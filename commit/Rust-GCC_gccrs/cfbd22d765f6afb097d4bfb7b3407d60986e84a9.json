{"sha": "cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZiZDIyZDc2NWY2YWZiMDk3ZDRiZmI3YjM0MDdkNjA5ODZlODRhOQ==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-06-24T21:12:18Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-06-24T21:12:18Z"}, "message": "Adopt splay trees for object database.\n\n2004-06-24  Frank Ch. Eigler  <fche@redhat.com>\n\n\tAdopt splay trees for object database.\n\t* Makefile.am: Copy splay-tree.* from libiberty.\n\t* Makefile.in, testsuite/Makefile.in: Regenerated.\n\t* mf-runtime.h.in (__mf_unregister): Add third parameter (type).\n\t* mf-hooks[123].c (*): Add new third parameter to mf_unregister.\n\t* mf-impl.h (BEGIN_PROTECT): Remove some trace text.\n\t* mf-runtime.c: Rewrite code dealing with object database to use\n\tlibiberty splay trees.  Remove tree liveness aging option.\n\t* testsuite/libmudflap.c/fail18-frag.c: Add volatile flag.\n\nFrom-SVN: r83611", "tree": {"sha": "b11f74e9117eab25751541c23cf9a481cd239e29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b11f74e9117eab25751541c23cf9a481cd239e29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "79066482014cb25e9743b44622fb304b6633b24b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79066482014cb25e9743b44622fb304b6633b24b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79066482014cb25e9743b44622fb304b6633b24b"}], "stats": {"total": 2027, "additions": 892, "deletions": 1135}, "files": [{"sha": "4f3beed4787cdb7aac96e34e1e2999d811818087", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -1,3 +1,15 @@\n+2004-06-24  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\tAdopt splay trees for object database.\n+\t* Makefile.am: Copy splay-tree.* from libiberty.\n+\t* Makefile.in, testsuite/Makefile.in: Regenerated.\n+\t* mf-runtime.h.in (__mf_unregister): Add third parameter (type).\n+\t* mf-hooks[123].c (*): Add new third parameter to mf_unregister.\n+\t* mf-impl.h (BEGIN_PROTECT): Remove some trace text.\n+\t* mf-runtime.c: Rewrite code dealing with object database to use\n+\tlibiberty splay trees.  Remove tree liveness aging option.\n+\t* testsuite/libmudflap.c/fail18-frag.c: Add volatile flag.\n+\n 2004-06-15  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* configure.ac: New name of configure.in.  Update"}, {"sha": "639db4218d40a193163fbc35aa00fef6e0431d9b", "filename": "libmudflap/Makefile.am", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.am?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -20,18 +20,29 @@ endif\n toolexeclib_LTLIBRARIES = libmudflap.la $(libmudflapth)\n include_HEADERS = mf-runtime.h\n \n+# Copy this out of libiberty's source tree, so it can be built here via libtool\n+splay-tree.c:\n+\trm -f $@\n+\t$(LN_S) $(srcdir)/../libiberty/splay-tree.c $@\n+# Copy this so that top-level include/ does not have to be put into -I path\n+splay-tree.h:\n+\trm -f $@\n+\t$(LN_S) $(srcdir)/../include/splay-tree.h $@\n+\n libmudflap_la_SOURCES = \\\n \tmf-runtime.c \\\n \tmf-heuristics.c \\\n \tmf-hooks1.c \\\n \tmf-hooks2.c\n+mf-runtime.lo: mf-runtime.c splay-tree.c splay-tree.h\n libmudflap_la_LIBADD = \n libmudflap_la_DEPENDENCIES = $(libmudflap_la_LIBADD)\n \n clean-local:\n \trm -f pth/*.o pth/*.lo\n+\trm -f splay-tree.c splay-tree.h\n \n-pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h\n+pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h splay-tree.c splay-tree.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-runtime.c -o $@\n pth/mf-heuristics.lo: mf-heuristics.c mf-runtime.h mf-impl.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-heuristics.c -o $@"}, {"sha": "787007ac66b84b93056f980fd0be8cdd373f90f8", "filename": "libmudflap/Makefile.in", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.in?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -50,7 +50,7 @@ DIST_COMMON = $(am__configure_deps) $(include_HEADERS) \\\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \\\n-\t$(top_srcdir)/configure.in\n+\t$(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n@@ -818,10 +818,21 @@ uninstall-info: uninstall-info-recursive\n \tuninstall-info-am uninstall-toolexeclibLTLIBRARIES\n \n \n+# Copy this out of libiberty's source tree, so it can be built here via libtool\n+splay-tree.c:\n+\trm -f $@\n+\t$(LN_S) $(srcdir)/../libiberty/splay-tree.c $@\n+# Copy this so that top-level include/ does not have to be put into -I path\n+splay-tree.h:\n+\trm -f $@\n+\t$(LN_S) $(srcdir)/../include/splay-tree.h $@\n+mf-runtime.lo: mf-runtime.c splay-tree.c splay-tree.h\n+\n clean-local:\n \trm -f pth/*.o pth/*.lo\n+\trm -f splay-tree.c splay-tree.h\n \n-pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h\n+pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h splay-tree.c splay-tree.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-runtime.c -o $@\n pth/mf-heuristics.lo: mf-heuristics.c mf-runtime.h mf-impl.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-heuristics.c -o $@"}, {"sha": "ba6bc959dd6f34b6f0fdd50654d81389b3357573", "filename": "libmudflap/mf-hooks1.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-hooks1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-hooks1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks1.c?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -199,7 +199,8 @@ WRAPPER(void *, realloc, void *buf, size_t c)\n   __mf_opts.wipe_heap = 0;\n \n   if (LIKELY(buf))\n-    __mfu_unregister (buf, 0);\n+    __mfu_unregister (buf, 0, __MF_TYPE_HEAP_I); \n+  /* NB: underlying region may have been __MF_TYPE_HEAP. */\n   \n   if (LIKELY(result))\n     {\n@@ -250,7 +251,8 @@ WRAPPER(void, free, void *buf)\n     }\n   UNLOCKTH ();\n \n-  __mf_unregister (buf, 0);\n+  __mf_unregister (buf, 0, __MF_TYPE_HEAP_I);\n+  /* NB: underlying region may have been __MF_TYPE_HEAP. */\n \n   if (UNLIKELY(__mf_opts.free_queue_length > 0))\n     {\n@@ -378,7 +380,7 @@ WRAPPER(int , munmap, void *start, size_t length)\n       uintptr_t offset;\n \n       for (offset=0; offset<length; offset+=ps)\n-\t__mf_unregister ((void *) CLAMPADD (base, offset), ps);\n+\t__mf_unregister ((void *) CLAMPADD (base, offset), ps, __MF_TYPE_HEAP_I);\n     }\n   return result;\n }\n@@ -419,7 +421,7 @@ __mf_wrap_alloca_indirect (size_t c)\n \t ((uintptr_t) alloca_history->stack DEEPER_THAN (uintptr_t) stack))\n     {\n       struct alloca_tracking *next = alloca_history->next;\n-      __mf_unregister (alloca_history->ptr, 0);\n+      __mf_unregister (alloca_history->ptr, 0, __MF_TYPE_HEAP);\n       CALL_REAL (free, alloca_history->ptr);\n       CALL_REAL (free, alloca_history);\n       alloca_history = next;"}, {"sha": "d2a5f3130f459290f1e71cfe75423fbd1d241f31", "filename": "libmudflap/mf-hooks2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-hooks2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-hooks2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks2.c?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -624,7 +624,7 @@ WRAPPER2(int, fclose, FILE *stream)\n     \"fclose stream\");\n   resp = fclose (stream);\n #ifdef MF_REGISTER_fopen\n-  __mf_unregister (stream, sizeof (*stream));\n+  __mf_unregister (stream, sizeof (*stream), MF_REGISTER_fopen);\n #endif\n \n   return resp;\n@@ -1101,7 +1101,7 @@ WRAPPER2(int, closedir, DIR *dir)\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n   MF_VALIDATE_EXTENT (dir, 0, __MF_CHECK_WRITE, \"closedir dir\");\n #ifdef MF_REGISTER_opendir\n-  __mf_unregister (dir, MF_RESULT_SIZE_opendir);\n+  __mf_unregister (dir, MF_RESULT_SIZE_opendir, MF_REGISTER_opendir);\n #endif\n   return closedir (dir);\n }\n@@ -1381,7 +1381,7 @@ WRAPPER2(int, pclose, FILE *stream)\n     \"pclose stream\");\n   resp = pclose (stream);\n #ifdef MF_REGISTER_fopen\n-  __mf_unregister (stream, sizeof (*stream));\n+  __mf_unregister (stream, sizeof (*stream), MF_REGISTER_fopen);\n #endif\n   return resp;\n }\n@@ -1499,7 +1499,7 @@ WRAPPER2(int, dlclose, void *handle)\n   MF_VALIDATE_EXTENT (handle, 0, __MF_CHECK_READ, \"dlclose handle\");\n   resp = dlclose (handle);\n #ifdef MF_REGISTER_dlopen\n-  __mf_unregister (handle, 0);\n+  __mf_unregister (handle, 0, MF_REGISTER_dlopen);\n #endif\n   return resp;\n }\n@@ -1637,7 +1637,7 @@ WRAPPER2(int, shmdt, const void *shmaddr)\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n   resp = shmdt (shmaddr);\n #ifdef MF_REGISTER_shmat\n-  __mf_unregister ((void *)shmaddr, 0);\n+  __mf_unregister ((void *)shmaddr, 0, MF_REGISTER_shmat);\n #endif\n   return resp;\n }"}, {"sha": "00fb3728e3687575b1b3e1946560e68d2af5bb38", "filename": "libmudflap/mf-hooks3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-hooks3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-hooks3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks3.c?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -273,7 +273,7 @@ __mf_pthread_cleanup (void *arg)\n   /* XXX: This unregistration is not safe on platforms where distinct\n      threads share errno (or at least its virtual address).  */\n   if (pi->thread_errno != NULL)\n-    __mf_unregister (pi->thread_errno, sizeof (int));\n+    __mf_unregister (pi->thread_errno, sizeof (int), __MF_TYPE_GUESS);\n \n   /* XXX: Only detached threads should designate themselves as dead\n      here.  Non-detached threads are marked dead after their"}, {"sha": "ef962bfaf01a88182fdf3ff2cdbcbd14decbb64f", "filename": "libmudflap/mf-impl.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-impl.h?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -365,10 +365,6 @@ ret __mfwrap_ ## fname (__VA_ARGS__)\n   else if (UNLIKELY (__mf_state == reentrant))   \\\n   {                                         \\\n     extern unsigned long __mf_reentrancy;   \\\n-    if (UNLIKELY (__mf_opts.verbose_trace)) { \\\n-      write (2, \"mf: reentrancy detected in `\", 28); \\\n-      write (2, __PRETTY_FUNCTION__, strlen(__PRETTY_FUNCTION__)); \\\n-      write (2, \"'\\n\", 2); } \\\n     __mf_reentrancy ++; \\\n     return CALL_REAL(fname, __VA_ARGS__);   \\\n   }                                         \\\n@@ -381,7 +377,7 @@ ret __mfwrap_ ## fname (__VA_ARGS__)\n /* Unlocked variants of main entry points from mf-runtime.h.  */\n extern void __mfu_check (void *ptr, size_t sz, int type, const char *location);\n extern void __mfu_register (void *ptr, size_t sz, int type, const char *name);\n-extern void __mfu_unregister (void *ptr, size_t sz);\n+extern void __mfu_unregister (void *ptr, size_t sz, int type);\n extern void __mfu_report ();\n extern int __mfu_set_options (const char *opts);\n "}, {"sha": "8b1cc749c9e43ef7615c38b5be61bf3e6224df0e", "filename": "libmudflap/mf-runtime.c", "status": "modified", "additions": 838, "deletions": 1114, "changes": 1952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -67,6 +67,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"mf-runtime.h\"\n #include \"mf-impl.h\"\n+#include \"splay-tree.h\"\n \n \n /* ------------------------------------------------------------------------ */\n@@ -145,7 +146,6 @@ const void *threads_active_p = (void *) pthread_join;\n \n static unsigned long __mf_count_check;\n static unsigned long __mf_lookup_cache_reusecount [LOOKUP_CACHE_SIZE_MAX];\n-static unsigned long __mf_treerot_left, __mf_treerot_right;\n static unsigned long __mf_count_register;\n static unsigned long __mf_total_register_size [__MF_TYPE_MAX+1];\n static unsigned long __mf_count_unregister;\n@@ -191,20 +191,12 @@ typedef struct __mf_object\n #endif\n } __mf_object_t;\n \n-\n-typedef struct __mf_object_tree\n-{\n-  __mf_object_t data;\n-  struct __mf_object_tree *left;\n-  struct __mf_object_tree *right;\n-} __mf_object_tree_t;\n-\n-/* Live objects: binary tree on __mf_object_t.low */\n-static __mf_object_tree_t *__mf_object_root;\n+/* Live objects: splay trees, separated by type, ordered on .low (base address).  */\n+/* Actually stored as static vars within lookup function below.  */\n \n /* Dead objects: circular arrays; _MIN_CEM .. _MAX_CEM only */\n static unsigned __mf_object_dead_head[__MF_TYPE_MAX_CEM+1]; /* next empty spot */\n-static __mf_object_tree_t *__mf_object_cemetary[__MF_TYPE_MAX_CEM+1][__MF_PERSIST_MAX];\n+static __mf_object_t *__mf_object_cemetary[__MF_TYPE_MAX_CEM+1][__MF_PERSIST_MAX];\n \n \n /* ------------------------------------------------------------------------ */\n@@ -213,16 +205,17 @@ static __mf_object_tree_t *__mf_object_cemetary[__MF_TYPE_MAX_CEM+1][__MF_PERSIS\n static void __mf_init () CTOR;\n static void __mf_sigusr1_respond ();\n static unsigned __mf_find_objects (uintptr_t ptr_low, uintptr_t ptr_high, \n-\t\t\t\t   __mf_object_tree_t **objs, unsigned max_objs);\n+                                   __mf_object_t **objs, unsigned max_objs);\n+static unsigned __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high, \n+                                    __mf_object_t **objs, unsigned max_objs, int type);\n static unsigned __mf_find_dead_objects (uintptr_t ptr_low, uintptr_t ptr_high, \n-\t\t\t\t\t__mf_object_tree_t **objs, unsigned max_objs);\n-static void __mf_link_object (__mf_object_tree_t *obj);\n-static void __mf_age_tree (__mf_object_tree_t *obj);\n+                                        __mf_object_t **objs, unsigned max_objs);\n static void __mf_adapt_cache ();\n-static void __mf_unlink_object (__mf_object_tree_t *obj);\n static void __mf_describe_object (__mf_object_t *obj);\n static unsigned __mf_watch_or_not (void *ptr, size_t sz, char flag);\n-\n+static splay_tree __mf_object_tree (int type);\n+static void __mf_link_object (__mf_object_t *node);\n+static void __mf_unlink_object (__mf_object_t *node);\n \n \n /* ------------------------------------------------------------------------ */\n@@ -233,7 +226,6 @@ __mf_set_default_options ()\n {\n   memset (& __mf_opts, 0, sizeof (__mf_opts));\n \n-  __mf_opts.tree_aging =    13037;\n   __mf_opts.adapt_cache = 1000003;\n   __mf_opts.abbreviate = 1;\n   __mf_opts.verbose_violations = 1;\n@@ -305,9 +297,6 @@ options [] =\n     {\"internal-checking\", \n      \"perform more expensive internal checking\",\n      set_option, 1, &__mf_opts.internal_checking},\n-    {\"age-tree\", \n-     \"age the object tree after N accesses for working set\",\n-     read_integer_option, 1000000, &__mf_opts.tree_aging},\n     {\"print-leaks\", \n      \"print any memory leaks at program shutdown\",\n      set_option, 1, &__mf_opts.print_leaks},\n@@ -375,52 +364,52 @@ __mf_usage ()\n   struct option *opt;\n \n   fprintf (stderr, \n-\t   \"This is a %s%sGCC \\\"mudflap\\\" memory-checked binary.\\n\"\n-\t   \"Mudflap is Copyright (C) 2002-2003 Free Software Foundation, Inc.\\n\"\n-\t   \"\\n\"\n-\t   \"The mudflap code can be controlled by an environment variable:\\n\"\n-\t   \"\\n\"\n-\t   \"$ export MUDFLAP_OPTIONS='<options>'\\n\"\n-\t   \"$ <mudflapped_program>\\n\"\n-\t   \"\\n\"\n-\t   \"where <options> is a space-separated list of \\n\"\n-\t   \"any of the following options.  Use `-no-OPTION' to disable options.\\n\"\n-\t   \"\\n\",\n+           \"This is a %s%sGCC \\\"mudflap\\\" memory-checked binary.\\n\"\n+           \"Mudflap is Copyright (C) 2002-2003 Free Software Foundation, Inc.\\n\"\n+           \"\\n\"\n+           \"The mudflap code can be controlled by an environment variable:\\n\"\n+           \"\\n\"\n+           \"$ export MUDFLAP_OPTIONS='<options>'\\n\"\n+           \"$ <mudflapped_program>\\n\"\n+           \"\\n\"\n+           \"where <options> is a space-separated list of \\n\"\n+           \"any of the following options.  Use `-no-OPTION' to disable options.\\n\"\n+           \"\\n\",\n #if HAVE_PTHREAD_H\n-\t   (threads_active_p ? \"multi-threaded \" : \"single-threaded \"),\n+           (threads_active_p ? \"multi-threaded \" : \"single-threaded \"),\n #else\n-\t   \"\",\n+           \"\",\n #endif\n #if LIBMUDFLAPTH\n-\t   \"thread-aware \"\n+           \"thread-aware \"\n #else\n-\t   \"thread-unaware \"\n+           \"thread-unaware \"\n #endif\n-\t    );\n+            );\n   /* XXX: The multi-threaded thread-unaware combination is bad.  */\n \n   for (opt = options; opt->name; opt++)\n     {\n       int default_p = (opt->value == * opt->target);\n \n       switch (opt->type)\n-\t{\n-\t  char buf[128];\n-\tcase set_option:\n-\t  fprintf (stderr, \"-%-23.23s %s\", opt->name, opt->description);\n-\t  if (default_p)\n-\t    fprintf (stderr, \" [active]\\n\");\n-\t  else\n-\t    fprintf (stderr, \"\\n\");\n-\t  break;\n-\tcase read_integer_option:\n-\t  strncpy (buf, opt->name, 128);\n-\t  strncpy (buf + strlen (opt->name), \"=N\", 2);\n-\t  fprintf (stderr, \"-%-23.23s %s\", buf, opt->description);\n-\t  fprintf (stderr, \" [%d]\\n\", * opt->target);\n-\t  break;\t  \n-\tdefault: abort();\n-\t}\n+        {\n+          char buf[128];\n+        case set_option:\n+          fprintf (stderr, \"-%-23.23s %s\", opt->name, opt->description);\n+          if (default_p)\n+            fprintf (stderr, \" [active]\\n\");\n+          else\n+            fprintf (stderr, \"\\n\");\n+          break;\n+        case read_integer_option:\n+          strncpy (buf, opt->name, 128);\n+          strncpy (buf + strlen (opt->name), \"=N\", 2);\n+          fprintf (stderr, \"-%-23.23s %s\", buf, opt->description);\n+          fprintf (stderr, \" [%d]\\n\", * opt->target);\n+          break;          \n+        default: abort();\n+        }\n     }\n \n   fprintf (stderr, \"\\n\");\n@@ -460,69 +449,69 @@ __mfu_set_options (const char *optstr)\n       case ' ':\n       case '\\t':\n       case '\\n':\n-\toptstr++;\n-\tbreak;\n+        optstr++;\n+        break;\n \n       case '-':\n-\tif (*optstr+1)\n-\t  {\t    \n-\t    int negate = 0;\n-\t    optstr++;\n-\n-\t    if (*optstr == '?' || \n-\t\tstrncmp (optstr, \"help\", 4) == 0)\n-\t      {\n-\t\t/* Caller will print help and exit.  */\n-\t\treturn -1;\n-\t      }\n-\t    \n-\t    if (strncmp (optstr, \"no-\", 3) == 0)\n-\t      {\n-\t\tnegate = 1;\n-\t\toptstr = & optstr[3];\n-\t      }\n-\t    \n-\t    for (opts = options; opts->name; opts++)\n-\t      {\n-\t\tif (strncmp (optstr, opts->name, strlen (opts->name)) == 0)\n-\t\t  {\n-\t\t    optstr += strlen (opts->name);\n-\t\t    assert (opts->target);\n-\t\t    switch (opts->type) \n-\t\t      {\n-\t\t      case set_option:\n-\t\t\tif (negate)\n-\t\t\t  *(opts->target) = 0;\n-\t\t\telse\n-\t\t\t  *(opts->target) = opts->value;\n-\t\t\tbreak;\n-\t\t      case read_integer_option:\n-\t\t\tif (! negate && (*optstr == '=' && *(optstr+1)))\n-\t\t\t  {\n-\t\t\t    optstr++;\n-\t\t\t    tmp = strtol (optstr, &nxt, 10);\n-\t\t\t    if ((optstr != nxt) && (tmp != LONG_MAX))\n-\t\t\t      {\n-\t\t\t\toptstr = nxt;\t\t\t\t\n-\t\t\t\t*(opts->target) = (int)tmp;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\telse if (negate)\n-\t\t\t  * opts->target = 0;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-\tbreak;\n-\t\n+        if (*optstr+1)\n+          {         \n+            int negate = 0;\n+            optstr++;\n+\n+            if (*optstr == '?' || \n+                strncmp (optstr, \"help\", 4) == 0)\n+              {\n+                /* Caller will print help and exit.  */\n+                return -1;\n+              }\n+            \n+            if (strncmp (optstr, \"no-\", 3) == 0)\n+              {\n+                negate = 1;\n+                optstr = & optstr[3];\n+              }\n+            \n+            for (opts = options; opts->name; opts++)\n+              {\n+                if (strncmp (optstr, opts->name, strlen (opts->name)) == 0)\n+                  {\n+                    optstr += strlen (opts->name);\n+                    assert (opts->target);\n+                    switch (opts->type) \n+                      {\n+                      case set_option:\n+                        if (negate)\n+                          *(opts->target) = 0;\n+                        else\n+                          *(opts->target) = opts->value;\n+                        break;\n+                      case read_integer_option:\n+                        if (! negate && (*optstr == '=' && *(optstr+1)))\n+                          {\n+                            optstr++;\n+                            tmp = strtol (optstr, &nxt, 10);\n+                            if ((optstr != nxt) && (tmp != LONG_MAX))\n+                              {\n+                                optstr = nxt;                           \n+                                *(opts->target) = (int)tmp;\n+                              }\n+                          }\n+                        else if (negate)\n+                          * opts->target = 0;\n+                        break;\n+                      }\n+                  }\n+              }\n+          }\n+        break;\n+        \n       default:\n-\tfprintf (stderr, \n-\t\t \"warning: unrecognized string '%s' in mudflap options\\n\",\n-\t\t optstr);\n-\toptstr += strlen (optstr);\n-\trc = -1;\n-\tbreak;\n+        fprintf (stderr, \n+                 \"warning: unrecognized string '%s' in mudflap options\\n\",\n+                 optstr);\n+        optstr += strlen (optstr);\n+        rc = -1;\n+        break;\n       }\n     }\n \n@@ -567,7 +556,7 @@ __mf_resolve_single_dynamic (struct __mf_dynamic_entry *e)\n   if (err)\n     {\n       fprintf (stderr, \"mf: error in dlsym(\\\"%s\\\"): %s\\n\",\n-\t       e->name, err);\n+               e->name, err);\n       abort ();\n     }  \n   if (! e->pointer)\n@@ -610,8 +599,20 @@ struct __mf_dynamic_entry __mf_dynamic [] =\n \n /* ------------------------------------------------------------------------ */\n \n+/* Lookup & manage automatic initialization of the five or so splay trees.  */\n+static splay_tree\n+__mf_object_tree (int type)\n+{\n+  static splay_tree trees [__MF_TYPE_MAX+1];\n+  assert (type >= 0 && type <= __MF_TYPE_MAX);\n+  if (UNLIKELY (trees[type] == NULL))\n+    trees[type] = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+  return trees[type];\n+}\n \n-void __mf_init ()\n+\n+void\n+__mf_init ()\n {\n   char *ov = 0;\n \n@@ -628,10 +629,10 @@ void __mf_init ()\n     {\n       int rc = __mfu_set_options (ov);\n       if (rc < 0)\n-\t{\n-\t  __mf_usage ();\n-\t  exit (1);\n-\t}\n+        {\n+          __mf_usage ();\n+          exit (1);\n+        }\n     }\n \n   /* Initialize to a non-zero description epoch. */\n@@ -666,19 +667,19 @@ __wrap_main (int argc, char* argv[])\n       been_here = 1;\n       __mf_register (argv, sizeof(char *)*(argc+1), __MF_TYPE_STATIC, \"argv[]\");\n       for (i=0; i<argc; i++)\n-\t{\n-\t  unsigned j = strlen (argv[i]);\n-\t  __mf_register (argv[i], j+1, __MF_TYPE_STATIC, \"argv element\");\n-\t}\n+        {\n+          unsigned j = strlen (argv[i]);\n+          __mf_register (argv[i], j+1, __MF_TYPE_STATIC, \"argv element\");\n+        }\n \n       for (i=0; ; i++)\n-\t{\n-\t  char *e = environ[i];\n-\t  unsigned j;\n-\t  if (e == NULL) break;\n-\t  j = strlen (environ[i]);\n-\t  __mf_register (environ[i], j+1, __MF_TYPE_STATIC, \"environ element\");\n-\t}\n+        {\n+          char *e = environ[i];\n+          unsigned j;\n+          if (e == NULL) break;\n+          j = strlen (environ[i]);\n+          __mf_register (environ[i], j+1, __MF_TYPE_STATIC, \"environ element\");\n+        }\n       __mf_register (environ, sizeof(char *)*(i+1), __MF_TYPE_STATIC, \"environ[]\");\n \n       __mf_register (& errno, sizeof (errno), __MF_TYPE_STATIC, \"errno area\");\n@@ -737,8 +738,8 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n     __mf_sigusr1_respond ();\n \n   TRACE (\"check ptr=%p b=%u size=%lu %s location=`%s'\\n\",\n-\t ptr, entry_idx, (unsigned long)sz,\n-\t (type == 0 ? \"read\" : \"write\"), location);\n+         ptr, entry_idx, (unsigned long)sz,\n+         (type == 0 ? \"read\" : \"write\"), location);\n   \n   switch (__mf_opts.mudflap_mode)\n     {\n@@ -756,192 +757,117 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n \n     case mode_check:\n       {\n-\tunsigned heuristics = 0;\n-\n-\t/* Advance aging/adaptation counters.  */\n-\tif (__mf_object_root)\n-\t  {\n-\t    static unsigned aging_count;\n-\t    static unsigned adapt_count;\n-\t    aging_count ++;\n-\t    adapt_count ++;\n-\t    if (UNLIKELY (__mf_opts.tree_aging > 0 &&\n-\t\t\t  aging_count > __mf_opts.tree_aging))\n-\t      {\n-\t\taging_count = 0;\n-\t\t__mf_age_tree (__mf_object_root);\n-\t      }\n-\t    if (UNLIKELY (__mf_opts.adapt_cache > 0 &&\n-\t\t\t  adapt_count > __mf_opts.adapt_cache))\n-\t      {\n-\t\tadapt_count = 0;\n-\t\t__mf_adapt_cache ();\n-\t      }\n-\t  }\n-\n-\t/* Looping only occurs if heuristics were triggered.  */\n-\twhile (judgement == 0)\n-\t  {\n-\t    __mf_object_tree_t* ovr_obj[1];\n-\t    unsigned obj_count;\n-\n-\t    obj_count = __mf_find_objects (ptr_low, ptr_high, ovr_obj, 1);\n-\n-\t    if (LIKELY (obj_count == 1)) /* A single hit! */\n-\t      {\n-\t\t__mf_object_t *obj = & ovr_obj[0]->data;\n-\t\tassert (obj != NULL);\n-\t\tif (LIKELY (ptr_low >= obj->low && ptr_high <= obj->high))\n-\t\t  {\n-\t\t    /* XXX: hope for no overflow!  */\n-\t\t    if (type == __MF_CHECK_READ)\n-\t\t      obj->read_count ++;\n-\t\t    else\n-\t\t      obj->write_count ++;\n-\n-\t\t    obj->liveness ++;\n-\t\t    \n-\t\t    if (UNLIKELY (obj->type == __MF_TYPE_NOACCESS))\n-\t\t      judgement = -1;\n-\t\t    else if (UNLIKELY (obj->watching_p))\n-\t\t      judgement = -2; /* trigger VIOL_WATCH */\n-\t\t    else if (UNLIKELY (__mf_opts.check_initialization\n-\t\t\t\t       /* reading */\n-\t\t\t\t       && type == __MF_CHECK_READ\n-\t\t\t\t       /* not written */\n-\t\t\t\t       && obj->write_count == 0\n-\t\t\t\t       /* uninitialized (heap) */\n-\t\t\t\t       && obj->type == __MF_TYPE_HEAP))\n-\t\t      judgement = -1;\n-\t\t    else\n-\t\t      {\n-\t\t\t/* Valid access.  */\n-\t\t\tentry->low = obj->low;\n-\t\t\tentry->high = obj->high;\n-\t\t\tjudgement = 1;\n-\t\t      }\n-\t\t  }\n-\t\t/* The object did not cover the entire accessed region.  */\n-\t      }\n-\t    else if (LIKELY (obj_count > 1))\n-\t      {\n-\t\t__mf_object_tree_t **all_ovr_objs;\n-\t\tunsigned n;\n-\t\tDECLARE (void *, malloc, size_t c);\n-\t\tDECLARE (void, free, void *p);\n-\n-\t\tall_ovr_objs = CALL_REAL (malloc, (sizeof (__mf_object_tree_t *) *\n-\t\t\t\t\t\t   obj_count));\n-\t\tif (all_ovr_objs == NULL) abort ();\n-\t\tn = __mf_find_objects (ptr_low, ptr_high, all_ovr_objs, obj_count);\n-\t\tassert (n == obj_count);\n-\n-\t\t/* Confirm that accessed range is covered by first/last object. */\n-\t\tif (LIKELY ((ptr_low >= all_ovr_objs[0]->data.low) &&\n-\t\t\t    (ptr_high <= all_ovr_objs[obj_count-1]->data.high)))\n-\t\t  {\n-\t\t    /* Presume valid access.  */\n-\t\t    judgement = 1;\n-\n-\t\t    /* Confirm that intermediate objects are\n-\t\t       contiguous and share a single name.  Thus they\n-\t\t       are likely split up GUESS regions, or mmap\n-\t\t       pages.  The idea of the name check is to\n-\t\t       prevent an oversize access to a\n-\t\t       stack-registered object (followed by some GUESS\n-\t\t       type) from being accepted as a hit.  */\n-\t\t    for (n=0; n<obj_count-1; n++)\n-\t\t      {\n-\t\t\t__mf_object_t *obj = & (all_ovr_objs[n]->data);\n-\t\t\t__mf_object_t *nextobj = & (all_ovr_objs[n+1]->data);\n-\t\t\t\n-\t\t\tif (UNLIKELY (obj->type == __MF_TYPE_NOACCESS))\n-\t\t\t  judgement = -1; /* Force error. */\n-\t\t\t\n-\t\t\tif (UNLIKELY (judgement == 1 &&\n-\t\t\t\t      (obj->high + 1 != nextobj->low)))\n-\t\t\t  judgement = 0; /* Cancel presumption. */\n-\t\t\t\n-\t\t\tif (UNLIKELY (judgement == 1 &&\n-\t\t\t\t      (obj->name != nextobj->name)))\n-\t\t\t  judgement = 0; /* Cancel presumption. */\n-\t\t\t/* NB: strcmp above is not necessary since the\n-\t\t\t   same literal string pointer is normally\n-\t\t\t   used when creating regions.  */\n-\n-\t\t\t/* XXX: hope for no overflow!  */\n-\t\t\tif (type == __MF_CHECK_READ)\n-\t\t\t  obj->read_count ++;\n-\t\t\telse\n-\t\t\t  obj->write_count ++;\n-\t\t\tobj->liveness ++;\n-\t\t      }\n-\n-\t\t    /* If the access is otherwise successful, check whether\n-\t\t       any of the covered objects are being watched.  */\n-\t\t    if (judgement > 0)\n-\t\t      {\n-\t\t\tunsigned i;\n-\t\t\tfor (i=0; i<obj_count; i++)\n-\t\t\t  if (all_ovr_objs[i]->data.watching_p)\n-\t\t\t    judgement = -2;  /* trigger VIOL_WATCH */\n-\t\t      }\n-\n-\t\t    /* Check for uninitialized reads.  */\n-\t\t    if (judgement > 0 &&\n-\t\t\t__mf_opts.check_initialization &&\n-\t\t\ttype == __MF_CHECK_READ)\n-\t\t      {\n-\t\t\tunsigned i;\n-\t\t\tunsigned written_count = 0;\n-\n-\t\t\tfor (i=0; i<obj_count; i++)\n-\t\t\t  {\n-\t\t\t    __mf_object_t *obj = & all_ovr_objs[i]->data;\n-\n-\t\t\t    if (obj->write_count\n-\t\t\t\t|| obj->type == __MF_TYPE_HEAP_I\n-\t\t\t\t|| obj->type == __MF_TYPE_GUESS)\n-\t\t\t      written_count ++;\n-\t\t\t  }\n-\t\t\t\n-\t\t\t/* Check for ALL pieces having been written-to.\n-\t\t\t   XXX: should this be ANY instead?  */\n-\t\t\tif (written_count != obj_count)\n-\t\t\t  judgement = -1;\n-\t\t      }\n-\n-\t\t    /* Fill out the cache with the bounds of the first\n-\t\t       object and the last object that covers this\n-\t\t       cache line (== includes the same __MF_CACHE_INDEX).\n-\t\t       This could let this cache line span *two* distinct\n-\t\t       registered objects: a peculiar but reasonable\n-\t\t       situation.  The cache line may not include the\n-\t\t       entire object though.  */\n-\t\t    if (judgement > 0)\n-\t\t      {\n-\t\t\tunsigned i;\n-\t\t\tentry->low = all_ovr_objs[0]->data.low;\n-\t\t\tfor (i=0; i<obj_count; i++)\n-\t\t\t  {\n-\t\t\t    uintptr_t high = all_ovr_objs[i]->data.high;\n-\t\t\t    if (__MF_CACHE_INDEX (high) == entry_idx)\n-\t\t\t      entry->high = high;\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\n-\t\tCALL_REAL (free, all_ovr_objs);\n-\t      }\n-\n-\t    if (judgement == 0)\n-\t      {\n-\t\tif (heuristics++ < 2) /* XXX parametrize this number? */\n-\t\t  judgement = __mf_heuristic_check (ptr_low, ptr_high);\n-\t\telse\n-\t\t  judgement = -1;\n-\t      }\n-\t  }\n+        unsigned heuristics = 0;\n+        \n+        /* Advance aging/adaptation counters.  */\n+        static unsigned adapt_count;\n+        adapt_count ++;\n+        if (UNLIKELY (__mf_opts.adapt_cache > 0 &&\n+                      adapt_count > __mf_opts.adapt_cache))\n+          {\n+            adapt_count = 0;\n+            __mf_adapt_cache ();\n+          }\n+        \n+        /* Looping only occurs if heuristics were triggered.  */\n+        while (judgement == 0)\n+          {\n+            DECLARE (void, free, void *p);\n+            __mf_object_t* ovr_obj[1];\n+            unsigned obj_count;\n+            __mf_object_t** all_ovr_obj = NULL;\n+            __mf_object_t** dealloc_me = NULL;\n+            unsigned i;\n+\n+            /* Find all overlapping objects.  Be optimistic that there is just one.  */\n+            obj_count = __mf_find_objects (ptr_low, ptr_high, ovr_obj, 1);\n+            if (UNLIKELY (obj_count > 1))\n+              {\n+                /* Allocate a real buffer and do the search again.  */\n+                DECLARE (void *, malloc, size_t c);\n+                unsigned n;\n+                all_ovr_obj = CALL_REAL (malloc, (sizeof (__mf_object_t *) *\n+                                                   obj_count));\n+                if (all_ovr_obj == NULL) abort ();\n+                n = __mf_find_objects (ptr_low, ptr_high, all_ovr_obj, obj_count);\n+                assert (n == obj_count);\n+                dealloc_me = all_ovr_obj;\n+              }\n+            else \n+              {\n+                all_ovr_obj = ovr_obj;\n+                dealloc_me = NULL;\n+              }\n+\n+            /* Update object statistics.  */\n+            for (i = 0; i < obj_count; i++)\n+              {\n+                __mf_object_t *obj = all_ovr_obj[i];\n+                assert (obj != NULL);\n+                if (type == __MF_CHECK_READ)\n+                  obj->read_count ++;\n+                else\n+                  obj->write_count ++;\n+                obj->liveness ++;\n+              }\n+            \n+            /* Iterate over the various objects.  There are a number of special cases.  */\n+            for (i = 0; i < obj_count; i++)\n+              {\n+                  __mf_object_t *obj = all_ovr_obj[i];\n+\n+                /* Any __MF_TYPE_NOACCESS hit is bad.  */\n+                if (UNLIKELY (obj->type == __MF_TYPE_NOACCESS))\n+                  judgement = -1;\n+\n+                /* Any object with a watch flag is bad.  */\n+                if (UNLIKELY (obj->watching_p))\n+                  judgement = -2; /* trigger VIOL_WATCH */\n+            \n+                /* A read from an uninitialized object is bad. */\n+                if (UNLIKELY (__mf_opts.check_initialization\n+                              /* reading */\n+                              && type == __MF_CHECK_READ\n+                              /* not written */\n+                              && obj->write_count == 0\n+                              /* uninitialized (heap) */\n+                              && obj->type == __MF_TYPE_HEAP))\n+                  judgement = -1;\n+              }\n+\n+            /* We now know that the access spans one or more valid objects.  */\n+            if (LIKELY (judgement >= 0))\n+              for (i = 0; i < obj_count; i++)\n+                {\n+                  __mf_object_t *obj = all_ovr_obj[i];\n+                  \n+                  /* Is this access entirely contained within this object?  */\n+                  if (LIKELY (ptr_low >= obj->low && ptr_high <= obj->high))\n+                    {\n+                      /* Valid access.  */\n+                      entry->low = obj->low;\n+                      entry->high = obj->high;\n+                      judgement = 1;\n+                    }\n+\n+                  /* XXX: Access runs off left or right side of this\n+                          object.  That could be okay, if there are\n+                          other objects that fill in all the holes. */\n+                }\n+\n+            if (dealloc_me != NULL)\n+              CALL_REAL (free, dealloc_me);\n+\n+            /* If the judgment is still unknown at this stage, loop\n+               around at most one more time.  */\n+            if (judgement == 0)\n+              {\n+                if (heuristics++ < 2) /* XXX parametrize this number? */\n+                  judgement = __mf_heuristic_check (ptr_low, ptr_high);\n+                else\n+                  judgement = -1;\n+              }\n+          }\n \n       }\n       break;\n@@ -956,43 +882,43 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n       __mf_count_check ++;\n       \n       if (LIKELY (old_entry.low != entry->low || old_entry.high != entry->high))\n-\t/* && (old_entry.low != 0) && (old_entry.high != 0)) */\n-\t__mf_lookup_cache_reusecount [entry_idx] ++;    \n+        /* && (old_entry.low != 0) && (old_entry.high != 0)) */\n+        __mf_lookup_cache_reusecount [entry_idx] ++;    \n     }\n   \n   if (UNLIKELY (judgement < 0))\n     __mf_violation (ptr, sz,\n-\t\t    (uintptr_t) __builtin_return_address (0), location,\n-\t\t    ((judgement == -1) ? \n-\t\t     (type == __MF_CHECK_READ ? __MF_VIOL_READ : __MF_VIOL_WRITE) :\n-\t\t     __MF_VIOL_WATCH));\n+                    (uintptr_t) __builtin_return_address (0), location,\n+                    ((judgement == -1) ? \n+                     (type == __MF_CHECK_READ ? __MF_VIOL_READ : __MF_VIOL_WRITE) :\n+                     __MF_VIOL_WATCH));\n }\n \n \n-static __mf_object_tree_t *\n+static __mf_object_t *\n __mf_insert_new_object (uintptr_t low, uintptr_t high, int type, \n-\t\t\tconst char *name, uintptr_t pc)\n+                        const char *name, uintptr_t pc)\n {\n   DECLARE (void *, calloc, size_t c, size_t n);\n \n-  __mf_object_tree_t *new_obj;\n-  new_obj = CALL_REAL (calloc, 1, sizeof(__mf_object_tree_t));\n-  new_obj->data.low = low;\n-  new_obj->data.high = high;\n-  new_obj->data.type = type;\n-  new_obj->data.name = name;\n-  new_obj->data.alloc_pc = pc;\n+  __mf_object_t *new_obj;\n+  new_obj = CALL_REAL (calloc, 1, sizeof(__mf_object_t));\n+  new_obj->low = low;\n+  new_obj->high = high;\n+  new_obj->type = type;\n+  new_obj->name = name;\n+  new_obj->alloc_pc = pc;\n #if HAVE_GETTIMEOFDAY\n-  gettimeofday (& new_obj->data.alloc_time, NULL);\n+  gettimeofday (& new_obj->alloc_time, NULL);\n #endif\n #if LIBMUDFLAPTH\n-  new_obj->data.alloc_thread = pthread_self ();\n+  new_obj->alloc_thread = pthread_self ();\n #endif\n \n   if (__mf_opts.backtrace > 0 && (type == __MF_TYPE_HEAP || type == __MF_TYPE_HEAP_I))\n-    new_obj->data.alloc_backtrace_size = \n-      __mf_backtrace (& new_obj->data.alloc_backtrace,\n-\t\t      (void *) pc, 2);\n+    new_obj->alloc_backtrace_size = \n+      __mf_backtrace (& new_obj->alloc_backtrace,\n+                      (void *) pc, 2);\n   \n   __mf_link_object (new_obj);\n   return new_obj;\n@@ -1013,18 +939,18 @@ __mf_uncache_object (__mf_object_t *old_obj)\n       unsigned idx_high = __MF_CACHE_INDEX (high);\n       unsigned i;\n       for (i = idx_low; i <= idx_high; i++)\n-\t{\n-\t  struct __mf_cache *entry = & __mf_lookup_cache [i];\n-\t  /* NB: the \"||\" in the following test permits this code to\n-\t     tolerate the situation introduced by __mf_check over\n-\t     contiguous objects, where a cache entry spans several \n-\t     objects.  */\n-\t  if (entry->low == low || entry->high == high)\n-\t    {\n-\t      entry->low = MAXPTR;\n-\t      entry->high = MINPTR;\n-\t    }\n-\t}\n+        {\n+          struct __mf_cache *entry = & __mf_lookup_cache [i];\n+          /* NB: the \"||\" in the following test permits this code to\n+             tolerate the situation introduced by __mf_check over\n+             contiguous objects, where a cache entry spans several \n+             objects.  */\n+          if (entry->low == low || entry->high == high)\n+            {\n+              entry->low = MAXPTR;\n+              entry->high = MINPTR;\n+            }\n+        }\n     }\n }\n \n@@ -1044,14 +970,14 @@ void\n __mfu_register (void *ptr, size_t sz, int type, const char *name)\n {\n   TRACE (\"register ptr=%p size=%lu type=%x name='%s'\\n\", \n-\t ptr, (unsigned long) sz, type, name ? name : \"\");\n+         ptr, (unsigned long) sz, type, name ? name : \"\");\n \n   if (__mf_opts.collect_stats)\n     {\n       __mf_count_register ++;\n       __mf_total_register_size [(type < 0) ? 0 :\n-\t\t\t\t(type > __MF_TYPE_MAX) ? 0 : \n-\t\t\t\ttype] += sz;\n+                                (type > __MF_TYPE_MAX) ? 0 : \n+                                type] += sz;\n     }\n \n   if (UNLIKELY (__mf_opts.sigusr1_report))\n@@ -1064,7 +990,7 @@ __mfu_register (void *ptr, size_t sz, int type, const char *name)\n       \n     case mode_violate:\n       __mf_violation (ptr, sz, (uintptr_t) __builtin_return_address (0), NULL,\n-\t\t      __MF_VIOL_REGISTER);\n+                      __MF_VIOL_REGISTER);\n       break;\n \n     case mode_populate:\n@@ -1078,172 +1004,79 @@ __mfu_register (void *ptr, size_t sz, int type, const char *name)\n \n     case mode_check:\n       {\n-\t__mf_object_tree_t *ovr_objs [1];\n-\tunsigned num_overlapping_objs;\n-\tuintptr_t low = (uintptr_t) ptr;\n-\tuintptr_t high = CLAMPSZ (ptr, sz);\n-\tuintptr_t pc = (uintptr_t) __builtin_return_address (0);\n-\t\n-\t/* Treat unknown size indication as 1.  */\n-\tif (UNLIKELY (sz == 0)) sz = 1;\n-\t\n-\tnum_overlapping_objs = __mf_find_objects (low, high, ovr_objs, 1);\n-\n-\t/* Handle overlaps.  */\n-\tif (UNLIKELY (num_overlapping_objs > 0))\n-\t  {\n-\t    __mf_object_tree_t *ovr_obj = ovr_objs[0];\n-\t    \n-\t    /* Quietly accept a single duplicate registration for\n-\t       static objects, since these may come from distinct\n-\t       compilation units.  */\n-\t    if (type == __MF_TYPE_STATIC\n-\t\t&& ovr_obj->data.type == __MF_TYPE_STATIC\n-\t\t&& ovr_obj->data.low == low\n-\t\t&& ovr_obj->data.high == high)\n-\t      {\n-\t\t/* do nothing */\n-\t\tVERBOSE_TRACE (\"duplicate static reg %p-%p `%s'\\n\", \n-\t\t\t       (void *) low, (void *) high, \n-\t\t\t       (ovr_obj->data.name ? ovr_obj->data.name : \"\"));\n-\t\tbreak;\n-\t      }\n-\n-\t    /* Quietly accept a single duplicate registration for\n-\t       guess objects too.  */\n-\t    if (type == __MF_TYPE_GUESS &&\n-\t\tovr_obj->data.type == __MF_TYPE_GUESS &&\n-\t\tovr_obj->data.low == low &&\n-\t\tovr_obj->data.high == high)\n-\t      {\n-\t\t/* do nothing */\n-\t\tVERBOSE_TRACE (\"duplicate guess reg %p-%p\\n\", \n-\t\t\t       (void *) low, (void *) high);\n-\t\tbreak;\n-\t      }\n-\n-\t    /* Quietly accept new a guess registration that overlaps\n-\t       at least one existing object.  Trim it down to size.  */\n-\t    else if (type == __MF_TYPE_GUESS)\n-\t      {\n-\t\t/* We need to split this new GUESS region into some\n-\t\t   smaller ones.  Or we may not need to insert it at\n-\t\t   all if it is covered by the overlapping region.  */\n-\n-\t\t/* First, identify all the overlapping objects.  */\n-\t\t__mf_object_tree_t **all_ovr_objs;\n-\t\tunsigned num_ovr_objs, n;\n-\t\tuintptr_t next_low;\n-\t\tDECLARE (void *, malloc, size_t c);\n-\t\tDECLARE (void, free, void *p);\n-\n-\t\tall_ovr_objs = CALL_REAL (malloc, (sizeof (__mf_object_tree_t *) *\n-\t\t\t\t\t\t   num_overlapping_objs));\n-\t\tif (all_ovr_objs == NULL) abort ();\n-\t\tnum_ovr_objs = __mf_find_objects (low, high, all_ovr_objs,\n-\t\t\t\t\t\t  num_overlapping_objs);\n-\t\tassert (num_ovr_objs == num_overlapping_objs);\n-\n-\t\tVERBOSE_TRACE (\"splitting guess %p-%p, # overlaps: %u\\n\",\n-\t\t\t       (void *) low, (void *) high, num_ovr_objs);\n-\n-\t\t/* Add GUESS regions between the holes: before each\n-\t\t   overlapping region.  */\n-\n-\t\tnext_low = low;\n-\t\t/* This makes use of the assumption that __mf_find_objects() returns\n-\t\t   overlapping objects in an increasing sequence.  */\n-\t\tfor (n=0; n < min (num_ovr_objs, num_overlapping_objs); n++)\n-\t\t  {\n-\t\t    if (all_ovr_objs[n]->data.low > next_low) /* Gap? */\n-\t\t      {\n-\t\t\tuintptr_t next_high = CLAMPSUB (all_ovr_objs[n]->data.low, 1);\n-\t\t\t__mfu_register ((void *) next_low, next_high-next_low+1,\n-\t\t\t\t\t__MF_TYPE_GUESS, name);\n-\t\t      }\n-\t\t    next_low = CLAMPADD (all_ovr_objs[n]->data.high, 1);\n-\t\t  }\n-\t\t/* Add in any leftover room at the top.  */\n-\t\tif (next_low <= high)\n-\t\t  __mfu_register ((void *) next_low, high-next_low+1,\n-\t\t\t\t  __MF_TYPE_GUESS, name);\n-\n-\t\t/* XXX: future optimization: allow consecutive GUESS regions to\n-\t\t   be glued together.  */\n-\t\tCALL_REAL (free, all_ovr_objs);\n-\t\treturn;\n-\t      }\n-\n-\t    /* Quietly accept a non-GUESS region overlaying a GUESS\n-\t       region.  Handle it by removing the GUESS region\n-\t       temporarily, then recursively adding this new object,\n-\t       and then the GUESS back.  The latter will be split up\n-\t       by the recursive process above.  */\n-\t    else if (ovr_obj->data.type == __MF_TYPE_GUESS)\n-\t      {\n-\t\tuintptr_t old_low = ovr_obj->data.low;\n-\t\tuintptr_t old_high = ovr_obj->data.high;\n-\t\tconst char* old_name = ovr_obj->data.name;\n-\n-\t\t/* Now to recursively remove the guess piece, and\n-  \t\t   reinsert them in the opposite order.  Recursion\n-  \t\t   should bottom out if another non-GUESS overlapping\n-  \t\t   region is found for this new object (resulting in a\n-  \t\t   violation), or if no further overlap occurs.  The\n-  \t\t   located GUESS region should end up being split up\n-  \t\t   in any case.  */\n-\t\t__mfu_unregister ((void *) old_low, old_high-old_low+1);\n-\t\t__mfu_register ((void *) low, sz, type, name);\n-\t\t__mfu_register ((void *) old_low, old_high-old_low+1,\n-\t\t\t\t__MF_TYPE_GUESS, old_name);\n-\t\treturn;\n-\t      }\n-\n-\t    /* Alas, a genuine violation.  */\n-\t    else\n-\t      {\n-\t\t/* Two or more *real* mappings here. */\n-\t\t__mf_violation ((void *) ptr, sz,\n-\t\t\t\t(uintptr_t) __builtin_return_address (0), NULL,\n-\t\t\t\t__MF_VIOL_REGISTER);\n-\t      }\n-\t  }\n-\t\n-\t/* No overlapping objects: AOK.  */\n-\telse\n-\t  {\n-\t    __mf_insert_new_object (low, high, type, name, pc);\n-\t  }\n-\t\n-\t/* We could conceivably call __mf_check() here to prime the cache,\n-\t   but then the read_count/write_count field is not reliable.  */\n-\t\n-\tbreak;\n+        __mf_object_t *ovr_objs [1];\n+        unsigned num_overlapping_objs;\n+        uintptr_t low = (uintptr_t) ptr;\n+        uintptr_t high = CLAMPSZ (ptr, sz);\n+        uintptr_t pc = (uintptr_t) __builtin_return_address (0);\n+        \n+        /* Treat unknown size indication as 1.  */\n+        if (UNLIKELY (sz == 0)) sz = 1;\n+\n+        /* Look for objects only of the same type.  This will e.g. permit a registration\n+           of a STATIC overlapping with a GUESS, and a HEAP with a NOACCESS.  At\n+           __mf_check time however harmful overlaps will be detected. */\n+        num_overlapping_objs = __mf_find_objects2 (low, high, ovr_objs, 1, type);\n+\n+        /* Handle overlaps.  */\n+        if (UNLIKELY (num_overlapping_objs > 0))\n+          {\n+            __mf_object_t *ovr_obj = ovr_objs[0];\n+            \n+            /* Accept certain specific duplication pairs.  */\n+            if (((type == __MF_TYPE_STATIC) || (type == __MF_TYPE_GUESS))\n+                && ovr_obj->low == low\n+                && ovr_obj->high == high\n+                && ovr_obj->type == type)\n+              {\n+                /* Duplicate registration for static objects may come\n+                   from distinct compilation units.  */\n+                VERBOSE_TRACE (\"harmless duplicate reg %p-%p `%s'\\n\", \n+                               (void *) low, (void *) high, \n+                               (ovr_obj->name ? ovr_obj->name : \"\"));\n+                break;\n+              }\n+\n+            /* Alas, a genuine violation.  */\n+            else\n+              {\n+                /* Two or more *real* mappings here. */\n+                __mf_violation ((void *) ptr, sz,\n+                                (uintptr_t) __builtin_return_address (0), NULL,\n+                                __MF_VIOL_REGISTER);\n+              }\n+          }\n+        else /* No overlapping objects: AOK.  */\n+          __mf_insert_new_object (low, high, type, name, pc);\n+        \n+        /* We could conceivably call __mf_check() here to prime the cache,\n+           but then the read_count/write_count field is not reliable.  */\n+        break;\n       }\n     } /* end switch (__mf_opts.mudflap_mode) */\n }\n \n \n void\n-__mf_unregister (void *ptr, size_t sz)\n+__mf_unregister (void *ptr, size_t sz, int type)\n {\n   LOCKTH ();\n   BEGIN_RECURSION_PROTECT ();\n-  __mfu_unregister (ptr, sz);\n+  __mfu_unregister (ptr, sz, type);\n   END_RECURSION_PROTECT ();\n   UNLOCKTH ();\n }\n \n \n void\n-__mfu_unregister (void *ptr, size_t sz)\n+__mfu_unregister (void *ptr, size_t sz, int type)\n {\n   DECLARE (void, free, void *ptr);\n \n   if (UNLIKELY (__mf_opts.sigusr1_report))\n-  __mf_sigusr1_respond ();\n+    __mf_sigusr1_respond ();\n \n-  TRACE (\"unregister ptr=%p size=%lu\\n\", ptr, (unsigned long) sz);\n+  TRACE (\"unregister ptr=%p size=%lu type=%x\\n\", ptr, (unsigned long) sz, type);\n \n   switch (__mf_opts.mudflap_mode)\n     { \n@@ -1252,8 +1085,8 @@ __mfu_unregister (void *ptr, size_t sz)\n \n     case mode_violate:\n       __mf_violation (ptr, sz,\n-\t\t      (uintptr_t) __builtin_return_address (0), NULL,\n-\t\t      __MF_VIOL_UNREGISTER);\n+                      (uintptr_t) __builtin_return_address (0), NULL,\n+                      __MF_VIOL_UNREGISTER);\n       break;\n \n     case mode_populate:\n@@ -1266,109 +1099,113 @@ __mfu_unregister (void *ptr, size_t sz)\n \n     case mode_check:\n       {\n-\t__mf_object_tree_t *old_obj = NULL;\n-\t__mf_object_tree_t *del_obj = NULL;  /* Object to actually delete. */\n-\t__mf_object_tree_t *objs[1] = {NULL};\n-\tunsigned num_overlapping_objs;\n-\t\t\n-\t/* Treat unknown size indication as 1.  */\n-\tif (sz == 0) sz = 1;\n-\t\n-\tnum_overlapping_objs = __mf_find_objects ((uintptr_t) ptr,\n-\t\t\t\t\t\t  CLAMPSZ (ptr, sz), objs, 1);\n-\n-\t/* XXX: handle unregistration of big old GUESS region, that has since\n-\t   been splintered.  */\n-\told_obj = objs[0];\n-\n-\tif (UNLIKELY (num_overlapping_objs != 1 ||\n-\t\t      (uintptr_t)ptr != old_obj->data.low)) /* XXX: what about sz? */\n-\t  {\n-\t    __mf_violation (ptr, sz,\n-\t\t\t    (uintptr_t) __builtin_return_address (0), NULL,\n-\t\t\t    __MF_VIOL_UNREGISTER);\n-\t    break;\n-\t  }\n-\n-\t__mf_unlink_object (old_obj);\n-\t__mf_uncache_object (& old_obj->data);\n-\n-\t/* Wipe buffer contents if desired.  */\n-\tif ((__mf_opts.wipe_stack && old_obj->data.type == __MF_TYPE_STACK)\n-\t    || (__mf_opts.wipe_heap && (old_obj->data.type == __MF_TYPE_HEAP \n-\t\t\t\t\t|| old_obj->data.type == __MF_TYPE_HEAP_I)))\n-\t  {\n-\t    memset ((void *) old_obj->data.low,\n-\t\t    0,\n-\t\t    (size_t) (old_obj->data.high - old_obj->data.low + 1));\n-\t  }\n-\t\n-\t/* Manage the object cemetary.  */\n-\tif (__mf_opts.persistent_count > 0 && \n-\t    old_obj->data.type >= 0 && \n-\t    old_obj->data.type <= __MF_TYPE_MAX_CEM)\n-\t  {\n-\t    old_obj->data.deallocated_p = 1;\n-\t    old_obj->left = old_obj->right = NULL;\n-\t    old_obj->data.dealloc_pc = (uintptr_t) __builtin_return_address (0);\n+        __mf_object_t *old_obj = NULL;\n+        __mf_object_t *del_obj = NULL;  /* Object to actually delete. */\n+        __mf_object_t *objs[1] = {NULL};\n+        unsigned num_overlapping_objs;\n+\n+        num_overlapping_objs = __mf_find_objects2 ((uintptr_t) ptr,\n+                                                   CLAMPSZ (ptr, sz), objs, 1, type);\n+\n+        /* Special case for HEAP_I - see free & realloc hook.  They don't\n+           know whether the input region was HEAP or HEAP_I before\n+           unmapping it.  Here we give HEAP a try in case HEAP_I\n+           failed.  */\n+        if ((type == __MF_TYPE_HEAP_I) && (num_overlapping_objs == 0))\n+          {\n+            num_overlapping_objs = __mf_find_objects2 ((uintptr_t) ptr,\n+                                                       CLAMPSZ (ptr, sz), objs, 1, __MF_TYPE_HEAP);\n+          }\n+\n+        old_obj = objs[0];\n+        if (UNLIKELY ((num_overlapping_objs != 1) /* more than one overlap */\n+                      || ((sz == 0) ? 0 : (sz != (old_obj->high - old_obj->low + 1))) /* size mismatch */\n+                      || ((uintptr_t) ptr != old_obj->low))) /* base mismatch */\n+          {\n+            __mf_violation (ptr, sz,\n+                            (uintptr_t) __builtin_return_address (0), NULL,\n+                            __MF_VIOL_UNREGISTER);\n+            break;\n+          }\n+\n+        __mf_unlink_object (old_obj);\n+        __mf_uncache_object (old_obj);\n+\n+        /* Wipe buffer contents if desired.  */\n+        if ((__mf_opts.wipe_stack && old_obj->type == __MF_TYPE_STACK)\n+            || (__mf_opts.wipe_heap && (old_obj->type == __MF_TYPE_HEAP \n+                                        || old_obj->type == __MF_TYPE_HEAP_I)))\n+          {\n+            memset ((void *) old_obj->low,\n+                    0,\n+                    (size_t) (old_obj->high - old_obj->low + 1));\n+          }\n+        \n+        /* Manage the object cemetary.  */\n+        if (__mf_opts.persistent_count > 0 && \n+            old_obj->type >= 0 && \n+            old_obj->type <= __MF_TYPE_MAX_CEM)\n+          {\n+            old_obj->deallocated_p = 1;\n+            old_obj->dealloc_pc = (uintptr_t) __builtin_return_address (0);\n #if HAVE_GETTIMEOFDAY\n-\t    gettimeofday (& old_obj->data.dealloc_time, NULL);\n+            gettimeofday (& old_obj->dealloc_time, NULL);\n #endif\n #ifdef LIBMUDFLAPTH\n-\t    old_obj->data.dealloc_thread = pthread_self ();\n+            old_obj->dealloc_thread = pthread_self ();\n #endif\n \n-\t    if (__mf_opts.backtrace > 0 && old_obj->data.type == __MF_TYPE_HEAP)\n-\t      old_obj->data.dealloc_backtrace_size = \n-\t\t__mf_backtrace (& old_obj->data.dealloc_backtrace,\n-\t\t\t\tNULL, 2);\n-\n-\t    /* Encourage this object to be displayed again in current epoch.  */\n-\t    old_obj->data.description_epoch --;\n-\n-\t    /* Put this object into the cemetary.  This may require this plot to\n-\t       be recycled, and the previous resident to be designated del_obj.  */\n-\t    {\n-\t      unsigned row = old_obj->data.type;\n-\t      unsigned plot = __mf_object_dead_head [row];\n-\t      \n-\t      del_obj = __mf_object_cemetary [row][plot];\n-\t      __mf_object_cemetary [row][plot] = old_obj;\n-\t      plot ++;\n-\t      if (plot == __mf_opts.persistent_count) plot = 0;\n-\t      __mf_object_dead_head [row] = plot;\n-\t    }\n-\t  }\n-\telse\n-\t  del_obj = old_obj;\n-\t\n-\tif (__mf_opts.print_leaks)\n-\t  {\n-\t    if ((old_obj->data.read_count + old_obj->data.write_count) == 0 &&\n-\t\t(old_obj->data.type == __MF_TYPE_HEAP \n-\t\t || old_obj->data.type == __MF_TYPE_HEAP_I))\n-\t      {\n-\t\tfprintf (stderr, \n-\t\t\t \"*******\\n\"\n-\t\t\t \"mudflap warning: unaccessed registered object:\\n\");\n-\t\t__mf_describe_object (& old_obj->data);\n-\t      }\n-\t  }\n-\t\n-\tif (del_obj != NULL) /* May or may not equal old_obj.  */\n-\t  {\n-\t    if (__mf_opts.backtrace > 0)\n-\t      {\n-\t\tCALL_REAL(free, del_obj->data.alloc_backtrace);\n-\t\tif (__mf_opts.persistent_count > 0)\n-\t\t  {\n-\t\t    CALL_REAL(free, del_obj->data.dealloc_backtrace);\n-\t\t  }\n-\t      }\n-\t    CALL_REAL(free, del_obj);\n-\t  }\n-\t\n-\tbreak;\n+            if (__mf_opts.backtrace > 0 && old_obj->type == __MF_TYPE_HEAP)\n+              old_obj->dealloc_backtrace_size = \n+                __mf_backtrace (& old_obj->dealloc_backtrace,\n+                                NULL, 2);\n+\n+            /* Encourage this object to be displayed again in current epoch.  */\n+            old_obj->description_epoch --;\n+\n+            /* Put this object into the cemetary.  This may require this plot to\n+               be recycled, and the previous resident to be designated del_obj.  */\n+            {\n+              unsigned row = old_obj->type;\n+              unsigned plot = __mf_object_dead_head [row];\n+              \n+              del_obj = __mf_object_cemetary [row][plot];\n+              __mf_object_cemetary [row][plot] = old_obj;\n+              plot ++;\n+              if (plot == __mf_opts.persistent_count) plot = 0;\n+              __mf_object_dead_head [row] = plot;\n+            }\n+          }\n+        else\n+          del_obj = old_obj;\n+        \n+        if (__mf_opts.print_leaks)\n+          {\n+            if ((old_obj->read_count + old_obj->write_count) == 0 &&\n+                (old_obj->type == __MF_TYPE_HEAP \n+                 || old_obj->type == __MF_TYPE_HEAP_I))\n+              {\n+                fprintf (stderr, \n+                         \"*******\\n\"\n+                         \"mudflap warning: unaccessed registered object:\\n\");\n+                __mf_describe_object (old_obj);\n+              }\n+          }\n+        \n+        if (del_obj != NULL) /* May or may not equal old_obj.  */\n+          {\n+            if (__mf_opts.backtrace > 0)\n+              {\n+                CALL_REAL(free, del_obj->alloc_backtrace);\n+                if (__mf_opts.persistent_count > 0)\n+                  {\n+                    CALL_REAL(free, del_obj->dealloc_backtrace);\n+                  }\n+              }\n+            CALL_REAL(free, del_obj);\n+          }\n+        \n+        break;\n       }\n     } /* end switch (__mf_opts.mudflap_mode) */\n \n@@ -1380,75 +1217,6 @@ __mfu_unregister (void *ptr, size_t sz)\n     }\n }\n \n-/* ------------------------------------------------------------------------ */\n-/* __mf_validate_live_object_tree, _object_cemetary */\n-\n-static void\n-__mf_validate_live_object_tree (__mf_object_tree_t *obj)\n-{\n-  assert (obj != NULL);\n-\n-  if (__mf_opts.persistent_count > 0)\n-    assert (! obj->data.deallocated_p);\n-\n-  if (obj->left)\n-    {\n-      assert (obj->left->data.high < obj->data.low);\n-      __mf_validate_live_object_tree (obj->left);\n-    }\n-  if (obj->right)\n-    {\n-      assert (obj->right->data.low > obj->data.high);\n-      __mf_validate_live_object_tree (obj->right);\n-    }\n-}\n-\n-static void\n-__mf_validate_object_cemetary ()\n-{\n-  unsigned cls;\n-  unsigned i;\n-\n-  for (cls = 0; cls <= __MF_TYPE_MAX_CEM; cls++)\n-    {\n-      assert (__mf_object_dead_head [cls] >= 0 &&\n-\t      __mf_object_dead_head [cls] < __mf_opts.persistent_count);\n-      for (i = 0; i < __mf_opts.persistent_count; i++)\n-\t{\n-\t  __mf_object_tree_t *obj = __mf_object_cemetary [cls][i];\n-\t  if (obj != NULL)\n-\t    {\n-\t      assert (obj->data.deallocated_p);\n-\t      assert (obj->left == NULL);\n-\t      assert (obj->right == NULL);\n-\t    }\n-\t}\n-    }\n-}\n-\n-static void \n-__mf_validate_objects ()\n-{\n-  if (__mf_object_root)\n-    __mf_validate_live_object_tree (__mf_object_root);\n-\n-  if (__mf_opts.persistent_count > 0)\n-    __mf_validate_object_cemetary ();\n-}\n-\n-\n-static void\n-__mf_age_tree (__mf_object_tree_t *obj)\n-{\n-  assert (obj != NULL);\n-  obj->data.liveness = obj->data.liveness >> 1;\n-\n-  if (obj->left)\n-    __mf_age_tree (obj->left);\n-  if (obj->right)\n-    __mf_age_tree (obj->right);\n-}\n-\n \n \n struct tree_stats\n@@ -1462,46 +1230,49 @@ struct tree_stats\n };\n \n \n-static void\n-__mf_tree_analyze (__mf_object_tree_t *obj, struct tree_stats* s)\n-{\n-  assert (obj != NULL);\n \n-  if (obj->left)\n-    __mf_tree_analyze (obj->left, s);\n+static int\n+__mf_adapt_cache_fn (splay_tree_node n, void *param)\n+{\n+  __mf_object_t *obj = (__mf_object_t *) n->value;\n+  struct tree_stats *s = (struct tree_stats *) param;\n \n+  assert (obj != NULL && s != NULL);\n+  \n   /* Exclude never-accessed objects.  */\n-  if (obj->data.read_count + obj->data.write_count)\n+  if (obj->read_count + obj->write_count)\n     {\n       s->obj_count ++;\n-      s->total_size += (obj->data.high - obj->data.low + 1);\n-\n-      if (obj->data.liveness)\n-\t{\n-\t  unsigned i;\n-\t  uintptr_t addr;\n-\n-\t  VERBOSE_TRACE (\"analyze low=%p live=%u name=`%s'\\n\",\n-\t\t\t (void *) obj->data.low, obj->data.liveness, obj->data.name);\n-\n-\t  s->live_obj_count ++;\n-\t  s->total_weight += (double) obj->data.liveness;\n-\t  s->weighted_size +=\n-\t    (double) (obj->data.high - obj->data.low + 1) *\n-\t    (double) obj->data.liveness;\n-\n-\t  addr = obj->data.low;\n-\t  for (i=0; i<sizeof(uintptr_t) * 8; i++)\n-\t    {\n-\t      unsigned bit = addr & 1;\n-\t      s->weighted_address_bits[i][bit] += obj->data.liveness;\n-\t      addr = addr >> 1;\n-\t    }\n-\t}\n+      s->total_size += (obj->high - obj->low + 1);\n+\n+      if (obj->liveness)\n+        {\n+          unsigned i;\n+          uintptr_t addr;\n+\n+          /* VERBOSE_TRACE (\"analyze low=%p live=%u name=`%s'\\n\",\n+             (void *) obj->low, obj->liveness, obj->name); */\n+\n+          s->live_obj_count ++;\n+          s->total_weight += (double) obj->liveness;\n+          s->weighted_size +=\n+            (double) (obj->high - obj->low + 1) *\n+            (double) obj->liveness;\n+\n+          addr = obj->low;\n+          for (i=0; i<sizeof(uintptr_t) * 8; i++)\n+            {\n+              unsigned bit = addr & 1;\n+              s->weighted_address_bits[i][bit] += obj->liveness;\n+              addr = addr >> 1;\n+            }\n+\n+          /* Age the liveness value.  */\n+          obj->liveness >>= 1;\n+        }\n     }\n \n-  if (obj->right)\n-    __mf_tree_analyze (obj->right, s);\n+  return 0;\n }\n \n \n@@ -1517,8 +1288,12 @@ __mf_adapt_cache ()\n   unsigned i;\n \n   memset (&s, 0, sizeof (s));\n-  if (__mf_object_root)\n-    __mf_tree_analyze (__mf_object_root, & s);\n+\n+  splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP), __mf_adapt_cache_fn, (void *) & s);\n+  splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I), __mf_adapt_cache_fn, (void *) & s);\n+  splay_tree_foreach (__mf_object_tree (__MF_TYPE_STACK), __mf_adapt_cache_fn, (void *) & s);\n+  splay_tree_foreach (__mf_object_tree (__MF_TYPE_STATIC), __mf_adapt_cache_fn, (void *) & s);\n+  splay_tree_foreach (__mf_object_tree (__MF_TYPE_GUESS), __mf_adapt_cache_fn, (void *) & s);\n \n   /* Maybe we're dealing with funny aging/adaptation parameters, or an\n      empty tree.  Just leave the cache alone in such cases, rather\n@@ -1539,7 +1314,7 @@ __mf_adapt_cache ()\n       float shoulder_factor = 0.7;  /* Include slightly less popular bits too.  */\n       float value = (float) s.weighted_address_bits[i][0] * (float) s.weighted_address_bits[i][1];\n       if (value >= max_value * shoulder_factor)\n-\tbreak;\n+        break;\n     }\n   if (smoothed_new_shift < 0) smoothed_new_shift = __mf_lc_shift;\n   /* Converge toward this slowly to reduce flapping. */  \n@@ -1558,9 +1333,9 @@ __mf_adapt_cache ()\n   new_mask &= (LOOKUP_CACHE_SIZE_MAX - 1);\n \n   VERBOSE_TRACE (\"adapt cache obj=%u/%u sizes=%lu/%.0f/%.0f => \"\n-\t\t \"util=%u%% m=%p s=%u\\n\",\n-\t\t s.obj_count, s.live_obj_count, s.total_size, s.total_weight, s.weighted_size,\n-\t\t (unsigned)(cache_utilization*100.0), (void *) new_mask, new_shift);\n+                 \"util=%u%% m=%p s=%u\\n\",\n+                 s.obj_count, s.live_obj_count, s.total_size, s.total_weight, s.weighted_size,\n+                 (unsigned)(cache_utilization*100.0), (void *) new_mask, new_shift);\n \n   /* We should reinitialize cache if its parameters have changed.  */\n   if (new_mask != __mf_lc_mask ||\n@@ -1577,89 +1352,53 @@ __mf_adapt_cache ()\n \n \n \n-\n /* __mf_find_object[s] */\n \n /* Find overlapping live objecs between [low,high].  Return up to\n    max_objs of their pointers in objs[].  Return total count of\n    overlaps (may exceed max_objs). */\n \n-/* XXX: track traversal statistics, like average depth, balance.  */\n-\n-static unsigned\n-__mf_find_objects_rec (uintptr_t low, uintptr_t high, __mf_object_tree_t **nodep,\n-\t\t       __mf_object_tree_t **objs, unsigned max_objs)\n+unsigned \n+__mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high, \n+                    __mf_object_t **objs, unsigned max_objs, int type)\n {\n-  unsigned count;\n-  __mf_object_tree_t *node = *nodep;\n-\n-  assert (low <= high);\n-  assert (max_objs == 0 || objs != NULL);\n-\n-  if (UNLIKELY (node == NULL)) return 0;\n-\n-  /* Traverse down left subtree. */\n-  count = 0;\n-  if (low < node->data.low)\n-    count += __mf_find_objects_rec (low, min(high, node->data.low),\n-\t\t\t\t    & node->left, objs, max_objs);\n-\n-  /* Track the used slots of objs[].  */\n-  if (count < max_objs)\n-    {\n-      objs += count;\n-      max_objs -= count;\n-    }\n-  else\n-    {\n-      max_objs = 0;\n-    }\n+  unsigned count = 0;\n+  splay_tree t = __mf_object_tree (type);\n+  splay_tree_key k = (splay_tree_key) ptr_low;\n+  int direction;\n \n-  /* Check for overlap with this node.  */\n-  if (high >= node->data.low && low <= node->data.high)\n+  splay_tree_node n = splay_tree_lookup (t, k);\n+  /* An exact match for base address implies a hit.  */\n+  if (n != NULL)\n     {\n+      if (count < max_objs)\n+        objs[count] = (__mf_object_t *) n->value;\n       count ++;\n-      if (max_objs > 0)  /* Any room left?  */\n-\t{\n-\t  objs[0] = node;\n-\t  objs ++;\n-\t  max_objs --;\n-\t}\n     }\n \n-  /* Traverse down right subtree.  */\n-  if (high > node->data.high)\n-    count += __mf_find_objects_rec (max (low, node->data.high), high,\n-\t\t\t\t    & node->right, objs, max_objs);\n-  /* There is no need to manipulate objs/max_objs any further.  */\n-\n-\n-  /* Rotate a child node up if its access count is higher. */\n-  if (UNLIKELY ((node->left && node->left->data.liveness > node->data.liveness) &&\n-\t\t((!node->right || (node->right && \n-\t\t\t\t   node->left->data.liveness > \n-\t\t\t\t   node->right->data.liveness)))))\n-    {\n-      __mf_object_tree_t *l = node->left;\n-      __mf_object_tree_t *l_r = l->right;\n-\n-      *nodep = l;\n-      l->right = node;\n-      node->left = l_r;\n-      __mf_treerot_left ++;\n-    }\n-  else if (UNLIKELY ((node->right && node->right->data.liveness > node->data.liveness) &&\n-\t\t     ((!node->left || (node->left && \n-\t\t\t\t       node->right->data.liveness > \n-\t\t\t\t       node->left->data.liveness)))))\n+  /* Iterate left then right near this key value to find all overlapping objects. */\n+  for (direction = 0; direction < 2; direction ++)\n     {\n-      __mf_object_tree_t *r = node->right;\n-      __mf_object_tree_t *r_l = r->left;\n-\n-      *nodep = r;\n-      r->left = node;\n-      node->right = r_l;\n-      __mf_treerot_right ++;\n+      /* Reset search origin.  */\n+      k = (splay_tree_key) ptr_low;\n+\n+      while (1)\n+        {\n+          __mf_object_t *obj;\n+              \n+          n = (direction == 0 ? splay_tree_predecessor (t, k) : splay_tree_successor (t, k));\n+          if (n == NULL) break;\n+          obj = (__mf_object_t *) n->value;\n+              \n+          if (! (obj->low <= ptr_high && obj->high >= ptr_low)) /* No overlap? */\n+            break;\n+              \n+          if (count < max_objs)\n+            objs[count] = (__mf_object_t *) n->value;\n+          count ++;\n+\n+          k = (splay_tree_key) obj->low;\n+        }\n     }\n \n   return count;\n@@ -1668,88 +1407,49 @@ __mf_find_objects_rec (uintptr_t low, uintptr_t high, __mf_object_tree_t **nodep\n \n unsigned\n __mf_find_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n-\t\t   __mf_object_tree_t **objs, unsigned max_objs)\n-{\n-  if (UNLIKELY(__mf_opts.internal_checking))\n-    __mf_validate_objects ();\n-\n-  return __mf_find_objects_rec (ptr_low, ptr_high, & __mf_object_root, objs, max_objs);\n-}\n-\n-/* __mf_link_object */\n-\n-static void\n-__mf_link_object2 (__mf_object_tree_t *ptr, __mf_object_tree_t **link)\n+                   __mf_object_t **objs, unsigned max_objs)\n {\n-  __mf_object_tree_t *node = *link;\n+  int type;\n+  unsigned count = 0;\n \n-  assert (ptr != NULL);\n-  if (UNLIKELY(node == NULL))\n+  /* Search each splay tree for overlaps.  */\n+  for (type = __MF_TYPE_NOACCESS; type <= __MF_TYPE_GUESS; type++)\n     {\n-      *link = ptr;\n-      return;\n+      unsigned c = __mf_find_objects2 (ptr_low, ptr_high, objs, max_objs, type);\n+      if (c > max_objs)\n+        {\n+          max_objs = 0;\n+          objs = NULL;\n+        }\n+      else /* NB: C may equal 0 */\n+        {\n+          max_objs -= c;\n+          objs += c;\n+        }\n+      count += c;\n     }\n \n-  if (ptr->data.high < node->data.low)\n-    return __mf_link_object2 (ptr, & node->left);\n-  else if (ptr->data.low > node->data.high)\n-    return __mf_link_object2 (ptr, & node->right);\n-  else\n-    abort (); /* XXX: duplicate object */\n+  return count;\n }\n \n \n-void\n-__mf_link_object (__mf_object_tree_t *ptr)\n-{\n-  if (UNLIKELY(__mf_opts.internal_checking))\n-    __mf_validate_objects ();\n-\n-  return __mf_link_object2 (ptr, & __mf_object_root);\n-}\n \n-/* __mf_unlink_object */\n+/* __mf_link_object */\n \n static void\n-__mf_unlink_object2 (__mf_object_tree_t *ptr, __mf_object_tree_t **link)\n+__mf_link_object (__mf_object_t *node)\n {\n-  __mf_object_tree_t *node = *link;\n-  \n-  assert (ptr != NULL);\n-  if (UNLIKELY(node == ptr))\n-    {\n-      static unsigned promote_left_p = 0;\n-      promote_left_p = 1 - promote_left_p;\n-\n-      /* Alternate promoting the left & right subtrees. */\n-      if (promote_left_p)\n-\t{\n-\t  *link = ptr->left;\n-\t  if (ptr->right != NULL)\n-\t    __mf_link_object2 (ptr->right, link);\n-\t}\n-      else\n-\t{\n-\t  *link = ptr->right;\n-\t  if (ptr->left != NULL)\n-\t    __mf_link_object2 (ptr->left, link);\n-\t}\n-\n-      return;\n-    }\n-\n-  if (ptr->data.high < node->data.low)\n-    return __mf_unlink_object2 (ptr, & node->left);\n-  else if (ptr->data.low > node->data.high)\n-    return __mf_unlink_object2 (ptr, & node->right);\n-  else\n-    abort (); /* XXX: missing object; should fail more gracefully. */\n+  splay_tree t = __mf_object_tree (node->type);\n+  splay_tree_insert (t, (splay_tree_key) node->low, (splay_tree_value) node);\n }\n \n+/* __mf_unlink_object */\n+\n static void\n-__mf_unlink_object (__mf_object_tree_t *node)\n+__mf_unlink_object (__mf_object_t *node)\n {\n-  __mf_unlink_object2 (node, & __mf_object_root);\n+  splay_tree t = __mf_object_tree (node->type);\n+  splay_tree_remove (t, (splay_tree_key) node->low);\n }\n \n /* __mf_find_dead_objects */\n@@ -1760,7 +1460,7 @@ __mf_unlink_object (__mf_object_tree_t *node)\n \n static unsigned\n __mf_find_dead_objects (uintptr_t low, uintptr_t high,\n-\t\t\t__mf_object_tree_t **objs, unsigned max_objs)\n+                        __mf_object_t **objs, unsigned max_objs)\n {\n   if (__mf_opts.persistent_count > 0)\n     {\n@@ -1772,43 +1472,43 @@ __mf_find_dead_objects (uintptr_t low, uintptr_t high,\n       assert (max_objs == 0 || objs != NULL);\n       \n       /* Widen the search from the most recent plots in each row, looking\n-\t backward in time.  */\n+         backward in time.  */\n       recollection = 0;\n       while (recollection < __mf_opts.persistent_count)\n-\t{\n-\t  count = 0;\n-\t  \n-\t  for (row = 0; row <= __MF_TYPE_MAX_CEM; row ++)\n-\t    {\n-\t      unsigned plot;\n-\t      unsigned i;\n-\t      \n-\t      plot = __mf_object_dead_head [row];\n-\t      for (i = 0; i <= recollection; i ++)\n-\t\t{\n-\t\t  __mf_object_tree_t *obj;\n-\t\t  \n-\t\t  /* Look backward through row: it's a circular buffer.  */\n-\t\t  if (plot > 0) plot --;\n-\t\t  else plot = __mf_opts.persistent_count - 1;\n-\t\t  \n-\t\t  obj = __mf_object_cemetary [row][plot];\n-\t\t  if (obj && obj->data.low <= high && obj->data.high >= low)\n-\t\t    {\n-\t\t      /* Found an overlapping dead object!  */\n-\t\t      if (count < max_objs)\n-\t\t\tobjs [count] = obj;\n-\t\t      count ++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  \n-\t  if (count)\n-\t    break;\n-\t  \n-\t  /* Look farther back in time.  */\n-\t  recollection = (recollection * 2) + 1;\n-\t}\n+        {\n+          count = 0;\n+          \n+          for (row = 0; row <= __MF_TYPE_MAX_CEM; row ++)\n+            {\n+              unsigned plot;\n+              unsigned i;\n+              \n+              plot = __mf_object_dead_head [row];\n+              for (i = 0; i <= recollection; i ++)\n+                {\n+                  __mf_object_t *obj;\n+                  \n+                  /* Look backward through row: it's a circular buffer.  */\n+                  if (plot > 0) plot --;\n+                  else plot = __mf_opts.persistent_count - 1;\n+                  \n+                  obj = __mf_object_cemetary [row][plot];\n+                  if (obj && obj->low <= high && obj->high >= low)\n+                    {\n+                      /* Found an overlapping dead object!  */\n+                      if (count < max_objs)\n+                        objs [count] = obj;\n+                      count ++;\n+                    }\n+                }\n+            }\n+          \n+          if (count)\n+            break;\n+          \n+          /* Look farther back in time.  */\n+          recollection = (recollection * 2) + 1;\n+        }\n       \n       return count;\n     } else {\n@@ -1831,39 +1531,39 @@ __mf_describe_object (__mf_object_t *obj)\n   if (__mf_opts.abbreviate && obj->description_epoch == epoch)\n     {\n       fprintf (stderr,\n-\t       \"mudflap object %p: name=`%s'\\n\",\n-\t       (void *) obj, (obj->name ? obj->name : \"\"));\n+               \"mudflap object %p: name=`%s'\\n\",\n+               (void *) obj, (obj->name ? obj->name : \"\"));\n       return;\n     }\n   else\n     obj->description_epoch = epoch;\n \n   fprintf (stderr,\n-\t   \"mudflap object %p: name=`%s'\\n\"\n-\t   \"bounds=[%p,%p] size=%lu area=%s check=%ur/%uw liveness=%u%s\\n\"\n-\t   \"alloc time=%lu.%06lu pc=%p\"\n+           \"mudflap object %p: name=`%s'\\n\"\n+           \"bounds=[%p,%p] size=%lu area=%s check=%ur/%uw liveness=%u%s\\n\"\n+           \"alloc time=%lu.%06lu pc=%p\"\n #ifdef LIBMUDFLAPTH\n-\t   \" thread=%u\"\n+           \" thread=%u\"\n #endif\n-\t   \"\\n\",\n-\t   (void *) obj, (obj->name ? obj->name : \"\"), \n-\t   (void *) obj->low, (void *) obj->high,\n-\t   (unsigned long) (obj->high - obj->low + 1),\n-\t   (obj->type == __MF_TYPE_NOACCESS ? \"no-access\" :\n-\t    obj->type == __MF_TYPE_HEAP ? \"heap\" :\n-\t    obj->type == __MF_TYPE_HEAP_I ? \"heap-init\" :\n-\t    obj->type == __MF_TYPE_STACK ? \"stack\" :\n-\t    obj->type == __MF_TYPE_STATIC ? \"static\" :\n-\t    obj->type == __MF_TYPE_GUESS ? \"guess\" :\n-\t    \"unknown\"),\n-\t   obj->read_count, obj->write_count, obj->liveness, \n-\t   obj->watching_p ? \" watching\" : \"\",\n-\t   obj->alloc_time.tv_sec, obj->alloc_time.tv_usec, \n-\t   (void *) obj->alloc_pc\n+           \"\\n\",\n+           (void *) obj, (obj->name ? obj->name : \"\"), \n+           (void *) obj->low, (void *) obj->high,\n+           (unsigned long) (obj->high - obj->low + 1),\n+           (obj->type == __MF_TYPE_NOACCESS ? \"no-access\" :\n+            obj->type == __MF_TYPE_HEAP ? \"heap\" :\n+            obj->type == __MF_TYPE_HEAP_I ? \"heap-init\" :\n+            obj->type == __MF_TYPE_STACK ? \"stack\" :\n+            obj->type == __MF_TYPE_STATIC ? \"static\" :\n+            obj->type == __MF_TYPE_GUESS ? \"guess\" :\n+            \"unknown\"),\n+           obj->read_count, obj->write_count, obj->liveness, \n+           obj->watching_p ? \" watching\" : \"\",\n+           obj->alloc_time.tv_sec, obj->alloc_time.tv_usec, \n+           (void *) obj->alloc_pc\n #ifdef LIBMUDFLAPTH\n-\t   , (unsigned) obj->alloc_thread\n+           , (unsigned) obj->alloc_thread\n #endif\n-\t   );\n+           );\n \n   if (__mf_opts.backtrace > 0)\n   {\n@@ -1875,55 +1575,56 @@ __mf_describe_object (__mf_object_t *obj)\n   if (__mf_opts.persistent_count > 0)\n     {\n       if (obj->deallocated_p)\n-\t{\n-\t  fprintf (stderr, \"dealloc time=%lu.%06lu pc=%p\"\n+        {\n+          fprintf (stderr, \"dealloc time=%lu.%06lu pc=%p\"\n #ifdef LIBMUDFLAPTH\n-\t\t   \" thread=%u\"\n+                   \" thread=%u\"\n #endif\n-\t\t   \"\\n\",\n-\t\t   obj->dealloc_time.tv_sec, obj->dealloc_time.tv_usec, \n-\t\t   (void *) obj->dealloc_pc\n+                   \"\\n\",\n+                   obj->dealloc_time.tv_sec, obj->dealloc_time.tv_usec, \n+                   (void *) obj->dealloc_pc\n #ifdef LIBMUDFLAPTH\n-\t\t   , (unsigned) obj->dealloc_thread\n+                   , (unsigned) obj->dealloc_thread\n #endif\n-\t\t   );\n+                   );\n \n \n-\t  if (__mf_opts.backtrace > 0)\n-\t  {\n-\t    unsigned i;\n-\t    for (i=0; i<obj->dealloc_backtrace_size; i++)\n-\t      fprintf (stderr, \"      %s\\n\", obj->dealloc_backtrace[i]);\n-\t  }\n-\t}\n+          if (__mf_opts.backtrace > 0)\n+          {\n+            unsigned i;\n+            for (i=0; i<obj->dealloc_backtrace_size; i++)\n+              fprintf (stderr, \"      %s\\n\", obj->dealloc_backtrace[i]);\n+          }\n+        }\n     }\n }\n \n-static unsigned\n-__mf_report_leaks (__mf_object_tree_t *node)\n+\n+static int\n+__mf_report_leaks_fn (splay_tree_node n, void *param)\n {\n- /* The counter is amongst recursive calls, so\n-    that cumulative numbers are printed below.  */\n-  static unsigned count = 0;\n+  __mf_object_t *node = (__mf_object_t *) n->value;\n+  unsigned *count = (unsigned *) param;\n \n-  if (node == NULL)  /* Reset */\n-    {\n-      count = 0;\n-      return 0;\n-    }\n+  if (count != NULL)\n+    (*count) ++;\n \n-  /* Inorder traversal. */\n-  if (node->left)\n-    __mf_report_leaks (node->left);\n-  if (node->data.type == __MF_TYPE_HEAP\n-      || node->data.type == __MF_TYPE_HEAP_I)\n-    {\n-      count ++;\n-      fprintf (stderr, \"Leaked object %u:\\n\", count);\n-      __mf_describe_object (& node->data);\n-    }\n-  if (node->right)\n-    __mf_report_leaks (node->right);\n+  fprintf (stderr, \"Leaked object %u:\\n\", (*count));\n+  __mf_describe_object (node);\n+\n+  return 0;\n+}\n+\n+\n+static unsigned\n+__mf_report_leaks ()\n+{\n+  unsigned count = 0;\n+\n+  (void) splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP),\n+                             __mf_report_leaks_fn, & count);\n+  (void) splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I),\n+                             __mf_report_leaks_fn, & count);\n \n   return count;\n }\n@@ -1947,65 +1648,65 @@ __mfu_report ()\n   if (__mf_opts.collect_stats)\n     {\n       fprintf (stderr,\n-\t       \"*******\\n\"\n-\t       \"mudflap stats:\\n\"\n-\t       \"calls to __mf_check: %lu rot: %lu/%lu\\n\"\n-\t       \"         __mf_register: %lu [%luB, %luB, %luB, %luB, %luB]\\n\"\n-\t       \"         __mf_unregister: %lu [%luB]\\n\"\n-\t       \"         __mf_violation: [%lu, %lu, %lu, %lu, %lu]\\n\",\n-\t       __mf_count_check, __mf_treerot_left, __mf_treerot_right,\n-\t       __mf_count_register,\n-\t       __mf_total_register_size[0], __mf_total_register_size[1],\n-\t       __mf_total_register_size[2], __mf_total_register_size[3],\n-\t       __mf_total_register_size[4], /* XXX */\n-\t       __mf_count_unregister, __mf_total_unregister_size,\n-\t       __mf_count_violation[0], __mf_count_violation[1],\n-\t       __mf_count_violation[2], __mf_count_violation[3],\n-\t       __mf_count_violation[4]);\n+               \"*******\\n\"\n+               \"mudflap stats:\\n\"\n+               \"calls to __mf_check: %lu\\n\"\n+               \"         __mf_register: %lu [%luB, %luB, %luB, %luB, %luB]\\n\"\n+               \"         __mf_unregister: %lu [%luB]\\n\"\n+               \"         __mf_violation: [%lu, %lu, %lu, %lu, %lu]\\n\",\n+               __mf_count_check,\n+               __mf_count_register,\n+               __mf_total_register_size[0], __mf_total_register_size[1],\n+               __mf_total_register_size[2], __mf_total_register_size[3],\n+               __mf_total_register_size[4], /* XXX */\n+               __mf_count_unregister, __mf_total_unregister_size,\n+               __mf_count_violation[0], __mf_count_violation[1],\n+               __mf_count_violation[2], __mf_count_violation[3],\n+               __mf_count_violation[4]);\n \n       fprintf (stderr,\n-\t       \"calls with reentrancy: %lu\\n\", __mf_reentrancy);\n+               \"calls with reentrancy: %lu\\n\", __mf_reentrancy);\n #ifdef LIBMUDFLAPTH\n       fprintf (stderr,\n-\t       \"           lock contention: %lu\\n\", __mf_lock_contention);\n+               \"           lock contention: %lu\\n\", __mf_lock_contention);\n #endif\n \n       /* Lookup cache stats.  */\n       {\n-\tunsigned i;\n-\tunsigned max_reuse = 0;\n-\tunsigned num_used = 0;\n-\tunsigned num_unused = 0;\n-\n-\tfor (i = 0; i < LOOKUP_CACHE_SIZE; i++)\n-\t  {\n-\t    if (__mf_lookup_cache_reusecount[i])\n-\t      num_used ++;\n-\t    else\n-\t      num_unused ++;\n-\t    if (max_reuse < __mf_lookup_cache_reusecount[i])\n-\t      max_reuse = __mf_lookup_cache_reusecount[i];\n-\t  }\n-\tfprintf (stderr, \"lookup cache slots used: %u  unused: %u  peak-reuse: %u\\n\",\n-\t\t num_used, num_unused, max_reuse);\n+        unsigned i;\n+        unsigned max_reuse = 0;\n+        unsigned num_used = 0;\n+        unsigned num_unused = 0;\n+\n+        for (i = 0; i < LOOKUP_CACHE_SIZE; i++)\n+          {\n+            if (__mf_lookup_cache_reusecount[i])\n+              num_used ++;\n+            else\n+              num_unused ++;\n+            if (max_reuse < __mf_lookup_cache_reusecount[i])\n+              max_reuse = __mf_lookup_cache_reusecount[i];\n+          }\n+        fprintf (stderr, \"lookup cache slots used: %u  unused: %u  peak-reuse: %u\\n\",\n+                 num_used, num_unused, max_reuse);\n       }\n \n       {\n-\tunsigned live_count;\n-\tlive_count = __mf_find_objects (MINPTR, MAXPTR, NULL, 0);\n-\tfprintf (stderr, \"number of live objects: %u\\n\", live_count);\n+        unsigned live_count;\n+        live_count = __mf_find_objects (MINPTR, MAXPTR, NULL, 0);\n+        fprintf (stderr, \"number of live objects: %u\\n\", live_count);\n       }\n \n       if (__mf_opts.persistent_count > 0)\n-\t{\n-\t  unsigned dead_count = 0;\n-\t  unsigned row, plot;\n-\t  for (row = 0; row <= __MF_TYPE_MAX_CEM; row ++)\n-\t    for (plot = 0 ; plot < __mf_opts.persistent_count; plot ++)\n-\t      if (__mf_object_cemetary [row][plot] != 0)\n-\t\tdead_count ++;\n-\t  fprintf (stderr, \"          zombie objects: %u\\n\", dead_count);\n-\t}\n+        {\n+          unsigned dead_count = 0;\n+          unsigned row, plot;\n+          for (row = 0; row <= __MF_TYPE_MAX_CEM; row ++)\n+            for (plot = 0 ; plot < __mf_opts.persistent_count; plot ++)\n+              if (__mf_object_cemetary [row][plot] != 0)\n+                dead_count ++;\n+          fprintf (stderr, \"          zombie objects: %u\\n\", dead_count);\n+        }\n     }\n   if (__mf_opts.print_leaks && (__mf_opts.mudflap_mode == mode_check))\n     {\n@@ -2015,8 +1716,7 @@ __mfu_report ()\n       /* Free up any remaining alloca()'d blocks.  */\n       __mf_wrap_alloca_indirect (0);\n       __mf_describe_object (NULL); /* Reset description epoch.  */\n-      __mf_report_leaks (NULL); /* Reset cumulative count.  */\n-      l = __mf_report_leaks (__mf_object_root);\n+      l = __mf_report_leaks ();\n       fprintf (stderr, \"number of leaked objects: %u\\n\", l);\n     }\n }\n@@ -2074,7 +1774,7 @@ __mf_backtrace (char ***symbols, void *guess_pc, unsigned guess_omit_levels)\n   if (guess_pc != NULL)\n     for (i=0; i<pc_array_size; i++)\n       if (pc_array [i] == guess_pc)\n-\tomitted_size = i;\n+        omitted_size = i;\n \n   if (omitted_size == 0) /* No match? */\n     if (pc_array_size > guess_omit_levels)\n@@ -2098,9 +1798,9 @@ __mf_backtrace (char ***symbols, void *guess_pc, unsigned guess_omit_levels)\n     chars = (char *)buffer + (remaining_size * sizeof (char *));\n     for (i = 0; i < remaining_size; i++)\n       {\n-\tpointers[i] = chars;\n-\tsprintf (chars, \"[0x%p]\", pc_array [omitted_size + i]);\n-\tchars = chars + perline;\n+        pointers[i] = chars;\n+        sprintf (chars, \"[0x%p]\", pc_array [omitted_size + i]);\n+        chars = chars + perline;\n       }\n     *symbols = pointers;\n   }\n@@ -2115,20 +1815,20 @@ __mf_backtrace (char ***symbols, void *guess_pc, unsigned guess_omit_levels)\n \n void\n __mf_violation (void *ptr, size_t sz, uintptr_t pc, \n-\t\tconst char *location, int type)\n+                const char *location, int type)\n {\n   char buf [128];\n   static unsigned violation_number;\n   DECLARE(void, free, void *ptr);\n \n   TRACE (\"violation pc=%p location=%s type=%d ptr=%p size=%lu\\n\", \n-\t (void *) pc, \n-\t (location != NULL ? location : \"\"), type, ptr, (unsigned long) sz);\n+         (void *) pc, \n+         (location != NULL ? location : \"\"), type, ptr, (unsigned long) sz);\n \n   if (__mf_opts.collect_stats)\n     __mf_count_violation [(type < 0) ? 0 :\n-\t\t\t  (type > __MF_VIOL_WATCH) ? 0 :\n-\t\t\t  type] ++;\n+                          (type > __MF_VIOL_WATCH) ? 0 :\n+                          type] ++;\n \n   /* Print out a basic warning message.  */\n   if (__mf_opts.verbose_violations)\n@@ -2142,36 +1842,36 @@ __mf_violation (void *ptr, size_t sz, uintptr_t pc,\n \n     violation_number ++;\n     fprintf (stderr,\n-\t     \"*******\\n\"\n-\t     \"mudflap violation %u (%s): time=%lu.%06lu \"\n-\t     \"ptr=%p size=%lu\\npc=%p%s%s%s\\n\", \n-\t     violation_number,\n-\t     ((type == __MF_VIOL_READ) ? \"check/read\" :\n-\t      (type == __MF_VIOL_WRITE) ? \"check/write\" :\n-\t      (type == __MF_VIOL_REGISTER) ? \"register\" :\n-\t      (type == __MF_VIOL_UNREGISTER) ? \"unregister\" :\n-\t      (type == __MF_VIOL_WATCH) ? \"watch\" : \"unknown\"),\n-\t     now.tv_sec, now.tv_usec, \n-\t     (void *) ptr, (unsigned long)sz, (void *) pc,\n-\t     (location != NULL ? \" location=`\" : \"\"),\n-\t     (location != NULL ? location : \"\"),\n-\t     (location != NULL ? \"'\" : \"\"));\n+             \"*******\\n\"\n+             \"mudflap violation %u (%s): time=%lu.%06lu \"\n+             \"ptr=%p size=%lu\\npc=%p%s%s%s\\n\", \n+             violation_number,\n+             ((type == __MF_VIOL_READ) ? \"check/read\" :\n+              (type == __MF_VIOL_WRITE) ? \"check/write\" :\n+              (type == __MF_VIOL_REGISTER) ? \"register\" :\n+              (type == __MF_VIOL_UNREGISTER) ? \"unregister\" :\n+              (type == __MF_VIOL_WATCH) ? \"watch\" : \"unknown\"),\n+             now.tv_sec, now.tv_usec, \n+             (void *) ptr, (unsigned long)sz, (void *) pc,\n+             (location != NULL ? \" location=`\" : \"\"),\n+             (location != NULL ? location : \"\"),\n+             (location != NULL ? \"'\" : \"\"));\n \n     if (__mf_opts.backtrace > 0)\n       {\n-\tchar ** symbols;\n-\tunsigned i, num;\n-\t\n-\tnum = __mf_backtrace (& symbols, (void *) pc, 2);\n-\t/* Note: backtrace_symbols calls malloc().  But since we're in\n-\t   __mf_violation and presumably __mf_check, it'll detect\n-\t   recursion, and not put the new string into the database.  */\n-\t\n-\tfor (i=0; i<num; i++)\n-\t  fprintf (stderr, \"      %s\\n\", symbols[i]);\n-\t\n-\t/* Calling free() here would trigger a violation.  */\n-\tCALL_REAL(free, symbols);\n+        char ** symbols;\n+        unsigned i, num;\n+        \n+        num = __mf_backtrace (& symbols, (void *) pc, 2);\n+        /* Note: backtrace_symbols calls malloc().  But since we're in\n+           __mf_violation and presumably __mf_check, it'll detect\n+           recursion, and not put the new string into the database.  */\n+        \n+        for (i=0; i<num; i++)\n+          fprintf (stderr, \"      %s\\n\", symbols[i]);\n+        \n+        /* Calling free() here would trigger a violation.  */\n+        CALL_REAL(free, symbols);\n       }\n     \n     \n@@ -2183,56 +1883,56 @@ __mf_violation (void *ptr, size_t sz, uintptr_t pc,\n     \n     for (dead_p = 0; dead_p <= 1; dead_p ++) /* for dead_p in 0 1 */\n       {\n-\tenum {max_objs = 3}; /* magic */\n-\t__mf_object_tree_t *objs[max_objs];\n-\tunsigned num_objs = 0;\n-\tuintptr_t s_low, s_high;\n-\tunsigned tries = 0;\n-\tunsigned i;\n-\t\n-\ts_low = (uintptr_t) ptr;\n-\ts_high = CLAMPSZ (ptr, sz);\n-\n-\twhile (tries < 16) /* magic */\n-\t  {\n-\t    if (dead_p)\n-\t      num_objs = __mf_find_dead_objects (s_low, s_high, objs, max_objs);\n-\t    else\n-\t      num_objs = __mf_find_objects (s_low, s_high, objs, max_objs);\n-\n-\t    if (num_objs) /* good enough */\n-\t      break;\n-\n-\t    tries ++;\n-\n-\t    /* XXX: tune this search strategy.  It's too dependent on\n-\t     sz, which can vary from 1 to very big (when array index\n-\t     checking) numbers. */\n-\t    s_low = CLAMPSUB (s_low, (sz * tries * tries));\n-\t    s_high = CLAMPADD (s_high, (sz * tries * tries));\n-\t  }\n-\n-\tfor (i = 0; i < min (num_objs, max_objs); i++)\n-\t  {\n-\t    __mf_object_t *obj = & objs[i]->data;\n-\t    uintptr_t low = (uintptr_t) ptr;\n-\t    uintptr_t high = CLAMPSZ (ptr, sz);\n-\t    unsigned before1 = (low < obj->low) ? obj->low - low : 0;\n-\t    unsigned after1 = (low > obj->high) ? low - obj->high : 0;\n-\t    unsigned into1 = (high >= obj->low && low <= obj->high) ? low - obj->low : 0;\n-\t    unsigned before2 = (high < obj->low) ? obj->low - high : 0;\n-\t    unsigned after2 = (high > obj->high) ? high - obj->high : 0;\n-\t    unsigned into2 = (high >= obj->low && low <= obj->high) ? high - obj->low : 0;\n-\n-\t    fprintf (stderr, \"Nearby object %u: checked region begins %uB %s and ends %uB %s\\n\",\n-\t\t     num_helpful + i + 1,\n-\t\t     (before1 ? before1 : after1 ? after1 : into1),\n-\t\t     (before1 ? \"before\" : after1 ? \"after\" : \"into\"),\n-\t\t     (before2 ? before2 : after2 ? after2 : into2),\n-\t\t     (before2 ? \"before\" : after2 ? \"after\" : \"into\"));\n-\t    __mf_describe_object (obj);\n-\t  }\n-\tnum_helpful += num_objs;\n+        enum {max_objs = 3}; /* magic */\n+        __mf_object_t *objs[max_objs];\n+        unsigned num_objs = 0;\n+        uintptr_t s_low, s_high;\n+        unsigned tries = 0;\n+        unsigned i;\n+        \n+        s_low = (uintptr_t) ptr;\n+        s_high = CLAMPSZ (ptr, sz);\n+\n+        while (tries < 16) /* magic */\n+          {\n+            if (dead_p)\n+              num_objs = __mf_find_dead_objects (s_low, s_high, objs, max_objs);\n+            else\n+              num_objs = __mf_find_objects (s_low, s_high, objs, max_objs);\n+\n+            if (num_objs) /* good enough */\n+              break;\n+\n+            tries ++;\n+\n+            /* XXX: tune this search strategy.  It's too dependent on\n+             sz, which can vary from 1 to very big (when array index\n+             checking) numbers. */\n+            s_low = CLAMPSUB (s_low, (sz * tries * tries));\n+            s_high = CLAMPADD (s_high, (sz * tries * tries));\n+          }\n+\n+        for (i = 0; i < min (num_objs, max_objs); i++)\n+          {\n+            __mf_object_t *obj = objs[i];\n+            uintptr_t low = (uintptr_t) ptr;\n+            uintptr_t high = CLAMPSZ (ptr, sz);\n+            unsigned before1 = (low < obj->low) ? obj->low - low : 0;\n+            unsigned after1 = (low > obj->high) ? low - obj->high : 0;\n+            unsigned into1 = (high >= obj->low && low <= obj->high) ? low - obj->low : 0;\n+            unsigned before2 = (high < obj->low) ? obj->low - high : 0;\n+            unsigned after2 = (high > obj->high) ? high - obj->high : 0;\n+            unsigned into2 = (high >= obj->low && low <= obj->high) ? high - obj->low : 0;\n+\n+            fprintf (stderr, \"Nearby object %u: checked region begins %uB %s and ends %uB %s\\n\",\n+                     num_helpful + i + 1,\n+                     (before1 ? before1 : after1 ? after1 : into1),\n+                     (before1 ? \"before\" : after1 ? \"after\" : \"into\"),\n+                     (before2 ? before2 : after2 ? after2 : into2),\n+                     (before2 ? \"before\" : after2 ? \"after\" : \"into\"));\n+            __mf_describe_object (obj);\n+          }\n+        num_helpful += num_objs;\n       }\n \n     fprintf (stderr, \"number of nearby objects: %u\\n\", num_helpful);\n@@ -2296,7 +1996,7 @@ __mf_watch_or_not (void *ptr, size_t sz, char flag)\n   unsigned count = 0;\n \n   TRACE (\"%s ptr=%p size=%lu\\n\",\n-\t (flag ? \"watch\" : \"unwatch\"), ptr, (unsigned long) sz);\n+         (flag ? \"watch\" : \"unwatch\"), ptr, (unsigned long) sz);\n   \n   switch (__mf_opts.mudflap_mode)\n     {\n@@ -2308,38 +2008,37 @@ __mf_watch_or_not (void *ptr, size_t sz, char flag)\n \n     case mode_check:\n       {\n-\t__mf_object_tree_t **all_ovr_objs;\n-\tunsigned obj_count;\n-\tunsigned n;\n-\tDECLARE (void *, malloc, size_t c);\n-\tDECLARE (void, free, void *p);\n-\n-\tobj_count = __mf_find_objects (ptr_low, ptr_high, NULL, 0);\n-\tVERBOSE_TRACE (\" %u:\", obj_count);\n-\n-\tall_ovr_objs = CALL_REAL (malloc, (sizeof (__mf_object_tree_t *) *\n-\t\t\t\t\t   obj_count));\n-\tif (all_ovr_objs == NULL) abort ();\n-\tn = __mf_find_objects (ptr_low, ptr_high, all_ovr_objs, obj_count);\n-\tassert (n == obj_count);\n-\n-\tfor (n = 0; n < obj_count; n ++)\n-\t  {\n-\t    __mf_object_t *obj = & (all_ovr_objs[n]->data);\n-\n-\t    VERBOSE_TRACE (\" [%p]\", (void *) obj);\n-\t    if (obj->watching_p != flag)\n-\t      {\n-\t\tobj->watching_p = flag;\n-\t\tcount ++;\n-\n-\t\t/* Remove object from cache, to ensure next access\n-\t\t   goes through __mf_check().  */\n-\t        if (flag)\n-\t\t  __mf_uncache_object (obj);\n-\t      }\n-\t  }\n-\tCALL_REAL (free, all_ovr_objs);\n+        __mf_object_t **all_ovr_objs;\n+        unsigned obj_count;\n+        unsigned n;\n+        DECLARE (void *, malloc, size_t c);\n+        DECLARE (void, free, void *p);\n+\n+        obj_count = __mf_find_objects (ptr_low, ptr_high, NULL, 0);\n+        VERBOSE_TRACE (\" %u:\", obj_count);\n+\n+        all_ovr_objs = CALL_REAL (malloc, (sizeof (__mf_object_t *) * obj_count));\n+        if (all_ovr_objs == NULL) abort ();\n+        n = __mf_find_objects (ptr_low, ptr_high, all_ovr_objs, obj_count);\n+        assert (n == obj_count);\n+\n+        for (n = 0; n < obj_count; n ++)\n+          {\n+            __mf_object_t *obj = all_ovr_objs[n];\n+\n+            VERBOSE_TRACE (\" [%p]\", (void *) obj);\n+            if (obj->watching_p != flag)\n+              {\n+                obj->watching_p = flag;\n+                count ++;\n+\n+                /* Remove object from cache, to ensure next access\n+                   goes through __mf_check().  */\n+                if (flag)\n+                  __mf_uncache_object (obj);\n+              }\n+          }\n+        CALL_REAL (free, all_ovr_objs);\n       }\n       break;\n     }\n@@ -2403,12 +2102,12 @@ write_itoa (int fd, unsigned n)\n       buf[bufsize-2-i] = digit + '0';\n       n /= 10;\n       if (n == 0) \n-\t{\n-\t  char *m = & buf [bufsize-2-i];\n-\t  buf[bufsize-1] = '\\0';\n-\t  write (fd, m, strlen(m));\n-\t  break;\n-\t}\n+        {\n+          char *m = & buf [bufsize-2-i];\n+          buf[bufsize-1] = '\\0';\n+          write (fd, m, strlen(m));\n+          break;\n+        }\n     }\n }\n \n@@ -2438,3 +2137,28 @@ __assert_fail (const char *msg, const char *file, unsigned line, const char *fun\n \n \n #endif\n+\n+\n+\n+\n+\n+/* #include the generic splay tree implementation from libiberty here, to\n+   ensure that it uses our memory allocation primitives.  */\n+\n+static void\n+splay_tree_free (void *p)\n+{\n+  DECLARE (void, free, void *p);\n+  CALL_REAL (free, p);\n+}\n+\n+static void *\n+splay_tree_xmalloc (size_t s)\n+{\n+  DECLARE (void *, malloc, size_t s);\n+  return CALL_REAL (malloc, s);\n+}\n+\n+#define free(z) splay_tree_free(z)\n+#define xmalloc(z) splay_tree_xmalloc(z)\n+#include \"splay-tree.c\""}, {"sha": "b035c7d2d32fff8b963a260e2ff6ed794030e453", "filename": "libmudflap/mf-runtime.h.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-runtime.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Fmf-runtime.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.h.in?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -55,7 +55,8 @@ extern void __mf_check (void *ptr, size_t sz, int type, const char *location)\n        __attribute((nothrow));\n extern void __mf_register (void *ptr, size_t sz, int type, const char *name) \n        __attribute((nothrow));\n-extern void __mf_unregister (void *ptr, size_t sz) __attribute((nothrow));\n+extern void __mf_unregister (void *ptr, size_t sz, int type)\n+       __attribute((nothrow));\n extern unsigned __mf_watch (void *ptr, size_t sz);\n extern unsigned __mf_unwatch (void *ptr, size_t sz);\n extern void __mf_report ();"}, {"sha": "a30769a73dfe8e12c335ea22ac8f3fb329a2bb7b", "filename": "libmudflap/testsuite/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2FMakefile.in?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -41,7 +41,7 @@ DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n \t$(srcdir)/mfconfig.exp.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \\\n-\t$(top_srcdir)/configure.in\n+\t$(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs"}, {"sha": "a7b62ddb7c7355480657ce3b5025919b7f306e7f", "filename": "libmudflap/testsuite/libmudflap.c/fail18-frag.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail18-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbd22d765f6afb097d4bfb7b3407d60986e84a9/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail18-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail18-frag.c?ref=cfbd22d765f6afb097d4bfb7b3407d60986e84a9", "patch": "@@ -6,7 +6,7 @@ int main ()\n /* One cannot redeclare __mf_lc_mask in proper C from instrumented\n    code, because of the way the instrumentation code emits its decls.  */\n extern unsigned foo __asm__ (\"__mf_lc_mask\");\n-unsigned *bar = &foo;\n+unsigned * volatile bar = &foo;\n *bar = 4;\n return 0;\n }"}]}