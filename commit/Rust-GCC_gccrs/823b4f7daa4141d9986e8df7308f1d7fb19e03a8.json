{"sha": "823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzYjRmN2RhYTQxNDFkOTk4NmU4ZGY3MzA4ZjFkN2ZiMTllMDNhOA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-12-07T02:58:36Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-12-07T02:58:36Z"}, "message": "[multiple changes]\n\n\n2001-12-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tlibstdc++/3720\n\t* include/bits/locale_facets.tcc (num_put): Clean.\n\t(num_get::_M_extract_float): Change argument to string.\n\t(num_get::do_get(float)): Fixup.\n\t(num_get::do_get(double)): Same.\n\t(num_get::do_get(long double)): Same.\n\t(num_get::_M_extract_int): Add maximum length parameter, __max.\n\t(num_get::_M_extract_float): Correct zeros, use string.\n\t* include/bits/locale_facets.h (num_get::_M_extract_float): Change\n\tdeclaration here.\n\t* src/locale.cc (__num_base::_S_atoms): Remove x, X.\n\t* testsuite/27_io/istream_extractor_arith.cc (test13): Add.\n\n2001-12-06  Philip Martin  <pmartin@uklinux.net>\n\n\t* testsuite/27_io/istream_extractor_arith.cc (test12): Add\n\ttests for excess input digits.\n\nFrom-SVN: r47743", "tree": {"sha": "74795169d392cf89d1d1f0c8a0dd317675d7b8cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74795169d392cf89d1d1f0c8a0dd317675d7b8cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/comments", "author": null, "committer": null, "parents": [{"sha": "a2b1e914592aebb8c495c7a7d5bc408d4cf368d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b1e914592aebb8c495c7a7d5bc408d4cf368d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b1e914592aebb8c495c7a7d5bc408d4cf368d3"}], "stats": {"total": 315, "additions": 226, "deletions": 89}, "files": [{"sha": "4348d33f44de79f43dd5379de196943df00454db", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "patch": "@@ -1,3 +1,23 @@\n+2001-12-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tlibstdc++/3720\n+\t* include/bits/locale_facets.tcc (num_put): Clean.\n+\t(num_get::_M_extract_float): Change argument to string. \n+\t(num_get::do_get(float)): Fixup.\n+\t(num_get::do_get(double)): Same.\n+\t(num_get::do_get(long double)): Same.\n+\t(num_get::_M_extract_int): Add maximum length parameter, __max.\n+\t(num_get::_M_extract_float): Correct zeros, use string.\n+\t* include/bits/locale_facets.h (num_get::_M_extract_float): Change\n+\tdeclaration here.\n+\t* src/locale.cc (__num_base::_S_atoms): Remove x, X.\n+\t* testsuite/27_io/istream_extractor_arith.cc (test13): Add.\n+\t\n+2001-12-06  Philip Martin  <pmartin@uklinux.net>\n+\n+\t* testsuite/27_io/istream_extractor_arith.cc (test12): Add\n+\ttests for excess input digits.\n+\n 2001-12-06  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* include/bits/std_bitset.h:  Use GLIBCPP in multiple-inclusion guard.\n@@ -42,7 +62,7 @@\n 2001-12-04  Paolo Carlini <pcarlini@unitus.it>\n \n         libstdc++/4402\n-        * testsuite/27_io/ostream_inserter_arith.cc (test02): add testcase\n+        * testsuite/27_io/ostream_inserter_arith.cc (test02): Add testcase\n \tfrom the PR.\n         * include/bits/locale_facets.tcc (num_put::_M_convert_float):\n         Deal properly with long ios_base::fixed floats."}, {"sha": "27bd5b15ac7ac48723389f79689bf335e65c083e", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "patch": "@@ -420,15 +420,15 @@ namespace std\n   {\n   public:\n     // String literal of acceptable (narrow) input, for num_get.\n-    // \"0123456789eEabcdfxABCDFX\"\n+    // \"0123456789eEabcdfABCDF\"\n     static const char _S_atoms[];\n \n     enum \n     {  \n       _M_zero,\n       _M_e = _M_zero + 10,\n       _M_E = _M_zero + 11,\n-      _M_size = 23 + 1\n+      _M_size = 21 + 1\n     };\n \n     // Construct and return valid scanf format for floating point types.\n@@ -634,11 +634,11 @@ namespace std\n \n       void \n       _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&, \n-\t\t       char* __xtrc) const;\n+\t\t       string& __xtrc) const;\n \n       void \n       _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&, \n-\t\t     char* __xtrc, int& __base) const;\n+\t\t     char* __xtrc, int __max, int& __base) const;\n \n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;"}, {"sha": "363ff8b54a0281d5b3d66d2a5a5bd2eff78bd4cb", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 122, "deletions": 83, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "patch": "@@ -35,6 +35,7 @@\n #include <bits/std_cerrno.h>\n #include <bits/std_clocale.h>   // For localeconv\n #include <bits/std_cstdlib.h>   // For strof, strtold\n+#include <bits/std_cmath.h>   // For ceil\n #include <bits/std_limits.h>    // For numeric_limits\n #include <bits/std_memory.h>    // For auto_ptr\n #include <bits/streambuf_iterator.h>     // For streambuf_iterators\n@@ -90,20 +91,21 @@ namespace std\n     void\n     num_get<_CharT, _InIter>::\n     _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,\n-\t\t     ios_base::iostate& __err, char* __xtrc) const\n+\t\t     ios_base::iostate& __err, string& __xtrc) const\n     {\n       const locale __loc = __io.getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n-      int __pos = 0;\n-      char_type  __c = *__beg;\n \n       // Check first for sign.\n       const char_type __plus = __ctype.widen('+');\n       const char_type __minus = __ctype.widen('-');\n+      int __pos = 0;\n+      char_type  __c = *__beg;\n       if ((__c == __plus || __c == __minus) && __beg != __end)\n \t{\n-\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t  __xtrc += __ctype.narrow(__c, char());\n+\t  ++__pos;\n \t  __c = *(++__beg);\n \t}\n \n@@ -116,7 +118,10 @@ namespace std\n \t  __found_zero = true;\n \t}\n       if (__found_zero)\n-\t__xtrc[__pos++] = _S_atoms[_M_zero];\n+\t{\n+\t  __xtrc += _S_atoms[_M_zero];\n+\t  ++__pos;\n+\t}\n \n       // Only need acceptable digits for floating point numbers.\n       const size_t __len = _M_E - _M_zero + 1;\n@@ -142,7 +147,8 @@ namespace std\n           if (__p && __c)\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n-\t      __xtrc[__pos++] = _S_atoms[__p - __watoms];\n+\t      ++__pos;\n+\t      __xtrc += _S_atoms[__p - __watoms];\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n \t    }\n@@ -165,21 +171,24 @@ namespace std\n \t  else if (__c == __dec && !__found_dec)\n \t    {\n \t      __found_grouping += static_cast<char>(__sep_pos);\n-\t      __xtrc[__pos++] = '.';\n+\t      ++__pos;\n+\t      __xtrc += '.';\n \t      __c = *(++__beg);\n \t      __found_dec = true;\n \t    }\n \t  else if ((__c == __watoms[_M_e] || __c == __watoms[_M_E]) \n \t\t   && !__found_sci && __pos)\n \t    {\n \t      // Scientific notation.\n-\t      __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t      ++__pos;\n+\t      __xtrc += __ctype.narrow(__c, char());\n \t      __c = *(++__beg);\n \n \t      // Remove optional plus or minus sign, if they exist.\n \t      if (__c == __plus || __c == __minus)\n \t\t{\n-\t\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t\t  ++__pos;\n+\t\t  __xtrc += __ctype.narrow(__c, char());\n \t\t  __c = *(++__beg);\n \t\t}\n \t      __found_sci = true;\n@@ -196,19 +205,12 @@ namespace std\n           // Add the ending grouping if a decimal wasn't found.\n \t  if (!__found_dec)\n \t    __found_grouping += static_cast<char>(__sep_pos);\n-\n           if (!__verify_grouping(__grouping, __found_grouping))\n-            {\n-              __err |= ios_base::failbit;\n-              __xtrc[__pos] = '\\0';\n-              if (__beg == __end)\n-                __err |= ios_base::eofbit;\n-              return;\n-            }\n+\t    __err |= ios_base::failbit;\n         }\n \n       // Finish up\n-      __xtrc[__pos] = char_type();\n+      __xtrc += char();\n       if (__beg == __end)\n         __err |= ios_base::eofbit;\n     }\n@@ -217,9 +219,15 @@ namespace std\n     void\n     num_get<_CharT, _InIter>::\n     _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n-\t\t   ios_base::iostate& __err, char* __xtrc, int& __base) const\n+\t\t   ios_base::iostate& __err, char* __xtrc, int __max, \n+\t\t   int& __base) const\n     {\n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+ \n       // Stage 1: determine a conversion specifier.\n+      // NB: Iff __basefield == 0, this can change based on contents.\n       ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n       if (__basefield == ios_base::oct)\n         __base = 8;\n@@ -228,38 +236,55 @@ namespace std\n       else\n \t__base = 10;\n \n-      const locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+     // Check first for sign.\n       int __pos = 0;\n       char_type  __c = *__beg;\n-\n-      // Check first for sign.\n       if ((__c == __ctype.widen('+') || __c == __ctype.widen('-'))\n \t  && __beg != __end)\n \t{\n \t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n \t  __c = *(++__beg);\n \t}\n \n-      // Next, strip leading zeros\n+      // Next, strip leading zeros and check required digits for base formats.\n       const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);\n-      bool __found_zero = false;\n-      while (__base == 10 && __c == __zero && __beg != __end)\n+      const char_type __x = __ctype.widen('x');\n+      const char_type __X = __ctype.widen('X');\n+      if (__base == 10)\n \t{\n-\t  __c = *(++__beg);\n-\t  __found_zero = true;\n+\t  bool __found_zero = false;\n+\t  while (__c == __zero && __beg != __end)\n+\t    {\n+\t      __c = *(++__beg);\n+\t      __found_zero = true;\n+\t    }\n+\t  if (__found_zero)\n+\t    {\n+\t      __xtrc[__pos++] = _S_atoms[_M_zero];\n+\t      if (__basefield == 0)\n+\t\t{\t      \n+\t\t  if ((__c == __x || __c == __X) && __beg != __end)\n+\t\t    {\n+\t\t      __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t\t      __c = *(++__beg);\n+\t\t      __base = 16;\n+\t\t    }\n+\t\t  else \n+\t\t    __base = 8;\n+\t\t}\n+\t    }\n \t}\n-      if (__found_zero)\n+      else if (__base == 16)\n \t{\n-\t  __xtrc[__pos++] = _S_atoms[_M_zero];\n-\t  if (__basefield == 0)\n+\t  if (__c == __zero && __beg != __end)\n \t    {\n-\t      // Depending on what is discovered, the base may change.\n-\t      if (__c == __ctype.widen('x') || __c == __ctype.widen('X'))\n-\t\t__base = 16;\n-\t      else\n-\t\t__base = 8;\n+\t      __xtrc[__pos++] = _S_atoms[_M_zero];\n+\t      __c = *(++__beg); \n+\t      if  ((__c == __x || __c == __X) && __beg != __end)\n+\t\t{\n+\t\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t\t  __c = *(++__beg);\n+\t\t}\n \t    }\n \t}\n \n@@ -271,14 +296,26 @@ namespace std\n       else\n \t__len = __base;\n \n-      char_type  __watoms[_M_size];\n+      // Figure out the maximum number of digits that can be extracted\n+      // for the given type, using the determined base.\n+      int __max_digits;\n+      if (__base != 10)\n+\t__max_digits = static_cast<int>(ceil(__max * log(10.0)\n+\t\t\t\t\t   /log(static_cast<double>(__base))));\n+      else \n+\t__max_digits = __max;\n+      // Add in what's already been extracted.\n+      __max_digits += __pos;\n+\n+      // Extract.\n+      char_type __watoms[_M_size];\n       __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);\n       string __found_grouping;\n       const string __grouping = __np.grouping();\n       bool __check_grouping = __grouping.size() && __base == 10;\n       int __sep_pos = 0;\n       const char_type __sep = __np.thousands_sep();\n-      while (__beg != __end)\n+      while (__beg != __end && __pos <= __max_digits)\n         {\n \t  typedef char_traits<_CharT> \t__traits_type;\n           const char_type* __p = __traits_type::find(__watoms, __len,  __c);\n@@ -312,25 +349,22 @@ namespace std\n \t    break;\n         }\n \n+      // If one more than the maximum number of digits is extracted.\n+      if (__pos > __max_digits)\n+\t__err |= ios_base::failbit;\n+\n       // Digit grouping is checked. If grouping and found_grouping don't\n       // match, then get very very upset, and set failbit.\n       if (__check_grouping && __found_grouping.size())\n         {\n-          // Add the ending grouping\n+          // Add the ending grouping.\n           __found_grouping += static_cast<char>(__sep_pos);\n-\n           if (!__verify_grouping(__grouping, __found_grouping))\n-            {\n-              __err |= ios_base::failbit;\n-              __xtrc[__pos] = '\\0';\n-              if (__beg == __end)\n-                __err |= ios_base::eofbit;\n-              return;\n-            }\n+\t    __err |= ios_base::failbit;\n         }\n \n       // Finish up\n-      __xtrc[__pos] = char_type();\n+      __xtrc[__pos] = char();\n       if (__beg == __end)\n         __err |= ios_base::eofbit;\n     }\n@@ -351,10 +385,11 @@ namespace std\n \n           // Stage 1: extract and determine the conversion specifier.\n           // Assuming leading zeros eliminated, thus the size of 32 for\n-          // integral types.\n-          char __xtrc[32] = {'\\0'};\n+          // integral types\n+          char __xtrc[32];\n           int __base;\n-          _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+          _M_extract_int(__beg, __end, __io, __err, __xtrc, \n+\t\t\t numeric_limits<bool>::digits10, __base);\n \n           // Stage 2: convert and store results.\n           char* __sanity;\n@@ -416,9 +451,10 @@ namespace std\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32]= {'\\0'};\n+      char __xtrc[32];\n       int __base;\n-      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, \n+\t\t     numeric_limits<long>::digits10, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -441,9 +477,10 @@ namespace std\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32]= {'\\0'};\n+      char __xtrc[32];\n       int __base;\n-      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, \n+\t\t     numeric_limits<unsigned short>::digits10, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -467,9 +504,10 @@ namespace std\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32]= {'\\0'};\n+      char __xtrc[32];\n       int __base;\n-      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, \n+\t\t     numeric_limits<unsigned int>::digits10, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -493,9 +531,10 @@ namespace std\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32] = {'\\0'};\n+      char __xtrc[32];\n       int __base;\n-      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, \n+\t\t     numeric_limits<unsigned long>::digits10, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -519,9 +558,10 @@ namespace std\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32]= {'\\0'};\n+      char __xtrc[32];\n       int __base;\n-      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, \n+\t\t     numeric_limits<long long>::digits10, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -544,9 +584,10 @@ namespace std\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32]= {'\\0'};\n+      char __xtrc[32];\n       int __base;\n-      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc,\n+\t\t     numeric_limits<unsigned long long>::digits10, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -568,21 +609,20 @@ namespace std\n \t   ios_base::iostate& __err, float& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n-      // Assuming leading zeros eliminated, thus the size of 256 for\n-      // floating-point types.\n-      char __xtrc[32]= {'\\0'};\n+      string __xtrc;\n+      __xtrc.reserve(32);\n       _M_extract_float(__beg, __end, __io, __err, __xtrc);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n #ifdef _GLIBCPP_USE_C99\n-      float __f = strtof(__xtrc, &__sanity);\n+      float __f = strtof(__xtrc.c_str(), &__sanity);\n #else\n-      float __f = static_cast<float>(strtod(__xtrc, &__sanity));\n+      float __f = static_cast<float>(strtod(__xtrc.c_str(), &__sanity));\n #endif\n       if (!(__err & ios_base::failbit)\n-          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+          && __sanity != __xtrc.c_str() && *__sanity == '\\0' && errno == 0)\n         __v = __f;\n       else\n         __err |= ios_base::failbit;\n@@ -596,17 +636,16 @@ namespace std\n            ios_base::iostate& __err, double& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n-      // Assuming leading zeros eliminated, thus the size of 256 for\n-      // floating-point types.\n-      char __xtrc[32]= {'\\0'};\n+      string __xtrc;\n+      __xtrc.reserve(32);\n       _M_extract_float(__beg, __end, __io, __err, __xtrc);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n-      double __d = strtod(__xtrc, &__sanity);\n+      double __d = strtod(__xtrc.c_str(), &__sanity);\n       if (!(__err & ios_base::failbit)\n-          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+          && __sanity != __xtrc.c_str() && *__sanity == '\\0' && errno == 0)\n         __v = __d;\n       else\n         __err |= ios_base::failbit;\n@@ -620,18 +659,17 @@ namespace std\n            ios_base::iostate& __err, long double& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n-      // Assuming leading zeros eliminated, thus the size of 256 for\n-      // floating-point types.\n-      char __xtrc[32]= {'\\0'};\n+      string __xtrc;\n+      __xtrc.reserve(32);\n       _M_extract_float(__beg, __end, __io, __err, __xtrc);\n \n #if defined(_GLIBCPP_USE_C99) && !defined(__hpux)\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n-      long double __ld = strtold(__xtrc, &__sanity);\n+      long double __ld = strtold(__xtrc.c_str(), &__sanity);\n       if (!(__err & ios_base::failbit)\n-          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+          && __sanity != __xtrc.c_str() && *__sanity == '\\0' && errno == 0)\n         __v = __ld;\n #else\n       // Stage 2: determine a conversion specifier.\n@@ -649,7 +687,7 @@ namespace std\n       // Stage 3: store results.\n       typedef typename char_traits<_CharT>::int_type int_type;\n       long double __ld;\n-      int __p = sscanf(__xtrc, __conv, &__ld);\n+      int __p = sscanf(__xtrc.c_str(), __conv, &__ld);\n       if (!(__err & ios_base::failbit) && __p \n \t  && static_cast<int_type>(__p) != char_traits<_CharT>::eof())\n         __v = __ld;\n@@ -675,9 +713,10 @@ namespace std\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32]= {'\\0'};\n+      char __xtrc[32];\n       int __base;\n-      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, \n+\t\t     numeric_limits<unsigned long>::digits10, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;"}, {"sha": "2a16a3aeed21499a69a0969ae79350062bcf607c", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "patch": "@@ -74,7 +74,7 @@ namespace std\n   // Definitions for static const data members of locale::id\n   size_t locale::id::_S_highwater;  // init'd to 0 by linker\n \n-  const char __num_base::_S_atoms[] = \"0123456789eEabcdfxABCDFX\";\n+  const char __num_base::_S_atoms[] = \"0123456789eEabcdfABCDF\";\n \n   // Definitions for static const data members of locale::_Impl\n   const locale::id* const"}, {"sha": "9a8537e82f837c225d96b05e9fd92a2a123f0af0", "filename": "libstdc++-v3/testsuite/27_io/istream_extractor_arith.cc", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823b4f7daa4141d9986e8df7308f1d7fb19e03a8/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc?ref=823b4f7daa4141d9986e8df7308f1d7fb19e03a8", "patch": "@@ -513,6 +513,83 @@ bool test11()\n   return test;\n }\n \n+// libstdc++/3720\n+// excess input should not cause a core dump\n+template<typename T>\n+bool test12_aux(bool integer_type)\n+{\n+  bool test = true;\n+  \n+  int digits_overflow;\n+  if (integer_type)\n+    // This many digits will overflow integer types in base 10.\n+    digits_overflow = std::numeric_limits<T>::digits10 + 1;\n+  else\n+    // This might do it, unsure.\n+    digits_overflow = std::numeric_limits<T>::max_exponent10 + 1;\n+  \n+  std::string st;\n+  std::string part = \"1234567890123456789012345678901234567890\";\n+  for (int i = 0; i < digits_overflow / part.size() + 1; ++i)\n+    st += part;\n+  std::stringbuf sb(st);\n+  std::istream is(&sb);\n+  T t;\n+  is >> t;\n+  VERIFY(is.fail());\n+  return test;\n+}\n+\n+bool test12()\n+{\n+  bool test = true;\n+  VERIFY(test12_aux<short>(true));\n+  VERIFY(test12_aux<int>(true));\n+  VERIFY(test12_aux<long>(true));\n+  VERIFY(test12_aux<float>(false));\n+  VERIFY(test12_aux<double>(false));\n+  VERIFY(test12_aux<long double>(false));\n+  return test;\n+}\n+\n+// libstdc++/3720 part two\n+void test13()\n+{\n+  using namespace std;\n+  bool test = true;\n+  const char* l1 = \"12345678901234567890123456789012345678901234567890123456\";\n+  const char* l2 = \"1.2345678901234567890123456789012345678901234567890123456\"\n+                   \"  \"\n+                   \"1246.9\";\n+\n+  // 1 \n+  // used to core.\n+  double d;\n+  istringstream iss1(l2);\n+  iss1 >> d;\n+  iss1 >> d;\n+  VERIFY (d > 1246 && d < 1247);\n+\n+  // 2\n+  // quick test for failbit on maximum length extraction.\n+  int i;\n+  int max_digits = numeric_limits<int>::digits10;\n+  string digits;\n+  for (int j = 0; j < max_digits; ++j)\n+    digits += '1';\n+  istringstream iss2(digits);\n+  iss2 >> i;\n+  VERIFY( iss2.good() );\n+\n+  digits += '1';\n+  i = 0;\n+  iss2.str(digits);\n+  iss2.clear();\n+  iss2 >> i; \n+  VERIFY( i == 0 );\n+  VERIFY( iss2.fail() );\n+}\n+\n int main()\n {\n   test01();\n@@ -526,6 +603,7 @@ int main()\n   test10();\n   \n   test11();\n+  test12();\n   return 0;\n }\n "}]}