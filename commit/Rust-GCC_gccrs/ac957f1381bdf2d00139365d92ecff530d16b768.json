{"sha": "ac957f1381bdf2d00139365d92ecff530d16b768", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5NTdmMTM4MWJkZjJkMDAxMzkzNjVkOTJlY2ZmNTMwZDE2Yjc2OA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-12-09T08:20:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-09T08:20:07Z"}, "message": "* Partially cleaned up prototyping code from HJ.\n\n        * haifa-sched.c (haifa_classify_insn): Renamed from classify_insn.\n        All references changed.\n        * rtl.h: Protect from multiple inclusions.  Add many prototypes.\n\n        * libgcc2.c (string.h): Hoist inclusion to occur before first use of\n        string functions like strlen.\nMore pending patches.\n\nFrom-SVN: r17024", "tree": {"sha": "27428732fdaadeadefb7dd0fb50033ad0600a164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27428732fdaadeadefb7dd0fb50033ad0600a164"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac957f1381bdf2d00139365d92ecff530d16b768", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac957f1381bdf2d00139365d92ecff530d16b768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac957f1381bdf2d00139365d92ecff530d16b768", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac957f1381bdf2d00139365d92ecff530d16b768/comments", "author": null, "committer": null, "parents": [{"sha": "0a232106fc0b44b5174f179c4efffbc11b186b92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a232106fc0b44b5174f179c4efffbc11b186b92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a232106fc0b44b5174f179c4efffbc11b186b92"}], "stats": {"total": 368, "additions": 348, "deletions": 20}, "files": [{"sha": "6bd20f8a5923d6e4bfc079a8650a6f6a7d0ff81f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac957f1381bdf2d00139365d92ecff530d16b768", "patch": "@@ -1,3 +1,15 @@\n+Tue Dec  9 01:16:06 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Partially cleaned up prototyping code from HJ.\n+\t* haifa-sched.c (haifa_classify_insn): Renamed from classify_insn.\n+\tAll references changed.\n+\t* rtl.h: Protect from multiple inclusions.  Add many prototypes.\n+\t\n+Tue Dec  9 01:15:15 199  Fred Fish  <fnf@ninemoons.com>7\n+\n+\t* libgcc2.c (string.h): Hoist inclusion to occur before first use of\n+\tstring functions like strlen.\n+\n Tue Dec  9 00:57:38 1997  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* configure.in: Check for functions getrlimit and setrlimit."}, {"sha": "ab8fbc2d7696b6fe97fbde442e0aae0b58b11b52", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ac957f1381bdf2d00139365d92ecff530d16b768", "patch": "@@ -714,7 +714,7 @@ static int is_pfree PROTO ((rtx, int, int));\n static int find_conditional_protection PROTO ((rtx, int));\n static int is_conditionally_protected PROTO ((rtx, int, int));\n static int may_trap_exp PROTO ((rtx, int));\n-static int classify_insn PROTO ((rtx));\n+static int haifa_classify_insn PROTO ((rtx));\n static int is_exception_free PROTO ((rtx, int, int));\n \n static char find_insn_mem_list PROTO ((rtx, rtx, rtx, rtx));\n@@ -2558,7 +2558,7 @@ is_pfree (load_insn, bb_src, bb_trg)\n \t      if (GET_MODE (fore_link) == VOIDmode)\n \t\t{\n \t\t  /* found a DEF-USE dependence (insn1, insn2) */\n-\t\t  if (classify_insn (insn2) != PFREE_CANDIDATE)\n+\t\t  if (haifa_classify_insn (insn2) != PFREE_CANDIDATE)\n \t\t    /* insn2 not guaranteed to be a 1 base reg load */\n \t\t    continue;\n \n@@ -2659,7 +2659,7 @@ may_trap_exp (x, is_store)\n    being either PFREE or PRISKY.  */\n \n static int\n-classify_insn (insn)\n+haifa_classify_insn (insn)\n      rtx insn;\n {\n   rtx pat = PATTERN (insn);\n@@ -2721,7 +2721,7 @@ classify_insn (insn)\n \n   return insn_class;\n \n-}\t\t\t\t/* classify_insn */\n+}\t\t\t\t/* haifa_classify_insn */\n \n /* Return 1 if load_insn is prisky (i.e. if load_insn is fed by\n    a load moved speculatively, or if load_insn is protected by\n@@ -2754,7 +2754,7 @@ is_exception_free (insn, bb_src, bb_trg)\n      rtx insn;\n      int bb_src, bb_trg;\n {\n-  int insn_class = classify_insn (insn);\n+  int insn_class = haifa_classify_insn (insn);\n \n   /* handle non-load insns */\n   switch (insn_class)"}, {"sha": "5a1273995aa66edc7c0e737ddac19b655c12dc19", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=ac957f1381bdf2d00139365d92ecff530d16b768", "patch": "@@ -1446,6 +1446,7 @@ char *ctime ();\n \n #include \"gbl-ctors.h\"\n #include \"gcov-io.h\"\n+#include <string.h>\n \n static struct bb *bb_head;\n \n@@ -1723,8 +1724,6 @@ __bb_init_func (struct bb *blocks)\n #define MACHINE_STATE_RESTORE(ID)\n #endif\n \n-#include <string.h>\n-\n /* Number of buckets in hashtable of basic block addresses.  */\n \n #define BB_BUCKETS 311"}, {"sha": "47cc556ee8b560b392f074eb9df0c7da593ecb79", "filename": "gcc/rtl.h", "status": "modified", "additions": 330, "deletions": 13, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac957f1381bdf2d00139365d92ecff530d16b768/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ac957f1381bdf2d00139365d92ecff530d16b768", "patch": "@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef _RTL_H\n+#define _RTL_H\n \n #include \"machmode.h\"\n \n@@ -662,9 +664,14 @@ extern char *note_insn_name[];\n    defined here and in tree.h.  */\n \n #ifndef exact_log2\n-#define exact_log2(N) exact_log2_wide ((HOST_WIDE_INT) (N))\n-#define floor_log2(N) floor_log2_wide ((HOST_WIDE_INT) (N))\n+#define exact_log2(N) exact_log2_wide ((unsigned HOST_WIDE_INT) (N))\n+#define floor_log2(N) floor_log2_wide ((unsigned HOST_WIDE_INT) (N))\n #endif\n+extern int exact_log2_wide\t\tPROTO((unsigned HOST_WIDE_INT));\n+extern int floor_log2_wide\t\tPROTO((unsigned HOST_WIDE_INT));\n+\n+/* In expmed.c */\n+extern int ceil_log2\t\t\tPROTO((unsigned HOST_WIDE_INT));\n \n #define plus_constant(X,C) plus_constant_wide (X, (HOST_WIDE_INT) (C))\n \n@@ -676,7 +683,9 @@ extern rtx plus_constant_for_output_wide PROTO((rtx, HOST_WIDE_INT));\n \n #define GEN_INT(N) gen_rtx (CONST_INT, VOIDmode, (HOST_WIDE_INT) (N))\n \n-extern rtx bc_gen_rtx ();\n+struct bc_label;\n+extern rtx bc_gen_rtx\t\t\tPROTO ((char *, int,\n+\t\t\t\t\t\tstruct bc_label *));\n \n extern rtx gen_rtx\t\t\tPVPROTO((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, ...));\n@@ -818,7 +827,7 @@ extern int side_effects_p\tPROTO((rtx));\n extern int volatile_refs_p\tPROTO((rtx));\n extern int volatile_insn_p\tPROTO((rtx));\n extern void remove_note\t\tPROTO((rtx, rtx));\n-extern void note_stores\t\tPROTO((rtx, void (*)()));\n+extern void note_stores\t\tPROTO((rtx, void (*) (rtx, rtx)));\n extern int refers_to_regno_p\tPROTO((int, int, rtx, rtx *));\n extern int reg_overlap_mentioned_p PROTO((rtx, rtx));\n extern rtx find_use_as_address\tPROTO((rtx, rtx, HOST_WIDE_INT));\n@@ -860,6 +869,7 @@ extern int may_trap_p\t\t\tPROTO((rtx));\n extern int inequality_comparison_p\tPROTO((rtx));\n extern rtx replace_rtx\t\t\tPROTO((rtx, rtx, rtx));\n extern rtx replace_regs\t\t\tPROTO((rtx, rtx *, int, int));\n+extern int computed_jump_p\t\tPROTO((rtx));\n \n /* Maximum number of parallel sets and clobbers in any insn in this fn.\n    Always at least 3, since the combiner could put that many togetherm\n@@ -1016,12 +1026,319 @@ extern char *regno_pointer_align;\n \n extern int rtx_to_tree_code\tPROTO((enum rtx_code));\n \n-extern int true_dependence\tPROTO((rtx, enum machine_mode, rtx, int (*)()));\n-extern int read_dependence\tPROTO((rtx, rtx));\n-extern int anti_dependence\tPROTO((rtx, rtx));\n-extern int output_dependence\tPROTO((rtx, rtx));\n-extern void init_alias_analysis\tPROTO((void));\n-extern void end_alias_analysis\tPROTO((void));\n-extern void mark_user_reg\tPROTO((rtx));\n-extern void mark_reg_pointer\tPROTO((rtx, int));\n-extern int computed_jump_p\tPROTO((rtx));\n+/* In rtlanal.c */\n+extern int reg_set_p\t\t\tPROTO ((rtx, rtx));\n+extern int reg_mentioned_p\t\tPROTO ((rtx, rtx));\n+extern int reg_referenced_p\t\tPROTO ((rtx, rtx));\n+extern int reg_used_between_p\t\tPROTO ((rtx, rtx, rtx));\n+extern int reg_set_p\t\t\tPROTO ((rtx, rtx));\n+extern int reg_referenced_between_p\tPROTO ((rtx, rtx, rtx));\n+extern int reg_set_between_p\t\tPROTO ((rtx, rtx, rtx));\n+extern int rtx_unstable_p\t\tPROTO ((rtx));\n+extern int rtx_addr_varies_p\t\tPROTO ((rtx));\n+extern int rtx_equal_p\t\t\tPROTO ((rtx, rtx));\n+extern int inequality_comparisons_p\tPROTO ((rtx));\n+extern int dead_or_set_p\t\tPROTO ((rtx, rtx));\n+extern int dead_or_set_regno_p\t\tPROTO ((rtx, int));\n+extern int no_labels_between_p\t\tPROTO ((rtx, rtx));\n+extern int modified_between_p\t\tPROTO ((rtx, rtx, rtx));\n+extern int modified_in_p\t\tPROTO ((rtx, rtx));\n+\n+/* In tree.c */\n+extern void obfree\t\t\tPROTO ((char *));\n+struct obstack;\n+extern void gcc_obstack_init\t\tPROTO ((struct obstack *));\n+extern void pop_obstacks\t\tPROTO ((void));\n+extern void push_obstacks\t\tPROTO ((struct obstack *,\n+\t\t\t\t\t\tstruct obstack *));\n+#ifdef BUFSIZ\n+extern int read_skip_spaces\t\tPROTO ((FILE *));\n+#endif\n+\n+/* In cse.c */\n+struct cse_basic_block_data;\n+extern int rtx_cost\t\t\tPROTO ((rtx, enum rtx_code));\n+extern void delete_dead_from_cse\tPROTO ((rtx, int));\n+#ifdef BUFSIZ\n+extern int cse_main\t\t\tPROTO ((rtx, int, int, FILE *));\n+#endif\n+extern void cse_end_of_basic_block\tPROTO ((rtx,\n+\t\t\t\t\t\tstruct cse_basic_block_data *,\n+\t\t\t\t\t\tint, int, int));\n+\n+/* In jump.c */\n+extern int comparison_dominates_p\tPROTO ((enum rtx_code, enum rtx_code));\n+extern int condjump_p\t\t\tPROTO ((rtx));\n+extern int simplejump_p\t\t\tPROTO ((rtx));\n+extern int sets_cc0_p\t\t\tPROTO ((rtx));\n+extern int invert_jump\t\t\tPROTO ((rtx, rtx));\n+extern int rtx_renumbered_equal_p\tPROTO ((rtx, rtx));\n+extern int true_regnum\t\t\tPROTO ((rtx));\n+extern int redirect_jump\t\tPROTO ((rtx, rtx));\n+extern void jump_optimize\t\tPROTO ((rtx, int, int, int));\n+extern void thread_jumps\t\tPROTO ((rtx, int, int));\n+extern int redirect_exp\t\t\tPROTO ((rtx *, rtx, rtx, rtx));\n+extern int rtx_equal_for_thread_p\tPROTO ((rtx, rtx, rtx));\n+extern int invert_exp\t\t\tPROTO ((rtx, rtx));\n+extern int can_reverse_comparison_p\tPROTO ((rtx, rtx));\n+extern void delete_for_peephole\t\tPROTO ((rtx, rtx));\n+extern int condjump_in_parallel_p\tPROTO ((rtx));\n+\n+/* In emit-rtl.c. */\n+extern int max_reg_num\t\t\t\tPROTO ((void));\n+extern int max_label_num\t\t\tPROTO ((void));\n+extern int get_first_label_num\t\t\tPROTO ((void));\n+extern void delete_insns_since\t\t\tPROTO ((rtx));\n+extern void mark_reg_pointer\t\t\tPROTO ((rtx, int));\n+extern void mark_user_reg\t\t\tPROTO ((rtx));\n+extern void reset_used_flags\t\t\tPROTO ((rtx));\n+extern void reorder_insns\t\t\tPROTO ((rtx, rtx, rtx));\n+extern int get_max_uid\t\t\t\tPROTO ((void));\n+extern int in_sequence_p\t\t\tPROTO ((void));\n+extern void force_next_line_note\t\tPROTO ((void));\n+extern void init_emit\t\t\t\tPROTO ((void));\n+extern void init_emit_once\t\t\tPROTO ((int));\n+extern void push_topmost_sequence\t\tPROTO ((void));\n+extern void pop_topmost_sequence\t\tPROTO ((void));\n+extern int subreg_realpart_p\t\t\tPROTO ((rtx));\n+extern void reverse_comparison\t\t\tPROTO ((rtx));\n+extern void set_new_first_and_last_insn\t\tPROTO ((rtx, rtx));\n+extern void set_new_first_and_last_label_num\tPROTO ((int, int));\n+extern void unshare_all_rtl\t\t\tPROTO ((rtx));\n+extern void set_last_insn\t\t\tPROTO ((rtx));\n+extern void link_cc0_insns\t\t\tPROTO ((rtx));\n+extern void add_insn\t\t\t\tPROTO ((rtx));\n+extern void add_insn_before\t\t\tPROTO ((rtx, rtx));\n+extern void add_insn_after\t\t\tPROTO ((rtx, rtx));\n+extern void reorder_insns_with_line_notes\tPROTO ((rtx, rtx, rtx));\n+extern void emit_insn_after_with_line_notes\tPROTO ((rtx, rtx, rtx));\n+extern enum rtx_code classify_insn\t\tPROTO ((rtx));\n+extern rtx emit\t\t\t\t\tPROTO ((rtx));\n+\n+/* In insn-emit.c */\n+extern void add_clobbers\t\tPROTO ((rtx, int));\n+\n+/* In combine.c */\n+extern void combine_instructions\tPROTO ((rtx, int));\n+extern int extended_count\t\tPROTO ((rtx, enum machine_mode, int));\n+extern rtx remove_death\t\t\tPROTO ((int, rtx));\n+#ifdef BUFSIZ\n+extern void dump_combine_stats\t\tPROTO ((FILE *));\n+extern void dump_combine_total_stats\tPROTO ((FILE *));\n+#endif\n+\n+/* In sched.c. */\n+#ifdef BUFSIZ\n+extern void schedule_insns\t\tPROTO ((FILE *));\n+#endif\n+\n+/* In print-rtl.c */\n+extern void debug_rtx\t\t\tPROTO ((rtx));\n+extern void debug_rtx_list\t\tPROTO ((rtx, int));\n+extern rtx debug_rtx_find\t\tPROTO ((rtx, int));\n+#ifdef BUFSIZ\n+extern void print_rtl\t\t\tPROTO ((FILE *, rtx));\n+extern void print_inline_rtx\t\tPROTO ((FILE *, rtx, int));\n+#endif\n+\n+/* In loop.c */\n+extern void init_loop\t\t\tPROTO ((void));\n+#ifdef BUFSIZ\n+extern void loop_optimize\t\tPROTO ((rtx, FILE *, int));\n+#endif\n+extern void record_excess_regs\t\tPROTO ((rtx, rtx, rtx *));\n+\n+/* In function.c */\n+extern void reposition_prologue_and_epilogue_notes\tPROTO ((rtx));\n+extern void thread_prologue_and_epilogue_insns\t\tPROTO ((rtx));\n+extern void use_variable\t\t\t\tPROTO ((rtx));\n+extern HOST_WIDE_INT get_frame_size\t\t\tPROTO ((void));\n+extern void preserve_rtl_expr_result\t\t\tPROTO ((rtx));\n+extern void mark_temp_addr_taken\t\t\tPROTO ((rtx));\n+extern void update_temp_slot_address\t\t\tPROTO ((rtx, rtx));\n+extern void use_variable_after\t\t\t\tPROTO ((rtx, rtx));\n+\n+/* In reload.c */\n+extern int operands_match_p\t\tPROTO ((rtx, rtx));\n+extern int safe_from_earlyclobber\tPROTO ((rtx, rtx));\n+extern int strict_memory_address_p\tPROTO ((enum machine_mode, rtx));\n+\n+/* In recog.c */\n+extern int memory_address_p\t\tPROTO ((enum machine_mode, rtx));\n+extern int constrain_operands\t\tPROTO ((int, int));\n+extern int mode_dependent_address_p\tPROTO ((rtx));\n+extern void init_recog_no_volatile\tPROTO ((void));\n+extern int offsettable_memref_pq\tPROTO ((rtx));\n+extern int offsettable_nonstrict_memref_p PROTO ((rtx));\n+extern int reg_fits_class_p\t\tPROTO ((rtx, register enum reg_class,\n+\t\t\t\t\t\tint, enum machine_mode));\n+extern int check_asm_operands\t\tPROTO ((rtx));\n+extern int address_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int const_int_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int const_double_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int general_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int immediate_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int nonimmediate_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int memory_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int nonmemory_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int push_operand\t\t\tPROTO ((rtx, enum machine_mode));\n+extern int register_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int scratch_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int indirect_operand\t\tPROTO ((rtx, enum machine_mode));\n+extern int mode_independent_operand\tPROTO ((rtx, enum machine_mode));\n+extern int comparison_operator\t\tPROTO ((rtx, enum machine_mode));\n+extern void init_recog_no_volatile\tPROTO ((void));\n+extern void init_recog\t\t\tPROTO ((void));\n+extern int validate_replace_rtx\t\tPROTO ((rtx, rtx, rtx));\n+extern int offsettable_address_p\tPROTO ((int, enum machine_mode, rtx));\n+extern int next_insn_tests_no_inequality PROTO ((rtx));\n+extern int recog_memoized\t\tPROTO ((rtx));\n+extern int validate_change\t\tPROTO ((rtx, rtx *, rtx, int));\n+extern int apply_change_group\t\tPROTO ((void));\n+extern void cancel_changes\t\tPROTO ((int));\n+extern int num_validated_changes\tPROTO ((void));\n+\n+/* In insn-recog.c */\n+extern int recog\t\t\tPROTO ((rtx, rtx, int *));\n+\n+/* In stmt.c */\n+extern void emit_jump\t\t\tPROTO ((rtx));\n+extern int preserve_subexpressions_p\tPROTO ((void));\n+\n+/* In expr.c */\n+extern rtx bc_allocate_local\t\tPROTO ((int, int));\n+extern void init_expr_once\t\tPROTO ((void));\n+\n+/* In stupid.c */\n+#ifdef BUFSIZ\n+extern void stupid_life_analysis\tPROTO ((rtx, int, FILE *));\n+#endif\n+\n+/* In flow.c */\n+extern void allocate_for_life_analysis\tPROTO ((void));\n+#ifdef BUFSIZ\n+extern void dump_flow_info\t\tPROTO ((FILE *));\n+#endif\n+\n+/* In expmed.c */\n+extern void init_expmed\t\t\tPROTO ((void));\n+extern void expand_inc\t\t\tPROTO ((rtx, rtx));\n+extern void expand_dec\t\t\tPROTO ((rtx, rtx));\n+extern rtx expand_mult_highpart\t\tPROTO ((enum machine_mode, rtx,\n+\t\t\t\t\t\tunsigned HOST_WIDE_INT, rtx,\n+\t\t\t\t\t\tint, int));\n+\n+/* In toplev.c */\n+extern void strip_off_ending\t\tPROTO ((char *, int));\n+extern void print_time\t\t\tPROTO ((char *, int));\n+extern int get_run_time\t\t\tPROTO ((void));\n+#if 0\n+extern void fatal\t\t\tPVPROTO ((char *, ...));\n+extern void warning\t\t\tPVPROTO ((char *, ...));\n+extern void error\t\t\tPVPROTO ((char *, ...));\n+#endif\n+extern void pfatal_with_name\t\tPROTO ((char *));\n+extern void fancy_abort\t\t\tPROTO ((void));\n+extern int count_error\t\t\tPROTO ((int));\n+extern void pedwarn\t\t\tPVPROTO ((char *, ...));\n+extern void warning_for_asm\t\tPVPROTO ((rtx, char *, ...));\n+extern void error_for_asm\t\tPVPROTO ((rtx, char *, ...));\n+\n+/* In global.c */\n+#ifdef BUFSIZ\n+extern int global_alloc\t\t\tPROTO ((FILE *));\n+extern void dump_global_regs\t\tPROTO ((FILE *));\n+#endif\n+\n+/* In regclass.c */\n+extern void globalize_reg\t\tPROTO ((int));\n+extern void init_regs\t\t\tPROTO ((void));\n+extern void init_reg_sets\t\tPROTO ((void));\n+extern void regset_release_memory\tPROTO ((void));\n+extern void regclass_init\t\tPROTO ((void));\n+extern void regclass\t\t\tPROTO ((rtx, int));\n+extern void reg_scan\t\t\tPROTO ((rtx, int, int));\n+extern void fix_register\t\tPROTO ((char *, int, int));\n+\n+/* In optabs.c */\n+extern void init_optabs\t\t\tPROTO ((void));\n+\n+/* In local-alloc.c */\n+#ifdef BUFSIZ\n+extern void dump_local_alloc\t\tPROTO ((FILE *));\n+#endif\n+extern void local_alloc\t\t\tPROTO ((void));\n+\n+/* In reload1.c */\n+extern void reload_cse_regs\t\tPROTO ((rtx));\n+extern void init_reload\t\t\tPROTO ((void));\n+extern void mark_home_live\t\tPROTO ((int));\n+#ifdef BUFSIZ\n+extern int reload\t\t\tPROTO ((rtx, int, FILE *));\n+#endif\n+\n+/* In caller-save.c */\n+extern void init_caller_save\t\tPROTO ((void));\n+\n+/* In profile.c */\n+extern void init_branch_prob\t\tPROTO ((char *));\n+\n+/* In reg-stack.c */\n+#ifdef BUFSIZ\n+extern void reg_to_stack\t\tPROTO ((rtx, FILE *));\n+#endif\n+extern int stack_regs_mentioned_p\tPROTO ((rtx));\n+\n+/* In fold-const.c */\n+extern int add_double\t\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n+extern int neg_double\t\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n+extern int mul_double\t\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n+extern void lshift_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n+\t\t\t\t\tHOST_WIDE_INT *, int));\n+extern void rshift_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT, int,\n+\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *, int));\n+extern void lrotate_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n+\t\t\t\t\tHOST_WIDE_INT *));\n+extern void rrotate_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n+\t\t\t\t\tHOST_WIDE_INT *));\n+\n+/* In calls.c */\n+/* Emit library call.  */                                           \n+extern void emit_library_call\t\tPVPROTO ((rtx, int, enum machine_mode,\n+\t\t\t\t\t\t  int, ...));\n+extern rtx emit_library_call_value\tPVPROTO((rtx, rtx, int,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t int, ...));\n+\n+/* In unroll.c */\n+extern int set_dominates_use\t\tPROTO ((int, int, int, rtx, rtx));\n+\n+/* In varasm.c */\n+extern void bss_section\t\t\tPROTO ((void));\n+extern int in_data_section\t\tPROTO ((void));\n+extern int supports_one_only\t\tPROTO ((void));\n+\n+/* In rtl.c */\n+extern void init_rtl\t\t\tPROTO ((void));\n+extern void rtx_free\t\t\tPROTO ((rtx));\n+\n+/* In alias.c */\n+extern int true_dependence\t\tPROTO ((rtx, enum machine_mode, rtx,\n+\t\t\t\t\t\tint (*)(rtx)));\n+extern int read_dependence\t\tPROTO ((rtx, rtx));\n+extern int anti_dependence\t\tPROTO ((rtx, rtx));\n+extern int output_dependence\t\tPROTO ((rtx, rtx));\n+extern void init_alias_analysis\t\tPROTO ((void));\n+extern void end_alias_analysis\t\tPROTO ((void));\n+\n+#endif /* _RTL_H */\n+"}]}