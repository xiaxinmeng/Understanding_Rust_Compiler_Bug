{"sha": "0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZkYzMwYmNmNTZkN2I0NjEyMmQ3ZTY3ZDYxYjU2YzBhMTk4ZjNiMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-15T08:47:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-15T08:47:25Z"}, "message": "[AArch64] Rework SVE INC/DEC handling\n\nThe scalar addition patterns allowed all the VL constants that\nADDVL and ADDPL allow, but wrote the instructions as INC or DEC\nif possible (i.e. adding or subtracting a number of elements * [1, 16]\nwhen the source and target registers the same).  That works for the\ncases that the autovectoriser needs, but there are a few constants\nthat INC and DEC can handle but ADDPL and ADDVL can't.  E.g.:\n\n        inch    x0, all, mul #9\n\nis not a multiple of the number of bytes in an SVE register, and so\ncan't use ADDVL.  It represents 36 times the number of bytes in an\nSVE predicate, putting it outside the range of ADDPL.\n\nThis patch therefore adds separate alternatives for INC and DEC,\ntied to a new Uai constraint.  It also adds an explicit \"scalar\"\nor \"vector\" to the function names, to avoid a clash with the\nexisting support for vector INC and DEC.\n\n2019-08-15  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_sve_scalar_inc_dec_immediate_p): Declare.\n\t(aarch64_sve_inc_dec_immediate_p): Rename to...\n\t(aarch64_sve_vector_inc_dec_immediate_p): ...this.\n\t(aarch64_output_sve_addvl_addpl): Take a single rtx argument.\n\t(aarch64_output_sve_scalar_inc_dec): Declare.\n\t(aarch64_output_sve_inc_dec_immediate): Rename to...\n\t(aarch64_output_sve_vector_inc_dec): ...this.\n\t* config/aarch64/aarch64.c (aarch64_sve_scalar_inc_dec_immediate_p)\n\t(aarch64_output_sve_scalar_inc_dec): New functions.\n\t(aarch64_output_sve_addvl_addpl): Remove the base and offset\n\targuments.  Only handle true ADDVL and ADDPL instructions;\n\tdon't emit an INC or DEC.\n\t(aarch64_sve_inc_dec_immediate_p): Rename to...\n\t(aarch64_sve_vector_inc_dec_immediate_p): ...this.\n\t(aarch64_output_sve_inc_dec_immediate): Rename to...\n\t(aarch64_output_sve_vector_inc_dec): ...this.  Update call to\n\taarch64_sve_vector_inc_dec_immediate_p.\n\t* config/aarch64/predicates.md (aarch64_sve_scalar_inc_dec_immediate)\n\t(aarch64_sve_plus_immediate): New predicates.\n\t(aarch64_pluslong_operand): Accept aarch64_sve_plus_immediate\n\trather than aarch64_sve_addvl_addpl_immediate.\n\t(aarch64_sve_inc_dec_immediate): Rename to...\n\t(aarch64_sve_vector_inc_dec_immediate): ...this.  Update call to\n\taarch64_sve_vector_inc_dec_immediate_p.\n\t(aarch64_sve_add_operand): Update accordingly.\n\t* config/aarch64/constraints.md (Uai): New constraint.\n\t(vsi): Update call to aarch64_sve_vector_inc_dec_immediate_p.\n\t* config/aarch64/aarch64.md (add<GPI:mode>3): Don't force the second\n\toperand into a register if it satisfies aarch64_sve_plus_immediate.\n\t(*add<GPI:mode>3_aarch64, *add<GPI:mode>3_poly_1): Add an alternative\n\tfor Uai.  Update calls to aarch64_output_sve_addvl_addpl.\n\t* config/aarch64/aarch64-sve.md (add<mode>3): Call\n\taarch64_output_sve_vector_inc_dec instead of\n\taarch64_output_sve_inc_dec_immediate.\n\nFrom-SVN: r274518", "tree": {"sha": "2586c74f745eb5efeec23294c29e156dfd1d7e9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2586c74f745eb5efeec23294c29e156dfd1d7e9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d7a09c445a475a95559e8b9f29eb06ad92effa91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a09c445a475a95559e8b9f29eb06ad92effa91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a09c445a475a95559e8b9f29eb06ad92effa91"}], "stats": {"total": 158, "additions": 116, "deletions": 42}, "files": [{"sha": "c3aa1130b6e9d9bb0fd617ded8913257cea37dcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "patch": "@@ -1,3 +1,41 @@\n+2019-08-15  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_sve_scalar_inc_dec_immediate_p): Declare.\n+\t(aarch64_sve_inc_dec_immediate_p): Rename to...\n+\t(aarch64_sve_vector_inc_dec_immediate_p): ...this.\n+\t(aarch64_output_sve_addvl_addpl): Take a single rtx argument.\n+\t(aarch64_output_sve_scalar_inc_dec): Declare.\n+\t(aarch64_output_sve_inc_dec_immediate): Rename to...\n+\t(aarch64_output_sve_vector_inc_dec): ...this.\n+\t* config/aarch64/aarch64.c (aarch64_sve_scalar_inc_dec_immediate_p)\n+\t(aarch64_output_sve_scalar_inc_dec): New functions.\n+\t(aarch64_output_sve_addvl_addpl): Remove the base and offset\n+\targuments.  Only handle true ADDVL and ADDPL instructions;\n+\tdon't emit an INC or DEC.\n+\t(aarch64_sve_inc_dec_immediate_p): Rename to...\n+\t(aarch64_sve_vector_inc_dec_immediate_p): ...this.\n+\t(aarch64_output_sve_inc_dec_immediate): Rename to...\n+\t(aarch64_output_sve_vector_inc_dec): ...this.  Update call to\n+\taarch64_sve_vector_inc_dec_immediate_p.\n+\t* config/aarch64/predicates.md (aarch64_sve_scalar_inc_dec_immediate)\n+\t(aarch64_sve_plus_immediate): New predicates.\n+\t(aarch64_pluslong_operand): Accept aarch64_sve_plus_immediate\n+\trather than aarch64_sve_addvl_addpl_immediate.\n+\t(aarch64_sve_inc_dec_immediate): Rename to...\n+\t(aarch64_sve_vector_inc_dec_immediate): ...this.  Update call to\n+\taarch64_sve_vector_inc_dec_immediate_p.\n+\t(aarch64_sve_add_operand): Update accordingly.\n+\t* config/aarch64/constraints.md (Uai): New constraint.\n+\t(vsi): Update call to aarch64_sve_vector_inc_dec_immediate_p.\n+\t* config/aarch64/aarch64.md (add<GPI:mode>3): Don't force the second\n+\toperand into a register if it satisfies aarch64_sve_plus_immediate.\n+\t(*add<GPI:mode>3_aarch64, *add<GPI:mode>3_poly_1): Add an alternative\n+\tfor Uai.  Update calls to aarch64_output_sve_addvl_addpl.\n+\t* config/aarch64/aarch64-sve.md (add<mode>3): Call\n+\taarch64_output_sve_vector_inc_dec instead of\n+\taarch64_output_sve_inc_dec_immediate.\n+\n 2019-08-15  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/iterators.md (UNSPEC_REVB, UNSPEC_REVH)"}, {"sha": "9191cfeb73db905aa4ce21c29afe40f5ec1bdbda", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "patch": "@@ -476,17 +476,19 @@ bool aarch64_zero_extend_const_eq (machine_mode, rtx, machine_mode, rtx);\n bool aarch64_move_imm (HOST_WIDE_INT, machine_mode);\n opt_machine_mode aarch64_sve_pred_mode (unsigned int);\n bool aarch64_sve_cnt_immediate_p (rtx);\n+bool aarch64_sve_scalar_inc_dec_immediate_p (rtx);\n bool aarch64_sve_addvl_addpl_immediate_p (rtx);\n-bool aarch64_sve_inc_dec_immediate_p (rtx);\n+bool aarch64_sve_vector_inc_dec_immediate_p (rtx);\n int aarch64_add_offset_temporaries (rtx);\n void aarch64_split_add_offset (scalar_int_mode, rtx, rtx, rtx, rtx, rtx);\n bool aarch64_mov_operand_p (rtx, machine_mode);\n rtx aarch64_reverse_mask (machine_mode, unsigned int);\n bool aarch64_offset_7bit_signed_scaled_p (machine_mode, poly_int64);\n bool aarch64_offset_9bit_signed_unscaled_p (machine_mode, poly_int64);\n char *aarch64_output_sve_cnt_immediate (const char *, const char *, rtx);\n-char *aarch64_output_sve_addvl_addpl (rtx, rtx, rtx);\n-char *aarch64_output_sve_inc_dec_immediate (const char *, rtx);\n+char *aarch64_output_sve_scalar_inc_dec (rtx);\n+char *aarch64_output_sve_addvl_addpl (rtx);\n+char *aarch64_output_sve_vector_inc_dec (const char *, rtx);\n char *aarch64_output_scalar_simd_mov_immediate (rtx, scalar_int_mode);\n char *aarch64_output_simd_mov_immediate (rtx, unsigned,\n \t\t\tenum simd_immediate_check w = AARCH64_CHECK_MOV);"}, {"sha": "f1f4fa26ba992ea5f378de49eb3b5f764f99cfee", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "patch": "@@ -1971,7 +1971,7 @@\n   \"@\n    add\\t%0.<Vetype>, %0.<Vetype>, #%D2\n    sub\\t%0.<Vetype>, %0.<Vetype>, #%N2\n-   * return aarch64_output_sve_inc_dec_immediate (\\\"%0.<Vetype>\\\", operands[2]);\n+   * return aarch64_output_sve_vector_inc_dec (\\\"%0.<Vetype>\\\", operands[2]);\n    movprfx\\t%0, %1\\;add\\t%0.<Vetype>, %0.<Vetype>, #%D2\n    movprfx\\t%0, %1\\;sub\\t%0.<Vetype>, %0.<Vetype>, #%N2\n    add\\t%0.<Vetype>, %1.<Vetype>, %2.<Vetype>\""}, {"sha": "b8c947e97b71f277a7c1d8cbfbfc2a50a60030db", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "patch": "@@ -2950,6 +2950,33 @@ aarch64_output_sve_cnt_immediate (const char *prefix, const char *operands,\n \t\t\t\t\t   value.coeffs[1], 0);\n }\n \n+/* Return true if we can add X using a single SVE INC or DEC instruction.  */\n+\n+bool\n+aarch64_sve_scalar_inc_dec_immediate_p (rtx x)\n+{\n+  poly_int64 value;\n+  return (poly_int_rtx_p (x, &value)\n+\t  && (aarch64_sve_cnt_immediate_p (value)\n+\t      || aarch64_sve_cnt_immediate_p (-value)));\n+}\n+\n+/* Return the asm string for adding SVE INC/DEC immediate OFFSET to\n+   operand 0.  */\n+\n+char *\n+aarch64_output_sve_scalar_inc_dec (rtx offset)\n+{\n+  poly_int64 offset_value = rtx_to_poly_int64 (offset);\n+  gcc_assert (offset_value.coeffs[0] == offset_value.coeffs[1]);\n+  if (offset_value.coeffs[1] > 0)\n+    return aarch64_output_sve_cnt_immediate (\"inc\", \"%x0\",\n+\t\t\t\t\t     offset_value.coeffs[1], 0);\n+  else\n+    return aarch64_output_sve_cnt_immediate (\"dec\", \"%x0\",\n+\t\t\t\t\t     -offset_value.coeffs[1], 0);\n+}\n+\n /* Return true if we can add VALUE to a register using a single ADDVL\n    or ADDPL instruction.  */\n \n@@ -2975,27 +3002,16 @@ aarch64_sve_addvl_addpl_immediate_p (rtx x)\n \t  && aarch64_sve_addvl_addpl_immediate_p (value));\n }\n \n-/* Return the asm string for adding ADDVL or ADDPL immediate X to operand 1\n-   and storing the result in operand 0.  */\n+/* Return the asm string for adding ADDVL or ADDPL immediate OFFSET\n+   to operand 1 and storing the result in operand 0.  */\n \n char *\n-aarch64_output_sve_addvl_addpl (rtx dest, rtx base, rtx offset)\n+aarch64_output_sve_addvl_addpl (rtx offset)\n {\n   static char buffer[sizeof (\"addpl\\t%x0, %x1, #-\") + 3 * sizeof (int)];\n   poly_int64 offset_value = rtx_to_poly_int64 (offset);\n   gcc_assert (aarch64_sve_addvl_addpl_immediate_p (offset_value));\n \n-  /* Use INC or DEC if possible.  */\n-  if (rtx_equal_p (dest, base) && GP_REGNUM_P (REGNO (dest)))\n-    {\n-      if (aarch64_sve_cnt_immediate_p (offset_value))\n-\treturn aarch64_output_sve_cnt_immediate (\"inc\", \"%x0\",\n-\t\t\t\t\t\t offset_value.coeffs[1], 0);\n-      if (aarch64_sve_cnt_immediate_p (-offset_value))\n-\treturn aarch64_output_sve_cnt_immediate (\"dec\", \"%x0\",\n-\t\t\t\t\t\t -offset_value.coeffs[1], 0);\n-    }\n-\n   int factor = offset_value.coeffs[1];\n   if ((factor & 15) == 0)\n     snprintf (buffer, sizeof (buffer), \"addvl\\t%%x0, %%x1, #%d\", factor / 16);\n@@ -3010,8 +3026,8 @@ aarch64_output_sve_addvl_addpl (rtx dest, rtx base, rtx offset)\n    factor in *FACTOR_OUT (if nonnull).  */\n \n bool\n-aarch64_sve_inc_dec_immediate_p (rtx x, int *factor_out,\n-\t\t\t\t unsigned int *nelts_per_vq_out)\n+aarch64_sve_vector_inc_dec_immediate_p (rtx x, int *factor_out,\n+\t\t\t\t\tunsigned int *nelts_per_vq_out)\n {\n   rtx elt;\n   poly_int64 value;\n@@ -3045,21 +3061,21 @@ aarch64_sve_inc_dec_immediate_p (rtx x, int *factor_out,\n    instruction.  */\n \n bool\n-aarch64_sve_inc_dec_immediate_p (rtx x)\n+aarch64_sve_vector_inc_dec_immediate_p (rtx x)\n {\n-  return aarch64_sve_inc_dec_immediate_p (x, NULL, NULL);\n+  return aarch64_sve_vector_inc_dec_immediate_p (x, NULL, NULL);\n }\n \n /* Return the asm template for an SVE vector INC or DEC instruction.\n    OPERANDS gives the operands before the vector count and X is the\n    value of the vector count operand itself.  */\n \n char *\n-aarch64_output_sve_inc_dec_immediate (const char *operands, rtx x)\n+aarch64_output_sve_vector_inc_dec (const char *operands, rtx x)\n {\n   int factor;\n   unsigned int nelts_per_vq;\n-  if (!aarch64_sve_inc_dec_immediate_p (x, &factor, &nelts_per_vq))\n+  if (!aarch64_sve_vector_inc_dec_immediate_p (x, &factor, &nelts_per_vq))\n     gcc_unreachable ();\n   if (factor < 0)\n     return aarch64_output_sve_cnt_immediate (\"dec\", operands, -factor,"}, {"sha": "cf561f00bb0bcd995adc4c2633ab1b5319339ae1", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "patch": "@@ -1753,6 +1753,7 @@\n   /* If the constant is too large for a single instruction and isn't frame\n      based, split off the immediate so it is available for CSE.  */\n   if (!aarch64_plus_immediate (operands[2], <MODE>mode)\n+      && !(TARGET_SVE && aarch64_sve_plus_immediate (operands[2], <MODE>mode))\n       && can_create_pseudo_p ()\n       && (!REG_P (op1)\n \t || !REGNO_PTR_FRAME_P (REGNO (op1))))\n@@ -1770,21 +1771,22 @@\n \n (define_insn \"*add<mode>3_aarch64\"\n   [(set\n-    (match_operand:GPI 0 \"register_operand\" \"=rk,rk,w,rk,r,rk\")\n+    (match_operand:GPI 0 \"register_operand\" \"=rk,rk,w,rk,r,r,rk\")\n     (plus:GPI\n-     (match_operand:GPI 1 \"register_operand\" \"%rk,rk,w,rk,rk,rk\")\n-     (match_operand:GPI 2 \"aarch64_pluslong_operand\" \"I,r,w,J,Uaa,Uav\")))]\n+     (match_operand:GPI 1 \"register_operand\" \"%rk,rk,w,rk,rk,0,rk\")\n+     (match_operand:GPI 2 \"aarch64_pluslong_operand\" \"I,r,w,J,Uaa,Uai,Uav\")))]\n   \"\"\n   \"@\n   add\\\\t%<w>0, %<w>1, %2\n   add\\\\t%<w>0, %<w>1, %<w>2\n   add\\\\t%<rtn>0<vas>, %<rtn>1<vas>, %<rtn>2<vas>\n   sub\\\\t%<w>0, %<w>1, #%n2\n   #\n-  * return aarch64_output_sve_addvl_addpl (operands[0], operands[1], operands[2]);\"\n-  ;; The \"alu_imm\" type for ADDVL/ADDPL is just a placeholder.\n-  [(set_attr \"type\" \"alu_imm,alu_sreg,neon_add,alu_imm,multiple,alu_imm\")\n-   (set_attr \"arch\" \"*,*,simd,*,*,*\")]\n+  * return aarch64_output_sve_scalar_inc_dec (operands[2]);\n+  * return aarch64_output_sve_addvl_addpl (operands[2]);\"\n+  ;; The \"alu_imm\" types for INC/DEC and ADDVL/ADDPL are just placeholders.\n+  [(set_attr \"type\" \"alu_imm,alu_sreg,neon_add,alu_imm,multiple,alu_imm,alu_imm\")\n+   (set_attr \"arch\" \"*,*,simd,*,*,sve,sve\")]\n )\n \n ;; zero_extend version of above\n@@ -1863,17 +1865,18 @@\n ;; this pattern.\n (define_insn_and_split \"*add<mode>3_poly_1\"\n   [(set\n-    (match_operand:GPI 0 \"register_operand\" \"=r,r,r,r,r,&r\")\n+    (match_operand:GPI 0 \"register_operand\" \"=r,r,r,r,r,r,&r\")\n     (plus:GPI\n-     (match_operand:GPI 1 \"register_operand\" \"%rk,rk,rk,rk,rk,rk\")\n-     (match_operand:GPI 2 \"aarch64_pluslong_or_poly_operand\" \"I,r,J,Uaa,Uav,Uat\")))]\n+     (match_operand:GPI 1 \"register_operand\" \"%rk,rk,rk,rk,rk,0,rk\")\n+     (match_operand:GPI 2 \"aarch64_pluslong_or_poly_operand\" \"I,r,J,Uaa,Uav,Uai,Uat\")))]\n   \"TARGET_SVE && operands[0] != stack_pointer_rtx\"\n   \"@\n   add\\\\t%<w>0, %<w>1, %2\n   add\\\\t%<w>0, %<w>1, %<w>2\n   sub\\\\t%<w>0, %<w>1, #%n2\n   #\n-  * return aarch64_output_sve_addvl_addpl (operands[0], operands[1], operands[2]);\n+  * return aarch64_output_sve_scalar_inc_dec (operands[2]);\n+  * return aarch64_output_sve_addvl_addpl (operands[2]);\n   #\"\n   \"&& epilogue_completed\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\n@@ -1884,8 +1887,8 @@\n \t\t\t      operands[2], operands[0], NULL_RTX);\n     DONE;\n   }\n-  ;; The \"alu_imm\" type for ADDVL/ADDPL is just a placeholder.\n-  [(set_attr \"type\" \"alu_imm,alu_sreg,alu_imm,multiple,alu_imm,multiple\")]\n+  ;; The \"alu_imm\" types for INC/DEC and ADDVL/ADDPL are just placeholders.\n+  [(set_attr \"type\" \"alu_imm,alu_sreg,alu_imm,multiple,alu_imm,alu_imm,multiple\")]\n )\n \n (define_split"}, {"sha": "1a43beee994af5a8279a883f5edcc2d2fca461f7", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "patch": "@@ -49,6 +49,12 @@\n   (and (match_code \"const_int\")\n        (match_test \"aarch64_pluslong_strict_immedate (op, VOIDmode)\")))\n \n+(define_constraint \"Uai\"\n+  \"@internal\n+   A constraint that matches a VG-based constant that can be added by\n+   a single INC or DEC.\"\n+  (match_operand 0 \"aarch64_sve_scalar_inc_dec_immediate\"))\n+\n (define_constraint \"Uav\"\n   \"@internal\n    A constraint that matches a VG-based constant that can be added by\n@@ -416,7 +422,7 @@\n   \"@internal\n    A constraint that matches a vector count operand valid for SVE INC and\n    DEC instructions.\"\n- (match_operand 0 \"aarch64_sve_inc_dec_immediate\"))\n+ (match_operand 0 \"aarch64_sve_vector_inc_dec_immediate\"))\n \n (define_constraint \"vsn\"\n   \"@internal"}, {"sha": "593b1be29df9b0eca39e0c75e93f7e51ad61ac7b", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=0fdc30bcf56d7b46122d7e67d61b56c0a198f3b3", "patch": "@@ -144,18 +144,27 @@\n   (and (match_operand 0 \"aarch64_pluslong_immediate\")\n        (not (match_operand 0 \"aarch64_plus_immediate\"))))\n \n+(define_predicate \"aarch64_sve_scalar_inc_dec_immediate\"\n+  (and (match_code \"const_poly_int\")\n+       (match_test \"aarch64_sve_scalar_inc_dec_immediate_p (op)\")))\n+\n (define_predicate \"aarch64_sve_addvl_addpl_immediate\"\n   (and (match_code \"const_poly_int\")\n        (match_test \"aarch64_sve_addvl_addpl_immediate_p (op)\")))\n \n+(define_predicate \"aarch64_sve_plus_immediate\"\n+  (ior (match_operand 0 \"aarch64_sve_scalar_inc_dec_immediate\")\n+       (match_operand 0 \"aarch64_sve_addvl_addpl_immediate\")))\n+\n (define_predicate \"aarch64_split_add_offset_immediate\"\n   (and (match_code \"const_poly_int\")\n        (match_test \"aarch64_add_offset_temporaries (op) == 1\")))\n \n (define_predicate \"aarch64_pluslong_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_pluslong_immediate\")\n-       (match_operand 0 \"aarch64_sve_addvl_addpl_immediate\")))\n+       (and (match_test \"TARGET_SVE\")\n+\t    (match_operand 0 \"aarch64_sve_plus_immediate\"))))\n \n (define_predicate \"aarch64_pluslong_or_poly_operand\"\n   (ior (match_operand 0 \"aarch64_pluslong_operand\")\n@@ -602,9 +611,9 @@\n   (and (match_code \"const,const_vector\")\n        (match_test \"aarch64_sve_arith_immediate_p (op, true)\")))\n \n-(define_predicate \"aarch64_sve_inc_dec_immediate\"\n+(define_predicate \"aarch64_sve_vector_inc_dec_immediate\"\n   (and (match_code \"const,const_vector\")\n-       (match_test \"aarch64_sve_inc_dec_immediate_p (op)\")))\n+       (match_test \"aarch64_sve_vector_inc_dec_immediate_p (op)\")))\n \n (define_predicate \"aarch64_sve_uxtb_immediate\"\n   (and (match_code \"const_vector\")\n@@ -687,7 +696,7 @@\n (define_predicate \"aarch64_sve_add_operand\"\n   (ior (match_operand 0 \"aarch64_sve_arith_operand\")\n        (match_operand 0 \"aarch64_sve_sub_arith_immediate\")\n-       (match_operand 0 \"aarch64_sve_inc_dec_immediate\")))\n+       (match_operand 0 \"aarch64_sve_vector_inc_dec_immediate\")))\n \n (define_predicate \"aarch64_sve_pred_and_operand\"\n   (ior (match_operand 0 \"register_operand\")"}]}