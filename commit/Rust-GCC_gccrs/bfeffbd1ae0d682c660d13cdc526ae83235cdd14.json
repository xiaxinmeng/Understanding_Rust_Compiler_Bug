{"sha": "bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlZmZiZDFhZTBkNjgyYzY2MGQxM2NkYzUyNmFlODMyMzVjZGQxNA==", "commit": {"author": {"name": "Fan You", "email": "youfan.noey@gmail.com", "date": "2015-11-13T10:00:59Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-11-13T10:00:59Z"}, "message": "Implement C++ LFTSv1 polymorphic memory resources\n\n2015-11-13  Fan You  <youfan.noey@gmail.com>\n\n\t* include/Makefile.am: Add new headers.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/uses_allocator.h (__erased_type): Define.\n\t(__uses_allocator_helper): Check for __erased_type.\n\t* include/experimental/memory_resource: New.\n\t* include/experimental/utlity: New.\n\t* testsuite/experimental/type_erased_allocator/1.cc: New.\n\t* testsuite/experimental/type_erased_allocator/1_neg.cc: New.\n\t* testsuite/experimental/type_erased_allocator/2.cc: New.\n\t* testsuite/experimental/type_erased_allocator/uses_allocator.cc: New.\n\nFrom-SVN: r230294", "tree": {"sha": "35698a64de43fb63ce527ee6b18af0ce1c415fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35698a64de43fb63ce527ee6b18af0ce1c415fcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6faa91548255490c2dc61a25596c33e6d5fc537e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6faa91548255490c2dc61a25596c33e6d5fc537e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6faa91548255490c2dc61a25596c33e6d5fc537e"}], "stats": {"total": 864, "additions": 863, "deletions": 1}, "files": [{"sha": "f52bfef65d5622e92d9a5629320958de83d400ca", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -1,3 +1,16 @@\n+2015-11-13  Fan You  <youfan.noey@gmail.com>\n+\n+\t* include/Makefile.am: Add new headers.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/uses_allocator.h (__erased_type): Define.\n+\t(__uses_allocator_helper): Check for __erased_type.\n+\t* include/experimental/memory_resource: New.\n+\t* include/experimental/utlity: New.\n+\t* testsuite/experimental/type_erased_allocator/1.cc: New.\n+\t* testsuite/experimental/type_erased_allocator/1_neg.cc: New.\n+\t* testsuite/experimental/type_erased_allocator/2.cc: New.\n+\t* testsuite/experimental/type_erased_allocator/uses_allocator.cc: New.\n+\n 2015-11-12  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/56158"}, {"sha": "ee9b6d8c246292c195114e50c96a6286f8766bfd", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -656,6 +656,7 @@ experimental_headers = \\\n \t${experimental_srcdir}/list \\\n \t${experimental_srcdir}/map \\\n \t${experimental_srcdir}/memory \\\n+\t${experimental_srcdir}/memory_resource \\\n \t${experimental_srcdir}/numeric \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/propagate_const \\\n@@ -668,6 +669,7 @@ experimental_headers = \\\n \t${experimental_srcdir}/type_traits \\\n \t${experimental_srcdir}/unordered_map \\\n \t${experimental_srcdir}/unordered_set \\\n+\t${experimental_srcdir}/utility \\\n \t${experimental_srcdir}/vector \\\n \t${experimental_filesystem_headers}\n "}, {"sha": "482fdb406a79d0e547831037aa3e07683cd810e9", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -945,6 +945,7 @@ experimental_headers = \\\n \t${experimental_srcdir}/list \\\n \t${experimental_srcdir}/map \\\n \t${experimental_srcdir}/memory \\\n+\t${experimental_srcdir}/memory_resource \\\n \t${experimental_srcdir}/numeric \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/propagate_const \\\n@@ -957,6 +958,7 @@ experimental_headers = \\\n \t${experimental_srcdir}/type_traits \\\n \t${experimental_srcdir}/unordered_map \\\n \t${experimental_srcdir}/unordered_set \\\n+\t${experimental_srcdir}/utility \\\n \t${experimental_srcdir}/vector \\\n \t${experimental_filesystem_headers}\n "}, {"sha": "f7566a2e522d54448091832cc2bb084c1c7d5b5b", "filename": "libstdc++-v3/include/bits/uses_allocator.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -35,6 +35,12 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  struct __erased_type { };\n+\n+  template<typename _Alloc, typename _Tp>\n+    using __is_erased_or_convertible\n+      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;\n+\n   /// [allocator.tag]\n   struct allocator_arg_t { explicit allocator_arg_t() = default; };\n \n@@ -47,7 +53,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Alloc>\n     struct __uses_allocator_helper<_Tp, _Alloc,\n \t\t\t\t   __void_t<typename _Tp::allocator_type>>\n-    : is_convertible<_Alloc, typename _Tp::allocator_type>::type\n+    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type\n     { };\n \n   /// [allocator.uses.trait]"}, {"sha": "5c8cbd6f133a13bddd62dd4f4ccebf7f3b6f1b87", "filename": "libstdc++-v3/include/experimental/memory_resource", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -0,0 +1,383 @@\n+// <experimental/memory_resource> -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/memory_resource\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_MEMORY_RESOURCE\n+#define _GLIBCXX_EXPERIMENTAL_MEMORY_RESOURCE 1\n+\n+#include <memory>\n+#include <new>\n+#include <atomic>\n+#include <cstddef>\n+#include <bits/alloc_traits.h>\n+\n+namespace std {\n+namespace experimental {\n+inline namespace fundamentals_v2 {\n+namespace pmr {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  class memory_resource;\n+\n+  template <typename _Tp>\n+    class polymorphic_allocator;\n+\n+  template <typename _Alloc>\n+    class __resource_adaptor_imp;\n+\n+  template <typename _Alloc>\n+    using resource_adaptor = __resource_adaptor_imp<\n+      typename allocator_traits<_Alloc>::template rebind_alloc<char>>;\n+\n+  template <typename _Tp>\n+    struct __uses_allocator_construction_helper;\n+\n+  // Global memory resources\n+  memory_resource* new_delete_resource() noexcept;\n+  memory_resource* null_memory_resource() noexcept;\n+\n+  // The default memory resource\n+  memory_resource* get_default_resource() noexcept;\n+  memory_resource* set_default_resource(memory_resource* __r) noexcept;\n+\n+  // Standard memory resources\n+\n+  // 8.5 Class memory_resource\n+  class memory_resource\n+  {\n+    static constexpr size_t _S_max_align = alignof(max_align_t);\n+\n+  public:\n+    virtual ~memory_resource() { }\n+\n+    void*\n+    allocate(size_t __bytes, size_t __alignment = _S_max_align)\n+    { return do_allocate(__bytes, __alignment); }\n+\n+    void\n+    deallocate(void* __p, size_t __bytes, size_t __alignment = _S_max_align)\n+    { return do_deallocate(__p, __bytes, __alignment); }\n+\n+    bool\n+    is_equal(const memory_resource& __other) const noexcept\n+    { return do_is_equal(__other); }\n+\n+  protected:\n+    virtual void*\n+    do_allocate(size_t __bytes, size_t __alignment) = 0;\n+\n+    virtual void\n+    do_deallocate(void* __p, size_t __bytes, size_t __alignment) = 0;\n+\n+    virtual bool\n+    do_is_equal(const memory_resource& __other) const noexcept = 0;\n+  };\n+\n+  inline bool\n+  operator==(const memory_resource& __a,\n+\t     const memory_resource& __b) noexcept\n+  { return &__a == &__b || __a.is_equal(__b); }\n+\n+  inline bool\n+  operator!=(const memory_resource& __a,\n+\t     const memory_resource& __b) noexcept\n+  { return !(__a == __b); }\n+\n+\n+  // 8.6 Class template polymorphic_allocator\n+  template <class _Tp>\n+    class polymorphic_allocator\n+    {\n+      using __uses_alloc1_ = __uses_alloc1<memory_resource*>;\n+      using __uses_alloc2_ = __uses_alloc2<memory_resource*>;\n+\n+      template<typename _Tp1, typename... _Args>\n+\tvoid\n+\t_M_construct(__uses_alloc0, _Tp1* __p, _Args&&... __args)\n+\t{ ::new(__p) _Tp1(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Tp1, typename... _Args>\n+\tvoid\n+\t_M_construct(__uses_alloc1_, _Tp1* __p, _Args&&...  __args)\n+\t{ ::new(__p) _Tp1(allocator_arg, this->resource(),\n+\t\t\t  std::forward<_Args>(__args)...); }\n+\n+      template<typename _Tp1, typename... _Args>\n+\tvoid\n+\t_M_construct(__uses_alloc2_, _Tp1* __p, _Args&&...  __args)\n+\t{ ::new(__p) _Tp1(std::forward<_Args>(__args)...,\n+\t\t\t  this->resource()); }\n+\n+    public:\n+      using value_type = _Tp;\n+\n+      polymorphic_allocator() noexcept\n+      : _M_resource(get_default_resource())\n+      { }\n+\n+      polymorphic_allocator(memory_resource* __r)\n+      : _M_resource(__r)\n+      { _GLIBCXX_DEBUG_ASSERT(__r); }\n+\n+      polymorphic_allocator(const polymorphic_allocator& __other) = default;\n+\n+      template <typename _Up>\n+\tpolymorphic_allocator(const polymorphic_allocator<_Up>&\n+\t\t\t      __other) noexcept\n+\t: _M_resource(__other.resource())\n+\t{ }\n+\n+      polymorphic_allocator&\n+\toperator=(const polymorphic_allocator& __rhs) = default;\n+\n+      _Tp* allocate(size_t __n)\n+      { return static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),\n+\t\t\t\t\t\t       alignof(_Tp))); }\n+\n+      void deallocate(_Tp* __p, size_t __n)\n+      { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }\n+\n+      template <typename _Tp1, typename... _Args> //used here\n+\tvoid construct(_Tp1* __p, _Args&&... __args)\n+\t{\n+\t  auto __use_tag = __use_alloc<_Tp1, memory_resource*,\n+\t       _Args...>(this->resource());\n+\t  _M_construct(__use_tag, __p, std::forward<_Args>(__args)...);\n+\t}\n+\n+      // Specializations for pair using piecewise construction\n+      template <typename _Tp1, typename _Tp2,\n+\t       typename... _Args1, typename... _Args2>\n+\tvoid construct(pair<_Tp1, _Tp2>* __p, piecewise_construct_t,\n+\t\t       tuple<_Args1...> __x,\n+\t\t       tuple<_Args2...> __y)\n+\t{\n+\t  auto __x_use_tag =\n+\t    __use_alloc<_Tp1, memory_resource*, _Args1...>(this->resource());\n+\t  auto __y_use_tag =\n+\t    __use_alloc<_Tp2, memory_resource*, _Args2...>(this->resource());\n+\n+\t  ::new(__p) std::pair<_Tp1, _Tp2>(piecewise_construct,\n+\t\t\t\t\t   _M_construct_p(__x_use_tag, __x),\n+\t\t\t\t\t   _M_construct_p(__y_use_tag, __y));\n+\t}\n+\n+      template <typename _Tp1, typename _Tp2>\n+\tvoid construct(pair<_Tp1,_Tp2>* __p)\n+\t{ this->construct(__p, piecewise_construct, tuple<>(), tuple<>()); }\n+\n+      template <typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\tvoid construct(pair<_Tp1,_Tp2>* __p, _Up&& __x, _Vp&& __y)\n+\t{ this->construct(__p, piecewise_construct,\n+\t\t\t  forward_as_tuple(std::forward<_Up>(__x)),\n+\t\t\t  forward_as_tuple(std::forward<_Vp>(__y))); }\n+\n+      template <typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\tvoid construct(pair<_Tp1,_Tp2>* __p, const std::pair<_Up, _Vp>& __pr)\n+\t{ this->construct(__p, piecewise_construct, forward_as_tuple(__pr.first),\n+\t\t\t  forward_as_tuple(__pr.second)); }\n+\n+      template <typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\tvoid construct(pair<_Tp1,_Tp2>* __p, pair<_Up, _Vp>&& __pr)\n+\t{ this->construct(__p, piecewise_construct,\n+\t\t\t  forward_as_tuple(std::forward<_Up>(__pr.first)),\n+\t\t\t  forward_as_tuple(std::forward<_Vp>(__pr.second))); }\n+\n+      template <typename _Up>\n+\tvoid destroy(_Up* __p)\n+\t{ __p->~_Up(); }\n+\n+      // Return a default-constructed allocator (no allocator propagation)\n+      polymorphic_allocator select_on_container_copy_construction() const\n+      { return polymorphic_allocator(); }\n+\n+      memory_resource* resource() const\n+      { return _M_resource; }\n+\n+    private:\n+      template<typename _Tuple>\n+\t_Tuple&&\n+\t_M_construct_p(__uses_alloc0, _Tuple& __t)\n+\t{ return std::move(__t); }\n+\n+      template<typename... _Args>\n+\tdecltype(auto)\n+\t_M_construct_p(__uses_alloc1_ __ua, tuple<_Args...>& __t)\n+\t{ return tuple_cat(make_tuple(allocator_arg, *(__ua._M_a)),\n+\t\t\t   std::move(__t)); }\n+\n+      template<typename... _Args>\n+\tdecltype(auto)\n+\t_M_construct_p(__uses_alloc2_ __ua, tuple<_Args...>& __t)\n+\t{ return tuple_cat(std::move(__t), make_tuple(*(__ua._M_a))); }\n+\n+      memory_resource* _M_resource;\n+    };\n+\n+  template <class _Tp1, class _Tp2>\n+    bool operator==(const polymorphic_allocator<_Tp1>& __a,\n+\t\t    const polymorphic_allocator<_Tp2>& __b) noexcept\n+    { return *__a.resource() == *__b.resource(); }\n+\n+  template <class _Tp1, class _Tp2>\n+    bool operator!=(const polymorphic_allocator<_Tp1>& __a,\n+\t\t    const polymorphic_allocator<_Tp2>& __b) noexcept\n+    { return !(__a == __b); }\n+\n+  // 8.7.1 __resource_adaptor_imp\n+  template <typename _Alloc>\n+    class __resource_adaptor_imp : public memory_resource\n+    {\n+    public:\n+      using allocator_type = _Alloc;\n+\n+      __resource_adaptor_imp() = default;\n+      __resource_adaptor_imp(const __resource_adaptor_imp&) = default;\n+      __resource_adaptor_imp(__resource_adaptor_imp&&) = default;\n+\n+      explicit __resource_adaptor_imp(const _Alloc& __a2)\n+      : _M_alloc(__a2)\n+      { }\n+\n+      explicit __resource_adaptor_imp(_Alloc&& __a2)\n+      : _M_alloc(std::move(__a2))\n+      { }\n+\n+      __resource_adaptor_imp&\n+      operator=(const __resource_adaptor_imp&) = default;\n+\n+      allocator_type get_allocator() const { return _M_alloc; }\n+\n+    protected:\n+      virtual void*\n+      do_allocate(size_t __bytes, size_t __alignment)\n+      {\n+\tusing _Aligned_alloc = std::__alloc_rebind<_Alloc, char>;\n+\tsize_t __new_size = _S_aligned_size(__bytes,\n+\t\t\t\t\t    _S_supported(__alignment) ?\n+\t\t\t\t\t    __alignment : _S_max_align);\n+\treturn _Aligned_alloc().allocate(__new_size);\n+      }\n+\n+      virtual void\n+      do_deallocate(void* __p, size_t __bytes, size_t __alignment)\n+      {\n+\tusing _Aligned_alloc = std::__alloc_rebind<_Alloc, char>;\n+\tsize_t __new_size = _S_aligned_size(__bytes,\n+\t\t\t\t\t    _S_supported(__alignment) ?\n+\t\t\t\t\t    __alignment : _S_max_align);\n+\t_Aligned_alloc().deallocate(static_cast<typename\n+\t\t\t\t    _Aligned_alloc::pointer>(__p),\n+\t\t\t\t    __new_size);\n+      }\n+\n+      virtual bool\n+      do_is_equal(const memory_resource& __other) const noexcept\n+      {\n+\tauto __p = dynamic_cast<const __resource_adaptor_imp*>(&__other);\n+\treturn __p ? (_M_alloc == __p->_M_alloc) : false;\n+      }\n+\n+    private:\n+      // Calculate Aligned Size\n+      // Returns a size that is larger than or equal to __size and divided by\n+      // __alignment, where __alignment is required to be the power of 2.\n+      static size_t\n+      _S_aligned_size(size_t __size, size_t __alignment)\n+      { return ((__size - 1)|(__alignment - 1)) + 1; }\n+\n+      // Determine whether alignment meets one of those preconditions:\n+      // 1. Equals to Zero\n+      // 2. Is power of two\n+      static bool\n+      _S_supported (size_t __x)\n+      { return ((__x != 0) && !(__x & (__x - 1))); }\n+\n+      _Alloc _M_alloc;\n+    };\n+\n+  // Global memory resources\n+  inline std::atomic<memory_resource*>&\n+  __get_default_resource()\n+  {\n+    static atomic<memory_resource*> _S_default_resource(new_delete_resource());\n+    return _S_default_resource;\n+  }\n+\n+  inline memory_resource*\n+  new_delete_resource() noexcept\n+  {\n+    static resource_adaptor<std::allocator<char>> __r;\n+    return static_cast<memory_resource*>(&__r);\n+  }\n+\n+  template <typename _Alloc>\n+    class __null_memory_resource : private memory_resource\n+    {\n+    protected:\n+      void*\n+      do_allocate(size_t __bytes, size_t __alignment)\n+      { std::__throw_bad_alloc(); }\n+\n+      void\n+      do_deallocate(void* __p, size_t __bytes, size_t __alignment)\n+      { }\n+\n+      bool\n+      do_is_equal(const memory_resource& __other) const noexcept\n+      { }\n+\n+      friend memory_resource* null_memory_resource() noexcept;\n+    };\n+\n+  inline memory_resource*\n+  null_memory_resource() noexcept\n+  {\n+    static __null_memory_resource<void> __r;\n+    return static_cast<memory_resource*>(&__r);\n+  }\n+\n+  // The default memory resource\n+  inline memory_resource*\n+  get_default_resource() noexcept\n+  { return __get_default_resource().load(); }\n+\n+  inline memory_resource*\n+  set_default_resource(memory_resource* __r) noexcept\n+  {\n+    if (__r == nullptr)\n+      __r = new_delete_resource();\n+    return __get_default_resource().exchange(__r);\n+  }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace pmr\n+} // namespace fundamentals_v2\n+} // namespace experimental\n+} // namespace std\n+\n+#endif"}, {"sha": "b1aaceee056818deb07978b55b446815cbbb2e5a", "filename": "libstdc++-v3/include/experimental/utility", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Futility?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -0,0 +1,48 @@\n+// <experimental/utility> -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/utility\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_UTILITY\n+#define _GLIBCXX_EXPERIMENTAL_UTILITY 1\n+\n+#include <utility>\n+#include <bits/uses_allocator.h>\n+\n+namespace std {\n+namespace experimental {\n+inline namespace fundamentals_v2 {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // 3.1.2, erased-type placeholder\n+  using erased_type = std::__erased_type;\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace fundamentals_v2\n+} // namespace experimental\n+} // namespace std\n+\n+#endif"}, {"sha": "9545edff54d67620b99d1bccd0470392b9bde0f2", "filename": "libstdc++-v3/testsuite/experimental/type_erased_allocator/1.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F1.cc?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -0,0 +1,147 @@\n+// { dg-options \"-std=gnu++14\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <experimental/memory_resource>\n+#include <vector>\n+#include <bits/uses_allocator.h>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using std::experimental::pmr::polymorphic_allocator;\n+using std::experimental::pmr::memory_resource;\n+using std::experimental::pmr::new_delete_resource;\n+using std::experimental::pmr::get_default_resource;\n+using std::experimental::pmr::set_default_resource;\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  ~A() { ++dtor_count; }\n+  static int ctor_count;\n+  static int dtor_count;\n+};\n+int A::ctor_count = 0;\n+int A::dtor_count = 0;\n+\n+struct CountedResource : public memory_resource\n+{\n+public:\n+  CountedResource() = default;\n+  ~ CountedResource() = default;\n+\n+  static size_t get_alloc_count()  { return alloc_count;  }\n+  static size_t get_dalloc_count() { return dalloc_count; }\n+\n+  static size_t  alloc_count;\n+  static size_t  dalloc_count;\n+protected:\n+  void* do_allocate(size_t bytes, size_t alignment)\n+  {\n+    alloc_count += bytes;\n+    if (auto ptr = std::malloc(bytes)) {\n+      return ptr;\n+    }\n+    throw std::bad_alloc();\n+  }\n+\n+  void do_deallocate(void *p, size_t bytes, size_t alignment)\n+  {\n+    dalloc_count += bytes;\n+    free(p);\n+  }\n+\n+  bool do_is_equal(const memory_resource& __other) const noexcept\n+  { return this == &__other; }\n+};\n+  size_t  CountedResource::alloc_count  = 0;\n+  size_t  CountedResource::dalloc_count = 0;\n+\n+void clear()\n+{\n+  CountedResource::alloc_count  = 0;\n+  CountedResource::dalloc_count = 0;\n+  A::ctor_count = 0;\n+  A::dtor_count = 0;\n+}\n+\n+// memory resource\n+void test01()\n+{\n+  memory_resource* r = new_delete_resource();\n+  VERIFY(get_default_resource() == r);\n+  void *p = get_default_resource()->allocate(5);\n+  VERIFY(p);\n+  get_default_resource()->deallocate(p, 5);\n+\n+  clear();\n+  CountedResource* cr = new CountedResource();\n+  set_default_resource(cr);\n+  VERIFY(get_default_resource() == cr);\n+  void *pc = get_default_resource()->allocate(5);\n+  VERIFY(pc);\n+  get_default_resource()->deallocate(pc, 5);\n+  VERIFY(CountedResource::get_alloc_count()  == 5);\n+  VERIFY(CountedResource::get_dalloc_count() == 5);\n+}\n+\n+// polymorphic_allocator\n+void test02()\n+{\n+  clear();\n+  {\n+    CountedResource cr;\n+    polymorphic_allocator<A> pa(&cr);\n+    std::vector<A, polymorphic_allocator<A>> v(5, A(), pa);\n+  }\n+  VERIFY(A::ctor_count == 1);\n+  VERIFY(A::dtor_count == 6);\n+  VERIFY(CountedResource::get_alloc_count()  == 5);\n+  VERIFY(CountedResource::get_dalloc_count() == 5);\n+}\n+\n+void test03() {\n+  clear();\n+  CountedResource cr;\n+  polymorphic_allocator<A> pa(&cr);\n+  A* p = pa.allocate(1);\n+  pa.construct(p);\n+  pa.destroy(p);\n+  pa.deallocate(p, 1);\n+  VERIFY(A::ctor_count == 1);\n+  VERIFY(A::dtor_count == 1);\n+  VERIFY(CountedResource::get_alloc_count()  == 1);\n+  VERIFY(CountedResource::get_dalloc_count() == 1);\n+}\n+\n+void test04() {\n+  polymorphic_allocator<A> pa1(get_default_resource());\n+  polymorphic_allocator<A> pa2(get_default_resource());\n+  VERIFY(pa1 == pa2);\n+  polymorphic_allocator<A> pa3 = pa2.select_on_container_copy_construction();\n+  VERIFY(pa1 == pa3);\n+}\n+\n+int main() {\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}"}, {"sha": "b85e0ea469f83d990249a99a91c939e90159e024", "filename": "libstdc++-v3/testsuite/experimental/type_erased_allocator/1_neg.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F1_neg.cc?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do run { xfail *-*-* } }\n+// { dg-options \"-std=gnu++14\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/memory_resource>\n+#include <bits/uses_allocator.h>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using std::experimental::pmr::polymorphic_allocator;\n+using std::experimental::pmr::null_memory_resource;\n+using std::experimental::pmr::memory_resource;\n+\n+void test01() {\n+  memory_resource* r = null_memory_resource();\n+  auto p = r->allocate(1);\n+}\n+\n+int main() {\n+  test01();\n+}"}, {"sha": "014c357e5fad27a8aa98a8dac622dd8f4d80f86f", "filename": "libstdc++-v3/testsuite/experimental/type_erased_allocator/2.cc", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2F2.cc?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -0,0 +1,202 @@\n+// { dg-options \"-std=gnu++14\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <experimental/memory_resource>\n+#include <experimental/utility>\n+#include <bits/uses_allocator.h>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using std::experimental::pmr::polymorphic_allocator;\n+using std::experimental::pmr::memory_resource;\n+using std::experimental::pmr::new_delete_resource;\n+using std::experimental::pmr::get_default_resource;\n+using std::experimental::pmr::set_default_resource;\n+using std::allocator_arg_t;\n+\n+enum CtorType { Default, Copy, Move, Other, Tuple, Piecewise_Default, Piecewise_Copy};\n+\n+// type that takes a memory_resource before other ctor args\n+struct A\n+{\n+  using allocator_type = std::experimental::erased_type;\n+\n+  CtorType type;\n+  memory_resource* alloc = nullptr;\n+\n+  A() : type(Default) { }\n+  A(allocator_arg_t, memory_resource* a) : type(Default), alloc(a) { }\n+  A(const A&) : type(Copy) { }\n+  A(allocator_arg_t, memory_resource* a, const A&) : type(Copy), alloc(a) { }\n+  A(A&&) : type (Move) { }\n+  A(allocator_arg_t, memory_resource* a, A&&) : type (Move), alloc(a) { }\n+  A(int) : type(Other) { }\n+  A(allocator_arg_t, memory_resource* a, int) : type(Other), alloc(a) { }\n+};\n+\n+// type that takes a memory_resource after other ctor args\n+struct B\n+{\n+  using allocator_type = std::experimental::erased_type;\n+\n+  CtorType type;\n+  memory_resource* alloc = nullptr;\n+\n+  B() : type(Default) { }\n+  B(memory_resource* a) : type(Default), alloc(a) { }\n+  B(const B&) : type(Copy) { }\n+  B(const B&, memory_resource* a) : type(Copy), alloc(a) { }\n+  B(B&&) : type (Move) { }\n+  B(B&&, memory_resource* a) : type(Move), alloc(a) { }\n+  B(int) : type(Other) { }\n+  B(int, memory_resource* a) : type(Other), alloc(a) { }\n+};\n+\n+// type that takes no memory_resource\n+struct C\n+{\n+  CtorType type;\n+  C() : type(Default) { }\n+  C(const C&) : type(Copy) { }\n+  C(C&&) : type(Move) { }\n+  C(int) : type(Other) { }\n+};\n+\n+// test construct for type that\n+// uses memory_resource* as allocator\n+template<typename A>\n+void test_uses_alloc() {\n+  polymorphic_allocator<A> pa;\n+  A* p = pa.allocate(1);\n+  A a;\n+\n+  pa.construct(p);\n+  VERIFY(p->alloc == get_default_resource());\n+  VERIFY(p->type == Default);\n+  pa.destroy(p);\n+\n+  pa.construct(p, a);\n+  VERIFY(p->type == Copy);\n+  pa.destroy(p);\n+\n+  pa.construct(p, A());\n+  VERIFY(p->type == Move);\n+  pa.destroy(p);\n+\n+  pa.construct(p, 1);\n+  VERIFY(p->type == Other);\n+  pa.destroy(p);\n+\n+  pa.deallocate(p, 1);\n+}\n+\n+// test construct for type that not using allocator\n+template <typename C>\n+void test_non_alloc() {\n+  polymorphic_allocator<C> pa;\n+  C* p = pa.allocate(1);\n+  C b;\n+\n+  pa.construct(p);\n+  VERIFY(p->type == Default);\n+  pa.destroy(p);\n+\n+  pa.construct(p, b);\n+  VERIFY(p->type == Copy);\n+  pa.destroy(p);\n+\n+  pa.construct(p, C());\n+  VERIFY(p->type == Move);\n+  pa.destroy(p);\n+\n+  pa.construct(p, 1);\n+  VERIFY(p->type == Other);\n+  pa.destroy(p);\n+\n+  pa.deallocate(p, 1);\n+}\n+\n+// test piecewise_construct\n+template <typename A, typename B>\n+void test_pair() {\n+  polymorphic_allocator<std::pair<A, B>> pa;\n+  std::pair<A, B>* p = pa.allocate(1);\n+  std::tuple<> t;\n+\n+  // construct(pair<T1, T2>* p, piecewise_construct_t, tuple<...>, tuple<...>)\n+  pa.construct(p, std::piecewise_construct, t, t);\n+  VERIFY(p->first.type == Default);\n+  VERIFY(p->second.type == Default);\n+  pa.destroy(p);\n+\n+  // construct(pair<T1, T2>* __p)\n+  pa.construct(p);\n+  VERIFY(p->first.type == Default);\n+  VERIFY(p->second.type == Default);\n+  pa.destroy(p);\n+\n+  // construct(pair<T1, T2>* p, U&& x, V&& y)\n+  A a; B b;\n+  pa.construct(p, a, b);\n+  VERIFY(p->first.type == Copy);\n+  VERIFY(p->second.type == Copy);\n+  pa.destroy(p);\n+\n+  pa.construct(p, A(), B());\n+  VERIFY(p->first.type == Move);\n+  VERIFY(p->second.type == Move);\n+  auto pp = *p;\n+  pa.destroy(p);\n+\n+  // construct(pair<T1, T2>* p, const pair<U, V>& x)\n+  pa.construct(p, pp);\n+  VERIFY(p->first.type == Copy);\n+  VERIFY(p->second.type == Copy);\n+  pa.destroy(p);\n+\n+  // construct(pair<T1, T2>* p, pair<U, V>&& x)\n+  pa.construct(p, std::move(pp));\n+  VERIFY(p->first.type == Move);\n+  VERIFY(p->second.type == Move);\n+  pa.destroy(p);\n+  pa.deallocate(p, 1);\n+}\n+\n+void test01() {\n+  test_uses_alloc<A>();\n+  test_uses_alloc<B>();\n+  test_non_alloc<C>();\n+}\n+\n+void test02() {\n+  test_pair<A, A>();\n+  test_pair<A, B>();\n+  test_pair<A, C>();\n+  test_pair<B, B>();\n+  test_pair<B, A>();\n+  test_pair<B, C>();\n+  test_pair<C, C>();\n+}\n+\n+\n+int main() {\n+  test01();\n+  test02();\n+}"}, {"sha": "fc8acf16dcdea5adc69a2031a37d8de8f7973816", "filename": "libstdc++-v3/testsuite/experimental/type_erased_allocator/uses_allocator.cc", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2Fuses_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeffbd1ae0d682c660d13cdc526ae83235cdd14/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2Fuses_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_erased_allocator%2Fuses_allocator.cc?ref=bfeffbd1ae0d682c660d13cdc526ae83235cdd14", "patch": "@@ -0,0 +1,22 @@\n+#include <bits/uses_allocator.h>\n+#include <vector>\n+#include <experimental/utility>\n+#include <memory>\n+\n+using std::vector;\n+using std::allocator;\n+using std::uses_allocator;\n+\n+struct A {\n+  using allocator_type = std::experimental::erased_type;\n+};\n+\n+void test01() {\n+    static_assert(uses_allocator<vector<int>, allocator<int>>());\n+    static_assert(uses_allocator<A, allocator<A>>());\n+}\n+\n+int main() {\n+  test01();\n+  return 0;\n+}"}]}