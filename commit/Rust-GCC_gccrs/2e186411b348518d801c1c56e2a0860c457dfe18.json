{"sha": "2e186411b348518d801c1c56e2a0860c457dfe18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxODY0MTFiMzQ4NTE4ZDgwMWMxYzU2ZTJhMDg2MGM0NTdkZmUxOA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-08-10T23:12:11Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-08-10T23:12:11Z"}, "message": "[LRA] Reload of slow mems\n\npr71680.c -m64 -O1 -mlra, ira output showing two problem insns.\n(insn 7 5 26 3 (set (reg:SI 159 [ a ])\n        (mem/c:SI (reg/f:DI 158) [1 a+0 S4 A8])) pr71680.c:13 464 {*movsi_internal1}\n     (expr_list:REG_EQUIV (mem/c:SI (reg/f:DI 158) [1 a+0 S4 A8])\n        (nil)))\n(insn 26 7 27 3 (set (reg:DI 162)\n        (unspec:DI [\n                (fix:SI (subreg:SF (reg:SI 159 [ a ]) 0))\n            ] UNSPEC_FCTIWZ)) pr71680.c:13 372 {fctiwz_sf}\n     (expr_list:REG_DEAD (reg:SI 159 [ a ])\n        (nil)))\nInsn 26 requires that reg 159 be of class FLOAT_REGS.\n\nfirst lra action:\ndeleting insn with uid = 7.\nChanging pseudo 159 in operand 1 of insn 26 on equiv [r158:DI]\n      Creating newreg=164, assigning class ALL_REGS to subreg reg r164\n   26: r162:DI=unspec[fix(r164:SI#0)] 7\n      REG_DEAD r159:SI\n    Inserting subreg reload before:\n   30: r164:SI=[r158:DI]\n[snip]\n      Change to class FLOAT_REGS for r164\n\nWell, that didn't do much.  lra tried the equiv mem, found that didn't\nwork, and had to reload.  Effectively getting back to the two original\ninsns but r159 replaced with r164.  simplify_operand_subreg did not do\nanything in this case because SLOW_UNALIGNED_ACCESS was true (wrongly\nfor power8, but that's beside the point).  So now we have, using\nabbreviated rtl notation:\nr164:SI=[r158:DI]\nr162:DI=unspec[fix(r164:SI)]\nThe problem here is that the first insn isn't valid, due to the rs6000\nbackend not supporting SImode in fprs, and r164 must be an fpr to make\nthe second insn valid.\n\nnext lra action:\n      Creating newreg=165 from oldreg=164, assigning class GENERAL_REGS to r165\n   30: r165:SI=[r158:DI]\n    Inserting insn reload after:\n   31: r164:SI=r165:SI\nso now we have\nr165:SI=[r158:DI]\nr164:SI=r165:SI\nr162:DI=unspec[fix(r164:SI)]\n\nThis ought to be good on power8, except for one little thing.\nr165 is GENERAL_REGS so the first insn is good, a gpr load from mem.\nr164 is FLOAT_REGS, making the last insn good, a fctiwz.\nThe second insn ought to be a sldi, mtvsrd, xscvspdpn combination, but\nthat is only supported for SFmode.  So lra continue on reloading the\nsecond insn, but in vain because it never tries anything other than\nSImode and as noted above, SImode is not valid in fprs.\n\nWhat this patch does is arrange to emit the two reloads needed for the\nSLOW_UNALIGNED_ACCESS case at once, moving the subreg to the second\ninsn in order to switch modes, producing:\n\nr164:SI=[r158:DI]\nr165:SF=r164:SI#0\nr162:DI=unspec[fix(r165:SF)]\n\nI've also tidied a couple of other things:\n1) \"old\" is unnecessary as it duplicated \"operand\".\n2) Rejecting mem subregs due to SLOW_UNALIGNED_ACCESS only makes sense\nif the original mode was not slow.\n\n\tPR target/71680\n\t* lra-constraints.c (simplify_operand_subreg): Allow subreg\n\tmode for mem when SLOW_UNALIGNED_ACCESS if inner mode is also\n\tslow.  Emit two reloads for slow mem case, first loading in\n\tfast innermode, then converting to required mode.\ntestsuite/\n\t* gcc.target/powerpc/pr71680.c: New.\n\nFrom-SVN: r239342", "tree": {"sha": "aea13312f9fef4e3b0d5a83f6141dfc264530bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aea13312f9fef4e3b0d5a83f6141dfc264530bea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e186411b348518d801c1c56e2a0860c457dfe18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e186411b348518d801c1c56e2a0860c457dfe18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e186411b348518d801c1c56e2a0860c457dfe18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e186411b348518d801c1c56e2a0860c457dfe18/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "452df4a4e62dc8e2ff2ccd0828cde674025fb292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/452df4a4e62dc8e2ff2ccd0828cde674025fb292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/452df4a4e62dc8e2ff2ccd0828cde674025fb292"}], "stats": {"total": 111, "additions": 82, "deletions": 29}, "files": [{"sha": "491f62d17abde03d3cec89883e81f08a509a7a43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e186411b348518d801c1c56e2a0860c457dfe18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e186411b348518d801c1c56e2a0860c457dfe18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e186411b348518d801c1c56e2a0860c457dfe18", "patch": "@@ -1,3 +1,11 @@\n+2016-08-11  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/71680\n+\t* lra-constraints.c (simplify_operand_subreg): Allow subreg\n+\tmode for mem when SLOW_UNALIGNED_ACCESS if inner mode is also\n+\tslow.  Emit two reloads for slow mem case, first loading in\n+\tfast innermode, then converting to required mode.\n+\n 2016-08-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* config/rs6000/altivec.h (vec_extract_exp): New macro."}, {"sha": "213e408c08b207949e0f50cfd718e29060591552", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 70, "deletions": 29, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e186411b348518d801c1c56e2a0860c457dfe18/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e186411b348518d801c1c56e2a0860c457dfe18/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=2e186411b348518d801c1c56e2a0860c457dfe18", "patch": "@@ -1462,47 +1462,88 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n   reg = SUBREG_REG (operand);\n   innermode = GET_MODE (reg);\n   type = curr_static_id->operand[nop].type;\n-  /* If we change address for paradoxical subreg of memory, the\n-     address might violate the necessary alignment or the access might\n-     be slow.  So take this into consideration.  We should not worry\n-     about access beyond allocated memory for paradoxical memory\n-     subregs as we don't substitute such equiv memory (see processing\n-     equivalences in function lra_constraints) and because for spilled\n-     pseudos we allocate stack memory enough for the biggest\n-     corresponding paradoxical subreg.  */\n-  if (MEM_P (reg)\n-      && (! SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (reg))\n-\t  || MEM_ALIGN (reg) >= GET_MODE_ALIGNMENT (mode)))\n+  if (MEM_P (reg))\n     {\n-      rtx subst, old = *curr_id->operand_loc[nop];\n+      rtx subst;\n \n       alter_subreg (curr_id->operand_loc[nop], false);\n       subst = *curr_id->operand_loc[nop];\n       lra_assert (MEM_P (subst));\n       if (! valid_address_p (innermode, XEXP (reg, 0),\n \t\t\t     MEM_ADDR_SPACE (reg))\n \t  || valid_address_p (GET_MODE (subst), XEXP (subst, 0),\n-\t\t\t      MEM_ADDR_SPACE (subst)))\n-\treturn true;\n-      else if ((get_constraint_type (lookup_constraint\n-\t\t\t\t     (curr_static_id->operand[nop].constraint))\n-\t\t!= CT_SPECIAL_MEMORY)\n-\t       /* We still can reload address and if the address is\n-\t\t  valid, we can remove subreg without reloading its\n-\t\t  inner memory.  */\n-\t       && valid_address_p (GET_MODE (subst),\n-\t\t\t\t   regno_reg_rtx\n-\t\t\t\t   [ira_class_hard_regs\n-\t\t\t\t    [base_reg_class (GET_MODE (subst),\n-\t\t\t\t\t\t     MEM_ADDR_SPACE (subst),\n-\t\t\t\t\t\t     ADDRESS, SCRATCH)][0]],\n-\t\t\t\t   MEM_ADDR_SPACE (subst)))\n-\treturn true;\n+\t\t\t      MEM_ADDR_SPACE (subst))\n+\t  || ((get_constraint_type (lookup_constraint\n+\t\t\t\t    (curr_static_id->operand[nop].constraint))\n+\t       != CT_SPECIAL_MEMORY)\n+\t      /* We still can reload address and if the address is\n+\t\t valid, we can remove subreg without reloading its\n+\t\t inner memory.  */\n+\t      && valid_address_p (GET_MODE (subst),\n+\t\t\t\t  regno_reg_rtx\n+\t\t\t\t  [ira_class_hard_regs\n+\t\t\t\t   [base_reg_class (GET_MODE (subst),\n+\t\t\t\t\t\t    MEM_ADDR_SPACE (subst),\n+\t\t\t\t\t\t    ADDRESS, SCRATCH)][0]],\n+\t\t\t\t  MEM_ADDR_SPACE (subst))))\n+\t{\n+\t  /* If we change address for paradoxical subreg of memory, the\n+\t     address might violate the necessary alignment or the access might\n+\t     be slow.  So take this into consideration.  We should not worry\n+\t     about access beyond allocated memory for paradoxical memory\n+\t     subregs as we don't substitute such equiv memory (see processing\n+\t     equivalences in function lra_constraints) and because for spilled\n+\t     pseudos we allocate stack memory enough for the biggest\n+\t     corresponding paradoxical subreg.  */\n+\t  if (!SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (reg))\n+\t      || SLOW_UNALIGNED_ACCESS (innermode, MEM_ALIGN (reg))\n+\t      || MEM_ALIGN (reg) >= GET_MODE_ALIGNMENT (mode))\n+\t    return true;\n+\n+\t  /* INNERMODE is fast, MODE slow.  Reload the mem in INNERMODE.  */\n+\t  enum reg_class rclass\n+\t    = (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n+\t  if (get_reload_reg (curr_static_id->operand[nop].type, innermode, reg,\n+\t\t\t      rclass, TRUE, \"slow mem\", &new_reg))\n+\t    {\n+\t      bool insert_before, insert_after;\n+\t      bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n+\n+\t      insert_before = (type != OP_OUT\n+\t\t\t       || GET_MODE_SIZE (innermode) > GET_MODE_SIZE (mode));\n+\t      insert_after = type != OP_IN;\n+\t      insert_move_for_subreg (insert_before ? &before : NULL,\n+\t\t\t\t      insert_after ? &after : NULL,\n+\t\t\t\t      reg, new_reg);\n+\t    }\n+\t  *curr_id->operand_loc[nop] = operand;\n+\t  SUBREG_REG (operand) = new_reg;\n+\n+\t  /* Convert to MODE.  */\n+\t  reg = operand;\n+\t  rclass = (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n+\t  if (get_reload_reg (curr_static_id->operand[nop].type, mode, reg,\n+\t\t\t      rclass, TRUE, \"slow mem\", &new_reg))\n+\t    {\n+\t      bool insert_before, insert_after;\n+\t      bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n+\n+\t      insert_before = type != OP_OUT;\n+\t      insert_after = type != OP_IN;\n+\t      insert_move_for_subreg (insert_before ? &before : NULL,\n+\t\t\t\t      insert_after ? &after : NULL,\n+\t\t\t\t      reg, new_reg);\n+\t    }\n+\t  *curr_id->operand_loc[nop] = new_reg;\n+\t  lra_process_new_insns (curr_insn, before, after,\n+\t\t\t\t \"Inserting slow mem reload\");\n+\t  return true;\n+\t}\n \n       /* If the address was valid and became invalid, prefer to reload\n \t the memory.  Typical case is when the index scale should\n \t correspond the memory.  */\n-      *curr_id->operand_loc[nop] = old;\n+      *curr_id->operand_loc[nop] = operand;\n     }\n   else if (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     {"}, {"sha": "b77940bc34c8decf60c0ebb68434f176d33ea6a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e186411b348518d801c1c56e2a0860c457dfe18/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e186411b348518d801c1c56e2a0860c457dfe18/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2e186411b348518d801c1c56e2a0860c457dfe18", "patch": "@@ -1,3 +1,7 @@\n+2016-08-11  Alan Modra  <amodra@gmail.com>\n+\n+\t* gcc.target/powerpc/pr71680.c: New.\n+\n 2016-08-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* gcc.target/powerpc/bfp/bfp.exp: New file."}]}