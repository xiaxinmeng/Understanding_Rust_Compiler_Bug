{"sha": "696d846a56cc12549f080c6c87e6a0272bdb29f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk2ZDg0NmE1NmNjMTI1NDlmMDgwYzZjODdlNmEwMjcyYmRiMjlmMQ==", "commit": {"author": {"name": "Max Ostapenko", "email": "m.ostapenko@partner.samsung.com", "date": "2015-10-21T07:32:45Z"}, "committer": {"name": "Maxim Ostapenko", "email": "chefmax@gcc.gnu.org", "date": "2015-10-21T07:32:45Z"}, "message": "libsanitizer merge from upstream r250806.\n\nlibsanitizer/\n\n2015-10-20  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>\n\n\t* All source files: Merge from upstream r250806.\n\t* configure.ac (link_sanitizer_common): Add -lrt flag.\n\t* configure.tgt: Enable TSAN and LSAN for aarch64-linux targets.\n\tSet CXX_ABI_NEEDED=true for darwin.\n\t* asan/Makefile.am (asan_files): Add new files.\n\t(DEFS): Add DCAN_SANITIZE_UB=0 and remove unused and legacy\n\tDASAN_FLEXIBLE_MAPPING_AND_OFFSET=0.\n\t* asan/Makefile.in: Regenerate.\n\t* ubsan/Makefile.am (ubsan_files): Add new files.\n\t(DEFS): Add DCAN_SANITIZE_UB=1.\n\t(libubsan_la_LIBADD): Add -lc++abi if CXX_ABI_NEEDED is true.\n\t* ubsan/Makefile.in: Regenerate.\n\t* tsan/Makefile.am (tsan_files): Add new files.\n\t(DEFS): Add DCAN_SANITIZE_UB=0.\n\t* tsan/Makefile.in: Regenerate.\n\t* sanitizer_common/Makefile.am (sanitizer_common_files): Add new files.\n\t* sanitizer_common/Makefile.in: Regenerate.\n\t* asan/libtool-version: Bump the libasan SONAME.\n\nFrom-SVN: r229111", "tree": {"sha": "2bdaf703dd35e1806b59bd7d74c7eee290a1054f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bdaf703dd35e1806b59bd7d74c7eee290a1054f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/696d846a56cc12549f080c6c87e6a0272bdb29f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/696d846a56cc12549f080c6c87e6a0272bdb29f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/696d846a56cc12549f080c6c87e6a0272bdb29f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/696d846a56cc12549f080c6c87e6a0272bdb29f1/comments", "author": null, "committer": null, "parents": [{"sha": "013a8899f5d9469a835cf1f6ccb1b29f69344959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013a8899f5d9469a835cf1f6ccb1b29f69344959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/013a8899f5d9469a835cf1f6ccb1b29f69344959"}], "stats": {"total": 18750, "additions": 12307, "deletions": 6443}, "files": [{"sha": "3316629c8097b301e5ed715e810c7799b70adb3f", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -1,3 +1,24 @@\n+2015-10-21  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>\n+\n+\t* All source files: Merge from upstream r250806.\n+\t* configure.ac (link_sanitizer_common): Add -lrt flag.\n+\t* configure.tgt: Enable TSAN and LSAN for aarch64-linux targets.\n+\tSet USE_CXX_ABI_FLAG=true for darwin.\n+\t* asan/Makefile.am (asan_files): Add new files.\n+\t(DEFS): Add DCAN_SANITIZE_UB=0 and remove unused and legacy\n+\tDASAN_FLEXIBLE_MAPPING_AND_OFFSET=0.\n+\t* asan/Makefile.in: Regenerate.\n+\t* ubsan/Makefile.am (ubsan_files): Add new files.\n+\t(DEFS): Add DCAN_SANITIZE_UB=1.\n+\t(libubsan_la_LIBADD): Add -lc++abi if USE_CXX_ABI_FLAG is true.\n+\t* ubsan/Makefile.in: Regenerate.\n+\t* tsan/Makefile.am (tsan_files): Add new files.\n+\t(DEFS): Add DCAN_SANITIZE_UB=0.\n+\t* tsan/Makefile.in: Regenerate.\n+\t* sanitizer_common/Makefile.am (sanitizer_common_files): Add new files.\n+\t* sanitizer_common/Makefile.in: Regenerate.\n+\t* asan/libtool-version: Bump the libasan SONAME.\n+\n 2015-09-09  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \tPR sanitizer/67258"}, {"sha": "6ff9a9acc6b42818b3318f0f59cc2fdec8b8bca1", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -1,4 +1,4 @@\n-221802\n+250806\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "bd3cd735a982392249619873e3745f46b9983eaa", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -3,7 +3,7 @@ AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n # May be used by toolexeclibdir.\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n \n-DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_FLEXIBLE_MAPPING_AND_OFFSET=0 -DASAN_NEEDS_SEGV=1\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_NEEDS_SEGV=1 -DCAN_SANITIZE_UB=0\n if USING_MAC_INTERPOSE\n DEFS += -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT\n endif\n@@ -17,9 +17,10 @@ nodist_toolexeclib_HEADERS = libasan_preinit.o\n \n asan_files = \\\n \tasan_activation.cc \\\n-\tasan_allocator2.cc \\\n+\tasan_allocator.cc \\\n \tasan_debugging.cc \\\n \tasan_fake_stack.cc \\\n+\tasan_flags.cc \\\n \tasan_globals.cc \\\n \tasan_interceptors.cc \\\n \tasan_linux.cc \\\n@@ -34,6 +35,7 @@ asan_files = \\\n \tasan_rtl.cc \\\n \tasan_stack.cc \\\n \tasan_stats.cc \\\n+\tasan_suppressions.cc \\\n \tasan_thread.cc \\\n \tasan_win.cc \\\n \tasan_win_dll_thunk.cc \\"}, {"sha": "229c7b400d1094b85868dc5aedb19a2620d05154", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -111,14 +111,14 @@ libasan_la_DEPENDENCIES =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(top_builddir)/lsan/libsanitizer_lsan.la $(am__append_2) \\\n \t$(am__append_3) $(am__DEPENDENCIES_1)\n-am__objects_1 = asan_activation.lo asan_allocator2.lo \\\n-\tasan_debugging.lo asan_fake_stack.lo asan_globals.lo \\\n+am__objects_1 = asan_activation.lo asan_allocator.lo asan_debugging.lo \\\n+\tasan_fake_stack.lo asan_flags.lo asan_globals.lo \\\n \tasan_interceptors.lo asan_linux.lo asan_mac.lo \\\n \tasan_malloc_linux.lo asan_malloc_mac.lo asan_malloc_win.lo \\\n \tasan_new_delete.lo asan_poisoning.lo asan_posix.lo \\\n \tasan_report.lo asan_rtl.lo asan_stack.lo asan_stats.lo \\\n-\tasan_thread.lo asan_win.lo asan_win_dll_thunk.lo \\\n-\tasan_win_dynamic_runtime_thunk.lo\n+\tasan_suppressions.lo asan_thread.lo asan_win.lo \\\n+\tasan_win_dll_thunk.lo asan_win_dynamic_runtime_thunk.lo\n am_libasan_la_OBJECTS = $(am__objects_1)\n libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n libasan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -172,8 +172,8 @@ CXXFLAGS = @CXXFLAGS@\n CYGPATH_W = @CYGPATH_W@\n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \\\n \t-D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \\\n-\t-DASAN_HAS_EXCEPTIONS=1 -DASAN_FLEXIBLE_MAPPING_AND_OFFSET=0 \\\n-\t-DASAN_NEEDS_SEGV=1 $(am__append_1)\n+\t-DASAN_HAS_EXCEPTIONS=1 -DASAN_NEEDS_SEGV=1 \\\n+\t-DCAN_SANITIZE_UB=0 $(am__append_1)\n DEPDIR = @DEPDIR@\n DSYMUTIL = @DSYMUTIL@\n DUMPBIN = @DUMPBIN@\n@@ -306,9 +306,10 @@ toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o\n asan_files = \\\n \tasan_activation.cc \\\n-\tasan_allocator2.cc \\\n+\tasan_allocator.cc \\\n \tasan_debugging.cc \\\n \tasan_fake_stack.cc \\\n+\tasan_flags.cc \\\n \tasan_globals.cc \\\n \tasan_interceptors.cc \\\n \tasan_linux.cc \\\n@@ -323,6 +324,7 @@ asan_files = \\\n \tasan_rtl.cc \\\n \tasan_stack.cc \\\n \tasan_stats.cc \\\n+\tasan_suppressions.cc \\\n \tasan_thread.cc \\\n \tasan_win.cc \\\n \tasan_win_dll_thunk.cc \\\n@@ -450,9 +452,10 @@ distclean-compile:\n \t-rm -f *.tab.c\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_activation.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_debugging.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_fake_stack.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_linux.Plo@am__quote@\n@@ -467,6 +470,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stats.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_suppressions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win_dll_thunk.Plo@am__quote@"}, {"sha": "58867956086da47285c41fc2fde55b5e34c5e0c1", "filename": "libsanitizer/asan/asan_activation.cc", "status": "modified", "additions": 99, "deletions": 29, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_activation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_activation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,32 +14,106 @@\n #include \"asan_allocator.h\"\n #include \"asan_flags.h\"\n #include \"asan_internal.h\"\n+#include \"asan_poisoning.h\"\n+#include \"asan_stack.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n \n namespace __asan {\n \n static struct AsanDeactivatedFlags {\n-  int quarantine_size;\n-  int max_redzone;\n+  AllocatorOptions allocator_options;\n   int malloc_context_size;\n   bool poison_heap;\n+  bool coverage;\n+  const char *coverage_dir;\n+\n+  void RegisterActivationFlags(FlagParser *parser, Flags *f, CommonFlags *cf) {\n+#define ASAN_ACTIVATION_FLAG(Type, Name) \\\n+  RegisterFlag(parser, #Name, \"\", &f->Name);\n+#define COMMON_ACTIVATION_FLAG(Type, Name) \\\n+  RegisterFlag(parser, #Name, \"\", &cf->Name);\n+#include \"asan_activation_flags.inc\"\n+#undef ASAN_ACTIVATION_FLAG\n+#undef COMMON_ACTIVATION_FLAG\n+\n+    RegisterIncludeFlags(parser, cf);\n+  }\n+\n+  void OverrideFromActivationFlags() {\n+    Flags f;\n+    CommonFlags cf;\n+    FlagParser parser;\n+    RegisterActivationFlags(&parser, &f, &cf);\n+\n+    // Copy the current activation flags.\n+    allocator_options.CopyTo(&f, &cf);\n+    cf.malloc_context_size = malloc_context_size;\n+    f.poison_heap = poison_heap;\n+    cf.coverage = coverage;\n+    cf.coverage_dir = coverage_dir;\n+    cf.verbosity = Verbosity();\n+    cf.help = false; // this is activation-specific help\n+\n+    // Check if activation flags need to be overriden.\n+    if (const char *env = GetEnv(\"ASAN_ACTIVATION_OPTIONS\")) {\n+      parser.ParseString(env);\n+    }\n+\n+    // Override from getprop asan.options.\n+    char buf[100];\n+    GetExtraActivationFlags(buf, sizeof(buf));\n+    parser.ParseString(buf);\n+\n+    SetVerbosity(cf.verbosity);\n+\n+    if (Verbosity()) ReportUnrecognizedFlags();\n+\n+    if (cf.help) parser.PrintFlagDescriptions();\n+\n+    allocator_options.SetFrom(&f, &cf);\n+    malloc_context_size = cf.malloc_context_size;\n+    poison_heap = f.poison_heap;\n+    coverage = cf.coverage;\n+    coverage_dir = cf.coverage_dir;\n+  }\n+\n+  void Print() {\n+    Report(\n+        \"quarantine_size_mb %d, max_redzone %d, poison_heap %d, \"\n+        \"malloc_context_size %d, alloc_dealloc_mismatch %d, \"\n+        \"allocator_may_return_null %d, coverage %d, coverage_dir %s\\n\",\n+        allocator_options.quarantine_size_mb, allocator_options.max_redzone,\n+        poison_heap, malloc_context_size,\n+        allocator_options.alloc_dealloc_mismatch,\n+        allocator_options.may_return_null, coverage, coverage_dir);\n+  }\n } asan_deactivated_flags;\n \n static bool asan_is_deactivated;\n \n-void AsanStartDeactivated() {\n+void AsanDeactivate() {\n+  CHECK(!asan_is_deactivated);\n   VReport(1, \"Deactivating ASan\\n\");\n-  // Save flag values.\n-  asan_deactivated_flags.quarantine_size = flags()->quarantine_size;\n-  asan_deactivated_flags.max_redzone = flags()->max_redzone;\n-  asan_deactivated_flags.poison_heap = flags()->poison_heap;\n-  asan_deactivated_flags.malloc_context_size =\n-      common_flags()->malloc_context_size;\n-\n-  flags()->quarantine_size = 0;\n-  flags()->max_redzone = 16;\n-  flags()->poison_heap = false;\n-  common_flags()->malloc_context_size = 0;\n+\n+  // Stash runtime state.\n+  GetAllocatorOptions(&asan_deactivated_flags.allocator_options);\n+  asan_deactivated_flags.malloc_context_size = GetMallocContextSize();\n+  asan_deactivated_flags.poison_heap = CanPoisonMemory();\n+  asan_deactivated_flags.coverage = common_flags()->coverage;\n+  asan_deactivated_flags.coverage_dir = common_flags()->coverage_dir;\n+\n+  // Deactivate the runtime.\n+  SetCanPoisonMemory(false);\n+  SetMallocContextSize(1);\n+  ReInitializeCoverage(false, nullptr);\n+\n+  AllocatorOptions disabled = asan_deactivated_flags.allocator_options;\n+  disabled.quarantine_size_mb = 0;\n+  disabled.min_redzone = 16;  // Redzone must be at least 16 bytes long.\n+  disabled.max_redzone = 16;\n+  disabled.alloc_dealloc_mismatch = false;\n+  disabled.may_return_null = true;\n+  ReInitializeAllocator(disabled);\n \n   asan_is_deactivated = true;\n }\n@@ -48,25 +122,21 @@ void AsanActivate() {\n   if (!asan_is_deactivated) return;\n   VReport(1, \"Activating ASan\\n\");\n \n-  // Restore flag values.\n-  // FIXME: this is not atomic, and there may be other threads alive.\n-  flags()->quarantine_size = asan_deactivated_flags.quarantine_size;\n-  flags()->max_redzone = asan_deactivated_flags.max_redzone;\n-  flags()->poison_heap = asan_deactivated_flags.poison_heap;\n-  common_flags()->malloc_context_size =\n-      asan_deactivated_flags.malloc_context_size;\n+  UpdateProcessName();\n \n-  ParseExtraActivationFlags();\n+  asan_deactivated_flags.OverrideFromActivationFlags();\n \n-  ReInitializeAllocator();\n+  SetCanPoisonMemory(asan_deactivated_flags.poison_heap);\n+  SetMallocContextSize(asan_deactivated_flags.malloc_context_size);\n+  ReInitializeCoverage(asan_deactivated_flags.coverage,\n+                       asan_deactivated_flags.coverage_dir);\n+  ReInitializeAllocator(asan_deactivated_flags.allocator_options);\n \n   asan_is_deactivated = false;\n-  VReport(\n-      1,\n-      \"quarantine_size %d, max_redzone %d, poison_heap %d, malloc_context_size \"\n-      \"%d\\n\",\n-      flags()->quarantine_size, flags()->max_redzone, flags()->poison_heap,\n-      common_flags()->malloc_context_size);\n+  if (Verbosity()) {\n+    Report(\"Activated with flags:\\n\");\n+    asan_deactivated_flags.Print();\n+  }\n }\n \n }  // namespace __asan"}, {"sha": "162a5ebcea98e0fefab75e7bce7ac4fc7a0177ff", "filename": "libsanitizer/asan/asan_activation.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_activation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_activation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,7 +14,7 @@\n #define ASAN_ACTIVATION_H\n \n namespace __asan {\n-void AsanStartDeactivated();\n+void AsanDeactivate();\n void AsanActivate();\n }  // namespace __asan\n "}, {"sha": "4bab38213c19ded6e3bd7c8bf577548fb759e543", "filename": "libsanitizer/asan/asan_activation_flags.inc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_activation_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_activation_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation_flags.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,33 @@\n+//===-- asan_activation_flags.inc -------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// A subset of ASan (and common) runtime flags supported at activation time.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_ACTIVATION_FLAG\n+# error \"Define ASAN_ACTIVATION_FLAG prior to including this file!\"\n+#endif\n+\n+#ifndef COMMON_ACTIVATION_FLAG\n+# error \"Define COMMON_ACTIVATION_FLAG prior to including this file!\"\n+#endif\n+\n+// ASAN_ACTIVATION_FLAG(Type, Name)\n+// See COMMON_FLAG in sanitizer_flags.inc for more details.\n+\n+ASAN_ACTIVATION_FLAG(int, redzone)\n+ASAN_ACTIVATION_FLAG(int, max_redzone)\n+ASAN_ACTIVATION_FLAG(int, quarantine_size_mb)\n+ASAN_ACTIVATION_FLAG(bool, alloc_dealloc_mismatch)\n+ASAN_ACTIVATION_FLAG(bool, poison_heap)\n+\n+COMMON_ACTIVATION_FLAG(bool, allocator_may_return_null)\n+COMMON_ACTIVATION_FLAG(int, malloc_context_size)\n+COMMON_ACTIVATION_FLAG(bool, coverage)\n+COMMON_ACTIVATION_FLAG(const char *, coverage_dir)\n+COMMON_ACTIVATION_FLAG(int, verbosity)\n+COMMON_ACTIVATION_FLAG(bool, help)"}, {"sha": "187c405e118e27a0352564222fd3cde2a410a180", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "added", "additions": 906, "deletions": 0, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,906 @@\n+//===-- asan_allocator.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Implementation of ASan's memory allocator, 2-nd version.\n+// This variant uses the allocator from sanitizer_common, i.e. the one shared\n+// with ThreadSanitizer and MemorySanitizer.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_list.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_quarantine.h\"\n+#include \"lsan/lsan_common.h\"\n+\n+namespace __asan {\n+\n+// Valid redzone sizes are 16, 32, 64, ... 2048, so we encode them in 3 bits.\n+// We use adaptive redzones: for larger allocation larger redzones are used.\n+static u32 RZLog2Size(u32 rz_log) {\n+  CHECK_LT(rz_log, 8);\n+  return 16 << rz_log;\n+}\n+\n+static u32 RZSize2Log(u32 rz_size) {\n+  CHECK_GE(rz_size, 16);\n+  CHECK_LE(rz_size, 2048);\n+  CHECK(IsPowerOfTwo(rz_size));\n+  u32 res = Log2(rz_size) - 4;\n+  CHECK_EQ(rz_size, RZLog2Size(res));\n+  return res;\n+}\n+\n+static AsanAllocator &get_allocator();\n+\n+// The memory chunk allocated from the underlying allocator looks like this:\n+// L L L L L L H H U U U U U U R R\n+//   L -- left redzone words (0 or more bytes)\n+//   H -- ChunkHeader (16 bytes), which is also a part of the left redzone.\n+//   U -- user memory.\n+//   R -- right redzone (0 or more bytes)\n+// ChunkBase consists of ChunkHeader and other bytes that overlap with user\n+// memory.\n+\n+// If the left redzone is greater than the ChunkHeader size we store a magic\n+// value in the first uptr word of the memory block and store the address of\n+// ChunkBase in the next uptr.\n+// M B L L L L L L L L L  H H U U U U U U\n+//   |                    ^\n+//   ---------------------|\n+//   M -- magic value kAllocBegMagic\n+//   B -- address of ChunkHeader pointing to the first 'H'\n+static const uptr kAllocBegMagic = 0xCC6E96B9;\n+\n+struct ChunkHeader {\n+  // 1-st 8 bytes.\n+  u32 chunk_state       : 8;  // Must be first.\n+  u32 alloc_tid         : 24;\n+\n+  u32 free_tid          : 24;\n+  u32 from_memalign     : 1;\n+  u32 alloc_type        : 2;\n+  u32 rz_log            : 3;\n+  u32 lsan_tag          : 2;\n+  // 2-nd 8 bytes\n+  // This field is used for small sizes. For large sizes it is equal to\n+  // SizeClassMap::kMaxSize and the actual size is stored in the\n+  // SecondaryAllocator's metadata.\n+  u32 user_requested_size;\n+  u32 alloc_context_id;\n+};\n+\n+struct ChunkBase : ChunkHeader {\n+  // Header2, intersects with user memory.\n+  u32 free_context_id;\n+};\n+\n+static const uptr kChunkHeaderSize = sizeof(ChunkHeader);\n+static const uptr kChunkHeader2Size = sizeof(ChunkBase) - kChunkHeaderSize;\n+COMPILER_CHECK(kChunkHeaderSize == 16);\n+COMPILER_CHECK(kChunkHeader2Size <= 16);\n+\n+// Every chunk of memory allocated by this allocator can be in one of 3 states:\n+// CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.\n+// CHUNK_ALLOCATED: the chunk is allocated and not yet freed.\n+// CHUNK_QUARANTINE: the chunk was freed and put into quarantine zone.\n+enum {\n+  CHUNK_AVAILABLE  = 0,  // 0 is the default value even if we didn't set it.\n+  CHUNK_ALLOCATED  = 2,\n+  CHUNK_QUARANTINE = 3\n+};\n+\n+struct AsanChunk: ChunkBase {\n+  uptr Beg() { return reinterpret_cast<uptr>(this) + kChunkHeaderSize; }\n+  uptr UsedSize(bool locked_version = false) {\n+    if (user_requested_size != SizeClassMap::kMaxSize)\n+      return user_requested_size;\n+    return *reinterpret_cast<uptr *>(\n+               get_allocator().GetMetaData(AllocBeg(locked_version)));\n+  }\n+  void *AllocBeg(bool locked_version = false) {\n+    if (from_memalign) {\n+      if (locked_version)\n+        return get_allocator().GetBlockBeginFastLocked(\n+            reinterpret_cast<void *>(this));\n+      return get_allocator().GetBlockBegin(reinterpret_cast<void *>(this));\n+    }\n+    return reinterpret_cast<void*>(Beg() - RZLog2Size(rz_log));\n+  }\n+  bool AddrIsInside(uptr addr, bool locked_version = false) {\n+    return (addr >= Beg()) && (addr < Beg() + UsedSize(locked_version));\n+  }\n+};\n+\n+struct QuarantineCallback {\n+  explicit QuarantineCallback(AllocatorCache *cache)\n+      : cache_(cache) {\n+  }\n+\n+  void Recycle(AsanChunk *m) {\n+    CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n+    atomic_store((atomic_uint8_t*)m, CHUNK_AVAILABLE, memory_order_relaxed);\n+    CHECK_NE(m->alloc_tid, kInvalidTid);\n+    CHECK_NE(m->free_tid, kInvalidTid);\n+    PoisonShadow(m->Beg(),\n+                 RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n+                 kAsanHeapLeftRedzoneMagic);\n+    void *p = reinterpret_cast<void *>(m->AllocBeg());\n+    if (p != m) {\n+      uptr *alloc_magic = reinterpret_cast<uptr *>(p);\n+      CHECK_EQ(alloc_magic[0], kAllocBegMagic);\n+      // Clear the magic value, as allocator internals may overwrite the\n+      // contents of deallocated chunk, confusing GetAsanChunk lookup.\n+      alloc_magic[0] = 0;\n+      CHECK_EQ(alloc_magic[1], reinterpret_cast<uptr>(m));\n+    }\n+\n+    // Statistics.\n+    AsanStats &thread_stats = GetCurrentThreadStats();\n+    thread_stats.real_frees++;\n+    thread_stats.really_freed += m->UsedSize();\n+\n+    get_allocator().Deallocate(cache_, p);\n+  }\n+\n+  void *Allocate(uptr size) {\n+    return get_allocator().Allocate(cache_, size, 1, false);\n+  }\n+\n+  void Deallocate(void *p) {\n+    get_allocator().Deallocate(cache_, p);\n+  }\n+\n+  AllocatorCache *cache_;\n+};\n+\n+typedef Quarantine<QuarantineCallback, AsanChunk> AsanQuarantine;\n+typedef AsanQuarantine::Cache QuarantineCache;\n+\n+void AsanMapUnmapCallback::OnMap(uptr p, uptr size) const {\n+  PoisonShadow(p, size, kAsanHeapLeftRedzoneMagic);\n+  // Statistics.\n+  AsanStats &thread_stats = GetCurrentThreadStats();\n+  thread_stats.mmaps++;\n+  thread_stats.mmaped += size;\n+}\n+void AsanMapUnmapCallback::OnUnmap(uptr p, uptr size) const {\n+  PoisonShadow(p, size, 0);\n+  // We are about to unmap a chunk of user memory.\n+  // Mark the corresponding shadow memory as not needed.\n+  FlushUnneededASanShadowMemory(p, size);\n+  // Statistics.\n+  AsanStats &thread_stats = GetCurrentThreadStats();\n+  thread_stats.munmaps++;\n+  thread_stats.munmaped += size;\n+}\n+\n+// We can not use THREADLOCAL because it is not supported on some of the\n+// platforms we care about (OSX 10.6, Android).\n+// static THREADLOCAL AllocatorCache cache;\n+AllocatorCache *GetAllocatorCache(AsanThreadLocalMallocStorage *ms) {\n+  CHECK(ms);\n+  return &ms->allocator_cache;\n+}\n+\n+QuarantineCache *GetQuarantineCache(AsanThreadLocalMallocStorage *ms) {\n+  CHECK(ms);\n+  CHECK_LE(sizeof(QuarantineCache), sizeof(ms->quarantine_cache));\n+  return reinterpret_cast<QuarantineCache *>(ms->quarantine_cache);\n+}\n+\n+void AllocatorOptions::SetFrom(const Flags *f, const CommonFlags *cf) {\n+  quarantine_size_mb = f->quarantine_size_mb;\n+  min_redzone = f->redzone;\n+  max_redzone = f->max_redzone;\n+  may_return_null = cf->allocator_may_return_null;\n+  alloc_dealloc_mismatch = f->alloc_dealloc_mismatch;\n+}\n+\n+void AllocatorOptions::CopyTo(Flags *f, CommonFlags *cf) {\n+  f->quarantine_size_mb = quarantine_size_mb;\n+  f->redzone = min_redzone;\n+  f->max_redzone = max_redzone;\n+  cf->allocator_may_return_null = may_return_null;\n+  f->alloc_dealloc_mismatch = alloc_dealloc_mismatch;\n+}\n+\n+struct Allocator {\n+  static const uptr kMaxAllowedMallocSize =\n+      FIRST_32_SECOND_64(3UL << 30, 1UL << 40);\n+  static const uptr kMaxThreadLocalQuarantine =\n+      FIRST_32_SECOND_64(1 << 18, 1 << 20);\n+\n+  AsanAllocator allocator;\n+  AsanQuarantine quarantine;\n+  StaticSpinMutex fallback_mutex;\n+  AllocatorCache fallback_allocator_cache;\n+  QuarantineCache fallback_quarantine_cache;\n+\n+  // ------------------- Options --------------------------\n+  atomic_uint16_t min_redzone;\n+  atomic_uint16_t max_redzone;\n+  atomic_uint8_t alloc_dealloc_mismatch;\n+\n+  // ------------------- Initialization ------------------------\n+  explicit Allocator(LinkerInitialized)\n+      : quarantine(LINKER_INITIALIZED),\n+        fallback_quarantine_cache(LINKER_INITIALIZED) {}\n+\n+  void CheckOptions(const AllocatorOptions &options) const {\n+    CHECK_GE(options.min_redzone, 16);\n+    CHECK_GE(options.max_redzone, options.min_redzone);\n+    CHECK_LE(options.max_redzone, 2048);\n+    CHECK(IsPowerOfTwo(options.min_redzone));\n+    CHECK(IsPowerOfTwo(options.max_redzone));\n+  }\n+\n+  void SharedInitCode(const AllocatorOptions &options) {\n+    CheckOptions(options);\n+    quarantine.Init((uptr)options.quarantine_size_mb << 20,\n+                    kMaxThreadLocalQuarantine);\n+    atomic_store(&alloc_dealloc_mismatch, options.alloc_dealloc_mismatch,\n+                 memory_order_release);\n+    atomic_store(&min_redzone, options.min_redzone, memory_order_release);\n+    atomic_store(&max_redzone, options.max_redzone, memory_order_release);\n+  }\n+\n+  void Initialize(const AllocatorOptions &options) {\n+    allocator.Init(options.may_return_null);\n+    SharedInitCode(options);\n+  }\n+\n+  void ReInitialize(const AllocatorOptions &options) {\n+    allocator.SetMayReturnNull(options.may_return_null);\n+    SharedInitCode(options);\n+  }\n+\n+  void GetOptions(AllocatorOptions *options) const {\n+    options->quarantine_size_mb = quarantine.GetSize() >> 20;\n+    options->min_redzone = atomic_load(&min_redzone, memory_order_acquire);\n+    options->max_redzone = atomic_load(&max_redzone, memory_order_acquire);\n+    options->may_return_null = allocator.MayReturnNull();\n+    options->alloc_dealloc_mismatch =\n+        atomic_load(&alloc_dealloc_mismatch, memory_order_acquire);\n+  }\n+\n+  // -------------------- Helper methods. -------------------------\n+  uptr ComputeRZLog(uptr user_requested_size) {\n+    u32 rz_log =\n+      user_requested_size <= 64        - 16   ? 0 :\n+      user_requested_size <= 128       - 32   ? 1 :\n+      user_requested_size <= 512       - 64   ? 2 :\n+      user_requested_size <= 4096      - 128  ? 3 :\n+      user_requested_size <= (1 << 14) - 256  ? 4 :\n+      user_requested_size <= (1 << 15) - 512  ? 5 :\n+      user_requested_size <= (1 << 16) - 1024 ? 6 : 7;\n+    u32 min_rz = atomic_load(&min_redzone, memory_order_acquire);\n+    u32 max_rz = atomic_load(&max_redzone, memory_order_acquire);\n+    return Min(Max(rz_log, RZSize2Log(min_rz)), RZSize2Log(max_rz));\n+  }\n+\n+  // We have an address between two chunks, and we want to report just one.\n+  AsanChunk *ChooseChunk(uptr addr, AsanChunk *left_chunk,\n+                         AsanChunk *right_chunk) {\n+    // Prefer an allocated chunk over freed chunk and freed chunk\n+    // over available chunk.\n+    if (left_chunk->chunk_state != right_chunk->chunk_state) {\n+      if (left_chunk->chunk_state == CHUNK_ALLOCATED)\n+        return left_chunk;\n+      if (right_chunk->chunk_state == CHUNK_ALLOCATED)\n+        return right_chunk;\n+      if (left_chunk->chunk_state == CHUNK_QUARANTINE)\n+        return left_chunk;\n+      if (right_chunk->chunk_state == CHUNK_QUARANTINE)\n+        return right_chunk;\n+    }\n+    // Same chunk_state: choose based on offset.\n+    sptr l_offset = 0, r_offset = 0;\n+    CHECK(AsanChunkView(left_chunk).AddrIsAtRight(addr, 1, &l_offset));\n+    CHECK(AsanChunkView(right_chunk).AddrIsAtLeft(addr, 1, &r_offset));\n+    if (l_offset < r_offset)\n+      return left_chunk;\n+    return right_chunk;\n+  }\n+\n+  // -------------------- Allocation/Deallocation routines ---------------\n+  void *Allocate(uptr size, uptr alignment, BufferedStackTrace *stack,\n+                 AllocType alloc_type, bool can_fill) {\n+    if (UNLIKELY(!asan_inited))\n+      AsanInitFromRtl();\n+    Flags &fl = *flags();\n+    CHECK(stack);\n+    const uptr min_alignment = SHADOW_GRANULARITY;\n+    if (alignment < min_alignment)\n+      alignment = min_alignment;\n+    if (size == 0) {\n+      // We'd be happy to avoid allocating memory for zero-size requests, but\n+      // some programs/tests depend on this behavior and assume that malloc\n+      // would not return NULL even for zero-size allocations. Moreover, it\n+      // looks like operator new should never return NULL, and results of\n+      // consecutive \"new\" calls must be different even if the allocated size\n+      // is zero.\n+      size = 1;\n+    }\n+    CHECK(IsPowerOfTwo(alignment));\n+    uptr rz_log = ComputeRZLog(size);\n+    uptr rz_size = RZLog2Size(rz_log);\n+    uptr rounded_size = RoundUpTo(Max(size, kChunkHeader2Size), alignment);\n+    uptr needed_size = rounded_size + rz_size;\n+    if (alignment > min_alignment)\n+      needed_size += alignment;\n+    bool using_primary_allocator = true;\n+    // If we are allocating from the secondary allocator, there will be no\n+    // automatic right redzone, so add the right redzone manually.\n+    if (!PrimaryAllocator::CanAllocate(needed_size, alignment)) {\n+      needed_size += rz_size;\n+      using_primary_allocator = false;\n+    }\n+    CHECK(IsAligned(needed_size, min_alignment));\n+    if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n+      Report(\"WARNING: AddressSanitizer failed to allocate 0x%zx bytes\\n\",\n+             (void*)size);\n+      return allocator.ReturnNullOrDie();\n+    }\n+\n+    AsanThread *t = GetCurrentThread();\n+    void *allocated;\n+    bool check_rss_limit = true;\n+    if (t) {\n+      AllocatorCache *cache = GetAllocatorCache(&t->malloc_storage());\n+      allocated =\n+          allocator.Allocate(cache, needed_size, 8, false, check_rss_limit);\n+    } else {\n+      SpinMutexLock l(&fallback_mutex);\n+      AllocatorCache *cache = &fallback_allocator_cache;\n+      allocated =\n+          allocator.Allocate(cache, needed_size, 8, false, check_rss_limit);\n+    }\n+\n+    if (!allocated)\n+      return allocator.ReturnNullOrDie();\n+\n+    if (*(u8 *)MEM_TO_SHADOW((uptr)allocated) == 0 && CanPoisonMemory()) {\n+      // Heap poisoning is enabled, but the allocator provides an unpoisoned\n+      // chunk. This is possible if CanPoisonMemory() was false for some\n+      // time, for example, due to flags()->start_disabled.\n+      // Anyway, poison the block before using it for anything else.\n+      uptr allocated_size = allocator.GetActuallyAllocatedSize(allocated);\n+      PoisonShadow((uptr)allocated, allocated_size, kAsanHeapLeftRedzoneMagic);\n+    }\n+\n+    uptr alloc_beg = reinterpret_cast<uptr>(allocated);\n+    uptr alloc_end = alloc_beg + needed_size;\n+    uptr beg_plus_redzone = alloc_beg + rz_size;\n+    uptr user_beg = beg_plus_redzone;\n+    if (!IsAligned(user_beg, alignment))\n+      user_beg = RoundUpTo(user_beg, alignment);\n+    uptr user_end = user_beg + size;\n+    CHECK_LE(user_end, alloc_end);\n+    uptr chunk_beg = user_beg - kChunkHeaderSize;\n+    AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n+    m->alloc_type = alloc_type;\n+    m->rz_log = rz_log;\n+    u32 alloc_tid = t ? t->tid() : 0;\n+    m->alloc_tid = alloc_tid;\n+    CHECK_EQ(alloc_tid, m->alloc_tid);  // Does alloc_tid fit into the bitfield?\n+    m->free_tid = kInvalidTid;\n+    m->from_memalign = user_beg != beg_plus_redzone;\n+    if (alloc_beg != chunk_beg) {\n+      CHECK_LE(alloc_beg+ 2 * sizeof(uptr), chunk_beg);\n+      reinterpret_cast<uptr *>(alloc_beg)[0] = kAllocBegMagic;\n+      reinterpret_cast<uptr *>(alloc_beg)[1] = chunk_beg;\n+    }\n+    if (using_primary_allocator) {\n+      CHECK(size);\n+      m->user_requested_size = size;\n+      CHECK(allocator.FromPrimary(allocated));\n+    } else {\n+      CHECK(!allocator.FromPrimary(allocated));\n+      m->user_requested_size = SizeClassMap::kMaxSize;\n+      uptr *meta = reinterpret_cast<uptr *>(allocator.GetMetaData(allocated));\n+      meta[0] = size;\n+      meta[1] = chunk_beg;\n+    }\n+\n+    m->alloc_context_id = StackDepotPut(*stack);\n+\n+    uptr size_rounded_down_to_granularity =\n+        RoundDownTo(size, SHADOW_GRANULARITY);\n+    // Unpoison the bulk of the memory region.\n+    if (size_rounded_down_to_granularity)\n+      PoisonShadow(user_beg, size_rounded_down_to_granularity, 0);\n+    // Deal with the end of the region if size is not aligned to granularity.\n+    if (size != size_rounded_down_to_granularity && CanPoisonMemory()) {\n+      u8 *shadow =\n+          (u8 *)MemToShadow(user_beg + size_rounded_down_to_granularity);\n+      *shadow = fl.poison_partial ? (size & (SHADOW_GRANULARITY - 1)) : 0;\n+    }\n+\n+    AsanStats &thread_stats = GetCurrentThreadStats();\n+    thread_stats.mallocs++;\n+    thread_stats.malloced += size;\n+    thread_stats.malloced_redzones += needed_size - size;\n+    if (needed_size > SizeClassMap::kMaxSize)\n+      thread_stats.malloc_large++;\n+    else\n+      thread_stats.malloced_by_size[SizeClassMap::ClassID(needed_size)]++;\n+\n+    void *res = reinterpret_cast<void *>(user_beg);\n+    if (can_fill && fl.max_malloc_fill_size) {\n+      uptr fill_size = Min(size, (uptr)fl.max_malloc_fill_size);\n+      REAL(memset)(res, fl.malloc_fill_byte, fill_size);\n+    }\n+#if CAN_SANITIZE_LEAKS\n+    m->lsan_tag = __lsan::DisabledInThisThread() ? __lsan::kIgnored\n+                                                 : __lsan::kDirectlyLeaked;\n+#endif\n+    // Must be the last mutation of metadata in this function.\n+    atomic_store((atomic_uint8_t *)m, CHUNK_ALLOCATED, memory_order_release);\n+    ASAN_MALLOC_HOOK(res, size);\n+    return res;\n+  }\n+\n+  void AtomicallySetQuarantineFlag(AsanChunk *m, void *ptr,\n+                                   BufferedStackTrace *stack) {\n+    u8 old_chunk_state = CHUNK_ALLOCATED;\n+    // Flip the chunk_state atomically to avoid race on double-free.\n+    if (!atomic_compare_exchange_strong((atomic_uint8_t*)m, &old_chunk_state,\n+                                        CHUNK_QUARANTINE, memory_order_acquire))\n+      ReportInvalidFree(ptr, old_chunk_state, stack);\n+    CHECK_EQ(CHUNK_ALLOCATED, old_chunk_state);\n+  }\n+\n+  // Expects the chunk to already be marked as quarantined by using\n+  // AtomicallySetQuarantineFlag.\n+  void QuarantineChunk(AsanChunk *m, void *ptr, BufferedStackTrace *stack,\n+                       AllocType alloc_type) {\n+    CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n+\n+    if (m->alloc_type != alloc_type) {\n+      if (atomic_load(&alloc_dealloc_mismatch, memory_order_acquire)) {\n+        ReportAllocTypeMismatch((uptr)ptr, stack, (AllocType)m->alloc_type,\n+                                (AllocType)alloc_type);\n+      }\n+    }\n+\n+    CHECK_GE(m->alloc_tid, 0);\n+    if (SANITIZER_WORDSIZE == 64)  // On 32-bits this resides in user area.\n+      CHECK_EQ(m->free_tid, kInvalidTid);\n+    AsanThread *t = GetCurrentThread();\n+    m->free_tid = t ? t->tid() : 0;\n+    m->free_context_id = StackDepotPut(*stack);\n+    // Poison the region.\n+    PoisonShadow(m->Beg(),\n+                 RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n+                 kAsanHeapFreeMagic);\n+\n+    AsanStats &thread_stats = GetCurrentThreadStats();\n+    thread_stats.frees++;\n+    thread_stats.freed += m->UsedSize();\n+\n+    // Push into quarantine.\n+    if (t) {\n+      AsanThreadLocalMallocStorage *ms = &t->malloc_storage();\n+      AllocatorCache *ac = GetAllocatorCache(ms);\n+      quarantine.Put(GetQuarantineCache(ms), QuarantineCallback(ac), m,\n+                           m->UsedSize());\n+    } else {\n+      SpinMutexLock l(&fallback_mutex);\n+      AllocatorCache *ac = &fallback_allocator_cache;\n+      quarantine.Put(&fallback_quarantine_cache, QuarantineCallback(ac), m,\n+                           m->UsedSize());\n+    }\n+  }\n+\n+  void Deallocate(void *ptr, uptr delete_size, BufferedStackTrace *stack,\n+                  AllocType alloc_type) {\n+    uptr p = reinterpret_cast<uptr>(ptr);\n+    if (p == 0) return;\n+\n+    uptr chunk_beg = p - kChunkHeaderSize;\n+    AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n+    if (delete_size && flags()->new_delete_type_mismatch &&\n+        delete_size != m->UsedSize()) {\n+      ReportNewDeleteSizeMismatch(p, delete_size, stack);\n+    }\n+    ASAN_FREE_HOOK(ptr);\n+    // Must mark the chunk as quarantined before any changes to its metadata.\n+    AtomicallySetQuarantineFlag(m, ptr, stack);\n+    QuarantineChunk(m, ptr, stack, alloc_type);\n+  }\n+\n+  void *Reallocate(void *old_ptr, uptr new_size, BufferedStackTrace *stack) {\n+    CHECK(old_ptr && new_size);\n+    uptr p = reinterpret_cast<uptr>(old_ptr);\n+    uptr chunk_beg = p - kChunkHeaderSize;\n+    AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n+\n+    AsanStats &thread_stats = GetCurrentThreadStats();\n+    thread_stats.reallocs++;\n+    thread_stats.realloced += new_size;\n+\n+    void *new_ptr = Allocate(new_size, 8, stack, FROM_MALLOC, true);\n+    if (new_ptr) {\n+      u8 chunk_state = m->chunk_state;\n+      if (chunk_state != CHUNK_ALLOCATED)\n+        ReportInvalidFree(old_ptr, chunk_state, stack);\n+      CHECK_NE(REAL(memcpy), nullptr);\n+      uptr memcpy_size = Min(new_size, m->UsedSize());\n+      // If realloc() races with free(), we may start copying freed memory.\n+      // However, we will report racy double-free later anyway.\n+      REAL(memcpy)(new_ptr, old_ptr, memcpy_size);\n+      Deallocate(old_ptr, 0, stack, FROM_MALLOC);\n+    }\n+    return new_ptr;\n+  }\n+\n+  void *Calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n+    if (CallocShouldReturnNullDueToOverflow(size, nmemb))\n+      return allocator.ReturnNullOrDie();\n+    void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC, false);\n+    // If the memory comes from the secondary allocator no need to clear it\n+    // as it comes directly from mmap.\n+    if (ptr && allocator.FromPrimary(ptr))\n+      REAL(memset)(ptr, 0, nmemb * size);\n+    return ptr;\n+  }\n+\n+  void ReportInvalidFree(void *ptr, u8 chunk_state, BufferedStackTrace *stack) {\n+    if (chunk_state == CHUNK_QUARANTINE)\n+      ReportDoubleFree((uptr)ptr, stack);\n+    else\n+      ReportFreeNotMalloced((uptr)ptr, stack);\n+  }\n+\n+  void CommitBack(AsanThreadLocalMallocStorage *ms) {\n+    AllocatorCache *ac = GetAllocatorCache(ms);\n+    quarantine.Drain(GetQuarantineCache(ms), QuarantineCallback(ac));\n+    allocator.SwallowCache(ac);\n+  }\n+\n+  // -------------------------- Chunk lookup ----------------------\n+\n+  // Assumes alloc_beg == allocator.GetBlockBegin(alloc_beg).\n+  AsanChunk *GetAsanChunk(void *alloc_beg) {\n+    if (!alloc_beg) return nullptr;\n+    if (!allocator.FromPrimary(alloc_beg)) {\n+      uptr *meta = reinterpret_cast<uptr *>(allocator.GetMetaData(alloc_beg));\n+      AsanChunk *m = reinterpret_cast<AsanChunk *>(meta[1]);\n+      return m;\n+    }\n+    uptr *alloc_magic = reinterpret_cast<uptr *>(alloc_beg);\n+    if (alloc_magic[0] == kAllocBegMagic)\n+      return reinterpret_cast<AsanChunk *>(alloc_magic[1]);\n+    return reinterpret_cast<AsanChunk *>(alloc_beg);\n+  }\n+\n+  AsanChunk *GetAsanChunkByAddr(uptr p) {\n+    void *alloc_beg = allocator.GetBlockBegin(reinterpret_cast<void *>(p));\n+    return GetAsanChunk(alloc_beg);\n+  }\n+\n+  // Allocator must be locked when this function is called.\n+  AsanChunk *GetAsanChunkByAddrFastLocked(uptr p) {\n+    void *alloc_beg =\n+        allocator.GetBlockBeginFastLocked(reinterpret_cast<void *>(p));\n+    return GetAsanChunk(alloc_beg);\n+  }\n+\n+  uptr AllocationSize(uptr p) {\n+    AsanChunk *m = GetAsanChunkByAddr(p);\n+    if (!m) return 0;\n+    if (m->chunk_state != CHUNK_ALLOCATED) return 0;\n+    if (m->Beg() != p) return 0;\n+    return m->UsedSize();\n+  }\n+\n+  AsanChunkView FindHeapChunkByAddress(uptr addr) {\n+    AsanChunk *m1 = GetAsanChunkByAddr(addr);\n+    if (!m1) return AsanChunkView(m1);\n+    sptr offset = 0;\n+    if (AsanChunkView(m1).AddrIsAtLeft(addr, 1, &offset)) {\n+      // The address is in the chunk's left redzone, so maybe it is actually\n+      // a right buffer overflow from the other chunk to the left.\n+      // Search a bit to the left to see if there is another chunk.\n+      AsanChunk *m2 = nullptr;\n+      for (uptr l = 1; l < GetPageSizeCached(); l++) {\n+        m2 = GetAsanChunkByAddr(addr - l);\n+        if (m2 == m1) continue;  // Still the same chunk.\n+        break;\n+      }\n+      if (m2 && AsanChunkView(m2).AddrIsAtRight(addr, 1, &offset))\n+        m1 = ChooseChunk(addr, m2, m1);\n+    }\n+    return AsanChunkView(m1);\n+  }\n+\n+  void PrintStats() {\n+    allocator.PrintStats();\n+  }\n+\n+  void ForceLock() {\n+    allocator.ForceLock();\n+    fallback_mutex.Lock();\n+  }\n+\n+  void ForceUnlock() {\n+    fallback_mutex.Unlock();\n+    allocator.ForceUnlock();\n+  }\n+};\n+\n+static Allocator instance(LINKER_INITIALIZED);\n+\n+static AsanAllocator &get_allocator() {\n+  return instance.allocator;\n+}\n+\n+bool AsanChunkView::IsValid() {\n+  return chunk_ && chunk_->chunk_state != CHUNK_AVAILABLE;\n+}\n+uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n+uptr AsanChunkView::End() { return Beg() + UsedSize(); }\n+uptr AsanChunkView::UsedSize() { return chunk_->UsedSize(); }\n+uptr AsanChunkView::AllocTid() { return chunk_->alloc_tid; }\n+uptr AsanChunkView::FreeTid() { return chunk_->free_tid; }\n+\n+static StackTrace GetStackTraceFromId(u32 id) {\n+  CHECK(id);\n+  StackTrace res = StackDepotGet(id);\n+  CHECK(res.trace);\n+  return res;\n+}\n+\n+StackTrace AsanChunkView::GetAllocStack() {\n+  return GetStackTraceFromId(chunk_->alloc_context_id);\n+}\n+\n+StackTrace AsanChunkView::GetFreeStack() {\n+  return GetStackTraceFromId(chunk_->free_context_id);\n+}\n+\n+void InitializeAllocator(const AllocatorOptions &options) {\n+  instance.Initialize(options);\n+}\n+\n+void ReInitializeAllocator(const AllocatorOptions &options) {\n+  instance.ReInitialize(options);\n+}\n+\n+void GetAllocatorOptions(AllocatorOptions *options) {\n+  instance.GetOptions(options);\n+}\n+\n+AsanChunkView FindHeapChunkByAddress(uptr addr) {\n+  return instance.FindHeapChunkByAddress(addr);\n+}\n+\n+void AsanThreadLocalMallocStorage::CommitBack() {\n+  instance.CommitBack(this);\n+}\n+\n+void PrintInternalAllocatorStats() {\n+  instance.PrintStats();\n+}\n+\n+void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n+                    AllocType alloc_type) {\n+  return instance.Allocate(size, alignment, stack, alloc_type, true);\n+}\n+\n+void asan_free(void *ptr, BufferedStackTrace *stack, AllocType alloc_type) {\n+  instance.Deallocate(ptr, 0, stack, alloc_type);\n+}\n+\n+void asan_sized_free(void *ptr, uptr size, BufferedStackTrace *stack,\n+                     AllocType alloc_type) {\n+  instance.Deallocate(ptr, size, stack, alloc_type);\n+}\n+\n+void *asan_malloc(uptr size, BufferedStackTrace *stack) {\n+  return instance.Allocate(size, 8, stack, FROM_MALLOC, true);\n+}\n+\n+void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n+  return instance.Calloc(nmemb, size, stack);\n+}\n+\n+void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack) {\n+  if (!p)\n+    return instance.Allocate(size, 8, stack, FROM_MALLOC, true);\n+  if (size == 0) {\n+    instance.Deallocate(p, 0, stack, FROM_MALLOC);\n+    return nullptr;\n+  }\n+  return instance.Reallocate(p, size, stack);\n+}\n+\n+void *asan_valloc(uptr size, BufferedStackTrace *stack) {\n+  return instance.Allocate(size, GetPageSizeCached(), stack, FROM_MALLOC, true);\n+}\n+\n+void *asan_pvalloc(uptr size, BufferedStackTrace *stack) {\n+  uptr PageSize = GetPageSizeCached();\n+  size = RoundUpTo(size, PageSize);\n+  if (size == 0) {\n+    // pvalloc(0) should allocate one page.\n+    size = PageSize;\n+  }\n+  return instance.Allocate(size, PageSize, stack, FROM_MALLOC, true);\n+}\n+\n+int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n+                        BufferedStackTrace *stack) {\n+  void *ptr = instance.Allocate(size, alignment, stack, FROM_MALLOC, true);\n+  CHECK(IsAligned((uptr)ptr, alignment));\n+  *memptr = ptr;\n+  return 0;\n+}\n+\n+uptr asan_malloc_usable_size(void *ptr, uptr pc, uptr bp) {\n+  if (!ptr) return 0;\n+  uptr usable_size = instance.AllocationSize(reinterpret_cast<uptr>(ptr));\n+  if (flags()->check_malloc_usable_size && (usable_size == 0)) {\n+    GET_STACK_TRACE_FATAL(pc, bp);\n+    ReportMallocUsableSizeNotOwned((uptr)ptr, &stack);\n+  }\n+  return usable_size;\n+}\n+\n+uptr asan_mz_size(const void *ptr) {\n+  return instance.AllocationSize(reinterpret_cast<uptr>(ptr));\n+}\n+\n+void asan_mz_force_lock() {\n+  instance.ForceLock();\n+}\n+\n+void asan_mz_force_unlock() {\n+  instance.ForceUnlock();\n+}\n+\n+void AsanSoftRssLimitExceededCallback(bool exceeded) {\n+  instance.allocator.SetRssLimitIsExceeded(exceeded);\n+}\n+\n+} // namespace __asan\n+\n+// --- Implementation of LSan-specific functions --- {{{1\n+namespace __lsan {\n+void LockAllocator() {\n+  __asan::get_allocator().ForceLock();\n+}\n+\n+void UnlockAllocator() {\n+  __asan::get_allocator().ForceUnlock();\n+}\n+\n+void GetAllocatorGlobalRange(uptr *begin, uptr *end) {\n+  *begin = (uptr)&__asan::get_allocator();\n+  *end = *begin + sizeof(__asan::get_allocator());\n+}\n+\n+uptr PointsIntoChunk(void* p) {\n+  uptr addr = reinterpret_cast<uptr>(p);\n+  __asan::AsanChunk *m = __asan::instance.GetAsanChunkByAddrFastLocked(addr);\n+  if (!m) return 0;\n+  uptr chunk = m->Beg();\n+  if (m->chunk_state != __asan::CHUNK_ALLOCATED)\n+    return 0;\n+  if (m->AddrIsInside(addr, /*locked_version=*/true))\n+    return chunk;\n+  if (IsSpecialCaseOfOperatorNew0(chunk, m->UsedSize(/*locked_version*/ true),\n+                                  addr))\n+    return chunk;\n+  return 0;\n+}\n+\n+uptr GetUserBegin(uptr chunk) {\n+  __asan::AsanChunk *m = __asan::instance.GetAsanChunkByAddrFastLocked(chunk);\n+  CHECK(m);\n+  return m->Beg();\n+}\n+\n+LsanMetadata::LsanMetadata(uptr chunk) {\n+  metadata_ = reinterpret_cast<void *>(chunk - __asan::kChunkHeaderSize);\n+}\n+\n+bool LsanMetadata::allocated() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return m->chunk_state == __asan::CHUNK_ALLOCATED;\n+}\n+\n+ChunkTag LsanMetadata::tag() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return static_cast<ChunkTag>(m->lsan_tag);\n+}\n+\n+void LsanMetadata::set_tag(ChunkTag value) {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  m->lsan_tag = value;\n+}\n+\n+uptr LsanMetadata::requested_size() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return m->UsedSize(/*locked_version=*/true);\n+}\n+\n+u32 LsanMetadata::stack_trace_id() const {\n+  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n+  return m->alloc_context_id;\n+}\n+\n+void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+  __asan::get_allocator().ForEachChunk(callback, arg);\n+}\n+\n+IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n+  uptr addr = reinterpret_cast<uptr>(p);\n+  __asan::AsanChunk *m = __asan::instance.GetAsanChunkByAddr(addr);\n+  if (!m) return kIgnoreObjectInvalid;\n+  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) && m->AddrIsInside(addr)) {\n+    if (m->lsan_tag == kIgnored)\n+      return kIgnoreObjectAlreadyIgnored;\n+    m->lsan_tag = __lsan::kIgnored;\n+    return kIgnoreObjectSuccess;\n+  } else {\n+    return kIgnoreObjectInvalid;\n+  }\n+}\n+}  // namespace __lsan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+// ASan allocator doesn't reserve extra bytes, so normally we would\n+// just return \"size\". We don't want to expose our redzone sizes, etc here.\n+uptr __sanitizer_get_estimated_allocated_size(uptr size) {\n+  return size;\n+}\n+\n+int __sanitizer_get_ownership(const void *p) {\n+  uptr ptr = reinterpret_cast<uptr>(p);\n+  return instance.AllocationSize(ptr) > 0;\n+}\n+\n+uptr __sanitizer_get_allocated_size(const void *p) {\n+  if (!p) return 0;\n+  uptr ptr = reinterpret_cast<uptr>(p);\n+  uptr allocated_size = instance.AllocationSize(ptr);\n+  // Die if p is not malloced or if it is already freed.\n+  if (allocated_size == 0) {\n+    GET_STACK_TRACE_FATAL_HERE;\n+    ReportSanitizerGetAllocatedSizeNotOwned(ptr, &stack);\n+  }\n+  return allocated_size;\n+}\n+\n+#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n+// Provide default (no-op) implementation of malloc hooks.\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_malloc_hook(void *ptr, uptr size) {\n+  (void)ptr;\n+  (void)size;\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_free_hook(void *ptr) {\n+  (void)ptr;\n+}\n+} // extern \"C\"\n+#endif"}, {"sha": "921131ab4e9b39ef661a654acceecdf4421e740d", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -7,12 +7,13 @@\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_allocator2.cc.\n+// ASan-private header for asan_allocator.cc.\n //===----------------------------------------------------------------------===//\n \n #ifndef ASAN_ALLOCATOR_H\n #define ASAN_ALLOCATOR_H\n \n+#include \"asan_flags.h\"\n #include \"asan_internal.h\"\n #include \"asan_interceptors.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n@@ -26,11 +27,22 @@ enum AllocType {\n   FROM_NEW_BR = 3   // Memory block came from operator new [ ]\n };\n \n-static const uptr kNumberOfSizeClasses = 255;\n struct AsanChunk;\n \n-void InitializeAllocator();\n-void ReInitializeAllocator();\n+struct AllocatorOptions {\n+  u32 quarantine_size_mb;\n+  u16 min_redzone;\n+  u16 max_redzone;\n+  u8 may_return_null;\n+  u8 alloc_dealloc_mismatch;\n+\n+  void SetFrom(const Flags *f, const CommonFlags *cf);\n+  void CopyTo(Flags *f, CommonFlags *cf);\n+};\n+\n+void InitializeAllocator(const AllocatorOptions &options);\n+void ReInitializeAllocator(const AllocatorOptions &options);\n+void GetAllocatorOptions(AllocatorOptions *options);\n \n class AsanChunkView {\n  public:\n@@ -100,6 +112,11 @@ struct AsanMapUnmapCallback {\n # if defined(__powerpc64__)\n const uptr kAllocatorSpace =  0xa0000000000ULL;\n const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n+# elif defined(__aarch64__)\n+// AArch64/SANITIZIER_CAN_USER_ALLOCATOR64 is only for 42-bit VMA\n+// so no need to different values for different VMA.\n+const uptr kAllocatorSpace =  0x10000000000ULL;\n+const uptr kAllocatorSize  =  0x10000000000ULL;  // 3T.\n # else\n const uptr kAllocatorSpace = 0x600000000000ULL;\n const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n@@ -122,15 +139,16 @@ typedef SizeClassAllocator32<0, SANITIZER_MMAP_RANGE_SIZE, 16,\n   AsanMapUnmapCallback> PrimaryAllocator;\n #endif  // SANITIZER_CAN_USE_ALLOCATOR64\n \n+static const uptr kNumberOfSizeClasses = SizeClassMap::kNumClasses;\n typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator<AsanMapUnmapCallback> SecondaryAllocator;\n typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n-    SecondaryAllocator> Allocator;\n+    SecondaryAllocator> AsanAllocator;\n \n \n struct AsanThreadLocalMallocStorage {\n   uptr quarantine_cache[16];\n-  AllocatorCache allocator2_cache;\n+  AllocatorCache allocator_cache;\n   void CommitBack();\n  private:\n   // These objects are allocated via mmap() and are zero-initialized.\n@@ -158,6 +176,7 @@ void asan_mz_force_lock();\n void asan_mz_force_unlock();\n \n void PrintInternalAllocatorStats();\n+void AsanSoftRssLimitExceededCallback(bool exceeded);\n \n }  // namespace __asan\n #endif  // ASAN_ALLOCATOR_H"}, {"sha": "33d9fea70cb67145576cbcc6bfc44e8a97bda2db", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "removed", "additions": 0, "deletions": 790, "changes": 790, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -1,790 +0,0 @@\n-//===-- asan_allocator2.cc ------------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Implementation of ASan's memory allocator, 2-nd version.\n-// This variant uses the allocator from sanitizer_common, i.e. the one shared\n-// with ThreadSanitizer and MemorySanitizer.\n-//\n-//===----------------------------------------------------------------------===//\n-#include \"asan_allocator.h\"\n-\n-#include \"asan_mapping.h\"\n-#include \"asan_poisoning.h\"\n-#include \"asan_report.h\"\n-#include \"asan_stack.h\"\n-#include \"asan_thread.h\"\n-#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n-#include \"sanitizer_common/sanitizer_flags.h\"\n-#include \"sanitizer_common/sanitizer_internal_defs.h\"\n-#include \"sanitizer_common/sanitizer_list.h\"\n-#include \"sanitizer_common/sanitizer_stackdepot.h\"\n-#include \"sanitizer_common/sanitizer_quarantine.h\"\n-#include \"lsan/lsan_common.h\"\n-\n-namespace __asan {\n-\n-void AsanMapUnmapCallback::OnMap(uptr p, uptr size) const {\n-  PoisonShadow(p, size, kAsanHeapLeftRedzoneMagic);\n-  // Statistics.\n-  AsanStats &thread_stats = GetCurrentThreadStats();\n-  thread_stats.mmaps++;\n-  thread_stats.mmaped += size;\n-}\n-void AsanMapUnmapCallback::OnUnmap(uptr p, uptr size) const {\n-  PoisonShadow(p, size, 0);\n-  // We are about to unmap a chunk of user memory.\n-  // Mark the corresponding shadow memory as not needed.\n-  FlushUnneededASanShadowMemory(p, size);\n-  // Statistics.\n-  AsanStats &thread_stats = GetCurrentThreadStats();\n-  thread_stats.munmaps++;\n-  thread_stats.munmaped += size;\n-}\n-\n-// We can not use THREADLOCAL because it is not supported on some of the\n-// platforms we care about (OSX 10.6, Android).\n-// static THREADLOCAL AllocatorCache cache;\n-AllocatorCache *GetAllocatorCache(AsanThreadLocalMallocStorage *ms) {\n-  CHECK(ms);\n-  return &ms->allocator2_cache;\n-}\n-\n-static Allocator allocator;\n-\n-static const uptr kMaxAllowedMallocSize =\n-  FIRST_32_SECOND_64(3UL << 30, 64UL << 30);\n-\n-static const uptr kMaxThreadLocalQuarantine =\n-  FIRST_32_SECOND_64(1 << 18, 1 << 20);\n-\n-// Every chunk of memory allocated by this allocator can be in one of 3 states:\n-// CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.\n-// CHUNK_ALLOCATED: the chunk is allocated and not yet freed.\n-// CHUNK_QUARANTINE: the chunk was freed and put into quarantine zone.\n-enum {\n-  CHUNK_AVAILABLE  = 0,  // 0 is the default value even if we didn't set it.\n-  CHUNK_ALLOCATED  = 2,\n-  CHUNK_QUARANTINE = 3\n-};\n-\n-// Valid redzone sizes are 16, 32, 64, ... 2048, so we encode them in 3 bits.\n-// We use adaptive redzones: for larger allocation larger redzones are used.\n-static u32 RZLog2Size(u32 rz_log) {\n-  CHECK_LT(rz_log, 8);\n-  return 16 << rz_log;\n-}\n-\n-static u32 RZSize2Log(u32 rz_size) {\n-  CHECK_GE(rz_size, 16);\n-  CHECK_LE(rz_size, 2048);\n-  CHECK(IsPowerOfTwo(rz_size));\n-  u32 res = Log2(rz_size) - 4;\n-  CHECK_EQ(rz_size, RZLog2Size(res));\n-  return res;\n-}\n-\n-static uptr ComputeRZLog(uptr user_requested_size) {\n-  u32 rz_log =\n-    user_requested_size <= 64        - 16   ? 0 :\n-    user_requested_size <= 128       - 32   ? 1 :\n-    user_requested_size <= 512       - 64   ? 2 :\n-    user_requested_size <= 4096      - 128  ? 3 :\n-    user_requested_size <= (1 << 14) - 256  ? 4 :\n-    user_requested_size <= (1 << 15) - 512  ? 5 :\n-    user_requested_size <= (1 << 16) - 1024 ? 6 : 7;\n-  return Min(Max(rz_log, RZSize2Log(flags()->redzone)),\n-             RZSize2Log(flags()->max_redzone));\n-}\n-\n-// The memory chunk allocated from the underlying allocator looks like this:\n-// L L L L L L H H U U U U U U R R\n-//   L -- left redzone words (0 or more bytes)\n-//   H -- ChunkHeader (16 bytes), which is also a part of the left redzone.\n-//   U -- user memory.\n-//   R -- right redzone (0 or more bytes)\n-// ChunkBase consists of ChunkHeader and other bytes that overlap with user\n-// memory.\n-\n-// If the left redzone is greater than the ChunkHeader size we store a magic\n-// value in the first uptr word of the memory block and store the address of\n-// ChunkBase in the next uptr.\n-// M B L L L L L L L L L  H H U U U U U U\n-//   |                    ^\n-//   ---------------------|\n-//   M -- magic value kAllocBegMagic\n-//   B -- address of ChunkHeader pointing to the first 'H'\n-static const uptr kAllocBegMagic = 0xCC6E96B9;\n-\n-struct ChunkHeader {\n-  // 1-st 8 bytes.\n-  u32 chunk_state       : 8;  // Must be first.\n-  u32 alloc_tid         : 24;\n-\n-  u32 free_tid          : 24;\n-  u32 from_memalign     : 1;\n-  u32 alloc_type        : 2;\n-  u32 rz_log            : 3;\n-  u32 lsan_tag          : 2;\n-  // 2-nd 8 bytes\n-  // This field is used for small sizes. For large sizes it is equal to\n-  // SizeClassMap::kMaxSize and the actual size is stored in the\n-  // SecondaryAllocator's metadata.\n-  u32 user_requested_size;\n-  u32 alloc_context_id;\n-};\n-\n-struct ChunkBase : ChunkHeader {\n-  // Header2, intersects with user memory.\n-  u32 free_context_id;\n-};\n-\n-static const uptr kChunkHeaderSize = sizeof(ChunkHeader);\n-static const uptr kChunkHeader2Size = sizeof(ChunkBase) - kChunkHeaderSize;\n-COMPILER_CHECK(kChunkHeaderSize == 16);\n-COMPILER_CHECK(kChunkHeader2Size <= 16);\n-\n-struct AsanChunk: ChunkBase {\n-  uptr Beg() { return reinterpret_cast<uptr>(this) + kChunkHeaderSize; }\n-  uptr UsedSize(bool locked_version = false) {\n-    if (user_requested_size != SizeClassMap::kMaxSize)\n-      return user_requested_size;\n-    return *reinterpret_cast<uptr *>(\n-                allocator.GetMetaData(AllocBeg(locked_version)));\n-  }\n-  void *AllocBeg(bool locked_version = false) {\n-    if (from_memalign) {\n-      if (locked_version)\n-        return allocator.GetBlockBeginFastLocked(\n-            reinterpret_cast<void *>(this));\n-      return allocator.GetBlockBegin(reinterpret_cast<void *>(this));\n-    }\n-    return reinterpret_cast<void*>(Beg() - RZLog2Size(rz_log));\n-  }\n-  bool AddrIsInside(uptr addr, bool locked_version = false) {\n-    return (addr >= Beg()) && (addr < Beg() + UsedSize(locked_version));\n-  }\n-};\n-\n-bool AsanChunkView::IsValid() {\n-  return chunk_ != 0 && chunk_->chunk_state != CHUNK_AVAILABLE;\n-}\n-uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n-uptr AsanChunkView::End() { return Beg() + UsedSize(); }\n-uptr AsanChunkView::UsedSize() { return chunk_->UsedSize(); }\n-uptr AsanChunkView::AllocTid() { return chunk_->alloc_tid; }\n-uptr AsanChunkView::FreeTid() { return chunk_->free_tid; }\n-\n-static StackTrace GetStackTraceFromId(u32 id) {\n-  CHECK(id);\n-  StackTrace res = StackDepotGet(id);\n-  CHECK(res.trace);\n-  return res;\n-}\n-\n-StackTrace AsanChunkView::GetAllocStack() {\n-  return GetStackTraceFromId(chunk_->alloc_context_id);\n-}\n-\n-StackTrace AsanChunkView::GetFreeStack() {\n-  return GetStackTraceFromId(chunk_->free_context_id);\n-}\n-\n-struct QuarantineCallback;\n-typedef Quarantine<QuarantineCallback, AsanChunk> AsanQuarantine;\n-typedef AsanQuarantine::Cache QuarantineCache;\n-static AsanQuarantine quarantine(LINKER_INITIALIZED);\n-static QuarantineCache fallback_quarantine_cache(LINKER_INITIALIZED);\n-static AllocatorCache fallback_allocator_cache;\n-static SpinMutex fallback_mutex;\n-\n-QuarantineCache *GetQuarantineCache(AsanThreadLocalMallocStorage *ms) {\n-  CHECK(ms);\n-  CHECK_LE(sizeof(QuarantineCache), sizeof(ms->quarantine_cache));\n-  return reinterpret_cast<QuarantineCache *>(ms->quarantine_cache);\n-}\n-\n-struct QuarantineCallback {\n-  explicit QuarantineCallback(AllocatorCache *cache)\n-      : cache_(cache) {\n-  }\n-\n-  void Recycle(AsanChunk *m) {\n-    CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n-    atomic_store((atomic_uint8_t*)m, CHUNK_AVAILABLE, memory_order_relaxed);\n-    CHECK_NE(m->alloc_tid, kInvalidTid);\n-    CHECK_NE(m->free_tid, kInvalidTid);\n-    PoisonShadow(m->Beg(),\n-                 RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n-                 kAsanHeapLeftRedzoneMagic);\n-    void *p = reinterpret_cast<void *>(m->AllocBeg());\n-    if (p != m) {\n-      uptr *alloc_magic = reinterpret_cast<uptr *>(p);\n-      CHECK_EQ(alloc_magic[0], kAllocBegMagic);\n-      // Clear the magic value, as allocator internals may overwrite the\n-      // contents of deallocated chunk, confusing GetAsanChunk lookup.\n-      alloc_magic[0] = 0;\n-      CHECK_EQ(alloc_magic[1], reinterpret_cast<uptr>(m));\n-    }\n-\n-    // Statistics.\n-    AsanStats &thread_stats = GetCurrentThreadStats();\n-    thread_stats.real_frees++;\n-    thread_stats.really_freed += m->UsedSize();\n-\n-    allocator.Deallocate(cache_, p);\n-  }\n-\n-  void *Allocate(uptr size) {\n-    return allocator.Allocate(cache_, size, 1, false);\n-  }\n-\n-  void Deallocate(void *p) {\n-    allocator.Deallocate(cache_, p);\n-  }\n-\n-  AllocatorCache *cache_;\n-};\n-\n-void InitializeAllocator() {\n-  allocator.Init();\n-  quarantine.Init((uptr)flags()->quarantine_size, kMaxThreadLocalQuarantine);\n-}\n-\n-void ReInitializeAllocator() {\n-  quarantine.Init((uptr)flags()->quarantine_size, kMaxThreadLocalQuarantine);\n-}\n-\n-static void *Allocate(uptr size, uptr alignment, BufferedStackTrace *stack,\n-                      AllocType alloc_type, bool can_fill) {\n-  if (UNLIKELY(!asan_inited))\n-    AsanInitFromRtl();\n-  Flags &fl = *flags();\n-  CHECK(stack);\n-  const uptr min_alignment = SHADOW_GRANULARITY;\n-  if (alignment < min_alignment)\n-    alignment = min_alignment;\n-  if (size == 0) {\n-    // We'd be happy to avoid allocating memory for zero-size requests, but\n-    // some programs/tests depend on this behavior and assume that malloc would\n-    // not return NULL even for zero-size allocations. Moreover, it looks like\n-    // operator new should never return NULL, and results of consecutive \"new\"\n-    // calls must be different even if the allocated size is zero.\n-    size = 1;\n-  }\n-  CHECK(IsPowerOfTwo(alignment));\n-  uptr rz_log = ComputeRZLog(size);\n-  uptr rz_size = RZLog2Size(rz_log);\n-  uptr rounded_size = RoundUpTo(Max(size, kChunkHeader2Size), alignment);\n-  uptr needed_size = rounded_size + rz_size;\n-  if (alignment > min_alignment)\n-    needed_size += alignment;\n-  bool using_primary_allocator = true;\n-  // If we are allocating from the secondary allocator, there will be no\n-  // automatic right redzone, so add the right redzone manually.\n-  if (!PrimaryAllocator::CanAllocate(needed_size, alignment)) {\n-    needed_size += rz_size;\n-    using_primary_allocator = false;\n-  }\n-  CHECK(IsAligned(needed_size, min_alignment));\n-  if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n-    Report(\"WARNING: AddressSanitizer failed to allocate %p bytes\\n\",\n-           (void*)size);\n-    return AllocatorReturnNull();\n-  }\n-\n-  AsanThread *t = GetCurrentThread();\n-  void *allocated;\n-  if (t) {\n-    AllocatorCache *cache = GetAllocatorCache(&t->malloc_storage());\n-    allocated = allocator.Allocate(cache, needed_size, 8, false);\n-  } else {\n-    SpinMutexLock l(&fallback_mutex);\n-    AllocatorCache *cache = &fallback_allocator_cache;\n-    allocated = allocator.Allocate(cache, needed_size, 8, false);\n-  }\n-\n-  if (*(u8 *)MEM_TO_SHADOW((uptr)allocated) == 0 && flags()->poison_heap) {\n-    // Heap poisoning is enabled, but the allocator provides an unpoisoned\n-    // chunk. This is possible if flags()->poison_heap was disabled for some\n-    // time, for example, due to flags()->start_disabled.\n-    // Anyway, poison the block before using it for anything else.\n-    uptr allocated_size = allocator.GetActuallyAllocatedSize(allocated);\n-    PoisonShadow((uptr)allocated, allocated_size, kAsanHeapLeftRedzoneMagic);\n-  }\n-\n-  uptr alloc_beg = reinterpret_cast<uptr>(allocated);\n-  uptr alloc_end = alloc_beg + needed_size;\n-  uptr beg_plus_redzone = alloc_beg + rz_size;\n-  uptr user_beg = beg_plus_redzone;\n-  if (!IsAligned(user_beg, alignment))\n-    user_beg = RoundUpTo(user_beg, alignment);\n-  uptr user_end = user_beg + size;\n-  CHECK_LE(user_end, alloc_end);\n-  uptr chunk_beg = user_beg - kChunkHeaderSize;\n-  AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n-  m->alloc_type = alloc_type;\n-  m->rz_log = rz_log;\n-  u32 alloc_tid = t ? t->tid() : 0;\n-  m->alloc_tid = alloc_tid;\n-  CHECK_EQ(alloc_tid, m->alloc_tid);  // Does alloc_tid fit into the bitfield?\n-  m->free_tid = kInvalidTid;\n-  m->from_memalign = user_beg != beg_plus_redzone;\n-  if (alloc_beg != chunk_beg) {\n-    CHECK_LE(alloc_beg+ 2 * sizeof(uptr), chunk_beg);\n-    reinterpret_cast<uptr *>(alloc_beg)[0] = kAllocBegMagic;\n-    reinterpret_cast<uptr *>(alloc_beg)[1] = chunk_beg;\n-  }\n-  if (using_primary_allocator) {\n-    CHECK(size);\n-    m->user_requested_size = size;\n-    CHECK(allocator.FromPrimary(allocated));\n-  } else {\n-    CHECK(!allocator.FromPrimary(allocated));\n-    m->user_requested_size = SizeClassMap::kMaxSize;\n-    uptr *meta = reinterpret_cast<uptr *>(allocator.GetMetaData(allocated));\n-    meta[0] = size;\n-    meta[1] = chunk_beg;\n-  }\n-\n-  m->alloc_context_id = StackDepotPut(*stack);\n-\n-  uptr size_rounded_down_to_granularity = RoundDownTo(size, SHADOW_GRANULARITY);\n-  // Unpoison the bulk of the memory region.\n-  if (size_rounded_down_to_granularity)\n-    PoisonShadow(user_beg, size_rounded_down_to_granularity, 0);\n-  // Deal with the end of the region if size is not aligned to granularity.\n-  if (size != size_rounded_down_to_granularity && fl.poison_heap) {\n-    u8 *shadow = (u8*)MemToShadow(user_beg + size_rounded_down_to_granularity);\n-    *shadow = fl.poison_partial ? (size & (SHADOW_GRANULARITY - 1)) : 0;\n-  }\n-\n-  AsanStats &thread_stats = GetCurrentThreadStats();\n-  thread_stats.mallocs++;\n-  thread_stats.malloced += size;\n-  thread_stats.malloced_redzones += needed_size - size;\n-  uptr class_id = Min(kNumberOfSizeClasses, SizeClassMap::ClassID(needed_size));\n-  thread_stats.malloced_by_size[class_id]++;\n-  if (needed_size > SizeClassMap::kMaxSize)\n-    thread_stats.malloc_large++;\n-\n-  void *res = reinterpret_cast<void *>(user_beg);\n-  if (can_fill && fl.max_malloc_fill_size) {\n-    uptr fill_size = Min(size, (uptr)fl.max_malloc_fill_size);\n-    REAL(memset)(res, fl.malloc_fill_byte, fill_size);\n-  }\n-#if CAN_SANITIZE_LEAKS\n-  m->lsan_tag = __lsan::DisabledInThisThread() ? __lsan::kIgnored\n-                                               : __lsan::kDirectlyLeaked;\n-#endif\n-  // Must be the last mutation of metadata in this function.\n-  atomic_store((atomic_uint8_t *)m, CHUNK_ALLOCATED, memory_order_release);\n-  ASAN_MALLOC_HOOK(res, size);\n-  return res;\n-}\n-\n-static void ReportInvalidFree(void *ptr, u8 chunk_state,\n-                              BufferedStackTrace *stack) {\n-  if (chunk_state == CHUNK_QUARANTINE)\n-    ReportDoubleFree((uptr)ptr, stack);\n-  else\n-    ReportFreeNotMalloced((uptr)ptr, stack);\n-}\n-\n-static void AtomicallySetQuarantineFlag(AsanChunk *m, void *ptr,\n-                                        BufferedStackTrace *stack) {\n-  u8 old_chunk_state = CHUNK_ALLOCATED;\n-  // Flip the chunk_state atomically to avoid race on double-free.\n-  if (!atomic_compare_exchange_strong((atomic_uint8_t*)m, &old_chunk_state,\n-                                      CHUNK_QUARANTINE, memory_order_acquire))\n-    ReportInvalidFree(ptr, old_chunk_state, stack);\n-  CHECK_EQ(CHUNK_ALLOCATED, old_chunk_state);\n-}\n-\n-// Expects the chunk to already be marked as quarantined by using\n-// AtomicallySetQuarantineFlag.\n-static void QuarantineChunk(AsanChunk *m, void *ptr, BufferedStackTrace *stack,\n-                            AllocType alloc_type) {\n-  CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n-\n-  if (m->alloc_type != alloc_type && flags()->alloc_dealloc_mismatch)\n-    ReportAllocTypeMismatch((uptr)ptr, stack,\n-                            (AllocType)m->alloc_type, (AllocType)alloc_type);\n-\n-  CHECK_GE(m->alloc_tid, 0);\n-  if (SANITIZER_WORDSIZE == 64)  // On 32-bits this resides in user area.\n-    CHECK_EQ(m->free_tid, kInvalidTid);\n-  AsanThread *t = GetCurrentThread();\n-  m->free_tid = t ? t->tid() : 0;\n-  m->free_context_id = StackDepotPut(*stack);\n-  // Poison the region.\n-  PoisonShadow(m->Beg(),\n-               RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n-               kAsanHeapFreeMagic);\n-\n-  AsanStats &thread_stats = GetCurrentThreadStats();\n-  thread_stats.frees++;\n-  thread_stats.freed += m->UsedSize();\n-\n-  // Push into quarantine.\n-  if (t) {\n-    AsanThreadLocalMallocStorage *ms = &t->malloc_storage();\n-    AllocatorCache *ac = GetAllocatorCache(ms);\n-    quarantine.Put(GetQuarantineCache(ms), QuarantineCallback(ac),\n-                   m, m->UsedSize());\n-  } else {\n-    SpinMutexLock l(&fallback_mutex);\n-    AllocatorCache *ac = &fallback_allocator_cache;\n-    quarantine.Put(&fallback_quarantine_cache, QuarantineCallback(ac),\n-                   m, m->UsedSize());\n-  }\n-}\n-\n-static void Deallocate(void *ptr, uptr delete_size, BufferedStackTrace *stack,\n-                       AllocType alloc_type) {\n-  uptr p = reinterpret_cast<uptr>(ptr);\n-  if (p == 0) return;\n-\n-  uptr chunk_beg = p - kChunkHeaderSize;\n-  AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n-  if (delete_size && flags()->new_delete_type_mismatch &&\n-      delete_size != m->UsedSize()) {\n-    ReportNewDeleteSizeMismatch(p, delete_size, stack);\n-  }\n-  ASAN_FREE_HOOK(ptr);\n-  // Must mark the chunk as quarantined before any changes to its metadata.\n-  AtomicallySetQuarantineFlag(m, ptr, stack);\n-  QuarantineChunk(m, ptr, stack, alloc_type);\n-}\n-\n-static void *Reallocate(void *old_ptr, uptr new_size,\n-                        BufferedStackTrace *stack) {\n-  CHECK(old_ptr && new_size);\n-  uptr p = reinterpret_cast<uptr>(old_ptr);\n-  uptr chunk_beg = p - kChunkHeaderSize;\n-  AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n-\n-  AsanStats &thread_stats = GetCurrentThreadStats();\n-  thread_stats.reallocs++;\n-  thread_stats.realloced += new_size;\n-\n-  void *new_ptr = Allocate(new_size, 8, stack, FROM_MALLOC, true);\n-  if (new_ptr) {\n-    u8 chunk_state = m->chunk_state;\n-    if (chunk_state != CHUNK_ALLOCATED)\n-      ReportInvalidFree(old_ptr, chunk_state, stack);\n-    CHECK_NE(REAL(memcpy), (void*)0);\n-    uptr memcpy_size = Min(new_size, m->UsedSize());\n-    // If realloc() races with free(), we may start copying freed memory.\n-    // However, we will report racy double-free later anyway.\n-    REAL(memcpy)(new_ptr, old_ptr, memcpy_size);\n-    Deallocate(old_ptr, 0, stack, FROM_MALLOC);\n-  }\n-  return new_ptr;\n-}\n-\n-// Assumes alloc_beg == allocator.GetBlockBegin(alloc_beg).\n-static AsanChunk *GetAsanChunk(void *alloc_beg) {\n-  if (!alloc_beg) return 0;\n-  if (!allocator.FromPrimary(alloc_beg)) {\n-    uptr *meta = reinterpret_cast<uptr *>(allocator.GetMetaData(alloc_beg));\n-    AsanChunk *m = reinterpret_cast<AsanChunk *>(meta[1]);\n-    return m;\n-  }\n-  uptr *alloc_magic = reinterpret_cast<uptr *>(alloc_beg);\n-  if (alloc_magic[0] == kAllocBegMagic)\n-    return reinterpret_cast<AsanChunk *>(alloc_magic[1]);\n-  return reinterpret_cast<AsanChunk *>(alloc_beg);\n-}\n-\n-static AsanChunk *GetAsanChunkByAddr(uptr p) {\n-  void *alloc_beg = allocator.GetBlockBegin(reinterpret_cast<void *>(p));\n-  return GetAsanChunk(alloc_beg);\n-}\n-\n-// Allocator must be locked when this function is called.\n-static AsanChunk *GetAsanChunkByAddrFastLocked(uptr p) {\n-  void *alloc_beg =\n-      allocator.GetBlockBeginFastLocked(reinterpret_cast<void *>(p));\n-  return GetAsanChunk(alloc_beg);\n-}\n-\n-static uptr AllocationSize(uptr p) {\n-  AsanChunk *m = GetAsanChunkByAddr(p);\n-  if (!m) return 0;\n-  if (m->chunk_state != CHUNK_ALLOCATED) return 0;\n-  if (m->Beg() != p) return 0;\n-  return m->UsedSize();\n-}\n-\n-// We have an address between two chunks, and we want to report just one.\n-AsanChunk *ChooseChunk(uptr addr,\n-                       AsanChunk *left_chunk, AsanChunk *right_chunk) {\n-  // Prefer an allocated chunk over freed chunk and freed chunk\n-  // over available chunk.\n-  if (left_chunk->chunk_state != right_chunk->chunk_state) {\n-    if (left_chunk->chunk_state == CHUNK_ALLOCATED)\n-      return left_chunk;\n-    if (right_chunk->chunk_state == CHUNK_ALLOCATED)\n-      return right_chunk;\n-    if (left_chunk->chunk_state == CHUNK_QUARANTINE)\n-      return left_chunk;\n-    if (right_chunk->chunk_state == CHUNK_QUARANTINE)\n-      return right_chunk;\n-  }\n-  // Same chunk_state: choose based on offset.\n-  sptr l_offset = 0, r_offset = 0;\n-  CHECK(AsanChunkView(left_chunk).AddrIsAtRight(addr, 1, &l_offset));\n-  CHECK(AsanChunkView(right_chunk).AddrIsAtLeft(addr, 1, &r_offset));\n-  if (l_offset < r_offset)\n-    return left_chunk;\n-  return right_chunk;\n-}\n-\n-AsanChunkView FindHeapChunkByAddress(uptr addr) {\n-  AsanChunk *m1 = GetAsanChunkByAddr(addr);\n-  if (!m1) return AsanChunkView(m1);\n-  sptr offset = 0;\n-  if (AsanChunkView(m1).AddrIsAtLeft(addr, 1, &offset)) {\n-    // The address is in the chunk's left redzone, so maybe it is actually\n-    // a right buffer overflow from the other chunk to the left.\n-    // Search a bit to the left to see if there is another chunk.\n-    AsanChunk *m2 = 0;\n-    for (uptr l = 1; l < GetPageSizeCached(); l++) {\n-      m2 = GetAsanChunkByAddr(addr - l);\n-      if (m2 == m1) continue;  // Still the same chunk.\n-      break;\n-    }\n-    if (m2 && AsanChunkView(m2).AddrIsAtRight(addr, 1, &offset))\n-      m1 = ChooseChunk(addr, m2, m1);\n-  }\n-  return AsanChunkView(m1);\n-}\n-\n-void AsanThreadLocalMallocStorage::CommitBack() {\n-  AllocatorCache *ac = GetAllocatorCache(this);\n-  quarantine.Drain(GetQuarantineCache(this), QuarantineCallback(ac));\n-  allocator.SwallowCache(GetAllocatorCache(this));\n-}\n-\n-void PrintInternalAllocatorStats() {\n-  allocator.PrintStats();\n-}\n-\n-void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n-                    AllocType alloc_type) {\n-  return Allocate(size, alignment, stack, alloc_type, true);\n-}\n-\n-void asan_free(void *ptr, BufferedStackTrace *stack, AllocType alloc_type) {\n-  Deallocate(ptr, 0, stack, alloc_type);\n-}\n-\n-void asan_sized_free(void *ptr, uptr size, BufferedStackTrace *stack,\n-                     AllocType alloc_type) {\n-  Deallocate(ptr, size, stack, alloc_type);\n-}\n-\n-void *asan_malloc(uptr size, BufferedStackTrace *stack) {\n-  return Allocate(size, 8, stack, FROM_MALLOC, true);\n-}\n-\n-void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n-  if (CallocShouldReturnNullDueToOverflow(size, nmemb))\n-    return AllocatorReturnNull();\n-  void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC, false);\n-  // If the memory comes from the secondary allocator no need to clear it\n-  // as it comes directly from mmap.\n-  if (ptr && allocator.FromPrimary(ptr))\n-    REAL(memset)(ptr, 0, nmemb * size);\n-  return ptr;\n-}\n-\n-void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack) {\n-  if (p == 0)\n-    return Allocate(size, 8, stack, FROM_MALLOC, true);\n-  if (size == 0) {\n-    Deallocate(p, 0, stack, FROM_MALLOC);\n-    return 0;\n-  }\n-  return Reallocate(p, size, stack);\n-}\n-\n-void *asan_valloc(uptr size, BufferedStackTrace *stack) {\n-  return Allocate(size, GetPageSizeCached(), stack, FROM_MALLOC, true);\n-}\n-\n-void *asan_pvalloc(uptr size, BufferedStackTrace *stack) {\n-  uptr PageSize = GetPageSizeCached();\n-  size = RoundUpTo(size, PageSize);\n-  if (size == 0) {\n-    // pvalloc(0) should allocate one page.\n-    size = PageSize;\n-  }\n-  return Allocate(size, PageSize, stack, FROM_MALLOC, true);\n-}\n-\n-int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n-                        BufferedStackTrace *stack) {\n-  void *ptr = Allocate(size, alignment, stack, FROM_MALLOC, true);\n-  CHECK(IsAligned((uptr)ptr, alignment));\n-  *memptr = ptr;\n-  return 0;\n-}\n-\n-uptr asan_malloc_usable_size(void *ptr, uptr pc, uptr bp) {\n-  if (ptr == 0) return 0;\n-  uptr usable_size = AllocationSize(reinterpret_cast<uptr>(ptr));\n-  if (flags()->check_malloc_usable_size && (usable_size == 0)) {\n-    GET_STACK_TRACE_FATAL(pc, bp);\n-    ReportMallocUsableSizeNotOwned((uptr)ptr, &stack);\n-  }\n-  return usable_size;\n-}\n-\n-uptr asan_mz_size(const void *ptr) {\n-  return AllocationSize(reinterpret_cast<uptr>(ptr));\n-}\n-\n-void asan_mz_force_lock() {\n-  allocator.ForceLock();\n-  fallback_mutex.Lock();\n-}\n-\n-void asan_mz_force_unlock() {\n-  fallback_mutex.Unlock();\n-  allocator.ForceUnlock();\n-}\n-\n-}  // namespace __asan\n-\n-// --- Implementation of LSan-specific functions --- {{{1\n-namespace __lsan {\n-void LockAllocator() {\n-  __asan::allocator.ForceLock();\n-}\n-\n-void UnlockAllocator() {\n-  __asan::allocator.ForceUnlock();\n-}\n-\n-void GetAllocatorGlobalRange(uptr *begin, uptr *end) {\n-  *begin = (uptr)&__asan::allocator;\n-  *end = *begin + sizeof(__asan::allocator);\n-}\n-\n-uptr PointsIntoChunk(void* p) {\n-  uptr addr = reinterpret_cast<uptr>(p);\n-  __asan::AsanChunk *m = __asan::GetAsanChunkByAddrFastLocked(addr);\n-  if (!m) return 0;\n-  uptr chunk = m->Beg();\n-  if (m->chunk_state != __asan::CHUNK_ALLOCATED)\n-    return 0;\n-  if (m->AddrIsInside(addr, /*locked_version=*/true))\n-    return chunk;\n-  if (IsSpecialCaseOfOperatorNew0(chunk, m->UsedSize(/*locked_version*/ true),\n-                                  addr))\n-    return chunk;\n-  return 0;\n-}\n-\n-uptr GetUserBegin(uptr chunk) {\n-  __asan::AsanChunk *m =\n-      __asan::GetAsanChunkByAddrFastLocked(chunk);\n-  CHECK(m);\n-  return m->Beg();\n-}\n-\n-LsanMetadata::LsanMetadata(uptr chunk) {\n-  metadata_ = reinterpret_cast<void *>(chunk - __asan::kChunkHeaderSize);\n-}\n-\n-bool LsanMetadata::allocated() const {\n-  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return m->chunk_state == __asan::CHUNK_ALLOCATED;\n-}\n-\n-ChunkTag LsanMetadata::tag() const {\n-  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return static_cast<ChunkTag>(m->lsan_tag);\n-}\n-\n-void LsanMetadata::set_tag(ChunkTag value) {\n-  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  m->lsan_tag = value;\n-}\n-\n-uptr LsanMetadata::requested_size() const {\n-  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return m->UsedSize(/*locked_version=*/true);\n-}\n-\n-u32 LsanMetadata::stack_trace_id() const {\n-  __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return m->alloc_context_id;\n-}\n-\n-void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n-  __asan::allocator.ForEachChunk(callback, arg);\n-}\n-\n-IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n-  uptr addr = reinterpret_cast<uptr>(p);\n-  __asan::AsanChunk *m = __asan::GetAsanChunkByAddr(addr);\n-  if (!m) return kIgnoreObjectInvalid;\n-  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) && m->AddrIsInside(addr)) {\n-    if (m->lsan_tag == kIgnored)\n-      return kIgnoreObjectAlreadyIgnored;\n-    m->lsan_tag = __lsan::kIgnored;\n-    return kIgnoreObjectSuccess;\n-  } else {\n-    return kIgnoreObjectInvalid;\n-  }\n-}\n-}  // namespace __lsan\n-\n-// ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n-// ASan allocator doesn't reserve extra bytes, so normally we would\n-// just return \"size\". We don't want to expose our redzone sizes, etc here.\n-uptr __sanitizer_get_estimated_allocated_size(uptr size) {\n-  return size;\n-}\n-\n-int __sanitizer_get_ownership(const void *p) {\n-  uptr ptr = reinterpret_cast<uptr>(p);\n-  return (AllocationSize(ptr) > 0);\n-}\n-\n-uptr __sanitizer_get_allocated_size(const void *p) {\n-  if (p == 0) return 0;\n-  uptr ptr = reinterpret_cast<uptr>(p);\n-  uptr allocated_size = AllocationSize(ptr);\n-  // Die if p is not malloced or if it is already freed.\n-  if (allocated_size == 0) {\n-    GET_STACK_TRACE_FATAL_HERE;\n-    ReportSanitizerGetAllocatedSizeNotOwned(ptr, &stack);\n-  }\n-  return allocated_size;\n-}\n-\n-#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n-// Provide default (no-op) implementation of malloc hooks.\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_malloc_hook(void *ptr, uptr size) {\n-  (void)ptr;\n-  (void)size;\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_free_hook(void *ptr) {\n-  (void)ptr;\n-}\n-}  // extern \"C\"\n-#endif"}, {"sha": "6e33a9d4c51f419a52620b1730f411eeac4e8d3e", "filename": "libsanitizer/asan/asan_debugging.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -79,8 +79,8 @@ void AsanLocateAddress(uptr addr, AddressDescription *descr) {\n   GetInfoForHeapAddress(addr, descr);\n }\n \n-uptr AsanGetStack(uptr addr, uptr *trace, uptr size, u32 *thread_id,\n-                  bool alloc_stack) {\n+static uptr AsanGetStack(uptr addr, uptr *trace, u32 size, u32 *thread_id,\n+                         bool alloc_stack) {\n   AsanChunkView chunk = FindHeapChunkByAddress(addr);\n   if (!chunk.IsValid()) return 0;\n \n@@ -106,14 +106,14 @@ uptr AsanGetStack(uptr addr, uptr *trace, uptr size, u32 *thread_id,\n   return 0;\n }\n \n-}  // namespace __asan\n+} // namespace __asan\n \n using namespace __asan;\n \n SANITIZER_INTERFACE_ATTRIBUTE\n const char *__asan_locate_address(uptr addr, char *name, uptr name_size,\n                                   uptr *region_address, uptr *region_size) {\n-  AddressDescription descr = { name, name_size, 0, 0, 0 };\n+  AddressDescription descr = { name, name_size, 0, 0, nullptr };\n   AsanLocateAddress(addr, &descr);\n   if (region_address) *region_address = descr.region_address;\n   if (region_size) *region_size = descr.region_size;"}, {"sha": "de190d11a16d8671c509a92cddc3ff2140392096", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,6 +9,7 @@\n //\n // FakeStack is used to detect use-after-return bugs.\n //===----------------------------------------------------------------------===//\n+\n #include \"asan_allocator.h\"\n #include \"asan_poisoning.h\"\n #include \"asan_thread.h\"\n@@ -20,13 +21,19 @@ static const u64 kMagic2 = (kMagic1 << 8) | kMagic1;\n static const u64 kMagic4 = (kMagic2 << 16) | kMagic2;\n static const u64 kMagic8 = (kMagic4 << 32) | kMagic4;\n \n+static const u64 kAllocaRedzoneSize = 32UL;\n+static const u64 kAllocaRedzoneMask = 31UL;\n+\n // For small size classes inline PoisonShadow for better performance.\n ALWAYS_INLINE void SetShadow(uptr ptr, uptr size, uptr class_id, u64 magic) {\n   CHECK_EQ(SHADOW_SCALE, 3);  // This code expects SHADOW_SCALE=3.\n   u64 *shadow = reinterpret_cast<u64*>(MemToShadow(ptr));\n   if (class_id <= 6) {\n-    for (uptr i = 0; i < (1U << class_id); i++)\n+    for (uptr i = 0; i < (1U << class_id); i++) {\n       shadow[i] = magic;\n+      // Make sure this does not become memset.\n+      SanitizerBreakOptimization(nullptr);\n+    }\n   } else {\n     // The size class is too big, it's cheaper to poison only size bytes.\n     PoisonShadow(ptr, size, static_cast<u8>(magic));\n@@ -56,7 +63,7 @@ FakeStack *FakeStack::Create(uptr stack_size_log) {\n \n void FakeStack::Destroy(int tid) {\n   PoisonAll(0);\n-  if (common_flags()->verbosity >= 2) {\n+  if (Verbosity() >= 2) {\n     InternalScopedString str(kNumberOfSizeClasses * 50);\n     for (uptr class_id = 0; class_id < kNumberOfSizeClasses; class_id++)\n       str.append(\"%zd: %zd/%zd; \", class_id, hint_position_[class_id],\n@@ -73,7 +80,9 @@ void FakeStack::PoisonAll(u8 magic) {\n                magic);\n }\n \n+#if !defined(_MSC_VER) || defined(__clang__)\n ALWAYS_INLINE USED\n+#endif\n FakeFrame *FakeStack::Allocate(uptr stack_size_log, uptr class_id,\n                                uptr real_stack) {\n   CHECK_LT(class_id, kNumberOfSizeClasses);\n@@ -99,7 +108,7 @@ FakeFrame *FakeStack::Allocate(uptr stack_size_log, uptr class_id,\n     *SavedFlagPtr(reinterpret_cast<uptr>(res), class_id) = &flags[pos];\n     return res;\n   }\n-  return 0; // We are out of fake stack.\n+  return nullptr; // We are out of fake stack.\n }\n \n uptr FakeStack::AddrIsInFakeStack(uptr ptr, uptr *frame_beg, uptr *frame_end) {\n@@ -176,48 +185,47 @@ void SetTLSFakeStack(FakeStack *fs) { }\n \n static FakeStack *GetFakeStack() {\n   AsanThread *t = GetCurrentThread();\n-  if (!t) return 0;\n+  if (!t) return nullptr;\n   return t->fake_stack();\n }\n \n static FakeStack *GetFakeStackFast() {\n   if (FakeStack *fs = GetTLSFakeStack())\n     return fs;\n   if (!__asan_option_detect_stack_use_after_return)\n-    return 0;\n+    return nullptr;\n   return GetFakeStack();\n }\n \n-ALWAYS_INLINE uptr OnMalloc(uptr class_id, uptr size, uptr real_stack) {\n+ALWAYS_INLINE uptr OnMalloc(uptr class_id, uptr size) {\n   FakeStack *fs = GetFakeStackFast();\n-  if (!fs) return real_stack;\n+  if (!fs) return 0;\n+  uptr local_stack;\n+  uptr real_stack = reinterpret_cast<uptr>(&local_stack);\n   FakeFrame *ff = fs->Allocate(fs->stack_size_log(), class_id, real_stack);\n-  if (!ff)\n-    return real_stack;  // Out of fake stack, return the real one.\n+  if (!ff) return 0;  // Out of fake stack.\n   uptr ptr = reinterpret_cast<uptr>(ff);\n   SetShadow(ptr, size, class_id, 0);\n   return ptr;\n }\n \n-ALWAYS_INLINE void OnFree(uptr ptr, uptr class_id, uptr size, uptr real_stack) {\n-  if (ptr == real_stack)\n-    return;\n+ALWAYS_INLINE void OnFree(uptr ptr, uptr class_id, uptr size) {\n   FakeStack::Deallocate(ptr, class_id);\n   SetShadow(ptr, size, class_id, kMagic8);\n }\n \n-}  // namespace __asan\n+} // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;\n #define DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(class_id)                       \\\n   extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr                                \\\n-  __asan_stack_malloc_##class_id(uptr size, uptr real_stack) {                 \\\n-    return OnMalloc(class_id, size, real_stack);                               \\\n+      __asan_stack_malloc_##class_id(uptr size) {                              \\\n+    return OnMalloc(class_id, size);                                           \\\n   }                                                                            \\\n   extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __asan_stack_free_##class_id(  \\\n-      uptr ptr, uptr size, uptr real_stack) {                                  \\\n-    OnFree(ptr, class_id, size, real_stack);                                   \\\n+      uptr ptr, uptr size) {                                                   \\\n+    OnFree(ptr, class_id, size);                                               \\\n   }\n \n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(0)\n@@ -239,15 +247,35 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,\n                                    void **end) {\n   FakeStack *fs = reinterpret_cast<FakeStack*>(fake_stack);\n-  if (!fs) return 0;\n+  if (!fs) return nullptr;\n   uptr frame_beg, frame_end;\n   FakeFrame *frame = reinterpret_cast<FakeFrame *>(fs->AddrIsInFakeStack(\n       reinterpret_cast<uptr>(addr), &frame_beg, &frame_end));\n-  if (!frame) return 0;\n+  if (!frame) return nullptr;\n   if (frame->magic != kCurrentStackFrameMagic)\n-    return 0;\n+    return nullptr;\n   if (beg) *beg = reinterpret_cast<void*>(frame_beg);\n   if (end) *end = reinterpret_cast<void*>(frame_end);\n   return reinterpret_cast<void*>(frame->real_stack);\n }\n-}  // extern \"C\"\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_alloca_poison(uptr addr, uptr size) {\n+  uptr LeftRedzoneAddr = addr - kAllocaRedzoneSize;\n+  uptr PartialRzAddr = addr + size;\n+  uptr RightRzAddr = (PartialRzAddr + kAllocaRedzoneMask) & ~kAllocaRedzoneMask;\n+  uptr PartialRzAligned = PartialRzAddr & ~(SHADOW_GRANULARITY - 1);\n+  FastPoisonShadow(LeftRedzoneAddr, kAllocaRedzoneSize, kAsanAllocaLeftMagic);\n+  FastPoisonShadowPartialRightRedzone(\n+      PartialRzAligned, PartialRzAddr % SHADOW_GRANULARITY,\n+      RightRzAddr - PartialRzAligned, kAsanAllocaRightMagic);\n+  FastPoisonShadow(RightRzAddr, kAllocaRedzoneSize, kAsanAllocaRightMagic);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_allocas_unpoison(uptr top, uptr bottom) {\n+  if ((!top) || (top > bottom)) return;\n+  REAL(memset)(reinterpret_cast<void*>(MemToShadow(top)), 0,\n+               (bottom - top) / SHADOW_GRANULARITY);\n+}\n+} // extern \"C\""}, {"sha": "9a68ad4eaa8e5887a56896a912d106f5eaac5e3e", "filename": "libsanitizer/asan/asan_flags.cc", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,177 @@\n+//===-- asan_flags.cc -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan flag parsing logic.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_activation.h\"\n+#include \"asan_flags.h\"\n+#include \"asan_interface_internal.h\"\n+#include \"asan_stack.h\"\n+#include \"lsan/lsan_common.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_flag_parser.h\"\n+#include \"ubsan/ubsan_flags.h\"\n+#include \"ubsan/ubsan_platform.h\"\n+\n+namespace __asan {\n+\n+Flags asan_flags_dont_use_directly;  // use via flags().\n+\n+static const char *MaybeCallAsanDefaultOptions() {\n+  return (&__asan_default_options) ? __asan_default_options() : \"\";\n+}\n+\n+static const char *MaybeUseAsanDefaultOptionsCompileDefinition() {\n+#ifdef ASAN_DEFAULT_OPTIONS\n+// Stringize the macro value.\n+# define ASAN_STRINGIZE(x) #x\n+# define ASAN_STRINGIZE_OPTIONS(options) ASAN_STRINGIZE(options)\n+  return ASAN_STRINGIZE_OPTIONS(ASAN_DEFAULT_OPTIONS);\n+#else\n+  return \"\";\n+#endif\n+}\n+\n+void Flags::SetDefaults() {\n+#define ASAN_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n+#include \"asan_flags.inc\"\n+#undef ASAN_FLAG\n+}\n+\n+static void RegisterAsanFlags(FlagParser *parser, Flags *f) {\n+#define ASAN_FLAG(Type, Name, DefaultValue, Description) \\\n+  RegisterFlag(parser, #Name, Description, &f->Name);\n+#include \"asan_flags.inc\"\n+#undef ASAN_FLAG\n+}\n+\n+void InitializeFlags() {\n+  // Set the default values and prepare for parsing ASan and common flags.\n+  SetCommonFlagsDefaults();\n+  {\n+    CommonFlags cf;\n+    cf.CopyFrom(*common_flags());\n+    cf.detect_leaks = CAN_SANITIZE_LEAKS;\n+    cf.external_symbolizer_path = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n+    cf.malloc_context_size = kDefaultMallocContextSize;\n+    cf.intercept_tls_get_addr = true;\n+    cf.exitcode = 1;\n+    OverrideCommonFlags(cf);\n+  }\n+  Flags *f = flags();\n+  f->SetDefaults();\n+\n+  FlagParser asan_parser;\n+  RegisterAsanFlags(&asan_parser, f);\n+  RegisterCommonFlags(&asan_parser);\n+\n+  // Set the default values and prepare for parsing LSan and UBSan flags\n+  // (which can also overwrite common flags).\n+#if CAN_SANITIZE_LEAKS\n+  __lsan::Flags *lf = __lsan::flags();\n+  lf->SetDefaults();\n+\n+  FlagParser lsan_parser;\n+  __lsan::RegisterLsanFlags(&lsan_parser, lf);\n+  RegisterCommonFlags(&lsan_parser);\n+#endif\n+\n+#if CAN_SANITIZE_UB\n+  __ubsan::Flags *uf = __ubsan::flags();\n+  uf->SetDefaults();\n+\n+  FlagParser ubsan_parser;\n+  __ubsan::RegisterUbsanFlags(&ubsan_parser, uf);\n+  RegisterCommonFlags(&ubsan_parser);\n+#endif\n+\n+  // Override from ASan compile definition.\n+  const char *asan_compile_def = MaybeUseAsanDefaultOptionsCompileDefinition();\n+  asan_parser.ParseString(asan_compile_def);\n+\n+  // Override from user-specified string.\n+  const char *asan_default_options = MaybeCallAsanDefaultOptions();\n+  asan_parser.ParseString(asan_default_options);\n+#if CAN_SANITIZE_UB\n+  const char *ubsan_default_options = __ubsan::MaybeCallUbsanDefaultOptions();\n+  ubsan_parser.ParseString(ubsan_default_options);\n+#endif\n+\n+  // Override from command line.\n+  asan_parser.ParseString(GetEnv(\"ASAN_OPTIONS\"));\n+#if CAN_SANITIZE_LEAKS\n+  lsan_parser.ParseString(GetEnv(\"LSAN_OPTIONS\"));\n+#endif\n+#if CAN_SANITIZE_UB\n+  ubsan_parser.ParseString(GetEnv(\"UBSAN_OPTIONS\"));\n+#endif\n+\n+  // Let activation flags override current settings. On Android they come\n+  // from a system property. On other platforms this is no-op.\n+  if (!flags()->start_deactivated) {\n+    char buf[100];\n+    GetExtraActivationFlags(buf, sizeof(buf));\n+    asan_parser.ParseString(buf);\n+  }\n+\n+  SetVerbosity(common_flags()->verbosity);\n+\n+  // TODO(eugenis): dump all flags at verbosity>=2?\n+  if (Verbosity()) ReportUnrecognizedFlags();\n+\n+  if (common_flags()->help) {\n+    // TODO(samsonov): print all of the flags (ASan, LSan, common).\n+    asan_parser.PrintFlagDescriptions();\n+  }\n+\n+  // Flag validation:\n+  if (!CAN_SANITIZE_LEAKS && common_flags()->detect_leaks) {\n+    Report(\"%s: detect_leaks is not supported on this platform.\\n\",\n+           SanitizerToolName);\n+    Die();\n+  }\n+  // Make \"strict_init_order\" imply \"check_initialization_order\".\n+  // TODO(samsonov): Use a single runtime flag for an init-order checker.\n+  if (f->strict_init_order) {\n+    f->check_initialization_order = true;\n+  }\n+  CHECK_LE((uptr)common_flags()->malloc_context_size, kStackTraceMax);\n+  CHECK_LE(f->min_uar_stack_size_log, f->max_uar_stack_size_log);\n+  CHECK_GE(f->redzone, 16);\n+  CHECK_GE(f->max_redzone, f->redzone);\n+  CHECK_LE(f->max_redzone, 2048);\n+  CHECK(IsPowerOfTwo(f->redzone));\n+  CHECK(IsPowerOfTwo(f->max_redzone));\n+\n+  // quarantine_size is deprecated but we still honor it.\n+  // quarantine_size can not be used together with quarantine_size_mb.\n+  if (f->quarantine_size >= 0 && f->quarantine_size_mb >= 0) {\n+    Report(\"%s: please use either 'quarantine_size' (deprecated) or \"\n+           \"quarantine_size_mb, but not both\\n\", SanitizerToolName);\n+    Die();\n+  }\n+  if (f->quarantine_size >= 0)\n+    f->quarantine_size_mb = f->quarantine_size >> 20;\n+  if (f->quarantine_size_mb < 0) {\n+    const int kDefaultQuarantineSizeMb =\n+        (ASAN_LOW_MEMORY) ? 1UL << 6 : 1UL << 8;\n+    f->quarantine_size_mb = kDefaultQuarantineSizeMb;\n+  }\n+}\n+\n+}  // namespace __asan\n+\n+#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char* __asan_default_options() { return \"\"; }\n+}  // extern \"C\"\n+#endif"}, {"sha": "6b33789b84c2b2054b22bdb0e34d731a0e4a9af8", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 9, "deletions": 39, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,6 +14,7 @@\n #define ASAN_FLAGS_H\n \n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_flag_parser.h\"\n \n // ASan flag values can be defined in four ways:\n // 1) initialized with default values at startup.\n@@ -22,55 +23,24 @@\n // 3) overriden from string returned by user-specified function\n //    __asan_default_options().\n // 4) overriden from env variable ASAN_OPTIONS.\n+// 5) overriden during ASan activation (for now used on Android only).\n \n namespace __asan {\n \n struct Flags {\n-  // Flag descriptions are in asan_rtl.cc.\n-  int  quarantine_size;\n-  int  redzone;\n-  int  max_redzone;\n-  bool debug;\n-  int  report_globals;\n-  bool check_initialization_order;\n-  bool replace_str;\n-  bool replace_intrin;\n-  bool mac_ignore_invalid_free;\n-  bool detect_stack_use_after_return;\n-  int min_uar_stack_size_log;\n-  int max_uar_stack_size_log;\n-  bool uar_noreserve;\n-  int max_malloc_fill_size, malloc_fill_byte;\n-  int  exitcode;\n-  bool allow_user_poisoning;\n-  int  sleep_before_dying;\n-  bool check_malloc_usable_size;\n-  bool unmap_shadow_on_exit;\n-  bool abort_on_error;\n-  bool print_stats;\n-  bool print_legend;\n-  bool atexit;\n-  bool allow_reexec;\n-  bool print_full_thread_history;\n-  bool poison_heap;\n-  bool poison_partial;\n-  bool poison_array_cookie;\n-  bool alloc_dealloc_mismatch;\n-  bool new_delete_type_mismatch;\n-  bool strict_memcmp;\n-  bool strict_init_order;\n-  bool start_deactivated;\n-  int detect_invalid_pointer_pairs;\n-  bool detect_container_overflow;\n-  int detect_odr_violation;\n-  bool dump_instruction_bytes;\n+#define ASAN_FLAG(Type, Name, DefaultValue, Description) Type Name;\n+#include \"asan_flags.inc\"\n+#undef ASAN_FLAG\n+\n+  void SetDefaults();\n };\n \n extern Flags asan_flags_dont_use_directly;\n inline Flags *flags() {\n   return &asan_flags_dont_use_directly;\n }\n-void InitializeFlags(Flags *f, const char *env);\n+\n+void InitializeFlags();\n \n }  // namespace __asan\n "}, {"sha": "3163c23cd098b03446687c352cafd39423495637", "filename": "libsanitizer/asan/asan_flags.inc", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,134 @@\n+//===-- asan_flags.inc ------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// ASan runtime flags.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_FLAG\n+# error \"Define ASAN_FLAG prior to including this file!\"\n+#endif\n+\n+// ASAN_FLAG(Type, Name, DefaultValue, Description)\n+// See COMMON_FLAG in sanitizer_flags.inc for more details.\n+\n+ASAN_FLAG(int, quarantine_size, -1,\n+            \"Deprecated, please use quarantine_size_mb.\")\n+ASAN_FLAG(int, quarantine_size_mb, -1,\n+          \"Size (in Mb) of quarantine used to detect use-after-free \"\n+          \"errors. Lower value may reduce memory usage but increase the \"\n+          \"chance of false negatives.\")\n+ASAN_FLAG(int, redzone, 16,\n+          \"Minimal size (in bytes) of redzones around heap objects. \"\n+          \"Requirement: redzone >= 16, is a power of two.\")\n+ASAN_FLAG(int, max_redzone, 2048,\n+          \"Maximal size (in bytes) of redzones around heap objects.\")\n+ASAN_FLAG(\n+    bool, debug, false,\n+    \"If set, prints some debugging information and does additional checks.\")\n+ASAN_FLAG(\n+    int, report_globals, 1,\n+    \"Controls the way to handle globals (0 - don't detect buffer overflow on \"\n+    \"globals, 1 - detect buffer overflow, 2 - print data about registered \"\n+    \"globals).\")\n+ASAN_FLAG(bool, check_initialization_order, false,\n+          \"If set, attempts to catch initialization order issues.\")\n+ASAN_FLAG(\n+    bool, replace_str, true,\n+    \"If set, uses custom wrappers and replacements for libc string functions \"\n+    \"to find more errors.\")\n+ASAN_FLAG(bool, replace_intrin, true,\n+          \"If set, uses custom wrappers for memset/memcpy/memmove intinsics.\")\n+ASAN_FLAG(bool, mac_ignore_invalid_free, false,\n+          \"Ignore invalid free() calls to work around some bugs. Used on OS X \"\n+          \"only.\")\n+ASAN_FLAG(bool, detect_stack_use_after_return, false,\n+          \"Enables stack-use-after-return checking at run-time.\")\n+ASAN_FLAG(int, min_uar_stack_size_log, 16, // We can't do smaller anyway.\n+          \"Minimum fake stack size log.\")\n+ASAN_FLAG(int, max_uar_stack_size_log,\n+          20, // 1Mb per size class, i.e. ~11Mb per thread\n+          \"Maximum fake stack size log.\")\n+ASAN_FLAG(bool, uar_noreserve, false,\n+          \"Use mmap with 'noreserve' flag to allocate fake stack.\")\n+ASAN_FLAG(\n+    int, max_malloc_fill_size, 0x1000,  // By default, fill only the first 4K.\n+    \"ASan allocator flag. max_malloc_fill_size is the maximal amount of \"\n+    \"bytes that will be filled with malloc_fill_byte on malloc.\")\n+ASAN_FLAG(int, malloc_fill_byte, 0xbe,\n+          \"Value used to fill the newly allocated memory.\")\n+ASAN_FLAG(bool, allow_user_poisoning, true,\n+          \"If set, user may manually mark memory regions as poisoned or \"\n+          \"unpoisoned.\")\n+ASAN_FLAG(\n+    int, sleep_before_dying, 0,\n+    \"Number of seconds to sleep between printing an error report and \"\n+    \"terminating the program. Useful for debugging purposes (e.g. when one \"\n+    \"needs to attach gdb).\")\n+ASAN_FLAG(bool, check_malloc_usable_size, true,\n+          \"Allows the users to work around the bug in Nvidia drivers prior to \"\n+          \"295.*.\")\n+ASAN_FLAG(bool, unmap_shadow_on_exit, false,\n+          \"If set, explicitly unmaps the (huge) shadow at exit.\")\n+ASAN_FLAG(bool, print_stats, false,\n+          \"Print various statistics after printing an error message or if \"\n+          \"atexit=1.\")\n+ASAN_FLAG(bool, print_legend, true, \"Print the legend for the shadow bytes.\")\n+ASAN_FLAG(bool, atexit, false,\n+          \"If set, prints ASan exit stats even after program terminates \"\n+          \"successfully.\")\n+ASAN_FLAG(\n+    bool, print_full_thread_history, true,\n+    \"If set, prints thread creation stacks for the threads involved in the \"\n+    \"report and their ancestors up to the main thread.\")\n+ASAN_FLAG(\n+    bool, poison_heap, true,\n+    \"Poison (or not) the heap memory on [de]allocation. Zero value is useful \"\n+    \"for benchmarking the allocator or instrumentator.\")\n+ASAN_FLAG(bool, poison_partial, true,\n+          \"If true, poison partially addressable 8-byte aligned words \"\n+          \"(default=true). This flag affects heap and global buffers, but not \"\n+          \"stack buffers.\")\n+ASAN_FLAG(bool, poison_array_cookie, true,\n+          \"Poison (or not) the array cookie after operator new[].\")\n+\n+// Turn off alloc/dealloc mismatch checker on Mac and Windows for now.\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=131\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=309\n+// TODO(glider,timurrrr): Fix known issues and enable this back.\n+ASAN_FLAG(bool, alloc_dealloc_mismatch,\n+          (SANITIZER_MAC == 0) && (SANITIZER_WINDOWS == 0),\n+          \"Report errors on malloc/delete, new/free, new/delete[], etc.\")\n+\n+ASAN_FLAG(bool, new_delete_type_mismatch, true,\n+          \"Report errors on mismatch betwen size of new and delete.\")\n+ASAN_FLAG(\n+    bool, strict_init_order, false,\n+    \"If true, assume that dynamic initializers can never access globals from \"\n+    \"other modules, even if the latter are already initialized.\")\n+ASAN_FLAG(\n+    bool, start_deactivated, false,\n+    \"If true, ASan tweaks a bunch of other flags (quarantine, redzone, heap \"\n+    \"poisoning) to reduce memory consumption as much as possible, and \"\n+    \"restores them to original values when the first instrumented module is \"\n+    \"loaded into the process. This is mainly intended to be used on \"\n+    \"Android. \")\n+ASAN_FLAG(\n+    int, detect_invalid_pointer_pairs, 0,\n+    \"If non-zero, try to detect operations like <, <=, >, >= and - on \"\n+    \"invalid pointer pairs (e.g. when pointers belong to different objects). \"\n+    \"The bigger the value the harder we try.\")\n+ASAN_FLAG(\n+    bool, detect_container_overflow, true,\n+    \"If true, honor the container overflow  annotations. \"\n+    \"See https://code.google.com/p/address-sanitizer/wiki/ContainerOverflow\")\n+ASAN_FLAG(int, detect_odr_violation, 2,\n+          \"If >=2, detect violation of One-Definition-Rule (ODR); \"\n+          \"If ==1, detect ODR-violation only if the two variables \"\n+          \"have different sizes\")\n+ASAN_FLAG(bool, dump_instruction_bytes, false,\n+          \"If true, dump 16 bytes starting at the instruction that caused SEGV\")\n+ASAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")"}, {"sha": "b132c8b09b9116fa4cc163e0864a14c344410984", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,13 +9,15 @@\n //\n // Handle globals.\n //===----------------------------------------------------------------------===//\n+\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n #include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n+#include \"asan_suppressions.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n@@ -71,7 +73,7 @@ ALWAYS_INLINE void PoisonRedZones(const Global &g) {\n \n const uptr kMinimalDistanceFromAnotherGlobal = 64;\n \n-bool IsAddressNearGlobal(uptr addr, const __asan_global &g) {\n+static bool IsAddressNearGlobal(uptr addr, const __asan_global &g) {\n   if (addr <= g.beg - kMinimalDistanceFromAnotherGlobal) return false;\n   if (addr >= g.beg + g.size_with_redzone) return false;\n   return true;\n@@ -88,36 +90,40 @@ static void ReportGlobal(const Global &g, const char *prefix) {\n   }\n }\n \n-static bool DescribeOrGetInfoIfGlobal(uptr addr, uptr size, bool print,\n-                                      Global *output_global) {\n-  if (!flags()->report_globals) return false;\n+static u32 FindRegistrationSite(const Global *g) {\n+  mu_for_globals.CheckLocked();\n+  CHECK(global_registration_site_vector);\n+  for (uptr i = 0, n = global_registration_site_vector->size(); i < n; i++) {\n+    GlobalRegistrationSite &grs = (*global_registration_site_vector)[i];\n+    if (g >= grs.g_first && g <= grs.g_last)\n+      return grs.stack_id;\n+  }\n+  return 0;\n+}\n+\n+int GetGlobalsForAddress(uptr addr, Global *globals, u32 *reg_sites,\n+                         int max_globals) {\n+  if (!flags()->report_globals) return 0;\n   BlockingMutexLock lock(&mu_for_globals);\n-  bool res = false;\n+  int res = 0;\n   for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n     const Global &g = *l->g;\n-    if (print) {\n-      if (flags()->report_globals >= 2)\n-        ReportGlobal(g, \"Search\");\n-      res |= DescribeAddressRelativeToGlobal(addr, size, g);\n-    } else {\n-      if (IsAddressNearGlobal(addr, g)) {\n-        CHECK(output_global);\n-        *output_global = g;\n-        return true;\n-      }\n+    if (flags()->report_globals >= 2)\n+      ReportGlobal(g, \"Search\");\n+    if (IsAddressNearGlobal(addr, g)) {\n+      globals[res] = g;\n+      if (reg_sites)\n+        reg_sites[res] = FindRegistrationSite(&g);\n+      res++;\n+      if (res == max_globals) break;\n     }\n   }\n   return res;\n }\n \n-bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n-  return DescribeOrGetInfoIfGlobal(addr, size, /* print */ true,\n-                                   /* output_global */ nullptr);\n-}\n-\n bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr) {\n   Global g = {};\n-  if (DescribeOrGetInfoIfGlobal(addr, /* size */ 1, /* print */ false, &g)) {\n+  if (GetGlobalsForAddress(addr, &g, nullptr, 1)) {\n     internal_strncpy(descr->name, g.name, descr->name_size);\n     descr->region_address = g.beg;\n     descr->region_size = g.size;\n@@ -127,16 +133,6 @@ bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr) {\n   return false;\n }\n \n-u32 FindRegistrationSite(const Global *g) {\n-  CHECK(global_registration_site_vector);\n-  for (uptr i = 0, n = global_registration_site_vector->size(); i < n; i++) {\n-    GlobalRegistrationSite &grs = (*global_registration_site_vector)[i];\n-    if (g >= grs.g_first && g <= grs.g_last)\n-      return grs.stack_id;\n-  }\n-  return 0;\n-}\n-\n // Register a global variable.\n // This function may be called more than once for every global\n // so we store the globals in a map.\n@@ -148,30 +144,29 @@ static void RegisterGlobal(const Global *g) {\n   CHECK(AddrIsInMem(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n-  // This \"ODR violation\" detection is fundamentally incompatible with\n-  // how GCC registers globals.  Disable as useless until rewritten upstream.\n-  if (0 && flags()->detect_odr_violation) {\n+  if (flags()->detect_odr_violation) {\n     // Try detecting ODR (One Definition Rule) violation, i.e. the situation\n     // where two globals with the same name are defined in different modules.\n     if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n       // This check may not be enough: if the first global is much larger\n       // the entire redzone of the second global may be within the first global.\n       for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n         if (g->beg == l->g->beg &&\n-            (flags()->detect_odr_violation >= 2 || g->size != l->g->size))\n+            (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+            !IsODRViolationSuppressed(g->name))\n           ReportODRViolation(g, FindRegistrationSite(g),\n                              l->g, FindRegistrationSite(l->g));\n       }\n     }\n   }\n-  if (flags()->poison_heap)\n+  if (CanPoisonMemory())\n     PoisonRedZones(*g);\n   ListOfGlobals *l = new(allocator_for_globals) ListOfGlobals;\n   l->g = g;\n   l->next = list_of_all_globals;\n   list_of_all_globals = l;\n   if (g->has_dynamic_init) {\n-    if (dynamic_init_globals == 0) {\n+    if (!dynamic_init_globals) {\n       dynamic_init_globals = new(allocator_for_globals)\n           VectorOfGlobals(kDynamicInitGlobalsInitialCapacity);\n     }\n@@ -182,11 +177,13 @@ static void RegisterGlobal(const Global *g) {\n \n static void UnregisterGlobal(const Global *g) {\n   CHECK(asan_inited);\n+  if (flags()->report_globals >= 2)\n+    ReportGlobal(*g, \"Removed\");\n   CHECK(flags()->report_globals);\n   CHECK(AddrIsInMem(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n-  if (flags()->poison_heap)\n+  if (CanPoisonMemory())\n     PoisonShadowForGlobal(g, 0);\n   // We unpoison the shadow memory for the global but we do not remove it from\n   // the list because that would require O(n^2) time with the current list\n@@ -208,15 +205,15 @@ void StopInitOrderChecking() {\n   }\n }\n \n-}  // namespace __asan\n+} // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n // Register an array of globals.\n void __asan_register_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;\n-  GET_STACK_TRACE_FATAL_HERE;\n+  GET_STACK_TRACE_MALLOC;\n   u32 stack_id = StackDepotPut(stack);\n   BlockingMutexLock lock(&mu_for_globals);\n   if (!global_registration_site_vector)\n@@ -249,7 +246,7 @@ void __asan_unregister_globals(__asan_global *globals, uptr n) {\n // initializer can only touch global variables in the same TU.\n void __asan_before_dynamic_init(const char *module_name) {\n   if (!flags()->check_initialization_order ||\n-      !flags()->poison_heap)\n+      !CanPoisonMemory())\n     return;\n   bool strict_init_order = flags()->strict_init_order;\n   CHECK(dynamic_init_globals);\n@@ -275,7 +272,7 @@ void __asan_before_dynamic_init(const char *module_name) {\n // TU are poisoned.  It simply unpoisons all dynamically initialized globals.\n void __asan_after_dynamic_init() {\n   if (!flags()->check_initialization_order ||\n-      !flags()->poison_heap)\n+      !CanPoisonMemory())\n     return;\n   CHECK(asan_inited);\n   BlockingMutexLock lock(&mu_for_globals);"}, {"sha": "2cda18849dd1e63fc1a825563682811eb1d7ca5c", "filename": "libsanitizer/asan/asan_init_version.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_init_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_init_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_init_version.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -23,8 +23,10 @@ extern \"C\" {\n   //         contains the function PC as the 3-rd field (see\n   //         DescribeAddressIfStack).\n   // v3=>v4: added '__asan_global_source_location' to __asan_global.\n-  #define __asan_init __asan_init_v4\n-  #define __asan_init_name \"__asan_init_v4\"\n+  // v4=>v5: changed the semantics and format of __asan_stack_malloc_ and\n+  //         __asan_stack_free_ functions.\n+  // v5=>v6: changed the name of the version check symbol\n+  #define __asan_version_mismatch_check __asan_version_mismatch_check_v6\n }\n \n #endif  // ASAN_INIT_VERSION_H"}, {"sha": "1b0592e027f71bbbec839eb66c38e3dfe7c04f8e", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 235, "deletions": 232, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,17 +9,28 @@\n //\n // Intercept various libc functions.\n //===----------------------------------------------------------------------===//\n-#include \"asan_interceptors.h\"\n \n+#include \"asan_interceptors.h\"\n #include \"asan_allocator.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n #include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n+#include \"asan_suppressions.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n+#if SANITIZER_POSIX\n+#include \"sanitizer_common/sanitizer_posix.h\"\n+#endif\n+\n+#if defined(__i386) && SANITIZER_LINUX\n+#define ASAN_PTHREAD_CREATE_VERSION \"GLIBC_2.1\"\n+#elif defined(__mips__) && SANITIZER_LINUX\n+#define ASAN_PTHREAD_CREATE_VERSION \"GLIBC_2.2\"\n+#endif\n+\n namespace __asan {\n \n // Return true if we can quickly decide that the region is unpoisoned.\n@@ -32,12 +43,16 @@ static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n   return false;\n }\n \n+struct AsanInterceptorContext {\n+  const char *interceptor_name;\n+};\n+\n // We implement ACCESS_MEMORY_RANGE, ASAN_READ_RANGE,\n // and ASAN_WRITE_RANGE as macro instead of function so\n // that no extra frames are created, and stack trace contains\n // relevant information only.\n // We check all shadow bytes.\n-#define ACCESS_MEMORY_RANGE(offset, size, isWrite) do {                 \\\n+#define ACCESS_MEMORY_RANGE(ctx, offset, size, isWrite) do {            \\\n     uptr __offset = (uptr)(offset);                                     \\\n     uptr __size = (uptr)(size);                                         \\\n     uptr __bad = 0;                                                     \\\n@@ -47,13 +62,33 @@ static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n     }                                                                   \\\n     if (!QuickCheckForUnpoisonedRegion(__offset, __size) &&             \\\n         (__bad = __asan_region_is_poisoned(__offset, __size))) {        \\\n-      GET_CURRENT_PC_BP_SP;                                             \\\n-      __asan_report_error(pc, bp, sp, __bad, isWrite, __size);          \\\n+      AsanInterceptorContext *_ctx = (AsanInterceptorContext *)ctx;     \\\n+      bool suppressed = false;                                          \\\n+      if (_ctx) {                                                       \\\n+        suppressed = IsInterceptorSuppressed(_ctx->interceptor_name);   \\\n+        if (!suppressed && HaveStackTraceBasedSuppressions()) {         \\\n+          GET_STACK_TRACE_FATAL_HERE;                                   \\\n+          suppressed = IsStackTraceSuppressed(&stack);                  \\\n+        }                                                               \\\n+      }                                                                 \\\n+      if (!suppressed) {                                                \\\n+        GET_CURRENT_PC_BP_SP;                                           \\\n+        __asan_report_error(pc, bp, sp, __bad, isWrite, __size, 0);     \\\n+      }                                                                 \\\n     }                                                                   \\\n   } while (0)\n \n-#define ASAN_READ_RANGE(offset, size) ACCESS_MEMORY_RANGE(offset, size, false)\n-#define ASAN_WRITE_RANGE(offset, size) ACCESS_MEMORY_RANGE(offset, size, true)\n+#define ASAN_READ_RANGE(ctx, offset, size) \\\n+  ACCESS_MEMORY_RANGE(ctx, offset, size, false)\n+#define ASAN_WRITE_RANGE(ctx, offset, size) \\\n+  ACCESS_MEMORY_RANGE(ctx, offset, size, true)\n+\n+#define ASAN_READ_STRING_OF_LEN(ctx, s, len, n)                 \\\n+  ASAN_READ_RANGE((ctx), (s),                                   \\\n+    common_flags()->strict_string_checks ? (len) + 1 : (n))\n+\n+#define ASAN_READ_STRING(ctx, s, n)                             \\\n+  ASAN_READ_STRING_OF_LEN((ctx), (s), REAL(strlen)(s), (n))\n \n // Behavior of functions like \"memcpy\" or \"strcpy\" is undefined\n // if memory intervals overlap. We report error in this case.\n@@ -74,7 +109,7 @@ static inline bool RangesOverlap(const char *offset1, uptr length1,\n \n static inline uptr MaybeRealStrnlen(const char *s, uptr maxlen) {\n #if ASAN_INTERCEPT_STRNLEN\n-  if (REAL(strnlen) != 0) {\n+  if (REAL(strnlen)) {\n     return REAL(strnlen)(s, maxlen);\n   }\n #endif\n@@ -92,39 +127,36 @@ int OnExit() {\n   return 0;\n }\n \n-}  // namespace __asan\n+} // namespace __asan\n \n // ---------------------- Wrappers ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n DECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr)\n DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n \n-#if !SANITIZER_MAC\n-#define ASAN_INTERCEPT_FUNC(name)                                        \\\n-  do {                                                                   \\\n-    if ((!INTERCEPT_FUNCTION(name) || !REAL(name)))                      \\\n-      VReport(1, \"AddressSanitizer: failed to intercept '\" #name \"'\\n\"); \\\n-  } while (0)\n-#else\n-// OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION.\n-#define ASAN_INTERCEPT_FUNC(name)\n-#endif  // SANITIZER_MAC\n+#define ASAN_INTERCEPTOR_ENTER(ctx, func)                                      \\\n+  AsanInterceptorContext _ctx = {#func};                                       \\\n+  ctx = (void *)&_ctx;                                                         \\\n+  (void) ctx;                                                                  \\\n \n #define COMMON_INTERCEPT_FUNCTION(name) ASAN_INTERCEPT_FUNC(name)\n #define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size) \\\n-  ASAN_WRITE_RANGE(ptr, size)\n-#define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size) ASAN_READ_RANGE(ptr, size)\n+  ASAN_WRITE_RANGE(ctx, ptr, size)\n+#define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size) \\\n+  ASAN_READ_RANGE(ctx, ptr, size)\n #define COMMON_INTERCEPTOR_ENTER(ctx, func, ...)                               \\\n+  ASAN_INTERCEPTOR_ENTER(ctx, func);                                           \\\n   do {                                                                         \\\n     if (asan_init_is_running)                                                  \\\n       return REAL(func)(__VA_ARGS__);                                          \\\n-    ctx = 0;                                                                   \\\n-    (void) ctx;                                                                \\\n     if (SANITIZER_MAC && UNLIKELY(!asan_inited))                               \\\n       return REAL(func)(__VA_ARGS__);                                          \\\n     ENSURE_ASAN_INITED();                                                      \\\n   } while (false)\n+#define COMMON_INTERCEPTOR_DIR_ACQUIRE(ctx, path) \\\n+  do {                                            \\\n+  } while (false)\n #define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n   do {                                         \\\n   } while (false)\n@@ -143,14 +175,30 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   do {                                                         \\\n   } while (false)\n #define COMMON_INTERCEPTOR_BLOCK_REAL(name) REAL(name)\n+// Strict init-order checking is dlopen-hostile:\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=178\n+#define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag)                           \\\n+  if (flags()->strict_init_order) {                                            \\\n+    StopInitOrderChecking();                                                   \\\n+  }\n #define COMMON_INTERCEPTOR_ON_EXIT(ctx) OnExit()\n-#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res) CovUpdateMapping()\n-#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() CovUpdateMapping()\n+#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle) \\\n+  CoverageUpdateMapping()\n+#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() CoverageUpdateMapping()\n #define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (!asan_inited)\n+#define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end)                           \\\n+  if (AsanThread *t = GetCurrentThread()) {                                    \\\n+    *begin = t->tls_begin();                                                   \\\n+    *end = t->tls_end();                                                       \\\n+  } else {                                                                     \\\n+    *begin = *end = 0;                                                         \\\n+  }\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n \n-#define COMMON_SYSCALL_PRE_READ_RANGE(p, s) ASAN_READ_RANGE(p, s)\n-#define COMMON_SYSCALL_PRE_WRITE_RANGE(p, s) ASAN_WRITE_RANGE(p, s)\n+// Syscall interceptors don't have contexts, we don't support suppressions\n+// for them.\n+#define COMMON_SYSCALL_PRE_READ_RANGE(p, s) ASAN_READ_RANGE(nullptr, p, s)\n+#define COMMON_SYSCALL_PRE_WRITE_RANGE(p, s) ASAN_WRITE_RANGE(nullptr, p, s)\n #define COMMON_SYSCALL_POST_READ_RANGE(p, s) \\\n   do {                                       \\\n     (void)(p);                               \\\n@@ -163,67 +211,92 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   } while (false)\n #include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n \n+struct ThreadStartParam {\n+  atomic_uintptr_t t;\n+  atomic_uintptr_t is_registered;\n+};\n+\n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n-  AsanThread *t = (AsanThread*)arg;\n+  ThreadStartParam *param = reinterpret_cast<ThreadStartParam *>(arg);\n+  AsanThread *t = nullptr;\n+  while ((t = reinterpret_cast<AsanThread *>(\n+              atomic_load(&param->t, memory_order_acquire))) == nullptr)\n+    internal_sched_yield();\n   SetCurrentThread(t);\n-  return t->ThreadStart(GetTid());\n+  return t->ThreadStart(GetTid(), &param->is_registered);\n }\n \n #if ASAN_INTERCEPT_PTHREAD_CREATE\n INTERCEPTOR(int, pthread_create, void *thread,\n     void *attr, void *(*start_routine)(void*), void *arg) {\n   EnsureMainThreadIDIsCorrect();\n-  // Strict init-order checking in thread-hostile.\n+  // Strict init-order checking is thread-hostile.\n   if (flags()->strict_init_order)\n     StopInitOrderChecking();\n   GET_STACK_TRACE_THREAD;\n   int detached = 0;\n-  if (attr != 0)\n+  if (attr)\n     REAL(pthread_attr_getdetachstate)(attr, &detached);\n+  ThreadStartParam param;\n+  atomic_store(&param.t, 0, memory_order_relaxed);\n+  atomic_store(&param.is_registered, 0, memory_order_relaxed);\n+  int result = REAL(pthread_create)(thread, attr, asan_thread_start, &param);\n+  if (result == 0) {\n+    u32 current_tid = GetCurrentTidOrInvalid();\n+    AsanThread *t =\n+        AsanThread::Create(start_routine, arg, current_tid, &stack, detached);\n+    atomic_store(&param.t, reinterpret_cast<uptr>(t), memory_order_release);\n+    // Wait until the AsanThread object is initialized and the ThreadRegistry\n+    // entry is in \"started\" state. One reason for this is that after this\n+    // interceptor exits, the child thread's stack may be the only thing holding\n+    // the |arg| pointer. This may cause LSan to report a leak if leak checking\n+    // happens at a point when the interceptor has already exited, but the stack\n+    // range for the child thread is not yet known.\n+    while (atomic_load(&param.is_registered, memory_order_acquire) == 0)\n+      internal_sched_yield();\n+  }\n+  return result;\n+}\n \n-  u32 current_tid = GetCurrentTidOrInvalid();\n-  AsanThread *t = AsanThread::Create(start_routine, arg);\n-  CreateThreadContextArgs args = { t, &stack };\n-  asanThreadRegistry().CreateThread(*(uptr*)t, detached, current_tid, &args);\n-  return REAL(pthread_create)(thread, attr, asan_thread_start, t);\n+INTERCEPTOR(int, pthread_join, void *t, void **arg) {\n+  return real_pthread_join(t, arg);\n }\n+\n+DEFINE_REAL_PTHREAD_FUNCTIONS\n #endif  // ASAN_INTERCEPT_PTHREAD_CREATE\n \n #if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n \n #if SANITIZER_ANDROID\n INTERCEPTOR(void*, bsd_signal, int signum, void *handler) {\n-  if (!AsanInterceptsSignal(signum) ||\n-      common_flags()->allow_user_segv_handler) {\n+  if (!IsDeadlySignal(signum) || common_flags()->allow_user_segv_handler) {\n     return REAL(bsd_signal)(signum, handler);\n   }\n   return 0;\n }\n-#else\n+#endif\n+\n INTERCEPTOR(void*, signal, int signum, void *handler) {\n-  if (!AsanInterceptsSignal(signum) ||\n-      common_flags()->allow_user_segv_handler) {\n+  if (!IsDeadlySignal(signum) || common_flags()->allow_user_segv_handler) {\n     return REAL(signal)(signum, handler);\n   }\n-  return 0;\n+  return nullptr;\n }\n-#endif\n \n INTERCEPTOR(int, sigaction, int signum, const struct sigaction *act,\n                             struct sigaction *oldact) {\n-  if (!AsanInterceptsSignal(signum) ||\n-      common_flags()->allow_user_segv_handler) {\n+  if (!IsDeadlySignal(signum) || common_flags()->allow_user_segv_handler) {\n     return REAL(sigaction)(signum, act, oldact);\n   }\n   return 0;\n }\n \n namespace __sanitizer {\n int real_sigaction(int signum, const void *act, void *oldact) {\n-  return REAL(sigaction)(signum,\n-                         (struct sigaction *)act, (struct sigaction *)oldact);\n+  return REAL(sigaction)(signum, (const struct sigaction *)act,\n+                         (struct sigaction *)oldact);\n }\n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n #elif SANITIZER_POSIX\n // We need to have defined REAL(sigaction) on posix systems.\n@@ -239,7 +312,7 @@ static void ClearShadowMemoryForContextStack(uptr stack, uptr ssize) {\n   ssize += stack - bottom;\n   ssize = RoundUpTo(ssize, PageSize);\n   static const uptr kMaxSaneContextStackSize = 1 << 22;  // 4 Mb\n-  if (ssize && ssize <= kMaxSaneContextStackSize) {\n+  if (AddrIsInMem(bottom) && ssize && ssize <= kMaxSaneContextStackSize) {\n     PoisonShadow(bottom, ssize, 0);\n   }\n }\n@@ -294,129 +367,93 @@ INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n }\n #endif\n \n-#if SANITIZER_WINDOWS\n-INTERCEPTOR_WINAPI(void, RaiseException, void *a, void *b, void *c, void *d) {\n-  CHECK(REAL(RaiseException));\n-  __asan_handle_no_return();\n-  REAL(RaiseException)(a, b, c, d);\n-}\n-\n-INTERCEPTOR(int, _except_handler3, void *a, void *b, void *c, void *d) {\n-  CHECK(REAL(_except_handler3));\n-  __asan_handle_no_return();\n-  return REAL(_except_handler3)(a, b, c, d);\n-}\n-\n-#if ASAN_DYNAMIC\n-// This handler is named differently in -MT and -MD CRTs.\n-#define _except_handler4 _except_handler4_common\n-#endif\n-INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n-  CHECK(REAL(_except_handler4));\n-  __asan_handle_no_return();\n-  return REAL(_except_handler4)(a, b, c, d);\n-}\n-#endif\n-\n-static inline int CharCmp(unsigned char c1, unsigned char c2) {\n-  return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n-}\n+// memcpy is called during __asan_init() from the internals of printf(...).\n+// We do not treat memcpy with to==from as a bug.\n+// See http://llvm.org/bugs/show_bug.cgi?id=11763.\n+#define ASAN_MEMCPY_IMPL(ctx, to, from, size) do {                             \\\n+    if (UNLIKELY(!asan_inited)) return internal_memcpy(to, from, size);        \\\n+    if (asan_init_is_running) {                                                \\\n+      return REAL(memcpy)(to, from, size);                                     \\\n+    }                                                                          \\\n+    ENSURE_ASAN_INITED();                                                      \\\n+    if (flags()->replace_intrin) {                                             \\\n+      if (to != from) {                                                        \\\n+        CHECK_RANGES_OVERLAP(\"memcpy\", to, size, from, size);                  \\\n+      }                                                                        \\\n+      ASAN_READ_RANGE(ctx, from, size);                                        \\\n+      ASAN_WRITE_RANGE(ctx, to, size);                                         \\\n+    }                                                                          \\\n+    return REAL(memcpy)(to, from, size);                                       \\\n+  } while (0)\n \n-INTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n-  if (UNLIKELY(!asan_inited)) return internal_memcmp(a1, a2, size);\n-  ENSURE_ASAN_INITED();\n-  if (flags()->replace_intrin) {\n-    if (flags()->strict_memcmp) {\n-      // Check the entire regions even if the first bytes of the buffers are\n-      // different.\n-      ASAN_READ_RANGE(a1, size);\n-      ASAN_READ_RANGE(a2, size);\n-      // Fallthrough to REAL(memcmp) below.\n-    } else {\n-      unsigned char c1 = 0, c2 = 0;\n-      const unsigned char *s1 = (const unsigned char*)a1;\n-      const unsigned char *s2 = (const unsigned char*)a2;\n-      uptr i;\n-      for (i = 0; i < size; i++) {\n-        c1 = s1[i];\n-        c2 = s2[i];\n-        if (c1 != c2) break;\n-      }\n-      ASAN_READ_RANGE(s1, Min(i + 1, size));\n-      ASAN_READ_RANGE(s2, Min(i + 1, size));\n-      return CharCmp(c1, c2);\n-    }\n-  }\n-  return REAL(memcmp(a1, a2, size));\n-}\n \n void *__asan_memcpy(void *to, const void *from, uptr size) {\n-  if (UNLIKELY(!asan_inited)) return internal_memcpy(to, from, size);\n-  // memcpy is called during __asan_init() from the internals\n-  // of printf(...).\n-  if (asan_init_is_running) {\n-    return REAL(memcpy)(to, from, size);\n-  }\n-  ENSURE_ASAN_INITED();\n-  if (flags()->replace_intrin) {\n-    if (to != from) {\n-      // We do not treat memcpy with to==from as a bug.\n-      // See http://llvm.org/bugs/show_bug.cgi?id=11763.\n-      CHECK_RANGES_OVERLAP(\"memcpy\", to, size, from, size);\n-    }\n-    ASAN_READ_RANGE(from, size);\n-    ASAN_WRITE_RANGE(to, size);\n-  }\n-  return REAL(memcpy)(to, from, size);\n+  ASAN_MEMCPY_IMPL(nullptr, to, from, size);\n }\n \n+// memset is called inside Printf.\n+#define ASAN_MEMSET_IMPL(ctx, block, c, size) do {                             \\\n+    if (UNLIKELY(!asan_inited)) return internal_memset(block, c, size);        \\\n+    if (asan_init_is_running) {                                                \\\n+      return REAL(memset)(block, c, size);                                     \\\n+    }                                                                          \\\n+    ENSURE_ASAN_INITED();                                                      \\\n+    if (flags()->replace_intrin) {                                             \\\n+      ASAN_WRITE_RANGE(ctx, block, size);                                      \\\n+    }                                                                          \\\n+    return REAL(memset)(block, c, size);                                       \\\n+  } while (0)\n+\n void *__asan_memset(void *block, int c, uptr size) {\n-  if (UNLIKELY(!asan_inited)) return internal_memset(block, c, size);\n-  // memset is called inside Printf.\n-  if (asan_init_is_running) {\n-    return REAL(memset)(block, c, size);\n-  }\n-  ENSURE_ASAN_INITED();\n-  if (flags()->replace_intrin) {\n-    ASAN_WRITE_RANGE(block, size);\n-  }\n-  return REAL(memset)(block, c, size);\n+  ASAN_MEMSET_IMPL(nullptr, block, c, size);\n }\n \n+#define ASAN_MEMMOVE_IMPL(ctx, to, from, size) do {                            \\\n+    if (UNLIKELY(!asan_inited))                                                \\\n+      return internal_memmove(to, from, size);                                 \\\n+    ENSURE_ASAN_INITED();                                                      \\\n+    if (flags()->replace_intrin) {                                             \\\n+      ASAN_READ_RANGE(ctx, from, size);                                        \\\n+      ASAN_WRITE_RANGE(ctx, to, size);                                         \\\n+    }                                                                          \\\n+    return internal_memmove(to, from, size);                                   \\\n+  } while (0)\n+\n void *__asan_memmove(void *to, const void *from, uptr size) {\n-  if (UNLIKELY(!asan_inited))\n-    return internal_memmove(to, from, size);\n-  ENSURE_ASAN_INITED();\n-  if (flags()->replace_intrin) {\n-    ASAN_READ_RANGE(from, size);\n-    ASAN_WRITE_RANGE(to, size);\n-  }\n-  return internal_memmove(to, from, size);\n+  ASAN_MEMMOVE_IMPL(nullptr, to, from, size);\n }\n \n INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n-  return __asan_memmove(to, from, size);\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, memmove);\n+  ASAN_MEMMOVE_IMPL(ctx, to, from, size);\n }\n \n INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, memcpy);\n #if !SANITIZER_MAC\n-  return __asan_memcpy(to, from, size);\n+  ASAN_MEMCPY_IMPL(ctx, to, from, size);\n #else\n   // At least on 10.7 and 10.8 both memcpy() and memmove() are being replaced\n   // with WRAP(memcpy). As a result, false positives are reported for memmove()\n   // calls. If we just disable error reporting with\n   // ASAN_OPTIONS=replace_intrin=0, memmove() is still replaced with\n   // internal_memcpy(), which may lead to crashes, see\n   // http://llvm.org/bugs/show_bug.cgi?id=16362.\n-  return __asan_memmove(to, from, size);\n+  ASAN_MEMMOVE_IMPL(ctx, to, from, size);\n #endif  // !SANITIZER_MAC\n }\n \n INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n-  return __asan_memset(block, c, size);\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, memset);\n+  ASAN_MEMSET_IMPL(ctx, block, c, size);\n }\n \n INTERCEPTOR(char*, strchr, const char *str, int c) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strchr);\n   if (UNLIKELY(!asan_inited)) return internal_strchr(str, c);\n   // strchr is called inside create_purgeable_zone() when MallocGuardEdges=1 is\n   // used.\n@@ -426,8 +463,9 @@ INTERCEPTOR(char*, strchr, const char *str, int c) {\n   ENSURE_ASAN_INITED();\n   char *result = REAL(strchr)(str, c);\n   if (flags()->replace_str) {\n-    uptr bytes_read = (result ? result - str : REAL(strlen)(str)) + 1;\n-    ASAN_READ_RANGE(str, bytes_read);\n+    uptr len = REAL(strlen)(str);\n+    uptr bytes_read = (result ? result - str : len) + 1;\n+    ASAN_READ_STRING_OF_LEN(ctx, str, len, bytes_read);\n   }\n   return result;\n }\n@@ -449,13 +487,15 @@ DEFINE_REAL(char*, index, const char *string, int c)\n // For both strcat() and strncat() we need to check the validity of |to|\n // argument irrespective of the |from| length.\n INTERCEPTOR(char*, strcat, char *to, const char *from) {  // NOLINT\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strcat);  // NOLINT\n   ENSURE_ASAN_INITED();\n   if (flags()->replace_str) {\n     uptr from_length = REAL(strlen)(from);\n-    ASAN_READ_RANGE(from, from_length + 1);\n+    ASAN_READ_RANGE(ctx, from, from_length + 1);\n     uptr to_length = REAL(strlen)(to);\n-    ASAN_READ_RANGE(to, to_length);\n-    ASAN_WRITE_RANGE(to + to_length, from_length + 1);\n+    ASAN_READ_STRING_OF_LEN(ctx, to, to_length, to_length);\n+    ASAN_WRITE_RANGE(ctx, to + to_length, from_length + 1);\n     // If the copying actually happens, the |from| string should not overlap\n     // with the resulting string starting at |to|, which has a length of\n     // to_length + from_length + 1.\n@@ -468,14 +508,16 @@ INTERCEPTOR(char*, strcat, char *to, const char *from) {  // NOLINT\n }\n \n INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strncat);\n   ENSURE_ASAN_INITED();\n   if (flags()->replace_str) {\n     uptr from_length = MaybeRealStrnlen(from, size);\n     uptr copy_length = Min(size, from_length + 1);\n-    ASAN_READ_RANGE(from, copy_length);\n+    ASAN_READ_RANGE(ctx, from, copy_length);\n     uptr to_length = REAL(strlen)(to);\n-    ASAN_READ_RANGE(to, to_length);\n-    ASAN_WRITE_RANGE(to + to_length, from_length + 1);\n+    ASAN_READ_STRING_OF_LEN(ctx, to, to_length, to_length);\n+    ASAN_WRITE_RANGE(ctx, to + to_length, from_length + 1);\n     if (from_length > 0) {\n       CHECK_RANGES_OVERLAP(\"strncat\", to, to_length + copy_length + 1,\n                            from, copy_length);\n@@ -485,6 +527,8 @@ INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n }\n \n INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strcpy);  // NOLINT\n #if SANITIZER_MAC\n   if (UNLIKELY(!asan_inited)) return REAL(strcpy)(to, from);  // NOLINT\n #endif\n@@ -497,19 +541,21 @@ INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n   if (flags()->replace_str) {\n     uptr from_size = REAL(strlen)(from) + 1;\n     CHECK_RANGES_OVERLAP(\"strcpy\", to, from_size, from, from_size);\n-    ASAN_READ_RANGE(from, from_size);\n-    ASAN_WRITE_RANGE(to, from_size);\n+    ASAN_READ_RANGE(ctx, from, from_size);\n+    ASAN_WRITE_RANGE(ctx, to, from_size);\n   }\n   return REAL(strcpy)(to, from);  // NOLINT\n }\n \n #if ASAN_INTERCEPT_STRDUP\n INTERCEPTOR(char*, strdup, const char *s) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strdup);\n   if (UNLIKELY(!asan_inited)) return internal_strdup(s);\n   ENSURE_ASAN_INITED();\n   uptr length = REAL(strlen)(s);\n   if (flags()->replace_str) {\n-    ASAN_READ_RANGE(s, length + 1);\n+    ASAN_READ_RANGE(ctx, s, length + 1);\n   }\n   GET_STACK_TRACE_MALLOC;\n   void *new_mem = asan_malloc(length + 1, &stack);\n@@ -519,6 +565,8 @@ INTERCEPTOR(char*, strdup, const char *s) {\n #endif\n \n INTERCEPTOR(SIZE_T, strlen, const char *s) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strlen);\n   if (UNLIKELY(!asan_inited)) return internal_strlen(s);\n   // strlen is called from malloc_default_purgeable_zone()\n   // in __asan::ReplaceSystemAlloc() on Mac.\n@@ -528,78 +576,65 @@ INTERCEPTOR(SIZE_T, strlen, const char *s) {\n   ENSURE_ASAN_INITED();\n   SIZE_T length = REAL(strlen)(s);\n   if (flags()->replace_str) {\n-    ASAN_READ_RANGE(s, length + 1);\n+    ASAN_READ_RANGE(ctx, s, length + 1);\n   }\n   return length;\n }\n \n INTERCEPTOR(SIZE_T, wcslen, const wchar_t *s) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, wcslen);\n   SIZE_T length = REAL(wcslen)(s);\n   if (!asan_init_is_running) {\n     ENSURE_ASAN_INITED();\n-    ASAN_READ_RANGE(s, (length + 1) * sizeof(wchar_t));\n+    ASAN_READ_RANGE(ctx, s, (length + 1) * sizeof(wchar_t));\n   }\n   return length;\n }\n \n INTERCEPTOR(char*, strncpy, char *to, const char *from, uptr size) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strncpy);\n   ENSURE_ASAN_INITED();\n   if (flags()->replace_str) {\n     uptr from_size = Min(size, MaybeRealStrnlen(from, size) + 1);\n     CHECK_RANGES_OVERLAP(\"strncpy\", to, from_size, from, from_size);\n-    ASAN_READ_RANGE(from, from_size);\n-    ASAN_WRITE_RANGE(to, size);\n+    ASAN_READ_RANGE(ctx, from, from_size);\n+    ASAN_WRITE_RANGE(ctx, to, size);\n   }\n   return REAL(strncpy)(to, from, size);\n }\n \n #if ASAN_INTERCEPT_STRNLEN\n INTERCEPTOR(uptr, strnlen, const char *s, uptr maxlen) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strnlen);\n   ENSURE_ASAN_INITED();\n   uptr length = REAL(strnlen)(s, maxlen);\n   if (flags()->replace_str) {\n-    ASAN_READ_RANGE(s, Min(length + 1, maxlen));\n+    ASAN_READ_RANGE(ctx, s, Min(length + 1, maxlen));\n   }\n   return length;\n }\n #endif  // ASAN_INTERCEPT_STRNLEN\n \n-static inline bool IsValidStrtolBase(int base) {\n-  return (base == 0) || (2 <= base && base <= 36);\n-}\n-\n-static inline void FixRealStrtolEndptr(const char *nptr, char **endptr) {\n-  CHECK(endptr);\n-  if (nptr == *endptr) {\n-    // No digits were found at strtol call, we need to find out the last\n-    // symbol accessed by strtoll on our own.\n-    // We get this symbol by skipping leading blanks and optional +/- sign.\n-    while (IsSpace(*nptr)) nptr++;\n-    if (*nptr == '+' || *nptr == '-') nptr++;\n-    *endptr = (char*)nptr;\n-  }\n-  CHECK(*endptr >= nptr);\n-}\n-\n INTERCEPTOR(long, strtol, const char *nptr,  // NOLINT\n             char **endptr, int base) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strtol);\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n     return REAL(strtol)(nptr, endptr, base);\n   }\n   char *real_endptr;\n   long result = REAL(strtol)(nptr, &real_endptr, base);  // NOLINT\n-  if (endptr != 0) {\n-    *endptr = real_endptr;\n-  }\n-  if (IsValidStrtolBase(base)) {\n-    FixRealStrtolEndptr(nptr, &real_endptr);\n-    ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n-  }\n+  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n   return result;\n }\n \n INTERCEPTOR(int, atoi, const char *nptr) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, atoi);\n #if SANITIZER_MAC\n   if (UNLIKELY(!asan_inited)) return REAL(atoi)(nptr);\n #endif\n@@ -614,11 +649,13 @@ INTERCEPTOR(int, atoi, const char *nptr) {\n   // different from int). So, we just imitate this behavior.\n   int result = REAL(strtol)(nptr, &real_endptr, 10);\n   FixRealStrtolEndptr(nptr, &real_endptr);\n-  ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  ASAN_READ_STRING(ctx, nptr, (real_endptr - nptr) + 1);\n   return result;\n }\n \n INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, atol);\n #if SANITIZER_MAC\n   if (UNLIKELY(!asan_inited)) return REAL(atol)(nptr);\n #endif\n@@ -629,41 +666,36 @@ INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n   char *real_endptr;\n   long result = REAL(strtol)(nptr, &real_endptr, 10);  // NOLINT\n   FixRealStrtolEndptr(nptr, &real_endptr);\n-  ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  ASAN_READ_STRING(ctx, nptr, (real_endptr - nptr) + 1);\n   return result;\n }\n \n #if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n INTERCEPTOR(long long, strtoll, const char *nptr,  // NOLINT\n             char **endptr, int base) {\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, strtoll);\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n     return REAL(strtoll)(nptr, endptr, base);\n   }\n   char *real_endptr;\n   long long result = REAL(strtoll)(nptr, &real_endptr, base);  // NOLINT\n-  if (endptr != 0) {\n-    *endptr = real_endptr;\n-  }\n-  // If base has unsupported value, strtoll can exit with EINVAL\n-  // without reading any characters. So do additional checks only\n-  // if base is valid.\n-  if (IsValidStrtolBase(base)) {\n-    FixRealStrtolEndptr(nptr, &real_endptr);\n-    ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n-  }\n+  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n   return result;\n }\n \n INTERCEPTOR(long long, atoll, const char *nptr) {  // NOLINT\n+  void *ctx;\n+  ASAN_INTERCEPTOR_ENTER(ctx, atoll);\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n     return REAL(atoll)(nptr);\n   }\n   char *real_endptr;\n   long long result = REAL(strtoll)(nptr, &real_endptr, 10);  // NOLINT\n   FixRealStrtolEndptr(nptr, &real_endptr);\n-  ASAN_READ_RANGE(nptr, (real_endptr - nptr) + 1);\n+  ASAN_READ_STRING(ctx, nptr, (real_endptr - nptr) + 1);\n   return result;\n }\n #endif  // ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n@@ -681,7 +713,7 @@ INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n #endif\n   ENSURE_ASAN_INITED();\n   int res = REAL(__cxa_atexit)(func, arg, dso_handle);\n-  REAL(__cxa_atexit)(AtCxaAtexit, 0, 0);\n+  REAL(__cxa_atexit)(AtCxaAtexit, nullptr, nullptr);\n   return res;\n }\n #endif  // ASAN_INTERCEPT___CXA_ATEXIT\n@@ -696,35 +728,6 @@ INTERCEPTOR(int, fork, void) {\n }\n #endif  // ASAN_INTERCEPT_FORK\n \n-#if SANITIZER_WINDOWS\n-INTERCEPTOR_WINAPI(DWORD, CreateThread,\n-                   void* security, uptr stack_size,\n-                   DWORD (__stdcall *start_routine)(void*), void* arg,\n-                   DWORD thr_flags, void* tid) {\n-  // Strict init-order checking in thread-hostile.\n-  if (flags()->strict_init_order)\n-    StopInitOrderChecking();\n-  GET_STACK_TRACE_THREAD;\n-  u32 current_tid = GetCurrentTidOrInvalid();\n-  AsanThread *t = AsanThread::Create(start_routine, arg);\n-  CreateThreadContextArgs args = { t, &stack };\n-  bool detached = false;  // FIXME: how can we determine it on Windows?\n-  asanThreadRegistry().CreateThread(*(uptr*)t, detached, current_tid, &args);\n-  return REAL(CreateThread)(security, stack_size,\n-                            asan_thread_start, t, thr_flags, tid);\n-}\n-\n-namespace __asan {\n-void InitializeWindowsInterceptors() {\n-  ASAN_INTERCEPT_FUNC(CreateThread);\n-  ASAN_INTERCEPT_FUNC(RaiseException);\n-  ASAN_INTERCEPT_FUNC(_except_handler3);\n-  ASAN_INTERCEPT_FUNC(_except_handler4);\n-}\n-\n-}  // namespace __asan\n-#endif\n-\n // ---------------------- InitializeAsanInterceptors ---------------- {{{1\n namespace __asan {\n void InitializeAsanInterceptors() {\n@@ -734,7 +737,6 @@ void InitializeAsanInterceptors() {\n   InitializeCommonInterceptors();\n \n   // Intercept mem* functions.\n-  ASAN_INTERCEPT_FUNC(memcmp);\n   ASAN_INTERCEPT_FUNC(memmove);\n   ASAN_INTERCEPT_FUNC(memset);\n   if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n@@ -773,9 +775,8 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(sigaction);\n #if SANITIZER_ANDROID\n   ASAN_INTERCEPT_FUNC(bsd_signal);\n-#else\n-  ASAN_INTERCEPT_FUNC(signal);\n #endif\n+  ASAN_INTERCEPT_FUNC(signal);\n #endif\n #if ASAN_INTERCEPT_SWAPCONTEXT\n   ASAN_INTERCEPT_FUNC(swapcontext);\n@@ -794,8 +795,13 @@ void InitializeAsanInterceptors() {\n \n   // Intercept threading-related functions\n #if ASAN_INTERCEPT_PTHREAD_CREATE\n+#if defined(ASAN_PTHREAD_CREATE_VERSION)\n+  ASAN_INTERCEPT_FUNC_VER(pthread_create, ASAN_PTHREAD_CREATE_VERSION);\n+#else\n   ASAN_INTERCEPT_FUNC(pthread_create);\n #endif\n+  ASAN_INTERCEPT_FUNC(pthread_join);\n+#endif\n \n   // Intercept atexit function.\n #if ASAN_INTERCEPT___CXA_ATEXIT\n@@ -806,12 +812,9 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(fork);\n #endif\n \n-  // Some Windows-specific interceptors.\n-#if SANITIZER_WINDOWS\n-  InitializeWindowsInterceptors();\n-#endif\n+  InitializePlatformInterceptors();\n \n   VReport(1, \"AddressSanitizer: libc interceptors initialized\\n\");\n }\n \n-}  // namespace __asan\n+} // namespace __asan"}, {"sha": "46c74176ed3800ce1e4787a03bc44d55fe190db6", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -13,7 +13,7 @@\n #define ASAN_INTERCEPTORS_H\n \n #include \"asan_internal.h\"\n-#include \"sanitizer_common/sanitizer_interception.h\"\n+#include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n // Use macro to describe if specific function should be\n@@ -90,9 +90,27 @@ struct sigaction;\n DECLARE_REAL(int, sigaction, int signum, const struct sigaction *act,\n                              struct sigaction *oldact)\n \n+#if !SANITIZER_MAC\n+#define ASAN_INTERCEPT_FUNC(name)                                        \\\n+  do {                                                                   \\\n+    if ((!INTERCEPT_FUNCTION(name) || !REAL(name)))                      \\\n+      VReport(1, \"AddressSanitizer: failed to intercept '\" #name \"'\\n\"); \\\n+  } while (0)\n+#define ASAN_INTERCEPT_FUNC_VER(name, ver)                                     \\\n+  do {                                                                         \\\n+    if ((!INTERCEPT_FUNCTION_VER(name, ver) || !REAL(name)))                   \\\n+      VReport(                                                                 \\\n+          1, \"AddressSanitizer: failed to intercept '\" #name \"@@\" #ver \"'\\n\"); \\\n+  } while (0)\n+#else\n+// OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION.\n+#define ASAN_INTERCEPT_FUNC(name)\n+#endif  // SANITIZER_MAC\n+\n namespace __asan {\n \n void InitializeAsanInterceptors();\n+void InitializePlatformInterceptors();\n \n #define ENSURE_ASAN_INITED() do { \\\n   CHECK(!asan_init_is_running); \\"}, {"sha": "b512bf8bd7abcf4b7a0e87137b115fe642ba8bb7", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -7,8 +7,11 @@\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// This header can be included by the instrumented program to fetch\n-// data (mostly allocator statistics) from ASan runtime library.\n+// This header declares the AddressSanitizer runtime interface functions.\n+// The runtime library has to define these functions so the instrumented program\n+// could call them.\n+//\n+// See also include/sanitizer/asan_interface.h\n //===----------------------------------------------------------------------===//\n #ifndef ASAN_INTERFACE_INTERNAL_H\n #define ASAN_INTERFACE_INTERNAL_H\n@@ -22,10 +25,14 @@ using __sanitizer::uptr;\n extern \"C\" {\n   // This function should be called at the very beginning of the process,\n   // before any instrumented code is executed and before any call to malloc.\n-  // Please note that __asan_init is a macro that is replaced with\n-  // __asan_init_vXXX at compile-time.\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_init();\n \n+  // This function exists purely to get a linker/loader error when using\n+  // incompatible versions of instrumentation and runtime library. Please note\n+  // that __asan_version_mismatch_check is a macro that is replaced with\n+  // __asan_version_mismatch_check_vXXX at compile-time.\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_version_mismatch_check();\n+\n   // This structure is used to describe the source location of a place where\n   // global was defined.\n   struct __asan_global_source_location {\n@@ -123,10 +130,8 @@ extern \"C\" {\n \n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_report_error(uptr pc, uptr bp, uptr sp,\n-                           uptr addr, int is_write, uptr access_size);\n+                           uptr addr, int is_write, uptr access_size, u32 exp);\n \n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  int __asan_set_error_exit_code(int exit_code);\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_set_death_callback(void (*callback)(void));\n   SANITIZER_INTERFACE_ATTRIBUTE\n@@ -160,6 +165,21 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_loadN(uptr p, uptr size);\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_storeN(uptr p, uptr size);\n \n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load1(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load2(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load4(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load8(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load16(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_store1(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_store2(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_store4(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_store8(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_store16(uptr p, u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_loadN(uptr p, uptr size,\n+                                                      u32 exp);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_storeN(uptr p, uptr size,\n+                                                       u32 exp);\n+\n   SANITIZER_INTERFACE_ATTRIBUTE\n       void* __asan_memcpy(void *dst, const void *src, uptr size);\n   SANITIZER_INTERFACE_ATTRIBUTE\n@@ -175,6 +195,10 @@ extern \"C\" {\n   void __asan_poison_intra_object_redzone(uptr p, uptr size);\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_unpoison_intra_object_redzone(uptr p, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_alloca_poison(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_allocas_unpoison(uptr top, uptr bottom);\n }  // extern \"C\"\n \n #endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "e31f2648b1ab9f13e610288c779d9766169b06bf", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -19,8 +19,6 @@\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n-#define ASAN_DEFAULT_FAILURE_EXITCODE 1\n-\n #if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n # error \"The AddressSanitizer run-time should not be\"\n         \" instrumented by AddressSanitizer\"\n@@ -73,13 +71,11 @@ void *AsanDoesNotSupportStaticLinkage();\n void AsanCheckDynamicRTPrereqs();\n void AsanCheckIncompatibleRT();\n \n-void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp);\n-void AsanOnSIGSEGV(int, void *siginfo, void *context);\n+void AsanOnDeadlySignal(int, void *siginfo, void *context);\n \n+void DisableReexec();\n void MaybeReexec();\n-bool AsanInterceptsSignal(int signum);\n void ReadContextStack(void *context, uptr *stack, uptr *ssize);\n-void AsanPlatformThreadInit();\n void StopInitOrderChecking();\n \n // Wrapper for TLS/TSD.\n@@ -90,10 +86,10 @@ void PlatformTSDDtor(void *tsd);\n \n void AppendToErrorMessageBuffer(const char *buffer);\n \n-void ParseExtraActivationFlags();\n-\n void *AsanDlSymNext(const char *sym);\n \n+void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name);\n+\n // Platform-specific options.\n #if SANITIZER_MAC\n bool PlatformHasDifferentMemcpyAndMemmove();\n@@ -134,6 +130,8 @@ const int kAsanGlobalRedzoneMagic = 0xf9;\n const int kAsanInternalHeapMagic = 0xfe;\n const int kAsanArrayCookieMagic = 0xac;\n const int kAsanIntraObjectRedzone = 0xbb;\n+const int kAsanAllocaLeftMagic = 0xca;\n+const int kAsanAllocaRightMagic = 0xcb;\n \n static const uptr kCurrentStackFrameMagic = 0x41B58AB3;\n static const uptr kRetiredStackFrameMagic = 0x45E0360E;"}, {"sha": "4e47d5a049645edeb1f41a28013281cf26a9dc83", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 15, "deletions": 85, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -66,6 +66,12 @@ asan_rt_version_t  __asan_rt_version;\n \n namespace __asan {\n \n+void InitializePlatformInterceptors() {}\n+\n+void DisableReexec() {\n+  // No need to re-exec on Linux.\n+}\n+\n void MaybeReexec() {\n   // No need to re-exec on Linux.\n }\n@@ -105,8 +111,11 @@ static void ReportIncompatibleRT() {\n }\n \n void AsanCheckDynamicRTPrereqs() {\n+  if (!ASAN_DYNAMIC)\n+    return;\n+\n   // Ensure that dynamic RT is the first DSO in the list\n-  const char *first_dso_name = 0;\n+  const char *first_dso_name = nullptr;\n   dl_iterate_phdr(FindFirstDSOCallback, &first_dso_name);\n   if (first_dso_name && !IsDynamicRTName(first_dso_name)) {\n     Report(\"ASan runtime does not come first in initial library list; \"\n@@ -131,7 +140,8 @@ void AsanCheckIncompatibleRT() {\n       // system libraries, causing crashes later in ASan initialization.\n       MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n       char filename[128];\n-      while (proc_maps.Next(0, 0, 0, filename, sizeof(filename), 0)) {\n+      while (proc_maps.Next(nullptr, nullptr, nullptr, filename,\n+                            sizeof(filename), nullptr)) {\n         if (IsDynamicRTName(filename)) {\n           Report(\"Your application is linked against \"\n                  \"incompatible ASan runtimes.\\n\");\n@@ -144,87 +154,7 @@ void AsanCheckIncompatibleRT() {\n     }\n   }\n }\n-#endif  // SANITIZER_ANDROID\n-\n-void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n-#if defined(__arm__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.arm_pc;\n-  *bp = ucontext->uc_mcontext.arm_fp;\n-  *sp = ucontext->uc_mcontext.arm_sp;\n-#elif defined(__aarch64__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.pc;\n-  *bp = ucontext->uc_mcontext.regs[29];\n-  *sp = ucontext->uc_mcontext.sp;\n-#elif defined(__hppa__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.sc_iaoq[0];\n-  /* GCC uses %r3 whenever a frame pointer is needed.  */\n-  *bp = ucontext->uc_mcontext.sc_gr[3];\n-  *sp = ucontext->uc_mcontext.sc_gr[30];\n-#elif defined(__x86_64__)\n-# if SANITIZER_FREEBSD\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.mc_rip;\n-  *bp = ucontext->uc_mcontext.mc_rbp;\n-  *sp = ucontext->uc_mcontext.mc_rsp;\n-# else\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.gregs[REG_RIP];\n-  *bp = ucontext->uc_mcontext.gregs[REG_RBP];\n-  *sp = ucontext->uc_mcontext.gregs[REG_RSP];\n-# endif\n-#elif defined(__i386__)\n-# if SANITIZER_FREEBSD\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.mc_eip;\n-  *bp = ucontext->uc_mcontext.mc_ebp;\n-  *sp = ucontext->uc_mcontext.mc_esp;\n-# else\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.gregs[REG_EIP];\n-  *bp = ucontext->uc_mcontext.gregs[REG_EBP];\n-  *sp = ucontext->uc_mcontext.gregs[REG_ESP];\n-# endif\n-#elif defined(__powerpc__) || defined(__powerpc64__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.regs->nip;\n-  *sp = ucontext->uc_mcontext.regs->gpr[PT_R1];\n-  // The powerpc{,64}-linux ABIs do not specify r31 as the frame\n-  // pointer, but GCC always uses r31 when we need a frame pointer.\n-  *bp = ucontext->uc_mcontext.regs->gpr[PT_R31];\n-#elif defined(__sparc__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  uptr *stk_ptr;\n-# if defined (__arch64__)\n-  *pc = ucontext->uc_mcontext.mc_gregs[MC_PC];\n-  *sp = ucontext->uc_mcontext.mc_gregs[MC_O6];\n-  stk_ptr = (uptr *) (*sp + 2047);\n-  *bp = stk_ptr[15];\n-# else\n-  *pc = ucontext->uc_mcontext.gregs[REG_PC];\n-  *sp = ucontext->uc_mcontext.gregs[REG_O6];\n-  stk_ptr = (uptr *) *sp;\n-  *bp = stk_ptr[15];\n-# endif\n-#elif defined(__mips__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.gregs[31];\n-  *bp = ucontext->uc_mcontext.gregs[30];\n-  *sp = ucontext->uc_mcontext.gregs[29];\n-#else\n-# error \"Unsupported arch\"\n-#endif\n-}\n-\n-bool AsanInterceptsSignal(int signum) {\n-  return signum == SIGSEGV && common_flags()->handle_segv;\n-}\n-\n-void AsanPlatformThreadInit() {\n-  // Nothing here for now.\n-}\n+#endif // SANITIZER_ANDROID\n \n #if !SANITIZER_ANDROID\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n@@ -242,6 +172,6 @@ void *AsanDlSymNext(const char *sym) {\n   return dlsym(RTLD_NEXT, sym);\n }\n \n-}  // namespace __asan\n+} // namespace __asan\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "036d7ff65f12888d86ff99d2bead043e65d78b91", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 119, "deletions": 97, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -22,7 +22,14 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mac.h\"\n \n-#include <crt_externs.h>  // for _NSGetArgv\n+#if !SANITIZER_IOS\n+#include <crt_externs.h>  // for _NSGetArgv and _NSGetEnviron\n+#else\n+extern \"C\" {\n+  extern char ***_NSGetArgv(void);\n+}\n+#endif\n+\n #include <dlfcn.h>  // for dladdr()\n #include <mach-o/dyld.h>\n #include <mach-o/loader.h>\n@@ -38,19 +45,7 @@\n \n namespace __asan {\n \n-void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-# if SANITIZER_WORDSIZE == 64\n-  *pc = ucontext->uc_mcontext->__ss.__rip;\n-  *bp = ucontext->uc_mcontext->__ss.__rbp;\n-  *sp = ucontext->uc_mcontext->__ss.__rsp;\n-# else\n-  *pc = ucontext->uc_mcontext->__ss.__eip;\n-  *bp = ucontext->uc_mcontext->__ss.__ebp;\n-  *sp = ucontext->uc_mcontext->__ss.__esp;\n-# endif  // SANITIZER_WORDSIZE\n-}\n-\n+void InitializePlatformInterceptors() {}\n \n bool PlatformHasDifferentMemcpyAndMemmove() {\n   // On OS X 10.7 memcpy() and memmove() are both resolved\n@@ -72,35 +67,51 @@ LowLevelAllocator allocator_for_env;\n // otherwise the corresponding \"NAME=value\" string is replaced with\n // |name_value|.\n void LeakyResetEnv(const char *name, const char *name_value) {\n-  char ***env_ptr = _NSGetEnviron();\n-  CHECK(env_ptr);\n-  char **environ = *env_ptr;\n-  CHECK(environ);\n+  char **env = GetEnviron();\n   uptr name_len = internal_strlen(name);\n-  while (*environ != 0) {\n-    uptr len = internal_strlen(*environ);\n+  while (*env != 0) {\n+    uptr len = internal_strlen(*env);\n     if (len > name_len) {\n-      const char *p = *environ;\n+      const char *p = *env;\n       if (!internal_memcmp(p, name, name_len) && p[name_len] == '=') {\n         // Match.\n         if (name_value) {\n           // Replace the old value with the new one.\n-          *environ = const_cast<char*>(name_value);\n+          *env = const_cast<char*>(name_value);\n         } else {\n           // Shift the subsequent pointers back.\n-          char **del = environ;\n+          char **del = env;\n           do {\n             del[0] = del[1];\n           } while (*del++);\n         }\n       }\n     }\n-    environ++;\n+    env++;\n   }\n }\n \n+static bool reexec_disabled = false;\n+\n+void DisableReexec() {\n+  reexec_disabled = true;\n+}\n+\n+extern \"C\" double dyldVersionNumber;\n+static const double kMinDyldVersionWithAutoInterposition = 360.0;\n+\n+bool DyldNeedsEnvVariable() {\n+  // If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if\n+  // DYLD_INSERT_LIBRARIES is not set. However, checking OS version via\n+  // GetMacosVersion() doesn't work for the simulator. Let's instead check\n+  // `dyldVersionNumber`, which is exported by dyld, against a known version\n+  // number from the first OS release where this appeared.\n+  return dyldVersionNumber < kMinDyldVersionWithAutoInterposition;\n+}\n+\n void MaybeReexec() {\n-  if (!flags()->allow_reexec) return;\n+  if (reexec_disabled) return;\n+\n   // Make sure the dynamic ASan runtime library is preloaded so that the\n   // wrappers work. If it is not, set DYLD_INSERT_LIBRARIES and re-exec\n   // ourselves.\n@@ -111,8 +122,12 @@ void MaybeReexec() {\n   uptr old_env_len = dyld_insert_libraries ?\n       internal_strlen(dyld_insert_libraries) : 0;\n   uptr fname_len = internal_strlen(info.dli_fname);\n-  if (!dyld_insert_libraries ||\n-      !REAL(strstr)(dyld_insert_libraries, info.dli_fname)) {\n+  const char *dylib_name = StripModuleName(info.dli_fname);\n+  uptr dylib_name_len = internal_strlen(dylib_name);\n+\n+  bool lib_is_in_env =\n+      dyld_insert_libraries && REAL(strstr)(dyld_insert_libraries, dylib_name);\n+  if (DyldNeedsEnvVariable() && !lib_is_in_env) {\n     // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n     // library.\n     char program_name[1024];\n@@ -138,58 +153,77 @@ void MaybeReexec() {\n     VReport(1, \"exec()-ing the program with\\n\");\n     VReport(1, \"%s=%s\\n\", kDyldInsertLibraries, new_env);\n     VReport(1, \"to enable ASan wrappers.\\n\");\n-    VReport(1, \"Set ASAN_OPTIONS=allow_reexec=0 to disable this.\\n\");\n     execv(program_name, *_NSGetArgv());\n-  } else {\n-    // DYLD_INSERT_LIBRARIES is set and contains the runtime library.\n-    if (old_env_len == fname_len) {\n-      // It's just the runtime library name - fine to unset the variable.\n-      LeakyResetEnv(kDyldInsertLibraries, NULL);\n+\n+    // We get here only if execv() failed.\n+    Report(\"ERROR: The process is launched without DYLD_INSERT_LIBRARIES, \"\n+           \"which is required for ASan to work. ASan tried to set the \"\n+           \"environment variable and re-execute itself, but execv() failed, \"\n+           \"possibly because of sandbox restrictions. Make sure to launch the \"\n+           \"executable with:\\n%s=%s\\n\", kDyldInsertLibraries, new_env);\n+    CHECK(\"execv failed\" && 0);\n+  }\n+\n+  if (!lib_is_in_env)\n+    return;\n+\n+  // DYLD_INSERT_LIBRARIES is set and contains the runtime library. Let's remove\n+  // the dylib from the environment variable, because interceptors are installed\n+  // and we don't want our children to inherit the variable.\n+\n+  uptr env_name_len = internal_strlen(kDyldInsertLibraries);\n+  // Allocate memory to hold the previous env var name, its value, the '='\n+  // sign and the '\\0' char.\n+  char *new_env = (char*)allocator_for_env.Allocate(\n+      old_env_len + 2 + env_name_len);\n+  CHECK(new_env);\n+  internal_memset(new_env, '\\0', old_env_len + 2 + env_name_len);\n+  internal_strncpy(new_env, kDyldInsertLibraries, env_name_len);\n+  new_env[env_name_len] = '=';\n+  char *new_env_pos = new_env + env_name_len + 1;\n+\n+  // Iterate over colon-separated pieces of |dyld_insert_libraries|.\n+  char *piece_start = dyld_insert_libraries;\n+  char *piece_end = NULL;\n+  char *old_env_end = dyld_insert_libraries + old_env_len;\n+  do {\n+    if (piece_start[0] == ':') piece_start++;\n+    piece_end = REAL(strchr)(piece_start, ':');\n+    if (!piece_end) piece_end = dyld_insert_libraries + old_env_len;\n+    if ((uptr)(piece_start - dyld_insert_libraries) > old_env_len) break;\n+    uptr piece_len = piece_end - piece_start;\n+\n+    char *filename_start =\n+        (char *)internal_memrchr(piece_start, '/', piece_len);\n+    uptr filename_len = piece_len;\n+    if (filename_start) {\n+      filename_start += 1;\n+      filename_len = piece_len - (filename_start - piece_start);\n     } else {\n-      uptr env_name_len = internal_strlen(kDyldInsertLibraries);\n-      // Allocate memory to hold the previous env var name, its value, the '='\n-      // sign and the '\\0' char.\n-      char *new_env = (char*)allocator_for_env.Allocate(\n-          old_env_len + 2 + env_name_len);\n-      CHECK(new_env);\n-      internal_memset(new_env, '\\0', old_env_len + 2 + env_name_len);\n-      internal_strncpy(new_env, kDyldInsertLibraries, env_name_len);\n-      new_env[env_name_len] = '=';\n-      char *new_env_pos = new_env + env_name_len + 1;\n-\n-      // Iterate over colon-separated pieces of |dyld_insert_libraries|.\n-      char *piece_start = dyld_insert_libraries;\n-      char *piece_end = NULL;\n-      char *old_env_end = dyld_insert_libraries + old_env_len;\n-      do {\n-        if (piece_start[0] == ':') piece_start++;\n-        piece_end =  REAL(strchr)(piece_start, ':');\n-        if (!piece_end) piece_end = dyld_insert_libraries + old_env_len;\n-        if ((uptr)(piece_start - dyld_insert_libraries) > old_env_len) break;\n-        uptr piece_len = piece_end - piece_start;\n-\n-        // If the current piece isn't the runtime library name,\n-        // append it to new_env.\n-        if ((piece_len != fname_len) ||\n-            (internal_strncmp(piece_start, info.dli_fname, fname_len) != 0)) {\n-          if (new_env_pos != new_env + env_name_len + 1) {\n-            new_env_pos[0] = ':';\n-            new_env_pos++;\n-          }\n-          internal_strncpy(new_env_pos, piece_start, piece_len);\n-        }\n-        // Move on to the next piece.\n-        new_env_pos += piece_len;\n-        piece_start = piece_end;\n-      } while (piece_start < old_env_end);\n-\n-      // Can't use setenv() here, because it requires the allocator to be\n-      // initialized.\n-      // FIXME: instead of filtering DYLD_INSERT_LIBRARIES here, do it in\n-      // a separate function called after InitializeAllocator().\n-      LeakyResetEnv(kDyldInsertLibraries, new_env);\n+      filename_start = piece_start;\n     }\n-  }\n+\n+    // If the current piece isn't the runtime library name,\n+    // append it to new_env.\n+    if ((dylib_name_len != filename_len) ||\n+        (internal_memcmp(filename_start, dylib_name, dylib_name_len) != 0)) {\n+      if (new_env_pos != new_env + env_name_len + 1) {\n+        new_env_pos[0] = ':';\n+        new_env_pos++;\n+      }\n+      internal_strncpy(new_env_pos, piece_start, piece_len);\n+      new_env_pos += piece_len;\n+    }\n+    // Move on to the next piece.\n+    piece_start = piece_end;\n+  } while (piece_start < old_env_end);\n+\n+  // Can't use setenv() here, because it requires the allocator to be\n+  // initialized.\n+  // FIXME: instead of filtering DYLD_INSERT_LIBRARIES here, do it in\n+  // a separate function called after InitializeAllocator().\n+  if (new_env_pos == new_env + env_name_len + 1) new_env = NULL;\n+  LeakyResetEnv(kDyldInsertLibraries, new_env);\n }\n \n // No-op. Mac does not support static linkage anyway.\n@@ -203,14 +237,6 @@ void AsanCheckDynamicRTPrereqs() {}\n // No-op. Mac does not support static linkage anyway.\n void AsanCheckIncompatibleRT() {}\n \n-bool AsanInterceptsSignal(int signum) {\n-  return (signum == SIGSEGV || signum == SIGBUS) &&\n-         common_flags()->handle_segv;\n-}\n-\n-void AsanPlatformThreadInit() {\n-}\n-\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n@@ -262,9 +288,8 @@ ALWAYS_INLINE\n void asan_register_worker_thread(int parent_tid, StackTrace *stack) {\n   AsanThread *t = GetCurrentThread();\n   if (!t) {\n-    t = AsanThread::Create(0, 0);\n-    CreateThreadContextArgs args = { t, stack };\n-    asanThreadRegistry().CreateThread(*(uptr*)t, true, parent_tid, &args);\n+    t = AsanThread::Create(/* start_routine */ nullptr, /* arg */ nullptr,\n+                           parent_tid, stack, /* detached */ true);\n     t->Init();\n     asanThreadRegistry().StartThread(t->tid(), 0, 0);\n     SetCurrentThread(t);\n@@ -311,7 +336,7 @@ asan_block_context_t *alloc_asan_context(void *ctxt, dispatch_function_t func,\n                                   dispatch_function_t func) {                 \\\n     GET_STACK_TRACE_THREAD;                                                   \\\n     asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack); \\\n-    if (common_flags()->verbosity >= 2) {                                     \\\n+    if (Verbosity() >= 2) {                                     \\\n       Report(#dispatch_x_f \"(): context: %p, pthread_self: %p\\n\",             \\\n              asan_ctxt, pthread_self());                                      \\\n       PRINT_CURRENT_STACK();                                                  \\\n@@ -329,7 +354,7 @@ INTERCEPTOR(void, dispatch_after_f, dispatch_time_t when,\n                                     dispatch_function_t func) {\n   GET_STACK_TRACE_THREAD;\n   asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack);\n-  if (common_flags()->verbosity >= 2) {\n+  if (Verbosity() >= 2) {\n     Report(\"dispatch_after_f: %p\\n\", asan_ctxt);\n     PRINT_CURRENT_STACK();\n   }\n@@ -342,7 +367,7 @@ INTERCEPTOR(void, dispatch_group_async_f, dispatch_group_t group,\n                                           dispatch_function_t func) {\n   GET_STACK_TRACE_THREAD;\n   asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack);\n-  if (common_flags()->verbosity >= 2) {\n+  if (Verbosity() >= 2) {\n     Report(\"dispatch_group_async_f(): context: %p, pthread_self: %p\\n\",\n            asan_ctxt, pthread_self());\n     PRINT_CURRENT_STACK();\n@@ -372,13 +397,6 @@ void dispatch_source_set_event_handler(dispatch_source_t ds, void(^work)(void));\n     work(); \\\n   }\n \n-// Forces the compiler to generate a frame pointer in the function.\n-#define ENABLE_FRAME_POINTER                                       \\\n-  do {                                                             \\\n-    volatile uptr enable_fp;                                       \\\n-    enable_fp = GET_CURRENT_FRAME();                               \\\n-  } while (0)\n-\n INTERCEPTOR(void, dispatch_async,\n             dispatch_queue_t dq, void(^work)(void)) {\n   ENABLE_FRAME_POINTER;\n@@ -402,6 +420,10 @@ INTERCEPTOR(void, dispatch_after,\n \n INTERCEPTOR(void, dispatch_source_set_cancel_handler,\n             dispatch_source_t ds, void(^work)(void)) {\n+  if (!work) {\n+    REAL(dispatch_source_set_cancel_handler)(ds, work);\n+    return;\n+  }\n   ENABLE_FRAME_POINTER;\n   GET_ASAN_BLOCK(work);\n   REAL(dispatch_source_set_cancel_handler)(ds, asan_block);"}, {"sha": "fbe05490ce7c4040cf713c4d7eee7f4436eccb95", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -88,9 +88,9 @@ INTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n   ENSURE_ASAN_INITED();\n   // Allocate |strlen(\"asan-\") + 1 + internal_strlen(name)| bytes.\n   size_t buflen = 6 + (name ? internal_strlen(name) : 0);\n-  InternalScopedBuffer<char> new_name(buflen);\n+  InternalScopedString new_name(buflen);\n   if (name && zone->introspect == asan_zone.introspect) {\n-    internal_snprintf(new_name.data(), buflen, \"asan-%s\", name);\n+    new_name.append(\"asan-%s\", name);\n     name = new_name.data();\n   }\n \n@@ -150,13 +150,17 @@ INTERCEPTOR(int, posix_memalign, void **memptr, size_t alignment, size_t size) {\n \n namespace {\n \n-// TODO(glider): the mz_* functions should be united with the Linux wrappers,\n-// as they are basically copied from there.\n-size_t mz_size(malloc_zone_t* zone, const void* ptr) {\n+// TODO(glider): the __asan_mz_* functions should be united with the Linux\n+// wrappers, as they are basically copied from there.\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+size_t __asan_mz_size(malloc_zone_t* zone, const void* ptr) {\n   return asan_mz_size(ptr);\n }\n \n-void *mz_malloc(malloc_zone_t *zone, size_t size) {\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__asan_mz_malloc(malloc_zone_t *zone, uptr size) {\n   if (UNLIKELY(!asan_inited)) {\n     CHECK(system_malloc_zone);\n     return malloc_zone_malloc(system_malloc_zone, size);\n@@ -165,7 +169,9 @@ void *mz_malloc(malloc_zone_t *zone, size_t size) {\n   return asan_malloc(size, &stack);\n }\n \n-void *mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__asan_mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n   if (UNLIKELY(!asan_inited)) {\n     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n     const size_t kCallocPoolSize = 1024;\n@@ -181,7 +187,9 @@ void *mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n   return asan_calloc(nmemb, size, &stack);\n }\n \n-void *mz_valloc(malloc_zone_t *zone, size_t size) {\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__asan_mz_valloc(malloc_zone_t *zone, size_t size) {\n   if (UNLIKELY(!asan_inited)) {\n     CHECK(system_malloc_zone);\n     return malloc_zone_valloc(system_malloc_zone, size);\n@@ -208,11 +216,15 @@ void ALWAYS_INLINE free_common(void *context, void *ptr) {\n }\n \n // TODO(glider): the allocation callbacks need to be refactored.\n-void mz_free(malloc_zone_t *zone, void *ptr) {\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_mz_free(malloc_zone_t *zone, void *ptr) {\n   free_common(zone, ptr);\n }\n \n-void *mz_realloc(malloc_zone_t *zone, void *ptr, size_t size) {\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__asan_mz_realloc(malloc_zone_t *zone, void *ptr, size_t size) {\n   if (!ptr) {\n     GET_STACK_TRACE_MALLOC;\n     return asan_malloc(size, &stack);\n@@ -231,15 +243,16 @@ void *mz_realloc(malloc_zone_t *zone, void *ptr, size_t size) {\n   }\n }\n \n-void mz_destroy(malloc_zone_t* zone) {\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_mz_destroy(malloc_zone_t* zone) {\n   // A no-op -- we will not be destroyed!\n-  Report(\"mz_destroy() called -- ignoring\\n\");\n+  Report(\"__asan_mz_destroy() called -- ignoring\\n\");\n }\n \n-  // from AvailabilityMacros.h\n-#if defined(MAC_OS_X_VERSION_10_6) && \\\n-    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n-void *mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__asan_mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n   if (UNLIKELY(!asan_inited)) {\n     CHECK(system_malloc_zone);\n     return malloc_zone_memalign(system_malloc_zone, align, size);\n@@ -250,12 +263,12 @@ void *mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n \n // This function is currently unused, and we build with -Werror.\n #if 0\n-void mz_free_definite_size(malloc_zone_t* zone, void *ptr, size_t size) {\n+void __asan_mz_free_definite_size(\n+    malloc_zone_t* zone, void *ptr, size_t size) {\n   // TODO(glider): check that |size| is valid.\n   UNIMPLEMENTED();\n }\n #endif\n-#endif\n \n kern_return_t mi_enumerator(task_t task, void *,\n                             unsigned type_mask, vm_address_t zone_address,\n@@ -297,13 +310,10 @@ void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {\n   internal_memcpy(stats, &malloc_stats, sizeof(malloc_statistics_t));\n }\n \n-#if defined(MAC_OS_X_VERSION_10_6) && \\\n-    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n boolean_t mi_zone_locked(malloc_zone_t *zone) {\n   // UNIMPLEMENTED();\n   return false;\n }\n-#endif\n \n }  // unnamed namespace\n \n@@ -322,32 +332,25 @@ void ReplaceSystemMalloc() {\n   asan_introspection.force_lock = &mi_force_lock;\n   asan_introspection.force_unlock = &mi_force_unlock;\n   asan_introspection.statistics = &mi_statistics;\n+  asan_introspection.zone_locked = &mi_zone_locked;\n \n   internal_memset(&asan_zone, 0, sizeof(malloc_zone_t));\n \n-  // Start with a version 4 zone which is used for OS X 10.4 and 10.5.\n-  asan_zone.version = 4;\n+  // Use version 6 for OSX >= 10.6.\n+  asan_zone.version = 6;\n   asan_zone.zone_name = \"asan\";\n-  asan_zone.size = &mz_size;\n-  asan_zone.malloc = &mz_malloc;\n-  asan_zone.calloc = &mz_calloc;\n-  asan_zone.valloc = &mz_valloc;\n-  asan_zone.free = &mz_free;\n-  asan_zone.realloc = &mz_realloc;\n-  asan_zone.destroy = &mz_destroy;\n+  asan_zone.size = &__asan_mz_size;\n+  asan_zone.malloc = &__asan_mz_malloc;\n+  asan_zone.calloc = &__asan_mz_calloc;\n+  asan_zone.valloc = &__asan_mz_valloc;\n+  asan_zone.free = &__asan_mz_free;\n+  asan_zone.realloc = &__asan_mz_realloc;\n+  asan_zone.destroy = &__asan_mz_destroy;\n   asan_zone.batch_malloc = 0;\n   asan_zone.batch_free = 0;\n-  asan_zone.introspect = &asan_introspection;\n-\n-  // from AvailabilityMacros.h\n-#if defined(MAC_OS_X_VERSION_10_6) && \\\n-    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n-  // Switch to version 6 on OSX 10.6 to support memalign.\n-  asan_zone.version = 6;\n   asan_zone.free_definite_size = 0;\n-  asan_zone.memalign = &mz_memalign;\n-  asan_introspection.zone_locked = &mi_zone_locked;\n-#endif\n+  asan_zone.memalign = &__asan_mz_memalign;\n+  asan_zone.introspect = &asan_introspection;\n \n   // Register the ASan zone.\n   malloc_zone_register(&asan_zone);"}, {"sha": "f2ab188bf5b14d8fca53807e8d69bc3bd82f71db", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -17,7 +17,7 @@\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n-#include \"sanitizer_common/sanitizer_interception.h\"\n+#include \"interception/interception.h\"\n \n #include <stddef.h>\n "}, {"sha": "b158bd2979db83ab5006fccbed17872483b1373c", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 61, "deletions": 16, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -57,13 +57,34 @@\n // || `[0x20000000, 0x23ffffff]` || LowShadow  ||\n // || `[0x00000000, 0x1fffffff]` || LowMem     ||\n //\n-// Default Linux/MIPS mapping:\n+// Default Linux/MIPS32 mapping:\n // || `[0x2aaa0000, 0xffffffff]` || HighMem    ||\n // || `[0x0fff4000, 0x2aa9ffff]` || HighShadow ||\n // || `[0x0bff4000, 0x0fff3fff]` || ShadowGap  ||\n // || `[0x0aaa0000, 0x0bff3fff]` || LowShadow  ||\n // || `[0x00000000, 0x0aa9ffff]` || LowMem     ||\n //\n+// Default Linux/MIPS64 mapping:\n+// || `[0x4000000000, 0xffffffffff]` || HighMem    ||\n+// || `[0x2800000000, 0x3fffffffff]` || HighShadow ||\n+// || `[0x2400000000, 0x27ffffffff]` || ShadowGap  ||\n+// || `[0x2000000000, 0x23ffffffff]` || LowShadow  ||\n+// || `[0x0000000000, 0x1fffffffff]` || LowMem     ||\n+//\n+// Default Linux/AArch64 (39-bit VMA) mapping:\n+// || `[0x2000000000, 0x7fffffffff]` || highmem    ||\n+// || `[0x1400000000, 0x1fffffffff]` || highshadow ||\n+// || `[0x1200000000, 0x13ffffffff]` || shadowgap  ||\n+// || `[0x1000000000, 0x11ffffffff]` || lowshadow  ||\n+// || `[0x0000000000, 0x0fffffffff]` || lowmem     ||\n+//\n+// Default Linux/AArch64 (42-bit VMA) mapping:\n+// || `[0x10000000000, 0x3ffffffffff]` || highmem    ||\n+// || `[0x0a000000000, 0x0ffffffffff]` || highshadow ||\n+// || `[0x09000000000, 0x09fffffffff]` || shadowgap  ||\n+// || `[0x08000000000, 0x08fffffffff]` || lowshadow  ||\n+// || `[0x00000000000, 0x07fffffffff]` || lowmem     ||\n+//\n // Shadow mapping on FreeBSD/x86-64 with SHADOW_OFFSET == 0x400000000000:\n // || `[0x500000000000, 0x7fffffffffff]` || HighMem    ||\n // || `[0x4a0000000000, 0x4fffffffffff]` || HighShadow ||\n@@ -77,36 +98,56 @@\n // || `[0x48000000, 0x4bffffff]` || ShadowGap  ||\n // || `[0x40000000, 0x47ffffff]` || LowShadow  ||\n // || `[0x00000000, 0x3fffffff]` || LowMem     ||\n+//\n+// Default Windows/i386 mapping:\n+// (the exact location of HighShadow/HighMem may vary depending\n+//  on WoW64, /LARGEADDRESSAWARE, etc).\n+// || `[0x50000000, 0xffffffff]` || HighMem    ||\n+// || `[0x3a000000, 0x4fffffff]` || HighShadow ||\n+// || `[0x36000000, 0x39ffffff]` || ShadowGap  ||\n+// || `[0x30000000, 0x35ffffff]` || LowShadow  ||\n+// || `[0x00000000, 0x2fffffff]` || LowMem     ||\n \n static const u64 kDefaultShadowScale = 3;\n static const u64 kDefaultShadowOffset32 = 1ULL << 29;  // 0x20000000\n-static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n static const u64 kDefaultShort64bitShadowOffset = 0x7FFF8000;  // < 2G.\n+static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n+static const u64 kIosShadowOffset64 = 0x130000000;\n+static const u64 kIosSimShadowOffset32 = 1ULL << 30;\n+static const u64 kIosSimShadowOffset64 = kDefaultShadowOffset64;\n+#if SANITIZER_AARCH64_VMA == 39\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n+#elif SANITIZER_AARCH64_VMA == 42\n+static const u64 kAArch64_ShadowOffset64 = 1ULL << 39;\n+#endif\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n-static const u64 kMIPS64_ShadowOffset64 = 1ULL << 36;\n+static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n+static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n \n #define SHADOW_SCALE kDefaultShadowScale\n-#if SANITIZER_ANDROID\n-# define SHADOW_OFFSET (0)\n-#else\n-# if SANITIZER_WORDSIZE == 32\n-#  if defined(__mips__)\n+\n+\n+#if SANITIZER_WORDSIZE == 32\n+#  if SANITIZER_ANDROID\n+#    define SHADOW_OFFSET (0)\n+#  elif defined(__mips__)\n #    define SHADOW_OFFSET kMIPS32_ShadowOffset32\n #  elif SANITIZER_FREEBSD\n #    define SHADOW_OFFSET kFreeBSD_ShadowOffset32\n+#  elif SANITIZER_WINDOWS\n+#    define SHADOW_OFFSET kWindowsShadowOffset32\n+#  elif SANITIZER_IOSSIM\n+#    define SHADOW_OFFSET kIosSimShadowOffset32\n+#  elif SANITIZER_IOS\n+#    define SHADOW_OFFSET kIosShadowOffset32\n #  else\n-#    if SANITIZER_IOS\n-#      define SHADOW_OFFSET kIosShadowOffset32\n-#    else\n-#      define SHADOW_OFFSET kDefaultShadowOffset32\n-#    endif\n+#    define SHADOW_OFFSET kDefaultShadowOffset32\n #  endif\n-# else\n+#else\n #  if defined(__aarch64__)\n #    define SHADOW_OFFSET kAArch64_ShadowOffset64\n #  elif defined(__powerpc64__)\n@@ -117,10 +158,13 @@ static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n #   define SHADOW_OFFSET kDefaultShadowOffset64\n #  elif defined(__mips64)\n #   define SHADOW_OFFSET kMIPS64_ShadowOffset64\n+#  elif SANITIZER_IOSSIM\n+#    define SHADOW_OFFSET kIosSimShadowOffset64\n+#  elif SANITIZER_IOS\n+#    define SHADOW_OFFSET kIosShadowOffset64\n #  else\n #   define SHADOW_OFFSET kDefaultShort64bitShadowOffset\n #  endif\n-# endif\n #endif\n \n #define SHADOW_GRANULARITY (1ULL << SHADOW_SCALE)\n@@ -143,7 +187,8 @@ static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n \n // With the zero shadow base we can not actually map pages starting from 0.\n // This constant is somewhat arbitrary.\n-#define kZeroBaseShadowStart (1 << 18)\n+#define kZeroBaseShadowStart 0\n+#define kZeroBaseMaxShadowStart (1 << 18)\n \n #define kShadowGapBeg   (kLowShadowEnd ? kLowShadowEnd + 1 \\\n                                        : kZeroBaseShadowStart)"}, {"sha": "719cdfa2bb91bdf2b9e4edf4ce962aaf647ba2a7", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,7 +14,7 @@\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n \n-#include \"sanitizer_common/sanitizer_interception.h\"\n+#include \"interception/interception.h\"\n \n #include <stddef.h>\n \n@@ -88,11 +88,11 @@ INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n \n #if !SANITIZER_MAC\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr) throw() {\n+void operator delete(void *ptr) NOEXCEPT {\n   OPERATOR_DELETE_BODY(FROM_NEW);\n }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr) throw() {\n+void operator delete[](void *ptr) NOEXCEPT {\n   OPERATOR_DELETE_BODY(FROM_NEW_BR);\n }\n CXX_OPERATOR_ATTRIBUTE\n@@ -104,12 +104,12 @@ void operator delete[](void *ptr, std::nothrow_t const&) {\n   OPERATOR_DELETE_BODY(FROM_NEW_BR);\n }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr, size_t size) throw() {\n+void operator delete(void *ptr, size_t size) NOEXCEPT {\n   GET_STACK_TRACE_FREE;\n   asan_sized_free(ptr, size, &stack, FROM_NEW);\n }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr, size_t size) throw() {\n+void operator delete[](void *ptr, size_t size) NOEXCEPT {\n   GET_STACK_TRACE_FREE;\n   asan_sized_free(ptr, size, &stack, FROM_NEW_BR);\n }"}, {"sha": "78604310fcbce8509675768c1ef19bee72ce33b0", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -13,13 +13,24 @@\n #include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n \n namespace __asan {\n \n+static atomic_uint8_t can_poison_memory;\n+\n+void SetCanPoisonMemory(bool value) {\n+  atomic_store(&can_poison_memory, value, memory_order_release);\n+}\n+\n+bool CanPoisonMemory() {\n+  return atomic_load(&can_poison_memory, memory_order_acquire);\n+}\n+\n void PoisonShadow(uptr addr, uptr size, u8 value) {\n-  if (!flags()->poison_heap) return;\n+  if (!CanPoisonMemory()) return;\n   CHECK(AddrIsAlignedByGranularity(addr));\n   CHECK(AddrIsInMem(addr));\n   CHECK(AddrIsAlignedByGranularity(addr + size));\n@@ -32,7 +43,7 @@ void PoisonShadowPartialRightRedzone(uptr addr,\n                                      uptr size,\n                                      uptr redzone_size,\n                                      u8 value) {\n-  if (!flags()->poison_heap) return;\n+  if (!CanPoisonMemory()) return;\n   CHECK(AddrIsAlignedByGranularity(addr));\n   CHECK(AddrIsInMem(addr));\n   FastPoisonShadowPartialRightRedzone(addr, size, redzone_size, value);\n@@ -61,10 +72,10 @@ void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n \n void AsanPoisonOrUnpoisonIntraObjectRedzone(uptr ptr, uptr size, bool poison) {\n   uptr end = ptr + size;\n-  if (common_flags()->verbosity) {\n+  if (Verbosity()) {\n     Printf(\"__asan_%spoison_intra_object_redzone [%p,%p) %zd\\n\",\n            poison ? \"\" : \"un\", ptr, end, size);\n-    if (common_flags()->verbosity >= 2)\n+    if (Verbosity() >= 2)\n       PRINT_CURRENT_STACK();\n   }\n   CHECK(size);\n@@ -99,7 +110,7 @@ void __asan_poison_memory_region(void const volatile *addr, uptr size) {\n   if (!flags()->allow_user_poisoning || size == 0) return;\n   uptr beg_addr = (uptr)addr;\n   uptr end_addr = beg_addr + size;\n-  VPrintf(1, \"Trying to poison memory region [%p, %p)\\n\", (void *)beg_addr,\n+  VPrintf(3, \"Trying to poison memory region [%p, %p)\\n\", (void *)beg_addr,\n           (void *)end_addr);\n   ShadowSegmentEndpoint beg(beg_addr);\n   ShadowSegmentEndpoint end(end_addr);\n@@ -139,7 +150,7 @@ void __asan_unpoison_memory_region(void const volatile *addr, uptr size) {\n   if (!flags()->allow_user_poisoning || size == 0) return;\n   uptr beg_addr = (uptr)addr;\n   uptr end_addr = beg_addr + size;\n-  VPrintf(1, \"Trying to unpoison memory region [%p, %p)\\n\", (void *)beg_addr,\n+  VPrintf(3, \"Trying to unpoison memory region [%p, %p)\\n\", (void *)beg_addr,\n           (void *)end_addr);\n   ShadowSegmentEndpoint beg(beg_addr);\n   ShadowSegmentEndpoint end(end_addr);\n@@ -205,7 +216,7 @@ uptr __asan_region_is_poisoned(uptr beg, uptr size) {\n         __asan::AddressIsPoisoned(__p + __size - 1))) {       \\\n       GET_CURRENT_PC_BP_SP;                                   \\\n       uptr __bad = __asan_region_is_poisoned(__p, __size);    \\\n-      __asan_report_error(pc, bp, sp, __bad, isWrite, __size);\\\n+      __asan_report_error(pc, bp, sp, __bad, isWrite, __size, 0);\\\n     }                                                         \\\n   } while (false);                                            \\\n "}, {"sha": "30e39e9077cbff3ecfec2bf3830b4cfa6fe775ed", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -17,6 +17,10 @@\n \n namespace __asan {\n \n+// Enable/disable memory poisoning.\n+void SetCanPoisonMemory(bool value);\n+bool CanPoisonMemory();\n+\n // Poisons the shadow memory for \"size\" bytes starting from \"addr\".\n void PoisonShadow(uptr addr, uptr size, u8 value);\n \n@@ -32,7 +36,7 @@ void PoisonShadowPartialRightRedzone(uptr addr,\n // performance-critical code with care.\n ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n                                     u8 value) {\n-  DCHECK(flags()->poison_heap);\n+  DCHECK(CanPoisonMemory());\n   uptr shadow_beg = MEM_TO_SHADOW(aligned_beg);\n   uptr shadow_end = MEM_TO_SHADOW(\n       aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;\n@@ -58,15 +62,14 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n       if (page_end != shadow_end) {\n         REAL(memset)((void *)page_end, 0, shadow_end - page_end);\n       }\n-      void *res = MmapFixedNoReserve(page_beg, page_end - page_beg);\n-      CHECK_EQ(page_beg, res);\n+      ReserveShadowMemoryRange(page_beg, page_end - 1, nullptr);\n     }\n   }\n }\n \n ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n     uptr aligned_addr, uptr size, uptr redzone_size, u8 value) {\n-  DCHECK(flags()->poison_heap);\n+  DCHECK(CanPoisonMemory());\n   bool poison_partial = flags()->poison_partial;\n   u8 *shadow = (u8*)MEM_TO_SHADOW(aligned_addr);\n   for (uptr i = 0; i < redzone_size; i += SHADOW_GRANULARITY, shadow++) {"}, {"sha": "5b532e950bbea473f0beeb229c89d4bba40c8655", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -19,6 +19,7 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_posix.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n #include <pthread.h>\n@@ -30,26 +31,52 @@\n \n namespace __asan {\n \n-void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n+void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n   ScopedDeadlySignal signal_scope(GetCurrentThread());\n-  uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;\n   int code = (int)((siginfo_t*)siginfo)->si_code;\n   // Write the first message using the bullet-proof write.\n-  if (13 != internal_write(2, \"ASAN:SIGSEGV\\n\", 13)) Die();\n-  uptr pc, sp, bp;\n-  GetPcSpBp(context, &pc, &sp, &bp);\n+  if (18 != internal_write(2, \"ASAN:DEADLYSIGNAL\\n\", 18)) Die();\n+  SignalContext sig = SignalContext::Create(siginfo, context);\n \n   // Access at a reasonable offset above SP, or slightly below it (to account\n   // for x86_64 or PowerPC redzone, ARM push of multiple registers, etc) is\n   // probably a stack overflow.\n+  bool IsStackAccess = sig.addr + 512 > sig.sp && sig.addr < sig.sp + 0xFFFF;\n+\n+#if __powerpc__\n+  // Large stack frames can be allocated with e.g.\n+  //   lis r0,-10000\n+  //   stdux r1,r1,r0 # store sp to [sp-10000] and update sp by -10000\n+  // If the store faults then sp will not have been updated, so test above\n+  // will not work, becase the fault address will be more than just \"slightly\"\n+  // below sp.\n+  if (!IsStackAccess && IsAccessibleMemoryRange(sig.pc, 4)) {\n+    u32 inst = *(unsigned *)sig.pc;\n+    u32 ra = (inst >> 16) & 0x1F;\n+    u32 opcd = inst >> 26;\n+    u32 xo = (inst >> 1) & 0x3FF;\n+    // Check for store-with-update to sp. The instructions we accept are:\n+    //   stbu rs,d(ra)          stbux rs,ra,rb\n+    //   sthu rs,d(ra)          sthux rs,ra,rb\n+    //   stwu rs,d(ra)          stwux rs,ra,rb\n+    //   stdu rs,ds(ra)         stdux rs,ra,rb\n+    // where ra is r1 (the stack pointer).\n+    if (ra == 1 &&\n+        (opcd == 39 || opcd == 45 || opcd == 37 || opcd == 62 ||\n+         (opcd == 31 && (xo == 247 || xo == 439 || xo == 183 || xo == 181))))\n+      IsStackAccess = true;\n+  }\n+#endif // __powerpc__\n+\n   // We also check si_code to filter out SEGV caused by something else other\n   // then hitting the guard page or unmapped memory, like, for example,\n   // unaligned memory access.\n-  if (addr + 512 > sp && addr < sp + 0xFFFF &&\n-      (code == si_SEGV_MAPERR || code == si_SEGV_ACCERR))\n-    ReportStackOverflow(pc, sp, bp, context, addr);\n+  if (IsStackAccess && (code == si_SEGV_MAPERR || code == si_SEGV_ACCERR))\n+    ReportStackOverflow(sig);\n+  else if (signo == SIGFPE)\n+    ReportDeadlySignal(\"FPE\", sig);\n   else\n-    ReportSIGSEGV(\"SEGV\", pc, sp, bp, context, addr);\n+    ReportDeadlySignal(\"SEGV\", sig);\n }\n \n // ---------------------- TSD ---------------- {{{1"}, {"sha": "6cb115bd3690e088a271649d9b01ee8734f1d2cb", "filename": "libsanitizer/asan/asan_preinit.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_preinit.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -11,9 +11,13 @@\n //===----------------------------------------------------------------------===//\n #include \"asan_internal.h\"\n \n+using namespace __asan;\n+\n #if SANITIZER_CAN_USE_PREINIT_ARRAY\n   // The symbol is called __local_asan_preinit, because it's not intended to be\n   // exported.\n+  // This code linked into the main executable when -fsanitize=address is in\n+  // the link flags. It can only use exported interface functions.\n   __attribute__((section(\".preinit_array\"), used))\n   void (*__local_asan_preinit)(void) = __asan_init;\n #endif"}, {"sha": "cbfc6f548e47227ab2b145cf5ba6d78c222b644d", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 79, "deletions": 32, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,6 +9,7 @@\n //\n // This file contains error reporting code.\n //===----------------------------------------------------------------------===//\n+\n #include \"asan_flags.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n@@ -25,7 +26,7 @@ namespace __asan {\n \n // -------------------- User-specified callbacks ----------------- {{{1\n static void (*error_report_callback)(const char*);\n-static char *error_message_buffer = 0;\n+static char *error_message_buffer = nullptr;\n static uptr error_message_buffer_pos = 0;\n static uptr error_message_buffer_size = 0;\n \n@@ -51,7 +52,7 @@ void AppendToErrorMessageBuffer(const char *buffer) {\n                      buffer, remaining);\n     error_message_buffer[error_message_buffer_size - 1] = '\\0';\n     // FIXME: reallocate the buffer instead of truncating the message.\n-    error_message_buffer_pos += remaining > length ? length : remaining;\n+    error_message_buffer_pos += Min(remaining, length);\n   }\n }\n \n@@ -85,6 +86,8 @@ class Decorator: public __sanitizer::SanitizerCommonDecorator {\n         return Cyan();\n       case kAsanUserPoisonedMemoryMagic:\n       case kAsanContiguousContainerOOBMagic:\n+      case kAsanAllocaLeftMagic:\n+      case kAsanAllocaRightMagic:\n         return Blue();\n       case kAsanStackUseAfterScopeMagic:\n         return Magenta();\n@@ -171,6 +174,8 @@ static void PrintLegend(InternalScopedString *str) {\n   PrintShadowByte(str, \"  Intra object redzone:    \",\n                   kAsanIntraObjectRedzone);\n   PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n+  PrintShadowByte(str, \"  Left alloca redzone:     \", kAsanAllocaLeftMagic);\n+  PrintShadowByte(str, \"  Right alloca redzone:    \", kAsanAllocaRightMagic);\n }\n \n void MaybeDumpInstructionBytes(uptr pc) {\n@@ -275,9 +280,8 @@ static void PrintGlobalLocation(InternalScopedString *str,\n     str->append(\":%d\", g.location->column_no);\n }\n \n-bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n-                                     const __asan_global &g) {\n-  if (!IsAddressNearGlobal(addr, g)) return false;\n+static void DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n+                                            const __asan_global &g) {\n   InternalScopedString str(4096);\n   Decorator d;\n   str.append(\"%s\", d.Location());\n@@ -300,6 +304,26 @@ bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n   str.append(\"%s\", d.EndLocation());\n   PrintGlobalNameIfASCII(&str, g);\n   Printf(\"%s\", str.data());\n+}\n+\n+static bool DescribeAddressIfGlobal(uptr addr, uptr size,\n+                                    const char *bug_type) {\n+  // Assume address is close to at most four globals.\n+  const int kMaxGlobalsInReport = 4;\n+  __asan_global globals[kMaxGlobalsInReport];\n+  u32 reg_sites[kMaxGlobalsInReport];\n+  int globals_num =\n+      GetGlobalsForAddress(addr, globals, reg_sites, ARRAY_SIZE(globals));\n+  if (globals_num == 0)\n+    return false;\n+  for (int i = 0; i < globals_num; i++) {\n+    DescribeAddressRelativeToGlobal(addr, size, globals[i]);\n+    if (0 == internal_strcmp(bug_type, \"initialization-order-fiasco\") &&\n+        reg_sites[i]) {\n+      Printf(\"  registered at:\\n\");\n+      StackDepotGet(reg_sites[i]).Print();\n+    }\n+  }\n   return true;\n }\n \n@@ -348,7 +372,7 @@ static void PrintAccessAndVarIntersection(const StackVarDescr &var, uptr addr,\n                                           uptr next_var_beg) {\n   uptr var_end = var.beg + var.size;\n   uptr addr_end = addr + access_size;\n-  const char *pos_descr = 0;\n+  const char *pos_descr = nullptr;\n   // If the variable [var.beg, var_end) is the nearest variable to the\n   // current memory access, indicate it in the log.\n   if (addr >= var.beg) {\n@@ -519,7 +543,7 @@ void DescribeHeapAddress(uptr addr, uptr access_size) {\n   StackTrace alloc_stack = chunk.GetAllocStack();\n   char tname[128];\n   Decorator d;\n-  AsanThreadContext *free_thread = 0;\n+  AsanThreadContext *free_thread = nullptr;\n   if (chunk.FreeTid() != kInvalidTid) {\n     free_thread = GetThreadContextByTidLocked(chunk.FreeTid());\n     Printf(\"%sfreed by thread T%d%s here:%s\\n\", d.Allocation(),\n@@ -545,12 +569,12 @@ void DescribeHeapAddress(uptr addr, uptr access_size) {\n   DescribeThread(alloc_thread);\n }\n \n-void DescribeAddress(uptr addr, uptr access_size) {\n+static void DescribeAddress(uptr addr, uptr access_size, const char *bug_type) {\n   // Check if this is shadow or shadow gap.\n   if (DescribeAddressIfShadow(addr))\n     return;\n   CHECK(AddrIsInMem(addr));\n-  if (DescribeAddressIfGlobal(addr, access_size))\n+  if (DescribeAddressIfGlobal(addr, access_size, bug_type))\n     return;\n   if (DescribeAddressIfStack(addr, access_size))\n     return;\n@@ -572,6 +596,11 @@ void DescribeThread(AsanThreadContext *context) {\n   InternalScopedString str(1024);\n   str.append(\"Thread T%d%s\", context->tid,\n              ThreadNameWithParenthesis(context->tid, tname, sizeof(tname)));\n+  if (context->parent_tid == kInvalidTid) {\n+    str.append(\" created by unknown thread\\n\");\n+    Printf(\"%s\", str.data());\n+    return;\n+  }\n   str.append(\n       \" created by T%d%s here:\\n\", context->parent_tid,\n       ThreadNameWithParenthesis(context->parent_tid, tname, sizeof(tname)));\n@@ -609,7 +638,7 @@ class ScopedInErrorReport {\n       }\n       // If we're still not dead for some reason, use raw _exit() instead of\n       // Die() to bypass any additional checks.\n-      internal__exit(flags()->exitcode);\n+      internal__exit(common_flags()->exitcode);\n     }\n     if (report) report_data = *report;\n     report_happened = true;\n@@ -641,40 +670,39 @@ class ScopedInErrorReport {\n   }\n };\n \n-void ReportStackOverflow(uptr pc, uptr sp, uptr bp, void *context, uptr addr) {\n+void ReportStackOverflow(const SignalContext &sig) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\n       \"ERROR: AddressSanitizer: stack-overflow on address %p\"\n       \" (pc %p bp %p sp %p T%d)\\n\",\n-      (void *)addr, (void *)pc, (void *)bp, (void *)sp,\n+      (void *)sig.addr, (void *)sig.pc, (void *)sig.bp, (void *)sig.sp,\n       GetCurrentTidOrInvalid());\n   Printf(\"%s\", d.EndWarning());\n-  GET_STACK_TRACE_SIGNAL(pc, bp, context);\n+  GET_STACK_TRACE_SIGNAL(sig);\n   stack.Print();\n   ReportErrorSummary(\"stack-overflow\", &stack);\n }\n \n-void ReportSIGSEGV(const char *description, uptr pc, uptr sp, uptr bp,\n-                   void *context, uptr addr) {\n+void ReportDeadlySignal(const char *description, const SignalContext &sig) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\n       \"ERROR: AddressSanitizer: %s on unknown address %p\"\n       \" (pc %p bp %p sp %p T%d)\\n\",\n-      description, (void *)addr, (void *)pc, (void *)bp, (void *)sp,\n-      GetCurrentTidOrInvalid());\n-  if (pc < GetPageSizeCached()) {\n+      description, (void *)sig.addr, (void *)sig.pc, (void *)sig.bp,\n+      (void *)sig.sp, GetCurrentTidOrInvalid());\n+  if (sig.pc < GetPageSizeCached()) {\n     Report(\"Hint: pc points to the zero page.\\n\");\n   }\n   Printf(\"%s\", d.EndWarning());\n-  GET_STACK_TRACE_SIGNAL(pc, bp, context);\n+  GET_STACK_TRACE_SIGNAL(sig);\n   stack.Print();\n-  MaybeDumpInstructionBytes(pc);\n+  MaybeDumpInstructionBytes(sig.pc);\n   Printf(\"AddressSanitizer can not provide additional info.\\n\");\n-  ReportErrorSummary(\"SEGV\", &stack);\n+  ReportErrorSummary(description, &stack);\n }\n \n void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack) {\n@@ -800,8 +828,8 @@ void ReportStringFunctionMemoryRangesOverlap(const char *function,\n              bug_type, offset1, offset1 + length1, offset2, offset2 + length2);\n   Printf(\"%s\", d.EndWarning());\n   stack->Print();\n-  DescribeAddress((uptr)offset1, length1);\n-  DescribeAddress((uptr)offset2, length2);\n+  DescribeAddress((uptr)offset1, length1, bug_type);\n+  DescribeAddress((uptr)offset2, length2, bug_type);\n   ReportErrorSummary(bug_type, stack);\n }\n \n@@ -814,7 +842,7 @@ void ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n   Report(\"ERROR: AddressSanitizer: %s: (size=%zd)\\n\", bug_type, size);\n   Printf(\"%s\", d.EndWarning());\n   stack->Print();\n-  DescribeAddress(offset, size);\n+  DescribeAddress(offset, size, bug_type);\n   ReportErrorSummary(bug_type, stack);\n }\n \n@@ -829,6 +857,9 @@ void ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n          \"      old_mid : %p\\n\"\n          \"      new_mid : %p\\n\",\n          beg, end, old_mid, new_mid);\n+  uptr granularity = SHADOW_GRANULARITY;\n+  if (!IsAligned(beg, granularity))\n+    Report(\"ERROR: beg is not aligned by %d\\n\", granularity);\n   stack->Print();\n   ReportErrorSummary(\"bad-__sanitizer_annotate_contiguous_container\", stack);\n }\n@@ -866,15 +897,16 @@ void ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n static NOINLINE void\n ReportInvalidPointerPair(uptr pc, uptr bp, uptr sp, uptr a1, uptr a2) {\n   ScopedInErrorReport in_report;\n+  const char *bug_type = \"invalid-pointer-pair\";\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\"ERROR: AddressSanitizer: invalid-pointer-pair: %p %p\\n\", a1, a2);\n   Printf(\"%s\", d.EndWarning());\n   GET_STACK_TRACE_FATAL(pc, bp);\n   stack.Print();\n-  DescribeAddress(a1, 1);\n-  DescribeAddress(a2, 1);\n-  ReportErrorSummary(\"invalid-pointer-pair\", &stack);\n+  DescribeAddress(a1, 1, bug_type);\n+  DescribeAddress(a2, 1, bug_type);\n+  ReportErrorSummary(bug_type, &stack);\n }\n \n static INLINE void CheckForInvalidPointerPair(void *p1, void *p2) {\n@@ -925,13 +957,24 @@ void ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr, const char *zone_name,\n   DescribeHeapAddress(addr, 1);\n }\n \n-}  // namespace __asan\n+} // namespace __asan\n \n // --------------------------- Interface --------------------- {{{1\n using namespace __asan;  // NOLINT\n \n void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n-                         uptr access_size) {\n+                         uptr access_size, u32 exp) {\n+  ENABLE_FRAME_POINTER;\n+\n+  // Optimization experiments.\n+  // The experiments can be used to evaluate potential optimizations that remove\n+  // instrumentation (assess false negatives). Instead of completely removing\n+  // some instrumentation, compiler can emit special calls into runtime\n+  // (e.g. __asan_report_exp_load1 instead of __asan_report_load1) and pass\n+  // mask of experiments (exp).\n+  // The reaction to a non-zero value of exp is to be defined.\n+  (void)exp;\n+\n   // Determine the error type.\n   const char *bug_descr = \"unknown-crash\";\n   if (AddrIsInMem(addr)) {\n@@ -980,6 +1023,10 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n       case kAsanIntraObjectRedzone:\n         bug_descr = \"intra-object-overflow\";\n         break;\n+      case kAsanAllocaLeftMagic:\n+      case kAsanAllocaRightMagic:\n+        bug_descr = \"dynamic-stack-buffer-overflow\";\n+        break;\n     }\n   }\n \n@@ -1006,7 +1053,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n   GET_STACK_TRACE_FATAL(pc, bp);\n   stack.Print();\n \n-  DescribeAddress(addr, access_size);\n+  DescribeAddress(addr, access_size, bug_descr);\n   ReportErrorSummary(bug_descr, &stack);\n   PrintShadowMemoryForAddress(addr);\n }\n@@ -1024,7 +1071,7 @@ void NOINLINE __asan_set_error_report_callback(void (*callback)(const char*)) {\n void __asan_describe_address(uptr addr) {\n   // Thread registry must be locked while we're describing an address.\n   asanThreadRegistry().Lock();\n-  DescribeAddress(addr, 1);\n+  DescribeAddress(addr, 1, \"\");\n   asanThreadRegistry().Unlock();\n }\n \n@@ -1069,7 +1116,7 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_ptr_cmp(void *a, void *b) {\n   CheckForInvalidPointerPair(a, b);\n }\n-}  // extern \"C\"\n+} // extern \"C\"\n \n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n // Provide default implementation of __asan_on_error that does nothing"}, {"sha": "6214979cf4ce6967970e936d3bcc56d37c29098a", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -31,29 +31,25 @@ struct AddressDescription {\n   const char *region_kind;\n };\n \n+// Returns the number of globals close to the provided address and copies\n+// them to \"globals\" array.\n+int GetGlobalsForAddress(uptr addr, __asan_global *globals, u32 *reg_sites,\n+                         int max_globals);\n+bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr);\n // The following functions prints address description depending\n // on the memory type (shadow/heap/stack/global).\n void DescribeHeapAddress(uptr addr, uptr access_size);\n-bool DescribeAddressIfGlobal(uptr addr, uptr access_size);\n-bool DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n-                                     const __asan_global &g);\n-bool IsAddressNearGlobal(uptr addr, const __asan_global &g);\n-bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr);\n bool DescribeAddressIfShadow(uptr addr, AddressDescription *descr = nullptr,\n                              bool print = true);\n bool ParseFrameDescription(const char *frame_descr,\n                            InternalMmapVector<StackVarDescr> *vars);\n bool DescribeAddressIfStack(uptr addr, uptr access_size);\n-// Determines memory type on its own.\n-void DescribeAddress(uptr addr, uptr access_size);\n-\n void DescribeThread(AsanThreadContext *context);\n \n // Different kinds of error reports.\n-void NORETURN\n-    ReportStackOverflow(uptr pc, uptr sp, uptr bp, void *context, uptr addr);\n-void NORETURN ReportSIGSEGV(const char *description, uptr pc, uptr sp, uptr bp,\n-                            void *context, uptr addr);\n+void NORETURN ReportStackOverflow(const SignalContext &sig);\n+void NORETURN ReportDeadlySignal(const char* description,\n+                                 const SignalContext &sig);\n void NORETURN ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n                                           BufferedStackTrace *free_stack);\n void NORETURN ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack);"}, {"sha": "551fea5b0c7818ab0bec451731040cabfa98441b", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 188, "deletions": 365, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,6 +9,7 @@\n //\n // Main file of the ASan run-time library.\n //===----------------------------------------------------------------------===//\n+\n #include \"asan_activation.h\"\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n@@ -19,12 +20,15 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n+#include \"asan_suppressions.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n #include \"lsan/lsan_common.h\"\n+#include \"ubsan/ubsan_init.h\"\n+#include \"ubsan/ubsan_platform.h\"\n \n int __asan_option_detect_stack_use_after_return;  // Global interface symbol.\n uptr *__asan_test_only_reported_buggy_pointer;  // Used only for testing asan.\n@@ -51,13 +55,6 @@ static void AsanDie() {\n       UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n     }\n   }\n-  if (common_flags()->coverage)\n-    __sanitizer_cov_dump();\n-  if (death_callback)\n-    death_callback();\n-  if (flags()->abort_on_error)\n-    Abort();\n-  internal__exit(flags()->exitcode);\n }\n \n static void AsanCheckFailed(const char *file, int line, const char *cond,\n@@ -69,265 +66,9 @@ static void AsanCheckFailed(const char *file, int line, const char *cond,\n   Die();\n }\n \n-// -------------------------- Flags ------------------------- {{{1\n-static const int kDefaultMallocContextSize = 30;\n-\n-Flags asan_flags_dont_use_directly;  // use via flags().\n-\n-static const char *MaybeCallAsanDefaultOptions() {\n-  return (&__asan_default_options) ? __asan_default_options() : \"\";\n-}\n-\n-static const char *MaybeUseAsanDefaultOptionsCompileDefinition() {\n-#ifdef ASAN_DEFAULT_OPTIONS\n-// Stringize the macro value.\n-# define ASAN_STRINGIZE(x) #x\n-# define ASAN_STRINGIZE_OPTIONS(options) ASAN_STRINGIZE(options)\n-  return ASAN_STRINGIZE_OPTIONS(ASAN_DEFAULT_OPTIONS);\n-#else\n-  return \"\";\n-#endif\n-}\n-\n-static void ParseFlagsFromString(Flags *f, const char *str) {\n-  CommonFlags *cf = common_flags();\n-  ParseCommonFlagsFromString(cf, str);\n-  CHECK((uptr)cf->malloc_context_size <= kStackTraceMax);\n-  // Please write meaningful flag descriptions when adding new flags.\n-  ParseFlag(str, &f->quarantine_size, \"quarantine_size\",\n-            \"Size (in bytes) of quarantine used to detect use-after-free \"\n-            \"errors. Lower value may reduce memory usage but increase the \"\n-            \"chance of false negatives.\");\n-  ParseFlag(str, &f->redzone, \"redzone\",\n-            \"Minimal size (in bytes) of redzones around heap objects. \"\n-            \"Requirement: redzone >= 16, is a power of two.\");\n-  ParseFlag(str, &f->max_redzone, \"max_redzone\",\n-            \"Maximal size (in bytes) of redzones around heap objects.\");\n-  CHECK_GE(f->redzone, 16);\n-  CHECK_GE(f->max_redzone, f->redzone);\n-  CHECK_LE(f->max_redzone, 2048);\n-  CHECK(IsPowerOfTwo(f->redzone));\n-  CHECK(IsPowerOfTwo(f->max_redzone));\n-\n-  ParseFlag(str, &f->debug, \"debug\",\n-      \"If set, prints some debugging information and does additional checks.\");\n-  ParseFlag(str, &f->report_globals, \"report_globals\",\n-      \"Controls the way to handle globals (0 - don't detect buffer overflow on \"\n-      \"globals, 1 - detect buffer overflow, 2 - print data about registered \"\n-      \"globals).\");\n-\n-  ParseFlag(str, &f->check_initialization_order,\n-      \"check_initialization_order\",\n-      \"If set, attempts to catch initialization order issues.\");\n-\n-  ParseFlag(str, &f->replace_str, \"replace_str\",\n-      \"If set, uses custom wrappers and replacements for libc string functions \"\n-      \"to find more errors.\");\n-\n-  ParseFlag(str, &f->replace_intrin, \"replace_intrin\",\n-      \"If set, uses custom wrappers for memset/memcpy/memmove intinsics.\");\n-  ParseFlag(str, &f->mac_ignore_invalid_free, \"mac_ignore_invalid_free\",\n-      \"Ignore invalid free() calls to work around some bugs. Used on OS X \"\n-      \"only.\");\n-  ParseFlag(str, &f->detect_stack_use_after_return,\n-      \"detect_stack_use_after_return\",\n-      \"Enables stack-use-after-return checking at run-time.\");\n-  ParseFlag(str, &f->min_uar_stack_size_log, \"min_uar_stack_size_log\",\n-      \"Minimum fake stack size log.\");\n-  ParseFlag(str, &f->max_uar_stack_size_log, \"max_uar_stack_size_log\",\n-      \"Maximum fake stack size log.\");\n-  ParseFlag(str, &f->uar_noreserve, \"uar_noreserve\",\n-      \"Use mmap with 'norserve' flag to allocate fake stack.\");\n-  ParseFlag(str, &f->max_malloc_fill_size, \"max_malloc_fill_size\",\n-      \"ASan allocator flag. max_malloc_fill_size is the maximal amount of \"\n-      \"bytes that will be filled with malloc_fill_byte on malloc.\");\n-  ParseFlag(str, &f->malloc_fill_byte, \"malloc_fill_byte\",\n-      \"Value used to fill the newly allocated memory.\");\n-  ParseFlag(str, &f->exitcode, \"exitcode\",\n-      \"Override the program exit status if the tool found an error.\");\n-  ParseFlag(str, &f->allow_user_poisoning, \"allow_user_poisoning\",\n-      \"If set, user may manually mark memory regions as poisoned or \"\n-      \"unpoisoned.\");\n-  ParseFlag(str, &f->sleep_before_dying, \"sleep_before_dying\",\n-      \"Number of seconds to sleep between printing an error report and \"\n-      \"terminating the program. Useful for debugging purposes (e.g. when one \"\n-      \"needs to attach gdb).\");\n-\n-  ParseFlag(str, &f->check_malloc_usable_size, \"check_malloc_usable_size\",\n-      \"Allows the users to work around the bug in Nvidia drivers prior to \"\n-      \"295.*.\");\n-\n-  ParseFlag(str, &f->unmap_shadow_on_exit, \"unmap_shadow_on_exit\",\n-      \"If set, explicitly unmaps the (huge) shadow at exit.\");\n-  ParseFlag(str, &f->abort_on_error, \"abort_on_error\",\n-      \"If set, the tool calls abort() instead of _exit() after printing the \"\n-      \"error report.\");\n-  ParseFlag(str, &f->print_stats, \"print_stats\",\n-      \"Print various statistics after printing an error message or if \"\n-      \"atexit=1.\");\n-  ParseFlag(str, &f->print_legend, \"print_legend\",\n-      \"Print the legend for the shadow bytes.\");\n-  ParseFlag(str, &f->atexit, \"atexit\",\n-      \"If set, prints ASan exit stats even after program terminates \"\n-      \"successfully.\");\n-\n-  ParseFlag(str, &f->allow_reexec, \"allow_reexec\",\n-      \"Allow the tool to re-exec the program. This may interfere badly with \"\n-      \"the debugger.\");\n-\n-  ParseFlag(str, &f->print_full_thread_history,\n-      \"print_full_thread_history\",\n-      \"If set, prints thread creation stacks for the threads involved in the \"\n-      \"report and their ancestors up to the main thread.\");\n-\n-  ParseFlag(str, &f->poison_heap, \"poison_heap\",\n-      \"Poison (or not) the heap memory on [de]allocation. Zero value is useful \"\n-      \"for benchmarking the allocator or instrumentator.\");\n-\n-  ParseFlag(str, &f->poison_array_cookie, \"poison_array_cookie\",\n-      \"Poison (or not) the array cookie after operator new[].\");\n-\n-  ParseFlag(str, &f->poison_partial, \"poison_partial\",\n-      \"If true, poison partially addressable 8-byte aligned words \"\n-      \"(default=true). This flag affects heap and global buffers, but not \"\n-      \"stack buffers.\");\n-\n-  ParseFlag(str, &f->alloc_dealloc_mismatch, \"alloc_dealloc_mismatch\",\n-      \"Report errors on malloc/delete, new/free, new/delete[], etc.\");\n-\n-  ParseFlag(str, &f->new_delete_type_mismatch, \"new_delete_type_mismatch\",\n-      \"Report errors on mismatch betwen size of new and delete.\");\n-\n-  ParseFlag(str, &f->strict_memcmp, \"strict_memcmp\",\n-      \"If true, assume that memcmp(p1, p2, n) always reads n bytes before \"\n-      \"comparing p1 and p2.\");\n-\n-  ParseFlag(str, &f->strict_init_order, \"strict_init_order\",\n-      \"If true, assume that dynamic initializers can never access globals from \"\n-      \"other modules, even if the latter are already initialized.\");\n-\n-  ParseFlag(str, &f->start_deactivated, \"start_deactivated\",\n-      \"If true, ASan tweaks a bunch of other flags (quarantine, redzone, heap \"\n-      \"poisoning) to reduce memory consumption as much as possible, and \"\n-      \"restores them to original values when the first instrumented module is \"\n-      \"loaded into the process. This is mainly intended to be used on \"\n-      \"Android. \");\n-\n-  ParseFlag(str, &f->detect_invalid_pointer_pairs,\n-      \"detect_invalid_pointer_pairs\",\n-      \"If non-zero, try to detect operations like <, <=, >, >= and - on \"\n-      \"invalid pointer pairs (e.g. when pointers belong to different objects). \"\n-      \"The bigger the value the harder we try.\");\n-\n-  ParseFlag(str, &f->detect_container_overflow,\n-      \"detect_container_overflow\",\n-      \"If true, honor the container overflow  annotations. \"\n-      \"See https://code.google.com/p/address-sanitizer/wiki/ContainerOverflow\");\n-\n-  ParseFlag(str, &f->detect_odr_violation, \"detect_odr_violation\",\n-            \"If >=2, detect violation of One-Definition-Rule (ODR); \"\n-            \"If ==1, detect ODR-violation only if the two variables \"\n-            \"have different sizes\");\n-\n-  ParseFlag(str, &f->dump_instruction_bytes, \"dump_instruction_bytes\",\n-      \"If true, dump 16 bytes starting at the instruction that caused SEGV\");\n-}\n-\n-void InitializeFlags(Flags *f, const char *env) {\n-  CommonFlags *cf = common_flags();\n-  SetCommonFlagsDefaults(cf);\n-  cf->detect_leaks = CAN_SANITIZE_LEAKS;\n-  cf->external_symbolizer_path = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n-  cf->malloc_context_size = kDefaultMallocContextSize;\n-  cf->intercept_tls_get_addr = true;\n-  cf->coverage = false;\n-\n-  internal_memset(f, 0, sizeof(*f));\n-  f->quarantine_size = (ASAN_LOW_MEMORY) ? 1UL << 26 : 1UL << 28;\n-  f->redzone = 16;\n-  f->max_redzone = 2048;\n-  f->debug = false;\n-  f->report_globals = 1;\n-  f->check_initialization_order = false;\n-  f->replace_str = true;\n-  f->replace_intrin = true;\n-  f->mac_ignore_invalid_free = false;\n-  f->detect_stack_use_after_return = false;  // Also needs the compiler flag.\n-  f->min_uar_stack_size_log = 16;  // We can't do smaller anyway.\n-  f->max_uar_stack_size_log = 20;  // 1Mb per size class, i.e. ~11Mb per thread.\n-  f->uar_noreserve = false;\n-  f->max_malloc_fill_size = 0x1000;  // By default, fill only the first 4K.\n-  f->malloc_fill_byte = 0xbe;\n-  f->exitcode = ASAN_DEFAULT_FAILURE_EXITCODE;\n-  f->allow_user_poisoning = true;\n-  f->sleep_before_dying = 0;\n-  f->check_malloc_usable_size = true;\n-  f->unmap_shadow_on_exit = false;\n-  f->abort_on_error = false;\n-  f->print_stats = false;\n-  f->print_legend = true;\n-  f->atexit = false;\n-  f->allow_reexec = true;\n-  f->print_full_thread_history = true;\n-  f->poison_heap = true;\n-  f->poison_array_cookie = true;\n-  f->poison_partial = true;\n-  // Turn off alloc/dealloc mismatch checker on Mac and Windows for now.\n-  // https://code.google.com/p/address-sanitizer/issues/detail?id=131\n-  // https://code.google.com/p/address-sanitizer/issues/detail?id=309\n-  // TODO(glider,timurrrr): Fix known issues and enable this back.\n-  f->alloc_dealloc_mismatch = (SANITIZER_MAC == 0) && (SANITIZER_WINDOWS == 0);\n-  f->new_delete_type_mismatch = true;\n-  f->strict_memcmp = true;\n-  f->strict_init_order = false;\n-  f->start_deactivated = false;\n-  f->detect_invalid_pointer_pairs = 0;\n-  f->detect_container_overflow = true;\n-  f->detect_odr_violation = 2;\n-  f->dump_instruction_bytes = false;\n-\n-  // Override from compile definition.\n-  ParseFlagsFromString(f, MaybeUseAsanDefaultOptionsCompileDefinition());\n-\n-  // Override from user-specified string.\n-  ParseFlagsFromString(f, MaybeCallAsanDefaultOptions());\n-  VReport(1, \"Using the defaults from __asan_default_options: %s\\n\",\n-          MaybeCallAsanDefaultOptions());\n-\n-  // Override from command line.\n-  ParseFlagsFromString(f, env);\n-  if (common_flags()->help) {\n-    PrintFlagDescriptions();\n-  }\n-\n-  if (!CAN_SANITIZE_LEAKS && cf->detect_leaks) {\n-    Report(\"%s: detect_leaks is not supported on this platform.\\n\",\n-           SanitizerToolName);\n-    cf->detect_leaks = false;\n-  }\n-\n-  // Make \"strict_init_order\" imply \"check_initialization_order\".\n-  // TODO(samsonov): Use a single runtime flag for an init-order checker.\n-  if (f->strict_init_order) {\n-    f->check_initialization_order = true;\n-  }\n-}\n-\n-// Parse flags that may change between startup and activation.\n-// On Android they come from a system property.\n-// On other platforms this is no-op.\n-void ParseExtraActivationFlags() {\n-  char buf[100];\n-  GetExtraActivationFlags(buf, sizeof(buf));\n-  ParseFlagsFromString(flags(), buf);\n-  if (buf[0] != '\\0')\n-    VReport(1, \"Extra activation flags: %s\\n\", buf);\n-}\n-\n // -------------------------- Globals --------------------- {{{1\n int asan_inited;\n bool asan_init_is_running;\n-void (*death_callback)(void);\n \n #if !ASAN_FIXED_MAPPING\n uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;\n@@ -341,17 +82,22 @@ void ShowStatsAndAbort() {\n \n // ---------------------- mmap -------------------- {{{1\n // Reserve memory range [beg, end].\n-static void ReserveShadowMemoryRange(uptr beg, uptr end) {\n+// We need to use inclusive range because end+1 may not be representable.\n+void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n   CHECK_EQ((beg % GetPageSizeCached()), 0);\n   CHECK_EQ(((end + 1) % GetPageSizeCached()), 0);\n   uptr size = end - beg + 1;\n   DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n-  void *res = MmapFixedNoReserve(beg, size);\n+  void *res = MmapFixedNoReserve(beg, size, name);\n   if (res != (void*)beg) {\n     Report(\"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n            \"Perhaps you're using ulimit -v\\n\", size);\n     Abort();\n   }\n+  if (common_flags()->no_huge_pages_for_shadow)\n+    NoHugePagesInRegion(beg, size);\n+  if (common_flags()->use_madv_dontdump)\n+    DontDumpShadowMemory(beg, size);\n }\n \n // --------------- LowLevelAllocateCallbac ---------- {{{1\n@@ -362,11 +108,15 @@ static void OnLowLevelAllocate(uptr ptr, uptr size) {\n // -------------------------- Run-time entry ------------------- {{{1\n // exported functions\n #define ASAN_REPORT_ERROR(type, is_write, size)                     \\\n-extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                        \\\n-void __asan_report_ ## type ## size(uptr addr);                \\\n-void __asan_report_ ## type ## size(uptr addr) {               \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\n+void __asan_report_ ## type ## size(uptr addr) {                    \\\n+  GET_CALLER_PC_BP_SP;                                              \\\n+  __asan_report_error(pc, bp, sp, addr, is_write, size, 0);         \\\n+}                                                                   \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\n+void __asan_report_exp_ ## type ## size(uptr addr, u32 exp) {       \\\n   GET_CALLER_PC_BP_SP;                                              \\\n-  __asan_report_error(pc, bp, sp, addr, is_write, size);            \\\n+  __asan_report_error(pc, bp, sp, addr, is_write, size, exp);       \\\n }\n \n ASAN_REPORT_ERROR(load, false, 1)\n@@ -382,18 +132,20 @@ ASAN_REPORT_ERROR(store, true, 16)\n \n #define ASAN_REPORT_ERROR_N(type, is_write)                    \\\n extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                        \\\n-void __asan_report_ ## type ## _n(uptr addr, uptr size);       \\\n void __asan_report_ ## type ## _n(uptr addr, uptr size) {      \\\n   GET_CALLER_PC_BP_SP;                                         \\\n-  __asan_report_error(pc, bp, sp, addr, is_write, size);       \\\n+  __asan_report_error(pc, bp, sp, addr, is_write, size, 0);    \\\n+}                                                              \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                        \\\n+void __asan_report_exp_ ## type ## _n(uptr addr, uptr size, u32 exp) {      \\\n+  GET_CALLER_PC_BP_SP;                                                      \\\n+  __asan_report_error(pc, bp, sp, addr, is_write, size, exp);               \\\n }\n \n ASAN_REPORT_ERROR_N(load, false)\n ASAN_REPORT_ERROR_N(store, true)\n \n-#define ASAN_MEMORY_ACCESS_CALLBACK(type, is_write, size)                      \\\n-  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE void __asan_##type##size(uptr addr); \\\n-  void __asan_##type##size(uptr addr) {                                        \\\n+#define ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp_arg)        \\\n     uptr sp = MEM_TO_SHADOW(addr);                                             \\\n     uptr s = size <= SHADOW_GRANULARITY ? *reinterpret_cast<u8 *>(sp)          \\\n                                         : *reinterpret_cast<u16 *>(sp);        \\\n@@ -405,10 +157,19 @@ ASAN_REPORT_ERROR_N(store, true)\n           *__asan_test_only_reported_buggy_pointer = addr;                     \\\n         } else {                                                               \\\n           GET_CALLER_PC_BP_SP;                                                 \\\n-          __asan_report_error(pc, bp, sp, addr, is_write, size);               \\\n+          __asan_report_error(pc, bp, sp, addr, is_write, size, exp_arg);      \\\n         }                                                                      \\\n       }                                                                        \\\n-    }                                                                          \\\n+    }\n+\n+#define ASAN_MEMORY_ACCESS_CALLBACK(type, is_write, size)                      \\\n+  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n+  void __asan_##type##size(uptr addr) {                                        \\\n+    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, 0)                  \\\n+  }                                                                            \\\n+  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n+  void __asan_exp_##type##size(uptr addr, u32 exp) {                           \\\n+    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp)                \\\n   }\n \n ASAN_MEMORY_ACCESS_CALLBACK(load, false, 1)\n@@ -423,18 +184,38 @@ ASAN_MEMORY_ACCESS_CALLBACK(store, true, 8)\n ASAN_MEMORY_ACCESS_CALLBACK(store, true, 16)\n \n extern \"C\"\n-NOINLINE INTERFACE_ATTRIBUTE void __asan_loadN(uptr addr, uptr size) {\n+NOINLINE INTERFACE_ATTRIBUTE\n+void __asan_loadN(uptr addr, uptr size) {\n   if (__asan_region_is_poisoned(addr, size)) {\n     GET_CALLER_PC_BP_SP;\n-    __asan_report_error(pc, bp, sp, addr, false, size);\n+    __asan_report_error(pc, bp, sp, addr, false, size, 0);\n   }\n }\n \n extern \"C\"\n-NOINLINE INTERFACE_ATTRIBUTE void __asan_storeN(uptr addr, uptr size) {\n+NOINLINE INTERFACE_ATTRIBUTE\n+void __asan_exp_loadN(uptr addr, uptr size, u32 exp) {\n   if (__asan_region_is_poisoned(addr, size)) {\n     GET_CALLER_PC_BP_SP;\n-    __asan_report_error(pc, bp, sp, addr, true, size);\n+    __asan_report_error(pc, bp, sp, addr, false, size, exp);\n+  }\n+}\n+\n+extern \"C\"\n+NOINLINE INTERFACE_ATTRIBUTE\n+void __asan_storeN(uptr addr, uptr size) {\n+  if (__asan_region_is_poisoned(addr, size)) {\n+    GET_CALLER_PC_BP_SP;\n+    __asan_report_error(pc, bp, sp, addr, true, size, 0);\n+  }\n+}\n+\n+extern \"C\"\n+NOINLINE INTERFACE_ATTRIBUTE\n+void __asan_exp_storeN(uptr addr, uptr size, u32 exp) {\n+  if (__asan_region_is_poisoned(addr, size)) {\n+    GET_CALLER_PC_BP_SP;\n+    __asan_report_error(pc, bp, sp, addr, true, size, exp);\n   }\n }\n \n@@ -453,26 +234,39 @@ static NOINLINE void force_interface_symbols() {\n     case 3: __asan_report_load4(0); break;\n     case 4: __asan_report_load8(0); break;\n     case 5: __asan_report_load16(0); break;\n-    case 6: __asan_report_store1(0); break;\n-    case 7: __asan_report_store2(0); break;\n-    case 8: __asan_report_store4(0); break;\n-    case 9: __asan_report_store8(0); break;\n-    case 10: __asan_report_store16(0); break;\n-    case 12: __asan_register_globals(0, 0); break;\n-    case 13: __asan_unregister_globals(0, 0); break;\n-    case 14: __asan_set_death_callback(0); break;\n-    case 15: __asan_set_error_report_callback(0); break;\n-    case 16: __asan_handle_no_return(); break;\n-    case 17: __asan_address_is_poisoned(0); break;\n-    case 25: __asan_poison_memory_region(0, 0); break;\n-    case 26: __asan_unpoison_memory_region(0, 0); break;\n-    case 27: __asan_set_error_exit_code(0); break;\n-    case 30: __asan_before_dynamic_init(0); break;\n-    case 31: __asan_after_dynamic_init(); break;\n-    case 32: __asan_poison_stack_memory(0, 0); break;\n-    case 33: __asan_unpoison_stack_memory(0, 0); break;\n-    case 34: __asan_region_is_poisoned(0, 0); break;\n-    case 35: __asan_describe_address(0); break;\n+    case 6: __asan_report_load_n(0, 0); break;\n+    case 7: __asan_report_store1(0); break;\n+    case 8: __asan_report_store2(0); break;\n+    case 9: __asan_report_store4(0); break;\n+    case 10: __asan_report_store8(0); break;\n+    case 11: __asan_report_store16(0); break;\n+    case 12: __asan_report_store_n(0, 0); break;\n+    case 13: __asan_report_exp_load1(0, 0); break;\n+    case 14: __asan_report_exp_load2(0, 0); break;\n+    case 15: __asan_report_exp_load4(0, 0); break;\n+    case 16: __asan_report_exp_load8(0, 0); break;\n+    case 17: __asan_report_exp_load16(0, 0); break;\n+    case 18: __asan_report_exp_load_n(0, 0, 0); break;\n+    case 19: __asan_report_exp_store1(0, 0); break;\n+    case 20: __asan_report_exp_store2(0, 0); break;\n+    case 21: __asan_report_exp_store4(0, 0); break;\n+    case 22: __asan_report_exp_store8(0, 0); break;\n+    case 23: __asan_report_exp_store16(0, 0); break;\n+    case 24: __asan_report_exp_store_n(0, 0, 0); break;\n+    case 25: __asan_register_globals(nullptr, 0); break;\n+    case 26: __asan_unregister_globals(nullptr, 0); break;\n+    case 27: __asan_set_death_callback(nullptr); break;\n+    case 28: __asan_set_error_report_callback(nullptr); break;\n+    case 29: __asan_handle_no_return(); break;\n+    case 30: __asan_address_is_poisoned(nullptr); break;\n+    case 31: __asan_poison_memory_region(nullptr, 0); break;\n+    case 32: __asan_unpoison_memory_region(nullptr, 0); break;\n+    case 34: __asan_before_dynamic_init(nullptr); break;\n+    case 35: __asan_after_dynamic_init(); break;\n+    case 36: __asan_poison_stack_memory(0, 0); break;\n+    case 37: __asan_unpoison_stack_memory(0, 0); break;\n+    case 38: __asan_region_is_poisoned(0, 0); break;\n+    case 39: __asan_describe_address(0); break;\n   }\n }\n \n@@ -496,8 +290,28 @@ static void InitializeHighMemEnd() {\n   CHECK_EQ((kHighMemBeg % GetPageSizeCached()), 0);\n }\n \n-static void ProtectGap(uptr a, uptr size) {\n-  CHECK_EQ(a, (uptr)Mprotect(a, size));\n+static void ProtectGap(uptr addr, uptr size) {\n+  void *res = MmapNoAccess(addr, size, \"shadow gap\");\n+  if (addr == (uptr)res)\n+    return;\n+  // A few pages at the start of the address space can not be protected.\n+  // But we really want to protect as much as possible, to prevent this memory\n+  // being returned as a result of a non-FIXED mmap().\n+  if (addr == kZeroBaseShadowStart) {\n+    uptr step = GetPageSizeCached();\n+    while (size > step && addr < kZeroBaseMaxShadowStart) {\n+      addr += step;\n+      size -= step;\n+      void *res = MmapNoAccess(addr, size, \"shadow gap\");\n+      if (addr == (uptr)res)\n+        return;\n+    }\n+  }\n+\n+  Report(\"ERROR: Failed to protect the shadow gap. \"\n+         \"ASan cannot proceed correctly. ABORTING.\\n\");\n+  DumpProcessMap();\n+  Die();\n }\n \n static void PrintAddressSpaceLayout() {\n@@ -536,13 +350,13 @@ static void PrintAddressSpaceLayout() {\n   Printf(\"\\n\");\n   Printf(\"redzone=%zu\\n\", (uptr)flags()->redzone);\n   Printf(\"max_redzone=%zu\\n\", (uptr)flags()->max_redzone);\n-  Printf(\"quarantine_size=%zuM\\n\", (uptr)flags()->quarantine_size >> 20);\n+  Printf(\"quarantine_size_mb=%zuM\\n\", (uptr)flags()->quarantine_size_mb);\n   Printf(\"malloc_context_size=%zu\\n\",\n          (uptr)common_flags()->malloc_context_size);\n \n-  Printf(\"SHADOW_SCALE: %zx\\n\", (uptr)SHADOW_SCALE);\n-  Printf(\"SHADOW_GRANULARITY: %zx\\n\", (uptr)SHADOW_GRANULARITY);\n-  Printf(\"SHADOW_OFFSET: %zx\\n\", (uptr)SHADOW_OFFSET);\n+  Printf(\"SHADOW_SCALE: %d\\n\", (int)SHADOW_SCALE);\n+  Printf(\"SHADOW_GRANULARITY: %d\\n\", (int)SHADOW_GRANULARITY);\n+  Printf(\"SHADOW_OFFSET: 0x%zx\\n\", (uptr)SHADOW_OFFSET);\n   CHECK(SHADOW_SCALE >= 3 && SHADOW_SCALE <= 7);\n   if (kMidMemBeg)\n     CHECK(kMidShadowBeg > kLowShadowEnd &&\n@@ -556,35 +370,35 @@ static void AsanInitInternal() {\n   CHECK(!asan_init_is_running && \"ASan init calls itself!\");\n   asan_init_is_running = true;\n \n+  CacheBinaryName();\n+\n   // Initialize flags. This must be done early, because most of the\n   // initialization steps look at flags().\n-  const char *options = GetEnv(\"ASAN_OPTIONS\");\n-  InitializeFlags(flags(), options);\n+  InitializeFlags();\n+\n+  CheckVMASize();\n+\n+  AsanCheckIncompatibleRT();\n+  AsanCheckDynamicRTPrereqs();\n+\n+  SetCanPoisonMemory(flags()->poison_heap);\n+  SetMallocContextSize(common_flags()->malloc_context_size);\n \n   InitializeHighMemEnd();\n \n   // Make sure we are not statically linked.\n   AsanDoesNotSupportStaticLinkage();\n \n   // Install tool-specific callbacks in sanitizer_common.\n-  SetDieCallback(AsanDie);\n+  AddDieCallback(AsanDie);\n   SetCheckFailedCallback(AsanCheckFailed);\n   SetPrintfAndReportCallback(AppendToErrorMessageBuffer);\n \n-  if (!flags()->start_deactivated)\n-    ParseExtraActivationFlags();\n-\n   __sanitizer_set_report_path(common_flags()->log_path);\n+\n+  // Enable UAR detection, if required.\n   __asan_option_detect_stack_use_after_return =\n       flags()->detect_stack_use_after_return;\n-  CHECK_LE(flags()->min_uar_stack_size_log, flags()->max_uar_stack_size_log);\n-\n-  if (options) {\n-    VReport(1, \"Parsed ASAN_OPTIONS: %s\\n\", options);\n-  }\n-\n-  if (flags()->start_deactivated)\n-    AsanStartDeactivated();\n \n   // Re-exec ourselves if we need to set additional env or command line args.\n   MaybeReexec();\n@@ -615,17 +429,16 @@ static void AsanInitInternal() {\n   }\n #endif\n \n-  if (common_flags()->verbosity)\n-    PrintAddressSpaceLayout();\n+  if (Verbosity()) PrintAddressSpaceLayout();\n \n   DisableCoreDumperIfNecessary();\n \n   if (full_shadow_is_available) {\n     // mmap the low shadow plus at least one page at the left.\n     if (kLowShadowBeg)\n-      ReserveShadowMemoryRange(shadow_start, kLowShadowEnd);\n+      ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n     // mmap the high shadow.\n-    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd);\n+    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n     // protect the gap.\n     ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n     CHECK_EQ(kShadowGapEnd, kHighShadowBeg - 1);\n@@ -634,26 +447,33 @@ static void AsanInitInternal() {\n       MemoryRangeIsAvailable(kMidMemEnd + 1, kHighShadowEnd)) {\n     CHECK(kLowShadowBeg != kLowShadowEnd);\n     // mmap the low shadow plus at least one page at the left.\n-    ReserveShadowMemoryRange(shadow_start, kLowShadowEnd);\n+    ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n     // mmap the mid shadow.\n-    ReserveShadowMemoryRange(kMidShadowBeg, kMidShadowEnd);\n+    ReserveShadowMemoryRange(kMidShadowBeg, kMidShadowEnd, \"mid shadow\");\n     // mmap the high shadow.\n-    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd);\n+    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n     // protect the gaps.\n     ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n     ProtectGap(kShadowGap2Beg, kShadowGap2End - kShadowGap2Beg + 1);\n     ProtectGap(kShadowGap3Beg, kShadowGap3End - kShadowGap3Beg + 1);\n   } else {\n     Report(\"Shadow memory range interleaves with an existing memory mapping. \"\n            \"ASan cannot proceed correctly. ABORTING.\\n\");\n+    Report(\"ASan shadow was supposed to be located in the [%p-%p] range.\\n\",\n+           shadow_start, kHighShadowEnd);\n     DumpProcessMap();\n     Die();\n   }\n \n   AsanTSDInit(PlatformTSDDtor);\n-  InstallDeadlySignalHandlers(AsanOnSIGSEGV);\n+  InstallDeadlySignalHandlers(AsanOnDeadlySignal);\n+\n+  AllocatorOptions allocator_options;\n+  allocator_options.SetFrom(flags(), common_flags());\n+  InitializeAllocator(allocator_options);\n \n-  InitializeAllocator();\n+  MaybeStartBackgroudThread();\n+  SetSoftRssLimitExceededCallback(AsanSoftRssLimitExceededCallback);\n \n   // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n   // should be set to 1 prior to initializing the threads.\n@@ -663,32 +483,40 @@ static void AsanInitInternal() {\n   if (flags()->atexit)\n     Atexit(asan_atexit);\n \n-  if (common_flags()->coverage) {\n-    __sanitizer_cov_init();\n-    Atexit(__sanitizer_cov_dump);\n-  }\n+  InitializeCoverage(common_flags()->coverage, common_flags()->coverage_dir);\n+\n+  // Now that ASan runtime is (mostly) initialized, deactivate it if\n+  // necessary, so that it can be re-activated when requested.\n+  if (flags()->start_deactivated)\n+    AsanDeactivate();\n \n   // interceptors\n   InitTlsSize();\n \n   // Create main thread.\n-  AsanThread *main_thread = AsanThread::Create(0, 0);\n-  CreateThreadContextArgs create_main_args = { main_thread, 0 };\n-  u32 main_tid = asanThreadRegistry().CreateThread(\n-      0, true, 0, &create_main_args);\n-  CHECK_EQ(0, main_tid);\n+  AsanThread *main_thread = AsanThread::Create(\n+      /* start_routine */ nullptr, /* arg */ nullptr, /* parent_tid */ 0,\n+      /* stack */ nullptr, /* detached */ true);\n+  CHECK_EQ(0, main_thread->tid());\n   SetCurrentThread(main_thread);\n-  main_thread->ThreadStart(internal_getpid());\n+  main_thread->ThreadStart(internal_getpid(),\n+                           /* signal_thread_is_registered */ nullptr);\n   force_interface_symbols();  // no-op.\n   SanitizerInitializeUnwinder();\n \n #if CAN_SANITIZE_LEAKS\n-  __lsan::InitCommonLsan(false);\n+  __lsan::InitCommonLsan();\n   if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit) {\n     Atexit(__lsan::DoLeakCheck);\n   }\n #endif  // CAN_SANITIZE_LEAKS\n \n+#if CAN_SANITIZE_UB\n+  __ubsan::InitAsPlugin();\n+#endif\n+\n+  InitializeSuppressions();\n+\n   VReport(1, \"AddressSanitizer Init done\\n\");\n }\n \n@@ -700,46 +528,38 @@ void AsanInitFromRtl() {\n \n #if ASAN_DYNAMIC\n // Initialize runtime in case it's LD_PRELOAD-ed into unsanitized executable\n-// (and thus normal initializer from .preinit_array haven't run).\n+// (and thus normal initializers from .preinit_array or modules haven't run).\n \n class AsanInitializer {\n public:  // NOLINT\n   AsanInitializer() {\n-    AsanCheckIncompatibleRT();\n-    AsanCheckDynamicRTPrereqs();\n-    if (UNLIKELY(!asan_inited))\n-      __asan_init();\n+    AsanInitFromRtl();\n   }\n };\n \n static AsanInitializer asan_initializer;\n #endif  // ASAN_DYNAMIC\n \n-}  // namespace __asan\n+} // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n-#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-const char* __asan_default_options() { return \"\"; }\n-}  // extern \"C\"\n-#endif\n-\n-int NOINLINE __asan_set_error_exit_code(int exit_code) {\n-  int old = flags()->exitcode;\n-  flags()->exitcode = exit_code;\n-  return old;\n-}\n-\n void NOINLINE __asan_handle_no_return() {\n   int local_stack;\n   AsanThread *curr_thread = GetCurrentThread();\n-  CHECK(curr_thread);\n   uptr PageSize = GetPageSizeCached();\n-  uptr top = curr_thread->stack_top();\n-  uptr bottom = ((uptr)&local_stack - PageSize) & ~(PageSize-1);\n+  uptr top, bottom;\n+  if (curr_thread) {\n+    top = curr_thread->stack_top();\n+    bottom = ((uptr)&local_stack - PageSize) & ~(PageSize - 1);\n+  } else {\n+    // If we haven't seen this thread, try asking the OS for stack bounds.\n+    uptr tls_addr, tls_size, stack_size;\n+    GetThreadStackAndTls(/*main=*/false, &bottom, &stack_size, &tls_addr,\n+                         &tls_size);\n+    top = bottom + stack_size;\n+  }\n   static const uptr kMaxExpectedCleanupSize = 64 << 20;  // 64M\n   if (top - bottom > kMaxExpectedCleanupSize) {\n     static bool reported_warning = false;\n@@ -755,18 +575,21 @@ void NOINLINE __asan_handle_no_return() {\n     return;\n   }\n   PoisonShadow(bottom, top - bottom, 0);\n-  if (curr_thread->has_fake_stack())\n+  if (curr_thread && curr_thread->has_fake_stack())\n     curr_thread->fake_stack()->HandleNoReturn();\n }\n \n void NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n-  death_callback = callback;\n+  SetUserDieCallback(callback);\n }\n \n // Initialize as requested from instrumented application code.\n // We use this call as a trigger to wake up ASan from deactivated state.\n void __asan_init() {\n-  AsanCheckIncompatibleRT();\n   AsanActivate();\n   AsanInitInternal();\n }\n+\n+void __asan_version_mismatch_check() {\n+  // Do nothing.\n+}"}, {"sha": "973c5ce59eff13c0293799e3c6d883d1dd7f4fb0", "filename": "libsanitizer/asan/asan_stack.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -11,6 +11,21 @@\n //===----------------------------------------------------------------------===//\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+\n+namespace __asan {\n+\n+static atomic_uint32_t malloc_context_size;\n+\n+void SetMallocContextSize(u32 size) {\n+  atomic_store(&malloc_context_size, size, memory_order_release);\n+}\n+\n+u32 GetMallocContextSize() {\n+  return atomic_load(&malloc_context_size, memory_order_acquire);\n+}\n+\n+}  // namespace __asan\n \n // ------------------ Interface -------------- {{{1\n "}, {"sha": "30dc592130344459775e80a4c42871037369eea4", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,6 +9,7 @@\n //\n // ASan-private header for asan_stack.cc.\n //===----------------------------------------------------------------------===//\n+\n #ifndef ASAN_STACK_H\n #define ASAN_STACK_H\n \n@@ -19,6 +20,11 @@\n \n namespace __asan {\n \n+static const u32 kDefaultMallocContextSize = 30;\n+\n+void SetMallocContextSize(u32 size);\n+u32 GetMallocContextSize();\n+\n // Get the stack trace with the given pc and bp.\n // The pc will be in the position 0 of the resulting stack trace.\n // The bp may refer to the current frame or to the caller's frame.\n@@ -41,15 +47,15 @@ void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n       uptr stack_bottom = t->stack_bottom();\n       ScopedUnwinding unwind_scope(t);\n       stack->Unwind(max_depth, pc, bp, context, stack_top, stack_bottom, fast);\n-    } else if (t == 0 && !fast) {\n+    } else if (!t && !fast) {\n       /* If GetCurrentThread() has failed, try to do slow unwind anyways. */\n       stack->Unwind(max_depth, pc, bp, context, 0, 0, false);\n     }\n   }\n-#endif  // SANITIZER_WINDOWS\n+#endif // SANITIZER_WINDOWS\n }\n \n-}  // namespace __asan\n+} // namespace __asan\n \n // NOTE: A Rule of thumb is to retrieve stack trace in the interceptors\n // as early as possible (in functions exposed to the user), as we generally\n@@ -76,9 +82,10 @@ void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n   GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, 0,           \\\n                                   common_flags()->fast_unwind_on_fatal)\n \n-#define GET_STACK_TRACE_SIGNAL(pc, bp, context)                                \\\n+#define GET_STACK_TRACE_SIGNAL(sig)                                            \\\n   BufferedStackTrace stack;                                                    \\\n-  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, context,     \\\n+  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax,                      \\\n+                                  (sig).pc, (sig).bp, (sig).context,           \\\n                                   common_flags()->fast_unwind_on_fatal)\n \n #define GET_STACK_TRACE_FATAL_HERE                                \\\n@@ -90,9 +97,8 @@ void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n #define GET_STACK_TRACE_THREAD                                    \\\n   GET_STACK_TRACE(kStackTraceMax, true)\n \n-#define GET_STACK_TRACE_MALLOC                                    \\\n-  GET_STACK_TRACE(common_flags()->malloc_context_size,            \\\n-                  common_flags()->fast_unwind_on_malloc)\n+#define GET_STACK_TRACE_MALLOC                                                 \\\n+  GET_STACK_TRACE(GetMallocContextSize(), common_flags()->fast_unwind_on_malloc)\n \n #define GET_STACK_TRACE_FREE GET_STACK_TRACE_MALLOC\n \n@@ -108,4 +114,4 @@ void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n     stack.Print();                  \\\n   }\n \n-#endif  // ASAN_STACK_H\n+#endif // ASAN_STACK_H"}, {"sha": "64a788a6a5d1a5785524f17a61eaaa3d663494cc", "filename": "libsanitizer/asan/asan_stats.cc", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -49,12 +49,8 @@ void AsanStats::Print() {\n              (mmaped-munmaped)>>20, mmaped>>20, munmaped>>20,\n              mmaps, munmaps);\n \n-  PrintMallocStatsArray(\"  mmaps   by size class: \", mmaped_by_size);\n   PrintMallocStatsArray(\"  mallocs by size class: \", malloced_by_size);\n-  PrintMallocStatsArray(\"  frees   by size class: \", freed_by_size);\n-  PrintMallocStatsArray(\"  rfrees  by size class: \", really_freed_by_size);\n-  Printf(\"Stats: malloc large: %zu small slow: %zu\\n\",\n-             malloc_large, malloc_small_slow);\n+  Printf(\"Stats: malloc large: %zu\\n\", malloc_large);\n }\n \n void AsanStats::MergeFrom(const AsanStats *stats) {\n@@ -159,8 +155,7 @@ uptr __sanitizer_get_free_bytes() {\n   GetAccumulatedStats(&stats);\n   uptr total_free = stats.mmaped\n                   - stats.munmaped\n-                  + stats.really_freed\n-                  + stats.really_freed_redzones;\n+                  + stats.really_freed;\n   uptr total_used = stats.malloced\n                   + stats.malloced_redzones;\n   // Return sane value if total_free < total_used due to racy"}, {"sha": "a48e3f916a951e2ab5b025bed56c1a1de481aa33", "filename": "libsanitizer/asan/asan_stats.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -30,20 +30,14 @@ struct AsanStats {\n   uptr freed;\n   uptr real_frees;\n   uptr really_freed;\n-  uptr really_freed_redzones;\n   uptr reallocs;\n   uptr realloced;\n   uptr mmaps;\n   uptr mmaped;\n   uptr munmaps;\n   uptr munmaped;\n-  uptr mmaped_by_size[kNumberOfSizeClasses];\n-  uptr malloced_by_size[kNumberOfSizeClasses];\n-  uptr freed_by_size[kNumberOfSizeClasses];\n-  uptr really_freed_by_size[kNumberOfSizeClasses];\n-\n   uptr malloc_large;\n-  uptr malloc_small_slow;\n+  uptr malloced_by_size[kNumberOfSizeClasses];\n \n   // Ctor for global AsanStats (accumulated stats for dead threads).\n   explicit AsanStats(LinkerInitialized) { }"}, {"sha": "c94fff0500a289c342450fec7b43f4910fa9bfbb", "filename": "libsanitizer/asan/asan_suppressions.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_suppressions.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,108 @@\n+//===-- asan_suppressions.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Issue suppression and suppression-related functions.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_suppressions.h\"\n+\n+#include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_suppressions.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n+\n+namespace __asan {\n+\n+ALIGNED(64) static char suppression_placeholder[sizeof(SuppressionContext)];\n+static SuppressionContext *suppression_ctx = nullptr;\n+static const char kInterceptorName[] = \"interceptor_name\";\n+static const char kInterceptorViaFunction[] = \"interceptor_via_fun\";\n+static const char kInterceptorViaLibrary[] = \"interceptor_via_lib\";\n+static const char kODRViolation[] = \"odr_violation\";\n+static const char *kSuppressionTypes[] = {\n+    kInterceptorName, kInterceptorViaFunction, kInterceptorViaLibrary,\n+    kODRViolation};\n+\n+extern \"C\" {\n+#if SANITIZER_SUPPORTS_WEAK_HOOKS\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char *__asan_default_suppressions();\n+#else\n+// No week hooks, provide empty implementation.\n+const char *__asan_default_suppressions() { return \"\"; }\n+#endif  // SANITIZER_SUPPORTS_WEAK_HOOKS\n+}  // extern \"C\"\n+\n+void InitializeSuppressions() {\n+  CHECK_EQ(nullptr, suppression_ctx);\n+  suppression_ctx = new (suppression_placeholder)  // NOLINT\n+      SuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n+  suppression_ctx->ParseFromFile(flags()->suppressions);\n+  if (&__asan_default_suppressions)\n+    suppression_ctx->Parse(__asan_default_suppressions());\n+}\n+\n+bool IsInterceptorSuppressed(const char *interceptor_name) {\n+  CHECK(suppression_ctx);\n+  Suppression *s;\n+  // Match \"interceptor_name\" suppressions.\n+  return suppression_ctx->Match(interceptor_name, kInterceptorName, &s);\n+}\n+\n+bool HaveStackTraceBasedSuppressions() {\n+  CHECK(suppression_ctx);\n+  return suppression_ctx->HasSuppressionType(kInterceptorViaFunction) ||\n+         suppression_ctx->HasSuppressionType(kInterceptorViaLibrary);\n+}\n+\n+bool IsODRViolationSuppressed(const char *global_var_name) {\n+  CHECK(suppression_ctx);\n+  Suppression *s;\n+  // Match \"odr_violation\" suppressions.\n+  return suppression_ctx->Match(global_var_name, kODRViolation, &s);\n+}\n+\n+bool IsStackTraceSuppressed(const StackTrace *stack) {\n+  if (!HaveStackTraceBasedSuppressions())\n+    return false;\n+\n+  CHECK(suppression_ctx);\n+  Symbolizer *symbolizer = Symbolizer::GetOrInit();\n+  Suppression *s;\n+  for (uptr i = 0; i < stack->size && stack->trace[i]; i++) {\n+    uptr addr = stack->trace[i];\n+\n+    if (suppression_ctx->HasSuppressionType(kInterceptorViaLibrary)) {\n+      // Match \"interceptor_via_lib\" suppressions.\n+      if (const char *module_name = symbolizer->GetModuleNameForPc(addr))\n+        if (suppression_ctx->Match(module_name, kInterceptorViaLibrary, &s))\n+          return true;\n+    }\n+\n+    if (suppression_ctx->HasSuppressionType(kInterceptorViaFunction)) {\n+      SymbolizedStack *frames = symbolizer->SymbolizePC(addr);\n+      for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n+        const char *function_name = cur->info.function;\n+        if (!function_name) {\n+          continue;\n+        }\n+        // Match \"interceptor_via_fun\" suppressions.\n+        if (suppression_ctx->Match(function_name, kInterceptorViaFunction,\n+                                   &s)) {\n+          frames->ClearAll();\n+          return true;\n+        }\n+      }\n+      frames->ClearAll();\n+    }\n+  }\n+  return false;\n+}\n+\n+} // namespace __asan"}, {"sha": "331d72245480b930faff9e3757615cf834790402", "filename": "libsanitizer/asan/asan_suppressions.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_suppressions.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,28 @@\n+//===-- asan_suppressions.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_suppressions.cc.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_SUPPRESSIONS_H\n+#define ASAN_SUPPRESSIONS_H\n+\n+#include \"asan_internal.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+\n+namespace __asan {\n+\n+void InitializeSuppressions();\n+bool IsInterceptorSuppressed(const char *interceptor_name);\n+bool HaveStackTraceBasedSuppressions();\n+bool IsStackTraceSuppressed(const StackTrace *stack);\n+bool IsODRViolationSuppressed(const char *global_var_name);\n+\n+} // namespace __asan\n+\n+#endif // ASAN_SUPPRESSIONS_H"}, {"sha": "92f968bdee4a76e9011f3334f0c79f85bdaeb4ea", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -25,6 +25,11 @@ namespace __asan {\n \n // AsanThreadContext implementation.\n \n+struct CreateThreadContextArgs {\n+  AsanThread *thread;\n+  StackTrace *stack;\n+};\n+\n void AsanThreadContext::OnCreated(void *arg) {\n   CreateThreadContextArgs *args = static_cast<CreateThreadContextArgs*>(arg);\n   if (args->stack)\n@@ -35,7 +40,7 @@ void AsanThreadContext::OnCreated(void *arg) {\n \n void AsanThreadContext::OnFinished() {\n   // Drop the link to the AsanThread object.\n-  thread = 0;\n+  thread = nullptr;\n }\n \n // MIPS requires aligned address\n@@ -73,13 +78,17 @@ AsanThreadContext *GetThreadContextByTidLocked(u32 tid) {\n \n // AsanThread implementation.\n \n-AsanThread *AsanThread::Create(thread_callback_t start_routine,\n-                               void *arg) {\n+AsanThread *AsanThread::Create(thread_callback_t start_routine, void *arg,\n+                               u32 parent_tid, StackTrace *stack,\n+                               bool detached) {\n   uptr PageSize = GetPageSizeCached();\n   uptr size = RoundUpTo(sizeof(AsanThread), PageSize);\n   AsanThread *thread = (AsanThread*)MmapOrDie(size, __func__);\n   thread->start_routine_ = start_routine;\n   thread->arg_ = arg;\n+  CreateThreadContextArgs args = { thread, stack };\n+  asanThreadRegistry().CreateThread(*reinterpret_cast<uptr *>(thread), detached,\n+                                    parent_tid, &args);\n \n   return thread;\n }\n@@ -114,7 +123,7 @@ void AsanThread::Destroy() {\n FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n   uptr stack_size = this->stack_size();\n   if (stack_size == 0)  // stack_size is not yet available, don't use FakeStack.\n-    return 0;\n+    return nullptr;\n   uptr old_val = 0;\n   // fake_stack_ has 3 states:\n   // 0   -- not initialized\n@@ -135,11 +144,11 @@ FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n     SetTLSFakeStack(fake_stack_);\n     return fake_stack_;\n   }\n-  return 0;\n+  return nullptr;\n }\n \n void AsanThread::Init() {\n-  fake_stack_ = 0;  // Will be initialized lazily if needed.\n+  fake_stack_ = nullptr;  // Will be initialized lazily if needed.\n   CHECK_EQ(this->stack_size(), 0U);\n   SetThreadStackAndTls();\n   CHECK_GT(this->stack_size(), 0U);\n@@ -150,12 +159,15 @@ void AsanThread::Init() {\n   VReport(1, \"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\", tid(),\n           (void *)stack_bottom_, (void *)stack_top_, stack_top_ - stack_bottom_,\n           &local);\n-  AsanPlatformThreadInit();\n }\n \n-thread_return_t AsanThread::ThreadStart(uptr os_id) {\n+thread_return_t AsanThread::ThreadStart(\n+    uptr os_id, atomic_uintptr_t *signal_thread_is_registered) {\n   Init();\n-  asanThreadRegistry().StartThread(tid(), os_id, 0);\n+  asanThreadRegistry().StartThread(tid(), os_id, nullptr);\n+  if (signal_thread_is_registered)\n+    atomic_store(signal_thread_is_registered, 1, memory_order_release);\n+\n   if (common_flags()->use_sigaltstack) SetAlternateSignalStack();\n \n   if (!start_routine_) {\n@@ -262,7 +274,7 @@ AsanThread *GetCurrentThread() {\n         return tctx->thread;\n       }\n     }\n-    return 0;\n+    return nullptr;\n   }\n   return context->thread;\n }\n@@ -287,7 +299,7 @@ AsanThread *FindThreadByStackAddress(uptr addr) {\n   AsanThreadContext *tctx = static_cast<AsanThreadContext *>(\n       asanThreadRegistry().FindThreadContextLocked(ThreadStackContainsAddress,\n                                                    (void *)addr));\n-  return tctx ? tctx->thread : 0;\n+  return tctx ? tctx->thread : nullptr;\n }\n \n void EnsureMainThreadIDIsCorrect() {\n@@ -300,10 +312,10 @@ void EnsureMainThreadIDIsCorrect() {\n __asan::AsanThread *GetAsanThreadByOsIDLocked(uptr os_id) {\n   __asan::AsanThreadContext *context = static_cast<__asan::AsanThreadContext *>(\n       __asan::asanThreadRegistry().FindThreadContextByOsIDLocked(os_id));\n-  if (!context) return 0;\n+  if (!context) return nullptr;\n   return context->thread;\n }\n-}  // namespace __asan\n+} // namespace __asan\n \n // --- Implementation of LSan-specific functions --- {{{1\n namespace __lsan {\n@@ -340,4 +352,4 @@ void UnlockThreadRegistry() {\n void EnsureMainThreadIDIsCorrect() {\n   __asan::EnsureMainThreadIDIsCorrect();\n }\n-}  // namespace __lsan\n+} // namespace __lsan"}, {"sha": "27a3367d8e71cd3ad3b3489984216ffdc2874428", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,6 +9,7 @@\n //\n // ASan-private header for asan_thread.cc.\n //===----------------------------------------------------------------------===//\n+\n #ifndef ASAN_THREAD_H\n #define ASAN_THREAD_H\n \n@@ -32,19 +33,16 @@ class AsanThread;\n class AsanThreadContext : public ThreadContextBase {\n  public:\n   explicit AsanThreadContext(int tid)\n-      : ThreadContextBase(tid),\n-        announced(false),\n-        destructor_iterations(kPthreadDestructorIterations),\n-        stack_id(0),\n-        thread(0) {\n-  }\n+      : ThreadContextBase(tid), announced(false),\n+        destructor_iterations(GetPthreadDestructorIterations()), stack_id(0),\n+        thread(nullptr) {}\n   bool announced;\n   u8 destructor_iterations;\n   u32 stack_id;\n   AsanThread *thread;\n \n-  void OnCreated(void *arg);\n-  void OnFinished();\n+  void OnCreated(void *arg) override;\n+  void OnFinished() override;\n };\n \n // AsanThreadContext objects are never freed, so we need many of them.\n@@ -53,12 +51,14 @@ COMPILER_CHECK(sizeof(AsanThreadContext) <= 256);\n // AsanThread are stored in TSD and destroyed when the thread dies.\n class AsanThread {\n  public:\n-  static AsanThread *Create(thread_callback_t start_routine, void *arg);\n+  static AsanThread *Create(thread_callback_t start_routine, void *arg,\n+                            u32 parent_tid, StackTrace *stack, bool detached);\n   static void TSDDtor(void *tsd);\n   void Destroy();\n \n   void Init();  // Should be called from the thread itself.\n-  thread_return_t ThreadStart(uptr os_id);\n+  thread_return_t ThreadStart(uptr os_id,\n+                              atomic_uintptr_t *signal_thread_is_registered);\n \n   uptr stack_top() { return stack_top_; }\n   uptr stack_bottom() { return stack_bottom_; }\n@@ -83,8 +83,8 @@ class AsanThread {\n   void DeleteFakeStack(int tid) {\n     if (!fake_stack_) return;\n     FakeStack *t = fake_stack_;\n-    fake_stack_ = 0;\n-    SetTLSFakeStack(0);\n+    fake_stack_ = nullptr;\n+    SetTLSFakeStack(nullptr);\n     t->Destroy(tid);\n   }\n \n@@ -94,7 +94,7 @@ class AsanThread {\n \n   FakeStack *fake_stack() {\n     if (!__asan_option_detect_stack_use_after_return)\n-      return 0;\n+      return nullptr;\n     if (!has_fake_stack())\n       return AsyncSignalSafeLazyInitFakeStack();\n     return fake_stack_;\n@@ -164,11 +164,6 @@ class ScopedDeadlySignal {\n   AsanThread *thread;\n };\n \n-struct CreateThreadContextArgs {\n-  AsanThread *thread;\n-  StackTrace *stack;\n-};\n-\n // Returns a single instance of registry.\n ThreadRegistry &asanThreadRegistry();\n \n@@ -183,6 +178,6 @@ AsanThread *FindThreadByStackAddress(uptr addr);\n \n // Used to handle fork().\n void EnsureMainThreadIDIsCorrect();\n-}  // namespace __asan\n+} // namespace __asan\n \n-#endif  // ASAN_THREAD_H\n+#endif // ASAN_THREAD_H"}, {"sha": "caec9f83d6852f086b2cd27fc88261279a1b7c41", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 131, "deletions": 23, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,27 +14,139 @@\n #if SANITIZER_WINDOWS\n #include <windows.h>\n \n-#include <dbghelp.h>\n #include <stdlib.h>\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_report.h\"\n+#include \"asan_stack.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n \n+using namespace __asan;  // NOLINT\n+\n extern \"C\" {\n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  int __asan_should_detect_stack_use_after_return() {\n-    __asan_init();\n-    return __asan_option_detect_stack_use_after_return;\n-  }\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __asan_should_detect_stack_use_after_return() {\n+  __asan_init();\n+  return __asan_option_detect_stack_use_after_return;\n+}\n+\n+// -------------------- A workaround for the abscence of weak symbols ----- {{{\n+// We don't have a direct equivalent of weak symbols when using MSVC, but we can\n+// use the /alternatename directive to tell the linker to default a specific\n+// symbol to a specific value, which works nicely for allocator hooks and\n+// __asan_default_options().\n+void __sanitizer_default_malloc_hook(void *ptr, uptr size) { }\n+void __sanitizer_default_free_hook(void *ptr) { }\n+const char* __asan_default_default_options() { return \"\"; }\n+const char* __asan_default_default_suppressions() { return \"\"; }\n+void __asan_default_on_error() {}\n+#pragma comment(linker, \"/alternatename:___sanitizer_malloc_hook=___sanitizer_default_malloc_hook\")  // NOLINT\n+#pragma comment(linker, \"/alternatename:___sanitizer_free_hook=___sanitizer_default_free_hook\")      // NOLINT\n+#pragma comment(linker, \"/alternatename:___asan_default_options=___asan_default_default_options\")    // NOLINT\n+#pragma comment(linker, \"/alternatename:___asan_default_suppressions=___asan_default_default_suppressions\")    // NOLINT\n+#pragma comment(linker, \"/alternatename:___asan_on_error=___asan_default_on_error\")                  // NOLINT\n+// }}}\n+}  // extern \"C\"\n+\n+// ---------------------- Windows-specific inteceptors ---------------- {{{\n+INTERCEPTOR_WINAPI(void, RaiseException, void *a, void *b, void *c, void *d) {\n+  CHECK(REAL(RaiseException));\n+  __asan_handle_no_return();\n+  REAL(RaiseException)(a, b, c, d);\n+}\n+\n+INTERCEPTOR(int, _except_handler3, void *a, void *b, void *c, void *d) {\n+  CHECK(REAL(_except_handler3));\n+  __asan_handle_no_return();\n+  return REAL(_except_handler3)(a, b, c, d);\n+}\n+\n+#if ASAN_DYNAMIC\n+// This handler is named differently in -MT and -MD CRTs.\n+#define _except_handler4 _except_handler4_common\n+#endif\n+INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n+  CHECK(REAL(_except_handler4));\n+  __asan_handle_no_return();\n+  return REAL(_except_handler4)(a, b, c, d);\n+}\n+\n+static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n+  AsanThread *t = (AsanThread*)arg;\n+  SetCurrentThread(t);\n+  return t->ThreadStart(GetTid(), /* signal_thread_is_registered */ nullptr);\n+}\n+\n+INTERCEPTOR_WINAPI(DWORD, CreateThread,\n+                   void* security, uptr stack_size,\n+                   DWORD (__stdcall *start_routine)(void*), void* arg,\n+                   DWORD thr_flags, void* tid) {\n+  // Strict init-order checking is thread-hostile.\n+  if (flags()->strict_init_order)\n+    StopInitOrderChecking();\n+  GET_STACK_TRACE_THREAD;\n+  // FIXME: The CreateThread interceptor is not the same as a pthread_create\n+  // one.  This is a bandaid fix for PR22025.\n+  bool detached = false;  // FIXME: how can we determine it on Windows?\n+  u32 current_tid = GetCurrentTidOrInvalid();\n+  AsanThread *t =\n+        AsanThread::Create(start_routine, arg, current_tid, &stack, detached);\n+  return REAL(CreateThread)(security, stack_size,\n+                            asan_thread_start, t, thr_flags, tid);\n+}\n+\n+namespace {\n+BlockingMutex mu_for_thread_tracking(LINKER_INITIALIZED);\n+\n+void EnsureWorkerThreadRegistered() {\n+  // FIXME: GetCurrentThread relies on TSD, which might not play well with\n+  // system thread pools.  We might want to use something like reference\n+  // counting to zero out GetCurrentThread() underlying storage when the last\n+  // work item finishes?  Or can we disable reclaiming of threads in the pool?\n+  BlockingMutexLock l(&mu_for_thread_tracking);\n+  if (__asan::GetCurrentThread())\n+    return;\n+\n+  AsanThread *t = AsanThread::Create(\n+      /* start_routine */ nullptr, /* arg */ nullptr,\n+      /* parent_tid */ -1, /* stack */ nullptr, /* detached */ true);\n+  t->Init();\n+  asanThreadRegistry().StartThread(t->tid(), 0, 0);\n+  SetCurrentThread(t);\n+}\n+}  // namespace\n+\n+INTERCEPTOR_WINAPI(DWORD, NtWaitForWorkViaWorkerFactory, DWORD a, DWORD b) {\n+  // NtWaitForWorkViaWorkerFactory is called from system worker pool threads to\n+  // query work scheduled by BindIoCompletionCallback, QueueUserWorkItem, etc.\n+  // System worker pool threads are created at arbitraty point in time and\n+  // without using CreateThread, so we wrap NtWaitForWorkViaWorkerFactory\n+  // instead and don't register a specific parent_tid/stack.\n+  EnsureWorkerThreadRegistered();\n+  return REAL(NtWaitForWorkViaWorkerFactory)(a, b);\n }\n \n+// }}}\n+\n namespace __asan {\n \n-// ---------------------- TSD ---------------- {{{1\n+void InitializePlatformInterceptors() {\n+  ASAN_INTERCEPT_FUNC(CreateThread);\n+  ASAN_INTERCEPT_FUNC(RaiseException);\n+  ASAN_INTERCEPT_FUNC(_except_handler3);\n+  ASAN_INTERCEPT_FUNC(_except_handler4);\n+\n+  // NtWaitForWorkViaWorkerFactory is always linked dynamically.\n+  CHECK(::__interception::OverrideFunction(\n+      \"NtWaitForWorkViaWorkerFactory\",\n+      (uptr)WRAP(NtWaitForWorkViaWorkerFactory),\n+      (uptr *)&REAL(NtWaitForWorkViaWorkerFactory)));\n+}\n+\n+// ---------------------- TSD ---------------- {{{\n static bool tsd_key_inited = false;\n \n static __declspec(thread) void *fake_tsd = 0;\n@@ -57,7 +169,13 @@ void AsanTSDSet(void *tsd) {\n void PlatformTSDDtor(void *tsd) {\n   AsanThread::TSDDtor(tsd);\n }\n-// ---------------------- Various stuff ---------------- {{{1\n+// }}}\n+\n+// ---------------------- Various stuff ---------------- {{{\n+void DisableReexec() {\n+  // No need to re-exec on Windows.\n+}\n+\n void MaybeReexec() {\n   // No need to re-exec on Windows.\n }\n@@ -73,15 +191,11 @@ void AsanCheckDynamicRTPrereqs() {}\n \n void AsanCheckIncompatibleRT() {}\n \n-void AsanPlatformThreadInit() {\n-  // Nothing here for now.\n-}\n-\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n-void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n+void AsanOnDeadlySignal(int, void *siginfo, void *context) {\n   UNIMPLEMENTED();\n }\n \n@@ -90,21 +204,15 @@ static LPTOP_LEVEL_EXCEPTION_FILTER default_seh_handler;\n static long WINAPI SEHHandler(EXCEPTION_POINTERS *info) {\n   EXCEPTION_RECORD *exception_record = info->ExceptionRecord;\n   CONTEXT *context = info->ContextRecord;\n-  uptr pc = (uptr)exception_record->ExceptionAddress;\n-#ifdef _WIN64\n-  uptr bp = (uptr)context->Rbp, sp = (uptr)context->Rsp;\n-#else\n-  uptr bp = (uptr)context->Ebp, sp = (uptr)context->Esp;\n-#endif\n \n   if (exception_record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||\n       exception_record->ExceptionCode == EXCEPTION_IN_PAGE_ERROR) {\n     const char *description =\n         (exception_record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)\n             ? \"access-violation\"\n             : \"in-page-error\";\n-    uptr access_addr = exception_record->ExceptionInformation[1];\n-    ReportSIGSEGV(description, pc, sp, bp, context, access_addr);\n+    SignalContext sig = SignalContext::Create(exception_record, context);\n+    ReportDeadlySignal(description, sig);\n   }\n \n   // FIXME: Handle EXCEPTION_STACK_OVERFLOW here.\n@@ -142,10 +250,10 @@ int __asan_set_seh_filter() {\n // Put a pointer to __asan_set_seh_filter at the end of the global list\n // of C initializers, after the default EH is set by the CRT.\n #pragma section(\".CRT$XIZ\", long, read)  // NOLINT\n-static __declspec(allocate(\".CRT$XIZ\"))\n+__declspec(allocate(\".CRT$XIZ\"))\n     int (*__intercept_seh)() = __asan_set_seh_filter;\n #endif\n-\n+// }}}\n }  // namespace __asan\n \n #endif  // _WIN32"}, {"sha": "19d73f9f89e3ae9d696d66a1afb1e5fa8a6b4635", "filename": "libsanitizer/asan/asan_win_dll_thunk.cc", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -19,7 +19,7 @@\n // simplifies the build procedure.\n #ifdef ASAN_DLL_THUNK\n #include \"asan_init_version.h\"\n-#include \"sanitizer_common/sanitizer_interception.h\"\n+#include \"interception/interception.h\"\n \n // ---------- Function interception helper functions and macros ----------- {{{1\n extern \"C\" {\n@@ -28,8 +28,9 @@ void *__stdcall GetProcAddress(void *module, const char *proc_name);\n void abort();\n }\n \n-static void *getRealProcAddressOrDie(const char *name) {\n-  void *ret = GetProcAddress(GetModuleHandleA(0), name);\n+static uptr getRealProcAddressOrDie(const char *name) {\n+  uptr ret =\n+      __interception::InternalGetProcAddress((void *)GetModuleHandleA(0), name);\n   if (!ret)\n     abort();\n   return ret;\n@@ -60,13 +61,12 @@ struct FunctionInterceptor<0> {\n };\n \n #define INTERCEPT_WHEN_POSSIBLE(main_function, dll_function)                   \\\n-  template<> struct FunctionInterceptor<__LINE__> {                            \\\n+  template <> struct FunctionInterceptor<__LINE__> {                           \\\n     static void Execute() {                                                    \\\n-      void *wrapper = getRealProcAddressOrDie(main_function);                  \\\n-      if (!__interception::OverrideFunction((uptr)dll_function,                \\\n-                                            (uptr)wrapper, 0))                 \\\n+      uptr wrapper = getRealProcAddressOrDie(main_function);                   \\\n+      if (!__interception::OverrideFunction((uptr)dll_function, wrapper, 0))   \\\n         abort();                                                               \\\n-      FunctionInterceptor<__LINE__-1>::Execute();                              \\\n+      FunctionInterceptor<__LINE__ - 1>::Execute();                            \\\n     }                                                                          \\\n   };\n \n@@ -208,7 +208,7 @@ extern \"C\" {\n     // __asan_init is expected to be called by only one thread.\n     if (fn) return;\n \n-    fn = (fntype)getRealProcAddressOrDie(__asan_init_name);\n+    fn = (fntype)getRealProcAddressOrDie(\"__asan_init\");\n     fn();\n     __asan_option_detect_stack_use_after_return =\n         (__asan_should_detect_stack_use_after_return() != 0);\n@@ -217,6 +217,10 @@ extern \"C\" {\n   }\n }\n \n+extern \"C\" void __asan_version_mismatch_check() {\n+  // Do nothing.\n+}\n+\n INTERFACE_FUNCTION(__asan_handle_no_return)\n \n INTERFACE_FUNCTION(__asan_report_store1)\n@@ -292,7 +296,45 @@ INTERFACE_FUNCTION(__asan_stack_free_8)\n INTERFACE_FUNCTION(__asan_stack_free_9)\n INTERFACE_FUNCTION(__asan_stack_free_10)\n \n+// FIXME: we might want to have a sanitizer_win_dll_thunk?\n+INTERFACE_FUNCTION(__sanitizer_annotate_contiguous_container)\n+INTERFACE_FUNCTION(__sanitizer_cov)\n+INTERFACE_FUNCTION(__sanitizer_cov_dump)\n+INTERFACE_FUNCTION(__sanitizer_cov_indir_call16)\n+INTERFACE_FUNCTION(__sanitizer_cov_init)\n INTERFACE_FUNCTION(__sanitizer_cov_module_init)\n+INTERFACE_FUNCTION(__sanitizer_cov_trace_basic_block)\n+INTERFACE_FUNCTION(__sanitizer_cov_trace_func_enter)\n+INTERFACE_FUNCTION(__sanitizer_cov_trace_cmp)\n+INTERFACE_FUNCTION(__sanitizer_cov_trace_switch)\n+INTERFACE_FUNCTION(__sanitizer_cov_with_check)\n+INTERFACE_FUNCTION(__sanitizer_get_allocated_size)\n+INTERFACE_FUNCTION(__sanitizer_get_coverage_guards)\n+INTERFACE_FUNCTION(__sanitizer_get_current_allocated_bytes)\n+INTERFACE_FUNCTION(__sanitizer_get_estimated_allocated_size)\n+INTERFACE_FUNCTION(__sanitizer_get_free_bytes)\n+INTERFACE_FUNCTION(__sanitizer_get_heap_size)\n+INTERFACE_FUNCTION(__sanitizer_get_ownership)\n+INTERFACE_FUNCTION(__sanitizer_get_total_unique_coverage)\n+INTERFACE_FUNCTION(__sanitizer_get_unmapped_bytes)\n+INTERFACE_FUNCTION(__sanitizer_maybe_open_cov_file)\n+INTERFACE_FUNCTION(__sanitizer_print_stack_trace)\n+INTERFACE_FUNCTION(__sanitizer_ptr_cmp)\n+INTERFACE_FUNCTION(__sanitizer_ptr_sub)\n+INTERFACE_FUNCTION(__sanitizer_report_error_summary)\n+INTERFACE_FUNCTION(__sanitizer_reset_coverage)\n+INTERFACE_FUNCTION(__sanitizer_get_number_of_counters)\n+INTERFACE_FUNCTION(__sanitizer_update_counter_bitset_and_clear_counters)\n+INTERFACE_FUNCTION(__sanitizer_sandbox_on_notify)\n+INTERFACE_FUNCTION(__sanitizer_set_death_callback)\n+INTERFACE_FUNCTION(__sanitizer_set_report_path)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_load16)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_load32)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_load64)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_store16)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_store32)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_store64)\n+INTERFACE_FUNCTION(__sanitizer_verify_contiguous_container)\n \n // TODO(timurrrr): Add more interface functions on the as-needed basis.\n \n@@ -342,11 +384,15 @@ INTERCEPT_LIBRARY_FUNCTION(strcat);  // NOLINT\n INTERCEPT_LIBRARY_FUNCTION(strchr);\n INTERCEPT_LIBRARY_FUNCTION(strcmp);\n INTERCEPT_LIBRARY_FUNCTION(strcpy);  // NOLINT\n+INTERCEPT_LIBRARY_FUNCTION(strcspn);\n INTERCEPT_LIBRARY_FUNCTION(strlen);\n INTERCEPT_LIBRARY_FUNCTION(strncat);\n INTERCEPT_LIBRARY_FUNCTION(strncmp);\n INTERCEPT_LIBRARY_FUNCTION(strncpy);\n INTERCEPT_LIBRARY_FUNCTION(strnlen);\n+INTERCEPT_LIBRARY_FUNCTION(strpbrk);\n+INTERCEPT_LIBRARY_FUNCTION(strspn);\n+INTERCEPT_LIBRARY_FUNCTION(strstr);\n INTERCEPT_LIBRARY_FUNCTION(strtol);\n INTERCEPT_LIBRARY_FUNCTION(wcslen);\n "}, {"sha": "69da2a83c47cf8dd4d6b03095190d301762b88f8", "filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cc", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -13,18 +13,24 @@\n //\n // This includes:\n //  - forwarding the detect_stack_use_after_return runtime option\n-//  - installing a custom SEH handler\n+//  - working around deficiencies of the MD runtime\n+//  - installing a custom SEH handlerx\n //\n //===----------------------------------------------------------------------===//\n \n // Only compile this code when buidling asan_dynamic_runtime_thunk.lib\n // Using #ifdef rather than relying on Makefiles etc.\n // simplifies the build procedure.\n #ifdef ASAN_DYNAMIC_RUNTIME_THUNK\n-extern \"C\" {\n-__declspec(dllimport) int __asan_set_seh_filter();\n-__declspec(dllimport) int __asan_should_detect_stack_use_after_return();\n+#include <windows.h>\n \n+// First, declare CRT sections we'll be using in this file\n+#pragma section(\".CRT$XID\", long, read)  // NOLINT\n+#pragma section(\".CRT$XIZ\", long, read)  // NOLINT\n+#pragma section(\".CRT$XTW\", long, read)  // NOLINT\n+#pragma section(\".CRT$XTY\", long, read)  // NOLINT\n+\n+////////////////////////////////////////////////////////////////////////////////\n // Define a copy of __asan_option_detect_stack_use_after_return that should be\n // used when linking an MD runtime with a set of object files on Windows.\n //\n@@ -35,16 +41,55 @@ __declspec(dllimport) int __asan_should_detect_stack_use_after_return();\n // with a MT or MD runtime and we don't want to use ugly __imp_ names on Windows\n // just to work around this issue, let's clone the a variable that is\n // constant after initialization anyways.\n+extern \"C\" {\n+__declspec(dllimport) int __asan_should_detect_stack_use_after_return();\n int __asan_option_detect_stack_use_after_return =\n     __asan_should_detect_stack_use_after_return();\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// For some reason, the MD CRT doesn't call the C/C++ terminators during on DLL\n+// unload or on exit.  ASan relies on LLVM global_dtors to call\n+// __asan_unregister_globals on these events, which unfortunately doesn't work\n+// with the MD runtime, see PR22545 for the details.\n+// To work around this, for each DLL we schedule a call to UnregisterGlobals\n+// using atexit() that calls a small subset of C terminators\n+// where LLVM global_dtors is placed.  Fingers crossed, no other C terminators\n+// are there.\n+extern \"C\" void __cdecl _initterm(void *a, void *b);\n+\n+namespace {\n+__declspec(allocate(\".CRT$XTW\")) void* before_global_dtors = 0;\n+__declspec(allocate(\".CRT$XTY\")) void* after_global_dtors = 0;\n+\n+void UnregisterGlobals() {\n+  _initterm(&before_global_dtors, &after_global_dtors);\n+}\n+\n+int ScheduleUnregisterGlobals() {\n+  return atexit(UnregisterGlobals);\n+}\n+\n+// We need to call 'atexit(UnregisterGlobals);' as early as possible, but after\n+// atexit() is initialized (.CRT$XIC).  As this is executed before C++\n+// initializers (think ctors for globals), UnregisterGlobals gets executed after\n+// dtors for C++ globals.\n+__declspec(allocate(\".CRT$XID\"))\n+int (*__asan_schedule_unregister_globals)() = ScheduleUnregisterGlobals;\n+\n+}  // namespace\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// ASan SEH handling.\n+// We need to set the ASan-specific SEH handler at the end of CRT initialization\n+// of each module (see also asan_win.cc).\n+extern \"C\" {\n+__declspec(dllimport) int __asan_set_seh_filter();\n+static int SetSEHFilter() { return __asan_set_seh_filter(); }\n \n-// Set the ASan-specific SEH handler at the end of CRT initialization of each\n-// module (see asan_win.cc for the details).\n-//\n // Unfortunately, putting a pointer to __asan_set_seh_filter into\n // __asan_intercept_seh gets optimized out, so we have to use an extra function.\n-static int SetSEHFilter() { return __asan_set_seh_filter(); }\n-#pragma section(\".CRT$XIZ\", long, read)  // NOLINT\n __declspec(allocate(\".CRT$XIZ\")) int (*__asan_seh_interceptor)() = SetSEHFilter;\n }\n+\n #endif // ASAN_DYNAMIC_RUNTIME_THUNK"}, {"sha": "7e838a5740b3b18af4d32294ce61c856d9c4d86c", "filename": "libsanitizer/asan/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fasan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Flibtool-version?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -3,4 +3,4 @@\n # a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-2:0:0\n+3:0:0"}, {"sha": "80655f05e9754b70983fe5cc56072cfa94ac6f4f", "filename": "libsanitizer/configure", "status": "modified", "additions": 19, "deletions": 54, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -616,6 +616,8 @@ BACKTRACE_SUPPORTED\n FORMAT_FILE\n SANITIZER_SUPPORTED_FALSE\n SANITIZER_SUPPORTED_TRUE\n+USE_CXX_ABI_FLAG_FALSE\n+USE_CXX_ABI_FLAG_TRUE\n USING_MAC_INTERPOSE_FALSE\n USING_MAC_INTERPOSE_TRUE\n link_liblsan\n@@ -12027,7 +12029,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12030 \"configure\"\n+#line 12032 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12133,7 +12135,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12136 \"configure\"\n+#line 12138 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -15514,7 +15516,7 @@ done\n \n \n # Common libraries that we need to link against for all sanitizer libs.\n-link_sanitizer_common='-lpthread -ldl -lm'\n+link_sanitizer_common='-lrt -lpthread -ldl -lm'\n \n # Set up the set of additional libraries that we need to link against for libasan.\n link_libasan=$link_sanitizer_common\n@@ -15532,58 +15534,9 @@ link_libubsan=$link_sanitizer_common\n link_liblsan=$link_sanitizer_common\n \n \n-# At least for glibc, clock_gettime is in librt.  But don't pull that\n-# in if it still doesn't give us the function we want.  This\n-# test is copied from libgomp.\n-if test $ac_cv_func_clock_gettime = no; then\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for clock_gettime in -lrt\" >&5\n-$as_echo_n \"checking for clock_gettime in -lrt... \" >&6; }\n-if test \"${ac_cv_lib_rt_clock_gettime+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  ac_check_lib_save_LIBS=$LIBS\n-LIBS=\"-lrt  $LIBS\"\n-cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-/* Override any GCC internal prototype to avoid an error.\n-   Use char because int might match the return type of a GCC\n-   builtin and then its argument prototype would still apply.  */\n-#ifdef __cplusplus\n-extern \"C\"\n-#endif\n-char clock_gettime ();\n-int\n-main ()\n-{\n-return clock_gettime ();\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  ac_cv_lib_rt_clock_gettime=yes\n-else\n-  ac_cv_lib_rt_clock_gettime=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-LIBS=$ac_check_lib_save_LIBS\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_rt_clock_gettime\" >&5\n-$as_echo \"$ac_cv_lib_rt_clock_gettime\" >&6; }\n-if test \"x$ac_cv_lib_rt_clock_gettime\" = x\"\"yes; then :\n-  link_libasan=\"-lrt $link_libasan\"\n-link_libtsan=\"-lrt $link_libtsan\"\n-# Other sanitizers do not override clock_* API\n-\n-fi\n-\n-fi\n-\n case \"$host\" in\n-  *-*-darwin*) MAC_INTERPOSE=true ; enable_static=no ;;\n-  *) MAC_INTERPOSE=false ;;\n+  *-*-darwin*) MAC_INTERPOSE=true ; enable_static=no ; CXX_ABI_NEEDED=true ;;\n+  *) MAC_INTERPOSE=false ; CXX_ABI_NEEDED=false ;;\n esac\n  if $MAC_INTERPOSE; then\n   USING_MAC_INTERPOSE_TRUE=\n@@ -15593,6 +15546,14 @@ else\n   USING_MAC_INTERPOSE_FALSE=\n fi\n \n+ if $CXX_ABI_NEEDED; then\n+  USE_CXX_ABI_FLAG_TRUE=\n+  USE_CXX_ABI_FLAG_FALSE='#'\n+else\n+  USE_CXX_ABI_FLAG_TRUE='#'\n+  USE_CXX_ABI_FLAG_FALSE=\n+fi\n+\n \n backtrace_supported=yes\n \n@@ -16550,6 +16511,10 @@ if test -z \"${USING_MAC_INTERPOSE_TRUE}\" && test -z \"${USING_MAC_INTERPOSE_FALSE\n   as_fn_error \"conditional \\\"USING_MAC_INTERPOSE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${USE_CXX_ABI_FLAG_TRUE}\" && test -z \"${USE_CXX_ABI_FLAG_FALSE}\"; then\n+  as_fn_error \"conditional \\\"USE_CXX_ABI_FLAG\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${SANITIZER_SUPPORTED_TRUE}\" && test -z \"${SANITIZER_SUPPORTED_FALSE}\"; then\n   as_fn_error \"conditional \\\"SANITIZER_SUPPORTED\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "ece15ed13dcbbc369600b833845b4056aae1f2c2", "filename": "libsanitizer/configure.ac", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -96,7 +96,7 @@ AM_CONDITIONAL(LSAN_SUPPORTED, [test \"x$LSAN_SUPPORTED\" = \"xyes\"])\n AC_CHECK_FUNCS(clock_getres clock_gettime clock_settime)\n \n # Common libraries that we need to link against for all sanitizer libs.\n-link_sanitizer_common='-lpthread -ldl -lm'\n+link_sanitizer_common='-lrt -lpthread -ldl -lm'\n \n # Set up the set of additional libraries that we need to link against for libasan.\n link_libasan=$link_sanitizer_common\n@@ -114,22 +114,12 @@ AC_SUBST(link_libubsan)\n link_liblsan=$link_sanitizer_common\n AC_SUBST(link_liblsan)\n \n-# At least for glibc, clock_gettime is in librt.  But don't pull that\n-# in if it still doesn't give us the function we want.  This\n-# test is copied from libgomp.\n-if test $ac_cv_func_clock_gettime = no; then\n-  AC_CHECK_LIB(rt, clock_gettime,\n-    [link_libasan=\"-lrt $link_libasan\"\n-link_libtsan=\"-lrt $link_libtsan\"\n-# Other sanitizers do not override clock_* API\n-])\n-fi\n-\n case \"$host\" in\n-  *-*-darwin*) MAC_INTERPOSE=true ; enable_static=no ;;\n-  *) MAC_INTERPOSE=false ;;\n+  *-*-darwin*) MAC_INTERPOSE=true ; enable_static=no ; CXX_ABI_NEEDED=true ;;\n+  *) MAC_INTERPOSE=false ; CXX_ABI_NEEDED=false ;;\n esac\n AM_CONDITIONAL(USING_MAC_INTERPOSE, $MAC_INTERPOSE)\n+AM_CONDITIONAL(USE_CXX_ABI_FLAG, $CXX_ABI_NEEDED)\n \n backtrace_supported=yes\n "}, {"sha": "1ba3718cdbec3c4036140a61847ff12744b94473", "filename": "libsanitizer/configure.tgt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.tgt?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -35,6 +35,9 @@ case \"${target}\" in\n   arm*-*-linux*)\n \t;;\n   aarch64*-*-linux*)\n+\tif test x$ac_cv_sizeof_void_p = x8; then\n+\t\tTSAN_SUPPORTED=yes\n+\tfi\n \t;;\n   x86_64-*-darwin[1]* | i?86-*-darwin[1]*)\n \tTSAN_SUPPORTED=no"}, {"sha": "448a0bcba016d3f8d791e58511bd3be4128c2e2c", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -108,12 +108,7 @@ extern \"C\" {\n   void __asan_report_error(void *pc, void *bp, void *sp,\n                            void *addr, int is_write, size_t access_size);\n \n-  // Sets the exit code to use when reporting an error.\n-  // Returns the old value.\n-  int __asan_set_error_exit_code(int exit_code);\n-\n-  // Sets the callback to be called right before death on error.\n-  // Passing 0 will unset the callback.\n+  // Deprecated. Call __sanitizer_set_death_callback instead.\n   void __asan_set_death_callback(void (*callback)(void));\n \n   void __asan_set_error_report_callback(void (*callback)(const char*));"}, {"sha": "6a97567fea66e363691ca63d162f2f7604b03ee8", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -60,15 +60,6 @@ extern \"C\" {\n   void __sanitizer_unaligned_store32(void *p, uint32_t x);\n   void __sanitizer_unaligned_store64(void *p, uint64_t x);\n \n-  // Initialize coverage.\n-  void __sanitizer_cov_init();\n-  // Record and dump coverage info.\n-  void __sanitizer_cov_dump();\n-  // Open <name>.sancov.packed in the coverage directory and return the file\n-  // descriptor. Returns -1 on failure, or if coverage dumping is disabled.\n-  // This is intended for use by sandboxing code.\n-  intptr_t __sanitizer_maybe_open_cov_file(const char *name);\n-\n   // Annotate the current state of a contiguous container, such as\n   // std::vector, std::string or similar.\n   // A contiguous container is a container that keeps all of its elements\n@@ -115,6 +106,20 @@ extern \"C\" {\n   // Print the stack trace leading to this call. Useful for debugging user code.\n   void __sanitizer_print_stack_trace();\n \n+  // Sets the callback to be called right before death on error.\n+  // Passing 0 will unset the callback.\n+  void __sanitizer_set_death_callback(void (*callback)(void));\n+\n+  // Interceptor hooks.\n+  // Whenever a libc function interceptor is called it checks if the\n+  // corresponding weak hook is defined, and it so -- calls it.\n+  // The primary use case is data-flow-guided fuzzing, where the fuzzer needs\n+  // to know what is being passed to libc functions, e.g. memcmp.\n+  // FIXME: implement more hooks.\n+  void __sanitizer_weak_hook_memcmp(void *called_pc, const void *s1,\n+                                    const void *s2, size_t n);\n+  void __sanitizer_weak_hook_strncmp(void *called_pc, const char *s1,\n+                                    const char *s2, size_t n);\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "1b7e2a4cdd88dfdafcd332d957e61de189dd0a4c", "filename": "libsanitizer/include/sanitizer/coverage_interface.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,61 @@\n+//===-- sanitizer/coverage_interface.h --------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Public interface for sanitizer coverage.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_COVERAG_INTERFACE_H\n+#define SANITIZER_COVERAG_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+  // Initialize coverage.\n+  void __sanitizer_cov_init();\n+  // Record and dump coverage info.\n+  void __sanitizer_cov_dump();\n+  // Open <name>.sancov.packed in the coverage directory and return the file\n+  // descriptor. Returns -1 on failure, or if coverage dumping is disabled.\n+  // This is intended for use by sandboxing code.\n+  intptr_t __sanitizer_maybe_open_cov_file(const char *name);\n+  // Get the number of total unique covered entities (blocks, edges, calls).\n+  // This can be useful for coverage-directed in-process fuzzers.\n+  uintptr_t __sanitizer_get_total_unique_coverage();\n+\n+  // Reset the basic-block (edge) coverage to the initial state.\n+  // Useful for in-process fuzzing to start collecting coverage from scratch.\n+  // Experimental, will likely not work for multi-threaded process.\n+  void __sanitizer_reset_coverage();\n+  // Set *data to the array of covered PCs and return the size of that array.\n+  // Some of the entries in *data will be zero.\n+  uintptr_t __sanitizer_get_coverage_guards(uintptr_t **data);\n+\n+  // The coverage instrumentation may optionally provide imprecise counters.\n+  // Rather than exposing the counter values to the user we instead map\n+  // the counters to a bitset.\n+  // Every counter is associated with 8 bits in the bitset.\n+  // We define 8 value ranges: 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+\n+  // The i-th bit is set to 1 if the counter value is in the i-th range.\n+  // This counter-based coverage implementation is *not* thread-safe.\n+\n+  // Returns the number of registered coverage counters.\n+  uintptr_t __sanitizer_get_number_of_counters();\n+  // Updates the counter 'bitset', clears the counters and returns the number of\n+  // new bits in 'bitset'.\n+  // If 'bitset' is nullptr, only clears the counters.\n+  // Otherwise 'bitset' should be at least\n+  // __sanitizer_get_number_of_counters bytes long and 8-aligned.\n+  uintptr_t\n+  __sanitizer_update_counter_bitset_and_clear_counters(uint8_t *bitset);\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // SANITIZER_COVERAG_INTERFACE_H"}, {"sha": "0cebccf945e2e1ba56e1a76d9a183849f5060318", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -83,6 +83,24 @@ size_t dfsan_get_label_count(void);\n /// callback executes.  Pass in NULL to remove any callback.\n void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);\n \n+/// Writes the labels currently used by the program to the given file\n+/// descriptor. The lines of the output have the following format:\n+///\n+/// <label> <parent label 1> <parent label 2> <label description if any>\n+void dfsan_dump_labels(int fd);\n+\n+/// Interceptor hooks.\n+/// Whenever a dfsan's custom function is called the corresponding\n+/// hook is called it non-zero. The hooks should be defined by the user.\n+/// The primary use case is taint-guided fuzzing, where the fuzzer\n+/// needs to see the parameters of the function and the labels.\n+/// FIXME: implement more hooks.\n+void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,\n+                            size_t n, dfsan_label s1_label,\n+                            dfsan_label s2_label, dfsan_label n_label);\n+void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,\n+                             size_t n, dfsan_label s1_label,\n+                             dfsan_label s2_label, dfsan_label n_label);\n #ifdef __cplusplus\n }  // extern \"C\"\n "}, {"sha": "bdbe39084f79c8fcef45ee5719fe55ba6c867f70", "filename": "libsanitizer/include/sanitizer/lsan_interface.h", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -39,14 +39,25 @@ extern \"C\" {\n   void __lsan_register_root_region(const void *p, size_t size);\n   void __lsan_unregister_root_region(const void *p, size_t size);\n \n-  // Calling this function makes LSan enter the leak checking phase immediately.\n-  // Use this if normal end-of-process leak checking happens too late (e.g. if\n-  // you have intentional memory leaks in your shutdown code). Calling this\n-  // function overrides end-of-process leak checking; it must be called at\n-  // most once per process. This function will terminate the process if there\n-  // are memory leaks and the exit_code flag is non-zero.\n+  // Check for leaks now. This function behaves identically to the default\n+  // end-of-process leak check. In particular, it will terminate the process if\n+  // leaks are found and the exitcode runtime flag is non-zero.\n+  // Subsequent calls to this function will have no effect and end-of-process\n+  // leak check will not run. Effectively, end-of-process leak check is moved to\n+  // the time of first invocation of this function.\n+  // By calling this function early during process shutdown, you can instruct\n+  // LSan to ignore shutdown-only leaks which happen later on.\n   void __lsan_do_leak_check();\n \n+  // Check for leaks now. Returns zero if no leaks have been found or if leak\n+  // detection is disabled, non-zero otherwise.\n+  // This function may be called repeatedly, e.g. to periodically check a\n+  // long-running process. It prints a leak report if appropriate, but does not\n+  // terminate the process. It does not affect the behavior of\n+  // __lsan_do_leak_check() or the end-of-process leak check, and is not\n+  // affected by them.\n+  int __lsan_do_recoverable_leak_check();\n+\n   // The user may optionally provide this function to disallow leak checking\n   // for the program it is linked into (if the return value is non-zero). This\n   // function must be defined as returning a constant value; any behavior beyond"}, {"sha": "92793a19bde4e0abe0604c8cce2e1707ae61e945", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -23,6 +23,11 @@ extern \"C\" {\n   /* Get raw origin for an address. */\n   uint32_t __msan_get_origin(const volatile void *a);\n \n+  /* Test that this_id is a descendant of prev_id (or they are simply equal).\n+   * \"descendant\" here means they are part of the same chain, created with\n+   * __msan_chain_origin. */\n+  int __msan_origin_is_descendant_or_same(uint32_t this_id, uint32_t prev_id);\n+\n   /* Returns non-zero if tracking origins. */\n   int __msan_get_track_origins();\n \n@@ -36,7 +41,9 @@ extern \"C\" {\n      contents). */\n   void __msan_unpoison_string(const volatile char *a);\n \n-  /* Make memory region fully uninitialized (without changing its contents). */\n+  /* Make memory region fully uninitialized (without changing its contents).\n+     This is a legacy interface that does not update origin information. Use\n+     __msan_allocated_memory() instead. */\n   void __msan_poison(const volatile void *a, size_t size);\n \n   /* Make memory region partially uninitialized (without changing its contents).\n@@ -52,10 +59,6 @@ extern \"C\" {\n    * is not. */\n   void __msan_check_mem_is_initialized(const volatile void *x, size_t size);\n \n-  /* Set exit code when error(s) were detected.\n-     Value of 0 means don't change the program exit code. */\n-  void __msan_set_exit_code(int exit_code);\n-\n   /* For testing:\n      __msan_set_expect_umr(1);\n      ... some buggy code ...\n@@ -83,14 +86,22 @@ extern \"C\" {\n      Memory will be marked uninitialized, with origin at the call site. */\n   void __msan_allocated_memory(const volatile void* data, size_t size);\n \n+  /* Tell MSan about newly destroyed memory. Mark memory as uninitialized. */\n+  void __sanitizer_dtor_callback(const volatile void* data, size_t size);\n+\n   /* This function may be optionally provided by user and should return\n      a string containing Msan runtime options. See msan_flags.h for details. */\n   const char* __msan_default_options();\n \n-  /* Sets the callback to be called right before death on error.\n-     Passing 0 will unset the callback. */\n+  /* Deprecated. Call __sanitizer_set_death_callback instead. */\n   void __msan_set_death_callback(void (*callback)(void));\n \n+  /* Update shadow for the application copy of size bytes from src to dst.\n+     Src and dst are application addresses. This function does not copy the\n+     actual application memory, it only updates shadow and origin for such\n+     copy. Source and destination regions can overlap. */\n+  void __msan_copy_shadow(const volatile void *dst, const volatile void *src,\n+                          size_t size);\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "f2d48c9332f6a355571653df2fd2c880c27b0f47", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -217,7 +217,6 @@ const interpose_substitution substitution_##func_name[] \\\n     namespace __interception { \\\n       FUNC_TYPE(func) PTR_TO_REAL(func); \\\n     } \\\n-    DECLARE_WRAPPER_WINAPI(ret_type, func, __VA_ARGS__) \\\n     extern \"C\" \\\n     INTERCEPTOR_ATTRIBUTE \\\n     ret_type __stdcall WRAP(func)(__VA_ARGS__)"}, {"sha": "61bf48a72338f4bfc8690352d67a8ebe5d749aa8", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -33,12 +33,12 @@ void *GetFuncAddrVer(const char *func_name, const char *ver);\n       (::__interception::uptr) & WRAP(func))\n \n #if !defined(__ANDROID__)  // android does not have dlvsym\n-# define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n-     ::__interception::real_##func = (func##_f)(unsigned long) \\\n-         ::__interception::GetFuncAddrVer(#func, symver)\n+#define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n+  (::__interception::real_##func = (func##_f)(                \\\n+       unsigned long)::__interception::GetFuncAddrVer(#func, symver))\n #else\n-# define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n-     INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n+#define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n+  INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n #endif  // !defined(__ANDROID__)\n \n #endif  // INTERCEPTION_LINUX_H"}, {"sha": "24784c73dedbf9013e1a39e87ac27a6f465a732f", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -82,6 +82,7 @@ static size_t RoundUpToInstrBoundary(size_t size, char *code) {\n         cursor += 2;\n         continue;\n       case '\\xE9':  // E9 XX YY ZZ WW = jmp WWZZYYXX\n+      case '\\xB8':  // B8 XX YY ZZ WW = mov eax, WWZZYYXX\n         cursor += 5;\n         continue;\n     }\n@@ -179,26 +180,81 @@ bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n   return true;\n }\n \n-static const void **InterestingDLLsAvailable() {\n-  const char *InterestingDLLs[] = {\"kernel32.dll\",\n-                                   \"msvcr110.dll\", // VS2012\n-                                   \"msvcr120.dll\", // VS2013\n-                                   NULL};\n+static void **InterestingDLLsAvailable() {\n+  const char *InterestingDLLs[] = {\n+    \"kernel32.dll\",\n+    \"msvcr110.dll\", // VS2012\n+    \"msvcr120.dll\", // VS2013\n+    // NTDLL should go last as it exports some functions that we should override\n+    // in the CRT [presumably only used internally].\n+    \"ntdll.dll\", NULL\n+  };\n   static void *result[ARRAY_SIZE(InterestingDLLs)] = { 0 };\n   if (!result[0]) {\n     for (size_t i = 0, j = 0; InterestingDLLs[i]; ++i) {\n       if (HMODULE h = GetModuleHandleA(InterestingDLLs[i]))\n         result[j++] = (void *)h;\n     }\n   }\n-  return (const void **)&result[0];\n+  return &result[0];\n+}\n+\n+namespace {\n+// Utility for reading loaded PE images.\n+template <typename T> class RVAPtr {\n+ public:\n+  RVAPtr(void *module, uptr rva)\n+      : ptr_(reinterpret_cast<T *>(reinterpret_cast<char *>(module) + rva)) {}\n+  operator T *() { return ptr_; }\n+  T *operator->() { return ptr_; }\n+  T *operator++() { return ++ptr_; }\n+\n+ private:\n+  T *ptr_;\n+};\n+} // namespace\n+\n+// Internal implementation of GetProcAddress. At least since Windows 8,\n+// GetProcAddress appears to initialize DLLs before returning function pointers\n+// into them. This is problematic for the sanitizers, because they typically\n+// want to intercept malloc *before* MSVCRT initializes. Our internal\n+// implementation walks the export list manually without doing initialization.\n+uptr InternalGetProcAddress(void *module, const char *func_name) {\n+  // Check that the module header is full and present.\n+  RVAPtr<IMAGE_DOS_HEADER> dos_stub(module, 0);\n+  RVAPtr<IMAGE_NT_HEADERS> headers(module, dos_stub->e_lfanew);\n+  if (!module || dos_stub->e_magic != IMAGE_DOS_SIGNATURE || // \"MZ\"\n+      headers->Signature != IMAGE_NT_SIGNATURE ||           // \"PE\\0\\0\"\n+      headers->FileHeader.SizeOfOptionalHeader <\n+          sizeof(IMAGE_OPTIONAL_HEADER)) {\n+    return 0;\n+  }\n+\n+  IMAGE_DATA_DIRECTORY *export_directory =\n+      &headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];\n+  RVAPtr<IMAGE_EXPORT_DIRECTORY> exports(module,\n+                                         export_directory->VirtualAddress);\n+  RVAPtr<DWORD> functions(module, exports->AddressOfFunctions);\n+  RVAPtr<DWORD> names(module, exports->AddressOfNames);\n+  RVAPtr<WORD> ordinals(module, exports->AddressOfNameOrdinals);\n+\n+  for (DWORD i = 0; i < exports->NumberOfNames; i++) {\n+    RVAPtr<char> name(module, names[i]);\n+    if (!strcmp(func_name, name)) {\n+      DWORD index = ordinals[i];\n+      RVAPtr<char> func(module, functions[index]);\n+      return (uptr)(char *)func;\n+    }\n+  }\n+\n+  return 0;\n }\n \n static bool GetFunctionAddressInDLLs(const char *func_name, uptr *func_addr) {\n   *func_addr = 0;\n-  const void **DLLs = InterestingDLLsAvailable();\n+  void **DLLs = InterestingDLLsAvailable();\n   for (size_t i = 0; *func_addr == 0 && DLLs[i]; ++i)\n-    *func_addr = (uptr)GetProcAddress((HMODULE)DLLs[i], func_name);\n+    *func_addr = InternalGetProcAddress(DLLs[i], func_name);\n   return (*func_addr != 0);\n }\n "}, {"sha": "6388209dcc160fdb1da6e5b81374a620ea6b64ae", "filename": "libsanitizer/interception/interception_win.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Finterception%2Finterception_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -28,6 +28,10 @@ bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func = 0);\n \n // Overrides a function in a system DLL or DLL CRT by its exported name.\n bool OverrideFunction(const char *name, uptr new_func, uptr *orig_old_func = 0);\n+\n+// Windows-only replacement for GetProcAddress. Useful for some sanitizers.\n+uptr InternalGetProcAddress(void *module, const char *func_name);\n+\n }  // namespace __interception\n \n #if defined(INTERCEPTION_DYNAMIC_CRT)"}, {"sha": "6e7429c95a5efd43996e8859775ad79e4293b8e7", "filename": "libsanitizer/lsan/lsan.cc", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -13,6 +13,7 @@\n #include \"lsan.h\"\n \n #include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_flag_parser.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"lsan_allocator.h\"\n #include \"lsan_common.h\"\n@@ -32,13 +33,44 @@ bool WordIsPoisoned(uptr addr) {\n \n using namespace __lsan;  // NOLINT\n \n+static void InitializeFlags() {\n+  // Set all the default values.\n+  SetCommonFlagsDefaults();\n+  {\n+    CommonFlags cf;\n+    cf.CopyFrom(*common_flags());\n+    cf.external_symbolizer_path = GetEnv(\"LSAN_SYMBOLIZER_PATH\");\n+    cf.malloc_context_size = 30;\n+    cf.detect_leaks = true;\n+    cf.exitcode = 23;\n+    OverrideCommonFlags(cf);\n+  }\n+\n+  Flags *f = flags();\n+  f->SetDefaults();\n+\n+  FlagParser parser;\n+  RegisterLsanFlags(&parser, f);\n+  RegisterCommonFlags(&parser);\n+\n+  parser.ParseString(GetEnv(\"LSAN_OPTIONS\"));\n+\n+  SetVerbosity(common_flags()->verbosity);\n+\n+  if (Verbosity()) ReportUnrecognizedFlags();\n+\n+  if (common_flags()->help) parser.PrintFlagDescriptions();\n+}\n+\n extern \"C\" void __lsan_init() {\n   CHECK(!lsan_init_is_running);\n   if (lsan_inited)\n     return;\n   lsan_init_is_running = true;\n   SanitizerToolName = \"LeakSanitizer\";\n-  InitCommonLsan(true);\n+  CacheBinaryName();\n+  InitializeFlags();\n+  InitCommonLsan();\n   InitializeAllocator();\n   InitTlsSize();\n   InitializeInterceptors();\n@@ -50,6 +82,9 @@ extern \"C\" void __lsan_init() {\n \n   if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit)\n     Atexit(DoLeakCheck);\n+\n+  InitializeCoverage(common_flags()->coverage, common_flags()->coverage_dir);\n+\n   lsan_inited = true;\n   lsan_init_is_running = false;\n }"}, {"sha": "486305bcc76d7e6abfc57e41f898bb8a73b45f66", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -23,19 +23,29 @@ extern \"C\" void *memset(void *ptr, int value, uptr num);\n \n namespace __lsan {\n \n-static const uptr kMaxAllowedMallocSize = 8UL << 30;\n-static const uptr kAllocatorSpace = 0x600000000000ULL;\n-static const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n-\n struct ChunkMetadata {\n-  bool allocated : 8;  // Must be first.\n+  u8 allocated : 8;  // Must be first.\n   ChunkTag tag : 2;\n   uptr requested_size : 54;\n   u32 stack_trace_id;\n };\n \n+#if defined(__mips64)\n+static const uptr kMaxAllowedMallocSize = 4UL << 30;\n+static const uptr kRegionSizeLog = 20;\n+static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;\n+typedef TwoLevelByteMap<(kNumRegions >> 12), 1 << 12> ByteMap;\n+typedef CompactSizeClassMap SizeClassMap;\n+typedef SizeClassAllocator32<0, SANITIZER_MMAP_RANGE_SIZE,\n+    sizeof(ChunkMetadata), SizeClassMap, kRegionSizeLog, ByteMap>\n+    PrimaryAllocator;\n+#else\n+static const uptr kMaxAllowedMallocSize = 8UL << 30;\n+static const uptr kAllocatorSpace = 0x600000000000ULL;\n+static const uptr kAllocatorSize = 0x40000000000ULL; // 4T.\n typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize,\n         sizeof(ChunkMetadata), DefaultSizeClassMap> PrimaryAllocator;\n+#endif\n typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator<> SecondaryAllocator;\n typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n@@ -45,7 +55,7 @@ static Allocator allocator;\n static THREADLOCAL AllocatorCache cache;\n \n void InitializeAllocator() {\n-  allocator.Init();\n+  allocator.InitLinkerInitialized(common_flags()->allocator_may_return_null);\n }\n \n void AllocatorThreadFinish() {\n@@ -79,7 +89,7 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n     size = 1;\n   if (size > kMaxAllowedMallocSize) {\n     Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", size);\n-    return 0;\n+    return nullptr;\n   }\n   void *p = allocator.Allocate(&cache, size, alignment, false);\n   // Do not rely on the allocator to clear the memory (it's slow).\n@@ -102,7 +112,7 @@ void *Reallocate(const StackTrace &stack, void *p, uptr new_size,\n   if (new_size > kMaxAllowedMallocSize) {\n     Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", new_size);\n     allocator.Deallocate(&cache, p);\n-    return 0;\n+    return nullptr;\n   }\n   p = allocator.Reallocate(&cache, p, new_size, alignment);\n   RegisterAllocation(stack, p, new_size);\n@@ -200,7 +210,7 @@ IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n     return kIgnoreObjectInvalid;\n   }\n }\n-}  // namespace __lsan\n+} // namespace __lsan\n \n using namespace __lsan;\n \n@@ -229,10 +239,10 @@ SANITIZER_INTERFACE_ATTRIBUTE\n uptr __sanitizer_get_estimated_allocated_size(uptr size) { return size; }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n-int __sanitizer_get_ownership(const void *p) { return Metadata(p) != 0; }\n+int __sanitizer_get_ownership(const void *p) { return Metadata(p) != nullptr; }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n uptr __sanitizer_get_allocated_size(const void *p) {\n   return GetMallocUsableSize(p);\n }\n-}  // extern \"C\"\n+} // extern \"C\""}, {"sha": "7efbf600da20d16f876b3098d1a571047b1a22aa", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 127, "deletions": 124, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,11 +14,11 @@\n \n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_flag_parser.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n-#include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"sanitizer_common/sanitizer_suppressions.h\"\n #include \"sanitizer_common/sanitizer_report_decorator.h\"\n \n@@ -34,52 +34,17 @@ bool DisabledInThisThread() { return disable_counter > 0; }\n \n Flags lsan_flags;\n \n-static void InitializeFlags(bool standalone) {\n-  Flags *f = flags();\n-  // Default values.\n-  f->report_objects = false;\n-  f->resolution = 0;\n-  f->max_leaks = 0;\n-  f->exitcode = 23;\n-  f->use_registers = true;\n-  f->use_globals = true;\n-  f->use_stacks = true;\n-  f->use_tls = true;\n-  f->use_root_regions = true;\n-  f->use_unaligned = false;\n-  f->use_poisoned = false;\n-  f->log_pointers = false;\n-  f->log_threads = false;\n-\n-  const char *options = GetEnv(\"LSAN_OPTIONS\");\n-  if (options) {\n-    ParseFlag(options, &f->use_registers, \"use_registers\", \"\");\n-    ParseFlag(options, &f->use_globals, \"use_globals\", \"\");\n-    ParseFlag(options, &f->use_stacks, \"use_stacks\", \"\");\n-    ParseFlag(options, &f->use_tls, \"use_tls\", \"\");\n-    ParseFlag(options, &f->use_root_regions, \"use_root_regions\", \"\");\n-    ParseFlag(options, &f->use_unaligned, \"use_unaligned\", \"\");\n-    ParseFlag(options, &f->use_poisoned, \"use_poisoned\", \"\");\n-    ParseFlag(options, &f->report_objects, \"report_objects\", \"\");\n-    ParseFlag(options, &f->resolution, \"resolution\", \"\");\n-    CHECK_GE(&f->resolution, 0);\n-    ParseFlag(options, &f->max_leaks, \"max_leaks\", \"\");\n-    CHECK_GE(&f->max_leaks, 0);\n-    ParseFlag(options, &f->log_pointers, \"log_pointers\", \"\");\n-    ParseFlag(options, &f->log_threads, \"log_threads\", \"\");\n-    ParseFlag(options, &f->exitcode, \"exitcode\", \"\");\n-  }\n+void Flags::SetDefaults() {\n+#define LSAN_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n+#include \"lsan_flags.inc\"\n+#undef LSAN_FLAG\n+}\n \n-  // Set defaults for common flags (only in standalone mode) and parse\n-  // them from LSAN_OPTIONS.\n-  CommonFlags *cf = common_flags();\n-  if (standalone) {\n-    SetCommonFlagsDefaults(cf);\n-    cf->external_symbolizer_path = GetEnv(\"LSAN_SYMBOLIZER_PATH\");\n-    cf->malloc_context_size = 30;\n-    cf->detect_leaks = true;\n-  }\n-  ParseCommonFlagsFromString(cf, options);\n+void RegisterLsanFlags(FlagParser *parser, Flags *f) {\n+#define LSAN_FLAG(Type, Name, DefaultValue, Description) \\\n+  RegisterFlag(parser, #Name, Description, &f->Name);\n+#include \"lsan_flags.inc\"\n+#undef LSAN_FLAG\n }\n \n #define LOG_POINTERS(...)                           \\\n@@ -92,14 +57,23 @@ static void InitializeFlags(bool standalone) {\n     if (flags()->log_threads) Report(__VA_ARGS__); \\\n   } while (0);\n \n-static bool suppressions_inited = false;\n+ALIGNED(64) static char suppression_placeholder[sizeof(SuppressionContext)];\n+static SuppressionContext *suppression_ctx = nullptr;\n+static const char kSuppressionLeak[] = \"leak\";\n+static const char *kSuppressionTypes[] = { kSuppressionLeak };\n \n void InitializeSuppressions() {\n-  CHECK(!suppressions_inited);\n-  SuppressionContext::InitIfNecessary();\n+  CHECK_EQ(nullptr, suppression_ctx);\n+  suppression_ctx = new (suppression_placeholder) // NOLINT\n+      SuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n+  suppression_ctx->ParseFromFile(flags()->suppressions);\n   if (&__lsan_default_suppressions)\n-    SuppressionContext::Get()->Parse(__lsan_default_suppressions());\n-  suppressions_inited = true;\n+    suppression_ctx->Parse(__lsan_default_suppressions());\n+}\n+\n+static SuppressionContext *GetSuppressionContext() {\n+  CHECK(suppression_ctx);\n+  return suppression_ctx;\n }\n \n struct RootRegion {\n@@ -115,8 +89,7 @@ void InitializeRootRegions() {\n   root_regions = new(placeholder) InternalMmapVector<RootRegion>(1);\n }\n \n-void InitCommonLsan(bool standalone) {\n-  InitializeFlags(standalone);\n+void InitCommonLsan() {\n   InitializeRootRegions();\n   if (common_flags()->detect_leaks) {\n     // Initialization which can fail or print warnings should only be done if\n@@ -139,23 +112,26 @@ static inline bool CanBeAHeapPointer(uptr p) {\n   // bound on heap addresses.\n   const uptr kMinAddress = 4 * 4096;\n   if (p < kMinAddress) return false;\n-#ifdef __x86_64__\n+#if defined(__x86_64__)\n   // Accept only canonical form user-space addresses.\n   return ((p >> 47) == 0);\n+#elif defined(__mips64)\n+  return ((p >> 40) == 0);\n #else\n   return true;\n #endif\n }\n \n // Scans the memory range, looking for byte patterns that point into allocator\n // chunks. Marks those chunks with |tag| and adds them to |frontier|.\n-// There are two usage modes for this function: finding reachable or ignored\n-// chunks (|tag| = kReachable or kIgnored) and finding indirectly leaked chunks\n+// There are two usage modes for this function: finding reachable chunks\n+// (|tag| = kReachable) and finding indirectly leaked chunks\n // (|tag| = kIndirectlyLeaked). In the second case, there's no flood fill,\n // so |frontier| = 0.\n void ScanRangeForPointers(uptr begin, uptr end,\n                           Frontier *frontier,\n                           const char *region_type, ChunkTag tag) {\n+  CHECK(tag == kReachable || tag == kIndirectlyLeaked);\n   const uptr alignment = flags()->pointer_alignment();\n   LOG_POINTERS(\"Scanning %s range %p-%p.\\n\", region_type, begin, end);\n   uptr pp = begin;\n@@ -169,9 +145,7 @@ void ScanRangeForPointers(uptr begin, uptr end,\n     // Pointers to self don't count. This matters when tag == kIndirectlyLeaked.\n     if (chunk == begin) continue;\n     LsanMetadata m(chunk);\n-    // Reachable beats ignored beats leaked.\n-    if (m.tag() == kReachable) continue;\n-    if (m.tag() == kIgnored && tag != kReachable) continue;\n+    if (m.tag() == kReachable || m.tag() == kIgnored) continue;\n \n     // Do this check relatively late so we can log only the interesting cases.\n     if (!flags()->use_poisoned && WordIsPoisoned(pp)) {\n@@ -267,8 +241,8 @@ static void ProcessRootRegion(Frontier *frontier, uptr root_begin,\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n   uptr begin, end, prot;\n   while (proc_maps.Next(&begin, &end,\n-                        /*offset*/ 0, /*filename*/ 0, /*filename_size*/ 0,\n-                        &prot)) {\n+                        /*offset*/ nullptr, /*filename*/ nullptr,\n+                        /*filename_size*/ 0, &prot)) {\n     uptr intersection_begin = Max(root_begin, begin);\n     uptr intersection_end = Min(end, root_end);\n     if (intersection_begin >= intersection_end) continue;\n@@ -310,7 +284,7 @@ static void MarkIndirectlyLeakedCb(uptr chunk, void *arg) {\n   LsanMetadata m(chunk);\n   if (m.allocated() && m.tag() != kReachable) {\n     ScanRangeForPointers(chunk, chunk + m.requested_size(),\n-                         /* frontier */ 0, \"HEAP\", kIndirectlyLeaked);\n+                         /* frontier */ nullptr, \"HEAP\", kIndirectlyLeaked);\n   }\n }\n \n@@ -320,35 +294,45 @@ static void CollectIgnoredCb(uptr chunk, void *arg) {\n   CHECK(arg);\n   chunk = GetUserBegin(chunk);\n   LsanMetadata m(chunk);\n-  if (m.allocated() && m.tag() == kIgnored)\n+  if (m.allocated() && m.tag() == kIgnored) {\n+    LOG_POINTERS(\"Ignored: chunk %p-%p of size %zu.\\n\",\n+                 chunk, chunk + m.requested_size(), m.requested_size());\n     reinterpret_cast<Frontier *>(arg)->push_back(chunk);\n+  }\n }\n \n // Sets the appropriate tag on each chunk.\n static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n   // Holds the flood fill frontier.\n   Frontier frontier(1);\n \n+  ForEachChunk(CollectIgnoredCb, &frontier);\n   ProcessGlobalRegions(&frontier);\n   ProcessThreads(suspended_threads, &frontier);\n   ProcessRootRegions(&frontier);\n   FloodFillTag(&frontier, kReachable);\n+\n   // The check here is relatively expensive, so we do this in a separate flood\n   // fill. That way we can skip the check for chunks that are reachable\n   // otherwise.\n   LOG_POINTERS(\"Processing platform-specific allocations.\\n\");\n+  CHECK_EQ(0, frontier.size());\n   ProcessPlatformSpecificAllocations(&frontier);\n   FloodFillTag(&frontier, kReachable);\n \n-  LOG_POINTERS(\"Scanning ignored chunks.\\n\");\n-  CHECK_EQ(0, frontier.size());\n-  ForEachChunk(CollectIgnoredCb, &frontier);\n-  FloodFillTag(&frontier, kIgnored);\n-\n   // Iterate over leaked chunks and mark those that are reachable from other\n   // leaked chunks.\n   LOG_POINTERS(\"Scanning leaked chunks.\\n\");\n-  ForEachChunk(MarkIndirectlyLeakedCb, 0 /* arg */);\n+  ForEachChunk(MarkIndirectlyLeakedCb, nullptr);\n+}\n+\n+// ForEachChunk callback. Resets the tags to pre-leak-check state.\n+static void ResetTagsCb(uptr chunk, void *arg) {\n+  (void)arg;\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (m.allocated() && m.tag() != kIgnored)\n+    m.set_tag(kDirectlyLeaked);\n }\n \n static void PrintStackTraceById(u32 stack_trace_id) {\n@@ -365,7 +349,7 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n   LsanMetadata m(chunk);\n   if (!m.allocated()) return;\n   if (m.tag() == kDirectlyLeaked || m.tag() == kIndirectlyLeaked) {\n-    uptr resolution = flags()->resolution;\n+    u32 resolution = flags()->resolution;\n     u32 stack_trace_id = 0;\n     if (resolution > 0) {\n       StackTrace stack = StackDepotGet(m.stack_trace_id());\n@@ -381,48 +365,46 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n \n static void PrintMatchedSuppressions() {\n   InternalMmapVector<Suppression *> matched(1);\n-  SuppressionContext::Get()->GetMatched(&matched);\n+  GetSuppressionContext()->GetMatched(&matched);\n   if (!matched.size())\n     return;\n   const char *line = \"-----------------------------------------------------\";\n   Printf(\"%s\\n\", line);\n   Printf(\"Suppressions used:\\n\");\n   Printf(\"  count      bytes template\\n\");\n   for (uptr i = 0; i < matched.size(); i++)\n-    Printf(\"%7zu %10zu %s\\n\", static_cast<uptr>(matched[i]->hit_count),\n-           matched[i]->weight, matched[i]->templ);\n+    Printf(\"%7zu %10zu %s\\n\", static_cast<uptr>(atomic_load_relaxed(\n+        &matched[i]->hit_count)), matched[i]->weight, matched[i]->templ);\n   Printf(\"%s\\n\\n\", line);\n }\n \n-struct DoLeakCheckParam {\n+struct CheckForLeaksParam {\n   bool success;\n   LeakReport leak_report;\n };\n \n-static void DoLeakCheckCallback(const SuspendedThreadsList &suspended_threads,\n-                                void *arg) {\n-  DoLeakCheckParam *param = reinterpret_cast<DoLeakCheckParam *>(arg);\n+static void CheckForLeaksCallback(const SuspendedThreadsList &suspended_threads,\n+                                  void *arg) {\n+  CheckForLeaksParam *param = reinterpret_cast<CheckForLeaksParam *>(arg);\n   CHECK(param);\n   CHECK(!param->success);\n   ClassifyAllChunks(suspended_threads);\n   ForEachChunk(CollectLeaksCb, &param->leak_report);\n+  // Clean up for subsequent leak checks. This assumes we did not overwrite any\n+  // kIgnored tags.\n+  ForEachChunk(ResetTagsCb, nullptr);\n   param->success = true;\n }\n \n-void DoLeakCheck() {\n-  EnsureMainThreadIDIsCorrect();\n-  BlockingMutexLock l(&global_mutex);\n-  static bool already_done;\n-  if (already_done) return;\n-  already_done = true;\n+static bool CheckForLeaks() {\n   if (&__lsan_is_turned_off && __lsan_is_turned_off())\n-      return;\n-\n-  DoLeakCheckParam param;\n+      return false;\n+  EnsureMainThreadIDIsCorrect();\n+  CheckForLeaksParam param;\n   param.success = false;\n   LockThreadRegistry();\n   LockAllocator();\n-  StopTheWorld(DoLeakCheckCallback, &param);\n+  DoStopTheWorld(CheckForLeaksCallback, &param);\n   UnlockAllocator();\n   UnlockThreadRegistry();\n \n@@ -446,39 +428,51 @@ void DoLeakCheck() {\n     PrintMatchedSuppressions();\n   if (unsuppressed_count > 0) {\n     param.leak_report.PrintSummary();\n-    if (flags()->exitcode) {\n-      if (common_flags()->coverage)\n-        __sanitizer_cov_dump();\n-      internal__exit(flags()->exitcode);\n-    }\n+    return true;\n   }\n+  return false;\n+}\n+\n+void DoLeakCheck() {\n+  BlockingMutexLock l(&global_mutex);\n+  static bool already_done;\n+  if (already_done) return;\n+  already_done = true;\n+  bool have_leaks = CheckForLeaks();\n+  if (!have_leaks) {\n+    return;\n+  }\n+  if (common_flags()->exitcode) {\n+    Die();\n+  }\n+}\n+\n+static int DoRecoverableLeakCheck() {\n+  BlockingMutexLock l(&global_mutex);\n+  bool have_leaks = CheckForLeaks();\n+  return have_leaks ? 1 : 0;\n }\n \n static Suppression *GetSuppressionForAddr(uptr addr) {\n-  Suppression *s;\n+  Suppression *s = nullptr;\n \n   // Suppress by module name.\n-  const char *module_name;\n-  uptr module_offset;\n-  if (Symbolizer::GetOrInit()\n-          ->GetModuleNameAndOffsetForPC(addr, &module_name, &module_offset) &&\n-      SuppressionContext::Get()->Match(module_name, SuppressionLeak, &s))\n-    return s;\n+  SuppressionContext *suppressions = GetSuppressionContext();\n+  if (const char *module_name =\n+          Symbolizer::GetOrInit()->GetModuleNameForPc(addr))\n+    if (suppressions->Match(module_name, kSuppressionLeak, &s))\n+      return s;\n \n   // Suppress by file or function name.\n-  static const uptr kMaxAddrFrames = 16;\n-  InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n-  for (uptr i = 0; i < kMaxAddrFrames; i++) new (&addr_frames[i]) AddressInfo();\n-  uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n-      addr, addr_frames.data(), kMaxAddrFrames);\n-  for (uptr i = 0; i < addr_frames_num; i++) {\n-    if (SuppressionContext::Get()->Match(addr_frames[i].function,\n-                                         SuppressionLeak, &s) ||\n-        SuppressionContext::Get()->Match(addr_frames[i].file, SuppressionLeak,\n-                                         &s))\n-      return s;\n+  SymbolizedStack *frames = Symbolizer::GetOrInit()->SymbolizePC(addr);\n+  for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n+    if (suppressions->Match(cur->info.function, kSuppressionLeak, &s) ||\n+        suppressions->Match(cur->info.file, kSuppressionLeak, &s)) {\n+      break;\n+    }\n   }\n-  return 0;\n+  frames->ClearAll();\n+  return s;\n }\n \n static Suppression *GetSuppressionForStack(u32 stack_trace_id) {\n@@ -488,7 +482,7 @@ static Suppression *GetSuppressionForStack(u32 stack_trace_id) {\n         StackTrace::GetPreviousInstructionPc(stack.trace[i]));\n     if (s) return s;\n   }\n-  return 0;\n+  return nullptr;\n }\n \n ///// LeakReport implementation. /////\n@@ -591,10 +585,9 @@ void LeakReport::PrintSummary() {\n       bytes += leaks_[i].total_size;\n       allocations += leaks_[i].hit_count;\n   }\n-  InternalScopedBuffer<char> summary(kMaxSummaryLength);\n-  internal_snprintf(summary.data(), summary.size(),\n-                    \"%zu byte(s) leaked in %zu allocation(s).\", bytes,\n-                    allocations);\n+  InternalScopedString summary(kMaxSummaryLength);\n+  summary.append(\"%zu byte(s) leaked in %zu allocation(s).\", bytes,\n+                 allocations);\n   ReportErrorSummary(summary.data());\n }\n \n@@ -603,7 +596,8 @@ void LeakReport::ApplySuppressions() {\n     Suppression *s = GetSuppressionForStack(leaks_[i].stack_trace_id);\n     if (s) {\n       s->weight += leaks_[i].total_size;\n-      s->hit_count += leaks_[i].hit_count;\n+      atomic_store_relaxed(&s->hit_count, atomic_load_relaxed(&s->hit_count) +\n+          leaks_[i].hit_count);\n       leaks_[i].is_suppressed = true;\n     }\n   }\n@@ -616,8 +610,8 @@ uptr LeakReport::UnsuppressedLeakCount() {\n   return result;\n }\n \n-}  // namespace __lsan\n-#endif  // CAN_SANITIZE_LEAKS\n+} // namespace __lsan\n+#endif // CAN_SANITIZE_LEAKS\n \n using namespace __lsan;  // NOLINT\n \n@@ -638,7 +632,7 @@ void __lsan_ignore_object(const void *p) {\n            \"heap object at %p is already being ignored\\n\", p);\n   if (res == kIgnoreObjectSuccess)\n     VReport(1, \"__lsan_ignore_object(): ignoring heap object at %p\\n\", p);\n-#endif  // CAN_SANITIZE_LEAKS\n+#endif // CAN_SANITIZE_LEAKS\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n@@ -649,7 +643,7 @@ void __lsan_register_root_region(const void *begin, uptr size) {\n   RootRegion region = {begin, size};\n   root_regions->push_back(region);\n   VReport(1, \"Registered root region at %p of size %llu\\n\", begin, size);\n-#endif  // CAN_SANITIZE_LEAKS\n+#endif // CAN_SANITIZE_LEAKS\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n@@ -676,7 +670,7 @@ void __lsan_unregister_root_region(const void *begin, uptr size) {\n         begin, size);\n     Die();\n   }\n-#endif  // CAN_SANITIZE_LEAKS\n+#endif // CAN_SANITIZE_LEAKS\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n@@ -702,7 +696,16 @@ void __lsan_do_leak_check() {\n #if CAN_SANITIZE_LEAKS\n   if (common_flags()->detect_leaks)\n     __lsan::DoLeakCheck();\n-#endif  // CAN_SANITIZE_LEAKS\n+#endif // CAN_SANITIZE_LEAKS\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __lsan_do_recoverable_leak_check() {\n+#if CAN_SANITIZE_LEAKS\n+  if (common_flags()->detect_leaks)\n+    return __lsan::DoRecoverableLeakCheck();\n+#endif // CAN_SANITIZE_LEAKS\n+  return 0;\n }\n \n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n@@ -711,4 +714,4 @@ int __lsan_is_turned_off() {\n   return 0;\n }\n #endif\n-}  // extern \"C\"\n+} // extern \"C\""}, {"sha": "786a53b69f0ffc82f0778879b8289f83d0baee69", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -17,14 +17,20 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_platform.h\"\n+#include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n-#if SANITIZER_LINUX && defined(__x86_64__) && (SANITIZER_WORDSIZE == 64)\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips64)) \\\n+    && (SANITIZER_WORDSIZE == 64)\n #define CAN_SANITIZE_LEAKS 1\n #else\n #define CAN_SANITIZE_LEAKS 0\n #endif\n \n+namespace __sanitizer {\n+class FlagParser;\n+}\n+\n namespace __lsan {\n \n // Chunk tags.\n@@ -36,44 +42,19 @@ enum ChunkTag {\n };\n \n struct Flags {\n+#define LSAN_FLAG(Type, Name, DefaultValue, Description) Type Name;\n+#include \"lsan_flags.inc\"\n+#undef LSAN_FLAG\n+\n+  void SetDefaults();\n   uptr pointer_alignment() const {\n     return use_unaligned ? 1 : sizeof(uptr);\n   }\n-\n-  // Print addresses of leaked objects after main leak report.\n-  bool report_objects;\n-  // Aggregate two objects into one leak if this many stack frames match. If\n-  // zero, the entire stack trace must match.\n-  int resolution;\n-  // The number of leaks reported.\n-  int max_leaks;\n-  // If nonzero kill the process with this exit code upon finding leaks.\n-  int exitcode;\n-\n-  // Flags controlling the root set of reachable memory.\n-  // Global variables (.data and .bss).\n-  bool use_globals;\n-  // Thread stacks.\n-  bool use_stacks;\n-  // Thread registers.\n-  bool use_registers;\n-  // TLS and thread-specific storage.\n-  bool use_tls;\n-  // Regions added via __lsan_register_root_region().\n-  bool use_root_regions;\n-\n-  // Consider unaligned pointers valid.\n-  bool use_unaligned;\n-  // Consider pointers found in poisoned memory to be valid.\n-  bool use_poisoned;\n-\n-  // Debug logging.\n-  bool log_pointers;\n-  bool log_threads;\n };\n \n extern Flags lsan_flags;\n inline Flags *flags() { return &lsan_flags; }\n+void RegisterLsanFlags(FlagParser *parser, Flags *f);\n \n struct Leak {\n   u32 id;\n@@ -117,6 +98,8 @@ typedef InternalMmapVector<uptr> Frontier;\n void InitializePlatformSpecificModules();\n void ProcessGlobalRegions(Frontier *frontier);\n void ProcessPlatformSpecificAllocations(Frontier *frontier);\n+// Run stoptheworld while holding any platform-specific locks.\n+void DoStopTheWorld(StopTheWorldCallback callback, void* argument);\n \n void ScanRangeForPointers(uptr begin, uptr end,\n                           Frontier *frontier,\n@@ -129,7 +112,7 @@ enum IgnoreObjectResult {\n };\n \n // Functions called from the parent tool.\n-void InitCommonLsan(bool standalone);\n+void InitCommonLsan();\n void DoLeakCheck();\n bool DisabledInThisThread();\n "}, {"sha": "0456dce890a1d007a2073ee2f99a596879a71c9e", "filename": "libsanitizer/lsan/lsan_common_linux.cc", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_common_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_common_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -27,7 +27,7 @@ static const char kLinkerName[] = \"ld\";\n // We request 2 modules matching \"ld\", so we can print a warning if there's more\n // than one match. But only the first one is actually used.\n static char linker_placeholder[2 * sizeof(LoadedModule)] ALIGNED(64);\n-static LoadedModule *linker = 0;\n+static LoadedModule *linker = nullptr;\n \n static bool IsLinker(const char* full_name) {\n   return LibraryNameIs(full_name, kLinkerName);\n@@ -47,7 +47,7 @@ void InitializePlatformSpecificModules() {\n   else if (num_matches > 1)\n     VReport(1, \"LeakSanitizer: Multiple modules match \\\"%s\\\". \"\n             \"TLS will not be handled correctly.\\n\", kLinkerName);\n-  linker = 0;\n+  linker = nullptr;\n }\n \n static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n@@ -83,10 +83,6 @@ static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n // Scans global variables for heap pointers.\n void ProcessGlobalRegions(Frontier *frontier) {\n   if (!flags()->use_globals) return;\n-  // FIXME: dl_iterate_phdr acquires a linker lock, so we run a risk of\n-  // deadlocking by running this under StopTheWorld. However, the lock is\n-  // reentrant, so we should be able to fix this by acquiring the lock before\n-  // suspending threads.\n   dl_iterate_phdr(ProcessGlobalRegionsCallback, frontier);\n }\n \n@@ -112,7 +108,7 @@ static void ProcessPlatformSpecificAllocationsCb(uptr chunk, void *arg) {\n       reinterpret_cast<ProcessPlatformAllocParam *>(arg);\n   chunk = GetUserBegin(chunk);\n   LsanMetadata m(chunk);\n-  if (m.allocated() && m.tag() != kReachable) {\n+  if (m.allocated() && m.tag() != kReachable && m.tag() != kIgnored) {\n     u32 stack_id = m.stack_trace_id();\n     uptr caller_pc = 0;\n     if (stack_id > 0)\n@@ -151,5 +147,31 @@ void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n   ForEachChunk(ProcessPlatformSpecificAllocationsCb, &arg);\n }\n \n-}  // namespace __lsan\n-#endif  // CAN_SANITIZE_LEAKS && SANITIZER_LINUX\n+struct DoStopTheWorldParam {\n+  StopTheWorldCallback callback;\n+  void *argument;\n+};\n+\n+static int DoStopTheWorldCallback(struct dl_phdr_info *info, size_t size,\n+                                  void *data) {\n+  DoStopTheWorldParam *param = reinterpret_cast<DoStopTheWorldParam *>(data);\n+  StopTheWorld(param->callback, param->argument);\n+  return 1;\n+}\n+\n+// LSan calls dl_iterate_phdr() from the tracer task. This may deadlock: if one\n+// of the threads is frozen while holding the libdl lock, the tracer will hang\n+// in dl_iterate_phdr() forever.\n+// Luckily, (a) the lock is reentrant and (b) libc can't distinguish between the\n+// tracer task and the thread that spawned it. Thus, if we run the tracer task\n+// while holding the libdl lock in the parent thread, we can safely reenter it\n+// in the tracer. The solution is to run stoptheworld from a dl_iterate_phdr()\n+// callback in the parent thread.\n+void DoStopTheWorld(StopTheWorldCallback callback, void *argument) {\n+  DoStopTheWorldParam param = {callback, argument};\n+  dl_iterate_phdr(DoStopTheWorldCallback, &param);\n+}\n+\n+} // namespace __lsan\n+\n+#endif // CAN_SANITIZE_LEAKS && SANITIZER_LINUX"}, {"sha": "73a980e17249d10d839aa03f1ac8e3c96b751aa8", "filename": "libsanitizer/lsan/lsan_flags.inc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_flags.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,41 @@\n+//===-- lsan_flags.inc ------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// LSan runtime flags.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef LSAN_FLAG\n+# error \"Define LSAN_FLAG prior to including this file!\"\n+#endif\n+\n+// LSAN_FLAG(Type, Name, DefaultValue, Description)\n+// See COMMON_FLAG in sanitizer_flags.inc for more details.\n+\n+LSAN_FLAG(bool, report_objects, false,\n+          \"Print addresses of leaked objects after main leak report.\")\n+LSAN_FLAG(\n+    int, resolution, 0,\n+    \"Aggregate two objects into one leak if this many stack frames match. If \"\n+    \"zero, the entire stack trace must match.\")\n+LSAN_FLAG(int, max_leaks, 0, \"The number of leaks reported.\")\n+\n+// Flags controlling the root set of reachable memory.\n+LSAN_FLAG(bool, use_globals, true,\n+          \"Root set: include global variables (.data and .bss)\")\n+LSAN_FLAG(bool, use_stacks, true, \"Root set: include thread stacks\")\n+LSAN_FLAG(bool, use_registers, true, \"Root set: include thread registers\")\n+LSAN_FLAG(bool, use_tls, true,\n+          \"Root set: include TLS and thread-specific storage\")\n+LSAN_FLAG(bool, use_root_regions, true,\n+          \"Root set: include regions added via __lsan_register_root_region().\")\n+\n+LSAN_FLAG(bool, use_unaligned, false, \"Consider unaligned pointers valid.\")\n+LSAN_FLAG(bool, use_poisoned, false,\n+          \"Consider pointers found in poisoned memory to be valid.\")\n+LSAN_FLAG(bool, log_pointers, false, \"Debug logging\")\n+LSAN_FLAG(bool, log_threads, false, \"Debug logging\")\n+LSAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")"}, {"sha": "57581e855c44418d55303cc513b1d09a0c954a26", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -10,11 +10,11 @@\n //\n //===----------------------------------------------------------------------===//\n \n+#include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n-#include \"sanitizer_common/sanitizer_interception.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_linux.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n@@ -69,7 +69,7 @@ INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n     CHECK(allocated < kCallocPoolSize);\n     return mem;\n   }\n-  if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n+  if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return nullptr;\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n   size *= nmemb;\n@@ -162,9 +162,9 @@ void *operator new[](uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n   Deallocate(ptr);\n \n INTERCEPTOR_ATTRIBUTE\n-void operator delete(void *ptr) throw() { OPERATOR_DELETE_BODY; }\n+void operator delete(void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n-void operator delete[](void *ptr) throw() { OPERATOR_DELETE_BODY; }\n+void operator delete[](void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n void operator delete(void *ptr, std::nothrow_t const&) { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n@@ -206,16 +206,16 @@ extern \"C\" void *__lsan_thread_start_func(void *arg) {\n   // Wait until the last iteration to maximize the chance that we are the last\n   // destructor to run.\n   if (pthread_setspecific(g_thread_finalize_key,\n-                          (void*)kPthreadDestructorIterations)) {\n+                          (void*)GetPthreadDestructorIterations())) {\n     Report(\"LeakSanitizer: failed to set thread key.\\n\");\n     Die();\n   }\n   int tid = 0;\n   while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n     internal_sched_yield();\n-  atomic_store(&p->tid, 0, memory_order_release);\n   SetCurrentThread(tid);\n   ThreadStart(tid, GetTid());\n+  atomic_store(&p->tid, 0, memory_order_release);\n   return callback(param);\n }\n \n@@ -224,7 +224,7 @@ INTERCEPTOR(int, pthread_create, void *th, void *attr,\n   ENSURE_LSAN_INITED;\n   EnsureMainThreadIDIsCorrect();\n   __sanitizer_pthread_attr_t myattr;\n-  if (attr == 0) {\n+  if (!attr) {\n     pthread_attr_init(&myattr);\n     attr = &myattr;\n   }\n@@ -282,4 +282,4 @@ void InitializeInterceptors() {\n   }\n }\n \n-}  // namespace __lsan\n+} // namespace __lsan"}, {"sha": "1313ea2dce13ae11698cbdca54a24e91a37463f8", "filename": "libsanitizer/lsan/lsan_thread.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -77,7 +77,7 @@ void ThreadContext::OnFinished() {\n \n u32 ThreadCreate(u32 parent_tid, uptr user_id, bool detached) {\n   return thread_registry->CreateThread(user_id, detached, parent_tid,\n-                                       /* arg */ 0);\n+                                       /* arg */ nullptr);\n }\n \n void ThreadStart(u32 tid, uptr os_id) {\n@@ -97,9 +97,9 @@ void ThreadFinish() {\n }\n \n ThreadContext *CurrentThreadContext() {\n-  if (!thread_registry) return 0;\n+  if (!thread_registry) return nullptr;\n   if (GetCurrentThread() == kInvalidTid)\n-    return 0;\n+    return nullptr;\n   // No lock needed when getting current thread.\n   return (ThreadContext *)thread_registry->GetThreadLocked(GetCurrentThread());\n }\n@@ -118,7 +118,7 @@ u32 ThreadTid(uptr uid) {\n \n void ThreadJoin(u32 tid) {\n   CHECK_NE(tid, kInvalidTid);\n-  thread_registry->JoinThread(tid, /* arg */0);\n+  thread_registry->JoinThread(tid, /* arg */nullptr);\n }\n \n void EnsureMainThreadIDIsCorrect() {\n@@ -155,4 +155,4 @@ void UnlockThreadRegistry() {\n   thread_registry->Unlock();\n }\n \n-}  // namespace __lsan\n+} // namespace __lsan"}, {"sha": "70c3ff926168bec3f835426adf8638a768eef518", "filename": "libsanitizer/lsan/lsan_thread.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Flsan%2Flsan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -20,8 +20,8 @@ namespace __lsan {\n class ThreadContext : public ThreadContextBase {\n  public:\n   explicit ThreadContext(int tid);\n-  void OnStarted(void *arg);\n-  void OnFinished();\n+  void OnStarted(void *arg) override;\n+  void OnFinished() override;\n   uptr stack_begin() { return stack_begin_; }\n   uptr stack_end() { return stack_end_; }\n   uptr tls_begin() { return tls_begin_; }"}, {"sha": "ee7a3f1dd2c5779b00a4c85fa18b95c7a187ade1", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -27,6 +27,7 @@ sanitizer_common_files = \\\n \tsanitizer_deadlock_detector1.cc \\\n \tsanitizer_deadlock_detector2.cc \\\n \tsanitizer_flags.cc \\\n+\tsanitizer_flag_parser.cc \\\n \tsanitizer_libc.cc \\\n \tsanitizer_libignore.cc \\\n \tsanitizer_linux.cc \\\n@@ -45,6 +46,7 @@ sanitizer_common_files = \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n \tsanitizer_stacktrace_libcdep.cc \\\n+\tsanitizer_symbolizer_mac.cc \\\n \tsanitizer_stacktrace_printer.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n@@ -55,7 +57,7 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_win.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_tls_get_addr.cc \\\n-\tsanitizer_unwind_posix_libcdep.cc \\\n+\tsanitizer_unwind_linux_libcdep.cc \\\n \tsanitizer_win.cc\n \n "}, {"sha": "4b008ad7ae6217bae274b2578d5de62df17a7fa6", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -85,7 +85,8 @@ am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_coverage_mapping_libcdep.lo \\\n \tsanitizer_deadlock_detector1.lo \\\n \tsanitizer_deadlock_detector2.lo sanitizer_flags.lo \\\n-\tsanitizer_libc.lo sanitizer_libignore.lo sanitizer_linux.lo \\\n+\tsanitizer_flag_parser.lo sanitizer_libc.lo \\\n+\tsanitizer_libignore.lo sanitizer_linux.lo \\\n \tsanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n \tsanitizer_persistent_allocator.lo \\\n \tsanitizer_platform_limits_linux.lo \\\n@@ -94,15 +95,15 @@ am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_procmaps_common.lo sanitizer_procmaps_freebsd.lo \\\n \tsanitizer_procmaps_linux.lo sanitizer_procmaps_mac.lo \\\n \tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n-\tsanitizer_stacktrace_libcdep.lo \\\n+\tsanitizer_stacktrace_libcdep.lo sanitizer_symbolizer_mac.lo \\\n \tsanitizer_stacktrace_printer.lo \\\n \tsanitizer_stoptheworld_linux_libcdep.lo \\\n \tsanitizer_suppressions.lo sanitizer_symbolizer.lo \\\n \tsanitizer_symbolizer_libbacktrace.lo \\\n \tsanitizer_symbolizer_libcdep.lo \\\n \tsanitizer_symbolizer_posix_libcdep.lo \\\n \tsanitizer_symbolizer_win.lo sanitizer_thread_registry.lo \\\n-\tsanitizer_tls_get_addr.lo sanitizer_unwind_posix_libcdep.lo \\\n+\tsanitizer_tls_get_addr.lo sanitizer_unwind_linux_libcdep.lo \\\n \tsanitizer_win.lo\n am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n@@ -290,6 +291,7 @@ sanitizer_common_files = \\\n \tsanitizer_deadlock_detector1.cc \\\n \tsanitizer_deadlock_detector2.cc \\\n \tsanitizer_flags.cc \\\n+\tsanitizer_flag_parser.cc \\\n \tsanitizer_libc.cc \\\n \tsanitizer_libignore.cc \\\n \tsanitizer_linux.cc \\\n@@ -308,6 +310,7 @@ sanitizer_common_files = \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n \tsanitizer_stacktrace_libcdep.cc \\\n+\tsanitizer_symbolizer_mac.cc \\\n \tsanitizer_stacktrace_printer.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n@@ -318,7 +321,7 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_win.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_tls_get_addr.cc \\\n-\tsanitizer_unwind_posix_libcdep.cc \\\n+\tsanitizer_unwind_linux_libcdep.cc \\\n \tsanitizer_win.cc\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n@@ -421,6 +424,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_mapping_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flag_parser.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libignore.Plo@am__quote@\n@@ -446,11 +450,12 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_tls_get_addr.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_posix_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_linux_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@\n \n .cc.o:"}, {"sha": "3bc40ef64f010220ea9c8475560947ad201f903e", "filename": "libsanitizer/sanitizer_common/sanitizer_addrhashmap.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -141,7 +141,7 @@ bool AddrHashMap<T, kSize>::Handle::created() const {\n \n template<typename T, uptr kSize>\n bool AddrHashMap<T, kSize>::Handle::exists() const {\n-  return cell_ != 0;\n+  return cell_ != nullptr;\n }\n \n template<typename T, uptr kSize>\n@@ -158,7 +158,7 @@ void AddrHashMap<T, kSize>::acquire(Handle *h) {\n   h->created_ = false;\n   h->addidx_ = -1U;\n   h->bucket_ = b;\n-  h->cell_ = 0;\n+  h->cell_ = nullptr;\n \n   // If we want to remove the element, we need exclusive access to the bucket,\n   // so skip the lock-free phase.\n@@ -248,7 +248,7 @@ void AddrHashMap<T, kSize>::acquire(Handle *h) {\n   }\n \n   // Store in the add cells.\n-  if (add == 0) {\n+  if (!add) {\n     // Allocate a new add array.\n     const uptr kInitSize = 64;\n     add = (AddBucket*)InternalAlloc(kInitSize);\n@@ -280,7 +280,7 @@ void AddrHashMap<T, kSize>::acquire(Handle *h) {\n \n template<typename T, uptr kSize>\n void AddrHashMap<T, kSize>::release(Handle *h) {\n-  if (h->cell_ == 0)\n+  if (!h->cell_)\n     return;\n   Bucket *b = h->bucket_;\n   Cell *c = h->cell_;"}, {"sha": "b5e0bab91f15d08bda730af0b6548c6a7f98d217", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,10 +9,10 @@\n // run-time libraries.\n // This allocator is used inside run-times.\n //===----------------------------------------------------------------------===//\n+\n #include \"sanitizer_allocator.h\"\n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_common.h\"\n-#include \"sanitizer_flags.h\"\n \n namespace __sanitizer {\n \n@@ -43,7 +43,7 @@ InternalAllocator *internal_allocator() {\n   return 0;\n }\n \n-#else  // SANITIZER_GO\n+#else // SANITIZER_GO\n \n static ALIGNED(64) char internal_alloc_placeholder[sizeof(InternalAllocator)];\n static atomic_uint8_t internal_allocator_initialized;\n@@ -59,7 +59,7 @@ InternalAllocator *internal_allocator() {\n     SpinMutexLock l(&internal_alloc_init_mu);\n     if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==\n         0) {\n-      internal_allocator_instance->Init();\n+      internal_allocator_instance->Init(/* may_return_null*/ false);\n       atomic_store(&internal_allocator_initialized, 1, memory_order_release);\n     }\n   }\n@@ -76,29 +76,29 @@ static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache) {\n }\n \n static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n-  if (cache == 0) {\n+  if (!cache) {\n     SpinMutexLock l(&internal_allocator_cache_mu);\n     return internal_allocator()->Deallocate(&internal_allocator_cache, ptr);\n   }\n   internal_allocator()->Deallocate(cache, ptr);\n }\n \n-#endif  // SANITIZER_GO\n+#endif // SANITIZER_GO\n \n const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;\n \n void *InternalAlloc(uptr size, InternalAllocatorCache *cache) {\n   if (size + sizeof(u64) < size)\n-    return 0;\n+    return nullptr;\n   void *p = RawInternalAlloc(size + sizeof(u64), cache);\n-  if (p == 0)\n-    return 0;\n+  if (!p)\n+    return nullptr;\n   ((u64*)p)[0] = kBlockMagic;\n   return (char*)p + sizeof(u64);\n }\n \n void InternalFree(void *addr, InternalAllocatorCache *cache) {\n-  if (addr == 0)\n+  if (!addr)\n     return;\n   addr = (char*)addr - sizeof(u64);\n   CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);\n@@ -138,14 +138,12 @@ bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n) {\n   return (max / size) < n;\n }\n \n-void *AllocatorReturnNull() {\n-  if (common_flags()->allocator_may_return_null)\n-    return 0;\n+void NORETURN ReportAllocatorCannotReturnNull() {\n   Report(\"%s's allocator is terminating the process instead of returning 0\\n\",\n          SanitizerToolName);\n   Report(\"If you don't like this behavior set allocator_may_return_null=1\\n\");\n   CHECK(0);\n-  return 0;\n+  Die();\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer"}, {"sha": "d98528c722ca8cc8c30e304e7b5023341cb1e297", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 94, "deletions": 28, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -21,8 +21,8 @@\n \n namespace __sanitizer {\n \n-// Depending on allocator_may_return_null either return 0 or crash.\n-void *AllocatorReturnNull();\n+// Prints error message and kills the program.\n+void NORETURN ReportAllocatorCannotReturnNull();\n \n // SizeClassMap maps allocation sizes into size classes and back.\n // Class 0 corresponds to size 0.\n@@ -209,6 +209,7 @@ class AllocatorStats {\n   void Init() {\n     internal_memset(this, 0, sizeof(*this));\n   }\n+  void InitLinkerInitialized() {}\n \n   void Add(AllocatorStat i, uptr v) {\n     v += atomic_load(&stats_[i], memory_order_relaxed);\n@@ -238,11 +239,14 @@ class AllocatorStats {\n // Global stats, used for aggregation and querying.\n class AllocatorGlobalStats : public AllocatorStats {\n  public:\n-  void Init() {\n-    internal_memset(this, 0, sizeof(*this));\n+  void InitLinkerInitialized() {\n     next_ = this;\n     prev_ = this;\n   }\n+  void Init() {\n+    internal_memset(this, 0, sizeof(*this));\n+    InitLinkerInitialized();\n+  }\n \n   void Register(AllocatorStats *s) {\n     SpinMutexLock l(&mu_);\n@@ -317,7 +321,7 @@ class SizeClassAllocator64 {\n \n   void Init() {\n     CHECK_EQ(kSpaceBeg,\n-             reinterpret_cast<uptr>(Mprotect(kSpaceBeg, kSpaceSize)));\n+             reinterpret_cast<uptr>(MmapNoAccess(kSpaceBeg, kSpaceSize)));\n     MapWithCallback(kSpaceEnd, AdditionalSize());\n   }\n \n@@ -341,7 +345,7 @@ class SizeClassAllocator64 {\n     CHECK_LT(class_id, kNumClasses);\n     RegionInfo *region = GetRegionInfo(class_id);\n     Batch *b = region->free_list.Pop();\n-    if (b == 0)\n+    if (!b)\n       b = PopulateFreeList(stat, c, class_id, region);\n     region->n_allocated += b->count;\n     return b;\n@@ -365,16 +369,16 @@ class SizeClassAllocator64 {\n   void *GetBlockBegin(const void *p) {\n     uptr class_id = GetSizeClass(p);\n     uptr size = SizeClassMap::Size(class_id);\n-    if (!size) return 0;\n+    if (!size) return nullptr;\n     uptr chunk_idx = GetChunkIdx((uptr)p, size);\n     uptr reg_beg = (uptr)p & ~(kRegionSize - 1);\n     uptr beg = chunk_idx * size;\n     uptr next_beg = beg + size;\n-    if (class_id >= kNumClasses) return 0;\n+    if (class_id >= kNumClasses) return nullptr;\n     RegionInfo *region = GetRegionInfo(class_id);\n     if (region->mapped_user >= next_beg)\n       return reinterpret_cast<void*>(reg_beg + beg);\n-    return 0;\n+    return nullptr;\n   }\n \n   static uptr GetActuallyAllocatedSize(void *p) {\n@@ -603,6 +607,7 @@ class TwoLevelByteMap {\n     internal_memset(map1_, 0, sizeof(map1_));\n     mu_.Init();\n   }\n+\n   void TestOnlyUnmap() {\n     for (uptr i = 0; i < kSize1; i++) {\n       u8 *p = Get(i);\n@@ -816,6 +821,10 @@ class SizeClassAllocator32 {\n   void PrintStats() {\n   }\n \n+  static uptr AdditionalSize() {\n+    return 0;\n+  }\n+\n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n \n@@ -862,9 +871,9 @@ class SizeClassAllocator32 {\n     uptr reg = AllocateRegion(stat, class_id);\n     uptr n_chunks = kRegionSize / (size + kMetadataSize);\n     uptr max_count = SizeClassMap::MaxCached(class_id);\n-    Batch *b = 0;\n+    Batch *b = nullptr;\n     for (uptr i = reg; i < reg + n_chunks * size; i += size) {\n-      if (b == 0) {\n+      if (!b) {\n         if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n           b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));\n         else\n@@ -875,7 +884,7 @@ class SizeClassAllocator32 {\n       if (b->count == max_count) {\n         CHECK_GT(b->count, 0);\n         sci->free_list.push_back(b);\n-        b = 0;\n+        b = nullptr;\n       }\n     }\n     if (b) {\n@@ -1000,17 +1009,24 @@ struct SizeClassAllocatorLocalCache {\n template <class MapUnmapCallback = NoOpMapUnmapCallback>\n class LargeMmapAllocator {\n  public:\n-  void Init() {\n-    internal_memset(this, 0, sizeof(*this));\n+  void InitLinkerInitialized(bool may_return_null) {\n     page_size_ = GetPageSizeCached();\n+    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n+  }\n+\n+  void Init(bool may_return_null) {\n+    internal_memset(this, 0, sizeof(*this));\n+    InitLinkerInitialized(may_return_null);\n   }\n \n   void *Allocate(AllocatorStats *stat, uptr size, uptr alignment) {\n     CHECK(IsPowerOfTwo(alignment));\n     uptr map_size = RoundUpMapSize(size);\n     if (alignment > page_size_)\n       map_size += alignment;\n-    if (map_size < size) return AllocatorReturnNull();  // Overflow.\n+    // Overflow.\n+    if (map_size < size)\n+      return ReturnNullOrDie();\n     uptr map_beg = reinterpret_cast<uptr>(\n         MmapOrDie(map_size, \"LargeMmapAllocator\"));\n     CHECK(IsAligned(map_beg, page_size_));\n@@ -1046,6 +1062,16 @@ class LargeMmapAllocator {\n     return reinterpret_cast<void*>(res);\n   }\n \n+  void *ReturnNullOrDie() {\n+    if (atomic_load(&may_return_null_, memory_order_acquire))\n+      return nullptr;\n+    ReportAllocatorCannotReturnNull();\n+  }\n+\n+  void SetMayReturnNull(bool may_return_null) {\n+    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n+  }\n+\n   void Deallocate(AllocatorStats *stat, void *p) {\n     Header *h = GetHeader(p);\n     {\n@@ -1078,7 +1104,7 @@ class LargeMmapAllocator {\n   }\n \n   bool PointerIsMine(const void *p) {\n-    return GetBlockBegin(p) != 0;\n+    return GetBlockBegin(p) != nullptr;\n   }\n \n   uptr GetActuallyAllocatedSize(void *p) {\n@@ -1107,13 +1133,13 @@ class LargeMmapAllocator {\n         nearest_chunk = ch;\n     }\n     if (!nearest_chunk)\n-      return 0;\n+      return nullptr;\n     Header *h = reinterpret_cast<Header *>(nearest_chunk);\n     CHECK_GE(nearest_chunk, h->map_beg);\n     CHECK_LT(nearest_chunk, h->map_beg + h->map_size);\n     CHECK_LE(nearest_chunk, p);\n     if (h->map_beg + h->map_size <= p)\n-      return 0;\n+      return nullptr;\n     return GetUser(h);\n   }\n \n@@ -1123,7 +1149,7 @@ class LargeMmapAllocator {\n     mutex_.CheckLocked();\n     uptr p = reinterpret_cast<uptr>(ptr);\n     uptr n = n_chunks_;\n-    if (!n) return 0;\n+    if (!n) return nullptr;\n     if (!chunks_sorted_) {\n       // Do one-time sort. chunks_sorted_ is reset in Allocate/Deallocate.\n       SortArray(reinterpret_cast<uptr*>(chunks_), n);\n@@ -1135,7 +1161,7 @@ class LargeMmapAllocator {\n           chunks_[n - 1]->map_size;\n     }\n     if (p < min_mmap_ || p >= max_mmap_)\n-      return 0;\n+      return nullptr;\n     uptr beg = 0, end = n - 1;\n     // This loop is a log(n) lower_bound. It does not check for the exact match\n     // to avoid expensive cache-thrashing loads.\n@@ -1156,7 +1182,7 @@ class LargeMmapAllocator {\n \n     Header *h = chunks_[beg];\n     if (h->map_beg + h->map_size <= p || p < h->map_beg)\n-      return 0;\n+      return nullptr;\n     return GetUser(h);\n   }\n \n@@ -1224,6 +1250,7 @@ class LargeMmapAllocator {\n   struct Stats {\n     uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n   } stats;\n+  atomic_uint8_t may_return_null_;\n   SpinMutex mutex_;\n };\n \n@@ -1237,19 +1264,32 @@ template <class PrimaryAllocator, class AllocatorCache,\n           class SecondaryAllocator>  // NOLINT\n class CombinedAllocator {\n  public:\n-  void Init() {\n+  void InitCommon(bool may_return_null) {\n     primary_.Init();\n-    secondary_.Init();\n+    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n+  }\n+\n+  void InitLinkerInitialized(bool may_return_null) {\n+    secondary_.InitLinkerInitialized(may_return_null);\n+    stats_.InitLinkerInitialized();\n+    InitCommon(may_return_null);\n+  }\n+\n+  void Init(bool may_return_null) {\n+    secondary_.Init(may_return_null);\n     stats_.Init();\n+    InitCommon(may_return_null);\n   }\n \n   void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,\n-                 bool cleared = false) {\n+                 bool cleared = false, bool check_rss_limit = false) {\n     // Returning 0 on malloc(0) may break a lot of code.\n     if (size == 0)\n       size = 1;\n     if (size + alignment < size)\n-      return AllocatorReturnNull();\n+      return ReturnNullOrDie();\n+    if (check_rss_limit && RssLimitIsExceeded())\n+      return ReturnNullOrDie();\n     if (alignment > 8)\n       size = RoundUpTo(size, alignment);\n     void *res;\n@@ -1265,6 +1305,30 @@ class CombinedAllocator {\n     return res;\n   }\n \n+  bool MayReturnNull() const {\n+    return atomic_load(&may_return_null_, memory_order_acquire);\n+  }\n+\n+  void *ReturnNullOrDie() {\n+    if (MayReturnNull())\n+      return nullptr;\n+    ReportAllocatorCannotReturnNull();\n+  }\n+\n+  void SetMayReturnNull(bool may_return_null) {\n+    secondary_.SetMayReturnNull(may_return_null);\n+    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n+  }\n+\n+  bool RssLimitIsExceeded() {\n+    return atomic_load(&rss_limit_is_exceeded_, memory_order_acquire);\n+  }\n+\n+  void SetRssLimitIsExceeded(bool rss_limit_is_exceeded) {\n+    atomic_store(&rss_limit_is_exceeded_, rss_limit_is_exceeded,\n+                 memory_order_release);\n+  }\n+\n   void Deallocate(AllocatorCache *cache, void *p) {\n     if (!p) return;\n     if (primary_.PointerIsMine(p))\n@@ -1279,7 +1343,7 @@ class CombinedAllocator {\n       return Allocate(cache, new_size, alignment);\n     if (!new_size) {\n       Deallocate(cache, p);\n-      return 0;\n+      return nullptr;\n     }\n     CHECK(PointerIsMine(p));\n     uptr old_size = GetActuallyAllocatedSize(p);\n@@ -1377,11 +1441,13 @@ class CombinedAllocator {\n   PrimaryAllocator primary_;\n   SecondaryAllocator secondary_;\n   AllocatorGlobalStats stats_;\n+  atomic_uint8_t may_return_null_;\n+  atomic_uint8_t rss_limit_is_exceeded_;\n };\n \n // Returns true if calloc(size, n) should return 0 due to overflow in size*n.\n bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n);\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_ALLOCATOR_H\n+#endif // SANITIZER_ALLOCATOR_H"}, {"sha": "99d8516d8cf220e3b7b98125773ab2f80ee9c4f3", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -1,4 +1,4 @@\n-//===-- sanitizer_allocator_internal.h -------------------------- C++ -----===//\n+//===-- sanitizer_allocator_internal.h --------------------------*- C++ -*-===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n@@ -43,10 +43,19 @@ typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n typedef CombinedAllocator<PrimaryInternalAllocator, InternalAllocatorCache,\n                           LargeMmapAllocator<> > InternalAllocator;\n \n-void *InternalAlloc(uptr size, InternalAllocatorCache *cache = 0);\n-void InternalFree(void *p, InternalAllocatorCache *cache = 0);\n+void *InternalAlloc(uptr size, InternalAllocatorCache *cache = nullptr);\n+void InternalFree(void *p, InternalAllocatorCache *cache = nullptr);\n InternalAllocator *internal_allocator();\n \n-}  // namespace __sanitizer\n+enum InternalAllocEnum {\n+  INTERNAL_ALLOC\n+};\n \n-#endif  // SANITIZER_ALLOCATOR_INTERNAL_H\n+} // namespace __sanitizer\n+\n+inline void *operator new(__sanitizer::operator_new_size_type size,\n+                          InternalAllocEnum) {\n+  return InternalAlloc(size);\n+}\n+\n+#endif // SANITIZER_ALLOCATOR_INTERNAL_H"}, {"sha": "4973b7d4e88be6f15f2867b646b2c5417e19e730", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -53,12 +53,28 @@ struct atomic_uintptr_t {\n \n }  // namespace __sanitizer\n \n-#if defined(__GNUC__)\n+#if defined(__clang__) || defined(__GNUC__)\n # include \"sanitizer_atomic_clang.h\"\n #elif defined(_MSC_VER)\n # include \"sanitizer_atomic_msvc.h\"\n #else\n # error \"Unsupported compiler\"\n #endif\n \n+namespace __sanitizer {\n+\n+// Clutter-reducing helpers.\n+\n+template<typename T>\n+INLINE typename T::Type atomic_load_relaxed(const volatile T *a) {\n+  return atomic_load(a, memory_order_relaxed);\n+}\n+\n+template<typename T>\n+INLINE void atomic_store_relaxed(volatile T *a, typename T::Type v) {\n+  atomic_store(a, v, memory_order_relaxed);\n+}\n+\n+}  // namespace __sanitizer\n+\n #endif  // SANITIZER_ATOMIC_H"}, {"sha": "4ac3b90769f25e8de10c3f40567a00591ef57a7a", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -19,6 +19,15 @@ extern \"C\" void _mm_mfence();\n #pragma intrinsic(_mm_mfence)\n extern \"C\" void _mm_pause();\n #pragma intrinsic(_mm_pause)\n+extern \"C\" char _InterlockedExchange8(   // NOLINT\n+    char volatile *Addend, char Value);  // NOLINT\n+#pragma intrinsic(_InterlockedExchange8)\n+extern \"C\" short _InterlockedExchange16(   // NOLINT\n+    short volatile *Addend, short Value);  // NOLINT\n+#pragma intrinsic(_InterlockedExchange16)\n+extern \"C\" long _InterlockedExchange(    // NOLINT\n+    long volatile *Addend, long Value);  // NOLINT\n+#pragma intrinsic(_InterlockedExchange)\n extern \"C\" long _InterlockedExchangeAdd(  // NOLINT\n     long volatile * Addend, long Value);  // NOLINT\n #pragma intrinsic(_InterlockedExchangeAdd)\n@@ -143,28 +152,25 @@ INLINE u8 atomic_exchange(volatile atomic_uint8_t *a,\n     u8 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n-  __asm {\n-    mov eax, a\n-    mov cl, v\n-    xchg [eax], cl  // NOLINT\n-    mov v, cl\n-  }\n-  return v;\n+  return (u8)_InterlockedExchange8((volatile char*)&a->val_dont_use, v);\n }\n \n INLINE u16 atomic_exchange(volatile atomic_uint16_t *a,\n     u16 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n-  __asm {\n-    mov eax, a\n-    mov cx, v\n-    xchg [eax], cx  // NOLINT\n-    mov v, cx\n-  }\n-  return v;\n+  return (u16)_InterlockedExchange16((volatile short*)&a->val_dont_use, v);\n+}\n+\n+INLINE u32 atomic_exchange(volatile atomic_uint32_t *a,\n+    u32 v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  return (u32)_InterlockedExchange((volatile long*)&a->val_dont_use, v);\n }\n \n+#ifndef _WIN64\n+\n INLINE bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n                                            u8 *cmp,\n                                            u8 xchgv,\n@@ -186,6 +192,8 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n   return false;\n }\n \n+#endif\n+\n INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n                                            uptr *cmp,\n                                            uptr xchg,"}, {"sha": "a7b5efb6bb4c07f11f5ac0efcfbd9270d4c79e6d", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 301, "deletions": 93, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -10,33 +10,91 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_stacktrace_printer.h\"\n+#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n const char *SanitizerToolName = \"SanitizerTool\";\n \n+atomic_uint32_t current_verbosity;\n+\n uptr GetPageSizeCached() {\n   static uptr PageSize;\n   if (!PageSize)\n     PageSize = GetPageSize();\n   return PageSize;\n }\n \n+StaticSpinMutex report_file_mu;\n+ReportFile report_file = {&report_file_mu, kStderrFd, \"\", \"\", 0};\n \n-// By default, dump to stderr. If |log_to_file| is true and |report_fd_pid|\n-// isn't equal to the current PID, try to obtain file descriptor by opening\n-// file \"report_path_prefix.<PID>\".\n-fd_t report_fd = kStderrFd;\n+void RawWrite(const char *buffer) {\n+  report_file.Write(buffer, internal_strlen(buffer));\n+}\n \n-// Set via __sanitizer_set_report_path.\n-bool log_to_file = false;\n-char report_path_prefix[sizeof(report_path_prefix)];\n+void ReportFile::ReopenIfNecessary() {\n+  mu->CheckLocked();\n+  if (fd == kStdoutFd || fd == kStderrFd) return;\n+\n+  uptr pid = internal_getpid();\n+  // If in tracer, use the parent's file.\n+  if (pid == stoptheworld_tracer_pid)\n+    pid = stoptheworld_tracer_ppid;\n+  if (fd != kInvalidFd) {\n+    // If the report file is already opened by the current process,\n+    // do nothing. Otherwise the report file was opened by the parent\n+    // process, close it now.\n+    if (fd_pid == pid)\n+      return;\n+    else\n+      CloseFile(fd);\n+  }\n \n-// PID of process that opened |report_fd|. If a fork() occurs, the PID of the\n-// child thread will be different from |report_fd_pid|.\n-uptr report_fd_pid = 0;\n+  const char *exe_name = GetProcessName();\n+  if (common_flags()->log_exe_name && exe_name) {\n+    internal_snprintf(full_path, kMaxPathLength, \"%s.%s.%zu\", path_prefix,\n+                      exe_name, pid);\n+  } else {\n+    internal_snprintf(full_path, kMaxPathLength, \"%s.%zu\", path_prefix, pid);\n+  }\n+  fd = OpenFile(full_path, WrOnly);\n+  if (fd == kInvalidFd) {\n+    const char *ErrorMsgPrefix = \"ERROR: Can't open file: \";\n+    WriteToFile(kStderrFd, ErrorMsgPrefix, internal_strlen(ErrorMsgPrefix));\n+    WriteToFile(kStderrFd, full_path, internal_strlen(full_path));\n+    Die();\n+  }\n+  fd_pid = pid;\n+}\n+\n+void ReportFile::SetReportPath(const char *path) {\n+  if (!path)\n+    return;\n+  uptr len = internal_strlen(path);\n+  if (len > sizeof(path_prefix) - 100) {\n+    Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n+           path[0], path[1], path[2], path[3],\n+           path[4], path[5], path[6], path[7]);\n+    Die();\n+  }\n+\n+  SpinMutexLock l(mu);\n+  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)\n+    CloseFile(fd);\n+  fd = kInvalidFd;\n+  if (internal_strcmp(path, \"stdout\") == 0) {\n+    fd = kStdoutFd;\n+  } else if (internal_strcmp(path, \"stderr\") == 0) {\n+    fd = kStderrFd;\n+  } else {\n+    internal_snprintf(path_prefix, kMaxPathLength, \"%s\", path);\n+  }\n+}\n \n // PID of the tracer task in StopTheWorld. It shares the address space with the\n // main process, but has a different PID and thus requires special handling.\n@@ -45,20 +103,47 @@ uptr stoptheworld_tracer_pid = 0;\n // writing to the same log file.\n uptr stoptheworld_tracer_ppid = 0;\n \n-static DieCallbackType DieCallback;\n-void SetDieCallback(DieCallbackType callback) {\n-  DieCallback = callback;\n+static const int kMaxNumOfInternalDieCallbacks = 5;\n+static DieCallbackType InternalDieCallbacks[kMaxNumOfInternalDieCallbacks];\n+\n+bool AddDieCallback(DieCallbackType callback) {\n+  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {\n+    if (InternalDieCallbacks[i] == nullptr) {\n+      InternalDieCallbacks[i] = callback;\n+      return true;\n+    }\n+  }\n+  return false;\n }\n \n-DieCallbackType GetDieCallback() {\n-  return DieCallback;\n+bool RemoveDieCallback(DieCallbackType callback) {\n+  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {\n+    if (InternalDieCallbacks[i] == callback) {\n+      internal_memmove(&InternalDieCallbacks[i], &InternalDieCallbacks[i + 1],\n+                       sizeof(InternalDieCallbacks[0]) *\n+                           (kMaxNumOfInternalDieCallbacks - i - 1));\n+      InternalDieCallbacks[kMaxNumOfInternalDieCallbacks - 1] = nullptr;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+static DieCallbackType UserDieCallback;\n+void SetUserDieCallback(DieCallbackType callback) {\n+  UserDieCallback = callback;\n }\n \n void NORETURN Die() {\n-  if (DieCallback) {\n-    DieCallback();\n+  if (UserDieCallback)\n+    UserDieCallback();\n+  for (int i = kMaxNumOfInternalDieCallbacks - 1; i >= 0; i--) {\n+    if (InternalDieCallbacks[i])\n+      InternalDieCallbacks[i]();\n   }\n-  internal__exit(1);\n+  if (common_flags()->abort_on_error)\n+    Abort();\n+  internal__exit(common_flags()->exitcode);\n }\n \n static CheckFailedCallbackType CheckFailedCallback;\n@@ -76,37 +161,57 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n   Die();\n }\n \n-uptr ReadFileToBuffer(const char *file_name, char **buff,\n-                      uptr *buff_size, uptr max_len) {\n+void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n+                                      error_t err) {\n+  static int recursion_count;\n+  if (recursion_count) {\n+    // The Report() and CHECK calls below may call mmap recursively and fail.\n+    // If we went into recursion, just die.\n+    RawWrite(\"ERROR: Failed to mmap\\n\");\n+    Die();\n+  }\n+  recursion_count++;\n+  Report(\"ERROR: %s failed to \"\n+         \"allocate 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n+         SanitizerToolName, size, size, mem_type, err);\n+  DumpProcessMap();\n+  UNREACHABLE(\"unable to mmap\");\n+}\n+\n+bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n+                      uptr *read_len, uptr max_len, error_t *errno_p) {\n   uptr PageSize = GetPageSizeCached();\n   uptr kMinFileLen = PageSize;\n-  uptr read_len = 0;\n-  *buff = 0;\n+  *buff = nullptr;\n   *buff_size = 0;\n+  *read_len = 0;\n   // The files we usually open are not seekable, so try different buffer sizes.\n   for (uptr size = kMinFileLen; size <= max_len; size *= 2) {\n-    uptr openrv = OpenFile(file_name, /*write*/ false);\n-    if (internal_iserror(openrv)) return 0;\n-    fd_t fd = openrv;\n+    fd_t fd = OpenFile(file_name, RdOnly, errno_p);\n+    if (fd == kInvalidFd) return false;\n     UnmapOrDie(*buff, *buff_size);\n     *buff = (char*)MmapOrDie(size, __func__);\n     *buff_size = size;\n+    *read_len = 0;\n     // Read up to one page at a time.\n-    read_len = 0;\n     bool reached_eof = false;\n-    while (read_len + PageSize <= size) {\n-      uptr just_read = internal_read(fd, *buff + read_len, PageSize);\n+    while (*read_len + PageSize <= size) {\n+      uptr just_read;\n+      if (!ReadFromFile(fd, *buff + *read_len, PageSize, &just_read, errno_p)) {\n+        UnmapOrDie(*buff, *buff_size);\n+        return false;\n+      }\n       if (just_read == 0) {\n         reached_eof = true;\n         break;\n       }\n-      read_len += just_read;\n+      *read_len += just_read;\n     }\n-    internal_close(fd);\n+    CloseFile(fd);\n     if (reached_eof)  // We've read the whole file.\n       break;\n   }\n-  return read_len;\n+  return true;\n }\n \n typedef bool UptrComparisonFunction(const uptr &a, const uptr &b);\n@@ -143,62 +248,77 @@ void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {\n \n const char *StripPathPrefix(const char *filepath,\n                             const char *strip_path_prefix) {\n-  if (filepath == 0) return 0;\n-  if (strip_path_prefix == 0) return filepath;\n-  const char *pos = internal_strstr(filepath, strip_path_prefix);\n-  if (pos == 0) return filepath;\n-  pos += internal_strlen(strip_path_prefix);\n-  if (pos[0] == '.' && pos[1] == '/')\n-    pos += 2;\n-  return pos;\n+  if (!filepath) return nullptr;\n+  if (!strip_path_prefix) return filepath;\n+  const char *res = filepath;\n+  if (const char *pos = internal_strstr(filepath, strip_path_prefix))\n+    res = pos + internal_strlen(strip_path_prefix);\n+  if (res[0] == '.' && res[1] == '/')\n+    res += 2;\n+  return res;\n }\n \n const char *StripModuleName(const char *module) {\n-  if (module == 0)\n-    return 0;\n-  if (const char *slash_pos = internal_strrchr(module, '/'))\n+  if (!module)\n+    return nullptr;\n+  if (SANITIZER_WINDOWS) {\n+    // On Windows, both slash and backslash are possible.\n+    // Pick the one that goes last.\n+    if (const char *bslash_pos = internal_strrchr(module, '\\\\'))\n+      return StripModuleName(bslash_pos + 1);\n+  }\n+  if (const char *slash_pos = internal_strrchr(module, '/')) {\n     return slash_pos + 1;\n+  }\n   return module;\n }\n \n void ReportErrorSummary(const char *error_message) {\n   if (!common_flags()->print_summary)\n     return;\n-  InternalScopedBuffer<char> buff(kMaxSummaryLength);\n-  internal_snprintf(buff.data(), buff.size(),\n-                    \"SUMMARY: %s: %s\", SanitizerToolName, error_message);\n+  InternalScopedString buff(kMaxSummaryLength);\n+  buff.append(\"SUMMARY: %s: %s\", SanitizerToolName, error_message);\n   __sanitizer_report_error_summary(buff.data());\n }\n \n-void ReportErrorSummary(const char *error_type, const char *file,\n-                        int line, const char *function) {\n+#ifndef SANITIZER_GO\n+void ReportErrorSummary(const char *error_type, const AddressInfo &info) {\n   if (!common_flags()->print_summary)\n     return;\n-  InternalScopedBuffer<char> buff(kMaxSummaryLength);\n-  internal_snprintf(\n-      buff.data(), buff.size(), \"%s %s:%d %s\", error_type,\n-      file ? StripPathPrefix(file, common_flags()->strip_path_prefix) : \"??\",\n-      line, function ? function : \"??\");\n+  InternalScopedString buff(kMaxSummaryLength);\n+  buff.append(\"%s \", error_type);\n+  RenderFrame(&buff, \"%L %F\", 0, info, common_flags()->symbolize_vs_style,\n+              common_flags()->strip_path_prefix);\n   ReportErrorSummary(buff.data());\n }\n+#endif\n \n-LoadedModule::LoadedModule(const char *module_name, uptr base_address) {\n+void LoadedModule::set(const char *module_name, uptr base_address) {\n+  clear();\n   full_name_ = internal_strdup(module_name);\n   base_address_ = base_address;\n-  n_ranges_ = 0;\n+}\n+\n+void LoadedModule::clear() {\n+  InternalFree(full_name_);\n+  full_name_ = nullptr;\n+  while (!ranges_.empty()) {\n+    AddressRange *r = ranges_.front();\n+    ranges_.pop_front();\n+    InternalFree(r);\n+  }\n }\n \n void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable) {\n-  CHECK_LT(n_ranges_, kMaxNumberOfAddressRanges);\n-  ranges_[n_ranges_].beg = beg;\n-  ranges_[n_ranges_].end = end;\n-  exec_[n_ranges_] = executable;\n-  n_ranges_++;\n+  void *mem = InternalAlloc(sizeof(AddressRange));\n+  AddressRange *r = new(mem) AddressRange(beg, end, executable);\n+  ranges_.push_back(r);\n }\n \n bool LoadedModule::containsAddress(uptr address) const {\n-  for (uptr i = 0; i < n_ranges_; i++) {\n-    if (ranges_[i].beg <= address && address < ranges_[i].end)\n+  for (Iterator iter = ranges(); iter.hasNext();) {\n+    const AddressRange *r = iter.next();\n+    if (r->beg <= address && address < r->end)\n       return true;\n   }\n   return false;\n@@ -210,52 +330,140 @@ void IncreaseTotalMmap(uptr size) {\n   if (!common_flags()->mmap_limit_mb) return;\n   uptr total_mmaped =\n       atomic_fetch_add(&g_total_mmaped, size, memory_order_relaxed) + size;\n-  if ((total_mmaped >> 20) > common_flags()->mmap_limit_mb) {\n-    // Since for now mmap_limit_mb is not a user-facing flag, just CHECK.\n-    uptr mmap_limit_mb = common_flags()->mmap_limit_mb;\n-    common_flags()->mmap_limit_mb = 0;  // Allow mmap in CHECK.\n-    RAW_CHECK(total_mmaped >> 20 < mmap_limit_mb);\n-  }\n+  // Since for now mmap_limit_mb is not a user-facing flag, just kill\n+  // a program. Use RAW_CHECK to avoid extra mmaps in reporting.\n+  RAW_CHECK((total_mmaped >> 20) < common_flags()->mmap_limit_mb);\n }\n \n void DecreaseTotalMmap(uptr size) {\n   if (!common_flags()->mmap_limit_mb) return;\n   atomic_fetch_sub(&g_total_mmaped, size, memory_order_relaxed);\n }\n \n-}  // namespace __sanitizer\n+bool TemplateMatch(const char *templ, const char *str) {\n+  if ((!str) || str[0] == 0)\n+    return false;\n+  bool start = false;\n+  if (templ && templ[0] == '^') {\n+    start = true;\n+    templ++;\n+  }\n+  bool asterisk = false;\n+  while (templ && templ[0]) {\n+    if (templ[0] == '*') {\n+      templ++;\n+      start = false;\n+      asterisk = true;\n+      continue;\n+    }\n+    if (templ[0] == '$')\n+      return str[0] == 0 || asterisk;\n+    if (str[0] == 0)\n+      return false;\n+    char *tpos = (char*)internal_strchr(templ, '*');\n+    char *tpos1 = (char*)internal_strchr(templ, '$');\n+    if ((!tpos) || (tpos1 && tpos1 < tpos))\n+      tpos = tpos1;\n+    if (tpos)\n+      tpos[0] = 0;\n+    const char *str0 = str;\n+    const char *spos = internal_strstr(str, templ);\n+    str = spos + internal_strlen(templ);\n+    templ = tpos;\n+    if (tpos)\n+      tpos[0] = tpos == tpos1 ? '$' : '*';\n+    if (!spos)\n+      return false;\n+    if (start && spos != str0)\n+      return false;\n+    start = false;\n+    asterisk = false;\n+  }\n+  return true;\n+}\n \n-using namespace __sanitizer;  // NOLINT\n+static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';\n \n-extern \"C\" {\n-void __sanitizer_set_report_path(const char *path) {\n+char *FindPathToBinary(const char *name) {\n+  const char *path = GetEnv(\"PATH\");\n   if (!path)\n-    return;\n-  uptr len = internal_strlen(path);\n-  if (len > sizeof(report_path_prefix) - 100) {\n-    Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n-           path[0], path[1], path[2], path[3],\n-           path[4], path[5], path[6], path[7]);\n-    Die();\n+    return nullptr;\n+  uptr name_len = internal_strlen(name);\n+  InternalScopedBuffer<char> buffer(kMaxPathLength);\n+  const char *beg = path;\n+  while (true) {\n+    const char *end = internal_strchrnul(beg, kPathSeparator);\n+    uptr prefix_len = end - beg;\n+    if (prefix_len + name_len + 2 <= kMaxPathLength) {\n+      internal_memcpy(buffer.data(), beg, prefix_len);\n+      buffer[prefix_len] = '/';\n+      internal_memcpy(&buffer[prefix_len + 1], name, name_len);\n+      buffer[prefix_len + 1 + name_len] = '\\0';\n+      if (FileExists(buffer.data()))\n+        return internal_strdup(buffer.data());\n+    }\n+    if (*end == '\\0') break;\n+    beg = end + 1;\n   }\n-  if (report_fd != kStdoutFd &&\n-      report_fd != kStderrFd &&\n-      report_fd != kInvalidFd)\n-    internal_close(report_fd);\n-  report_fd = kInvalidFd;\n-  log_to_file = false;\n-  if (internal_strcmp(path, \"stdout\") == 0) {\n-    report_fd = kStdoutFd;\n-  } else if (internal_strcmp(path, \"stderr\") == 0) {\n-    report_fd = kStderrFd;\n-  } else {\n-    internal_strncpy(report_path_prefix, path, sizeof(report_path_prefix));\n-    report_path_prefix[len] = '\\0';\n-    log_to_file = true;\n+  return nullptr;\n+}\n+\n+static char binary_name_cache_str[kMaxPathLength];\n+static char process_name_cache_str[kMaxPathLength];\n+\n+const char *GetProcessName() {\n+  return process_name_cache_str;\n+}\n+\n+static uptr ReadProcessName(/*out*/ char *buf, uptr buf_len) {\n+  ReadLongProcessName(buf, buf_len);\n+  char *s = const_cast<char *>(StripModuleName(buf));\n+  uptr len = internal_strlen(s);\n+  if (s != buf) {\n+    internal_memmove(buf, s, len);\n+    buf[len] = '\\0';\n   }\n+  return len;\n+}\n+\n+void UpdateProcessName() {\n+  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));\n+}\n+\n+// Call once to make sure that binary_name_cache_str is initialized\n+void CacheBinaryName() {\n+  if (binary_name_cache_str[0] != '\\0')\n+    return;\n+  ReadBinaryName(binary_name_cache_str, sizeof(binary_name_cache_str));\n+  ReadProcessName(process_name_cache_str, sizeof(process_name_cache_str));\n+}\n+\n+uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {\n+  CacheBinaryName();\n+  uptr name_len = internal_strlen(binary_name_cache_str);\n+  name_len = (name_len < buf_len - 1) ? name_len : buf_len - 1;\n+  if (buf_len == 0)\n+    return 0;\n+  internal_memcpy(buf, binary_name_cache_str, name_len);\n+  buf[name_len] = '\\0';\n+  return name_len;\n+}\n+\n+} // namespace __sanitizer\n+\n+using namespace __sanitizer;  // NOLINT\n+\n+extern \"C\" {\n+void __sanitizer_set_report_path(const char *path) {\n+  report_file.SetReportPath(path);\n }\n \n void __sanitizer_report_error_summary(const char *error_summary) {\n   Printf(\"%s\\n\", error_summary);\n }\n-}  // extern \"C\"\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_set_death_callback(void (*callback)(void)) {\n+  SetUserDieCallback(callback);\n+}\n+} // extern \"C\""}, {"sha": "637e229742d1b30c83249cbd1271c80e0eb2f0c8", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 244, "deletions": 84, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -5,22 +5,30 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file is shared between AddressSanitizer and ThreadSanitizer\n-// run-time libraries.\n+// This file is shared between run-time libraries of sanitizers.\n+//\n // It declares common functions and classes that are used in both runtimes.\n // Implementation of some functions are provided in sanitizer_common, while\n // others must be defined by run-time library itself.\n //===----------------------------------------------------------------------===//\n #ifndef SANITIZER_COMMON_H\n #define SANITIZER_COMMON_H\n \n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_interface_internal.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_list.h\"\n #include \"sanitizer_mutex.h\"\n-#include \"sanitizer_flags.h\"\n+\n+#ifdef _MSC_VER\n+extern \"C\" void _ReadWriteBarrier();\n+#pragma intrinsic(_ReadWriteBarrier)\n+#endif\n \n namespace __sanitizer {\n struct StackTrace;\n+struct AddressInfo;\n \n // Constants.\n const uptr kWordSize = SANITIZER_WORDSIZE / 8;\n@@ -32,12 +40,27 @@ const uptr kWordSizeInBits = 8 * kWordSize;\n   const uptr kCacheLineSize = 64;\n #endif\n \n-const uptr kMaxPathLength = 512;\n+const uptr kMaxPathLength = 4096;\n+\n+// 16K loaded modules should be enough for everyone.\n+static const uptr kMaxNumberOfModules = 1 << 14;\n \n const uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n \n+// Denotes fake PC values that come from JIT/JAVA/etc.\n+// For such PC values __tsan_symbolize_external() will be called.\n+const u64 kExternalPCBit = 1ULL << 60;\n+\n extern const char *SanitizerToolName;  // Can be changed by the tool.\n \n+extern atomic_uint32_t current_verbosity;\n+INLINE void SetVerbosity(int verbosity) {\n+  atomic_store(&current_verbosity, verbosity, memory_order_relaxed);\n+}\n+INLINE int Verbosity() {\n+  return atomic_load(&current_verbosity, memory_order_relaxed);\n+}\n+\n uptr GetPageSize();\n uptr GetPageSizeCached();\n uptr GetMmapGranularity();\n@@ -53,17 +76,27 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n // Memory management\n void *MmapOrDie(uptr size, const char *mem_type);\n void UnmapOrDie(void *addr, uptr size);\n-void *MmapFixedNoReserve(uptr fixed_addr, uptr size);\n+void *MmapFixedNoReserve(uptr fixed_addr, uptr size,\n+                         const char *name = nullptr);\n void *MmapNoReserveOrDie(uptr size, const char *mem_type);\n void *MmapFixedOrDie(uptr fixed_addr, uptr size);\n-void *Mprotect(uptr fixed_addr, uptr size);\n+void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name = nullptr);\n // Map aligned chunk of address space; size and alignment are powers of two.\n void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type);\n+// Disallow access to a memory range.  Use MmapNoAccess to allocate an\n+// unaccessible memory.\n+bool MprotectNoAccess(uptr addr, uptr size);\n+\n // Used to check if we can map shadow memory to a fixed location.\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n void FlushUnneededShadowMemory(uptr addr, uptr size);\n void IncreaseTotalMmap(uptr size);\n void DecreaseTotalMmap(uptr size);\n+uptr GetRSS();\n+void NoHugePagesInRegion(uptr addr, uptr length);\n+void DontDumpShadowMemory(uptr addr, uptr length);\n+// Check if the built VMA size matches the runtime one.\n+void CheckVMASize();\n \n // InternalScopedBuffer can be used instead of large stack arrays to\n // keep frame size low.\n@@ -126,44 +159,93 @@ void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback);\n \n // IO\n void RawWrite(const char *buffer);\n-bool PrintsToTty();\n-// Caching version of PrintsToTty(). Not thread-safe.\n-bool PrintsToTtyCached();\n bool ColorizeReports();\n void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n #define VReport(level, ...)                                              \\\n   do {                                                                   \\\n-    if ((uptr)common_flags()->verbosity >= (level)) Report(__VA_ARGS__); \\\n+    if ((uptr)Verbosity() >= (level)) Report(__VA_ARGS__); \\\n   } while (0)\n #define VPrintf(level, ...)                                              \\\n   do {                                                                   \\\n-    if ((uptr)common_flags()->verbosity >= (level)) Printf(__VA_ARGS__); \\\n+    if ((uptr)Verbosity() >= (level)) Printf(__VA_ARGS__); \\\n   } while (0)\n \n // Can be used to prevent mixing error reports from different sanitizers.\n extern StaticSpinMutex CommonSanitizerReportMutex;\n-void MaybeOpenReportFile();\n-extern fd_t report_fd;\n-extern bool log_to_file;\n-extern char report_path_prefix[4096];\n-extern uptr report_fd_pid;\n+\n+struct ReportFile {\n+  void Write(const char *buffer, uptr length);\n+  bool SupportsColors();\n+  void SetReportPath(const char *path);\n+\n+  // Don't use fields directly. They are only declared public to allow\n+  // aggregate initialization.\n+\n+  // Protects fields below.\n+  StaticSpinMutex *mu;\n+  // Opened file descriptor. Defaults to stderr. It may be equal to\n+  // kInvalidFd, in which case new file will be opened when necessary.\n+  fd_t fd;\n+  // Path prefix of report file, set via __sanitizer_set_report_path.\n+  char path_prefix[kMaxPathLength];\n+  // Full path to report, obtained as <path_prefix>.PID\n+  char full_path[kMaxPathLength];\n+  // PID of the process that opened fd. If a fork() occurs,\n+  // the PID of child will be different from fd_pid.\n+  uptr fd_pid;\n+\n+ private:\n+  void ReopenIfNecessary();\n+};\n+extern ReportFile report_file;\n+\n extern uptr stoptheworld_tracer_pid;\n extern uptr stoptheworld_tracer_ppid;\n \n-uptr OpenFile(const char *filename, bool write);\n+enum FileAccessMode {\n+  RdOnly,\n+  WrOnly,\n+  RdWr\n+};\n+\n+// Returns kInvalidFd on error.\n+fd_t OpenFile(const char *filename, FileAccessMode mode,\n+              error_t *errno_p = nullptr);\n+void CloseFile(fd_t);\n+\n+// Return true on success, false on error.\n+bool ReadFromFile(fd_t fd, void *buff, uptr buff_size,\n+                  uptr *bytes_read = nullptr, error_t *error_p = nullptr);\n+bool WriteToFile(fd_t fd, const void *buff, uptr buff_size,\n+                 uptr *bytes_written = nullptr, error_t *error_p = nullptr);\n+\n+bool RenameFile(const char *oldpath, const char *newpath,\n+                error_t *error_p = nullptr);\n+\n+// Scoped file handle closer.\n+struct FileCloser {\n+  explicit FileCloser(fd_t fd) : fd(fd) {}\n+  ~FileCloser() { CloseFile(fd); }\n+  fd_t fd;\n+};\n+\n+bool SupportsColoredOutput(fd_t fd);\n+\n // Opens the file 'file_name\" and reads up to 'max_len' bytes.\n // The resulting buffer is mmaped and stored in '*buff'.\n-// The size of the mmaped region is stored in '*buff_size',\n-// Returns the number of read bytes or 0 if file can not be opened.\n-uptr ReadFileToBuffer(const char *file_name, char **buff,\n-                      uptr *buff_size, uptr max_len);\n+// The size of the mmaped region is stored in '*buff_size'.\n+// The total number of read bytes is stored in '*read_len'.\n+// Returns true if file was successfully opened and read.\n+bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n+                      uptr *read_len, uptr max_len = 1 << 26,\n+                      error_t *errno_p = nullptr);\n // Maps given file to virtual memory, and returns pointer to it\n-// (or NULL if the mapping failes). Stores the size of mmaped region\n+// (or NULL if mapping fails). Stores the size of mmaped region\n // in '*buff_size'.\n void *MapFileToMemory(const char *file_name, uptr *buff_size);\n-void *MapWritableFileToMemory(void *addr, uptr size, uptr fd, uptr offset);\n+void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset);\n \n bool IsAccessibleMemoryRange(uptr beg, uptr size);\n \n@@ -174,13 +256,22 @@ const char *StripPathPrefix(const char *filepath,\n const char *StripModuleName(const char *module);\n \n // OS\n+uptr ReadBinaryName(/*out*/char *buf, uptr buf_len);\n+uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len);\n+uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len);\n+const char *GetProcessName();\n+void UpdateProcessName();\n+void CacheBinaryName();\n void DisableCoreDumperIfNecessary();\n void DumpProcessMap();\n bool FileExists(const char *filename);\n const char *GetEnv(const char *name);\n bool SetEnv(const char *name, const char *value);\n const char *GetPwd();\n char *FindPathToBinary(const char *name);\n+bool IsPathSeparator(const char c);\n+bool IsAbsolutePath(const char *path);\n+\n u32 GetUid();\n void ReExec();\n bool StackSizeIsUnlimited();\n@@ -192,10 +283,13 @@ void PrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n void SetSandboxingCallback(void (*f)());\n \n-void CovUpdateMapping(uptr caller_pc = 0);\n+void CoverageUpdateMapping();\n void CovBeforeFork();\n void CovAfterFork(int child_pid);\n \n+void InitializeCoverage(bool enabled, const char *coverage_dir);\n+void ReInitializeCoverage(bool enabled, const char *coverage_dir);\n+\n void InitTlsSize();\n uptr GetTlsSize();\n \n@@ -205,12 +299,15 @@ void SleepForMillis(int millis);\n u64 NanoTime();\n int Atexit(void (*function)(void));\n void SortArray(uptr *array, uptr size);\n+bool TemplateMatch(const char *templ, const char *str);\n \n // Exit\n void NORETURN Abort();\n void NORETURN Die();\n void NORETURN\n CheckFailed(const char *file, int line, const char *cond, u64 v1, u64 v2);\n+void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n+                                      error_t err);\n \n // Set the name of the current thread to 'name', return true on succees.\n // The name may be truncated to a system-dependent limit.\n@@ -222,12 +319,26 @@ bool SanitizerGetThreadName(char *name, int max_len);\n // Specific tools may override behavior of \"Die\" and \"CheckFailed\" functions\n // to do tool-specific job.\n typedef void (*DieCallbackType)(void);\n-void SetDieCallback(DieCallbackType);\n-DieCallbackType GetDieCallback();\n+\n+// It's possible to add several callbacks that would be run when \"Die\" is\n+// called. The callbacks will be run in the opposite order. The tools are\n+// strongly recommended to setup all callbacks during initialization, when there\n+// is only a single thread.\n+bool AddDieCallback(DieCallbackType callback);\n+bool RemoveDieCallback(DieCallbackType callback);\n+\n+void SetUserDieCallback(DieCallbackType callback);\n+\n typedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n                                        u64, u64);\n void SetCheckFailedCallback(CheckFailedCallbackType callback);\n \n+// Callback will be called if soft_rss_limit_mb is given and the limit is\n+// exceeded (exceeded==true) or if rss went down below the limit\n+// (exceeded==false).\n+// The callback should be registered once at the tool init time.\n+void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded));\n+\n // Functions related to signal handling.\n typedef void (*SignalHandlerType)(int, void *, void *);\n bool IsDeadlySignal(int signum);\n@@ -243,9 +354,9 @@ const int kMaxSummaryLength = 1024;\n // and pass it to __sanitizer_report_error_summary.\n void ReportErrorSummary(const char *error_message);\n // Same as above, but construct error_message as:\n-//   error_type file:line function\n-void ReportErrorSummary(const char *error_type, const char *file,\n-                        int line, const char *function);\n+//   error_type file:line[:column][ function]\n+void ReportErrorSummary(const char *error_type, const AddressInfo &info);\n+// Same as above, but obtains AddressInfo by symbolizing top stack trace frame.\n void ReportErrorSummary(const char *error_type, StackTrace *trace);\n \n // Math\n@@ -264,7 +375,11 @@ INLINE uptr MostSignificantSetBitIndex(uptr x) {\n   CHECK_NE(x, 0U);\n   unsigned long up;  // NOLINT\n #if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n+# ifdef _WIN64\n+  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);\n+# else\n   up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);\n+# endif\n #elif defined(_WIN64)\n   _BitScanReverse64(&up, x);\n #else\n@@ -277,7 +392,11 @@ INLINE uptr LeastSignificantSetBitIndex(uptr x) {\n   CHECK_NE(x, 0U);\n   unsigned long up;  // NOLINT\n #if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n+# ifdef _WIN64\n+  up = __builtin_ctzll(x);\n+# else\n   up = __builtin_ctzl(x);\n+# endif\n #elif defined(_WIN64)\n   _BitScanForward64(&up, x);\n #else\n@@ -297,7 +416,7 @@ INLINE uptr RoundUpToPowerOfTwo(uptr size) {\n   uptr up = MostSignificantSetBitIndex(size);\n   CHECK(size < (1ULL << (up + 1)));\n   CHECK(size > (1ULL << up));\n-  return 1UL << (up + 1);\n+  return 1ULL << (up + 1);\n }\n \n INLINE uptr RoundUpTo(uptr size, uptr boundary) {\n@@ -315,17 +434,7 @@ INLINE bool IsAligned(uptr a, uptr alignment) {\n \n INLINE uptr Log2(uptr x) {\n   CHECK(IsPowerOfTwo(x));\n-#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n-  return __builtin_ctzl(x);\n-#elif defined(_WIN64)\n-  unsigned long ret;  // NOLINT\n-  _BitScanForward64(&ret, x);\n-  return ret;\n-#else\n-  unsigned long ret;  // NOLINT\n-  _BitScanForward(&ret, x);\n-  return ret;\n-#endif\n+  return LeastSignificantSetBitIndex(x);\n }\n \n // Don't use std::min, std::max or std::swap, to minimize dependency\n@@ -354,14 +463,14 @@ INLINE int ToLower(int c) {\n // small vectors.\n // WARNING: The current implementation supports only POD types.\n template<typename T>\n-class InternalMmapVector {\n+class InternalMmapVectorNoCtor {\n  public:\n-  explicit InternalMmapVector(uptr initial_capacity) {\n+  void Initialize(uptr initial_capacity) {\n     capacity_ = Max(initial_capacity, (uptr)1);\n     size_ = 0;\n-    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), \"InternalMmapVector\");\n+    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), \"InternalMmapVectorNoCtor\");\n   }\n-  ~InternalMmapVector() {\n+  void Destroy() {\n     UnmapOrDie(data_, capacity_ * sizeof(T));\n   }\n   T &operator[](uptr i) {\n@@ -394,11 +503,15 @@ class InternalMmapVector {\n   const T *data() const {\n     return data_;\n   }\n+  T *data() {\n+    return data_;\n+  }\n   uptr capacity() const {\n     return capacity_;\n   }\n \n   void clear() { size_ = 0; }\n+  bool empty() const { return size() == 0; }\n \n  private:\n   void Resize(uptr new_capacity) {\n@@ -412,15 +525,24 @@ class InternalMmapVector {\n     UnmapOrDie(old_data, capacity_ * sizeof(T));\n     capacity_ = new_capacity;\n   }\n-  // Disallow evil constructors.\n-  InternalMmapVector(const InternalMmapVector&);\n-  void operator=(const InternalMmapVector&);\n \n   T *data_;\n   uptr capacity_;\n   uptr size_;\n };\n \n+template<typename T>\n+class InternalMmapVector : public InternalMmapVectorNoCtor<T> {\n+ public:\n+  explicit InternalMmapVector(uptr initial_capacity) {\n+    InternalMmapVectorNoCtor<T>::Initialize(initial_capacity);\n+  }\n+  ~InternalMmapVector() { InternalMmapVectorNoCtor<T>::Destroy(); }\n+  // Disallow evil constructors.\n+  InternalMmapVector(const InternalMmapVector&);\n+  void operator=(const InternalMmapVector&);\n+};\n+\n // HeapSort for arrays and InternalMmapVector.\n template<class Container, class Compare>\n void InternalSort(Container *v, uptr size, Compare comp) {\n@@ -478,29 +600,32 @@ uptr InternalBinarySearch(const Container &v, uptr first, uptr last,\n // executable or a shared object).\n class LoadedModule {\n  public:\n-  LoadedModule(const char *module_name, uptr base_address);\n+  LoadedModule() : full_name_(nullptr), base_address_(0) { ranges_.clear(); }\n+  void set(const char *module_name, uptr base_address);\n+  void clear();\n   void addAddressRange(uptr beg, uptr end, bool executable);\n   bool containsAddress(uptr address) const;\n \n   const char *full_name() const { return full_name_; }\n   uptr base_address() const { return base_address_; }\n \n-  uptr n_ranges() const { return n_ranges_; }\n-  uptr address_range_start(int i) const { return ranges_[i].beg; }\n-  uptr address_range_end(int i) const { return ranges_[i].end; }\n-  bool address_range_executable(int i) const { return exec_[i]; }\n-\n- private:\n   struct AddressRange {\n+    AddressRange *next;\n     uptr beg;\n     uptr end;\n+    bool executable;\n+\n+    AddressRange(uptr beg, uptr end, bool executable)\n+        : next(nullptr), beg(beg), end(end), executable(executable) {}\n   };\n-  char *full_name_;\n+\n+  typedef IntrusiveList<AddressRange>::ConstIterator Iterator;\n+  Iterator ranges() const { return Iterator(&ranges_); }\n+\n+ private:\n+  char *full_name_;  // Owned.\n   uptr base_address_;\n-  static const uptr kMaxNumberOfAddressRanges = 6;\n-  AddressRange ranges_[kMaxNumberOfAddressRanges];\n-  bool exec_[kMaxNumberOfAddressRanges];\n-  uptr n_ranges_;\n+  IntrusiveList<AddressRange> ranges_;\n };\n \n // OS-dependent function that fills array with descriptions of at most\n@@ -511,45 +636,80 @@ typedef bool (*string_predicate_t)(const char *);\n uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n                       string_predicate_t filter);\n \n-#if SANITIZER_POSIX\n-const uptr kPthreadDestructorIterations = 4;\n-#else\n-// Unused on Windows.\n-const uptr kPthreadDestructorIterations = 0;\n-#endif\n-\n // Callback type for iterating over a set of memory ranges.\n typedef void (*RangeIteratorCallback)(uptr begin, uptr end, void *arg);\n \n-#if (SANITIZER_FREEBSD || SANITIZER_LINUX) && !defined(SANITIZER_GO)\n-extern uptr indirect_call_wrapper;\n-void SetIndirectCallWrapper(uptr wrapper);\n+enum AndroidApiLevel {\n+  ANDROID_NOT_ANDROID = 0,\n+  ANDROID_KITKAT = 19,\n+  ANDROID_LOLLIPOP_MR1 = 22,\n+  ANDROID_POST_LOLLIPOP = 23\n+};\n \n-template <typename F>\n-F IndirectExternCall(F f) {\n-  typedef F (*WrapF)(F);\n-  return indirect_call_wrapper ? ((WrapF)indirect_call_wrapper)(f) : f;\n-}\n+#if SANITIZER_LINUX\n+// Initialize Android logging. Any writes before this are silently lost.\n+void AndroidLogInit();\n+void WriteToSyslog(const char *buffer);\n #else\n-INLINE void SetIndirectCallWrapper(uptr wrapper) {}\n-template <typename F>\n-F IndirectExternCall(F f) {\n-  return f;\n-}\n+INLINE void AndroidLogInit() {}\n+INLINE void WriteToSyslog(const char *buffer) {}\n #endif\n \n #if SANITIZER_ANDROID\n-// Initialize Android logging. Any writes before this are silently lost.\n-void AndroidLogInit();\n-void AndroidLogWrite(const char *buffer);\n void GetExtraActivationFlags(char *buf, uptr size);\n void SanitizerInitializeUnwinder();\n+AndroidApiLevel AndroidGetApiLevel();\n #else\n-INLINE void AndroidLogInit() {}\n INLINE void AndroidLogWrite(const char *buffer_unused) {}\n INLINE void GetExtraActivationFlags(char *buf, uptr size) { *buf = '\\0'; }\n INLINE void SanitizerInitializeUnwinder() {}\n+INLINE AndroidApiLevel AndroidGetApiLevel() { return ANDROID_NOT_ANDROID; }\n+#endif\n+\n+INLINE uptr GetPthreadDestructorIterations() {\n+#if SANITIZER_ANDROID\n+  return (AndroidGetApiLevel() == ANDROID_LOLLIPOP_MR1) ? 8 : 4;\n+#elif SANITIZER_POSIX\n+  return 4;\n+#else\n+// Unused on Windows.\n+  return 0;\n+#endif\n+}\n+\n+void *internal_start_thread(void(*func)(void*), void *arg);\n+void internal_join_thread(void *th);\n+void MaybeStartBackgroudThread();\n+\n+// Make the compiler think that something is going on there.\n+// Use this inside a loop that looks like memset/memcpy/etc to prevent the\n+// compiler from recognising it and turning it into an actual call to\n+// memset/memcpy/etc.\n+static inline void SanitizerBreakOptimization(void *arg) {\n+#if _MSC_VER && !defined(__clang__)\n+  _ReadWriteBarrier();\n+#else\n+  __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n #endif\n+}\n+\n+struct SignalContext {\n+  void *context;\n+  uptr addr;\n+  uptr pc;\n+  uptr sp;\n+  uptr bp;\n+\n+  SignalContext(void *context, uptr addr, uptr pc, uptr sp, uptr bp) :\n+      context(context), addr(addr), pc(pc), sp(sp), bp(bp) {\n+  }\n+\n+  // Creates signal context in a platform-specific manner.\n+  static SignalContext Create(void *siginfo, void *context);\n+};\n+\n+void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp);\n+\n }  // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,"}, {"sha": "9b8c77e690132f7d3da3efff529722ac6b61241e", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 591, "deletions": 76, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -15,10 +15,12 @@\n //   COMMON_INTERCEPTOR_READ_RANGE\n //   COMMON_INTERCEPTOR_WRITE_RANGE\n //   COMMON_INTERCEPTOR_INITIALIZE_RANGE\n+//   COMMON_INTERCEPTOR_DIR_ACQUIRE\n //   COMMON_INTERCEPTOR_FD_ACQUIRE\n //   COMMON_INTERCEPTOR_FD_RELEASE\n //   COMMON_INTERCEPTOR_FD_ACCESS\n //   COMMON_INTERCEPTOR_SET_THREAD_NAME\n+//   COMMON_INTERCEPTOR_ON_DLOPEN\n //   COMMON_INTERCEPTOR_ON_EXIT\n //   COMMON_INTERCEPTOR_MUTEX_LOCK\n //   COMMON_INTERCEPTOR_MUTEX_UNLOCK\n@@ -27,6 +29,7 @@\n //   COMMON_INTERCEPTOR_HANDLE_RECVMSG\n //   COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n //===----------------------------------------------------------------------===//\n+\n #include \"interception/interception.h\"\n #include \"sanitizer_addrhashmap.h\"\n #include \"sanitizer_placement_new.h\"\n@@ -35,12 +38,31 @@\n \n #include <stdarg.h>\n \n+#if SANITIZER_INTERCEPTOR_HOOKS\n+#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...)                                     \\\n+  do {                                                                         \\\n+    if (f)                                                                     \\\n+      f(__VA_ARGS__);                                                          \\\n+  } while (false);\n+#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...)                                  \\\n+  extern \"C\" {                                                                 \\\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void f(__VA_ARGS__);  \\\n+  } // extern \"C\"\n+#else\n+#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...)\n+#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...)\n+\n+#endif  // SANITIZER_INTERCEPTOR_HOOKS\n+\n #if SANITIZER_WINDOWS && !defined(va_copy)\n #define va_copy(dst, src) ((dst) = (src))\n #endif // _WIN32\n \n #if SANITIZER_FREEBSD\n #define pthread_setname_np pthread_set_name_np\n+#define inet_aton __inet_aton\n+#define inet_pton __inet_pton\n+#define iconv __bsd_iconv\n #endif\n \n #ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n@@ -80,7 +102,7 @@\n #endif\n \n #ifndef COMMON_INTERCEPTOR_LIBRARY_LOADED\n-#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, map) {}\n+#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle) {}\n #endif\n \n #ifndef COMMON_INTERCEPTOR_LIBRARY_UNLOADED\n@@ -96,6 +118,29 @@\n #define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (0)\n #endif\n \n+#define COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s, len, n)       \\\n+    COMMON_INTERCEPTOR_READ_RANGE((ctx), (s),                       \\\n+      common_flags()->strict_string_checks ? (len) + 1 : (n) )\n+\n+#define COMMON_INTERCEPTOR_READ_STRING(ctx, s, n)                   \\\n+    COMMON_INTERCEPTOR_READ_STRING_OF_LEN((ctx), (s), REAL(strlen)(s), (n))\n+\n+#ifndef COMMON_INTERCEPTOR_ON_DLOPEN\n+#define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_GET_TLS_RANGE\n+#define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end) *begin = *end = 0;\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_ACQUIRE\n+#define COMMON_INTERCEPTOR_ACQUIRE(ctx, u) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_RELEASE\n+#define COMMON_INTERCEPTOR_RELEASE(ctx, u) {}\n+#endif\n+\n struct FileMetadata {\n   // For open_memstream().\n   char **addr;\n@@ -149,7 +194,8 @@ UNUSED static void DeleteInterceptorMetadata(void *addr) {\n INTERCEPTOR(char*, textdomain, const char *domainname) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, textdomain, domainname);\n-  char* domain = REAL(textdomain)(domainname);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, domainname, 0);\n+  char *domain = REAL(textdomain)(domainname);\n   if (domain) {\n     COMMON_INTERCEPTOR_INITIALIZE_RANGE(domain, REAL(strlen)(domain) + 1);\n   }\n@@ -165,26 +211,36 @@ static inline int CharCmpX(unsigned char c1, unsigned char c2) {\n   return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n }\n \n+DECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcmp, uptr called_pc,\n+                              const char *s1, const char *s2)\n+\n INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strcmp, s1, s2);\n+  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcmp, GET_CALLER_PC(), s1,\n+                             s2);\n   unsigned char c1, c2;\n   uptr i;\n   for (i = 0;; i++) {\n     c1 = (unsigned char)s1[i];\n     c2 = (unsigned char)s2[i];\n     if (c1 != c2 || c1 == '\\0') break;\n   }\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, i + 1);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, i + 1);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n   return CharCmpX(c1, c2);\n }\n \n+DECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncmp, uptr called_pc,\n+                              const char *s1, const char *s2, uptr n)\n+\n INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n   if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n     return internal_strncmp(s1, s2, size);\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strncmp, s1, s2, size);\n+  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncmp, GET_CALLER_PC(), s1,\n+                             s2, size);\n   unsigned char c1 = 0, c2 = 0;\n   uptr i;\n   for (i = 0; i < size; i++) {\n@@ -221,8 +277,8 @@ INTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n     c2 = (unsigned char)s2[i];\n     if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n   }\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, i + 1);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, i + 1);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n   return CharCaseCmp(c1, c2);\n }\n \n@@ -248,12 +304,145 @@ INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T n) {\n #define INIT_STRNCASECMP\n #endif\n \n+#if SANITIZER_INTERCEPT_STRSTR || SANITIZER_INTERCEPT_STRCASESTR\n+static inline void StrstrCheck(void *ctx, char *r, const char *s1,\n+                               const char *s2) {\n+    uptr len1 = REAL(strlen)(s1);\n+    uptr len2 = REAL(strlen)(s2);\n+    COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s1, len1,\n+                                          r ? r - s1 + len2 : len1 + 1);\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, len2 + 1);\n+}\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRSTR\n+INTERCEPTOR(char*, strstr, const char *s1, const char *s2) {\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return internal_strstr(s1, s2);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strstr, s1, s2);\n+  char *r = REAL(strstr)(s1, s2);\n+  if (common_flags()->intercept_strstr)\n+    StrstrCheck(ctx, r, s1, s2);\n+  return r;\n+}\n+\n+#define INIT_STRSTR COMMON_INTERCEPT_FUNCTION(strstr);\n+#else\n+#define INIT_STRSTR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRCASESTR\n+INTERCEPTOR(char*, strcasestr, const char *s1, const char *s2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strcasestr, s1, s2);\n+  char *r = REAL(strcasestr)(s1, s2);\n+  if (common_flags()->intercept_strstr)\n+    StrstrCheck(ctx, r, s1, s2);\n+  return r;\n+}\n+\n+#define INIT_STRCASESTR COMMON_INTERCEPT_FUNCTION(strcasestr);\n+#else\n+#define INIT_STRCASESTR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRSPN\n+INTERCEPTOR(SIZE_T, strspn, const char *s1, const char *s2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strspn, s1, s2);\n+  SIZE_T r = REAL(strspn)(s1, s2);\n+  if (common_flags()->intercept_strspn) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r + 1);\n+  }\n+  return r;\n+}\n+\n+INTERCEPTOR(SIZE_T, strcspn, const char *s1, const char *s2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strcspn, s1, s2);\n+  SIZE_T r = REAL(strcspn)(s1, s2);\n+  if (common_flags()->intercept_strspn) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r + 1);\n+  }\n+  return r;\n+}\n+\n+#define INIT_STRSPN \\\n+  COMMON_INTERCEPT_FUNCTION(strspn); \\\n+  COMMON_INTERCEPT_FUNCTION(strcspn);\n+#else\n+#define INIT_STRSPN\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRPBRK\n+INTERCEPTOR(char *, strpbrk, const char *s1, const char *s2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strpbrk, s1, s2);\n+  char *r = REAL(strpbrk)(s1, s2);\n+  if (common_flags()->intercept_strpbrk) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s1,\n+        r ? r - s1 + 1 : REAL(strlen)(s1) + 1);\n+  }\n+  return r;\n+}\n+\n+#define INIT_STRPBRK COMMON_INTERCEPT_FUNCTION(strpbrk);\n+#else\n+#define INIT_STRPBRK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MEMCMP\n+\n+DECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, uptr called_pc,\n+                              const void *s1, const void *s2, uptr n)\n+\n+INTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, memcmp, a1, a2, size);\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return internal_memcmp(a1, a2, size);\n+  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, GET_CALLER_PC(), a1,\n+                             a2, size);\n+  if (common_flags()->intercept_memcmp) {\n+    if (common_flags()->strict_memcmp) {\n+      // Check the entire regions even if the first bytes of the buffers are\n+      // different.\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, a1, size);\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, a2, size);\n+      // Fallthrough to REAL(memcmp) below.\n+    } else {\n+      unsigned char c1 = 0, c2 = 0;\n+      const unsigned char *s1 = (const unsigned char*)a1;\n+      const unsigned char *s2 = (const unsigned char*)a2;\n+      uptr i;\n+      for (i = 0; i < size; i++) {\n+        c1 = s1[i];\n+        c2 = s2[i];\n+        if (c1 != c2) break;\n+      }\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, size));\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, size));\n+      return CharCmpX(c1, c2);\n+    }\n+  }\n+  return REAL(memcmp(a1, a2, size));\n+}\n+\n+#define INIT_MEMCMP COMMON_INTERCEPT_FUNCTION(memcmp)\n+#else\n+#define INIT_MEMCMP\n+#endif\n+\n #if SANITIZER_INTERCEPT_MEMCHR\n INTERCEPTOR(void*, memchr, const void *s, int c, SIZE_T n) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, memchr, s, c, n);\n   void *res = REAL(memchr)(s, c, n);\n-  uptr len = res ? (char*)res - (char*)s + 1 : n;\n+  uptr len = res ? (char *)res - (const char *)s + 1 : n;\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, s, len);\n   return res;\n }\n@@ -717,12 +906,12 @@ INTERCEPTOR(char *, strptime, char *s, char *format, __sanitizer_tm *tm) {\n   // its metadata. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(strptime)(s, format, tm);\n-  if (res) {\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, res - s);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, s, res ? res - s : 0);\n+  if (res && tm) {\n     // Do not call unpoison_tm here, because strptime does not, in fact,\n     // initialize the entire struct tm. For example, tm_zone pointer is left\n     // uninitialized.\n-    if (tm) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n   }\n   return res;\n }\n@@ -913,6 +1102,16 @@ INTERCEPTOR(int, vsnprintf, char *str, SIZE_T size, const char *format,\n             va_list ap)\n VSNPRINTF_INTERCEPTOR_IMPL(vsnprintf, str, size, format, ap)\n \n+#if SANITIZER_INTERCEPT_PRINTF_L\n+INTERCEPTOR(int, vsnprintf_l, char *str, SIZE_T size, void *loc,\n+            const char *format, va_list ap)\n+VSNPRINTF_INTERCEPTOR_IMPL(vsnprintf_l, str, size, loc, format, ap)\n+\n+INTERCEPTOR(int, snprintf_l, char *str, SIZE_T size, void *loc,\n+            const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(snprintf_l, vsnprintf_l, str, size, loc, format)\n+#endif  // SANITIZER_INTERCEPT_PRINTF_L\n+\n INTERCEPTOR(int, vsprintf, char *str, const char *format, va_list ap)\n VSPRINTF_INTERCEPTOR_IMPL(vsprintf, str, format, ap)\n \n@@ -989,6 +1188,14 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n #define INIT_PRINTF\n #endif\n \n+#if SANITIZER_INTERCEPT_PRINTF_L\n+#define INIT_PRINTF_L                     \\\n+  COMMON_INTERCEPT_FUNCTION(snprintf_l);  \\\n+  COMMON_INTERCEPT_FUNCTION(vsnprintf_l);\n+#else\n+#define INIT_PRINTF_L\n+#endif\n+\n #if SANITIZER_INTERCEPT_ISOC99_PRINTF\n #define INIT_ISOC99_PRINTF                       \\\n   COMMON_INTERCEPT_FUNCTION(__isoc99_printf);    \\\n@@ -1005,8 +1212,18 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n \n #if SANITIZER_INTERCEPT_IOCTL\n #include \"sanitizer_common_interceptors_ioctl.inc\"\n-INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n-  void *ctx;\n+INTERCEPTOR(int, ioctl, int d, unsigned long request, ...) {\n+  // We need a frame pointer, because we call into ioctl_common_[pre|post] which\n+  // can trigger a report and we need to be able to unwind through this\n+  // function.  On Mac in debug mode we might not have a frame pointer, because\n+  // ioctl_common_[pre|post] doesn't get inlined here.\n+  ENABLE_FRAME_POINTER;\n+\n+  void *ctx;\n+  va_list ap;\n+  va_start(ap, request);\n+  void *arg = va_arg(ap, void *);\n+  va_end(ap);\n   COMMON_INTERCEPTOR_ENTER(ctx, ioctl, d, request, arg);\n \n   CHECK(ioctl_initialized);\n@@ -1015,6 +1232,10 @@ INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n   // This effectively disables ioctl handling in TSan.\n   if (!common_flags()->handle_ioctl) return REAL(ioctl)(d, request, arg);\n \n+  // Although request is unsigned long, the rest of the interceptor uses it\n+  // as just \"unsigned\" to save space, because we know that all values fit in\n+  // \"unsigned\" - they are compile-time constants.\n+\n   const ioctl_desc *desc = ioctl_lookup(request);\n   ioctl_desc decoded_desc;\n   if (!desc) {\n@@ -1097,29 +1318,29 @@ INTERCEPTOR(__sanitizer_passwd *, getpwnam, const char *name) {\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwnam, name);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   __sanitizer_passwd *res = REAL(getpwnam)(name);\n-  if (res != 0) unpoison_passwd(ctx, res);\n+  if (res) unpoison_passwd(ctx, res);\n   return res;\n }\n INTERCEPTOR(__sanitizer_passwd *, getpwuid, u32 uid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwuid, uid);\n   __sanitizer_passwd *res = REAL(getpwuid)(uid);\n-  if (res != 0) unpoison_passwd(ctx, res);\n+  if (res) unpoison_passwd(ctx, res);\n   return res;\n }\n INTERCEPTOR(__sanitizer_group *, getgrnam, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrnam, name);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   __sanitizer_group *res = REAL(getgrnam)(name);\n-  if (res != 0) unpoison_group(ctx, res);\n+  if (res) unpoison_group(ctx, res);\n   return res;\n }\n INTERCEPTOR(__sanitizer_group *, getgrgid, u32 gid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrgid, gid);\n   __sanitizer_group *res = REAL(getgrgid)(gid);\n-  if (res != 0) unpoison_group(ctx, res);\n+  if (res) unpoison_group(ctx, res);\n   return res;\n }\n #define INIT_GETPWNAM_AND_FRIENDS      \\\n@@ -1208,14 +1429,14 @@ INTERCEPTOR(__sanitizer_passwd *, getpwent, int dummy) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwent, dummy);\n   __sanitizer_passwd *res = REAL(getpwent)(dummy);\n-  if (res != 0) unpoison_passwd(ctx, res);\n+  if (res) unpoison_passwd(ctx, res);\n   return res;\n }\n INTERCEPTOR(__sanitizer_group *, getgrent, int dummy) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrent, dummy);\n   __sanitizer_group *res = REAL(getgrent)(dummy);\n-  if (res != 0) unpoison_group(ctx, res);;\n+  if (res) unpoison_group(ctx, res);;\n   return res;\n }\n #define INIT_GETPWENT                  \\\n@@ -1230,14 +1451,14 @@ INTERCEPTOR(__sanitizer_passwd *, fgetpwent, void *fp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent, fp);\n   __sanitizer_passwd *res = REAL(fgetpwent)(fp);\n-  if (res != 0) unpoison_passwd(ctx, res);\n+  if (res) unpoison_passwd(ctx, res);\n   return res;\n }\n INTERCEPTOR(__sanitizer_group *, fgetgrent, void *fp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent, fp);\n   __sanitizer_group *res = REAL(fgetgrent)(fp);\n-  if (res != 0) unpoison_group(ctx, res);\n+  if (res) unpoison_group(ctx, res);\n   return res;\n }\n #define INIT_FGETPWENT                  \\\n@@ -1440,37 +1661,38 @@ static THREADLOCAL __sanitizer_glob_t *pglob_copy;\n \n static void wrapped_gl_closedir(void *dir) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n-  IndirectExternCall(pglob_copy->gl_closedir)(dir);\n+  pglob_copy->gl_closedir(dir);\n }\n \n static void *wrapped_gl_readdir(void *dir) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n-  return IndirectExternCall(pglob_copy->gl_readdir)(dir);\n+  return pglob_copy->gl_readdir(dir);\n }\n \n static void *wrapped_gl_opendir(const char *s) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n-  return IndirectExternCall(pglob_copy->gl_opendir)(s);\n+  return pglob_copy->gl_opendir(s);\n }\n \n static int wrapped_gl_lstat(const char *s, void *st) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n-  return IndirectExternCall(pglob_copy->gl_lstat)(s, st);\n+  return pglob_copy->gl_lstat(s, st);\n }\n \n static int wrapped_gl_stat(const char *s, void *st) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n-  return IndirectExternCall(pglob_copy->gl_stat)(s, st);\n+  return pglob_copy->gl_stat(s, st);\n }\n \n INTERCEPTOR(int, glob, const char *pattern, int flags,\n             int (*errfunc)(const char *epath, int eerrno),\n             __sanitizer_glob_t *pglob) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, glob, pattern, flags, errfunc, pglob);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n   __sanitizer_glob_t glob_copy = {\n       0,                  0,                   0,\n       0,                  wrapped_gl_closedir, wrapped_gl_readdir,\n@@ -1501,6 +1723,7 @@ INTERCEPTOR(int, glob64, const char *pattern, int flags,\n             __sanitizer_glob_t *pglob) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, glob64, pattern, flags, errfunc, pglob);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n   __sanitizer_glob_t glob_copy = {\n       0,                  0,                   0,\n       0,                  wrapped_gl_closedir, wrapped_gl_readdir,\n@@ -1647,6 +1870,7 @@ INTERCEPTOR(char *, inet_ntop, int af, const void *src, char *dst, u32 size) {\n INTERCEPTOR(int, inet_pton, int af, const char *src, void *dst) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, inet_pton, af, src, dst);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, src, 0);\n   // FIXME: figure out read size based on the address family.\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n@@ -2137,6 +2361,16 @@ INTERCEPTOR(int, sysinfo, void *info) {\n #endif\n \n #if SANITIZER_INTERCEPT_READDIR\n+INTERCEPTOR(__sanitizer_dirent *, opendir, const char *path) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, opendir, path);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  __sanitizer_dirent *res = REAL(opendir)(path);\n+  if (res)\n+    COMMON_INTERCEPTOR_DIR_ACQUIRE(ctx, path);\n+  return res;\n+}\n+\n INTERCEPTOR(__sanitizer_dirent *, readdir, void *dirp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readdir, dirp);\n@@ -2165,6 +2399,7 @@ INTERCEPTOR(int, readdir_r, void *dirp, __sanitizer_dirent *entry,\n }\n \n #define INIT_READDIR                  \\\n+  COMMON_INTERCEPT_FUNCTION(opendir); \\\n   COMMON_INTERCEPT_FUNCTION(readdir); \\\n   COMMON_INTERCEPT_FUNCTION(readdir_r);\n #else\n@@ -2306,15 +2541,47 @@ INTERCEPTOR(char *, get_current_dir_name, int fake) {\n #define INIT_GET_CURRENT_DIR_NAME\n #endif\n \n+UNUSED static inline void FixRealStrtolEndptr(const char *nptr, char **endptr) {\n+  CHECK(endptr);\n+  if (nptr == *endptr) {\n+    // No digits were found at strtol call, we need to find out the last\n+    // symbol accessed by strtoll on our own.\n+    // We get this symbol by skipping leading blanks and optional +/- sign.\n+    while (IsSpace(*nptr)) nptr++;\n+    if (*nptr == '+' || *nptr == '-') nptr++;\n+    *endptr = const_cast<char *>(nptr);\n+  }\n+  CHECK(*endptr >= nptr);\n+}\n+\n+UNUSED static inline void StrtolFixAndCheck(void *ctx, const char *nptr,\n+                             char **endptr, char *real_endptr, int base) {\n+  if (endptr) {\n+    *endptr = real_endptr;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n+  }\n+  // If base has unsupported value, strtol can exit with EINVAL\n+  // without reading any characters. So do additional checks only\n+  // if base is valid.\n+  bool is_valid_base = (base == 0) || (2 <= base && base <= 36);\n+  if (is_valid_base) {\n+    FixRealStrtolEndptr(nptr, &real_endptr);\n+  }\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, nptr, is_valid_base ?\n+                                 (real_endptr - nptr) + 1 : 0);\n+}\n+\n+\n #if SANITIZER_INTERCEPT_STRTOIMAX\n INTERCEPTOR(INTMAX_T, strtoimax, const char *nptr, char **endptr, int base) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strtoimax, nptr, endptr, base);\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n-  INTMAX_T res = REAL(strtoimax)(nptr, endptr, base);\n-  if (endptr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n+  char *real_endptr;\n+  INTMAX_T res = REAL(strtoimax)(nptr, &real_endptr, base);\n+  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n   return res;\n }\n \n@@ -2324,8 +2591,9 @@ INTERCEPTOR(INTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n-  INTMAX_T res = REAL(strtoumax)(nptr, endptr, base);\n-  if (endptr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n+  char *real_endptr;\n+  INTMAX_T res = REAL(strtoumax)(nptr, &real_endptr, base);\n+  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n   return res;\n }\n \n@@ -2456,7 +2724,7 @@ INTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n   // its metadata. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(wcsnrtombs)(dest, src, nms, len, ps);\n-  if (res != (SIZE_T) - 1 && dest && src) {\n+  if (res != ((SIZE_T)-1) && dest && src) {\n     SIZE_T write_cnt = res + !*src;\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n   }\n@@ -2468,6 +2736,28 @@ INTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n #define INIT_WCSNRTOMBS\n #endif\n \n+\n+#if SANITIZER_INTERCEPT_WCRTOMB\n+INTERCEPTOR(SIZE_T, wcrtomb, char *dest, wchar_t src, void *ps) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcrtomb, dest, src, ps);\n+  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n+  SIZE_T res = REAL(wcrtomb)(dest, src, ps);\n+  if (res != ((SIZE_T)-1) && dest) {\n+    SIZE_T write_cnt = res;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n+  }\n+  return res;\n+}\n+\n+#define INIT_WCRTOMB COMMON_INTERCEPT_FUNCTION(wcrtomb);\n+#else\n+#define INIT_WCRTOMB\n+#endif\n+\n #if SANITIZER_INTERCEPT_TCGETATTR\n INTERCEPTOR(int, tcgetattr, int fd, void *termios_p) {\n   void *ctx;\n@@ -2496,7 +2786,7 @@ INTERCEPTOR(char *, realpath, const char *path, char *resolved_path) {\n   // version of a versioned symbol. For realpath(), this gives us something\n   // (called __old_realpath) that does not handle NULL in the second argument.\n   // Handle it as part of the interceptor.\n-  char *allocated_path = 0;\n+  char *allocated_path = nullptr;\n   if (!resolved_path)\n     allocated_path = resolved_path = (char *)WRAP(malloc)(path_max + 1);\n \n@@ -2558,6 +2848,19 @@ INTERCEPTOR(int, sched_getaffinity, int pid, SIZE_T cpusetsize, void *mask) {\n #define INIT_SCHED_GETAFFINITY\n #endif\n \n+#if SANITIZER_INTERCEPT_SCHED_GETPARAM\n+INTERCEPTOR(int, sched_getparam, int pid, void *param) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sched_getparam, pid, param);\n+  int res = REAL(sched_getparam)(pid, param);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, param, struct_sched_param_sz);\n+  return res;\n+}\n+#define INIT_SCHED_GETPARAM COMMON_INTERCEPT_FUNCTION(sched_getparam);\n+#else\n+#define INIT_SCHED_GETPARAM\n+#endif\n+\n #if SANITIZER_INTERCEPT_STRERROR\n INTERCEPTOR(char *, strerror, int errnum) {\n   void *ctx;\n@@ -2631,7 +2934,7 @@ static THREADLOCAL scandir_compar_f scandir_compar;\n static int wrapped_scandir_filter(const struct __sanitizer_dirent *dir) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n-  return IndirectExternCall(scandir_filter)(dir);\n+  return scandir_filter(dir);\n }\n \n static int wrapped_scandir_compar(const struct __sanitizer_dirent **a,\n@@ -2641,7 +2944,7 @@ static int wrapped_scandir_compar(const struct __sanitizer_dirent **a,\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n-  return IndirectExternCall(scandir_compar)(a, b);\n+  return scandir_compar(a, b);\n }\n \n INTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n@@ -2654,10 +2957,11 @@ INTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n-  int res = REAL(scandir)(dirp, namelist, filter ? wrapped_scandir_filter : 0,\n-                          compar ? wrapped_scandir_compar : 0);\n-  scandir_filter = 0;\n-  scandir_compar = 0;\n+  int res = REAL(scandir)(dirp, namelist,\n+                          filter ? wrapped_scandir_filter : nullptr,\n+                          compar ? wrapped_scandir_compar : nullptr);\n+  scandir_filter = nullptr;\n+  scandir_compar = nullptr;\n   if (namelist && res > 0) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n@@ -2683,7 +2987,7 @@ static THREADLOCAL scandir64_compar_f scandir64_compar;\n static int wrapped_scandir64_filter(const struct __sanitizer_dirent64 *dir) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n-  return IndirectExternCall(scandir64_filter)(dir);\n+  return scandir64_filter(dir);\n }\n \n static int wrapped_scandir64_compar(const struct __sanitizer_dirent64 **a,\n@@ -2693,7 +2997,7 @@ static int wrapped_scandir64_compar(const struct __sanitizer_dirent64 **a,\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n   COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n-  return IndirectExternCall(scandir64_compar)(a, b);\n+  return scandir64_compar(a, b);\n }\n \n INTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n@@ -2707,10 +3011,11 @@ INTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n   // its metadata. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res =\n-      REAL(scandir64)(dirp, namelist, filter ? wrapped_scandir64_filter : 0,\n-                      compar ? wrapped_scandir64_compar : 0);\n-  scandir64_filter = 0;\n-  scandir64_compar = 0;\n+      REAL(scandir64)(dirp, namelist,\n+                      filter ? wrapped_scandir64_filter : nullptr,\n+                      compar ? wrapped_scandir64_compar : nullptr);\n+  scandir64_filter = nullptr;\n+  scandir64_compar = nullptr;\n   if (namelist && res > 0) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n@@ -3576,6 +3881,7 @@ INTERCEPTOR(char *, tempnam, char *dir, char *pfx) {\n INTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_setname_np, thread, name);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, name, 0);\n   COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name);\n   return REAL(pthread_setname_np)(thread, name);\n }\n@@ -3792,25 +4098,33 @@ INTERCEPTOR(SSIZE_T, getline, char **lineptr, SIZE_T *n, void *stream) {\n   }\n   return res;\n }\n-INTERCEPTOR(SSIZE_T, __getdelim, char **lineptr, SIZE_T *n, int delim,\n-            void *stream) {\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, __getdelim, lineptr, n, delim, stream);\n-  // FIXME: under ASan the call below may write to freed memory and corrupt\n-  // its metadata. See\n-  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n-  SSIZE_T res = REAL(__getdelim)(lineptr, n, delim, stream);\n-  if (res > 0) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);\n+\n+// FIXME: under ASan the call below may write to freed memory and corrupt its\n+// metadata. See\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n+#define GETDELIM_INTERCEPTOR_IMPL(vname)                                       \\\n+  {                                                                            \\\n+    void *ctx;                                                                 \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, vname, lineptr, n, delim, stream);           \\\n+    SSIZE_T res = REAL(vname)(lineptr, n, delim, stream);                      \\\n+    if (res > 0) {                                                             \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));          \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));                      \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);                  \\\n+    }                                                                          \\\n+    return res;                                                                \\\n   }\n-  return res;\n-}\n+\n+INTERCEPTOR(SSIZE_T, __getdelim, char **lineptr, SIZE_T *n, int delim,\n+            void *stream)\n+GETDELIM_INTERCEPTOR_IMPL(__getdelim)\n+\n+// There's no __getdelim() on FreeBSD so we supply the getdelim() interceptor\n+// with its own body.\n INTERCEPTOR(SSIZE_T, getdelim, char **lineptr, SIZE_T *n, int delim,\n-            void *stream) {\n-  return __getdelim(lineptr, n, delim, stream);\n-}\n+            void *stream)\n+GETDELIM_INTERCEPTOR_IMPL(getdelim)\n+\n #define INIT_GETLINE                     \\\n   COMMON_INTERCEPT_FUNCTION(getline);    \\\n   COMMON_INTERCEPT_FUNCTION(__getdelim); \\\n@@ -3831,7 +4145,7 @@ INTERCEPTOR(SIZE_T, iconv, void *cd, char **inbuf, SIZE_T *inbytesleft,\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, *inbuf, *inbytesleft);\n   if (outbytesleft)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, outbytesleft, sizeof(*outbytesleft));\n-  void *outbuf_orig = outbuf ? *outbuf : 0;\n+  void *outbuf_orig = outbuf ? *outbuf : nullptr;\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n@@ -3866,11 +4180,19 @@ INTERCEPTOR(__sanitizer_clock_t, times, void *tms) {\n \n #if SANITIZER_INTERCEPT_TLS_GET_ADDR\n #define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_addr)\n+// If you see any crashes around this functions, there are 2 known issues with\n+// it: 1. __tls_get_addr can be called with mis-aligned stack due to:\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58066\n+// 2. It can be called recursively if sanitizer code uses __tls_get_addr\n+// to access thread local variables (it should not happen normally,\n+// because sanitizers use initial-exec tls model).\n INTERCEPTOR(void *, __tls_get_addr, void *arg) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr, arg);\n   void *res = REAL(__tls_get_addr)(arg);\n-  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res);\n+  uptr tls_begin, tls_end;\n+  COMMON_INTERCEPTOR_GET_TLS_RANGE(&tls_begin, &tls_end);\n+  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res, tls_begin, tls_end);\n   if (dtv) {\n     // New DTLS block has been allocated.\n     COMMON_INTERCEPTOR_INITIALIZE_RANGE((void *)dtv->beg, dtv->size);\n@@ -4106,9 +4428,9 @@ INTERCEPTOR(int, capset, void *hdrp, const void *datap) {\n #endif\n \n #if SANITIZER_INTERCEPT_AEABI_MEM\n-DECLARE_REAL_AND_INTERCEPTOR(void *, memmove, void *, const void *, uptr);\n-DECLARE_REAL_AND_INTERCEPTOR(void *, memcpy, void *, const void *, uptr);\n-DECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr);\n+DECLARE_REAL_AND_INTERCEPTOR(void *, memmove, void *, const void *, uptr)\n+DECLARE_REAL_AND_INTERCEPTOR(void *, memcpy, void *, const void *, uptr)\n+DECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr)\n \n INTERCEPTOR(void *, __aeabi_memmove, void *to, const void *from, uptr size) {\n   return WRAP(memmove)(to, from, size);\n@@ -4448,7 +4770,7 @@ INTERCEPTOR(__sanitizer_FILE *, freopen, const char *path, const char *mode,\n             __sanitizer_FILE *fp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, freopen, path, mode, fp);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n   COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n   __sanitizer_FILE *res = REAL(freopen)(path, mode, fp);\n@@ -4479,7 +4801,7 @@ INTERCEPTOR(__sanitizer_FILE *, freopen64, const char *path, const char *mode,\n             __sanitizer_FILE *fp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, freopen64, path, mode, fp);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n   COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n   __sanitizer_FILE *res = REAL(freopen64)(path, mode, fp);\n@@ -4608,15 +4930,14 @@ INTERCEPTOR(int, fflush, __sanitizer_FILE *fp) {\n INTERCEPTOR(int, fclose, __sanitizer_FILE *fp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fclose, fp);\n-  if (fp) {\n-    COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n-    const FileMetadata *m = GetInterceptorMetadata(fp);\n-    if (m) {\n-      COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n-      DeleteInterceptorMetadata(fp);\n-    }\n+  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n+  const FileMetadata *m = GetInterceptorMetadata(fp);\n+  int res = REAL(fclose)(fp);\n+  if (m) {\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n+    DeleteInterceptorMetadata(fp);\n   }\n-  return REAL(fclose)(fp);\n+  return res;\n }\n #define INIT_FCLOSE COMMON_INTERCEPT_FUNCTION(fclose);\n #else\n@@ -4627,6 +4948,8 @@ INTERCEPTOR(int, fclose, __sanitizer_FILE *fp) {\n INTERCEPTOR(void*, dlopen, const char *filename, int flag) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlopen, filename, flag);\n+  if (filename) COMMON_INTERCEPTOR_READ_STRING(ctx, filename, 0);\n+  COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag);\n   void *res = REAL(dlopen)(filename, flag);\n   COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res);\n   return res;\n@@ -4697,7 +5020,7 @@ static void MlockIsUnsupported() {\n   static atomic_uint8_t printed;\n   if (atomic_exchange(&printed, 1, memory_order_relaxed))\n     return;\n-  VPrintf(1, \"INFO: %s ignores mlock/mlockall/munlock/munlockall\\n\",\n+  VPrintf(1, \"%s ignores mlock/mlockall/munlock/munlockall\\n\",\n           SanitizerToolName);\n }\n \n@@ -4731,6 +5054,186 @@ INTERCEPTOR(int, munlockall, void) {\n #define INIT_MLOCKX\n #endif  // SANITIZER_INTERCEPT_MLOCKX\n \n+#if SANITIZER_INTERCEPT_FOPENCOOKIE\n+struct WrappedCookie {\n+  void *real_cookie;\n+  __sanitizer_cookie_io_functions_t real_io_funcs;\n+};\n+\n+static uptr wrapped_read(void *cookie, char *buf, uptr size) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n+  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n+  __sanitizer_cookie_io_read real_read = wrapped_cookie->real_io_funcs.read;\n+  return real_read ? real_read(wrapped_cookie->real_cookie, buf, size) : 0;\n+}\n+\n+static uptr wrapped_write(void *cookie, const char *buf, uptr size) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n+  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n+  __sanitizer_cookie_io_write real_write = wrapped_cookie->real_io_funcs.write;\n+  return real_write ? real_write(wrapped_cookie->real_cookie, buf, size) : size;\n+}\n+\n+static int wrapped_seek(void *cookie, u64 *offset, int whence) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(offset, sizeof(*offset));\n+  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n+  __sanitizer_cookie_io_seek real_seek = wrapped_cookie->real_io_funcs.seek;\n+  return real_seek ? real_seek(wrapped_cookie->real_cookie, offset, whence)\n+                   : -1;\n+}\n+\n+static int wrapped_close(void *cookie) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n+  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n+  __sanitizer_cookie_io_close real_close = wrapped_cookie->real_io_funcs.close;\n+  int res = real_close ? real_close(wrapped_cookie->real_cookie) : 0;\n+  InternalFree(wrapped_cookie);\n+  return res;\n+}\n+\n+INTERCEPTOR(__sanitizer_FILE *, fopencookie, void *cookie, const char *mode,\n+            __sanitizer_cookie_io_functions_t io_funcs) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fopencookie, cookie, mode, io_funcs);\n+  WrappedCookie *wrapped_cookie =\n+      (WrappedCookie *)InternalAlloc(sizeof(WrappedCookie));\n+  wrapped_cookie->real_cookie = cookie;\n+  wrapped_cookie->real_io_funcs = io_funcs;\n+  __sanitizer_FILE *res =\n+      REAL(fopencookie)(wrapped_cookie, mode, {wrapped_read, wrapped_write,\n+                                               wrapped_seek, wrapped_close});\n+  return res;\n+}\n+\n+#define INIT_FOPENCOOKIE COMMON_INTERCEPT_FUNCTION(fopencookie);\n+#else\n+#define INIT_FOPENCOOKIE\n+#endif  // SANITIZER_INTERCEPT_FOPENCOOKIE\n+\n+#if SANITIZER_INTERCEPT_SEM\n+INTERCEPTOR(int, sem_init, __sanitizer_sem_t *s, int pshared, unsigned value) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sem_init, s, pshared, value);\n+  // Workaround a bug in glibc's \"old\" semaphore implementation by\n+  // zero-initializing the sem_t contents. This has to be done here because\n+  // interceptors bind to the lowest symbols version by default, hitting the\n+  // buggy code path while the non-sanitized build of the same code works fine.\n+  REAL(memset)(s, 0, sizeof(*s));\n+  int res = REAL(sem_init)(s, pshared, value);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sem_destroy, __sanitizer_sem_t *s) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sem_destroy, s);\n+  int res = REAL(sem_destroy)(s);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sem_wait, __sanitizer_sem_t *s) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sem_wait, s);\n+  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_wait)(s);\n+  if (res == 0) {\n+    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sem_trywait, __sanitizer_sem_t *s) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sem_trywait, s);\n+  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_trywait)(s);\n+  if (res == 0) {\n+    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sem_timedwait, __sanitizer_sem_t *s, void *abstime) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sem_timedwait, s, abstime);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, abstime, struct_timespec_sz);\n+  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_timedwait)(s, abstime);\n+  if (res == 0) {\n+    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sem_post, __sanitizer_sem_t *s) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sem_post, s);\n+  COMMON_INTERCEPTOR_RELEASE(ctx, (uptr)s);\n+  int res = REAL(sem_post)(s);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sem_getvalue, __sanitizer_sem_t *s, int *sval) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sem_getvalue, s, sval);\n+  int res = REAL(sem_getvalue)(s, sval);\n+  if (res == 0) {\n+    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sval, sizeof(*sval));\n+  }\n+  return res;\n+}\n+#define INIT_SEM                                                               \\\n+  COMMON_INTERCEPT_FUNCTION(sem_init);                                         \\\n+  COMMON_INTERCEPT_FUNCTION(sem_destroy);                                      \\\n+  COMMON_INTERCEPT_FUNCTION(sem_wait);                                         \\\n+  COMMON_INTERCEPT_FUNCTION(sem_trywait);                                      \\\n+  COMMON_INTERCEPT_FUNCTION(sem_timedwait);                                    \\\n+  COMMON_INTERCEPT_FUNCTION(sem_post);                                         \\\n+  COMMON_INTERCEPT_FUNCTION(sem_getvalue);\n+#else\n+#define INIT_SEM\n+#endif // SANITIZER_INTERCEPT_SEM\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_SETCANCEL\n+INTERCEPTOR(int, pthread_setcancelstate, int state, int *oldstate) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcancelstate, state, oldstate);\n+  int res = REAL(pthread_setcancelstate)(state, oldstate);\n+  if (res == 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldstate, sizeof(*oldstate));\n+  return res;\n+}\n+\n+INTERCEPTOR(int, pthread_setcanceltype, int type, int *oldtype) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcanceltype, type, oldtype);\n+  int res = REAL(pthread_setcanceltype)(type, oldtype);\n+  if (res == 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldtype, sizeof(*oldtype));\n+  return res;\n+}\n+#define INIT_PTHREAD_SETCANCEL                                                 \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_setcancelstate);                           \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_setcanceltype);\n+#else\n+#define INIT_PTHREAD_SETCANCEL\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MINCORE\n+INTERCEPTOR(int, mincore, void *addr, uptr length, unsigned char *vec) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, mincore, addr, length, vec);\n+  int res = REAL(mincore)(addr, length, vec);\n+  if (res == 0) {\n+    uptr page_size = GetPageSizeCached();\n+    uptr vec_size = ((length + page_size - 1) & (~(page_size - 1))) / page_size;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, vec, vec_size);\n+  }\n+  return res;\n+}\n+#define INIT_MINCORE COMMON_INTERCEPT_FUNCTION(mincore);\n+#else\n+#define INIT_MINCORE\n+#endif\n+\n static void InitializeCommonInterceptors() {\n   static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n   interceptor_metadata_map = new((void *)&metadata_mem) MetadataHashMap();\n@@ -4740,7 +5243,12 @@ static void InitializeCommonInterceptors() {\n   INIT_STRNCMP;\n   INIT_STRCASECMP;\n   INIT_STRNCASECMP;\n+  INIT_STRSTR;\n+  INIT_STRCASESTR;\n+  INIT_STRSPN;\n+  INIT_STRPBRK;\n   INIT_MEMCHR;\n+  INIT_MEMCMP;\n   INIT_MEMRCHR;\n   INIT_READ;\n   INIT_PREAD;\n@@ -4760,6 +5268,7 @@ static void InitializeCommonInterceptors() {\n   INIT_SCANF;\n   INIT_ISOC99_SCANF;\n   INIT_PRINTF;\n+  INIT_PRINTF_L;\n   INIT_ISOC99_PRINTF;\n   INIT_FREXP;\n   INIT_FREXPF_FREXPL;\n@@ -4805,11 +5314,13 @@ static void InitializeCommonInterceptors() {\n   INIT_MBSNRTOWCS;\n   INIT_WCSTOMBS;\n   INIT_WCSNRTOMBS;\n+  INIT_WCRTOMB;\n   INIT_TCGETATTR;\n   INIT_REALPATH;\n   INIT_CANONICALIZE_FILE_NAME;\n   INIT_CONFSTR;\n   INIT_SCHED_GETAFFINITY;\n+  INIT_SCHED_GETPARAM;\n   INIT_STRERROR;\n   INIT_STRERROR_R;\n   INIT_XPG_STRERROR_R;\n@@ -4892,4 +5403,8 @@ static void InitializeCommonInterceptors() {\n   INIT_GETPASS;\n   INIT_TIMERFD;\n   INIT_MLOCKX;\n+  INIT_FOPENCOOKIE;\n+  INIT_SEM;\n+  INIT_PTHREAD_SETCANCEL;\n+  INIT_MINCORE;\n }"}, {"sha": "9133be7097d598806cb75addfcd2320717b5ffa2", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_format.inc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -11,6 +11,7 @@\n // with a few common GNU extensions.\n //\n //===----------------------------------------------------------------------===//\n+\n #include <stdarg.h>\n \n static const char *parse_number(const char *p, int *out) {\n@@ -189,7 +190,7 @@ static const char *scanf_parse_next(const char *p, bool allowGnuMalloc,\n       continue;\n     }\n     if (*p == '\\0') {\n-      return 0;\n+      return nullptr;\n     }\n     // %n$\n     p = maybe_parse_param_index(p, &dir->argIdx);\n@@ -204,7 +205,7 @@ static const char *scanf_parse_next(const char *p, bool allowGnuMalloc,\n       p = parse_number(p, &dir->fieldWidth);\n       CHECK(p);\n       if (dir->fieldWidth <= 0)  // Width if at all must be non-zero\n-        return 0;\n+        return nullptr;\n     }\n     // m\n     if (*p == 'm') {\n@@ -224,8 +225,8 @@ static const char *scanf_parse_next(const char *p, bool allowGnuMalloc,\n       while (*p && *p != ']')\n         ++p;\n       if (*p == 0)\n-        return 0; // unexpected end of string\n-                  // Consume the closing ']'.\n+        return nullptr; // unexpected end of string\n+                        // Consume the closing ']'.\n       ++p;\n     }\n     // This is unfortunately ambiguous between old GNU extension\n@@ -249,7 +250,7 @@ static const char *scanf_parse_next(const char *p, bool allowGnuMalloc,\n         while (*q && *q != ']' && *q != '%')\n           ++q;\n         if (*q == 0 || *q == '%')\n-          return 0;\n+          return nullptr;\n         p = q + 1; // Consume the closing ']'.\n         dir->maybeGnuMalloc = true;\n       }\n@@ -393,7 +394,7 @@ static const char *printf_parse_next(const char *p, PrintfDirective *dir) {\n       continue;\n     }\n     if (*p == '\\0') {\n-      return 0;\n+      return nullptr;\n     }\n     // %n$\n     p = maybe_parse_param_index(p, &dir->precisionIdx);\n@@ -406,15 +407,15 @@ static const char *printf_parse_next(const char *p, PrintfDirective *dir) {\n     p = maybe_parse_number_or_star(p, &dir->fieldWidth,\n                                    &dir->starredWidth);\n     if (!p)\n-      return 0;\n+      return nullptr;\n     // Precision\n     if (*p == '.') {\n       ++p;\n       // Actual precision is optional (surprise!)\n       p = maybe_parse_number_or_star(p, &dir->fieldPrecision,\n                                      &dir->starredPrecision);\n       if (!p)\n-        return 0;\n+        return nullptr;\n       // m$\n       if (dir->starredPrecision) {\n         p = maybe_parse_param_index(p, &dir->precisionIdx);\n@@ -554,4 +555,4 @@ static void printf_common(void *ctx, const char *format, va_list aq) {\n   }\n }\n \n-#endif  // SANITIZER_INTERCEPT_PRINTF\n+#endif // SANITIZER_INTERCEPT_PRINTF"}, {"sha": "6c5fda09fbf39ca7c07312a2b01c4774ff6dda0c", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -518,7 +518,7 @@ static const ioctl_desc *ioctl_table_lookup(unsigned req) {\n   if (left == right && ioctl_table[left].req == req)\n     return ioctl_table + left;\n   else\n-    return 0;\n+    return nullptr;\n }\n \n static bool ioctl_decode(unsigned req, ioctl_desc *desc) {\n@@ -565,7 +565,7 @@ static const ioctl_desc *ioctl_lookup(unsigned req) {\n       (desc->type == ioctl_desc::READWRITE || desc->type == ioctl_desc::WRITE ||\n        desc->type == ioctl_desc::READ))\n     return desc;\n-  return 0;\n+  return nullptr;\n }\n \n static void ioctl_common_pre(void *ctx, const ioctl_desc *desc, int d,\n@@ -576,14 +576,10 @@ static void ioctl_common_pre(void *ctx, const ioctl_desc *desc, int d,\n   }\n   if (desc->type != ioctl_desc::CUSTOM)\n     return;\n-  switch (request) {\n-    case 0x00008912: {  // SIOCGIFCONF\n-      struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n-      COMMON_INTERCEPTOR_READ_RANGE(ctx, &ifc->ifc_len, sizeof(ifc->ifc_len));\n-      break;\n-    }\n+  if (request == IOCTL_SIOCGIFCONF) {\n+    struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, &ifc->ifc_len, sizeof(ifc->ifc_len));\n   }\n-  return;\n }\n \n static void ioctl_common_post(void *ctx, const ioctl_desc *desc, int res, int d,\n@@ -595,12 +591,8 @@ static void ioctl_common_post(void *ctx, const ioctl_desc *desc, int res, int d,\n   }\n   if (desc->type != ioctl_desc::CUSTOM)\n     return;\n-  switch (request) {\n-    case 0x00008912: {  // SIOCGIFCONF\n-      struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifc->ifc_ifcu.ifcu_req, ifc->ifc_len);\n-      break;\n-    }\n+  if (request == IOCTL_SIOCGIFCONF) {\n+    struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifc->ifc_ifcu.ifcu_req, ifc->ifc_len);\n   }\n-  return;\n }"}, {"sha": "5a76c4ebd8bf434d3ebc9a0cf3655c26bae0a8af", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc", "status": "modified", "additions": 86, "deletions": 24, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -11,35 +11,31 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n+#include \"sanitizer_stackdepot.h\"\n #include \"sanitizer_stacktrace.h\"\n #include \"sanitizer_symbolizer.h\"\n \n+#if SANITIZER_POSIX\n+#include \"sanitizer_posix.h\"\n+#endif\n+\n namespace __sanitizer {\n \n-bool PrintsToTty() {\n-  MaybeOpenReportFile();\n-  return internal_isatty(report_fd) != 0;\n+bool ReportFile::SupportsColors() {\n+  SpinMutexLock l(mu);\n+  ReopenIfNecessary();\n+  return SupportsColoredOutput(fd);\n }\n \n-bool PrintsToTtyCached() {\n+bool ColorizeReports() {\n   // FIXME: Add proper Windows support to AnsiColorDecorator and re-enable color\n   // printing on Windows.\n   if (SANITIZER_WINDOWS)\n-    return 0;\n-\n-  static int cached = 0;\n-  static bool prints_to_tty;\n-  if (!cached) {  // Not thread-safe.\n-    prints_to_tty = PrintsToTty();\n-    cached = 1;\n-  }\n-  return prints_to_tty;\n-}\n+    return false;\n \n-bool ColorizeReports() {\n   const char *flag = common_flags()->color;\n   return internal_strcmp(flag, \"always\") == 0 ||\n-         (internal_strcmp(flag, \"auto\") == 0 && PrintsToTtyCached());\n+         (internal_strcmp(flag, \"auto\") == 0 && report_file.SupportsColors());\n }\n \n static void (*sandboxing_callback)();\n@@ -50,16 +46,82 @@ void SetSandboxingCallback(void (*f)()) {\n void ReportErrorSummary(const char *error_type, StackTrace *stack) {\n   if (!common_flags()->print_summary)\n     return;\n-  AddressInfo ai;\n-#if !SANITIZER_GO\n-  if (stack->size > 0 && Symbolizer::GetOrInit()->CanReturnFileLineInfo()) {\n-    // Currently, we include the first stack frame into the report summary.\n-    // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n-    uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n-    Symbolizer::GetOrInit()->SymbolizePC(pc, &ai, 1);\n+  if (stack->size == 0) {\n+    ReportErrorSummary(error_type);\n+    return;\n   }\n+  // Currently, we include the first stack frame into the report summary.\n+  // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n+  uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n+  SymbolizedStack *frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n+  ReportErrorSummary(error_type, frame->info);\n+  frame->ClearAll();\n+}\n+\n+static void (*SoftRssLimitExceededCallback)(bool exceeded);\n+void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded)) {\n+  CHECK_EQ(SoftRssLimitExceededCallback, nullptr);\n+  SoftRssLimitExceededCallback = Callback;\n+}\n+\n+void BackgroundThread(void *arg) {\n+  uptr hard_rss_limit_mb = common_flags()->hard_rss_limit_mb;\n+  uptr soft_rss_limit_mb = common_flags()->soft_rss_limit_mb;\n+  uptr prev_reported_rss = 0;\n+  uptr prev_reported_stack_depot_size = 0;\n+  bool reached_soft_rss_limit = false;\n+  while (true) {\n+    SleepForMillis(100);\n+    uptr current_rss_mb = GetRSS() >> 20;\n+    if (Verbosity()) {\n+      // If RSS has grown 10% since last time, print some information.\n+      if (prev_reported_rss * 11 / 10 < current_rss_mb) {\n+        Printf(\"%s: RSS: %zdMb\\n\", SanitizerToolName, current_rss_mb);\n+        prev_reported_rss = current_rss_mb;\n+      }\n+      // If stack depot has grown 10% since last time, print it too.\n+      StackDepotStats *stack_depot_stats = StackDepotGetStats();\n+      if (prev_reported_stack_depot_size * 11 / 10 <\n+          stack_depot_stats->allocated) {\n+        Printf(\"%s: StackDepot: %zd ids; %zdM allocated\\n\",\n+               SanitizerToolName,\n+               stack_depot_stats->n_uniq_ids,\n+               stack_depot_stats->allocated >> 20);\n+        prev_reported_stack_depot_size = stack_depot_stats->allocated;\n+      }\n+    }\n+    // Check RSS against the limit.\n+    if (hard_rss_limit_mb && hard_rss_limit_mb < current_rss_mb) {\n+      Report(\"%s: hard rss limit exhausted (%zdMb vs %zdMb)\\n\",\n+             SanitizerToolName, hard_rss_limit_mb, current_rss_mb);\n+      DumpProcessMap();\n+      Die();\n+    }\n+    if (soft_rss_limit_mb) {\n+      if (soft_rss_limit_mb < current_rss_mb && !reached_soft_rss_limit) {\n+        reached_soft_rss_limit = true;\n+        Report(\"%s: soft rss limit exhausted (%zdMb vs %zdMb)\\n\",\n+               SanitizerToolName, soft_rss_limit_mb, current_rss_mb);\n+        if (SoftRssLimitExceededCallback)\n+          SoftRssLimitExceededCallback(true);\n+      } else if (soft_rss_limit_mb >= current_rss_mb &&\n+                 reached_soft_rss_limit) {\n+        reached_soft_rss_limit = false;\n+        if (SoftRssLimitExceededCallback)\n+          SoftRssLimitExceededCallback(false);\n+      }\n+    }\n+  }\n+}\n+\n+void MaybeStartBackgroudThread() {\n+#if SANITIZER_LINUX  // Need to implement/test on other platforms.\n+  // Start the background thread if one of the rss limits is given.\n+  if (!common_flags()->hard_rss_limit_mb &&\n+      !common_flags()->soft_rss_limit_mb) return;\n+  if (!&real_pthread_create) return;  // Can't spawn the thread anyway.\n+  internal_start_thread(BackgroundThread, nullptr);\n #endif\n-  ReportErrorSummary(error_type, ai.file, ai.line, ai.function);\n }\n \n }  // namespace __sanitizer"}, {"sha": "5e83ce9786c94be6f684a17aecc7480471ba0c19", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -2297,7 +2297,9 @@ PRE_SYSCALL(ni_syscall)() {}\n POST_SYSCALL(ni_syscall)(long res) {}\n \n PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n-#if !SANITIZER_ANDROID && (defined(__i386) || defined (__x86_64))\n+#if !SANITIZER_ANDROID && \\\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n+     defined(__powerpc64__) || defined(__aarch64__))\n   if (data) {\n     if (request == ptrace_setregs) {\n       PRE_READ((void *)data, struct_user_regs_struct_sz);\n@@ -2316,7 +2318,9 @@ PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n }\n \n POST_SYSCALL(ptrace)(long res, long request, long pid, long addr, long data) {\n-#if !SANITIZER_ANDROID && (defined(__i386) || defined (__x86_64))\n+#if !SANITIZER_ANDROID && \\\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n+     defined(__powerpc64__) || defined(__aarch64__))\n   if (res >= 0 && data) {\n     // Note that this is different from the interceptor in\n     // sanitizer_common_interceptors.inc."}, {"sha": "108a6163d19df3e959f422fbbd31d4c144cbc7f8", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep.cc", "status": "modified", "additions": 613, "deletions": 140, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -10,18 +10,24 @@\n //\n // Compiler instrumentation:\n // For every interesting basic block the compiler injects the following code:\n-// if (*Guard) {\n-//    __sanitizer_cov();\n-//    *Guard = 1;\n+// if (Guard < 0) {\n+//    __sanitizer_cov(&Guard);\n // }\n+// At the module start up time __sanitizer_cov_module_init sets the guards\n+// to consecutive negative numbers (-1, -2, -3, ...).\n // It's fine to call __sanitizer_cov more than once for a given block.\n //\n // Run-time:\n //  - __sanitizer_cov(): record that we've executed the PC (GET_CALLER_PC).\n+//    and atomically set Guard to -Guard.\n //  - __sanitizer_cov_dump: dump the coverage data to disk.\n //  For every module of the current process that has coverage data\n-//  this will create a file module_name.PID.sancov. The file format is simple:\n-//  it's just a sorted sequence of 4-byte offsets in the module.\n+//  this will create a file module_name.PID.sancov.\n+//\n+// The file format is simple: the first 8 bytes is the magic,\n+// one of 0xC0BFFFFFFFFFFF64 and 0xC0BFFFFFFFFFFF32. The last byte of the\n+// magic defines the size of the following offsets.\n+// The rest of the data is the offsets in the module.\n //\n // Eventually, this coverage implementation should be obsoleted by a more\n // powerful general purpose Clang/LLVM coverage instrumentation.\n@@ -39,7 +45,12 @@\n #include \"sanitizer_symbolizer.h\"\n #include \"sanitizer_flags.h\"\n \n-atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n+static const u64 kMagic64 = 0xC0BFFFFFFFFFFF64ULL;\n+static const u64 kMagic32 = 0xC0BFFFFFFFFFFF32ULL;\n+\n+static atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n+\n+static atomic_uintptr_t coverage_counter;\n \n // pc_array is the array containing the covered PCs.\n // To make the pc_array thread- and async-signal-safe it has to be large enough.\n@@ -50,29 +61,55 @@ atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n // dump current memory layout to another file.\n \n static bool cov_sandboxed = false;\n-static int cov_fd = kInvalidFd;\n+static fd_t cov_fd = kInvalidFd;\n static unsigned int cov_max_block_size = 0;\n+static bool coverage_enabled = false;\n+static const char *coverage_dir;\n \n namespace __sanitizer {\n \n class CoverageData {\n  public:\n   void Init();\n+  void Enable();\n+  void Disable();\n+  void ReInit();\n   void BeforeFork();\n   void AfterFork(int child_pid);\n   void Extend(uptr npcs);\n-  void Add(uptr pc);\n+  void Add(uptr pc, u32 *guard);\n   void IndirCall(uptr caller, uptr callee, uptr callee_cache[],\n                  uptr cache_size);\n   void DumpCallerCalleePairs();\n+  void DumpTrace();\n+  void DumpAsBitSet();\n+  void DumpCounters();\n+  void DumpOffsets();\n+  void DumpAll();\n+\n+  ALWAYS_INLINE\n+  void TraceBasicBlock(s32 *id);\n+\n+  void InitializeGuardArray(s32 *guards);\n+  void InitializeGuards(s32 *guards, uptr n, const char *module_name,\n+                        uptr caller_pc);\n+  void InitializeCounters(u8 *counters, uptr n);\n+  void ReinitializeGuards();\n+  uptr GetNumberOf8bitCounters();\n+  uptr Update8bitCounterBitsetAndClearCounters(u8 *bitset);\n \n   uptr *data();\n   uptr size();\n \n  private:\n+  void DirectOpen();\n+  void UpdateModuleNameVec(uptr caller_pc, uptr range_beg, uptr range_end);\n+\n   // Maximal size pc array may ever grow.\n   // We MmapNoReserve this space to ensure that the array is contiguous.\n-  static const uptr kPcArrayMaxSize = FIRST_32_SECOND_64(1 << 22, 1 << 27);\n+  static const uptr kPcArrayMaxSize = FIRST_32_SECOND_64(\n+      1 << (SANITIZER_ANDROID ? 24 : (SANITIZER_WINDOWS ? 27 : 26)),\n+      1 << 27);\n   // The amount file mapping for the pc array is grown by.\n   static const uptr kPcArrayMmapSize = 64 * 1024;\n \n@@ -86,67 +123,159 @@ class CoverageData {\n   // Current file mapped size of the pc array.\n   uptr pc_array_mapped_size;\n   // Descriptor of the file mapped pc array.\n-  int pc_fd;\n+  fd_t pc_fd;\n+\n+  // Vector of coverage guard arrays, protected by mu.\n+  InternalMmapVectorNoCtor<s32*> guard_array_vec;\n+\n+  struct NamedPcRange {\n+    const char *copied_module_name;\n+    uptr beg, end; // elements [beg,end) in pc_array.\n+  };\n+\n+  // Vector of module and compilation unit pc ranges.\n+  InternalMmapVectorNoCtor<NamedPcRange> comp_unit_name_vec;\n+  InternalMmapVectorNoCtor<NamedPcRange> module_name_vec;\n+\n+  struct CounterAndSize {\n+    u8 *counters;\n+    uptr n;\n+  };\n+\n+  InternalMmapVectorNoCtor<CounterAndSize> counters_vec;\n+  uptr num_8bit_counters;\n \n   // Caller-Callee (cc) array, size and current index.\n   static const uptr kCcArrayMaxSize = FIRST_32_SECOND_64(1 << 18, 1 << 24);\n   uptr **cc_array;\n   atomic_uintptr_t cc_array_index;\n   atomic_uintptr_t cc_array_size;\n \n+  // Tracing event array, size and current pointer.\n+  // We record all events (basic block entries) in a global buffer of u32\n+  // values. Each such value is the index in pc_array.\n+  // So far the tracing is highly experimental:\n+  //   - not thread-safe;\n+  //   - does not support long traces;\n+  //   - not tuned for performance.\n+  static const uptr kTrEventArrayMaxSize = FIRST_32_SECOND_64(1 << 22, 1 << 30);\n+  u32 *tr_event_array;\n+  uptr tr_event_array_size;\n+  u32 *tr_event_pointer;\n+  static const uptr kTrPcArrayMaxSize    = FIRST_32_SECOND_64(1 << 22, 1 << 27);\n \n   StaticSpinMutex mu;\n-\n-  void DirectOpen();\n-  void ReInit();\n };\n \n static CoverageData coverage_data;\n \n+void CovUpdateMapping(const char *path, uptr caller_pc = 0);\n+\n void CoverageData::DirectOpen() {\n-  InternalScopedString path(1024);\n+  InternalScopedString path(kMaxPathLength);\n   internal_snprintf((char *)path.data(), path.size(), \"%s/%zd.sancov.raw\",\n-                    common_flags()->coverage_dir, internal_getpid());\n-  pc_fd = OpenFile(path.data(), true);\n-  if (internal_iserror(pc_fd)) {\n-    Report(\" Coverage: failed to open %s for writing\\n\", path.data());\n+                    coverage_dir, internal_getpid());\n+  pc_fd = OpenFile(path.data(), RdWr);\n+  if (pc_fd == kInvalidFd) {\n+    Report(\"Coverage: failed to open %s for reading/writing\\n\", path.data());\n     Die();\n   }\n \n   pc_array_mapped_size = 0;\n-  CovUpdateMapping();\n+  CovUpdateMapping(coverage_dir);\n }\n \n void CoverageData::Init() {\n+  pc_fd = kInvalidFd;\n+}\n+\n+void CoverageData::Enable() {\n+  if (pc_array)\n+    return;\n   pc_array = reinterpret_cast<uptr *>(\n       MmapNoReserveOrDie(sizeof(uptr) * kPcArrayMaxSize, \"CovInit\"));\n-  pc_fd = kInvalidFd;\n+  atomic_store(&pc_array_index, 0, memory_order_relaxed);\n   if (common_flags()->coverage_direct) {\n     atomic_store(&pc_array_size, 0, memory_order_relaxed);\n-    atomic_store(&pc_array_index, 0, memory_order_relaxed);\n   } else {\n     atomic_store(&pc_array_size, kPcArrayMaxSize, memory_order_relaxed);\n-    atomic_store(&pc_array_index, 0, memory_order_relaxed);\n   }\n \n   cc_array = reinterpret_cast<uptr **>(MmapNoReserveOrDie(\n       sizeof(uptr *) * kCcArrayMaxSize, \"CovInit::cc_array\"));\n   atomic_store(&cc_array_size, kCcArrayMaxSize, memory_order_relaxed);\n   atomic_store(&cc_array_index, 0, memory_order_relaxed);\n+\n+  // Allocate tr_event_array with a guard page at the end.\n+  tr_event_array = reinterpret_cast<u32 *>(MmapNoReserveOrDie(\n+      sizeof(tr_event_array[0]) * kTrEventArrayMaxSize + GetMmapGranularity(),\n+      \"CovInit::tr_event_array\"));\n+  MprotectNoAccess(\n+      reinterpret_cast<uptr>(&tr_event_array[kTrEventArrayMaxSize]),\n+      GetMmapGranularity());\n+  tr_event_array_size = kTrEventArrayMaxSize;\n+  tr_event_pointer = tr_event_array;\n+\n+  num_8bit_counters = 0;\n+}\n+\n+void CoverageData::InitializeGuardArray(s32 *guards) {\n+  Enable();  // Make sure coverage is enabled at this point.\n+  s32 n = guards[0];\n+  for (s32 j = 1; j <= n; j++) {\n+    uptr idx = atomic_fetch_add(&pc_array_index, 1, memory_order_relaxed);\n+    guards[j] = -static_cast<s32>(idx + 1);\n+  }\n+}\n+\n+void CoverageData::Disable() {\n+  if (pc_array) {\n+    UnmapOrDie(pc_array, sizeof(uptr) * kPcArrayMaxSize);\n+    pc_array = nullptr;\n+  }\n+  if (cc_array) {\n+    UnmapOrDie(cc_array, sizeof(uptr *) * kCcArrayMaxSize);\n+    cc_array = nullptr;\n+  }\n+  if (tr_event_array) {\n+    UnmapOrDie(tr_event_array,\n+               sizeof(tr_event_array[0]) * kTrEventArrayMaxSize +\n+                   GetMmapGranularity());\n+    tr_event_array = nullptr;\n+    tr_event_pointer = nullptr;\n+  }\n+  if (pc_fd != kInvalidFd) {\n+    CloseFile(pc_fd);\n+    pc_fd = kInvalidFd;\n+  }\n+}\n+\n+void CoverageData::ReinitializeGuards() {\n+  // Assuming single thread.\n+  atomic_store(&pc_array_index, 0, memory_order_relaxed);\n+  for (uptr i = 0; i < guard_array_vec.size(); i++)\n+    InitializeGuardArray(guard_array_vec[i]);\n }\n \n void CoverageData::ReInit() {\n-  internal_munmap(pc_array, sizeof(uptr) * kPcArrayMaxSize);\n-  if (pc_fd != kInvalidFd) internal_close(pc_fd);\n-  if (common_flags()->coverage_direct) {\n-    // In memory-mapped mode we must extend the new file to the known array\n-    // size.\n-    uptr size = atomic_load(&pc_array_size, memory_order_relaxed);\n-    Init();\n-    if (size) Extend(size);\n-  } else {\n-    Init();\n+  Disable();\n+  if (coverage_enabled) {\n+    if (common_flags()->coverage_direct) {\n+      // In memory-mapped mode we must extend the new file to the known array\n+      // size.\n+      uptr size = atomic_load(&pc_array_size, memory_order_relaxed);\n+      uptr npcs = size / sizeof(uptr);\n+      Enable();\n+      if (size) Extend(npcs);\n+      if (coverage_enabled) CovUpdateMapping(coverage_dir);\n+    } else {\n+      Enable();\n+    }\n   }\n+  // Re-initialize the guards.\n+  // We are single-threaded now, no need to grab any lock.\n+  CHECK_EQ(atomic_load(&pc_array_index, memory_order_relaxed), 0);\n+  ReinitializeGuards();\n }\n \n void CoverageData::BeforeFork() {\n@@ -164,15 +293,16 @@ void CoverageData::Extend(uptr npcs) {\n   if (!common_flags()->coverage_direct) return;\n   SpinMutexLock l(&mu);\n \n-  if (pc_fd == kInvalidFd) DirectOpen();\n-  CHECK_NE(pc_fd, kInvalidFd);\n-\n   uptr size = atomic_load(&pc_array_size, memory_order_relaxed);\n   size += npcs * sizeof(uptr);\n \n-  if (size > pc_array_mapped_size) {\n+  if (coverage_enabled && size > pc_array_mapped_size) {\n+    if (pc_fd == kInvalidFd) DirectOpen();\n+    CHECK_NE(pc_fd, kInvalidFd);\n+\n     uptr new_mapped_size = pc_array_mapped_size;\n     while (size > new_mapped_size) new_mapped_size += kPcArrayMmapSize;\n+    CHECK_LE(new_mapped_size, sizeof(uptr) * kPcArrayMaxSize);\n \n     // Extend the file and map the new space at the end of pc_array.\n     uptr res = internal_ftruncate(pc_fd, new_mapped_size);\n@@ -181,24 +311,100 @@ void CoverageData::Extend(uptr npcs) {\n       Printf(\"failed to extend raw coverage file: %d\\n\", err);\n       Die();\n     }\n-    void *p = MapWritableFileToMemory(pc_array + pc_array_mapped_size,\n+\n+    uptr next_map_base = ((uptr)pc_array) + pc_array_mapped_size;\n+    void *p = MapWritableFileToMemory((void *)next_map_base,\n                                       new_mapped_size - pc_array_mapped_size,\n                                       pc_fd, pc_array_mapped_size);\n-    CHECK_EQ(p, pc_array + pc_array_mapped_size);\n+    CHECK_EQ((uptr)p, next_map_base);\n     pc_array_mapped_size = new_mapped_size;\n   }\n \n   atomic_store(&pc_array_size, size, memory_order_release);\n }\n \n-// Simply add the pc into the vector under lock. If the function is called more\n-// than once for a given PC it will be inserted multiple times, which is fine.\n-void CoverageData::Add(uptr pc) {\n+void CoverageData::InitializeCounters(u8 *counters, uptr n) {\n+  if (!counters) return;\n+  CHECK_EQ(reinterpret_cast<uptr>(counters) % 16, 0);\n+  n = RoundUpTo(n, 16); // The compiler must ensure that counters is 16-aligned.\n+  SpinMutexLock l(&mu);\n+  counters_vec.push_back({counters, n});\n+  num_8bit_counters += n;\n+}\n+\n+void CoverageData::UpdateModuleNameVec(uptr caller_pc, uptr range_beg,\n+                                       uptr range_end) {\n+  auto sym = Symbolizer::GetOrInit();\n+  if (!sym)\n+    return;\n+  const char *module_name = sym->GetModuleNameForPc(caller_pc);\n+  if (!module_name) return;\n+  if (module_name_vec.empty() ||\n+      module_name_vec.back().copied_module_name != module_name)\n+    module_name_vec.push_back({module_name, range_beg, range_end});\n+  else\n+    module_name_vec.back().end = range_end;\n+}\n+\n+void CoverageData::InitializeGuards(s32 *guards, uptr n,\n+                                    const char *comp_unit_name,\n+                                    uptr caller_pc) {\n+  // The array 'guards' has n+1 elements, we use the element zero\n+  // to store 'n'.\n+  CHECK_LT(n, 1 << 30);\n+  guards[0] = static_cast<s32>(n);\n+  InitializeGuardArray(guards);\n+  SpinMutexLock l(&mu);\n+  uptr range_end = atomic_load(&pc_array_index, memory_order_relaxed);\n+  uptr range_beg = range_end - n;\n+  comp_unit_name_vec.push_back({comp_unit_name, range_beg, range_end});\n+  guard_array_vec.push_back(guards);\n+  UpdateModuleNameVec(caller_pc, range_beg, range_end);\n+}\n+\n+static const uptr kBundleCounterBits = 16;\n+\n+// When coverage_order_pcs==true and SANITIZER_WORDSIZE==64\n+// we insert the global counter into the first 16 bits of the PC.\n+uptr BundlePcAndCounter(uptr pc, uptr counter) {\n+  if (SANITIZER_WORDSIZE != 64 || !common_flags()->coverage_order_pcs)\n+    return pc;\n+  static const uptr kMaxCounter = (1 << kBundleCounterBits) - 1;\n+  if (counter > kMaxCounter)\n+    counter = kMaxCounter;\n+  CHECK_EQ(0, pc >> (SANITIZER_WORDSIZE - kBundleCounterBits));\n+  return pc | (counter << (SANITIZER_WORDSIZE - kBundleCounterBits));\n+}\n+\n+uptr UnbundlePc(uptr bundle) {\n+  if (SANITIZER_WORDSIZE != 64 || !common_flags()->coverage_order_pcs)\n+    return bundle;\n+  return (bundle << kBundleCounterBits) >> kBundleCounterBits;\n+}\n+\n+uptr UnbundleCounter(uptr bundle) {\n+  if (SANITIZER_WORDSIZE != 64 || !common_flags()->coverage_order_pcs)\n+    return 0;\n+  return bundle >> (SANITIZER_WORDSIZE - kBundleCounterBits);\n+}\n+\n+// If guard is negative, atomically set it to -guard and store the PC in\n+// pc_array.\n+void CoverageData::Add(uptr pc, u32 *guard) {\n+  atomic_uint32_t *atomic_guard = reinterpret_cast<atomic_uint32_t*>(guard);\n+  s32 guard_value = atomic_load(atomic_guard, memory_order_relaxed);\n+  if (guard_value >= 0) return;\n+\n+  atomic_store(atomic_guard, -guard_value, memory_order_relaxed);\n   if (!pc_array) return;\n-  uptr idx = atomic_fetch_add(&pc_array_index, 1, memory_order_relaxed);\n+\n+  uptr idx = -guard_value - 1;\n+  if (idx >= atomic_load(&pc_array_index, memory_order_acquire))\n+    return;  // May happen after fork when pc_array_index becomes 0.\n   CHECK_LT(idx * sizeof(uptr),\n            atomic_load(&pc_array_size, memory_order_acquire));\n-  pc_array[idx] = pc;\n+  uptr counter = atomic_fetch_add(&coverage_counter, 1, memory_order_relaxed);\n+  pc_array[idx] = BundlePcAndCounter(pc, counter);\n }\n \n // Registers a pair caller=>callee.\n@@ -226,13 +432,73 @@ void CoverageData::IndirCall(uptr caller, uptr callee, uptr callee_cache[],\n   for (uptr i = 2; i < cache_size; i++) {\n     uptr was = 0;\n     if (atomic_compare_exchange_strong(&atomic_callee_cache[i], &was, callee,\n-                                       memory_order_seq_cst))\n+                                       memory_order_seq_cst)) {\n+      atomic_fetch_add(&coverage_counter, 1, memory_order_relaxed);\n       return;\n+    }\n     if (was == callee)  // Already have this callee.\n       return;\n   }\n }\n \n+uptr CoverageData::GetNumberOf8bitCounters() {\n+  return num_8bit_counters;\n+}\n+\n+// Map every 8bit counter to a 8-bit bitset and clear the counter.\n+uptr CoverageData::Update8bitCounterBitsetAndClearCounters(u8 *bitset) {\n+  uptr num_new_bits = 0;\n+  uptr cur = 0;\n+  // For better speed we map 8 counters to 8 bytes of bitset at once.\n+  static const uptr kBatchSize = 8;\n+  CHECK_EQ(reinterpret_cast<uptr>(bitset) % kBatchSize, 0);\n+  for (uptr i = 0, len = counters_vec.size(); i < len; i++) {\n+    u8 *c = counters_vec[i].counters;\n+    uptr n = counters_vec[i].n;\n+    CHECK_EQ(n % 16, 0);\n+    CHECK_EQ(cur % kBatchSize, 0);\n+    CHECK_EQ(reinterpret_cast<uptr>(c) % kBatchSize, 0);\n+    if (!bitset) {\n+      internal_bzero_aligned16(c, n);\n+      cur += n;\n+      continue;\n+    }\n+    for (uptr j = 0; j < n; j += kBatchSize, cur += kBatchSize) {\n+      CHECK_LT(cur, num_8bit_counters);\n+      u64 *pc64 = reinterpret_cast<u64*>(c + j);\n+      u64 *pb64 = reinterpret_cast<u64*>(bitset + cur);\n+      u64 c64 = *pc64;\n+      u64 old_bits_64 = *pb64;\n+      u64 new_bits_64 = old_bits_64;\n+      if (c64) {\n+        *pc64 = 0;\n+        for (uptr k = 0; k < kBatchSize; k++) {\n+          u64 x = (c64 >> (8 * k)) & 0xff;\n+          if (x) {\n+            u64 bit = 0;\n+            /**/ if (x >= 128) bit = 128;\n+            else if (x >= 32) bit = 64;\n+            else if (x >= 16) bit = 32;\n+            else if (x >= 8) bit = 16;\n+            else if (x >= 4) bit = 8;\n+            else if (x >= 3) bit = 4;\n+            else if (x >= 2) bit = 2;\n+            else if (x >= 1) bit = 1;\n+            u64 mask = bit << (8 * k);\n+            if (!(new_bits_64 & mask)) {\n+              num_new_bits++;\n+              new_bits_64 |= mask;\n+            }\n+          }\n+        }\n+        *pb64 = new_bits_64;\n+      }\n+    }\n+  }\n+  CHECK_EQ(cur, num_8bit_counters);\n+  return num_new_bits;\n+}\n+\n uptr *CoverageData::data() {\n   return pc_array;\n }\n@@ -251,15 +517,15 @@ struct CovHeader {\n \n static void CovWritePacked(int pid, const char *module, const void *blob,\n                            unsigned int blob_size) {\n-  if (cov_fd < 0) return;\n+  if (cov_fd == kInvalidFd) return;\n   unsigned module_name_length = internal_strlen(module);\n   CovHeader header = {pid, module_name_length, blob_size};\n \n   if (cov_max_block_size == 0) {\n     // Writing to a file. Just go ahead.\n-    internal_write(cov_fd, &header, sizeof(header));\n-    internal_write(cov_fd, module, module_name_length);\n-    internal_write(cov_fd, blob, blob_size);\n+    WriteToFile(cov_fd, &header, sizeof(header));\n+    WriteToFile(cov_fd, module, module_name_length);\n+    WriteToFile(cov_fd, blob, blob_size);\n   } else {\n     // Writing to a socket. We want to split the data into appropriately sized\n     // blocks.\n@@ -275,15 +541,14 @@ static void CovWritePacked(int pid, const char *module, const void *blob,\n     internal_memcpy(block_pos, module, module_name_length);\n     block_pos += module_name_length;\n     char *block_data_begin = block_pos;\n-    char *blob_pos = (char *)blob;\n+    const char *blob_pos = (const char *)blob;\n     while (blob_size > 0) {\n       unsigned int payload_size = Min(blob_size, max_payload_size);\n       blob_size -= payload_size;\n       internal_memcpy(block_data_begin, blob_pos, payload_size);\n       blob_pos += payload_size;\n       ((CovHeader *)block.data())->data_length = payload_size;\n-      internal_write(cov_fd, block.data(),\n-                     header_size_with_module + payload_size);\n+      WriteToFile(cov_fd, block.data(), header_size_with_module + payload_size);\n     }\n   }\n }\n@@ -292,29 +557,77 @@ static void CovWritePacked(int pid, const char *module, const void *blob,\n // If packed = true and name == 0: <pid>.<sancov>.<packed>.\n // If packed = true and name != 0: <name>.<sancov>.<packed> (name is\n // user-supplied).\n-static int CovOpenFile(bool packed, const char* name) {\n-  InternalScopedBuffer<char> path(1024);\n+static fd_t CovOpenFile(InternalScopedString *path, bool packed,\n+                       const char *name, const char *extension = \"sancov\") {\n+  path->clear();\n   if (!packed) {\n     CHECK(name);\n-    internal_snprintf((char *)path.data(), path.size(), \"%s/%s.%zd.sancov\",\n-                      common_flags()->coverage_dir, name, internal_getpid());\n+    path->append(\"%s/%s.%zd.%s\", coverage_dir, name, internal_getpid(),\n+                extension);\n   } else {\n     if (!name)\n-      internal_snprintf((char *)path.data(), path.size(),\n-                        \"%s/%zd.sancov.packed\", common_flags()->coverage_dir,\n-                        internal_getpid());\n+      path->append(\"%s/%zd.%s.packed\", coverage_dir, internal_getpid(),\n+                  extension);\n     else\n-      internal_snprintf((char *)path.data(), path.size(), \"%s/%s.sancov.packed\",\n-                        common_flags()->coverage_dir, name);\n-  }\n-  uptr fd = OpenFile(path.data(), true);\n-  if (internal_iserror(fd)) {\n-    Report(\" SanitizerCoverage: failed to open %s for writing\\n\", path.data());\n-    return -1;\n+      path->append(\"%s/%s.%s.packed\", coverage_dir, name, extension);\n   }\n+  error_t err;\n+  fd_t fd = OpenFile(path->data(), WrOnly, &err);\n+  if (fd == kInvalidFd)\n+    Report(\"SanitizerCoverage: failed to open %s for writing (reason: %d)\\n\",\n+           path->data(), err);\n   return fd;\n }\n \n+// Dump trace PCs and trace events into two separate files.\n+void CoverageData::DumpTrace() {\n+  uptr max_idx = tr_event_pointer - tr_event_array;\n+  if (!max_idx) return;\n+  auto sym = Symbolizer::GetOrInit();\n+  if (!sym)\n+    return;\n+  InternalScopedString out(32 << 20);\n+  for (uptr i = 0, n = size(); i < n; i++) {\n+    const char *module_name = \"<unknown>\";\n+    uptr module_address = 0;\n+    sym->GetModuleNameAndOffsetForPC(UnbundlePc(pc_array[i]), &module_name,\n+                                     &module_address);\n+    out.append(\"%s 0x%zx\\n\", module_name, module_address);\n+  }\n+  InternalScopedString path(kMaxPathLength);\n+  fd_t fd = CovOpenFile(&path, false, \"trace-points\");\n+  if (fd == kInvalidFd) return;\n+  WriteToFile(fd, out.data(), out.length());\n+  CloseFile(fd);\n+\n+  fd = CovOpenFile(&path, false, \"trace-compunits\");\n+  if (fd == kInvalidFd) return;\n+  out.clear();\n+  for (uptr i = 0; i < comp_unit_name_vec.size(); i++)\n+    out.append(\"%s\\n\", comp_unit_name_vec[i].copied_module_name);\n+  WriteToFile(fd, out.data(), out.length());\n+  CloseFile(fd);\n+\n+  fd = CovOpenFile(&path, false, \"trace-events\");\n+  if (fd == kInvalidFd) return;\n+  uptr bytes_to_write = max_idx * sizeof(tr_event_array[0]);\n+  u8 *event_bytes = reinterpret_cast<u8*>(tr_event_array);\n+  // The trace file could be huge, and may not be written with a single syscall.\n+  while (bytes_to_write) {\n+    uptr actually_written;\n+    if (WriteToFile(fd, event_bytes, bytes_to_write, &actually_written) &&\n+        actually_written <= bytes_to_write) {\n+      bytes_to_write -= actually_written;\n+      event_bytes += actually_written;\n+    } else {\n+      break;\n+    }\n+  }\n+  CloseFile(fd);\n+  VReport(1, \" CovDump: Trace: %zd PCs written\\n\", size());\n+  VReport(1, \" CovDump: Trace: %zd Events written\\n\", max_idx);\n+}\n+\n // This function dumps the caller=>callee pairs into a file as a sequence of\n // lines like \"module_name offset\".\n void CoverageData::DumpCallerCalleePairs() {\n@@ -347,88 +660,166 @@ void CoverageData::DumpCallerCalleePairs() {\n                  callee_module_address);\n     }\n   }\n-  int fd = CovOpenFile(false, \"caller-callee\");\n-  if (fd < 0) return;\n-  internal_write(fd, out.data(), out.length());\n-  internal_close(fd);\n+  InternalScopedString path(kMaxPathLength);\n+  fd_t fd = CovOpenFile(&path, false, \"caller-callee\");\n+  if (fd == kInvalidFd) return;\n+  WriteToFile(fd, out.data(), out.length());\n+  CloseFile(fd);\n   VReport(1, \" CovDump: %zd caller-callee pairs written\\n\", total);\n }\n \n-// Dump the coverage on disk.\n-static void CovDump() {\n-  if (!common_flags()->coverage || common_flags()->coverage_direct) return;\n-#if !SANITIZER_WINDOWS\n-  if (atomic_fetch_add(&dump_once_guard, 1, memory_order_relaxed))\n-    return;\n-  uptr size = coverage_data.size();\n-  InternalMmapVector<u32> offsets(size);\n-  uptr *vb = coverage_data.data();\n-  uptr *ve = vb + size;\n-  SortArray(vb, size);\n-  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n-  uptr mb, me, off, prot;\n-  InternalScopedBuffer<char> module(4096);\n-  InternalScopedBuffer<char> path(4096 * 2);\n-  for (int i = 0;\n-       proc_maps.Next(&mb, &me, &off, module.data(), module.size(), &prot);\n-       i++) {\n-    if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n-      continue;\n-    while (vb < ve && *vb < mb) vb++;\n-    if (vb >= ve) break;\n-    if (*vb < me) {\n-      offsets.clear();\n-      const uptr *old_vb = vb;\n-      CHECK_LE(off, *vb);\n-      for (; vb < ve && *vb < me; vb++) {\n-        uptr diff = *vb - (i ? mb : 0) + off;\n-        CHECK_LE(diff, 0xffffffffU);\n-        offsets.push_back(static_cast<u32>(diff));\n-      }\n-      const char *module_name = StripModuleName(module.data());\n-      if (cov_sandboxed) {\n-        if (cov_fd >= 0) {\n-          CovWritePacked(internal_getpid(), module_name, offsets.data(),\n-                         offsets.size() * sizeof(u32));\n-          VReport(1, \" CovDump: %zd PCs written to packed file\\n\", vb - old_vb);\n-        }\n-      } else {\n-        // One file per module per process.\n-        internal_snprintf((char *)path.data(), path.size(), \"%s/%s.%zd.sancov\",\n-                          common_flags()->coverage_dir, module_name,\n-                          internal_getpid());\n-        int fd = CovOpenFile(false /* packed */, module_name);\n-        if (fd > 0) {\n-          internal_write(fd, offsets.data(), offsets.size() * sizeof(u32));\n-          internal_close(fd);\n-          VReport(1, \" CovDump: %s: %zd PCs written\\n\", path.data(),\n-                  vb - old_vb);\n-        }\n+// Record the current PC into the event buffer.\n+// Every event is a u32 value (index in tr_pc_array_index) so we compute\n+// it once and then cache in the provided 'cache' storage.\n+//\n+// This function will eventually be inlined by the compiler.\n+void CoverageData::TraceBasicBlock(s32 *id) {\n+  // Will trap here if\n+  //  1. coverage is not enabled at run-time.\n+  //  2. The array tr_event_array is full.\n+  *tr_event_pointer = static_cast<u32>(*id - 1);\n+  tr_event_pointer++;\n+}\n+\n+void CoverageData::DumpCounters() {\n+  if (!common_flags()->coverage_counters) return;\n+  uptr n = coverage_data.GetNumberOf8bitCounters();\n+  if (!n) return;\n+  InternalScopedBuffer<u8> bitset(n);\n+  coverage_data.Update8bitCounterBitsetAndClearCounters(bitset.data());\n+  InternalScopedString path(kMaxPathLength);\n+\n+  for (uptr m = 0; m < module_name_vec.size(); m++) {\n+    auto r = module_name_vec[m];\n+    CHECK(r.copied_module_name);\n+    CHECK_LE(r.beg, r.end);\n+    CHECK_LE(r.end, size());\n+    const char *base_name = StripModuleName(r.copied_module_name);\n+    fd_t fd =\n+        CovOpenFile(&path, /* packed */ false, base_name, \"counters-sancov\");\n+    if (fd == kInvalidFd) return;\n+    WriteToFile(fd, bitset.data() + r.beg, r.end - r.beg);\n+    CloseFile(fd);\n+    VReport(1, \" CovDump: %zd counters written for '%s'\\n\", r.end - r.beg,\n+            base_name);\n+  }\n+}\n+\n+void CoverageData::DumpAsBitSet() {\n+  if (!common_flags()->coverage_bitset) return;\n+  if (!size()) return;\n+  InternalScopedBuffer<char> out(size());\n+  InternalScopedString path(kMaxPathLength);\n+  for (uptr m = 0; m < module_name_vec.size(); m++) {\n+    uptr n_set_bits = 0;\n+    auto r = module_name_vec[m];\n+    CHECK(r.copied_module_name);\n+    CHECK_LE(r.beg, r.end);\n+    CHECK_LE(r.end, size());\n+    for (uptr i = r.beg; i < r.end; i++) {\n+      uptr pc = UnbundlePc(pc_array[i]);\n+      out[i] = pc ? '1' : '0';\n+      if (pc)\n+        n_set_bits++;\n+    }\n+    const char *base_name = StripModuleName(r.copied_module_name);\n+    fd_t fd = CovOpenFile(&path, /* packed */false, base_name, \"bitset-sancov\");\n+    if (fd == kInvalidFd) return;\n+    WriteToFile(fd, out.data() + r.beg, r.end - r.beg);\n+    CloseFile(fd);\n+    VReport(1,\n+            \" CovDump: bitset of %zd bits written for '%s', %zd bits are set\\n\",\n+            r.end - r.beg, base_name, n_set_bits);\n+  }\n+}\n+\n+void CoverageData::DumpOffsets() {\n+  auto sym = Symbolizer::GetOrInit();\n+  if (!common_flags()->coverage_pcs) return;\n+  CHECK_NE(sym, nullptr);\n+  InternalMmapVector<uptr> offsets(0);\n+  InternalScopedString path(kMaxPathLength);\n+  for (uptr m = 0; m < module_name_vec.size(); m++) {\n+    offsets.clear();\n+    uptr num_words_for_magic = SANITIZER_WORDSIZE == 64 ? 1 : 2;\n+    for (uptr i = 0; i < num_words_for_magic; i++)\n+      offsets.push_back(0);\n+    auto r = module_name_vec[m];\n+    CHECK(r.copied_module_name);\n+    CHECK_LE(r.beg, r.end);\n+    CHECK_LE(r.end, size());\n+    for (uptr i = r.beg; i < r.end; i++) {\n+      uptr pc = UnbundlePc(pc_array[i]);\n+      uptr counter = UnbundleCounter(pc_array[i]);\n+      if (!pc) continue; // Not visited.\n+      uptr offset = 0;\n+      sym->GetModuleNameAndOffsetForPC(pc, nullptr, &offset);\n+      offsets.push_back(BundlePcAndCounter(offset, counter));\n+    }\n+\n+    CHECK_GE(offsets.size(), num_words_for_magic);\n+    SortArray(offsets.data(), offsets.size());\n+    for (uptr i = 0; i < offsets.size(); i++)\n+      offsets[i] = UnbundlePc(offsets[i]);\n+\n+    uptr num_offsets = offsets.size() - num_words_for_magic;\n+    u64 *magic_p = reinterpret_cast<u64*>(offsets.data());\n+    CHECK_EQ(*magic_p, 0ULL);\n+    // FIXME: we may want to write 32-bit offsets even in 64-mode\n+    // if all the offsets are small enough.\n+    *magic_p = SANITIZER_WORDSIZE == 64 ? kMagic64 : kMagic32;\n+\n+    const char *module_name = StripModuleName(r.copied_module_name);\n+    if (cov_sandboxed) {\n+      if (cov_fd != kInvalidFd) {\n+        CovWritePacked(internal_getpid(), module_name, offsets.data(),\n+                       offsets.size() * sizeof(offsets[0]));\n+        VReport(1, \" CovDump: %zd PCs written to packed file\\n\", num_offsets);\n       }\n+    } else {\n+      // One file per module per process.\n+      fd_t fd = CovOpenFile(&path, false /* packed */, module_name);\n+      if (fd == kInvalidFd) continue;\n+      WriteToFile(fd, offsets.data(), offsets.size() * sizeof(offsets[0]));\n+      CloseFile(fd);\n+      VReport(1, \" CovDump: %s: %zd PCs written\\n\", path.data(), num_offsets);\n     }\n   }\n-  if (cov_fd >= 0)\n-    internal_close(cov_fd);\n-  coverage_data.DumpCallerCalleePairs();\n-#endif  // !SANITIZER_WINDOWS\n+  if (cov_fd != kInvalidFd)\n+    CloseFile(cov_fd);\n+}\n+\n+void CoverageData::DumpAll() {\n+  if (!coverage_enabled || common_flags()->coverage_direct) return;\n+  if (atomic_fetch_add(&dump_once_guard, 1, memory_order_relaxed))\n+    return;\n+  DumpAsBitSet();\n+  DumpCounters();\n+  DumpTrace();\n+  DumpOffsets();\n+  DumpCallerCalleePairs();\n }\n \n void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n   if (!args) return;\n-  if (!common_flags()->coverage) return;\n+  if (!coverage_enabled) return;\n   cov_sandboxed = args->coverage_sandboxed;\n   if (!cov_sandboxed) return;\n-  cov_fd = args->coverage_fd;\n   cov_max_block_size = args->coverage_max_block_size;\n-  if (cov_fd < 0)\n+  if (args->coverage_fd >= 0) {\n+    cov_fd = (fd_t)args->coverage_fd;\n+  } else {\n+    InternalScopedString path(kMaxPathLength);\n     // Pre-open the file now. The sandbox won't allow us to do it later.\n-    cov_fd = CovOpenFile(true /* packed */, 0);\n+    cov_fd = CovOpenFile(&path, true /* packed */, nullptr);\n+  }\n }\n \n-int MaybeOpenCovFile(const char *name) {\n+fd_t MaybeOpenCovFile(const char *name) {\n   CHECK(name);\n-  if (!common_flags()->coverage) return -1;\n-  return CovOpenFile(true /* packed */, name);\n+  if (!coverage_enabled) return kInvalidFd;\n+  InternalScopedString path(kMaxPathLength);\n+  return CovOpenFile(&path, true /* packed */, name);\n }\n \n void CovBeforeFork() {\n@@ -439,32 +830,114 @@ void CovAfterFork(int child_pid) {\n   coverage_data.AfterFork(child_pid);\n }\n \n-}  // namespace __sanitizer\n+static void MaybeDumpCoverage() {\n+  if (common_flags()->coverage)\n+    __sanitizer_cov_dump();\n+}\n+\n+void InitializeCoverage(bool enabled, const char *dir) {\n+  if (coverage_enabled)\n+    return;  // May happen if two sanitizer enable coverage in the same process.\n+  coverage_enabled = enabled;\n+  coverage_dir = dir;\n+  coverage_data.Init();\n+  if (enabled) coverage_data.Enable();\n+  if (!common_flags()->coverage_direct) Atexit(__sanitizer_cov_dump);\n+  AddDieCallback(MaybeDumpCoverage);\n+}\n+\n+void ReInitializeCoverage(bool enabled, const char *dir) {\n+  coverage_enabled = enabled;\n+  coverage_dir = dir;\n+  coverage_data.ReInit();\n+}\n+\n+void CoverageUpdateMapping() {\n+  if (coverage_enabled)\n+    CovUpdateMapping(coverage_dir);\n+}\n+\n+} // namespace __sanitizer\n \n extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov() {\n-  coverage_data.Add(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()));\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(u32 *guard) {\n+  coverage_data.Add(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()),\n+                    guard);\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_with_check(u32 *guard) {\n+  atomic_uint32_t *atomic_guard = reinterpret_cast<atomic_uint32_t*>(guard);\n+  if (static_cast<s32>(\n+          __sanitizer::atomic_load(atomic_guard, memory_order_relaxed)) < 0)\n+    __sanitizer_cov(guard);\n }\n SANITIZER_INTERFACE_ATTRIBUTE void\n __sanitizer_cov_indir_call16(uptr callee, uptr callee_cache16[]) {\n   coverage_data.IndirCall(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()),\n                           callee, callee_cache16, 16);\n }\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() { CovDump(); }\n SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init() {\n+  coverage_enabled = true;\n+  coverage_dir = common_flags()->coverage_dir;\n   coverage_data.Init();\n }\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_module_init(uptr npcs) {\n-  if (!common_flags()->coverage || !common_flags()->coverage_direct) return;\n-  if (SANITIZER_ANDROID) {\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() {\n+  coverage_data.DumpAll();\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void\n+__sanitizer_cov_module_init(s32 *guards, uptr npcs, u8 *counters,\n+                            const char *comp_unit_name) {\n+  coverage_data.InitializeGuards(guards, npcs, comp_unit_name, GET_CALLER_PC());\n+  coverage_data.InitializeCounters(counters, npcs);\n+  if (!common_flags()->coverage_direct) return;\n+  if (SANITIZER_ANDROID && coverage_enabled) {\n     // dlopen/dlclose interceptors do not work on Android, so we rely on\n     // Extend() calls to update .sancov.map.\n-    CovUpdateMapping(GET_CALLER_PC());\n+    CovUpdateMapping(coverage_dir, GET_CALLER_PC());\n   }\n   coverage_data.Extend(npcs);\n }\n SANITIZER_INTERFACE_ATTRIBUTE\n sptr __sanitizer_maybe_open_cov_file(const char *name) {\n-  return MaybeOpenCovFile(name);\n+  return (sptr)MaybeOpenCovFile(name);\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_total_unique_coverage() {\n+  return atomic_load(&coverage_counter, memory_order_relaxed);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_cov_trace_func_enter(s32 *id) {\n+  coverage_data.TraceBasicBlock(id);\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_cov_trace_basic_block(s32 *id) {\n+  coverage_data.TraceBasicBlock(id);\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_reset_coverage() {\n+  coverage_data.ReinitializeGuards();\n+  internal_bzero_aligned16(\n+      coverage_data.data(),\n+      RoundUpTo(coverage_data.size() * sizeof(coverage_data.data()[0]), 16));\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_coverage_guards(uptr **data) {\n+  *data = coverage_data.data();\n+  return coverage_data.size();\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_number_of_counters() {\n+  return coverage_data.GetNumberOf8bitCounters();\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_update_counter_bitset_and_clear_counters(u8 *bitset) {\n+  return coverage_data.Update8bitCounterBitsetAndClearCounters(bitset);\n }\n-}  // extern \"C\"\n+// Default empty implementations (weak). Users should redefine them.\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_cmp() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_switch() {}\n+} // extern \"C\""}, {"sha": "ebac681288186d4a4c03332f22fe6f1a2a8e466b", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_mapping_libcdep.cc", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -33,7 +33,6 @@\n \n namespace __sanitizer {\n \n-static const uptr kMaxNumberOfModules = 1 << 14;\n static const uptr kMaxTextSize = 64 * 1024;\n \n struct CachedMapping {\n@@ -60,66 +59,67 @@ struct CachedMapping {\n static CachedMapping cached_mapping;\n static StaticSpinMutex mapping_mu;\n \n-void CovUpdateMapping(uptr caller_pc) {\n-  if (!common_flags()->coverage || !common_flags()->coverage_direct) return;\n+void CovUpdateMapping(const char *coverage_dir, uptr caller_pc) {\n+  if (!common_flags()->coverage_direct) return;\n \n   SpinMutexLock l(&mapping_mu);\n \n   if (!cached_mapping.NeedsUpdate(caller_pc))\n     return;\n \n   InternalScopedString text(kMaxTextSize);\n-  InternalScopedBuffer<char> modules_data(kMaxNumberOfModules *\n-                                          sizeof(LoadedModule));\n-  LoadedModule *modules = (LoadedModule *)modules_data.data();\n-  CHECK(modules);\n-  int n_modules = GetListOfModules(modules, kMaxNumberOfModules,\n-                                   /* filter */ 0);\n-\n-  text.append(\"%d\\n\", sizeof(uptr) * 8);\n-  for (int i = 0; i < n_modules; ++i) {\n-    const char *module_name = StripModuleName(modules[i].full_name());\n-    for (unsigned j = 0; j < modules[i].n_ranges(); ++j) {\n-      if (modules[i].address_range_executable(j)) {\n-        uptr start = modules[i].address_range_start(j);\n-        uptr end = modules[i].address_range_end(j);\n-        uptr base = modules[i].base_address();\n-        text.append(\"%zx %zx %zx %s\\n\", start, end, base, module_name);\n-        if (caller_pc && caller_pc >= start && caller_pc < end)\n-          cached_mapping.SetModuleRange(start, end);\n+\n+  {\n+    InternalScopedBuffer<LoadedModule> modules(kMaxNumberOfModules);\n+    CHECK(modules.data());\n+    int n_modules = GetListOfModules(modules.data(), kMaxNumberOfModules,\n+                                     /* filter */ nullptr);\n+\n+    text.append(\"%d\\n\", sizeof(uptr) * 8);\n+    for (int i = 0; i < n_modules; ++i) {\n+      const char *module_name = StripModuleName(modules[i].full_name());\n+      uptr base = modules[i].base_address();\n+      for (auto iter = modules[i].ranges(); iter.hasNext();) {\n+        const auto *range = iter.next();\n+        if (range->executable) {\n+          uptr start = range->beg;\n+          uptr end = range->end;\n+          text.append(\"%zx %zx %zx %s\\n\", start, end, base, module_name);\n+          if (caller_pc && caller_pc >= start && caller_pc < end)\n+            cached_mapping.SetModuleRange(start, end);\n+        }\n       }\n+      modules[i].clear();\n     }\n   }\n \n-  int err;\n-  InternalScopedString tmp_path(64 +\n-                                internal_strlen(common_flags()->coverage_dir));\n+  error_t err;\n+  InternalScopedString tmp_path(64 + internal_strlen(coverage_dir));\n   uptr res = internal_snprintf((char *)tmp_path.data(), tmp_path.size(),\n-                    \"%s/%zd.sancov.map.tmp\", common_flags()->coverage_dir,\n-                    internal_getpid());\n+                               \"%s/%zd.sancov.map.tmp\", coverage_dir,\n+                               internal_getpid());\n   CHECK_LE(res, tmp_path.size());\n-  uptr map_fd = OpenFile(tmp_path.data(), true);\n-  if (internal_iserror(map_fd)) {\n-    Report(\" Coverage: failed to open %s for writing\\n\", tmp_path.data());\n+  fd_t map_fd = OpenFile(tmp_path.data(), WrOnly, &err);\n+  if (map_fd == kInvalidFd) {\n+    Report(\"Coverage: failed to open %s for writing: %d\\n\", tmp_path.data(),\n+           err);\n     Die();\n   }\n \n-  res = internal_write(map_fd, text.data(), text.length());\n-  if (internal_iserror(res, &err)) {\n+  if (!WriteToFile(map_fd, text.data(), text.length(), nullptr, &err)) {\n     Printf(\"sancov.map write failed: %d\\n\", err);\n     Die();\n   }\n-  internal_close(map_fd);\n+  CloseFile(map_fd);\n \n-  InternalScopedString path(64 + internal_strlen(common_flags()->coverage_dir));\n+  InternalScopedString path(64 + internal_strlen(coverage_dir));\n   res = internal_snprintf((char *)path.data(), path.size(), \"%s/%zd.sancov.map\",\n-                    common_flags()->coverage_dir, internal_getpid());\n+                          coverage_dir, internal_getpid());\n   CHECK_LE(res, path.size());\n-  res = internal_rename(tmp_path.data(), path.data());\n-  if (internal_iserror(res, &err)) {\n+  if (!RenameFile(tmp_path.data(), path.data(), &err)) {\n     Printf(\"sancov.map rename failed: %d\\n\", err);\n     Die();\n   }\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer"}, {"sha": "7a318c963f749fd4a6cafef6a317634b68c871eb", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector1.cc", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -38,19 +38,20 @@ struct DD : public DDetector {\n \n   explicit DD(const DDFlags *flags);\n \n-  DDPhysicalThread* CreatePhysicalThread();\n-  void DestroyPhysicalThread(DDPhysicalThread *pt);\n+  DDPhysicalThread *CreatePhysicalThread() override;\n+  void DestroyPhysicalThread(DDPhysicalThread *pt) override;\n \n-  DDLogicalThread* CreateLogicalThread(u64 ctx);\n-  void DestroyLogicalThread(DDLogicalThread *lt);\n+  DDLogicalThread *CreateLogicalThread(u64 ctx) override;\n+  void DestroyLogicalThread(DDLogicalThread *lt) override;\n \n-  void MutexInit(DDCallback *cb, DDMutex *m);\n-  void MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock);\n-  void MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock);\n-  void MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock);\n-  void MutexDestroy(DDCallback *cb, DDMutex *m);\n+  void MutexInit(DDCallback *cb, DDMutex *m) override;\n+  void MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock) override;\n+  void MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock,\n+                      bool trylock) override;\n+  void MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock) override;\n+  void MutexDestroy(DDCallback *cb, DDMutex *m) override;\n \n-  DDReport *GetReport(DDCallback *cb);\n+  DDReport *GetReport(DDCallback *cb) override;\n \n   void MutexEnsureID(DDLogicalThread *lt, DDMutex *m);\n   void ReportDeadlock(DDCallback *cb, DDMutex *m);\n@@ -68,7 +69,7 @@ DD::DD(const DDFlags *flags)\n }\n \n DDPhysicalThread* DD::CreatePhysicalThread() {\n-  return 0;\n+  return nullptr;\n }\n \n void DD::DestroyPhysicalThread(DDPhysicalThread *pt) {\n@@ -178,10 +179,10 @@ void DD::MutexDestroy(DDCallback *cb,\n \n DDReport *DD::GetReport(DDCallback *cb) {\n   if (!cb->lt->report_pending)\n-    return 0;\n+    return nullptr;\n   cb->lt->report_pending = false;\n   return &cb->lt->rep;\n }\n \n-}  // namespace __sanitizer\n-#endif  // #if SANITIZER_DEADLOCK_DETECTOR_VERSION == 1\n+} // namespace __sanitizer\n+#endif // #if SANITIZER_DEADLOCK_DETECTOR_VERSION == 1"}, {"sha": "07c3755155f2cbd1d32feff57bad20794697ed1e", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector_interface.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -70,10 +70,10 @@ struct DDCallback {\n struct DDetector {\n   static DDetector *Create(const DDFlags *flags);\n \n-  virtual DDPhysicalThread* CreatePhysicalThread() { return 0; }\n+  virtual DDPhysicalThread* CreatePhysicalThread() { return nullptr; }\n   virtual void DestroyPhysicalThread(DDPhysicalThread *pt) {}\n \n-  virtual DDLogicalThread* CreateLogicalThread(u64 ctx) { return 0; }\n+  virtual DDLogicalThread* CreateLogicalThread(u64 ctx) { return nullptr; }\n   virtual void DestroyLogicalThread(DDLogicalThread *lt) {}\n \n   virtual void MutexInit(DDCallback *cb, DDMutex *m) {}\n@@ -83,7 +83,7 @@ struct DDetector {\n   virtual void MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock) {}\n   virtual void MutexDestroy(DDCallback *cb, DDMutex *m) {}\n \n-  virtual DDReport *GetReport(DDCallback *cb) { return 0; }\n+  virtual DDReport *GetReport(DDCallback *cb) { return nullptr; }\n };\n \n } // namespace __sanitizer"}, {"sha": "1fc6b2edb0c57939ebb0507d802d8795c8309ae7", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.cc", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,169 @@\n+//===-- sanitizer_flag_parser.cc ------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_flag_parser.h\"\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_flag_parser.h\"\n+\n+namespace __sanitizer {\n+\n+LowLevelAllocator FlagParser::Alloc;\n+\n+class UnknownFlags {\n+  static const int kMaxUnknownFlags = 20;\n+  const char *unknown_flags_[kMaxUnknownFlags];\n+  int n_unknown_flags_;\n+\n+ public:\n+  void Add(const char *name) {\n+    CHECK_LT(n_unknown_flags_, kMaxUnknownFlags);\n+    unknown_flags_[n_unknown_flags_++] = name;\n+  }\n+\n+  void Report() {\n+    if (!n_unknown_flags_) return;\n+    Printf(\"WARNING: found %d unrecognized flag(s):\\n\", n_unknown_flags_);\n+    for (int i = 0; i < n_unknown_flags_; ++i)\n+      Printf(\"    %s\\n\", unknown_flags_[i]);\n+    n_unknown_flags_ = 0;\n+  }\n+};\n+\n+UnknownFlags unknown_flags;\n+\n+void ReportUnrecognizedFlags() {\n+  unknown_flags.Report();\n+}\n+\n+char *FlagParser::ll_strndup(const char *s, uptr n) {\n+  uptr len = internal_strnlen(s, n);\n+  char *s2 = (char*)Alloc.Allocate(len + 1);\n+  internal_memcpy(s2, s, len);\n+  s2[len] = 0;\n+  return s2;\n+}\n+\n+void FlagParser::PrintFlagDescriptions() {\n+  Printf(\"Available flags for %s:\\n\", SanitizerToolName);\n+  for (int i = 0; i < n_flags_; ++i)\n+    Printf(\"\\t%s\\n\\t\\t- %s\\n\", flags_[i].name, flags_[i].desc);\n+}\n+\n+void FlagParser::fatal_error(const char *err) {\n+  Printf(\"ERROR: %s\\n\", err);\n+  Die();\n+}\n+\n+bool FlagParser::is_space(char c) {\n+  return c == ' ' || c == ',' || c == ':' || c == '\\n' || c == '\\t' ||\n+         c == '\\r';\n+}\n+\n+void FlagParser::skip_whitespace() {\n+  while (is_space(buf_[pos_])) ++pos_;\n+}\n+\n+void FlagParser::parse_flag() {\n+  uptr name_start = pos_;\n+  while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;\n+  if (buf_[pos_] != '=') fatal_error(\"expected '='\");\n+  char *name = ll_strndup(buf_ + name_start, pos_ - name_start);\n+\n+  uptr value_start = ++pos_;\n+  char *value;\n+  if (buf_[pos_] == '\\'' || buf_[pos_] == '\"') {\n+    char quote = buf_[pos_++];\n+    while (buf_[pos_] != 0 && buf_[pos_] != quote) ++pos_;\n+    if (buf_[pos_] == 0) fatal_error(\"unterminated string\");\n+    value = ll_strndup(buf_ + value_start + 1, pos_ - value_start - 1);\n+    ++pos_; // consume the closing quote\n+  } else {\n+    while (buf_[pos_] != 0 && !is_space(buf_[pos_])) ++pos_;\n+    if (buf_[pos_] != 0 && !is_space(buf_[pos_]))\n+      fatal_error(\"expected separator or eol\");\n+    value = ll_strndup(buf_ + value_start, pos_ - value_start);\n+  }\n+\n+  bool res = run_handler(name, value);\n+  if (!res) fatal_error(\"Flag parsing failed.\");\n+}\n+\n+void FlagParser::parse_flags() {\n+  while (true) {\n+    skip_whitespace();\n+    if (buf_[pos_] == 0) break;\n+    parse_flag();\n+  }\n+\n+  // Do a sanity check for certain flags.\n+  if (common_flags_dont_use.malloc_context_size < 1)\n+    common_flags_dont_use.malloc_context_size = 1;\n+}\n+\n+void FlagParser::ParseString(const char *s) {\n+  if (!s) return;\n+  // Backup current parser state to allow nested ParseString() calls.\n+  const char *old_buf_ = buf_;\n+  uptr old_pos_ = pos_;\n+  buf_ = s;\n+  pos_ = 0;\n+\n+  parse_flags();\n+\n+  buf_ = old_buf_;\n+  pos_ = old_pos_;\n+}\n+\n+bool FlagParser::ParseFile(const char *path, bool ignore_missing) {\n+  static const uptr kMaxIncludeSize = 1 << 15;\n+  char *data;\n+  uptr data_mapped_size;\n+  error_t err;\n+  uptr len;\n+  if (!ReadFileToBuffer(path, &data, &data_mapped_size, &len,\n+                        Max(kMaxIncludeSize, GetPageSizeCached()), &err)) {\n+    if (ignore_missing)\n+      return true;\n+    Printf(\"Failed to read options from '%s': error %d\\n\", path, err);\n+    return false;\n+  }\n+  ParseString(data);\n+  UnmapOrDie(data, data_mapped_size);\n+  return true;\n+}\n+\n+bool FlagParser::run_handler(const char *name, const char *value) {\n+  for (int i = 0; i < n_flags_; ++i) {\n+    if (internal_strcmp(name, flags_[i].name) == 0)\n+      return flags_[i].handler->Parse(value);\n+  }\n+  // Unrecognized flag. This is not a fatal error, we may print a warning later.\n+  unknown_flags.Add(name);\n+  return true;\n+}\n+\n+void FlagParser::RegisterHandler(const char *name, FlagHandlerBase *handler,\n+                                 const char *desc) {\n+  CHECK_LT(n_flags_, kMaxFlags);\n+  flags_[n_flags_].name = name;\n+  flags_[n_flags_].desc = desc;\n+  flags_[n_flags_].handler = handler;\n+  ++n_flags_;\n+}\n+\n+FlagParser::FlagParser() : n_flags_(0), buf_(nullptr), pos_(0) {\n+  flags_ = (Flag *)Alloc.Allocate(sizeof(Flag) * kMaxFlags);\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "7827d7357706c077c9edb6820fe837ae5af763c3", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,120 @@\n+//===-- sanitizer_flag_parser.h ---------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_FLAG_REGISTRY_H\n+#define SANITIZER_FLAG_REGISTRY_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_common.h\"\n+\n+namespace __sanitizer {\n+\n+class FlagHandlerBase {\n+ public:\n+  virtual bool Parse(const char *value) { return false; }\n+};\n+\n+template <typename T>\n+class FlagHandler : public FlagHandlerBase {\n+  T *t_;\n+\n+ public:\n+  explicit FlagHandler(T *t) : t_(t) {}\n+  bool Parse(const char *value) final;\n+};\n+\n+template <>\n+inline bool FlagHandler<bool>::Parse(const char *value) {\n+  if (internal_strcmp(value, \"0\") == 0 ||\n+      internal_strcmp(value, \"no\") == 0 ||\n+      internal_strcmp(value, \"false\") == 0) {\n+    *t_ = false;\n+    return true;\n+  }\n+  if (internal_strcmp(value, \"1\") == 0 ||\n+      internal_strcmp(value, \"yes\") == 0 ||\n+      internal_strcmp(value, \"true\") == 0) {\n+    *t_ = true;\n+    return true;\n+  }\n+  Printf(\"ERROR: Invalid value for bool option: '%s'\\n\", value);\n+  return false;\n+}\n+\n+template <>\n+inline bool FlagHandler<const char *>::Parse(const char *value) {\n+  *t_ = internal_strdup(value);\n+  return true;\n+}\n+\n+template <>\n+inline bool FlagHandler<int>::Parse(const char *value) {\n+  char *value_end;\n+  *t_ = internal_simple_strtoll(value, &value_end, 10);\n+  bool ok = *value_end == 0;\n+  if (!ok) Printf(\"ERROR: Invalid value for int option: '%s'\\n\", value);\n+  return ok;\n+}\n+\n+template <>\n+inline bool FlagHandler<uptr>::Parse(const char *value) {\n+  char *value_end;\n+  *t_ = internal_simple_strtoll(value, &value_end, 10);\n+  bool ok = *value_end == 0;\n+  if (!ok) Printf(\"ERROR: Invalid value for uptr option: '%s'\\n\", value);\n+  return ok;\n+}\n+\n+class FlagParser {\n+  static const int kMaxFlags = 200;\n+  struct Flag {\n+    const char *name;\n+    const char *desc;\n+    FlagHandlerBase *handler;\n+  } *flags_;\n+  int n_flags_;\n+\n+  const char *buf_;\n+  uptr pos_;\n+\n+ public:\n+  FlagParser();\n+  void RegisterHandler(const char *name, FlagHandlerBase *handler,\n+                       const char *desc);\n+  void ParseString(const char *s);\n+  bool ParseFile(const char *path, bool ignore_missing);\n+  void PrintFlagDescriptions();\n+\n+  static LowLevelAllocator Alloc;\n+\n+ private:\n+  void fatal_error(const char *err);\n+  bool is_space(char c);\n+  void skip_whitespace();\n+  void parse_flags();\n+  void parse_flag();\n+  bool run_handler(const char *name, const char *value);\n+  char *ll_strndup(const char *s, uptr n);\n+};\n+\n+template <typename T>\n+static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,\n+                         T *var) {\n+  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT\n+  parser->RegisterHandler(name, fh, desc);\n+}\n+\n+void ReportUnrecognizedFlags();\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FLAG_REGISTRY_H"}, {"sha": "a24ff900011cb07fbf1aeac403a75f594937c23b", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 51, "deletions": 256, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,6 +14,7 @@\n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_list.h\"\n+#include \"sanitizer_flag_parser.h\"\n \n namespace __sanitizer {\n \n@@ -32,274 +33,68 @@ IntrusiveList<FlagDescription> flag_descriptions;\n # define SANITIZER_NEEDS_SEGV 1\n #endif\n \n-void SetCommonFlagsDefaults(CommonFlags *f) {\n-  f->symbolize = true;\n-  f->external_symbolizer_path = 0;\n-  f->allow_addr2line = false;\n-  f->strip_path_prefix = \"\";\n-  f->fast_unwind_on_check = false;\n-  f->fast_unwind_on_fatal = false;\n-  f->fast_unwind_on_malloc = true;\n-  f->handle_ioctl = false;\n-  f->malloc_context_size = 1;\n-  f->log_path = \"stderr\";\n-  f->verbosity = 0;\n-  f->detect_leaks = true;\n-  f->leak_check_at_exit = true;\n-  f->allocator_may_return_null = false;\n-  f->print_summary = true;\n-  f->check_printf = true;\n-  // TODO(glider): tools may want to set different defaults for handle_segv.\n-  f->handle_segv = SANITIZER_NEEDS_SEGV;\n-  f->allow_user_segv_handler = false;\n-  f->use_sigaltstack = true;\n-  f->detect_deadlocks = false;\n-  f->clear_shadow_mmap_threshold = 64 * 1024;\n-  f->color = \"auto\";\n-  f->legacy_pthread_cond = false;\n-  f->intercept_tls_get_addr = false;\n-  f->coverage = false;\n-  f->coverage_direct = SANITIZER_ANDROID;\n-  f->coverage_dir = \".\";\n-  f->full_address_space = false;\n-  f->suppressions = \"\";\n-  f->print_suppressions = true;\n-  f->disable_coredump = (SANITIZER_WORDSIZE == 64);\n-  f->symbolize_inline_frames = true;\n-  f->stack_trace_format = \"DEFAULT\";\n+void CommonFlags::SetDefaults() {\n+#define COMMON_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n+#include \"sanitizer_flags.inc\"\n+#undef COMMON_FLAG\n }\n \n-void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n-  ParseFlag(str, &f->symbolize, \"symbolize\",\n-      \"If set, use the online symbolizer from common sanitizer runtime to turn \"\n-      \"virtual addresses to file/line locations.\");\n-  ParseFlag(str, &f->external_symbolizer_path, \"external_symbolizer_path\",\n-      \"Path to external symbolizer. If empty, the tool will search $PATH for \"\n-      \"the symbolizer.\");\n-  ParseFlag(str, &f->allow_addr2line, \"allow_addr2line\",\n-      \"If set, allows online symbolizer to run addr2line binary to symbolize \"\n-      \"stack traces (addr2line will only be used if llvm-symbolizer binary is \"\n-      \"unavailable.\");\n-  ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\",\n-      \"Strips this prefix from file paths in error reports.\");\n-  ParseFlag(str, &f->fast_unwind_on_check, \"fast_unwind_on_check\",\n-      \"If available, use the fast frame-pointer-based unwinder on \"\n-      \"internal CHECK failures.\");\n-  ParseFlag(str, &f->fast_unwind_on_fatal, \"fast_unwind_on_fatal\",\n-      \"If available, use the fast frame-pointer-based unwinder on fatal \"\n-      \"errors.\");\n-  ParseFlag(str, &f->fast_unwind_on_malloc, \"fast_unwind_on_malloc\",\n-      \"If available, use the fast frame-pointer-based unwinder on \"\n-      \"malloc/free.\");\n-  ParseFlag(str, &f->handle_ioctl, \"handle_ioctl\",\n-      \"Intercept and handle ioctl requests.\");\n-  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\",\n-      \"Max number of stack frames kept for each allocation/deallocation.\");\n-  ParseFlag(str, &f->log_path, \"log_path\",\n-      \"Write logs to \\\"log_path.pid\\\". The special values are \\\"stdout\\\" and \"\n-      \"\\\"stderr\\\". The default is \\\"stderr\\\".\");\n-  ParseFlag(str, &f->verbosity, \"verbosity\",\n-      \"Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\");\n-  ParseFlag(str, &f->detect_leaks, \"detect_leaks\",\n-      \"Enable memory leak detection.\");\n-  ParseFlag(str, &f->leak_check_at_exit, \"leak_check_at_exit\",\n-      \"Invoke leak checking in an atexit handler. Has no effect if \"\n-      \"detect_leaks=false, or if __lsan_do_leak_check() is called before the \"\n-      \"handler has a chance to run.\");\n-  ParseFlag(str, &f->allocator_may_return_null, \"allocator_may_return_null\",\n-      \"If false, the allocator will crash instead of returning 0 on \"\n-      \"out-of-memory.\");\n-  ParseFlag(str, &f->print_summary, \"print_summary\",\n-      \"If false, disable printing error summaries in addition to error \"\n-      \"reports.\");\n-  ParseFlag(str, &f->check_printf, \"check_printf\",\n-      \"Check printf arguments.\");\n-  ParseFlag(str, &f->handle_segv, \"handle_segv\",\n-      \"If set, registers the tool's custom SEGV handler (both SIGBUS and \"\n-      \"SIGSEGV on OSX).\");\n-  ParseFlag(str, &f->allow_user_segv_handler, \"allow_user_segv_handler\",\n-      \"If set, allows user to register a SEGV handler even if the tool \"\n-      \"registers one.\");\n-  ParseFlag(str, &f->use_sigaltstack, \"use_sigaltstack\",\n-      \"If set, uses alternate stack for signal handling.\");\n-  ParseFlag(str, &f->detect_deadlocks, \"detect_deadlocks\",\n-      \"If set, deadlock detection is enabled.\");\n-  ParseFlag(str, &f->clear_shadow_mmap_threshold,\n-            \"clear_shadow_mmap_threshold\",\n-      \"Large shadow regions are zero-filled using mmap(NORESERVE) instead of \"\n-      \"memset(). This is the threshold size in bytes.\");\n-  ParseFlag(str, &f->color, \"color\",\n-      \"Colorize reports: (always|never|auto).\");\n-  ParseFlag(str, &f->legacy_pthread_cond, \"legacy_pthread_cond\",\n-      \"Enables support for dynamic libraries linked with libpthread 2.2.5.\");\n-  ParseFlag(str, &f->intercept_tls_get_addr, \"intercept_tls_get_addr\",\n-            \"Intercept __tls_get_addr.\");\n-  ParseFlag(str, &f->help, \"help\", \"Print the flag descriptions.\");\n-  ParseFlag(str, &f->mmap_limit_mb, \"mmap_limit_mb\",\n-            \"Limit the amount of mmap-ed memory (excluding shadow) in Mb; \"\n-            \"not a user-facing flag, used mosly for testing the tools\");\n-  ParseFlag(str, &f->coverage, \"coverage\",\n-      \"If set, coverage information will be dumped at program shutdown (if the \"\n-      \"coverage instrumentation was enabled at compile time).\");\n-  ParseFlag(str, &f->coverage_direct, \"coverage_direct\",\n-            \"If set, coverage information will be dumped directly to a memory \"\n-            \"mapped file. This way data is not lost even if the process is \"\n-            \"suddenly killed.\");\n-  ParseFlag(str, &f->coverage_dir, \"coverage_dir\",\n-            \"Target directory for coverage dumps. Defaults to the current \"\n-            \"directory.\");\n-  ParseFlag(str, &f->full_address_space, \"full_address_space\",\n-            \"Sanitize complete address space; \"\n-            \"by default kernel area on 32-bit platforms will not be sanitized\");\n-  ParseFlag(str, &f->suppressions, \"suppressions\", \"Suppressions file name.\");\n-  ParseFlag(str, &f->print_suppressions, \"print_suppressions\",\n-            \"Print matched suppressions at exit.\");\n-  ParseFlag(str, &f->disable_coredump, \"disable_coredump\",\n-      \"Disable core dumping. By default, disable_core=1 on 64-bit to avoid \"\n-      \"dumping a 16T+ core file. Ignored on OSes that don't dump core by\"\n-      \"default and for sanitizers that don't reserve lots of virtual memory.\");\n-  ParseFlag(str, &f->symbolize_inline_frames, \"symbolize_inline_frames\",\n-            \"Print inlined frames in stacktraces. Defaults to true.\");\n-  ParseFlag(str, &f->stack_trace_format, \"stack_trace_format\",\n-            \"Format string used to render stack frames. \"\n-            \"See sanitizer_stacktrace_printer.h for the format description. \"\n-            \"Use DEFAULT to get default format.\");\n-\n-  // Do a sanity check for certain flags.\n-  if (f->malloc_context_size < 1)\n-    f->malloc_context_size = 1;\n-}\n-\n-static bool GetFlagValue(const char *env, const char *name,\n-                         const char **value, int *value_length) {\n-  if (env == 0)\n-    return false;\n-  const char *pos = 0;\n-  for (;;) {\n-    pos = internal_strstr(env, name);\n-    if (pos == 0)\n-      return false;\n-    const char *name_end = pos + internal_strlen(name);\n-    if ((pos != env &&\n-         ((pos[-1] >= 'a' && pos[-1] <= 'z') || pos[-1] == '_')) ||\n-        *name_end != '=') {\n-      // Seems to be middle of another flag name or value.\n-      env = pos + 1;\n-      continue;\n-    }\n-    pos = name_end;\n-    break;\n-  }\n-  const char *end;\n-  if (pos[0] != '=') {\n-    end = pos;\n-  } else {\n-    pos += 1;\n-    if (pos[0] == '\"') {\n-      pos += 1;\n-      end = internal_strchr(pos, '\"');\n-    } else if (pos[0] == '\\'') {\n-      pos += 1;\n-      end = internal_strchr(pos, '\\'');\n-    } else {\n-      // Read until the next space or colon.\n-      end = pos + internal_strcspn(pos, \" :\");\n-    }\n-    if (end == 0)\n-      end = pos + internal_strlen(pos);\n-  }\n-  *value = pos;\n-  *value_length = end - pos;\n-  return true;\n-}\n-\n-static bool StartsWith(const char *flag, int flag_length, const char *value) {\n-  if (!flag || !value)\n-    return false;\n-  int value_length = internal_strlen(value);\n-  return (flag_length >= value_length) &&\n-         (0 == internal_strncmp(flag, value, value_length));\n+void CommonFlags::CopyFrom(const CommonFlags &other) {\n+  internal_memcpy(this, &other, sizeof(*this));\n }\n \n-static LowLevelAllocator allocator_for_flags;\n-\n-// The linear scan is suboptimal, but the number of flags is relatively small.\n-bool FlagInDescriptionList(const char *name) {\n-  IntrusiveList<FlagDescription>::Iterator it(&flag_descriptions);\n-  while (it.hasNext()) {\n-    if (!internal_strcmp(it.next()->name, name)) return true;\n+// Copy the string from \"s\" to \"out\", replacing \"%b\" with the binary basename.\n+static void SubstituteBinaryName(const char *s, char *out, uptr out_size) {\n+  char *out_end = out + out_size;\n+  while (*s && out < out_end - 1) {\n+    if (s[0] != '%' || s[1] != 'b') { *out++ = *s++; continue; }\n+    const char *base = GetProcessName();\n+    CHECK(base);\n+    while (*base && out < out_end - 1)\n+      *out++ = *base++;\n+    s += 2; // skip \"%b\"\n   }\n-  return false;\n-}\n-\n-void AddFlagDescription(const char *name, const char *description) {\n-  if (FlagInDescriptionList(name)) return;\n-  FlagDescription *new_description = new(allocator_for_flags) FlagDescription;\n-  new_description->name = name;\n-  new_description->description = description;\n-  flag_descriptions.push_back(new_description);\n+  *out = '\\0';\n }\n \n-// TODO(glider): put the descriptions inside CommonFlags.\n-void PrintFlagDescriptions() {\n-  IntrusiveList<FlagDescription>::Iterator it(&flag_descriptions);\n-  Printf(\"Available flags for %s:\\n\", SanitizerToolName);\n-  while (it.hasNext()) {\n-    FlagDescription *descr = it.next();\n-    Printf(\"\\t%s\\n\\t\\t- %s\\n\", descr->name, descr->description);\n+class FlagHandlerInclude : public FlagHandlerBase {\n+  FlagParser *parser_;\n+  bool ignore_missing_;\n+\n+ public:\n+  explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)\n+      : parser_(parser), ignore_missing_(ignore_missing) {}\n+  bool Parse(const char *value) final {\n+    if (internal_strchr(value, '%')) {\n+      char *buf = (char *)MmapOrDie(kMaxPathLength, \"FlagHandlerInclude\");\n+      SubstituteBinaryName(value, buf, kMaxPathLength);\n+      bool res = parser_->ParseFile(buf, ignore_missing_);\n+      UnmapOrDie(buf, kMaxPathLength);\n+      return res;\n+    }\n+    return parser_->ParseFile(value, ignore_missing_);\n   }\n-}\n-\n-void ParseFlag(const char *env, bool *flag,\n-               const char *name, const char *descr) {\n-  const char *value;\n-  int value_length;\n-  AddFlagDescription(name, descr);\n-  if (!GetFlagValue(env, name, &value, &value_length))\n-    return;\n-  if (StartsWith(value, value_length, \"0\") ||\n-      StartsWith(value, value_length, \"no\") ||\n-      StartsWith(value, value_length, \"false\"))\n-    *flag = false;\n-  if (StartsWith(value, value_length, \"1\") ||\n-      StartsWith(value, value_length, \"yes\") ||\n-      StartsWith(value, value_length, \"true\"))\n-    *flag = true;\n-}\n+};\n \n-void ParseFlag(const char *env, int *flag,\n-               const char *name, const char *descr) {\n-  const char *value;\n-  int value_length;\n-  AddFlagDescription(name, descr);\n-  if (!GetFlagValue(env, name, &value, &value_length))\n-    return;\n-  *flag = static_cast<int>(internal_atoll(value));\n+void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {\n+  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT\n+      FlagHandlerInclude(parser, /*ignore_missing*/ false);\n+  parser->RegisterHandler(\"include\", fh_include,\n+                          \"read more options from the given file\");\n+  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT\n+      FlagHandlerInclude(parser, /*ignore_missing*/ true);\n+  parser->RegisterHandler(\n+      \"include_if_exists\", fh_include_if_exists,\n+      \"read more options from the given file (if it exists)\");\n }\n \n-void ParseFlag(const char *env, uptr *flag,\n-               const char *name, const char *descr) {\n-  const char *value;\n-  int value_length;\n-  AddFlagDescription(name, descr);\n-  if (!GetFlagValue(env, name, &value, &value_length))\n-    return;\n-  *flag = static_cast<uptr>(internal_atoll(value));\n-}\n+void RegisterCommonFlags(FlagParser *parser, CommonFlags *cf) {\n+#define COMMON_FLAG(Type, Name, DefaultValue, Description) \\\n+  RegisterFlag(parser, #Name, Description, &cf->Name);\n+#include \"sanitizer_flags.inc\"\n+#undef COMMON_FLAG\n \n-void ParseFlag(const char *env, const char **flag,\n-               const char *name, const char *descr) {\n-  const char *value;\n-  int value_length;\n-  AddFlagDescription(name, descr);\n-  if (!GetFlagValue(env, name, &value, &value_length))\n-    return;\n-  // Copy the flag value. Don't use locks here, as flags are parsed at\n-  // tool startup.\n-  char *value_copy = (char*)(allocator_for_flags.Allocate(value_length + 1));\n-  internal_memcpy(value_copy, value, value_length);\n-  value_copy[value_length] = '\\0';\n-  *flag = value_copy;\n+  RegisterIncludeFlags(parser, cf);\n }\n \n }  // namespace __sanitizer"}, {"sha": "f1b872b79e2a23e63ad4b44587059c86a304694f", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 25, "deletions": 49, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -16,62 +16,38 @@\n \n namespace __sanitizer {\n \n-void ParseFlag(const char *env, bool *flag,\n-    const char *name, const char *descr);\n-void ParseFlag(const char *env, int *flag,\n-    const char *name, const char *descr);\n-void ParseFlag(const char *env, uptr *flag,\n-    const char *name, const char *descr);\n-void ParseFlag(const char *env, const char **flag,\n-    const char *name, const char *descr);\n-\n struct CommonFlags {\n-  bool symbolize;\n-  const char *external_symbolizer_path;\n-  bool allow_addr2line;\n-  const char *strip_path_prefix;\n-  bool fast_unwind_on_check;\n-  bool fast_unwind_on_fatal;\n-  bool fast_unwind_on_malloc;\n-  bool handle_ioctl;\n-  int malloc_context_size;\n-  const char *log_path;\n-  int  verbosity;\n-  bool detect_leaks;\n-  bool leak_check_at_exit;\n-  bool allocator_may_return_null;\n-  bool print_summary;\n-  bool check_printf;\n-  bool handle_segv;\n-  bool allow_user_segv_handler;\n-  bool use_sigaltstack;\n-  bool detect_deadlocks;\n-  uptr clear_shadow_mmap_threshold;\n-  const char *color;\n-  bool legacy_pthread_cond;\n-  bool intercept_tls_get_addr;\n-  bool help;\n-  uptr mmap_limit_mb;\n-  bool coverage;\n-  bool coverage_direct;\n-  const char *coverage_dir;\n-  bool full_address_space;\n-  const char *suppressions;\n-  bool print_suppressions;\n-  bool disable_coredump;\n-  bool symbolize_inline_frames;\n-  const char *stack_trace_format;\n+#define COMMON_FLAG(Type, Name, DefaultValue, Description) Type Name;\n+#include \"sanitizer_flags.inc\"\n+#undef COMMON_FLAG\n+\n+  void SetDefaults();\n+  void CopyFrom(const CommonFlags &other);\n };\n \n-inline CommonFlags *common_flags() {\n-  extern CommonFlags common_flags_dont_use;\n+// Functions to get/set global CommonFlags shared by all sanitizer runtimes:\n+extern CommonFlags common_flags_dont_use;\n+inline const CommonFlags *common_flags() {\n   return &common_flags_dont_use;\n }\n \n-void SetCommonFlagsDefaults(CommonFlags *f);\n-void ParseCommonFlagsFromString(CommonFlags *f, const char *str);\n-void PrintFlagDescriptions();\n+inline void SetCommonFlagsDefaults() {\n+  common_flags_dont_use.SetDefaults();\n+}\n+\n+// This function can only be used to setup tool-specific overrides for\n+// CommonFlags defaults. Generally, it should only be used right after\n+// SetCommonFlagsDefaults(), but before ParseCommonFlagsFromString(), and\n+// only during the flags initialization (i.e. before they are used for\n+// the first time).\n+inline void OverrideCommonFlags(const CommonFlags &cf) {\n+  common_flags_dont_use.CopyFrom(cf);\n+}\n \n+class FlagParser;\n+void RegisterCommonFlags(FlagParser *parser,\n+                         CommonFlags *cf = &common_flags_dont_use);\n+void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf);\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_FLAGS_H"}, {"sha": "bca1c4b4d0ff293ab567998a5532c89c4daa4c5c", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,192 @@\n+//===-- sanitizer_flags.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file describes common flags available in all sanitizers.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef COMMON_FLAG\n+#error \"Define COMMON_FLAG prior to including this file!\"\n+#endif\n+\n+// COMMON_FLAG(Type, Name, DefaultValue, Description)\n+// Supported types: bool, const char *, int, uptr.\n+// Default value must be a compile-time constant.\n+// Description must be a string literal.\n+\n+COMMON_FLAG(\n+    bool, symbolize, true,\n+    \"If set, use the online symbolizer from common sanitizer runtime to turn \"\n+    \"virtual addresses to file/line locations.\")\n+COMMON_FLAG(\n+    const char *, external_symbolizer_path, nullptr,\n+    \"Path to external symbolizer. If empty, the tool will search $PATH for \"\n+    \"the symbolizer.\")\n+COMMON_FLAG(\n+    bool, allow_addr2line, false,\n+    \"If set, allows online symbolizer to run addr2line binary to symbolize \"\n+    \"stack traces (addr2line will only be used if llvm-symbolizer binary is \"\n+    \"unavailable.\")\n+COMMON_FLAG(const char *, strip_path_prefix, \"\",\n+            \"Strips this prefix from file paths in error reports.\")\n+COMMON_FLAG(bool, fast_unwind_on_check, false,\n+            \"If available, use the fast frame-pointer-based unwinder on \"\n+            \"internal CHECK failures.\")\n+COMMON_FLAG(bool, fast_unwind_on_fatal, false,\n+            \"If available, use the fast frame-pointer-based unwinder on fatal \"\n+            \"errors.\")\n+COMMON_FLAG(bool, fast_unwind_on_malloc, true,\n+            \"If available, use the fast frame-pointer-based unwinder on \"\n+            \"malloc/free.\")\n+COMMON_FLAG(bool, handle_ioctl, false, \"Intercept and handle ioctl requests.\")\n+COMMON_FLAG(int, malloc_context_size, 1,\n+            \"Max number of stack frames kept for each allocation/deallocation.\")\n+COMMON_FLAG(\n+    const char *, log_path, \"stderr\",\n+    \"Write logs to \\\"log_path.pid\\\". The special values are \\\"stdout\\\" and \"\n+    \"\\\"stderr\\\". The default is \\\"stderr\\\".\")\n+COMMON_FLAG(\n+    bool, log_exe_name, false,\n+    \"Mention name of executable when reporting error and \"\n+    \"append executable name to logs (as in \\\"log_path.exe_name.pid\\\").\")\n+COMMON_FLAG(\n+    bool, log_to_syslog, SANITIZER_ANDROID,\n+    \"Write all sanitizer output to syslog in addition to other means of \"\n+    \"logging.\")\n+COMMON_FLAG(\n+    int, verbosity, 0,\n+    \"Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\")\n+COMMON_FLAG(bool, detect_leaks, true, \"Enable memory leak detection.\")\n+COMMON_FLAG(\n+    bool, leak_check_at_exit, true,\n+    \"Invoke leak checking in an atexit handler. Has no effect if \"\n+    \"detect_leaks=false, or if __lsan_do_leak_check() is called before the \"\n+    \"handler has a chance to run.\")\n+COMMON_FLAG(bool, allocator_may_return_null, false,\n+            \"If false, the allocator will crash instead of returning 0 on \"\n+            \"out-of-memory.\")\n+COMMON_FLAG(bool, print_summary, true,\n+            \"If false, disable printing error summaries in addition to error \"\n+            \"reports.\")\n+COMMON_FLAG(bool, check_printf, true, \"Check printf arguments.\")\n+COMMON_FLAG(bool, handle_segv, SANITIZER_NEEDS_SEGV,\n+            \"If set, registers the tool's custom SIGSEGV/SIGBUS handler.\")\n+COMMON_FLAG(bool, handle_abort, false,\n+            \"If set, registers the tool's custom SIGABRT handler.\")\n+COMMON_FLAG(bool, handle_sigfpe, true,\n+            \"If set, registers the tool's custom SIGFPE handler.\")\n+COMMON_FLAG(bool, allow_user_segv_handler, false,\n+            \"If set, allows user to register a SEGV handler even if the tool \"\n+            \"registers one.\")\n+COMMON_FLAG(bool, use_sigaltstack, true,\n+            \"If set, uses alternate stack for signal handling.\")\n+COMMON_FLAG(bool, detect_deadlocks, false,\n+            \"If set, deadlock detection is enabled.\")\n+COMMON_FLAG(\n+    uptr, clear_shadow_mmap_threshold, 64 * 1024,\n+    \"Large shadow regions are zero-filled using mmap(NORESERVE) instead of \"\n+    \"memset(). This is the threshold size in bytes.\")\n+COMMON_FLAG(const char *, color, \"auto\",\n+            \"Colorize reports: (always|never|auto).\")\n+COMMON_FLAG(\n+    bool, legacy_pthread_cond, false,\n+    \"Enables support for dynamic libraries linked with libpthread 2.2.5.\")\n+COMMON_FLAG(bool, intercept_tls_get_addr, false, \"Intercept __tls_get_addr.\")\n+COMMON_FLAG(bool, help, false, \"Print the flag descriptions.\")\n+COMMON_FLAG(uptr, mmap_limit_mb, 0,\n+            \"Limit the amount of mmap-ed memory (excluding shadow) in Mb; \"\n+            \"not a user-facing flag, used mosly for testing the tools\")\n+COMMON_FLAG(uptr, hard_rss_limit_mb, 0,\n+            \"Hard RSS limit in Mb.\"\n+            \" If non-zero, a background thread is spawned at startup\"\n+            \" which periodically reads RSS and aborts the process if the\"\n+            \" limit is reached\")\n+COMMON_FLAG(uptr, soft_rss_limit_mb, 0,\n+            \"Soft RSS limit in Mb.\"\n+            \" If non-zero, a background thread is spawned at startup\"\n+            \" which periodically reads RSS. If the limit is reached\"\n+            \" all subsequent malloc/new calls will fail or return NULL\"\n+            \" (depending on the value of allocator_may_return_null)\"\n+            \" until the RSS goes below the soft limit.\"\n+            \" This limit does not affect memory allocations other than\"\n+            \" malloc/new.\")\n+COMMON_FLAG(bool, can_use_proc_maps_statm, true,\n+            \"If false, do not attempt to read /proc/maps/statm.\"\n+            \" Mostly useful for testing sanitizers.\")\n+COMMON_FLAG(\n+    bool, coverage, false,\n+    \"If set, coverage information will be dumped at program shutdown (if the \"\n+    \"coverage instrumentation was enabled at compile time).\")\n+COMMON_FLAG(bool, coverage_pcs, true,\n+            \"If set (and if 'coverage' is set too), the coverage information \"\n+            \"will be dumped as a set of PC offsets for every module.\")\n+COMMON_FLAG(bool, coverage_order_pcs, false,\n+             \"If true, the PCs will be dumped in the order they've\"\n+             \" appeared during the execution.\")\n+COMMON_FLAG(bool, coverage_bitset, false,\n+            \"If set (and if 'coverage' is set too), the coverage information \"\n+            \"will also be dumped as a bitset to a separate file.\")\n+COMMON_FLAG(bool, coverage_counters, false,\n+            \"If set (and if 'coverage' is set too), the bitmap that corresponds\"\n+            \" to coverage counters will be dumped.\")\n+COMMON_FLAG(bool, coverage_direct, SANITIZER_ANDROID,\n+            \"If set, coverage information will be dumped directly to a memory \"\n+            \"mapped file. This way data is not lost even if the process is \"\n+            \"suddenly killed.\")\n+COMMON_FLAG(const char *, coverage_dir, \".\",\n+            \"Target directory for coverage dumps. Defaults to the current \"\n+            \"directory.\")\n+COMMON_FLAG(bool, full_address_space, false,\n+            \"Sanitize complete address space; \"\n+            \"by default kernel area on 32-bit platforms will not be sanitized\")\n+COMMON_FLAG(bool, print_suppressions, true,\n+            \"Print matched suppressions at exit.\")\n+COMMON_FLAG(\n+    bool, disable_coredump, (SANITIZER_WORDSIZE == 64),\n+    \"Disable core dumping. By default, disable_core=1 on 64-bit to avoid \"\n+    \"dumping a 16T+ core file. Ignored on OSes that don't dump core by\"\n+    \"default and for sanitizers that don't reserve lots of virtual memory.\")\n+COMMON_FLAG(bool, use_madv_dontdump, true,\n+          \"If set, instructs kernel to not store the (huge) shadow \"\n+          \"in core file.\")\n+COMMON_FLAG(bool, symbolize_inline_frames, true,\n+            \"Print inlined frames in stacktraces. Defaults to true.\")\n+COMMON_FLAG(bool, symbolize_vs_style, false,\n+            \"Print file locations in Visual Studio style (e.g: \"\n+            \" file(10,42): ...\")\n+COMMON_FLAG(const char *, stack_trace_format, \"DEFAULT\",\n+            \"Format string used to render stack frames. \"\n+            \"See sanitizer_stacktrace_printer.h for the format description. \"\n+            \"Use DEFAULT to get default format.\")\n+COMMON_FLAG(bool, no_huge_pages_for_shadow, true,\n+            \"If true, the shadow is not allowed to use huge pages. \")\n+COMMON_FLAG(bool, strict_string_checks, false,\n+            \"If set check that string arguments are properly null-terminated\")\n+COMMON_FLAG(bool, intercept_strstr, true,\n+            \"If set, uses custom wrappers for strstr and strcasestr functions \"\n+            \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_strspn, true,\n+            \"If set, uses custom wrappers for strspn and strcspn function \"\n+            \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_strpbrk, true,\n+            \"If set, uses custom wrappers for strpbrk function \"\n+            \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_memcmp, true,\n+            \"If set, uses custom wrappers for memcmp function \"\n+            \"to find more errors.\")\n+COMMON_FLAG(bool, strict_memcmp, true,\n+          \"If true, assume that memcmp(p1, p2, n) always reads n bytes before \"\n+          \"comparing p1 and p2.\")\n+COMMON_FLAG(bool, decorate_proc_maps, false, \"If set, decorate sanitizer \"\n+                                             \"mappings in /proc/self/maps with \"\n+                                             \"user-readable names\")\n+COMMON_FLAG(int, exitcode, 1, \"Override the program exit status if the tool \"\n+                              \"found an error\")\n+COMMON_FLAG(\n+    bool, abort_on_error, SANITIZER_MAC,\n+    \"If set, the tool calls abort() instead of _exit() after printing the \"\n+    \"error report.\")"}, {"sha": "2346fa859b10140be379d196f7a8a7022d7efaa0", "filename": "libsanitizer/sanitizer_common/sanitizer_interception.h", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/libsanitizer%2Fsanitizer_common%2Fsanitizer_interception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/libsanitizer%2Fsanitizer_common%2Fsanitizer_interception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interception.h?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -1,23 +0,0 @@\n-//===-- sanitizer_interception.h --------------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// Common macro definitions for interceptors.\n-// Always use this headers instead of interception/interception.h.\n-//\n-//===----------------------------------------------------------------------===//\n-#ifndef SANITIZER_INTERCEPTION_H\n-#define SANITIZER_INTERCEPTION_H\n-\n-#include \"interception/interception.h\"\n-#include \"sanitizer_common.h\"\n-\n-#if SANITIZER_LINUX && !defined(SANITIZER_GO)\n-#undef REAL\n-#define REAL(x) IndirectExternCall(__interception::PTR_TO_REAL(x))\n-#endif\n-\n-#endif  // SANITIZER_INTERCEPTION_H"}, {"sha": "fe472d8c52720a32214b17f6a23ed6f536291ace", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,56 @@\n+//===-- sanitizer_interface_internal.h --------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between run-time libraries of sanitizers.\n+//\n+// This header declares the sanitizer runtime interface functions.\n+// The runtime library has to define these functions so the instrumented program\n+// could call them.\n+//\n+// See also include/sanitizer/common_interface_defs.h\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_INTERFACE_INTERNAL_H\n+#define SANITIZER_INTERFACE_INTERNAL_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+extern \"C\" {\n+  // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n+  // The special values are \"stdout\" and \"stderr\".\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __sanitizer_set_report_path(const char *path);\n+\n+  typedef struct {\n+      int coverage_sandboxed;\n+      __sanitizer::sptr coverage_fd;\n+      unsigned int coverage_max_block_size;\n+  } __sanitizer_sandbox_arguments;\n+\n+  // Notify the tools that the sandbox is going to be turned on.\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+      __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);\n+\n+  // This function is called by the tool when it has just finished reporting\n+  // an error. 'error_summary' is a one-line string that summarizes\n+  // the error message. This function can be overridden by the client.\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_report_error_summary(const char *error_summary);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump();\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init();\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(__sanitizer::u32 *guard);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __sanitizer_annotate_contiguous_container(const void *beg,\n+                                                 const void *end,\n+                                                 const void *old_mid,\n+                                                 const void *new_mid);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n+                                              const void *end);\n+}  // extern \"C\"\n+\n+#endif  // SANITIZER_INTERFACE_INTERNAL_H"}, {"sha": "d76ed7570a7e732fab579925af0d06dc19501f15", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 31, "deletions": 41, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -13,6 +13,10 @@\n \n #include \"sanitizer_platform.h\"\n \n+#ifndef SANITIZER_DEBUG\n+# define SANITIZER_DEBUG 0\n+#endif\n+\n // Only use SANITIZER_*ATTRIBUTE* before the function return type!\n #if SANITIZER_WINDOWS\n # define SANITIZER_INTERFACE_ATTRIBUTE __declspec(dllexport)\n@@ -26,7 +30,7 @@\n # define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n #endif\n \n-#if SANITIZER_LINUX && !defined(SANITIZER_GO)\n+#if (SANITIZER_LINUX || SANITIZER_WINDOWS) && !defined(SANITIZER_GO)\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n #else\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n@@ -74,13 +78,22 @@ typedef signed   char s8;\n typedef signed   short s16;  // NOLINT\n typedef signed   int s32;\n typedef signed   long long s64;  // NOLINT\n+#if SANITIZER_WINDOWS\n+// On Windows, files are HANDLE, which is a synonim of void*.\n+// Use void* to avoid including <windows.h> everywhere.\n+typedef void* fd_t;\n+typedef unsigned error_t;\n+#else\n typedef int fd_t;\n+typedef int error_t;\n+#endif\n \n // WARNING: OFF_T may be different from OS type off_t, depending on the value of\n // _FILE_OFFSET_BITS. This definition of OFF_T matches the ABI of system calls\n // like pread and mmap, as opposed to pread64 and mmap64.\n-// Mac and Linux/x86-64 are special.\n-#if SANITIZER_MAC || (SANITIZER_LINUX && defined(__x86_64__))\n+// FreeBSD, Mac and Linux/x86-64 are special.\n+#if SANITIZER_FREEBSD || SANITIZER_MAC || \\\n+  (SANITIZER_LINUX && defined(__x86_64__))\n typedef u64 OFF_T;\n #else\n typedef uptr OFF_T;\n@@ -94,41 +107,6 @@ typedef u32 operator_new_size_type;\n #endif\n }  // namespace __sanitizer\n \n-extern \"C\" {\n-  // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n-  // The special values are \"stdout\" and \"stderr\".\n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  void __sanitizer_set_report_path(const char *path);\n-\n-  typedef struct {\n-      int coverage_sandboxed;\n-      __sanitizer::sptr coverage_fd;\n-      unsigned int coverage_max_block_size;\n-  } __sanitizer_sandbox_arguments;\n-\n-  // Notify the tools that the sandbox is going to be turned on.\n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n-      __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);\n-\n-  // This function is called by the tool when it has just finished reporting\n-  // an error. 'error_summary' is a one-line string that summarizes\n-  // the error message. This function can be overridden by the client.\n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  void __sanitizer_report_error_summary(const char *error_summary);\n-\n-  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump();\n-  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init();\n-  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov();\n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  void __sanitizer_annotate_contiguous_container(const void *beg,\n-                                                 const void *end,\n-                                                 const void *old_mid,\n-                                                 const void *new_mid);\n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n-                                              const void *end);\n-}  // extern \"C\"\n-\n \n using namespace __sanitizer;  // NOLINT\n // ----------- ATTENTION -------------\n@@ -149,7 +127,6 @@ using namespace __sanitizer;  // NOLINT\n # define NOINLINE __declspec(noinline)\n # define NORETURN __declspec(noreturn)\n # define THREADLOCAL   __declspec(thread)\n-# define NOTHROW\n # define LIKELY(x) (x)\n # define UNLIKELY(x) (x)\n # define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */\n@@ -163,7 +140,6 @@ using namespace __sanitizer;  // NOLINT\n # define NOINLINE __attribute__((noinline))\n # define NORETURN  __attribute__((noreturn))\n # define THREADLOCAL   __thread\n-# define NOTHROW throw()\n # define LIKELY(x)     __builtin_expect(!!(x), 1)\n # define UNLIKELY(x)   __builtin_expect(!!(x), 0)\n # if defined(__i386__) || defined(__x86_64__)\n@@ -182,6 +158,12 @@ using namespace __sanitizer;  // NOLINT\n # define USED\n #endif\n \n+#if !defined(_MSC_VER) || defined(__clang__) || MSC_PREREQ(1900)\n+# define NOEXCEPT noexcept\n+#else\n+# define NOEXCEPT throw()\n+#endif\n+\n // Unaligned versions of basic types.\n typedef ALIGNED(1) u16 uu16;\n typedef ALIGNED(1) u32 uu32;\n@@ -238,7 +220,7 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n #define CHECK_GT(a, b) CHECK_IMPL((a), >,  (b))\n #define CHECK_GE(a, b) CHECK_IMPL((a), >=, (b))\n \n-#if TSAN_DEBUG\n+#if SANITIZER_DEBUG\n #define DCHECK(a)       CHECK(a)\n #define DCHECK_EQ(a, b) CHECK_EQ(a, b)\n #define DCHECK_NE(a, b) CHECK_NE(a, b)\n@@ -318,4 +300,12 @@ extern \"C\" void* _ReturnAddress(void);\n     } while (internal_iserror(res, &rverrno) && rverrno == EINTR); \\\n   }\n \n+// Forces the compiler to generate a frame pointer in the function.\n+#define ENABLE_FRAME_POINTER                                       \\\n+  do {                                                             \\\n+    volatile uptr enable_fp;                                       \\\n+    enable_fp = GET_CURRENT_FRAME();                               \\\n+    (void)enable_fp;                                               \\\n+  } while (0)\n+\n #endif  // SANITIZER_DEFS_H"}, {"sha": "8bd0e91c400024df6f32d4d55e77b0165e0cd73a", "filename": "libsanitizer/sanitizer_common/sanitizer_lfstack.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -47,8 +47,8 @@ struct LFStack {\n     u64 cmp = atomic_load(&head_, memory_order_acquire);\n     for (;;) {\n       T *cur = (T*)(uptr)(cmp & kPtrMask);\n-      if (cur == 0)\n-        return 0;\n+      if (!cur)\n+        return nullptr;\n       T *nxt = cur->next;\n       u64 cnt = (cmp & kCounterMask);\n       u64 xch = (u64)(uptr)nxt | cnt;\n@@ -66,6 +66,6 @@ struct LFStack {\n \n   atomic_uint64_t head_;\n };\n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // #ifndef SANITIZER_LFSTACK_H\n+#endif // SANITIZER_LFSTACK_H"}, {"sha": "05fdca622e432282836325de5e7f328e0897245f", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -8,37 +8,37 @@\n // This file is shared between AddressSanitizer and ThreadSanitizer\n // run-time libraries. See sanitizer_libc.h for details.\n //===----------------------------------------------------------------------===//\n+\n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n \n namespace __sanitizer {\n \n-// Make the compiler think that something is going on there.\n-static inline void break_optimization(void *arg) {\n-#if _MSC_VER\n-  // FIXME: make sure this is actually enough.\n-  __asm;\n-#else\n-  __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n-#endif\n-}\n-\n s64 internal_atoll(const char *nptr) {\n-  return internal_simple_strtoll(nptr, (char**)0, 10);\n+  return internal_simple_strtoll(nptr, nullptr, 10);\n }\n \n void *internal_memchr(const void *s, int c, uptr n) {\n-  const char* t = (char*)s;\n+  const char *t = (const char *)s;\n   for (uptr i = 0; i < n; ++i, ++t)\n     if (*t == c)\n-      return (void*)t;\n-  return 0;\n+      return reinterpret_cast<void *>(const_cast<char *>(t));\n+  return nullptr;\n+}\n+\n+void *internal_memrchr(const void *s, int c, uptr n) {\n+  const char *t = (const char *)s;\n+  void *res = nullptr;\n+  for (uptr i = 0; i < n; ++i, ++t) {\n+    if (*t == c) res = reinterpret_cast<void *>(const_cast<char *>(t));\n+  }\n+  return res;\n }\n \n int internal_memcmp(const void* s1, const void* s2, uptr n) {\n-  const char* t1 = (char*)s1;\n-  const char* t2 = (char*)s2;\n+  const char *t1 = (const char *)s1;\n+  const char *t2 = (const char *)s2;\n   for (uptr i = 0; i < n; ++i, ++t1, ++t2)\n     if (*t1 != *t2)\n       return *t1 < *t2 ? -1 : 1;\n@@ -47,15 +47,15 @@ int internal_memcmp(const void* s1, const void* s2, uptr n) {\n \n void *internal_memcpy(void *dest, const void *src, uptr n) {\n   char *d = (char*)dest;\n-  char *s = (char*)src;\n+  const char *s = (const char *)src;\n   for (uptr i = 0; i < n; ++i)\n     d[i] = s[i];\n   return dest;\n }\n \n void *internal_memmove(void *dest, const void *src, uptr n) {\n   char *d = (char*)dest;\n-  char *s = (char*)src;\n+  const char *s = (const char *)src;\n   sptr i, signed_n = (sptr)n;\n   CHECK_GE(signed_n, 0);\n   if (d < s) {\n@@ -76,7 +76,8 @@ void internal_bzero_aligned16(void *s, uptr n) {\n   CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);\n   for (S16 *p = reinterpret_cast<S16*>(s), *end = p + n / 16; p < end; p++) {\n     p->a = p->b = 0;\n-    break_optimization(0);  // Make sure this does not become memset.\n+    // Make sure this does not become memset.\n+    SanitizerBreakOptimization(nullptr);\n   }\n }\n \n@@ -95,7 +96,7 @@ void *internal_memset(void* s, int c, uptr n) {\n uptr internal_strcspn(const char *s, const char *reject) {\n   uptr i;\n   for (i = 0; s[i]; i++) {\n-    if (internal_strchr(reject, s[i]) != 0)\n+    if (internal_strchr(reject, s[i]))\n       return i;\n   }\n   return i;\n@@ -109,6 +110,14 @@ char* internal_strdup(const char *s) {\n   return s2;\n }\n \n+char* internal_strndup(const char *s, uptr n) {\n+  uptr len = internal_strnlen(s, n);\n+  char *s2 = (char*)InternalAlloc(len + 1);\n+  internal_memcpy(s2, s, len);\n+  s2[len] = 0;\n+  return s2;\n+}\n+\n int internal_strcmp(const char *s1, const char *s2) {\n   while (true) {\n     unsigned c1 = *s1;\n@@ -136,26 +145,26 @@ int internal_strncmp(const char *s1, const char *s2, uptr n) {\n char* internal_strchr(const char *s, int c) {\n   while (true) {\n     if (*s == (char)c)\n-      return (char*)s;\n+      return const_cast<char *>(s);\n     if (*s == 0)\n-      return 0;\n+      return nullptr;\n     s++;\n   }\n }\n \n char *internal_strchrnul(const char *s, int c) {\n   char *res = internal_strchr(s, c);\n   if (!res)\n-    res = (char*)s + internal_strlen(s);\n+    res = const_cast<char *>(s) + internal_strlen(s);\n   return res;\n }\n \n char *internal_strrchr(const char *s, int c) {\n-  const char *res = 0;\n+  const char *res = nullptr;\n   for (uptr i = 0; s[i]; i++) {\n     if (s[i] == c) res = s + i;\n   }\n-  return (char*)res;\n+  return const_cast<char *>(res);\n }\n \n uptr internal_strlen(const char *s) {\n@@ -191,12 +200,12 @@ char *internal_strstr(const char *haystack, const char *needle) {\n   // This is O(N^2), but we are not using it in hot places.\n   uptr len1 = internal_strlen(haystack);\n   uptr len2 = internal_strlen(needle);\n-  if (len1 < len2) return 0;\n+  if (len1 < len2) return nullptr;\n   for (uptr pos = 0; pos <= len1 - len2; pos++) {\n     if (internal_memcmp(haystack + pos, needle, len2) == 0)\n-      return (char*)haystack + pos;\n+      return const_cast<char *>(haystack) + pos;\n   }\n-  return 0;\n+  return nullptr;\n }\n \n s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {\n@@ -205,7 +214,7 @@ s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {\n   int sgn = 1;\n   u64 res = 0;\n   bool have_digits = false;\n-  char *old_nptr = (char*)nptr;\n+  char *old_nptr = const_cast<char *>(nptr);\n   if (*nptr == '+') {\n     sgn = 1;\n     nptr++;\n@@ -220,8 +229,8 @@ s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {\n     have_digits = true;\n     nptr++;\n   }\n-  if (endptr != 0) {\n-    *endptr = (have_digits) ? (char*)nptr : old_nptr;\n+  if (endptr) {\n+    *endptr = (have_digits) ? const_cast<char *>(nptr) : old_nptr;\n   }\n   if (sgn > 0) {\n     return (s64)(Min((u64)INT64_MAX, res));\n@@ -249,4 +258,4 @@ bool mem_is_zero(const char *beg, uptr size) {\n   return all == 0;\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer"}, {"sha": "1b3f8edfadbedb2d82ed67e980ad419feac5704b", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,7 +9,9 @@\n // run-time libraries.\n // These tools can not use some of the libc functions directly because those\n // functions are intercepted. Instead, we implement a tiny subset of libc here.\n+// FIXME: Some of functions declared in this file are in fact POSIX, not libc.\n //===----------------------------------------------------------------------===//\n+\n #ifndef SANITIZER_LIBC_H\n #define SANITIZER_LIBC_H\n \n@@ -24,6 +26,7 @@ namespace __sanitizer {\n // String functions\n s64 internal_atoll(const char *nptr);\n void *internal_memchr(const void *s, int c, uptr n);\n+void *internal_memrchr(const void *s, int c, uptr n);\n int internal_memcmp(const void* s1, const void* s2, uptr n);\n void *internal_memcpy(void *dest, const void *src, uptr n);\n void *internal_memmove(void *dest, const void *src, uptr n);\n@@ -36,6 +39,7 @@ char *internal_strchrnul(const char *s, int c);\n int internal_strcmp(const char *s1, const char *s2);\n uptr internal_strcspn(const char *s, const char *reject);\n char *internal_strdup(const char *s);\n+char *internal_strndup(const char *s, uptr n);\n uptr internal_strlen(const char *s);\n char *internal_strncat(char *dst, const char *src, uptr n);\n int internal_strncmp(const char *s1, const char *s2, uptr n);\n@@ -52,55 +56,26 @@ int internal_snprintf(char *buffer, uptr length, const char *format, ...);\n // Optimized for the case when the result is true.\n bool mem_is_zero(const char *mem, uptr size);\n \n-\n-// Memory\n-uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n-                   int fd, u64 offset);\n-uptr internal_munmap(void *addr, uptr length);\n-\n // I/O\n-const fd_t kInvalidFd = -1;\n+const fd_t kInvalidFd = (fd_t)-1;\n const fd_t kStdinFd = 0;\n-const fd_t kStdoutFd = 1;\n-const fd_t kStderrFd = 2;\n-uptr internal_close(fd_t fd);\n-int internal_isatty(fd_t fd);\n+const fd_t kStdoutFd = (fd_t)1;\n+const fd_t kStderrFd = (fd_t)2;\n \n-// Use __sanitizer::OpenFile() instead.\n-uptr internal_open(const char *filename, int flags);\n-uptr internal_open(const char *filename, int flags, u32 mode);\n-\n-uptr internal_read(fd_t fd, void *buf, uptr count);\n-uptr internal_write(fd_t fd, const void *buf, uptr count);\n uptr internal_ftruncate(fd_t fd, uptr size);\n \n // OS\n-uptr internal_filesize(fd_t fd);  // -1 on error.\n-uptr internal_stat(const char *path, void *buf);\n-uptr internal_lstat(const char *path, void *buf);\n-uptr internal_fstat(fd_t fd, void *buf);\n-uptr internal_dup2(int oldfd, int newfd);\n-uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n-uptr internal_unlink(const char *path);\n-uptr internal_rename(const char *oldpath, const char *newpath);\n void NORETURN internal__exit(int exitcode);\n-uptr internal_lseek(fd_t fd, OFF_T offset, int whence);\n \n-uptr internal_ptrace(int request, int pid, void *addr, void *data);\n-uptr internal_waitpid(int pid, int *status, int options);\n uptr internal_getpid();\n uptr internal_getppid();\n \n-int internal_fork();\n-\n // Threading\n uptr internal_sched_yield();\n \n // Error handling\n-bool internal_iserror(uptr retval, int *rverrno = 0);\n-\n-int internal_sigaction(int signum, const void *act, void *oldact);\n+bool internal_iserror(uptr retval, int *rverrno = nullptr);\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_LIBC_H\n+#endif // SANITIZER_LIBC_H"}, {"sha": "021ca618d6408f91125d561984e5a4d2a4e42f1d", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -6,54 +6,50 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n+\n #if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n #include \"sanitizer_libignore.h\"\n #include \"sanitizer_flags.h\"\n+#include \"sanitizer_posix.h\"\n #include \"sanitizer_procmaps.h\"\n \n namespace __sanitizer {\n \n LibIgnore::LibIgnore(LinkerInitialized) {\n }\n \n-void LibIgnore::Init(const SuppressionContext &supp) {\n+void LibIgnore::AddIgnoredLibrary(const char *name_templ) {\n   BlockingMutexLock lock(&mutex_);\n-  CHECK_EQ(count_, 0);\n-  const uptr n = supp.SuppressionCount();\n-  for (uptr i = 0; i < n; i++) {\n-    const Suppression *s = supp.SuppressionAt(i);\n-    if (s->type != SuppressionLib)\n-      continue;\n-    if (count_ >= kMaxLibs) {\n-      Report(\"%s: too many called_from_lib suppressions (max: %d)\\n\",\n-             SanitizerToolName, kMaxLibs);\n-      Die();\n-    }\n-    Lib *lib = &libs_[count_++];\n-    lib->templ = internal_strdup(s->templ);\n-    lib->name = 0;\n-    lib->loaded = false;\n+  if (count_ >= kMaxLibs) {\n+    Report(\"%s: too many ignored libraries (max: %d)\\n\", SanitizerToolName,\n+           kMaxLibs);\n+    Die();\n   }\n+  Lib *lib = &libs_[count_++];\n+  lib->templ = internal_strdup(name_templ);\n+  lib->name = nullptr;\n+  lib->real_name = nullptr;\n+  lib->loaded = false;\n }\n \n void LibIgnore::OnLibraryLoaded(const char *name) {\n   BlockingMutexLock lock(&mutex_);\n   // Try to match suppressions with symlink target.\n-  InternalScopedBuffer<char> buf(4096);\n-  if (name != 0 && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&\n-      buf.data()[0]) {\n+  InternalScopedString buf(kMaxPathLength);\n+  if (name && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&\n+      buf[0]) {\n     for (uptr i = 0; i < count_; i++) {\n       Lib *lib = &libs_[i];\n-      if (!lib->loaded && lib->real_name == 0 &&\n+      if (!lib->loaded && (!lib->real_name) &&\n           TemplateMatch(lib->templ, name))\n         lib->real_name = internal_strdup(buf.data());\n     }\n   }\n \n   // Scan suppressions list and find newly loaded and unloaded libraries.\n   MemoryMappingLayout proc_maps(/*cache_enabled*/false);\n-  InternalScopedBuffer<char> module(4096);\n+  InternalScopedString module(kMaxPathLength);\n   for (uptr i = 0; i < count_; i++) {\n     Lib *lib = &libs_[i];\n     bool loaded = false;\n@@ -63,7 +59,7 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n       if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n         continue;\n       if (TemplateMatch(lib->templ, module.data()) ||\n-          (lib->real_name != 0 &&\n+          (lib->real_name &&\n           internal_strcmp(lib->real_name, module.data()) == 0)) {\n         if (loaded) {\n           Report(\"%s: called_from_lib suppression '%s' is matched against\"\n@@ -96,9 +92,9 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n }\n \n void LibIgnore::OnLibraryUnloaded() {\n-  OnLibraryLoaded(0);\n+  OnLibraryLoaded(nullptr);\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // #if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif // #if SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "84419d14fed9aa2ba90f408c56449fbc061c1f1f", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -6,8 +6,8 @@\n //===----------------------------------------------------------------------===//\n //\n // LibIgnore allows to ignore all interceptors called from a particular set\n-// of dynamic libraries. LibIgnore remembers all \"called_from_lib\" suppressions\n-// from the provided SuppressionContext; finds code ranges for the libraries;\n+// of dynamic libraries. LibIgnore can be initialized with several templates\n+// of names of libraries to be ignored. It finds code ranges for the libraries;\n // and checks whether the provided PC value belongs to the code ranges.\n //\n //===----------------------------------------------------------------------===//\n@@ -17,7 +17,6 @@\n \n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_common.h\"\n-#include \"sanitizer_suppressions.h\"\n #include \"sanitizer_atomic.h\"\n #include \"sanitizer_mutex.h\"\n \n@@ -27,8 +26,8 @@ class LibIgnore {\n  public:\n   explicit LibIgnore(LinkerInitialized);\n \n-  // Fetches all \"called_from_lib\" suppressions from the SuppressionContext.\n-  void Init(const SuppressionContext &supp);\n+  // Must be called during initialization.\n+  void AddIgnoredLibrary(const char *name_templ);\n \n   // Must be called after a new dynamic library is loaded.\n   void OnLibraryLoaded(const char *name);"}, {"sha": "00a6c1f094a50a4b63b1c90fc143709a0d7569ad", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 361, "deletions": 92, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -11,6 +11,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n+\n #if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n #include \"sanitizer_common.h\"\n@@ -28,12 +29,22 @@\n #include <asm/param.h>\n #endif\n \n+// For mips64, syscall(__NR_stat) fills the buffer in the 'struct kernel_stat'\n+// format. Struct kernel_stat is defined as 'struct stat' in asm/stat.h. To\n+// access stat from asm/stat.h, without conflicting with definition in\n+// sys/stat.h, we use this trick.\n+#if defined(__mips64)\n+#include <asm/unistd.h>\n+#include <sys/types.h>\n+#define stat kernel_stat\n+#include <asm/stat.h>\n+#undef stat\n+#endif\n+\n #include <dlfcn.h>\n #include <errno.h>\n #include <fcntl.h>\n-#if !SANITIZER_ANDROID\n #include <link.h>\n-#endif\n #include <pthread.h>\n #include <sched.h>\n #include <sys/mman.h>\n@@ -43,6 +54,7 @@\n #include <sys/syscall.h>\n #include <sys/time.h>\n #include <sys/types.h>\n+#include <ucontext.h>\n #include <unistd.h>\n \n #if SANITIZER_FREEBSD\n@@ -60,11 +72,6 @@ extern char **environ;  // provided by crt1\n #include <sys/signal.h>\n #endif\n \n-#if SANITIZER_ANDROID\n-#include <android/log.h>\n-#include <sys/system_properties.h>\n-#endif\n-\n #if SANITIZER_LINUX\n // <linux/time.h>\n struct kernel_timeval {\n@@ -90,26 +97,34 @@ namespace __sanitizer {\n \n #if SANITIZER_LINUX && defined(__x86_64__)\n #include \"sanitizer_syscall_linux_x86_64.inc\"\n+#elif SANITIZER_LINUX && defined(__aarch64__)\n+#include \"sanitizer_syscall_linux_aarch64.inc\"\n #else\n #include \"sanitizer_syscall_generic.inc\"\n #endif\n \n // --------------- sanitizer_libc.h\n-uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n-                    int fd, u64 offset) {\n+uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n+                   OFF_T offset) {\n #if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n   return internal_syscall(SYSCALL(mmap), (uptr)addr, length, prot, flags, fd,\n                           offset);\n #else\n+  // mmap2 specifies file offset in 4096-byte units.\n+  CHECK(IsAligned(offset, 4096));\n   return internal_syscall(SYSCALL(mmap2), addr, length, prot, flags, fd,\n-                          offset);\n+                          offset / 4096);\n #endif\n }\n \n uptr internal_munmap(void *addr, uptr length) {\n   return internal_syscall(SYSCALL(munmap), (uptr)addr, length);\n }\n \n+int internal_mprotect(void *addr, uptr length, int prot) {\n+  return internal_syscall(SYSCALL(mprotect), (uptr)addr, length, prot);\n+}\n+\n uptr internal_close(fd_t fd) {\n   return internal_syscall(SYSCALL(close), fd);\n }\n@@ -131,11 +146,6 @@ uptr internal_open(const char *filename, int flags, u32 mode) {\n #endif\n }\n \n-uptr OpenFile(const char *filename, bool write) {\n-  return internal_open(filename,\n-      write ? O_RDWR | O_CREAT /*| O_CLOEXEC*/ : O_RDONLY, 0660);\n-}\n-\n uptr internal_read(fd_t fd, void *buf, uptr count) {\n   sptr res;\n   HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(read), fd, (uptr)buf,\n@@ -152,7 +162,8 @@ uptr internal_write(fd_t fd, const void *buf, uptr count) {\n \n uptr internal_ftruncate(fd_t fd, uptr size) {\n   sptr res;\n-  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(ftruncate), fd, size));\n+  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(ftruncate), fd,\n+               (OFF_T)size));\n   return res;\n }\n \n@@ -176,14 +187,42 @@ static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n }\n #endif\n \n+#if defined(__mips64)\n+static void kernel_stat_to_stat(struct kernel_stat *in, struct stat *out) {\n+  internal_memset(out, 0, sizeof(*out));\n+  out->st_dev = in->st_dev;\n+  out->st_ino = in->st_ino;\n+  out->st_mode = in->st_mode;\n+  out->st_nlink = in->st_nlink;\n+  out->st_uid = in->st_uid;\n+  out->st_gid = in->st_gid;\n+  out->st_rdev = in->st_rdev;\n+  out->st_size = in->st_size;\n+  out->st_blksize = in->st_blksize;\n+  out->st_blocks = in->st_blocks;\n+  out->st_atime = in->st_atime_nsec;\n+  out->st_mtime = in->st_mtime_nsec;\n+  out->st_ctime = in->st_ctime_nsec;\n+  out->st_ino = in->st_ino;\n+}\n+#endif\n+\n uptr internal_stat(const char *path, void *buf) {\n #if SANITIZER_FREEBSD\n   return internal_syscall(SYSCALL(stat), path, buf);\n #elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n                           (uptr)buf, 0);\n #elif SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+# if defined(__mips64)\n+  // For mips64, stat syscall fills buffer in the format of kernel_stat\n+  struct kernel_stat kbuf;\n+  int res = internal_syscall(SYSCALL(stat), path, &kbuf);\n+  kernel_stat_to_stat(&kbuf, (struct stat *)buf);\n+  return res;\n+# else\n   return internal_syscall(SYSCALL(stat), (uptr)path, (uptr)buf);\n+# endif\n #else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(stat64), path, &buf64);\n@@ -331,23 +370,23 @@ const char *GetEnv(const char *name) {\n   if (!inited) {\n     inited = true;\n     uptr environ_size;\n-    len = ReadFileToBuffer(\"/proc/self/environ\",\n-                           &environ, &environ_size, 1 << 26);\n+    if (!ReadFileToBuffer(\"/proc/self/environ\", &environ, &environ_size, &len))\n+      environ = nullptr;\n   }\n-  if (!environ || len == 0) return 0;\n+  if (!environ || len == 0) return nullptr;\n   uptr namelen = internal_strlen(name);\n   const char *p = environ;\n   while (*p != '\\0') {  // will happen at the \\0\\0 that terminates the buffer\n     // proc file has the format NAME=value\\0NAME=value\\0NAME=value\\0...\n     const char* endp =\n         (char*)internal_memchr(p, '\\0', len - (p - environ));\n-    if (endp == 0)  // this entry isn't NUL terminated\n-      return 0;\n+    if (!endp)  // this entry isn't NUL terminated\n+      return nullptr;\n     else if (!internal_memcmp(p, name, namelen) && p[namelen] == '=')  // Match.\n       return p + namelen + 1;  // point after =\n     p = endp + 1;\n   }\n-  return 0;  // Not found.\n+  return nullptr;  // Not found.\n #else\n #error \"Unsupported platform\"\n #endif\n@@ -361,9 +400,13 @@ extern \"C\" {\n static void ReadNullSepFileToArray(const char *path, char ***arr,\n                                    int arr_size) {\n   char *buff;\n-  uptr buff_size = 0;\n+  uptr buff_size;\n+  uptr buff_len;\n   *arr = (char **)MmapOrDie(arr_size * sizeof(char *), \"NullSepFileArray\");\n-  ReadFileToBuffer(path, &buff, &buff_size, 1024 * 1024);\n+  if (!ReadFileToBuffer(path, &buff, &buff_size, &buff_len, 1024 * 1024)) {\n+    (*arr)[0] = nullptr;\n+    return;\n+  }\n   (*arr)[0] = buff;\n   int count, i;\n   for (count = 1, i = 1; ; i++) {\n@@ -374,7 +417,7 @@ static void ReadNullSepFileToArray(const char *path, char ***arr,\n       count++;\n     }\n   }\n-  (*arr)[count] = 0;\n+  (*arr)[count] = nullptr;\n }\n #endif\n \n@@ -405,32 +448,18 @@ void ReExec() {\n   Die();\n }\n \n-// Stub implementation of GetThreadStackAndTls for Go.\n-#if SANITIZER_GO\n-void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n-                          uptr *tls_addr, uptr *tls_size) {\n-  *stk_addr = 0;\n-  *stk_size = 0;\n-  *tls_addr = 0;\n-  *tls_size = 0;\n-}\n-#endif  // SANITIZER_GO\n-\n enum MutexState {\n   MtxUnlocked = 0,\n   MtxLocked = 1,\n   MtxSleeping = 2\n };\n \n-BlockingMutex::BlockingMutex(LinkerInitialized) {\n-  CHECK_EQ(owner_, 0);\n-}\n-\n BlockingMutex::BlockingMutex() {\n   internal_memset(this, 0, sizeof(*this));\n }\n \n void BlockingMutex::Lock() {\n+  CHECK_EQ(owner_, 0);\n   atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n   if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)\n     return;\n@@ -528,19 +557,21 @@ int internal_fork() {\n }\n \n #if SANITIZER_LINUX\n+#define SA_RESTORER 0x04000000\n // Doesn't set sa_restorer, use with caution (see below).\n int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {\n   __sanitizer_kernel_sigaction_t k_act, k_oldact;\n   internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));\n   internal_memset(&k_oldact, 0, sizeof(__sanitizer_kernel_sigaction_t));\n-  const __sanitizer_sigaction *u_act = (__sanitizer_sigaction *)act;\n+  const __sanitizer_sigaction *u_act = (const __sanitizer_sigaction *)act;\n   __sanitizer_sigaction *u_oldact = (__sanitizer_sigaction *)oldact;\n   if (u_act) {\n     k_act.handler = u_act->handler;\n     k_act.sigaction = u_act->sigaction;\n     internal_memcpy(&k_act.sa_mask, &u_act->sa_mask,\n                     sizeof(__sanitizer_kernel_sigset_t));\n-    k_act.sa_flags = u_act->sa_flags;\n+    // Without SA_RESTORER kernel ignores the calls (probably returns EINVAL).\n+    k_act.sa_flags = u_act->sa_flags | SA_RESTORER;\n     // FIXME: most often sa_restorer is unset, however the kernel requires it\n     // to point to a valid signal restorer that calls the rt_sigreturn syscall.\n     // If sa_restorer passed to the kernel is NULL, the program may crash upon\n@@ -553,8 +584,8 @@ int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {\n   }\n \n   uptr result = internal_syscall(SYSCALL(rt_sigaction), (uptr)signum,\n-      (uptr)(u_act ? &k_act : NULL),\n-      (uptr)(u_oldact ? &k_oldact : NULL),\n+      (uptr)(u_act ? &k_act : nullptr),\n+      (uptr)(u_oldact ? &k_oldact : nullptr),\n       (uptr)sizeof(__sanitizer_kernel_sigset_t));\n \n   if ((result == 0) && u_oldact) {\n@@ -674,45 +705,45 @@ uptr GetPageSize() {\n #endif\n }\n \n-static char proc_self_exe_cache_str[kMaxPathLength];\n-static uptr proc_self_exe_cache_len = 0;\n-\n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n-  if (proc_self_exe_cache_len > 0) {\n-    // If available, use the cached module name.\n-    uptr module_name_len =\n-        internal_snprintf(buf, buf_len, \"%s\", proc_self_exe_cache_str);\n-    CHECK_LT(module_name_len, buf_len);\n-    return module_name_len;\n-  }\n #if SANITIZER_FREEBSD\n-  const int Mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };\n+  const int Mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };\n+  const char *default_module_name = \"kern.proc.pathname\";\n   size_t Size = buf_len;\n-  bool IsErr = (sysctl(Mib, 4, buf, &Size, NULL, 0) != 0);\n+  bool IsErr = (sysctl(Mib, ARRAY_SIZE(Mib), buf, &Size, NULL, 0) != 0);\n   int readlink_error = IsErr ? errno : 0;\n   uptr module_name_len = Size;\n #else\n+  const char *default_module_name = \"/proc/self/exe\";\n   uptr module_name_len = internal_readlink(\n-      \"/proc/self/exe\", buf, buf_len);\n+      default_module_name, buf, buf_len);\n   int readlink_error;\n   bool IsErr = internal_iserror(module_name_len, &readlink_error);\n #endif\n   if (IsErr) {\n-    // We can't read /proc/self/exe for some reason, assume the name of the\n-    // binary is unknown.\n-    Report(\"WARNING: readlink(\\\"/proc/self/exe\\\") failed with errno %d, \"\n+    // We can't read binary name for some reason, assume it's unknown.\n+    Report(\"WARNING: reading executable name failed with errno %d, \"\n            \"some stack frames may not be symbolized\\n\", readlink_error);\n-    module_name_len = internal_snprintf(buf, buf_len, \"/proc/self/exe\");\n+    module_name_len = internal_snprintf(buf, buf_len, \"%s\",\n+                                        default_module_name);\n     CHECK_LT(module_name_len, buf_len);\n   }\n   return module_name_len;\n }\n \n-void CacheBinaryName() {\n-  if (!proc_self_exe_cache_len) {\n-    proc_self_exe_cache_len =\n-        ReadBinaryName(proc_self_exe_cache_str, kMaxPathLength);\n+uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len) {\n+#if SANITIZER_LINUX\n+  char *tmpbuf;\n+  uptr tmpsize;\n+  uptr tmplen;\n+  if (ReadFileToBuffer(\"/proc/self/cmdline\", &tmpbuf, &tmpsize, &tmplen,\n+                       1024 * 1024)) {\n+    internal_strncpy(buf, tmpbuf, buf_len);\n+    UnmapOrDie(tmpbuf, tmpsize);\n+    return internal_strlen(buf);\n   }\n+#endif\n+  return ReadBinaryName(buf, buf_len);\n }\n \n // Match full names of the form /path/to/base_name{-,.}*\n@@ -730,6 +761,7 @@ bool LibraryNameIs(const char *full_name, const char *base_name) {\n #if !SANITIZER_ANDROID\n // Call cb for each region mapped by map.\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {\n+  CHECK_NE(map, nullptr);\n #if !SANITIZER_FREEBSD\n   typedef ElfW(Phdr) Elf_Phdr;\n   typedef ElfW(Ehdr) Elf_Ehdr;\n@@ -829,46 +861,283 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                        : \"rsp\", \"memory\", \"r11\", \"rcx\");\n   return res;\n }\n-#endif  // defined(__x86_64__) && SANITIZER_LINUX\n+#elif defined(__mips__)\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  long long res;\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  CHECK_EQ(0, (uptr)child_stack % 16);\n+  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);\n+  ((unsigned long long *)child_stack)[0] = (uptr)fn;\n+  ((unsigned long long *)child_stack)[1] = (uptr)arg;\n+  register void *a3 __asm__(\"$7\") = newtls;\n+  register int *a4 __asm__(\"$8\") = child_tidptr;\n+  // We don't have proper CFI directives here because it requires alot of code\n+  // for very marginal benefits.\n+  __asm__ __volatile__(\n+                       /* $v0 = syscall($v0 = __NR_clone,\n+                        * $a0 = flags,\n+                        * $a1 = child_stack,\n+                        * $a2 = parent_tidptr,\n+                        * $a3 = new_tls,\n+                        * $a4 = child_tidptr)\n+                        */\n+                       \".cprestore 16;\\n\"\n+                       \"move $4,%1;\\n\"\n+                       \"move $5,%2;\\n\"\n+                       \"move $6,%3;\\n\"\n+                       \"move $7,%4;\\n\"\n+                       /* Store the fifth argument on stack\n+                        * if we are using 32-bit abi.\n+                        */\n+#if SANITIZER_WORDSIZE == 32\n+                       \"lw %5,16($29);\\n\"\n+#else\n+                       \"move $8,%5;\\n\"\n+#endif\n+                       \"li $2,%6;\\n\"\n+                       \"syscall;\\n\"\n \n-#if SANITIZER_ANDROID\n-static atomic_uint8_t android_log_initialized;\n+                       /* if ($v0 != 0)\n+                        * return;\n+                        */\n+                       \"bnez $2,1f;\\n\"\n+\n+                       /* Call \"fn(arg)\". */\n+                       \"ld $25,0($29);\\n\"\n+                       \"ld $4,8($29);\\n\"\n+                       \"jal $25;\\n\"\n \n-void AndroidLogInit() {\n-  atomic_store(&android_log_initialized, 1, memory_order_release);\n+                       /* Call _exit($v0). */\n+                       \"move $4,$2;\\n\"\n+                       \"li $2,%7;\\n\"\n+                       \"syscall;\\n\"\n+\n+                       /* Return to parent. */\n+                     \"1:\\n\"\n+                       : \"=r\" (res)\n+                       : \"r\"(flags),\n+                         \"r\"(child_stack),\n+                         \"r\"(parent_tidptr),\n+                         \"r\"(a3),\n+                         \"r\"(a4),\n+                         \"i\"(__NR_clone),\n+                         \"i\"(__NR_exit)\n+                       : \"memory\", \"$29\" );\n+  return res;\n }\n-// This thing is not, strictly speaking, async signal safe, but it does not seem\n-// to cause any issues. Alternative is writing to log devices directly, but\n-// their location and message format might change in the future, so we'd really\n-// like to avoid that.\n-void AndroidLogWrite(const char *buffer) {\n-  if (!atomic_load(&android_log_initialized, memory_order_acquire))\n-    return;\n+#elif defined(__aarch64__)\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  long long res;\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  CHECK_EQ(0, (uptr)child_stack % 16);\n+  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);\n+  ((unsigned long long *)child_stack)[0] = (uptr)fn;\n+  ((unsigned long long *)child_stack)[1] = (uptr)arg;\n \n-  char *copy = internal_strdup(buffer);\n-  char *p = copy;\n-  char *q;\n-  // __android_log_write has an implicit message length limit.\n-  // Print one line at a time.\n-  do {\n-    q = internal_strchr(p, '\\n');\n-    if (q) *q = '\\0';\n-    __android_log_write(ANDROID_LOG_INFO, NULL, p);\n-    if (q) p = q + 1;\n-  } while (q);\n-  InternalFree(copy);\n+  register int (*__fn)(void *)  __asm__(\"x0\") = fn;\n+  register void *__stack __asm__(\"x1\") = child_stack;\n+  register int   __flags __asm__(\"x2\") = flags;\n+  register void *__arg   __asm__(\"x3\") = arg;\n+  register int  *__ptid  __asm__(\"x4\") = parent_tidptr;\n+  register void *__tls   __asm__(\"x5\") = newtls;\n+  register int  *__ctid  __asm__(\"x6\") = child_tidptr;\n+\n+  __asm__ __volatile__(\n+                       \"mov x0,x2\\n\" /* flags  */\n+                       \"mov x2,x4\\n\" /* ptid  */\n+                       \"mov x3,x5\\n\" /* tls  */\n+                       \"mov x4,x6\\n\" /* ctid  */\n+                       \"mov x8,%9\\n\" /* clone  */\n+\n+                       \"svc 0x0\\n\"\n+\n+                       /* if (%r0 != 0)\n+                        *   return %r0;\n+                        */\n+                       \"cmp x0, #0\\n\"\n+                       \"bne 1f\\n\"\n+\n+                       /* In the child, now. Call \"fn(arg)\". */\n+                       \"ldp x1, x0, [sp], #16\\n\"\n+                       \"blr x1\\n\"\n+\n+                       /* Call _exit(%r0).  */\n+                       \"mov x8, %10\\n\"\n+                       \"svc 0x0\\n\"\n+                     \"1:\\n\"\n+\n+                       : \"=r\" (res)\n+                       : \"i\"(-EINVAL),\n+                         \"r\"(__fn), \"r\"(__stack), \"r\"(__flags), \"r\"(__arg),\n+                         \"r\"(__ptid), \"r\"(__tls), \"r\"(__ctid),\n+                         \"i\"(__NR_clone), \"i\"(__NR_exit)\n+                       : \"x30\", \"memory\");\n+  return res;\n }\n+#endif  // defined(__x86_64__) && SANITIZER_LINUX\n \n+#if SANITIZER_ANDROID\n+#define PROP_VALUE_MAX 92\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE int __system_property_get(const char *name,\n+                                                              char *value);\n void GetExtraActivationFlags(char *buf, uptr size) {\n   CHECK(size > PROP_VALUE_MAX);\n+  CHECK(&__system_property_get);\n   __system_property_get(\"asan.options\", buf);\n }\n+\n+#if __ANDROID_API__ < 21\n+extern \"C\" __attribute__((weak)) int dl_iterate_phdr(\n+    int (*)(struct dl_phdr_info *, size_t, void *), void *);\n+#endif\n+\n+static int dl_iterate_phdr_test_cb(struct dl_phdr_info *info, size_t size,\n+                                   void *data) {\n+  // Any name starting with \"lib\" indicates a bug in L where library base names\n+  // are returned instead of paths.\n+  if (info->dlpi_name && info->dlpi_name[0] == 'l' &&\n+      info->dlpi_name[1] == 'i' && info->dlpi_name[2] == 'b') {\n+    *(bool *)data = true;\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+static atomic_uint32_t android_api_level;\n+\n+static AndroidApiLevel AndroidDetectApiLevel() {\n+  if (!&dl_iterate_phdr)\n+    return ANDROID_KITKAT; // K or lower\n+  bool base_name_seen = false;\n+  dl_iterate_phdr(dl_iterate_phdr_test_cb, &base_name_seen);\n+  if (base_name_seen)\n+    return ANDROID_LOLLIPOP_MR1; // L MR1\n+  return ANDROID_POST_LOLLIPOP;   // post-L\n+  // Plain L (API level 21) is completely broken wrt ASan and not very\n+  // interesting to detect.\n+}\n+\n+AndroidApiLevel AndroidGetApiLevel() {\n+  AndroidApiLevel level =\n+      (AndroidApiLevel)atomic_load(&android_api_level, memory_order_relaxed);\n+  if (level) return level;\n+  level = AndroidDetectApiLevel();\n+  atomic_store(&android_api_level, level, memory_order_relaxed);\n+  return level;\n+}\n+\n #endif\n \n bool IsDeadlySignal(int signum) {\n-  return (signum == SIGSEGV) && common_flags()->handle_segv;\n+  if (common_flags()->handle_abort && signum == SIGABRT)\n+    return true;\n+  if (common_flags()->handle_sigfpe && signum == SIGFPE)\n+    return true;\n+  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;\n+}\n+\n+#ifndef SANITIZER_GO\n+void *internal_start_thread(void(*func)(void *arg), void *arg) {\n+  // Start the thread with signals blocked, otherwise it can steal user signals.\n+  __sanitizer_sigset_t set, old;\n+  internal_sigfillset(&set);\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  // Glibc uses SIGSETXID signal during setuid call. If this signal is blocked\n+  // on any thread, setuid call hangs (see test/tsan/setuid.c).\n+  internal_sigdelset(&set, 33);\n+#endif\n+  internal_sigprocmask(SIG_SETMASK, &set, &old);\n+  void *th;\n+  real_pthread_create(&th, nullptr, (void*(*)(void *arg))func, arg);\n+  internal_sigprocmask(SIG_SETMASK, &old, nullptr);\n+  return th;\n+}\n+\n+void internal_join_thread(void *th) {\n+  real_pthread_join(th, nullptr);\n+}\n+#else\n+void *internal_start_thread(void (*func)(void *), void *arg) { return 0; }\n+\n+void internal_join_thread(void *th) {}\n+#endif\n+\n+void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n+#if defined(__arm__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.arm_pc;\n+  *bp = ucontext->uc_mcontext.arm_fp;\n+  *sp = ucontext->uc_mcontext.arm_sp;\n+#elif defined(__aarch64__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.pc;\n+  *bp = ucontext->uc_mcontext.regs[29];\n+  *sp = ucontext->uc_mcontext.sp;\n+#elif defined(__hppa__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.sc_iaoq[0];\n+  /* GCC uses %r3 whenever a frame pointer is needed.  */\n+  *bp = ucontext->uc_mcontext.sc_gr[3];\n+  *sp = ucontext->uc_mcontext.sc_gr[30];\n+#elif defined(__x86_64__)\n+# if SANITIZER_FREEBSD\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.mc_rip;\n+  *bp = ucontext->uc_mcontext.mc_rbp;\n+  *sp = ucontext->uc_mcontext.mc_rsp;\n+# else\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.gregs[REG_RIP];\n+  *bp = ucontext->uc_mcontext.gregs[REG_RBP];\n+  *sp = ucontext->uc_mcontext.gregs[REG_RSP];\n+# endif\n+#elif defined(__i386__)\n+# if SANITIZER_FREEBSD\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.mc_eip;\n+  *bp = ucontext->uc_mcontext.mc_ebp;\n+  *sp = ucontext->uc_mcontext.mc_esp;\n+# else\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.gregs[REG_EIP];\n+  *bp = ucontext->uc_mcontext.gregs[REG_EBP];\n+  *sp = ucontext->uc_mcontext.gregs[REG_ESP];\n+# endif\n+#elif defined(__powerpc__) || defined(__powerpc64__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.regs->nip;\n+  *sp = ucontext->uc_mcontext.regs->gpr[PT_R1];\n+  // The powerpc{,64}-linux ABIs do not specify r31 as the frame\n+  // pointer, but GCC always uses r31 when we need a frame pointer.\n+  *bp = ucontext->uc_mcontext.regs->gpr[PT_R31];\n+#elif defined(__sparc__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  uptr *stk_ptr;\n+# if defined (__arch64__)\n+  *pc = ucontext->uc_mcontext.mc_gregs[MC_PC];\n+  *sp = ucontext->uc_mcontext.mc_gregs[MC_O6];\n+  stk_ptr = (uptr *) (*sp + 2047);\n+  *bp = stk_ptr[15];\n+# else\n+  *pc = ucontext->uc_mcontext.gregs[REG_PC];\n+  *sp = ucontext->uc_mcontext.gregs[REG_O6];\n+  stk_ptr = (uptr *) *sp;\n+  *bp = stk_ptr[15];\n+# endif\n+#elif defined(__mips__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.pc;\n+  *bp = ucontext->uc_mcontext.gregs[30];\n+  *sp = ucontext->uc_mcontext.gregs[29];\n+#else\n+# error \"Unsupported arch\"\n+#endif\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "44977020bce4eab8a2c0025ea5b0f97d2ae4bdb5", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -15,6 +15,7 @@\n #if SANITIZER_FREEBSD || SANITIZER_LINUX\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_posix.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n \n struct link_map;  // Opaque type returned by dlopen().\n@@ -41,7 +42,7 @@ uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n // internal_sigaction instead.\n int internal_sigaction_norestorer(int signum, const void *act, void *oldact);\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__)\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n #endif\n@@ -78,11 +79,6 @@ uptr ThreadSelfOffset();\n // information).\n bool LibraryNameIs(const char *full_name, const char *base_name);\n \n-// Read the name of the current binary from /proc/self/exe.\n-uptr ReadBinaryName(/*out*/char *buf, uptr buf_len);\n-// Cache the value of /proc/self/exe.\n-void CacheBinaryName();\n-\n // Call cb for each region mapped by map.\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n }  // namespace __sanitizer"}, {"sha": "d876e62fa74b39c80af294c6b092ec0e4786602c", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 210, "deletions": 53, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -11,22 +11,24 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n+\n #if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_freebsd.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_atomic.h\"\n-#include \"sanitizer_symbolizer.h\"\n \n #if SANITIZER_ANDROID || SANITIZER_FREEBSD\n #include <dlfcn.h>  // for dlsym()\n #endif\n \n+#include <link.h>\n #include <pthread.h>\n #include <signal.h>\n #include <sys/resource.h>\n@@ -41,9 +43,18 @@\n #include <sys/prctl.h>\n #endif\n \n+#if SANITIZER_ANDROID\n+#include <android/api-level.h>\n+#endif\n+\n+#if SANITIZER_ANDROID && __ANDROID_API__ < 21\n+#include <android/log.h>\n+#else\n+#include <syslog.h>\n+#endif\n+\n #if !SANITIZER_ANDROID\n #include <elf.h>\n-#include <link.h>\n #include <unistd.h>\n #endif\n \n@@ -53,21 +64,26 @@ namespace __sanitizer {\n extern \"C\" {\n SANITIZER_WEAK_ATTRIBUTE int\n real_pthread_attr_getstack(void *attr, void **addr, size_t *size);\n-}  // extern \"C\"\n+} // extern \"C\"\n \n static int my_pthread_attr_getstack(void *attr, void **addr, size_t *size) {\n-  if (real_pthread_attr_getstack)\n+#if !SANITIZER_GO\n+  if (&real_pthread_attr_getstack)\n     return real_pthread_attr_getstack((pthread_attr_t *)attr, addr, size);\n+#endif\n   return pthread_attr_getstack((pthread_attr_t *)attr, addr, size);\n }\n \n SANITIZER_WEAK_ATTRIBUTE int\n real_sigaction(int signum, const void *act, void *oldact);\n \n int internal_sigaction(int signum, const void *act, void *oldact) {\n-  if (real_sigaction)\n+#if !SANITIZER_GO\n+  if (&real_sigaction)\n     return real_sigaction(signum, act, oldact);\n-  return sigaction(signum, (struct sigaction *)act, (struct sigaction *)oldact);\n+#endif\n+  return sigaction(signum, (const struct sigaction *)act,\n+                   (struct sigaction *)oldact);\n }\n \n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n@@ -83,7 +99,8 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n     MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n     uptr start, end, offset;\n     uptr prev_end = 0;\n-    while (proc_maps.Next(&start, &end, &offset, 0, 0, /* protection */0)) {\n+    while (proc_maps.Next(&start, &end, &offset, nullptr, 0,\n+          /* protection */nullptr)) {\n       if ((uptr)&rl < end)\n         break;\n       prev_end = end;\n@@ -108,7 +125,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   pthread_attr_init(&attr);\n   CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n   uptr stacksize = 0;\n-  void *stackaddr = 0;\n+  void *stackaddr = nullptr;\n   my_pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n   pthread_attr_destroy(&attr);\n \n@@ -117,16 +134,18 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   *stack_bottom = (uptr)stackaddr;\n }\n \n+#if !SANITIZER_GO\n bool SetEnv(const char *name, const char *value) {\n   void *f = dlsym(RTLD_NEXT, \"setenv\");\n-  if (f == 0)\n+  if (!f)\n     return false;\n   typedef int(*setenv_ft)(const char *name, const char *value, int overwrite);\n   setenv_ft setenv_f;\n   CHECK_EQ(sizeof(setenv_f), sizeof(f));\n   internal_memcpy(&setenv_f, &f, sizeof(f));\n-  return IndirectExternCall(setenv_f)(name, value, 1) == 0;\n+  return setenv_f(name, value, 1) == 0;\n }\n+#endif\n \n bool SanitizerSetThreadName(const char *name) {\n #ifdef PR_SET_NAME\n@@ -149,7 +168,7 @@ bool SanitizerGetThreadName(char *name, int max_len) {\n #endif\n }\n \n-#if !SANITIZER_FREEBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n static uptr g_tls_size;\n #endif\n \n@@ -159,8 +178,24 @@ static uptr g_tls_size;\n # define DL_INTERNAL_FUNCTION\n #endif\n \n+#if defined(__mips__)\n+// TlsPreTcbSize includes size of struct pthread_descr and size of tcb\n+// head structure. It lies before the static tls blocks.\n+static uptr TlsPreTcbSize() {\n+  const uptr kTcbHead = 16;\n+  const uptr kTlsAlign = 16;\n+  const uptr kTlsPreTcbSize =\n+    (ThreadDescriptorSize() + kTcbHead + kTlsAlign - 1) & ~(kTlsAlign - 1);\n+  InitTlsSize();\n+  g_tls_size = (g_tls_size + kTlsPreTcbSize + kTlsAlign -1) & ~(kTlsAlign - 1);\n+  return kTlsPreTcbSize;\n+}\n+#endif\n+\n void InitTlsSize() {\n-#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID\n+#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n+// all current supported platforms have 16 bytes stack alignment\n+  const size_t kStackAlign = 16;\n   typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;\n   get_tls_func get_tls;\n   void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n@@ -170,19 +205,24 @@ void InitTlsSize() {\n   CHECK_NE(get_tls, 0);\n   size_t tls_size = 0;\n   size_t tls_align = 0;\n-  IndirectExternCall(get_tls)(&tls_size, &tls_align);\n-  g_tls_size = tls_size;\n-#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID\n+  get_tls(&tls_size, &tls_align);\n+  if (tls_align < kStackAlign)\n+    tls_align = kStackAlign;\n+  g_tls_size = RoundUpTo(tls_size, tls_align);\n+#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n }\n \n-#if (defined(__x86_64__) || defined(__i386__)) && SANITIZER_LINUX\n+#if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) \\\n+    || defined(__aarch64__)) \\\n+    && SANITIZER_LINUX && !SANITIZER_ANDROID\n // sizeof(struct thread) from glibc.\n static atomic_uintptr_t kThreadDescriptorSize;\n \n uptr ThreadDescriptorSize() {\n   uptr val = atomic_load(&kThreadDescriptorSize, memory_order_relaxed);\n   if (val)\n     return val;\n+#if defined(__x86_64__) || defined(__i386__)\n #ifdef _CS_GNU_LIBC_VERSION\n   char buf[64];\n   uptr len = confstr(_CS_GNU_LIBC_VERSION, buf, sizeof(buf));\n@@ -205,13 +245,27 @@ uptr ThreadDescriptorSize() {\n         val = FIRST_32_SECOND_64(1168, 1776);\n       else if (minor <= 12)\n         val = FIRST_32_SECOND_64(1168, 2288);\n+      else if (minor == 13)\n+        val = FIRST_32_SECOND_64(1168, 2304);\n       else\n         val = FIRST_32_SECOND_64(1216, 2304);\n     }\n     if (val)\n       atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n     return val;\n   }\n+#endif\n+#elif defined(__mips__)\n+  // TODO(sagarthakur): add more values as per different glibc versions.\n+  val = FIRST_32_SECOND_64(1152, 1776);\n+  if (val)\n+    atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n+  return val;\n+#elif defined(__aarch64__)\n+  // The sizeof (struct pthread) is the same from GLIBC 2.17 to 2.22.\n+  val = 1776;\n+  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n+  return val;\n #endif\n   return 0;\n }\n@@ -229,12 +283,26 @@ uptr ThreadSelf() {\n   asm(\"mov %%gs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n # elif defined(__x86_64__)\n   asm(\"mov %%fs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n+# elif defined(__mips__)\n+  // MIPS uses TLS variant I. The thread pointer (in hardware register $29)\n+  // points to the end of the TCB + 0x7000. The pthread_descr structure is\n+  // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n+  // TCB and the size of pthread_descr.\n+  const uptr kTlsTcbOffset = 0x7000;\n+  uptr thread_pointer;\n+  asm volatile(\".set push;\\\n+                .set mips64r2;\\\n+                rdhwr %0,$29;\\\n+                .set pop\" : \"=r\" (thread_pointer));\n+  descr_addr = thread_pointer - kTlsTcbOffset - TlsPreTcbSize();\n+# elif defined(__aarch64__)\n+  descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer());\n # else\n #  error \"unsupported CPU arch\"\n # endif\n   return descr_addr;\n }\n-#endif  // (defined(__x86_64__) || defined(__i386__)) && SANITIZER_LINUX\n+#endif  // (x86_64 || i386 || MIPS) && SANITIZER_LINUX\n \n #if SANITIZER_FREEBSD\n static void **ThreadSelfSegbase() {\n@@ -256,13 +324,17 @@ uptr ThreadSelf() {\n }\n #endif  // SANITIZER_FREEBSD\n \n+#if !SANITIZER_GO\n static void GetTls(uptr *addr, uptr *size) {\n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n # if defined(__x86_64__) || defined(__i386__)\n   *addr = ThreadSelf();\n   *size = GetTlsSize();\n   *addr -= *size;\n   *addr += ThreadDescriptorSize();\n+# elif defined(__mips__) || defined(__aarch64__)\n+  *addr = ThreadSelf();\n+  *size = GetTlsSize();\n # else\n   *addr = 0;\n   *size = 0;\n@@ -280,23 +352,33 @@ static void GetTls(uptr *addr, uptr *size) {\n     *addr = (uptr) dtv[2];\n     *size = (*addr == 0) ? 0 : ((uptr) segbase[0] - (uptr) dtv[2]);\n   }\n+#elif SANITIZER_ANDROID\n+  *addr = 0;\n+  *size = 0;\n #else\n # error \"Unknown OS\"\n #endif\n }\n+#endif\n \n+#if !SANITIZER_GO\n uptr GetTlsSize() {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_ANDROID\n   uptr addr, size;\n   GetTls(&addr, &size);\n   return size;\n #else\n   return g_tls_size;\n #endif\n }\n+#endif\n \n void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                           uptr *tls_addr, uptr *tls_size) {\n+#if SANITIZER_GO\n+  // Stub implementation for Go.\n+  *stk_addr = *stk_size = *tls_addr = *tls_size = 0;\n+#else\n   GetTls(tls_addr, tls_size);\n \n   uptr stack_top, stack_bottom;\n@@ -313,8 +395,10 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n       *tls_addr = *stk_addr + *stk_size;\n     }\n   }\n+#endif\n }\n \n+#if !SANITIZER_GO\n void AdjustStackSize(void *attr_) {\n   pthread_attr_t *attr = (pthread_attr_t *)attr_;\n   uptr stackaddr = 0;\n@@ -339,14 +423,8 @@ void AdjustStackSize(void *attr_) {\n     }\n   }\n }\n+#endif // !SANITIZER_GO\n \n-#if SANITIZER_ANDROID\n-uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n-                      string_predicate_t filter) {\n-  MemoryMappingLayout memory_mapping(false);\n-  return memory_mapping.DumpListOfModules(modules, max_modules, filter);\n-}\n-#else  // SANITIZER_ANDROID\n # if !SANITIZER_FREEBSD\n typedef ElfW(Phdr) Elf_Phdr;\n # elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001  // v9.2\n@@ -367,22 +445,20 @@ static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n   DlIteratePhdrData *data = (DlIteratePhdrData*)arg;\n   if (data->current_n == data->max_n)\n     return 0;\n-  InternalScopedBuffer<char> module_name(kMaxPathLength);\n-  module_name.data()[0] = '\\0';\n+  InternalScopedString module_name(kMaxPathLength);\n   if (data->first) {\n     data->first = false;\n     // First module is the binary itself.\n-    ReadBinaryName(module_name.data(), module_name.size());\n+    ReadBinaryNameCached(module_name.data(), module_name.size());\n   } else if (info->dlpi_name) {\n-    internal_strncpy(module_name.data(), info->dlpi_name, module_name.size());\n+    module_name.append(\"%s\", info->dlpi_name);\n   }\n-  if (module_name.data()[0] == '\\0')\n+  if (module_name[0] == '\\0')\n     return 0;\n   if (data->filter && !data->filter(module_name.data()))\n     return 0;\n-  void *mem = &data->modules[data->current_n];\n-  LoadedModule *cur_module = new(mem) LoadedModule(module_name.data(),\n-                                                   info->dlpi_addr);\n+  LoadedModule *cur_module = &data->modules[data->current_n];\n+  cur_module->set(module_name.data(), info->dlpi_addr);\n   data->current_n++;\n   for (int i = 0; i < info->dlpi_phnum; i++) {\n     const Elf_Phdr *phdr = &info->dlpi_phdr[i];\n@@ -396,36 +472,117 @@ static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n   return 0;\n }\n \n+#if SANITIZER_ANDROID && __ANDROID_API__ < 21\n+extern \"C\" __attribute__((weak)) int dl_iterate_phdr(\n+    int (*)(struct dl_phdr_info *, size_t, void *), void *);\n+#endif\n+\n uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n                       string_predicate_t filter) {\n+#if SANITIZER_ANDROID && __ANDROID_API__ <= 22\n+  u32 api_level = AndroidGetApiLevel();\n+  // Fall back to /proc/maps if dl_iterate_phdr is unavailable or broken.\n+  // The runtime check allows the same library to work with\n+  // both K and L (and future) Android releases.\n+  if (api_level <= ANDROID_LOLLIPOP_MR1) { // L or earlier\n+    MemoryMappingLayout memory_mapping(false);\n+    return memory_mapping.DumpListOfModules(modules, max_modules, filter);\n+  }\n+#endif\n   CHECK(modules);\n   DlIteratePhdrData data = {modules, 0, true, max_modules, filter};\n   dl_iterate_phdr(dl_iterate_phdr_cb, &data);\n   return data.current_n;\n }\n-#endif  // SANITIZER_ANDROID\n \n-uptr indirect_call_wrapper;\n+// getrusage does not give us the current RSS, only the max RSS.\n+// Still, this is better than nothing if /proc/self/statm is not available\n+// for some reason, e.g. due to a sandbox.\n+static uptr GetRSSFromGetrusage() {\n+  struct rusage usage;\n+  if (getrusage(RUSAGE_SELF, &usage))  // Failed, probably due to a sandbox.\n+    return 0;\n+  return usage.ru_maxrss << 10;  // ru_maxrss is in Kb.\n+}\n+\n+uptr GetRSS() {\n+  if (!common_flags()->can_use_proc_maps_statm)\n+    return GetRSSFromGetrusage();\n+  fd_t fd = OpenFile(\"/proc/self/statm\", RdOnly);\n+  if (fd == kInvalidFd)\n+    return GetRSSFromGetrusage();\n+  char buf[64];\n+  uptr len = internal_read(fd, buf, sizeof(buf) - 1);\n+  internal_close(fd);\n+  if ((sptr)len <= 0)\n+    return 0;\n+  buf[len] = 0;\n+  // The format of the file is:\n+  // 1084 89 69 11 0 79 0\n+  // We need the second number which is RSS in pages.\n+  char *pos = buf;\n+  // Skip the first number.\n+  while (*pos >= '0' && *pos <= '9')\n+    pos++;\n+  // Skip whitespaces.\n+  while (!(*pos >= '0' && *pos <= '9') && *pos != 0)\n+    pos++;\n+  // Read the number.\n+  uptr rss = 0;\n+  while (*pos >= '0' && *pos <= '9')\n+    rss = rss * 10 + *pos++ - '0';\n+  return rss * GetPageSizeCached();\n+}\n+\n+// 64-bit Android targets don't provide the deprecated __android_log_write.\n+// Starting with the L release, syslog() works and is preferable to\n+// __android_log_write.\n+#if SANITIZER_LINUX\n+\n+#if SANITIZER_ANDROID\n+static atomic_uint8_t android_log_initialized;\n \n-void SetIndirectCallWrapper(uptr wrapper) {\n-  CHECK(!indirect_call_wrapper);\n-  CHECK(wrapper);\n-  indirect_call_wrapper = wrapper;\n+void AndroidLogInit() {\n+  atomic_store(&android_log_initialized, 1, memory_order_release);\n }\n \n-void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n-  // Some kinds of sandboxes may forbid filesystem access, so we won't be able\n-  // to read the file mappings from /proc/self/maps. Luckily, neither the\n-  // process will be able to load additional libraries, so it's fine to use the\n-  // cached mappings.\n-  MemoryMappingLayout::CacheMemoryMappings();\n-  // Same for /proc/self/exe in the symbolizer.\n-#if !SANITIZER_GO\n-  Symbolizer::GetOrInit()->PrepareForSandboxing();\n-  CovPrepareForSandboxing(args);\n+static bool IsSyslogAvailable() {\n+  return atomic_load(&android_log_initialized, memory_order_acquire);\n+}\n+#else\n+void AndroidLogInit() {}\n+\n+static bool IsSyslogAvailable() { return true; }\n+#endif  // SANITIZER_ANDROID\n+\n+static void WriteOneLineToSyslog(const char *s) {\n+#if SANITIZER_ANDROID &&__ANDROID_API__ < 21\n+  __android_log_write(ANDROID_LOG_INFO, NULL, s);\n+#else\n+  syslog(LOG_INFO, \"%s\", s);\n #endif\n }\n \n-}  // namespace __sanitizer\n+void WriteToSyslog(const char *buffer) {\n+  if (!IsSyslogAvailable())\n+    return;\n+  char *copy = internal_strdup(buffer);\n+  char *p = copy;\n+  char *q;\n+  // syslog, at least on Android, has an implicit message length limit.\n+  // Print one line at a time.\n+  do {\n+    q = internal_strchr(p, '\\n');\n+    if (q)\n+      *q = '\\0';\n+    WriteOneLineToSyslog(p);\n+    if (q)\n+      p = q + 1;\n+  } while (q);\n+  InternalFree(copy);\n+}\n+#endif // SANITIZER_LINUX\n+\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "9216ede67fb8a27dfac1499f9b0800faa5608364", "filename": "libsanitizer/sanitizer_common/sanitizer_list.h", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,6 +9,7 @@\n // ThreadSanitizer, etc run-times.\n //\n //===----------------------------------------------------------------------===//\n+\n #ifndef SANITIZER_LIST_H\n #define SANITIZER_LIST_H\n \n@@ -27,7 +28,7 @@ struct IntrusiveList {\n   friend class Iterator;\n \n   void clear() {\n-    first_ = last_ = 0;\n+    first_ = last_ = nullptr;\n     size_ = 0;\n   }\n \n@@ -36,11 +37,11 @@ struct IntrusiveList {\n \n   void push_back(Item *x) {\n     if (empty()) {\n-      x->next = 0;\n+      x->next = nullptr;\n       first_ = last_ = x;\n       size_ = 1;\n     } else {\n-      x->next = 0;\n+      x->next = nullptr;\n       last_->next = x;\n       last_ = x;\n       size_++;\n@@ -49,7 +50,7 @@ struct IntrusiveList {\n \n   void push_front(Item *x) {\n     if (empty()) {\n-      x->next = 0;\n+      x->next = nullptr;\n       first_ = last_ = x;\n       size_ = 1;\n     } else {\n@@ -62,8 +63,8 @@ struct IntrusiveList {\n   void pop_front() {\n     CHECK(!empty());\n     first_ = first_->next;\n-    if (first_ == 0)\n-      last_ = 0;\n+    if (!first_)\n+      last_ = nullptr;\n     size_--;\n   }\n \n@@ -113,27 +114,31 @@ struct IntrusiveList {\n     }\n   }\n \n-  class Iterator {\n+  template<class ListTy, class ItemTy>\n+  class IteratorBase {\n    public:\n-    explicit Iterator(IntrusiveList<Item> *list)\n+    explicit IteratorBase(ListTy *list)\n         : list_(list), current_(list->first_) { }\n-    Item *next() {\n-      Item *ret = current_;\n+    ItemTy *next() {\n+      ItemTy *ret = current_;\n       if (current_) current_ = current_->next;\n       return ret;\n     }\n-    bool hasNext() const { return current_ != 0; }\n+    bool hasNext() const { return current_ != nullptr; }\n    private:\n-    IntrusiveList<Item> *list_;\n-    Item *current_;\n+    ListTy *list_;\n+    ItemTy *current_;\n   };\n \n+  typedef IteratorBase<IntrusiveList<Item>, Item> Iterator;\n+  typedef IteratorBase<const IntrusiveList<Item>, const Item> ConstIterator;\n+\n // private, don't use directly.\n   uptr size_;\n   Item *first_;\n   Item *last_;\n };\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_LIST_H\n+#endif // SANITIZER_LIST_H"}, {"sha": "8cc07f12788c3d17788ebfbcb6f94a612c3c0a59", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 105, "deletions": 23, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -25,21 +25,30 @@\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_mac.h\"\n #include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n #include \"sanitizer_procmaps.h\"\n \n+#if !SANITIZER_IOS\n #include <crt_externs.h>  // for _NSGetEnviron\n+#else\n+extern char **environ;\n+#endif\n+\n+#include <errno.h>\n #include <fcntl.h>\n+#include <libkern/OSAtomic.h>\n+#include <mach-o/dyld.h>\n+#include <mach/mach.h>\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>\n+#include <stdlib.h>\n #include <sys/mman.h>\n #include <sys/resource.h>\n #include <sys/stat.h>\n #include <sys/sysctl.h>\n #include <sys/types.h>\n #include <unistd.h>\n-#include <libkern/OSAtomic.h>\n-#include <errno.h>\n \n namespace __sanitizer {\n \n@@ -55,6 +64,10 @@ uptr internal_munmap(void *addr, uptr length) {\n   return munmap(addr, length);\n }\n \n+int internal_mprotect(void *addr, uptr length, int prot) {\n+  return mprotect(addr, length, prot);\n+}\n+\n uptr internal_close(fd_t fd) {\n   return close(fd);\n }\n@@ -67,11 +80,6 @@ uptr internal_open(const char *filename, int flags, u32 mode) {\n   return open(filename, flags, mode);\n }\n \n-uptr OpenFile(const char *filename, bool write) {\n-  return internal_open(filename,\n-      write ? O_WRONLY | O_CREAT : O_RDONLY, 0660);\n-}\n-\n uptr internal_read(fd_t fd, void *buf, uptr count) {\n   return read(fd, buf, count);\n }\n@@ -107,6 +115,10 @@ uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n   return readlink(path, buf, bufsize);\n }\n \n+uptr internal_unlink(const char *path) {\n+  return unlink(path);\n+}\n+\n uptr internal_sched_yield() {\n   return sched_yield();\n }\n@@ -124,6 +136,13 @@ int internal_sigaction(int signum, const void *act, void *oldact) {\n                    (struct sigaction *)act, (struct sigaction *)oldact);\n }\n \n+void internal_sigfillset(__sanitizer_sigset_t *set) { sigfillset(set); }\n+\n+uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n+                          __sanitizer_sigset_t *oldset) {\n+  return sigprocmask(how, set, oldset);\n+}\n+\n int internal_fork() {\n   // TODO(glider): this may call user's pthread_atfork() handlers which is bad.\n   return fork();\n@@ -174,45 +193,62 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   *stack_bottom = *stack_top - stacksize;\n }\n \n-const char *GetEnv(const char *name) {\n+char **GetEnviron() {\n+#if !SANITIZER_IOS\n   char ***env_ptr = _NSGetEnviron();\n   if (!env_ptr) {\n     Report(\"_NSGetEnviron() returned NULL. Please make sure __asan_init() is \"\n            \"called after libSystem_initializer().\\n\");\n     CHECK(env_ptr);\n   }\n   char **environ = *env_ptr;\n+#endif\n   CHECK(environ);\n+  return environ;\n+}\n+\n+const char *GetEnv(const char *name) {\n+  char **env = GetEnviron();\n   uptr name_len = internal_strlen(name);\n-  while (*environ != 0) {\n-    uptr len = internal_strlen(*environ);\n+  while (*env != 0) {\n+    uptr len = internal_strlen(*env);\n     if (len > name_len) {\n-      const char *p = *environ;\n+      const char *p = *env;\n       if (!internal_memcmp(p, name, name_len) &&\n           p[name_len] == '=') {  // Match.\n-        return *environ + name_len + 1;  // String starting after =.\n+        return *env + name_len + 1;  // String starting after =.\n       }\n     }\n-    environ++;\n+    env++;\n   }\n   return 0;\n }\n \n-void ReExec() {\n-  UNIMPLEMENTED();\n+uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n+  CHECK_LE(kMaxPathLength, buf_len);\n+\n+  // On OS X the executable path is saved to the stack by dyld. Reading it\n+  // from there is much faster than calling dladdr, especially for large\n+  // binaries with symbols.\n+  InternalScopedString exe_path(kMaxPathLength);\n+  uint32_t size = exe_path.size();\n+  if (_NSGetExecutablePath(exe_path.data(), &size) == 0 &&\n+      realpath(exe_path.data(), buf) != 0) {\n+    return internal_strlen(buf);\n+  }\n+  return 0;\n }\n \n-void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n-  (void)args;\n-  // Nothing here for now.\n+uptr ReadLongProcessName(/*out*/char *buf, uptr buf_len) {\n+  return ReadBinaryName(buf, buf_len);\n }\n \n-uptr GetPageSize() {\n-  return sysconf(_SC_PAGESIZE);\n+void ReExec() {\n+  UNIMPLEMENTED();\n }\n \n-BlockingMutex::BlockingMutex(LinkerInitialized) {\n-  // We assume that OS_SPINLOCK_INIT is zero\n+uptr GetPageSize() {\n+  return sysconf(_SC_PAGESIZE);\n }\n \n BlockingMutex::BlockingMutex() {\n@@ -296,7 +332,11 @@ MacosVersion GetMacosVersionInternal() {\n         case '2': return MACOS_VERSION_MOUNTAIN_LION;\n         case '3': return MACOS_VERSION_MAVERICKS;\n         case '4': return MACOS_VERSION_YOSEMITE;\n-        default: return MACOS_VERSION_UNKNOWN;\n+        default:\n+          if (IsDigit(version[1]))\n+            return MACOS_VERSION_UNKNOWN_NEWER;\n+          else\n+            return MACOS_VERSION_UNKNOWN;\n       }\n     }\n     default: return MACOS_VERSION_UNKNOWN;\n@@ -315,6 +355,48 @@ MacosVersion GetMacosVersion() {\n   return result;\n }\n \n+uptr GetRSS() {\n+  struct task_basic_info info;\n+  unsigned count = TASK_BASIC_INFO_COUNT;\n+  kern_return_t result =\n+      task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &count);\n+  if (UNLIKELY(result != KERN_SUCCESS)) {\n+    Report(\"Cannot get task info. Error: %d\\n\", result);\n+    Die();\n+  }\n+  return info.resident_size;\n+}\n+\n+void *internal_start_thread(void (*func)(void *arg), void *arg) { return 0; }\n+void internal_join_thread(void *th) { }\n+\n+void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+# if defined(__aarch64__)\n+  *pc = ucontext->uc_mcontext->__ss.__pc;\n+#   if defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_8_0\n+  *bp = ucontext->uc_mcontext->__ss.__fp;\n+#   else\n+  *bp = ucontext->uc_mcontext->__ss.__lr;\n+#   endif\n+  *sp = ucontext->uc_mcontext->__ss.__sp;\n+# elif defined(__x86_64__)\n+  *pc = ucontext->uc_mcontext->__ss.__rip;\n+  *bp = ucontext->uc_mcontext->__ss.__rbp;\n+  *sp = ucontext->uc_mcontext->__ss.__rsp;\n+# elif defined(__arm__)\n+  *pc = ucontext->uc_mcontext->__ss.__pc;\n+  *bp = ucontext->uc_mcontext->__ss.__r[7];\n+  *sp = ucontext->uc_mcontext->__ss.__sp;\n+# elif defined(__i386__)\n+  *pc = ucontext->uc_mcontext->__ss.__eip;\n+  *bp = ucontext->uc_mcontext->__ss.__ebp;\n+  *sp = ucontext->uc_mcontext->__ss.__esp;\n+# else\n+# error \"Unknown architecture\"\n+# endif\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_MAC"}, {"sha": "2aac83e3657ccc4b2be183aa8ead5bc193d2437a", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -13,6 +13,7 @@\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_MAC\n+#include \"sanitizer_posix.h\"\n \n namespace __sanitizer {\n \n@@ -25,10 +26,13 @@ enum MacosVersion {\n   MACOS_VERSION_MOUNTAIN_LION,\n   MACOS_VERSION_MAVERICKS,\n   MACOS_VERSION_YOSEMITE,\n+  MACOS_VERSION_UNKNOWN_NEWER\n };\n \n MacosVersion GetMacosVersion();\n \n+char **GetEnviron();\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_MAC"}, {"sha": "75f495a4d65fb79d583f5b63a9a900a9e900a2f6", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -71,7 +71,13 @@ class SpinMutex : public StaticSpinMutex {\n \n class BlockingMutex {\n  public:\n+#if SANITIZER_WINDOWS\n+  // Windows does not currently support LinkerInitialized\n   explicit BlockingMutex(LinkerInitialized);\n+#else\n+  explicit constexpr BlockingMutex(LinkerInitialized)\n+      : opaque_storage_ {0, }, owner_(0) {}\n+#endif\n   BlockingMutex();\n   void Lock();\n   void Unlock();"}, {"sha": "71185033eff4e8d59e838d9e9190943dda963fb1", "filename": "libsanitizer/sanitizer_common/sanitizer_persistent_allocator.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -8,6 +8,7 @@\n // A fast memory allocator that does not support free() nor realloc().\n // All allocations are forever.\n //===----------------------------------------------------------------------===//\n+\n #ifndef SANITIZER_PERSISTENT_ALLOCATOR_H\n #define SANITIZER_PERSISTENT_ALLOCATOR_H\n \n@@ -34,7 +35,7 @@ inline void *PersistentAllocator::tryAlloc(uptr size) {\n   for (;;) {\n     uptr cmp = atomic_load(&region_pos, memory_order_acquire);\n     uptr end = atomic_load(&region_end, memory_order_acquire);\n-    if (cmp == 0 || cmp + size > end) return 0;\n+    if (cmp == 0 || cmp + size > end) return nullptr;\n     if (atomic_compare_exchange_weak(&region_pos, &cmp, cmp + size,\n                                      memory_order_acquire))\n       return (void *)cmp;\n@@ -66,4 +67,4 @@ inline void *PersistentAlloc(uptr sz) {\n \n } // namespace __sanitizer\n \n-#endif  // SANITIZER_PERSISTENT_ALLOCATOR_H\n+#endif // SANITIZER_PERSISTENT_ALLOCATOR_H"}, {"sha": "6a4eab333cd4b1dfad25e811cad591f649b27af9", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -36,9 +36,15 @@\n # else\n #  define SANITIZER_IOS    0\n # endif\n+# if TARGET_IPHONE_SIMULATOR\n+#  define SANITIZER_IOSSIM 1\n+# else\n+#  define SANITIZER_IOSSIM 0\n+# endif\n #else\n # define SANITIZER_MAC     0\n # define SANITIZER_IOS     0\n+# define SANITIZER_IOSSIM  0\n #endif\n \n #if defined(_WIN32)\n@@ -73,13 +79,23 @@\n # define SANITIZER_X32 0\n #endif\n \n+// VMA size definition for architecture that support multiple sizes.\n+// AArch64 has 3 VMA sizes: 39, 42 and 48.\n+#if !defined(SANITIZER_AARCH64_VMA)\n+# define SANITIZER_AARCH64_VMA 39\n+#else\n+# if SANITIZER_AARCH64_VMA != 39 && SANITIZER_AARCH64_VMA != 42\n+#  error \"invalid SANITIZER_AARCH64_VMA size\"\n+# endif\n+#endif\n+\n // By default we allow to use SizeClassAllocator64 on 64-bit platform.\n // But in some cases (e.g. AArch64's 39-bit address space) SizeClassAllocator64\n // does not work well and we need to fallback to SizeClassAllocator32.\n // For such platforms build this code with -DSANITIZER_CAN_USE_ALLOCATOR64=0 or\n // change the definition of SANITIZER_CAN_USE_ALLOCATOR64 here.\n #ifndef SANITIZER_CAN_USE_ALLOCATOR64\n-# if defined(__aarch64__) || defined(__mips64)\n+# if defined(__mips64) || (defined(__aarch64__) && SANITIZER_AARCH64_VMA == 39)\n #  define SANITIZER_CAN_USE_ALLOCATOR64 0\n # else\n #  define SANITIZER_CAN_USE_ALLOCATOR64 (SANITIZER_WORDSIZE == 64)\n@@ -91,7 +107,13 @@\n // e.g. on AArch64 it is most likely (1ULL << 39). Larger values will still work\n // but will consume more memory for TwoLevelByteMap.\n #if defined(__aarch64__)\n-# define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 39)\n+# if SANITIZER_AARCH64_VMA == 39\n+#  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 39)\n+# elif SANITIZER_AARCH64_VMA == 42\n+#  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 42)\n+# endif\n+#elif defined(__mips__)\n+# define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 40)\n #else\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)\n #endif\n@@ -120,8 +142,10 @@\n #define SANITIZER_USES_UID16_SYSCALLS 0\n #endif\n \n-#ifdef __mips__\n+#if defined(__mips__) || (defined(__aarch64__) && SANITIZER_AARCH64_VMA == 39)\n # define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 10)\n+#elif defined(__aarch64__) && SANITIZER_AARCH64_VMA == 42\n+# define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 11)\n #else\n # define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 12)\n #endif\n@@ -132,4 +156,15 @@\n # define HAVE_TIRPC_RPC_XDR_H 0\n #endif\n \n+/// \\macro MSC_PREREQ\n+/// \\brief Is the compiler MSVC of at least the specified version?\n+/// The common \\param version values to check for are:\n+///  * 1800: Microsoft Visual Studio 2013 / 12.0\n+///  * 1900: Microsoft Visual Studio 2015 / 14.0\n+#ifdef _MSC_VER\n+# define MSC_PREREQ(version) (_MSC_VER >= (version))\n+#else\n+# define MSC_PREREQ(version) 0\n+#endif\n+\n #endif // SANITIZER_PLATFORM_H"}, {"sha": "c8adc5fcaed5d9b53f75802a9809e37daafc89f4", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -52,10 +52,15 @@\n #endif\n \n #define SANITIZER_INTERCEPT_STRCMP 1\n+#define SANITIZER_INTERCEPT_STRSTR 1\n+#define SANITIZER_INTERCEPT_STRCASESTR SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRSPN 1\n+#define SANITIZER_INTERCEPT_STRPBRK 1\n #define SANITIZER_INTERCEPT_TEXTDOMAIN SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STRCASECMP SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MEMCMP 1\n #define SANITIZER_INTERCEPT_MEMCHR 1\n-#define SANITIZER_INTERCEPT_MEMRCHR SI_LINUX\n+#define SANITIZER_INTERCEPT_MEMRCHR SI_FREEBSD || SI_LINUX\n \n #define SANITIZER_INTERCEPT_READ   SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_PREAD  SI_NOT_WINDOWS\n@@ -68,7 +73,7 @@\n #define SANITIZER_INTERCEPT_READV SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_WRITEV SI_NOT_WINDOWS\n \n-#define SANITIZER_INTERCEPT_PREADV SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PREADV SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PWRITEV SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PREADV64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PWRITEV64 SI_LINUX_NOT_ANDROID\n@@ -83,6 +88,7 @@\n \n #ifndef SANITIZER_INTERCEPT_PRINTF\n # define SANITIZER_INTERCEPT_PRINTF SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PRINTF_L SI_FREEBSD\n # define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_LINUX_NOT_ANDROID\n #endif\n \n@@ -91,12 +97,13 @@\n \n #define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS \\\n-  SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETPWENT SI_MAC || SI_LINUX_NOT_ANDROID\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETPWENT \\\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETPWENT_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETPWENT_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SETPWENT SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_CLOCK_GETTIME SI_LINUX\n+#define SANITIZER_INTERCEPT_CLOCK_GETTIME SI_FREEBSD || SI_LINUX\n #define SANITIZER_INTERCEPT_GETITIMER SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_TIME SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID\n@@ -107,10 +114,10 @@\n #define SANITIZER_INTERCEPT_GETNAMEINFO SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETSOCKNAME SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETHOSTBYNAME_R SI_LINUX\n-#define SANITIZER_INTERCEPT_GETHOSTBYNAME2_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETHOSTBYADDR_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETHOSTENT_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME_R SI_FREEBSD || SI_LINUX\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME2_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETHOSTBYADDR_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETHOSTENT_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_GETSOCKOPT SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_ACCEPT SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX_NOT_ANDROID\n@@ -123,54 +130,63 @@\n #define SANITIZER_INTERCEPT_READDIR SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTRACE SI_LINUX_NOT_ANDROID && \\\n-   (defined(__i386) || defined (__x86_64))  // NOLINT\n+  (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n+    defined(__powerpc64__) || defined(__aarch64__))\n #define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STRTOIMAX SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_MBSTOWCS SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_MBSNRTOWCS SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WCSTOMBS SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_WCSNRTOMBS SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_WCSNRTOMBS \\\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_WCRTOMB \\\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_REALPATH SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_CONFSTR SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_CONFSTR \\\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SCHED_GETPARAM SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STRERROR SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_STRERROR_R SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_XPG_STRERROR_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SCANDIR SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SCANDIR \\\n+  SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_GETGROUPS SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_POLL SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_PPOLL SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_WORDEXP (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_WORDEXP \\\n+  SI_FREEBSD || (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGWAIT SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGSETOPS \\\n   SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGPENDING SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_SIGPROCMASK SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_BACKTRACE SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_BACKTRACE SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n #define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STATFS SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STATFS SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATFS64 \\\n   (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STATVFS SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STATVFS SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_INITGROUPS SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_ETHER_NTOA_ATON SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_ETHER_HOST SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_ETHER_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_ETHER_HOST \\\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_ETHER_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SHMCTL \\\n-  (SI_LINUX_NOT_ANDROID && SANITIZER_WORDSIZE == 64)\n+  ((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && SANITIZER_WORDSIZE == 64)\n #define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n-  SI_MAC || SI_LINUX_NOT_ANDROID\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE SI_NOT_WINDOWS\n@@ -191,33 +207,37 @@\n #define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n #define SANITIZER_INTERCEPT_REMQUO SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_LGAMMA SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_LGAMMA_R SI_LINUX\n+#define SANITIZER_INTERCEPT_LGAMMA_R SI_FREEBSD || SI_LINUX\n #define SANITIZER_INTERCEPT_LGAMMAL_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_RAND_R SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_ICONV SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_RAND_R \\\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_ICONV SI_FREEBSD || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_TIMES SI_NOT_WINDOWS\n \n // FIXME: getline seems to be available on OSX 10.7\n-#define SANITIZER_INTERCEPT_GETLINE SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETLINE SI_FREEBSD || SI_LINUX_NOT_ANDROID\n \n #define SANITIZER_INTERCEPT__EXIT SI_LINUX || SI_FREEBSD\n \n #define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP \\\n   SI_FREEBSD || SI_LINUX_NOT_ANDROID\n \n-#define SANITIZER_INTERCEPT_TLS_GET_ADDR SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TLS_GET_ADDR \\\n+  SI_FREEBSD || SI_LINUX_NOT_ANDROID\n \n #define SANITIZER_INTERCEPT_LISTXATTR SI_LINUX\n #define SANITIZER_INTERCEPT_GETXATTR SI_LINUX\n #define SANITIZER_INTERCEPT_GETRESID SI_LINUX\n-#define SANITIZER_INTERCEPT_GETIFADDRS SI_LINUX_NOT_ANDROID || SI_MAC\n-#define SANITIZER_INTERCEPT_IF_INDEXTONAME SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_GETIFADDRS \\\n+  SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_IF_INDEXTONAME \\\n+  SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n #define SANITIZER_INTERCEPT_CAPGET SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_AEABI_MEM SI_LINUX && defined(__arm__)\n #define SANITIZER_INTERCEPT___BZERO SI_MAC\n-#define SANITIZER_INTERCEPT_FTIME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FTIME !SI_FREEBSD && SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_TSEARCH SI_LINUX_NOT_ANDROID || SI_MAC\n #define SANITIZER_INTERCEPT_LIBIO_INTERNALS SI_LINUX_NOT_ANDROID\n@@ -233,5 +253,11 @@\n #define SANITIZER_INTERCEPT_TIMERFD SI_LINUX_NOT_ANDROID\n \n #define SANITIZER_INTERCEPT_MLOCKX SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FOPENCOOKIE SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SEM SI_LINUX || SI_FREEBSD\n+#define SANITIZER_INTERCEPT_PTHREAD_SETCANCEL SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MINCORE SI_LINUX\n+\n+#define SANITIZER_INTERCEPTOR_HOOKS SI_LINUX\n \n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "8779d8adf7274ac09d530f3577a203468f12d1b4", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -36,7 +36,6 @@\n #define uid_t __kernel_uid_t\n #define gid_t __kernel_gid_t\n #define off_t __kernel_off_t\n-#define time_t __kernel_time_t\n // This header seems to contain the definitions of _kernel_ stat* structs.\n #include <asm/stat.h>\n #undef ino_t\n@@ -61,7 +60,7 @@ namespace __sanitizer {\n }  // namespace __sanitizer\n \n #if !defined(__powerpc64__) && !defined(__x86_64__) && !defined(__aarch64__)\\\n-                            && !defined(__mips__) && !defined(__sparc__)\n+                            && !defined(__mips__)\n COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));\n #endif\n "}, {"sha": "05f8c06a49855e1e04426ecac6f687ecb72e6aa6", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 81, "deletions": 31, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -10,8 +10,8 @@\n // Sizes and layouts of platform-specific POSIX data structures.\n //===----------------------------------------------------------------------===//\n \n-\n #include \"sanitizer_platform.h\"\n+\n #if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC\n // Tests in this file assume that off_t-dependent data structures match the\n // libc ABI. For example, struct dirent here is what readdir() function (as\n@@ -32,8 +32,6 @@\n #include <grp.h>\n #include <limits.h>\n #include <net/if.h>\n-#include <net/if_arp.h>\n-#include <net/route.h>\n #include <netdb.h>\n #include <poll.h>\n #include <pthread.h>\n@@ -52,6 +50,10 @@\n #include <time.h>\n #include <wchar.h>\n \n+#if !SANITIZER_IOS\n+#include <net/route.h>\n+#endif\n+\n #if !SANITIZER_ANDROID\n #include <sys/mount.h>\n #include <sys/timeb.h>\n@@ -73,6 +75,7 @@\n #include <linux/sysctl.h>\n #include <linux/utsname.h>\n #include <linux/posix_types.h>\n+#include <net/if_arp.h>\n #endif\n \n #if SANITIZER_FREEBSD\n@@ -95,7 +98,6 @@\n # include <sys/link_elf.h>\n # include <netinet/ip_mroute.h>\n # include <netinet/in.h>\n-# include <netinet/ip_compat.h>\n # include <net/ethernet.h>\n # include <net/ppp_defs.h>\n # include <glob.h>\n@@ -115,6 +117,10 @@\n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n # include <utime.h>\n # include <sys/ptrace.h>\n+# if defined(__mips64) || defined(__aarch64__)\n+#  include <asm/ptrace.h>\n+# endif\n+# include <semaphore.h>\n #endif\n \n #if !SANITIZER_ANDROID\n@@ -142,6 +148,9 @@\n #include <sys/shm.h>\n #include <sys/statvfs.h>\n #include <sys/timex.h>\n+#if defined(__mips64)\n+# include <sys/procfs.h>\n+#endif\n #include <sys/user.h>\n #include <sys/ustat.h>\n #include <linux/cyclades.h>\n@@ -185,7 +194,7 @@ namespace __sanitizer {\n   unsigned struct_stat_sz = sizeof(struct stat);\n #if !SANITIZER_IOS && !SANITIZER_FREEBSD\n   unsigned struct_stat64_sz = sizeof(struct stat64);\n-#endif  // !SANITIZER_IOS && !SANITIZER_FREEBSD\n+#endif // !SANITIZER_IOS && !SANITIZER_FREEBSD\n   unsigned struct_rusage_sz = sizeof(struct rusage);\n   unsigned struct_tm_sz = sizeof(struct tm);\n   unsigned struct_passwd_sz = sizeof(struct passwd);\n@@ -226,27 +235,27 @@ namespace __sanitizer {\n   unsigned struct_new_utsname_sz = sizeof(struct new_utsname);\n   unsigned struct_old_utsname_sz = sizeof(struct old_utsname);\n   unsigned struct_oldold_utsname_sz = sizeof(struct oldold_utsname);\n-#endif  // SANITIZER_LINUX\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n   unsigned struct_rlimit_sz = sizeof(struct rlimit);\n   unsigned struct_timespec_sz = sizeof(struct timespec);\n   unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n   unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_ustat_sz = sizeof(struct ustat);\n   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);\n   unsigned struct_statvfs64_sz = sizeof(struct statvfs64);\n-#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n #if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   unsigned struct_timex_sz = sizeof(struct timex);\n   unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n   unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n   unsigned struct_statvfs_sz = sizeof(struct statvfs);\n-#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#endif // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n   uptr sig_ign = (uptr)SIG_IGN;\n   uptr sig_dfl = (uptr)SIG_DFL;\n@@ -280,30 +289,61 @@ namespace __sanitizer {\n       return 0;\n   }\n \n+#if SANITIZER_LINUX\n+unsigned struct_ElfW_Phdr_sz = sizeof(ElfW(Phdr));\n+#elif SANITIZER_FREEBSD\n+unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n+#endif\n+\n #if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   int glob_nomatch = GLOB_NOMATCH;\n   int glob_altdirfunc = GLOB_ALTDIRFUNC;\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n-    (defined(__i386) || defined(__x86_64))\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n+      defined(__powerpc64__) || defined(__aarch64__))\n+#if defined(__mips64) || defined(__powerpc64__)\n+  unsigned struct_user_regs_struct_sz = sizeof(struct pt_regs);\n+  unsigned struct_user_fpregs_struct_sz = sizeof(elf_fpregset_t);\n+#elif defined(__aarch64__)\n+  unsigned struct_user_regs_struct_sz = sizeof(struct user_pt_regs);\n+  unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpsimd_state);\n+#else\n   unsigned struct_user_regs_struct_sz = sizeof(struct user_regs_struct);\n   unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpregs_struct);\n-#ifdef __x86_64\n+#endif // __mips64 || __powerpc64__ || __aarch64__\n+#if defined(__x86_64) || defined(__mips64) || defined(__powerpc64__) || \\\n+    defined(__aarch64__)\n   unsigned struct_user_fpxregs_struct_sz = 0;\n #else\n   unsigned struct_user_fpxregs_struct_sz = sizeof(struct user_fpxregs_struct);\n-#endif\n+#endif // __x86_64 || __mips64 || __powerpc64__ || __aarch64__\n \n   int ptrace_peektext = PTRACE_PEEKTEXT;\n   int ptrace_peekdata = PTRACE_PEEKDATA;\n   int ptrace_peekuser = PTRACE_PEEKUSER;\n+#if defined(PT_GETREGS) && defined(PT_SETREGS)\n   int ptrace_getregs = PTRACE_GETREGS;\n   int ptrace_setregs = PTRACE_SETREGS;\n+#else\n+  int ptrace_getregs = -1;\n+  int ptrace_setregs = -1;\n+#endif\n+#if defined(PT_GETFPREGS) && defined(PT_SETFPREGS)\n   int ptrace_getfpregs = PTRACE_GETFPREGS;\n   int ptrace_setfpregs = PTRACE_SETFPREGS;\n+#else\n+  int ptrace_getfpregs = -1;\n+  int ptrace_setfpregs = -1;\n+#endif\n+#if defined(PT_GETFPXREGS) && defined(PT_SETFPXREGS)\n   int ptrace_getfpxregs = PTRACE_GETFPXREGS;\n   int ptrace_setfpxregs = PTRACE_SETFPXREGS;\n+#else\n+  int ptrace_getfpxregs = -1;\n+  int ptrace_setfpxregs = -1;\n+#endif // PTRACE_GETFPXREGS/PTRACE_SETFPXREGS\n   int ptrace_geteventmsg = PTRACE_GETEVENTMSG;\n #if (defined(PTRACE_GETSIGINFO) && defined(PTRACE_SETSIGINFO)) ||              \\\n     (defined(PT_GETSIGINFO) && defined(PT_SETSIGINFO))\n@@ -312,25 +352,25 @@ namespace __sanitizer {\n #else\n   int ptrace_getsiginfo = -1;\n   int ptrace_setsiginfo = -1;\n-#endif  // PTRACE_GETSIGINFO/PTRACE_SETSIGINFO\n+#endif // PTRACE_GETSIGINFO/PTRACE_SETSIGINFO\n #if defined(PTRACE_GETREGSET) && defined(PTRACE_SETREGSET)\n   int ptrace_getregset = PTRACE_GETREGSET;\n   int ptrace_setregset = PTRACE_SETREGSET;\n #else\n   int ptrace_getregset = -1;\n   int ptrace_setregset = -1;\n-#endif  // PTRACE_GETREGSET/PTRACE_SETREGSET\n+#endif // PTRACE_GETREGSET/PTRACE_SETREGSET\n #endif\n \n   unsigned path_max = PATH_MAX;\n \n   // ioctl arguments\n-  unsigned struct_arpreq_sz = sizeof(struct arpreq);\n   unsigned struct_ifreq_sz = sizeof(struct ifreq);\n   unsigned struct_termios_sz = sizeof(struct termios);\n   unsigned struct_winsize_sz = sizeof(struct winsize);\n \n #if SANITIZER_LINUX\n+  unsigned struct_arpreq_sz = sizeof(struct arpreq);\n   unsigned struct_cdrom_msf_sz = sizeof(struct cdrom_msf);\n   unsigned struct_cdrom_multisession_sz = sizeof(struct cdrom_multisession);\n   unsigned struct_cdrom_read_audio_sz = sizeof(struct cdrom_read_audio);\n@@ -357,7 +397,7 @@ namespace __sanitizer {\n   unsigned struct_vt_consize_sz = sizeof(struct vt_consize);\n   unsigned struct_vt_sizes_sz = sizeof(struct vt_sizes);\n   unsigned struct_vt_stat_sz = sizeof(struct vt_stat);\n-#endif  // SANITIZER_LINUX\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n #if SOUND_VERSION >= 0x040000\n@@ -377,7 +417,7 @@ namespace __sanitizer {\n   unsigned struct_seq_event_rec_sz = sizeof(struct seq_event_rec);\n   unsigned struct_synth_info_sz = sizeof(struct synth_info);\n   unsigned struct_vt_mode_sz = sizeof(struct vt_mode);\n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_ax25_parms_struct_sz = sizeof(struct ax25_parms_struct);\n@@ -402,12 +442,12 @@ namespace __sanitizer {\n   unsigned struct_sockaddr_ax25_sz = sizeof(struct sockaddr_ax25);\n   unsigned struct_unimapdesc_sz = sizeof(struct unimapdesc);\n   unsigned struct_unimapinit_sz = sizeof(struct unimapinit);\n-#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n #if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n   unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n-#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#endif // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n #if !SANITIZER_ANDROID && !SANITIZER_MAC\n   unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n@@ -622,7 +662,7 @@ namespace __sanitizer {\n   unsigned IOCTL_SOUND_PCM_READ_RATE = SOUND_PCM_READ_RATE;\n   unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS = SOUND_PCM_WRITE_CHANNELS;\n   unsigned IOCTL_SOUND_PCM_WRITE_FILTER = SOUND_PCM_WRITE_FILTER;\n-#endif  // SOUND_VERSION\n+#endif // SOUND_VERSION\n   unsigned IOCTL_TCFLSH = TCFLSH;\n   unsigned IOCTL_TCGETA = TCGETA;\n   unsigned IOCTL_TCGETS = TCGETS;\n@@ -745,7 +785,7 @@ namespace __sanitizer {\n   unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n   unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n   unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned IOCTL_CYGETDEFTHRESH = CYGETDEFTHRESH;\n@@ -836,7 +876,7 @@ namespace __sanitizer {\n   unsigned IOCTL_TIOCSERGETMULTI = TIOCSERGETMULTI;\n   unsigned IOCTL_TIOCSERSETMULTI = TIOCSERSETMULTI;\n   unsigned IOCTL_TIOCSSERIAL = TIOCSSERIAL;\n-#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n #if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n@@ -854,7 +894,7 @@ namespace __sanitizer {\n   unsigned IOCTL_PIO_SCRNMAP = PIO_SCRNMAP;\n   unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n   unsigned IOCTL_SNDCTL_DSP_GETOSPACE = SNDCTL_DSP_GETOSPACE;\n-#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#endif // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n   const int errno_EINVAL = EINVAL;\n // EOWNERDEAD is not present in some older platforms.\n@@ -866,7 +906,7 @@ namespace __sanitizer {\n \n   const int si_SEGV_MAPERR = SEGV_MAPERR;\n   const int si_SEGV_ACCERR = SEGV_ACCERR;\n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n \n@@ -896,7 +936,7 @@ COMPILER_CHECK(IOC_SIZE(0x12345678) == _IOC_SIZE(0x12345678));\n COMPILER_CHECK(IOC_DIR(0x12345678) == _IOC_DIR(0x12345678));\n COMPILER_CHECK(IOC_NR(0x12345678) == _IOC_NR(0x12345678));\n COMPILER_CHECK(IOC_TYPE(0x12345678) == _IOC_TYPE(0x12345678));\n-#endif  // SANITIZER_LINUX\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n // There are more undocumented fields in dl_phdr_info that we are not interested\n@@ -906,7 +946,7 @@ CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_addr);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_name);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n CHECK_TYPE_SIZE(glob_t);\n@@ -1103,14 +1143,14 @@ CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_netmask);\n # if SANITIZER_FREEBSD\n CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n # else\n-COMPILER_CHECK(sizeof(((__sanitizer_ifaddrs *)NULL)->ifa_dstaddr) ==\n-               sizeof(((ifaddrs *)NULL)->ifa_ifu));\n+COMPILER_CHECK(sizeof(((__sanitizer_ifaddrs *)nullptr)->ifa_dstaddr) ==\n+               sizeof(((ifaddrs *)nullptr)->ifa_ifu));\n COMPILER_CHECK(offsetof(__sanitizer_ifaddrs, ifa_dstaddr) ==\n                offsetof(ifaddrs, ifa_ifu));\n-# endif  // SANITIZER_FREEBSD\n+# endif // SANITIZER_FREEBSD\n #else\n CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n-#endif  // SANITIZER_LINUX\n+#endif // SANITIZER_LINUX\n CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_data);\n #endif\n \n@@ -1192,6 +1232,16 @@ CHECK_SIZE_AND_OFFSET(obstack, chunk_size);\n CHECK_SIZE_AND_OFFSET(obstack, chunk);\n CHECK_SIZE_AND_OFFSET(obstack, object_base);\n CHECK_SIZE_AND_OFFSET(obstack, next_free);\n+\n+CHECK_TYPE_SIZE(cookie_io_functions_t);\n+CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, read);\n+CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, write);\n+CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, seek);\n+CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, close);\n+#endif\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+CHECK_TYPE_SIZE(sem_t);\n #endif\n \n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC"}, {"sha": "53118b5bde55799f81aeb98da15b65c6f878251e", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 70, "deletions": 61, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -16,6 +16,15 @@\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n+#if SANITIZER_FREEBSD\n+// FreeBSD's dlopen() returns a pointer to an Obj_Entry structure that\n+// incroporates the map structure.\n+# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n+    ((link_map*)((handle) == nullptr ? nullptr : ((char*)(handle) + 544)))\n+#else\n+# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) ((link_map*)(handle))\n+#endif  // !SANITIZER_FREEBSD\n+\n namespace __sanitizer {\n   extern unsigned struct_utsname_sz;\n   extern unsigned struct_stat_sz;\n@@ -72,14 +81,6 @@ namespace __sanitizer {\n   const unsigned struct_kernel_stat_sz = 144;\n   #endif\n   const unsigned struct_kernel_stat64_sz = 104;\n-#elif defined(__sparc__) && defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n-  const unsigned struct_kernel_stat_sz = 104;\n-  const unsigned struct_kernel_stat64_sz = 144;\n-#elif defined(__sparc__) && !defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n-  const unsigned struct_kernel_stat_sz = 64;\n-  const unsigned struct_kernel_stat64_sz = 104;\n #endif\n   struct __sanitizer_perf_event_attr {\n     unsigned type;\n@@ -102,7 +103,7 @@ namespace __sanitizer {\n \n #if defined(__powerpc64__)\n   const unsigned struct___old_kernel_stat_sz = 0;\n-#elif !defined(__sparc__)\n+#else\n   const unsigned struct___old_kernel_stat_sz = 32;\n #endif\n \n@@ -147,6 +148,18 @@ namespace __sanitizer {\n   };\n \n   const unsigned old_sigset_t_sz = sizeof(unsigned long);\n+\n+  struct __sanitizer_sem_t {\n+#if SANITIZER_ANDROID && defined(_LP64)\n+    int data[4];\n+#elif SANITIZER_ANDROID && !defined(_LP64)\n+    int data;\n+#elif SANITIZER_LINUX\n+    uptr data[4];\n+#elif SANITIZER_FREEBSD\n+    u32 data[4];\n+#endif\n+  };\n #endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if SANITIZER_ANDROID\n@@ -181,18 +194,6 @@ namespace __sanitizer {\n     unsigned short __pad1;\n     unsigned long __unused1;\n     unsigned long __unused2;\n-#elif defined(__sparc__)\n-# if defined(__arch64__)\n-    unsigned mode;\n-    unsigned short __pad1;\n-# else\n-    unsigned short __pad1;\n-    unsigned short mode;\n-    unsigned short __pad2;\n-# endif\n-    unsigned short __seq;\n-    unsigned long long __unused1;\n-    unsigned long long __unused2;\n #else\n     unsigned short mode;\n     unsigned short __pad1;\n@@ -210,26 +211,6 @@ namespace __sanitizer {\n \n   struct __sanitizer_shmid_ds {\n     __sanitizer_ipc_perm shm_perm;\n-  #if defined(__sparc__)\n-  # if !defined(__arch64__)\n-    u32 __pad1;\n-  # endif\n-    long shm_atime;\n-  # if !defined(__arch64__)\n-    u32 __pad2;\n-  # endif\n-    long shm_dtime;\n-  # if !defined(__arch64__)\n-    u32 __pad3;\n-  # endif\n-    long shm_ctime;\n-    uptr shm_segsz;\n-    int shm_cpid;\n-    int shm_lpid;\n-    unsigned long shm_nattch;\n-    unsigned long __glibc_reserved1;\n-    unsigned long __glibc_reserved2;\n-  #else    \n   #ifndef __powerpc__\n     uptr shm_segsz;\n   #elif !defined(__powerpc64__)\n@@ -267,7 +248,6 @@ namespace __sanitizer {\n     uptr __unused4;\n     uptr __unused5;\n   #endif\n-#endif\n   };\n #elif SANITIZER_FREEBSD\n   struct __sanitizer_ipc_perm {\n@@ -351,7 +331,7 @@ namespace __sanitizer {\n     long pw_change;\n     char *pw_class;\n #endif\n-#if !SANITIZER_ANDROID\n+#if !(SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 32))\n     char *pw_gecos;\n #endif\n     char *pw_dir;\n@@ -413,7 +393,7 @@ namespace __sanitizer {\n   };\n #endif\n \n-#if SANITIZER_ANDROID || SANITIZER_MAC || SANITIZER_FREEBSD\n+#if SANITIZER_MAC || SANITIZER_FREEBSD\n   struct __sanitizer_msghdr {\n     void *msg_name;\n     unsigned msg_namelen;\n@@ -550,6 +530,27 @@ namespace __sanitizer {\n #endif\n \n   // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n+#if SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 64)\n+  struct __sanitizer_sigaction {\n+    unsigned sa_flags;\n+    union {\n+      void (*sigaction)(int sig, void *siginfo, void *uctx);\n+      void (*handler)(int sig);\n+    };\n+    __sanitizer_sigset_t sa_mask;\n+    void (*sa_restorer)();\n+  };\n+#elif SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 32)\n+  struct __sanitizer_sigaction {\n+    union {\n+      void (*sigaction)(int sig, void *siginfo, void *uctx);\n+      void (*handler)(int sig);\n+    };\n+    __sanitizer_sigset_t sa_mask;\n+    uptr sa_flags;\n+    void (*sa_restorer)();\n+  };\n+#else // !SANITIZER_ANDROID\n   struct __sanitizer_sigaction {\n #if defined(__mips__) && !SANITIZER_FREEBSD\n     unsigned int sa_flags;\n@@ -564,23 +565,24 @@ namespace __sanitizer {\n #else\n     __sanitizer_sigset_t sa_mask;\n #ifndef __mips__\n-#if defined(__sparc__)\n-    unsigned long sa_flags;\n-#else\n     int sa_flags;\n #endif\n #endif\n-#endif\n #if SANITIZER_LINUX\n     void (*sa_restorer)();\n #endif\n #if defined(__mips__) && (SANITIZER_WORDSIZE == 32)\n     int sa_resv[1];\n #endif\n   };\n+#endif // !SANITIZER_ANDROID\n \n #if SANITIZER_FREEBSD\n   typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n+#elif defined(__mips__)\n+  struct __sanitizer_kernel_sigset_t {\n+    u8 sig[16];\n+  };\n #else\n   struct __sanitizer_kernel_sigset_t {\n     u8 sig[8];\n@@ -617,6 +619,8 @@ namespace __sanitizer {\n     const void *dlpi_phdr;\n     short dlpi_phnum;\n   };\n+\n+  extern unsigned struct_ElfW_Phdr_sz;\n #endif\n \n   struct __sanitizer_addrinfo {\n@@ -729,7 +733,8 @@ namespace __sanitizer {\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n-    (defined(__i386) || defined(__x86_64))\n+  (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n+    defined(__powerpc64__) || defined(__aarch64__))\n   extern unsigned struct_user_regs_struct_sz;\n   extern unsigned struct_user_fpregs_struct_sz;\n   extern unsigned struct_user_fpxregs_struct_sz;\n@@ -786,11 +791,25 @@ struct __sanitizer_obstack {\n   char *next_free;\n   uptr more_fields[7];\n };\n+\n+typedef uptr (*__sanitizer_cookie_io_read)(void *cookie, char *buf, uptr size);\n+typedef uptr (*__sanitizer_cookie_io_write)(void *cookie, const char *buf,\n+                                            uptr size);\n+typedef int (*__sanitizer_cookie_io_seek)(void *cookie, u64 *offset,\n+                                          int whence);\n+typedef int (*__sanitizer_cookie_io_close)(void *cookie);\n+\n+struct __sanitizer_cookie_io_functions_t {\n+  __sanitizer_cookie_io_read read;\n+  __sanitizer_cookie_io_write write;\n+  __sanitizer_cookie_io_seek seek;\n+  __sanitizer_cookie_io_close close;\n+};\n #endif\n \n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n-#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__) || defined(__sparc__)\n+#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__)\n #define IOC_SIZEBITS 13\n #define IOC_DIRBITS 3\n #define IOC_NONE 1U\n@@ -820,24 +839,14 @@ struct __sanitizer_obstack {\n #define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n #define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n #define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n-\n-#if defined(__sparc__)\n-// In sparc the 14 bits SIZE field overlaps with the\n-// least significant bit of DIR, so either IOC_READ or\n-// IOC_WRITE shall be 1 in order to get a non-zero SIZE.\n-# define IOC_SIZE(nr)                       \\\n-  ((((((nr) >> 29) & 0x7) & (4U|2U)) == 0)? \\\n-   0 : (((nr) >> 16) & 0x3fff))\n-#else\n #define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n-#endif\n \n-  extern unsigned struct_arpreq_sz;\n   extern unsigned struct_ifreq_sz;\n   extern unsigned struct_termios_sz;\n   extern unsigned struct_winsize_sz;\n \n #if SANITIZER_LINUX\n+  extern unsigned struct_arpreq_sz;\n   extern unsigned struct_cdrom_msf_sz;\n   extern unsigned struct_cdrom_multisession_sz;\n   extern unsigned struct_cdrom_read_audio_sz;"}, {"sha": "1438827e1007a72369e6c5e75c57f45ac814addc", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 125, "deletions": 120, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -7,17 +7,21 @@\n //\n // This file is shared between AddressSanitizer and ThreadSanitizer\n // run-time libraries and implements POSIX-specific functions from\n-// sanitizer_libc.h.\n+// sanitizer_posix.h.\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n+\n #if SANITIZER_POSIX\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_posix.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n \n+#include <fcntl.h>\n+#include <signal.h>\n #include <sys/mman.h>\n \n #if SANITIZER_LINUX\n@@ -28,6 +32,13 @@\n #include <sys/personality.h>\n #endif\n \n+#if SANITIZER_FREEBSD\n+// The MAP_NORESERVE define has been removed in FreeBSD 11.x, and even before\n+// that, it was never implemented.  So just define it to zero.\n+#undef  MAP_NORESERVE\n+#define MAP_NORESERVE 0\n+#endif\n+\n namespace __sanitizer {\n \n // ------------- sanitizer_common.h\n@@ -38,15 +49,15 @@ uptr GetMmapGranularity() {\n #if SANITIZER_WORDSIZE == 32\n // Take care of unusable kernel area in top gigabyte.\n static uptr GetKernelAreaSize() {\n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX && !SANITIZER_X32\n   const uptr gbyte = 1UL << 30;\n \n   // Firstly check if there are writable segments\n   // mapped to top gigabyte (e.g. stack).\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n   uptr end, prot;\n-  while (proc_maps.Next(/*start*/0, &end,\n-                        /*offset*/0, /*filename*/0,\n+  while (proc_maps.Next(/*start*/nullptr, &end,\n+                        /*offset*/nullptr, /*filename*/nullptr,\n                         /*filename_size*/0, &prot)) {\n     if ((end >= 3 * gbyte)\n         && (prot & MemoryMappingLayout::kProtectionWrite) != 0)\n@@ -70,7 +81,7 @@ static uptr GetKernelAreaSize() {\n   return gbyte;\n #else\n   return 0;\n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_LINUX && !SANITIZER_X32\n }\n #endif  // SANITIZER_WORDSIZE == 32\n \n@@ -86,7 +97,7 @@ uptr GetMaxVirtualAddress() {\n   // Similarly, aarch64 has multiple address space layouts: 39, 42 and 47-bit.\n   return (1ULL << (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1)) - 1;\n # elif defined(__mips64)\n-  return (1ULL << 40) - 1;\n+  return (1ULL << 40) - 1;  // 0x000000ffffffffffUL;\n # else\n   return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n # endif\n@@ -101,25 +112,12 @@ uptr GetMaxVirtualAddress() {\n \n void *MmapOrDie(uptr size, const char *mem_type) {\n   size = RoundUpTo(size, GetPageSizeCached());\n-  uptr res = internal_mmap(0, size,\n-                            PROT_READ | PROT_WRITE,\n-                            MAP_PRIVATE | MAP_ANON, -1, 0);\n+  uptr res = internal_mmap(nullptr, size,\n+                           PROT_READ | PROT_WRITE,\n+                           MAP_PRIVATE | MAP_ANON, -1, 0);\n   int reserrno;\n-  if (internal_iserror(res, &reserrno)) {\n-    static int recursion_count;\n-    if (recursion_count) {\n-      // The Report() and CHECK calls below may call mmap recursively and fail.\n-      // If we went into recursion, just die.\n-      RawWrite(\"ERROR: Failed to mmap\\n\");\n-      Die();\n-    }\n-    recursion_count++;\n-    Report(\"ERROR: %s failed to \"\n-           \"allocate 0x%zx (%zd) bytes of %s (errno: %d)\\n\",\n-           SanitizerToolName, size, size, mem_type, reserrno);\n-    DumpProcessMap();\n-    CHECK(\"unable to mmap\" && 0);\n-  }\n+  if (internal_iserror(res, &reserrno))\n+    ReportMmapFailureAndDie(size, mem_type, reserrno);\n   IncreaseTotalMmap(size);\n   return (void *)res;\n }\n@@ -137,11 +135,11 @@ void UnmapOrDie(void *addr, uptr size) {\n \n void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n   uptr PageSize = GetPageSizeCached();\n-  uptr p = internal_mmap(0,\n-      RoundUpTo(size, PageSize),\n-      PROT_READ | PROT_WRITE,\n-      MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,\n-      -1, 0);\n+  uptr p = internal_mmap(nullptr,\n+                         RoundUpTo(size, PageSize),\n+                         PROT_READ | PROT_WRITE,\n+                         MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,\n+                         -1, 0);\n   int reserrno;\n   if (internal_iserror(p, &reserrno)) {\n     Report(\"ERROR: %s failed to \"\n@@ -153,22 +151,6 @@ void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n   return (void *)p;\n }\n \n-void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n-  uptr PageSize = GetPageSizeCached();\n-  uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),\n-      RoundUpTo(size, PageSize),\n-      PROT_READ | PROT_WRITE,\n-      MAP_PRIVATE | MAP_ANON | MAP_FIXED | MAP_NORESERVE,\n-      -1, 0);\n-  int reserrno;\n-  if (internal_iserror(p, &reserrno))\n-    Report(\"ERROR: %s failed to \"\n-           \"allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\\n\",\n-           SanitizerToolName, size, size, fixed_addr, reserrno);\n-  IncreaseTotalMmap(size);\n-  return (void *)p;\n-}\n-\n void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n   uptr PageSize = GetPageSizeCached();\n   uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),\n@@ -187,33 +169,72 @@ void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n   return (void *)p;\n }\n \n-void *Mprotect(uptr fixed_addr, uptr size) {\n-  return (void *)internal_mmap((void*)fixed_addr, size,\n-                               PROT_NONE,\n-                               MAP_PRIVATE | MAP_ANON | MAP_FIXED |\n-                               MAP_NORESERVE, -1, 0);\n+bool MprotectNoAccess(uptr addr, uptr size) {\n+  return 0 == internal_mprotect((void*)addr, size, PROT_NONE);\n+}\n+\n+fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {\n+  int flags;\n+  switch (mode) {\n+    case RdOnly: flags = O_RDONLY; break;\n+    case WrOnly: flags = O_WRONLY | O_CREAT; break;\n+    case RdWr: flags = O_RDWR | O_CREAT; break;\n+  }\n+  fd_t res = internal_open(filename, flags, 0660);\n+  if (internal_iserror(res, errno_p))\n+    return kInvalidFd;\n+  return res;\n+}\n+\n+void CloseFile(fd_t fd) {\n+  internal_close(fd);\n+}\n+\n+bool ReadFromFile(fd_t fd, void *buff, uptr buff_size, uptr *bytes_read,\n+                  error_t *error_p) {\n+  uptr res = internal_read(fd, buff, buff_size);\n+  if (internal_iserror(res, error_p))\n+    return false;\n+  if (bytes_read)\n+    *bytes_read = res;\n+  return true;\n+}\n+\n+bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,\n+                 error_t *error_p) {\n+  uptr res = internal_write(fd, buff, buff_size);\n+  if (internal_iserror(res, error_p))\n+    return false;\n+  if (bytes_written)\n+    *bytes_written = res;\n+  return true;\n+}\n+\n+bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {\n+  uptr res = internal_rename(oldpath, newpath);\n+  return !internal_iserror(res, error_p);\n }\n \n void *MapFileToMemory(const char *file_name, uptr *buff_size) {\n-  uptr openrv = OpenFile(file_name, false);\n-  CHECK(!internal_iserror(openrv));\n-  fd_t fd = openrv;\n+  fd_t fd = OpenFile(file_name, RdOnly);\n+  CHECK(fd != kInvalidFd);\n   uptr fsize = internal_filesize(fd);\n   CHECK_NE(fsize, (uptr)-1);\n   CHECK_GT(fsize, 0);\n   *buff_size = RoundUpTo(fsize, GetPageSizeCached());\n-  uptr map = internal_mmap(0, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);\n-  return internal_iserror(map) ? 0 : (void *)map;\n+  uptr map = internal_mmap(nullptr, *buff_size, PROT_READ, MAP_PRIVATE, fd, 0);\n+  return internal_iserror(map) ? nullptr : (void *)map;\n }\n \n-void *MapWritableFileToMemory(void *addr, uptr size, uptr fd, uptr offset) {\n+void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset) {\n   uptr flags = MAP_SHARED;\n   if (addr) flags |= MAP_FIXED;\n   uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);\n-  if (internal_iserror(p)) {\n-    Printf(\"could not map writable file (%zd, %zu, %zu): %zd\\n\", fd, offset,\n-           size, p);\n-    return 0;\n+  int mmap_errno = 0;\n+  if (internal_iserror(p, &mmap_errno)) {\n+    Printf(\"could not map writable file (%d, %lld, %zu): %zd, errno: %d\\n\",\n+           fd, (long long)offset, size, p, mmap_errno);\n+    return nullptr;\n   }\n   return (void *)p;\n }\n@@ -233,9 +254,11 @@ bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n   uptr start, end;\n   while (proc_maps.Next(&start, &end,\n-                        /*offset*/0, /*filename*/0, /*filename_size*/0,\n-                        /*protection*/0)) {\n-    if (!IntervalsAreSeparate(start, end, range_start, range_end))\n+                        /*offset*/nullptr, /*filename*/nullptr,\n+                        /*filename_size*/0, /*protection*/nullptr)) {\n+    if (start == end) continue;  // Empty range.\n+    CHECK_NE(0, end);\n+    if (!IntervalsAreSeparate(start, end - 1, range_start, range_end))\n       return false;\n   }\n   return true;\n@@ -247,8 +270,8 @@ void DumpProcessMap() {\n   const sptr kBufSize = 4095;\n   char *filename = (char*)MmapOrDie(kBufSize, __func__);\n   Report(\"Process memory map follows:\\n\");\n-  while (proc_maps.Next(&start, &end, /* file_offset */0,\n-                        filename, kBufSize, /* protection */0)) {\n+  while (proc_maps.Next(&start, &end, /* file_offset */nullptr,\n+                        filename, kBufSize, /* protection */nullptr)) {\n     Printf(\"\\t%p-%p\\t%s\\n\", (void*)start, (void*)end, filename);\n   }\n   Report(\"End of process memory map.\\n\");\n@@ -259,69 +282,28 @@ const char *GetPwd() {\n   return GetEnv(\"PWD\");\n }\n \n-char *FindPathToBinary(const char *name) {\n-  const char *path = GetEnv(\"PATH\");\n-  if (!path)\n-    return 0;\n-  uptr name_len = internal_strlen(name);\n-  InternalScopedBuffer<char> buffer(kMaxPathLength);\n-  const char *beg = path;\n-  while (true) {\n-    const char *end = internal_strchrnul(beg, ':');\n-    uptr prefix_len = end - beg;\n-    if (prefix_len + name_len + 2 <= kMaxPathLength) {\n-      internal_memcpy(buffer.data(), beg, prefix_len);\n-      buffer[prefix_len] = '/';\n-      internal_memcpy(&buffer[prefix_len + 1], name, name_len);\n-      buffer[prefix_len + 1 + name_len] = '\\0';\n-      if (FileExists(buffer.data()))\n-        return internal_strdup(buffer.data());\n-    }\n-    if (*end == '\\0') break;\n-    beg = end + 1;\n-  }\n-  return 0;\n+bool IsPathSeparator(const char c) {\n+  return c == '/';\n }\n \n-void MaybeOpenReportFile() {\n-  if (!log_to_file) return;\n-  uptr pid = internal_getpid();\n-  // If in tracer, use the parent's file.\n-  if (pid == stoptheworld_tracer_pid)\n-    pid = stoptheworld_tracer_ppid;\n-  if (report_fd_pid == pid) return;\n-  InternalScopedBuffer<char> report_path_full(4096);\n-  internal_snprintf(report_path_full.data(), report_path_full.size(),\n-                    \"%s.%zu\", report_path_prefix, pid);\n-  uptr openrv = OpenFile(report_path_full.data(), true);\n-  if (internal_iserror(openrv)) {\n-    report_fd = kStderrFd;\n-    log_to_file = false;\n-    Report(\"ERROR: Can't open file: %s\\n\", report_path_full.data());\n-    Die();\n-  }\n-  if (report_fd != kInvalidFd) {\n-    // We're in the child. Close the parent's log.\n-    internal_close(report_fd);\n-  }\n-  report_fd = openrv;\n-  report_fd_pid = pid;\n+bool IsAbsolutePath(const char *path) {\n+  return path != nullptr && IsPathSeparator(path[0]);\n }\n \n-void RawWrite(const char *buffer) {\n-  static const char *kRawWriteError =\n-      \"RawWrite can't output requested buffer!\\n\";\n-  uptr length = (uptr)internal_strlen(buffer);\n-  MaybeOpenReportFile();\n-  if (length != internal_write(report_fd, buffer, length)) {\n-    internal_write(report_fd, kRawWriteError, internal_strlen(kRawWriteError));\n+void ReportFile::Write(const char *buffer, uptr length) {\n+  SpinMutexLock l(mu);\n+  static const char *kWriteError =\n+      \"ReportFile::Write() can't output requested buffer!\\n\";\n+  ReopenIfNecessary();\n+  if (length != internal_write(fd, buffer, length)) {\n+    internal_write(fd, kWriteError, internal_strlen(kWriteError));\n     Die();\n   }\n }\n \n bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {\n   uptr s, e, off, prot;\n-  InternalScopedString buff(4096);\n+  InternalScopedString buff(kMaxPathLength);\n   MemoryMappingLayout proc_maps(/*cache_enabled*/false);\n   while (proc_maps.Next(&s, &e, &off, buff.data(), buff.size(), &prot)) {\n     if ((prot & MemoryMappingLayout::kProtectionExecute) != 0\n@@ -334,6 +316,29 @@ bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {\n   return false;\n }\n \n-}  // namespace __sanitizer\n+SignalContext SignalContext::Create(void *siginfo, void *context) {\n+  uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;\n+  uptr pc, sp, bp;\n+  GetPcSpBp(context, &pc, &sp, &bp);\n+  return SignalContext(context, addr, pc, sp, bp);\n+}\n+\n+// This function check is the built VMA matches the runtime one for\n+// architectures with multiple VMA size.\n+void CheckVMASize() {\n+#ifdef __aarch64__\n+  static const unsigned kBuiltVMA = SANITIZER_AARCH64_VMA;\n+  unsigned maxRuntimeVMA =\n+    (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1);\n+  if (kBuiltVMA != maxRuntimeVMA) {\n+    Printf(\"WARNING: %s runtime VMA is not the one built for.\\n\",\n+      SanitizerToolName);\n+    Printf(\"\\tBuilt VMA:   %u bits\\n\", kBuiltVMA);\n+    Printf(\"\\tRuntime VMA: %u bits\\n\", maxRuntimeVMA);\n+  }\n+#endif\n+}\n+\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_POSIX\n+#endif // SANITIZER_POSIX"}, {"sha": "8668a03e68f61831f51c1176194c96f72f284e0f", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,79 @@\n+//===-- sanitizer_posix.h -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries and declares some useful POSIX-specific functions.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_POSIX_H\n+#define SANITIZER_POSIX_H\n+\n+// ----------- ATTENTION -------------\n+// This header should NOT include any other headers from sanitizer runtime.\n+#include \"sanitizer_internal_defs.h\"\n+\n+#if !SANITIZER_POSIX\n+// Make it hard to accidentally use any of functions declared in this file:\n+#error This file should only be included on POSIX\n+#endif\n+\n+namespace __sanitizer {\n+\n+// I/O\n+// Don't use directly, use __sanitizer::OpenFile() instead.\n+uptr internal_open(const char *filename, int flags);\n+uptr internal_open(const char *filename, int flags, u32 mode);\n+uptr internal_close(fd_t fd);\n+\n+uptr internal_read(fd_t fd, void *buf, uptr count);\n+uptr internal_write(fd_t fd, const void *buf, uptr count);\n+\n+// Memory\n+uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n+                   int fd, OFF_T offset);\n+uptr internal_munmap(void *addr, uptr length);\n+int internal_mprotect(void *addr, uptr length, int prot);\n+\n+// OS\n+uptr internal_filesize(fd_t fd);  // -1 on error.\n+uptr internal_stat(const char *path, void *buf);\n+uptr internal_lstat(const char *path, void *buf);\n+uptr internal_fstat(fd_t fd, void *buf);\n+uptr internal_dup2(int oldfd, int newfd);\n+uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n+uptr internal_unlink(const char *path);\n+uptr internal_rename(const char *oldpath, const char *newpath);\n+uptr internal_lseek(fd_t fd, OFF_T offset, int whence);\n+\n+uptr internal_ptrace(int request, int pid, void *addr, void *data);\n+uptr internal_waitpid(int pid, int *status, int options);\n+\n+int internal_fork();\n+\n+// These functions call appropriate pthread_ functions directly, bypassing\n+// the interceptor. They are weak and may not be present in some tools.\n+SANITIZER_WEAK_ATTRIBUTE\n+int real_pthread_create(void *th, void *attr, void *(*callback)(void *),\n+                        void *param);\n+SANITIZER_WEAK_ATTRIBUTE\n+int real_pthread_join(void *th, void **ret);\n+\n+#define DEFINE_REAL_PTHREAD_FUNCTIONS                                          \\\n+  namespace __sanitizer {                                                      \\\n+  int real_pthread_create(void *th, void *attr, void *(*callback)(void *),     \\\n+                          void *param) {                                       \\\n+    return REAL(pthread_create)(th, attr, callback, param);                    \\\n+  }                                                                            \\\n+  int real_pthread_join(void *th, void **ret) {                                \\\n+    return REAL(pthread_join(th, ret));                                        \\\n+  }                                                                            \\\n+  }  // namespace __sanitizer\n+\n+int internal_sigaction(int signum, const void *act, void *oldact);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_POSIX_H"}, {"sha": "b99cdae9c28562a82edfae15e3b03ba03adf4c87", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 97, "deletions": 9, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -13,21 +13,34 @@\n #include \"sanitizer_platform.h\"\n \n #if SANITIZER_POSIX\n+\n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n+#include \"sanitizer_posix.h\"\n+#include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n \n #include <errno.h>\n+#include <fcntl.h>\n #include <pthread.h>\n #include <signal.h>\n #include <stdlib.h>\n #include <sys/mman.h>\n #include <sys/resource.h>\n+#include <sys/stat.h>\n #include <sys/time.h>\n #include <sys/types.h>\n #include <unistd.h>\n \n+#if SANITIZER_FREEBSD\n+// The MAP_NORESERVE define has been removed in FreeBSD 11.x, and even before\n+// that, it was never implemented.  So just define it to zero.\n+#undef  MAP_NORESERVE\n+#define MAP_NORESERVE 0\n+#endif\n+\n namespace __sanitizer {\n \n u32 GetUid() {\n@@ -42,6 +55,18 @@ void FlushUnneededShadowMemory(uptr addr, uptr size) {\n   madvise((void*)addr, size, MADV_DONTNEED);\n }\n \n+void NoHugePagesInRegion(uptr addr, uptr size) {\n+#ifdef MADV_NOHUGEPAGE  // May not be defined on old systems.\n+  madvise((void *)addr, size, MADV_NOHUGEPAGE);\n+#endif  // MADV_NOHUGEPAGE\n+}\n+\n+void DontDumpShadowMemory(uptr addr, uptr length) {\n+#ifdef MADV_DONTDUMP\n+  madvise((void *)addr, length, MADV_DONTDUMP);\n+#endif\n+}\n+\n static rlim_t getlim(int res) {\n   rlimit rlim;\n   CHECK_EQ(0, getrlimit(res, &rlim));\n@@ -53,7 +78,7 @@ static void setlim(int res, rlim_t lim) {\n   volatile struct rlimit rlim;\n   rlim.rlim_cur = lim;\n   rlim.rlim_max = lim;\n-  if (setrlimit(res, (struct rlimit*)&rlim)) {\n+  if (setrlimit(res, const_cast<struct rlimit *>(&rlim))) {\n     Report(\"ERROR: %s setrlimit() failed %d\\n\", SanitizerToolName, errno);\n     Die();\n   }\n@@ -105,8 +130,8 @@ int Atexit(void (*function)(void)) {\n #endif\n }\n \n-int internal_isatty(fd_t fd) {\n-  return isatty(fd);\n+bool SupportsColoredOutput(fd_t fd) {\n+  return isatty(fd) != 0;\n }\n \n #ifndef SANITIZER_GO\n@@ -115,7 +140,7 @@ static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.\n \n void SetAlternateSignalStack() {\n   stack_t altstack, oldstack;\n-  CHECK_EQ(0, sigaltstack(0, &oldstack));\n+  CHECK_EQ(0, sigaltstack(nullptr, &oldstack));\n   // If the alternate stack is already in place, do nothing.\n   // Android always sets an alternate stack, but it's too small for us.\n   if (!SANITIZER_ANDROID && !(oldstack.ss_flags & SS_DISABLE)) return;\n@@ -126,12 +151,12 @@ void SetAlternateSignalStack() {\n   altstack.ss_sp = (char*) base;\n   altstack.ss_flags = 0;\n   altstack.ss_size = kAltStackSize;\n-  CHECK_EQ(0, sigaltstack(&altstack, 0));\n+  CHECK_EQ(0, sigaltstack(&altstack, nullptr));\n }\n \n void UnsetAlternateSignalStack() {\n   stack_t altstack, oldstack;\n-  altstack.ss_sp = 0;\n+  altstack.ss_sp = nullptr;\n   altstack.ss_flags = SS_DISABLE;\n   altstack.ss_size = kAltStackSize;  // Some sane value required on Darwin.\n   CHECK_EQ(0, sigaltstack(&altstack, &oldstack));\n@@ -150,7 +175,7 @@ static void MaybeInstallSigaction(int signum,\n   // Clients are responsible for handling this correctly.\n   sigact.sa_flags = SA_SIGINFO | SA_NODEFER;\n   if (common_flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;\n-  CHECK_EQ(0, internal_sigaction(signum, &sigact, 0));\n+  CHECK_EQ(0, internal_sigaction(signum, &sigact, nullptr));\n   VReport(1, \"Installed the sigaction for signal %d\\n\", signum);\n }\n \n@@ -161,6 +186,8 @@ void InstallDeadlySignalHandlers(SignalHandlerType handler) {\n   if (common_flags()->use_sigaltstack) SetAlternateSignalStack();\n   MaybeInstallSigaction(SIGSEGV, handler);\n   MaybeInstallSigaction(SIGBUS, handler);\n+  MaybeInstallSigaction(SIGABRT, handler);\n+  MaybeInstallSigaction(SIGFPE, handler);\n }\n #endif  // SANITIZER_GO\n \n@@ -186,6 +213,67 @@ bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n   return result;\n }\n \n-}  // namespace __sanitizer\n+void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n+  // Some kinds of sandboxes may forbid filesystem access, so we won't be able\n+  // to read the file mappings from /proc/self/maps. Luckily, neither the\n+  // process will be able to load additional libraries, so it's fine to use the\n+  // cached mappings.\n+  MemoryMappingLayout::CacheMemoryMappings();\n+  // Same for /proc/self/exe in the symbolizer.\n+#if !SANITIZER_GO\n+  Symbolizer::GetOrInit()->PrepareForSandboxing();\n+  CovPrepareForSandboxing(args);\n+#endif\n+}\n+\n+#if SANITIZER_ANDROID\n+int GetNamedMappingFd(const char *name, uptr size) {\n+  return -1;\n+}\n+#else\n+int GetNamedMappingFd(const char *name, uptr size) {\n+  if (!common_flags()->decorate_proc_maps)\n+    return -1;\n+  char shmname[200];\n+  CHECK(internal_strlen(name) < sizeof(shmname) - 10);\n+  internal_snprintf(shmname, sizeof(shmname), \"%zu [%s]\", internal_getpid(),\n+                    name);\n+  int fd = shm_open(shmname, O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);\n+  CHECK_GE(fd, 0);\n+  int res = internal_ftruncate(fd, size);\n+  CHECK_EQ(0, res);\n+  res = shm_unlink(shmname);\n+  CHECK_EQ(0, res);\n+  return fd;\n+}\n+#endif\n+\n+void *MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n+  int fd = name ? GetNamedMappingFd(name, size) : -1;\n+  unsigned flags = MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE;\n+  if (fd == -1) flags |= MAP_ANON;\n+\n+  uptr PageSize = GetPageSizeCached();\n+  uptr p = internal_mmap((void *)(fixed_addr & ~(PageSize - 1)),\n+                         RoundUpTo(size, PageSize), PROT_READ | PROT_WRITE,\n+                         flags, fd, 0);\n+  int reserrno;\n+  if (internal_iserror(p, &reserrno))\n+    Report(\"ERROR: %s failed to \"\n+           \"allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\\n\",\n+           SanitizerToolName, size, size, fixed_addr, reserrno);\n+  IncreaseTotalMmap(size);\n+  return (void *)p;\n+}\n+\n+void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name) {\n+  int fd = name ? GetNamedMappingFd(name, size) : -1;\n+  unsigned flags = MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE;\n+  if (fd == -1) flags |= MAP_ANON;\n+\n+  return (void *)internal_mmap((void *)fixed_addr, size, PROT_NONE, flags, fd,\n+                               0);\n+}\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_POSIX\n+#endif // SANITIZER_POSIX"}, {"sha": "6688610bf0f4bd3bad85f6cb7ba7064191928ee8", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -12,7 +12,6 @@\n // inside it.\n //===----------------------------------------------------------------------===//\n \n-\n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n@@ -96,7 +95,7 @@ static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num,\n \n static int AppendString(char **buff, const char *buff_end, int precision,\n                         const char *s) {\n-  if (s == 0)\n+  if (!s)\n     s = \"<null>\";\n   int result = 0;\n   for (; *s; s++) {\n@@ -249,29 +248,36 @@ static void SharedPrintfCode(bool append_pid, const char *format,\n       buffer_size = kLen;\n     }\n     needed_length = 0;\n+    // Check that data fits into the current buffer.\n+#   define CHECK_NEEDED_LENGTH \\\n+      if (needed_length >= buffer_size) { \\\n+        if (!use_mmap) continue; \\\n+        RAW_CHECK_MSG(needed_length < kLen, \\\n+                      \"Buffer in Report is too short!\\n\"); \\\n+      }\n     if (append_pid) {\n       int pid = internal_getpid();\n-      needed_length += internal_snprintf(buffer, buffer_size, \"==%d==\", pid);\n-      if (needed_length >= buffer_size) {\n-        // The pid doesn't fit into the current buffer.\n-        if (!use_mmap)\n-          continue;\n-        RAW_CHECK_MSG(needed_length < kLen, \"Buffer in Report is too short!\\n\");\n+      const char *exe_name = GetProcessName();\n+      if (common_flags()->log_exe_name && exe_name) {\n+        needed_length += internal_snprintf(buffer, buffer_size,\n+                                           \"==%s\", exe_name);\n+        CHECK_NEEDED_LENGTH\n       }\n+      needed_length += internal_snprintf(buffer + needed_length,\n+                                         buffer_size - needed_length,\n+                                         \"==%d==\", pid);\n+      CHECK_NEEDED_LENGTH\n     }\n     needed_length += VSNPrintf(buffer + needed_length,\n                                buffer_size - needed_length, format, args);\n-    if (needed_length >= buffer_size) {\n-      // The message doesn't fit into the current buffer.\n-      if (!use_mmap)\n-        continue;\n-      RAW_CHECK_MSG(needed_length < kLen, \"Buffer in Report is too short!\\n\");\n-    }\n+    CHECK_NEEDED_LENGTH\n     // If the message fit into the buffer, print it and exit.\n     break;\n+#   undef CHECK_NEEDED_LENGTH\n   }\n   RawWrite(buffer);\n-  AndroidLogWrite(buffer);\n+  if (common_flags()->log_to_syslog)\n+    WriteToSyslog(buffer);\n   CallPrintfAndReportCallback(buffer);\n   // If we had mapped any memory, clean up.\n   if (buffer != local_buffer)\n@@ -320,4 +326,4 @@ void InternalScopedString::append(const char *format, ...) {\n   CHECK_LT(length_, size());\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer"}, {"sha": "1cf3f8510fb6690a8d2179b7ee981f5598527707", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,7 +9,9 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n+\n #if SANITIZER_FREEBSD || SANITIZER_LINUX\n+\n #include \"sanitizer_common.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n@@ -117,7 +119,7 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n                                             string_predicate_t filter) {\n   Reset();\n   uptr cur_beg, cur_end, cur_offset, prot;\n-  InternalScopedBuffer<char> module_name(kMaxPathLength);\n+  InternalScopedString module_name(kMaxPathLength);\n   uptr n_modules = 0;\n   for (uptr i = 0; n_modules < max_modules &&\n                        Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),\n@@ -128,7 +130,6 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n       continue;\n     if (filter && !filter(cur_name))\n       continue;\n-    void *mem = &modules[n_modules];\n     // Don't subtract 'cur_beg' from the first entry:\n     // * If a binary is compiled w/o -pie, then the first entry in\n     //   process maps is likely the binary itself (all dynamic libs\n@@ -141,18 +142,20 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n     //   shadow memory of the tool), so the module can't be the\n     //   first entry.\n     uptr base_address = (i ? cur_beg : 0) - cur_offset;\n-    LoadedModule *cur_module = new(mem) LoadedModule(cur_name, base_address);\n+    LoadedModule *cur_module = &modules[n_modules];\n+    cur_module->set(cur_name, base_address);\n     cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);\n     n_modules++;\n   }\n   return n_modules;\n }\n \n void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {\n-  char *smaps = 0;\n+  char *smaps = nullptr;\n   uptr smaps_cap = 0;\n-  uptr smaps_len = ReadFileToBuffer(\"/proc/self/smaps\",\n-      &smaps, &smaps_cap, 64<<20);\n+  uptr smaps_len = 0;\n+  if (!ReadFileToBuffer(\"/proc/self/smaps\", &smaps, &smaps_cap, &smaps_len))\n+    return;\n   uptr start = 0;\n   bool file = false;\n   const char *pos = smaps;\n@@ -171,6 +174,6 @@ void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {\n   UnmapOrDie(smaps, smaps_cap);\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "e77e33fb2d776350ce3a26d56a84ad4a2b1f8aa3", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -16,8 +16,8 @@\n namespace __sanitizer {\n \n void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n-  proc_maps->len = ReadFileToBuffer(\"/proc/self/maps\", &proc_maps->data,\n-                                    &proc_maps->mmaped_size, 1 << 26);\n+  CHECK(ReadFileToBuffer(\"/proc/self/maps\", &proc_maps->data,\n+                         &proc_maps->mmaped_size, &proc_maps->len));\n }\n \n static bool IsOneOf(char c, char c1, char c2) {"}, {"sha": "393243b7c28198daf56164db5a05e4c37b6e359f", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -158,7 +158,7 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n                                             string_predicate_t filter) {\n   Reset();\n   uptr cur_beg, cur_end, prot;\n-  InternalScopedBuffer<char> module_name(kMaxPathLength);\n+  InternalScopedString module_name(kMaxPathLength);\n   uptr n_modules = 0;\n   for (uptr i = 0; n_modules < max_modules &&\n                        Next(&cur_beg, &cur_end, 0, module_name.data(),\n@@ -169,13 +169,13 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n       continue;\n     if (filter && !filter(cur_name))\n       continue;\n-    LoadedModule *cur_module = 0;\n+    LoadedModule *cur_module = nullptr;\n     if (n_modules > 0 &&\n         0 == internal_strcmp(cur_name, modules[n_modules - 1].full_name())) {\n       cur_module = &modules[n_modules - 1];\n     } else {\n-      void *mem = &modules[n_modules];\n-      cur_module = new(mem) LoadedModule(cur_name, cur_beg);\n+      cur_module = &modules[n_modules];\n+      cur_module->set(cur_name, cur_beg);\n       n_modules++;\n     }\n     cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);"}, {"sha": "a635871be4541b0e93690f8df7d59f495cd536e5", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -47,11 +47,14 @@ class Quarantine {\n   }\n \n   void Init(uptr size, uptr cache_size) {\n-    max_size_ = size;\n-    min_size_ = size / 10 * 9;  // 90% of max size.\n+    atomic_store(&max_size_, size, memory_order_release);\n+    atomic_store(&min_size_, size / 10 * 9,\n+                 memory_order_release); // 90% of max size.\n     max_cache_size_ = cache_size;\n   }\n \n+  uptr GetSize() const { return atomic_load(&max_size_, memory_order_acquire); }\n+\n   void Put(Cache *c, Callback cb, Node *ptr, uptr size) {\n     c->Enqueue(cb, ptr, size);\n     if (c->Size() > max_cache_size_)\n@@ -63,15 +66,15 @@ class Quarantine {\n       SpinMutexLock l(&cache_mutex_);\n       cache_.Transfer(c);\n     }\n-    if (cache_.Size() > max_size_ && recycle_mutex_.TryLock())\n+    if (cache_.Size() > GetSize() && recycle_mutex_.TryLock())\n       Recycle(cb);\n   }\n \n  private:\n   // Read-only data.\n   char pad0_[kCacheLineSize];\n-  uptr max_size_;\n-  uptr min_size_;\n+  atomic_uintptr_t max_size_;\n+  atomic_uintptr_t min_size_;\n   uptr max_cache_size_;\n   char pad1_[kCacheLineSize];\n   SpinMutex cache_mutex_;\n@@ -81,9 +84,10 @@ class Quarantine {\n \n   void NOINLINE Recycle(Callback cb) {\n     Cache tmp;\n+    uptr min_size = atomic_load(&min_size_, memory_order_acquire);\n     {\n       SpinMutexLock l(&cache_mutex_);\n-      while (cache_.Size() > min_size_) {\n+      while (cache_.Size() > min_size) {\n         QuarantineBatch *b = cache_.DequeueBatch();\n         tmp.EnqueueBatch(b);\n       }\n@@ -128,6 +132,7 @@ class QuarantineCache {\n       size += sizeof(QuarantineBatch);  // Count the batch in Quarantine size.\n     }\n     QuarantineBatch *b = list_.back();\n+    CHECK(b);\n     b->batch[b->count++] = ptr;\n     b->size += size;\n     SizeAdd(size);\n@@ -146,7 +151,7 @@ class QuarantineCache {\n \n   QuarantineBatch *DequeueBatch() {\n     if (list_.empty())\n-      return 0;\n+      return nullptr;\n     QuarantineBatch *b = list_.front();\n     list_.pop_front();\n     SizeSub(b->size);\n@@ -166,12 +171,13 @@ class QuarantineCache {\n \n   NOINLINE QuarantineBatch* AllocBatch(Callback cb) {\n     QuarantineBatch *b = (QuarantineBatch *)cb.Allocate(sizeof(*b));\n+    CHECK(b);\n     b->count = 0;\n     b->size = 0;\n     list_.push_back(b);\n     return b;\n   }\n };\n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // #ifndef SANITIZER_QUARANTINE_H\n+#endif // SANITIZER_QUARANTINE_H"}, {"sha": "3c5313c3ae455bae6d96b89e4e27442e84ba2556", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -20,7 +20,8 @@ struct StackDepotNode {\n   StackDepotNode *link;\n   u32 id;\n   atomic_uint32_t hash_and_use_count; // hash_bits : 12; use_count : 20;\n-  uptr size;\n+  u32 size;\n+  u32 tag;\n   uptr stack[1];  // [size]\n \n   static const u32 kTabSizeLog = 20;\n@@ -35,7 +36,8 @@ struct StackDepotNode {\n   bool eq(u32 hash, const args_type &args) const {\n     u32 hash_bits =\n         atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;\n-    if ((hash & kHashMask) != hash_bits || args.size != size) return false;\n+    if ((hash & kHashMask) != hash_bits || args.size != size || args.tag != tag)\n+      return false;\n     uptr i = 0;\n     for (; i < size; i++) {\n       if (stack[i] != args.trace[i]) return false;\n@@ -70,10 +72,11 @@ struct StackDepotNode {\n   void store(const args_type &args, u32 hash) {\n     atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);\n     size = args.size;\n+    tag = args.tag;\n     internal_memcpy(stack, args.trace, size * sizeof(uptr));\n   }\n   args_type load() const {\n-    return args_type(&stack[0], size);\n+    return args_type(&stack[0], size, tag);\n   }\n   StackDepotHandle get_handle() { return StackDepotHandle(this); }\n \n@@ -147,12 +150,12 @@ StackDepotReverseMap::StackDepotReverseMap()\n StackTrace StackDepotReverseMap::Get(u32 id) {\n   if (!map_.size())\n     return StackTrace();\n-  IdDescPair pair = {id, 0};\n+  IdDescPair pair = {id, nullptr};\n   uptr idx = InternalBinarySearch(map_, 0, map_.size(), pair,\n                                   IdDescPair::IdComparator);\n   if (idx > map_.size())\n     return StackTrace();\n   return map_[idx].desc->load();\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer"}, {"sha": "dfb5349de9f3c5da0c0c5026e8b3e0c9ca018200", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -8,6 +8,7 @@\n // This file is shared between AddressSanitizer and ThreadSanitizer\n // run-time libraries.\n //===----------------------------------------------------------------------===//\n+\n #ifndef SANITIZER_STACKDEPOT_H\n #define SANITIZER_STACKDEPOT_H\n \n@@ -21,7 +22,7 @@ namespace __sanitizer {\n struct StackDepotNode;\n struct StackDepotHandle {\n   StackDepotNode *node_;\n-  StackDepotHandle() : node_(0) {}\n+  StackDepotHandle() : node_(nullptr) {}\n   explicit StackDepotHandle(StackDepotNode *node) : node_(node) {}\n   bool valid() { return node_; }\n   u32 id();\n@@ -64,6 +65,6 @@ class StackDepotReverseMap {\n   void operator=(const StackDepotReverseMap&);\n };\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_STACKDEPOT_H\n+#endif // SANITIZER_STACKDEPOT_H"}, {"sha": "ab4932823a3030813e5e49c0ef16fafd5969e480", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -8,6 +8,7 @@\n // Implementation of a mapping from arbitrary values to unique 32-bit\n // identifiers.\n //===----------------------------------------------------------------------===//\n+\n #ifndef SANITIZER_STACKDEPOTBASE_H\n #define SANITIZER_STACKDEPOTBASE_H\n \n@@ -24,7 +25,7 @@ class StackDepotBase {\n   typedef typename Node::args_type args_type;\n   typedef typename Node::handle_type handle_type;\n   // Maps stack trace to an unique id.\n-  handle_type Put(args_type args, bool *inserted = 0);\n+  handle_type Put(args_type args, bool *inserted = nullptr);\n   // Retrieves a stored stack trace by the id.\n   args_type Get(u32 id);\n \n@@ -64,7 +65,7 @@ Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::find(Node *s,\n       return s;\n     }\n   }\n-  return 0;\n+  return nullptr;\n }\n \n template <class Node, int kReservedBits, int kTabSizeLog>\n@@ -170,5 +171,6 @@ void StackDepotBase<Node, kReservedBits, kTabSizeLog>::UnlockAll() {\n   }\n }\n \n-}  // namespace __sanitizer\n-#endif  // SANITIZER_STACKDEPOTBASE_H\n+} // namespace __sanitizer\n+\n+#endif // SANITIZER_STACKDEPOTBASE_H"}, {"sha": "7b0c084b1a2c868ad6bc577a264e072809c085de", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -15,18 +15,13 @@\n \n namespace __sanitizer {\n \n-uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n-#if defined(__arm__)\n-  // Cancel Thumb bit.\n-  pc = pc & (~1);\n-#endif\n-#if defined(__powerpc__) || defined(__powerpc64__)\n-  // PCs are always 4 byte aligned.\n-  return pc - 4;\n-#elif defined(__sparc__) || defined(__mips__)\n-  return pc - 8;\n+uptr StackTrace::GetNextInstructionPc(uptr pc) {\n+#if defined(__mips__)\n+  return pc + 8;\n+#elif defined(__powerpc__)\n+  return pc + 4;\n #else\n-  return pc - 1;\n+  return pc + 1;\n #endif\n }\n \n@@ -73,7 +68,7 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n }\n \n void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n-                                         uptr stack_bottom, uptr max_depth) {\n+                                         uptr stack_bottom, u32 max_depth) {\n   CHECK_GE(max_depth, 2);\n   trace_buffer[0] = pc;\n   size = 1;\n@@ -92,7 +87,7 @@ void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n     // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n-\t!IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n+        !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n     uhwptr pc1 = caller_frame[2];\n #else\n@@ -121,7 +116,7 @@ void BufferedStackTrace::PopStackFrames(uptr count) {\n uptr BufferedStackTrace::LocatePcInTrace(uptr pc) {\n   // Use threshold to find PC in stack trace, as PC we want to unwind from may\n   // slightly differ from return address in the actual unwinded stack trace.\n-  const int kPcThreshold = 288;\n+  const int kPcThreshold = 304;\n   for (uptr i = 0; i < size; ++i) {\n     if (MatchPc(pc, trace[i], kPcThreshold))\n       return i;"}, {"sha": "7f22455ac9e3f94f081138c49de06424522a7b07", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -15,10 +15,9 @@\n \n namespace __sanitizer {\n \n-static const uptr kStackTraceMax = 256;\n+static const u32 kStackTraceMax = 256;\n \n-#if SANITIZER_LINUX && (defined(__aarch64__) || defined(__sparc__) || \\\n-                        defined(__mips__))\n+#if SANITIZER_LINUX &&  (defined(__sparc__) || defined(__mips__))\n # define SANITIZER_CAN_FAST_UNWIND 0\n #elif SANITIZER_WINDOWS\n # define SANITIZER_CAN_FAST_UNWIND 0\n@@ -37,10 +36,18 @@ static const uptr kStackTraceMax = 256;\n \n struct StackTrace {\n   const uptr *trace;\n-  uptr size;\n+  u32 size;\n+  u32 tag;\n \n-  StackTrace() : trace(nullptr), size(0) {}\n-  StackTrace(const uptr *trace, uptr size) : trace(trace), size(size) {}\n+  static const int TAG_UNKNOWN = 0;\n+  static const int TAG_ALLOC = 1;\n+  static const int TAG_DEALLOC = 2;\n+  static const int TAG_CUSTOM = 100; // Tool specific tags start here.\n+\n+  StackTrace() : trace(nullptr), size(0), tag(0) {}\n+  StackTrace(const uptr *trace, u32 size) : trace(trace), size(size), tag(0) {}\n+  StackTrace(const uptr *trace, u32 size, u32 tag)\n+      : trace(trace), size(size), tag(tag) {}\n \n   // Prints a symbolized stacktrace, followed by an empty line.\n   void Print() const;\n@@ -54,11 +61,29 @@ struct StackTrace {\n   }\n \n   static uptr GetCurrentPc();\n-  static uptr GetPreviousInstructionPc(uptr pc);\n+  static inline uptr GetPreviousInstructionPc(uptr pc);\n+  static uptr GetNextInstructionPc(uptr pc);\n   typedef bool (*SymbolizeCallback)(const void *pc, char *out_buffer,\n                                     int out_size);\n };\n \n+// Performance-critical, must be in the header.\n+ALWAYS_INLINE\n+uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n+#if defined(__arm__)\n+  // Cancel Thumb bit.\n+  pc = pc & (~1);\n+#endif\n+#if defined(__powerpc__) || defined(__powerpc64__)\n+  // PCs are always 4 byte aligned.\n+  return pc - 4;\n+#elif defined(__sparc__) || defined(__mips__)\n+  return pc - 8;\n+#else\n+  return pc - 1;\n+#endif\n+}\n+\n // StackTrace that owns the buffer used to store the addresses.\n struct BufferedStackTrace : public StackTrace {\n   uptr trace_buffer[kStackTraceMax];\n@@ -67,15 +92,15 @@ struct BufferedStackTrace : public StackTrace {\n   BufferedStackTrace() : StackTrace(trace_buffer, 0), top_frame_bp(0) {}\n \n   void Init(const uptr *pcs, uptr cnt, uptr extra_top_pc = 0);\n-  void Unwind(uptr max_depth, uptr pc, uptr bp, void *context, uptr stack_top,\n+  void Unwind(u32 max_depth, uptr pc, uptr bp, void *context, uptr stack_top,\n               uptr stack_bottom, bool request_fast_unwind);\n \n  private:\n   void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom,\n-                       uptr max_depth);\n-  void SlowUnwindStack(uptr pc, uptr max_depth);\n+                       u32 max_depth);\n+  void SlowUnwindStack(uptr pc, u32 max_depth);\n   void SlowUnwindStackWithContext(uptr pc, void *context,\n-                                  uptr max_depth);\n+                                  u32 max_depth);\n   void PopStackFrames(uptr count);\n   uptr LocatePcInTrace(uptr pc);\n "}, {"sha": "addf44f73279f1c1248336dbe5caba0ecc364c59", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -22,36 +22,28 @@ void StackTrace::Print() const {\n     Printf(\"    <empty stack>\\n\\n\");\n     return;\n   }\n-  const int kMaxAddrFrames = 64;\n-  InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n-  for (uptr i = 0; i < kMaxAddrFrames; i++)\n-    new(&addr_frames[i]) AddressInfo();\n   InternalScopedString frame_desc(GetPageSizeCached() * 2);\n   uptr frame_num = 0;\n   for (uptr i = 0; i < size && trace[i]; i++) {\n     // PCs in stack traces are actually the return addresses, that is,\n     // addresses of the next instructions after the call.\n     uptr pc = GetPreviousInstructionPc(trace[i]);\n-    uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n-        pc, addr_frames.data(), kMaxAddrFrames);\n-    if (addr_frames_num == 0) {\n-      addr_frames[0].address = pc;\n-      addr_frames_num = 1;\n-    }\n-    for (uptr j = 0; j < addr_frames_num; j++) {\n-      AddressInfo &info = addr_frames[j];\n+    SymbolizedStack *frames = Symbolizer::GetOrInit()->SymbolizePC(pc);\n+    CHECK(frames);\n+    for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n       frame_desc.clear();\n       RenderFrame(&frame_desc, common_flags()->stack_trace_format, frame_num++,\n-                  info, common_flags()->strip_path_prefix);\n+                  cur->info, common_flags()->symbolize_vs_style,\n+                  common_flags()->strip_path_prefix);\n       Printf(\"%s\\n\", frame_desc.data());\n-      info.Clear();\n     }\n+    frames->ClearAll();\n   }\n   // Always print a trailing empty line after stack trace.\n   Printf(\"\\n\");\n }\n \n-void BufferedStackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, void *context,\n+void BufferedStackTrace::Unwind(u32 max_depth, uptr pc, uptr bp, void *context,\n                                 uptr stack_top, uptr stack_bottom,\n                                 bool request_fast_unwind) {\n   top_frame_bp = (max_depth > 0) ? bp : 0;\n@@ -66,10 +58,14 @@ void BufferedStackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, void *context,\n     return;\n   }\n   if (!WillUseFastUnwind(request_fast_unwind)) {\n+#if SANITIZER_CAN_SLOW_UNWIND\n     if (context)\n       SlowUnwindStackWithContext(pc, context, max_depth);\n     else\n       SlowUnwindStack(pc, max_depth);\n+#else\n+    UNREACHABLE(\"slow unwind requested but not available\");\n+#endif\n   } else {\n     FastUnwindStack(pc, bp, stack_top, stack_bottom, max_depth);\n   }"}, {"sha": "bcc9de78ec1570e708ea2496c335240bcf7cb997", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cc", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -8,13 +8,14 @@\n // This file is shared between sanitizers' run-time libraries.\n //\n //===----------------------------------------------------------------------===//\n+\n #include \"sanitizer_stacktrace_printer.h\"\n \n namespace __sanitizer {\n \n static const char *StripFunctionName(const char *function, const char *prefix) {\n-  if (function == 0) return 0;\n-  if (prefix == 0) return function;\n+  if (!function) return nullptr;\n+  if (!prefix) return function;\n   uptr prefix_len = internal_strlen(prefix);\n   if (0 == internal_strncmp(function, prefix, prefix_len))\n     return function + prefix_len;\n@@ -24,8 +25,8 @@ static const char *StripFunctionName(const char *function, const char *prefix) {\n static const char kDefaultFormat[] = \"    #%n %p %F %L\";\n \n void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n-                 const AddressInfo &info, const char *strip_path_prefix,\n-                 const char *strip_func_prefix) {\n+                 const AddressInfo &info, bool vs_style,\n+                 const char *strip_path_prefix, const char *strip_func_prefix) {\n   if (0 == internal_strcmp(format, \"DEFAULT\"))\n     format = kDefaultFormat;\n   for (const char *p = format; *p != '\\0'; p++) {\n@@ -80,14 +81,14 @@ void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n       break;\n     case 'S':\n       // File/line information.\n-      RenderSourceLocation(buffer, info.file, info.line, info.column,\n+      RenderSourceLocation(buffer, info.file, info.line, info.column, vs_style,\n                            strip_path_prefix);\n       break;\n     case 'L':\n       // Source location, or module location.\n       if (info.file) {\n         RenderSourceLocation(buffer, info.file, info.line, info.column,\n-                             strip_path_prefix);\n+                             vs_style, strip_path_prefix);\n       } else if (info.module) {\n         RenderModuleLocation(buffer, info.module, info.module_offset,\n                              strip_path_prefix);\n@@ -97,22 +98,33 @@ void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n       break;\n     case 'M':\n       // Module basename and offset, or PC.\n-      if (info.module)\n+      if (info.address & kExternalPCBit)\n+        {} // There PCs are not meaningful.\n+      else if (info.module)\n         buffer->append(\"(%s+%p)\", StripModuleName(info.module),\n                        (void *)info.module_offset);\n       else\n         buffer->append(\"(%p)\", (void *)info.address);\n       break;\n     default:\n-      Report(\"Unsupported specifier in stack frame format: %c (0x%zx)!\\n\",\n-             *p, *p);\n+      Report(\"Unsupported specifier in stack frame format: %c (0x%zx)!\\n\", *p,\n+             *p);\n       Die();\n     }\n   }\n }\n \n void RenderSourceLocation(InternalScopedString *buffer, const char *file,\n-                          int line, int column, const char *strip_path_prefix) {\n+                          int line, int column, bool vs_style,\n+                          const char *strip_path_prefix) {\n+  if (vs_style && line > 0) {\n+    buffer->append(\"%s(%d\", StripPathPrefix(file, strip_path_prefix), line);\n+    if (column > 0)\n+      buffer->append(\",%d\", column);\n+    buffer->append(\")\");\n+    return;\n+  }\n+\n   buffer->append(\"%s\", StripPathPrefix(file, strip_path_prefix));\n   if (line > 0) {\n     buffer->append(\":%d\", line);\n@@ -127,4 +139,4 @@ void RenderModuleLocation(InternalScopedString *buffer, const char *module,\n                  offset);\n }\n \n-}  // namespace __sanitizer\n+} // namespace __sanitizer"}, {"sha": "a553568ea6ff60a671f3e56e2e681aebef8e907b", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -46,11 +46,13 @@ namespace __sanitizer {\n //        module+offset if it is known, or (<unknown module>) string.\n //   %M - prints module basename and offset, if it is known, or PC.\n void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n-                 const AddressInfo &info, const char *strip_path_prefix = \"\",\n+                 const AddressInfo &info, bool vs_style,\n+                 const char *strip_path_prefix = \"\",\n                  const char *strip_func_prefix = \"\");\n \n void RenderSourceLocation(InternalScopedString *buffer, const char *file,\n-                          int line, int column, const char *strip_path_prefix);\n+                          int line, int column, bool vs_style,\n+                          const char *strip_path_prefix);\n \n void RenderModuleLocation(InternalScopedString *buffer, const char *module,\n                           uptr offset, const char *strip_path_prefix);"}, {"sha": "c3245266fb90bd13da2966e18a791dc4ef189235", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -57,7 +57,8 @@ typedef void (*StopTheWorldCallback)(\n \n // Suspend all threads in the current process and run the callback on the list\n // of suspended threads. This function will resume the threads before returning.\n-// The callback should not call any libc functions.\n+// The callback should not call any libc functions. The callback must not call\n+// exit() nor _exit() and instead return to the caller.\n // This function should NOT be called from multiple threads simultaneously.\n void StopTheWorld(StopTheWorldCallback callback, void *argument);\n "}, {"sha": "c919e4f6e979fc26cda7df96fdf2d9c163e1bd23", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc", "status": "modified", "additions": 173, "deletions": 120, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -10,23 +10,31 @@\n //\n //===----------------------------------------------------------------------===//\n \n-\n #include \"sanitizer_platform.h\"\n-#if SANITIZER_LINUX && defined(__x86_64__)\n+\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips__) || \\\n+                        defined(__aarch64__))\n \n #include \"sanitizer_stoptheworld.h\"\n \n #include \"sanitizer_platform_limits_posix.h\"\n+#include \"sanitizer_atomic.h\"\n \n #include <errno.h>\n #include <sched.h> // for CLONE_* definitions\n #include <stddef.h>\n #include <sys/prctl.h> // for PR_* definitions\n #include <sys/ptrace.h> // for PTRACE_* definitions\n #include <sys/types.h> // for pid_t\n+#include <sys/uio.h> // for iovec\n+#include <elf.h> // for NT_PRSTATUS\n #if SANITIZER_ANDROID && defined(__arm__)\n # include <linux/user.h>  // for pt_regs\n #else\n+# ifdef __aarch64__\n+// GLIBC 2.20+ sys/user does not include asm/ptrace.h\n+#  include <asm/ptrace.h>\n+# endif\n # include <sys/user.h>  // for user_regs_struct\n #endif\n #include <sys/wait.h> // for signal-related stuff\n@@ -68,11 +76,25 @@\n COMPILER_CHECK(sizeof(SuspendedThreadID) == sizeof(pid_t));\n \n namespace __sanitizer {\n+\n+// Structure for passing arguments into the tracer thread.\n+struct TracerThreadArgument {\n+  StopTheWorldCallback callback;\n+  void *callback_argument;\n+  // The tracer thread waits on this mutex while the parent finishes its\n+  // preparations.\n+  BlockingMutex mutex;\n+  // Tracer thread signals its completion by setting done.\n+  atomic_uintptr_t done;\n+  uptr parent_pid;\n+};\n+\n // This class handles thread suspending/unsuspending in the tracer thread.\n class ThreadSuspender {\n  public:\n-  explicit ThreadSuspender(pid_t pid)\n-    : pid_(pid) {\n+  explicit ThreadSuspender(pid_t pid, TracerThreadArgument *arg)\n+    : arg(arg)\n+    , pid_(pid) {\n       CHECK_GE(pid, 0);\n     }\n   bool SuspendAllThreads();\n@@ -81,42 +103,58 @@ class ThreadSuspender {\n   SuspendedThreadsList &suspended_threads_list() {\n     return suspended_threads_list_;\n   }\n+  TracerThreadArgument *arg;\n  private:\n   SuspendedThreadsList suspended_threads_list_;\n   pid_t pid_;\n   bool SuspendThread(SuspendedThreadID thread_id);\n };\n \n-bool ThreadSuspender::SuspendThread(SuspendedThreadID thread_id) {\n+bool ThreadSuspender::SuspendThread(SuspendedThreadID tid) {\n   // Are we already attached to this thread?\n   // Currently this check takes linear time, however the number of threads is\n   // usually small.\n-  if (suspended_threads_list_.Contains(thread_id))\n+  if (suspended_threads_list_.Contains(tid))\n     return false;\n   int pterrno;\n-  if (internal_iserror(internal_ptrace(PTRACE_ATTACH, thread_id, NULL, NULL),\n+  if (internal_iserror(internal_ptrace(PTRACE_ATTACH, tid, nullptr, nullptr),\n                        &pterrno)) {\n     // Either the thread is dead, or something prevented us from attaching.\n     // Log this event and move on.\n-    VReport(1, \"Could not attach to thread %d (errno %d).\\n\", thread_id,\n-            pterrno);\n+    VReport(1, \"Could not attach to thread %d (errno %d).\\n\", tid, pterrno);\n     return false;\n   } else {\n-    VReport(1, \"Attached to thread %d.\\n\", thread_id);\n+    VReport(2, \"Attached to thread %d.\\n\", tid);\n     // The thread is not guaranteed to stop before ptrace returns, so we must\n-    // wait on it.\n-    uptr waitpid_status;\n-    HANDLE_EINTR(waitpid_status, internal_waitpid(thread_id, NULL, __WALL));\n-    int wperrno;\n-    if (internal_iserror(waitpid_status, &wperrno)) {\n-      // Got a ECHILD error. I don't think this situation is possible, but it\n-      // doesn't hurt to report it.\n-      VReport(1, \"Waiting on thread %d failed, detaching (errno %d).\\n\",\n-              thread_id, wperrno);\n-      internal_ptrace(PTRACE_DETACH, thread_id, NULL, NULL);\n-      return false;\n+    // wait on it. Note: if the thread receives a signal concurrently,\n+    // we can get notification about the signal before notification about stop.\n+    // In such case we need to forward the signal to the thread, otherwise\n+    // the signal will be missed (as we do PTRACE_DETACH with arg=0) and\n+    // any logic relying on signals will break. After forwarding we need to\n+    // continue to wait for stopping, because the thread is not stopped yet.\n+    // We do ignore delivery of SIGSTOP, because we want to make stop-the-world\n+    // as invisible as possible.\n+    for (;;) {\n+      int status;\n+      uptr waitpid_status;\n+      HANDLE_EINTR(waitpid_status, internal_waitpid(tid, &status, __WALL));\n+      int wperrno;\n+      if (internal_iserror(waitpid_status, &wperrno)) {\n+        // Got a ECHILD error. I don't think this situation is possible, but it\n+        // doesn't hurt to report it.\n+        VReport(1, \"Waiting on thread %d failed, detaching (errno %d).\\n\",\n+                tid, wperrno);\n+        internal_ptrace(PTRACE_DETACH, tid, nullptr, nullptr);\n+        return false;\n+      }\n+      if (WIFSTOPPED(status) && WSTOPSIG(status) != SIGSTOP) {\n+        internal_ptrace(PTRACE_CONT, tid, nullptr,\n+                        (void*)(uptr)WSTOPSIG(status));\n+        continue;\n+      }\n+      break;\n     }\n-    suspended_threads_list_.Append(thread_id);\n+    suspended_threads_list_.Append(tid);\n     return true;\n   }\n }\n@@ -125,9 +163,9 @@ void ThreadSuspender::ResumeAllThreads() {\n   for (uptr i = 0; i < suspended_threads_list_.thread_count(); i++) {\n     pid_t tid = suspended_threads_list_.GetThreadID(i);\n     int pterrno;\n-    if (!internal_iserror(internal_ptrace(PTRACE_DETACH, tid, NULL, NULL),\n+    if (!internal_iserror(internal_ptrace(PTRACE_DETACH, tid, nullptr, nullptr),\n                           &pterrno)) {\n-      VReport(1, \"Detached from thread %d.\\n\", tid);\n+      VReport(2, \"Detached from thread %d.\\n\", tid);\n     } else {\n       // Either the thread is dead, or we are already detached.\n       // The latter case is possible, for instance, if this function was called\n@@ -140,7 +178,7 @@ void ThreadSuspender::ResumeAllThreads() {\n void ThreadSuspender::KillAllThreads() {\n   for (uptr i = 0; i < suspended_threads_list_.thread_count(); i++)\n     internal_ptrace(PTRACE_KILL, suspended_threads_list_.GetThreadID(i),\n-                    NULL, NULL);\n+                    nullptr, nullptr);\n }\n \n bool ThreadSuspender::SuspendAllThreads() {\n@@ -166,35 +204,11 @@ bool ThreadSuspender::SuspendAllThreads() {\n }\n \n // Pointer to the ThreadSuspender instance for use in signal handler.\n-static ThreadSuspender *thread_suspender_instance = NULL;\n-\n-// Signals that should not be blocked (this is used in the parent thread as well\n-// as the tracer thread).\n-static const int kUnblockedSignals[] = { SIGABRT, SIGILL, SIGFPE, SIGSEGV,\n-                                         SIGBUS, SIGXCPU, SIGXFSZ };\n-\n-// Structure for passing arguments into the tracer thread.\n-struct TracerThreadArgument {\n-  StopTheWorldCallback callback;\n-  void *callback_argument;\n-  // The tracer thread waits on this mutex while the parent finishes its\n-  // preparations.\n-  BlockingMutex mutex;\n-  uptr parent_pid;\n-};\n-\n-static DieCallbackType old_die_callback;\n+static ThreadSuspender *thread_suspender_instance = nullptr;\n \n-// Signal handler to wake up suspended threads when the tracer thread dies.\n-void TracerThreadSignalHandler(int signum, void *siginfo, void *) {\n-  if (thread_suspender_instance != NULL) {\n-    if (signum == SIGABRT)\n-      thread_suspender_instance->KillAllThreads();\n-    else\n-      thread_suspender_instance->ResumeAllThreads();\n-  }\n-  internal__exit((signum == SIGABRT) ? 1 : 2);\n-}\n+// Synchronous signals that should not be blocked.\n+static const int kSyncSignals[] = { SIGABRT, SIGILL, SIGFPE, SIGSEGV, SIGBUS,\n+                                    SIGXCPU, SIGXFSZ };\n \n static void TracerThreadDieCallback() {\n   // Generally a call to Die() in the tracer thread should be fatal to the\n@@ -203,10 +217,29 @@ static void TracerThreadDieCallback() {\n   // point. So we correctly handle calls to Die() from within the callback, but\n   // not those that happen before or after the callback. Hopefully there aren't\n   // a lot of opportunities for that to happen...\n-  if (thread_suspender_instance)\n-    thread_suspender_instance->KillAllThreads();\n-  if (old_die_callback)\n-    old_die_callback();\n+  ThreadSuspender *inst = thread_suspender_instance;\n+  if (inst && stoptheworld_tracer_pid == internal_getpid()) {\n+    inst->KillAllThreads();\n+    thread_suspender_instance = nullptr;\n+  }\n+}\n+\n+// Signal handler to wake up suspended threads when the tracer thread dies.\n+static void TracerThreadSignalHandler(int signum, void *siginfo, void *uctx) {\n+  SignalContext ctx = SignalContext::Create(siginfo, uctx);\n+  VPrintf(1, \"Tracer caught signal %d: addr=0x%zx pc=0x%zx sp=0x%zx\\n\",\n+      signum, ctx.addr, ctx.pc, ctx.sp);\n+  ThreadSuspender *inst = thread_suspender_instance;\n+  if (inst) {\n+    if (signum == SIGABRT)\n+      inst->KillAllThreads();\n+    else\n+      inst->ResumeAllThreads();\n+    RAW_CHECK(RemoveDieCallback(TracerThreadDieCallback));\n+    thread_suspender_instance = nullptr;\n+    atomic_store(&inst->arg->done, 1, memory_order_relaxed);\n+  }\n+  internal__exit((signum == SIGABRT) ? 1 : 2);\n }\n \n // Size of alternative stack for signal handlers in the tracer thread.\n@@ -226,9 +259,9 @@ static int TracerThread(void* argument) {\n   tracer_thread_argument->mutex.Lock();\n   tracer_thread_argument->mutex.Unlock();\n \n-  SetDieCallback(TracerThreadDieCallback);\n+  RAW_CHECK(AddDieCallback(TracerThreadDieCallback));\n \n-  ThreadSuspender thread_suspender(internal_getppid());\n+  ThreadSuspender thread_suspender(internal_getppid(), tracer_thread_argument);\n   // Global pointer for the signal handler.\n   thread_suspender_instance = &thread_suspender;\n \n@@ -238,19 +271,16 @@ static int TracerThread(void* argument) {\n   internal_memset(&handler_stack, 0, sizeof(handler_stack));\n   handler_stack.ss_sp = handler_stack_memory.data();\n   handler_stack.ss_size = kHandlerStackSize;\n-  internal_sigaltstack(&handler_stack, NULL);\n-\n-  // Install our handler for fatal signals. Other signals should be blocked by\n-  // the mask we inherited from the caller thread.\n-  for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n-       signal_index++) {\n-    __sanitizer_sigaction new_sigaction;\n-    internal_memset(&new_sigaction, 0, sizeof(new_sigaction));\n-    new_sigaction.sigaction = TracerThreadSignalHandler;\n-    new_sigaction.sa_flags = SA_ONSTACK | SA_SIGINFO;\n-    internal_sigfillset(&new_sigaction.sa_mask);\n-    internal_sigaction_norestorer(kUnblockedSignals[signal_index],\n-                                  &new_sigaction, NULL);\n+  internal_sigaltstack(&handler_stack, nullptr);\n+\n+  // Install our handler for synchronous signals. Other signals should be\n+  // blocked by the mask we inherited from the parent thread.\n+  for (uptr i = 0; i < ARRAY_SIZE(kSyncSignals); i++) {\n+    __sanitizer_sigaction act;\n+    internal_memset(&act, 0, sizeof(act));\n+    act.sigaction = TracerThreadSignalHandler;\n+    act.sa_flags = SA_ONSTACK | SA_SIGINFO;\n+    internal_sigaction_norestorer(kSyncSignals[i], &act, 0);\n   }\n \n   int exit_code = 0;\n@@ -263,9 +293,9 @@ static int TracerThread(void* argument) {\n     thread_suspender.ResumeAllThreads();\n     exit_code = 0;\n   }\n-  thread_suspender_instance = NULL;\n-  handler_stack.ss_flags = SS_DISABLE;\n-  internal_sigaltstack(&handler_stack, NULL);\n+  RAW_CHECK(RemoveDieCallback(TracerThreadDieCallback));\n+  thread_suspender_instance = nullptr;\n+  atomic_store(&tracer_thread_argument->done, 1, memory_order_relaxed);\n   return exit_code;\n }\n \n@@ -278,7 +308,7 @@ class ScopedStackSpaceWithGuard {\n     // in the future.\n     guard_start_ = (uptr)MmapOrDie(stack_size_ + guard_size_,\n                                    \"ScopedStackWithGuard\");\n-    CHECK_EQ(guard_start_, (uptr)Mprotect((uptr)guard_start_, guard_size_));\n+    CHECK(MprotectNoAccess((uptr)guard_start_, guard_size_));\n   }\n   ~ScopedStackSpaceWithGuard() {\n     UnmapOrDie((void *)guard_start_, stack_size_ + guard_size_);\n@@ -297,53 +327,21 @@ class ScopedStackSpaceWithGuard {\n // into globals.\n static __sanitizer_sigset_t blocked_sigset;\n static __sanitizer_sigset_t old_sigset;\n-static __sanitizer_sigaction old_sigactions\n-    [ARRAY_SIZE(kUnblockedSignals)];\n \n class StopTheWorldScope {\n  public:\n   StopTheWorldScope() {\n-    // Block all signals that can be blocked safely, and install\n-    // default handlers for the remaining signals.\n-    // We cannot allow user-defined handlers to run while the ThreadSuspender\n-    // thread is active, because they could conceivably call some libc functions\n-    // which modify errno (which is shared between the two threads).\n-    internal_sigfillset(&blocked_sigset);\n-    for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n-         signal_index++) {\n-      // Remove the signal from the set of blocked signals.\n-      internal_sigdelset(&blocked_sigset, kUnblockedSignals[signal_index]);\n-      // Install the default handler.\n-      __sanitizer_sigaction new_sigaction;\n-      internal_memset(&new_sigaction, 0, sizeof(new_sigaction));\n-      new_sigaction.handler = SIG_DFL;\n-      internal_sigfillset(&new_sigaction.sa_mask);\n-      internal_sigaction_norestorer(kUnblockedSignals[signal_index],\n-          &new_sigaction, &old_sigactions[signal_index]);\n-    }\n-    int sigprocmask_status =\n-        internal_sigprocmask(SIG_BLOCK, &blocked_sigset, &old_sigset);\n-    CHECK_EQ(sigprocmask_status, 0); // sigprocmask should never fail\n     // Make this process dumpable. Processes that are not dumpable cannot be\n     // attached to.\n     process_was_dumpable_ = internal_prctl(PR_GET_DUMPABLE, 0, 0, 0, 0);\n     if (!process_was_dumpable_)\n       internal_prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);\n-    old_die_callback = GetDieCallback();\n   }\n \n   ~StopTheWorldScope() {\n-    SetDieCallback(old_die_callback);\n     // Restore the dumpable flag.\n     if (!process_was_dumpable_)\n       internal_prctl(PR_SET_DUMPABLE, 0, 0, 0, 0);\n-    // Restore the signal handlers.\n-    for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n-         signal_index++) {\n-      internal_sigaction_norestorer(kUnblockedSignals[signal_index],\n-                                    &old_sigactions[signal_index], NULL);\n-    }\n-    internal_sigprocmask(SIG_SETMASK, &old_sigset, &old_sigset);\n   }\n \n  private:\n@@ -371,16 +369,42 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n   tracer_thread_argument.callback = callback;\n   tracer_thread_argument.callback_argument = argument;\n   tracer_thread_argument.parent_pid = internal_getpid();\n+  atomic_store(&tracer_thread_argument.done, 0, memory_order_relaxed);\n   const uptr kTracerStackSize = 2 * 1024 * 1024;\n   ScopedStackSpaceWithGuard tracer_stack(kTracerStackSize);\n   // Block the execution of TracerThread until after we have set ptrace\n   // permissions.\n   tracer_thread_argument.mutex.Lock();\n+  // Signal handling story.\n+  // We don't want async signals to be delivered to the tracer thread,\n+  // so we block all async signals before creating the thread. An async signal\n+  // handler can temporary modify errno, which is shared with this thread.\n+  // We ought to use pthread_sigmask here, because sigprocmask has undefined\n+  // behavior in multithreaded programs. However, on linux sigprocmask is\n+  // equivalent to pthread_sigmask with the exception that pthread_sigmask\n+  // does not allow to block some signals used internally in pthread\n+  // implementation. We are fine with blocking them here, we are really not\n+  // going to pthread_cancel the thread.\n+  // The tracer thread should not raise any synchronous signals. But in case it\n+  // does, we setup a special handler for sync signals that properly kills the\n+  // parent as well. Note: we don't pass CLONE_SIGHAND to clone, so handlers\n+  // in the tracer thread won't interfere with user program. Double note: if a\n+  // user does something along the lines of 'kill -11 pid', that can kill the\n+  // process even if user setup own handler for SEGV.\n+  // Thing to watch out for: this code should not change behavior of user code\n+  // in any observable way. In particular it should not override user signal\n+  // handlers.\n+  internal_sigfillset(&blocked_sigset);\n+  for (uptr i = 0; i < ARRAY_SIZE(kSyncSignals); i++)\n+    internal_sigdelset(&blocked_sigset, kSyncSignals[i]);\n+  int rv = internal_sigprocmask(SIG_BLOCK, &blocked_sigset, &old_sigset);\n+  CHECK_EQ(rv, 0);\n   uptr tracer_pid = internal_clone(\n       TracerThread, tracer_stack.Bottom(),\n       CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_UNTRACED,\n-      &tracer_thread_argument, 0 /* parent_tidptr */, 0 /* newtls */, 0\n-      /* child_tidptr */);\n+      &tracer_thread_argument, nullptr /* parent_tidptr */,\n+      nullptr /* newtls */, nullptr /* child_tidptr */);\n+  internal_sigprocmask(SIG_SETMASK, &old_sigset, 0);\n   int local_errno = 0;\n   if (internal_iserror(tracer_pid, &local_errno)) {\n     VReport(1, \"Failed spawning a tracer thread (errno %d).\\n\", local_errno);\n@@ -394,14 +418,27 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n #endif\n     // Allow the tracer thread to start.\n     tracer_thread_argument.mutex.Unlock();\n-    // Since errno is shared between this thread and the tracer thread, we\n-    // must avoid using errno while the tracer thread is running.\n-    // At this point, any signal will either be blocked or kill us, so waitpid\n-    // should never return (and set errno) while the tracer thread is alive.\n-    uptr waitpid_status = internal_waitpid(tracer_pid, NULL, __WALL);\n-    if (internal_iserror(waitpid_status, &local_errno))\n+    // NOTE: errno is shared between this thread and the tracer thread.\n+    // internal_waitpid() may call syscall() which can access/spoil errno,\n+    // so we can't call it now. Instead we for the tracer thread to finish using\n+    // the spin loop below. Man page for sched_yield() says \"In the Linux\n+    // implementation, sched_yield() always succeeds\", so let's hope it does not\n+    // spoil errno. Note that this spin loop runs only for brief periods before\n+    // the tracer thread has suspended us and when it starts unblocking threads.\n+    while (atomic_load(&tracer_thread_argument.done, memory_order_relaxed) == 0)\n+      sched_yield();\n+    // Now the tracer thread is about to exit and does not touch errno,\n+    // wait for it.\n+    for (;;) {\n+      uptr waitpid_status = internal_waitpid(tracer_pid, nullptr, __WALL);\n+      if (!internal_iserror(waitpid_status, &local_errno))\n+        break;\n+      if (local_errno == EINTR)\n+        continue;\n       VReport(1, \"Waiting on the tracer thread failed (errno %d).\\n\",\n               local_errno);\n+      break;\n+    }\n   }\n }\n \n@@ -430,6 +467,11 @@ typedef pt_regs regs_struct;\n typedef struct user regs_struct;\n #define REG_SP regs[EF_REG29]\n \n+#elif defined(__aarch64__)\n+typedef struct user_pt_regs regs_struct;\n+#define REG_SP sp\n+#define ARCH_IOVEC_FOR_GETREGSET\n+\n #else\n #error \"Unsupported architecture\"\n #endif // SANITIZER_ANDROID && defined(__arm__)\n@@ -440,8 +482,18 @@ int SuspendedThreadsList::GetRegistersAndSP(uptr index,\n   pid_t tid = GetThreadID(index);\n   regs_struct regs;\n   int pterrno;\n-  if (internal_iserror(internal_ptrace(PTRACE_GETREGS, tid, NULL, &regs),\n-                       &pterrno)) {\n+#ifdef ARCH_IOVEC_FOR_GETREGSET\n+  struct iovec regset_io;\n+  regset_io.iov_base = &regs;\n+  regset_io.iov_len = sizeof(regs_struct);\n+  bool isErr = internal_iserror(internal_ptrace(PTRACE_GETREGSET, tid,\n+                                (void*)NT_PRSTATUS, (void*)&regset_io),\n+                                &pterrno);\n+#else\n+  bool isErr = internal_iserror(internal_ptrace(PTRACE_GETREGS, tid, nullptr,\n+                                &regs), &pterrno);\n+#endif\n+  if (isErr) {\n     VReport(1, \"Could not get registers from thread %d (errno %d).\\n\", tid,\n             pterrno);\n     return -1;\n@@ -455,6 +507,7 @@ int SuspendedThreadsList::GetRegistersAndSP(uptr index,\n uptr SuspendedThreadsList::RegisterCount() {\n   return sizeof(regs_struct) / sizeof(uptr);\n }\n-}  // namespace __sanitizer\n+} // namespace __sanitizer\n \n-#endif  // SANITIZER_LINUX && defined(__x86_64__)\n+#endif // SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips__)\n+       // || defined(__aarch64__)"}, {"sha": "2b6a78155fd25ca14f0ad4defbac2d6239f7e26c", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "modified", "additions": 71, "deletions": 85, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -5,7 +5,7 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// Suppression parsing/matching code shared between TSan and LSan.\n+// Suppression parsing/matching code.\n //\n //===----------------------------------------------------------------------===//\n \n@@ -19,90 +19,73 @@\n \n namespace __sanitizer {\n \n-static const char *const kTypeStrings[SuppressionTypeCount] = {\n-    \"none\", \"race\",            \"mutex\",    \"thread\",    \"signal\",\n-    \"leak\", \"called_from_lib\", \"deadlock\", \"vptr_check\"};\n+SuppressionContext::SuppressionContext(const char *suppression_types[],\n+                                       int suppression_types_num)\n+    : suppression_types_(suppression_types),\n+      suppression_types_num_(suppression_types_num), suppressions_(1),\n+      can_parse_(true) {\n+  CHECK_LE(suppression_types_num_, kMaxSuppressionTypes);\n+  internal_memset(has_suppression_type_, 0, suppression_types_num_);\n+}\n \n-bool TemplateMatch(char *templ, const char *str) {\n-  if (str == 0 || str[0] == 0)\n-    return false;\n-  bool start = false;\n-  if (templ && templ[0] == '^') {\n-    start = true;\n-    templ++;\n+static bool GetPathAssumingFileIsRelativeToExec(const char *file_path,\n+                                                /*out*/char *new_file_path,\n+                                                uptr new_file_path_size) {\n+  InternalScopedString exec(kMaxPathLength);\n+  if (ReadBinaryNameCached(exec.data(), exec.size())) {\n+    const char *file_name_pos = StripModuleName(exec.data());\n+    uptr path_to_exec_len = file_name_pos - exec.data();\n+    internal_strncat(new_file_path, exec.data(),\n+                     Min(path_to_exec_len, new_file_path_size - 1));\n+    internal_strncat(new_file_path, file_path,\n+                     new_file_path_size - internal_strlen(new_file_path) - 1);\n+    return true;\n   }\n-  bool asterisk = false;\n-  while (templ && templ[0]) {\n-    if (templ[0] == '*') {\n-      templ++;\n-      start = false;\n-      asterisk = true;\n-      continue;\n-    }\n-    if (templ[0] == '$')\n-      return str[0] == 0 || asterisk;\n-    if (str[0] == 0)\n-      return false;\n-    char *tpos = (char*)internal_strchr(templ, '*');\n-    char *tpos1 = (char*)internal_strchr(templ, '$');\n-    if (tpos == 0 || (tpos1 && tpos1 < tpos))\n-      tpos = tpos1;\n-    if (tpos != 0)\n-      tpos[0] = 0;\n-    const char *str0 = str;\n-    const char *spos = internal_strstr(str, templ);\n-    str = spos + internal_strlen(templ);\n-    templ = tpos;\n-    if (tpos)\n-      tpos[0] = tpos == tpos1 ? '$' : '*';\n-    if (spos == 0)\n-      return false;\n-    if (start && spos != str0)\n-      return false;\n-    start = false;\n-    asterisk = false;\n-  }\n-  return true;\n+  return false;\n }\n \n-ALIGNED(64) static char placeholder[sizeof(SuppressionContext)];\n-static SuppressionContext *suppression_ctx = 0;\n+void SuppressionContext::ParseFromFile(const char *filename) {\n+  if (filename[0] == '\\0')\n+    return;\n \n-SuppressionContext *SuppressionContext::Get() {\n-  CHECK(suppression_ctx);\n-  return suppression_ctx;\n-}\n+  // If we cannot find the file, check if its location is relative to\n+  // the location of the executable.\n+  InternalScopedString new_file_path(kMaxPathLength);\n+  if (!FileExists(filename) && !IsAbsolutePath(filename) &&\n+      GetPathAssumingFileIsRelativeToExec(filename, new_file_path.data(),\n+                                          new_file_path.size())) {\n+    filename = new_file_path.data();\n+  }\n \n-void SuppressionContext::InitIfNecessary() {\n-  if (suppression_ctx)\n-    return;\n-  suppression_ctx = new(placeholder) SuppressionContext;\n-  if (common_flags()->suppressions[0] == '\\0')\n-    return;\n-  char *suppressions_from_file;\n+  // Read the file.\n+  VPrintf(1, \"%s: reading suppressions file at %s\\n\",\n+          SanitizerToolName, filename);\n+  char *file_contents;\n   uptr buffer_size;\n-  uptr contents_size =\n-      ReadFileToBuffer(common_flags()->suppressions, &suppressions_from_file,\n-                       &buffer_size, 1 << 26 /* max_len */);\n-  if (contents_size == 0) {\n+  uptr contents_size;\n+  if (!ReadFileToBuffer(filename, &file_contents, &buffer_size,\n+                        &contents_size)) {\n     Printf(\"%s: failed to read suppressions file '%s'\\n\", SanitizerToolName,\n-           common_flags()->suppressions);\n+           filename);\n     Die();\n   }\n-  suppression_ctx->Parse(suppressions_from_file);\n+\n+  Parse(file_contents);\n }\n \n-bool SuppressionContext::Match(const char *str, SuppressionType type,\n+bool SuppressionContext::Match(const char *str, const char *type,\n                                Suppression **s) {\n   can_parse_ = false;\n-  uptr i;\n-  for (i = 0; i < suppressions_.size(); i++)\n-    if (type == suppressions_[i].type &&\n-        TemplateMatch(suppressions_[i].templ, str))\n-      break;\n-  if (i == suppressions_.size()) return false;\n-  *s = &suppressions_[i];\n-  return true;\n+  if (!HasSuppressionType(type))\n+    return false;\n+  for (uptr i = 0; i < suppressions_.size(); i++) {\n+    Suppression &cur = suppressions_[i];\n+    if (0 == internal_strcmp(cur.type, type) && TemplateMatch(cur.templ, str)) {\n+      *s = &cur;\n+      return true;\n+    }\n+  }\n+  return false;\n }\n \n static const char *StripPrefix(const char *str, const char *prefix) {\n@@ -127,28 +110,28 @@ void SuppressionContext::Parse(const char *str) {\n       end = line + internal_strlen(line);\n     if (line != end && line[0] != '#') {\n       const char *end2 = end;\n-      while (line != end2 && (end2[-1] == ' ' || end2[-1] == '\\t'))\n+      while (line != end2 &&\n+             (end2[-1] == ' ' || end2[-1] == '\\t' || end2[-1] == '\\r'))\n         end2--;\n       int type;\n-      for (type = 0; type < SuppressionTypeCount; type++) {\n-        const char *next_char = StripPrefix(line, kTypeStrings[type]);\n+      for (type = 0; type < suppression_types_num_; type++) {\n+        const char *next_char = StripPrefix(line, suppression_types_[type]);\n         if (next_char && *next_char == ':') {\n           line = ++next_char;\n           break;\n         }\n       }\n-      if (type == SuppressionTypeCount) {\n+      if (type == suppression_types_num_) {\n         Printf(\"%s: failed to parse suppressions\\n\", SanitizerToolName);\n         Die();\n       }\n-      Suppression s;\n-      s.type = static_cast<SuppressionType>(type);\n+      Suppression s = {};\n+      s.type = suppression_types_[type];\n       s.templ = (char*)InternalAlloc(end2 - line + 1);\n       internal_memcpy(s.templ, line, end2 - line);\n       s.templ[end2 - line] = 0;\n-      s.hit_count = 0;\n-      s.weight = 0;\n       suppressions_.push_back(s);\n+      has_suppression_type_[type] = true;\n     }\n     if (end[0] == 0)\n       break;\n@@ -160,6 +143,14 @@ uptr SuppressionContext::SuppressionCount() const {\n   return suppressions_.size();\n }\n \n+bool SuppressionContext::HasSuppressionType(const char *type) const {\n+  for (int i = 0; i < suppression_types_num_; i++) {\n+    if (0 == internal_strcmp(type, suppression_types_[i]))\n+      return has_suppression_type_[i];\n+  }\n+  return false;\n+}\n+\n const Suppression *SuppressionContext::SuppressionAt(uptr i) const {\n   CHECK_LT(i, suppressions_.size());\n   return &suppressions_[i];\n@@ -168,13 +159,8 @@ const Suppression *SuppressionContext::SuppressionAt(uptr i) const {\n void SuppressionContext::GetMatched(\n     InternalMmapVector<Suppression *> *matched) {\n   for (uptr i = 0; i < suppressions_.size(); i++)\n-    if (suppressions_[i].hit_count)\n+    if (atomic_load_relaxed(&suppressions_[i].hit_count))\n       matched->push_back(&suppressions_[i]);\n }\n \n-const char *SuppressionTypeString(SuppressionType t) {\n-  CHECK(t < SuppressionTypeCount);\n-  return kTypeStrings[t];\n-}\n-\n }  // namespace __sanitizer"}, {"sha": "efec926476baa36e5045b79bd7358f3730afa222", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -5,64 +5,50 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// Suppression parsing/matching code shared between TSan and LSan.\n+// Suppression parsing/matching code.\n //\n //===----------------------------------------------------------------------===//\n #ifndef SANITIZER_SUPPRESSIONS_H\n #define SANITIZER_SUPPRESSIONS_H\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_atomic.h\"\n #include \"sanitizer_internal_defs.h\"\n \n namespace __sanitizer {\n \n-enum SuppressionType {\n-  SuppressionNone,\n-  SuppressionRace,\n-  SuppressionMutex,\n-  SuppressionThread,\n-  SuppressionSignal,\n-  SuppressionLeak,\n-  SuppressionLib,\n-  SuppressionDeadlock,\n-  SuppressionVptrCheck,\n-  SuppressionTypeCount\n-};\n-\n struct Suppression {\n-  SuppressionType type;\n+  const char *type;\n   char *templ;\n-  unsigned hit_count;\n+  atomic_uint32_t hit_count;\n   uptr weight;\n };\n \n class SuppressionContext {\n  public:\n+  // Create new SuppressionContext capable of parsing given suppression types.\n+  SuppressionContext(const char *supprression_types[],\n+                     int suppression_types_num);\n+\n+  void ParseFromFile(const char *filename);\n   void Parse(const char *str);\n-  bool Match(const char* str, SuppressionType type, Suppression **s);\n+\n+  bool Match(const char *str, const char *type, Suppression **s);\n   uptr SuppressionCount() const;\n+  bool HasSuppressionType(const char *type) const;\n   const Suppression *SuppressionAt(uptr i) const;\n   void GetMatched(InternalMmapVector<Suppression *> *matched);\n \n-  // Create a SuppressionContext singleton if it hasn't been created earlier.\n-  // Not thread safe. Must be called early during initialization (but after\n-  // runtime flags are parsed).\n-  static void InitIfNecessary();\n-  // Returns a SuppressionContext singleton.\n-  static SuppressionContext *Get();\n-\n  private:\n-  SuppressionContext() : suppressions_(1), can_parse_(true) {}\n+  static const int kMaxSuppressionTypes = 16;\n+  const char **const suppression_types_;\n+  const int suppression_types_num_;\n+\n   InternalMmapVector<Suppression> suppressions_;\n+  bool has_suppression_type_[kMaxSuppressionTypes];\n   bool can_parse_;\n-\n-  friend class SuppressionContextTest;\n };\n \n-const char *SuppressionTypeString(SuppressionType t);\n-\n-bool TemplateMatch(char *templ, const char *str);\n-\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_SUPPRESSIONS_H"}, {"sha": "0e58d5fed6e4a805ac1696b02a5ad23c3082c2d5", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,32 +9,93 @@\n // run-time libraries.\n //===----------------------------------------------------------------------===//\n \n+#include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_platform.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n #include \"sanitizer_placement_new.h\"\n-#include \"sanitizer_symbolizer.h\"\n+#include \"sanitizer_symbolizer_internal.h\"\n \n namespace __sanitizer {\n \n+AddressInfo::AddressInfo() {\n+  internal_memset(this, 0, sizeof(AddressInfo));\n+  function_offset = kUnknown;\n+}\n+\n+void AddressInfo::Clear() {\n+  InternalFree(module);\n+  InternalFree(function);\n+  InternalFree(file);\n+  internal_memset(this, 0, sizeof(AddressInfo));\n+  function_offset = kUnknown;\n+}\n+\n+void AddressInfo::FillModuleInfo(const char *mod_name, uptr mod_offset) {\n+  module = internal_strdup(mod_name);\n+  module_offset = mod_offset;\n+}\n+\n+SymbolizedStack::SymbolizedStack() : next(nullptr), info() {}\n+\n+SymbolizedStack *SymbolizedStack::New(uptr addr) {\n+  void *mem = InternalAlloc(sizeof(SymbolizedStack));\n+  SymbolizedStack *res = new(mem) SymbolizedStack();\n+  res->info.address = addr;\n+  return res;\n+}\n+\n+void SymbolizedStack::ClearAll() {\n+  info.Clear();\n+  if (next)\n+    next->ClearAll();\n+  InternalFree(this);\n+}\n+\n+DataInfo::DataInfo() {\n+  internal_memset(this, 0, sizeof(DataInfo));\n+}\n+\n+void DataInfo::Clear() {\n+  InternalFree(module);\n+  InternalFree(name);\n+  internal_memset(this, 0, sizeof(DataInfo));\n+}\n+\n Symbolizer *Symbolizer::symbolizer_;\n StaticSpinMutex Symbolizer::init_mu_;\n LowLevelAllocator Symbolizer::symbolizer_allocator_;\n \n-Symbolizer *Symbolizer::Disable() {\n-  CHECK_EQ(0, symbolizer_);\n-  // Initialize a dummy symbolizer.\n-  symbolizer_ = new(symbolizer_allocator_) Symbolizer;\n-  return symbolizer_;\n-}\n-\n void Symbolizer::AddHooks(Symbolizer::StartSymbolizationHook start_hook,\n                           Symbolizer::EndSymbolizationHook end_hook) {\n   CHECK(start_hook_ == 0 && end_hook_ == 0);\n   start_hook_ = start_hook;\n   end_hook_ = end_hook;\n }\n \n-Symbolizer::Symbolizer() : start_hook_(0), end_hook_(0) {}\n+const char *Symbolizer::ModuleNameOwner::GetOwnedCopy(const char *str) {\n+  mu_->CheckLocked();\n+\n+  // 'str' will be the same string multiple times in a row, optimize this case.\n+  if (last_match_ && !internal_strcmp(last_match_, str))\n+    return last_match_;\n+\n+  // FIXME: this is linear search.\n+  // We should optimize this further if this turns out to be a bottleneck later.\n+  for (uptr i = 0; i < storage_.size(); ++i) {\n+    if (!internal_strcmp(storage_[i], str)) {\n+      last_match_ = storage_[i];\n+      return last_match_;\n+    }\n+  }\n+  last_match_ = internal_strdup(str);\n+  storage_.push_back(last_match_);\n+  return last_match_;\n+}\n+\n+Symbolizer::Symbolizer(IntrusiveList<SymbolizerTool> tools)\n+    : module_names_(&mu_), n_modules_(0), modules_fresh_(false), tools_(tools),\n+      start_hook_(0), end_hook_(0) {}\n \n Symbolizer::SymbolizerScope::SymbolizerScope(const Symbolizer *sym)\n     : sym_(sym) {"}, {"sha": "0a443a70115647bf0e3ab82151a6d66570fe49d9", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 86, "deletions": 55, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -17,13 +17,14 @@\n #ifndef SANITIZER_SYMBOLIZER_H\n #define SANITIZER_SYMBOLIZER_H\n \n-#include \"sanitizer_allocator_internal.h\"\n-#include \"sanitizer_internal_defs.h\"\n-#include \"sanitizer_libc.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_mutex.h\"\n \n namespace __sanitizer {\n \n struct AddressInfo {\n+  // Owns all the string members. Storage for them is\n+  // (de)allocated using sanitizer internal allocator.\n   uptr address;\n \n   char *module;\n@@ -37,75 +38,68 @@ struct AddressInfo {\n   int line;\n   int column;\n \n-  AddressInfo() {\n-    internal_memset(this, 0, sizeof(AddressInfo));\n-    function_offset = kUnknown;\n-  }\n-\n+  AddressInfo();\n   // Deletes all strings and resets all fields.\n-  void Clear() {\n-    InternalFree(module);\n-    InternalFree(function);\n-    InternalFree(file);\n-    internal_memset(this, 0, sizeof(AddressInfo));\n-    function_offset = kUnknown;\n-  }\n+  void Clear();\n+  void FillModuleInfo(const char *mod_name, uptr mod_offset);\n+};\n \n-  void FillAddressAndModuleInfo(uptr addr, const char *mod_name,\n-                                uptr mod_offset) {\n-    address = addr;\n-    module = internal_strdup(mod_name);\n-    module_offset = mod_offset;\n-  }\n+// Linked list of symbolized frames (each frame is described by AddressInfo).\n+struct SymbolizedStack {\n+  SymbolizedStack *next;\n+  AddressInfo info;\n+  static SymbolizedStack *New(uptr addr);\n+  // Deletes current, and all subsequent frames in the linked list.\n+  // The object cannot be accessed after the call to this function.\n+  void ClearAll();\n+\n+ private:\n+  SymbolizedStack();\n };\n \n // For now, DataInfo is used to describe global variable.\n struct DataInfo {\n+  // Owns all the string members. Storage for them is\n+  // (de)allocated using sanitizer internal allocator.\n   char *module;\n   uptr module_offset;\n   char *name;\n   uptr start;\n   uptr size;\n \n-  DataInfo() {\n-    internal_memset(this, 0, sizeof(DataInfo));\n-  }\n-\n-  void Clear() {\n-    InternalFree(module);\n-    InternalFree(name);\n-    internal_memset(this, 0, sizeof(DataInfo));\n-  }\n+  DataInfo();\n+  void Clear();\n };\n \n-class Symbolizer {\n+class SymbolizerTool;\n+\n+class Symbolizer final {\n  public:\n   /// Initialize and return platform-specific implementation of symbolizer\n   /// (if it wasn't already initialized).\n   static Symbolizer *GetOrInit();\n-  // Fills at most \"max_frames\" elements of \"frames\" with descriptions\n-  // for a given address (in all inlined functions). Returns the number\n-  // of descriptions actually filled.\n-  virtual uptr SymbolizePC(uptr address, AddressInfo *frames, uptr max_frames) {\n-    return 0;\n-  }\n-  virtual bool SymbolizeData(uptr address, DataInfo *info) {\n-    return false;\n-  }\n-  virtual bool GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n-                                           uptr *module_address) {\n-    return false;\n-  }\n-  virtual bool CanReturnFileLineInfo() {\n-    return false;\n+  // Returns a list of symbolized frames for a given address (containing\n+  // all inlined functions, if necessary).\n+  SymbolizedStack *SymbolizePC(uptr address);\n+  bool SymbolizeData(uptr address, DataInfo *info);\n+\n+  // The module names Symbolizer returns are stable and unique for every given\n+  // module.  It is safe to store and compare them as pointers.\n+  bool GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n+                                   uptr *module_address);\n+  const char *GetModuleNameForPc(uptr pc) {\n+    const char *module_name = nullptr;\n+    uptr unused;\n+    if (GetModuleNameAndOffsetForPC(pc, &module_name, &unused))\n+      return module_name;\n+    return nullptr;\n   }\n+\n   // Release internal caches (if any).\n-  virtual void Flush() {}\n+  void Flush();\n   // Attempts to demangle the provided C++ mangled name.\n-  virtual const char *Demangle(const char *name) {\n-    return name;\n-  }\n-  virtual void PrepareForSandboxing() {}\n+  const char *Demangle(const char *name);\n+  void PrepareForSandboxing();\n \n   // Allow user to install hooks that would be called before/after Symbolizer\n   // does the actual file/line info fetching. Specific sanitizers may need this\n@@ -118,16 +112,53 @@ class Symbolizer {\n                 EndSymbolizationHook end_hook);\n \n  private:\n+  // GetModuleNameAndOffsetForPC has to return a string to the caller.\n+  // Since the corresponding module might get unloaded later, we should create\n+  // our owned copies of the strings that we can safely return.\n+  // ModuleNameOwner does not provide any synchronization, thus calls to\n+  // its method should be protected by |mu_|.\n+  class ModuleNameOwner {\n+   public:\n+    explicit ModuleNameOwner(BlockingMutex *synchronized_by)\n+        : storage_(kInitialCapacity), last_match_(nullptr),\n+          mu_(synchronized_by) {}\n+    const char *GetOwnedCopy(const char *str);\n+\n+   private:\n+    static const uptr kInitialCapacity = 1000;\n+    InternalMmapVector<const char*> storage_;\n+    const char *last_match_;\n+\n+    BlockingMutex *mu_;\n+  } module_names_;\n+\n   /// Platform-specific function for creating a Symbolizer object.\n   static Symbolizer *PlatformInit();\n-  /// Initialize the symbolizer in a disabled state.  Not thread safe.\n-  static Symbolizer *Disable();\n+\n+  bool FindModuleNameAndOffsetForAddress(uptr address, const char **module_name,\n+                                         uptr *module_offset);\n+  LoadedModule *FindModuleForAddress(uptr address);\n+  LoadedModule modules_[kMaxNumberOfModules];\n+  uptr n_modules_;\n+  // If stale, need to reload the modules before looking up addresses.\n+  bool modules_fresh_;\n+\n+  // Platform-specific default demangler, must not return nullptr.\n+  const char *PlatformDemangle(const char *name);\n+  void PlatformPrepareForSandboxing();\n \n   static Symbolizer *symbolizer_;\n   static StaticSpinMutex init_mu_;\n \n- protected:\n-  Symbolizer();\n+  // Mutex locked from public methods of |Symbolizer|, so that the internals\n+  // (including individual symbolizer tools and platform-specific methods) are\n+  // always synchronized.\n+  BlockingMutex mu_;\n+\n+  typedef IntrusiveList<SymbolizerTool>::Iterator Iterator;\n+  IntrusiveList<SymbolizerTool> tools_;\n+\n+  explicit Symbolizer(IntrusiveList<SymbolizerTool> tools);\n \n   static LowLevelAllocator symbolizer_allocator_;\n "}, {"sha": "a87964b4636134ef6b60f2438b7f390122718cfe", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_internal.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -0,0 +1,149 @@\n+//===-- sanitizer_symbolizer_internal.h -------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Header for internal classes and functions to be used by implementations of\n+// symbolizers.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_SYMBOLIZER_INTERNAL_H\n+#define SANITIZER_SYMBOLIZER_INTERNAL_H\n+\n+#include \"sanitizer_symbolizer.h\"\n+\n+namespace __sanitizer {\n+\n+// Parsing helpers, 'str' is searched for delimiter(s) and a string or uptr\n+// is extracted. When extracting a string, a newly allocated (using\n+// InternalAlloc) and null-terminataed buffer is returned. They return a pointer\n+// to the next characted after the found delimiter.\n+const char *ExtractToken(const char *str, const char *delims, char **result);\n+const char *ExtractInt(const char *str, const char *delims, int *result);\n+const char *ExtractUptr(const char *str, const char *delims, uptr *result);\n+const char *ExtractTokenUpToDelimiter(const char *str, const char *delimiter,\n+                                      char **result);\n+\n+const char *DemangleCXXABI(const char *name);\n+\n+// SymbolizerTool is an interface that is implemented by individual \"tools\"\n+// that can perform symbolication (external llvm-symbolizer, libbacktrace,\n+// Windows DbgHelp symbolizer, etc.).\n+class SymbolizerTool {\n+ public:\n+  // The main |Symbolizer| class implements a \"fallback chain\" of symbolizer\n+  // tools. In a request to symbolize an address, if one tool returns false,\n+  // the next tool in the chain will be tried.\n+  SymbolizerTool *next;\n+\n+  SymbolizerTool() : next(nullptr) { }\n+\n+  // Can't declare pure virtual functions in sanitizer runtimes:\n+  // __cxa_pure_virtual might be unavailable.\n+\n+  // The |stack| parameter is inout. It is pre-filled with the address,\n+  // module base and module offset values and is to be used to construct\n+  // other stack frames.\n+  virtual bool SymbolizePC(uptr addr, SymbolizedStack *stack) {\n+    UNIMPLEMENTED();\n+  }\n+\n+  // The |info| parameter is inout. It is pre-filled with the module base\n+  // and module offset values.\n+  virtual bool SymbolizeData(uptr addr, DataInfo *info) {\n+    UNIMPLEMENTED();\n+  }\n+\n+  virtual void Flush() {}\n+\n+  // Return nullptr to fallback to the default platform-specific demangler.\n+  virtual const char *Demangle(const char *name) {\n+    return nullptr;\n+  }\n+};\n+\n+// SymbolizerProcess encapsulates communication between the tool and\n+// external symbolizer program, running in a different subprocess.\n+// SymbolizerProcess may not be used from two threads simultaneously.\n+class SymbolizerProcess {\n+ public:\n+  explicit SymbolizerProcess(const char *path, bool use_forkpty = false);\n+  const char *SendCommand(const char *command);\n+\n+ protected:\n+  virtual bool ReachedEndOfOutput(const char *buffer, uptr length) const {\n+    UNIMPLEMENTED();\n+  }\n+\n+  /// The maximum number of arguments required to invoke a tool process.\n+  enum { kArgVMax = 6 };\n+\n+  /// Fill in an argv array to invoke the child process.\n+  virtual void GetArgV(const char *path_to_binary,\n+                       const char *(&argv)[kArgVMax]) const {\n+    UNIMPLEMENTED();\n+  }\n+\n+  virtual bool ReadFromSymbolizer(char *buffer, uptr max_length);\n+\n+ private:\n+  bool Restart();\n+  const char *SendCommandImpl(const char *command);\n+  bool WriteToSymbolizer(const char *buffer, uptr length);\n+  bool StartSymbolizerSubprocess();\n+\n+  const char *path_;\n+  fd_t input_fd_;\n+  fd_t output_fd_;\n+\n+  static const uptr kBufferSize = 16 * 1024;\n+  char buffer_[kBufferSize];\n+\n+  static const uptr kMaxTimesRestarted = 5;\n+  static const int kSymbolizerStartupTimeMillis = 10;\n+  uptr times_restarted_;\n+  bool failed_to_start_;\n+  bool reported_invalid_path_;\n+  bool use_forkpty_;\n+};\n+\n+class LLVMSymbolizerProcess;\n+\n+// This tool invokes llvm-symbolizer in a subprocess. It should be as portable\n+// as the llvm-symbolizer tool is.\n+class LLVMSymbolizer : public SymbolizerTool {\n+ public:\n+  explicit LLVMSymbolizer(const char *path, LowLevelAllocator *allocator);\n+\n+  bool SymbolizePC(uptr addr, SymbolizedStack *stack) override;\n+\n+  bool SymbolizeData(uptr addr, DataInfo *info) override;\n+\n+ private:\n+  const char *SendCommand(bool is_data, const char *module_name,\n+                          uptr module_offset);\n+\n+  LLVMSymbolizerProcess *symbolizer_process_;\n+  static const uptr kBufferSize = 16 * 1024;\n+  char buffer_[kBufferSize];\n+};\n+\n+// Parses one or more two-line strings in the following format:\n+//   <function_name>\n+//   <file_name>:<line_number>[:<column_number>]\n+// Used by LLVMSymbolizer, Addr2LinePool and InternalSymbolizer, since all of\n+// them use the same output format.  Returns true if any useful debug\n+// information was found.\n+void ParseSymbolizePCOutput(const char *str, SymbolizedStack *res);\n+\n+// Parses a two-line string in the following format:\n+//   <symbol_name>\n+//   <start_address> <size>\n+// Used by LLVMSymbolizer and InternalSymbolizer.\n+void ParseSymbolizeDataOutput(const char *str, DataInfo *info);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_SYMBOLIZER_INTERNAL_H"}, {"sha": "b5bcfdbc089b80938ab2cec2ff050e09dec02ff4", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.cc", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -31,6 +31,8 @@\n \n namespace __sanitizer {\n \n+static char *DemangleAlloc(const char *name, bool always_alloc);\n+\n #if SANITIZER_LIBBACKTRACE\n \n namespace {\n@@ -81,52 +83,57 @@ char *CplusV3Demangle(const char *name) {\n }\n # endif  // SANITIZER_CP_DEMANGLE\n \n-struct SymbolizeCodeData {\n-  AddressInfo *frames;\n-  uptr n_frames;\n-  uptr max_frames;\n-  const char *module_name;\n-  uptr module_offset;\n+struct SymbolizeCodeCallbackArg {\n+  SymbolizedStack *first;\n+  SymbolizedStack *last;\n+  uptr frames_symbolized;\n+\n+  AddressInfo *get_new_frame(uintptr_t addr) {\n+    CHECK(last);\n+    if (frames_symbolized > 0) {\n+      SymbolizedStack *cur = SymbolizedStack::New(addr);\n+      AddressInfo *info = &cur->info;\n+      info->FillModuleInfo(first->info.module, first->info.module_offset);\n+      last->next = cur;\n+      last = cur;\n+    }\n+    CHECK_EQ(addr, first->info.address);\n+    CHECK_EQ(addr, last->info.address);\n+    return &last->info;\n+  }\n };\n \n extern \"C\" {\n static int SymbolizeCodePCInfoCallback(void *vdata, uintptr_t addr,\n                                        const char *filename, int lineno,\n                                        const char *function) {\n-  SymbolizeCodeData *cdata = (SymbolizeCodeData *)vdata;\n+  SymbolizeCodeCallbackArg *cdata = (SymbolizeCodeCallbackArg *)vdata;\n   if (function) {\n-    AddressInfo *info = &cdata->frames[cdata->n_frames++];\n-    info->Clear();\n-    info->FillAddressAndModuleInfo(addr, cdata->module_name,\n-                                   cdata->module_offset);\n-    info->function = LibbacktraceSymbolizer::Demangle(function, true);\n+    AddressInfo *info = cdata->get_new_frame(addr);\n+    info->function = DemangleAlloc(function, /*always_alloc*/ true);\n     if (filename)\n       info->file = internal_strdup(filename);\n     info->line = lineno;\n-    if (cdata->n_frames == cdata->max_frames)\n-      return 1;\n+    cdata->frames_symbolized++;\n   }\n   return 0;\n }\n \n static void SymbolizeCodeCallback(void *vdata, uintptr_t addr,\n                                   const char *symname, uintptr_t, uintptr_t) {\n-  SymbolizeCodeData *cdata = (SymbolizeCodeData *)vdata;\n+  SymbolizeCodeCallbackArg *cdata = (SymbolizeCodeCallbackArg *)vdata;\n   if (symname) {\n-    AddressInfo *info = &cdata->frames[0];\n-    info->Clear();\n-    info->FillAddressAndModuleInfo(addr, cdata->module_name,\n-                                   cdata->module_offset);\n-    info->function = LibbacktraceSymbolizer::Demangle(symname, true);\n-    cdata->n_frames = 1;\n+    AddressInfo *info = cdata->get_new_frame(addr);\n+    info->function = DemangleAlloc(symname, /*always_alloc*/ true);\n+    cdata->frames_symbolized++;\n   }\n }\n \n static void SymbolizeDataCallback(void *vdata, uintptr_t, const char *symname,\n                                   uintptr_t symval, uintptr_t symsize) {\n   DataInfo *info = (DataInfo *)vdata;\n   if (symname && symval) {\n-    info->name = LibbacktraceSymbolizer::Demangle(symname, true);\n+    info->name = DemangleAlloc(symname, /*always_alloc*/ true);\n     info->start = symval;\n     info->size = symsize;\n   }\n@@ -146,23 +153,18 @@ LibbacktraceSymbolizer *LibbacktraceSymbolizer::get(LowLevelAllocator *alloc) {\n   return new(*alloc) LibbacktraceSymbolizer(state);\n }\n \n-uptr LibbacktraceSymbolizer::SymbolizeCode(uptr addr, AddressInfo *frames,\n-                                           uptr max_frames,\n-                                           const char *module_name,\n-                                           uptr module_offset) {\n-  SymbolizeCodeData data;\n-  data.frames = frames;\n-  data.n_frames = 0;\n-  data.max_frames = max_frames;\n-  data.module_name = module_name;\n-  data.module_offset = module_offset;\n+bool LibbacktraceSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n+  SymbolizeCodeCallbackArg data;\n+  data.first = stack;\n+  data.last = stack;\n+  data.frames_symbolized = 0;\n   backtrace_pcinfo((backtrace_state *)state_, addr, SymbolizeCodePCInfoCallback,\n                    ErrorCallback, &data);\n-  if (data.n_frames)\n-    return data.n_frames;\n+  if (data.frames_symbolized > 0)\n+    return true;\n   backtrace_syminfo((backtrace_state *)state_, addr, SymbolizeCodeCallback,\n                     ErrorCallback, &data);\n-  return data.n_frames;\n+  return (data.frames_symbolized > 0);\n }\n \n bool LibbacktraceSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n@@ -177,12 +179,9 @@ LibbacktraceSymbolizer *LibbacktraceSymbolizer::get(LowLevelAllocator *alloc) {\n   return 0;\n }\n \n-uptr LibbacktraceSymbolizer::SymbolizeCode(uptr addr, AddressInfo *frames,\n-                                           uptr max_frames,\n-                                           const char *module_name,\n-                                           uptr module_offset) {\n+bool LibbacktraceSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   (void)state_;\n-  return 0;\n+  return false;\n }\n \n bool LibbacktraceSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n@@ -191,7 +190,7 @@ bool LibbacktraceSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n \n #endif  // SANITIZER_LIBBACKTRACE\n \n-char *LibbacktraceSymbolizer::Demangle(const char *name, bool always_alloc) {\n+static char *DemangleAlloc(const char *name, bool always_alloc) {\n #if SANITIZER_LIBBACKTRACE && SANITIZER_CP_DEMANGLE\n   if (char *demangled = CplusV3Demangle(name))\n     return demangled;\n@@ -201,4 +200,8 @@ char *LibbacktraceSymbolizer::Demangle(const char *name, bool always_alloc) {\n   return 0;\n }\n \n+const char *LibbacktraceSymbolizer::Demangle(const char *name) {\n+  return DemangleAlloc(name, /*always_alloc*/ false);\n+}\n+\n }  // namespace __sanitizer"}, {"sha": "ab1d6f9916346cf30dfbd13db2b933e92393ce24", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -14,7 +14,8 @@\n \n #include \"sanitizer_platform.h\"\n #include \"sanitizer_common.h\"\n-#include \"sanitizer_symbolizer.h\"\n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_symbolizer_internal.h\"\n \n #ifndef SANITIZER_LIBBACKTRACE\n # define SANITIZER_LIBBACKTRACE 0\n@@ -26,17 +27,16 @@\n \n namespace __sanitizer {\n \n-class LibbacktraceSymbolizer {\n+class LibbacktraceSymbolizer : public SymbolizerTool {\n  public:\n   static LibbacktraceSymbolizer *get(LowLevelAllocator *alloc);\n \n-  uptr SymbolizeCode(uptr addr, AddressInfo *frames, uptr max_frames,\n-                     const char *module_name, uptr module_offset);\n+  bool SymbolizePC(uptr addr, SymbolizedStack *stack) override;\n \n-  bool SymbolizeData(uptr addr, DataInfo *info);\n+  bool SymbolizeData(uptr addr, DataInfo *info) override;\n \n   // May return NULL if demangling failed.\n-  static char *Demangle(const char *name, bool always_alloc = false);\n+  const char *Demangle(const char *name) override;\n \n  private:\n   explicit LibbacktraceSymbolizer(void *state) : state_(state) {}"}, {"sha": "4264b5e3ddc64c666b2e7773f7b552f38c1378cf", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cc", "status": "modified", "additions": 404, "deletions": 4, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "patch": "@@ -9,18 +9,418 @@\n // run-time libraries.\n //===----------------------------------------------------------------------===//\n \n+#include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_internal_defs.h\"\n-#include \"sanitizer_symbolizer.h\"\n+#include \"sanitizer_symbolizer_internal.h\"\n \n namespace __sanitizer {\n \n+const char *ExtractToken(const char *str, const char *delims, char **result) {\n+  uptr prefix_len = internal_strcspn(str, delims);\n+  *result = (char*)InternalAlloc(prefix_len + 1);\n+  internal_memcpy(*result, str, prefix_len);\n+  (*result)[prefix_len] = '\\0';\n+  const char *prefix_end = str + prefix_len;\n+  if (*prefix_end != '\\0') prefix_end++;\n+  return prefix_end;\n+}\n+\n+const char *ExtractInt(const char *str, const char *delims, int *result) {\n+  char *buff;\n+  const char *ret = ExtractToken(str, delims, &buff);\n+  if (buff != 0) {\n+    *result = (int)internal_atoll(buff);\n+  }\n+  InternalFree(buff);\n+  return ret;\n+}\n+\n+const char *ExtractUptr(const char *str, const char *delims, uptr *result) {\n+  char *buff;\n+  const char *ret = ExtractToken(str, delims, &buff);\n+  if (buff != 0) {\n+    *result = (uptr)internal_atoll(buff);\n+  }\n+  InternalFree(buff);\n+  return ret;\n+}\n+\n+const char *ExtractTokenUpToDelimiter(const char *str, const char *delimiter,\n+                                      char **result) {\n+  const char *found_delimiter = internal_strstr(str, delimiter);\n+  uptr prefix_len =\n+      found_delimiter ? found_delimiter - str : internal_strlen(str);\n+  *result = (char *)InternalAlloc(prefix_len + 1);\n+  internal_memcpy(*result, str, prefix_len);\n+  (*result)[prefix_len] = '\\0';\n+  const char *prefix_end = str + prefix_len;\n+  if (*prefix_end != '\\0') prefix_end += internal_strlen(delimiter);\n+  return prefix_end;\n+}\n+\n+SymbolizedStack *Symbolizer::SymbolizePC(uptr addr) {\n+  BlockingMutexLock l(&mu_);\n+  const char *module_name;\n+  uptr module_offset;\n+  SymbolizedStack *res = SymbolizedStack::New(addr);\n+  if (!FindModuleNameAndOffsetForAddress(addr, &module_name, &module_offset))\n+    return res;\n+  // Always fill data about module name and offset.\n+  res->info.FillModuleInfo(module_name, module_offset);\n+  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n+    auto *tool = iter.next();\n+    SymbolizerScope sym_scope(this);\n+    if (tool->SymbolizePC(addr, res)) {\n+      return res;\n+    }\n+  }\n+  return res;\n+}\n+\n+bool Symbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n+  BlockingMutexLock l(&mu_);\n+  const char *module_name;\n+  uptr module_offset;\n+  if (!FindModuleNameAndOffsetForAddress(addr, &module_name, &module_offset))\n+    return false;\n+  info->Clear();\n+  info->module = internal_strdup(module_name);\n+  info->module_offset = module_offset;\n+  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n+    auto *tool = iter.next();\n+    SymbolizerScope sym_scope(this);\n+    if (tool->SymbolizeData(addr, info)) {\n+      return true;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool Symbolizer::GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n+                                             uptr *module_address) {\n+  BlockingMutexLock l(&mu_);\n+  const char *internal_module_name = nullptr;\n+  if (!FindModuleNameAndOffsetForAddress(pc, &internal_module_name,\n+                                         module_address))\n+    return false;\n+\n+  if (module_name)\n+    *module_name = module_names_.GetOwnedCopy(internal_module_name);\n+  return true;\n+}\n+\n+void Symbolizer::Flush() {\n+  BlockingMutexLock l(&mu_);\n+  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n+    auto *tool = iter.next();\n+    SymbolizerScope sym_scope(this);\n+    tool->Flush();\n+  }\n+}\n+\n+const char *Symbolizer::Demangle(const char *name) {\n+  BlockingMutexLock l(&mu_);\n+  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n+    auto *tool = iter.next();\n+    SymbolizerScope sym_scope(this);\n+    if (const char *demangled = tool->Demangle(name))\n+      return demangled;\n+  }\n+  return PlatformDemangle(name);\n+}\n+\n+void Symbolizer::PrepareForSandboxing() {\n+  BlockingMutexLock l(&mu_);\n+  PlatformPrepareForSandboxing();\n+}\n+\n+bool Symbolizer::FindModuleNameAndOffsetForAddress(uptr address,\n+                                                   const char **module_name,\n+                                                   uptr *module_offset) {\n+  LoadedModule *module = FindModuleForAddress(address);\n+  if (module == 0)\n+    return false;\n+  *module_name = module->full_name();\n+  *module_offset = address - module->base_address();\n+  return true;\n+}\n+\n+LoadedModule *Symbolizer::FindModuleForAddress(uptr address) {\n+  bool modules_were_reloaded = false;\n+  if (!modules_fresh_) {\n+    for (uptr i = 0; i < n_modules_; i++)\n+      modules_[i].clear();\n+    n_modules_ =\n+        GetListOfModules(modules_, kMaxNumberOfModules, /* filter */ nullptr);\n+    CHECK_GT(n_modules_, 0);\n+    CHECK_LT(n_modules_, kMaxNumberOfModules);\n+    modules_fresh_ = true;\n+    modules_were_reloaded = true;\n+  }\n+  for (uptr i = 0; i < n_modules_; i++) {\n+    if (modules_[i].containsAddress(address)) {\n+      return &modules_[i];\n+    }\n+  }\n+  // Reload the modules and look up again, if we haven't tried it yet.\n+  if (!modules_were_reloaded) {\n+    // FIXME: set modules_fresh_ from dlopen()/dlclose() interceptors.\n+    // It's too aggressive to reload the list of modules each time we fail\n+    // to find a module for a given address.\n+    modules_fresh_ = false;\n+    return FindModuleForAddress(address);\n+  }\n+  return 0;\n+}\n+\n Symbolizer *Symbolizer::GetOrInit() {\n   SpinMutexLock l(&init_mu_);\n   if (symbolizer_)\n     return symbolizer_;\n-  if ((symbolizer_ = PlatformInit()))\n-    return symbolizer_;\n-  return Disable();\n+  symbolizer_ = PlatformInit();\n+  CHECK(symbolizer_);\n+  return symbolizer_;\n+}\n+\n+// For now we assume the following protocol:\n+// For each request of the form\n+//   <module_name> <module_offset>\n+// passed to STDIN, external symbolizer prints to STDOUT response:\n+//   <function_name>\n+//   <file_name>:<line_number>:<column_number>\n+//   <function_name>\n+//   <file_name>:<line_number>:<column_number>\n+//   ...\n+//   <empty line>\n+class LLVMSymbolizerProcess : public SymbolizerProcess {\n+ public:\n+  explicit LLVMSymbolizerProcess(const char *path) : SymbolizerProcess(path) {}\n+\n+ private:\n+  bool ReachedEndOfOutput(const char *buffer, uptr length) const override {\n+    // Empty line marks the end of llvm-symbolizer output.\n+    return length >= 2 && buffer[length - 1] == '\\n' &&\n+           buffer[length - 2] == '\\n';\n+  }\n+\n+  void GetArgV(const char *path_to_binary,\n+               const char *(&argv)[kArgVMax]) const override {\n+#if defined(__x86_64h__)\n+    const char* const kSymbolizerArch = \"--default-arch=x86_64h\";\n+#elif defined(__x86_64__)\n+    const char* const kSymbolizerArch = \"--default-arch=x86_64\";\n+#elif defined(__i386__)\n+    const char* const kSymbolizerArch = \"--default-arch=i386\";\n+#elif defined(__powerpc64__) && defined(__BIG_ENDIAN__)\n+    const char* const kSymbolizerArch = \"--default-arch=powerpc64\";\n+#elif defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)\n+    const char* const kSymbolizerArch = \"--default-arch=powerpc64le\";\n+#else\n+    const char* const kSymbolizerArch = \"--default-arch=unknown\";\n+#endif\n+\n+    const char *const inline_flag = common_flags()->symbolize_inline_frames\n+                                        ? \"--inlining=true\"\n+                                        : \"--inlining=false\";\n+    int i = 0;\n+    argv[i++] = path_to_binary;\n+    argv[i++] = inline_flag;\n+    argv[i++] = kSymbolizerArch;\n+    argv[i++] = nullptr;\n+  }\n+};\n+\n+LLVMSymbolizer::LLVMSymbolizer(const char *path, LowLevelAllocator *allocator)\n+    : symbolizer_process_(new(*allocator) LLVMSymbolizerProcess(path)) {}\n+\n+// Parse a <file>:<line>[:<column>] buffer. The file path may contain colons on\n+// Windows, so extract tokens from the right hand side first. The column info is\n+// also optional.\n+static const char *ParseFileLineInfo(AddressInfo *info, const char *str) {\n+  char *file_line_info = 0;\n+  str = ExtractToken(str, \"\\n\", &file_line_info);\n+  CHECK(file_line_info);\n+  // Parse the last :<int>, which must be there.\n+  char *last_colon = internal_strrchr(file_line_info, ':');\n+  CHECK(last_colon);\n+  int line_or_column = internal_atoll(last_colon + 1);\n+  // Truncate the string at the last colon and find the next-to-last colon.\n+  *last_colon = '\\0';\n+  last_colon = internal_strrchr(file_line_info, ':');\n+  if (last_colon && IsDigit(last_colon[1])) {\n+    // If the second-to-last colon is followed by a digit, it must be the line\n+    // number, and the previous parsed number was a column.\n+    info->line = internal_atoll(last_colon + 1);\n+    info->column = line_or_column;\n+    *last_colon = '\\0';\n+  } else {\n+    // Otherwise, we have line info but no column info.\n+    info->line = line_or_column;\n+    info->column = 0;\n+  }\n+  ExtractToken(file_line_info, \"\", &info->file);\n+  InternalFree(file_line_info);\n+  return str;\n+}\n+\n+// Parses one or more two-line strings in the following format:\n+//   <function_name>\n+//   <file_name>:<line_number>[:<column_number>]\n+// Used by LLVMSymbolizer, Addr2LinePool and InternalSymbolizer, since all of\n+// them use the same output format.\n+void ParseSymbolizePCOutput(const char *str, SymbolizedStack *res) {\n+  bool top_frame = true;\n+  SymbolizedStack *last = res;\n+  while (true) {\n+    char *function_name = 0;\n+    str = ExtractToken(str, \"\\n\", &function_name);\n+    CHECK(function_name);\n+    if (function_name[0] == '\\0') {\n+      // There are no more frames.\n+      InternalFree(function_name);\n+      break;\n+    }\n+    SymbolizedStack *cur;\n+    if (top_frame) {\n+      cur = res;\n+      top_frame = false;\n+    } else {\n+      cur = SymbolizedStack::New(res->info.address);\n+      cur->info.FillModuleInfo(res->info.module, res->info.module_offset);\n+      last->next = cur;\n+      last = cur;\n+    }\n+\n+    AddressInfo *info = &cur->info;\n+    info->function = function_name;\n+    str = ParseFileLineInfo(info, str);\n+\n+    // Functions and filenames can be \"??\", in which case we write 0\n+    // to address info to mark that names are unknown.\n+    if (0 == internal_strcmp(info->function, \"??\")) {\n+      InternalFree(info->function);\n+      info->function = 0;\n+    }\n+    if (0 == internal_strcmp(info->file, \"??\")) {\n+      InternalFree(info->file);\n+      info->file = 0;\n+    }\n+  }\n+}\n+\n+// Parses a two-line string in the following format:\n+//   <symbol_name>\n+//   <start_address> <size>\n+// Used by LLVMSymbolizer and InternalSymbolizer.\n+void ParseSymbolizeDataOutput(const char *str, DataInfo *info) {\n+  str = ExtractToken(str, \"\\n\", &info->name);\n+  str = ExtractUptr(str, \" \", &info->start);\n+  str = ExtractUptr(str, \"\\n\", &info->size);\n+}\n+\n+bool LLVMSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n+  if (const char *buf = SendCommand(/*is_data*/ false, stack->info.module,\n+                                    stack->info.module_offset)) {\n+    ParseSymbolizePCOutput(buf, stack);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool LLVMSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n+  if (const char *buf =\n+          SendCommand(/*is_data*/ true, info->module, info->module_offset)) {\n+    ParseSymbolizeDataOutput(buf, info);\n+    info->start += (addr - info->module_offset); // Add the base address.\n+    return true;\n+  }\n+  return false;\n+}\n+\n+const char *LLVMSymbolizer::SendCommand(bool is_data, const char *module_name,\n+                                        uptr module_offset) {\n+  CHECK(module_name);\n+  internal_snprintf(buffer_, kBufferSize, \"%s\\\"%s\\\" 0x%zx\\n\",\n+                    is_data ? \"DATA \" : \"\", module_name, module_offset);\n+  return symbolizer_process_->SendCommand(buffer_);\n+}\n+\n+SymbolizerProcess::SymbolizerProcess(const char *path, bool use_forkpty)\n+    : path_(path),\n+      input_fd_(kInvalidFd),\n+      output_fd_(kInvalidFd),\n+      times_restarted_(0),\n+      failed_to_start_(false),\n+      reported_invalid_path_(false),\n+      use_forkpty_(use_forkpty) {\n+  CHECK(path_);\n+  CHECK_NE(path_[0], '\\0');\n+}\n+\n+const char *SymbolizerProcess::SendCommand(const char *command) {\n+  for (; times_restarted_ < kMaxTimesRestarted; times_restarted_++) {\n+    // Start or restart symbolizer if we failed to send command to it.\n+    if (const char *res = SendCommandImpl(command))\n+      return res;\n+    Restart();\n+  }\n+  if (!failed_to_start_) {\n+    Report(\"WARNING: Failed to use and restart external symbolizer!\\n\");\n+    failed_to_start_ = true;\n+  }\n+  return 0;\n+}\n+\n+const char *SymbolizerProcess::SendCommandImpl(const char *command) {\n+  if (input_fd_ == kInvalidFd || output_fd_ == kInvalidFd)\n+      return 0;\n+  if (!WriteToSymbolizer(command, internal_strlen(command)))\n+      return 0;\n+  if (!ReadFromSymbolizer(buffer_, kBufferSize))\n+      return 0;\n+  return buffer_;\n+}\n+\n+bool SymbolizerProcess::Restart() {\n+  if (input_fd_ != kInvalidFd)\n+    CloseFile(input_fd_);\n+  if (output_fd_ != kInvalidFd)\n+    CloseFile(output_fd_);\n+  return StartSymbolizerSubprocess();\n+}\n+\n+bool SymbolizerProcess::ReadFromSymbolizer(char *buffer, uptr max_length) {\n+  if (max_length == 0)\n+    return true;\n+  uptr read_len = 0;\n+  while (true) {\n+    uptr just_read = 0;\n+    bool success = ReadFromFile(input_fd_, buffer + read_len,\n+                                max_length - read_len - 1, &just_read);\n+    // We can't read 0 bytes, as we don't expect external symbolizer to close\n+    // its stdout.\n+    if (!success || just_read == 0) {\n+      Report(\"WARNING: Can't read from symbolizer at fd %d\\n\", input_fd_);\n+      return false;\n+    }\n+    read_len += just_read;\n+    if (ReachedEndOfOutput(buffer, read_len))\n+      break;\n+  }\n+  buffer[read_len] = '\\0';\n+  return true;\n+}\n+\n+bool SymbolizerProcess::WriteToSymbolizer(const char *buffer, uptr length) {\n+  if (length == 0)\n+    return true;\n+  uptr write_len = 0;\n+  bool success = WriteToFile(output_fd_, buffer, length, &write_len);\n+  if (!success || write_len != length) {\n+    Report(\"WARNING: Can't write to symbolizer at fd %d\\n\", output_fd_);\n+    return false;\n+  }\n+  return true;\n }\n \n }  // namespace __sanitizer"}, {"sha": "d3495348e756e10c91099c7ad29a94aed44522ff", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "240c538d93d4fafd0f9fdbf504caf02ff9eb4215", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "a67ae36a4d84e6900077266e8449865f2bcca088", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 216, "deletions": 513, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "bb59f803285cea0778838bd7dc05620edd4f9766", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 241, "deletions": 85, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "3bc50d972a4c432523e3899764d83f74efd5bb75", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_generic.inc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "64d6322651a2830ee0a20fe8f30a33119666e5a6", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_aarch64.inc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_aarch64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_aarch64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_aarch64.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "8d5f1ea39882607529dfc9cce5698582410b499c", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "e05c7be079912527ace4c2cc33868d67bbb396d1", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "e4f8c0c535e87cd6efdab7c3c3ffb0d4f6cd5585", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "408c21c913bbbc36a2c6dfb0e85349789bb75c05", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc", "status": "renamed", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_unwind_posix_libcdep.cc"}, {"sha": "bb84249b243cef7359619c00c49e1d5e654c0ec5", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 354, "deletions": 122, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "5c732cb50c314721c664bf6945886fce488c8322", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "bd196073e03fa9c3c79f805777ffb4d93187a447", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "d925c9cfd83db4754df960126eaf3f2ce53cb81d", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "21b68356e7bcbb777f99dd02b001b8d85783c9be", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "8f75a28200d49fa1e6fa1cf132a19ab9a64c67a3", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "4d9236c9903689c31435a7b4e03d47965b65e7d8", "filename": "libsanitizer/tsan/tsan_fd.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_fd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_fd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "3e89375187dbc684aabc607f635513ad95972476", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 58, "deletions": 65, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "3d58ff3793ef89c0f8e4b5c70918c1aa198e2891", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 6, "deletions": 59, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "822e560b6223895f0502d994855bccd8bac2dd6a", "filename": "libsanitizer/tsan/tsan_flags.inc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "16465b96b6c66694042abcb1a17e00fadeea2da5", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 288, "deletions": 284, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "4a246c647a066eabd8fb6b6152866dd12a682423", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "ee9a627076ba394ca715ebb420c97ad2e1561803", "filename": "libsanitizer/tsan/tsan_interface.cc", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "4ff6fa1831ee6459d1c91bb2c7ea9dfe6f0bf9c0", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "19ff4050abc438538d62b1f0e8f1c833fa457cab", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "0ded1aa10991d2ac829137dab1a2598b4fa2550b", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "67a91aa341a4581a2a46703a06f840cc6af8ed1d", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "934ccc3ef9c80847491c403e5b878184796561ec", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "04e52031dd31962b125d948f80c7b96881348ffd", "filename": "libsanitizer/tsan/tsan_interface_java.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "f299dfc59b693c018c0e190b22a1f821b8cce3fe", "filename": "libsanitizer/tsan/tsan_md5.cc", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_md5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_md5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_md5.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "c8a5a6a264a8bc0c431e8282dfb113a718173c5a", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "da7cf211940a61eb5843caeab6fc3ddba1466a4a", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "3d3f6cc82b9aeadd166770f0ee4fbcb30cbfc63a", "filename": "libsanitizer/tsan/tsan_mutex.cc", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "9960eee9bc8d9f98344eda14f1f1edacece9f8d8", "filename": "libsanitizer/tsan/tsan_mutex.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "d5406ae9f12849b9bf955cc4527c4f8fb762def6", "filename": "libsanitizer/tsan/tsan_mutexset.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutexset.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "ad4ed449751b50dd07b0e17aedc368815ca1ca92", "filename": "libsanitizer/tsan/tsan_new_delete.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_new_delete.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "07d11e572ff271fc27fd7eeb5794171821ca9f62", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 102, "deletions": 15, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "f409a8b221c0090e88e97f89a715c53ccfa8e521", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "a2ae26f5341e64eff85c3cb9b7c418f1146e74c8", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "ccea22ed66e30c57320e2f1183b61078715cb503", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "a84738dff6e86e84b9c61b565a1caa80140741ca", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "68924edb54790ae3e3c2284c82fba9313794a449", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "e7bdfb51884fddafcf37e840c6f923785df82c54", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 96, "deletions": 100, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "34b009b15d78c43b9a3f3aa63cca75526e70972d", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "deb7722f521ed7dc71005de2e024ef3a7dd9a73d", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "d0d1fbaf45ac526fd0c99468b6556e9769819323", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 121, "deletions": 121, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "9d7e2d3028e9408826a133d778f6ec993d1f298d", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "5eccca69312f45857d88438e1fab18fb947b93f7", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "002570f42f12d99fae50d93e9b4e28adff1cadf0", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "5c8d03dddd24d0dfe4b329ef705233742881cb19", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 69, "deletions": 47, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "58951975075940e3ef8d46892f44b81670c39d7a", "filename": "libsanitizer/tsan/tsan_suppressions.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "0e54562e385f9e5439a0353c461a9fdf8fee5f1d", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "a859f6318b006f1de4b31b14f1ff9870f7a68a15", "filename": "libsanitizer/tsan/tsan_symbolize.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "91ad8c8b2284ac038eda9eb35e4f79fd3d17fc7c", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "50bc872275dee6bed010c00e93be0775ad0c6dc4", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "a27efa9fd7a9456679d5195337c5a7ce38049c86", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "2ea7428381817efb700d2383a643295b3f293a76", "filename": "libsanitizer/tsan/tsan_update_shadow_word_inl.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "29b4115389ff64f53246c68578aed7bb1f370184", "filename": "libsanitizer/ubsan/Makefile.am", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.am?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "3b5cfbf3778a634115d04423e8dc6d5b131de194", "filename": "libsanitizer/ubsan/Makefile.in", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.in?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "935d82c5079218937ddcdc6957962e2e49430aa4", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "1197f837f750b7ba6c7be75247b2f31f7d50d062", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 84, "deletions": 51, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "7103d5229536f427fa5305050b1a210df6ca720e", "filename": "libsanitizer/ubsan/ubsan_diag.h", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_diag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_diag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "4e7db7a6a5710eaafc93050d4475380972dda5af", "filename": "libsanitizer/ubsan/ubsan_flags.cc", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "2604b6b00ccd49dad13b00d6c0bac3baa2392cd3", "filename": "libsanitizer/ubsan/ubsan_flags.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "170777adf26de3a927ab575e327e21deb418cfd6", "filename": "libsanitizer/ubsan/ubsan_flags.inc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.inc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "8530fcffc88bfa49cc83a76af9c13539056a6b2d", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 147, "deletions": 49, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "668535868e94301aa97452205b4f4bb7ca648e75", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "b50b4d4636dcd28513ec0472c227b14171c635f6", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.cc", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "b1486864298ece7144cdfb2cffcf81a64be958f6", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "5da4122c07abdab6aac54c1938e11c6af5d1fde9", "filename": "libsanitizer/ubsan/ubsan_init.cc", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "6a8366f82bf5b19913687454e7da17852f35a0dd", "filename": "libsanitizer/ubsan/ubsan_init.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_init.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_init.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "1630fd724fb0b38f45e294cff27485295d6d6af2", "filename": "libsanitizer/ubsan/ubsan_init_standalone.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_init_standalone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_init_standalone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init_standalone.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "999bf8154938c21dbf24e12cf8e4a780fee24d50", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "65160aa4abac8e3c36b6013353f6b99af71cb1be", "filename": "libsanitizer/ubsan/ubsan_type_hash.cc", "status": "modified", "additions": 9, "deletions": 225, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "2da070edffa636332deb812f01203a1a7aa5647d", "filename": "libsanitizer/ubsan/ubsan_type_hash.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "e4f133434d669154c155ff09d394d42d8cae33e2", "filename": "libsanitizer/ubsan/ubsan_type_hash_itanium.cc", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "a2eb1a71cb988a45b940f8055782459213dcb4a3", "filename": "libsanitizer/ubsan/ubsan_type_hash_win.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_type_hash_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash_win.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "e327f6ffc2e8485fc31a0bf7801a47d51117983c", "filename": "libsanitizer/ubsan/ubsan_value.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.cc?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}, {"sha": "cca1ac85b77e8a56d1165cc2e0d320524d219ac1", "filename": "libsanitizer/ubsan/ubsan_value.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/696d846a56cc12549f080c6c87e6a0272bdb29f1/libsanitizer%2Fubsan%2Fubsan_value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.h?ref=696d846a56cc12549f080c6c87e6a0272bdb29f1"}]}