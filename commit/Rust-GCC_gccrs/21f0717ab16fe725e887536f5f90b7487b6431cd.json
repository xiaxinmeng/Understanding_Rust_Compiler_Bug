{"sha": "21f0717ab16fe725e887536f5f90b7487b6431cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFmMDcxN2FiMTZmZTcyNWU4ODc1MzZmNWY5MGI3NDg3YjY0MzFjZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-10-29T16:20:06Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-29T16:20:06Z"}, "message": "[PATCH][PR tree-optimization/67892] Use FSM threader to handle backedges\n\n\tPR tree-optimization/67892\n\t* tree-ssa-threadedge.c (simplify_controL_stmt_condition): Fix typo\n\tin comment.\n\t(thread_through_normal_block): If we have seen a backedge, then\n\tdo nothing.  No longer call find_jump_threads_backwards here.\n\t(thread_across_edge): Use find_jump_threads_backwards to find\n\tjump threads if the old style threader was not successful.\n\t* tree-ssa-threadbackward.c (get_gimple_control_stmt): Use\n\tgsi_last_nondebug_bb.  Return NULL if the block does not end\n\twith a control statement.\n\t(find_jump_threads_backwards): Setup code moved here from\n\ttree-ssa-threadedge.c::thread_through_normal_block.  Accept\n\tsingle edge argument instead of name & block.\n\t* tree-ssa-threadbackward.h (find_jump_threads_backwards): Update\n\tprototype.\n\n        PR tree-optimization/67892\n\t* gcc.dg/tree-ssa/pr21417: Update expected output.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2b.c: Likewise.\n\nFrom-SVN: r229538", "tree": {"sha": "cbe77223cf0c65aa5396de518c330072d3fd1143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbe77223cf0c65aa5396de518c330072d3fd1143"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21f0717ab16fe725e887536f5f90b7487b6431cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f0717ab16fe725e887536f5f90b7487b6431cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21f0717ab16fe725e887536f5f90b7487b6431cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f0717ab16fe725e887536f5f90b7487b6431cd/comments", "author": null, "committer": null, "parents": [{"sha": "3ddb720ebfccb2c64d731cd841ce3388e87abf55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddb720ebfccb2c64d731cd841ce3388e87abf55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ddb720ebfccb2c64d731cd841ce3388e87abf55"}], "stats": {"total": 111, "additions": 73, "deletions": 38}, "files": [{"sha": "4fbfea052871194ffa8481bd64e0991eac01361b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21f0717ab16fe725e887536f5f90b7487b6431cd", "patch": "@@ -1,3 +1,21 @@\n+2015-10-29  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/67892\n+\t* tree-ssa-threadedge.c (simplify_controL_stmt_condition): Fix typo\n+\tin comment.\n+\t(thread_through_normal_block): If we have seen a backedge, then\n+\tdo nothing.  No longer call find_jump_threads_backwards here.\n+\t(thread_across_edge): Use find_jump_threads_backwards to find\n+\tjump threads if the old style threader was not successful.\n+\t* tree-ssa-threadbackward.c (get_gimple_control_stmt): Use\n+\tgsi_last_nondebug_bb.  Return NULL if the block does not end\n+\twith a control statement.\n+\t(find_jump_threads_backwards): Setup code moved here from\n+\ttree-ssa-threadedge.c::thread_through_normal_block.  Accept\n+\tsingle edge argument instead of name & block.\n+\t* tree-ssa-threadbackward.h (find_jump_threads_backwards): Update\n+\tprototype.\n+\n 2015-10-29  Tom de Vries  <tom@codesourcery.com>\n \n \t* fold-const.c (fold_unary_loc): Remove folding inhibition for restrict"}, {"sha": "223554ac31ad2080abf8857577a7abdd78f7412e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=21f0717ab16fe725e887536f5f90b7487b6431cd", "patch": "@@ -1,3 +1,9 @@\n+2015-10-29  Jeff Law  <law@redhat.com>\n+\n+        PR tree-optimization/67892\n+\t* gcc.dg/tree-ssa/pr21417: Update expected output.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2b.c: Likewise.\n+\n 2015-10-29  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/68142"}, {"sha": "fed6b31899c488c54184f650a26c8aa4301a1324", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21417.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c?ref=21f0717ab16fe725e887536f5f90b7487b6431cd", "patch": "@@ -49,5 +49,5 @@ test (tree expr, int t, int D17630)\n /* We should thread the backedge to the top of the loop; ie we only\n    execute the if (expr->common.code != 142) test once per loop\n    iteration.  */\n-/* { dg-final { scan-tree-dump-times \"Threaded jump\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"FSM jump thread\" 1 \"dom2\" } } */\n "}, {"sha": "909009a7f7cce89d4c0f871523b5ea5d6f817324", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2b.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c?ref=21f0717ab16fe725e887536f5f90b7487b6431cd", "patch": "@@ -25,6 +25,5 @@ void thread_latch_through_header (void)\n /* Threading the latch to a later point in the loop is safe in this\n    case.  And we want to thread through the header as well.  These\n    are both caught by threading in DOM.  */\n-/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"vrp1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 0 \"dom1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 1 \"dom1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"dom1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 1 \"vrp1\"} } */"}, {"sha": "90e01dfb2cab7448f7e1ead6b3ede6a82beaff4a", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=21f0717ab16fe725e887536f5f90b7487b6431cd", "patch": "@@ -37,19 +37,22 @@ along with GCC; see the file COPYING3.  If not see\n static int max_threaded_paths;\n \n /* Simple helper to get the last statement from BB, which is assumed\n-   to be a control statement.  */\n+   to be a control statement.   Return NULL if the last statement is\n+   not a control statement.  */\n+\n static gimple *\n get_gimple_control_stmt (basic_block bb)\n {\n-  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n \n   if (gsi_end_p (gsi))\n     return NULL;\n \n   gimple *stmt = gsi_stmt (gsi);\n   enum gimple_code code = gimple_code (stmt);\n-  gcc_assert (code == GIMPLE_COND || code == GIMPLE_SWITCH || code == GIMPLE_GOTO);\n-  return stmt;\n+  if (code == GIMPLE_COND || code == GIMPLE_SWITCH || code == GIMPLE_GOTO)\n+    return stmt;\n+  return NULL;\n }\n \n /* Return true if the CFG contains at least one path from START_BB to END_BB.\n@@ -340,16 +343,44 @@ fsm_find_control_statement_thread_paths (tree name,\n    finding a path where NAME is a constant, we can thread the path.  */\n \n void  \n-find_jump_threads_backwards (tree name, basic_block bb)\n+find_jump_threads_backwards (edge e)\n {     \n+  if (!flag_expensive_optimizations\n+      || optimize_function_for_size_p (cfun)\n+      || e->dest->loop_father != e->src->loop_father\n+      || loop_depth (e->dest->loop_father) == 0)\n+    return;\n+\n+  gimple *stmt = get_gimple_control_stmt (e->dest);\n+  if (!stmt)\n+    return;\n+\n+  enum gimple_code code = gimple_code (stmt);\n+  tree name = NULL;\n+  if (code == GIMPLE_SWITCH)\n+    name = gimple_switch_index (as_a <gswitch *> (stmt));\n+  else if (code == GIMPLE_GOTO)\n+    name = gimple_goto_dest (stmt);\n+  else if (code == GIMPLE_COND)\n+    {\n+      if (TREE_CODE (gimple_cond_lhs (stmt)) == SSA_NAME\n+\t  && TREE_CODE (gimple_cond_rhs (stmt)) == INTEGER_CST\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n+\t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n+\tname = gimple_cond_lhs (stmt);\n+    }\n+\n+  if (!name || TREE_CODE (name) != SSA_NAME)\n+    return;\n+\n   vec<basic_block, va_gc> *bb_path;\n   vec_alloc (bb_path, n_basic_blocks_for_fn (cfun));\n-  vec_safe_push (bb_path, bb);           \n+  vec_safe_push (bb_path, e->dest);\n   hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n \n   max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n   fsm_find_control_statement_thread_paths (name, visited_bbs, bb_path, false);\n \n   delete visited_bbs;\n   vec_free (bb_path);\n-}         \n+}"}, {"sha": "2136ff2620e8613fb09eceef0f69e0143eba47b5", "filename": "gcc/tree-ssa-threadbackward.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftree-ssa-threadbackward.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftree-ssa-threadbackward.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.h?ref=21f0717ab16fe725e887536f5f90b7487b6431cd", "patch": "@@ -20,6 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_THREADFSM_H\n #define GCC_TREE_SSA_THREADFSM_H\n \n-extern void find_jump_threads_backwards (tree, basic_block);\n+extern void find_jump_threads_backwards (edge);\n \n #endif /* GCC_TREE_SSA_THREADFSM_H */"}, {"sha": "ddd50614fd37842447d992186a5e4a961bf7bf8b", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f0717ab16fe725e887536f5f90b7487b6431cd/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=21f0717ab16fe725e887536f5f90b7487b6431cd", "patch": "@@ -566,7 +566,7 @@ simplify_control_stmt_condition (edge e,\n \n \t It is possible to get loops in the SSA_NAME_VALUE chains\n \t (consider threading the backedge of a loop where we have\n-\t a loop invariant SSA_NAME used in the condition.  */\n+\t a loop invariant SSA_NAME used in the condition).  */\n       if (cached_lhs)\n \t{\n \t  for (int i = 0; i < 2; i++)\n@@ -904,12 +904,10 @@ thread_through_normal_block (edge e,\n \t\t\t     bitmap visited,\n \t\t\t     bool *backedge_seen_p)\n {\n-  /* If we have traversed a backedge, then we do not want to look\n-     at certain expressions in the table that can not be relied upon.\n-     Luckily the only code that looked at those expressions is the\n-     SIMPLIFY callback, which we replace if we can no longer use it.  */\n+  /* If we have seen a backedge, then we rely solely on the FSM threader\n+     to find jump threads.  */\n   if (*backedge_seen_p)\n-    simplify = dummy_simplify;\n+    return 0;\n \n   /* We want to record any equivalences created by traversing E.  */\n   if (!handle_dominating_asserts)\n@@ -1019,26 +1017,6 @@ thread_through_normal_block (edge e,\n \t\t\t\t      backedge_seen_p);\n \t  return 1;\n \t}\n-\n-      if (!flag_expensive_optimizations\n-\t  || optimize_function_for_size_p (cfun)\n-\t  || !(TREE_CODE (cond) == SSA_NAME\n-\t       || (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n-\t\t   && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n-\t\t   && TREE_CODE (TREE_OPERAND (cond, 1)) == INTEGER_CST))\n-\t  || e->dest->loop_father != e->src->loop_father\n-\t  || loop_depth (e->dest->loop_father) == 0)\n-\treturn 0;\n-\n-      /* Extract the SSA_NAME we want to trace backwards if COND is not\n-\t already a bare SSA_NAME.  */\n-      if (TREE_CODE (cond) != SSA_NAME)\n-\tcond = TREE_OPERAND (cond, 0);\n-\n-      /* When COND cannot be simplified, try to find paths from a control\n-\t statement back through the PHI nodes which would affect that control\n-\t statement.  */\n-      find_jump_threads_backwards (cond, e->dest);\n     }\n   return 0;\n }\n@@ -1118,6 +1096,8 @@ thread_across_edge (gcond *dummy_cond,\n       path->release ();\n       delete path;\n \n+      find_jump_threads_backwards (e);\n+\n       /* A negative status indicates the target block was deemed too big to\n \t duplicate.  Just quit now rather than trying to use the block as\n \t a joiner in a jump threading path.\n@@ -1217,6 +1197,7 @@ thread_across_edge (gcond *dummy_cond,\n \t  }\n \telse\n \t  {\n+\t    find_jump_threads_backwards (path->last ()->e);\n \t    delete_jump_thread_path (path);\n \t  }\n "}]}