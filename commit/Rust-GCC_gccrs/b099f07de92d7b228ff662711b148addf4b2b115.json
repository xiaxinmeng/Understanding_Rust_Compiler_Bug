{"sha": "b099f07de92d7b228ff662711b148addf4b2b115", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA5OWYwN2RlOTJkN2IyMjhmZjY2MjcxMWIxNDhhZGRmNGIyYjExNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-03-02T20:25:20Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-03-02T20:25:20Z"}, "message": "java-interp.h: Don't include MethodInvocation.h.\n\n\t* include/java-interp.h: Don't include MethodInvocation.h.\n\t(class _Jv_InterpMethod): Don't make MethodInvocation a friend.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (gnu/gcj/runtime/MethodInvocation.h): Removed.\n\t(ordinary_java_source_files): Don't mention\n\tMethodInvocation.java.\n\t* gnu/gcj/runtime/MethodInvocation.java: Removed.\n\t* interpret.cc (MethodInvocation::continue1): Removed.\n\t(run): Handle exceptions here.\n\t* java/lang/ClassLoader.java (defineClass1, defineClass2):\n\tRemoved.\n\t* java/lang/natClassLoader.cc (defineClass0): Catch exceptions\n\there.\n\t(defineClass2): Removed.\n\n\t* java/lang/reflect/Method.java (hack_trampoline, hack_call):\n\tRemoved.\n\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Catch\n\texceptions here.\n\t(hack_call): Removed.\n\n\t* java/lang/Class.h (Class): Removed hackRunInitializers,\n\thackTrampoline.\n\t* java/lang/natClass.cc (hackRunInitializers): Removed.\n\t(initializeClass): Catch exceptions here.\n\tInclude ExceptionInInitializerError.h.\n\t* java/lang/Class.java (hackTrampoline, hackRunInitializers):\n\tRemoved.\n\n\t* java/lang/Object.h (Object): Don't mention hack12_6.\n\t* java/lang/natObject.cc (_Jv_FinalizeObject): Catch exceptions\n\there.\n\t* java/lang/Object.java (hack12_6): Removed.\n\n\t* java/lang/natThread.cc (run_): Renamed.  Catch exceptions here.\n\t(start): Use run_, not run__.\n\t* java/lang/Thread.java (run_): Renamed from run__; old run_\n\tremoved.\n\n\t* jni.cc (_Jv_JNI_FindClass): Handle exceptions.\n\t(_Jv_JNI_EnsureLocalCapacity): Likewise.\n\t(_Jv_JNI_DefineClass): Likewise.\n\t(_Jv_JNI_ThrowNew): Likewise.\n\t(_Jv_JNI_AllocObject): Likewise.\n\t(_Jv_JNI_GetAnyMethodID): Likewise.\n\t(_Jv_JNI_CallAnyMethodV): Likewise.\n\t(_Jv_JNI_CallAnyMethodA): Likewise.\n\t(_Jv_JNI_CallAnyVoidMethodV): Likewise.\n\t(_Jv_JNI_CallAnyVoidMethodA): Likewise.\n\t(_Jv_JNI_GetAnyFieldID): Likewise.\n\t(_Jv_JNI_NewString): Likewise.\n\t(_Jv_JNI_NewStringUTF): Likewise.\n\t(_Jv_JNI_GetStringUTFChars): Likewise.\n\t(_Jv_JNI_NewObjectArray): Likewise.\n\t(_Jv_JNI_NewPrimitiveArray): Likewise.\n\t(_Jv_JNI_GetPrimitiveArrayRegion): Likewise.\n\t(_Jv_JNI_GetStringRegion): Likewise.\n\t(_Jv_JNI_GetStringUTFRegion): Likewise.\n\t(_Jv_JNI_SetPrimitiveArrayRegion): Likewise.\n\t(_Jv_JNI_MonitorEnter): Likewise.\n\t(_Jv_JNI_MonitorExit): Likewise.\n\t(_Jv_JNI_ToReflectedField): Likewise.\n\t(_Jv_JNI_ToReflectedMethod): Likewise.\n\t(_Jv_JNI_RegisterNatives): Likewise.\n\t(_Jv_JNI_AttachCurrentThread): Likewise.\n\t(_Jv_JNI_DestroyJavaVM): Likewise.\n\nFrom-SVN: r32294", "tree": {"sha": "dd49bb49b56ee51fa4bbd2a20cc08ae6eefa6306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd49bb49b56ee51fa4bbd2a20cc08ae6eefa6306"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b099f07de92d7b228ff662711b148addf4b2b115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b099f07de92d7b228ff662711b148addf4b2b115", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b099f07de92d7b228ff662711b148addf4b2b115", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b099f07de92d7b228ff662711b148addf4b2b115/comments", "author": null, "committer": null, "parents": [{"sha": "c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c45da1ca925d67685ca633b48a4ca1ec44dfaca1"}], "stats": {"total": 1064, "additions": 582, "deletions": 482}, "files": [{"sha": "440119098ae62eed2bf7f4f5d547caa2083583ae", "filename": "libjava/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -1,3 +1,72 @@\n+2000-03-02  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* include/java-interp.h: Don't include MethodInvocation.h.\n+\t(class _Jv_InterpMethod): Don't make MethodInvocation a friend.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (gnu/gcj/runtime/MethodInvocation.h): Removed.\n+\t(ordinary_java_source_files): Don't mention\n+\tMethodInvocation.java.\n+\t* gnu/gcj/runtime/MethodInvocation.java: Removed.\n+\t* interpret.cc (MethodInvocation::continue1): Removed.\n+\t(run): Handle exceptions here.\n+\t* java/lang/ClassLoader.java (defineClass1, defineClass2):\n+\tRemoved.\n+\t* java/lang/natClassLoader.cc (defineClass0): Catch exceptions\n+\there.\n+\t(defineClass2): Removed.\n+\n+\t* java/lang/reflect/Method.java (hack_trampoline, hack_call):\n+\tRemoved.\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Catch\n+\texceptions here.\n+\t(hack_call): Removed.\n+\n+\t* java/lang/Class.h (Class): Removed hackRunInitializers,\n+\thackTrampoline.\n+\t* java/lang/natClass.cc (hackRunInitializers): Removed.\n+\t(initializeClass): Catch exceptions here.\n+\tInclude ExceptionInInitializerError.h.\n+\t* java/lang/Class.java (hackTrampoline, hackRunInitializers):\n+\tRemoved.\n+\n+\t* java/lang/Object.h (Object): Don't mention hack12_6.\n+\t* java/lang/natObject.cc (_Jv_FinalizeObject): Catch exceptions\n+\there.\n+\t* java/lang/Object.java (hack12_6): Removed.\n+\n+\t* java/lang/natThread.cc (run_): Renamed.  Catch exceptions here.\n+\t(start): Use run_, not run__.\n+\t* java/lang/Thread.java (run_): Renamed from run__; old run_\n+\tremoved.\n+\n+\t* jni.cc (_Jv_JNI_FindClass): Handle exceptions.\n+\t(_Jv_JNI_EnsureLocalCapacity): Likewise.\n+\t(_Jv_JNI_DefineClass): Likewise.\n+\t(_Jv_JNI_ThrowNew): Likewise.\n+\t(_Jv_JNI_AllocObject): Likewise.\n+\t(_Jv_JNI_GetAnyMethodID): Likewise.\n+\t(_Jv_JNI_CallAnyMethodV): Likewise.\n+\t(_Jv_JNI_CallAnyMethodA): Likewise.\n+\t(_Jv_JNI_CallAnyVoidMethodV): Likewise.\n+\t(_Jv_JNI_CallAnyVoidMethodA): Likewise.\n+\t(_Jv_JNI_GetAnyFieldID): Likewise.\n+\t(_Jv_JNI_NewString): Likewise.\n+\t(_Jv_JNI_NewStringUTF): Likewise.\n+\t(_Jv_JNI_GetStringUTFChars): Likewise.\n+\t(_Jv_JNI_NewObjectArray): Likewise.\n+\t(_Jv_JNI_NewPrimitiveArray): Likewise.\n+\t(_Jv_JNI_GetPrimitiveArrayRegion): Likewise.\n+\t(_Jv_JNI_GetStringRegion): Likewise.\n+\t(_Jv_JNI_GetStringUTFRegion): Likewise.\n+\t(_Jv_JNI_SetPrimitiveArrayRegion): Likewise.\n+\t(_Jv_JNI_MonitorEnter): Likewise.\n+\t(_Jv_JNI_MonitorExit): Likewise.\n+\t(_Jv_JNI_ToReflectedField): Likewise.\n+\t(_Jv_JNI_ToReflectedMethod): Likewise.\n+\t(_Jv_JNI_RegisterNatives): Likewise.\n+\t(_Jv_JNI_AttachCurrentThread): Likewise.\n+\t(_Jv_JNI_DestroyJavaVM): Likewise.\n+\n 2000-02-28  Mo DeJong  <mdejong@cygnus.com>\n \n \t* java/util/zip/ZipOutputStream.java(closeEntry) : Fixed"}, {"sha": "65506cc13f522ca5759a144550003529b58184e9", "filename": "libjava/Makefile.am", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -267,11 +267,6 @@ gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class libgcj.zip\n \t    -friend 'java::lang::ClassLoader;' \\\n \t    $(basename $<)\n \n-gnu/gcj/runtime/MethodInvocation.h: gnu/gcj/runtime/MethodInvocation.class libgcj.zip\n-\t$(GCJH) -classpath $(top_builddir) \\\n-\t    -friend 'class _Jv_InterpMethod;' \\\n-\t    $(basename $<)\n-\n ## Headers we maintain by hand and which we want to install.\n extra_headers = java/lang/Object.h java/lang/Class.h\n \n@@ -525,7 +520,6 @@ ordinary_java_source_files =  $(convert_source_files) \\\n gnu/gcj/io/DefaultMimeTypes.java \\\n gnu/gcj/io/MimeTypes.java \\\n gnu/gcj/jni/NativeThread.java \\\n-gnu/gcj/runtime/MethodInvocation.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\"}, {"sha": "6fd036605a7a44eda6d1047dd50dfa0b12cdf89f", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -329,7 +329,6 @@ ordinary_java_source_files = $(convert_source_files) \\\n gnu/gcj/io/DefaultMimeTypes.java \\\n gnu/gcj/io/MimeTypes.java \\\n gnu/gcj/jni/NativeThread.java \\\n-gnu/gcj/runtime/MethodInvocation.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n@@ -739,7 +738,7 @@ THANKS acinclude.m4 aclocal.m4 configure configure.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -765,7 +764,6 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/protocol/http/Handler.P \\\n .deps/gnu/gcj/protocol/jar/Connection.P \\\n .deps/gnu/gcj/protocol/jar/Handler.P \\\n-.deps/gnu/gcj/runtime/MethodInvocation.P \\\n .deps/gnu/gcj/runtime/VMClassLoader.P \\\n .deps/gnu/gcj/text/BaseBreakIterator.P \\\n .deps/gnu/gcj/text/CharacterBreakIterator.P \\\n@@ -1284,7 +1282,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n@@ -1565,11 +1563,6 @@ gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class libgcj.zip\n \t    -friend 'java::lang::ClassLoader;' \\\n \t    $(basename $<)\n \n-gnu/gcj/runtime/MethodInvocation.h: gnu/gcj/runtime/MethodInvocation.class libgcj.zip\n-\t$(GCJH) -classpath $(top_builddir) \\\n-\t    -friend 'class _Jv_InterpMethod;' \\\n-\t    $(basename $<)\n-\n install-data-local:\n \t$(PRE_INSTALL)\n \t@for f in $(nat_headers) $(extra_headers); do \\"}, {"sha": "4fee5b3cf345713691b01b0cd23390474417e2c5", "filename": "libjava/gnu/gcj/runtime/MethodInvocation.java", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodInvocation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodInvocation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodInvocation.java?ref=c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "patch": "@@ -1,32 +0,0 @@\n-// MethodInvocation.java - wrapper used by the interpreter.\n-// (the native method is implemented in interpret.cc)\n-\n-/* Copyright (C) 1999  Red Hat, Inc.\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-/* Author:  Kresten Krab Thorup <krab@gnu.org>  */\n-\n-package gnu.gcj.runtime;\n-\n-import gnu.gcj.RawData;\n-\n-final class MethodInvocation {\n-\n-  private static Throwable continue0 (RawData meth, RawData inv)\n-  {\n-    try {\n-      continue1 (meth, inv);\n-    } catch (Throwable ex) {\n-      return ex;\n-    }\n-    return null;\n-  }\n-\n-  private static native void continue1 (RawData meth, RawData inv);\n-\n-}"}, {"sha": "3074a2c944fbd8fe22a5f9b9dde8b35f42662a46", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -20,7 +20,6 @@ details.  */\n \n #include <java/lang/Class.h>\n #include <java/lang/ClassLoader.h>\n-#include <gnu/gcj/runtime/MethodInvocation.h>\n \n extern \"C\" {\n #include <ffi.h>\n@@ -135,7 +134,6 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpMethodInvocation;\n-  friend class gnu::gcj::runtime::MethodInvocation;\n \n   friend void _Jv_PrepareClass(jclass);\n };"}, {"sha": "2dc5e7724e45bdcc99bde1ad3145a25cee8ed6de", "filename": "libjava/interpret.cc", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -33,19 +33,7 @@ details.  */\n #include <java-insns.h>\n #include <java-signal.h>\n \n-#ifndef INTERPRETER\n-\n-#include <gnu/gcj/runtime/MethodInvocation.h>\n-\n-/* This should never happen. */\n-void \n-gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *,\n-\t\t\t\t\t\tgnu::gcj::RawData *)\n-{\n-  JvFail (\"no interpreter\");\n-}\n-\n-#else\n+#ifdef INTERPRETER\n \n #define ClassError _CL_Q34java4lang5Error\n extern java::lang::Class ClassError;\n@@ -216,10 +204,17 @@ _Jv_InterpMethod::run (ffi_cif* cif,\n   memcpy ((void*) locals, (void*) args, args_raw_size);\n \n  next_segment:\n-  /* this will call the method _Jv_InterpMethod::continue0, see below */\n-  jobject ex = \n-    gnu::gcj::runtime::MethodInvocation::continue0\n-    ((gnu::gcj::RawData *)this, (gnu::gcj::RawData *)inv);\n+\n+  jobject ex = NULL;\n+\n+  try\n+    {\n+      continue1 (inv);\n+    }\n+  catch (java::lang::Throwable *ex2)\n+    {\n+      ex = ex2;\n+    }\n \n   if (ex == 0)\t\t\t// no exception...\n     {\n@@ -280,7 +275,6 @@ _Jv_InterpMethod::run (ffi_cif* cif,\n \tdefault:\n \t  throw_internal_error (\"unknown return type\");\n \t}\n-\n     }\n \n   /** handle an exception */\n@@ -379,16 +373,6 @@ void _Jv_InterpMethod::run_synch_class (ffi_cif* cif,\n   if (ex != 0) _Jv_Throw (ex);\n }\n \n-/* this is the exception handler hack, for the interpreter */\n-void \n-gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *meth,\n-\t\t\t\t\t\tgnu::gcj::RawData *inv)\n-{\n-  _Jv_InterpMethod           *meth0 = (_Jv_InterpMethod*)meth;\n-  _Jv_InterpMethodInvocation *inv0  = (_Jv_InterpMethodInvocation*)inv;\n-  meth0->continue1 (inv0);\n-}\n-\n /*\n   This proceeds execution, as designated in \"inv\".  If an exception\n   happens, then it is simply thrown, and handled in Java.  Thus, the pc"}, {"sha": "717eed7af00852657982e48e2fdad382bda5b503", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -157,9 +157,6 @@ class java::lang::Class : public java::lang::Object\n private:\n   void checkMemberAccess (jint flags);\n \n-  // Various functions to handle class initialization.\n-  java::lang::Throwable *hackTrampoline (jint, java::lang::Throwable *);\n-  void hackRunInitializers (void);\n   void initializeClass (void);\n \n   // Friend functions implemented in natClass.cc."}, {"sha": "b0806248df6375efd576e152ced05b9c132874f5", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -172,32 +172,6 @@ private void checkMemberAccess (int flags)\n       sm.checkMemberAccess(this, flags);\n   }\n \n-  // FIXME: this method exists only because we cannot catch Java\n-  // exceptions from C++ code.  This is a helper for initializeClass.\n-  private Throwable hackTrampoline (int what, Throwable old_exception)\n-    {\n-      Throwable new_val = null;\n-      try\n-\t{\n-\t  if (what == 0)\n-\t    initializeClass ();\n-\t  else if (what == 1)\n-\t    hackRunInitializers ();\n-\t  else if (what == 2)\n-\t    new_val = new ExceptionInInitializerError (old_exception);\n-\t}\n-      catch (Throwable t)\n-\t{\n-\t  new_val = t;\n-\t}\n-      return new_val;\n-    }\n-\n-  // FIXME: this is a hack to let us run the class initializers.  We\n-  // could do it inline in initializeClass() if we could catch Java\n-  // exceptions from C++.\n-  private native void hackRunInitializers ();\n-\n   // Initialize the class.\n   private native void initializeClass ();\n "}, {"sha": "fb3f37a56c3f8ac1055c30c2fa9b451ca2f4bdd0", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -1,6 +1,6 @@\n // ClassLoader.java - Define policies for loading Java classes.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -234,28 +234,6 @@ private native Class defineClass0 (String name,\n     throws java.lang.ClassNotFoundException, java.lang.LinkageError;\n \n \n-  /** This is called by defineClass0, once the \"raw\" and uninitialized\n-   * class object has been created, and handles exceptions generated\n-   * while actually defining the class (_Jv_DefineClass).  defineClass0\n-   * holds the lock on the new class object, so it needs to capture\n-   * these exceptions.  */\n-\n-  private static Throwable defineClass1 (Class klass, byte[] data,\n-\t\t\t\t\t int offset, int length)\n-  {\n-    try {\n-      defineClass2 (klass, data, offset, length);\n-    } catch (Throwable x) {\n-      return x;\n-    }\n-    return null;\n-  }\n- \n-  /** This is just a wrapper for _Jv_DefineClass */\n-  private static native void defineClass2 (Class klass, byte[] data, \n-\t\t\t\t    int offset, int length)\n-    throws Throwable;\n-\n   /** \n    * Link the given class.  This will bring the class to a state where\n    * the class initializer can be run.  Linking involves the following"}, {"sha": "5e7337ad3341a4e49fe4d7053e34376a9ab57dbf", "filename": "libjava/java/lang/Object.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FObject.h?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -1,6 +1,6 @@\n // Object.h - Header file for java.lang.Object.  -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -69,8 +69,6 @@ class java::lang::Object : public _JvObjectPrefix\n \n   // Initialize the sync_info field.\n   void sync_init (void);\n-\n-  static void hack12_6 (jobject f);\n };\n \n #endif /* __JAVA_LANG_OBJECT_H__ */"}, {"sha": "9523f03514e9207ca6dceb32f800c1099476528b", "filename": "libjava/java/lang/Object.java", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FObject.java?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -1,6 +1,6 @@\n // Object.java - The root of all evil.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -66,21 +66,6 @@ public final void wait (long timeout) throws InterruptedException\n   // completeness (some day we'll be able to auto-generate Object.h).\n   private final native void sync_init ();\n \n-  // This exists as a workaround for the fact that we can't catch a\n-  // Java Exception from C++.  This is from section 12.6 of the Java\n-  // Language Spec.  FIXME: remove this once exception processing\n-  // works.\n-  private static final void hack12_6 (Object f)\n-  {\n-    try\n-      {\n-\tf.finalize();\n-      }\n-    catch (Throwable x)\n-      {\n-      }\n-  }\n-\n   // Note that we don't mention the sync_info field here.  If we do,\n   // jc1 will not work correctly.\n }"}, {"sha": "9cf7109a1fb53b8bc6d42d730898e35771628e7c", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -116,8 +116,8 @@ public final native void join (long timeout, int nanos)\n   public final native void resume ();\n \n   // This method exists only to avoid a warning from the C++ compiler.\n-  private static final native void run__ (Object obj);\n-  private native final void finish_ ();\n+  private static final native void run_ (Object obj);\n+  private final native void finish_ ();\n \n   // Convenience method to check and clear the thread's interrupted status.  \n   private boolean isInterrupted_ ()\n@@ -127,28 +127,6 @@ private boolean isInterrupted_ ()\n     return r;\n   }\n   \n-  private final void run_ ()\n-  {\n-    try\n-      {\n-\trun ();\n-      }\n-    catch (Throwable e)\n-      {\n-\t// Uncaught exceptions are forwarded to the ThreadGroup.  If\n-\t// this results in an uncaught exception, that is ignored.\n-\ttry\n-\t  {\n-\t    group.uncaughtException(this, e);\n-\t  }\n-\tcatch (Throwable f)\n-\t  {\n-\t    // Nothing.\n-\t  }\n-      }\n-    finish_ ();\n-  }\n-\n   public void run ()\n   {\n     if (runnable != null)"}, {"sha": "42af71585ef7d8b2f1315f5ad215b25b9490113f", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -27,6 +27,7 @@ details.  */\n #include <java/lang/reflect/Constructor.h>\n #include <java/lang/AbstractMethodError.h>\n #include <java/lang/ClassNotFoundException.h>\n+#include <java/lang/ExceptionInInitializerError.h>\n #include <java/lang/IllegalAccessException.h>\n #include <java/lang/IllegalAccessError.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n@@ -690,15 +691,6 @@ java::lang::Class::finalize (void)\n #endif\n }\n \n-// FIXME.\n-void\n-java::lang::Class::hackRunInitializers (void)\n-{\n-  _Jv_Method *meth = _Jv_GetMethodLocal (this, clinit_name, void_signature);\n-  if (meth)\n-    ((void (*) (void)) meth->ncode) ();\n-}\n-\n // This implements the initialization process for a class.  From Spec\n // section 12.4.2.\n void\n@@ -764,46 +756,53 @@ java::lang::Class::initializeClass (void)\n   // Step 7.\n   if (! isInterface () && superclass)\n     {\n-      // FIXME: We can't currently catch a Java exception in C++ code.\n-      // So instead we call a Java trampoline.  It returns an\n-      // exception, or null.\n-      jobject except = superclass->hackTrampoline(0, NULL);\n-      if (except)\n+      try\n+\t{\n+\t  superclass->initializeClass ();\n+\t}\n+      catch (java::lang::Throwable *except)\n \t{\n \t  // Caught an exception.\n \t  _Jv_MonitorEnter (this);\n \t  state = JV_STATE_ERROR;\n \t  notifyAll ();\n \t  _Jv_MonitorExit (this);\n-\t  JvThrow (except);\n+\t  throw except;\n \t}\n     }\n \n-  // Step 8.\n-  // FIXME: once again we have to go through a trampoline.\n-  java::lang::Throwable *except = hackTrampoline (1, NULL);\n-\n-  // Steps 9, 10, 11.\n-  if (! except)\n+  // Steps 8, 9, 10, 11.\n+  try\n     {\n-      _Jv_MonitorEnter (this);\n-      state = JV_STATE_DONE;\n+      _Jv_Method *meth = _Jv_GetMethodLocal (this, clinit_name,\n+\t\t\t\t\t     void_signature);\n+      if (meth)\n+\t((void (*) (void)) meth->ncode) ();\n     }\n-  else\n+  catch (java::lang::Throwable *except)\n     {\n       if (! ErrorClass.isInstance(except))\n \t{\n-\t  // Once again we must use the trampoline.  In this case we\n-\t  // have to detect an OutOfMemoryError.\n-\t  except = hackTrampoline(2, except);\n+\t  try\n+\t    {\n+\t      except = new ExceptionInInitializerError (except);\n+\t    }\n+\t  catch (java::lang::Throwable *t)\n+\t    {\n+\t      except = t;\n+\t    }\n \t}\n       _Jv_MonitorEnter (this);\n       state = JV_STATE_ERROR;\n+      notifyAll ();\n+      _Jv_MonitorExit (this);\n+      JvThrow (except);\n     }\n+\n+  _Jv_MonitorEnter (this);\n+  state = JV_STATE_DONE;\n   notifyAll ();\n   _Jv_MonitorExit (this);\n-  if (except)\n-    JvThrow (except);\n }\n \n \f"}, {"sha": "39ee0ba8b470a6410eb6838eb823d93b76bcf2a3", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -58,15 +58,6 @@ java::lang::ClassLoader::getSystemClassLoader (void)\n   return system;\n }\n \n-void\n-java::lang::ClassLoader::defineClass2 (jclass klass, jbyteArray data,\n-\t\t\t\t       jint offset, jint length)\n-{\n-#ifdef INTERPRETER\n-  _Jv_DefineClass (klass, data, offset, length);\n-#endif\n-}\n-\n java::lang::Class *\n java::lang::ClassLoader::defineClass0 (jstring name,\n \t\t\t\t       jbyteArray data, \n@@ -94,27 +85,27 @@ java::lang::ClassLoader::defineClass0 (jstring name,\n       klass->name = name2;\n     }\n \n-  // this will do the magic.  loadInto also operates\n-  // as an exception trampoline for now...\n-  Throwable *ex = defineClass1 (klass, data, offset, length);\n-    \n-  if (ex)  // we failed to load it\n+  try\n+    {\n+      _Jv_DefineClass (klass, data, offset, length);\n+    }\n+  catch (java::lang::Throwable *ex)\n     {\n       klass->state = JV_STATE_ERROR;\n       klass->notifyAll ();\n \n       _Jv_UnregisterClass (klass);\n \n       _Jv_MonitorExit (klass);\n-\t  \n+\n       // FIXME: Here we may want to test that EX does\n       // indeed represent a valid exception.  That is,\n       // anything but ClassNotFoundException, \n       // or some kind of Error.\n-\t  \n+\n       JvThrow (ex);\n     }\n-    \n+\n   // if everything proceeded sucessfully, we're loaded.\n   JvAssert (klass->state == JV_STATE_LOADED);\n "}, {"sha": "cdce6d2a5a0949ceccc372b570a4f9e5936c7ec9", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -1,6 +1,6 @@\n // natObject.cc - Implementation of the Object class.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -242,5 +242,13 @@ _Jv_MonitorExit (jobject obj)\n void\n _Jv_FinalizeObject (jobject obj)\n {\n-  java::lang::Object::hack12_6(obj);\n+  // Ignore exceptions.  From section 12.6 of the Java Language Spec.\n+  try\n+    {\n+      obj->finalize ();\n+    }\n+  catch (java::lang::Throwable *t)\n+    {\n+      // Ignore.\n+    }\n }"}, {"sha": "9c56808ea3070282f08911c6e1b97d5db06f8f73", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -263,9 +263,9 @@ java::lang::Thread::sleep (jlong millis, jint nanos)\n }\n \n void\n-java::lang::Thread::finish_ (void)\n+java::lang::Thread::finish_ ()\n {\n-  // Notify all threads waiting to join this thread.\n+  // Notify all threads waiting to join this this.\n   _Jv_MonitorEnter (this);\n   alive_flag = false;\n \n@@ -285,10 +285,28 @@ java::lang::Thread::finish_ (void)\n }\n \n void\n-java::lang::Thread::run__ (jobject obj)\n+java::lang::Thread::run_ (jobject obj)\n {\n   java::lang::Thread *thread = (java::lang::Thread *) obj;\n-  thread->run_ ();\n+  try\n+    {\n+      thread->run ();\n+    }\n+  catch (java::lang::Throwable *t)\n+    {\n+      // Uncaught exceptions are forwarded to the ThreadGroup.  If\n+      // this results in an uncaught exception, that is ignored.\n+      try\n+\t{\n+\t  thread->group->uncaughtException (thread, t);\n+\t}\n+      catch (java::lang::Throwable *f)\n+\t{\n+\t  // Nothing.\n+\t}\n+    }\n+\n+  thread->finish_ ();\n }\n \n void\n@@ -301,7 +319,7 @@ java::lang::Thread::start (void)\n \n   alive_flag = true;\n   natThread *nt = (natThread *) data;\n-  _Jv_ThreadStart (this, nt->thread, (_Jv_ThreadStartFunc *) &run__);\n+  _Jv_ThreadStart (this, nt->thread, (_Jv_ThreadStartFunc *) &run_);\n }\n \n void"}, {"sha": "e95ca0d2a364a478afcdd4b0657f09e3bf2de8d6", "filename": "libjava/java/lang/reflect/Method.java", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FMethod.java?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -1,6 +1,6 @@\n // Method.java - Represent method of class or interface.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -68,30 +68,6 @@ public int hashCode ()\n       return name.hashCode() + declaringClass.getName().hashCode();\n     }\n \n-  // This is used to perform an actual method call via ffi.\n-  private static final native void hack_call (RawData cif,\n-\t\t\t\t\t      RawData method,\n-\t\t\t\t\t      RawData ret_value,\n-\t\t\t\t\t      RawData values);\n-\n-  // Perform an ffi call while capturing exceptions.  We have to do\n-  // this because we can't catch Java exceptions from C++.\n-  static final Throwable hack_trampoline (RawData cif,\n-\t\t\t\t\t  RawData method,\n-\t\t\t\t\t  RawData ret_value,\n-\t\t\t\t\t  RawData values)\n-  {\n-    try\n-      {\n-\thack_call (cif, method, ret_value, values);\n-      }\n-    catch (Throwable x)\n-      {\n-\treturn x;\n-      }\n-    return null;\n-  }\n-\n   public native Object invoke (Object obj, Object[] args)\n     throws IllegalAccessException, IllegalArgumentException,\n            InvocationTargetException;"}, {"sha": "c4482ee7933620992caaa38034fda02e6c2ae88a", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -152,21 +152,6 @@ get_ffi_type (jclass klass)\n   return r;\n }\n \n-// Actually perform an FFI call.\n-void\n-java::lang::reflect::Method::hack_call (gnu::gcj::RawData *rcif,\n-\t\t\t\t\tgnu::gcj::RawData *rmethod,\n-\t\t\t\t\tgnu::gcj::RawData *rret_value,\n-\t\t\t\t\tgnu::gcj::RawData *rvalues)\n-{\n-  ffi_cif *cif = (ffi_cif *) rcif;\n-  void (*method) (...) = (void (*) (...)) rmethod;\n-  void *ret_value = (void *) rret_value;\n-  void **values = (void **) rvalues;\n-\n-  ffi_call (cif, method, ret_value, values);\n-}\n-\n jobject\n java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n {\n@@ -419,19 +404,23 @@ _Jv_CallAnyMethodA (jobject obj,\n \n   // FIXME: initialize class here.\n \n-  java::lang::Throwable *ex;\n   using namespace java::lang;\n   using namespace java::lang::reflect;\n-  ex = Method::hack_trampoline ((gnu::gcj::RawData *) &cif,\n-\t\t\t\t(gnu::gcj::RawData *) meth->ncode,\n-\t\t\t\t(gnu::gcj::RawData *) result,\n-\t\t\t\t(gnu::gcj::RawData *) values);\n \n-  if (ex)\n-    // FIXME: this is wrong for JNI.  But if we just return the\n-    // exception, then the non-JNI cases won't be able to distinguish\n-    // it from exceptions we might generate ourselves.  Sigh.\n-    ex = new InvocationTargetException (ex);\n+  Throwable *ex = NULL;\n+\n+  try\n+    {\n+      ffi_call (&cif, (void (*) (...)) meth->ncode, result, values);\n+    }\n+  catch (Throwable *ex2)\n+    {\n+      // FIXME: this is wrong for JNI.  But if we just return the\n+      // exception, then the non-JNI cases won't be able to\n+      // distinguish it from exceptions we might generate ourselves.\n+      // Sigh.\n+      ex = new InvocationTargetException (ex2);\n+    }\n \n   if (is_constructor)\n     result->l = obj;"}, {"sha": "f06e5802026b99dd6f721624524e55d909e197aa", "filename": "libjava/jni.cc", "status": "modified", "additions": 410, "deletions": 207, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b099f07de92d7b228ff662711b148addf4b2b115/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=b099f07de92d7b228ff662711b148addf4b2b115", "patch": "@@ -115,6 +115,7 @@ mark_for_gc (jobject obj)\n   using namespace java::lang;\n   Integer *refcount = (Integer *) ref_table->get (obj);\n   jint val = (refcount == NULL) ? 0 : refcount->intValue ();\n+  // FIXME: what about out of memory error?\n   ref_table->put (obj, new Integer (val + 1));\n }\n \n@@ -131,6 +132,7 @@ unmark_for_gc (jobject obj)\n   if (val == 0)\n     ref_table->remove (obj);\n   else\n+    // FIXME: what about out of memory error?\n     ref_table->put (obj, new Integer (val));\n }\n \n@@ -180,13 +182,15 @@ _Jv_JNI_EnsureLocalCapacity (JNIEnv *env, jint size)\n   // size.  This isn't the most efficient thing, but for now we don't\n   // care.  Note that _Jv_JNI_PushLocalFrame relies on this right now.\n \n-  _Jv_JNI_LocalFrame *frame\n-    = (_Jv_JNI_LocalFrame *) _Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n-\t\t\t\t\t\t  + size * sizeof (jobject));\n-  if (frame == NULL)\n+  _Jv_JNI_LocalFrame *frame;\n+  try\n     {\n-      // FIXME: exception processing.\n-      env->ex = new java::lang::OutOfMemoryError;\n+      frame = (_Jv_JNI_LocalFrame *) _Jv_Malloc (sizeof (_Jv_JNI_LocalFrame)\n+\t\t\t\t\t\t + size * sizeof (jobject));\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n       return JNI_ERR;\n     }\n \n@@ -304,16 +308,24 @@ static jclass\n _Jv_JNI_DefineClass (JNIEnv *env, jobject loader, \n \t\t     const jbyte *buf, jsize bufLen)\n {\n-  jbyteArray bytes = JvNewByteArray (bufLen);\n-  jbyte *elts = elements (bytes);\n-  memcpy (elts, buf, bufLen * sizeof (jbyte));\n+  try\n+    {\n+      jbyteArray bytes = JvNewByteArray (bufLen);\n \n-  java::lang::ClassLoader *l\n-    = reinterpret_cast<java::lang::ClassLoader *> (loader);\n+      jbyte *elts = elements (bytes);\n+      memcpy (elts, buf, bufLen * sizeof (jbyte));\n \n-  // FIXME: exception processing.\n-  jclass result = l->defineClass (bytes, 0, bufLen);\n-  return (jclass) wrap_value (env, result);\n+      java::lang::ClassLoader *l\n+\t= reinterpret_cast<java::lang::ClassLoader *> (loader);\n+\n+      jclass result = l->defineClass (bytes, 0, bufLen);\n+      return (jclass) wrap_value (env, result);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+      return NULL;\n+    }\n }\n \n static jclass\n@@ -324,20 +336,29 @@ _Jv_JNI_FindClass (JNIEnv *env, const char *name)\n   char s[len + 1];\n   for (int i = 0; i <= len; ++i)\n     s[i] = (name[i] == '/') ? '.' : name[i];\n-  jstring n = JvNewStringUTF (s);\n \n-  java::lang::ClassLoader *loader;\n-  if (env->klass == NULL)\n+  jclass r = NULL;\n+  try\n     {\n-      // FIXME: should use getBaseClassLoader, but we don't have that\n-      // yet.\n-      loader = java::lang::ClassLoader::getSystemClassLoader ();\n-    }\n-  else\n-    loader = env->klass->getClassLoader ();\n+      // This might throw an out of memory exception.\n+      jstring n = JvNewStringUTF (s);\n+\n+      java::lang::ClassLoader *loader;\n+      if (env->klass == NULL)\n+\t{\n+\t  // FIXME: should use getBaseClassLoader, but we don't have that\n+\t  // yet.\n+\t  loader = java::lang::ClassLoader::getSystemClassLoader ();\n+\t}\n+      else\n+\tloader = env->klass->getClassLoader ();\n \n-  // FIXME: exception processing.\n-  jclass r = loader->loadClass (n);\n+      r = loader->loadClass (n);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n \n   return (jclass) wrap_value (env, r);\n }\n@@ -370,24 +391,32 @@ _Jv_JNI_ThrowNew (JNIEnv *env, jclass clazz, const char *message)\n \n   JvAssert ((&ThrowableClass)->isAssignableFrom (clazz));\n \n-  JArray<jclass> *argtypes\n-    = (JArray<jclass> *) JvNewObjectArray (1, &ClassClass, NULL);\n+  int r = JNI_OK;\n+  try\n+    {\n+      JArray<jclass> *argtypes\n+\t= (JArray<jclass> *) JvNewObjectArray (1, &ClassClass, NULL);\n \n-  jclass *elts = elements (argtypes);\n-  elts[0] = &StringClass;\n+      jclass *elts = elements (argtypes);\n+      elts[0] = &StringClass;\n \n-  // FIXME: exception processing.\n-  Constructor *cons = clazz->getConstructor (argtypes);\n+      Constructor *cons = clazz->getConstructor (argtypes);\n \n-  jobjectArray values = JvNewObjectArray (1, &StringClass, NULL);\n-  jobject *velts = elements (values);\n-  velts[0] = JvNewStringUTF (message);\n+      jobjectArray values = JvNewObjectArray (1, &StringClass, NULL);\n+      jobject *velts = elements (values);\n+      velts[0] = JvNewStringUTF (message);\n \n-  // FIXME: exception processing.\n-  jobject obj = cons->newInstance (values);\n+      jobject obj = cons->newInstance (values);\n \n-  env->ex = reinterpret_cast<jthrowable> (obj);\n-  return 0;\n+      env->ex = reinterpret_cast<jthrowable> (obj);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+      r = JNI_ERR;\n+    }\n+\n+  return r;\n }\n \n static jthrowable\n@@ -435,14 +464,20 @@ _Jv_JNI_AllocObject (JNIEnv *env, jclass clazz)\n   jobject obj = NULL;\n   using namespace java::lang::reflect;\n \n-  JvAssert (clazz && ! clazz->isArray ());\n-  if (clazz->isInterface() || Modifier::isAbstract(clazz->getModifiers()))\n-    env->ex = new java::lang::InstantiationException ();\n-  else\n+  try\n+    {\n+      JvAssert (clazz && ! clazz->isArray ());\n+      if (clazz->isInterface() || Modifier::isAbstract(clazz->getModifiers()))\n+\tenv->ex = new java::lang::InstantiationException ();\n+      else\n+\t{\n+\t  // FIXME: will this work for String?\n+\t  obj = JvAllocObject (clazz);\n+\t}\n+    }\n+  catch (jthrowable t)\n     {\n-      // FIXME: exception processing.\n-      // FIXME: will this work for String?\n-      obj = JvAllocObject (clazz);\n+      env->ex = t;\n     }\n \n   return wrap_value (env, obj);\n@@ -472,36 +507,43 @@ static jmethodID\n _Jv_JNI_GetAnyMethodID (JNIEnv *env, jclass clazz,\n \t\t\tconst char *name, const char *sig)\n {\n-  // FIXME: exception processing.\n-  _Jv_InitClass (clazz);\n-\n-  _Jv_Utf8Const *name_u = _Jv_makeUtf8Const ((char *) name, -1);\n-  _Jv_Utf8Const *sig_u = _Jv_makeUtf8Const ((char *) sig, -1);\n+  try\n+    {\n+      _Jv_InitClass (clazz);\n \n-  JvAssert (! clazz->isPrimitive());\n+      _Jv_Utf8Const *name_u = _Jv_makeUtf8Const ((char *) name, -1);\n+      _Jv_Utf8Const *sig_u = _Jv_makeUtf8Const ((char *) sig, -1);\n \n-  using namespace java::lang::reflect;\n+      JvAssert (! clazz->isPrimitive());\n \n-  while (clazz != NULL)\n-    {\n-      jint count = JvNumMethods (clazz);\n-      jmethodID meth = JvGetFirstMethod (clazz);\n+      using namespace java::lang::reflect;\n \n-      for (jint i = 0; i < count; ++i)\n+      while (clazz != NULL)\n \t{\n-\t  if (((is_static && Modifier::isStatic (meth->accflags))\n-\t       || (! is_static && ! Modifier::isStatic (meth->accflags)))\n-\t      && _Jv_equalUtf8Consts (meth->name, name_u)\n-\t      && _Jv_equalUtf8Consts (meth->signature, sig_u))\n-\t    return meth;\n+\t  jint count = JvNumMethods (clazz);\n+\t  jmethodID meth = JvGetFirstMethod (clazz);\n+\n+\t  for (jint i = 0; i < count; ++i)\n+\t    {\n+\t      if (((is_static && Modifier::isStatic (meth->accflags))\n+\t\t   || (! is_static && ! Modifier::isStatic (meth->accflags)))\n+\t\t  && _Jv_equalUtf8Consts (meth->name, name_u)\n+\t\t  && _Jv_equalUtf8Consts (meth->signature, sig_u))\n+\t\treturn meth;\n+\n+\t      meth = meth->getNextMethod();\n+\t    }\n \n-\t  meth = meth->getNextMethod();\n+\t  clazz = clazz->getSuperclass ();\n \t}\n \n-      clazz = clazz->getSuperclass ();\n+      env->ex = new java::lang::NoSuchMethodError ();\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n     }\n \n-  env->ex = new java::lang::NoSuchMethodError ();\n   return NULL;\n }\n \n@@ -553,27 +595,36 @@ _Jv_JNI_CallAnyMethodV (JNIEnv *env, jobject obj, jclass klass,\n \n   jclass return_type;\n   JArray<jclass> *arg_types;\n-  // FIXME: exception processing.\n-  _Jv_GetTypesFromSignature (id, decl_class,\n-\t\t\t     &arg_types, &return_type);\n \n-  jvalue args[arg_types->length];\n-  array_from_valist (args, arg_types, vargs);\n+  try\n+    {\n+      _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t\t &arg_types, &return_type);\n+\n+      jvalue args[arg_types->length];\n+      array_from_valist (args, arg_types, vargs);\n \n-  // For constructors we need to pass the Class we are instantiating.\n-  if (style == constructor)\n-    return_type = klass;\n+      // For constructors we need to pass the Class we are instantiating.\n+      if (style == constructor)\n+\treturn_type = klass;\n \n-  jvalue result;\n-  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t      style == constructor,\n-\t\t\t\t      arg_types, args, &result);\n+      jvalue result;\n+      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t\t  style == constructor,\n+\t\t\t\t\t  arg_types, args, &result);\n \n-  if (ex != NULL)\n-    env->ex = ex;\n+      if (ex != NULL)\n+\tenv->ex = ex;\n \n-  // We cheat a little here.  FIXME.\n-  return wrap_value (env, * (T *) &result);\n+      // We cheat a little here.  FIXME.\n+      return wrap_value (env, * (T *) &result);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n+\n+  return wrap_value (env, (T) 0);\n }\n \n template<typename T, invocation_type style>\n@@ -604,24 +655,32 @@ _Jv_JNI_CallAnyMethodA (JNIEnv *env, jobject obj, jclass klass,\n \n   jclass return_type;\n   JArray<jclass> *arg_types;\n-  // FIXME: exception processing.\n-  _Jv_GetTypesFromSignature (id, decl_class,\n-\t\t\t     &arg_types, &return_type);\n+  try\n+    {\n+      _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t\t &arg_types, &return_type);\n \n-  // For constructors we need to pass the Class we are instantiating.\n-  if (style == constructor)\n-    return_type = klass;\n+      // For constructors we need to pass the Class we are instantiating.\n+      if (style == constructor)\n+\treturn_type = klass;\n \n-  jvalue result;\n-  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t      style == constructor,\n-\t\t\t\t      arg_types, args, &result);\n+      jvalue result;\n+      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t\t  style == constructor,\n+\t\t\t\t\t  arg_types, args, &result);\n \n-  if (ex != NULL)\n-    env->ex = ex;\n+      if (ex != NULL)\n+\tenv->ex = ex;\n \n-  // We cheat a little here.  FIXME.\n-  return wrap_value (env, * (T *) &result);\n+      // We cheat a little here.  FIXME.\n+      return wrap_value (env, * (T *) &result);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n+\n+  return wrap_value (env, (T) 0);\n }\n \n template<invocation_type style>\n@@ -637,23 +696,29 @@ _Jv_JNI_CallAnyVoidMethodV (JNIEnv *env, jobject obj, jclass klass,\n \n   jclass return_type;\n   JArray<jclass> *arg_types;\n-  // FIXME: exception processing.\n-  _Jv_GetTypesFromSignature (id, decl_class,\n-\t\t\t     &arg_types, &return_type);\n+  try\n+    {\n+      _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t\t &arg_types, &return_type);\n \n-  jvalue args[arg_types->length];\n-  array_from_valist (args, arg_types, vargs);\n+      jvalue args[arg_types->length];\n+      array_from_valist (args, arg_types, vargs);\n \n-  // For constructors we need to pass the Class we are instantiating.\n-  if (style == constructor)\n-    return_type = klass;\n+      // For constructors we need to pass the Class we are instantiating.\n+      if (style == constructor)\n+\treturn_type = klass;\n \n-  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t      style == constructor,\n-\t\t\t\t      arg_types, args, NULL);\n+      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t\t  style == constructor,\n+\t\t\t\t\t  arg_types, args, NULL);\n \n-  if (ex != NULL)\n-    env->ex = ex;\n+      if (ex != NULL)\n+\tenv->ex = ex;\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n }\n \n template<invocation_type style>\n@@ -681,16 +746,22 @@ _Jv_JNI_CallAnyVoidMethodA (JNIEnv *env, jobject obj, jclass klass,\n \n   jclass return_type;\n   JArray<jclass> *arg_types;\n-  // FIXME: exception processing.\n-  _Jv_GetTypesFromSignature (id, decl_class,\n-\t\t\t     &arg_types, &return_type);\n+  try\n+    {\n+      _Jv_GetTypesFromSignature (id, decl_class,\n+\t\t\t\t &arg_types, &return_type);\n \n-  jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n-\t\t\t\t      style == constructor,\n-\t\t\t\t      arg_types, args, NULL);\n+      jthrowable ex = _Jv_CallAnyMethodA (obj, return_type, id,\n+\t\t\t\t\t  style == constructor,\n+\t\t\t\t\t  arg_types, args, NULL);\n \n-  if (ex != NULL)\n-    env->ex = ex;\n+      if (ex != NULL)\n+\tenv->ex = ex;\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n }\n \n // Functions with this signature are used to implement functions in\n@@ -895,49 +966,55 @@ static jfieldID\n _Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n \t\t       const char *name, const char *sig)\n {\n-  // FIXME: exception processing.\n-  _Jv_InitClass (clazz);\n+  try\n+    {\n+      _Jv_InitClass (clazz);\n \n-  _Jv_Utf8Const *a_name = _Jv_makeUtf8Const ((char *) name, -1);\n+      _Jv_Utf8Const *a_name = _Jv_makeUtf8Const ((char *) name, -1);\n \n-  jclass field_class = NULL;\n-  if (sig[0] == '[')\n-    field_class = _Jv_FindClassFromSignature ((char *) sig, NULL);\n-  else\n-    {\n-      _Jv_Utf8Const *sig_u = _Jv_makeUtf8Const ((char *) sig, -1);\n-      field_class = _Jv_FindClass (sig_u, NULL);\n-    }\n+      jclass field_class = NULL;\n+      if (sig[0] == '[')\n+\tfield_class = _Jv_FindClassFromSignature ((char *) sig, NULL);\n+      else\n+\t{\n+\t  _Jv_Utf8Const *sig_u = _Jv_makeUtf8Const ((char *) sig, -1);\n+\t  field_class = _Jv_FindClass (sig_u, NULL);\n+\t}\n \n-  // FIXME: what if field_class == NULL?\n+      // FIXME: what if field_class == NULL?\n \n-  while (clazz != NULL)\n-    {\n-      jint count = (is_static\n-\t\t    ? JvNumStaticFields (clazz)\n-\t\t    : JvNumInstanceFields (clazz));\n-      jfieldID field = (is_static\n-\t\t\t? JvGetFirstStaticField (clazz)\n-\t\t\t: JvGetFirstInstanceField (clazz));\n-      for (jint i = 0; i < count; ++i)\n+      while (clazz != NULL)\n \t{\n-\t  // The field is resolved as a side effect of class\n-\t  // initialization.\n-\t  JvAssert (field->isResolved ());\n+\t  jint count = (is_static\n+\t\t\t? JvNumStaticFields (clazz)\n+\t\t\t: JvNumInstanceFields (clazz));\n+\t  jfieldID field = (is_static\n+\t\t\t    ? JvGetFirstStaticField (clazz)\n+\t\t\t    : JvGetFirstInstanceField (clazz));\n+\t  for (jint i = 0; i < count; ++i)\n+\t    {\n+\t      // The field is resolved as a side effect of class\n+\t      // initialization.\n+\t      JvAssert (field->isResolved ());\n \n-\t  _Jv_Utf8Const *f_name = field->getNameUtf8Const(clazz);\n+\t      _Jv_Utf8Const *f_name = field->getNameUtf8Const(clazz);\n \n-\t  if (_Jv_equalUtf8Consts (f_name, a_name)\n-\t      && field->getClass() == field_class)\n-\t    return field;\n+\t      if (_Jv_equalUtf8Consts (f_name, a_name)\n+\t\t  && field->getClass() == field_class)\n+\t\treturn field;\n \n-\t  field = field->getNextField ();\n+\t      field = field->getNextField ();\n+\t    }\n+\n+\t  clazz = clazz->getSuperclass ();\n \t}\n \n-      clazz = clazz->getSuperclass ();\n+      env->ex = new java::lang::NoSuchFieldError ();\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n     }\n-\n-  env->ex = new java::lang::NoSuchFieldError ();\n   return NULL;\n }\n \n@@ -960,9 +1037,16 @@ _Jv_JNI_SetStaticField (JNIEnv *, jclass, jfieldID field, T value)\n static jstring\n _Jv_JNI_NewString (JNIEnv *env, const jchar *unichars, jsize len)\n {\n-  // FIXME: exception processing.\n-  jstring r = _Jv_NewString (unichars, len);\n-  return (jstring) wrap_value (env, r);\n+  try\n+    {\n+      jstring r = _Jv_NewString (unichars, len);\n+      return (jstring) wrap_value (env, r);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+      return NULL;\n+    }\n }\n \n static jsize\n@@ -990,9 +1074,16 @@ _Jv_JNI_ReleaseStringChars (JNIEnv *, jstring string, const jchar *)\n static jstring\n _Jv_JNI_NewStringUTF (JNIEnv *env, const char *bytes)\n {\n-  // FIXME: exception processing.\n-  jstring result = JvNewStringUTF (bytes);\n-  return (jstring) wrap_value (env, result);\n+  try\n+    {\n+      jstring result = JvNewStringUTF (bytes);\n+      return (jstring) wrap_value (env, result);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+      return NULL;\n+    }\n }\n \n static jsize\n@@ -1002,18 +1093,25 @@ _Jv_JNI_GetStringUTFLength (JNIEnv *, jstring string)\n }\n \n static const char *\n-_Jv_JNI_GetStringUTFChars (JNIEnv *, jstring string, jboolean *isCopy)\n+_Jv_JNI_GetStringUTFChars (JNIEnv *env, jstring string, jboolean *isCopy)\n {\n   jsize len = JvGetStringUTFLength (string);\n-  // FIXME: exception processing.\n-  char *r = (char *) _Jv_Malloc (len + 1);\n-  JvGetStringUTFRegion (string, 0, len, r);\n-  r[len] = '\\0';\n+  try\n+    {\n+      char *r = (char *) _Jv_Malloc (len + 1);\n+      JvGetStringUTFRegion (string, 0, len, r);\n+      r[len] = '\\0';\n \n-  if (isCopy)\n-    *isCopy = true;\n+      if (isCopy)\n+\t*isCopy = true;\n \n-  return (const char *) r;\n+      return (const char *) r;\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+      return NULL;\n+    }\n }\n \n static void\n@@ -1029,7 +1127,16 @@ _Jv_JNI_GetStringRegion (JNIEnv *env, jstring string, jsize start, jsize len,\n   jchar *result = _Jv_GetStringChars (string);\n   if (start < 0 || start > string->length ()\n       || len < 0 || start + len > string->length ())\n-    env->ex = new java::lang::StringIndexOutOfBoundsException ();\n+    {\n+      try\n+\t{\n+\t  env->ex = new java::lang::StringIndexOutOfBoundsException ();\n+\t}\n+      catch (jthrowable t)\n+\t{\n+\t  env->ex = t;\n+\t}\n+    }\n   else\n     memcpy (buf, &result[start], len * sizeof (jchar));\n }\n@@ -1040,7 +1147,16 @@ _Jv_JNI_GetStringUTFRegion (JNIEnv *env, jstring str, jsize start,\n {\n   if (start < 0 || start > str->length ()\n       || len < 0 || start + len > str->length ())\n-    env->ex = new java::lang::StringIndexOutOfBoundsException ();\n+    {\n+      try\n+\t{\n+\t  env->ex = new java::lang::StringIndexOutOfBoundsException ();\n+\t}\n+      catch (jthrowable t)\n+\t{\n+\t  env->ex = t;\n+\t}\n+    }\n   else\n     _Jv_GetStringUTFRegion (str, start, len, buf);\n }\n@@ -1070,9 +1186,16 @@ static jarray\n _Jv_JNI_NewObjectArray (JNIEnv *env, jsize length, jclass elementClass,\n \t\t\tjobject init)\n {\n-  // FIXME: exception processing.\n-  jarray result = JvNewObjectArray (length, elementClass, init);\n-  return (jarray) wrap_value (env, result);\n+  try\n+    {\n+      jarray result = JvNewObjectArray (length, elementClass, init);\n+      return (jarray) wrap_value (env, result);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+      return NULL;\n+    }\n }\n \n static jobject\n@@ -1083,21 +1206,34 @@ _Jv_JNI_GetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index)\n }\n \n static void\n-_Jv_JNI_SetObjectArrayElement (JNIEnv *, jobjectArray array, jsize index,\n+_Jv_JNI_SetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index,\n \t\t\t       jobject value)\n {\n-  // FIXME: exception processing.\n-  _Jv_CheckArrayStore (array, value);\n-  jobject *elts = elements (array);\n-  elts[index] = value;\n+  try\n+    {\n+      _Jv_CheckArrayStore (array, value);\n+      jobject *elts = elements (array);\n+      elts[index] = value;\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n }\n \n template<typename T, jclass K>\n static JArray<T> *\n _Jv_JNI_NewPrimitiveArray (JNIEnv *env, jsize length)\n {\n-  // FIXME: exception processing.\n-  return (JArray<T> *) wrap_value (env, _Jv_NewPrimArray (K, length));\n+  try\n+    {\n+      return (JArray<T> *) wrap_value (env, _Jv_NewPrimArray (K, length));\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+      return NULL;\n+    }\n }\n \n template<typename T>\n@@ -1134,8 +1270,16 @@ _Jv_JNI_GetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n {\n   if (start < 0 || len >= array->length || start + len >= array->length)\n     {\n-      // FIXME: index.\n-      env->ex = new java::lang::ArrayIndexOutOfBoundsException ();\n+      try\n+\t{\n+\t  // FIXME: index.\n+\t  env->ex = new java::lang::ArrayIndexOutOfBoundsException ();\n+\t}\n+      catch (jthrowable t)\n+\t{\n+\t  // Could have thown out of memory error.\n+\t  env->ex = t;\n+\t}\n     }\n   else\n     {\n@@ -1151,8 +1295,15 @@ _Jv_JNI_SetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n {\n   if (start < 0 || len >= array->length || start + len >= array->length)\n     {\n-      // FIXME: index.\n-      env->ex = new java::lang::ArrayIndexOutOfBoundsException ();\n+      try\n+\t{\n+\t  // FIXME: index.\n+\t  env->ex = new java::lang::ArrayIndexOutOfBoundsException ();\n+\t}\n+      catch (jthrowable t)\n+\t{\n+\t  env->ex = t;\n+\t}\n     }\n   else\n     {\n@@ -1181,32 +1332,51 @@ _Jv_JNI_ReleasePrimitiveArrayCritical (JNIEnv *, jarray, void *, jint)\n }\n \n static jint\n-_Jv_JNI_MonitorEnter (JNIEnv *, jobject obj)\n+_Jv_JNI_MonitorEnter (JNIEnv *env, jobject obj)\n {\n-  // FIXME: exception processing.\n-  jint r = _Jv_MonitorEnter (obj);\n-  return r;\n+  try\n+    {\n+      return _Jv_MonitorEnter (obj);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n+  return JNI_ERR;\n }\n \n static jint\n-_Jv_JNI_MonitorExit (JNIEnv *, jobject obj)\n+_Jv_JNI_MonitorExit (JNIEnv *env, jobject obj)\n {\n-  // FIXME: exception processing.\n-  jint r = _Jv_MonitorExit (obj);\n-  return r;\n+  try\n+    {\n+      return _Jv_MonitorExit (obj);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n+  return JNI_ERR;\n }\n \n // JDK 1.2\n jobject\n _Jv_JNI_ToReflectedField (JNIEnv *env, jclass cls, jfieldID fieldID,\n \t\t\t  jboolean)\n {\n-  // FIXME: exception processing.\n-  java::lang::reflect::Field *field = new java::lang::reflect::Field();\n-  field->declaringClass = cls;\n-  field->offset = (char*) fieldID - (char *) cls->fields;\n-  field->name = _Jv_NewStringUtf8Const (fieldID->getNameUtf8Const (cls));\n-  return wrap_value (env, field);\n+  try\n+    {\n+      java::lang::reflect::Field *field = new java::lang::reflect::Field();\n+      field->declaringClass = cls;\n+      field->offset = (char*) fieldID - (char *) cls->fields;\n+      field->name = _Jv_NewStringUtf8Const (fieldID->getNameUtf8Const (cls));\n+      return wrap_value (env, field);\n+    }\n+  catch (jthrowable t)\n+    {\n+      env->ex = t;\n+    }\n+  return NULL;\n }\n \n // JDK 1.2\n@@ -1228,21 +1398,29 @@ _Jv_JNI_ToReflectedMethod (JNIEnv *env, jclass klass, jmethodID id,\n   // FIXME.\n   static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n \n-  jobject result;\n-  if (_Jv_equalUtf8Consts (id->name, init_name))\n+  jobject result = NULL;\n+\n+  try\n     {\n-      // A constructor.\n-      Constructor *cons = new Constructor ();\n-      cons->offset = (char *) id - (char *) &klass->methods;\n-      cons->declaringClass = klass;\n-      result = cons;\n+      if (_Jv_equalUtf8Consts (id->name, init_name))\n+\t{\n+\t  // A constructor.\n+\t  Constructor *cons = new Constructor ();\n+\t  cons->offset = (char *) id - (char *) &klass->methods;\n+\t  cons->declaringClass = klass;\n+\t  result = cons;\n+\t}\n+      else\n+\t{\n+\t  Method *meth = new Method ();\n+\t  meth->offset = (char *) id - (char *) &klass->methods;\n+\t  meth->declaringClass = klass;\n+\t  result = meth;\n+\t}\n     }\n-  else\n+  catch (jthrowable t)\n     {\n-      Method *meth = new Method ();\n-      meth->offset = (char *) id - (char *) &klass->methods;\n-      meth->declaringClass = klass;\n-      result = meth;\n+      env->ex = t;\n     }\n \n   return wrap_value (env, result);\n@@ -1302,7 +1480,14 @@ _Jv_JNI_RegisterNatives (JNIEnv *env, jclass k,\n       if (! found)\n \t{\n \t  jstring m = JvNewStringUTF (methods[j].name);\n-\t  _Jv_JNI_Throw (env, new java::lang::NoSuchMethodError (m));\n+\t  try\n+\t    {\n+\t      env->ex =new java::lang::NoSuchMethodError (m);\n+\t    }\n+\t  catch (jthrowable t)\n+\t    {\n+\t      env->ex = t;\n+\t    }\n \t  return JNI_ERR;\n \t}\n     }\n@@ -1545,7 +1730,14 @@ _Jv_JNI_AttachCurrentThread (JavaVM *, jstring name, void **penv, void *args)\n   // have been called simply to set the new JNIEnv.\n   if (_Jv_ThreadCurrent () == NULL)\n     {\n-      (void) new gnu::gcj::jni::NativeThread (group, name);\n+      try\n+\t{\n+\t  (void) new gnu::gcj::jni::NativeThread (group, name);\n+\t}\n+      catch (jthrowable t)\n+\t{\n+\t  return JNI_ERR;\n+\t}\n     }\n   _Jv_SetCurrentJNIEnv (env);\n \n@@ -1567,8 +1759,19 @@ _Jv_JNI_DestroyJavaVM (JavaVM *vm)\n   JNIEnv *env;\n   if (_Jv_ThreadCurrent () != NULL)\n     {\n+      jstring main_name;\n+      // This sucks.\n+      try\n+\t{\n+\t  main_name = JvNewStringLatin1 (\"main\");\n+\t}\n+      catch (jthrowable t)\n+\t{\n+\t  return JNI_ERR;\n+\t}\n+\n       jint r = _Jv_JNI_AttachCurrentThread (vm,\n-\t\t\t\t\t    JvNewStringLatin1 (\"main\"),\n+\t\t\t\t\t    main_name,\n \t\t\t\t\t    reinterpret_cast<void **> (&env),\n \t\t\t\t\t    NULL);\n       if (r < 0)"}]}