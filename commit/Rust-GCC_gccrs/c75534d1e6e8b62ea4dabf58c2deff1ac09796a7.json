{"sha": "c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1NTM0ZDFlNmU4YjYyZWE0ZGFiZjU4YzJkZWZmMWFjMDk3OTZhNw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-21T13:44:04Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-21T13:44:04Z"}, "message": "In libobjc/: 2010-12-21 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/45953\n\t* selector.c (__sel_register_typed_name): When registering a new\n\tselector with the same name as an existing one, reuse the existing\n\tname string.  Also updated types, casts and comments in the whole\n\tfunction.\n\nIn gcc/testsuite/:\n2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/45953\n\t* objc.dg/libobjc-selector-1.m: New test.\n\nFrom-SVN: r168115", "tree": {"sha": "7f571fa1e6bfcad3a54cae1509897fe496642bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f571fa1e6bfcad3a54cae1509897fe496642bfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb227aa9ab85856f4906ff49caef1bcee87ec643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb227aa9ab85856f4906ff49caef1bcee87ec643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb227aa9ab85856f4906ff49caef1bcee87ec643"}], "stats": {"total": 148, "additions": 108, "deletions": 40}, "files": [{"sha": "50cfa32e38c4bf061141019e854bd0ad62607f2a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "patch": "@@ -1,3 +1,8 @@\n+2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/45953\n+\t* objc.dg/libobjc-selector-1.m: New test.\n+\n 2010-12-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/45852"}, {"sha": "49947d7b8722fedfade09e7cfc493c74cdcf9866", "filename": "gcc/testsuite/objc.dg/libobjc-selector-1.m", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/gcc%2Ftestsuite%2Fobjc.dg%2Flibobjc-selector-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/gcc%2Ftestsuite%2Fobjc.dg%2Flibobjc-selector-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Flibobjc-selector-1.m?ref=c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "patch": "@@ -0,0 +1,39 @@\n+/* Test a little inefficiency that was fixed in libobjc when dealing\n+   with selectors (PR libobjc/45953).  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+/* Test that registering a new selector, with the same name but a\n+   different type than the previous one, does not change the original\n+   name string.  It is actually fine to change it (there is no\n+   guarantee that it won't change), except for runtime performance /\n+   memory consumption, since changing it means that the runtime is\n+   doing an unneeded objc_malloc()/strcpy(), which is inefficient.  */\n+\n+int main (void)\n+{\n+  SEL selector_1;\n+  SEL selector_2;\n+  const char *name_1;\n+  const char *name_2;\n+\n+  /* These method type strings may well be invalid.  Please don't use\n+     them as examples.  They are irrelevant for this test; any string\n+     will do.  */\n+  selector_1 = sel_registerTypedName (\"method\", \"v@:\");\n+  name_1 = sel_getName (selector_1);\n+\n+  selector_2 = sel_registerTypedName (\"method\", \"i@:\");\n+  name_2 = sel_getName (selector_1);\n+\n+  if (name_1 != name_2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "83387eef6796f390c45306bc877bfebd91c2e182", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "patch": "@@ -1,3 +1,11 @@\n+2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/45953\n+\t* selector.c (__sel_register_typed_name): When registering a new\n+\tselector with the same name as an existing one, reuse the existing\n+\tname string.  Also updated types, casts and comments in the whole\n+\tfunction.\n+\n 2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-private/module-abi-8.h (struct objc_symtab): Declare 'refs'"}, {"sha": "4fd213ba919667d6e0629cbab5f3561c23d24444", "filename": "libobjc/selector.c", "status": "modified", "additions": 56, "deletions": 40, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75534d1e6e8b62ea4dabf58c2deff1ac09796a7/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=c75534d1e6e8b62ea4dabf58c2deff1ac09796a7", "patch": "@@ -451,17 +451,19 @@ __sel_register_typed_name (const char *name, const char *types,\n   i = (sidx) objc_hash_value_for_key (__objc_selector_hash, name);\n   if (soffset_decode (i) != 0)\n     {\n-      for (l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n+      /* There are already selectors with that name.  Examine them to\n+\t see if the one we're registering already exists.  */\n+      for (l = (struct objc_list *)sarray_get_safe (__objc_selector_array, i);\n \t   l; l = l->tail)\n \t{\n-\t  SEL s = (SEL) l->head;\n+\t  SEL s = (SEL)l->head;\n \t  if (types == 0 || s->sel_types == 0)\n \t    {\n \t      if (s->sel_types == types)\n \t\t{\n \t\t  if (orig)\n \t\t    {\n-\t\t      orig->sel_id = (void *) i;\n+\t\t      orig->sel_id = (void *)i;\n \t\t      return orig;\n \t\t    }\n \t\t  else\n@@ -472,79 +474,93 @@ __sel_register_typed_name (const char *name, const char *types,\n \t    {\n \t      if (orig)\n \t\t{\n-\t\t  orig->sel_id = (void *) i;\n+\t\t  orig->sel_id = (void *)i;\n \t\t  return orig;\n \t\t}\n \t      else\n \t\treturn s;\n \t    }\n \t}\n+      /* A selector with this specific name/type combination does not\n+\t exist yet.  We need to register it.  */\n       if (orig)\n \tj = orig;\n       else\n \tj = pool_alloc_selector ();\n       \n-      j->sel_id = (void *) i;\n-      /* Can we use the pointer or must copy types?  Don't copy if\n+      j->sel_id = (void *)i;\n+      /* Can we use the pointer or must we copy types ?  Don't copy if\n \t NULL.  */\n       if ((is_const) || (types == 0))\n-\tj->sel_types = (const char *) types;\n+\tj->sel_types = types;\n       else\n \t{\n-\t  j->sel_types = (char *) objc_malloc (strlen (types) + 1);\n-\t  strcpy ((char *) j->sel_types, types);\n+\t  j->sel_types = (char *)objc_malloc (strlen (types) + 1);\n+\t  strcpy ((char *)j->sel_types, types);\n \t}\n-      l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n+      l = (struct objc_list *)sarray_get_safe (__objc_selector_array, i);\n     }\n   else\n     {\n+      /* There are no other selectors with this name registered in the\n+\t runtime tables.  */\n+      const char *new_name;\n+\n+      /* Determine i.  */\n       __objc_selector_max_index += 1;\n       i = soffset_encode (__objc_selector_max_index);\n+\n+      /* Prepare the selector.  */\n       if (orig)\n \tj = orig;\n       else\n \tj = pool_alloc_selector ();\n       \n-      j->sel_id = (void *) i;\n-      /* Can we use the pointer or must copy types?  Don't copy if\n+      j->sel_id = (void *)i;\n+      /* Can we use the pointer or must we copy types ?  Don't copy if\n \t NULL.  */\n-      if ((is_const) || (types == 0))\n-\tj->sel_types = (const char *) types;\n+      if (is_const || (types == 0))\n+\tj->sel_types = types;\n+      else\n+\t{\n+\t  j->sel_types = (char *)objc_malloc (strlen (types) + 1);\n+\t  strcpy ((char *)j->sel_types, types);\n+\t}\n+\n+      /* Since this is the first selector with this name, we need to\n+\t register the correspondence between 'i' (the sel_id) and\n+\t 'name' (the actual string) in __objc_selector_names and\n+\t __objc_selector_hash.  */\n+      \n+      /* Can we use the pointer or must we copy name ?  Don't copy if\n+\t NULL.  (FIXME: Can the name really be NULL here ?)  */\n+      if (is_const || (name == 0))\n+\tnew_name = name;\n       else\n \t{\n-\t  j->sel_types = (char *) objc_malloc (strlen (types) + 1);\n-\t  strcpy ((char *) j->sel_types, types);\n+\t  new_name = (char *)objc_malloc (strlen (name) + 1);\n+\t  strcpy ((char *)new_name, name);\n \t}\n+      \n+      /* This maps the sel_id to the name.  */\n+      sarray_at_put_safe (__objc_selector_names, i, (void *)new_name);\n+\n+      /* This maps the name to the sel_id.  */\n+      objc_hash_add (&__objc_selector_hash, (void *)new_name, (void *)i);\n+\n       l = 0;\n     }\n \n   DEBUG_PRINTF (\"Record selector %s[%s] as: %ld\\n\", name, types, \n-\t\t(long) soffset_decode (i));\n-  \n-  {\n-    int is_new = (l == 0);\n-    const char *new_name;\n-\n-    /* Can we use the pointer or must copy name?  Don't copy if\n-       NULL.  */\n-    if ((is_const) || (name == 0))\n-      new_name = name;\n-    else\n-      {\n-\tnew_name = (char *) objc_malloc (strlen (name) + 1);\n-\tstrcpy ((char *) new_name, name);\n-      }\n-    \n-    l = list_cons ((void *) j, l);\n-    sarray_at_put_safe (__objc_selector_names, i, (void *) new_name);\n-    sarray_at_put_safe (__objc_selector_array, i, (void *) l);\n-    if (is_new)\n-      objc_hash_add (&__objc_selector_hash, (void *) new_name, (void *) i);\n-  }\n-  \n+\t\t(long)soffset_decode (i));\n+\n+  /* Now add the selector to the list of selectors with that id.  */\n+  l = list_cons ((void *)j, l);\n+  sarray_at_put_safe (__objc_selector_array, i, (void *)l);\n+\n   sarray_realloc (__objc_uninstalled_dtable, __objc_selector_max_index + 1);\n   \n-  return (SEL) j;\n+  return (SEL)j;\n }\n \n SEL"}]}