{"sha": "a9f71ad8db46abada800399889b8e5fc9e024026", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlmNzFhZDhkYjQ2YWJhZGE4MDAzOTk4ODliOGU1ZmM5ZTAyNDAyNg==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-05-04T15:21:44Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-05-04T15:21:44Z"}, "message": "> (arith_reg_operand): New constraint.\n\n> (arith_reg_operand): New constraint.  (dump_constants): Force\n out a constant table if necessary.\n\nFrom-SVN: r4321", "tree": {"sha": "a7daca333f0ab02f24256339debcf701e2918771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7daca333f0ab02f24256339debcf701e2918771"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9f71ad8db46abada800399889b8e5fc9e024026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9f71ad8db46abada800399889b8e5fc9e024026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9f71ad8db46abada800399889b8e5fc9e024026", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9f71ad8db46abada800399889b8e5fc9e024026/comments", "author": null, "committer": null, "parents": [{"sha": "bc1ebe6373abe535f0d64cb2b17692fa16c285e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc1ebe6373abe535f0d64cb2b17692fa16c285e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc1ebe6373abe535f0d64cb2b17692fa16c285e0"}], "stats": {"total": 111, "additions": 96, "deletions": 15}, "files": [{"sha": "07c82576f1fd67e79bb9b0549fd33d51f4fde1c1", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 96, "deletions": 15, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9f71ad8db46abada800399889b8e5fc9e024026/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9f71ad8db46abada800399889b8e5fc9e024026/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a9f71ad8db46abada800399889b8e5fc9e024026", "patch": "@@ -39,7 +39,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n static int add_constant ();\n-static void dump_constants ();\n+static int dump_constants ();\n \n int current_function_anonymous_args;\n extern int current_function_pretend_args_size;\n@@ -83,12 +83,13 @@ enum reg_class reg_class_from_letter[] =\n /* Local label counter, used for constants in the pool and inside\n    pattern branches.  */\n \n-static int lf;\n+static int lf = 100;\n \n /* Used to work out sizes of instructions */\n static int first_pc;\n static int pc;\n-\n+#define MAYBE_DUMP_LEVEL 900\n+#define MUST_DUMP_LEVEL 1000\n static int dumpnext;\n \f\n /* Functions for generating procedure prologue and epilogue code */\n@@ -389,9 +390,27 @@ output_epilogue (f, frame_size)\n   int live_regs_mask = 0;\n   int d;\n   int i;\n-\n+  rtx delay_insn;\n+  \n   live_regs_mask = calc_live_regs (&d);\n \n+\n+  /* See if the delay insn is really ok for the slot. */\n+  if (current_function_epilogue_delay_list) {\n+    delay_insn = PATTERN (XEXP (current_function_epilogue_delay_list, 0));\n+\n+  if (GET_CODE (delay_insn) == SET\n+      && SET_DEST (delay_insn) == stack_pointer_rtx)\n+    {\n+      /* Can not use this instruction in the delay slot because\n+\t it changes the stack pointer, so emit it now.  */\n+      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t       asm_out_file, 1, 0, 1);\n+      current_function_epilogue_delay_list = 0;\n+    }\n+  }\n+  \n+\n   /* Reclaim the room for the automatics. */\n \n   output_stack_adjust (f, 1, frame_size);\n@@ -443,7 +462,7 @@ output_epilogue (f, frame_size)\n \n   output_epilogue_vec ();\n \n-  dump_constants ();\n+  dump_constants (0);\n   current_function_anonymous_args = 0;\n }\n \f\n@@ -530,7 +549,7 @@ print_operand (stream, x, code)\n       fprintf (stream, \"LF%d\", lf);\n       break;\n     case '!':\n-      dump_constants();\n+      dump_constants (0);\n       break;\n     case '^':\n       lf++;\n@@ -674,7 +693,14 @@ output_movedouble (operands, mode)\n     {\n       if (REGNO (operands[1]) == MACH_REG)\n \treturn \"sts\tmach,%0\\n\\tsts\tmacl,%R0\";\n-      return \"mov\t%1,%0\\n\\tmov\t%R1,%R0\";\n+      if (REGNO (operands[1]) > REGNO (operands[0])) \n+\t{\n+\t  return \"mov\t%1,%0\\n\\tmov\t%R1,%R0\";\n+\t}\n+      else \n+\t{\n+\t  return \"mov\t%R1,%R0\\n\\tmov\t%1,%0\";\n+\t}\n     }\n \n   if (GET_CODE (operands[1]) == CONST_INT)\n@@ -780,8 +806,8 @@ output_branch (logic, insn)\n       fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n       output_asm_insn (\"bra\t%l0\t! 12 bit cond \", recog_operand);\n       fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+      label = dump_constants (label);\n       fprintf (asm_out_file, \"LF%d:\\n\", label);\n-      lf++;\n       return \"\";\n \n     case 8:\n@@ -800,6 +826,23 @@ output_branch (logic, insn)\n \f\n /* Predicates used by the templates */\n \n+/* Nonzero if OP is a normal arithmetic register. */\n+\n+int\n+arith_reg_operand(op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    {\n+      if (GET_CODE (op) == REG)\n+\treturn REGNO (op) != T_REG;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+  \n /* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n \n int\n@@ -1054,7 +1097,7 @@ adjust_insn_length (insn, insn_lengths)\n \t     instruction than it can reach, so we'll stop accumulating\n \t     from that one and start fresh. */\n \t  target_pc = current_pc;\n-\t  target_insn_range = current_pc + 1000;\n+\t  target_insn_range = current_pc + MAYBE_DUMP_LEVEL;\n \t}\n       else\n \t{\n@@ -1087,18 +1130,25 @@ adjust_insn_length (insn, insn_lengths)\n }\n \n \n-/* Dump out the pending constant pool.  */\n+/* Dump out the pending constant pool. \n+   If label provided then insert an branch in the middle of the table \n+  */\n \n-static void\n-dump_constants ()\n+static int\n+dump_constants (label)\n {\n   int i;\n+  int rlabel = label;\n+  int size = 0;\n+  \n   for (i = 0; i < pool_size; i++)\n     {\n       pool_node *p = pool_vector + i;\n       fprintf (asm_out_file, \"\\n\\t! constants - waited %d\\n\", pc - first_pc);\n       fprintf (asm_out_file, \"\\t.align\\t2\\n\");\n       fprintf (asm_out_file, \"LK%d:\", p->number);\n+      size += GET_MODE_SIZE (p->mode);\n+      \n       switch (GET_MODE_CLASS (p->mode))\n \t{\n \tcase MODE_INT:\n@@ -1112,12 +1162,23 @@ dump_constants ()\n \t    assemble_real (u.d, p->mode);\n \t  }\n \t}\n-\n+      \n+      /* After 200 bytes of table, stick in another branch */\n+      if (label && size > 200) \n+\t{\n+\t  rlabel = lf ++;\n+\t  fprintf (asm_out_file,\"LF%d:\\tbra\tLF%d\\n\", label, rlabel);\n+\t  fprintf (asm_out_file,\"\\tor\tr0,r0\\n\");\n+\t  label = 0;\n+\t}\n+      \n       fprintf (asm_out_file, \"\\n\");\n     }\n   pool_size = 0;\n   current_pc = 0;\n   target_insn_range = 0;\n+  return rlabel;\n+  \n }\n \n \n@@ -1151,7 +1212,7 @@ output_movepcrel (insn, operands, mode)\n       fprintf (asm_out_file, \"\\t!constant table start\\n\");\n       fprintf (asm_out_file, \"\\tbra\tLF%d\\n\", lf);\n       fprintf (asm_out_file, \"\\tor\tr0,r0 ! wasted slot\\n\");\n-      dump_constants ();\n+      dump_constants (0);\n       fprintf (asm_out_file, \"LF%d:\\n\", lf++);\n       fprintf (asm_out_file, \"\\t!constant table end\\n\");\n     }\n@@ -1182,7 +1243,27 @@ final_prescan_insn (insn, opvec, noperands)\n       if (TARGET_DUMP_RTL)\n \tprint_rtl (asm_out_file, body);\n \n-      pc += get_attr_length (insn);\n+\n     }\n+  \n+  pc += get_attr_length (insn);\n+\n+  if (pool_size && pc - first_pc > MUST_DUMP_LEVEL)\n+    {\n+      /* For some reason we have not dumped out a constant table, and \n+      we have emitted a lot of code.  This can happen if the think\n+      which wants the table is a long conditional branch (which has no\n+      room for a constant table), and there has not been a move\n+      constant anywhere. */\n+      int label = lf++;\n+      fprintf (asm_out_file, \"\\t!forced constant table\\n\");      \n+      fprintf (asm_out_file, \"\\tbra\tLF%d\\n\", label);\n+      fprintf (asm_out_file, \"\\tor\tr0,r0 ! wasted slot\\n\");\n+      label = dump_constants (label);\n+      fprintf (asm_out_file, \"LF%d:\\n\", label);\n+      fprintf (asm_out_file, \"\\t!constant table end\\n\");\n+    }\n+  \n }\n \n+"}]}