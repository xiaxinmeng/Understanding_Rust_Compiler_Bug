{"sha": "3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZjY2JiOWVjZWM3ZGFhM2I2NDY4ZjcyMzc5YzBiZDFmYjViYjhkOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-01-15T09:05:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-01-15T09:05:59Z"}, "message": "re PR middle-end/82694 (Linux kernel miscompiled since r250765)\n\n\tPR middle-end/82694\n\t* common.opt (fstrict-overflow): No longer an alias.\n\t(fwrapv-pointer): New option.\n\t* tree.h (TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED): Define\n\talso for pointer types based on flag_wrapv_pointer.\n\t* opts.c (common_handle_option) <case OPT_fstrict_overflow>: Set\n\topts->x_flag_wrap[pv] to !value, clear opts->x_flag_trapv if\n\topts->x_flag_wrapv got set.\n\t* fold-const.c (fold_comparison, fold_binary_loc): Revert 2017-08-01\n\tchanges, just use TYPE_OVERFLOW_UNDEFINED on pointer type instead of\n\tPOINTER_TYPE_OVERFLOW_UNDEFINED.\n\t* match.pd: Likewise in address comparison pattern.\n\t* doc/invoke.texi: Document -fwrapv and -fstrict-overflow.\n\n\t* gcc.dg/no-strict-overflow-7.c: Revert 2017-08-01 changes.\n\t* gcc.dg/tree-ssa/pr81388-1.c: Likewise.\n\nFrom-SVN: r256686", "tree": {"sha": "08c17fa7abe77e42e46b0fdf6d49c9bdf48fc9a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08c17fa7abe77e42e46b0fdf6d49c9bdf48fc9a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2aa89839f557b7467704ddffa4dc43a130e8d027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa89839f557b7467704ddffa4dc43a130e8d027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa89839f557b7467704ddffa4dc43a130e8d027"}], "stats": {"total": 111, "additions": 87, "deletions": 24}, "files": [{"sha": "76977e0d053556e6ffbf3c2f198ee2c80283a035", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -1,3 +1,19 @@\n+2018-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/82694\n+\t* common.opt (fstrict-overflow): No longer an alias.\n+\t(fwrapv-pointer): New option.\n+\t* tree.h (TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED): Define\n+\talso for pointer types based on flag_wrapv_pointer.\n+\t* opts.c (common_handle_option) <case OPT_fstrict_overflow>: Set\n+\topts->x_flag_wrap[pv] to !value, clear opts->x_flag_trapv if\n+\topts->x_flag_wrapv got set.\n+\t* fold-const.c (fold_comparison, fold_binary_loc): Revert 2017-08-01\n+\tchanges, just use TYPE_OVERFLOW_UNDEFINED on pointer type instead of\n+\tPOINTER_TYPE_OVERFLOW_UNDEFINED.\n+\t* match.pd: Likewise in address comparison pattern.\n+\t* doc/invoke.texi: Document -fwrapv and -fstrict-overflow.\n+\n 2018-01-15  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/83804"}, {"sha": "b20a9aac82e1c82c1a55c8bc67ecfdd1fe9d85bc", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -2411,8 +2411,8 @@ Common Report Var(flag_strict_aliasing) Optimization\n Assume strict aliasing rules apply.\n \n fstrict-overflow\n-Common NegativeAlias Alias(fwrapv)\n-Treat signed overflow as undefined.  Negated as -fwrapv.\n+Common Report\n+Treat signed overflow as undefined.  Negated as -fwrapv -fwrapv-pointer.\n \n fsync-libcalls\n Common Report Var(flag_sync_libcalls) Init(1)\n@@ -2860,6 +2860,10 @@ fwhole-program\n Common Report Var(flag_whole_program) Init(0)\n Perform whole program optimizations.\n \n+fwrapv-pointer\n+Common Report Var(flag_wrapv_pointer) Optimization\n+Assume pointer overflow wraps around.\n+\n fwrapv\n Common Report Var(flag_wrapv) Optimization\n Assume signed arithmetic overflow wraps around."}, {"sha": "98b73db17afb6e39b4e1ae585223df87a6655139", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -12581,6 +12581,18 @@ The options @option{-ftrapv} and @option{-fwrapv} override each other, so using\n using @option{-ftrapv} @option{-fwrapv} @option{-fno-wrapv} on the command-line\n results in @option{-ftrapv} being effective.\n \n+@item -fwrapv-pointer\n+@opindex fwrapv-pointer\n+This option instructs the compiler to assume that pointer arithmetic\n+overflow on addition and subtraction wraps around using twos-complement\n+representation.  This flag disables some optimizations which assume\n+pointer overflow is invalid.\n+\n+@item -fstrict-overflow\n+@opindex fstrict-overflow\n+This option implies @option{-fno-wrapv} @option{-fno-wrapv-pointer} and when\n+negated implies @option{-fwrapv} @option{-fwrapv-pointer}.\n+\n @item -fexceptions\n @opindex fexceptions\n Enable exception handling.  Generates extra code needed to propagate"}, {"sha": "f3749db7ed65489eb91cf2313325efa26869b88c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -8551,9 +8551,13 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t{\n \t  /* We can fold this expression to a constant if the non-constant\n \t     offset parts are equal.  */\n-\t  if (offset0 == offset1\n-\t      || (offset0 && offset1\n-\t\t  && operand_equal_p (offset0, offset1, 0)))\n+\t  if ((offset0 == offset1\n+\t       || (offset0 && offset1\n+\t\t   && operand_equal_p (offset0, offset1, 0)))\n+\t      && (equality_code\n+\t\t  || (indirect_base0\n+\t\t      && (DECL_P (base0) || CONSTANT_CLASS_P (base0)))\n+\t\t  || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))))\n \t    {\n \t      if (!equality_code\n \t\t  && maybe_ne (bitpos0, bitpos1)\n@@ -8612,7 +8616,11 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t     because pointer arithmetic is restricted to retain within an\n \t     object and overflow on pointer differences is undefined as of\n \t     6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n-\t  else if (known_eq (bitpos0, bitpos1))\n+\t  else if (known_eq (bitpos0, bitpos1)\n+\t\t   && (equality_code\n+\t\t       || (indirect_base0\n+\t\t\t   && (DECL_P (base0) || CONSTANT_CLASS_P (base0)))\n+\t\t       || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))))\n \t    {\n \t      /* By converting to signed sizetype we cover middle-end pointer\n \t         arithmetic which operates on unsigned pointer types of size\n@@ -9721,8 +9729,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \n \t  /* With undefined overflow prefer doing association in a type\n \t     which wraps on overflow, if that is one of the operand types.  */\n-\t  if (POINTER_TYPE_P (type)\n-\t      || (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type)))\n+\t  if ((POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type))\n+\t      && !TYPE_OVERFLOW_WRAPS (type))\n \t    {\n \t      if (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n \t\t  && TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0)))\n@@ -9735,8 +9743,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \n \t  /* With undefined overflow we can only associate constants with one\n \t     variable, and constants whose association doesn't overflow.  */\n-\t  if (POINTER_TYPE_P (atype)\n-\t      || (INTEGRAL_TYPE_P (atype) && !TYPE_OVERFLOW_WRAPS (atype)))\n+\t  if ((POINTER_TYPE_P (atype) || INTEGRAL_TYPE_P (atype))\n+\t      && !TYPE_OVERFLOW_WRAPS (atype))\n \t    {\n \t      if ((var0 && var1) || (minus_var0 && minus_var1))\n \t\t{"}, {"sha": "3f6e0094bf503696fa65d4d3b50ca1a41df3dcab", "filename": "gcc/match.pd", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -3610,7 +3610,14 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t\t    || TREE_CODE (base1) == STRING_CST))\n          equal = (base0 == base1);\n      }\n-     (if (equal == 1)\n+     (if (equal == 1\n+\t  && (cmp == EQ_EXPR || cmp == NE_EXPR\n+\t      /* If the offsets are equal we can ignore overflow.  */\n+\t      || known_eq (off0, off1)\n+\t      || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0))\n+\t\t /* Or if we compare using pointers to decls or strings.  */\n+\t      || (POINTER_TYPE_P (TREE_TYPE (@2))\n+\t\t  && (DECL_P (base0) || TREE_CODE (base0) == STRING_CST))))\n       (switch\n        (if (cmp == EQ_EXPR && (known_eq (off0, off1) || known_ne (off0, off1)))\n \t{ constant_boolean_node (known_eq (off0, off1), type); })"}, {"sha": "b1b6a325d092c9c602c720e9f2cab8ba6a2dec0c", "filename": "gcc/opts.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -2465,6 +2465,13 @@ common_handle_option (struct gcc_options *opts,\n \topts->x_flag_wrapv = 0;\n       break;\n \n+    case OPT_fstrict_overflow:\n+      opts->x_flag_wrapv = !value;\n+      opts->x_flag_wrapv_pointer = !value;\n+      if (!value)\n+\topts->x_flag_trapv = 0;\n+      break;\n+\n     case OPT_fipa_icf:\n       opts->x_flag_ipa_icf_functions = value;\n       opts->x_flag_ipa_icf_variables = value;"}, {"sha": "546fc82c9f00f06721af2bf714f76f93f9b7f8ad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -1,3 +1,9 @@\n+2018-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/82694\n+\t* gcc.dg/no-strict-overflow-7.c: Revert 2017-08-01 changes.\n+\t* gcc.dg/tree-ssa/pr81388-1.c: Likewise.\n+\n 2018-01-10  Martin Sebor  <msebor@redhat.com>\n \n \tPR other/83508"}, {"sha": "19e1b55bb12f8f530efbb3dcb5d1400c543ba1aa", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-7.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -3,13 +3,13 @@\n \n /* Source: Ian Lance Taylor.  Dual of strict-overflow-6.c.  */\n \n-/* We can simplify the conditional because pointer overflow always has\n-   undefined semantics.  */\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n \n int\n foo (char* p)\n {\n   return p + 1000 < p;\n }\n \n-/* { dg-final { scan-tree-dump \"return 0\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"\\[+\\]\\[ \\]*1000\" \"optimized\" } } */"}, {"sha": "85c00e56144d542cc52e8687717f2667af33fefb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81388-1.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-strict-overflow -fdump-tree-tailc-details\" } */\n+/* { dg-options \"-O2 -fno-strict-overflow -fdump-tree-ivcanon-details\" } */\n \n void bar();\n void foo(char *dst)\n@@ -11,6 +11,4 @@ void foo(char *dst)\n   } while (dst < end);\n }\n \n-/* The loop only iterates once because pointer overflow always has undefined\n-   semantics.  As a result, call to bar becomes tail call.  */\n-/* { dg-final { scan-tree-dump-times \"Found tail call \" 1 \"tailc\" } } */\n+/* { dg-final { scan-tree-dump \" zero if \" \"ivcanon\" } } */"}, {"sha": "af8a6fb380c515a44a660f218b0229c07517b413", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3fccbb9ecec7daa3b6468f72379c0bd1fb5bb8d9", "patch": "@@ -829,22 +829,27 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* Same as TYPE_UNSIGNED but converted to SIGNOP.  */\n #define TYPE_SIGN(NODE) ((signop) TYPE_UNSIGNED (NODE))\n \n-/* True if overflow wraps around for the given integral type.  That\n+/* True if overflow wraps around for the given integral or pointer type.  That\n    is, TYPE_MAX + 1 == TYPE_MIN.  */\n #define TYPE_OVERFLOW_WRAPS(TYPE) \\\n-  (ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag || flag_wrapv)\n+  (POINTER_TYPE_P (TYPE)\t\t\t\t\t\\\n+   ? flag_wrapv_pointer\t\t\t\t\t\t\\\n+   : (ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag\t\\\n+      || flag_wrapv))\n \n-/* True if overflow is undefined for the given integral type.  We may\n-   optimize on the assumption that values in the type never overflow.\n+/* True if overflow is undefined for the given integral or pointer type.\n+   We may optimize on the assumption that values in the type never overflow.\n \n    IMPORTANT NOTE: Any optimization based on TYPE_OVERFLOW_UNDEFINED\n    must issue a warning based on warn_strict_overflow.  In some cases\n    it will be appropriate to issue the warning immediately, and in\n    other cases it will be appropriate to simply set a flag and let the\n    caller decide whether a warning is appropriate or not.  */\n #define TYPE_OVERFLOW_UNDEFINED(TYPE)\t\t\t\t\\\n-  (!ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag\t\\\n-   && !flag_wrapv && !flag_trapv)\n+  (POINTER_TYPE_P (TYPE)\t\t\t\t\t\\\n+   ? !flag_wrapv_pointer\t\t\t\t\t\\\n+   : (!ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag\t\\\n+      && !flag_wrapv && !flag_trapv))\n \n /* True if overflow for the given integral type should issue a\n    trap.  */"}]}