{"sha": "9bcedbbfc510e79cd299001dd79756ee4173b411", "node_id": "C_kwDOANBUbNoAKDliY2VkYmJmYzUxMGU3OWNkMjk5MDAxZGQ3OTc1NmVlNDE3M2I0MTE", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-01T14:19:28Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-01T19:31:00Z"}, "message": "libstdc++: Optimize is_constructible traits\n\nWe can replace some class template helpers with alias templates, which\nare cheaper to instantiate.\n\nFor example, replace the __is_copy_constructible_impl class template\nwith an alias template that uses just evaluates the __is_constructible\nbuilt-in, using add_lvalue_reference<const T> to get the argument type\nin a way that works for non-referenceable types. For a given\nspecialization of is_copy_constructible this results in the same number\nof class templates being instantiated (for the common case of non-void,\nnon-function types), but the add_lvalue_reference instantiations are not\nspecific to the is_copy_constructible specialization and so can be\nreused by other traits. Previously __is_copy_constructible_impl was a\ndistinct class template and its specializations were never used for\nanything except is_copy_constructible.\n\nWith the new definitions of these traits that don't depend on helper\nclasses, it becomes more practical to optimize the\nis_xxx_constructible_v variable templates to avoid instantiations.\nPreviously doing so would have meant two entirely separate\nimplementation strategies for these traits.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits (__is_constructible_impl): Replace\n\tclass template with alias template.\n\t(is_default_constructible, is_nothrow_constructible)\n\t(is_nothrow_constructible): Simplify base-specifier.\n\t(__is_copy_constructible_impl, __is_move_constructible_impl)\n\t(__is_nothrow_copy_constructible_impl)\n\t(__is_nothrow_move_constructible_impl): Remove class templates.\n\t(is_copy_constructible, is_move_constructible)\n\t(is_nothrow_constructible, is_nothrow_default_constructible)\n\t(is_nothrow_copy_constructible, is_nothrow_move_constructible):\n\tAdjust base-specifiers to use __is_constructible_impl.\n\t(__is_copy_assignable_impl, __is_move_assignable_impl)\n\t(__is_nt_copy_assignable_impl, __is_nt_move_assignable_impl):\n\tRemove class templates.\n\t(__is_assignable_impl): New alias template.\n\t(is_assignable, is_copy_assignable, is_move_assignable):\n\tAdjust base-specifiers to use new alias template.\n\t(is_nothrow_copy_assignable, is_nothrow_move_assignable):\n\tAdjust base-specifiers to use existing alias template.\n\t(__is_trivially_constructible_impl): New alias template.\n\t(is_trivially_constructible, is_trivially_default_constructible)\n\t(is_trivially_copy_constructible)\n\t(is_trivially_move_constructible): Adjust base-specifiers to use\n\tnew alias template.\n\t(__is_trivially_assignable_impl): New alias template.\n\t(is_trivially_assignable, is_trivially_copy_assignable)\n\t(is_trivially_move_assignable): Adjust base-specifier to use\n\tnew alias template.\n\t(__add_lval_ref_t, __add_rval_ref_t): New alias templates.\n\t(add_lvalue_reference, add_rvalue_reference): Use new alias\n\ttemplates.", "tree": {"sha": "f1b686f4d96ee4f11addce22a469d8aec2ebe842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1b686f4d96ee4f11addce22a469d8aec2ebe842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bcedbbfc510e79cd299001dd79756ee4173b411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcedbbfc510e79cd299001dd79756ee4173b411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bcedbbfc510e79cd299001dd79756ee4173b411", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcedbbfc510e79cd299001dd79756ee4173b411/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "775fe01b38933850dcb884733c4d0edc7cde45c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/775fe01b38933850dcb884733c4d0edc7cde45c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/775fe01b38933850dcb884733c4d0edc7cde45c3"}], "stats": {"total": 239, "additions": 57, "deletions": 182}, "files": [{"sha": "3041ac3c941432dcd46ba5687504cd8fc852d5b3", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 57, "deletions": 182, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcedbbfc510e79cd299001dd79756ee4173b411/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcedbbfc510e79cd299001dd79756ee4173b411/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=9bcedbbfc510e79cd299001dd79756ee4173b411", "patch": "@@ -1001,9 +1001,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// @cond undocumented\n   template<typename _Tp, typename... _Args>\n-    struct __is_constructible_impl\n-    : public __bool_constant<__is_constructible(_Tp, _Args...)>\n-    { };\n+    using __is_constructible_impl\n+      = __bool_constant<__is_constructible(_Tp, _Args...)>;\n   /// @endcond\n \n   /// is_constructible\n@@ -1018,53 +1017,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// is_default_constructible\n   template<typename _Tp>\n     struct is_default_constructible\n-    : public __is_constructible_impl<_Tp>::type\n+    : public __is_constructible_impl<_Tp>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n   /// @cond undocumented\n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_copy_constructible_impl;\n+    struct __add_lvalue_reference_helper\n+    { using type = _Tp; };\n \n   template<typename _Tp>\n-    struct __is_copy_constructible_impl<_Tp, false>\n-    : public false_type { };\n+    struct __add_lvalue_reference_helper<_Tp, true>\n+    { using type = _Tp&; };\n \n   template<typename _Tp>\n-    struct __is_copy_constructible_impl<_Tp, true>\n-    : public __is_constructible_impl<_Tp, const _Tp&>\n-    { };\n+    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;\n   /// @endcond\n \n   /// is_copy_constructible\n   template<typename _Tp>\n     struct is_copy_constructible\n-    : public __is_copy_constructible_impl<_Tp>\n+    : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n   /// @cond undocumented\n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_move_constructible_impl;\n+    struct __add_rvalue_reference_helper\n+    { using type = _Tp; };\n \n   template<typename _Tp>\n-    struct __is_move_constructible_impl<_Tp, false>\n-    : public false_type { };\n+    struct __add_rvalue_reference_helper<_Tp, true>\n+    { using type = _Tp&&; };\n \n   template<typename _Tp>\n-    struct __is_move_constructible_impl<_Tp, true>\n-    : public __is_constructible_impl<_Tp, _Tp&&>\n-    { };\n+    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;\n   /// @endcond\n \n   /// is_move_constructible\n   template<typename _Tp>\n     struct is_move_constructible\n-    : public __is_move_constructible_impl<_Tp>\n+    : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n@@ -1079,7 +1076,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// is_nothrow_constructible\n   template<typename _Tp, typename... _Args>\n     struct is_nothrow_constructible\n-    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type\n+    : public __is_nothrow_constructible_impl<_Tp, _Args...>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n@@ -1088,112 +1085,68 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// is_nothrow_default_constructible\n   template<typename _Tp>\n     struct is_nothrow_default_constructible\n-    : public __bool_constant<__is_nothrow_constructible(_Tp)>\n+    : public __is_nothrow_constructible_impl<_Tp>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  /// @cond undocumented\n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_nothrow_copy_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_copy_constructible_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_copy_constructible_impl<_Tp, true>\n-    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>\n-    { };\n-  /// @endcond\n-\n   /// is_nothrow_copy_constructible\n   template<typename _Tp>\n     struct is_nothrow_copy_constructible\n-    : public __is_nothrow_copy_constructible_impl<_Tp>::type\n+    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  /// @cond undocumented\n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_nothrow_move_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_move_constructible_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_move_constructible_impl<_Tp, true>\n-    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>\n-    { };\n-  /// @endcond\n-\n   /// is_nothrow_move_constructible\n   template<typename _Tp>\n     struct is_nothrow_move_constructible\n-    : public __is_nothrow_move_constructible_impl<_Tp>::type\n+    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n+  /// @cond undocumented\n+  template<typename _Tp, typename _Up>\n+    using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;\n+  /// @endcond\n+\n   /// is_assignable\n   template<typename _Tp, typename _Up>\n     struct is_assignable\n-    : public __bool_constant<__is_assignable(_Tp, _Up)>\n+    : public __is_assignable_impl<_Tp, _Up>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_copy_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_copy_assignable_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_copy_assignable_impl<_Tp, true>\n-    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>\n-    { };\n-\n   /// is_copy_assignable\n   template<typename _Tp>\n     struct is_copy_assignable\n-    : public __is_copy_assignable_impl<_Tp>::type\n+    : public __is_assignable_impl<__add_lval_ref_t<_Tp>,\n+\t\t\t\t  __add_lval_ref_t<const _Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_move_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_move_assignable_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_move_assignable_impl<_Tp, true>\n-    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>\n-    { };\n-\n   /// is_move_assignable\n   template<typename _Tp>\n     struct is_move_assignable\n-    : public __is_move_assignable_impl<_Tp>::type\n+    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n+  /// @cond undocumented\n   template<typename _Tp, typename _Up>\n     using __is_nothrow_assignable_impl\n       = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;\n+  /// @endcond\n \n   /// is_nothrow_assignable\n   template<typename _Tp, typename _Up>\n@@ -1204,52 +1157,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_nt_copy_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nt_copy_assignable_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nt_copy_assignable_impl<_Tp, true>\n-    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>\n-    { };\n-\n   /// is_nothrow_copy_assignable\n   template<typename _Tp>\n     struct is_nothrow_copy_assignable\n-    : public __is_nt_copy_assignable_impl<_Tp>\n+    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,\n+\t\t\t\t\t  __add_lval_ref_t<const _Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_nt_move_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nt_move_assignable_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nt_move_assignable_impl<_Tp, true>\n-    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>\n-    { };\n-\n   /// is_nothrow_move_assignable\n   template<typename _Tp>\n     struct is_nothrow_move_assignable\n-    : public __is_nt_move_assignable_impl<_Tp>\n+    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,\n+\t\t\t\t\t  __add_rval_ref_t<_Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n+  /// @cond undocumented\n+  template<typename _Tp, typename... _Args>\n+    using __is_trivially_constructible_impl\n+      = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;\n+  /// @endcond\n+\n   /// is_trivially_constructible\n   template<typename _Tp, typename... _Args>\n     struct is_trivially_constructible\n-    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>\n+    : public __is_trivially_constructible_impl<_Tp, _Args...>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n@@ -1258,7 +1195,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// is_trivially_default_constructible\n   template<typename _Tp>\n     struct is_trivially_default_constructible\n-    : public __bool_constant<__is_trivially_constructible(_Tp)>\n+    : public __is_trivially_constructible_impl<_Tp>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n@@ -1294,98 +1231,54 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    __is_implicitly_default_constructible_safe<_Tp>>\n     { };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_trivially_copy_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_trivially_copy_constructible_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_trivially_copy_constructible_impl<_Tp, true>\n-    : public __and_<__is_copy_constructible_impl<_Tp>,\n-\t\t    integral_constant<bool,\n-\t\t\t__is_trivially_constructible(_Tp, const _Tp&)>>\n-    { };\n-\n   /// is_trivially_copy_constructible\n   template<typename _Tp>\n     struct is_trivially_copy_constructible\n-    : public __is_trivially_copy_constructible_impl<_Tp>\n+    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_trivially_move_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_trivially_move_constructible_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_trivially_move_constructible_impl<_Tp, true>\n-    : public __and_<__is_move_constructible_impl<_Tp>,\n-\t\t    integral_constant<bool,\n-\t\t\t__is_trivially_constructible(_Tp, _Tp&&)>>\n-    { };\n-\n   /// is_trivially_move_constructible\n   template<typename _Tp>\n     struct is_trivially_move_constructible\n-    : public __is_trivially_move_constructible_impl<_Tp>\n+    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n+  /// @cond undocumented\n+  template<typename _Tp, typename _Up>\n+    using __is_trivially_assignable_impl\n+      = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;\n+  /// @endcond\n+\n   /// is_trivially_assignable\n   template<typename _Tp, typename _Up>\n     struct is_trivially_assignable\n-    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>\n+    : public __is_trivially_assignable_impl<_Tp, _Up>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_trivially_copy_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_trivially_copy_assignable_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_trivially_copy_assignable_impl<_Tp, true>\n-    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>\n-    { };\n-\n   /// is_trivially_copy_assignable\n   template<typename _Tp>\n     struct is_trivially_copy_assignable\n-    : public __is_trivially_copy_assignable_impl<_Tp>\n+    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,\n+\t\t\t\t\t    __add_lval_ref_t<const _Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n     };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __is_trivially_move_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_trivially_move_assignable_impl<_Tp, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_trivially_move_assignable_impl<_Tp, true>\n-    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>\n-    { };\n-\n   /// is_trivially_move_assignable\n   template<typename _Tp>\n     struct is_trivially_move_assignable\n-    : public __is_trivially_move_assignable_impl<_Tp>\n+    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,\n+\t\t\t\t\t    __add_rval_ref_t<_Tp>>\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n@@ -1669,33 +1562,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct remove_reference<_Tp&&>\n     { typedef _Tp   type; };\n \n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __add_lvalue_reference_helper\n-    { typedef _Tp   type; };\n-\n-  template<typename _Tp>\n-    struct __add_lvalue_reference_helper<_Tp, true>\n-    { typedef _Tp&   type; };\n-\n   /// add_lvalue_reference\n   template<typename _Tp>\n     struct add_lvalue_reference\n-    : public __add_lvalue_reference_helper<_Tp>\n-    { };\n-\n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n-    struct __add_rvalue_reference_helper\n-    { typedef _Tp   type; };\n-\n-  template<typename _Tp>\n-    struct __add_rvalue_reference_helper<_Tp, true>\n-    { typedef _Tp&&   type; };\n+    { using type = __add_lval_ref_t<_Tp>; };\n \n   /// add_rvalue_reference\n   template<typename _Tp>\n     struct add_rvalue_reference\n-    : public __add_rvalue_reference_helper<_Tp>\n-    { };\n+    { using type = __add_rval_ref_t<_Tp>; };\n \n #if __cplusplus > 201103L\n   /// Alias template for remove_reference"}]}