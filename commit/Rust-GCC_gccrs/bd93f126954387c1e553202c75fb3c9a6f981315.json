{"sha": "bd93f126954387c1e553202c75fb3c9a6f981315", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5M2YxMjY5NTQzODdjMWU1NTMyMDJjNzVmYjNjOWE2Zjk4MTMxNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-29T05:27:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-29T05:27:26Z"}, "message": "h8300.c (names_small): Remove \"BAD\" postfix from %r7 byte registers.\n\n        * h8300/h8300.c (names_small): Remove \"BAD\" postfix from\n        %r7 byte registers.\n        (rtx_equal_function_value_matters): Remove extra declaration.\n        (output_simode_bld): New function.\n        * h8300/h8300.h (NO_FUNCTION_CSE): Do define this.  Register\n        pressure makes cse-int function addresses rarely a win.\n        (reg_class): Remove unnecessary register classes LONG_REGS,\n        SP_REG, SP_AND_G_REGS.\n        (REG_CLASS_NAMES): Corresponding changes.\n        (REG_CLASS_CONTENTS): Corresponding changes.\n        (REGNO_REG_CLASS): Corresponding changes.\n        (REG_CLASS_FROM_LETTER): Corresponding chagnes.\n        (output_simode_bld): Declare.\n        * h8300/h8300.md: Nuke comments for stuff which has been fixed.\n        (all patterns): Remove references to register class \"a\" (SP_REGS)\n        which no longer exists.\n        (many patterns): Accept auto-inc auto-dec addresses in more cases.\n        (zero_extendqisi2): New pattern for the H8/300.\n        (zero_extendhisi2): Only use zero_extendhisi2_h8300 when not optimizing.\n        (extendhisi2): Only use extendhisi2_h8300 when not optimizing.\n        (extendqisi2): New pattern for the H8/300.\n        (bitfield related patterns): Completely rewrite.\n        (fancy_bclr, fancy_btst): Deleted.  Redundant with new bitfield\n        patterns.\n        (addhi3 pattern for h8300): Handle case where we can't make matching\n        constraints (works around hard to fix reload problem).\n        (stack_pointer_manip): Delete.\n        (and not patterns): New combiner patterns.\n\nFrom-SVN: r11902", "tree": {"sha": "f890c366b72af7d227b238f089c6ad3460b98b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f890c366b72af7d227b238f089c6ad3460b98b21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd93f126954387c1e553202c75fb3c9a6f981315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd93f126954387c1e553202c75fb3c9a6f981315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd93f126954387c1e553202c75fb3c9a6f981315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd93f126954387c1e553202c75fb3c9a6f981315/comments", "author": null, "committer": null, "parents": [{"sha": "2ac42d3ac2e7382a35b5bf82be9fda8fa1854520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac42d3ac2e7382a35b5bf82be9fda8fa1854520", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac42d3ac2e7382a35b5bf82be9fda8fa1854520"}], "stats": {"total": 804, "additions": 467, "deletions": 337}, "files": [{"sha": "0bca23fc089574963fe256ea4c1da115364e3096", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd93f126954387c1e553202c75fb3c9a6f981315/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd93f126954387c1e553202c75fb3c9a6f981315/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=bd93f126954387c1e553202c75fb3c9a6f981315", "patch": "@@ -104,7 +104,7 @@ byte_reg (x, b)\n {\n   static char *names_small[] =\n   {\"r0l\", \"r0h\", \"r1l\", \"r1h\", \"r2l\", \"r2h\", \"r3l\", \"r3h\",\n-   \"r4l\", \"r4h\", \"r5l\", \"r5h\", \"r6l\", \"r6h\", \"r7lBAD\", \"r7hBAD\"};\n+   \"r4l\", \"r4h\", \"r5l\", \"r5h\", \"r6l\", \"r6h\", \"r7l\", \"r7h\"};\n \n   return names_small[REGNO (x) * 2 + b];\n }\n@@ -1545,8 +1545,6 @@ expand_a_shift (mode, code, operands)\n      int code;\n      rtx operands[];\n {\n-  extern int rtx_equal_function_value_matters;\n-\n   emit_move_insn (operands[0], operands[1]);\n \n   /* need a loop to get all the bits we want  - we generate the\n@@ -2229,3 +2227,29 @@ h8300_valid_machine_decl_attribute (decl, attributes, attr, args)\n   return 0;\n }\n \n+char *\n+output_simode_bld (bild, log2, operands)\n+     int bild;\n+     int log2;\n+     rtx operands[];\n+{\n+  /* Clear the destination register.  */\n+  if (TARGET_H8300H)\n+    output_asm_insn (\"sub.l\\t%S0,%S0\", operands);\n+  else\n+    output_asm_insn (\"sub.w\\t%e0,%e0\\n\\tsub.w\\t%f0,%f0\", operands);\n+\n+  /* Get the bit number we want to load.  */\n+  if (log2)\n+    operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\n+\n+  /* Now output the bit load or bit inverse load, and store it in\n+     the destination.  */\n+  if (bild)\n+    output_asm_insn (\"bild\\t%Z2,%Y1\\n\\tbst\\t#0,%w0\", operands);\n+  else\n+    output_asm_insn (\"bld\\t%Z2,%Y1\\n\\tbst\\t#0,%w0\", operands);\n+\n+  /* All done.  */\n+  return \"\";\n+}"}, {"sha": "aa877698c31b04294628946e05f7cbf5c55fb438", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd93f126954387c1e553202c75fb3c9a6f981315/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd93f126954387c1e553202c75fb3c9a6f981315/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=bd93f126954387c1e553202c75fb3c9a6f981315", "patch": "@@ -125,8 +125,12 @@ do {\t\t\t\t\\\n /* Define this if addresses of constant functions\n    shouldn't be put through pseudo regs where they can be cse'd.\n    Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-/* #define NO_FUNCTION_CSE */\n+   but a CALL with constant address is cheap. \n+\n+   Calls through a register are cheaper than calls to named\n+   functions; however, the register pressure this causes makes\n+   CSEing of function addresses generally a lose.  */\n+#define NO_FUNCTION_CSE \n \f\n /* Target machine storage layout */\n \n@@ -319,44 +323,35 @@ do {\t\t\t\t\\\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n    \n-/* The h8 has only one kind of register, but we mustn't do byte by\n-   byte operations on the sp, so we keep it as a different class */\n-\n enum reg_class {\n-  NO_REGS, LONG_REGS, GENERAL_REGS, SP_REG, SP_AND_G_REGS,\n-  ALL_REGS, LIM_REG_CLASSES\n+  NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"LONG_REGS\", \"GENERAL_REGS\", \"SP_REG\", \"SP_AND_G_REGS\", \\\n-  \"ALL_REGS\", \"LIM_REGS\" }\n+{ \"NO_REGS\", \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS  \t\t\t\\\n {      0,\t\t/* No regs      */\t\\\n-   0x07f,               /* LONG_REGS    */      \\\n-   0x07f,\t\t/* GENERAL_REGS */\t\\\n-   0x080,\t\t/* SP_REG       */     \t\\\n-   0x0ff,\t\t/* SP_AND_G_REGS */    \t\\\n+   0x0ff,\t\t/* GENERAL_REGS */    \t\\\n    0x1ff,\t\t/* ALL_REGS \t*/\t\\\n }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n+   or could index an array.\n \n-#define REGNO_REG_CLASS(REGNO)  \\\n-   ((REGNO) < 7  ? LONG_REGS  : \\\n-    (REGNO) == 7 ? SP_REG     : \\\n-    GENERAL_REGS)\n+   ??? What about the ARG_POINTER_REGISTER? */\n+\n+#define REGNO_REG_CLASS(REGNO)  GENERAL_REGS\n \n /* The class value for index registers, and the one for base regs.  */\n \n@@ -365,8 +360,7 @@ enum reg_class {\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n \n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'a' ? (SP_REG) : (C) == 'l' ? (LONG_REGS) : (NO_REGS))\n+#define REG_CLASS_FROM_LETTER(C) (NO_REGS)\n \n /* The letters I, J, K, L, M, N, O, P in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -1341,4 +1335,6 @@ do { char dstr[30];\t\t\t\t\t\\\n /* Declarations for functions used in insn-output.c.  */\n char *emit_a_shift ();\n int h8300_funcvec_function_p ();\n-char *output_adds_subs();\n+char *output_adds_subs ();\n+char * output_simode_bld ();\n+"}, {"sha": "e7049dd17074753eafa4162fb2568c56c7ea344b", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 423, "deletions": 313, "changes": 736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd93f126954387c1e553202c75fb3c9a6f981315/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd93f126954387c1e553202c75fb3c9a6f981315/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=bd93f126954387c1e553202c75fb3c9a6f981315", "patch": "@@ -36,12 +36,6 @@\n ;;\t* movXX insns using register indirect addressing.\n ;; \t* insns referencing the 8-bit area with an 8-bit address.\n \n-;; Some move patterns have conditions which check that one operand\n-;; is a register.  Shouldn't all of them have such a condition?\n-\n-;; Consistently use \"a\" constraint.  Probably makes little difference\n-;; in the generated code, but it's easy to do.\n-\n ;; Loading some 32bit integer constants could be done more\n ;; efficiently.  For example loading the value 4 as a 32bit\n ;; is normally done via mov.l #4,erX.  sub.l erX,erX, inc.l #4,erX \n@@ -63,6 +57,10 @@\n ;; Long term, we want to expose the \"e\" half to the compiler (gives us\n ;; 8 more 16bit registers).  At that point addhi and subhi can't use adds/subs.\n \n+;; There's currently no way to have a insv/extzv expander for the h8/300h\n+;; because word_mode is different for the h8/300 and h8/300h.\n+\n+;; ??? Implement remaining bit ops available on the h8300\n \n (define_attr \"type\" \"branch,bcs,arith\"\n   (const_string \"arith\"))\n@@ -191,7 +189,7 @@\n ;; 16bit push insns!\n (define_insn \"movhi_push\"\n   [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n-\t(match_operand:HI 1 \"register_operand\" \"ra\"))]\n+\t(match_operand:HI 1 \"register_operand\" \"r\"))]\n   \"\"\n   \"*\n {\n@@ -204,8 +202,8 @@\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"movhi_internal\"\n-  [(set (match_operand:HI 0 \"general_operand_dst\" \"=ra,ra,<,ra,o\")\n-\t(match_operand:HI 1 \"general_operand_src\" \"I,ra>,ra,ion,ra\"))]\n+  [(set (match_operand:HI 0 \"general_operand_dst\" \"=r,r,<,r,o\")\n+\t(match_operand:HI 1 \"general_operand_src\" \"I,r>,r,ion,r\"))]\n   \"register_operand (operands[0],HImode)\n    || register_operand (operands[1], HImode)\"\n   \"@\n@@ -418,8 +416,8 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"movsi_h8300h\"\n-  [(set (match_operand:SI 0 \"general_operand_dst\" \"=ra,ra,ra,o,<,ra\")\n-\t(match_operand:SI 1 \"general_operand_src\" \"I,ra,ion,ra,ra,>\"))]\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"I,r,ion,r,r,>\"))]\n   \"TARGET_H8300H\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n@@ -487,30 +485,30 @@\n    (set_attr \"cc\" \"set_zn_c0\")])\n   \n (define_insn \"tstqi\"\n-  [(set (cc0) (match_operand:QI 0 \"general_operand\" \"ra\"))]\n+  [(set (cc0) (match_operand:QI 0 \"general_operand\" \"r\"))]\n   \"\"\n   \"mov.b\t%X0,%X0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"tsthi\"\n-  [(set (cc0) (match_operand:HI 0 \"general_operand\" \"ra\"))]\n+  [(set (cc0) (match_operand:HI 0 \"general_operand\" \"r\"))]\n   \"\"\n   \"mov.w\t%T0,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"tstsi\"\n-  [(set (cc0) (match_operand:SI 0 \"general_operand\" \"ra\"))]\n+  [(set (cc0) (match_operand:SI 0 \"general_operand\" \"r\"))]\n   \"TARGET_H8300H\"\n   \"mov.l\t%S0,%S0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"cmpqi\"\n   [(set (cc0)\n-\t(compare:QI (match_operand:QI 0 \"register_operand\" \"ra\")\n-\t\t    (match_operand:QI 1 \"nonmemory_operand\" \"rai\")))]\n+\t(compare:QI (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:QI 1 \"nonmemory_operand\" \"ri\")))]\n   \"\"\n   \"cmp.b\t%X1,%X0\"\n   [(set_attr \"length\" \"2\")\n@@ -531,26 +529,26 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare:HI (match_operand:HI 0 \"register_operand\" \"ra\")\n-\t\t    (match_operand:HI 1 \"register_operand\" \"ra\")))]\n+\t(compare:HI (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"!TARGET_H8300H\"\n   \"cmp.w\t%T1,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"compare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare:HI (match_operand:HI 0 \"register_operand\" \"ra\")\n-\t\t    (match_operand:HI 1 \"nonmemory_operand\" \"rai\")))]\n+\t(compare:HI (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:HI 1 \"nonmemory_operand\" \"ri\")))]\n   \"TARGET_H8300H\"\n   \"cmp.w\t%T1,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"compare\")])\n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare:SI (match_operand:SI 0 \"register_operand\" \"ra\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"rai\")))]\n+\t(compare:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"ri\")))]\n   \"TARGET_H8300H\"\n   \"cmp.l\t%S1,%S0\"\n   [(set_attr \"length\" \"2\")\n@@ -579,7 +577,7 @@\n ;; Specialized version using adds/subs.  This must come before\n ;; the more general patterns below.\n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=ra\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n \t\t (match_operand:HI 2 \"adds_subs_operand\" \"i\")))]\n   \"\"\n@@ -588,20 +586,21 @@\n    (set_attr \"cc\" \"none_0hit\")])\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=&ra,ra\")\n-\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"n,ra\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r,r,&r\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,g\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"n,r,r\")))]\n   \"TARGET_H8300\"\n   \"@\n    add.b\t%s2,%s0\\;addx\t%t2,%t0 \n-   add.w\t%T2,%T0\"\n-  [(set_attr \"length\" \"4,2\")\n-   (set_attr \"cc\" \"clobber,set_zn_c0\")])\n+   add.w\t%T2,%T0\n+   mov.w        %T1,%T0\\;add.w  %T2,%T0\"\n+  [(set_attr \"length\" \"4,2,6\")\n+   (set_attr \"cc\" \"clobber,set_zn_c0,set_zn_c0\")])\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"i,ra\")))]\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"i,r\")))]\n   \"TARGET_H8300H\"\n   \"@\n    add.w\t%T2,%T0\n@@ -619,7 +618,7 @@\n ;; Specialized version using adds/subs.  This must come before\n ;; the more general patterns below.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=ra\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"adds_subs_operand\" \"i\")))]\n   \"TARGET_H8300H\"\n@@ -628,7 +627,7 @@\n    (set_attr \"cc\" \"none_0hit\")])\n \n (define_insn \"addsi_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra,&ra\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,&r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"n,r,r\")))]\n   \"TARGET_H8300\"\n@@ -640,9 +639,9 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"addsi_h8300h\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"i,ra\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"i,r\")))]\n   \"TARGET_H8300H\"\n   \"@\n    add.l\t%S2,%S0\n@@ -676,7 +675,7 @@\n ;; the more general patterns below.  This may not be needed\n ;; due to instruction canonicalization.\n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=ra\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(minus:HI (match_operand:HI 1 \"register_operand\" \"r\")\n \t\t  (match_operand:HI 2 \"adds_subs_operand\" \"i\")))]\n   \"\"\n@@ -689,9 +688,9 @@\n    (set_attr \"cc\" \"none_0hit\")])\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=ra,&ra\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,&r\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"ra,n\")))]\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,n\")))]\n   \"TARGET_H8300\"\n   \"@\n    sub.w\t%T2,%T0\n@@ -700,9 +699,9 @@\n    (set_attr \"cc\" \"set_zn_c0,clobber\")])\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=ra,&ra\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,&r\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"ra,i\")))]\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,i\")))]\n   \"TARGET_H8300H\"\n   \"@\n    sub.w\t%T2,%T0\n@@ -730,7 +729,7 @@\n ;; the more general patterns below.  This may not be needed\n ;; due to instruction canonicalization.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=ra\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t  (match_operand:SI 2 \"adds_subs_operand\" \"i\")))]\n   \"TARGET_H8300H\"\n@@ -743,9 +742,9 @@\n    (set_attr \"cc\" \"none_0hit\")])\n \n (define_insn \"subsi3_h8300h\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"ra,i\")))]\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n   \"TARGET_H8300H\"\n   \"@\n    sub.l\t%S2,%S0\n@@ -1527,28 +1526,44 @@\n \n (define_insn \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,g\")))]\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n   \"\"\n   \"@\n   mov.b\t#0,%t0\n   mov.b\t%R1,%s0\\;mov.b\t#0,%t0\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n \n+;; The compiler can synthesize a 300H variant of this which is\n+;; just as efficient as one that we'd create\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n+  \"TARGET_H8300\"\n+  \"@\n+  mov.b\t#0,%x0\\;sub.w %e0,%e0\n+  mov.b\t%R1,%w0\\;mov.b\t#0,%x0\\;sub.w %e0,%e0\"\n+  [(set_attr \"length\" \"4,6\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\n (define_expand \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"\")))]\n   \"\"\n   \"\n {\n+  extern int optimize;\n+\n   if (TARGET_H8300\n-      && GET_CODE (operands[1]) != CONST_INT)\n+      && GET_CODE (operands[1]) != CONST_INT\n+      && !optimize)\n     {\n       emit_insn (gen_zero_extendhisi2_h8300 (operands[0], operands[1]));\n       DONE;\n     }\n }\")\n \n+\n ;; I don't know why, but if I try to simplify extendhisi2 in the\n ;; natural way, I get about a 2X code bloat on the h8300 without\n ;; optimization, and a small bloat with optimization.  Weird.\n@@ -1561,7 +1576,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,g\")))]\n+\t(zero_extend:SI (match_operand:HI 1 \"general_operand_src\" \"0,g>\")))]\n   \"TARGET_H8300\"\n   \"@\n   sub.w\t%e0,%e0\n@@ -1571,7 +1586,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,g\")))]\n+\t(zero_extend:SI (match_operand:HI 1 \"general_operand_src\" \"0,g>\")))]\n   \"TARGET_H8300H\"\n   \"@\n   extu.l\t%S0\n@@ -1587,7 +1602,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"0,g\")))]\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n   \"TARGET_H8300\"\n   \"@\n   bld\t#7,%s0\\;subx\t%t0,%t0\n@@ -1597,22 +1612,36 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"0,g\")))]\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n   \"TARGET_H8300H\"\n   \"@\n   exts.w\t%T0\n   mov.b\t%R1,%s0\\;exts.w\t%T0\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"set,set\")])\n \n+;; The compiler can synthesize a 300H variant of this which is\n+;; just as efficient as one that we'd create\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n+  \"TARGET_H8300\"\n+  \"@\n+  bld\t#7,%w0\\;subx\t%x0,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\n+  mov.b %R1,%w0\\;bld\t#7,%w0\\;subx\t%x0,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\"\n+  [(set_attr \"length\" \"8,10\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\n (define_expand \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"\")))]\n   \"\"\n   \"\n {\n+  extern int optimize;\n   if (TARGET_H8300\n-      && GET_CODE (operands[1]) != CONST_INT)\n+      && GET_CODE (operands[1]) != CONST_INT\n+      && !optimize)\n     {\n       emit_insn (gen_extendhisi2_h8300 (operands[0], operands[1]));\n       DONE;\n@@ -1631,7 +1660,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,g\")))]\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand_src\" \"0,g>\")))]\n   \"TARGET_H8300\"\n   \"@\n   bld\t#7,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\n@@ -1641,7 +1670,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,g\")))]\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand_src\" \"0,g>\")))]\n   \"TARGET_H8300H\"\n   \"@\n   exts.l\t%S0\n@@ -1719,7 +1748,7 @@\n \n (define_expand \"lshrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand_src\" \"\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   \"if (expand_a_shift (HImode, LSHIFTRT, operands)) DONE;else FAIL;\")\n@@ -1753,23 +1782,23 @@\n (define_expand \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashift:SI\n-\t (match_operand:SI 1 \"general_operand_src\" \"\")\n+\t (match_operand:SI 1 \"general_operand\" \"\")\n \t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   \"if (expand_a_shift (SImode, ASHIFT, operands)) DONE;else FAIL;\")\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(lshiftrt:SI\n-\t (match_operand:SI 1 \"general_operand_src\" \"\")\n+\t (match_operand:SI 1 \"general_operand\" \"\")\n \t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   \"if (expand_a_shift (SImode, LSHIFTRT, operands)) DONE;else FAIL;\")\n \n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:SI\n-\t (match_operand:SI 1 \"general_operand_src\" \"\")\n+\t (match_operand:SI 1 \"general_operand\" \"\")\n \t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   \"if (expand_a_shift (SImode, ASHIFTRT, operands)) DONE;else FAIL;\")\n@@ -1799,13 +1828,14 @@\n \n ;; BCC and BCS patterns.\n \n-(define_insn \"bcs_qiqi\"\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else \n \t (match_operator 1 \"eq_operator\"\n-\t\t\t [(zero_extract:QI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n-\t\t\t\t\t   (const_int 1)\n-\t\t\t\t\t   (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t\t [(zero_extract:QI \n+\t\t\t    (match_operand:HI 2 \"register_operand\" \"r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:HI 3 \"immediate_operand\" \"i\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 0 \"\" \"\"))\n \t (pc)))]\n@@ -1817,7 +1847,7 @@\n      can easily choose the right branch length.  */\n   int branch_length = get_attr_length (insn);\n \n-  if (! register_operand (operands[2], QImode))\n+  if (! register_operand (operands[2], HImode))\n     branch_length -= 4;\n   else\n     branch_length -= 2;\n@@ -1833,13 +1863,14 @@\n   [(set_attr \"type\" \"bcs\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"bcs_hihi\"\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else \n \t (match_operator 1 \"eq_operator\"\n-\t\t\t [(zero_extract:HI (match_operand:HI 2 \"bit_operand\" \"Ur\")\n-\t\t\t\t\t   (const_int 1)\n-\t\t\t\t\t   (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t\t [(zero_extract:HI\n+\t\t\t    (match_operand:HI 2 \"register_operand\" \"r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:HI 3 \"immediate_operand\" \"i\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 0 \"\" \"\"))\n \t (pc)))]\n@@ -1851,7 +1882,7 @@\n      can easily choose the right branch length.  */\n   int branch_length = get_attr_length (insn);\n \n-  if (! register_operand (operands[2], QImode))\n+  if (! register_operand (operands[2], HImode))\n     branch_length -= 4;\n   else\n     branch_length -= 2;\n@@ -1867,16 +1898,17 @@\n   [(set_attr \"type\" \"bcs\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"bcs_hiqi\"\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else \n \t (match_operator 1 \"eq_operator\"\n-\t\t\t [(zero_extract:HI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n-\t\t\t\t\t   (const_int 1)\n-\t\t\t\t\t   (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t\t [(zero_extract:HI\n+\t\t\t    (match_operand:HI 2 \"register_operand\" \"U\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:HI 3 \"immediate_operand\" \"i\"))\n \t\t\t  (const_int 0)])\n-\t (label_ref (match_operand 0 \"\" \"\"))\n-\t (pc)))]\n+\t (pc)\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n   \"*\n {\n@@ -1885,7 +1917,7 @@\n      can easily choose the right branch length.  */\n   int branch_length = get_attr_length (insn);\n \n-  if (! register_operand (operands[2], QImode))\n+  if (! register_operand (operands[2], HImode))\n     branch_length -= 4;\n   else\n     branch_length -= 2;\n@@ -1901,252 +1933,353 @@\n   [(set_attr \"type\" \"bcs\")\n    (set_attr \"cc\" \"clobber\")])\n \n-;; BLD and BST patterns\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else \n+\t (match_operator 1 \"eq_operator\"\n+\t\t\t [(zero_extract:QI \n+\t\t\t    (match_operand:HI 2 \"register_operand\" \"r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t\t  (const_int 0)])\n+\t (pc)\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  /* The length of this insn includes the bld insn below.  We\n+     compute the length of the branch without the bld so we\n+     can easily choose the right branch length.  */\n+  int branch_length = get_attr_length (insn);\n+\n+  if (! register_operand (operands[2], HImode))\n+    branch_length -= 4;\n+  else\n+    branch_length -= 2;\n \n-(define_insn \"extract_1\"\n+  output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n+  if (branch_length == 2) \n+    return \\\"%d1\t%l0\\\";\n+  else if (branch_length == 4) \n+    return \\\"%d1\t%l0:16\\\";\n+  else\n+    return \\\"%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+}\" \n+  [(set_attr \"type\" \"bcs\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; You'll never believe all these patterns perform one basic action --\n+;; load a bit from the source, optionally invert the bit, then store it\n+;; in the destination (which is known to be zero)..  \n+;;\n+;; Combine obviously need some work to better identify this situation and\n+;; canonicalize the form better.\n+\n+;; \n+;; Normal loads with a 16bit destination.\n+;; \n+;; Yes, both cases are needed.\n+;;\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"Ur\")\n+\t(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"sub.w\t%0,%0\\;bld\t%Z2,%Y1\\;bst\t#0,%X0\"\n   [(set_attr \"cc\" \"clobber\")\n    (set_attr \"length\" \"6\")])\n \n-(define_insn \"extract_1_hi\"\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"Ur\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n+\t(subreg:HI (zero_extract:SI\n+\t\t     (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t     (const_int 1)\n+\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\")) 1))]\n   \"\"\n   \"sub.w\t%0,%0\\;bld\t%Z2,%Y1\\;bst\t#0,%X0\"\n   [(set_attr \"cc\" \"clobber\")\n    (set_attr \"length\" \"6\")])\n \n-(define_insn \"insert_1\"\n-  [(set (zero_extract:HI (match_operand:QI 0 \"bit_operand\" \"+Ur\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n-\t(zero_extract:HI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n+;; \n+;; Inverted loads with a 16bit destination.\n+;; \n+;; Yes, all four cases are needed.\n+;;\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:HI (xor:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t\t (match_operand:HI 3 \"p_operand\" \"P\"))\n \t\t\t (const_int 1)\n-\t\t\t (const_int 0)))]\n+\t\t\t (match_operand:HI 2 \"const_int_operand\" \"n\")))]\n+  \"(1 << INTVAL (operands[2])) == INTVAL (operands[3])\"\n+  \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(and:HI (not:HI \n+\t\t  (lshiftrt:HI\n+\t\t    (match_operand:HI 1 \"bit_operand\" \"Ur\")\n+\t\t    (match_operand:HI 2 \"const_int_operand\" \"n\")))\n+\t\t(const_int 1)))]\n   \"\"\n-  \"bld\t#0,%R2\\;bst\t%Z1,%Y0 ; i1\"\n+  \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\"\n   [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"4\")])\n+   (set_attr \"length\" \"8\")])\n \n-;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n-;; in combine.c, but there is no problem with writing it this way so we do.\n-(define_insn \"extract_insert_1\"\n-  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"+Ur\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n-\t(lshiftrt:QI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n-\t\t     (match_operand:HI 3 \"immediate_operand\" \"i\")))]\n- \"\"\n- \"bld\t%Z3,%Y2\\;bst\t%Z1,%Y0; ei1\"\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(and:HI (not:HI \n+\t\t  (subreg:HI \n+\t\t    (lshiftrt:SI\n+\t\t      (match_operand:SI 1 \"register_operand\" \"Ur\")\n+\t\t      (match_operand:SI 2 \"const_int_operand\" \"n\")) 1))\n+\t\t(const_int 1)))]\n+  \"INTVAL (operands[2]) < 16\"\n+  \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\"\n   [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"4\")])\n+   (set_attr \"length\" \"8\")])\n \n-;; BAND, BOR, and BXOR patterns\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(and:HI (not:HI \n+\t\t  (subreg:HI \n+\t\t    (lshiftrt:SI\n+\t\t      (match_operand:SI 1 \"bit_operand\" \"Ur\")\n+\t\t      (match_operand:SI 2 \"const_int_operand\" \"n\")) 0))\n+\t\t(const_int 1)))]\n+  \"TARGET_H8300H && INTVAL (operands[2]) < 16\"\n+  \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"8\")])\n \n-(define_insn \"bitlogical_1\"\n-  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n-\t(match_operator:HI 4 \"bit_operator\"\n-\t   [(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"Ur\")\n-\t\t\t     (const_int 1)\n-\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n-\t    (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n+;; \n+;; Normal loads with a 32bit destination.\n+;; \n+;; Yes, all three cases are needed.\n+;;\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:SI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n-  \"bld\t%Z2,%Y1\\;%b4\t#0,%R0\\;bst\t#0,%R0; bl1\"\n+  \"* return output_simode_bld (0, 0, operands);\"\n   [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"6\")])\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n \n-(define_insn \"bitlogical_1_hi\"\n-  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n-\t(match_operator:HI 4 \"bit_operator\"\n-\t   [(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"Ur\")\n-\t\t\t     (const_int 1)\n-\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n-\t    (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n-  \"\"\n-  \"bld\t%Z2,%Y1\\;%b4\t#0,%R0\\;bst\t#0,%R0; bl2\"\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (zero_extend:SI \n+\t\t   (lshiftrt:QI\n+\t\t     (match_operand:QI 1 \"bit_operand\" \"Ur\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))\n+\t\t(const_int 1)))]\n+  \"\"\n+  \"* return output_simode_bld (0, 0, operands);\"\n   [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"6\")])\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n \n-(define_insn \"bitlogical_2\"\n-  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n-\t(match_operator:HI 5 \"bit_operator\"\n-\t   [(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"Ur\")\n-\t\t\t     (const_int 1)\n-\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n-\t    (zero_extract:HI (match_operand:QI 3 \"bit_operand\" \"Ur\")\n-\t\t\t     (const_int 1)\n-\t\t\t     (match_operand:HI 4 \"immediate_operand\" \"i\"))]))]\n-  \"\"\n-  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%R0; bl3\"\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (zero_extend:SI \n+\t\t   (lshiftrt:HI\n+\t\t      (match_operand:HI 1 \"bit_operand\" \"Ur\")\n+\t\t      (match_operand:HI 2 \"const_int_operand\" \"n\")))\n+\t\t(const_int 1)))]\n+  \"\"\n+  \"* return output_simode_bld (0, 0, operands);\"\n   [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"6\")])\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n \n-(define_insn \"bitlogical_2_hi\"\n-  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n-\t(match_operator:HI 5 \"bit_operator\"\n-\t   [(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"Ur\")\n-\t\t\t     (const_int 1)\n-\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n-\t    (zero_extract:HI (match_operand:HI 3 \"bit_operand\" \"Ur\")\n-\t\t\t     (const_int 1)\n-\t\t\t     (match_operand:HI 4 \"immediate_operand\" \"i\"))]))]\n+;; \n+;; Inverted loads with a 32bit destination.\n+;; \n+;; Yes, all seven cases are needed.\n+;;\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (not:SI\n+\t\t  (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))\n+\t\t(match_operand:SI 2 \"p_operand\" \"P\")))]\n   \"\"\n-  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%R0; bl3\"\n+  \"* return output_simode_bld (1, 1, operands);\"\n   [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"6\")])\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (not:SI\n+\t\t  (zero_extend:SI\n+\t\t    (lshiftrt:HI (match_operand:HI 1 \"bit_operand\" \"Ur\")\n+\t\t\t\t (match_operand:HI 2 \"const_int_operand\" \"n\"))))\n+\t\t(const_int 1)))]\n+  \"\"\n+  \"* return output_simode_bld (1, 0, operands);\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n \n-;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n-;; in combine.c, but there is no problem with writing it this way so we do.\n-(define_insn \"bitlogical_3\"\n-  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"+Ur\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n-\t(match_operator:QI 6 \"bit_operator\"\n-\t   [(lshiftrt:QI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n-\t\t\t (match_operand:HI 3 \"immediate_operand\" \"i\"))\n-\t    (lshiftrt:QI (match_operand:QI 4 \"bit_operand\" \"Ur\")\n-\t\t\t (match_operand:HI 5 \"immediate_operand\" \"i\"))]))]\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (not:SI\n+\t\t  (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))\n+\t\t(match_operand:SI 2 \"p_operand\" \"P\")))]\n   \"\"\n-  \"bld\t%Z3,%Y2\\;%b6\t%Z5,%Y4\\;bst\t%Z1,%Y0; bl5\"\n+  \"* return output_simode_bld (1, 1, operands);\"\n   [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"6\")])\n-\t\t\t\t\t\t     \n-;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n-;; in combine.c, but there is no problem with writing it this way so we do.\n-(define_insn \"bitnot_1\"\n-  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n-\t(lshiftrt:QI (xor:QI (match_operand:QI 2 \"bit_operand\" \"0\")\n-\t\t\t     (match_operand:HI 3 \"immediate_operand\" \"i\"))\n-\t\t     (match_operand:HI 4 \"immediate_operand\" \"1\")))]\n-  \"GET_CODE (operands[3]) == CONST_INT && GET_CODE (operands[1]) == CONST_INT\n-   && exact_log2 (INTVAL (operands[3])) == INTVAL (operands[1])\"\n-  \"bnot\t%Z1,%Y0\"\n-  [(set_attr \"cc\" \"none_0hit\")\n-   (set_attr \"length\" \"2\")])\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (not:SI\n+\t\t  (zero_extend:SI\n+\t\t    (lshiftrt:QI (match_operand:QI 1 \"bit_operand\" \"Ur\")\n+\t\t\t\t (match_operand:QI 2 \"const_int_operand\" \"n\"))))\n+\t\t(const_int 1)))]\n+  \"\"\n+  \"* return output_simode_bld (1, 0, operands);\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n \n-;; ??? Implement BIAND, BIOR, BIXOR\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (not:SI\n+\t\t  (subreg:SI \n+\t\t     (lshiftrt:HI\n+\t\t\t(match_operand:HI 1 \"bit_operand\" \"Ur\")\n+\t\t\t(match_operand:HI 2 \"const_int_operand\" \"n\")) 0))\n+\t\t(const_int 1)))]\n+  \"1\"\n+  \"* return output_simode_bld (1, 0, operands);\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n \n-;; ??? Implement BILD, BIST\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(and:SI (not:SI\n+\t\t  (subreg:SI \n+\t\t     (lshiftrt:QI\n+\t\t\t(match_operand:QI 1 \"bit_operand\" \"Ur\")\n+\t\t\t(match_operand:QI 2 \"const_int_operand\" \"n\")) 0))\n+\t\t(const_int 1)))]\n+  \"1\"\n+  \"* return output_simode_bld (1, 0, operands);\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))])\n \n-;; ??? Apparently general_operand for the 1st and 2nd operands is useful,\n-;; but I don't know why.  --Jim\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:SI (xor:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t\t (match_operand:HI 3 \"p_operand\" \"P\"))\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 2 \"const_int_operand\" \"n\")))]\n+  \"(1 << INTVAL (operands[2])) == INTVAL (operands[3])\"\n+  \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"8\")])\n \n (define_expand \"insv\"\n-  [(set (zero_extract:HI (match_operand:QI 0 \"bit_operand\" \"Ur\")\n-\t\t\t (match_operand:HI 1 \"general_operand\" \"g\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"g\"))\n-\t(zero_extract:HI (match_operand:QI 3 \"bit_operand\" \"Ur\")\n-\t\t\t (const_int 1)\n-\t\t\t (const_int 0)))]\n-;; ??? This should have word mode which is SImode for the h8/300h.\n+  [(set (zero_extract:HI (match_operand:HI 0 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 1 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\"))\n+\t(match_operand:HI 3 \"general_operand\" \"\"))]\n   \"TARGET_H8300\"\n   \"\n {\n+  /* We only have single bit bitfield instructions.  */\n   if (INTVAL (operands[1]) != 1)\n     FAIL;\n \n-  /* ??? HACK ???\n-     This INSV pattern is wrong.  It should use HImode for operand 3.\n-     Also, the zero_extract around operand 3 is superfluous and should be\n-     deleted.  Fixing this is more work than we care to do for the moment,\n-     because it means most of the above patterns would need to be rewritten,\n-     and we also need more combine.c patches to make this work.\n-\n-     So, for now, we work around this bug by simply not accepting any bitfield\n-     inserts that have a position greater than fits in QImode.  */\n-\n-  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) >= 8)\n+  /* For now, we don't allow memory operands.  */\n+  if (GET_CODE (operands[0]) == MEM\n+      || GET_CODE (operands[3]) == MEM)\n     FAIL;\n-\n-  /* The bit_operand predicate accepts any memory during RTL generation, but\n-     only 'U' memory afterwards, so if this is a MEM operand, we must force\n-     it to be valid for 'U' by reloading the address.  */\n-\n-  if (GET_CODE (operands[0]) == MEM && ! EXTRA_CONSTRAINT (operands[0], 'U'))\n-    {\n-      rtx mem;\n-      mem = gen_rtx (MEM, GET_MODE (operands[0]),\n-\t\t     copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n-      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[0]);\n-      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[0]);\n-      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[0]);\n-      operands[0] = mem;\n-    }\n-\n-  /* Likewise for operands[3].  */\n-\n-  if (GET_CODE (operands[3]) == MEM && ! EXTRA_CONSTRAINT (operands[3], 'U'))\n-    {\n-      rtx mem;\n-      mem = gen_rtx (MEM, GET_MODE (operands[3]),\n-\t\t     copy_to_mode_reg (Pmode, XEXP (operands[3], 0)));\n-      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[3]);\n-      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[3]);\n-      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[3]);\n-      operands[3] = mem;\n-    }\n }\")\n \n-;; ??? Apparently general_operand for the 2nd and 3rd operands is useful,\n-;; but I don't know why.  --Jim\n+(define_insn \"\"\n+  [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n+\t(match_operand:HI 2 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"bld\t#0,%R2\\;bst\t%Z1,%Y0 ; i1\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"extzv\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\") \n-\t(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"g\")\n-\t\t\t (match_operand:HI 3 \"general_operand\" \"g\")))]\n-;; ??? This should have word mode which is SImode for the h8/300h.\n+\t(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 3 \"general_operand\" \"\")))]\n   \"TARGET_H8300\"\n   \"\n {\n+  /* We only have single bit bitfield instructions.  */\n   if (INTVAL (operands[2]) != 1)\n     FAIL;\n \n-  /* The bit_operand predicate accepts any memory during RTL generation, but\n-     only 'U' memory afterwards, so if this is a MEM operand, we must force\n-     it to be valid for 'U' by reloading the address.  */\n-\n-  if (GET_CODE (operands[1]) == MEM && ! EXTRA_CONSTRAINT (operands[1], 'U'))\n-    {\n-      rtx mem;\n-      mem = gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t     copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n-      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[1]);\n-      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[1]);\n-      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[1]);\n-      operands[1] = mem;\n-    }\n+  /* For now, we don't allow memory operands.  */\n+  if (GET_CODE (operands[1]) == MEM)\n+    FAIL;\n }\")\n-\f\n-;; -----------------------------------------------------------------\n-;; STACK POINTER MANIPULATIONS\n-;; -----------------------------------------------------------------\n \n-;; This pattern is needed because there is no way on the H8/300\n-;; to add a 16 bit immediate value to the stack pointer in one \n-;; instruction, which could leave an invalid instruction if interrupted\n-;; half way through.  Here we add to the stack pointer from a\n-;; register.\n+;; BAND, BOR, and BXOR patterns\n \n-(define_insn \"stack_pointer_manip\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=&ra\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand_src\" \"g\")\n-\t\t (match_operand:HI 2 \"register_operand\" \"ra\")))]\n-  \"TARGET_H8300\"\n-  \"mov.w\t%T1,%T0\\;add.w\t%T2,%T0\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"set_zn_c0\")])\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 4 \"bit_operator\"\n+\t   [(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t    (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;%b4\t#0,%R0\\;bst\t#0,%R0; bl1\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"6\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 5 \"bit_operator\"\n+\t   [(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t    (zero_extract:HI (match_operand:HI 3 \"register_operand\" \"r\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 4 \"immediate_operand\" \"i\"))]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%R0; bl3\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"6\")])\n \n+\f\n ;; -------------------------------------------\n ;; BLK moves\n ;; -------------------------------------------\n@@ -2203,7 +2336,7 @@\n \n (define_peephole\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n+\t(mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\"))))\n    (set (match_operand:QI 3 \"register_operand\" \"=r\")\n \t(mem:QI (plus:HI (match_dup 1)\n@@ -2214,7 +2347,7 @@\n    (set_attr \"cc\" \"set\")])\n \n (define_peephole\n-  [(set (mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n+  [(set (mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\")))\n \t(match_operand:QI 0 \"register_operand\" \"r\"))\n    (set (mem:QI (plus:HI (match_dup 1)\n@@ -2283,7 +2416,7 @@\n \t(ior:QI (subreg:QI \n \t\t (ashift:HI (const_int 1)\n \t\t\t    (match_operand:HI 1 \"nonmemory_operand\" \"ri\") ) 0)\n-\t\t(match_operand:QI 2 \"general_operand\" \"Ur\")))]\n+\t\t(match_operand:QI 2 \"general_operand_src\" \"Ur>\")))]\n   \"\"\n   \"mov.b\t%R2,%R0\\;bset\t%X1,%R0\"\n   [(set_attr \"length\" \"4\")\n@@ -2343,15 +2476,6 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"fancybclr\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n-\t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"0\"))\n-\t\t(match_operand:QI 2 \"general_operand\" \"r\")))]\n-  \"\"\n-  \"not\t%X0\\;and\t%X2,%X0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n (define_insn \"fancybsetp3\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n \t(ior:QI (subreg:QI (ashift:HI (const_int 1)\n@@ -2366,7 +2490,7 @@\n   [(set (match_operand:QI 0 \"general_operand\" \"=r,U\")\n \t(ior:QI (subreg:QI (ashift:HI (const_int 1)\n \t\t\t\t      (match_operand:QI 1 \"register_operand\" \"r,r\")) 0)\n-\t\t(match_operand:QI 2 \"general_operand\" \"U,r\")))]\n+\t\t(match_operand:QI 2 \"general_operand_src\" \"U,r>\")))]\n   \"\"\n   \"mov.b\t%R2,%R0\\;bset\t%X1,%R0\"\n   [(set_attr \"length\" \"4\")\n@@ -2383,50 +2507,8 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"fancy_btst\"\n-  [(set (pc)\n-\t(if_then_else (eq (zero_extract:HI (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"Ur\"))\n-\t\t\t\t\t   (const_int 1)\n-\t\t\t\t\t   (match_operand:HI 2 \"nonmemory_operand\" \"rn\"))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (get_attr_length (insn) == 2)\n-    return \\\"btst\t%X2,%R1\\;beq\t%l0\\\";\n-  else if (get_attr_length (insn) == 4)\n-    return \\\"btst\t%X2,%R1\\;beq\t%l0:16\\\";\n-  else\n-    return \\\"btst\t%X2,%R1\\;bne\t%L1\\;jmp\t@%l0\\;%L1:\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"fancy_btst1\"\n-  [(set (pc)\n-\t(if_then_else (ne (zero_extract:HI (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"Ur\"))\n-\t\t\t\t\t   (const_int 1)\n-\t\t\t\t\t   (match_operand:HI 2 \"nonmemory_operand\" \"rn\"))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (get_attr_length (insn) == 2)\n-    return \\\"btst\t%X2,%R1\\;bne\t%l0\\\";\n-  else if (get_attr_length (insn) == 4)\n-    return \\\"btst\t%X2,%R1\\;bne\t%l0:16\\\";\n-  else\n-    return \\\"btst\t%X2,%R1\\;beq\t%L1\\;jmp\t@%l0\\;%L1:\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n (define_insn \"pxor\"\n-  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+  [(set (zero_extract:QI (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand 1 \"immediate_operand\" \"n,n\"))\n \t(and:QI (not:QI (match_operand:QI 2 \"bit_operand\" \"r,U\"))\n@@ -2435,3 +2517,31 @@\n   \"bld\t#0,%R2\\;bist\t%1,%0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(and:QI (not:QI (match_operand:QI 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rJ\")))]\n+  \"\"\n+  \"not.b\t%X0\\;and.b\t%X2,%X0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (not:HI (match_operand:HI 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"rJ\")))]\n+  \"TARGET_H8300H\"\n+  \"not.w\t%T0\\;and.w\t%T2,%T0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rJ\")))]\n+  \"TARGET_H8300H\"\n+  \"not.l\t%S0\\;and.l\t%S2,%S0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+"}]}