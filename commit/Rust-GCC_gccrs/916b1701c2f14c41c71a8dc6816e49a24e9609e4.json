{"sha": "916b1701c2f14c41c71a8dc6816e49a24e9609e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2YjE3MDFjMmYxNGM0MWM3MWE4ZGM2ODE2ZTQ5YTI0ZTk2MDllNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-05T10:24:03Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-05T10:24:03Z"}, "message": "abstract regset stuff into macros\n\nFrom-SVN: r14147", "tree": {"sha": "619a5e6cc2340785ce05f2bf95307154e057626d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/619a5e6cc2340785ce05f2bf95307154e057626d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916b1701c2f14c41c71a8dc6816e49a24e9609e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916b1701c2f14c41c71a8dc6816e49a24e9609e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916b1701c2f14c41c71a8dc6816e49a24e9609e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916b1701c2f14c41c71a8dc6816e49a24e9609e4/comments", "author": null, "committer": null, "parents": [{"sha": "2217c9f0e87acd69fb5e2675cee25bc97c32f4ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2217c9f0e87acd69fb5e2675cee25bc97c32f4ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2217c9f0e87acd69fb5e2675cee25bc97c32f4ef"}], "stats": {"total": 902, "additions": 458, "deletions": 444}, "files": [{"sha": "a6b8cf9dc52e0bfa46fc2debbbcca6e7ece95e45", "filename": "gcc/basic-block.h", "status": "modified", "additions": 219, "deletions": 2, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=916b1701c2f14c41c71a8dc6816e49a24e9609e4", "patch": "@@ -19,9 +19,11 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* Number of bits in each actual element of a regset.  */\n+/* Number of bits in each actual element of a regset.  We get slightly\n+   better code for reg%bits and reg/bits if bits is unsigned, assuming\n+   it is a power of 2.  */\n \n-#define REGSET_ELT_BITS HOST_BITS_PER_WIDE_INT\n+#define REGSET_ELT_BITS ((unsigned) HOST_BITS_PER_WIDE_INT)\n \n /* Type to use for a regset element.  Note that lots of code assumes\n    that the initial part of a regset that contains information on the\n@@ -40,6 +42,221 @@ typedef REGSET_ELT_TYPE *regset;\n extern int regset_bytes;\n extern int regset_size;\n \n+/* clear a register set */\n+#define CLEAR_REG_SET(TO)\t\t\t\t\t\t\\\n+do { register REGSET_ELT_TYPE *scan_tp_ = (TO);\t\t\t\t\\\n+     register int i_;\t\t\t\t\t\t\t\\\n+     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n+       *scan_tp_++ = 0; } while (0)\n+\n+/* copy a register to another register */\n+#define COPY_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n+do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+     register int i_;\t\t\t\t\t\t\t\\\n+     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n+       *scan_tp_++ = *scan_fp_++; } while (0)\n+\n+/* complent a register set, storing it in a second register set.  */\n+#define COMPL_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n+do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+     register int i_;\t\t\t\t\t\t\t\\\n+     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n+       *scan_tp_++ = ~ *scan_fp_++; } while (0)\n+\n+/* and a register set with a second register set.  */\n+#define AND_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n+do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+     register int i_;\t\t\t\t\t\t\t\\\n+     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n+       *scan_tp_++ &= *scan_fp_++; } while (0)\n+\n+/* and the complement of a register set to a register set.  */\n+#define AND_COMPL_REG_SET(TO, FROM)\t\t\t\t\t\\\n+do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+     register int i_;\t\t\t\t\t\t\t\\\n+     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n+       *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n+\n+/* inclusive or a register set with a second register set.  */\n+#define IOR_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n+do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+     register int i_;\t\t\t\t\t\t\t\\\n+     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n+       *scan_tp_++ |= *scan_fp_++; } while (0)\n+\n+/* complement two register sets and or in the result into a third.  */\n+#define IOR_AND_COMPL_REG_SET(TO, FROM1, FROM2)\t\t\t\t\\\n+do { register REGSET_ELT_TYPE *scan_tp_ = (TO);\t\t\t\t\\\n+     register REGSET_ELT_TYPE *scan_fp1_ = (FROM1);\t\t\t\\\n+     register REGSET_ELT_TYPE *scan_fp2_ = (FROM2);\t\t\t\\\n+     register int i_;\t\t\t\t\t\t\t\\\n+     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n+       *scan_tp_++ |= *scan_fp1_++ & ~ *scan_fp2_++; } while (0)\n+\n+/* Clear a single register in a register set.  */\n+#define CLEAR_REGNO_REG_SET(TO, REG)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  register REGSET_ELT_TYPE *tp_ = (TO);\t\t\t\t\t\\\n+  tp_[ (REG) / REGSET_ELT_BITS ]\t\t\t\t\t\\\n+    &= ~ ((REGSET_ELT_TYPE) 1 << ((REG) % REGSET_ELT_BITS)); } while (0);\n+\n+/* Set a single register in a register set.  */\n+#define SET_REGNO_REG_SET(TO, REG)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  register REGSET_ELT_TYPE *tp_ = (TO);\t\t\t\t\t\\\n+  tp_[ (REG) / REGSET_ELT_BITS ]\t\t\t\t\t\\\n+    |= ((REGSET_ELT_TYPE) 1 << ((REG) % REGSET_ELT_BITS)); } while (0);\n+\n+/* Return true if a register is set in a register set.  */\n+#define REGNO_REG_SET_P(TO, REG)\t\t\t\t\t\\\n+ (((TO)[ (REG) / REGSET_ELT_BITS ]\t\t\t\t\t\\\n+   & (((REGSET_ELT_TYPE)1) << (REG) % REGSET_ELT_BITS)) != 0)\n+\n+/* Copy the hard registers in a register set to the hard register set.  */\n+#define REG_SET_TO_HARD_REG_SET(TO, FROM)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  int i_;\t\t\t\t\t\t\t\t\\\n+  CLEAR_HARD_REG_SET (TO);\t\t\t\t\t\t\\\n+  for (i_ = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\t\\\n+    if (REGNO_REG_SET_P (FROM, i_))\t\t\t\t\t\\\n+      SET_HARD_REG_BIT (TO, i_);\t\t\t\t\t\\\n+} while (0)\n+\n+/* Loop over all registers in REGSET, starting with MIN, setting REGNUM to the\n+   register number and executing CODE for all registers that are set. */\n+#define EXECUTE_IF_SET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  register REGSET_ELT_TYPE *scan_rs_ = (REGSET);\t\t\t\\\n+  register int i_;\t\t\t\t\t\t\t\\\n+  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n+  for (i_ = (MIN) / REGSET_ELT_BITS; i_ < regset_size; i_++)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      REGSET_ELT_TYPE word_ = *scan_rs_++;\t\t\t\t\\\n+      if (word_)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n+\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n+\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n+\t       j_ != 0;\t\t\t\t\t\t\t\\\n+\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (word_ & j_)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  CODE;\t\t\t\t\t\t\t\\\n+\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n+\t\t  if (!word_)\t\t\t\t\t\t\\\n+\t\t    break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      shift_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Like EXECUTE_IF_SET_IN_REG_SET, but also clear the register set.  */\n+#define EXECUTE_IF_SET_AND_RESET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  register REGSET_ELT_TYPE *scan_rs_ = (REGSET);\t\t\t\\\n+  register int i_;\t\t\t\t\t\t\t\\\n+  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n+  for (i_ = (MIN) / REGSET_ELT_BITS; i_ < regset_size; i_++)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      REGSET_ELT_TYPE word_ = *scan_rs_++;\t\t\t\t\\\n+      if (word_)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n+\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n+\t  scan_rs_[-1] = 0;\t\t\t\t\t\t\\\n+\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n+\t       j_ != 0;\t\t\t\t\t\t\t\\\n+\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (word_ & j_)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  CODE;\t\t\t\t\t\t\t\\\n+\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n+\t\t  if (!word_)\t\t\t\t\t\t\\\n+\t\t    break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      shift_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n+   REGNUM to the register number and executing CODE for all registers that are\n+   set in both regsets. */\n+#define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  register REGSET_ELT_TYPE *scan_rs1_ = (REGSET1);\t\t\t\\\n+  register REGSET_ELT_TYPE *scan_rs2_ = (REGSET2);\t\t\t\\\n+  register int i_;\t\t\t\t\t\t\t\\\n+  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n+  for (i_ = (MIN) / REGSET_ELT_BITS; i_ < regset_size; i_++)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      REGSET_ELT_TYPE word_ = *scan_rs1_++ & *scan_rs2_++;\t\t\\\n+      if (word_)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n+\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n+\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n+\t       j_ != 0;\t\t\t\t\t\t\t\\\n+\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (word_ & j_)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  CODE;\t\t\t\t\t\t\t\\\n+\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n+\t\t  if (!word_)\t\t\t\t\t\t\\\n+\t\t    break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      shift_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n+   REGNUM to the register number and executing CODE for all registers that are\n+   set in the first regset and not set in the second. */\n+#define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  register REGSET_ELT_TYPE *scan_rs1_ = (REGSET1);\t\t\t\\\n+  register REGSET_ELT_TYPE *scan_rs2_ = (REGSET2);\t\t\t\\\n+  register int i_;\t\t\t\t\t\t\t\\\n+  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n+  for (i_ = (MIN) / REGSET_ELT_BITS; i_ < regset_size; i_++)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      REGSET_ELT_TYPE word_ = *scan_rs1_++ & ~ *scan_rs2_++;\t\t\\\n+      if (word_)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n+\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n+\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n+\t       j_ != 0;\t\t\t\t\t\t\t\\\n+\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (word_ & j_)\t\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  CODE;\t\t\t\t\t\t\t\\\n+\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n+\t\t  if (!word_)\t\t\t\t\t\t\\\n+\t\t    break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      shift_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Allocate a register set with oballoc.  */\n+#define OBALLOC_REG_SET()\t\t\t\t\t\t\\\n+  ((regset) obstack_alloc (&flow_obstack, regset_bytes))\n+\n+/* Allocate a register set with alloca.  */\n+#define ALLOCA_REG_SET() ((regset) alloca (regset_bytes))\n+\n /* Number of basic blocks in the current function.  */\n \n extern int n_basic_blocks;"}, {"sha": "51b9d5a8f62b0c1674ee8fa24ca5abfe674658d6", "filename": "gcc/caller-save.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=916b1701c2f14c41c71a8dc6816e49a24e9609e4", "patch": "@@ -367,31 +367,20 @@ save_call_clobbered_regs (insn_mode)\n \t saved because we restore all of them before the end of the basic\n \t block.  */\n \n-#ifdef HARD_REG_SET\n-      hard_regs_live = *regs_live;\n-#else\n-      COPY_HARD_REG_SET (hard_regs_live, regs_live);\n-#endif\n-\n+      REG_SET_TO_HARD_REG_SET (hard_regs_live, regs_live);\n       CLEAR_HARD_REG_SET (hard_regs_saved);\n       CLEAR_HARD_REG_SET (hard_regs_need_restore);\n       n_regs_saved = 0;\n \n-      for (offset = 0, i = 0; offset < regset_size; offset++)\n-\t{\n-\t  if (regs_live[offset] == 0)\n-\t    i += REGSET_ELT_BITS;\n-\t  else\n-\t    for (bit = 1; bit && i < max_regno; bit <<= 1, i++)\n-\t      if ((regs_live[offset] & bit)\n-\t\t  && (regno = reg_renumber[i]) >= 0)\n-\t\tfor (j = regno;\n-\t\t     j < regno + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t   PSEUDO_REGNO_MODE (i));\n-\t\t     j++)\n-\t\t  SET_HARD_REG_BIT (hard_regs_live, j);\n-\n-\t}\n+      EXECUTE_IF_SET_IN_REG_SET (regs_live, 0, i,\n+\t\t\t\t {\n+\t\t\t\t   if ((regno = reg_renumber[i]) >= 0)\n+\t\t\t\t     for (j = regno;\n+\t\t\t\t\t  j < regno + HARD_REGNO_NREGS (regno,\n+\t\t\t\t\t\t\t\t\tPSEUDO_REGNO_MODE (i));\n+\t\t\t\t\t  j++)\n+\t\t\t\t       SET_HARD_REG_BIT (hard_regs_live, j);\n+\t\t\t\t });\n \n       /* Now scan the insns in the block, keeping track of what hard\n \t regs are live as we go.  When we see a call, save the live"}, {"sha": "d39b784c6a40eb0745d86493eea5a2f07ba71b30", "filename": "gcc/flow.c", "status": "modified", "additions": 131, "deletions": 216, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=916b1701c2f14c41c71a8dc6816e49a24e9609e4", "patch": "@@ -1024,12 +1024,10 @@ life_analysis (f, nregs)\n       {\n \t/* If exiting needs the right stack value,\n \t   consider the stack pointer live at the end of the function.  */\n-\tbasic_block_live_at_end[n_basic_blocks - 1]\n-\t  [STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t    |= (REGSET_ELT_TYPE) 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n-\tbasic_block_new_live_at_end[n_basic_blocks - 1]\n-\t  [STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t    |= (REGSET_ELT_TYPE) 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n+\tSET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1],\n+\t\t\t   STACK_POINTER_REGNUM);\n+\tSET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1],\n+\t\t\t   STACK_POINTER_REGNUM);\n       }\n \n   /* Mark the frame pointer is needed at the end of the function.  If\n@@ -1038,22 +1036,16 @@ life_analysis (f, nregs)\n \n   if (n_basic_blocks > 0)\n     {\n-      basic_block_live_at_end[n_basic_blocks - 1]\n-\t[FRAME_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t  |= (REGSET_ELT_TYPE) 1 << (FRAME_POINTER_REGNUM % REGSET_ELT_BITS);\n-      basic_block_new_live_at_end[n_basic_blocks - 1]\n-\t[FRAME_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t  |= (REGSET_ELT_TYPE) 1 << (FRAME_POINTER_REGNUM % REGSET_ELT_BITS);\n+      SET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1],\n+\t\t\t FRAME_POINTER_REGNUM);\n+      SET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1],\n+\t\t\t FRAME_POINTER_REGNUM);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n       /* If they are different, also mark the hard frame pointer as live */\n-      basic_block_live_at_end[n_basic_blocks - 1]\n-\t[HARD_FRAME_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t  |= (REGSET_ELT_TYPE) 1 << (HARD_FRAME_POINTER_REGNUM\n-\t\t\t\t     % REGSET_ELT_BITS);\n-      basic_block_new_live_at_end[n_basic_blocks - 1]\n-\t[HARD_FRAME_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t  |= (REGSET_ELT_TYPE) 1 << (HARD_FRAME_POINTER_REGNUM\n-\t\t\t\t     % REGSET_ELT_BITS);\n+      SET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1],\n+\t\t\t HARD_FRAME_POINTER_REGNUM);\n+      SET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1],\n+\t\t\t HARD_FRAME_POINTER_REGNUM);\n #endif      \n       }\n \n@@ -1069,12 +1061,8 @@ life_analysis (f, nregs)\n #endif\n \t  )\n \t{\n-\t  basic_block_live_at_end[n_basic_blocks - 1]\n-\t    [i / REGSET_ELT_BITS]\n-\t      |= (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n-\t  basic_block_new_live_at_end[n_basic_blocks - 1]\n-\t    [i / REGSET_ELT_BITS]\n-\t      |= (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n+\t  SET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1], i);\n+\t  SET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1], i);\n \t}\n \n   /* Propagate life info through the basic blocks\n@@ -1109,21 +1097,18 @@ life_analysis (f, nregs)\n \t\t reg that is live at the end now but was not live there before\n \t\t is one of the significant regs of this basic block).  */\n \n-\t      for (j = 0; j < regset_size; j++)\n-\t\t{\n-\t\t  register REGSET_ELT_TYPE x\n-\t\t    = (basic_block_new_live_at_end[i][j]\n-\t\t       & ~basic_block_live_at_end[i][j]);\n-\t\t  if (x)\n-\t\t    consider = 1;\n-\t\t  if (x & basic_block_significant[i][j])\n-\t\t    {\n-\t\t      must_rescan = 1;\n-\t\t      consider = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n+\t      EXECUTE_IF_AND_COMPL_IN_REG_SET (basic_block_new_live_at_end[i],\n+\t\t\t\t\t       basic_block_live_at_end[i],\n+\t\t\t\t\t       0, j,\n+\t\t\t\t\t       {\n+\t\t\t\t\t\t consider = 1;\n+\t\t\t\t\t\t if (REGNO_REG_SET_P (basic_block_significant[i], j))\n+\t\t\t\t\t\t   {\n+\t\t\t\t\t\t     must_rescan = 1;\n+\t\t\t\t\t\t     goto done;\n+\t\t\t\t\t\t   }\n+\t\t\t\t\t       });\n+\t    done:\n \t      if (! consider)\n \t\tcontinue;\n \t    }\n@@ -1137,23 +1122,22 @@ life_analysis (f, nregs)\n \t      /* No complete rescan needed;\n \t\t just record those variables newly known live at end\n \t\t as live at start as well.  */\n-\t      for (j = 0; j < regset_size; j++)\n-\t\t{\n-\t\t  register REGSET_ELT_TYPE x\n-\t\t    = (basic_block_new_live_at_end[i][j]\n-\t\t       & ~basic_block_live_at_end[i][j]);\n-\t\t  basic_block_live_at_start[i][j] |= x;\n-\t\t  basic_block_live_at_end[i][j] |= x;\n-\t\t}\n+\t      IOR_AND_COMPL_REG_SET (basic_block_live_at_start[i],\n+\t\t\t\t     basic_block_new_live_at_end[i],\n+\t\t\t\t     basic_block_live_at_end[i]);\n+\n+\t      IOR_AND_COMPL_REG_SET (basic_block_live_at_end[i],\n+\t\t\t\t     basic_block_new_live_at_end[i],\n+\t\t\t\t     basic_block_live_at_end[i]);\n \t    }\n \t  else\n \t    {\n \t      /* Update the basic_block_live_at_start\n \t\t by propagation backwards through the block.  */\n-\t      bcopy ((char *) basic_block_new_live_at_end[i],\n-\t\t     (char *) basic_block_live_at_end[i], regset_bytes);\n-\t      bcopy ((char *) basic_block_live_at_end[i],\n-\t\t     (char *) basic_block_live_at_start[i], regset_bytes);\n+\t      COPY_REG_SET (basic_block_live_at_end[i],\n+\t\t\t    basic_block_new_live_at_end[i]);\n+\t      COPY_REG_SET (basic_block_live_at_start[i],\n+\t\t\t    basic_block_live_at_end[i]);\n \t      propagate_block (basic_block_live_at_start[i],\n \t\t\t       basic_block_head[i], basic_block_end[i], 0,\n \t\t\t       first_pass ? basic_block_significant[i]\n@@ -1168,12 +1152,8 @@ life_analysis (f, nregs)\n \t       that falls through into this one (if any).  */\n \t    head = basic_block_head[i];\n \t    if (basic_block_drops_in[i])\n-\t      {\n-\t\tregister int j;\n-\t\tfor (j = 0; j < regset_size; j++)\n-\t\t  basic_block_new_live_at_end[i-1][j]\n-\t\t    |= basic_block_live_at_start[i][j];\n-\t      }\n+\t      IOR_REG_SET (basic_block_new_live_at_end[i-1],\n+\t\t\t   basic_block_live_at_start[i]);\n \n \t    /* Update the basic_block_new_live_at_end's of\n \t       all the blocks that jump to this one.  */\n@@ -1183,10 +1163,8 @@ life_analysis (f, nregs)\n \t\t   jump = LABEL_NEXTREF (jump))\n \t\t{\n \t\t  register int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n-\t\t  register int j;\n-\t\t  for (j = 0; j < regset_size; j++)\n-\t\t    basic_block_new_live_at_end[from_block][j]\n-\t\t      |= basic_block_live_at_start[i][j];\n+\t\t  IOR_REG_SET (basic_block_new_live_at_end[from_block],\n+\t\t\t       basic_block_live_at_start[i]);\n \t\t}\n \t  }\n #ifdef USE_C_ALLOCA\n@@ -1202,10 +1180,11 @@ life_analysis (f, nregs)\n      one basic block.  */\n \n   if (n_basic_blocks > 0)\n-    for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-      if (basic_block_live_at_start[0][i / REGSET_ELT_BITS]\n-\t  & ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n-\tREG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n+    EXECUTE_IF_SET_IN_REG_SET (basic_block_live_at_start[0],\n+\t\t\t       FIRST_PSEUDO_REGISTER, i,\n+\t\t\t       {\n+\t\t\t\t REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n+\t\t\t       });\n \n   /* Now the life information is accurate.\n      Make one more pass over each basic block\n@@ -1236,14 +1215,16 @@ life_analysis (f, nregs)\n      But we don't need to do this for the user's variables, since\n      ANSI says only volatile variables need this.  */\n #ifdef LONGJMP_RESTORE_FROM_STACK\n-  for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n-    if (regs_live_at_setjmp[i / REGSET_ELT_BITS]\n-\t& ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS))\n-\t&& regno_reg_rtx[i] != 0 && ! REG_USERVAR_P (regno_reg_rtx[i]))\n-      {\n-\tREG_LIVE_LENGTH (i) = -1;\n-\tREG_BASIC_BLOCK (i) = -1;\n-      }\n+  EXECUTE_IF_SET_IN_REG_SET (regs_live_at_setjmp,\n+\t\t\t     FIRST_PSEUDO_REGISTER, i,\n+\t\t\t     {\n+\t\t\t       if (regno_reg_rtx[i] != 0\n+\t\t\t\t   && ! REG_USERVAR_P (regno_reg_rtx[i]))\n+\t\t\t\t {\n+\t\t\t\t   REG_LIVE_LENGTH (i) = -1;\n+\t\t\t\t   REG_BASIC_BLOCK (i) = -1;\n+\t\t\t\t }\n+\t\t\t     });\n #endif\n #endif\n \n@@ -1256,14 +1237,15 @@ life_analysis (f, nregs)\n      If the pseudo goes in a hard reg, some other value may occupy\n      that hard reg where this pseudo is dead, thus clobbering the pseudo.\n      Conclusion: such a pseudo must not go in a hard reg.  */\n-  for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n-    if ((regs_live_at_setjmp[i / REGSET_ELT_BITS]\n-\t & ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n-\t&& regno_reg_rtx[i] != 0)\n-      {\n-\tREG_LIVE_LENGTH (i) = -1;\n-\tREG_BASIC_BLOCK (i) = -1;\n-      }\n+  EXECUTE_IF_SET_IN_REG_SET (regs_live_at_setjmp,\n+\t\t\t     FIRST_PSEUDO_REGISTER, i,\n+\t\t\t     {\n+\t\t\t       if (regno_reg_rtx[i] != 0)\n+\t\t\t\t {\n+\t\t\t\t   REG_LIVE_LENGTH (i) = -1;\n+\t\t\t\t   REG_BASIC_BLOCK (i) = -1;\n+\t\t\t\t }\n+\t\t\t     });\n \n   obstack_free (&flow_obstack, NULL_PTR);\n }\n@@ -1360,11 +1342,8 @@ propagate_block (old, first, last, final, significant, bnum)\n   /* The following variables are used only if FINAL is nonzero.  */\n   /* This vector gets one element for each reg that has been live\n      at any point in the basic block that has been scanned so far.\n-     SOMETIMES_MAX says how many elements are in use so far.\n-     In each element, OFFSET is the byte-number within a regset\n-     for the register described by the element, and BIT is a mask\n-     for that register's bit within the byte.  */\n-  register struct sometimes { short offset; short bit; } *regs_sometimes_live;\n+     SOMETIMES_MAX says how many elements are in use so far.  */\n+  register int *regs_sometimes_live;\n   int sometimes_max = 0;\n   /* This regset has 1 for each reg that we have seen live so far.\n      It and REGS_SOMETIMES_LIVE are updated together.  */\n@@ -1396,32 +1375,22 @@ propagate_block (old, first, last, final, significant, bnum)\n \n   if (final)\n     {\n-      register int i, offset;\n-      REGSET_ELT_TYPE bit;\n+      register int i;\n \n       num_scratch = 0;\n       maxlive = (regset) alloca (regset_bytes);\n-      bcopy ((char *) old, (char *) maxlive, regset_bytes);\n-      regs_sometimes_live\n-\t= (struct sometimes *) alloca (max_regno * sizeof (struct sometimes));\n+      COPY_REG_SET (maxlive, old);\n+      regs_sometimes_live = (int *) alloca (max_regno * sizeof (int));\n \n       /* Process the regs live at the end of the block.\n \t Enter them in MAXLIVE and REGS_SOMETIMES_LIVE.\n-\t Also mark them as not local to any one basic block.  */\n-\n-      for (offset = 0, i = 0; offset < regset_size; offset++)\n-\tfor (bit = 1; bit; bit <<= 1, i++)\n-\t  {\n-\t    if (i == max_regno)\n-\t      break;\n-\t    if (old[offset] & bit)\n-\t      {\n-\t\tREG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n-\t\tregs_sometimes_live[sometimes_max].offset = offset;\n-\t\tregs_sometimes_live[sometimes_max].bit = i % REGSET_ELT_BITS;\n-\t\tsometimes_max++;\n-\t      }\n-\t  }\n+\t Also mark them as not local to any one basic block. */\n+      EXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n+\t\t\t\t {\n+\t\t\t\t   REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n+\t\t\t\t   regs_sometimes_live[sometimes_max] = i;\n+\t\t\t\t   sometimes_max++;\n+\t\t\t\t });\n     }\n \n   /* Scan the block an insn at a time from end to beginning.  */\n@@ -1448,11 +1417,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t     warn if any non-volatile datum is live.  */\n \n \t  if (final && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-\t    {\n-\t      int i;\n-\t      for (i = 0; i < regset_size; i++)\n-\t\tregs_live_at_setjmp[i] |= old[i];\n-\t    }\n+\t    IOR_REG_SET (regs_live_at_setjmp, old);\n \t}\n \n       /* Update the life-status of regs for this insn.\n@@ -1508,11 +1473,8 @@ propagate_block (old, first, last, final, significant, bnum)\n \t      goto flushed;\n \t    }\n \n-\t  for (i = 0; i < regset_size; i++)\n-\t    {\n-\t      dead[i] = 0;\t/* Faster than bzero here */\n-\t      live[i] = 0;\t/* since regset_size is usually small */\n-\t    }\n+\t  CLEAR_REG_SET (dead);\n+\t  CLEAR_REG_SET (live);\n \n \t  /* See if this is an increment or decrement that can be\n \t     merged into a following memory address.  */\n@@ -1602,13 +1564,10 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    if (call_used_regs[i] && ! global_regs[i]\n \t\t\t&& ! fixed_regs[i])\n-\t\t      dead[i / REGSET_ELT_BITS]\n-\t\t\t|= ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS));\n+\t\t      SET_REGNO_REG_SET (dead, i);\n \n \t\t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n-\t\t  live[STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t\t    |= ((REGSET_ELT_TYPE) 1\n-\t\t\t<< (STACK_POINTER_REGNUM % REGSET_ELT_BITS));\n+\t\t  SET_REGNO_REG_SET (live, STACK_POINTER_REGNUM);\n \n \t\t  /* Calls may also reference any of the global registers,\n \t\t     so they are made live.  */\n@@ -1623,23 +1582,20 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t}\n \n \t      /* Update OLD for the registers used or set.  */\n-\t      for (i = 0; i < regset_size; i++)\n-\t\t{\n-\t\t  old[i] &= ~dead[i];\n-\t\t  old[i] |= live[i];\n-\t\t}\n+\t      AND_COMPL_REG_SET (old, dead);\n+\t      IOR_REG_SET (old, live);\n \n \t      if (GET_CODE (insn) == CALL_INSN && final)\n \t\t{\n \t\t  /* Any regs live at the time of a call instruction\n \t\t     must not go in a register clobbered by calls.\n \t\t     Find all regs now live and record this for them.  */\n \n-\t\t  register struct sometimes *p = regs_sometimes_live;\n+\t\t  register int *p = regs_sometimes_live;\n \n \t\t  for (i = 0; i < sometimes_max; i++, p++)\n-\t\t    if (old[p->offset] & ((REGSET_ELT_TYPE) 1 << p->bit))\n-\t\t      REG_N_CALLS_CROSSED (p->offset * REGSET_ELT_BITS + p->bit)++;\n+\t\t    if (REGNO_REG_SET_P (old, *p))\n+\t\t      REG_N_CALLS_CROSSED (*p)++;\n \t\t}\n \t    }\n \n@@ -1649,33 +1605,22 @@ propagate_block (old, first, last, final, significant, bnum)\n \n \t  if (final)\n \t    {\n-\t      for (i = 0; i < regset_size; i++)\n-\t\t{\n-\t\t  register REGSET_ELT_TYPE diff = live[i] & ~maxlive[i];\n+\t      register int regno;\n+\t      register int *p;\n \n-\t\t  if (diff)\n-\t\t    {\n-\t\t      register int regno;\n-\t\t      maxlive[i] |= diff;\n-\t\t      for (regno = 0; diff && regno < REGSET_ELT_BITS; regno++)\n-\t\t\tif (diff & ((REGSET_ELT_TYPE) 1 << regno))\n-\t\t\t  {\n-\t\t\t    regs_sometimes_live[sometimes_max].offset = i;\n-\t\t\t    regs_sometimes_live[sometimes_max].bit = regno;\n-\t\t\t    diff &= ~ ((REGSET_ELT_TYPE) 1 << regno);\n-\t\t\t    sometimes_max++;\n-\t\t\t  }\n-\t\t    }\n-\t\t}\n+\t      EXECUTE_IF_AND_COMPL_IN_REG_SET (live, maxlive, 0, regno,\n+\t\t\t\t\t       {\n+\t\t\t\t\t\t regs_sometimes_live[sometimes_max++] = regno;\n+\t\t\t\t\t\t SET_REGNO_REG_SET (maxlive, regno);\n+\t\t\t\t\t       });\n \n-\t      {\n-\t\tregister struct sometimes *p = regs_sometimes_live;\n-\t\tfor (i = 0; i < sometimes_max; i++, p++)\n-\t\t  {\n-\t\t    if (old[p->offset] & ((REGSET_ELT_TYPE) 1 << p->bit))\n-\t\t      REG_LIVE_LENGTH (p->offset * REGSET_ELT_BITS + p->bit)++;\n-\t\t  }\n-\t      }\n+\t      p = regs_sometimes_live;\n+\t      for (i = 0; i < sometimes_max; i++)\n+\t\t{\n+\t\t  regno = *p++;\n+\t\t  if (REGNO_REG_SET_P (old, regno))\n+\t\t    REG_LIVE_LENGTH (regno)++;\n+\t\t}\n \t    }\n \t}\n     flushed: ;\n@@ -1728,9 +1673,6 @@ insn_dead_p (x, needed, call_ok)\n       if (GET_CODE (r) == REG)\n \t{\n \t  register int regno = REGNO (r);\n-\t  register int offset = regno / REGSET_ELT_BITS;\n-\t  register REGSET_ELT_TYPE bit\n-\t    = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t  /* Don't delete insns to set global regs.  */\n \t  if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n@@ -1745,7 +1687,7 @@ insn_dead_p (x, needed, call_ok)\n \t\t it, so we can treat it normally).  */\n \t      || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n #endif\n-\t      || (needed[offset] & bit) != 0)\n+\t      || REGNO_REG_SET_P (needed, regno))\n \t    return 0;\n \n \t  /* If this is a hard register, verify that subsequent words are\n@@ -1755,9 +1697,7 @@ insn_dead_p (x, needed, call_ok)\n \t      int n = HARD_REGNO_NREGS (regno, GET_MODE (r));\n \n \t      while (--n > 0)\n-\t\tif ((needed[(regno + n) / REGSET_ELT_BITS]\n-\t\t     & ((REGSET_ELT_TYPE) 1\n-\t\t\t<< ((regno + n) % REGSET_ELT_BITS))) != 0)\n+\t\tif (REGNO_REG_SET_P (needed, regno+n))\n \t\t  return 0;\n \t    }\n \n@@ -1866,8 +1806,7 @@ regno_uninitialized (regno)\n \t  && (global_regs[regno] || FUNCTION_ARG_REGNO_P (regno))))\n     return 0;\n \n-  return (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n-\t  & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS)));\n+  return REGNO_REG_SET_P (basic_block_live_at_start[0], regno);\n }\n \n /* 1 if register REGNO was alive at a place where `setjmp' was called\n@@ -1882,10 +1821,8 @@ regno_clobbered_at_setjmp (regno)\n     return 0;\n \n   return ((REG_N_SETS (regno) > 1\n-\t   || (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n-\t       & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n-\t  && (regs_live_at_setjmp[regno / REGSET_ELT_BITS]\n-\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))));\n+\t   || REGNO_REG_SET_P (basic_block_live_at_start[0], regno))\n+\t  && REGNO_REG_SET_P (regs_live_at_setjmp, regno));\n }\n \f\n /* Process the registers that are set within X.\n@@ -1978,18 +1915,15 @@ mark_set_1 (needed, dead, x, insn, significant)\n       && ! (regno < FIRST_PSEUDO_REGISTER && global_regs[regno]))\n     /* && regno != STACK_POINTER_REGNUM) -- let's try without this.  */\n     {\n-      register int offset = regno / REGSET_ELT_BITS;\n-      register REGSET_ELT_TYPE bit\n-\t= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n-      REGSET_ELT_TYPE some_needed = (needed[offset] & bit);\n-      REGSET_ELT_TYPE some_not_needed = (~ needed[offset]) & bit;\n+      int some_needed = REGNO_REG_SET_P (needed, regno);\n+      int some_not_needed = ! some_needed;\n \n       /* Mark it as a significant register for this basic block.  */\n       if (significant)\n-\tsignificant[offset] |= bit;\n+\tSET_REGNO_REG_SET (significant, regno);\n \n       /* Mark it as as dead before this insn.  */\n-      dead[offset] |= bit;\n+      SET_REGNO_REG_SET (dead, regno);\n \n       /* A hard reg in a wide mode may really be multiple registers.\n \t If so, mark all of them just like the first.  */\n@@ -2005,17 +1939,14 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n \t  while (--n > 0)\n \t    {\n-\t      REGSET_ELT_TYPE n_bit\n-\t\t= (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n-\n+\t      int regno_n = regno + n;\n+\t      int needed_regno = REGNO_REG_SET_P (needed, regno_n);\n \t      if (significant)\n-\t\tsignificant[(regno + n) / REGSET_ELT_BITS] |= n_bit;\n+\t\tSET_REGNO_REG_SET (significant, regno_n);\n \n-\t      dead[(regno + n) / REGSET_ELT_BITS] |= n_bit;\n-\t      some_needed\n-\t\t|= (needed[(regno + n) / REGSET_ELT_BITS] & n_bit);\n-\t      some_not_needed\n-\t\t|= ((~ needed[(regno + n) / REGSET_ELT_BITS]) & n_bit);\n+\t      SET_REGNO_REG_SET (dead, regno_n);\n+\t      some_needed |= needed_regno;\n+\t      some_not_needed |= ! needed_regno;\n \t    }\n \t}\n       /* Additional data to record if this is the final pass.  */\n@@ -2106,9 +2037,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n \n \t      for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n \t\t   i >= 0; i--)\n-\t\tif ((needed[(regno + i) / REGSET_ELT_BITS]\n-\t\t     & ((REGSET_ELT_TYPE) 1\n-\t\t\t<< ((regno + i) % REGSET_ELT_BITS))) == 0)\n+\t\tif (!REGNO_REG_SET_P (needed, regno + i))\n \t\t  REG_NOTES (insn)\n \t\t    = gen_rtx (EXPR_LIST, REG_UNUSED,\n \t\t\t       gen_rtx (REG, reg_raw_mode[regno + i],\n@@ -2271,8 +2200,7 @@ find_auto_inc (needed, x, insn)\n \t\t it previously wasn't live here.  If we don't mark\n \t\t it as needed, we'll put a REG_DEAD note for it\n \t\t on this insn, which is incorrect.  */\n-\t      needed[regno / REGSET_ELT_BITS]\n-\t\t|= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n+\t      SET_REGNO_REG_SET (needed, regno);\n \n \t      /* If there are any calls between INSN and INCR, show\n \t\t that REGNO now crosses them.  */\n@@ -2407,13 +2335,10 @@ mark_used_regs (needed, live, x, final, insn)\n \n       regno = REGNO (x);\n       {\n-\tregister int offset = regno / REGSET_ELT_BITS;\n-\tregister REGSET_ELT_TYPE bit\n-\t  = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n-\tREGSET_ELT_TYPE some_needed = needed[offset] & bit;\n-\tREGSET_ELT_TYPE some_not_needed = (~ needed[offset]) & bit;\n+\tREGSET_ELT_TYPE some_needed = REGNO_REG_SET_P (needed, regno);\n+\tREGSET_ELT_TYPE some_not_needed = ! some_needed;\n \n-\tlive[offset] |= bit;\n+\tSET_REGNO_REG_SET (live, regno);\n \n \t/* A hard reg in a wide mode may really be multiple registers.\n \t   If so, mark all of them just like the first.  */\n@@ -2455,13 +2380,12 @@ mark_used_regs (needed, live, x, final, insn)\n \t    n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n \t    while (--n > 0)\n \t      {\n-\t\tREGSET_ELT_TYPE n_bit\n-\t\t  = (REGSET_ELT_TYPE) 1 << ((regno + n) % REGSET_ELT_BITS);\n+\t\tint regno_n = regno + n;\n+\t\tint needed_regno = REGNO_REG_SET_P (needed, regno_n);\n \n-\t\tlive[(regno + n) / REGSET_ELT_BITS] |= n_bit;\n-\t\tsome_needed |= (needed[(regno + n) / REGSET_ELT_BITS] & n_bit);\n-\t\tsome_not_needed\n-\t\t  |= ((~ needed[(regno + n) / REGSET_ELT_BITS]) & n_bit);\n+\t\tSET_REGNO_REG_SET (live, regno_n);\n+\t\tsome_needed |= needed_regno;\n+\t\tsome_not_needed != ! needed_regno;\n \t      }\n \t  }\n \tif (final)\n@@ -2539,9 +2463,7 @@ mark_used_regs (needed, live, x, final, insn)\n \n \t\t    for (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1;\n \t\t\t i >= 0; i--)\n-\t\t      if ((needed[(regno + i) / REGSET_ELT_BITS]\n-\t\t\t   & ((REGSET_ELT_TYPE) 1\n-\t\t\t      << ((regno + i) % REGSET_ELT_BITS))) == 0\n+\t\t      if (!REGNO_REG_SET_P (needed, regno + i)\n \t\t\t  && ! dead_or_set_regno_p (insn, regno + i))\n \t\t\tREG_NOTES (insn)\n \t\t\t  = gen_rtx (EXPR_LIST, REG_DEAD,\n@@ -2635,17 +2557,15 @@ mark_used_regs (needed, live, x, final, insn)\n       if (! EXIT_IGNORE_STACK\n \t  || (! FRAME_POINTER_REQUIRED && flag_omit_frame_pointer))\n #endif\n-\tlive[STACK_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t  |= (REGSET_ELT_TYPE) 1 << (STACK_POINTER_REGNUM % REGSET_ELT_BITS);\n+\tSET_REGNO_REG_SET (live, STACK_POINTER_REGNUM);\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (global_regs[i]\n #ifdef EPILOGUE_USES\n \t    || EPILOGUE_USES (i)\n #endif\n \t    )\n-\t  live[i / REGSET_ELT_BITS]\n-\t    |= (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n+\t  SET_REGNO_REG_SET (live, i);\n       break;\n     }\n \n@@ -2945,13 +2865,8 @@ dump_flow_info (file)\n \t}\n       fprintf (file, \"\\nRegisters live at start:\");\n       for (regno = 0; regno < max_regno; regno++)\n-\t{\n-\t  register int offset = regno / REGSET_ELT_BITS;\n-\t  register REGSET_ELT_TYPE bit\n-\t    = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n-\t  if (basic_block_live_at_start[i][offset] & bit)\n-\t      fprintf (file, \" %d\", regno);\n-\t}\n+\tif (REGNO_REG_SET_P (basic_block_live_at_start[i], regno))\n+\t  fprintf (file, \" %d\", regno);\n       fprintf (file, \"\\n\");\n     }\n   fprintf (file, \"\\n\");"}, {"sha": "9ebd5a7d294b484e59d3e7dd7950e80235f1fc26", "filename": "gcc/global.c", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=916b1701c2f14c41c71a8dc6816e49a24e9609e4", "patch": "@@ -642,36 +642,21 @@ global_conflicts ()\n \t are explicitly marked in basic_block_live_at_start.  */\n \n       {\n-\tregister int offset;\n-\tREGSET_ELT_TYPE bit;\n \tregister regset old = basic_block_live_at_start[b];\n \tint ax = 0;\n \n-#ifdef HARD_REG_SET\n-\thard_regs_live = old[0];\n-#else\n-\tCOPY_HARD_REG_SET (hard_regs_live, old);\n-#endif\n-\tfor (offset = 0, i = 0; offset < regset_size; offset++)\n-\t  if (old[offset] == 0)\n-\t    i += REGSET_ELT_BITS;\n-\t  else\n-\t    for (bit = 1; bit; bit <<= 1, i++)\n-\t      {\n-\t\tif (i >= max_regno)\n-\t\t  break;\n-\t\tif (old[offset] & bit)\n-\t\t  {\n-\t\t    register int a = reg_allocno[i];\n-\t\t    if (a >= 0)\n-\t\t      {\n-\t\t\tSET_ALLOCNO_LIVE (a);\n-\t\t\tblock_start_allocnos[ax++] = a;\n-\t\t      }\n-\t\t    else if ((a = reg_renumber[i]) >= 0)\n-\t\t      mark_reg_live_nc (a, PSEUDO_REGNO_MODE (i));\n-\t\t  }\n-\t      }\n+\tREG_SET_TO_HARD_REG_SET (hard_regs_live, old);\n+\tEXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n+\t\t\t\t   {\n+\t\t\t\t     register int a = reg_allocno[i];\n+\t\t\t\t     if (a >= 0)\n+\t\t\t\t       {\n+\t\t\t\t\t SET_ALLOCNO_LIVE (a);\n+\t\t\t\t\t block_start_allocnos[ax++] = a;\n+\t\t\t\t       }\n+\t\t\t\t     else if ((a = reg_renumber[i]) >= 0)\n+\t\t\t\t       mark_reg_live_nc (a, PSEUDO_REGNO_MODE (i));\n+\t\t\t\t   });\n \n \t/* Record that each allocno now live conflicts with each other\n \t   allocno now live, and with each hard reg now live.  */\n@@ -1640,13 +1625,10 @@ mark_elimination (from, to)\n   int i;\n \n   for (i = 0; i < n_basic_blocks; i++)\n-    if ((basic_block_live_at_start[i][from / REGSET_ELT_BITS]\n-\t & ((REGSET_ELT_TYPE) 1 << (from % REGSET_ELT_BITS))) != 0)\n+    if (REGNO_REG_SET_P (basic_block_live_at_start[i], from))\n       {\n-\tbasic_block_live_at_start[i][from / REGSET_ELT_BITS]\n-\t  &= ~ ((REGSET_ELT_TYPE) 1 << (from % REGSET_ELT_BITS));\n-\tbasic_block_live_at_start[i][to / REGSET_ELT_BITS]\n-\t  |= ((REGSET_ELT_TYPE) 1 << (to % REGSET_ELT_BITS));\n+\tCLEAR_REGNO_REG_SET (basic_block_live_at_start[i], from);\n+\tSET_REGNO_REG_SET (basic_block_live_at_start[i], to);\n       }\n }\n \f"}, {"sha": "5abf1bb189960e5ac9f5b7b34501c5d895969212", "filename": "gcc/reorg.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=916b1701c2f14c41c71a8dc6816e49a24e9609e4", "patch": "@@ -2762,25 +2762,17 @@ mark_target_live_regs (target, res)\n \t marked live, plus live pseudo regs that have been renumbered to\n \t hard regs.  */\n \n-#ifdef HARD_REG_SET\n-      current_live_regs = *regs_live;\n-#else\n-      COPY_HARD_REG_SET (current_live_regs, regs_live);\n-#endif\n-\n-      for (offset = 0, i = 0; offset < regset_size; offset++)\n-\t{\n-\t  if (regs_live[offset] == 0)\n-\t    i += REGSET_ELT_BITS;\n-\t  else\n-\t    for (bit = 1; bit && i < max_regno; bit <<= 1, i++)\n-\t      if ((regs_live[offset] & bit)\n-\t\t  && (regno = reg_renumber[i]) >= 0)\n-\t\tfor (j = regno;\n-\t\t     j < regno + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t   PSEUDO_REGNO_MODE (i));\n-\t\t     j++)\n-\t\t  SET_HARD_REG_BIT (current_live_regs, j);\n+      REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);\n+\n+      EXECUTE_IF_SET_IN_REG_SET (regs_live, 0, i,\n+\t\t\t\t {\n+\t\t\t\t   if ((regno = reg_renumber[i]) >= 0)\n+\t\t\t\t     for (j = regno;\n+\t\t\t\t\t  j < regno + HARD_REGNO_NREGS (regno,\n+\t\t\t\t\t\t\t\t\tPSEUDO_REGNO_MODE (i));\n+\t\t\t\t\t  j++)\n+\t\t\t\t       SET_HARD_REG_BIT (current_live_regs, j);\n+\t\t\t\t });\n \t}\n \n       /* Get starting and ending insn, handling the case where each might"}, {"sha": "1fa338f2e25cd4cff5930d37279052c3c4985333", "filename": "gcc/sched.c", "status": "modified", "additions": 72, "deletions": 153, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b1701c2f14c41c71a8dc6816e49a24e9609e4/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=916b1701c2f14c41c71a8dc6816e49a24e9609e4", "patch": "@@ -289,8 +289,7 @@ static int *insn_tick;\n \n struct sometimes\n {\n-  int offset;\n-  int bit;\n+  int regno;\n   int live_length;\n   int calls_crossed;\n };\n@@ -333,8 +332,7 @@ static void create_reg_dead_note\tPROTO((rtx, rtx));\n static void attach_deaths\t\tPROTO((rtx, rtx, int));\n static void attach_deaths_insn\t\tPROTO((rtx));\n static rtx unlink_notes\t\t\tPROTO((rtx, rtx));\n-static int new_sometimes_live\t\tPROTO((struct sometimes *, int, int,\n-\t\t\t\t\t       int));\n+static int new_sometimes_live\t\tPROTO((struct sometimes *, int, int));\n static void finish_sometimes_live\tPROTO((struct sometimes *, int));\n static rtx reemit_notes\t\t\tPROTO((rtx, rtx));\n static void schedule_block\t\tPROTO((int, FILE *));\n@@ -1733,8 +1731,7 @@ sched_analyze_1 (x, insn)\n \t      if (reg_last_sets[regno + i])\n \t\tadd_dependence (insn, reg_last_sets[regno + i],\n \t\t\t\tREG_DEP_OUTPUT);\n-\t      reg_pending_sets[(regno + i) / REGSET_ELT_BITS]\n-\t\t|= (REGSET_ELT_TYPE) 1 << ((regno + i) % REGSET_ELT_BITS);\n+\t      SET_REGNO_REG_SET (reg_pending_sets, regno + i);\n \t      if ((call_used_regs[i] || global_regs[i])\n \t\t  && last_function_call)\n \t\t/* Function calls clobber all call_used regs.  */\n@@ -1750,8 +1747,7 @@ sched_analyze_1 (x, insn)\n \t  reg_last_uses[regno] = 0;\n \t  if (reg_last_sets[regno])\n \t    add_dependence (insn, reg_last_sets[regno], REG_DEP_OUTPUT);\n-\t  reg_pending_sets[regno / REGSET_ELT_BITS]\n-\t    |= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n+\t  SET_REGNO_REG_SET (reg_pending_sets, regno);\n \n \t  /* Pseudos that are REG_EQUIV to something may be replaced\n \t     by that during reloading.  We need only add dependencies for\n@@ -2132,18 +2128,11 @@ sched_analyze_insn (x, insn, loop_notes)\n \t  sched_analyze_2 (XEXP (note, 0), insn);\n     }\n \n-  for (i = 0; i < regset_size; i++)\n-    {\n-      REGSET_ELT_TYPE sets = reg_pending_sets[i];\n-      if (sets)\n-\t{\n-\t  register int bit;\n-\t  for (bit = 0; bit < REGSET_ELT_BITS; bit++)\n-\t    if (sets & ((REGSET_ELT_TYPE) 1 << bit))\n-\t      reg_last_sets[i * REGSET_ELT_BITS + bit] = insn;\n-\t  reg_pending_sets[i] = 0;\n-\t}\n-    }\n+  EXECUTE_IF_SET_AND_RESET_IN_REG_SET (reg_pending_sets, 0, i,\n+\t\t\t\t       {\n+\t\t\t\t\t reg_last_sets[i] = insn;\n+\t\t\t\t       });\n+\n   if (reg_pending_sets_all)\n     {\n       for (i = 0; i < maxreg; i++)\n@@ -2264,8 +2253,7 @@ sched_analyze (head, tail)\n \t\t    reg_last_uses[i] = 0;\n \t\t    if (reg_last_sets[i])\n \t\t      add_dependence (insn, reg_last_sets[i], REG_DEP_ANTI);\n-\t\t    reg_pending_sets[i / REGSET_ELT_BITS]\n-\t\t      |= (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n+\t\t    SET_REGNO_REG_SET (reg_pending_sets, i);\n \t\t  }\n \t    }\n \n@@ -2358,10 +2346,6 @@ sched_note_set (b, x, death)\n   regno = REGNO (reg);\n   if (regno >= FIRST_PSEUDO_REGISTER || ! global_regs[regno])\n     {\n-      register int offset = regno / REGSET_ELT_BITS;\n-      register REGSET_ELT_TYPE bit\n-\t= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n-\n       if (death)\n \t{\n \t  /* If we only set part of the register, then this set does not\n@@ -2375,17 +2359,14 @@ sched_note_set (b, x, death)\n \t      int j = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n \t      while (--j >= 0)\n \t\t{\n-\t\t  offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t  bit = (REGSET_ELT_TYPE) 1 << ((regno + j) % REGSET_ELT_BITS);\n-\t\t  \n-\t\t  bb_live_regs[offset] &= ~bit;\n-\t\t  bb_dead_regs[offset] |= bit;\n+\t\t  CLEAR_REGNO_REG_SET (bb_live_regs, regno + j);\n+\t\t  SET_REGNO_REG_SET (bb_dead_regs, regno + j);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      bb_live_regs[offset] &= ~bit;\n-\t      bb_dead_regs[offset] |= bit;\n+\t      CLEAR_REGNO_REG_SET (bb_live_regs, regno);\n+\t      SET_REGNO_REG_SET (bb_dead_regs, regno);\n \t    }\n \t}\n       else\n@@ -2396,17 +2377,14 @@ sched_note_set (b, x, death)\n \t      int j = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n \t      while (--j >= 0)\n \t\t{\n-\t\t  offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t  bit = (REGSET_ELT_TYPE) 1 << ((regno + j) % REGSET_ELT_BITS);\n-\t\t  \n-\t\t  bb_live_regs[offset] |= bit;\n-\t\t  bb_dead_regs[offset] &= ~bit;\n+\t\t  SET_REGNO_REG_SET (bb_live_regs, regno + j);\n+\t\t  CLEAR_REGNO_REG_SET (bb_dead_regs, regno + j);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      bb_live_regs[offset] |= bit;\n-\t      bb_dead_regs[offset] &= ~bit;\n+\t      SET_REGNO_REG_SET (bb_live_regs, regno);\n+\t      CLEAR_REGNO_REG_SET (bb_dead_regs, regno);\n \t    }\n \t}\n     }\n@@ -2524,14 +2502,12 @@ birthing_insn_p (pat)\n     {\n       rtx dest = SET_DEST (pat);\n       int i = REGNO (dest);\n-      int offset = i / REGSET_ELT_BITS;\n-      REGSET_ELT_TYPE bit = (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n \n       /* It would be more accurate to use refers_to_regno_p or\n \t reg_mentioned_p to determine when the dest is not live before this\n \t insn.  */\n \n-      if (bb_live_regs[offset] & bit)\n+      if (REGNO_REG_SET_P (bb_live_regs, i))\n \treturn (REG_N_SETS (i) == 1);\n \n       return 0;\n@@ -2859,29 +2835,25 @@ attach_deaths (x, insn, set_p)\n \t/* This code is very similar to mark_used_1 (if set_p is false)\n \t   and mark_set_1 (if set_p is true) in flow.c.  */\n \n-\tregister int regno = REGNO (x);\n-\tregister int offset = regno / REGSET_ELT_BITS;\n-\tregister REGSET_ELT_TYPE bit\n-\t  = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n-\tREGSET_ELT_TYPE all_needed = (old_live_regs[offset] & bit);\n-\tREGSET_ELT_TYPE some_needed = (old_live_regs[offset] & bit);\n+\tregister int regno;\n+\tint some_needed;\n+\tint all_needed;\n \n \tif (set_p)\n \t  return;\n \n+\tregno = REGNO (x);\n+\tall_needed = some_needed = REGNO_REG_SET_P (old_live_regs, regno);\n \tif (regno < FIRST_PSEUDO_REGISTER)\n \t  {\n \t    int n;\n \n \t    n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n \t    while (--n > 0)\n \t      {\n-\t\tsome_needed |= (old_live_regs[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t\t& ((REGSET_ELT_TYPE) 1\n-\t\t\t\t   << ((regno + n) % REGSET_ELT_BITS)));\n-\t\tall_needed &= (old_live_regs[(regno + n) / REGSET_ELT_BITS]\n-\t\t\t       & ((REGSET_ELT_TYPE) 1\n-\t\t\t\t  << ((regno + n) % REGSET_ELT_BITS)));\n+\t\tint needed = (REGNO_REG_SET_P (old_live_regs, regno + n));\n+\t\tsome_needed |= needed;\n+\t\tall_needed &= needed;\n \t      }\n \t  }\n \n@@ -2943,9 +2915,7 @@ attach_deaths (x, insn, set_p)\n \t\t\t   register that is set in the insn.  */\n \t\t\tfor (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1;\n \t\t\t     i >= 0; i--)\n-\t\t\t  if ((old_live_regs[(regno + i) / REGSET_ELT_BITS]\n-\t\t\t       & ((REGSET_ELT_TYPE) 1\n-\t\t\t\t  << ((regno +i) % REGSET_ELT_BITS))) == 0\n+\t\t\t  if (REGNO_REG_SET_P (old_live_regs, regno + i)\n \t\t\t      && ! dead_or_set_regno_p (insn, regno + i))\n \t\t\t    create_reg_dead_note (gen_rtx (REG,\n \t\t\t\t\t\t\t   reg_raw_mode[regno + i],\n@@ -2960,18 +2930,14 @@ attach_deaths (x, insn, set_p)\n \t\tint j = HARD_REGNO_NREGS (regno, GET_MODE (x));\n \t\twhile (--j >= 0)\n \t\t  {\n-\t\t    offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t    bit\n-\t\t      = (REGSET_ELT_TYPE) 1 << ((regno + j) % REGSET_ELT_BITS);\n-\n-\t\t    bb_dead_regs[offset] &= ~bit;\n-\t\t    bb_live_regs[offset] |= bit;\n+\t\t    CLEAR_REGNO_REG_SET (bb_dead_regs, regno + j);\n+\t\t    SET_REGNO_REG_SET (bb_live_regs, regno + j);\n \t\t  }\n \t      }\n \t    else\n \t      {\n-\t\tbb_dead_regs[offset] &= ~bit;\n-\t\tbb_live_regs[offset] |= bit;\n+\t\tCLEAR_REGNO_REG_SET (bb_dead_regs, regno);\n+\t\tSET_REGNO_REG_SET (bb_live_regs, regno);\n \t      }\n \t  }\n \treturn;\n@@ -3113,13 +3079,12 @@ unlink_notes (insn, tail)\n /* Constructor for `sometimes' data structure.  */\n \n static int\n-new_sometimes_live (regs_sometimes_live, offset, bit, sometimes_max)\n+new_sometimes_live (regs_sometimes_live, regno, sometimes_max)\n      struct sometimes *regs_sometimes_live;\n-     int offset, bit;\n+     int regno;\n      int sometimes_max;\n {\n   register struct sometimes *p;\n-  register int regno = offset * REGSET_ELT_BITS + bit;\n \n   /* There should never be a register greater than max_regno here.  If there\n      is, it means that a define_split has created a new pseudo reg.  This\n@@ -3129,8 +3094,7 @@ new_sometimes_live (regs_sometimes_live, offset, bit, sometimes_max)\n     abort ();\n \n   p = &regs_sometimes_live[sometimes_max];\n-  p->offset = offset;\n-  p->bit = bit;\n+  p->regno = regno;\n   p->live_length = 0;\n   p->calls_crossed = 0;\n   sometimes_max++;\n@@ -3150,9 +3114,7 @@ finish_sometimes_live (regs_sometimes_live, sometimes_max)\n   for (i = 0; i < sometimes_max; i++)\n     {\n       register struct sometimes *p = &regs_sometimes_live[i];\n-      int regno;\n-\n-      regno = p->offset * REGSET_ELT_BITS + p->bit;\n+      int regno = p->regno;\n \n       sched_reg_live_length[regno] += p->live_length;\n       sched_reg_n_calls_crossed[regno] += p->calls_crossed;\n@@ -3240,8 +3202,8 @@ schedule_block (b, file)\n   bzero ((char *) reg_last_uses, i * sizeof (rtx));\n   reg_last_sets = (rtx *) alloca (i * sizeof (rtx));\n   bzero ((char *) reg_last_sets, i * sizeof (rtx));\n-  reg_pending_sets = (regset) alloca (regset_bytes);\n-  bzero ((char *) reg_pending_sets, regset_bytes);\n+  reg_pending_sets = ALLOCA_REG_SET ();\n+  CLEAR_REG_SET (reg_pending_sets);\n   reg_pending_sets_all = 0;\n   clear_units ();\n \n@@ -3526,12 +3488,8 @@ schedule_block (b, file)\n \t\t      if (call_used_regs[j] && ! global_regs[j]\n \t\t\t  && ! fixed_regs[j])\n \t\t\t{\n-\t\t\t  register int offset = j / REGSET_ELT_BITS;\n-\t\t\t  register REGSET_ELT_TYPE bit\n-\t\t\t    = (REGSET_ELT_TYPE) 1 << (j % REGSET_ELT_BITS);\n-\n-\t\t\t  bb_live_regs[offset] |= bit;\n-\t\t\t  bb_dead_regs[offset] &= ~bit;\n+\t\t\t  SET_REGNO_REG_SET (bb_live_regs, j);\n+\t\t\t  CLEAR_REGNO_REG_SET (bb_dead_regs, j);\n \t\t\t}\n \t\t  }\n \n@@ -3543,28 +3501,21 @@ schedule_block (b, file)\n \t\t\t&& GET_CODE (XEXP (link, 0)) == REG)\n \t\t      {\n \t\t\tregister int regno = REGNO (XEXP (link, 0));\n-\t\t\tregister int offset = regno / REGSET_ELT_BITS;\n-\t\t\tregister REGSET_ELT_TYPE bit\n-\t\t\t  = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n \t\t\t  {\n \t\t\t    int j = HARD_REGNO_NREGS (regno,\n \t\t\t\t\t\t      GET_MODE (XEXP (link, 0)));\n \t\t\t    while (--j >= 0)\n \t\t\t      {\n-\t\t\t\toffset = (regno + j) / REGSET_ELT_BITS;\n-\t\t\t\tbit = ((REGSET_ELT_TYPE) 1\n-\t\t\t\t       << ((regno + j) % REGSET_ELT_BITS));\n-\n-\t\t\t\tbb_live_regs[offset] &= ~bit;\n-\t\t\t\tbb_dead_regs[offset] |= bit;\n+\t\t\t\tCLEAR_REGNO_REG_SET (bb_live_regs, regno + j);\n+\t\t\t\tSET_REGNO_REG_SET (bb_dead_regs, regno + j);\n \t\t\t      }\n \t\t\t  }\n \t\t\telse\n \t\t\t  {\n-\t\t\t    bb_live_regs[offset] &= ~bit;\n-\t\t\t    bb_dead_regs[offset] |= bit;\n+\t\t\t    CLEAR_REGNO_REG_SET (bb_live_regs, regno);\n+\t\t\t    SET_REGNO_REG_SET (bb_dead_regs, regno);\n \t\t\t  }\n \t\t      }\n \t\t  }\n@@ -3647,12 +3598,8 @@ schedule_block (b, file)\n \t\tif (call_used_regs[j] && ! global_regs[j]\n \t\t    && ! fixed_regs[j])\n \t\t  {\n-\t\t    register int offset = j / REGSET_ELT_BITS;\n-\t\t    register REGSET_ELT_TYPE bit\n-\t\t      = (REGSET_ELT_TYPE) 1 << (j % REGSET_ELT_BITS);\n-\n-\t\t    bb_live_regs[offset] |= bit;\n-\t\t    bb_dead_regs[offset] &= ~bit;\n+\t\t    SET_REGNO_REG_SET (bb_live_regs, j);\n+\t\t    CLEAR_REGNO_REG_SET (bb_dead_regs, j);\n \t\t  }\n \t    }\n \n@@ -3666,9 +3613,6 @@ schedule_block (b, file)\n \t\t  && GET_CODE (XEXP (link, 0)) == REG)\n \t\t{\n \t\t  register int regno = REGNO (XEXP (link, 0));\n-\t\t  register int offset = regno / REGSET_ELT_BITS;\n-\t\t  register REGSET_ELT_TYPE bit\n-\t\t    = (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t\t  /* Only unlink REG_DEAD notes; leave REG_UNUSED notes\n \t\t     alone.  */\n@@ -3690,18 +3634,14 @@ schedule_block (b, file)\n \t\t\t\t\t\tGET_MODE (XEXP (link, 0)));\n \t\t      while (--j >= 0)\n \t\t\t{\n-\t\t\t  offset = (regno + j) / REGSET_ELT_BITS;\n-\t\t\t  bit = ((REGSET_ELT_TYPE) 1\n-\t\t\t\t << ((regno + j) % REGSET_ELT_BITS));\n-\n-\t\t\t  bb_live_regs[offset] &= ~bit;\n-\t\t\t  bb_dead_regs[offset] |= bit;\n+\t\t\t  CLEAR_REGNO_REG_SET (bb_live_regs, regno + j);\n+\t\t\t  SET_REGNO_REG_SET (bb_dead_regs, regno + j);\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      bb_live_regs[offset] &= ~bit;\n-\t\t      bb_dead_regs[offset] |= bit;\n+\t\t      CLEAR_REGNO_REG_SET (bb_live_regs, regno);\n+\t\t      SET_REGNO_REG_SET (bb_dead_regs, regno);\n \t\t    }\n \t\t}\n \t      else\n@@ -3713,25 +3653,19 @@ schedule_block (b, file)\n   if (reload_completed == 0)\n     {\n       /* Keep track of register lives.  */\n-      old_live_regs = (regset) alloca (regset_bytes);\n+      old_live_regs = ALLOCA_REG_SET ();\n       regs_sometimes_live\n \t= (struct sometimes *) alloca (max_regno * sizeof (struct sometimes));\n       sometimes_max = 0;\n \n       /* Start with registers live at end.  */\n-      for (j = 0; j < regset_size; j++)\n-\t{\n-\t  REGSET_ELT_TYPE live = bb_live_regs[j];\n-\t  old_live_regs[j] = live;\n-\t  if (live)\n-\t    {\n-\t      register int bit;\n-\t      for (bit = 0; bit < REGSET_ELT_BITS; bit++)\n-\t\tif (live & ((REGSET_ELT_TYPE) 1 << bit))\n-\t\t  sometimes_max = new_sometimes_live (regs_sometimes_live, j,\n-\t\t\t\t\t\t      bit, sometimes_max);\n-\t    }\n-\t}\n+      COPY_REG_SET (old_live_regs, bb_live_regs);\n+      EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, 0, j,\n+\t\t\t\t {\n+\t\t\t\t   sometimes_max\n+\t\t\t\t     = new_sometimes_live (regs_sometimes_live,\n+\t\t\t\t\t\t\t   j, sometimes_max);\n+\t\t\t\t });\n     }\n \n   SCHED_SORT (ready, n_ready, 1);\n@@ -3902,12 +3836,8 @@ schedule_block (b, file)\n \t\t    if (call_used_regs[i] && ! global_regs[i]\n \t\t\t&& ! fixed_regs[i])\n \t\t      {\n-\t\t\tregister int offset = i / REGSET_ELT_BITS;\n-\t\t\tregister REGSET_ELT_TYPE bit\n-\t\t\t  = (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n-\n-\t\t\tbb_live_regs[offset] &= ~bit;\n-\t\t\tbb_dead_regs[offset] |= bit;\n+\t\t\tCLEAR_REGNO_REG_SET (bb_live_regs, i);\n+\t\t\tSET_REGNO_REG_SET (bb_dead_regs, i);\n \t\t      }\n \n \t\t  /* Regs live at the time of a call instruction must not\n@@ -3918,8 +3848,7 @@ schedule_block (b, file)\n \t\t     (below).  */\n \t\t  p = regs_sometimes_live;\n \t\t  for (i = 0; i < sometimes_max; i++, p++)\n-\t\t    if (bb_live_regs[p->offset]\n-\t\t\t& ((REGSET_ELT_TYPE) 1 << p->bit))\n+\t\t    if (REGNO_REG_SET_P (bb_live_regs, p->regno))\n \t\t      p->calls_crossed += 1;\n \t\t}\n \n@@ -3928,41 +3857,31 @@ schedule_block (b, file)\n \t      attach_deaths_insn (insn);\n \n \t      /* Find registers now made live by that instruction.  */\n-\t      for (i = 0; i < regset_size; i++)\n-\t\t{\n-\t\t  REGSET_ELT_TYPE diff = bb_live_regs[i] & ~old_live_regs[i];\n-\t\t  if (diff)\n-\t\t    {\n-\t\t      register int bit;\n-\t\t      old_live_regs[i] |= diff;\n-\t\t      for (bit = 0; bit < REGSET_ELT_BITS; bit++)\n-\t\t\tif (diff & ((REGSET_ELT_TYPE) 1 << bit))\n-\t\t\t  sometimes_max\n-\t\t\t    = new_sometimes_live (regs_sometimes_live, i, bit,\n-\t\t\t\t\t\t  sometimes_max);\n-\t\t    }\n-\t\t}\n+\t      EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, 0, i,\n+\t\t\t\t\t {\n+\t\t\t\t\t   sometimes_max\n+\t\t\t\t\t     = new_sometimes_live (regs_sometimes_live,\n+\t\t\t\t\t\t\t\t   i, sometimes_max);\n+\t\t\t\t\t });\n \n \t      /* Count lengths of all regs we are worrying about now,\n \t\t and handle registers no longer live.  */\n \n \t      for (i = 0; i < sometimes_max; i++)\n \t\t{\n \t\t  register struct sometimes *p = &regs_sometimes_live[i];\n-\t\t  int regno = p->offset*REGSET_ELT_BITS + p->bit;\n+\t\t  int regno = p->regno;\n \n \t\t  p->live_length += 1;\n \n-\t\t  if ((bb_live_regs[p->offset]\n-\t\t       & ((REGSET_ELT_TYPE) 1 << p->bit)) == 0)\n+\t\t  if (REGNO_REG_SET_P (bb_live_regs, p->regno))\n \t\t    {\n \t\t      /* This is the end of one of this register's lifetime\n \t\t\t segments.  Save the lifetime info collected so far,\n \t\t\t and clear its bit in the old_live_regs entry.  */\n \t\t      sched_reg_live_length[regno] += p->live_length;\n \t\t      sched_reg_n_calls_crossed[regno] += p->calls_crossed;\n-\t\t      old_live_regs[p->offset]\n-\t\t\t&= ~((REGSET_ELT_TYPE) 1 << p->bit);\n+\t\t      CLEAR_REGNO_REG_SET (old_live_regs, p->regno);\n \n \t\t      /* Delete the reg_sometimes_live entry for this reg by\n \t\t\t copying the last entry over top of it.  */\n@@ -4875,8 +4794,8 @@ schedule_insns (dump_file)\n     {\n       sched_reg_n_calls_crossed = (int *) alloca (max_regno * sizeof (int));\n       sched_reg_live_length = (int *) alloca (max_regno * sizeof (int));\n-      bb_dead_regs = (regset) alloca (regset_bytes);\n-      bb_live_regs = (regset) alloca (regset_bytes);\n+      bb_dead_regs = ALLOCA_REG_SET ();\n+      bb_live_regs = ALLOCA_REG_SET ();\n       bzero ((char *) sched_reg_n_calls_crossed, max_regno * sizeof (int));\n       bzero ((char *) sched_reg_live_length, max_regno * sizeof (int));\n       init_alias_analysis ();"}]}