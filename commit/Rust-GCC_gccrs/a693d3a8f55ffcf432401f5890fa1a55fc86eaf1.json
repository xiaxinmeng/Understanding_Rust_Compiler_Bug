{"sha": "a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY5M2QzYThmNTVmZmNmNDMyNDAxZjU4OTBmYTFhNTVmYzg2ZWFmMQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-27T09:53:43Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-27T09:53:43Z"}, "message": "In gcc/objc/: 2010-11-27 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (objc_build_struct): Fixed loops that save and\n        restore TYPE_OBJC_INFO to iterate over all variants of the type; a\n        special case for the current type is then no longer required.\n        Duplicate TYPE_LANG_SPECIFIC for each type before restoring\n        TYPE_OBJC_INFO.\n        (objc_get_protocol_qualified_type): Updated comments.\n\nIn gcc/testsuite/:\n2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/protocol-qualifier-1.m: New.\n        * objc.dg/protocol-qualifier-2.m: New.\n        * obj-c++.dg/protocol-qualifier-1.mm: New.\n        * obj-c++.dg/protocol-qualifier-2.mm: New.\n\nFrom-SVN: r167195", "tree": {"sha": "895f2f8651a945915cdbeae810ca04b6e2835748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/895f2f8651a945915cdbeae810ca04b6e2835748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5c7ea1d6235f4affed430e1ecb74ef316643135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c7ea1d6235f4affed430e1ecb74ef316643135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c7ea1d6235f4affed430e1ecb74ef316643135"}], "stats": {"total": 219, "additions": 191, "deletions": 28}, "files": [{"sha": "7c890ce7e2e36e843ad0db5b670b3ab67e1e098c", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "patch": "@@ -1,3 +1,12 @@\n+2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_build_struct): Fixed loops that save and\n+\trestore TYPE_OBJC_INFO to iterate over all variants of the type; a\n+\tspecial case for the current type is then no longer required.\n+\tDuplicate TYPE_LANG_SPECIFIC for each type before restoring\n+\tTYPE_OBJC_INFO.\n+\t(objc_get_protocol_qualified_type): Updated comments.\n+\t\n 2010-11-25  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_struct): Install TYPE_OBJC_INTERFACE"}, {"sha": "232708f6dbbce1404e92df46bded91af86e2952f", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "patch": "@@ -2137,41 +2137,54 @@ objc_build_struct (tree klass, tree fields, tree super_name)\n       fields = base;\n     }\n \n-  /* NB: Calling finish_struct() may cause type TYPE_LANG_SPECIFIC\n-     fields in all variants of this RECORD_TYPE to be clobbered (this\n-     is because the C frontend stores a sorted version of the list of\n-     fields in lang_type if it deems appropriate, and will update and\n-     propagate that list to all variants ignoring the fact that we use\n-     lang_type for something else and that such propagation will wipe\n-     the objc_info away), but it is therein that we store protocol\n-     conformance info (e.g., 'NSObject <MyProtocol>').  Hence, we must\n-     squirrel away the ObjC-specific information before calling\n+  /* NB: Calling finish_struct() may cause type TYPE_OBJC_INFO\n+     information in all variants of this RECORD_TYPE to be destroyed\n+     (this is because the C frontend manipulates TYPE_LANG_SPECIFIC\n+     for something else and then will change all variants to use the\n+     same resulting TYPE_LANG_SPECIFIC, ignoring the fact that we use\n+     it for ObjC protocols and that such propagation will make all\n+     variants use the same objc_info), but it is therein that we store\n+     protocol conformance info (e.g., 'NSObject <MyProtocol>').\n+     Hence, we must save the ObjC-specific information before calling\n      finish_struct(), and then reinstate it afterwards.  */\n \n-  for (t = TYPE_NEXT_VARIANT (s); t; t = TYPE_NEXT_VARIANT (t))\n+  for (t = TYPE_MAIN_VARIANT (s); t; t = TYPE_NEXT_VARIANT (t))\n     {\n-      if (!TYPE_HAS_OBJC_INFO (t))\n-\t{\n-\t  INIT_TYPE_OBJC_INFO (t);\n-\t  TYPE_OBJC_INTERFACE (t) = klass;\n-\t}\n+      INIT_TYPE_OBJC_INFO (t);\n       VEC_safe_push (tree, heap, objc_info, TYPE_OBJC_INFO (t));\n     }\n \n   s = objc_finish_struct (s, fields);\n \n-  /* Point the struct at its related Objective-C class.  We do this\n-     after calling finish_struct() because otherwise finish_struct()\n-     would wipe TYPE_OBJC_INTERFACE() out.  */\n-  if (!TYPE_HAS_OBJC_INFO (s))\n-    INIT_TYPE_OBJC_INFO (s);\n-\n-  TYPE_OBJC_INTERFACE (s) = klass;\n-\n-  for (i = 0, t = TYPE_NEXT_VARIANT (s); t; t = TYPE_NEXT_VARIANT (t), i++)\n+  for (i = 0, t = TYPE_MAIN_VARIANT (s); t; t = TYPE_NEXT_VARIANT (t), i++)\n     {\n+      /* We now want to restore the different TYPE_OBJC_INFO, but we\n+\t have the additional problem that the C frontend doesn't just\n+\t copy TYPE_LANG_SPECIFIC from one variant to the other; it\n+\t actually makes all of them the *same* TYPE_LANG_SPECIFIC.  As\n+\t we need a different TYPE_OBJC_INFO for each (and\n+\t TYPE_OBJC_INFO is a field in TYPE_LANG_SPECIFIC), we need to\n+\t make a copy of each TYPE_LANG_SPECIFIC before we modify\n+\t TYPE_OBJC_INFO.  */\n+      if (TYPE_LANG_SPECIFIC (t))\n+\t{\n+\t  /* Create a copy of TYPE_LANG_SPECIFIC.  */\n+\t  struct lang_type *old_lang_type = TYPE_LANG_SPECIFIC (t);\n+\t  ALLOC_OBJC_TYPE_LANG_SPECIFIC (t);\n+\t  memcpy (TYPE_LANG_SPECIFIC (t), old_lang_type,\n+\t\t  SIZEOF_OBJC_TYPE_LANG_SPECIFIC);\n+\t}\n+      else\n+\t{\n+\t  /* Just create a new one.  */\n+\t  ALLOC_OBJC_TYPE_LANG_SPECIFIC (t);\n+\t}\n+      /* Replace TYPE_OBJC_INFO with the saved one.  This restores any\n+\t protocol information that may have been associated with the\n+\t type.  */\n       TYPE_OBJC_INFO (t) = VEC_index (tree, objc_info, i);\n-      /* Replace the IDENTIFIER_NODE with an actual @interface.  */\n+      /* Replace the IDENTIFIER_NODE with an actual @interface now\n+\t that we have it.  */\n       TYPE_OBJC_INTERFACE (t) = klass;\n     }\n   VEC_free (tree, heap, objc_info);\n@@ -2766,9 +2779,12 @@ objc_non_volatilized_type (tree type)\n   return type;\n }\n \n-/* Construct a PROTOCOLS-qualified variant of INTERFACE, where INTERFACE may\n-   either name an Objective-C class, or refer to the special 'id' or 'Class'\n-   types.  If INTERFACE is not a valid ObjC type, just return it unchanged.  */\n+/* Construct a PROTOCOLS-qualified variant of INTERFACE, where\n+   INTERFACE may either name an Objective-C class, or refer to the\n+   special 'id' or 'Class' types.  If INTERFACE is not a valid ObjC\n+   type, just return it unchanged.  This function is often called when\n+   PROTOCOLS is NULL_TREE, in which case we simply look up the\n+   appropriate INTERFACE.  */\n \n tree\n objc_get_protocol_qualified_type (tree interface, tree protocols)\n@@ -4422,6 +4438,9 @@ objc_declare_class (tree ident_list)\n \n \t  record = xref_tag (RECORD_TYPE, ident);\n \t  INIT_TYPE_OBJC_INFO (record);\n+\t  /* In the case of a @class declaration, we store the ident\n+\t     in the TYPE_OBJC_INTERFACE.  If later an @interface is\n+\t     found, we'll replace the ident with the interface.  */\n \t  TYPE_OBJC_INTERFACE (record) = ident;\n \t  hash_class_name_enter (cls_name_hash_list, ident, NULL_TREE);\n \t}"}, {"sha": "d0b568a735e08f1ae30aa7e5d6a2e7f0b8d2d4e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "patch": "@@ -1,3 +1,10 @@\n+2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/protocol-qualifier-1.m: New.\t\n+\t* objc.dg/protocol-qualifier-2.m: New.\n+\t* obj-c++.dg/protocol-qualifier-1.mm: New.\t\n+\t* obj-c++.dg/protocol-qualifier-2.mm: New.\n+\n 2010-11-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* lib/gnat.exp: Load gcc.exp."}, {"sha": "c84bfbfa2083fb633c7972a0e31ee7ffcc7e65e6", "filename": "gcc/testsuite/obj-c++.dg/protocol-qualifier-1.mm", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-qualifier-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-qualifier-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-qualifier-1.mm?ref=a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "patch": "@@ -0,0 +1,33 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that protocol qualifiers work in the same way with @class and @interface.  */\n+\n+#include <objc/objc.h>\n+\n+@protocol MyProtocol\n+- (void) method;\n+@end\n+\n+\n+/* This first snippet gives no warnings, which is correct as 'object'\n+   implements <MyProtocol> and hence responds to 'method'.  Note how\n+   the details of the class 'MyClass' are never used.  */\n+@interface MyClass\n+@end\n+\n+void test (MyClass <MyProtocol> *object)\n+{\n+  [object method];\n+}\n+\n+\n+/* This second snippet should behave identically.  'object' still implements\n+   the same protocol and responds to 'method'.  The details of MyClass or\n+   MyClass2 are irrelevant.  */\n+@class MyClass2;\n+\n+void test2 (MyClass2 <MyProtocol> *object)\n+{\n+  [object method];\n+}"}, {"sha": "fd25d8ff606939c743fdfb65520d400e0ffe3b95", "filename": "gcc/testsuite/obj-c++.dg/protocol-qualifier-2.mm", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-qualifier-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-qualifier-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-qualifier-2.mm?ref=a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "patch": "@@ -0,0 +1,31 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that protocol qualifiers are maintained correctly when a\n+   @class is replaced by its @interface.  */\n+\n+#include <objc/objc.h>\n+\n+@protocol MyProtocol\n+- (void) method;\n+@end\n+\n+@class MyClass;\n+\n+static MyClass <MyProtocol> *object1;\n+static MyClass *object2;\n+\n+/* Declarating the @interface now will need to update all the existing\n+   ObjC types referring to MyClass with the new information.  We need\n+   to test that protocol information is not lost in the process.  */\n+@interface MyClass\n+@end\n+\n+void test1 (void)\n+{\n+  [object1 method]; /* Ok */\n+  [object2 method]; /* { dg-warning \".MyClass. may not respond to ..method.\" } */\n+                    /* { dg-warning \"without a matching method\" \"\" { target *-*-* } 27 } */\n+                    /* { dg-warning \"will be assumed to return\" \"\" { target *-*-* } 27 } */\n+                    /* { dg-warning \"as arguments\" \"\" { target *-*-* } 27 } */\n+}"}, {"sha": "c84bfbfa2083fb633c7972a0e31ee7ffcc7e65e6", "filename": "gcc/testsuite/objc.dg/protocol-qualifier-1.m", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-qualifier-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-qualifier-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-qualifier-1.m?ref=a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "patch": "@@ -0,0 +1,33 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that protocol qualifiers work in the same way with @class and @interface.  */\n+\n+#include <objc/objc.h>\n+\n+@protocol MyProtocol\n+- (void) method;\n+@end\n+\n+\n+/* This first snippet gives no warnings, which is correct as 'object'\n+   implements <MyProtocol> and hence responds to 'method'.  Note how\n+   the details of the class 'MyClass' are never used.  */\n+@interface MyClass\n+@end\n+\n+void test (MyClass <MyProtocol> *object)\n+{\n+  [object method];\n+}\n+\n+\n+/* This second snippet should behave identically.  'object' still implements\n+   the same protocol and responds to 'method'.  The details of MyClass or\n+   MyClass2 are irrelevant.  */\n+@class MyClass2;\n+\n+void test2 (MyClass2 <MyProtocol> *object)\n+{\n+  [object method];\n+}"}, {"sha": "fd25d8ff606939c743fdfb65520d400e0ffe3b95", "filename": "gcc/testsuite/objc.dg/protocol-qualifier-2.m", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-qualifier-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a693d3a8f55ffcf432401f5890fa1a55fc86eaf1/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-qualifier-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-qualifier-2.m?ref=a693d3a8f55ffcf432401f5890fa1a55fc86eaf1", "patch": "@@ -0,0 +1,31 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that protocol qualifiers are maintained correctly when a\n+   @class is replaced by its @interface.  */\n+\n+#include <objc/objc.h>\n+\n+@protocol MyProtocol\n+- (void) method;\n+@end\n+\n+@class MyClass;\n+\n+static MyClass <MyProtocol> *object1;\n+static MyClass *object2;\n+\n+/* Declarating the @interface now will need to update all the existing\n+   ObjC types referring to MyClass with the new information.  We need\n+   to test that protocol information is not lost in the process.  */\n+@interface MyClass\n+@end\n+\n+void test1 (void)\n+{\n+  [object1 method]; /* Ok */\n+  [object2 method]; /* { dg-warning \".MyClass. may not respond to ..method.\" } */\n+                    /* { dg-warning \"without a matching method\" \"\" { target *-*-* } 27 } */\n+                    /* { dg-warning \"will be assumed to return\" \"\" { target *-*-* } 27 } */\n+                    /* { dg-warning \"as arguments\" \"\" { target *-*-* } 27 } */\n+}"}]}