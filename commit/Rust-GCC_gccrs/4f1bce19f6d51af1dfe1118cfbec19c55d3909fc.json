{"sha": "4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "node_id": "C_kwDOANBUbNoAKDRmMWJjZTE5ZjZkNTFhZjFkZmUxMTE4Y2ZiZWMxOWM1NWQzOTA5ZmM", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-03-14T13:04:56Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-01T08:55:45Z"}, "message": "Implement abstract vrange class.\n\nThis is a series of patches making ranger type agnostic in preparation\nfor contributing support for other types of ranges (pointers and\nfloats initially).\n\nThe first step in this process is to implement vrange, an abstract\nclass that will be exclusively used by ranger, and from which all\nranges will inherit.  Vrange provides the minimum operations for\nranger to work.  The current virtual methods are what we've used to\nimplement frange (floats) and prange (pointers), but we may restrict\nthe virtual methods further as other ranges come about\n(i.e. set_nonnegative() has no meaning for a future string range).\n\nThis patchset also provides a mechanism for declaring local type\nagnostic ranges that can transparently hold an irange, frange,\nprange's, etc, and a dispatch mechanism for range-ops to work with\nvarious range types.  More details in the relevant patches.\n\nFUTURE PLAN\n===========\n\nThe plan after this is to contribute a bare bones implementation for\nfloats (frange) that will provide relationals, followed by a\nseparation of integers and pointers (irange and prange).  Once this is\nin place, we can further enhance both floats and pointers.  For\nexample, pointer tracking, pointer plus optimizations, and keeping\ntrack of NaN's, etc.\n\nOnce frange and prange come live, all ranger clients will immediately\nbenefit from these enhancements.  For instance, in our local branch,\nthe threader is already float aware with regards to relationals.\n\nWe expect to wait a few weeks before starting to contribute further\nenhancements to give the tree a time to stabilize, and Andrew time to\nrebase his upcoming patches  :-P.\n\nNOTES\n=====\n\nIn discussions with Andrew, it has become clear that with vrange\ncoming about, supports_type_p() is somewhat ambiguous.  Prior to\nvrange it has been used to (a) determine if a type is supported by\nranger, (b) as a short-cut for checking if a type is pointer or integer,\nas well as (c) to see if a given range can hold a type.  These things\nhave had the same meaning in irange, but are slightly different with\nvrange.  I will address this in a follow-up patch.\n\nSpeaking of supported types, we now provide an unsupported_range\nfor passing around ranges for unsupported types. We've been silently\ndoing this for a while, in both vr-values by creating VARYING for\nunsupported types with error_mark_node end points, and in ranger when\nwe pass an unsupported range before we realize in range_of_expr that\nit's unsupported.  This class just formalizes what we've already been\ndoing in an irange, but making it explicit that you can't do anything\nwith these ranges except pass them.  Any other operation traps.\n\nThere is no GTY support for vrange yet, as we don't store it long\nterm.  When we contribute support for global ranges (think\nSSA_NAME_RANGE_INFO but for generic ranges), we will include it.  There\nwas just no need to pollute this patchset with it.\n\nTESTING\n=======\n\nThe patchset has been tested on x86-64 Linux as well as ppc64 Linux.\nI have also verified that we fold the same number of conditionals in\nevrp as well as thread the same number of paths.  There should be no\nuser visible changes.\n\nWe have also benchmarked the work, with the final numbers being an\n*improvement* of 1.92% for evrp, and 0.82% for VRP.  Overall\ncompilation has a miniscule improvement.  This is despite the extra\nindirection level.\n\nThe improvements are mostly because of small cleanups required for the\ngeneralization of ranges.  As a sanity check, I stuck kcachegrind on a\nfew sample .ii files to see where the time was being gained.  Most of\nthe gain came from gimple_range_global() being 19% faster.  This\nfunction is called a lot, and it was constructing a legacy\nvalue_range, then returning it by value, which the caller then had to\nconvert to an irange.  This is in line with other pending work:\nanytime we get rid of legacy, we gain time.\n\nI will wait a few days before committing to welcome any comments.\n\ngcc/ChangeLog:\n\n\t* value-range-equiv.cc (value_range_equiv::set): New.\n\t* value-range-equiv.h (class value_range_equiv): Make set method\n\tvirtual.\n\tRemove default bitmap argument from set method.\n\t* value-range.cc (vrange::contains_p): New.\n\t(vrange::singleton_p): New.\n\t(vrange::operator=): New.\n\t(vrange::operator==): New.\n\t(irange::fits_p): Move to .cc file.\n\t(irange::set_nonnegative): New.\n\t(unsupported_range::unsupported_range): New.\n\t(unsupported_range::set): New.\n\t(unsupported_range::type): New.\n\t(unsupported_range::set_undefined): New.\n\t(unsupported_range::set_varying): New.\n\t(unsupported_range::dump): New.\n\t(unsupported_range::union_): New.\n\t(unsupported_range::intersect): New.\n\t(unsupported_range::zero_p): New.\n\t(unsupported_range::nonzero_p): New.\n\t(unsupported_range::set_nonzero): New.\n\t(unsupported_range::set_zero): New.\n\t(unsupported_range::set_nonnegative): New.\n\t(unsupported_range::fits_p): New.\n\t(irange::set): Call irange::set_undefined.\n\t(irange::verify_range): Check discriminator field.\n\t(irange::dump): Dump [irange] marker.\n\t(irange::debug): Move to...\n\t(vrange::debug): ...here.\n\t(dump_value_range): Accept vrange.\n\t(debug): Same.\n\t* value-range.h (enum value_range_discriminator): New.\n\t(class vrange): New.\n\t(class unsupported_range): New.\n\t(struct vrange_traits): New.\n\t(is_a): New.\n\t(as_a): New.\n\t(class irange): Inherit from vrange.\n\t(dump_value_range): Adjust for vrange.\n\t(irange::kind): Rename to...\n\t(vrange::kind): ...this.\n\t(irange::varying_p): Rename to...\n\t(vrange::varying_p): ...this.\n\t(irange::undefined_p): Rename to...\n\t(vrange::undefined_p): ...this.\n\t(irange::irange): Set discriminator.\n\t(irange::union_): Convert to irange before passing to irange\n\tmethod.\n\t(irange::intersect): Same.\n\t(vrange::supports_type_p): New.\n\t* vr-values.cc (vr_values::extract_range_from_binary_expr): Pass\n\tNULL bitmap argument to value_range_equiv::set.\n\t(vr_values::extract_range_basic): Same.", "tree": {"sha": "392b354388bdfa6786a7a6311b64c78867947078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/392b354388bdfa6786a7a6311b64c78867947078"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e9a6d29ee9a531db04b65652274f073ad1f1f1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e9a6d29ee9a531db04b65652274f073ad1f1f1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e9a6d29ee9a531db04b65652274f073ad1f1f1e"}], "stats": {"total": 378, "additions": 338, "deletions": 40}, "files": [{"sha": "b0ae1288a096292fc063ebe9198b7750a4578c73", "filename": "gcc/value-range-equiv.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range-equiv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range-equiv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.cc?ref=4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "patch": "@@ -50,6 +50,12 @@ value_range_equiv::set (tree min, tree max, bitmap equiv,\n     check ();\n }\n \n+void\n+value_range_equiv::set (tree min, tree max, value_range_kind kind)\n+{\n+  set (min, max, m_equiv, kind);\n+}\n+\n void\n value_range_equiv::set (tree val)\n {"}, {"sha": "743ceb2b2277de507f5630395412d7057f3edcab", "filename": "gcc/value-range-equiv.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range-equiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range-equiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.h?ref=4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "patch": "@@ -41,9 +41,10 @@ class GTY((user)) value_range_equiv : public value_range\n   void move (value_range_equiv *);\n \n   /* Leaves equiv bitmap alone.  */\n+  virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n   void update (tree, tree, value_range_kind = VR_RANGE);\n   /* Deep-copies equiv bitmap argument.  */\n-  void set (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n+  void set (tree, tree, bitmap, value_range_kind = VR_RANGE);\n   void set (tree);\n \n   bool operator== (const value_range_equiv &) const /* = delete */;"}, {"sha": "97ff0614f4845e0a2857d5c11d4ac077a3294946", "filename": "gcc/value-range.cc", "status": "modified", "additions": 163, "deletions": 5, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "patch": "@@ -30,6 +30,162 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"gimple-range.h\"\n \n+// Default implementation when none has been defined.\n+\n+bool\n+vrange::contains_p (tree) const\n+{\n+  return false;\n+}\n+\n+// Default implementation when none has been defined.\n+\n+bool\n+vrange::singleton_p (tree *) const\n+{\n+  return false;\n+}\n+\n+// Assignment operator for generic ranges.  Copying incompatible types\n+// is not allowed.\n+\n+vrange &\n+vrange::operator= (const vrange &src)\n+{\n+  if (is_a <irange> (src))\n+    {\n+      as_a <irange> (*this) = as_a <irange> (src);\n+      return *this;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+// Equality operator for generic ranges.\n+\n+bool\n+vrange::operator== (const vrange &src) const\n+{\n+  if (is_a <irange> (src))\n+    return as_a <irange> (*this) == as_a <irange> (src);\n+  gcc_unreachable ();\n+}\n+\n+// Return TRUE if R fits in THIS.\n+\n+bool\n+irange::fits_p (const vrange &r) const\n+{\n+  return m_max_ranges >= as_a <irange> (r).num_pairs ();\n+}\n+\n+void\n+irange::set_nonnegative (tree type)\n+{\n+  set (build_int_cst (type, 0), TYPE_MAX_VALUE (type));\n+}\n+\n+unsupported_range::unsupported_range ()\n+{\n+  m_discriminator = VR_UNKNOWN;\n+  set_undefined ();\n+}\n+\n+void\n+unsupported_range::set (tree, tree, value_range_kind)\n+{\n+  gcc_unreachable ();\n+}\n+\n+tree\n+unsupported_range::type () const\n+{\n+  gcc_unreachable ();\n+  return nullptr;\n+}\n+\n+void\n+unsupported_range::set_undefined ()\n+{\n+  m_kind = VR_UNDEFINED;\n+}\n+\n+void\n+unsupported_range::set_varying (tree)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+unsupported_range::dump (FILE *file) const\n+{\n+  fprintf (file, \"[unsupported_range] \");\n+  if (undefined_p ())\n+    {\n+      fprintf (file, \"UNDEFINED\");\n+      return;\n+    }\n+  if (varying_p ())\n+    {\n+      fprintf (file, \"VARYING\");\n+      return;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+bool\n+unsupported_range::union_ (const vrange &)\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+bool\n+unsupported_range::intersect (const vrange &)\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+bool\n+unsupported_range::zero_p () const\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+bool\n+unsupported_range::nonzero_p () const\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+void\n+unsupported_range::set_nonzero (tree)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+unsupported_range::set_zero (tree)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+unsupported_range::set_nonnegative (tree)\n+{\n+  gcc_unreachable ();\n+}\n+\n+bool\n+unsupported_range::fits_p (const vrange &) const\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n // Here we copy between any two irange's.  The ranges can be legacy or\n // multi-ranges, and copying between any combination works correctly.\n \n@@ -291,7 +447,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n     }\n   if (kind == VR_UNDEFINED)\n     {\n-      set_undefined ();\n+      irange::set_undefined ();\n       return;\n     }\n \n@@ -370,6 +526,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n void\n irange::verify_range ()\n {\n+  gcc_checking_assert (m_discriminator == VR_IRANGE);\n   if (m_kind == VR_UNDEFINED)\n     {\n       gcc_checking_assert (m_num_ranges == 0);\n@@ -2087,6 +2244,7 @@ dump_bound_with_infinite_markers (FILE *file, tree bound)\n void\n irange::dump (FILE *file) const\n {\n+  fprintf (file, \"[irange] \");\n   if (undefined_p ())\n     {\n       fprintf (file, \"UNDEFINED\");\n@@ -2121,27 +2279,27 @@ irange::dump (FILE *file) const\n }\n \n void\n-irange::debug () const\n+vrange::debug () const\n {\n   dump (stderr);\n   fprintf (stderr, \"\\n\");\n }\n \n void\n-dump_value_range (FILE *file, const irange *vr)\n+dump_value_range (FILE *file, const vrange *vr)\n {\n   vr->dump (file);\n }\n \n DEBUG_FUNCTION void\n-debug (const irange *vr)\n+debug (const vrange *vr)\n {\n   dump_value_range (stderr, vr);\n   fprintf (stderr, \"\\n\");\n }\n \n DEBUG_FUNCTION void\n-debug (const irange &vr)\n+debug (const vrange &vr)\n {\n   debug (&vr);\n }"}, {"sha": "0061f667092fbabb2c83639e009ac529aa1bf3cc", "filename": "gcc/value-range.h", "status": "modified", "additions": 164, "deletions": 31, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_VALUE_RANGE_H\n #define GCC_VALUE_RANGE_H\n \n+class irange;\n+\n // Types of value ranges.\n enum value_range_kind\n {\n@@ -37,24 +39,71 @@ enum value_range_kind\n   VR_LAST\n };\n \n-// Range of values that can be associated with an SSA_NAME.\n-//\n-// This is the base class without any storage.\n+// Discriminator between different vrange types.\n+\n+enum value_range_discriminator\n+{\n+  // Range holds an integer or pointer.\n+  VR_IRANGE,\n+  // Range holds an unsupported type.\n+  VR_UNKNOWN\n+};\n+\n+// Abstract class for ranges of any of the supported types.\n+\n+class vrange\n+{\n+  template <typename T> friend bool is_a (vrange &);\n+public:\n+  virtual void set (tree, tree, value_range_kind = VR_RANGE) = 0;\n+  virtual tree type () const = 0;\n+  virtual void set_varying (tree type) = 0;\n+  virtual void set_undefined () = 0;\n+  virtual void dump (FILE * = stderr) const = 0;\n+  virtual bool union_ (const vrange &) = 0;\n+  virtual bool intersect (const vrange &) = 0;\n+  virtual bool singleton_p (tree *result = NULL) const;\n+  virtual bool contains_p (tree cst) const;\n+  virtual bool zero_p () const = 0;\n+  virtual bool nonzero_p () const = 0;\n+  virtual void set_nonzero (tree type) = 0;\n+  virtual void set_zero (tree type) = 0;\n+  virtual void set_nonnegative (tree type) = 0;\n+  virtual bool fits_p (const vrange &r) const = 0;\n+\n+  static bool supports_type_p (tree);\n+\n+  bool varying_p () const;\n+  bool undefined_p () const;\n+  vrange& operator= (const vrange &);\n+  bool operator== (const vrange &) const;\n+  bool operator!= (const vrange &r) const { return !(*this == r); }\n+\n+  enum value_range_kind kind () const;\t\t// DEPRECATED\n+  void debug () const;\n+\n+protected:\n+  ENUM_BITFIELD(value_range_kind) m_kind : 8;\n+  ENUM_BITFIELD(value_range_discriminator) m_discriminator : 4;\n+};\n+\n+// An integer range without any storage.\n \n-class GTY((user)) irange\n+class GTY((user)) irange : public vrange\n {\n   friend class irange_allocator;\n public:\n   // In-place setters.\n-  void set (tree, tree, value_range_kind = VR_RANGE);\n-  void set_nonzero (tree);\n-  void set_zero (tree);\n-  void set_varying (tree type);\n-  void set_undefined ();\n+  virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n+  virtual void set_nonzero (tree type) override;\n+  virtual void set_zero (tree type) override;\n+  virtual void set_nonnegative (tree type) override;\n+  virtual void set_varying (tree type) override;\n+  virtual void set_undefined () override;\n \n   // Range types.\n   static bool supports_type_p (tree);\n-  tree type () const;\n+  virtual tree type () const override;\n \n   // Iteration over sub-ranges.\n   unsigned num_pairs () const;\n@@ -63,16 +112,14 @@ class GTY((user)) irange\n   wide_int upper_bound () const;\n \n   // Predicates.\n-  bool zero_p () const;\n-  bool nonzero_p () const;\n-  bool undefined_p () const;\n-  bool varying_p () const;\n-  bool singleton_p (tree *result = NULL) const;\n-  bool contains_p (tree) const;\n+  virtual bool zero_p () const override;\n+  virtual bool nonzero_p () const override;\n+  virtual bool singleton_p (tree *result = NULL) const override;\n+  virtual bool contains_p (tree cst) const override;\n \n   // In-place operators.\n-  bool union_ (const irange &);\n-  bool intersect (const irange &);\n+  virtual bool union_ (const vrange &) override;\n+  virtual bool intersect (const vrange &) override;\n   void invert ();\n \n   // Operator overloads.\n@@ -81,12 +128,10 @@ class GTY((user)) irange\n   bool operator!= (const irange &r) const { return !(*this == r); }\n \n   // Misc methods.\n-  bool fits_p (const irange &r) { return m_max_ranges >= r.num_pairs (); }\n-  void dump (FILE * = stderr) const;\n-  void debug () const;\n+  virtual bool fits_p (const vrange &r) const override;\n+  virtual void dump (FILE * = stderr) const override;\n \n   // Deprecated legacy public methods.\n-  enum value_range_kind kind () const;\t\t// DEPRECATED\n   tree min () const;\t\t\t\t// DEPRECATED\n   tree max () const;\t\t\t\t// DEPRECATED\n   bool symbolic_p () const;\t\t\t// DEPRECATED\n@@ -139,7 +184,6 @@ class GTY((user)) irange\n   bool intersect (const wide_int& lb, const wide_int& ub);\n   unsigned char m_num_ranges;\n   unsigned char m_max_ranges;\n-  ENUM_BITFIELD(value_range_kind) m_kind : 8;\n   tree *m_base;\n };\n \n@@ -173,6 +217,88 @@ class GTY((user)) int_range : public irange\n   tree m_ranges[N*2];\n };\n \n+// Unsupported temporaries may be created by ranger before it's known\n+// they're unsupported, or by vr_values::get_value_range.  All\n+// operations except construction cause a trap.\n+\n+class unsupported_range : public vrange\n+{\n+public:\n+  unsupported_range ();\n+  virtual void set (tree, tree, value_range_kind) override;\n+  virtual tree type () const override;\n+  virtual void set_varying (tree type) override;\n+  virtual void set_undefined () override;\n+  virtual void dump (FILE *) const override;\n+  virtual bool union_ (const vrange &) override;\n+  virtual bool intersect (const vrange &) override;\n+  virtual bool zero_p () const override;\n+  virtual bool nonzero_p () const override;\n+  virtual void set_nonzero (tree) override;\n+  virtual void set_zero (tree) override;\n+  virtual void set_nonnegative (tree) override;\n+  virtual bool fits_p (const vrange &) const override;\n+};\n+\n+// Traits to implement vrange is_a<> and as_a<>.\n+\n+template<typename T>\n+struct vrange_traits\n+{\n+  // Default to something unusable.\n+  typedef void range_type;\n+};\n+\n+template<>\n+struct vrange_traits<irange>\n+{\n+  typedef irange range_type;\n+};\n+\n+template <typename T>\n+inline bool\n+is_a (vrange &v)\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+template <typename T>\n+inline bool\n+is_a (const vrange &v)\n+{\n+  // Reuse is_a <vrange> to implement the const version.\n+  const T &derived = static_cast<const T &> (v);\n+  return is_a <T> (const_cast<T &> (derived));\n+}\n+\n+template <typename T>\n+inline T &\n+as_a (vrange &v)\n+{\n+  typedef typename vrange_traits<T>::range_type range_type;\n+  gcc_checking_assert (is_a <range_type> (v));\n+  return static_cast <range_type &> (v);\n+}\n+\n+template <typename T>\n+inline const T &\n+as_a (const vrange &v)\n+{\n+  typedef typename vrange_traits<T>::range_type range_type;\n+  gcc_checking_assert (is_a <range_type> (v));\n+  return static_cast <const range_type &> (v);\n+}\n+\n+// Specializations for the different range types.\n+\n+template <>\n+inline bool\n+is_a <irange> (vrange &v)\n+{\n+  return v.m_discriminator == VR_IRANGE;\n+}\n+\n // This is a special int_range<1> with only one pair, plus\n // VR_ANTI_RANGE magic to describe slightly more than can be described\n // in one pair.  It is described in the code as a \"legacy range\" (as\n@@ -197,13 +323,13 @@ irange::legacy_mode_p () const\n extern bool range_has_numeric_bounds_p (const irange *);\n extern bool ranges_from_anti_range (const value_range *,\n \t\t\t\t    value_range *, value_range *);\n-extern void dump_value_range (FILE *, const irange *);\n+extern void dump_value_range (FILE *, const vrange *);\n extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n extern bool vrp_operand_equal_p (const_tree, const_tree);\n \n inline value_range_kind\n-irange::kind () const\n+vrange::kind () const\n {\n   return m_kind;\n }\n@@ -293,13 +419,13 @@ irange::varying_compatible_p () const\n }\n \n inline bool\n-irange::varying_p () const\n+vrange::varying_p () const\n {\n   return m_kind == VR_VARYING;\n }\n \n inline bool\n-irange::undefined_p () const\n+vrange::undefined_p () const\n {\n   return m_kind == VR_UNDEFINED;\n }\n@@ -398,6 +524,7 @@ gt_pch_nx (int_range<N> *x, gt_pointer_operator op, void *cookie)\n inline\n irange::irange (tree *base, unsigned nranges)\n {\n+  m_discriminator = VR_IRANGE;\n   m_base = base;\n   m_max_ranges = nranges;\n   set_undefined ();\n@@ -547,21 +674,21 @@ irange::upper_bound () const\n }\n \n inline bool\n-irange::union_ (const irange &r)\n+irange::union_ (const vrange &r)\n {\n   dump_flags_t m_flags = dump_flags;\n   dump_flags &= ~TDF_DETAILS;\n-  bool ret = irange::legacy_verbose_union_ (&r);\n+  bool ret = irange::legacy_verbose_union_ (&as_a <irange> (r));\n   dump_flags = m_flags;\n   return ret;\n }\n \n inline bool\n-irange::intersect (const irange &r)\n+irange::intersect (const vrange &r)\n {\n   dump_flags_t m_flags = dump_flags;\n   dump_flags &= ~TDF_DETAILS;\n-  bool ret = irange::legacy_verbose_intersect (&r);\n+  bool ret = irange::legacy_verbose_intersect (&as_a <irange> (r));\n   dump_flags = m_flags;\n   return ret;\n }\n@@ -608,6 +735,12 @@ irange::normalize_kind ()\n     }\n }\n \n+inline bool\n+vrange::supports_type_p (tree type)\n+{\n+  return irange::supports_type_p (type);\n+}\n+\n // Return the maximum value for TYPE.\n \n inline tree"}, {"sha": "6f8583c8d01586b2a5a8b6c4b99c80f8bfb2cc77", "filename": "gcc/vr-values.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvr-values.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc/gcc%2Fvr-values.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.cc?ref=4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "patch": "@@ -883,7 +883,7 @@ vr_values::extract_range_from_binary_expr (value_range_equiv *vr,\n \t      wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n \t      tree range_min = build_zero_cst (expr_type);\n \t      tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n-\t      vr->set (range_min, range_max);\n+\t      vr->set (range_min, range_max, NULL);\n \t      return;\n \t    }\n      }\n@@ -1275,7 +1275,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t\t      /* This is the boolean return value whether compare and\n \t\t\t exchange changed anything or not.  */\n \t\t      vr->set (build_int_cst (type, 0),\n-\t\t\t       build_int_cst (type, 1));\n+\t\t\t       build_int_cst (type, 1), NULL);\n \t\t      return;\n \t\t    }\n \t\t  break;\n@@ -1297,7 +1297,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t\t\tvr->set_varying (type);\n \t\t      else\n \t\t\tvr->set (build_int_cst (type, 0),\n-\t\t\t\t build_int_cst (type, 1));\n+\t\t\t\t build_int_cst (type, 1), NULL);\n \t\t    }\n \t\t  else if (types_compatible_p (type, TREE_TYPE (op0))\n \t\t\t   && types_compatible_p (type, TREE_TYPE (op1)))"}]}