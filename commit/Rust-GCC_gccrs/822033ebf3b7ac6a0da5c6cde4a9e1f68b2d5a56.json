{"sha": "822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIyMDMzZWJmM2I3YWM2YTBkYTVjNmNkZTRhOWUxZjY4YjJkNWE1Ng==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-06-06T10:24:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:24:40Z"}, "message": "exp_ch2.adb: Remove \"with\" and \"use\" clauses for Namet and Snames.\n\n2007-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch2.adb: Remove \"with\" and \"use\" clauses for Namet and Snames.\n\tAdd \"with\" and \"use\" clauses for Sem_Attr.\n\t(Expand_Current_Value): Do not replace occurences of attribute\n\treferences where the prefix must be a simple name.\n\n\t* sem_attr.ads, sem_attr.adb: Remove \"with\" and \"use\" clauses for\n\tNamet. Add new arrays Attribute_Name_Modifies_Prefix and\n\tAttribute_Requires_Simple_Name_Prefix.\n\t(Name_Modifies_Prefix): Body of new function.\n\t(Requires_Simple_Name_Prefix): Body of new function.\n\t(Resolve_Attribute, case Access): Improve error message for case of\n\tmismatched conventions.\n\t(Analyze_Attribute, case 'Tag): The prefix the attribute cannot be of an\n\tincomplete type.\n\t(Analyze_Attribute, case 'Access): If the type of the prefix is a\n\tconstrained subtype for a nominal unconstrained type, use its base type\n\tto check for conformance with the context.\n\t(Resolve_Attribute): Remove test of the access type being associated\n\twith a return statement from condition for performing accessibility\n\tchecks on access attributes, since this case is now captured by\n\tIs_Local_Anonymous_Access.\n\t(Analyze_Access_Attribute): Set Address_Taken on entity\n\t(Analyze_Attribute, case Address): Set Address_Taken on entity\n\t(OK_Self_Reference): Traverse tree to locate enclosing aggregate when\n\tvalidating an access attribute whose prefix is a current instance.\n\t(Resolve_Attribute): In case of attributes 'Code_Address and 'Address\n\tapplied to dispatching operations, if freezing is required then we set\n\tthe attribute Has_Delayed_Freeze in the prefix's entity.\n\t(Check_Local_Access): Set flag Suppress_Value_Tracking_On_Call in\n\tcurrent scope if access of local subprogram taken\n\t(Analyze_Access_Attribute): Check legality of self-reference even if the\n\texpression comes from source, as when a single component association in\n\tan aggregate has a box association.\n\t(Resolve_Attribute, case 'Access): Do not apply accessibility checks to\n\tthe prefix if it is a protected operation and the attribute is\n\tUnrestricted_Access.\n\t(Resolve_Attribute, case 'Access): Set the Etype of the attribute\n\treference to the base type of the context, to force a constraint check\n\twhen the context is an access subtype with an explicit constraint.\n\t(Analyze_Attribute, case 'Class): If the prefix is an interface and the\n\tnode is rewritten as an interface conversion. leave unanalyzed after\n\tresolution, to ensure that type checking against the context will take\n\tplace.\n\nFrom-SVN: r125395", "tree": {"sha": "c928df246f8400dd4a71f7151bc3fefb4bb99800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c928df246f8400dd4a71f7151bc3fefb4bb99800"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "33160237cba68041242b7faf782ab35a5106224f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33160237cba68041242b7faf782ab35a5106224f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33160237cba68041242b7faf782ab35a5106224f"}], "stats": {"total": 565, "additions": 355, "deletions": 210}, "files": [{"sha": "f486d0270deca1a11e7f20f8d09a5eb42481499a", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,12 +35,12 @@ with Exp_VFpt; use Exp_VFpt;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Sem;      use Sem;\n+with Sem_Attr; use Sem_Attr;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n-with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -156,13 +156,12 @@ package body Exp_Ch2 is\n \n          and then Nkind (Parent (N)) /= N_Pragma_Argument_Association\n \n-         --  Same for Asm_Input and Asm_Output attribute references\n+         --  Same for attribute references that require a simple name prefix\n \n          and then not (Nkind (Parent (N)) = N_Attribute_Reference\n-                         and then\n-                           (Attribute_Name (Parent (N)) = Name_Asm_Input\n-                              or else\n-                            Attribute_Name (Parent (N)) = Name_Asm_Output))\n+                         and then Requires_Simple_Name_Prefix (\n+                                    Attribute_Name (Parent (N))))\n+\n       then\n          --  Case of Current_Value is a compile time known value\n "}, {"sha": "7e5b83547edf74c986e1dfdf175209357e365fa0", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 334, "deletions": 202, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,7 +37,6 @@ with Expander; use Expander;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n-with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -79,6 +78,7 @@ package body Sem_Attr is\n    --  trouble with cascaded errors.\n \n    --  The following array is the list of attributes defined in the Ada 83 RM\n+   --  that are not included in Ada 95, but still get recognized in GNAT.\n \n    Attribute_83 : constant Attribute_Class_Array := Attribute_Class_Array'(\n       Attribute_Address           |\n@@ -125,6 +125,40 @@ package body Sem_Attr is\n       Attribute_Width             => True,\n       others                      => False);\n \n+   --  The following array is the list of attributes defined in the Ada 2005\n+   --  RM which are not defined in Ada 95. These are recognized in Ada 95 mode,\n+   --  but in Ada 95 they are considered to be implementation defined.\n+\n+   Attribute_05 : constant Attribute_Class_Array := Attribute_Class_Array'(\n+      Attribute_Machine_Rounding  |\n+      Attribute_Priority          |\n+      Attribute_Stream_Size       |\n+      Attribute_Wide_Wide_Width   => True,\n+      others                      => False);\n+\n+   --  The following array contains all attributes that cause a modification\n+   --  of their prefixes. In a certain sense, the prefix may be considered as\n+   --  an lvalue.\n+\n+   Attribute_Name_Modifies_Prefix : constant Attribute_Class_Array :=\n+      Attribute_Class_Array'(\n+      Attribute_Access           |\n+      Attribute_Address          |\n+      Attribute_Input            |\n+      Attribute_Read             |\n+      Attribute_Unchecked_Access => True,\n+      others                     => False);\n+\n+   --  The following list contains all attributes that require simple names\n+   --  rather than values as their prefixes.\n+\n+   Attribute_Requires_Simple_Name_Prefix : constant Attribute_Class_Array :=\n+      Attribute_Class_Array'(\n+      Attribute_Asm_Input  |\n+      Attribute_Asm_Output |\n+      Attribute_Size       => True,\n+      others               => False);\n+\n    -----------------------\n    -- Local_Subprograms --\n    -----------------------\n@@ -311,6 +345,10 @@ package body Sem_Attr is\n       --  no arguments is used when the caller has already generated the\n       --  required error messages.\n \n+      procedure Error_Attr_P (Msg : String);\n+      pragma No_Return (Error_Attr);\n+      --  Like Error_Attr, but error is posted at the start of the prefix\n+\n       procedure Standard_Attribute (Val : Int);\n       --  Used to process attributes whose prefix is package Standard which\n       --  yield values of type Universal_Integer. The attribute reference\n@@ -348,7 +386,9 @@ package body Sem_Attr is\n          function OK_Self_Reference return Boolean;\n          --  An access reference whose prefix is a type can legally appear\n          --  within an aggregate, where it is obtained by expansion of\n-         --  a defaulted aggregate;\n+         --  a defaulted aggregate. The enclosing aggregate that contains\n+         --  the self-referenced is flagged so that the self-reference can\n+         --  be expanded into a reference to the target object (see exp_aggr).\n \n          ------------------------------\n          -- Build_Access_Object_Type --\n@@ -375,9 +415,27 @@ package body Sem_Attr is\n             Index : Interp_Index;\n             It    : Interp;\n \n+            procedure Check_Local_Access (E : Entity_Id);\n+            --  Deal with possible access to local subprogram. If we have such\n+            --  an access, we set a flag to kill all tracked values on any call\n+            --  because this access value may be passed around, and any called\n+            --  code might use it to access a local procedure which clobbers a\n+            --  tracked value.\n+\n             function Get_Kind (E : Entity_Id) return Entity_Kind;\n             --  Distinguish between access to regular/protected subprograms\n \n+            ------------------------\n+            -- Check_Local_Access --\n+            ------------------------\n+\n+            procedure Check_Local_Access (E : Entity_Id) is\n+            begin\n+               if not Is_Library_Level_Entity (E) then\n+                  Set_Suppress_Value_Tracking_On_Call (Current_Scope);\n+               end if;\n+            end Check_Local_Access;\n+\n             --------------\n             -- Get_Kind --\n             --------------\n@@ -401,6 +459,8 @@ package body Sem_Attr is\n             Set_Etype (N, Any_Type);\n \n             if not Is_Overloaded (P) then\n+               Check_Local_Access (Entity (P));\n+\n                if not Is_Intrinsic_Subprogram (Entity (P)) then\n                   Acc_Type :=\n                     New_Internal_Entity\n@@ -413,6 +473,8 @@ package body Sem_Attr is\n             else\n                Get_First_Interp (P, Index, It);\n                while Present (It.Nam) loop\n+                  Check_Local_Access (It.Nam);\n+\n                   if not Is_Intrinsic_Subprogram (It.Nam) then\n                      Acc_Type :=\n                        New_Internal_Entity\n@@ -426,8 +488,12 @@ package body Sem_Attr is\n                end loop;\n             end if;\n \n+            --  Cannot be applied to intrinsic. Looking at the tests above,\n+            --  the only way Etype (N) can still be set to Any_Type is if\n+            --  Is_Intrinsic_Subprogram was True for some referenced entity.\n+\n             if Etype (N) = Any_Type then\n-               Error_Attr (\"prefix of % attribute cannot be intrinsic\", P);\n+               Error_Attr_P (\"prefix of % attribute cannot be intrinsic\");\n             end if;\n          end Build_Access_Subprogram_Type;\n \n@@ -441,24 +507,25 @@ package body Sem_Attr is\n          begin\n             Par := Parent (N);\n             while Present (Par)\n-              and then Nkind (Par) in N_Subexpr\n+              and then\n+               (Nkind (Par) = N_Component_Association\n+                 or else Nkind (Par) in N_Subexpr)\n             loop\n-               exit when Nkind (Par) = N_Aggregate\n-                 or else Nkind (Par) = N_Extension_Aggregate;\n+               if Nkind (Par) = N_Aggregate\n+                 or else Nkind (Par) = N_Extension_Aggregate\n+               then\n+                  if Etype (Par) = Typ then\n+                     Set_Has_Self_Reference (Par);\n+                     return True;\n+                  end if;\n+               end if;\n+\n                Par := Parent (Par);\n             end loop;\n \n-            if Present (Par)\n-              and then\n-                (Nkind (Par) = N_Aggregate\n-                   or else Nkind (Par) = N_Extension_Aggregate)\n-              and then Etype (Par) = Typ\n-            then\n-               Set_Has_Self_Reference (Par);\n-               return True;\n-            else\n-               return False;\n-            end if;\n+            --  No enclosing aggregate, or not a self-reference\n+\n+            return False;\n          end OK_Self_Reference;\n \n       --  Start of processing for Analyze_Access_Attribute\n@@ -467,8 +534,8 @@ package body Sem_Attr is\n          Check_E0;\n \n          if Nkind (P) = N_Character_Literal then\n-            Error_Attr\n-              (\"prefix of % attribute cannot be enumeration literal\", P);\n+            Error_Attr_P\n+              (\"prefix of % attribute cannot be enumeration literal\");\n          end if;\n \n          --  Case of access to subprogram\n@@ -484,9 +551,8 @@ package body Sem_Attr is\n             end if;\n \n             if Is_Always_Inlined (Entity (P)) then\n-               Error_Attr\n-                 (\"prefix of % attribute cannot be Inline_Always subprogram\",\n-                  P);\n+               Error_Attr_P\n+                 (\"prefix of % attribute cannot be Inline_Always subprogram\");\n             end if;\n \n             if Aname = Name_Unchecked_Access then\n@@ -513,7 +579,7 @@ package body Sem_Attr is\n            and then Is_Overloadable (Entity (Selector_Name (P)))\n          then\n             if Ekind (Entity (Selector_Name (P))) = E_Entry then\n-               Error_Attr (\"prefix of % attribute must be subprogram\", P);\n+               Error_Attr_P (\"prefix of % attribute must be subprogram\");\n             end if;\n \n             Build_Access_Subprogram_Type (Selector_Name (P));\n@@ -565,7 +631,7 @@ package body Sem_Attr is\n                   end;\n \n                   if Nkind (P) = N_Expanded_Name then\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"current instance prefix must be a direct name\", P);\n                   end if;\n \n@@ -608,8 +674,11 @@ package body Sem_Attr is\n                --  OK if self-reference in an aggregate in Ada 2005, and\n                --  the reference comes from a copied default expression.\n \n+               --  Note that we check legality of self-reference even if the\n+               --  expression comes from source, e.g. when a single component\n+               --  association in an aggregate has a box association.\n+\n                elsif Ada_Version >= Ada_05\n-                 and then not Comes_From_Source (N)\n                  and then OK_Self_Reference\n                then\n                   null;\n@@ -647,31 +716,38 @@ package body Sem_Attr is\n             end;\n          end if;\n \n-         --  If we have an access to an object, and the attribute comes\n-         --  from source, then set the object as potentially source modified.\n-         --  We do this because the resulting access pointer can be used to\n-         --  modify the variable, and we might not detect this, leading to\n-         --  some junk warnings.\n+         --  Special cases when prefix is entity name\n \n          if Is_Entity_Name (P) then\n+\n+            --  If we have an access to an object, and the attribute comes from\n+            --  source, then set the object as potentially source modified. We\n+            --  do this because the resulting access pointer can be used to\n+            --  modify the variable, and we might not detect this, leading to\n+            --  some junk warnings.\n+\n             Set_Never_Set_In_Source (Entity (P), False);\n+\n+            --  Mark entity as address taken, and kill current values\n+\n+            Set_Address_Taken (Entity (P));\n+            Kill_Current_Values (Entity (P));\n          end if;\n \n-         --  Check for aliased view unless unrestricted case. We allow\n-         --  a nonaliased prefix when within an instance because the\n-         --  prefix may have been a tagged formal object, which is\n-         --  defined to be aliased even when the actual might not be\n-         --  (other instance cases will have been caught in the generic).\n-         --  Similarly, within an inlined body we know that the attribute\n-         --  is legal in the original subprogram, and therefore legal in\n-         --  the expansion.\n+         --  Check for aliased view unless unrestricted case. We allow a\n+         --  nonaliased prefix when within an instance because the prefix may\n+         --  have been a tagged formal object, which is defined to be aliased\n+         --  even when the actual might not be (other instance cases will have\n+         --  been caught in the generic). Similarly, within an inlined body we\n+         --  know that the attribute is legal in the original subprogram, and\n+         --  therefore legal in the expansion.\n \n          if Aname /= Name_Unrestricted_Access\n            and then not Is_Aliased_View (P)\n            and then not In_Instance\n            and then not In_Inlined_Body\n          then\n-            Error_Attr (\"prefix of % attribute must be aliased\", P);\n+            Error_Attr_P (\"prefix of % attribute must be aliased\");\n          end if;\n       end Analyze_Access_Attribute;\n \n@@ -788,23 +864,22 @@ package body Sem_Attr is\n                --  recovery behavior.\n \n                Error_Msg_Name_1 := Aname;\n-               Error_Msg_N\n+               Error_Msg_F\n                  (\"prefix for % attribute must be constrained array\", P);\n             end if;\n \n             D := Number_Dimensions (P_Type);\n \n          else\n             if Is_Private_Type (P_Type) then\n-               Error_Attr\n-                 (\"prefix for % attribute may not be private type\", P);\n+               Error_Attr_P (\"prefix for % attribute may not be private type\");\n \n             elsif Is_Access_Type (P_Type)\n               and then Is_Array_Type (Designated_Type (P_Type))\n               and then Is_Entity_Name (P)\n               and then Is_Type (Entity (P))\n             then\n-               Error_Attr (\"prefix of % attribute cannot be access type\", P);\n+               Error_Attr_P (\"prefix of % attribute cannot be access type\");\n \n             elsif Attr_Id = Attribute_First\n                     or else\n@@ -813,7 +888,7 @@ package body Sem_Attr is\n                Error_Attr (\"invalid prefix for % attribute\", P);\n \n             else\n-               Error_Attr (\"prefix for % attribute must be array\", P);\n+               Error_Attr_P (\"prefix for % attribute must be array\");\n             end if;\n          end if;\n \n@@ -888,8 +963,7 @@ package body Sem_Attr is\n                and then\n               Ekind (Entity (Selector_Name (P))) /= E_Discriminant)\n          then\n-            Error_Attr\n-              (\"prefix for % attribute must be selected component\", P);\n+            Error_Attr_P (\"prefix for % attribute must be selected component\");\n          end if;\n       end Check_Component;\n \n@@ -902,8 +976,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Decimal_Fixed_Point_Type (P_Type) then\n-            Error_Attr\n-              (\"prefix of % attribute must be decimal type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be decimal type\");\n          end if;\n       end Check_Decimal_Fixed_Point_Type;\n \n@@ -958,7 +1031,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Discrete_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be discrete type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be discrete type\");\n          end if;\n       end Check_Discrete_Type;\n \n@@ -1054,7 +1127,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Fixed_Point_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be fixed point type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be fixed point type\");\n          end if;\n       end Check_Fixed_Point_Type;\n \n@@ -1077,7 +1150,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Floating_Point_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be float type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be float type\");\n          end if;\n       end Check_Floating_Point_Type;\n \n@@ -1120,7 +1193,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Integer_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be integer type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be integer type\");\n          end if;\n       end Check_Integer_Type;\n \n@@ -1131,7 +1204,7 @@ package body Sem_Attr is\n       procedure Check_Library_Unit is\n       begin\n          if not Is_Compilation_Unit (Entity (P)) then\n-            Error_Attr (\"prefix of % attribute must be library unit\", P);\n+            Error_Attr_P (\"prefix of % attribute must be library unit\");\n          end if;\n       end Check_Library_Unit;\n \n@@ -1144,8 +1217,8 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Modular_Integer_Type (P_Type) then\n-            Error_Attr\n-              (\"prefix of % attribute must be modular integer type\", P);\n+            Error_Attr_P\n+              (\"prefix of % attribute must be modular integer type\");\n          end if;\n       end Check_Modular_Integer_Type;\n \n@@ -1188,8 +1261,8 @@ package body Sem_Attr is\n             end loop;\n \n             if From_With_Type (Etype (E)) then\n-               Error_Attr\n-                 (\"prefix of % attribute cannot be an incomplete type\", P);\n+               Error_Attr_P\n+                 (\"prefix of % attribute cannot be an incomplete type\");\n \n             else\n                if Is_Access_Type (Etype (E)) then\n@@ -1201,8 +1274,8 @@ package body Sem_Attr is\n                if Ekind (Typ) = E_Incomplete_Type\n                  and then No (Full_View (Typ))\n                then\n-                  Error_Attr\n-                    (\"prefix of % attribute cannot be an incomplete type\", P);\n+                  Error_Attr_P\n+                    (\"prefix of % attribute cannot be an incomplete type\");\n                end if;\n             end if;\n          end if;\n@@ -1242,7 +1315,7 @@ package body Sem_Attr is\n          --  Otherwise we must have an object reference\n \n          elsif not Is_Object_Reference (P) then\n-            Error_Attr (\"prefix of % attribute must be object\", P);\n+            Error_Attr_P (\"prefix of % attribute must be object\");\n          end if;\n       end Check_Object_Reference;\n \n@@ -1274,7 +1347,7 @@ package body Sem_Attr is\n             end;\n          end if;\n \n-         Error_Attr (\"prefix of % attribute must be program unit\", P);\n+         Error_Attr_P (\"prefix of % attribute must be program unit\");\n       end Check_Program_Unit;\n \n       ---------------------\n@@ -1286,7 +1359,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Real_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be real type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be real type\");\n          end if;\n       end Check_Real_Type;\n \n@@ -1299,7 +1372,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Scalar_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be scalar type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be scalar type\");\n          end if;\n       end Check_Scalar_Type;\n \n@@ -1443,11 +1516,12 @@ package body Sem_Attr is\n \n          else\n             if Ada_Version >= Ada_05 then\n-               Error_Attr (\"prefix of % attribute must be a task or a task \"\n-                           & \"interface class-wide object\", P);\n+               Error_Attr_P\n+                 (\"prefix of % attribute must be a task or a task \" &\n+                  \"interface class-wide object\");\n \n             else\n-               Error_Attr (\"prefix of % attribute must be a task\", P);\n+               Error_Attr_P (\"prefix of % attribute must be a task\");\n             end if;\n          end if;\n       end Check_Task_Prefix;\n@@ -1465,7 +1539,7 @@ package body Sem_Attr is\n          if not Is_Entity_Name (P)\n            or else not Is_Type (Entity (P))\n          then\n-            Error_Attr (\"prefix of % attribute must be a type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be a type\");\n \n          elsif Ekind (Entity (P)) = E_Incomplete_Type\n             and then Present (Full_View (Entity (P)))\n@@ -1513,6 +1587,17 @@ package body Sem_Attr is\n          Error_Attr;\n       end Error_Attr;\n \n+      ------------------\n+      -- Error_Attr_P --\n+      ------------------\n+\n+      procedure Error_Attr_P (Msg : String) is\n+      begin\n+         Error_Msg_Name_1 := Aname;\n+         Error_Msg_F (Msg, P);\n+         Error_Attr;\n+      end Error_Attr_P;\n+\n       ----------------------------\n       -- Legal_Formal_Attribute --\n       ----------------------------\n@@ -1524,7 +1609,7 @@ package body Sem_Attr is\n          if not Is_Entity_Name (P)\n            or else not Is_Type (Entity (P))\n          then\n-            Error_Attr (\"prefix of % attribute must be generic type\", N);\n+            Error_Attr_P (\"prefix of % attribute must be generic type\");\n \n          elsif Is_Generic_Actual_Type (Entity (P))\n            or else In_Instance\n@@ -1534,13 +1619,13 @@ package body Sem_Attr is\n \n          elsif Is_Generic_Type (Entity (P)) then\n             if not Is_Indefinite_Subtype (Entity (P)) then\n-               Error_Attr\n-                 (\"prefix of % attribute must be indefinite generic type\", N);\n+               Error_Attr_P\n+                 (\"prefix of % attribute must be indefinite generic type\");\n             end if;\n \n          else\n-            Error_Attr\n-              (\"prefix of % attribute must be indefinite generic type\", N);\n+            Error_Attr_P\n+              (\"prefix of % attribute must be indefinite generic type\");\n          end if;\n \n          Set_Etype (N, Standard_Boolean);\n@@ -1674,7 +1759,7 @@ package body Sem_Attr is\n          raise Bad_Attribute;\n       end if;\n \n-      --  Deal with Ada 83 and Features issues\n+      --  Deal with Ada 83 issues\n \n       if Comes_From_Source (N) then\n          if not Attribute_83 (Attr_Id) then\n@@ -1689,6 +1774,12 @@ package body Sem_Attr is\n          end if;\n       end if;\n \n+      --  Deal with Ada 2005 issues\n+\n+      if Attribute_05 (Attr_Id) and then Ada_Version <= Ada_95 then\n+         Check_Restriction (No_Implementation_Attributes, N);\n+      end if;\n+\n       --   Remote access to subprogram type access attribute reference needs\n       --   unanalyzed copy for tree transformation. The analyzed copy is used\n       --   for its semantic information (whether prefix is a remote subprogram\n@@ -1899,45 +1990,25 @@ package body Sem_Attr is\n \n             begin\n                if Is_Subprogram (Ent) then\n-                  if not Is_Library_Level_Entity (Ent)\n-\n-                     --  Do not take into account nodes generated by the\n-                     --  expander for the elaboration of the dispatch tables;\n-                     --  otherwise we erroneously generate warnings indicating\n-                     --  violation of restriction No_Implicit_Dynamic_Code\n-                     --  with those nodes.\n-\n-                    and then not (Is_Dispatching_Operation (Ent)\n-                       and then Nkind (Parent (N)) = N_Assignment_Statement\n-                       and then Nkind (Name (Parent (N))) = N_Indexed_Component\n-                       and then Nkind (Prefix (Name (Parent (N)))) =\n-                                  N_Selected_Component\n-                       and then Nkind (Selector_Name\n-                                        (Prefix (Name (Parent (N))))) =\n-                                  N_Identifier\n-                       and then Present (Entity (Selector_Name\n-                                                 (Prefix (Name (Parent (N))))))\n-                       and then Entity (Selector_Name\n-                                         (Prefix (Name (Parent (N))))) =\n-                                  RTE_Record_Component (RE_Prims_Ptr))\n-                  then\n+                  if not Is_Library_Level_Entity (Ent) then\n                      Check_Restriction (No_Implicit_Dynamic_Code, P);\n                   end if;\n \n                   Set_Address_Taken (Ent);\n+                  Kill_Current_Values (Ent);\n \n-                  --  An Address attribute is accepted when generated by\n-                  --  the compiler for dispatching operation, and an error\n-                  --  is issued once the subprogram is frozen (to avoid\n-                  --  confusing errors about implicit uses of Address in\n-                  --  the dispatch table initialization).\n+                  --  An Address attribute is accepted when generated by the\n+                  --  compiler for dispatching operation, and an error is\n+                  --  issued once the subprogram is frozen (to avoid confusing\n+                  --  errors about implicit uses of Address in the dispatch\n+                  --  table initialization).\n \n                   if Is_Always_Inlined (Entity (P))\n                     and then Comes_From_Source (P)\n                   then\n-                     Error_Attr\n+                     Error_Attr_P\n                        (\"prefix of % attribute cannot be Inline_Always\" &\n-                        \" subprogram\", P);\n+                        \" subprogram\");\n                   end if;\n \n                elsif Is_Object (Ent)\n@@ -2083,7 +2154,7 @@ package body Sem_Attr is\n \n          procedure Bad_AST_Entry is\n          begin\n-            Error_Attr (\"prefix for % attribute must be task entry\", P);\n+            Error_Attr_P (\"prefix for % attribute must be task entry\");\n          end Bad_AST_Entry;\n \n          function OK_Entry (E : Entity_Id) return Boolean is\n@@ -2099,8 +2170,7 @@ package body Sem_Attr is\n             if Result then\n                if not Is_AST_Entry (E) then\n                   Error_Msg_Name_2 := Aname;\n-                  Error_Attr\n-                    (\"% attribute requires previous % pragma\", P);\n+                  Error_Attr (\"% attribute requires previous % pragma\", P);\n                end if;\n             end if;\n \n@@ -2195,14 +2265,14 @@ package body Sem_Attr is\n            and then not Is_Scalar_Type (Typ)\n            and then not Is_Generic_Type (Typ)\n          then\n-            Error_Msg_N (\"prefix of Base attribute must be scalar type\", N);\n+            Error_Attr_P (\"prefix of Base attribute must be scalar type\");\n \n          elsif Sloc (Typ) = Standard_Location\n            and then Base_Type (Typ) = Typ\n            and then Warn_On_Redundant_Constructs\n          then\n-            Error_Msg_NE\n-              (\"?redudant attribute, & is its own base type\", N, Typ);\n+               Error_Msg_NE\n+                 (\"?redudant attribute, & is its own base type\", N, Typ);\n          end if;\n \n          Set_Etype (N, Base_Type (Entity (P)));\n@@ -2248,7 +2318,7 @@ package body Sem_Attr is\n          Check_E0;\n \n          if not Is_Object_Reference (P) then\n-            Error_Attr (\"prefix for % attribute must be object\", P);\n+            Error_Attr_P (\"prefix for % attribute must be object\");\n \n          --  What about the access object cases ???\n \n@@ -2269,7 +2339,7 @@ package body Sem_Attr is\n          Check_Type;\n \n          if not Is_Record_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be record type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be record type\");\n          end if;\n \n          if Bytes_Big_Endian xor Reverse_Bit_Order (P_Type) then\n@@ -2408,6 +2478,14 @@ package body Sem_Attr is\n               or else Is_Interface (Etype (E1))\n             then\n                Analyze_And_Resolve (N, Etype (P));\n+\n+               --  However, the attribute is a name that occurs in a context\n+               --  that imposes its own type. Leave the result unanalyzed,\n+               --  so that type checking with the context type take place.\n+               --  on the new conversion node, otherwise Resolve is a noop.\n+\n+               Set_Analyzed (N, False);\n+\n             else\n                Analyze (N);\n             end if;\n@@ -2417,7 +2495,6 @@ package body Sem_Attr is\n          else\n             Find_Type (N);\n          end if;\n-\n       end Class;\n \n       ------------------\n@@ -2552,8 +2629,8 @@ package body Sem_Attr is\n \n          --  Fall through if bad prefix\n \n-         Error_Attr\n-           (\"prefix of % attribute must be object of discriminated type\", P);\n+         Error_Attr_P\n+           (\"prefix of % attribute must be object of discriminated type\");\n \n       ---------------\n       -- Copy_Sign --\n@@ -2749,8 +2826,8 @@ package body Sem_Attr is\n          if not Is_Floating_Point_Type (P_Type)\n            and then not Is_Decimal_Fixed_Point_Type (P_Type)\n          then\n-            Error_Attr\n-              (\"prefix of % attribute must be float or decimal type\", P);\n+            Error_Attr_P\n+              (\"prefix of % attribute must be float or decimal type\");\n          end if;\n \n          Set_Etype (N, Universal_Integer);\n@@ -2812,9 +2889,9 @@ package body Sem_Attr is\n                          and then\n                        Ekind (Entity (P)) /= E_Enumeration_Literal)\n             then\n-               Error_Attr\n+               Error_Attr_P\n                  (\"prefix of %attribute must be \" &\n-                  \"discrete type/object or enum literal\", P);\n+                  \"discrete type/object or enum literal\");\n             end if;\n          end if;\n \n@@ -2849,7 +2926,7 @@ package body Sem_Attr is\n          Set_Etype (N, Standard_String);\n \n          if not Is_Tagged_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be tagged\", P);\n+            Error_Attr_P (\"prefix of % attribute must be tagged\");\n          end if;\n \n       -----------\n@@ -2946,11 +3023,12 @@ package body Sem_Attr is\n \n          else\n             if Ada_Version >= Ada_05 then\n-               Error_Attr (\"prefix of % attribute must be an exception, a \"\n-                         & \"task or a task interface class-wide object\", P);\n+               Error_Attr_P\n+                 (\"prefix of % attribute must be an exception, a \" &\n+                  \"task or a task interface class-wide object\");\n             else\n-               Error_Attr (\"prefix of % attribute must be a task or an \"\n-                         & \"exception\", P);\n+               Error_Attr_P\n+                 (\"prefix of % attribute must be a task or an exception\");\n             end if;\n          end if;\n \n@@ -2992,8 +3070,8 @@ package body Sem_Attr is\n          if not Is_Scalar_Type (P_Type)\n            or else (Is_Entity_Name (P) and then Is_Type (Entity (P)))\n          then\n-            Error_Attr\n-              (\"prefix of % attribute must be scalar object name\", N);\n+            Error_Attr_P\n+              (\"prefix of % attribute must be scalar object name\");\n          end if;\n \n          Check_Enum_Image;\n@@ -3184,7 +3262,7 @@ package body Sem_Attr is\n          if not Is_Entity_Name (P)\n            or else not Is_Subprogram (Entity (P))\n          then\n-            Error_Attr (\"prefix of % attribute must be subprogram\", P);\n+            Error_Attr_P (\"prefix of % attribute must be subprogram\");\n          end if;\n \n          Check_Either_E0_Or_E1;\n@@ -3405,8 +3483,8 @@ package body Sem_Attr is\n \n          if P_Type /= Any_Type then\n             if not Is_Library_Level_Entity (Entity (P)) then\n-               Error_Attr\n-                 (\"prefix of % attribute must be library-level entity\", P);\n+               Error_Attr_P\n+                 (\"prefix of % attribute must be library-level entity\");\n \n             --  The defining entity of prefix should not be declared inside\n             --  a Pure unit. RM E.1(8).\n@@ -3415,8 +3493,8 @@ package body Sem_Attr is\n             elsif Is_Entity_Name (P)\n               and then Is_Pure (Entity (P))\n             then\n-               Error_Attr\n-                 (\"prefix of % attribute must not be declared pure\", P);\n+               Error_Attr_P\n+                 (\"prefix of % attribute must not be declared pure\");\n             end if;\n          end if;\n \n@@ -3505,7 +3583,7 @@ package body Sem_Attr is\n          then\n             Resolve (P, Etype (P));\n          else\n-            Error_Attr (\"prefix of % attribute must be a protected object\", P);\n+            Error_Attr_P (\"prefix of % attribute must be a protected object\");\n          end if;\n \n          Set_Etype (N, Standard_Integer);\n@@ -3718,7 +3796,7 @@ package body Sem_Attr is\n             null;\n \n          else\n-            Error_Attr (\"invalid prefix for % attribute\", P);\n+            Error_Attr_P (\"invalid prefix for % attribute\");\n          end if;\n \n          Check_Not_Incomplete_Type;\n@@ -3742,8 +3820,8 @@ package body Sem_Attr is\n             Check_E0;\n \n             if Ekind (P_Type) = E_Access_Subprogram_Type then\n-               Error_Attr\n-                 (\"cannot use % attribute for access-to-subprogram type\", P);\n+               Error_Attr_P\n+                 (\"cannot use % attribute for access-to-subprogram type\");\n             end if;\n \n             --  Set appropriate entity\n@@ -3763,7 +3841,7 @@ package body Sem_Attr is\n             Validate_Remote_Access_To_Class_Wide_Type (N);\n \n          else\n-            Error_Attr (\"prefix of % attribute must be access type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be access type\");\n          end if;\n \n       ------------------\n@@ -3777,8 +3855,8 @@ package body Sem_Attr is\n \n          elsif Is_Access_Type (P_Type) then\n             if Ekind (P_Type) = E_Access_Subprogram_Type then\n-               Error_Attr\n-                 (\"cannot use % attribute for access-to-subprogram type\", P);\n+               Error_Attr_P\n+                 (\"cannot use % attribute for access-to-subprogram type\");\n             end if;\n \n             if Is_Entity_Name (P)\n@@ -3804,8 +3882,7 @@ package body Sem_Attr is\n             end if;\n \n          else\n-            Error_Attr\n-              (\"prefix of % attribute must be access or task type\", P);\n+            Error_Attr_P (\"prefix of % attribute must be access or task type\");\n          end if;\n \n       ------------------\n@@ -3828,7 +3905,7 @@ package body Sem_Attr is\n          then\n             Set_Etype (N, Universal_Integer);\n          else\n-            Error_Attr (\"invalid prefix for % attribute\", P);\n+            Error_Attr_P (\"invalid prefix for % attribute\");\n          end if;\n \n       ---------------\n@@ -3843,8 +3920,8 @@ package body Sem_Attr is\n             Rewrite (N,\n               New_Occurrence_Of (Corresponding_Stub_Type (P_Type), Loc));\n          else\n-            Error_Attr\n-              (\"prefix of% attribute must be remote access to classwide\", P);\n+            Error_Attr_P\n+              (\"prefix of% attribute must be remote access to classwide\");\n          end if;\n \n       ----------\n@@ -3881,7 +3958,7 @@ package body Sem_Attr is\n          Check_Dereference;\n \n          if not Is_Tagged_Type (P_Type) then\n-            Error_Attr (\"prefix of % attribute must be tagged\", P);\n+            Error_Attr_P (\"prefix of % attribute must be tagged\");\n \n          --  Next test does not apply to generated code\n          --  why not, and what does the illegal reference mean???\n@@ -3890,11 +3967,18 @@ package body Sem_Attr is\n            and then not Is_Class_Wide_Type (P_Type)\n            and then Comes_From_Source (N)\n          then\n-            Error_Attr\n-              (\"% attribute can only be applied to objects of class-wide type\",\n-               P);\n+            Error_Attr_P\n+              (\"% attribute can only be applied to objects \" &\n+               \"of class - wide type\");\n          end if;\n \n+         --  The prefix cannot be an incomplete type. However, references\n+         --  to 'Tag can be generated when expanding interface conversions,\n+         --  and this is legal.\n+\n+         if Comes_From_Source (N) then\n+            Check_Not_Incomplete_Type;\n+         end if;\n          Set_Etype (N, RTE (RE_Tag));\n \n       -----------------\n@@ -3941,7 +4025,7 @@ package body Sem_Attr is\n          if Nkind (P) /= N_Identifier\n            or else Chars (P) /= Name_System\n          then\n-            Error_Attr (\"prefix of %attribute must be System\", P);\n+            Error_Attr_P (\"prefix of %attribute must be System\");\n          end if;\n \n          Generate_Reference (RTE (RE_Address), P);\n@@ -4024,7 +4108,7 @@ package body Sem_Attr is\n          if not Is_Entity_Name (P)\n            or else Ekind (Entity (P)) not in Named_Kind\n          then\n-            Error_Attr (\"prefix for % attribute must be named number\", P);\n+            Error_Attr_P (\"prefix for % attribute must be named number\");\n \n          else\n             declare\n@@ -4125,7 +4209,7 @@ package body Sem_Attr is\n          end if;\n \n          if not Is_Scalar_Type (P_Type) then\n-            Error_Attr (\"object for % attribute must be of scalar type\", P);\n+            Error_Attr_P (\"object for % attribute must be of scalar type\");\n          end if;\n \n          Set_Etype (N, Standard_Boolean);\n@@ -6946,6 +7030,26 @@ package body Sem_Attr is\n           and then Associated_Node_For_Itype (Anon) = Parent (Typ);\n    end Is_Anonymous_Tagged_Base;\n \n+   --------------------------\n+   -- Name_Modifies_Prefix --\n+   --------------------------\n+\n+   function Name_Modifies_Prefix (Nam : Name_Id) return Boolean is\n+      pragma Assert (Is_Attribute_Name (Nam));\n+   begin\n+      return Attribute_Name_Modifies_Prefix (Get_Attribute_Id (Nam));\n+   end Name_Modifies_Prefix;\n+\n+   ---------------------------------\n+   -- Requires_Simple_Name_Prefix --\n+   ---------------------------------\n+\n+   function Requires_Simple_Name_Prefix (Nam : Name_Id) return Boolean is\n+      pragma Assert (Is_Attribute_Name (Nam));\n+   begin\n+      return Attribute_Requires_Simple_Name_Prefix (Get_Attribute_Id (Nam));\n+   end Requires_Simple_Name_Prefix;\n+\n    -----------------------\n    -- Resolve_Attribute --\n    -----------------------\n@@ -6977,9 +7081,9 @@ package body Sem_Attr is\n          --  know will fail, so generate an appropriate warning.\n \n          if In_Instance_Body then\n-            Error_Msg_N\n+            Error_Msg_F\n               (\"?non-local pointer cannot point to local object\", P);\n-            Error_Msg_N\n+            Error_Msg_F\n               (\"\\?Program_Error will be raised at run time\", P);\n             Rewrite (N,\n               Make_Raise_Program_Error (Loc,\n@@ -6988,7 +7092,7 @@ package body Sem_Attr is\n             return;\n \n          else\n-            Error_Msg_N\n+            Error_Msg_F\n               (\"non-local pointer cannot point to local object\", P);\n \n             --  Check for case where we have a missing access definition\n@@ -7009,8 +7113,8 @@ package body Sem_Attr is\n                if Present (Indic) then\n                   Error_Msg_NE\n                     (\"\\use an access definition for\" &\n-                      \" the access discriminant of&\", N,\n-                         Entity (Subtype_Mark (Indic)));\n+                     \" the access discriminant of&\",\n+                     N, Entity (Subtype_Mark (Indic)));\n                end if;\n             end if;\n          end if;\n@@ -7106,24 +7210,20 @@ package body Sem_Attr is\n                elsif Is_Overloadable (Entity (P))\n                  and then Is_Abstract_Subprogram (Entity (P))\n                then\n-                  Error_Msg_N (\"prefix of % attribute cannot be abstract\", P);\n+                  Error_Msg_F (\"prefix of % attribute cannot be abstract\", P);\n                   Set_Etype (N, Any_Type);\n \n                elsif Convention (Entity (P)) = Convention_Intrinsic then\n                   if Ekind (Entity (P)) = E_Enumeration_Literal then\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"prefix of % attribute cannot be enumeration literal\",\n-                          P);\n+                        P);\n                   else\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"prefix of % attribute cannot be intrinsic\", P);\n                   end if;\n \n                   Set_Etype (N, Any_Type);\n-\n-               elsif Is_Thread_Body (Entity (P)) then\n-                  Error_Msg_N\n-                    (\"prefix of % attribute cannot be a thread body\", P);\n                end if;\n \n                --  Assignments, return statements, components of aggregates,\n@@ -7138,9 +7238,21 @@ package body Sem_Attr is\n                     or else\n                   Ekind (Btyp) = E_Anonymous_Access_Protected_Subprogram_Type\n                then\n+                  --  Deal with convention mismatch\n+\n                   if Convention (Btyp) /= Convention (Entity (P)) then\n-                     Error_Msg_N\n-                      (\"subprogram has invalid convention for context\", P);\n+                     Error_Msg_FE\n+                       (\"subprogram & has wrong convention\", P, Entity (P));\n+\n+                     Error_Msg_FE\n+                       (\"\\does not match convention of access type &\",\n+                        P, Btyp);\n+\n+                     if not Has_Convention_Pragma (Btyp) then\n+                        Error_Msg_FE\n+                          (\"\\probable missing pragma Convention for &\",\n+                           P, Btyp);\n+                     end if;\n \n                   else\n                      Check_Subtype_Conformant\n@@ -7151,7 +7263,7 @@ package body Sem_Attr is\n \n                   if Attr_Id = Attribute_Unchecked_Access then\n                      Error_Msg_Name_1 := Aname;\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"attribute% cannot be applied to a subprogram\", P);\n \n                   elsif Aname = Name_Unrestricted_Access then\n@@ -7171,7 +7283,7 @@ package body Sem_Attr is\n                     and then Ekind (Btyp) /=\n                                E_Anonymous_Access_Protected_Subprogram_Type\n                   then\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"subprogram must not be deeper than access type\", P);\n \n                   --  Check the restriction of 3.10.2(32) that disallows the\n@@ -7210,8 +7322,8 @@ package body Sem_Attr is\n                   --  want the check to apply when the access attribute is in\n                   --  the spec and there's some other generic body enclosing\n                   --  generic). Finally, there's no point applying the check\n-                  --  when within an instance, because any violations will\n-                  --  have been caught by the compilation of the generic unit.\n+                  --  when within an instance, because any violations will have\n+                  --  been caught by the compilation of the generic unit.\n \n                   elsif Attr_Id = Attribute_Access\n                     and then not In_Instance\n@@ -7306,7 +7418,7 @@ package body Sem_Attr is\n \n                if Attr_Id = Attribute_Unchecked_Access then\n                   Error_Msg_Name_1 := Aname;\n-                  Error_Msg_N\n+                  Error_Msg_F\n                     (\"attribute% cannot be applied to protected operation\", P);\n                end if;\n \n@@ -7340,16 +7452,17 @@ package body Sem_Attr is\n                Resolve (P);\n             end if;\n \n-            --  X'Access is illegal if X denotes a constant and the access\n-            --  type is access-to-variable. Same for 'Unchecked_Access.\n-            --  The rule does not apply to 'Unrestricted_Access.\n-            --  If the reference is a default-initialized aggregate component\n-            --  for a self-referential type the reference is legal.\n+            --  X'Access is illegal if X denotes a constant and the access type\n+            --  is access-to-variable. Same for 'Unchecked_Access. The rule\n+            --  does not apply to 'Unrestricted_Access. If the reference is a\n+            --  default-initialized aggregate component for a self-referential\n+            --  type the reference is legal.\n \n             if not (Ekind (Btyp) = E_Access_Subprogram_Type\n                      or else Ekind (Btyp) = E_Anonymous_Access_Subprogram_Type\n-                     or else (Is_Record_Type (Btyp) and then\n-                              Present (Corresponding_Remote_Type (Btyp)))\n+                    or else (Is_Record_Type (Btyp)\n+                              and then\n+                                Present (Corresponding_Remote_Type (Btyp)))\n                      or else Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n                      or else Ekind (Btyp)\n                                = E_Anonymous_Access_Protected_Subprogram_Type\n@@ -7366,7 +7479,7 @@ package body Sem_Attr is\n                   null;\n \n                elsif Comes_From_Source (N) then\n-                  Error_Msg_N (\"access-to-variable designates constant\", P);\n+                  Error_Msg_F (\"access-to-variable designates constant\", P);\n                end if;\n             end if;\n \n@@ -7377,37 +7490,36 @@ package body Sem_Attr is\n                           or else Ekind (Btyp) = E_Anonymous_Access_Type)\n             then\n                --  Ada 2005 (AI-230): Check the accessibility of anonymous\n-               --  access types in record and array components. For a\n-               --  component definition the level is the same of the\n-               --  enclosing composite type.\n+               --  access types for stand-alone objects, record and array\n+               --  components, and return objects. For a component definition\n+               --  the level is the same of the enclosing composite type.\n \n                if Ada_Version >= Ada_05\n-                 and then\n-                   (Is_Local_Anonymous_Access (Btyp)\n-                      or else Ekind (Scope (Btyp)) = E_Return_Statement)\n+                 and then Is_Local_Anonymous_Access (Btyp)\n                  and then Object_Access_Level (P) > Type_Access_Level (Btyp)\n                  and then Attr_Id = Attribute_Access\n                then\n                   --  In an instance, this is a runtime check, but one we\n                   --  know will fail, so generate an appropriate warning.\n \n                   if In_Instance_Body then\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"?non-local pointer cannot point to local object\", P);\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"\\?Program_Error will be raised at run time\", P);\n                      Rewrite (N,\n                        Make_Raise_Program_Error (Loc,\n                          Reason => PE_Accessibility_Check_Failed));\n                      Set_Etype (N, Typ);\n+\n                   else\n-                     Error_Msg_N\n+                     Error_Msg_F\n                        (\"non-local pointer cannot point to local object\", P);\n                   end if;\n                end if;\n \n                if Is_Dependent_Component_Of_Mutable_Object (P) then\n-                  Error_Msg_N\n+                  Error_Msg_F\n                     (\"illegal attribute for discriminant-dependent component\",\n                      P);\n                end if;\n@@ -7419,7 +7531,7 @@ package body Sem_Attr is\n                Nom_Subt := Etype (P);\n \n                if Is_Constr_Subt_For_U_Nominal (Nom_Subt) then\n-                  Nom_Subt := Etype (Nom_Subt);\n+                  Nom_Subt := Base_Type (Nom_Subt);\n                end if;\n \n                Des_Btyp := Designated_Type (Btyp);\n@@ -7463,10 +7575,10 @@ package body Sem_Attr is\n                               null;\n \n                            else\n-                              Error_Msg_NE\n+                              Error_Msg_FE\n                                 (\"type of prefix: & not compatible\",\n                                   P, Nom_Subt);\n-                              Error_Msg_NE\n+                              Error_Msg_FE\n                                 (\"\\with &, the expected designated type\",\n                                   P, Designated_Type (Typ));\n                            end if;\n@@ -7478,9 +7590,9 @@ package body Sem_Attr is\n                       (not Is_Class_Wide_Type (Designated_Type (Typ))\n                         and then Is_Class_Wide_Type (Nom_Subt))\n                   then\n-                     Error_Msg_NE\n+                     Error_Msg_FE\n                        (\"type of prefix: & is not covered\", P, Nom_Subt);\n-                     Error_Msg_NE\n+                     Error_Msg_FE\n                        (\"\\by &, the expected designated type\" &\n                            \" ('R'M 3.10.2 (27))\", P, Designated_Type (Typ));\n                   end if;\n@@ -7511,7 +7623,7 @@ package body Sem_Attr is\n                                 not Has_Constrained_Partial_View\n                                       (Designated_Type (Base_Type (Typ)))))\n                then\n-                  Error_Msg_N\n+                  Error_Msg_F\n                     (\"object subtype must statically match \"\n                      & \"designated subtype\", P);\n \n@@ -7552,17 +7664,19 @@ package body Sem_Attr is\n                if Is_Entity_Name (P)\n                  and then not Is_Protected_Type (Scope (Entity (P)))\n                then\n-                  Error_Msg_N (\"context requires a protected subprogram\", P);\n+                  Error_Msg_F (\"context requires a protected subprogram\", P);\n \n                --  Check accessibility of protected object against that\n                --  of the access type, but only on user code, because\n                --  the expander creates access references for handlers.\n                --  If the context is an anonymous_access_to_protected,\n                --  there are no accessibility checks either.\n+               --  Omit check altogether for GNAT Unrestricted_Access.\n \n                elsif Object_Access_Level (P) > Type_Access_Level (Btyp)\n                  and then Comes_From_Source (N)\n                  and then Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n+                 and then Attr_Id /= Attribute_Unrestricted_Access\n                then\n                   Accessibility_Message;\n                   return;\n@@ -7573,7 +7687,7 @@ package body Sem_Attr is\n                    Ekind (Btyp) = E_Anonymous_Access_Subprogram_Type)\n               and then Ekind (Etype (N)) = E_Access_Protected_Subprogram_Type\n             then\n-               Error_Msg_N (\"context requires a non-protected subprogram\", P);\n+               Error_Msg_F (\"context requires a non-protected subprogram\", P);\n             end if;\n \n             --  The context cannot be a pool-specific type, but this is a\n@@ -7586,22 +7700,27 @@ package body Sem_Attr is\n                Wrong_Type (N, Typ);\n             end if;\n \n-            Set_Etype (N, Typ);\n+            --  The context may be a constrained access type (however ill-\n+            --  advised such subtypes might be) so in order to generate a\n+            --  constraint check when needed set the type of the attribute\n+            --  reference to the base type of the context.\n+\n+            Set_Etype (N, Btyp);\n \n             --  Check for incorrect atomic/volatile reference (RM C.6(12))\n \n             if Attr_Id /= Attribute_Unrestricted_Access then\n                if Is_Atomic_Object (P)\n                  and then not Is_Atomic (Designated_Type (Typ))\n                then\n-                  Error_Msg_N\n+                  Error_Msg_F\n                     (\"access to atomic object cannot yield access-to-\" &\n                      \"non-atomic type\", P);\n \n                elsif Is_Volatile_Object (P)\n                  and then not Is_Volatile (Designated_Type (Typ))\n                then\n-                  Error_Msg_N\n+                  Error_Msg_F\n                     (\"access to volatile object cannot yield access-to-\" &\n                      \"non-volatile type\", P);\n                end if;\n@@ -7631,9 +7750,8 @@ package body Sem_Attr is\n \n                if Present (It.Nam) then\n                   Error_Msg_Name_1 := Aname;\n-                  Error_Msg_N\n+                  Error_Msg_F\n                     (\"prefix of % attribute cannot be overloaded\", P);\n-                  return;\n                end if;\n             end if;\n \n@@ -7994,9 +8112,23 @@ package body Sem_Attr is\n       end case;\n \n       --  Normally the Freezing is done by Resolve but sometimes the Prefix\n-      --  is not resolved, in which case the freezing must be done now.\n+      --  is not resolved, in which case the freezing must be done now. The\n+      --  exception to this general rule is the use of 'Address with\n+      --  subprograms (this is required by the backend to support the static\n+      --  allocation of the dispatch tables).\n+\n+      if Static_Dispatch_Tables\n+        and then Nkind (P) in N_Has_Entity\n+        and then not Is_Frozen (Entity (P))\n+        and then Attr_Id = Attribute_Address\n+        and then Is_Subprogram (Entity (P))\n+        and then Is_Dispatching_Operation (Entity (P))\n+      then\n+         Set_Has_Delayed_Freeze (Entity (P));\n \n-      Freeze_Expression (P);\n+      else\n+         Freeze_Expression (P);\n+      end if;\n \n       --  Finally perform static evaluation on the attribute reference\n "}, {"sha": "6e15eaf720d98a25a8dd6d62af5247e4ada48a5d", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=822033ebf3b7ac6a0da5c6cde4a9e1f68b2d5a56", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,6 +32,7 @@\n --  This spec also documents all GNAT implementation defined pragmas\n \n with Exp_Tss; use Exp_Tss;\n+with Namet;   use Namet;\n with Snames;  use Snames;\n with Types;   use Types;\n \n@@ -541,6 +542,19 @@ package Sem_Attr is\n    --  in appropriate contexts (i.e. in subtype marks, or as prefixes for\n    --  other attributes).\n \n+   function Name_Modifies_Prefix (Nam : Name_Id) return Boolean;\n+   --  Determine whether the name of an attribute reference modifies the\n+   --  contents of its prefix. \"Read\" is such an attribute.\n+\n+   function Requires_Simple_Name_Prefix (Nam : Name_Id) return Boolean;\n+   --  Determine whether the name of an attribute reference requires a simple\n+   --  name rather than a value as its prefix. Such prefixes do not need to be\n+   --  optimized. For instance in the following example:\n+   --     I : constant Integer := 5;\n+   --     S : constant Integer := I'Size;\n+   --  \"Size\" requires a simple name prefix since \"5'Size\" does not make\n+   --  sense.\n+\n    procedure Resolve_Attribute (N : Node_Id; Typ : Entity_Id);\n    --  Performs type resolution of attribute. If the attribute yields a\n    --  universal value, mark its type as that of the context. On the other"}]}