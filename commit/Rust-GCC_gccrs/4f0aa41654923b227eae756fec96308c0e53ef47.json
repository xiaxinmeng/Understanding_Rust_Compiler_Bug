{"sha": "4f0aa41654923b227eae756fec96308c0e53ef47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYwYWE0MTY1NDkyM2IyMjdlYWU3NTZmZWM5NjMwOGMwZTUzZWY0Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-07-28T08:20:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-07-28T08:20:09Z"}, "message": "call.c (conditional_conversion): Don't build BASE_CONVs for conversions between things that have the same type.\n\n\t* call.c (conditional_conversion): Don't build BASE_CONVs for\n\tconversions between things that have the same type.\n\t(build_conditional_expr): Tweak.\n\t(convert_like): Some BASE_CONVs really do require the generation\n\tof code.\n\n\t* init.c (perform_member_init): Don't go through build_modify_expr\n\tfor simple initializations.\n\nFrom-SVN: r28310", "tree": {"sha": "ec3157e90ada3b76e2cacb25e81cf9dda4a08fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec3157e90ada3b76e2cacb25e81cf9dda4a08fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f0aa41654923b227eae756fec96308c0e53ef47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0aa41654923b227eae756fec96308c0e53ef47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0aa41654923b227eae756fec96308c0e53ef47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0aa41654923b227eae756fec96308c0e53ef47/comments", "author": null, "committer": null, "parents": [{"sha": "f66bbb410c40ea0a010329ecacb56b8214853d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f66bbb410c40ea0a010329ecacb56b8214853d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f66bbb410c40ea0a010329ecacb56b8214853d26"}], "stats": {"total": 134, "additions": 116, "deletions": 18}, "files": [{"sha": "3c7ddbd7f950e8af5dad505a68c03defe7a39936", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4f0aa41654923b227eae756fec96308c0e53ef47", "patch": "@@ -1,3 +1,14 @@\n+1999-07-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (conditional_conversion): Don't build BASE_CONVs for\n+\tconversions between things that have the same type.\n+\t(build_conditional_expr): Tweak.\n+\t(convert_like): Some BASE_CONVs really do require the generation\n+\tof code.\n+\t\n+\t* init.c (perform_member_init): Don't go through build_modify_expr\n+\tfor simple initializations.\n+\n 1999-07-27  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* cp-tree.h (DECL_VIRTUAL_CONTEXT): New macro."}, {"sha": "4deaac2d5b2df7d2bdf3387506efa5b1e5a0d405", "filename": "gcc/cp/call.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4f0aa41654923b227eae756fec96308c0e53ef47", "patch": "@@ -2716,7 +2716,9 @@ conditional_conversion (e1, e2)\n       if (at_least_as_qualified_p (t2, t1))\n \t{\n \t  conv = build1 (IDENTITY_CONV, t1, e1);\n-\t  conv = build_conv (BASE_CONV, t2, conv);\n+\t  if (!same_type_p (TYPE_MAIN_VARIANT (t1), \n+\t\t\t    TYPE_MAIN_VARIANT (t2)))\n+\t    conv = build_conv (BASE_CONV, t2, conv);\n \t  return conv;\n \t}\n       else\n@@ -2865,11 +2867,22 @@ build_conditional_expr (arg1, arg2, arg3)\n       else if (conv2 && !ICS_BAD_FLAG (conv2))\n \t{\n \t  arg2 = convert_like (conv2, arg2);\n+\t  /* That may not quite have done the trick.  If the two types\n+\t     are cv-qualified variants of one another, we will have\n+\t     just used an IDENTITY_CONV.  (There's no conversion from\n+\t     an lvalue of one class type to an lvalue of another type,\n+\t     even a cv-qualified variant, and we don't want to lose\n+\t     lvalue-ness here.)  So, we manually add a NOP_EXPR here\n+\t     if necessary.  */\n+\t  if (!same_type_p (TREE_TYPE (arg2), arg3_type))\n+\t    arg2 = build1 (NOP_EXPR, arg3_type, arg2);\n \t  arg2_type = TREE_TYPE (arg2);\n \t}\n       else if (conv3 && !ICS_BAD_FLAG (conv3))\n \t{\n \t  arg3 = convert_like (conv3, arg3);\n+\t  if (!same_type_p (TREE_TYPE (arg3), arg2_type))\n+\t    arg2 = build1 (NOP_EXPR, arg2_type, arg3);\n \t  arg3_type = TREE_TYPE (arg3);\n \t}\n     }\n@@ -3647,12 +3660,19 @@ convert_like (convs, expr)\n \treturn expr;\n       /* else fall through */\n     case BASE_CONV:\n-      if (TREE_CODE (convs) == BASE_CONV\n-\t  && !NEED_TEMPORARY_P (convs))\n-\t/* We are going to bind a reference directly to a base-class\n-\t   subobject of EXPR.  We don't have to generate any code\n-\t   here.  */\n-\treturn expr;\n+      if (TREE_CODE (convs) == BASE_CONV && !NEED_TEMPORARY_P (convs))\n+\t{\n+\t  /* We are going to bind a reference directly to a base-class\n+\t     subobject of EXPR.  */\n+\t  tree base_ptr = build_pointer_type (TREE_TYPE (convs));\n+\n+\t  /* Build an expression for `*((base*) &expr)'.  */\n+\t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n+\t  expr = perform_implicit_conversion (base_ptr, expr);\n+\t  expr = build_indirect_ref (expr, \"implicit conversion\");\n+\t  return expr;\n+\t}\n+\n       {\n \ttree cvt_expr = build_user_type_conversion\n \t  (TREE_TYPE (convs), expr, LOOKUP_NORMAL);"}, {"sha": "4163b1b894907e88f71e6f57ae49414eb0fc3410", "filename": "gcc/cp/init.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4f0aa41654923b227eae756fec96308c0e53ef47", "patch": "@@ -194,13 +194,21 @@ perform_member_init (member, name, init, explicit)\n \t    {\n \t      /* default-initialization.  */\n \t      if (AGGREGATE_TYPE_P (type))\n-\t\tinit = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n- \t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n \t\t{\n-\t\t  cp_error (\"default-initialization of `%#D', which has reference type\",\n-\t\t\t    member);\n-\t\t  init = error_mark_node;\n+\t\t  /* This is a default initialization of an aggregate,\n+\t\t     but not one of non-POD class type.  We cleverly\n+\t\t     notice that the initialization rules in such a\n+\t\t     case are the same as for initialization with an\n+\t\t     empty brace-initialization list.  We don't want\n+\t\t     to call build_modify_expr as that will go looking\n+\t\t     for constructors and such.  */\n+\t\t  tree e = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n+\t\t  TREE_SIDE_EFFECTS (e) = 1;\n+\t\t  expand_expr_stmt (build (INIT_EXPR, type, decl, e));\n \t\t}\n+ \t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\tcp_error (\"default-initialization of `%#D', which has reference type\",\n+\t\t\t  member);\n \t      else\n \t\tinit = integer_zero_node;\n \t    }\n@@ -221,12 +229,8 @@ perform_member_init (member, name, init, explicit)\n \t    init = TREE_VALUE (init);\n \t}\n \n-      /* We only build this with a null init if we got it from the\n-\t current_member_init_list.  */\n-      if (init || explicit)\n-\t{\n-\t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n-\t}\n+      if (init)\n+\texpand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n     }\n \n   expand_end_target_temps ();"}, {"sha": "a83273fa6749585e81c4b5ea9a84df5f28618988", "filename": "gcc/testsuite/g++.old-deja/g++.other/cond2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcond2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcond2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcond2.C?ref=4f0aa41654923b227eae756fec96308c0e53ef47", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+// Origin: Loring Holden <lsh@cs.brown.edu>\n+\n+class Wpt {};\n+\n+class RAYhit {\n+   protected:\n+      Wpt       _nearpt;\n+   public:\n+      Wpt       surf        () const { return true ? Wpt(): _nearpt; } \n+};"}, {"sha": "8c866d79e4b2cf7df8aa2ea615ac106e1fc08dcc", "filename": "gcc/testsuite/g++.old-deja/g++.other/init14.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit14.C?ref=4f0aa41654923b227eae756fec96308c0e53ef47", "patch": "@@ -0,0 +1,22 @@\n+// Build don't link:\n+// Origin: bkoz@nabi.net\n+\n+typedef struct\n+{\n+  int count;\n+} mbstate_t;\n+\n+struct fpos\n+{\n+  mbstate_t  _M_st;\n+  fpos(int __pos)\n+    : _M_st() { \n+  }\n+};\n+\n+int main ()\n+{\n+  fpos f (2);\n+}\n+\n+"}, {"sha": "6d615d4ce99d13d3e9547afd9a0931ef8cc7d599", "filename": "gcc/testsuite/g++.old-deja/g++.other/ref3.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fref3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0aa41654923b227eae756fec96308c0e53ef47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fref3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fref3.C?ref=4f0aa41654923b227eae756fec96308c0e53ef47", "patch": "@@ -0,0 +1,30 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct B1\n+{\n+  int i;\n+};\n+\n+struct B2\n+{\n+  int j;\n+};\n+\n+struct D: public B1, B2 \n+{\n+};\n+\n+bool f (B2& b)\n+{\n+  return b.j == 7;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  d.i = 2;\n+  d.j = 7;\n+  if (!f (d))\n+    return 1;\n+}\n+"}]}