{"sha": "c78d3425209f3c4ad529906bb43e7947f13311db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc4ZDM0MjUyMDlmM2M0YWQ1Mjk5MDZiYjQzZTc5NDdmMTMzMTFkYg==", "commit": {"author": {"name": "Alessandro Fanfarillo", "email": "afanfa@gcc.gnu.org", "date": "2019-09-26T19:59:00Z"}, "committer": {"name": "Alessandro Fanfarillo", "email": "afanfa@gcc.gnu.org", "date": "2019-09-26T19:59:00Z"}, "message": "CO_BROADCAST for derived types with allocatable components\n\nFrom-SVN: r276164", "tree": {"sha": "8228bfc87664a95593c50a8941124ff00f3e6dbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8228bfc87664a95593c50a8941124ff00f3e6dbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c78d3425209f3c4ad529906bb43e7947f13311db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78d3425209f3c4ad529906bb43e7947f13311db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c78d3425209f3c4ad529906bb43e7947f13311db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78d3425209f3c4ad529906bb43e7947f13311db/comments", "author": null, "committer": null, "parents": [{"sha": "9ab2f9aed07c3c02ee633801d30b86a216b4cc3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ab2f9aed07c3c02ee633801d30b86a216b4cc3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ab2f9aed07c3c02ee633801d30b86a216b4cc3b"}], "stats": {"total": 318, "additions": 260, "deletions": 58}, "files": [{"sha": "1c1997fb9eb19bf4a7efe0822333ec3158beecff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c78d3425209f3c4ad529906bb43e7947f13311db", "patch": "@@ -1,3 +1,17 @@\n+2019-09-26  Alessandro Fanfarillo  <afanfa@gcc.gnu.org>\n+\n+\t* trans-array.c (structure_alloc_comps):\n+\tAdd new enum item for BCAST_ALLOC_COMP.\n+\tNew argument for structure_alloc_comp, and new case to handle\n+\trecursive components in derived types.\n+\t* trans-array.c (gfc_bcast_alloc_comp): New function\n+\tused to handleco_broadcast for allocatable components\n+\tof derived types.\n+\t* trans-array.h: Add gfc_bcast_alloc_comp\n+\t* trans-intrinsics.c (conv_co_collective): Add check for\n+\tderived type variable and invocation of co_bcast_alloc_comp.\n+\t* trans.h: New data structure gfc_co_subroutines_args.\n+\n 2019-09-25  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR fortran/91426"}, {"sha": "07c4d7e671fd417c988e74d447f2201cbe9daaf0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 181, "deletions": 21, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c78d3425209f3c4ad529906bb43e7947f13311db", "patch": "@@ -8580,13 +8580,15 @@ gfc_caf_is_dealloc_only (int caf_mode)\n \n enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP,\n       COPY_ALLOC_COMP, COPY_ONLY_ALLOC_COMP, REASSIGN_CAF_COMP,\n-      ALLOCATE_PDT_COMP, DEALLOCATE_PDT_COMP, CHECK_PDT_DUMMY};\n+      ALLOCATE_PDT_COMP, DEALLOCATE_PDT_COMP, CHECK_PDT_DUMMY,\n+      BCAST_ALLOC_COMP};\n \n static gfc_actual_arglist *pdt_param_list;\n \n static tree\n structure_alloc_comps (gfc_symbol * der_type, tree decl,\n-\t\t       tree dest, int rank, int purpose, int caf_mode)\n+\t\t       tree dest, int rank, int purpose, int caf_mode,\n+\t\t       gfc_co_subroutines_args *args)\n {\n   gfc_component *c;\n   gfc_loopinfo loop;\n@@ -8672,14 +8674,14 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  && !caf_enabled (caf_mode))\n \t{\n \t  tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t gfc_conv_array_data (dest));\n+\t\t\t\t\t     gfc_conv_array_data (dest));\n \t  dref = gfc_build_array_ref (tmp, index, NULL);\n \t  tmp = structure_alloc_comps (der_type, vref, dref, rank,\n-\t\t\t\t       COPY_ALLOC_COMP, 0);\n+\t\t\t\t       COPY_ALLOC_COMP, 0, args);\n \t}\n       else\n \ttmp = structure_alloc_comps (der_type, vref, NULL_TREE, rank, purpose,\n-\t\t\t\t     caf_mode);\n+\t\t\t\t     caf_mode, args);\n \n       gfc_add_expr_to_block (&loopbody, tmp);\n \n@@ -8713,13 +8715,13 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   if (purpose == DEALLOCATE_ALLOC_COMP && der_type->attr.pdt_type)\n     {\n       tmp = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\t   DEALLOCATE_PDT_COMP, 0);\n+\t\t\t\t   DEALLOCATE_PDT_COMP, 0, args);\n       gfc_add_expr_to_block (&fnblock, tmp);\n     }\n   else if (purpose == ALLOCATE_PDT_COMP && der_type->attr.alloc_comp)\n     {\n       tmp = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\t   NULLIFY_ALLOC_COMP, 0);\n+\t\t\t\t   NULLIFY_ALLOC_COMP, 0, args);\n       gfc_add_expr_to_block (&fnblock, tmp);\n     }\n \n@@ -8741,6 +8743,125 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n       switch (purpose)\n \t{\n+\n+\tcase BCAST_ALLOC_COMP:\n+\n+\t  tree ubound;\n+\t  tree cdesc;\n+\t  stmtblock_t derived_type_block;\n+\n+\t  gfc_init_block (&tmpblock);\n+\n+\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n+\n+\t  /* Shortcut to get the attributes of the component.  */\n+\t  if (c->ts.type == BT_CLASS)\n+\t    {\n+\t      attr = &CLASS_DATA (c)->attr;\n+\t      if (attr->class_pointer)\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    {\n+\t      attr = &c->attr;\n+\t      if (attr->pointer)\n+\t\tcontinue;\n+\t    }\n+\n+\t  add_when_allocated = NULL_TREE;\n+\t  if (cmp_has_alloc_comps\n+\t      && !c->attr.pointer && !c->attr.proc_pointer)\n+\t    {\n+\t      if (c->ts.type == BT_CLASS)\n+\t\t{\n+\t\t  rank = CLASS_DATA (c)->as ? CLASS_DATA (c)->as->rank : 0;\n+\t\t  add_when_allocated\n+\t\t      = structure_alloc_comps (CLASS_DATA (c)->ts.u.derived,\n+\t\t\t\t\t       comp, NULL_TREE, rank, purpose,\n+\t\t\t\t\t       caf_mode, args);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rank = c->as ? c->as->rank : 0;\n+\t\t  add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n+\t\t\t\t\t\t\t      comp, NULL_TREE,\n+\t\t\t\t\t\t\t      rank, purpose,\n+\t\t\t\t\t\t\t      caf_mode, args);\n+\t\t}\n+\t    }\n+\n+\t  gfc_init_block (&derived_type_block);\n+\t  if (add_when_allocated)\n+\t    gfc_add_expr_to_block (&derived_type_block, add_when_allocated);\n+\t  tmp = gfc_finish_block (&derived_type_block);\n+\t  gfc_add_expr_to_block (&tmpblock, tmp);\n+\n+\t  /* Convert the component into a rank 1 descriptor type.  */\n+\t  if (attr->dimension)\n+\t    {\n+\t      tmp = gfc_get_element_type (TREE_TYPE (comp));\n+\t      ubound = gfc_full_array_size (&tmpblock, comp,\n+\t\t\t\t\t    c->ts.type == BT_CLASS\n+\t\t\t\t\t    ? CLASS_DATA (c)->as->rank\n+\t\t\t\t\t    : c->as->rank);\n+\t    }\n+\t  else\n+\t    {\n+\t      tmp = TREE_TYPE (comp);\n+\t      ubound = build_int_cst (gfc_array_index_type, 1);\n+\t    }\n+\n+\t  cdesc = gfc_get_array_type_bounds (tmp, 1, 0, &gfc_index_one_node,\n+\t\t\t\t\t     &ubound, 1,\n+\t\t\t\t\t     GFC_ARRAY_ALLOCATABLE, false);\n+\n+\t  cdesc = gfc_create_var (cdesc, \"cdesc\");\n+\t  DECL_ARTIFICIAL (cdesc) = 1;\n+  \n+\t  gfc_add_modify (&tmpblock, gfc_conv_descriptor_dtype (cdesc),\n+\t  \t\t  gfc_get_dtype_rank_type (1, tmp));\n+\t  gfc_conv_descriptor_lbound_set (&tmpblock, cdesc,\n+\t\t\t\t\t  gfc_index_zero_node,\n+\t\t\t\t\t  gfc_index_one_node);\n+\t  gfc_conv_descriptor_stride_set (&tmpblock, cdesc,\n+\t\t\t\t\t  gfc_index_zero_node,\n+\t\t\t\t\t  gfc_index_one_node);\n+\t  gfc_conv_descriptor_ubound_set (&tmpblock, cdesc,\n+\t\t\t\t\t  gfc_index_zero_node, ubound);\n+  \n+\t  if (attr->dimension)\n+\t    comp = gfc_conv_descriptor_data_get (comp);\n+\t  else\n+\t    {\n+\t      gfc_se se;\n+\n+\t      gfc_init_se (&se, NULL);\n+\n+\t      comp = gfc_conv_scalar_to_descriptor (&se, comp,\n+\t      \t\t\t\t\t    c->ts.type == BT_CLASS\n+\t      \t\t\t\t\t    ? CLASS_DATA (c)->attr\n+\t      \t\t\t\t\t    : c->attr);\n+\t      comp = gfc_build_addr_expr (NULL_TREE, comp);\n+\t      gfc_add_block_to_block (&tmpblock, &se.pre);\n+\t    }\n+\n+\t  gfc_conv_descriptor_data_set (&tmpblock, cdesc, comp);\n+\n+\t  tree fndecl;\n+\n+\t  fndecl = build_call_expr_loc (input_location,\n+\t\t\t\t\tgfor_fndecl_co_broadcast, 5,\n+\t\t\t\t\tgfc_build_addr_expr (pvoid_type_node,cdesc),\n+\t\t\t\t\targs->image_index,\n+\t\t\t\t\tnull_pointer_node, null_pointer_node,\n+\t\t\t\t\tnull_pointer_node);\n+\n+\t  gfc_add_expr_to_block (&tmpblock, fndecl);\n+\t  gfc_add_block_to_block (&fnblock, &tmpblock);\n+\n+\t  break;\n+\n \tcase DEALLOCATE_ALLOC_COMP:\n \n \t  gfc_init_block (&tmpblock);\n@@ -8791,15 +8912,15 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t  add_when_allocated\n \t\t      = structure_alloc_comps (CLASS_DATA (c)->ts.u.derived,\n \t\t\t\t\t       comp, NULL_TREE, rank, purpose,\n-\t\t\t\t\t       caf_mode);\n+\t\t\t\t\t       caf_mode, args);\n \t\t}\n \t      else\n \t\t{\n \t\t  rank = c->as ? c->as->rank : 0;\n \t\t  add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n \t\t\t\t\t\t\t      comp, NULL_TREE,\n \t\t\t\t\t\t\t      rank, purpose,\n-\t\t\t\t\t\t\t      caf_mode);\n+\t\t\t\t\t\t\t      caf_mode, args);\n \t\t}\n \t    }\n \n@@ -9075,7 +9196,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n-\t\t\t\t\t   rank, purpose, caf_mode);\n+\t\t\t\t\t   rank, purpose, caf_mode, args);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  break;\n@@ -9110,7 +9231,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t{\n \t\t  tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,\n \t\t\t\t\t       rank, purpose, caf_mode\n-\t\t\t\t\t   | GFC_STRUCTURE_CAF_MODE_IN_COARRAY);\n+\t\t\t\t\t       | GFC_STRUCTURE_CAF_MODE_IN_COARRAY,\n+\t\t\t\t\t       args);\n \t\t  gfc_add_expr_to_block (&fnblock, tmp);\n \t\t}\n \t    }\n@@ -9230,7 +9352,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n \t\t\t\t\t\t\t  comp, dcmp,\n \t\t\t\t\t\t\t  rank, purpose,\n-\t\t\t\t\t\t\t  caf_mode);\n+\t\t\t\t\t\t\t  caf_mode, args);\n \t    }\n \t  else\n \t    add_when_allocated = NULL_TREE;\n@@ -9594,7 +9716,7 @@ gfc_nullify_alloc_comp (gfc_symbol * der_type, tree decl, int rank,\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n \t\t\t\tNULLIFY_ALLOC_COMP,\n-\t\t\t      GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode);\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode, NULL);\n }\n \n \n@@ -9607,9 +9729,47 @@ gfc_deallocate_alloc_comp (gfc_symbol * der_type, tree decl, int rank,\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n \t\t\t\tDEALLOCATE_ALLOC_COMP,\n-\t\t\t      GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode);\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode, NULL);\n }\n \n+tree\n+gfc_bcast_alloc_comp (gfc_symbol *derived, gfc_expr *expr, int rank,\n+\t\t      tree image_index, tree stat, tree errmsg,\n+\t\t      tree errmsg_len)\n+{\n+  tree tmp, array;\n+  gfc_se argse;\n+  stmtblock_t block, post_block;\n+  gfc_co_subroutines_args args;\n+\n+  args.image_index = image_index;\n+  args.stat = stat;\n+  args.errmsg = errmsg;\n+  args.errmsg = errmsg_len;\n+\n+  if (rank == 0)\n+    {\n+      gfc_start_block (&block);\n+      gfc_init_block (&post_block);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr (&argse, expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      gfc_add_block_to_block (&post_block, &argse.post);\n+      array = argse.expr;\n+    }\n+  else\n+    {\n+      gfc_init_se (&argse, NULL);\n+      argse.want_pointer = 1;\n+      gfc_conv_expr_descriptor (&argse, expr);\n+      array = argse.expr;\n+    }\n+\n+  tmp = structure_alloc_comps (derived, array, NULL_TREE, rank,\n+\t\t\t       BCAST_ALLOC_COMP,\n+  \t\t\t       GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY, &args);\n+  return tmp;\n+}\n \n /* Recursively traverse an object of derived type, generating code to\n    deallocate allocatable components.  But do not deallocate coarrays.\n@@ -9620,15 +9780,15 @@ tree\n gfc_deallocate_alloc_comp_no_caf (gfc_symbol * der_type, tree decl, int rank)\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\tDEALLOCATE_ALLOC_COMP, 0);\n+\t\t\t\tDEALLOCATE_ALLOC_COMP, 0, NULL);\n }\n \n \n tree\n gfc_reassign_alloc_comp_caf (gfc_symbol *der_type, tree decl, tree dest)\n {\n   return structure_alloc_comps (der_type, decl, dest, 0, REASSIGN_CAF_COMP,\n-\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY);\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY, NULL);\n }\n \n \n@@ -9640,7 +9800,7 @@ gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank,\n \t\t     int caf_mode)\n {\n   return structure_alloc_comps (der_type, decl, dest, rank, COPY_ALLOC_COMP,\n-\t\t\t\tcaf_mode);\n+\t\t\t\tcaf_mode, NULL);\n }\n \n \n@@ -9651,7 +9811,7 @@ tree\n gfc_copy_only_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n {\n   return structure_alloc_comps (der_type, decl, dest, rank,\n-\t\t\t\tCOPY_ONLY_ALLOC_COMP, 0);\n+\t\t\t\tCOPY_ONLY_ALLOC_COMP, 0, NULL);\n }\n \n \n@@ -9666,7 +9826,7 @@ gfc_allocate_pdt_comp (gfc_symbol * der_type, tree decl, int rank,\n   gfc_actual_arglist *old_param_list = pdt_param_list;\n   pdt_param_list = param_list;\n   res = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t       ALLOCATE_PDT_COMP, 0);\n+\t\t\t       ALLOCATE_PDT_COMP, 0, NULL);\n   pdt_param_list = old_param_list;\n   return res;\n }\n@@ -9678,7 +9838,7 @@ tree\n gfc_deallocate_pdt_comp (gfc_symbol * der_type, tree decl, int rank)\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\tDEALLOCATE_PDT_COMP, 0);\n+\t\t\t\tDEALLOCATE_PDT_COMP, 0, NULL);\n }\n \n \n@@ -9693,7 +9853,7 @@ gfc_check_pdt_dummy (gfc_symbol * der_type, tree decl, int rank,\n   gfc_actual_arglist *old_param_list = pdt_param_list;\n   pdt_param_list = param_list;\n   res = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t       CHECK_PDT_DUMMY, 0);\n+\t\t\t       CHECK_PDT_DUMMY, 0, NULL);\n   pdt_param_list = old_param_list;\n   return res;\n }"}, {"sha": "5a7eee7e305e1b3fbcb0cb3ada5dde92bac252e5", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=c78d3425209f3c4ad529906bb43e7947f13311db", "patch": "@@ -52,6 +52,8 @@ bool gfc_caf_is_dealloc_only (int);\n tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int, int cm = 0);\n \n tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int, int cm = 0);\n+tree gfc_bcast_alloc_comp (gfc_symbol *, gfc_expr *, int, tree,\n+\t\t\t   tree, tree, tree);\n tree gfc_deallocate_alloc_comp_no_caf (gfc_symbol *, tree, int);\n tree gfc_reassign_alloc_comp_caf (gfc_symbol *, tree, tree);\n "}, {"sha": "c2e0533393aa4bca54c72e2d0be6bf9482ff94b1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c78d3425209f3c4ad529906bb43e7947f13311db", "patch": "@@ -10786,13 +10786,12 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n     }\n }\n \n-\n static tree\n conv_co_collective (gfc_code *code)\n {\n   gfc_se argse;\n   stmtblock_t block, post_block;\n-  tree fndecl, array, strlen, image_index, stat, errmsg, errmsg_len;\n+  tree fndecl, array = NULL_TREE, strlen, image_index, stat, errmsg, errmsg_len;\n   gfc_expr *image_idx_expr, *stat_expr, *errmsg_expr, *opr_expr;\n \n   gfc_start_block (&block);\n@@ -10857,6 +10856,7 @@ conv_co_collective (gfc_code *code)\n       gfc_conv_expr_descriptor (&argse, code->ext.actual->expr);\n       array = argse.expr;\n     }\n+\n   gfc_add_block_to_block (&block, &argse.pre);\n   gfc_add_block_to_block (&post_block, &argse.post);\n \n@@ -10915,46 +10915,64 @@ conv_co_collective (gfc_code *code)\n       gcc_unreachable ();\n     }\n \n-  if (code->resolved_isym->id == GFC_ISYM_CO_SUM\n-      || code->resolved_isym->id == GFC_ISYM_CO_BROADCAST)\n-    fndecl = build_call_expr_loc (input_location, fndecl, 5, array,\n-\t\t\t\t  image_index, stat, errmsg, errmsg_len);\n-  else if (code->resolved_isym->id != GFC_ISYM_CO_REDUCE)\n-    fndecl = build_call_expr_loc (input_location, fndecl, 6, array, image_index,\n-\t\t\t\t  stat, errmsg, strlen, errmsg_len);\n+  gfc_symbol *derived = code->ext.actual->expr->ts.type == BT_DERIVED\n+    ? code->ext.actual->expr->ts.u.derived : NULL;\n+\n+  if (derived && derived->attr.alloc_comp\n+      && code->resolved_isym->id == GFC_ISYM_CO_BROADCAST)\n+    /* The derived type has the attribute 'alloc_comp'.  */\n+    {\n+      tree tmp = gfc_bcast_alloc_comp (derived, code->ext.actual->expr,\n+\t\t\t\t       code->ext.actual->expr->rank,\n+\t\t\t\t       image_index, stat, errmsg, errmsg_len);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n   else\n     {\n-      tree opr, opr_flags;\n-\n-      // FIXME: Handle TS29113's bind(C) strings with descriptor.\n-      int opr_flag_int;\n-      if (gfc_is_proc_ptr_comp (opr_expr))\n-\t{\n-\t  gfc_symbol *sym = gfc_get_proc_ptr_comp (opr_expr)->ts.interface;\n-\t  opr_flag_int = sym->attr.dimension\n-\t\t\t || (sym->ts.type == BT_CHARACTER\n-\t\t\t     && !sym->attr.is_bind_c)\n-\t\t\t ? GFC_CAF_BYREF : 0;\n-\t  opr_flag_int |= opr_expr->ts.type == BT_CHARACTER\n-\t\t\t  && !sym->attr.is_bind_c\n-\t\t\t  ? GFC_CAF_HIDDENLEN : 0;\n-\t  opr_flag_int |= sym->formal->sym->attr.value ? GFC_CAF_ARG_VALUE : 0;\n-\t}\n+      if (code->resolved_isym->id == GFC_ISYM_CO_SUM\n+\t  || code->resolved_isym->id == GFC_ISYM_CO_BROADCAST)\n+\tfndecl = build_call_expr_loc (input_location, fndecl, 5, array,\n+\t\t\t\t      image_index, stat, errmsg, errmsg_len);\n+      else if (code->resolved_isym->id != GFC_ISYM_CO_REDUCE)\n+\tfndecl = build_call_expr_loc (input_location, fndecl, 6, array,\n+\t\t\t\t      image_index, stat, errmsg,\n+\t\t\t\t      strlen, errmsg_len);\n       else\n \t{\n-\t  opr_flag_int = gfc_return_by_reference (opr_expr->symtree->n.sym)\n-\t\t\t ? GFC_CAF_BYREF : 0;\n-\t  opr_flag_int |= opr_expr->ts.type == BT_CHARACTER\n-\t\t\t  && !opr_expr->symtree->n.sym->attr.is_bind_c\n-\t\t\t  ? GFC_CAF_HIDDENLEN : 0;\n-\t  opr_flag_int |= opr_expr->symtree->n.sym->formal->sym->attr.value\n-\t\t\t  ? GFC_CAF_ARG_VALUE : 0;\n+\t  tree opr, opr_flags;\n+\n+\t  // FIXME: Handle TS29113's bind(C) strings with descriptor.\n+\t  int opr_flag_int;\n+\t  if (gfc_is_proc_ptr_comp (opr_expr))\n+\t    {\n+\t      gfc_symbol *sym = gfc_get_proc_ptr_comp (opr_expr)->ts.interface;\n+\t      opr_flag_int = sym->attr.dimension\n+\t\t|| (sym->ts.type == BT_CHARACTER\n+\t\t    && !sym->attr.is_bind_c)\n+\t\t? GFC_CAF_BYREF : 0;\n+\t      opr_flag_int |= opr_expr->ts.type == BT_CHARACTER\n+\t\t&& !sym->attr.is_bind_c\n+\t\t? GFC_CAF_HIDDENLEN : 0;\n+\t      opr_flag_int |= sym->formal->sym->attr.value\n+\t\t? GFC_CAF_ARG_VALUE : 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      opr_flag_int = gfc_return_by_reference (opr_expr->symtree->n.sym)\n+\t\t? GFC_CAF_BYREF : 0;\n+\t      opr_flag_int |= opr_expr->ts.type == BT_CHARACTER\n+\t\t&& !opr_expr->symtree->n.sym->attr.is_bind_c\n+\t\t? GFC_CAF_HIDDENLEN : 0;\n+\t      opr_flag_int |= opr_expr->symtree->n.sym->formal->sym->attr.value\n+\t\t? GFC_CAF_ARG_VALUE : 0;\n+\t    }\n+\t  opr_flags = build_int_cst (integer_type_node, opr_flag_int);\n+\t  gfc_conv_expr (&argse, opr_expr);\n+\t  opr = argse.expr;\n+\t  fndecl = build_call_expr_loc (input_location, fndecl, 8, array, opr,\n+\t\t\t\t\topr_flags, image_index, stat, errmsg,\n+\t\t\t\t\tstrlen, errmsg_len);\n \t}\n-      opr_flags = build_int_cst (integer_type_node, opr_flag_int);\n-      gfc_conv_expr (&argse, opr_expr);\n-      opr = argse.expr;\n-      fndecl = build_call_expr_loc (input_location, fndecl, 8, array, opr, opr_flags,\n-\t\t\t\t    image_index, stat, errmsg, strlen, errmsg_len);\n     }\n \n   gfc_add_expr_to_block (&block, fndecl);"}, {"sha": "84793dc1df03687d7c00c5c6bbdc178753be704e", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78d3425209f3c4ad529906bb43e7947f13311db/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=c78d3425209f3c4ad529906bb43e7947f13311db", "patch": "@@ -107,6 +107,14 @@ typedef struct gfc_se\n }\n gfc_se;\n \n+typedef struct gfc_co_subroutines_args\n+{\n+  tree image_index;\n+  tree stat;\n+  tree errmsg;\n+  tree errmsg_len;\n+}\n+gfc_co_subroutines_args;\n \n /* Denotes different types of coarray.\n    Please keep in sync with libgfortran/caf/libcaf.h.  */"}]}