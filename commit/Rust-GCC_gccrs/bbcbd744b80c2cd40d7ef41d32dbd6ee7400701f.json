{"sha": "bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJjYmQ3NDRiODBjMmNkNDBkN2VmNDFkMzJkYmQ2ZWU3NDAwNzAxZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-08-17T04:01:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-08-17T04:01:14Z"}, "message": "re PR tree-optimization/86853 (sprintf optimization for wide strings doesn't account for conversion failure)\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/86853\n\t* gimple-ssa-sprintf.c (struct format_result): Rename member.\n\t(struct fmtresult): Add member and initialize it in ctors.\n\t(format_character): Handle %C.  Extend range to NUL.  Set MAYFAIL.\n\t(format_string): Handle %S the same as %ls.  Set MAYFAIL.\n\t(format_directive): Set POSUNDER4K when MAYFAIL is set.\n\t(parse_directive): Handle %C same as %c.\n\t(sprintf_dom_walker::compute_format_length): Adjust.\n\t(is_call_safe): Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/86853\n\t* gcc.dg/tree-ssa/builtin-sprintf-10.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-11.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-18.c: Adjust.\n\nFrom-SVN: r263612", "tree": {"sha": "41aaf431ca5d1badf20f6186830991a73761cee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41aaf431ca5d1badf20f6186830991a73761cee6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e584cd3509e56990aaf64b7e0b28881051483cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e584cd3509e56990aaf64b7e0b28881051483cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e584cd3509e56990aaf64b7e0b28881051483cb5"}], "stats": {"total": 281, "additions": 259, "deletions": 22}, "files": [{"sha": "9af07fc3a2fb07ceb9fa3f4f72c224d2439ac1e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "patch": "@@ -1,3 +1,15 @@\n+2018-08-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/86853\n+\t* gimple-ssa-sprintf.c (struct format_result): Rename member.\n+\t(struct fmtresult): Add member and initialize it in ctors.\n+\t(format_character): Handle %C.  Extend range to NUL.  Set MAYFAIL.\n+\t(format_string): Handle %S the same as %ls.  Set MAYFAIL.\n+\t(format_directive): Set POSUNDER4K when MAYFAIL is set.\n+\t(parse_directive): Handle %C same as %c.\n+\t(sprintf_dom_walker::compute_format_length): Adjust.\n+\t(is_call_safe): Adjust.\n+\n 2018-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* builtins.c (c_strlen): Add new parameter eltsize.  Use it"}, {"sha": "b5e1a08a88b769b75c7a91479f234150117cec31", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 53, "deletions": 20, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "patch": "@@ -211,12 +211,14 @@ struct format_result\n      the return value optimization.  */\n   bool knownrange;\n \n-  /* True if no individual directive resulted in more than 4095 bytes\n-     of output (the total NUMBER_CHARS_{MIN,MAX} might be greater).\n-     Implementations are not required to handle directives that produce\n-     more than 4K bytes (leading to undefined behavior) and so when one\n-     is found it disables the return value optimization.  */\n-  bool under4k;\n+  /* True if no individual directive could fail or result in more than\n+     4095 bytes of output (the total NUMBER_CHARS_{MIN,MAX} might be\n+     greater).  Implementations are not required to handle directives\n+     that produce more than 4K bytes (leading to undefined behavior)\n+     and so when one is found it disables the return value optimization.\n+     Similarly, directives that can fail (such as wide character\n+     directives) disable the optimization.  */\n+  bool posunder4k;\n \n   /* True when a floating point directive has been seen in the format\n      string.  */\n@@ -651,7 +653,7 @@ struct fmtresult\n   fmtresult (unsigned HOST_WIDE_INT min = HOST_WIDE_INT_MAX)\n   : argmin (), argmax (),\n     knownrange (min < HOST_WIDE_INT_MAX),\n-    nullp ()\n+    mayfail (), nullp ()\n   {\n     range.min = min;\n     range.max = min;\n@@ -665,7 +667,7 @@ struct fmtresult\n \t     unsigned HOST_WIDE_INT likely = HOST_WIDE_INT_MAX)\n   : argmin (), argmax (),\n     knownrange (min < HOST_WIDE_INT_MAX && max < HOST_WIDE_INT_MAX),\n-    nullp ()\n+    mayfail (), nullp ()\n   {\n     range.min = min;\n     range.max = max;\n@@ -695,6 +697,10 @@ struct fmtresult\n      heuristics that depend on warning levels.  */\n   bool knownrange;\n \n+  /* True for a directive that may fail (such as wide character\n+     directives).  */\n+  bool mayfail;\n+\n   /* True when the argument is a null pointer.  */\n   bool nullp;\n };\n@@ -2210,7 +2216,8 @@ format_character (const directive &dir, tree arg, vr_values *vr_values)\n \n   res.knownrange = true;\n \n-  if (dir.modifier == FMT_LEN_l)\n+  if (dir.specifier == 'C'\n+      || dir.modifier == FMT_LEN_l)\n     {\n       /* A wide character can result in as few as zero bytes.  */\n       res.range.min = 0;\n@@ -2225,13 +2232,20 @@ format_character (const directive &dir, tree arg, vr_values *vr_values)\n \t      res.range.likely = 0;\n \t      res.range.unlikely = 0;\n \t    }\n-\t  else if (min > 0 && min < 128)\n+\t  else if (min >= 0 && min < 128)\n \t    {\n+\t      /* Be conservative if the target execution character set\n+\t\t is not a 1-to-1 mapping to the source character set or\n+\t\t if the source set is not ASCII.  */\n+\t      bool one_2_one_ascii\n+\t\t= (target_to_host_charmap[0] == 1 && target_to_host ('a') == 97);\n+\n \t      /* A wide character in the ASCII range most likely results\n \t\t in a single byte, and only unlikely in up to MB_LEN_MAX.  */\n-\t      res.range.max = 1;\n+\t      res.range.max = one_2_one_ascii ? 1 : target_mb_len_max ();;\n \t      res.range.likely = 1;\n \t      res.range.unlikely = target_mb_len_max ();\n+\t      res.mayfail = !one_2_one_ascii;\n \t    }\n \t  else\n \t    {\n@@ -2240,6 +2254,8 @@ format_character (const directive &dir, tree arg, vr_values *vr_values)\n \t      res.range.max = target_mb_len_max ();\n \t      res.range.likely = 2;\n \t      res.range.unlikely = res.range.max;\n+\t      /* Converting such a character may fail.  */\n+\t      res.mayfail = true;\n \t    }\n \t}\n       else\n@@ -2249,6 +2265,7 @@ format_character (const directive &dir, tree arg, vr_values *vr_values)\n \t  res.range.max = target_mb_len_max ();\n \t  res.range.likely = 2;\n \t  res.range.unlikely = res.range.max;\n+\t  res.mayfail = true;\n \t}\n     }\n   else\n@@ -2285,7 +2302,8 @@ format_string (const directive &dir, tree arg, vr_values *)\n       /* A '%s' directive with a string argument with constant length.  */\n       res.range = slen.range;\n \n-      if (dir.modifier == FMT_LEN_l)\n+      if (dir.specifier == 'S'\n+\t  || dir.modifier == FMT_LEN_l)\n \t{\n \t  /* In the worst case the length of output of a wide string S\n \t     is bounded by MB_LEN_MAX * wcslen (S).  */\n@@ -2311,6 +2329,10 @@ format_string (const directive &dir, tree arg, vr_values *)\n \t  /* Even a non-empty wide character string need not convert into\n \t     any bytes.  */\n \t  res.range.min = 0;\n+\n+\t  /* A non-empty wide character conversion may fail.  */\n+\t  if (slen.range.max > 0)\n+\t    res.mayfail = true;\n \t}\n       else\n \t{\n@@ -2349,7 +2371,8 @@ format_string (const directive &dir, tree arg, vr_values *)\n \t at level 2.  This result is adjust upward for width (if it's\n \t specified).  */\n \n-      if (dir.modifier == FMT_LEN_l)\n+      if (dir.specifier == 'S'\n+\t  || dir.modifier == FMT_LEN_l)\n \t{\n \t  /* A wide character converts to as few as zero bytes.  */\n \t  slen.range.min = 0;\n@@ -2361,6 +2384,10 @@ format_string (const directive &dir, tree arg, vr_values *)\n \n \t  if (slen.range.likely < target_int_max ())\n \t    slen.range.unlikely *= target_mb_len_max ();\n+\n+\t  /* A non-empty wide character conversion may fail.  */\n+\t  if (slen.range.max > 0)\n+\t    res.mayfail = true;\n \t}\n \n       res.range = slen.range;\n@@ -2913,11 +2940,14 @@ format_directive (const sprintf_dom_walker::call_info &info,\n      of 4095 bytes required to be supported?  */\n   bool minunder4k = fmtres.range.min < 4096;\n   bool maxunder4k = fmtres.range.max < 4096;\n-  /* Clear UNDER4K in the overall result if the maximum has exceeded\n-     the 4k (this is necessary to avoid the return valuye optimization\n+  /* Clear POSUNDER4K in the overall result if the maximum has exceeded\n+     the 4k (this is necessary to avoid the return value optimization\n      that may not be safe in the maximum case).  */\n   if (!maxunder4k)\n-    res->under4k = false;\n+    res->posunder4k = false;\n+  /* Also clear POSUNDER4K if the directive may fail.  */\n+  if (fmtres.mayfail)\n+    res->posunder4k = false;\n \n   if (!warned\n       /* Only warn at level 2.  */\n@@ -3363,12 +3393,15 @@ parse_directive (sprintf_dom_walker::call_info &info,\n       dir.fmtfunc = format_none;\n       break;\n \n+    case 'C':\n     case 'c':\n+      /* POSIX wide character and C/POSIX narrow character.  */\n       dir.fmtfunc = format_character;\n       break;\n \n     case 'S':\n     case 's':\n+      /* POSIX wide string and C/POSIX narrow character string.  */\n       dir.fmtfunc = format_string;\n       break;\n \n@@ -3526,10 +3559,10 @@ sprintf_dom_walker::compute_format_length (call_info &info,\n   res->range.min = res->range.max = 0;\n \n   /* No directive has been seen yet so the length of output is bounded\n-     by the known range [0, 0] (with no conversion producing more than\n-     4K bytes) until determined otherwise.  */\n+     by the known range [0, 0] (with no conversion resulting in a failure\n+     or producing more than 4K bytes) until determined otherwise.  */\n   res->knownrange = true;\n-  res->under4k = true;\n+  res->posunder4k = true;\n   res->floating = false;\n   res->warned = false;\n \n@@ -3597,7 +3630,7 @@ is_call_safe (const sprintf_dom_walker::call_info &info,\n \t      const format_result &res, bool under4k,\n \t      unsigned HOST_WIDE_INT retval[2])\n {\n-  if (under4k && !res.under4k)\n+  if (under4k && !res.posunder4k)\n     return false;\n \n   /* The minimum return value.  */"}, {"sha": "abe919ebbb317a8a6501658ab695931c7342816e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "patch": "@@ -1,3 +1,10 @@\n+2018-08-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/86853\n+\t* gcc.dg/tree-ssa/builtin-sprintf-10.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-11.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-18.c: Adjust.\n+\n 2018-08-16  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/missing-header-fixit-3.c: New test."}, {"sha": "837b6f40c99196cb0effb33de7f3edaeb9871dc1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-10.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-10.c?ref=bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "patch": "@@ -0,0 +1,119 @@\n+/* PR tree-optimization/86853 - sprintf optimization for wide strings\n+   doesn't account for conversion failure\u00e2\u20ac\u2039\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__  size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+extern int snprintf (char*, size_t, const char*, ...);\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+/* Macro to emit a call to a function named\n+     call_made_in_{true,false}_branch_on_line_NNN()\n+   for each call that's expected to be retained.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that the expected number of both kinds of calls appears in output\n+   (a pair for each line with the invocation of the KEEP() macro.  */\n+#define KEEP(expr)\t\t\t\t\\\n+  if (expr)\t\t\t\t\t\\\n+    FAIL (made_in_true_branch);\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    FAIL (made_in_false_branch)\n+\n+\n+extern wchar_t wc;\n+extern wchar_t ws[];\n+\n+const wchar_t ws3[] = L\"12\\xff\";\n+\n+/* Verify that the following calls are eliminated.  */\n+\n+void elim_wide_char_call (void)\n+{\n+  ELIM (snprintf (0, 0, \"%lc\", L'\\0'));\n+  ELIM (snprintf (0, 0, \"%lc\", L'1'));\n+  ELIM (snprintf (0, 0, \"%lc\", L'a'));\n+  ELIM (snprintf (0, 0, \"%lc\", ws3[0]));\n+  ELIM (snprintf (0, 0, \"%lc\", ws3[1]));\n+  ELIM (snprintf (0, 0, \"%lc\", ws3[3]));\n+\n+  ELIM (snprintf (0, 0, \"%C\", L'\\0'));\n+  ELIM (snprintf (0, 0, \"%C\", L'9'));\n+  ELIM (snprintf (0, 0, \"%C\", L'z'));\n+  ELIM (snprintf (0, 0, \"%C\", ws3[0]));\n+  ELIM (snprintf (0, 0, \"%C\", ws3[1]));\n+  ELIM (snprintf (0, 0, \"%C\", ws3[3]));\n+\n+  /* Verify an unknown character value within the ASCII range.  */\n+  if (wc < 1 || 127 < wc)\n+    wc = 0;\n+\n+  ELIM (snprintf (0, 0, \"%C\", wc));\n+  ELIM (snprintf (0, 0, \"%C\", wc));\n+}\n+\n+void elim_wide_string_call (void)\n+{\n+  ELIM (snprintf (0, 0, \"%ls\", L\"\"));\n+}\n+\n+\n+#line 1000\n+\n+  /* Verify that the following calls are not eliminated.  */\n+\n+void keep_wide_char_call (void)\n+{\n+  KEEP (snprintf (0, 0, \"%lc\", L'\\xff'));\n+  KEEP (snprintf (0, 0, \"%lc\", L'\\xffff'));\n+  KEEP (snprintf (0, 0, \"%lc\", wc));\n+  KEEP (snprintf (0, 0, \"%lc\", ws3[2]));\n+\n+  KEEP (snprintf (0, 0, \"%C\", L'\\xff'));\n+  KEEP (snprintf (0, 0, \"%C\", L'\\xffff'));\n+  KEEP (snprintf (0, 0, \"%C\", wc));\n+  KEEP (snprintf (0, 0, \"%C\", ws3[2]));\n+\n+  /* Verify an unknown character value outside the ASCII range\n+     (with 128 being the only one).  */\n+  if (wc < 32 || 128 < wc)\n+    wc = 32;\n+\n+  KEEP (snprintf (0, 0, \"%lc\", wc));\n+  KEEP (snprintf (0, 0, \"%C\", wc));\n+}\n+\n+void keep_wide_string_call (void)\n+{\n+  KEEP (snprintf (0, 0, \"%ls\", L\"\\xff\"));\n+  KEEP (snprintf (0, 0, \"%ls\", L\"\\xffff\"));\n+  KEEP (snprintf (0, 0, \"%ls\", ws));\n+  KEEP (snprintf (0, 0, \"%ls\", ws3));\n+\n+  KEEP (snprintf (0, 0, \"%S\", L\"\\xff\"));\n+  KEEP (snprintf (0, 0, \"%S\", L\"\\xffff\"));\n+  KEEP (snprintf (0, 0, \"%S\", ws));\n+  KEEP (snprintf (0, 0, \"%S\", ws3));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"call_made_in_true_branch_not_eliminated\" 0 \"optimized\" } }\n+\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 18 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 18 \"optimized\" } } */"}, {"sha": "e1effe6834167fc59f4e4d2b063b2232e7c14549", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-11.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-11.c?ref=bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "patch": "@@ -0,0 +1,65 @@\n+/* PR tree-optimization/86853 - sprintf optimization for wide strings\n+   doesn't account for conversion failure\u00e2\u20ac\u2039\n+   Exercise wide character handling in an EBCDIC execution charset.\n+   { dg-do compile }\n+   { dg-require-iconv \"IBM1047\" }\n+   { dg-options \"-O2 -Wall -Wno-format -Wformat-overflow -fexec-charset=IBM1047 -fdump-tree-optimized\" } */\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+/* Exercise wide character constants. */\n+\n+void test_lc_cst (void)\n+{\n+  /* IBM1047 0x30 maps to ASCII 0x94 which neeed not be representable\n+     in the current locale (and the snprintf() call may fail).  Verify\n+     that snprintf() doesn't assume it is.  */\n+  wchar_t wc = 0x30;\n+\n+  int n = __builtin_snprintf (0, 0, \"%lc\", wc);\n+  if (n < 0)\n+    __builtin_abort ();\n+}\n+\n+void test_C_cst (void)\n+{\n+  /* Same as above but for %C and 0x31 which maps to 0x95.  */\n+  wchar_t wc = 0x31;\n+\n+  int n = __builtin_snprintf (0, 0, \"%C\", wc);\n+  if (n < 0)\n+    __builtin_abort ();\n+}\n+\n+/* Exercise wide character values in known ranges. */\n+\n+void test_lc_range (wchar_t wc)\n+{\n+  if (wc < 0x40 || 0x49 < wc)\n+    wc = 0x40;\n+\n+  int n = __builtin_snprintf (0, 0, \"%lc\", wc);\n+  if (n < 0)\n+    __builtin_abort ();\n+}\n+\n+void test_C_range (wchar_t wc)\n+{\n+  if (wc < 0x41 || 0x48 < wc)\n+    wc = 0x41;\n+\n+  int n = __builtin_snprintf (0, 0, \"%C\", wc);\n+  if (n < 0)\n+    __builtin_abort ();\n+}\n+\n+/* Exercise unknown wide character values. */\n+\n+void test_var (wchar_t wc)\n+{\n+  int n = __builtin_snprintf (0, 0, \"%lc\", wc);\n+  if (n < 0)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"abort\" 5 \"optimized\" } } */"}, {"sha": "7064f8a6d5862b6e35f504d871c5e36c2a365a3d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-18.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-18.c?ref=bbcbd744b80c2cd40d7ef41d32dbd6ee7400701f", "patch": "@@ -18,7 +18,7 @@ void test_characters ()\n   T (\"%A\",    0.0);   /* { dg-warning \".%A. directive writing between 6 and 20 \" } */\n   T (\"%a\",    0.0);   /* { dg-warning \".%a. directive writing between 6 and 20 \" } */\n \n-  T (\"%C\",    'a');   /* { dg-warning \".%C. directive writing 1 byte\" \"bug 80537\" { xfail *-*-* } } */\n+  T (\"%C\",   L'a');   /* { dg-warning \".%C. directive writing up to 6 bytes\" } */\n   T (\"%c\",    'a');   /* { dg-warning \".%c. directive writing 1 byte\" } */\n \n   T (\"%d\",     12);   /* { dg-warning \".%d. directive writing 2 bytes\" } */\n@@ -93,7 +93,8 @@ void test_characters ()\n   T (\"%x\",    1234);  /* { dg-warning \".%x. directive writing 3 bytes\" } */\n   T (\"%#X\",   1235);  /* { dg-warning \".%#X. directive writing 5 bytes\" } */\n \n-  T (\"%S\",    L\"1\");  /* { dg-warning \".%S. directive writing 1 byte\" } */\n+  T (\"%S\",    L\"1\");  /* { dg-warning \".%S. directive writing up to 6 bytes\" } */\n+  T (\"%ls\",  L\"12\");  /* { dg-warning \".%ls. directive writing up to 12 bytes\" } */\n   T (\"%-s\",    \"1\");  /* { dg-warning \".%-s. directive writing 1 byte\" } */\n \n   /* Verify that characters in the source character set appear in"}]}