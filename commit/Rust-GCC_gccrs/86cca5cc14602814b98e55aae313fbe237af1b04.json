{"sha": "86cca5cc14602814b98e55aae313fbe237af1b04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjY2E1Y2MxNDYwMjgxNGI5OGU1NWFhZTMxM2ZiZTIzN2FmMWIwNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-11T15:09:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-11T15:13:10Z"}, "message": "Fix PRE topological expression set sorting\n\nThis fixes sorted_array_from_bitmap_set to do a topological sort\nas required by re-using what PHI-translation does, namely a DFS\nwalk with the help of bitmap_find_leader.  The proper result\nis verified by extra checking in clean () (which would have tripped\nbefore) and for the testcase I'm working at during the last\npatches (PR97623) it is neutral in compile-time cost.\n\n2020-11-11  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (pre_expr_DFS): New function.\n\t(sorted_array_from_bitmap_set): Use it to properly\n\ttopologically sort the expression set.\n\t(clean): Verify we've cleaned everything we should.", "tree": {"sha": "ae6605d40549e2cda343c4e11c06fe3bed3ed126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae6605d40549e2cda343c4e11c06fe3bed3ed126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86cca5cc14602814b98e55aae313fbe237af1b04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cca5cc14602814b98e55aae313fbe237af1b04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86cca5cc14602814b98e55aae313fbe237af1b04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cca5cc14602814b98e55aae313fbe237af1b04/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "364ad1d44b43a22025814f7eb664173ce35b5878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/364ad1d44b43a22025814f7eb664173ce35b5878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/364ad1d44b43a22025814f7eb664173ce35b5878"}], "stats": {"total": 104, "additions": 84, "deletions": 20}, "files": [{"sha": "6dea8c28a1a62ec3e3e24560ff2a911f626b1537", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 84, "deletions": 20, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cca5cc14602814b98e55aae313fbe237af1b04/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cca5cc14602814b98e55aae313fbe237af1b04/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=86cca5cc14602814b98e55aae313fbe237af1b04", "patch": "@@ -806,36 +806,92 @@ bitmap_set_free (bitmap_set_t set)\n }\n \n \n+/* DFS walk EXPR to its operands with leaders in SET, collecting\n+   expressions in SET in postorder into POST.  */\n+\n+static void\n+pre_expr_DFS (pre_expr expr, bitmap_set_t set, bitmap visited,\n+\t      hash_set<int_hash<unsigned int, 0> > &leader_set,\n+\t      vec<pre_expr> &post)\n+{\n+  if (!bitmap_set_bit (visited, get_expression_id (expr)))\n+    return;\n+\n+  switch (expr->kind)\n+    {\n+    case NARY:\n+      {\n+\tvn_nary_op_t nary = PRE_EXPR_NARY (expr);\n+\tfor (unsigned i = 0; i < nary->length; i++)\n+\t  {\n+\t    if (TREE_CODE (nary->op[i]) != SSA_NAME)\n+\t      continue;\n+\t    unsigned int op_val_id = VN_INFO (nary->op[i])->value_id;\n+\t    /* If we already found a leader for the value we've\n+\t       recursed already.  Avoid the costly bitmap_find_leader.  */\n+\t    if (!leader_set.add (op_val_id))\n+\t      {\n+\t\tpre_expr leader = bitmap_find_leader (set, op_val_id);\n+\t\tif (leader)\n+\t\t  pre_expr_DFS (leader, set, visited, leader_set, post);\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+    case REFERENCE:\n+      {\n+\tvn_reference_t ref = PRE_EXPR_REFERENCE (expr);\n+\tvec<vn_reference_op_s> operands = ref->operands;\n+\tvn_reference_op_t operand;\n+\tfor (unsigned i = 0; operands.iterate (i, &operand); i++)\n+\t  {\n+\t    tree op[3];\n+\t    op[0] = operand->op0;\n+\t    op[1] = operand->op1;\n+\t    op[2] = operand->op2;\n+\t    for (unsigned n = 0; n < 3; ++n)\n+\t      {\n+\t\tif (!op[n] || TREE_CODE (op[n]) != SSA_NAME)\n+\t\t  continue;\n+\t\tunsigned op_val_id = VN_INFO (op[n])->value_id;\n+\t\tif (!leader_set.add (op_val_id))\n+\t\t  {\n+\t\t    pre_expr leader = bitmap_find_leader (set, op_val_id);\n+\t\t    if (leader)\n+\t\t      pre_expr_DFS (leader, set, visited, leader_set, post);\n+\t\t  }\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+    default:;\n+    }\n+  post.quick_push (expr);\n+}\n+\n /* Generate an topological-ordered array of bitmap set SET.  */\n \n static vec<pre_expr> \n sorted_array_from_bitmap_set (bitmap_set_t set)\n {\n-  unsigned int i, j;\n-  bitmap_iterator bi, bj;\n+  unsigned int i;\n+  bitmap_iterator bi;\n   vec<pre_expr> result;\n \n   /* Pre-allocate enough space for the array.  */\n-  result.create (bitmap_count_bits (&set->expressions));\n+  size_t len = bitmap_count_bits (&set->expressions);\n+  result.create (len);\n+  hash_set<int_hash<unsigned int, 0> > leader_set (2*len);\n \n-  FOR_EACH_VALUE_ID_IN_SET (set, i, bi)\n+  auto_bitmap visited (&grand_bitmap_obstack);\n+  bitmap_tree_view (visited);\n+  FOR_EACH_EXPR_ID_IN_SET (set, i, bi)\n     {\n-      /* The number of expressions having a given value is usually\n-\t relatively small.  Thus, rather than making a vector of all\n-\t the expressions and sorting it by value-id, we walk the values\n-\t and check in the reverse mapping that tells us what expressions\n-\t have a given value, to filter those in our set.  As a result,\n-\t the expressions are inserted in value-id order, which means\n-\t topological order.\n-\n-\t If this is somehow a significant lose for some cases, we can\n-\t choose which set to walk based on the set size.  */\n-      bitmap exprset = value_expressions[i];\n-      EXECUTE_IF_SET_IN_BITMAP (exprset, 0, j, bj)\n-\t{\n-\t  if (bitmap_bit_p (&set->expressions, j))\n-\t    result.quick_push (expression_for_id (j));\n-        }\n+      pre_expr expr = expression_for_id (i);\n+      /* Hoist insertion calls us with a value-set we have to and with,\n+\t do so.  */\n+      if (bitmap_set_contains_value (set, get_expr_value_id (expr)))\n+\tpre_expr_DFS (expr, set, visited, leader_set, result);\n     }\n \n   return result;\n@@ -1988,6 +2044,14 @@ clean (bitmap_set_t set1, bitmap_set_t set2 = NULL)\n \t}\n     }\n   exprs.release ();\n+\n+  if (flag_checking)\n+    {\n+      unsigned j;\n+      bitmap_iterator bi;\n+      FOR_EACH_EXPR_ID_IN_SET (set1, j, bi)\n+\tgcc_assert (valid_in_sets (set1, set2, expression_for_id (j)));\n+    }\n }\n \n /* Clean the set of expressions that are no longer valid in SET because"}]}