{"sha": "92b751fdc698c7b2040f986aaa125e4163003a2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJiNzUxZmRjNjk4YzdiMjA0MGY5ODZhYWExMjVlNDE2MzAwM2EyZA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-14T17:07:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-14T17:07:35Z"}, "message": "[multiple changes]\n\n2017-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* layout.ads (Set_Elem_Alignment): Add Align parameter defaulted to 0.\n\t* layout.adb (Set_Elem_Alignment): Likewise.  Use M name as maximum\n\talignment for consistency.  If Align is non-zero, use the minimum of\n\tAlign and M for the alignment.\n\t* cstand.adb (Build_Float_Type): Use Set_Elem_Alignment instead of\n\tsetting the alignment directly.\n\n2017-10-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case Check): Defer evaluation of the\n\toptional string in an Assert pragma until the expansion of the pragma\n\thas rewritten it as a conditional statement, so that the string\n\targument is only evaluaed if the assertion fails. This is mandated by\n\tRM 11.4.2.\n\n2017-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* debug.adb: Switch -gnatd.v and associated flag are now used to\n\tenforce the SPARK rules for elaboration in SPARK code.\n\t* sem_elab.adb: Describe switch -gnatd.v.\n\t(Process_Call): Verify the SPARK rules only when -gnatd.v is in effect.\n\t(Process_Instantiation): Verify the SPARK rules only when -gnatd.v is\n\tin effect.\n\t(Process_Variable_Assignment): Clarify why variable assignments are\n\tprocessed reglardless of whether -gnatd.v is in effect.\n\t* doc/gnat_ugn/elaboration_order_handling_in_gnat.rst: Update the\n\tsections on elaboration code and compilation switches.\n\t* gnat_ugn.texi: Regenerate.\n\n2017-10-14  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_util.adb, freeze.adb, sem_aggr.adb, sem_util.ads, sem_util.adb,\n\tsem_warn.adb: Minor reformattings.\n\nFrom-SVN: r253757", "tree": {"sha": "9877668163ec28526d8a074dc94e2f8c2e60e565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9877668163ec28526d8a074dc94e2f8c2e60e565"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92b751fdc698c7b2040f986aaa125e4163003a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b751fdc698c7b2040f986aaa125e4163003a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92b751fdc698c7b2040f986aaa125e4163003a2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b751fdc698c7b2040f986aaa125e4163003a2d/comments", "author": null, "committer": null, "parents": [{"sha": "2e60feb59198791c0a3b58838af26e6e5cd32677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e60feb59198791c0a3b58838af26e6e5cd32677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e60feb59198791c0a3b58838af26e6e5cd32677"}], "stats": {"total": 306, "additions": 244, "deletions": 62}, "files": [{"sha": "d0d17bacdb9f62f1865806c5eb8da16eee5bdf95", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -1,3 +1,39 @@\n+2017-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* layout.ads (Set_Elem_Alignment): Add Align parameter defaulted to 0.\n+\t* layout.adb (Set_Elem_Alignment): Likewise.  Use M name as maximum\n+\talignment for consistency.  If Align is non-zero, use the minimum of\n+\tAlign and M for the alignment.\n+\t* cstand.adb (Build_Float_Type): Use Set_Elem_Alignment instead of\n+\tsetting the alignment directly.\n+\n+2017-10-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Check): Defer evaluation of the\n+\toptional string in an Assert pragma until the expansion of the pragma\n+\thas rewritten it as a conditional statement, so that the string\n+\targument is only evaluaed if the assertion fails. This is mandated by\n+\tRM 11.4.2.\n+\n+2017-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* debug.adb: Switch -gnatd.v and associated flag are now used to\n+\tenforce the SPARK rules for elaboration in SPARK code.\n+\t* sem_elab.adb: Describe switch -gnatd.v.\n+\t(Process_Call): Verify the SPARK rules only when -gnatd.v is in effect.\n+\t(Process_Instantiation): Verify the SPARK rules only when -gnatd.v is\n+\tin effect.\n+\t(Process_Variable_Assignment): Clarify why variable assignments are\n+\tprocessed reglardless of whether -gnatd.v is in effect.\n+\t* doc/gnat_ugn/elaboration_order_handling_in_gnat.rst: Update the\n+\tsections on elaboration code and compilation switches.\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2017-10-14  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_util.adb, freeze.adb, sem_aggr.adb, sem_util.ads, sem_util.adb,\n+\tsem_warn.adb: Minor reformattings.\n+\n 2017-10-14  Ed Schonberg  <schonberg@adacore.com>\n \n \t* doc/gnat_rm/implementation_defined_aspects.rst: Add documentation"}, {"sha": "e45c0542f26784456efa380051ac7045cd1cdf4b", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -212,7 +212,7 @@ package body CStand is\n       Init_Digits_Value              (E, Digs);\n       Set_Float_Rep                  (E, Rep);\n       Init_Size                      (E, Siz);\n-      Set_Alignment                  (E, UI_From_Int (Align));\n+      Set_Elem_Alignment             (E, Align);\n       Set_Float_Bounds               (E);\n       Set_Is_Frozen                  (E);\n       Set_Is_Public                  (E);"}, {"sha": "2a812046247e22589da266808ff9e0ad599422c6", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -112,7 +112,7 @@ package body Debug is\n    --  d.s  Strict secondary stack management\n    --  d.t  Disable static allocation of library level dispatch tables\n    --  d.u  Enable Modify_Tree_For_C (update tree for c)\n-   --  d.v\n+   --  d.v  Enforce SPARK elaboration rules in SPARK code\n    --  d.w  Do not check for infinite loops\n    --  d.x  No exception handlers\n    --  d.y  Disable implicit pragma Elaborate_All on task bodies\n@@ -600,6 +600,13 @@ package body Debug is\n    --  d.u  Sets Modify_Tree_For_C mode in which tree is modified to make it\n    --       easier to generate code using a C compiler.\n \n+   --  d.v  This flag enforces the elaboration rules defined in the SPARK\n+   --       Reference Manual, chapter 7.7, to all SPARK code within a unit. As\n+   --       a result, constructs which violate the rules in chapter 7.7 are no\n+   --       longer accepted, even if the implementation is able to statically\n+   --       ensure that accepting these constructs does not introduce the\n+   --       possibility of failing an elaboration check.\n+\n    --  d.w  This flag turns off the scanning of loops to detect possible\n    --       infinite loops.\n "}, {"sha": "c45d3fcdbee8c7fd670ebdb641e68729726e318f", "filename": "gcc/ada/doc/gnat_ugn/elaboration_order_handling_in_gnat.rst", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -133,8 +133,43 @@ Elaboration Order\n =================\n \n The sequence by which the elaboration code of all units within a partition is\n-executed is referred to as **elaboration order**. The elaboration order depends\n-on the following factors:\n+executed is referred to as **elaboration order**.\n+\n+Within a single unit, elaboration code is executed in sequential order.\n+\n+::\n+\n+   package body Client is\n+      Result : ... := Server.Func;\n+\n+      procedure Proc is\n+         package Inst is new Server.Gen;\n+      begin\n+         Inst.Eval (Result);\n+      end Proc;\n+   begin\n+      Proc;\n+   end Client;\n+\n+In the example above, the elaboration order within package body ``Client`` is\n+as follows:\n+\n+1. The object declaration of ``Result`` is elaborated.\n+\n+   * Function ``Server.Func`` is invoked.\n+\n+2. The subprogram body of ``Proc`` is elaborated.\n+\n+3. Procedure ``Proc`` is invoked.\n+\n+   * Generic unit ``Server.Gen`` is instantiated as ``Inst``.\n+\n+   * Instance ``Inst`` is elaborated.\n+\n+   * Procedure ``Inst.Eval`` is invoked.\n+\n+The elaboration order of all units within a partition depends on the following\n+factors:\n \n * |withed| units\n \n@@ -571,7 +606,7 @@ elaboration order and to diagnose elaboration problems.\n   a partition is elaboration code. GNAT performs very few diagnostics and\n   generates run-time checks to verify the elaboration order of a program. This\n   behavior is identical to that specified by the Ada Reference Manual. The\n-  dynamic model is enabled with compilation switch :switch:`-gnatE`.\n+  dynamic model is enabled with compiler switch :switch:`-gnatE`.\n \n .. index:: Static elaboration model\n \n@@ -860,7 +895,7 @@ SPARK Elaboration Model in GNAT\n The SPARK model is identical to the static model in its handling of internal\n targets. The SPARK model, however, requires explicit ``Elaborate`` or\n ``Elaborate_All`` pragmas to be present in the program when a target is\n-external, and emits hard errors instead of warnings:\n+external, and compiler switch :switch:`-gnatd.v` is in effect.\n \n ::\n \n@@ -987,7 +1022,7 @@ available.\n * *Switch to more permissive elaboration model*\n \n   If the compilation was performed using the static model, enable the dynamic\n-  model with compilation switch :switch:`-gnatE`. GNAT will no longer generate\n+  model with compiler switch :switch:`-gnatE`. GNAT will no longer generate\n   implicit ``Elaborate`` and ``Elaborate_All`` pragmas, resulting in a behavior\n   identical to that specified by the Ada Reference Manual. The binder will\n   generate an executable program that may or may not raise ``Program_Error``,\n@@ -1504,6 +1539,17 @@ the elaboration order chosen by the binder.\n   When this switch is in effect, GNAT will ignore ``'Access`` of an entry,\n   operator, or subprogram when the static model is in effect.\n \n+.. index:: -gnatd.v  (gnat)\n+\n+:switch:`-gnatd.v`\n+  Enforce SPARK elaboration rules in SPARK code\n+\n+  When this switch is in effect, GNAT will enforce the SPARK rules of\n+  elaboration as defined in the SPARK Reference Manual, section 7.7. As a\n+  result, constructs which violate the SPARK elaboration rules are no longer\n+  accepted, even if GNAT is able to statically ensure that these constructs\n+  will not lead to ABE problems.\n+\n .. index:: -gnatd.y  (gnat)\n \n :switch:`-gnatd.y`\n@@ -1558,7 +1604,7 @@ the elaboration order chosen by the binder.\n   - *SPARK model*\n \n     GNAT will indicate how an elaboration requirement is met by the context of\n-    a unit.\n+    a unit. This diagnostic requires compiler switch :switch:`-gnatd.v`.\n \n     ::\n \n@@ -1612,8 +1658,8 @@ none of the binder or compiler switches. If the binder succeeds in finding an\n elaboration order, then apart from possible cases involing dispatching calls\n and access-to-subprogram types, the program is free of elaboration errors.\n If it is important for the program to be portable to compilers other than GNAT,\n-then the programmer should use compilation switch :switch:`-gnatel` and\n-consider the messages about missing or implicitly created ``Elaborate`` and\n+then the programmer should use compiler switch :switch:`-gnatel` and consider\n+the messages about missing or implicitly created ``Elaborate`` and\n ``Elaborate_All`` pragmas.\n \n If the binder reports an elaboration circularity, the programmer has several"}, {"sha": "d8ac4f8cea24a236e0b9de9c59cb4efc6eea05bf", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -11249,7 +11249,7 @@ package body Exp_Util is\n          --  Exp_Ch2.Expand_Renaming). Otherwise the temporary must be\n          --  elaborated by gigi, and is of course not to be replaced in-line\n          --  by the expression it renames, which would defeat the purpose of\n-         --  removing the side-effect.\n+         --  removing the side effect.\n \n          if Nkind_In (Exp, N_Selected_Component, N_Indexed_Component)\n            and then Has_Non_Standard_Rep (Etype (Prefix (Exp)))\n@@ -12650,7 +12650,7 @@ package body Exp_Util is\n            and then Variable_Ref\n          then\n             --  Exception is a prefix that is the result of a previous removal\n-            --  of side-effects.\n+            --  of side effects.\n \n             return Is_Entity_Name (Prefix (N))\n               and then not Comes_From_Source (Prefix (N))"}, {"sha": "a106d68ae8627934c5fe006dc2f8cbe0a64759e6", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -8450,7 +8450,7 @@ package body Freeze is\n             --  The analysis of the expression may generate insert actions,\n             --  which of course must not be executed. We wrap those actions\n             --  in a procedure that is not called, and later on eliminated.\n-            --  The following cases have no side-effects, and are analyzed\n+            --  The following cases have no side effects, and are analyzed\n             --  directly.\n \n             if Nkind (Dcopy) = N_Identifier"}, {"sha": "08e4b4bff94ab867a0ca80cf94a5542620faba02", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 79, "deletions": 9, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT User's Guide for Native Platforms , Oct 09, 2017\n+GNAT User's Guide for Native Platforms , Oct 14, 2017\n \n AdaCore\n \n@@ -27187,8 +27187,62 @@ elaborated.\n \n \n The sequence by which the elaboration code of all units within a partition is\n-executed is referred to as @strong{elaboration order}. The elaboration order depends\n-on the following factors:\n+executed is referred to as @strong{elaboration order}.\n+\n+Within a single unit, elaboration code is executed in sequential order.\n+\n+@example\n+package body Client is\n+   Result : ... := Server.Func;\n+\n+   procedure Proc is\n+      package Inst is new Server.Gen;\n+   begin\n+      Inst.Eval (Result);\n+   end Proc;\n+begin\n+   Proc;\n+end Client;\n+@end example\n+\n+In the example above, the elaboration order within package body @code{Client} is\n+as follows:\n+\n+\n+@enumerate \n+\n+@item \n+The object declaration of @code{Result} is elaborated.\n+\n+\n+@itemize *\n+\n+@item \n+Function @code{Server.Func} is invoked.\n+@end itemize\n+\n+@item \n+The subprogram body of @code{Proc} is elaborated.\n+\n+@item \n+Procedure @code{Proc} is invoked.\n+\n+\n+@itemize *\n+\n+@item \n+Generic unit @code{Server.Gen} is instantiated as @code{Inst}.\n+\n+@item \n+Instance @code{Inst} is elaborated.\n+\n+@item \n+Procedure @code{Inst.Eval} is invoked.\n+@end itemize\n+@end enumerate\n+\n+The elaboration order of all units within a partition depends on the following\n+factors:\n \n \n @itemize *\n@@ -27689,7 +27743,7 @@ dynamic model is in effect, GNAT assumes that all code within all units in\n a partition is elaboration code. GNAT performs very few diagnostics and\n generates run-time checks to verify the elaboration order of a program. This\n behavior is identical to that specified by the Ada Reference Manual. The\n-dynamic model is enabled with compilation switch @code{-gnatE}.\n+dynamic model is enabled with compiler switch @code{-gnatE}.\n @end itemize\n \n @geindex Static elaboration model\n@@ -28001,7 +28055,7 @@ elaborated prior to the body of @code{Static_Model}.\n The SPARK model is identical to the static model in its handling of internal\n targets. The SPARK model, however, requires explicit @code{Elaborate} or\n @code{Elaborate_All} pragmas to be present in the program when a target is\n-external, and emits hard errors instead of warnings:\n+external, and compiler switch @code{-gnatd.v} is in effect.\n \n @example\n 1. with Server;\n@@ -28146,7 +28200,7 @@ code.\n @emph{Switch to more permissive elaboration model}\n \n If the compilation was performed using the static model, enable the dynamic\n-model with compilation switch @code{-gnatE}. GNAT will no longer generate\n+model with compiler switch @code{-gnatE}. GNAT will no longer generate\n implicit @code{Elaborate} and @code{Elaborate_All} pragmas, resulting in a behavior\n identical to that specified by the Ada Reference Manual. The binder will\n generate an executable program that may or may not raise @code{Program_Error},\n@@ -28711,6 +28765,22 @@ When this switch is in effect, GNAT will ignore @code{'Access} of an entry,\n operator, or subprogram when the static model is in effect.\n @end table\n \n+@geindex -gnatd.v (gnat)\n+\n+\n+@table @asis\n+\n+@item @code{-gnatd.v}\n+\n+Enforce SPARK elaboration rules in SPARK code\n+\n+When this switch is in effect, GNAT will enforce the SPARK rules of\n+elaboration as defined in the SPARK Reference Manual, section 7.7. As a\n+result, constructs which violate the SPARK elaboration rules are no longer\n+accepted, even if GNAT is able to statically ensure that these constructs\n+will not lead to ABE problems.\n+@end table\n+\n @geindex -gnatd.y (gnat)\n \n \n@@ -28785,7 +28855,7 @@ it will provide detailed traceback when an implicit @code{Elaborate} or\n @emph{SPARK model}\n \n GNAT will indicate how an elaboration requirement is met by the context of\n-a unit.\n+a unit. This diagnostic requires compiler switch @code{-gnatd.v}.\n \n @example\n 1. with Server; pragma Elaborate_All (Server);\n@@ -28846,8 +28916,8 @@ none of the binder or compiler switches. If the binder succeeds in finding an\n elaboration order, then apart from possible cases involing dispatching calls\n and access-to-subprogram types, the program is free of elaboration errors.\n If it is important for the program to be portable to compilers other than GNAT,\n-then the programmer should use compilation switch @code{-gnatel} and\n-consider the messages about missing or implicitly created @code{Elaborate} and\n+then the programmer should use compiler switch @code{-gnatel} and consider\n+the messages about missing or implicitly created @code{Elaborate} and\n @code{Elaborate_All} pragmas.\n \n If the binder reports an elaboration circularity, the programmer has several"}, {"sha": "52e84526ca4e8935d98e348bf153f3ad00c8844e", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -843,7 +843,7 @@ package body Layout is\n    -- Set_Elem_Alignment --\n    ------------------------\n \n-   procedure Set_Elem_Alignment (E : Entity_Id) is\n+   procedure Set_Elem_Alignment (E : Entity_Id; Align : Nat := 0) is\n    begin\n       --  Do not set alignment for packed array types, this is handled in the\n       --  backend.\n@@ -869,15 +869,12 @@ package body Layout is\n          return;\n       end if;\n \n-      --  Here we calculate the alignment as the largest power of two multiple\n-      --  of System.Storage_Unit that does not exceed either the object size of\n-      --  the type, or the maximum allowed alignment.\n+      --  We attempt to set the alignment in all the other cases\n \n       declare\n          S : Int;\n          A : Nat;\n-\n-         Max_Alignment : Nat;\n+         M : Nat;\n \n       begin\n          --  The given Esize may be larger that int'last because of a previous\n@@ -908,7 +905,7 @@ package body Layout is\n            and then S = 8\n            and then Is_Floating_Point_Type (E)\n          then\n-            Max_Alignment := Ttypes.Target_Double_Float_Alignment;\n+            M := Ttypes.Target_Double_Float_Alignment;\n \n          --  If the default alignment of \"double\" or larger scalar types is\n          --  specifically capped, enforce the cap.\n@@ -917,18 +914,27 @@ package body Layout is\n            and then S >= 8\n            and then Is_Scalar_Type (E)\n          then\n-            Max_Alignment := Ttypes.Target_Double_Scalar_Alignment;\n+            M := Ttypes.Target_Double_Scalar_Alignment;\n \n          --  Otherwise enforce the overall alignment cap\n \n          else\n-            Max_Alignment := Ttypes.Maximum_Alignment;\n+            M := Ttypes.Maximum_Alignment;\n          end if;\n \n-         A := 1;\n-         while 2 * A <= Max_Alignment and then 2 * A <= S loop\n-            A := 2 * A;\n-         end loop;\n+         --  We calculate the alignment as the largest power-of-two multiple\n+         --  of System.Storage_Unit that does not exceed the object size of\n+         --  the type and the maximum allowed alignment, if none was specified.\n+         --  Otherwise we only cap it to the maximum allowed alignment.\n+\n+         if Align = 0 then\n+            A := 1;\n+            while 2 * A <= S and then 2 * A <= M loop\n+               A := 2 * A;\n+            end loop;\n+         else\n+            A := Nat'Min (Align, M);\n+         end if;\n \n          --  If alignment is currently not set, then we can safely set it to\n          --  this new calculated value."}, {"sha": "246970fd8fd9ba4fd58a53f05f64a5564044d623", "filename": "gcc/ada/layout.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Flayout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Flayout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.ads?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -74,10 +74,11 @@ package Layout is\n    --  types, the RM_Size is simply set to zero. This routine also sets\n    --  the Is_Constrained flag in Def_Id.\n \n-   procedure Set_Elem_Alignment (E : Entity_Id);\n+   procedure Set_Elem_Alignment (E : Entity_Id; Align : Nat := 0);\n    --  The front end always sets alignments for elementary types by calling\n    --  this procedure. Note that we have to do this for discrete types (since\n    --  the Alignment attribute is static), so we might as well do it for all\n-   --  elementary types, since the processing is the same.\n+   --  elementary types, as the processing is the same. If Align is nonzero,\n+   --  it is an external alignment setting that we must respect.\n \n end Layout;"}, {"sha": "6c29b38b93ad26ff8e561241c99c282c23915f0b", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -1594,7 +1594,7 @@ package body Sem_Aggr is\n             --  unless the expression covers a single component, or the\n             --  expander is inactive.\n \n-            --  In SPARK mode, expressions that can perform side-effects will\n+            --  In SPARK mode, expressions that can perform side effects will\n             --  be recognized by the gnat2why back-end, and the whole\n             --  subprogram will be ignored. So semantic analysis can be\n             --  performed safely.\n@@ -3605,7 +3605,7 @@ package body Sem_Aggr is\n                      --  This is redundant if the others_choice covers only\n                      --  one component (small optimization possible???), but\n                      --  indispensable otherwise, because each one must be\n-                     --  expanded individually to preserve side-effects.\n+                     --  expanded individually to preserve side effects.\n \n                      --  Ada 2005 (AI-287): In case of default initialization\n                      --  of components, we duplicate the corresponding default\n@@ -3881,7 +3881,7 @@ package body Sem_Aggr is\n          --  expansion is delayed until the enclosing aggregate is expanded\n          --  into assignments. In that case, do not generate checks on the\n          --  expression, because they will be generated later, and will other-\n-         --  wise force a copy (to remove side-effects) that would leave a\n+         --  wise force a copy (to remove side effects) that would leave a\n          --  dynamic-sized aggregate in the code, something that gigi cannot\n          --  handle.\n "}, {"sha": "7f5a3d6718ca9fc99a334c31aedb647f29237e3f", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -361,6 +361,13 @@ package body Sem_Elab is\n    --           entries, operators, and subprograms. As a result, the scenarios\n    --           are not recorder or processed.\n    --\n+   --  -gnatd.v enforce SPARK elaboration rules in SPARK code\n+   --\n+   --           The ABE mechanism applies some of the SPARK elaboration rules\n+   --           defined in the SPARK reference manual, chapter 7.7. Note that\n+   --           certain rules are always enforced, regardless of whether the\n+   --           switch is active.\n+   --\n    --  -gnatd.y disable implicit pragma Elaborate_All on task bodies\n    --\n    --           The ABE mechanism does not generate implicit Elaborate_All when\n@@ -6891,16 +6898,18 @@ package body Sem_Elab is\n       elsif Is_Up_Level_Target (Target_Attrs.Spec_Decl) then\n          return;\n \n-      --  The SPARK rules are in effect\n+      --  The SPARK rules are verified only when -gnatd.v (enforce SPARK\n+      --  elaboration rules in SPARK code) is in effect.\n \n-      elsif SPARK_Rules_On then\n+      elsif SPARK_Rules_On and Debug_Flag_Dot_V then\n          Process_Call_SPARK\n            (Call         => Call,\n             Call_Attrs   => Call_Attrs,\n             Target_Id    => Target_Id,\n             Target_Attrs => Target_Attrs);\n \n-      --  Otherwise the Ada rules are in effect\n+      --  Otherwise the Ada rules are in effect, or SPARK code is allowed to\n+      --  violate the SPARK rules.\n \n       else\n          Process_Call_Ada\n@@ -7459,17 +7468,19 @@ package body Sem_Elab is\n       elsif Is_Up_Level_Target (Gen_Attrs.Spec_Decl) then\n          return;\n \n-      --  The SPARK rules are in effect\n+      --  The SPARK rules are verified only when -gnatd.v (enforce SPARK\n+      --  elaboration rules in SPARK code) is in effect.\n \n-      elsif SPARK_Rules_On then\n+      elsif SPARK_Rules_On and Debug_Flag_Dot_V then\n          Process_Instantiation_SPARK\n            (Exp_Inst   => Exp_Inst,\n             Inst       => Inst,\n             Inst_Attrs => Inst_Attrs,\n             Gen_Id     => Gen_Id,\n             Gen_Attrs  => Gen_Attrs);\n \n-      --  Otherwise the Ada rules are in effect\n+      --  Otherwise the Ada rules are in effect, or SPARK code is allowed to\n+      --  violate the SPARK rules.\n \n       else\n          Process_Instantiation_Ada\n@@ -7869,7 +7880,10 @@ package body Sem_Elab is\n             In_SPARK => SPARK_Rules_On);\n       end if;\n \n-      --  The SPARK rules are in effect\n+      --  The SPARK rules are in effect. These rules are applied regardless of\n+      --  whether -gnatd.v (enforce SPARK elaboration rules in SPARK code) is\n+      --  in effect because the static model cannot ensure safe assignment of\n+      --  variables.\n \n       if SPARK_Rules_On then\n          Process_Variable_Assignment_SPARK"}, {"sha": "f0562ae59a6796634863e3aab623d1a3b81628d0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -13249,16 +13249,18 @@ package body Sem_Prag is\n                --  If checks are not on we don't want any expansion (since\n                --  such expansion would not get properly deleted) but\n                --  we do want to analyze (to get proper references).\n-               --  The Preanalyze_And_Resolve routine does just what we want\n+               --  The Preanalyze_And_Resolve routine does just what we want.\n+               --  Ditto if pragma is active, because it will be rewritten\n+               --  as an if-statement whose analysis will complete analysis\n+               --  and expansion of the string message. This makes a\n+               --  difference in the unusual case where the expression for\n+               --  the string may have a side effect, such as raising an\n+               --  exception. This is mandated by RM 11.4.2, which specifies\n+               --  that the string expression is only evaluated if the\n+               --  check fails and Assertion_Error is to be raised.\n+\n+               Preanalyze_And_Resolve (Str, Standard_String);\n \n-               if Is_Ignored (N) then\n-                  Preanalyze_And_Resolve (Str, Standard_String);\n-\n-                  --  Otherwise we need a proper analysis and expansion\n-\n-               else\n-                  Analyze_And_Resolve (Str, Standard_String);\n-               end if;\n             end if;\n \n             --  Now you might think we could just do the same with the Boolean"}, {"sha": "0eefd505c25defaad16ed0c4e27f041c2b81fb92", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -13387,7 +13387,7 @@ package body Sem_Util is\n                end if;\n \n             --  A discriminant check on a selected component may be expanded\n-            --  into a dereference when removing side-effects. Recover the\n+            --  into a dereference when removing side effects. Recover the\n             --  original node and its type, which may be unconstrained.\n \n             elsif Nkind (P) = N_Explicit_Dereference\n@@ -20648,7 +20648,7 @@ package body Sem_Util is\n       --  This construct appears in the context of dispatching calls.\n \n       function Reference_To (Obj : Node_Id) return Node_Id;\n-      --  An explicit dereference is created when removing side-effects from\n+      --  An explicit dereference is created when removing side effects from\n       --  expressions for constraint checking purposes. In this case a local\n       --  access type is created for it. The correct access level is that of\n       --  the original source node. We detect this case by noting that the"}, {"sha": "c6958cb1aaad96f0f347e8d4012b72dc66dffee1", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -2276,9 +2276,9 @@ package Sem_Util is\n    --      type of the other operand is a descendant of System.Address.\n \n    function Number_Of_Elements_In_Array (T : Entity_Id) return Int;\n-   --  Returns the number elements in the array T if the index bounds of T is\n-   --  known at compile time. If the bounds are not known at compile time, the\n-   --  function returns the value zero.\n+   --  Returns the number of elements in the array T if the index bounds of T\n+   --  is known at compile time. If the bounds are not known at compile time,\n+   --  the function returns the value zero.\n \n    function Object_Access_Level (Obj : Node_Id) return Uint;\n    --  Return the accessibility level of the view of the object Obj. For"}, {"sha": "0e498d3e6cb2cb8ba6b6ff669bf384e8edec7ad0", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b751fdc698c7b2040f986aaa125e4163003a2d/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=92b751fdc698c7b2040f986aaa125e4163003a2d", "patch": "@@ -509,7 +509,7 @@ package body Sem_Warn is\n             end if;\n \n             --  If the condition contains a function call, we consider it may\n-            --  be modified by side-effects from a procedure call. Otherwise,\n+            --  be modified by side effects from a procedure call. Otherwise,\n             --  we consider the condition may not be modified, although that\n             --  might happen if Variable is itself a by-reference parameter,\n             --  and the procedure called modifies the global object referred to"}]}