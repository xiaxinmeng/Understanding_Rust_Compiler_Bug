{"sha": "142d1f57d6c4a40bcf07a243bf71465bf72b1012", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyZDFmNTdkNmM0YTQwYmNmMDdhMjQzYmY3MTQ2NWJmNzJiMTAxMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-11-05T18:10:44Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-11-05T18:10:44Z"}, "message": "cfgloopanal.c (variable_initial_value, [...]): Record the fact that initial value is extended from inner mode.\n\n\t* cfgloopanal.c (variable_initial_value, variable_initial_values,\n\tsimple_loop_exit_p): Record the fact that initial value is extended\n\tfrom inner mode.\n\t(count_strange_loop_iterations, count_loop_iterations): Handle\n\tivs that iterate in a narrower mode. Fix handling of overflows.\n\tImprove handling of NE conditions.\n\t(inverse, fits_in_mode_p): New static functions.\n\t(simple_increment): Detect variables that iterate in a narrower mode.\n\t* cfgloop.h (struct loop_desc): Fields inner_mode and extend added.\n\nFrom-SVN: r73275", "tree": {"sha": "2803ac7a2623225480a95038c4747be2ab3b5082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2803ac7a2623225480a95038c4747be2ab3b5082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/142d1f57d6c4a40bcf07a243bf71465bf72b1012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142d1f57d6c4a40bcf07a243bf71465bf72b1012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142d1f57d6c4a40bcf07a243bf71465bf72b1012", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142d1f57d6c4a40bcf07a243bf71465bf72b1012/comments", "author": null, "committer": null, "parents": [{"sha": "af09332e6d6c7f4970b62d1549f5cf0192b7a718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af09332e6d6c7f4970b62d1549f5cf0192b7a718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af09332e6d6c7f4970b62d1549f5cf0192b7a718"}], "stats": {"total": 333, "additions": 284, "deletions": 49}, "files": [{"sha": "5c9c5efcd9d41759bacf9cb8b22089b9f86d689b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142d1f57d6c4a40bcf07a243bf71465bf72b1012/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142d1f57d6c4a40bcf07a243bf71465bf72b1012/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=142d1f57d6c4a40bcf07a243bf71465bf72b1012", "patch": "@@ -1,3 +1,15 @@\n+2003-11-05  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloopanal.c (variable_initial_value, variable_initial_values,\n+\tsimple_loop_exit_p): Record the fact that initial value is extended\n+\tfrom inner mode.\n+\t(count_strange_loop_iterations, count_loop_iterations): Handle\n+\tivs that iterate in a narrower mode. Fix handling of overflows.\n+\tImprove handling of NE conditions.\n+\t(inverse, fits_in_mode_p): New static functions.\n+\t(simple_increment): Detect variables that iterate in a narrower mode.\n+\t* cfgloop.h (struct loop_desc): Fields inner_mode and extend added.\n+\n 2003-11-05  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/rs6000/darwin.h (SUBTARGET_OVERRIDE_OPTIONS): Darwin"}, {"sha": "0ab1590c4ddd25af61dfc4a2f7ee8b6da4d2b9bc", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142d1f57d6c4a40bcf07a243bf71465bf72b1012/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142d1f57d6c4a40bcf07a243bf71465bf72b1012/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=142d1f57d6c4a40bcf07a243bf71465bf72b1012", "patch": "@@ -42,6 +42,9 @@ struct loop_desc\n   int postincr;\t\t/* 1 if increment/decrement is done after loop exit condition.  */\n   rtx stride;\t\t/* Value added to VAR in each iteration.  */\n   rtx var;\t\t/* Loop control variable.  */\n+  enum machine_mode inner_mode;\n+\t\t\t/* The mode from that it is extended.  */\n+  enum rtx_code extend;\t/* With this extend.  */\n   rtx var_alts;\t\t/* List of definitions of its initial value.  */\n   rtx lim;\t\t/* Expression var is compared with.  */\n   rtx lim_alts;\t\t/* List of definitions of its initial value.  */"}, {"sha": "03bf4db7d766d0f668ceb22fc1122ab7e3bb5fc6", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 269, "deletions": 49, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142d1f57d6c4a40bcf07a243bf71465bf72b1012/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142d1f57d6c4a40bcf07a243bf71465bf72b1012/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=142d1f57d6c4a40bcf07a243bf71465bf72b1012", "patch": "@@ -41,14 +41,35 @@ static bool constant_iterations (struct loop_desc *, unsigned HOST_WIDE_INT *,\n \t\t\t\t bool *);\n static bool simple_loop_exit_p (struct loops *, struct loop *, edge, regset,\n \t\t\t\trtx *, struct loop_desc *);\n-static rtx variable_initial_value (rtx, regset, rtx, rtx *);\n-static rtx variable_initial_values (edge, rtx);\n+static rtx variable_initial_value (rtx, regset, rtx, rtx *, enum machine_mode);\n+static rtx variable_initial_values (edge, rtx, enum machine_mode);\n static bool simple_condition_p (struct loop *, rtx, regset,\n \t\t\t\tstruct loop_desc *);\n static basic_block simple_increment (struct loops *, struct loop *, rtx *,\n \t\t\t\t     struct loop_desc *);\n static rtx count_strange_loop_iterations (rtx, rtx, enum rtx_code,\n-\t\t\t\t\t  int, rtx, enum machine_mode);\n+\t\t\t\t\t  int, rtx, enum machine_mode,\n+\t\t\t\t\t  enum machine_mode);\n+static unsigned HOST_WIDEST_INT inverse (unsigned HOST_WIDEST_INT, int);\n+static bool fits_in_mode_p (enum machine_mode mode, rtx expr);\n+\n+/* Computes inverse to X modulo (1 << MOD).  */\n+static unsigned HOST_WIDEST_INT\n+inverse (unsigned HOST_WIDEST_INT x, int mod)\n+{\n+  unsigned HOST_WIDEST_INT mask =\n+\t  ((unsigned HOST_WIDEST_INT) 1 << (mod - 1) << 1) - 1;\n+  unsigned HOST_WIDEST_INT rslt = 1;\n+  int i;\n+\n+  for (i = 0; i < mod - 1; i++)\n+    {\n+      rslt = (rslt * x) & mask;\n+      x = (x * x) & mask;\n+    }\n+\n+  return rslt;\n+}\n \n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n bool\n@@ -277,8 +298,8 @@ static basic_block\n simple_increment (struct loops *loops, struct loop *loop,\n \t\t  rtx *simple_increment_regs, struct loop_desc *desc)\n {\n-  rtx mod_insn, set, set_src, set_add;\n-  basic_block mod_bb;\n+  rtx mod_insn, mod_insn1, set, set_src, set_add;\n+  basic_block mod_bb, mod_bb1;\n \n   /* Find insn that modifies var.  */\n   mod_insn = simple_increment_regs[REGNO (desc->var)];\n@@ -300,6 +321,71 @@ simple_increment (struct loops *loops, struct loop *loop,\n   set_src = find_reg_equal_equiv_note (mod_insn);\n   if (!set_src)\n     set_src = SET_SRC (set);\n+\n+  /* Check for variables that iterate in narrower mode.  */\n+  if (GET_CODE (set_src) == SIGN_EXTEND\n+      || GET_CODE (set_src) == ZERO_EXTEND)\n+    {\n+      /* If we are sign extending variable that is then compared unsigned\n+\t or vice versa, there is something weird happening.  */\n+      if (desc->cond != EQ\n+\t  && desc->cond != NE\n+\t  && ((desc->cond == LEU\n+\t       || desc->cond == LTU\n+\t       || desc->cond == GEU\n+\t       || desc->cond == GTU)\n+\t      ^ (GET_CODE (set_src) == ZERO_EXTEND)))\n+\treturn NULL;\n+\n+      if (GET_CODE (XEXP (set_src, 0)) != SUBREG\n+\t  || SUBREG_BYTE (XEXP (set_src, 0)) != 0\n+\t  || GET_MODE (SUBREG_REG (XEXP (set_src, 0))) != GET_MODE (desc->var))\n+\treturn NULL;\n+\n+      desc->inner_mode = GET_MODE (XEXP (set_src, 0));\n+      desc->extend = GET_CODE (set_src);\n+      set_src = SUBREG_REG (XEXP (set_src, 0));\n+\n+      if (GET_CODE (set_src) != REG)\n+\treturn NULL;\n+\n+      /* Find where the reg is set.  */\n+      mod_insn1 = simple_increment_regs[REGNO (set_src)];\n+      if (!mod_insn1)\n+\treturn NULL;\n+\n+      mod_bb1 = BLOCK_FOR_INSN (mod_insn1);\n+      if (!dominated_by_p (loops->cfg.dom, mod_bb, mod_bb1))\n+\treturn NULL;\n+      if (mod_bb1 == mod_bb)\n+\t{\n+\t  for (;\n+\t       mod_insn != PREV_INSN (mod_bb->head);\n+\t       mod_insn = PREV_INSN (mod_insn))\n+\t    if (mod_insn == mod_insn1)\n+\t      break;\n+\n+\t  if (mod_insn == PREV_INSN (mod_bb->head))\n+\t    return NULL;\n+\t}\n+\n+      /* Replace the source with the possible place of increment.  */\n+      set = single_set (mod_insn1);\n+      if (!set)\n+\tabort ();\n+      if (!rtx_equal_p (SET_DEST (set), set_src))\n+\tabort ();\n+\n+      set_src = find_reg_equal_equiv_note (mod_insn1);\n+      if (!set_src)\n+\tset_src = SET_SRC (set);\n+    }\n+  else\n+    {\n+      desc->inner_mode = GET_MODE (desc->var);\n+      desc->extend = NIL;\n+    }\n+\n   if (GET_CODE (set_src) != PLUS)\n     return NULL;\n   if (!rtx_equal_p (XEXP (set_src, 0), desc->var))\n@@ -317,12 +403,14 @@ simple_increment (struct loops *loops, struct loop *loop,\n \n /* Tries to find initial value of VAR in INSN.  This value must be invariant\n    wrto INVARIANT_REGS.  If SET_INSN is not NULL, insn in that var is set is\n-   placed here.  */\n+   placed here.  INNER_MODE is mode in that induction variable VAR iterates.  */\n static rtx\n-variable_initial_value (rtx insn, regset invariant_regs, rtx var, rtx *set_insn)\n+variable_initial_value (rtx insn, regset invariant_regs,\n+\t\t\trtx var, rtx *set_insn, enum machine_mode inner_mode)\n {\n   basic_block bb;\n   rtx set;\n+  rtx ret = NULL;\n \n   /* Go back through cfg.  */\n   bb = BLOCK_FOR_INSN (insn);\n@@ -357,8 +445,21 @@ variable_initial_value (rtx insn, regset invariant_regs, rtx var, rtx *set_insn)\n \t    val = XEXP (note, 0);\n \t  else\n \t    val = SET_SRC (set);\n+\n+\t  /* If we know that the initial value is indeed in range of\n+\t     the inner mode, record the fact even in case the value itself\n+\t     is useless.  */\n+\t  if ((GET_CODE (val) == SIGN_EXTEND\n+\t       || GET_CODE (val) == ZERO_EXTEND)\n+\t      && GET_MODE (XEXP (val, 0)) == inner_mode)\n+\t    ret = gen_rtx_fmt_e (GET_CODE (val),\n+\t\t\t\t GET_MODE (var),\n+\t\t\t\t gen_rtx_fmt_ei (SUBREG,\n+\t\t\t\t\t\t inner_mode,\n+\t\t\t\t\t\t var, 0));\n+\n \t  if (!invariant_rtx_wrto_regs_p (val, invariant_regs))\n-\t    return NULL;\n+\t    return ret;\n \n \t  if (set_insn)\n \t    *set_insn = insn;\n@@ -376,9 +477,10 @@ variable_initial_value (rtx insn, regset invariant_regs, rtx var, rtx *set_insn)\n   return NULL;\n }\n \n-/* Returns list of definitions of initial value of VAR at Edge.  */\n+/* Returns list of definitions of initial value of VAR at edge E.  INNER_MODE\n+   is mode in that induction variable VAR really iterates.  */\n static rtx\n-variable_initial_values (edge e, rtx var)\n+variable_initial_values (edge e, rtx var, enum machine_mode inner_mode)\n {\n   rtx set_insn, list;\n   regset invariant_regs;\n@@ -396,7 +498,8 @@ variable_initial_values (edge e, rtx var)\n \n   set_insn = e->src->end;\n   while (REG_P (var)\n-\t && (var = variable_initial_value (set_insn, invariant_regs, var, &set_insn)))\n+\t && (var = variable_initial_value (set_insn, invariant_regs, var,\n+\t\t\t\t\t   &set_insn, inner_mode)))\n     list = alloc_EXPR_LIST (0, copy_rtx (var), list);\n \n   FREE_REG_SET (invariant_regs);\n@@ -453,18 +556,24 @@ constant_iterations (struct loop_desc *desc, unsigned HOST_WIDE_INT *niter,\n /* Attempts to determine a number of iterations of a \"strange\" loop.\n    Its induction variable starts with value INIT, is compared by COND\n    with LIM.  If POSTINCR, it is incremented after the test.  It is incremented\n-   by STRIDE each iteration and iterates in MODE.\n+   by STRIDE each iteration, has mode MODE but iterates in INNER_MODE.\n \n    By \"strange\" we mean loops where induction variable increases in the wrong\n    direction wrto comparison, i.e. for (i = 6; i > 5; i++).  */\n static rtx\n count_strange_loop_iterations (rtx init, rtx lim, enum rtx_code cond,\n-\t\t\t       int postincr, rtx stride, enum machine_mode mode)\n+\t\t\t       int postincr, rtx stride, enum machine_mode mode,\n+\t\t\t       enum machine_mode inner_mode)\n {\n   rtx rqmt, n_to_wrap, before_wrap, after_wrap;\n   rtx mode_min, mode_max;\n   int size;\n \n+  /* This could be handled, but it is not important enough to lose time with\n+     it just now.  */\n+  if (mode != inner_mode)\n+    return NULL_RTX;\n+\n   if (!postincr)\n     init = simplify_gen_binary (PLUS, mode, init, stride);\n \n@@ -567,6 +676,28 @@ count_strange_loop_iterations (rtx init, rtx lim, enum rtx_code cond,\n   return simplify_gen_binary (PLUS, mode, n_to_wrap, const1_rtx);\n }\n \n+/* Checks whether value of EXPR fits into range of MODE.  */\n+static bool\n+fits_in_mode_p (enum machine_mode mode, rtx expr)\n+{\n+  unsigned HOST_WIDEST_INT val;\n+  int n_bits = 0;\n+\n+  if (GET_CODE (expr) == CONST_INT)\n+    {\n+      for (val = INTVAL (expr); val; val >>= 1)\n+\tn_bits++;\n+\n+      return n_bits <= GET_MODE_BITSIZE (mode);\n+    }\n+\n+  if (GET_CODE (expr) == SIGN_EXTEND\n+      || GET_CODE (expr) == ZERO_EXTEND)\n+    return GET_MODE (XEXP (expr, 0)) == mode;\n+\n+  return false;\n+}\n+\n /* Return RTX expression representing number of iterations of loop as bounded\n    by test described by DESC (in the case loop really has multiple exit\n    edges, fewer iterations may happen in the practice).\n@@ -584,11 +715,14 @@ count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n {\n   enum rtx_code cond = desc->cond;\n   rtx stride = desc->stride;\n-  rtx mod, exp;\n+  rtx mod, exp, ainit, bound;\n+  rtx overflow_check, mx, mxp;\n+  enum machine_mode mode = GET_MODE (desc->var);\n+  unsigned HOST_WIDEST_INT s, size, d;\n \n   /* Give up on floating point modes and friends.  It can be possible to do\n      the job for constant loop bounds, but it is probably not worthwhile.  */\n-  if (!INTEGRAL_MODE_P (GET_MODE (desc->var)))\n+  if (!INTEGRAL_MODE_P (mode))\n     return NULL;\n \n   init = copy_rtx (init ? init : desc->var);\n@@ -598,50 +732,140 @@ count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n   if (desc->neg)\n     cond = reverse_condition (cond);\n \n+  if (desc->inner_mode != mode)\n+    {\n+      /* We have a case when the variable in fact iterates in the narrower\n+\t mode.  This has following consequences:\n+\t \n+\t For induction variable itself, if !desc->postincr, it does not mean\n+\t anything too special, since we know the variable is already in range\n+\t of the inner mode when we compare it (so it is just needed to shorten\n+\t it into the mode before calculations are done, so that we don't risk\n+\t wrong results).  More complicated case is when desc->postincr; then\n+\t the first two iterations are special (the first one because the value\n+\t may be out of range, the second one because after shortening it to the\n+\t range it may have absolutely any value), and we do not handle this in\n+\t unrolling.  So if we aren't able to prove that the initial value is in\n+\t the range, we fail in this case.\n+\t \n+\t Step is just moduled to fit into inner mode.\n+\n+\t If lim is out of range, then either the loop is infinite (and then\n+\t we may unroll however we like to), or exits in the first iteration\n+\t (this is also ok, since we handle it specially for this case anyway).\n+\t So we may safely assume that it fits into the inner mode.  */\n+\n+      for (ainit = desc->var_alts; ainit; ainit = XEXP (ainit, 1))\n+\tif (fits_in_mode_p (desc->inner_mode, XEXP (ainit, 0)))\n+\t  break;\n+\n+      if (!ainit)\n+\t{\n+\t  if (desc->postincr)\n+\t    return NULL_RTX;\n+\n+\t  init = simplify_gen_unary (desc->extend,\n+\t\t\t\t     mode,\n+\t\t\t\t     simplify_gen_subreg (desc->inner_mode,\n+\t\t\t\t\t\t\t  init,\n+\t\t\t\t\t\t\t  mode,\n+\t\t\t\t\t\t\t  0),\n+\t\t\t\t     desc->inner_mode);\n+\t}\n+\n+      stride = simplify_gen_subreg (desc->inner_mode, stride, mode, 0);\n+      if (stride == const0_rtx)\n+\treturn NULL_RTX;\n+    }\n+\n+  /* Prepare condition to verify that we do not risk overflow.  */\n+  if (stride == const1_rtx\n+      || stride == constm1_rtx\n+      || cond == NE\n+      || cond == EQ)\n+    {\n+      /* Overflow at NE conditions does not occur.  EQ condition\n+\t is weird and is handled in count_strange_loop_iterations.\n+\t If stride is 1, overflow may occur only for <= and >= conditions,\n+\t and then they are infinite, so it does not bother us.  */\n+      overflow_check = const0_rtx;\n+    }\n+  else\n+    {\n+      if (cond == LT || cond == LTU)\n+\tmx = simplify_gen_binary (MINUS, mode, lim, const1_rtx);\n+      else if (cond == GT || cond == GTU)\n+\tmx = simplify_gen_binary (PLUS, mode, lim, const1_rtx);\n+      else\n+\tmx = lim;\n+      if (mode != desc->inner_mode)\n+\tmxp = simplify_gen_subreg (desc->inner_mode, mx, mode, 0);\n+      else\n+\tmxp = mx;\n+      mxp = simplify_gen_binary (PLUS, desc->inner_mode, mxp, stride);\n+      if (mode != desc->inner_mode)\n+\tmxp = simplify_gen_unary (desc->extend, mode, mxp, desc->inner_mode);\n+      overflow_check = simplify_gen_relational (cond, SImode, mode, mx, mxp);\n+    }\n+    \n   /* Compute absolute value of the difference of initial and final value.  */\n   if (INTVAL (stride) > 0)\n     {\n       /* Handle strange tests specially.  */\n       if (cond == EQ || cond == GE || cond == GT || cond == GEU\n \t  || cond == GTU)\n \treturn count_strange_loop_iterations (init, lim, cond, desc->postincr,\n-\t\t\t\t\t      stride, GET_MODE (desc->var));\n-      exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n-\t\t\t\t lim, init);\n+\t\t\t\t\t      stride, mode, desc->inner_mode);\n+      exp = simplify_gen_binary (MINUS, mode, lim, init);\n     }\n   else\n     {\n-      /* Bypass nonsensical tests.  */\n       if (cond == EQ || cond == LE || cond == LT || cond == LEU\n \t  || cond == LTU)\n \treturn count_strange_loop_iterations (init, lim, cond, desc->postincr,\n-\t\t\t\t\t      stride, GET_MODE (desc->var));\n-      exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n-\t\t\t\t init, lim);\n-      stride = simplify_gen_unary (NEG, GET_MODE (desc->var),\n-\t\t\t\t   stride, GET_MODE (desc->var));\n+\t\t\t\t\t      stride, mode, desc->inner_mode);\n+      exp = simplify_gen_binary (MINUS, mode, init, lim);\n+      stride = simplify_gen_unary (NEG, mode, stride, mode);\n     }\n \n+  /* If there is a risk of overflow (i.e. when we increment value satisfying\n+     a condition, we may again obtain a value satisfying the condition),\n+     fail.  */\n+  if (overflow_check != const0_rtx)\n+    return NULL_RTX;\n+\n   /* Normalize difference so the value is always first examined\n      and later incremented.  */\n-\n   if (!desc->postincr)\n-    exp = simplify_gen_binary (MINUS, GET_MODE (desc->var),\n-\t\t\t       exp, stride);\n+    exp = simplify_gen_binary (MINUS, mode, exp, stride);\n \n   /* Determine delta caused by exit condition.  */\n   switch (cond)\n     {\n     case NE:\n-      /* For NE tests, make sure that the iteration variable won't miss\n-\t the final value.  If EXP mod STRIDE is not zero, then the\n-\t iteration variable will overflow before the loop exits, and we\n-\t can not calculate the number of iterations easily.  */\n-      if (stride != const1_rtx\n-\t  && (simplify_gen_binary (UMOD, GET_MODE (desc->var), exp, stride)\n-              != const0_rtx))\n-\treturn NULL;\n+      /* NE tests are easy to handle, because we just perform simple\n+\t arithmetics modulo power of 2.  Let's use the fact to compute the\n+\t number of iterations exactly.  We are now in situation when we want to\n+\t solve an equation stride * i = c (mod size of inner_mode).\n+\t Let nsd (stride, size of mode) = d.  If d does not divide c, the\n+\t loop is infinite.  Otherwise, the number of iterations is\n+\t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n+      size = GET_MODE_BITSIZE (desc->inner_mode);\n+      s = INTVAL (stride);\n+      d = 1;\n+      while (s % 2 != 1)\n+\t{\n+\t  s /= 2;\n+\t  d *= 2;\n+\t  size--;\n+\t}\n+      bound = GEN_INT (((unsigned HOST_WIDEST_INT) 1 << (size - 1 ) << 1) - 1);\n+      exp = simplify_gen_binary (UDIV, mode, exp, GEN_INT (d));\n+      exp = simplify_gen_binary (MULT, mode,\n+\t\t\t\t exp, GEN_INT (inverse (s, size)));\n+      exp = simplify_gen_binary (AND, mode, exp, bound);\n       break;\n+\n     case LT:\n     case GT:\n     case LTU:\n@@ -651,19 +875,18 @@ count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n     case GE:\n     case LEU:\n     case GEU:\n-      exp = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n-\t\t\t\t exp, const1_rtx);\n+      exp = simplify_gen_binary (PLUS, mode, exp, const1_rtx);\n       break;\n     default:\n       abort ();\n     }\n \n-  if (stride != const1_rtx)\n+  if (cond != NE && stride != const1_rtx)\n     {\n       /* Number of iterations is now (EXP + STRIDE - 1 / STRIDE),\n \t but we need to take care for overflows.  */\n \n-      mod = simplify_gen_binary (UMOD, GET_MODE (desc->var), exp, stride);\n+      mod = simplify_gen_binary (UMOD, mode, exp, stride);\n \n       /* This is dirty trick.  When we can't compute number of iterations\n \t to be constant, we simply ignore the possible overflow, as\n@@ -672,18 +895,15 @@ count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n \n       if (GET_CODE (mod) != CONST_INT)\n \t{\n-\t  rtx stridem1 = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n-\t\t\t\t\t      stride, constm1_rtx);\n-\t  exp = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n-\t\t\t\t     exp, stridem1);\n-\t  exp = simplify_gen_binary (UDIV, GET_MODE (desc->var), exp, stride);\n+\t  rtx stridem1 = simplify_gen_binary (PLUS, mode, stride, constm1_rtx);\n+\t  exp = simplify_gen_binary (PLUS, mode, exp, stridem1);\n+\t  exp = simplify_gen_binary (UDIV, mode, exp, stride);\n \t}\n       else\n \t{\n-\t  exp = simplify_gen_binary (UDIV, GET_MODE (desc->var), exp, stride);\n+\t  exp = simplify_gen_binary (UDIV, mode, exp, stride);\n \t  if (mod != const0_rtx)\n-\t    exp = simplify_gen_binary (PLUS, GET_MODE (desc->var),\n-\t\t\t\t       exp, const1_rtx);\n+\t    exp = simplify_gen_binary (PLUS, mode, exp, const1_rtx);\n \t}\n     }\n \n@@ -792,8 +1012,8 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n \n   /* Find initial value of var and alternative values for lim.  */\n   e = loop_preheader_edge (loop);\n-  desc->var_alts = variable_initial_values (e, desc->var);\n-  desc->lim_alts = variable_initial_values (e, desc->lim);\n+  desc->var_alts = variable_initial_values (e, desc->var, desc->inner_mode);\n+  desc->lim_alts = variable_initial_values (e, desc->lim, desc->inner_mode);\n \n   /* Number of iterations.  */\n   desc->const_iter ="}]}