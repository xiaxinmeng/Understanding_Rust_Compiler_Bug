{"sha": "b4feb49cf308b344fba6a72137df58de382fcb9d", "node_id": "C_kwDOANBUbNoAKGI0ZmViNDljZjMwOGIzNDRmYmE2YTcyMTM3ZGY1OGRlMzgyZmNiOWQ", "commit": {"author": {"name": "zhongjuzhe", "email": "juzhe.zhong@rivai.ai", "date": "2022-09-15T08:28:53Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-09-23T15:33:24Z"}, "message": "RISC-V: Support poly move manipulation and selftests.\n\ngcc/ChangeLog:\n\n\t* common/config/riscv/riscv-common.cc: Change \"static void\" to \"void\".\n\t* config.gcc: Add riscv-selftests.o\n\t* config/riscv/predicates.md: Allow const_poly_int.\n\t* config/riscv/riscv-protos.h (riscv_reinit): New function.\n\t(riscv_parse_arch_string): change as exten function.\n\t(riscv_run_selftests): New function.\n\t* config/riscv/riscv.cc (riscv_cannot_force_const_mem): Don't allow poly\n\tinto const pool.\n\t(riscv_report_v_required): New function.\n\t(riscv_expand_op): New function.\n\t(riscv_expand_mult_with_const_int): New function.\n\t(riscv_legitimize_poly_move): Ditto.\n\t(riscv_legitimize_move): New function.\n\t(riscv_hard_regno_mode_ok): Add VL/VTYPE register allocation and fix\n\tvector RA.\n\t(riscv_convert_vector_bits): Fix riscv_vector_chunks configuration for\n\t-marh no 'v'.\n\t(riscv_reinit): New function.\n\t(TARGET_RUN_TARGET_SELFTESTS): New target hook support.\n\t* config/riscv/t-riscv: Add riscv-selftests.o.\n\t* config/riscv/riscv-selftests.cc: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* selftests/riscv/empty-func.rtl: New test.", "tree": {"sha": "cbabdb92309bbf9f1538bcb7a811c16b8ee66357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbabdb92309bbf9f1538bcb7a811c16b8ee66357"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4feb49cf308b344fba6a72137df58de382fcb9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4feb49cf308b344fba6a72137df58de382fcb9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4feb49cf308b344fba6a72137df58de382fcb9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4feb49cf308b344fba6a72137df58de382fcb9d/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab98b4c0725eb7c0f03d319ef3e22ae761b2698a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab98b4c0725eb7c0f03d319ef3e22ae761b2698a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab98b4c0725eb7c0f03d319ef3e22ae761b2698a"}], "stats": {"total": 567, "additions": 560, "deletions": 7}, "files": [{"sha": "c39ed2e26962c907f696aa46c2a057e21ad30b57", "filename": "gcc/common/config/riscv/riscv-common.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -1224,7 +1224,7 @@ static const riscv_ext_flag_table_t riscv_ext_flag_table[] =\n /* Parse a RISC-V ISA string into an option mask.  Must clear or set all arch\n    dependent mask bits, in case more than one -march string is passed.  */\n \n-static void\n+void\n riscv_parse_arch_string (const char *isa,\n \t\t\t struct gcc_options *opts,\n \t\t\t location_t loc)"}, {"sha": "27ffce3fb500ce421ac9552d2685800272973f62", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -515,7 +515,7 @@ pru-*-*)\n \t;;\n riscv*)\n \tcpu_type=riscv\n-\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o\"\n+\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o\"\n \td_target_objs=\"riscv-d.o\"\n \t;;\n rs6000*-*-*)"}, {"sha": "5e149b3a95f3884d9d64222d6ae049df11f91244", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -146,6 +146,9 @@\n     case CONST_INT:\n       return !splittable_const_int_operand (op, mode);\n \n+    case CONST_POLY_INT:\n+      return known_eq (rtx_to_poly_int64 (op), BYTES_PER_RISCV_VECTOR);\n+\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:"}, {"sha": "f9a2baa46c71d9f3777b4cde2d730e54419e2737", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -74,6 +74,7 @@ extern bool riscv_expand_block_move (rtx, rtx, rtx);\n extern bool riscv_store_data_bypass_p (rtx_insn *, rtx_insn *);\n extern rtx riscv_gen_gpr_save_insn (struct riscv_frame_info *);\n extern bool riscv_gpr_save_operation_p (rtx);\n+extern void riscv_reinit (void);\n \n /* Routines implemented in riscv-c.cc.  */\n void riscv_cpu_cpp_builtins (cpp_reader *);\n@@ -86,6 +87,7 @@ extern void riscv_init_builtins (void);\n \n /* Routines implemented in riscv-common.cc.  */\n extern std::string riscv_arch_str (bool version_p = true);\n+extern void riscv_parse_arch_string (const char *, struct gcc_options *, location_t);\n \n extern bool riscv_hard_regno_rename_ok (unsigned, unsigned);\n \n@@ -105,4 +107,11 @@ struct riscv_cpu_info {\n \n extern const riscv_cpu_info *riscv_find_cpu (const char *);\n \n+/* Routines implemented in riscv-selftests.cc.  */\n+#if CHECKING_P\n+namespace selftest {\n+extern void riscv_run_selftests (void);\n+} // namespace selftest\n+#endif\n+\n #endif /* ! GCC_RISCV_PROTOS_H */"}, {"sha": "636874ebc0f0c93cd7c31cbe3f0a0b75a6b8df97", "filename": "gcc/config/riscv/riscv-selftests.cc", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Friscv-selftests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Friscv-selftests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-selftests.cc?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -0,0 +1,241 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#define INCLUDE_STRING\n+#define INCLUDE_MAP\n+#define INCLUDE_VECTOR\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"function.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"tm_p.h\"\n+#include \"expr.h\"\n+#include \"selftest.h\"\n+#include \"selftest-rtl.h\"\n+\n+#if CHECKING_P\n+using namespace selftest;\n+class riscv_selftest_arch_abi_setter\n+{\n+private:\n+  std::string m_arch_backup;\n+  enum riscv_abi_type m_abi_backup;\n+\n+public:\n+  riscv_selftest_arch_abi_setter (const char *arch, enum riscv_abi_type abi)\n+    : m_arch_backup (riscv_arch_str ()), m_abi_backup (riscv_abi)\n+  {\n+    riscv_parse_arch_string (arch, &global_options, UNKNOWN_LOCATION);\n+    riscv_abi = abi;\n+    riscv_reinit ();\n+  }\n+  ~riscv_selftest_arch_abi_setter ()\n+  {\n+    riscv_parse_arch_string (m_arch_backup.c_str (), &global_options,\n+\t\t\t     UNKNOWN_LOCATION);\n+    riscv_abi = m_abi_backup;\n+    riscv_reinit ();\n+  }\n+};\n+\n+static poly_int64\n+eval_value (rtx x, std::map<unsigned, rtx> &regno_to_rtx)\n+{\n+  if (!REG_P (x))\n+    {\n+      debug (x);\n+      gcc_unreachable ();\n+    }\n+\n+  rtx expr = NULL_RTX;\n+  unsigned regno = REGNO (x);\n+  expr = regno_to_rtx[regno];\n+\n+  poly_int64 op1_val = 0;\n+  poly_int64 op2_val = 0;\n+  if (UNARY_P (expr))\n+    {\n+      op1_val = eval_value (XEXP (expr, 0), regno_to_rtx);\n+    }\n+  if (BINARY_P (expr))\n+    {\n+      op1_val = eval_value (XEXP (expr, 0), regno_to_rtx);\n+      op2_val = eval_value (XEXP (expr, 1), regno_to_rtx);\n+    }\n+\n+  switch (GET_CODE (expr))\n+    {\n+    case CONST_POLY_INT:\n+      return rtx_to_poly_int64 (expr);\n+    case CONST_INT:\n+      return INTVAL (expr);\n+\n+    case MULT:\n+      if (op1_val.is_constant ())\n+\treturn op1_val.to_constant () * op2_val;\n+      else if (op2_val.is_constant ())\n+\treturn op1_val * op2_val.to_constant ();\n+      else\n+\tgcc_unreachable ();\n+    case PLUS:\n+      return op1_val + op2_val;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Calculate the value of x register in the sequence.  */\n+static poly_int64\n+calculate_x_in_sequence (rtx reg)\n+{\n+  std::map<unsigned, rtx> regno_to_rtx;\n+  rtx_insn *insn;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat = PATTERN (insn);\n+      rtx dest = SET_DEST (pat);\n+\n+      if (GET_CODE (pat) == CLOBBER)\n+\tcontinue;\n+\n+      if (SUBREG_P (dest))\n+\tcontinue;\n+\n+      gcc_assert (REG_P (dest));\n+      rtx note = find_reg_equal_equiv_note (insn);\n+      unsigned regno = REGNO (dest);\n+      if (note)\n+\tregno_to_rtx[regno] = XEXP (note, 0);\n+      else\n+\tregno_to_rtx[regno] = SET_SRC (pat);\n+    }\n+\n+  return eval_value (reg, regno_to_rtx);\n+}\n+\n+typedef enum\n+{\n+  POLY_TEST_DIMODE,\n+  POLY_TEST_PMODE\n+} poly_test_mode_t;\n+\n+static void\n+simple_poly_selftest (const char *arch, enum riscv_abi_type abi,\n+\t\t      const std::vector<machine_mode> &modes)\n+{\n+  riscv_selftest_arch_abi_setter rv (arch, abi);\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"riscv/empty-func.rtl\"));\n+  set_new_first_and_last_insn (NULL, NULL);\n+\n+  for (machine_mode mode : modes)\n+    emit_move_insn (gen_reg_rtx (mode),\n+\t\t    gen_int_mode (BYTES_PER_RISCV_VECTOR, mode));\n+}\n+\n+static void\n+run_poly_int_selftest (const char *arch, enum riscv_abi_type abi,\n+\t\t       poly_test_mode_t test_mode,\n+\t\t       const std::vector<poly_int64> &worklist)\n+{\n+  riscv_selftest_arch_abi_setter rv (arch, abi);\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"riscv/empty-func.rtl\"));\n+  set_new_first_and_last_insn (NULL, NULL);\n+  machine_mode mode = VOIDmode;\n+\n+  switch (test_mode)\n+    {\n+    case POLY_TEST_DIMODE:\n+      mode = DImode;\n+      break;\n+    case POLY_TEST_PMODE:\n+      mode = Pmode;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  for (const poly_int64 &poly_val : worklist)\n+    {\n+      start_sequence ();\n+      rtx dest = gen_reg_rtx (mode);\n+      emit_move_insn (dest, gen_int_mode (poly_val, mode));\n+      ASSERT_TRUE (known_eq (calculate_x_in_sequence (dest), poly_val));\n+      end_sequence ();\n+    }\n+}\n+\n+static void\n+run_poly_int_selftests (void)\n+{\n+  std::vector<poly_int64> worklist\n+    = {BYTES_PER_RISCV_VECTOR,\t    BYTES_PER_RISCV_VECTOR * 8,\n+       BYTES_PER_RISCV_VECTOR * 32, -BYTES_PER_RISCV_VECTOR * 8,\n+       -BYTES_PER_RISCV_VECTOR * 32, BYTES_PER_RISCV_VECTOR * 7,\n+       BYTES_PER_RISCV_VECTOR * 31, -BYTES_PER_RISCV_VECTOR * 7,\n+       -BYTES_PER_RISCV_VECTOR * 31, BYTES_PER_RISCV_VECTOR * 9,\n+       BYTES_PER_RISCV_VECTOR * 33, -BYTES_PER_RISCV_VECTOR * 9,\n+       -BYTES_PER_RISCV_VECTOR * 33, poly_int64 (207, 0),\n+       poly_int64 (-207, 0),\t    poly_int64 (0, 207),\n+       poly_int64 (0, -207),\t    poly_int64 (5555, 0),\n+       poly_int64 (0, 5555),\t    poly_int64 (4096, 4096),\n+       poly_int64 (17, 4088),\t    poly_int64 (3889, 4104),\n+       poly_int64 (-4096, -4096),   poly_int64 (219, -4088),\n+       poly_int64 (-4309, -4104),   poly_int64 (-7337, 88),\n+       poly_int64 (9317, -88),\t    poly_int64 (4, 4),\n+       poly_int64 (17, 4),\t    poly_int64 (-7337, 4),\n+       poly_int64 (-4, -4),\t    poly_int64 (-389, -4),\n+       poly_int64 (4789, -4),\t    poly_int64 (-5977, 1508),\n+       poly_int64 (219, -1508),\t    poly_int64 (2, 2),\n+       poly_int64 (33, 2),\t    poly_int64 (-7337, 2),\n+       poly_int64 (-2, -2),\t    poly_int64 (-389, -2),\n+       poly_int64 (4789, -2),\t    poly_int64 (-3567, 954),\n+       poly_int64 (945, -954),\t    poly_int64 (1, 1),\n+       poly_int64 (977, 1),\t    poly_int64 (-339, 1),\n+       poly_int64 (-1, -1),\t    poly_int64 (-12, -1),\n+       poly_int64 (44, -1),\t    poly_int64 (9567, 77),\n+       poly_int64 (3467, -77)};\n+\n+  simple_poly_selftest (\"rv64imafdv\", ABI_LP64D,\n+\t\t\t{QImode, HImode, SImode, DImode});\n+  simple_poly_selftest (\"rv32imafdv\", ABI_ILP32D, {QImode, HImode, SImode});\n+\n+  run_poly_int_selftest (\"rv64imafdv\", ABI_LP64D, POLY_TEST_PMODE, worklist);\n+  run_poly_int_selftest (\"rv64imafd_zve32x1p0\", ABI_LP64D, POLY_TEST_PMODE,\n+\t\t\t worklist);\n+  run_poly_int_selftest (\"rv32imafdv\", ABI_ILP32, POLY_TEST_PMODE, worklist);\n+  run_poly_int_selftest (\"rv32imafdv\", ABI_ILP32, POLY_TEST_DIMODE, worklist);\n+  run_poly_int_selftest (\"rv32imafd_zve32x1p0\", ABI_ILP32D, POLY_TEST_PMODE,\n+\t\t\t worklist);\n+  run_poly_int_selftest (\"rv32imafd_zve32x1p0\", ABI_ILP32D, POLY_TEST_DIMODE,\n+\t\t\t worklist);\n+}\n+namespace selftest {\n+/* Run all target-specific selftests.  */\n+void\n+riscv_run_selftests (void)\n+{\n+  run_poly_int_selftests ();\n+}\n+} // namespace selftest\n+#endif /* #if CHECKING_P */"}, {"sha": "4d5d88798ea7f8888bd5dac82969d48b8b745b31", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 293, "deletions": 5, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -57,6 +57,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"tree-pass.h\"\n #include \"opts.h\"\n+#include \"tm-constrs.h\"\n+#include \"rtl-iter.h\"\n \n /* True if X is an UNSPEC wrapper around a SYMBOL_REF or LABEL_REF.  */\n #define UNSPEC_ADDRESS_P(X)\t\t\t\t\t\\\n@@ -778,6 +780,12 @@ riscv_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n   enum riscv_symbol_type type;\n   rtx base, offset;\n \n+  /* There's no way to calculate VL-based values using relocations.  */\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, x, ALL)\n+    if (GET_CODE (*iter) == CONST_POLY_INT)\n+      return true;\n+\n   /* There is no assembler syntax for expressing an address-sized\n      high part.  */\n   if (GET_CODE (x) == HIGH)\n@@ -1684,12 +1692,268 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n   riscv_emit_move (dest, src);\n }\n \n+/* Report when we try to do something that requires vector when vector is\n+   disabled. This is an error of last resort and isn't very high-quality.  It\n+   usually involves attempts to measure the vector length in some way.  */\n+\n+static void\n+riscv_report_v_required (void)\n+{\n+  static bool reported_p = false;\n+\n+  /* Avoid reporting a slew of messages for a single oversight.  */\n+  if (reported_p)\n+    return;\n+\n+  error (\"this operation requires the RVV ISA extension\");\n+  inform (input_location, \"you can enable RVV using the command-line\"\n+\t\t\t  \" option %<-march%>, or by using the %<target%>\"\n+\t\t\t  \" attribute or pragma\");\n+  reported_p = true;\n+}\n+\n+/* Helper function to operation for rtx_code CODE.  */\n+static void\n+riscv_expand_op (enum rtx_code code, machine_mode mode, rtx op0, rtx op1,\n+\t\t rtx op2)\n+{\n+  if (can_create_pseudo_p ())\n+    {\n+      rtx result;\n+      if (GET_RTX_CLASS (code) == RTX_UNARY)\n+\tresult = expand_simple_unop (mode, code, op1, NULL_RTX, false);\n+      else\n+\tresult = expand_simple_binop (mode, code, op1, op2, NULL_RTX, false,\n+\t\t\t\t      OPTAB_DIRECT);\n+      riscv_emit_move (op0, result);\n+    }\n+  else\n+    {\n+      rtx pat;\n+      /* The following implementation is for prologue and epilogue.\n+\t Because prologue and epilogue can not use pseudo register.\n+\t We can't using expand_simple_binop or expand_simple_unop.  */\n+      if (GET_RTX_CLASS (code) == RTX_UNARY)\n+\tpat = gen_rtx_fmt_e (code, mode, op1);\n+      else\n+\tpat = gen_rtx_fmt_ee (code, mode, op1, op2);\n+      emit_insn (gen_rtx_SET (op0, pat));\n+    }\n+}\n+\n+/* Expand mult operation with constant integer, multiplicand also used as a\n+ * temporary register.  */\n+\n+static void\n+riscv_expand_mult_with_const_int (machine_mode mode, rtx dest, rtx multiplicand,\n+\t\t\t\t  int multiplier)\n+{\n+  if (multiplier == 0)\n+    {\n+      riscv_emit_move (dest, GEN_INT (0));\n+      return;\n+    }\n+\n+  bool neg_p = multiplier < 0;\n+  int multiplier_abs = abs (multiplier);\n+\n+  if (multiplier_abs == 1)\n+    {\n+      if (neg_p)\n+\triscv_expand_op (NEG, mode, dest, multiplicand, NULL_RTX);\n+      else\n+\triscv_emit_move (dest, multiplicand);\n+    }\n+  else\n+    {\n+      if (pow2p_hwi (multiplier_abs))\n+\t{\n+\t  /*\n+\t    multiplicand = [BYTES_PER_RISCV_VECTOR].\n+\t     1. const_poly_int:P [BYTES_PER_RISCV_VECTOR * 8].\n+\t    Sequence:\n+\t\t    csrr a5, vlenb\n+\t\t    slli a5, a5, 3\n+\t    2. const_poly_int:P [-BYTES_PER_RISCV_VECTOR * 8].\n+\t    Sequence:\n+\t\t    csrr a5, vlenb\n+\t\t    slli a5, a5, 3\n+\t\t    neg a5, a5\n+\t  */\n+\t  riscv_expand_op (ASHIFT, mode, dest, multiplicand,\n+\t\t\t   gen_int_mode (exact_log2 (multiplier_abs), QImode));\n+\t  if (neg_p)\n+\t    riscv_expand_op (NEG, mode, dest, dest, NULL_RTX);\n+\t}\n+      else if (pow2p_hwi (multiplier_abs + 1))\n+\t{\n+\t  /*\n+\t    multiplicand = [BYTES_PER_RISCV_VECTOR].\n+\t     1. const_poly_int:P [BYTES_PER_RISCV_VECTOR * 7].\n+\t    Sequence:\n+\t\t    csrr a5, vlenb\n+\t\t    slli a4, a5, 3\n+\t\t    sub a5, a4, a5\n+\t     2. const_poly_int:P [-BYTES_PER_RISCV_VECTOR * 7].\n+\t    Sequence:\n+\t\t    csrr a5, vlenb\n+\t\t    slli a4, a5, 3\n+\t\t    sub a5, a4, a5 + neg a5, a5 => sub a5, a5, a4\n+\t  */\n+\t  riscv_expand_op (ASHIFT, mode, dest, multiplicand,\n+\t\t\t   gen_int_mode (exact_log2 (multiplier_abs + 1),\n+\t\t\t\t\t QImode));\n+\t  if (neg_p)\n+\t    riscv_expand_op (MINUS, mode, dest, multiplicand, dest);\n+\t  else\n+\t    riscv_expand_op (MINUS, mode, dest, dest, multiplicand);\n+\t}\n+      else if (pow2p_hwi (multiplier - 1))\n+\t{\n+\t  /*\n+\t    multiplicand = [BYTES_PER_RISCV_VECTOR].\n+\t     1. const_poly_int:P [BYTES_PER_RISCV_VECTOR * 9].\n+\t    Sequence:\n+\t\t    csrr a5, vlenb\n+\t\t    slli a4, a5, 3\n+\t\t    add a5, a4, a5\n+\t     2. const_poly_int:P [-BYTES_PER_RISCV_VECTOR * 9].\n+\t    Sequence:\n+\t\t    csrr a5, vlenb\n+\t\t    slli a4, a5, 3\n+\t\t    add a5, a4, a5\n+\t\t    neg a5, a5\n+\t  */\n+\t  riscv_expand_op (ASHIFT, mode, dest, multiplicand,\n+\t\t\t   gen_int_mode (exact_log2 (multiplier_abs - 1),\n+\t\t\t\t\t QImode));\n+\t  riscv_expand_op (PLUS, mode, dest, dest, multiplicand);\n+\t  if (neg_p)\n+\t    riscv_expand_op (NEG, mode, dest, dest, NULL_RTX);\n+\t}\n+      else\n+\t{\n+\t  /* We use multiplication for remaining cases.  */\n+\t  gcc_assert (\n+\t    TARGET_MUL\n+\t    && \"M-extension must be enabled to calculate the poly_int \"\n+\t       \"size/offset.\");\n+\t  riscv_emit_move (dest, gen_int_mode (multiplier, mode));\n+\t  riscv_expand_op (MULT, mode, dest, dest, multiplicand);\n+\t}\n+    }\n+}\n+\n+/* Analyze src and emit const_poly_int mov sequence.  */\n+\n+static void\n+riscv_legitimize_poly_move (machine_mode mode, rtx dest, rtx tmp, rtx src)\n+{\n+  poly_int64 value = rtx_to_poly_int64 (src);\n+  int offset = value.coeffs[0];\n+  int factor = value.coeffs[1];\n+  int vlenb = BYTES_PER_RISCV_VECTOR.coeffs[1];\n+  int div_factor = 0;\n+  /* Calculate (const_poly_int:MODE [m, n]) using scalar instructions.\n+     For any (const_poly_int:MODE [m, n]), the calculation formula is as\n+     follows.\n+     constant = m - n.\n+     When minimum VLEN = 32, poly of VLENB = (4, 4).\n+     base = vlenb(4, 4) or vlenb/2(2, 2) or vlenb/4(1, 1).\n+     When minimum VLEN > 32, poly of VLENB = (8, 8).\n+     base = vlenb(8, 8) or vlenb/2(4, 4) or vlenb/4(2, 2) or vlenb/8(1, 1).\n+     magn = (n, n) / base.\n+     (m, n) = base * magn + constant.\n+     This calculation doesn't need div operation.  */\n+\n+  emit_move_insn (tmp, gen_int_mode (BYTES_PER_RISCV_VECTOR, mode));\n+\n+  if (BYTES_PER_RISCV_VECTOR.is_constant ())\n+    {\n+      gcc_assert (value.is_constant ());\n+      riscv_emit_move (dest, GEN_INT (value.to_constant ()));\n+      return;\n+    }\n+  else if ((factor % vlenb) == 0)\n+    div_factor = 1;\n+  else if ((factor % (vlenb / 2)) == 0)\n+    div_factor = 2;\n+  else if ((factor % (vlenb / 4)) == 0)\n+    div_factor = 4;\n+  else if ((factor % (vlenb / 8)) == 0)\n+    div_factor = 8;\n+  else\n+    gcc_unreachable ();\n+\n+  if (div_factor != 1)\n+    riscv_expand_op (LSHIFTRT, mode, tmp, tmp,\n+\t\t     gen_int_mode (exact_log2 (div_factor), QImode));\n+\n+  riscv_expand_mult_with_const_int (mode, dest, tmp,\n+\t\t\t\t    factor / (vlenb / div_factor));\n+  HOST_WIDE_INT constant = offset - factor;\n+\n+  if (constant == 0)\n+    return;\n+  else if (SMALL_OPERAND (constant))\n+    riscv_expand_op (PLUS, mode, dest, dest, gen_int_mode (constant, mode));\n+  else\n+    {\n+      /* Handle the constant value is not a 12-bit value.  */\n+      rtx high;\n+\n+      /* Leave OFFSET as a 16-bit offset and put the excess in HIGH.\n+\t The addition inside the macro CONST_HIGH_PART may cause an\n+\t overflow, so we need to force a sign-extension check.  */\n+      high = gen_int_mode (CONST_HIGH_PART (constant), mode);\n+      constant = CONST_LOW_PART (constant);\n+      riscv_emit_move (tmp, high);\n+      riscv_expand_op (PLUS, mode, dest, tmp, dest);\n+      riscv_expand_op (PLUS, mode, dest, dest, gen_int_mode (constant, mode));\n+    }\n+}\n+\n /* If (set DEST SRC) is not a valid move instruction, emit an equivalent\n    sequence that is valid.  */\n \n bool\n riscv_legitimize_move (machine_mode mode, rtx dest, rtx src)\n {\n+  if (CONST_POLY_INT_P (src))\n+    {\n+      poly_int64 value = rtx_to_poly_int64 (src);\n+      if (!value.is_constant () && !TARGET_VECTOR)\n+\t{\n+\t  riscv_report_v_required ();\n+\t  return false;\n+\t}\n+\n+      if (satisfies_constraint_vp (src))\n+\treturn false;\n+\n+      if (GET_MODE_SIZE (mode).to_constant () < GET_MODE_SIZE (Pmode))\n+\t{\n+\t  /* In RV32 system, handle (const_poly_int:QI [m, n])\n+\t\t\t\t    (const_poly_int:HI [m, n]).\n+\t     In RV64 system, handle (const_poly_int:QI [m, n])\n+\t\t\t\t    (const_poly_int:HI [m, n])\n+\t\t\t\t    (const_poly_int:SI [m, n]).  */\n+\t  rtx tmp = gen_reg_rtx (Pmode);\n+\t  riscv_legitimize_poly_move (Pmode, gen_lowpart (Pmode, dest), tmp,\n+\t\t\t\t      src);\n+\t}\n+      else\n+\t{\n+\t  /* In RV32 system, handle (const_poly_int:SI [m, n])\n+\t\t\t\t    (const_poly_int:DI [m, n]).\n+\t     In RV64 system, handle (const_poly_int:DI [m, n]).\n+       FIXME: Maybe we could gen SImode in RV32 and then sign-extend to DImode,\n+       the offset should not exceed 4GiB in general.  */\n+\t  rtx tmp = gen_reg_rtx (mode);\n+\t  riscv_legitimize_poly_move (mode, dest, tmp, src);\n+\t}\n+      return true;\n+    }\n   /* Expand \n        (set (reg:QI target) (mem:QI (address))) \n      to\n@@ -5033,6 +5297,9 @@ riscv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n       if (!riscv_v_ext_vector_mode_p (mode))\n \treturn false;\n \n+      if (!V_REG_P (regno + nregs - 1))\n+\treturn false;\n+\n       /* 3.3.2. LMUL = 2,4,8, register numbers should be multiple of 2,4,8.\n \t but for mask vector register, register numbers can be any number. */\n       int lmul = 1;\n@@ -5041,6 +5308,8 @@ riscv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n       if (lmul != 1)\n \treturn ((regno % lmul) == 0);\n     }\n+  else if (regno == VL_REGNUM || regno == VTYPE_REGNUM)\n+    return true;\n   else\n     return false;\n \n@@ -5231,10 +5500,6 @@ riscv_init_machine_status (void)\n static poly_uint16\n riscv_convert_vector_bits (void)\n {\n-  /* The runtime invariant is only meaningful when TARGET_VECTOR is enabled. */\n-  if (!TARGET_VECTOR)\n-    return 0;\n-\n   if (TARGET_MIN_VLEN > 32)\n     {\n       /* When targetting minimum VLEN > 32, we should use 64-bit chunk size.\n@@ -5255,7 +5520,13 @@ riscv_convert_vector_bits (void)\n       riscv_bytes_per_vector_chunk = 4;\n     }\n \n-  return poly_uint16 (1, 1);\n+  /* Set riscv_vector_chunks as poly (1, 1) run-time constant if TARGET_VECTOR\n+     is enabled. Set riscv_vector_chunks as 1 compile-time constant if\n+     TARGET_VECTOR is disabled. riscv_vector_chunks is used in \"riscv-modes.def\"\n+     to set RVV mode size. The RVV machine modes size are run-time constant if\n+     TARGET_VECTOR is enabled. The RVV machine modes size remains default\n+     compile-time constant if TARGET_VECTOR is disabled.  */\n+  return TARGET_VECTOR ? poly_uint16 (1, 1) : 1;\n }\n \n /* Implement TARGET_OPTION_OVERRIDE.  */\n@@ -6002,6 +6273,23 @@ riscv_init_libfuncs (void)\n   set_optab_libfunc (unord_optab, HFmode, NULL);\n }\n \n+#if CHECKING_P\n+void\n+riscv_reinit (void)\n+{\n+  riscv_option_override ();\n+  init_adjust_machine_modes ();\n+  init_derived_machine_modes ();\n+  reinit_regs ();\n+  init_optabs ();\n+}\n+#endif\n+\n+#if CHECKING_P\n+#undef TARGET_RUN_TARGET_SELFTESTS\n+#define TARGET_RUN_TARGET_SELFTESTS selftest::riscv_run_selftests\n+#endif /* #if CHECKING_P */\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\""}, {"sha": "2b82e5f2399191933d444eab2db5fe008ee5f3a6", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -23,6 +23,10 @@ riscv-shorten-memrefs.o: $(srcdir)/config/riscv/riscv-shorten-memrefs.cc\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+riscv-selftests.o: $(srcdir)/config/riscv/riscv-selftests.cc\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n PASSES_EXTRA += $(srcdir)/config/riscv/riscv-passes.def\n \n $(common_out_file): $(srcdir)/config/riscv/riscv-cores.def \\"}, {"sha": "32bcf72b86de2aa6da0e9a694955284283ce11c8", "filename": "gcc/testsuite/selftests/riscv/empty-func.rtl", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Ftestsuite%2Fselftests%2Friscv%2Fempty-func.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4feb49cf308b344fba6a72137df58de382fcb9d/gcc%2Ftestsuite%2Fselftests%2Friscv%2Fempty-func.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Friscv%2Fempty-func.rtl?ref=b4feb49cf308b344fba6a72137df58de382fcb9d", "patch": "@@ -0,0 +1,8 @@\n+(function \"func\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}]}