{"sha": "aa44273b85d17ab119a65ac6852bb6061bbeac05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0NDI3M2I4NWQxN2FiMTE5YTY1YWM2ODUyYmI2MDYxYmJlYWMwNQ==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2003-10-03T18:43:06Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2003-10-03T18:43:06Z"}, "message": "configure.in: Remove NO_GETENV definition for win32.\n\n\t* configure.in: Remove NO_GETENV definition for win32.\n\t* mach_dep.c (GC_generic_push_regs): Prevent tail call optimization.\n\t* misc.c (GC_init_inner): Call GC_thr_init for win32.\n\t  (GC_set_warn_proc): Add assertion.\n\t* win32_threads.c: Import 6.3alpha2 version.\n\t* include/private/gc_priv.h: Add support for EMPTY_GETENV_RESULTS.\n\nFrom-SVN: r72074", "tree": {"sha": "24628e70256e7b26eb5d3ef1d7173ad25c32fea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24628e70256e7b26eb5d3ef1d7173ad25c32fea6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa44273b85d17ab119a65ac6852bb6061bbeac05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa44273b85d17ab119a65ac6852bb6061bbeac05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa44273b85d17ab119a65ac6852bb6061bbeac05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa44273b85d17ab119a65ac6852bb6061bbeac05/comments", "author": null, "committer": null, "parents": [{"sha": "f451eeefad9f818fded92b2d0d8fbb0ca6b2456c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f451eeefad9f818fded92b2d0d8fbb0ca6b2456c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f451eeefad9f818fded92b2d0d8fbb0ca6b2456c"}], "stats": {"total": 827, "additions": 387, "deletions": 440}, "files": [{"sha": "f38b21894f27303c25c861667bee449c886ec5e7", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=aa44273b85d17ab119a65ac6852bb6061bbeac05", "patch": "@@ -1,3 +1,12 @@\n+2003-10-03  Hans Boehm  <Hans.Boehm@hp.com>\n+\n+\t* configure.in: Remove NO_GETENV definition for win32.\n+\t* mach_dep.c (GC_generic_push_regs): Prevent tail call optimization.\n+\t* misc.c (GC_init_inner): Call GC_thr_init for win32.\n+\t  (GC_set_warn_proc): Add assertion.\n+\t* win32_threads.c: Import 6.3alpha2 version.\n+\t* include/private/gc_priv.h: Add support for EMPTY_GETENV_RESULTS.\n+\n 2003-09-29  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* configure.in: Remove wildcard from Solaris 8-9/Intel and Solaris"}, {"sha": "85d0eeb707ce9c970b386c325accd9ac50aac4f8", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=aa44273b85d17ab119a65ac6852bb6061bbeac05", "patch": "@@ -137,8 +137,8 @@ case \"$THREADS\" in\n     ;;\n  win32)\n     AC_DEFINE(GC_WIN32_THREADS)\n-    dnl Wine getenv may not return NULL for missing entry\n-    AC_DEFINE(NO_GETENV)\n+    dnl Old wine getenv may not return NULL for missing entry.\n+    dnl Define EMPTY_GETENV_RESULTS here to work around the bug.\n     ;;\n  dgux386)\n     THREADS=dgux386"}, {"sha": "5e7625fb15069156f4608ff96036ffe9a81bf481", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=aa44273b85d17ab119a65ac6852bb6061bbeac05", "patch": "@@ -448,7 +448,19 @@ extern GC_warn_proc GC_current_warn_proc;\n \n /* Get environment entry */\n #if !defined(NO_GETENV)\n-#   define GETENV(name) getenv(name)\n+#   if defined(EMPTY_GETENV_RESULTS)\n+\t/* Workaround for a reputed Wine bug.\t*/\n+\tstatic inline char * fixed_getenv(const char *name)\n+\t{\n+\t  char * tmp = getenv(name);\n+\t  if (tmp == 0 || strlen(tmp) == 0)\n+\t    return 0;\n+\t  return tmp;\n+\t}\n+#       define GETENV(name) fixed_getenv(name)\n+#   else\n+#       define GETENV(name) getenv(name)\n+#   endif\n #else\n #   define GETENV(name) 0\n #endif"}, {"sha": "2c321fa978d731de57a347a7590b2f71687b8c2a", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=aa44273b85d17ab119a65ac6852bb6061bbeac05", "patch": "@@ -405,6 +405,8 @@ void GC_generic_push_regs(cold_gc_frame)\n ptr_t cold_gc_frame;\n {\n \t{\n+\t    word dummy;\n+\n #\t    ifdef HAVE_BUILTIN_UNWIND_INIT\n \t      /* This was suggested by Richard Henderson as the way to\t*/\n \t      /* force callee-save registers and register windows onto\t*/\n@@ -448,6 +450,10 @@ ptr_t cold_gc_frame;\n \t      }\n #           endif\n \t    GC_push_current_stack(cold_gc_frame);\n+\t    /* Strongly discourage the compiler from treating the above\t*/\n+\t    /* as a tail-call, since that would pop the register \t*/\n+\t    /* contents before we get a chance to look at them.\t\t*/\n+\t    GC_noop1((word)(&dummy));\n \t}\n }\n #endif /* USE_GENERIC_PUSH_REGS */"}, {"sha": "12d6d2e2ba67268ae6a8fcdbc4676904169de192", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=aa44273b85d17ab119a65ac6852bb6061bbeac05", "patch": "@@ -638,7 +638,8 @@ void GC_init_inner()\n #   if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__)\n \tGC_init_netbsd_elf();\n #   endif\n-#   if defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS)\n+#   if defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS) \\\n+       || defined(GC_WIN32_THREADS)\n         GC_thr_init();\n #   endif\n #   ifdef GC_SOLARIS_THREADS\n@@ -1002,6 +1003,9 @@ GC_warn_proc GC_current_warn_proc = GC_default_warn_proc;\n {\n     GC_warn_proc result;\n \n+#   ifdef GC_WIN32_THREADS\n+      GC_ASSERT(GC_is_initialized);\n+#   endif\n     LOCK();\n     result = GC_current_warn_proc;\n     GC_current_warn_proc = p;"}, {"sha": "7a1dbe27cd294ceff6f1512c23d108d9d4a4a721", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 352, "deletions": 436, "changes": 788, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa44273b85d17ab119a65ac6852bb6061bbeac05/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=aa44273b85d17ab119a65ac6852bb6061bbeac05", "patch": "@@ -14,36 +14,205 @@\n \n # define DEBUG_CYGWIN_THREADS 0\n \n-  GC_bool GC_thr_initialized = FALSE;\n   void * GC_start_routine(void * arg);\n   void GC_thread_exit_proc(void *arg);\n \n #endif\n \n+/* The type of the first argument to InterlockedExchange.\t*/\n+/* Documented to be LONG volatile *, but at least gcc likes \t*/\n+/* this better.\t\t\t\t\t\t\t*/\n+typedef LONG * IE_t;\n+\n #ifndef MAX_THREADS\n-# define MAX_THREADS 64\n+# define MAX_THREADS 256\n+    /* FIXME:\t\t\t\t\t\t\t*/\n+    /* Things may get quite slow for large numbers of threads,\t*/\n+    /* since we look them up with sequential search.\t\t*/\n #endif\n \n-struct thread_entry {\n-  LONG in_use;\n+GC_bool GC_thr_initialized = FALSE;\n+\n+DWORD GC_main_thread = 0;\n+\n+struct GC_thread_Rep {\n+  LONG in_use; /* Updated without lock.\t*/\n+  \t\t\t/* We assert that unused \t*/\n+  \t\t\t/* entries have invalid ids of\t*/\n+  \t\t\t/* zero and zero stack fields.  */\n   DWORD id;\n   HANDLE handle;\n-  void *stack;\t\t/* The cold end of the stack.   */\n+  ptr_t stack_base;\t/* The cold end of the stack.   */\n \t\t\t/* 0 ==> entry not valid.\t*/\n-\t\t\t/* !in_use ==> stack == 0\t*/\n-  CONTEXT context;\n+\t\t\t/* !in_use ==> stack_base == 0\t*/\n   GC_bool suspended;\n \n # ifdef CYGWIN32\n     void *status; /* hold exit value until join in case it's a pointer */\n     pthread_t pthread_id;\n+    short flags;\t\t/* Protected by GC lock.\t*/\n+#\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n+#\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n # endif\n-\n };\n \n+typedef volatile struct GC_thread_Rep * GC_thread;\n+\n+/*\n+ * We generally assume that volatile ==> memory ordering, at least among\n+ * volatiles.\n+ */\n+\n volatile GC_bool GC_please_stop = FALSE;\n \n-volatile struct thread_entry thread_table[MAX_THREADS];\n+volatile struct GC_thread_Rep thread_table[MAX_THREADS];\n+\n+volatile LONG GC_max_thread_index = 0; /* Largest index in thread_table\t*/\n+\t\t\t\t       /* that was ever used.\t\t*/\n+\n+extern LONG WINAPI GC_write_fault_handler(struct _EXCEPTION_POINTERS *exc_info);\n+\n+/*\n+ * This may be called from DllMain, and hence operates under unusual\n+ * constraints.\n+ */\n+static GC_thread GC_new_thread(void) {\n+  int i;\n+  /* It appears to be unsafe to acquire a lock here, since this\t*/\n+  /* code is apparently not preeemptible on some systems.\t*/\n+  /* (This is based on complaints, not on Microsoft's official\t*/\n+  /* documentation, which says this should perform \"only simple\t*/\n+  /* initialization tasks\".)\t\t\t\t\t*/\n+  /* Hence we make do with nonblocking synchronization.\t\t*/\n+\n+  /* The following should be a noop according to the win32\t*/\n+  /* documentation.  There is empirical evidence that it\t*/\n+  /* isn't.\t\t- HB\t\t\t\t\t*/\n+# if defined(MPROTECT_VDB)\n+   if (GC_incremental) SetUnhandledExceptionFilter(GC_write_fault_handler);\n+# endif\n+                /* cast away volatile qualifier */\n+  for (i = 0; InterlockedExchange((IE_t)&thread_table[i].in_use,1) != 0; i++) {\n+    /* Compare-and-swap would make this cleaner, but that's not \t*/\n+    /* supported before Windows 98 and NT 4.0.  In Windows 2000,\t*/\n+    /* InterlockedExchange is supposed to be replaced by\t\t*/\n+    /* InterlockedExchangePointer, but that's not really what I\t\t*/\n+    /* want here.\t\t\t\t\t\t\t*/\n+    if (i == MAX_THREADS - 1)\n+      ABORT(\"too many threads\");\n+  }\n+  /* Update GC_max_thread_index if necessary.  The following is safe,\t*/\n+  /* and unlike CompareExchange-based solutions seems to work on all\t*/\n+  /* Windows95 and later platforms.\t\t\t\t\t*/\n+  /* Unfortunately, GC_max_thread_index may be temporarily out of \t*/\n+  /* bounds, so readers have to compensate.\t\t\t\t*/\n+  while (i > GC_max_thread_index) {\n+    InterlockedIncrement((IE_t)&GC_max_thread_index);\n+  }\n+  if (GC_max_thread_index >= MAX_THREADS) {\n+    /* We overshot due to simultaneous increments.\t*/\n+    /* Setting it to MAX_THREADS-1 is always safe.\t*/\n+    GC_max_thread_index = MAX_THREADS - 1;\n+  }\n+  \n+# ifdef CYGWIN32\n+    thread_table[i].pthread_id = pthread_self();\n+# endif\n+  if (!DuplicateHandle(GetCurrentProcess(),\n+\t               GetCurrentThread(),\n+\t\t       GetCurrentProcess(),\n+\t\t       (HANDLE*)&thread_table[i].handle,\n+\t\t       0,\n+\t\t       0,\n+\t\t       DUPLICATE_SAME_ACCESS)) {\n+\tDWORD last_error = GetLastError();\n+\tGC_printf1(\"Last error code: %lx\\n\", last_error);\n+\tABORT(\"DuplicateHandle failed\");\n+  }\n+  thread_table[i].stack_base = GC_get_stack_base();\n+  /* Up until this point, GC_psuh_all_stacks considers this thread\t*/\n+  /* invalid.\t\t\t\t\t\t\t\t*/\n+  if (thread_table[i].stack_base == NULL) \n+    ABORT(\"Failed to find stack base in GC_new_thread\");\n+  /* Up until this point, this entry is viewed as reserved but invalid\t*/\n+  /* by GC_delete_thread.\t\t\t\t\t\t*/\n+  thread_table[i].id = GetCurrentThreadId();\n+  /* If this thread is being created while we are trying to stop\t*/\n+  /* the world, wait here.  Hopefully this can't happen on any\t*/\n+  /* systems that don't allow us to block here.\t\t\t*/\n+  while (GC_please_stop) Sleep(20);\n+  return thread_table + i;\n+}\n+\n+/*\n+ * GC_max_thread_index may temporarily be larger than MAX_THREADS.\n+ * To avoid subscript errors, we check on access.\n+ */\n+#ifdef __GNUC__\n+__inline__\n+#endif\n+LONG GC_get_max_thread_index()\n+{\n+  LONG my_max = GC_max_thread_index;\n+\n+  if (my_max >= MAX_THREADS) return MAX_THREADS-1;\n+  return my_max;\n+}\n+\n+/* This is intended to be lock-free, though that\t\t\t*/\n+/* assumes that the CloseHandle becomes visible before the \t\t*/\n+/* in_use assignment.\t\t\t\t\t\t\t*/\n+static void GC_delete_gc_thread(GC_thread thr)\n+{\n+    CloseHandle(thr->handle);\n+      /* cast away volatile qualifier */\n+    thr->stack_base = 0;\n+    thr->id = 0;\n+#   ifdef CYGWIN32\n+      thr->pthread_id = 0;\n+#   endif /* CYGWIN32 */\n+    thr->in_use = FALSE;\n+}\n+\n+static void GC_delete_thread(DWORD thread_id) {\n+  int i;\n+  LONG my_max = GC_get_max_thread_index();\n+\n+  for (i = 0;\n+       i <= my_max &&\n+       (!thread_table[i].in_use || thread_table[i].id != thread_id);\n+       /* Must still be in_use, since nobody else can store our thread_id. */\n+       i++) {}\n+  if (i > my_max) {\n+    WARN(\"Removing nonexisiting thread %ld\\n\", (GC_word)thread_id);\n+  } else {\n+    GC_delete_gc_thread(thread_table+i);\n+  }\n+}\n+\n+\n+#ifdef CYGWIN32\n+\n+/* Return a GC_thread corresponding to a given pthread_t.\t*/\n+/* Returns 0 if it's not there.\t\t\t\t\t*/\n+/* We assume that this is only called for pthread ids that\t*/\n+/* have not yet terminated or are still joinable.\t\t*/\n+static GC_thread GC_lookup_thread(pthread_t id)\n+{\n+  int i;\n+  LONG my_max = GC_get_max_thread_index();\n+\n+  for (i = 0;\n+       i <= my_max &&\n+       (!thread_table[i].in_use || thread_table[i].pthread_id != id\n+\t|| !thread_table[i].in_use);\n+       /* Must still be in_use, since nobody else can store our thread_id. */\n+       i++);\n+  if (i > my_max) return 0;\n+  return thread_table + i;\n+}\n+\n+#endif /* CYGWIN32 */\n \n void GC_push_thread_structures GC_PROTO((void))\n {\n@@ -52,8 +221,12 @@ void GC_push_thread_structures GC_PROTO((void))\n     /* no private structures we need to preserve.\t\t\t*/\n # ifdef CYGWIN32\n   { int i; /* pthreads may keep a pointer in the thread exit value */\n-    for (i = 0; i < MAX_THREADS; i++)\n-      if (thread_table[i].in_use) GC_push_all((ptr_t)&(thread_table[i].status),(ptr_t)(&(thread_table[i].status)+1));\n+    LONG my_max = GC_get_max_thread_index();\n+\n+    for (i = 0; i <= my_max; i++)\n+      if (thread_table[i].in_use)\n+\tGC_push_all((ptr_t)&(thread_table[i].status),\n+                    (ptr_t)(&(thread_table[i].status)+1));\n   }\n # endif\n }\n@@ -63,13 +236,11 @@ void GC_stop_world()\n   DWORD thread_id = GetCurrentThreadId();\n   int i;\n \n-#ifdef CYGWIN32\n   if (!GC_thr_initialized) ABORT(\"GC_stop_world() called before GC_thr_init()\");\n-#endif\n \n   GC_please_stop = TRUE;\n-  for (i = 0; i < MAX_THREADS; i++)\n-    if (thread_table[i].stack != 0\n+  for (i = 0; i <= GC_get_max_thread_index(); i++)\n+    if (thread_table[i].stack_base != 0\n \t&& thread_table[i].id != thread_id) {\n #     ifdef MSWINCE\n         /* SuspendThread will fail if thread is running kernel code */\n@@ -84,13 +255,12 @@ void GC_stop_world()\n \tDWORD exitCode; \n \tif (GetExitCodeThread(thread_table[i].handle,&exitCode) &&\n             exitCode != STILL_ACTIVE) {\n-          thread_table[i].stack = 0; /* prevent stack from being pushed */\n+          thread_table[i].stack_base = 0; /* prevent stack from being pushed */\n #         ifndef CYGWIN32\n             /* this breaks pthread_join on Cygwin, which is guaranteed to  */\n \t    /* only see user pthreads \t\t\t\t\t   */\n \t    thread_table[i].in_use = FALSE;\n \t    CloseHandle(thread_table[i].handle);\n-\t    BZERO((void *)(&thread_table[i].context), sizeof(CONTEXT));\n #         endif\n \t  continue;\n \t}\n@@ -105,8 +275,10 @@ void GC_start_world()\n {\n   DWORD thread_id = GetCurrentThreadId();\n   int i;\n-  for (i = 0; i < MAX_THREADS; i++)\n-    if (thread_table[i].stack != 0 && thread_table[i].suspended\n+  LONG my_max = GC_get_max_thread_index();\n+\n+  for (i = 0; i <= my_max; i++)\n+    if (thread_table[i].stack_base != 0 && thread_table[i].suspended\n \t&& thread_table[i].id != thread_id) {\n       if (ResumeThread(thread_table[i].handle) == (DWORD)-1)\n \tABORT(\"ResumeThread failed\");\n@@ -122,9 +294,11 @@ ptr_t GC_current_stackbottom()\n {\n   DWORD thread_id = GetCurrentThreadId();\n   int i;\n-  for (i = 0; i < MAX_THREADS; i++)\n-    if (thread_table[i].stack && thread_table[i].id == thread_id)\n-      return thread_table[i].stack;\n+  LONG my_max = GC_get_max_thread_index();\n+\n+  for (i = 0; i <= my_max; i++)\n+    if (thread_table[i].stack_base && thread_table[i].id == thread_id)\n+      return thread_table[i].stack_base;\n   ABORT(\"no thread table entry for current thread\");\n }\n # ifdef _MSC_VER\n@@ -135,10 +309,10 @@ ptr_t GC_current_stackbottom()\n     /* The VirtualQuery calls below won't work properly on WinCE, but\t*/\n     /* since each stack is restricted to an aligned 64K region of\t*/\n     /* virtual memory we can just take the next lowest multiple of 64K.\t*/\n-#   define GC_get_lo_stack_addr(s) \\\n+#   define GC_get_stack_min(s) \\\n         ((ptr_t)(((DWORD)(s) - 1) & 0xFFFF0000))\n # else\n-    static ptr_t GC_get_lo_stack_addr(ptr_t s)\n+    static ptr_t GC_get_stack_min(ptr_t s)\n     {\n \tptr_t bottom;\n \tMEMORY_BASIC_INFORMATION info;\n@@ -155,207 +329,87 @@ ptr_t GC_current_stackbottom()\n void GC_push_all_stacks()\n {\n   DWORD thread_id = GetCurrentThreadId();\n+  GC_bool found_me = FALSE;\n   int i;\n-  for (i = 0; i < MAX_THREADS; i++)\n-    if (thread_table[i].stack) {\n-      ptr_t bottom = GC_get_lo_stack_addr(thread_table[i].stack);\n-      if (thread_table[i].id == thread_id)\n-\tGC_push_all_stack((ptr_t)&i, thread_table[i].stack);\n-      else {\n-\tthread_table[i].context.ContextFlags\n-\t\t\t= (CONTEXT_INTEGER|CONTEXT_CONTROL);\n-\tif (!GetThreadContext(thread_table[i].handle,\n-\t\t\t\t/* cast away volatile qualifier */\n-\t    \t\t        (LPCONTEXT)&thread_table[i].context))\n+  int dummy;\n+  ptr_t sp, stack_min;\n+  GC_thread thread;\n+  LONG my_max = GC_get_max_thread_index();\n+  \n+  for (i = 0; i <= my_max; i++) {\n+    thread = thread_table + i;\n+    if (thread -> in_use && thread -> stack_base) {\n+      if (thread -> id == thread_id) {\n+\tsp = (ptr_t) &dummy;\n+\tfound_me = TRUE;\n+      } else {\n+        CONTEXT context;\n+        context.ContextFlags = CONTEXT_INTEGER|CONTEXT_CONTROL;\n+        if (!GetThreadContext(thread_table[i].handle, &context))\n \t  ABORT(\"GetThreadContext failed\");\n-#\tifdef I386\n-\t  GC_push_one ((word) thread_table[i].context.Edi);\n-    \t  GC_push_one ((word) thread_table[i].context.Esi);\n-    \t  GC_push_one ((word) thread_table[i].context.Ebp);\n-    \t  GC_push_one ((word) thread_table[i].context.Ebx);\n-    \t  GC_push_one ((word) thread_table[i].context.Edx);\n-    \t  GC_push_one ((word) thread_table[i].context.Ecx);\n-    \t  GC_push_one ((word) thread_table[i].context.Eax);\n-\t  if (thread_table[i].context.Esp >= (DWORD)thread_table[i].stack\n-\t      || thread_table[i].context.Esp < (DWORD)bottom) {\n-\t      WARN(\"Thread stack pointer 0x%lx out of range, pushing everything\",\n-\t\t   thread_table[i].context.Esp);\n-\t      GC_push_all_stack((char *) bottom, thread_table[i].stack);\n-\t  } else {\n-\t      GC_push_all_stack((char *) thread_table[i].context.Esp,\n-\t\t\t        thread_table[i].stack);\n-\t  }\n-#       else\n-#       ifdef ARM32\n-\t  if (thread_table[i].context.Sp >= (DWORD)thread_table[i].stack\n-\t      || thread_table[i].context.Sp < (DWORD)bottom)\n-\t      ABORT(\"Thread stack pointer out of range\");\n-\t  GC_push_one ((word) thread_table[i].context.R0);\n-\t  GC_push_one ((word) thread_table[i].context.R1);\n-\t  GC_push_one ((word) thread_table[i].context.R2);\n-\t  GC_push_one ((word) thread_table[i].context.R3);\n-\t  GC_push_one ((word) thread_table[i].context.R4);\n-\t  GC_push_one ((word) thread_table[i].context.R5);\n-\t  GC_push_one ((word) thread_table[i].context.R6);\n-\t  GC_push_one ((word) thread_table[i].context.R7);\n-\t  GC_push_one ((word) thread_table[i].context.R8);\n-\t  GC_push_one ((word) thread_table[i].context.R9);\n-\t  GC_push_one ((word) thread_table[i].context.R10);\n-\t  GC_push_one ((word) thread_table[i].context.R11);\n-\t  GC_push_one ((word) thread_table[i].context.R12);\n-\t  GC_push_all_stack((char *) thread_table[i].context.Sp,\n-\t\t\t    thread_table[i].stack);\n-#       else\n-#\tifdef SHx\n-\t  if (thread_table[i].context.R15 >= (DWORD)thread_table[i].stack\n-\t      || thread_table[i].context.R15 < (DWORD)bottom)\n-\t      ABORT(\"Thread stack pointer out of range\");\n-\t  GC_push_one ((word) thread_table[i].context.R0);\n-\t  GC_push_one ((word) thread_table[i].context.R1);\n-\t  GC_push_one ((word) thread_table[i].context.R2);\n-\t  GC_push_one ((word) thread_table[i].context.R3);\n-\t  GC_push_one ((word) thread_table[i].context.R4);\n-\t  GC_push_one ((word) thread_table[i].context.R5);\n-\t  GC_push_one ((word) thread_table[i].context.R6);\n-\t  GC_push_one ((word) thread_table[i].context.R7);\n-\t  GC_push_one ((word) thread_table[i].context.R8);\n-\t  GC_push_one ((word) thread_table[i].context.R9);\n-\t  GC_push_one ((word) thread_table[i].context.R10);\n-\t  GC_push_one ((word) thread_table[i].context.R11);\n-\t  GC_push_one ((word) thread_table[i].context.R12);\n-\t  GC_push_one ((word) thread_table[i].context.R13);\n-\t  GC_push_one ((word) thread_table[i].context.R14);\n-\t  GC_push_all_stack((char *) thread_table[i].context.R15,\n-\t\t\t    thread_table[i].stack);\n+\n+        /* Push all registers that might point into the heap.  Frame\t*/\n+        /* pointer registers are included in case client code was\t*/\n+        /* compiled with the 'omit frame pointer' optimisation.\t\t*/\n+#       define PUSH1(reg) GC_push_one((word)context.reg)\n+#       define PUSH2(r1,r2) PUSH1(r1), PUSH1(r2)\n+#       define PUSH4(r1,r2,r3,r4) PUSH2(r1,r2), PUSH2(r3,r4)\n+#       if defined(I386)\n+          PUSH4(Edi,Esi,Ebx,Edx), PUSH2(Ecx,Eax), PUSH1(Ebp);\n+\t  sp = (ptr_t)context.Esp;\n+#       elif defined(ARM32)\n+\t  PUSH4(R0,R1,R2,R3),PUSH4(R4,R5,R6,R7),PUSH4(R8,R9,R10,R11),PUSH1(R12);\n+\t  sp = (ptr_t)context.Sp;\n+#       elif defined(SHx)\n+\t  PUSH4(R0,R1,R2,R3), PUSH4(R4,R5,R6,R7), PUSH4(R8,R9,R10,R11);\n+\t  PUSH2(R12,R13), PUSH1(R14);\n+\t  sp = (ptr_t)context.R15;\n+#       elif defined(MIPS)\n+\t  PUSH4(IntAt,IntV0,IntV1,IntA0), PUSH4(IntA1,IntA2,IntA3,IntT0);\n+\t  PUSH4(IntT1,IntT2,IntT3,IntT4), PUSH4(IntT5,IntT6,IntT7,IntS0);\n+\t  PUSH4(IntS1,IntS2,IntS3,IntS4), PUSH4(IntS5,IntS6,IntS7,IntT8);\n+\t  PUSH4(IntT9,IntK0,IntK1,IntS8);\n+\t  sp = (ptr_t)context.IntSp;\n+#       elif defined(PPC)\n+\t  PUSH4(Gpr0, Gpr3, Gpr4, Gpr5),  PUSH4(Gpr6, Gpr7, Gpr8, Gpr9);\n+\t  PUSH4(Gpr10,Gpr11,Gpr12,Gpr14), PUSH4(Gpr15,Gpr16,Gpr17,Gpr18);\n+\t  PUSH4(Gpr19,Gpr20,Gpr21,Gpr22), PUSH4(Gpr23,Gpr24,Gpr25,Gpr26);\n+\t  PUSH4(Gpr27,Gpr28,Gpr29,Gpr30), PUSH1(Gpr31);\n+\t  sp = (ptr_t)context.Gpr1;\n+#       elif defined(ALPHA)\n+\t  PUSH4(IntV0,IntT0,IntT1,IntT2), PUSH4(IntT3,IntT4,IntT5,IntT6);\n+\t  PUSH4(IntT7,IntS0,IntS1,IntS2), PUSH4(IntS3,IntS4,IntS5,IntFp);\n+\t  PUSH4(IntA0,IntA1,IntA2,IntA3), PUSH4(IntA4,IntA5,IntT8,IntT9);\n+\t  PUSH4(IntT10,IntT11,IntT12,IntAt);\n+\t  sp = (ptr_t)context.IntSp;\n #       else\n-#\tifdef MIPS\n-\t  if (thread_table[i].context.IntSp >= (DWORD)thread_table[i].stack\n-\t      || thread_table[i].context.IntSp < (DWORD)bottom)\n-\t      ABORT(\"Thread stack pointer out of range\");\n-\t  GC_push_one ((word) thread_table[i].context.IntAt);\n-\t  GC_push_one ((word) thread_table[i].context.IntV0);\n-\t  GC_push_one ((word) thread_table[i].context.IntV1);\n-\t  GC_push_one ((word) thread_table[i].context.IntA0);\n-\t  GC_push_one ((word) thread_table[i].context.IntA1);\n-\t  GC_push_one ((word) thread_table[i].context.IntA2);\n-\t  GC_push_one ((word) thread_table[i].context.IntA3);\n-\t  GC_push_one ((word) thread_table[i].context.IntT0);\n-\t  GC_push_one ((word) thread_table[i].context.IntT1);\n-\t  GC_push_one ((word) thread_table[i].context.IntT2);\n-\t  GC_push_one ((word) thread_table[i].context.IntT3);\n-\t  GC_push_one ((word) thread_table[i].context.IntT4);\n-\t  GC_push_one ((word) thread_table[i].context.IntT5);\n-\t  GC_push_one ((word) thread_table[i].context.IntT6);\n-\t  GC_push_one ((word) thread_table[i].context.IntT7);\n-\t  GC_push_one ((word) thread_table[i].context.IntS0);\n-\t  GC_push_one ((word) thread_table[i].context.IntS1);\n-\t  GC_push_one ((word) thread_table[i].context.IntS2);\n-\t  GC_push_one ((word) thread_table[i].context.IntS3);\n-\t  GC_push_one ((word) thread_table[i].context.IntS4);\n-\t  GC_push_one ((word) thread_table[i].context.IntS5);\n-\t  GC_push_one ((word) thread_table[i].context.IntS6);\n-\t  GC_push_one ((word) thread_table[i].context.IntS7);\n-\t  GC_push_one ((word) thread_table[i].context.IntT8);\n-\t  GC_push_one ((word) thread_table[i].context.IntT9);\n-\t  GC_push_one ((word) thread_table[i].context.IntK0);\n-\t  GC_push_one ((word) thread_table[i].context.IntK1);\n-\t  GC_push_one ((word) thread_table[i].context.IntS8);\n-\t  GC_push_all_stack((char *) thread_table[i].context.IntSp,\n-\t\t\t    thread_table[i].stack);\n-#\telse\n-#\tifdef PPC\n-\t  if (thread_table[i].context.Gpr1 >= (DWORD)thread_table[i].stack\n-\t      || thread_table[i].context.Gpr1 < (DWORD)bottom)\n-\t      ABORT(\"Thread stack pointer out of range\");\n-\t  GC_push_one ((word) thread_table[i].context.Gpr0);\n-\t  /* Gpr1 is stack pointer */\n-\t  /* Gpr2 is global pointer */\n-\t  GC_push_one ((word) thread_table[i].context.Gpr3);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr4);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr5);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr6);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr7);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr8);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr9);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr10);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr11);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr12);\n-\t  /* Gpr13 is reserved for the kernel */\n-\t  GC_push_one ((word) thread_table[i].context.Gpr14);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr15);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr16);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr17);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr18);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr19);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr20);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr21);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr22);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr23);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr24);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr25);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr26);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr27);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr28);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr29);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr30);\n-\t  GC_push_one ((word) thread_table[i].context.Gpr31);\n-\t  GC_push_all_stack((char *) thread_table[i].context.Gpr1,\n-\t\t\t    thread_table[i].stack);\n-#\telse\n-#\tifdef ALPHA\n-\t  if (thread_table[i].context.IntSp >= (DWORD)thread_table[i].stack\n-\t      || thread_table[i].context.IntSp < (DWORD)bottom)\n-\t      ABORT(\"Thread stack pointer out of range\");\n-\t  GC_push_one ((word) thread_table[i].context.IntV0);\n-\t  GC_push_one ((word) thread_table[i].context.IntT0);\n-\t  GC_push_one ((word) thread_table[i].context.IntT1);\n-\t  GC_push_one ((word) thread_table[i].context.IntT2);\n-\t  GC_push_one ((word) thread_table[i].context.IntT3);\n-\t  GC_push_one ((word) thread_table[i].context.IntT4);\n-\t  GC_push_one ((word) thread_table[i].context.IntT5);\n-\t  GC_push_one ((word) thread_table[i].context.IntT6);\n-\t  GC_push_one ((word) thread_table[i].context.IntT7);\n-\t  GC_push_one ((word) thread_table[i].context.IntS0);\n-\t  GC_push_one ((word) thread_table[i].context.IntS1);\n-\t  GC_push_one ((word) thread_table[i].context.IntS2);\n-\t  GC_push_one ((word) thread_table[i].context.IntS3);\n-\t  GC_push_one ((word) thread_table[i].context.IntS4);\n-\t  GC_push_one ((word) thread_table[i].context.IntS5);\n-\t  GC_push_one ((word) thread_table[i].context.IntFp);\n-\t  GC_push_one ((word) thread_table[i].context.IntA0);\n-\t  GC_push_one ((word) thread_table[i].context.IntA1);\n-\t  GC_push_one ((word) thread_table[i].context.IntA2);\n-\t  GC_push_one ((word) thread_table[i].context.IntA3);\n-\t  GC_push_one ((word) thread_table[i].context.IntA4);\n-\t  GC_push_one ((word) thread_table[i].context.IntA5);\n-\t  GC_push_one ((word) thread_table[i].context.IntT8);\n-\t  GC_push_one ((word) thread_table[i].context.IntT9);\n-\t  GC_push_one ((word) thread_table[i].context.IntT10);\n-\t  GC_push_one ((word) thread_table[i].context.IntT11);\n-\t  GC_push_one ((word) thread_table[i].context.IntT12);\n-\t  GC_push_one ((word) thread_table[i].context.IntAt);\n-\t  GC_push_all_stack((char *) thread_table[i].context.IntSp,\n-\t\t\t    thread_table[i].stack);\n-#\telse\n-\t      --> architecture not supported\n-#\tendif /* !ALPHA */\n-#\tendif /* !PPC */\n-#\tendif /* !MIPS */\n-#\tendif /* !SHx */\n-#\tendif /* !ARM32 */\n-#\tendif /* !I386 */\n+#         error \"architecture is not supported\"\n+#       endif\n+      }\n+\n+      stack_min = GC_get_stack_min(thread->stack_base);\n+\n+      if (sp >= stack_min && sp < thread->stack_base)\n+        GC_push_all_stack(sp, thread->stack_base);\n+      else {\n+        WARN(\"Thread stack pointer 0x%lx out of range, pushing everything\\n\",\n+\t     (unsigned long)sp);\n+        GC_push_all_stack(stack_min, thread->stack_base);\n       }\n     }\n+  }\n+  if (!found_me) ABORT(\"Collecting from unknown thread.\");\n }\n \n void GC_get_next_stack(char *start, char **lo, char **hi)\n {\n     int i;\n #   define ADDR_LIMIT (char *)(-1L)\n     char * current_min = ADDR_LIMIT;\n-\n-    for (i = 0; i < MAX_THREADS; i++) {\n-    \tchar * s = (char *)thread_table[i].stack;\n+    LONG my_max = GC_get_max_thread_index();\n+  \n+    for (i = 0; i <= my_max; i++) {\n+    \tchar * s = (char *)thread_table[i].stack_base;\n \n \tif (0 != s && s > start && s < current_min) {\n \t    current_min = s;\n@@ -366,7 +420,7 @@ void GC_get_next_stack(char *start, char **lo, char **hi)\n     \t*lo = ADDR_LIMIT;\n \treturn;\n     }\n-    *lo = GC_get_lo_stack_addr(current_min);\n+    *lo = GC_get_stack_min(current_min);\n     if (*lo < start) *lo = start;\n }\n \n@@ -391,8 +445,6 @@ GC_API HANDLE WINAPI GC_CreateThread(\n /* must properly intercept thread creation.\t\t\t*/\n \n typedef struct {\n-    HANDLE child_ready_h, parent_ready_h;\n-    volatile struct thread_entry * entry;\n     LPTHREAD_START_ROUTINE start;\n     LPVOID param;\n } thread_args;\n@@ -405,117 +457,50 @@ GC_API HANDLE WINAPI GC_CreateThread(\n     LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId )\n {\n     HANDLE thread_h = NULL;\n-    HANDLE child_ready_h, parent_ready_h;\n \n-    int i;\n-    thread_args args;\n+    thread_args *args;\n \n-    /* allocate thread slot */\n-    LOCK();\n-    for (i = 0; i != MAX_THREADS && thread_table[i].in_use; i++)\n-\t;\n-    if (i != MAX_THREADS) {\n-\tthread_table[i].in_use = TRUE;\n+    if (!GC_is_initialized) GC_init();\n+    \t\t/* make sure GC is initialized (i.e. main thread is attached) */\n+    \n+    args = GC_malloc_uncollectable(sizeof(thread_args)); \n+\t/* Handed off to and deallocated by child thread.\t*/\n+    if (0 == args) {\n+\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n+        return NULL;\n     }\n-    UNLOCK();\n \n-    if (i != MAX_THREADS) {\n-\n-\t/* create unnamed unsignalled events */\n-\tif (child_ready_h = CreateEvent(NULL, FALSE, FALSE, NULL)) {\n-\t    if (parent_ready_h = CreateEvent(NULL, FALSE, FALSE, NULL)) {\n-\n-\t\t/* set up thread arguments */\n-\t\targs.child_ready_h = child_ready_h;\n-\t\targs.parent_ready_h = parent_ready_h;\n-\t\targs.entry = &thread_table[i];\n-\t\targs.start = lpStartAddress;\n-\t\targs.param = lpParameter;\n-\n-\t\tthread_h = CreateThread(lpThreadAttributes,\n-\t\t\t\t\tdwStackSize, thread_start,\n-\t\t\t\t\t&args,\n-\t\t\t\t\tdwCreationFlags & ~CREATE_SUSPENDED,\n-\t\t\t\t\tlpThreadId);\n-\n-\t\tif (thread_h) {\n-\n-\t\t    /* fill in ID and handle; tell child this is done */\n-\t\t    thread_table[i].id = *lpThreadId;\n-\t\t    if (!DuplicateHandle(GetCurrentProcess(),\n-\t\t\t\t \t thread_h,\n-\t\t\t\t\t GetCurrentProcess(),\n-\t\t\t \t\t (PHANDLE) &thread_table[i].handle,\n-\t\t\t  \t\t 0,\n-\t\t\t\t\t 0,\n-\t\t\t\t\t DUPLICATE_SAME_ACCESS)) {\n-\t\t\tDWORD last_error = GetLastError();\n-\t\t\tGC_printf1(\"Last error code: %lx\\n\", last_error);\n-\t\t\tABORT(\"DuplicateHandle failed\");\n-\t\t    }\n-\t\t    SetEvent (parent_ready_h);\n-\n-\t\t    /* wait for child to fill in stack and copy args */\n-\t\t    WaitForSingleObject (child_ready_h, INFINITE);\n-\n-\t\t    /* suspend the child if requested */\n-\t\t    if (dwCreationFlags & CREATE_SUSPENDED)\n-\t\t\tSuspendThread (thread_h);\n-\n-\t\t    /* let child call given function now (or when resumed) */\n-\t\t    SetEvent (parent_ready_h);\n-\n-\t\t} else {\n-\t\t    CloseHandle (parent_ready_h);\n-\t\t}\n-\t    }\n-\t}\n-\n-\tCloseHandle (child_ready_h);\n-\n-\tif (thread_h == NULL)\n-\t    thread_table[i].in_use = FALSE;\n+    /* set up thread arguments */\n+    \targs -> start = lpStartAddress;\n+    \targs -> param = lpParameter;\n \n-    } else { /* no thread slot found */\n-\tSetLastError (ERROR_TOO_MANY_TCBS);\n-    }\n+    thread_h = CreateThread(lpThreadAttributes,\n+    \t\t\t    dwStackSize, thread_start,\n+    \t\t\t    args, dwCreationFlags,\n+    \t\t\t    lpThreadId);\n \n     return thread_h;\n }\n \n static DWORD WINAPI thread_start(LPVOID arg)\n {\n     DWORD ret = 0;\n-    thread_args args = *(thread_args *)arg;\n-\n-    /* wait for parent to fill in ID and handle */\n-    WaitForSingleObject (args.parent_ready_h, INFINITE);\n-    ResetEvent (args.parent_ready_h);\n+    thread_args *args = (thread_args *)arg;\n \n-    /* fill in stack; tell parent this is done */\n-    args.entry->stack = GC_get_stack_base();\n-    SetEvent (args.child_ready_h);\n-\n-    /* wait for parent to tell us to go (in case it needs to suspend us) */\n-    WaitForSingleObject (args.parent_ready_h, INFINITE);\n-    CloseHandle (args.parent_ready_h);\n+    GC_new_thread();\n \n     /* Clear the thread entry even if we exit with an exception.\t*/\n     /* This is probably pointless, since an uncaught exception is\t*/\n     /* supposed to result in the process being killed.\t\t\t*/\n #ifndef __GNUC__\n     __try {\n #endif /* __GNUC__ */\n-\tret = args.start (args.param);\n+\tret = args->start (args->param);\n #ifndef __GNUC__\n     } __finally {\n #endif /* __GNUC__ */\n-\tLOCK();\n-\targs.entry->stack = 0;\n-\targs.entry->in_use = FALSE;\n-\t      /* cast away volatile qualifier */\n-\tBZERO((void *) &args.entry->context, sizeof(CONTEXT));\n-\tUNLOCK();\n+\tGC_free(args);\n+\tGC_delete_thread(GetCurrentThreadId());\n #ifndef __GNUC__\n     }\n #endif /* __GNUC__ */\n@@ -549,7 +534,6 @@ int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\n     DWORD thread_id;\n \n     /* initialize everything */\n-    InitializeCriticalSection(&GC_allocate_ml);\n     GC_init();\n \n     /* start the main thread */\n@@ -579,126 +563,44 @@ DWORD WINAPI main_thread_start(LPVOID arg)\n \n # else /* !MSWINCE */\n \n-LONG WINAPI GC_write_fault_handler(struct _EXCEPTION_POINTERS *exc_info);\n-\n-/* threadAttach/threadDetach routines used by both CYGWIN and DLL\n- * implementation, since both recieve explicit notification on thread\n- * creation/destruction.\n- */\n-static void threadAttach() {\n-  int i;\n-  /* It appears to be unsafe to acquire a lock here, since this\t*/\n-  /* code is apparently not preeemptible on some systems.\t*/\n-  /* (This is based on complaints, not on Microsoft's official\t*/\n-  /* documentation, which says this should perform \"only simple\t*/\n-  /* inititalization tasks\".)\t\t\t\t\t*/\n-  /* Hence we make do with nonblocking synchronization.\t\t*/\n-\n-  /* The following should be a noop according to the win32\t*/\n-  /* documentation.  There is empirical evidence that it\t*/\n-  /* isn't.\t\t- HB\t\t\t\t\t*/\n-# if defined(MPROTECT_VDB)\n-   if (GC_incremental) SetUnhandledExceptionFilter(GC_write_fault_handler);\n-# endif\n-                /* cast away volatile qualifier */\n-  for (i = 0; InterlockedExchange((LONG*)&thread_table[i].in_use,1) != 0; i++) {\n-    /* Compare-and-swap would make this cleaner, but that's not \t*/\n-    /* supported before Windows 98 and NT 4.0.  In Windows 2000,\t*/\n-    /* InterlockedExchange is supposed to be replaced by\t\t*/\n-    /* InterlockedExchangePointer, but that's not really what I\t*/\n-    /* want here.\t\t\t\t\t\t\t*/\n-    if (i == MAX_THREADS - 1)\n-      ABORT(\"too many threads\");\n-  }\n-  thread_table[i].id = GetCurrentThreadId();\n-# ifdef CYGWIN32\n-    thread_table[i].pthread_id = pthread_self();\n-# endif\n-  if (!DuplicateHandle(GetCurrentProcess(),\n-\t               GetCurrentThread(),\n-\t\t       GetCurrentProcess(),\n-\t\t       (HANDLE*)&thread_table[i].handle,\n-\t\t       0,\n-\t\t       0,\n-\t\t       DUPLICATE_SAME_ACCESS)) {\n-\tDWORD last_error = GetLastError();\n-\tGC_printf1(\"Last error code: %lx\\n\", last_error);\n-\tABORT(\"DuplicateHandle failed\");\n-  }\n-  thread_table[i].stack = GC_get_stack_base();\n-  if (thread_table[i].stack == NULL) \n-    ABORT(\"Failed to find stack base in threadAttach\");\n-  /* If this thread is being created while we are trying to stop\t*/\n-  /* the world, wait here.  Hopefully this can't happen on any\t*/\n-  /* systems that don't allow us to block here.\t\t\t*/\n-  while (GC_please_stop) Sleep(20);\n-}\n-\n-static void threadDetach(DWORD thread_id) {\n-  int i;\n-\n-  LOCK();\n-  for (i = 0;\n-       i < MAX_THREADS &&\n-       (!thread_table[i].in_use || thread_table[i].id != thread_id);\n-       i++) {}\n-  if (i >= MAX_THREADS ) {\n-    WARN(\"thread %ld not found on detach\", (GC_word)thread_id);\n-  } else {\n-    thread_table[i].stack = 0;\n-    thread_table[i].in_use = FALSE;\n-    CloseHandle(thread_table[i].handle);\n-      /* cast away volatile qualifier */\n-    BZERO((void *)&thread_table[i].context, sizeof(CONTEXT));\n-  }\n-  UNLOCK();\n-}\n-\n-#ifdef CYGWIN32\n-\n /* Called by GC_init() - we hold the allocation lock.\t*/\n void GC_thr_init() {\n     if (GC_thr_initialized) return;\n+    GC_main_thread = GetCurrentThreadId();\n     GC_thr_initialized = TRUE;\n \n-#if 0\n-    /* this might already be handled in GC_init... */\n-    InitializeCriticalSection(&GC_allocate_ml);\n-#endif\n-\n     /* Add the initial thread, so we can stop it.\t*/\n-    threadAttach();\n+    GC_new_thread();\n }\n \n+#ifdef CYGWIN32\n+\n struct start_info {\n     void *(*start_routine)(void *);\n     void *arg;\n+    GC_bool detached;\n };\n \n int GC_pthread_join(pthread_t pthread_id, void **retval) {\n     int result;\n     int i;\n+    GC_thread me;\n \n #   if DEBUG_CYGWIN_THREADS\n-      GC_printf3(\"thread 0x%x(0x%x) is joining thread 0x%x.\\n\",(int)pthread_self(),\n-\t\t GetCurrentThreadId(), (int)pthread_id);\n+      GC_printf3(\"thread 0x%x(0x%x) is joining thread 0x%x.\\n\",\n+\t\t (int)pthread_self(), GetCurrentThreadId(), (int)pthread_id);\n #   endif\n \n-    /* Can't do any table lookups here, because thread being joined \n-       might not have registered itself yet */\n+    /* Thread being joined might not have registered itself yet. */\n+    /* After the join,thread id may have been recycled.\t\t */\n+    /* FIXME: It would be better if this worked more like\t */\n+    /* pthread_support.c.\t\t\t\t\t */\n+\n+    while ((me = GC_lookup_thread(pthread_id)) == 0) Sleep(10);\n \n     result = pthread_join(pthread_id, retval);\n \n-    LOCK();\n-    for (i = 0; !thread_table[i].in_use || thread_table[i].pthread_id != pthread_id;\n-         i++) {\n-      if (i == MAX_THREADS - 1) {\n-        GC_printf1(\"Failed to find thread 0x%x in pthread_join()\\n\", pthread_id);\n-        ABORT(\"thread not found on detach\");\n-      }\n-    }\n-    UNLOCK();\n-    threadDetach(thread_table[i].id);\n+    GC_delete_gc_thread(me);\n \n #   if DEBUG_CYGWIN_THREADS\n       GC_printf3(\"thread 0x%x(0x%x) completed join with thread 0x%x.\\n\",\n@@ -729,10 +631,15 @@ GC_pthread_create(pthread_t *new_thread,\n \n     si -> start_routine = start_routine;\n     si -> arg = arg;\n+    if (attr != 0 &&\n+        pthread_attr_getdetachstate(attr, &si->detached)\n+\t== PTHREAD_CREATE_DETACHED) {\n+      si->detached = TRUE;\n+    }\n \n #   if DEBUG_CYGWIN_THREADS\n-      GC_printf2(\"About to create a thread from 0x%x(0x%x)\\n\",(int)pthread_self(),\n-\t\t      \t\t\t\t\t      GetCurrentThreadId);\n+      GC_printf2(\"About to create a thread from 0x%x(0x%x)\\n\",\n+\t\t (int)pthread_self(), GetCurrentThreadId);\n #   endif\n     result = pthread_create(new_thread, attr, GC_start_routine, si); \n \n@@ -750,6 +657,8 @@ void * GC_start_routine(void * arg)\n     void *(*start)(void *);\n     void *start_arg;\n     pthread_t pthread_id;\n+    GC_thread me;\n+    GC_bool detached;\n     int i;\n \n #   if DEBUG_CYGWIN_THREADS\n@@ -764,38 +673,32 @@ void * GC_start_routine(void * arg)\n     LOCK();\n     /* We register the thread here instead of in the parent, so that\t*/\n     /* we don't need to hold the allocation lock during pthread_create. */\n-    threadAttach();\n+    me = GC_new_thread();\n     UNLOCK();\n \n     start = si -> start_routine;\n     start_arg = si -> arg;\n-    pthread_id = pthread_self();\n+    if (si-> detached) me -> flags |= DETACHED;\n+    me -> pthread_id = pthread_id = pthread_self();\n \n     GC_free(si); /* was allocated uncollectable */\n \n-    pthread_cleanup_push(GC_thread_exit_proc, pthread_id);\n+    pthread_cleanup_push(GC_thread_exit_proc, (void *)me);\n     result = (*start)(start_arg);\n+    me -> status = result;\n     pthread_cleanup_pop(0);\n \n #   if DEBUG_CYGWIN_THREADS\n       GC_printf2(\"thread 0x%x(0x%x) returned from start routine.\\n\",\n \t\t (int)pthread_self(),GetCurrentThreadId());\n #   endif\n \n-    LOCK();\n-    for (i = 0; thread_table[i].pthread_id != pthread_id; i++) {\n-      if (i == MAX_THREADS - 1)\n-        ABORT(\"thread not found on exit\");\n-    }\n-    thread_table[i].status = result;\n-    UNLOCK();\n-\n     return(result);\n }\n \n void GC_thread_exit_proc(void *arg)\n {\n-    pthread_t pthread_id = (pthread_t)arg;\n+    GC_thread me = (GC_thread)arg;\n     int i;\n \n #   if DEBUG_CYGWIN_THREADS\n@@ -804,25 +707,41 @@ void GC_thread_exit_proc(void *arg)\n #   endif\n \n     LOCK();\n-    for (i = 0; thread_table[i].pthread_id != pthread_id; i++) {\n-      if (i == MAX_THREADS - 1)\n-        ABORT(\"thread not found on exit\");\n+    if (me -> flags & DETACHED) {\n+      GC_delete_thread(GetCurrentThreadId());\n+    } else {\n+      /* deallocate it as part of join */\n+      me -> flags |= FINISHED;\n     }\n     UNLOCK();\n-\n-#if 0\n-    /* TODO: we need a way to get the exit value after a pthread_exit so we can stash it safely away */\n-    thread_table[i].status = ???\n-#endif\n }\n \n /* nothing required here... */\n int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset) {\n   return pthread_sigmask(how, set, oset);\n }\n-int GC_pthread_detach(pthread_t thread) {\n-  return pthread_detach(thread);\n+\n+int GC_pthread_detach(pthread_t thread)\n+{\n+    int result;\n+    GC_thread thread_gc_id;\n+    \n+    LOCK();\n+    thread_gc_id = GC_lookup_thread(thread);\n+    UNLOCK();\n+    result = pthread_detach(thread);\n+    if (result == 0) {\n+      LOCK();\n+      thread_gc_id -> flags |= DETACHED;\n+      /* Here the pthread thread id may have been recycled. */\n+      if (thread_gc_id -> flags & FINISHED) {\n+        GC_delete_gc_thread(thread_gc_id);\n+      }\n+      UNLOCK();\n+    }\n+    return result;\n }\n+\n #else /* !CYGWIN32 */\n \n /*\n@@ -834,31 +753,28 @@ BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n {\n   switch (reason) {\n   case DLL_PROCESS_ATTACH:\n-    InitializeCriticalSection(&GC_allocate_ml);\n     GC_init();\t/* Force initialization before thread attach.\t*/\n     /* fall through */\n   case DLL_THREAD_ATTACH:\n-    threadAttach();\n+    GC_ASSERT(GC_thr_initialized);\n+    if (GC_main_thread != GetCurrentThreadId()) {\n+        GC_new_thread();\n+    } /* o.w. we already did it during GC_thr_init(), called by GC_init() */\n     break;\n \n   case DLL_THREAD_DETACH:\n-    threadDetach(GetCurrentThreadId());\n+    GC_delete_thread(GetCurrentThreadId());\n     break;\n \n   case DLL_PROCESS_DETACH:\n     {\n       int i;\n \n       LOCK();\n-      for (i = 0; i < MAX_THREADS; ++i)\n+      for (i = 0; i <= GC_get_max_thread_index(); ++i)\n       {\n           if (thread_table[i].in_use)\n-          {\n-              thread_table[i].stack = 0;\n-              thread_table[i].in_use = FALSE;\n-              CloseHandle(thread_table[i].handle);\n-              BZERO((void *) &thread_table[i].context, sizeof(CONTEXT));\n-          }\n+\t    GC_delete_gc_thread(thread_table + i);\n       }\n       UNLOCK();\n "}]}