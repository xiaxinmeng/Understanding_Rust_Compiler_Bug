{"sha": "9188c36364c9a8bdd993a5d911b875ce124bb04d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE4OGMzNjM2NGM5YThiZGQ5OTNhNWQ5MTFiODc1Y2UxMjRiYjA0ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-14T09:23:49Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-14T09:23:49Z"}, "message": "cp-tree.def (DECL_STMT): Make it smaller.\n\n\t* cp-tree.def (DECL_STMT): Make it smaller.\n\t* cp-tree.h (lang_decl_flags): Move saved_tree to ...\n\t(lang_decl): ... here.  Add next.\n\t(DECL_SAVED_TREE): Adjust accordingly.\n\t(DECL_IMPLICIT_TYPEDEF_P): New macro.\n\t(SET_DECL_IMPLICIT_TYPEDEF_P): Likewise.\n\t(DECL_STMT_DECL): Likewise.\n\t(create_implicit_typedef): New function.\n\t(maybe_push_decl): Likewise.\n\t(tsubst_default_argument): New function.\n\t(at_function_scope_p): Likewise.\n\t(add_decl_stmt): Likewise.\n\t(push_permanent_obstack): Likewise.\n\t* call.c (convert_default_arg): Use tsubst_default_argument.\n\t* class.c (add_method): Use push_permanent_obstack.\n\t(build_self_reference): Create a TEMPLATE_DECL for the\n\tself-reference, if necessary.\n\t* decl.c (pseudo_global_level_p): Only look at the current binding\n\tlevel.\n\t(push_binding): Use push_permanent_obstack.\n\t(create_implicit_typedef): New function.\n\t(pushtag): Use it.\n\t(duplicate_decls): Use push_permanent_obstack.\n\t(maybe_push_decl): New function.\n\t(start_decl): Use it.  Remove dead code.  Use add_decl_stmt.\n\t(start_decl_1): Remove dead code.\n\t(cp_finish_decl): Remove DECL_STMT handling here.  Don't use\n\tpseudo_global_level_p.\n\t(grokvardecl): Create DECL_LANG_SPECIFIC for a VAR_DECL in a\n\ttemplate.\n\t(grokdeclarator): Likewise, for TYPE_DECLs.  Don't use\n\tpseudo_global_level_p.\n\t* decl2.c (grokfield): Call push_template_decl for a TYPE_DECL in\n\ta template.\n\t(get_sentry): Use push_permanent_obstack.\n\t* dump.c (dequeue_and_dump): Enable DECL_STMT.\n\t* except.c (call_eh_info): Use push_permanent_obstack.\n\t(build_eh_type_ref): Likewise.\n\t(do_pop_exception): Likewise.\n\t(expand_eh_spec): Likewise.\n\t(alloc_eh_object): Likewise.\n\t(expand_throw): Likewise.\n\t* init.c (build_java_class_ref): Likewise.\n\t* lex.c (get_time_identifier): Likewise.\n\t(free_lang_decl_chain): Correct type.\n\t(retrofit_lang_decl): Adjust accordingly.\n\t(build_lang_field_decl): Likewise.\n\t* lex.h (free_lang_decl_chain): Likewise.\n\t* parse.y (lang_extdef): Don't use pseudo_global_level_p.\n\t* parse.c: Regenerated.\n\t* pt.c (tsubst_default_arguments): New function.\n\t(retrieve_local_specialization): Likewise.\n\t(register_local_specialization): Likewise.\n\t(push_template_decl_real): Use DECL_IMPLICIT_TYPEDEF_P.  Just use\n\tpseudo_global_level_p to determine whether or not a template is\n\tprimary.\n\t(lookup_template_class): Likewise.  Use create_implicit_typedef.\n\t(instantiate_class_template): Call tsubst_default_arguments for\n\tmember functions, if appropriate.\n\t(tsubst_default_argument): New function.\n\t(tsubst_decl): Use it.  Change TYPE_DECL handling to match VAR_DECLs.\n\t* search.c (at_function_scope_p): New function.\n\t* semantics.c (finish_asm_stmt): Use push_permanent_obstack.\n\t(finish_label_stmt): Likewise.\n\t(add_decl_stmt): New function.\n\t(begin_class_definition): Likewise.\n\t(finish_typeof): Likewise.\n\t* tree.c (copy_template_template_parm): Likewise.\n\t(copy_to_permanent): Likewise.\n\t(push_permanent_obstack): Define.\n\t(mark_addressable): Use it.\n\t* typeck.c (mark_addressable): Likewise.\n\nFrom-SVN: r28709", "tree": {"sha": "a8c7b851b33451e1c6acb9c8304ab3c8c0ea48a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8c7b851b33451e1c6acb9c8304ab3c8c0ea48a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9188c36364c9a8bdd993a5d911b875ce124bb04d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9188c36364c9a8bdd993a5d911b875ce124bb04d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9188c36364c9a8bdd993a5d911b875ce124bb04d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9188c36364c9a8bdd993a5d911b875ce124bb04d/comments", "author": null, "committer": null, "parents": [{"sha": "0d4255d1f69cd31cda0afc59f0211680d3bd7def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4255d1f69cd31cda0afc59f0211680d3bd7def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4255d1f69cd31cda0afc59f0211680d3bd7def"}], "stats": {"total": 845, "additions": 523, "deletions": 322}, "files": [{"sha": "4b882a6c730c7d159f926cf885c9af9b55d72602", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -1,3 +1,78 @@\n+1999-08-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (DECL_STMT): Make it smaller.\n+\t* cp-tree.h (lang_decl_flags): Move saved_tree to ...\n+\t(lang_decl): ... here.  Add next.\n+\t(DECL_SAVED_TREE): Adjust accordingly.\n+\t(DECL_IMPLICIT_TYPEDEF_P): New macro.\n+\t(SET_DECL_IMPLICIT_TYPEDEF_P): Likewise.\n+\t(DECL_STMT_DECL): Likewise.\n+\t(create_implicit_typedef): New function.\n+\t(maybe_push_decl): Likewise.\n+\t(tsubst_default_argument): New function.\n+\t(at_function_scope_p): Likewise.\n+\t(add_decl_stmt): Likewise.\n+\t(push_permanent_obstack): Likewise.\n+\t* call.c (convert_default_arg): Use tsubst_default_argument.\n+\t* class.c (add_method): Use push_permanent_obstack.\n+\t(build_self_reference): Create a TEMPLATE_DECL for the\n+\tself-reference, if necessary.\n+\t* decl.c (pseudo_global_level_p): Only look at the current binding\n+\tlevel.\n+\t(push_binding): Use push_permanent_obstack.\n+\t(create_implicit_typedef): New function.\n+\t(pushtag): Use it.\n+\t(duplicate_decls): Use push_permanent_obstack.\n+\t(maybe_push_decl): New function.\n+\t(start_decl): Use it.  Remove dead code.  Use add_decl_stmt.\n+\t(start_decl_1): Remove dead code.\n+\t(cp_finish_decl): Remove DECL_STMT handling here.  Don't use\n+\tpseudo_global_level_p.\n+\t(grokvardecl): Create DECL_LANG_SPECIFIC for a VAR_DECL in a\n+\ttemplate.\n+\t(grokdeclarator): Likewise, for TYPE_DECLs.  Don't use\n+\tpseudo_global_level_p.\n+\t* decl2.c (grokfield): Call push_template_decl for a TYPE_DECL in\n+\ta template.\n+\t(get_sentry): Use push_permanent_obstack.\n+\t* dump.c (dequeue_and_dump): Enable DECL_STMT.\n+\t* except.c (call_eh_info): Use push_permanent_obstack.\n+\t(build_eh_type_ref): Likewise.\n+\t(do_pop_exception): Likewise.\n+\t(expand_eh_spec): Likewise.\n+\t(alloc_eh_object): Likewise.\n+\t(expand_throw): Likewise.\n+\t* init.c (build_java_class_ref): Likewise.\n+\t* lex.c (get_time_identifier): Likewise.\n+\t(free_lang_decl_chain): Correct type.\n+\t(retrofit_lang_decl): Adjust accordingly.\n+\t(build_lang_field_decl): Likewise.\n+\t* lex.h (free_lang_decl_chain): Likewise.\n+\t* parse.y (lang_extdef): Don't use pseudo_global_level_p.\n+\t* parse.c: Regenerated.\n+\t* pt.c (tsubst_default_arguments): New function.\n+\t(retrieve_local_specialization): Likewise.\n+\t(register_local_specialization): Likewise.\n+\t(push_template_decl_real): Use DECL_IMPLICIT_TYPEDEF_P.  Just use\n+\tpseudo_global_level_p to determine whether or not a template is\n+\tprimary.\n+\t(lookup_template_class): Likewise.  Use create_implicit_typedef.\n+\t(instantiate_class_template): Call tsubst_default_arguments for\n+\tmember functions, if appropriate.\n+\t(tsubst_default_argument): New function.\n+\t(tsubst_decl): Use it.  Change TYPE_DECL handling to match VAR_DECLs.\n+\t* search.c (at_function_scope_p): New function.\n+\t* semantics.c (finish_asm_stmt): Use push_permanent_obstack.\n+\t(finish_label_stmt): Likewise.\n+\t(add_decl_stmt): New function.\n+\t(begin_class_definition): Likewise.\n+\t(finish_typeof): Likewise.\n+\t* tree.c (copy_template_template_parm): Likewise.\n+\t(copy_to_permanent): Likewise.\n+\t(push_permanent_obstack): Define.\n+\t(mark_addressable): Use it.\n+\t* typeck.c (mark_addressable): Likewise.\n+\t\n 1999-08-13  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \tcp-tree.h (init_cplus_unsave): New."}, {"sha": "fda38de4d9acd9db194b82d3f9a05585e8f74e9c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -3787,30 +3787,7 @@ convert_default_arg (type, arg, fn)\n      tree fn;\n {\n   if (fn && DECL_TEMPLATE_INFO (fn))\n-    {\n-      /* This default argument came from a template.  Instantiate the\n-\t default argument here, not in tsubst.  In the case of\n-\t something like: \n-\n-\t   template <class T>\n-\t   struct S {\n-\t     static T t();\n-\t     void f(T = t());\n-\t   };\n-\n-\t we must be careful to do name lookup in the scope of S<T>,\n-\t rather than in the current class.  */\n-      if (DECL_CLASS_SCOPE_P (fn))\n-\tpushclass (DECL_REAL_CONTEXT (fn), 2);\n-\n-      arg = tsubst_expr (arg, DECL_TI_ARGS (fn), /*complain=*/1, NULL_TREE);\n-\n-      if (DECL_CLASS_SCOPE_P (fn))\n-\tpopclass ();\n-\n-      /* Make sure the default argument is reasonable.  */\n-      arg = check_default_argument (type, arg);\n-    }\n+    arg = tsubst_default_argument (fn, type, arg);\n \n   arg = break_out_target_exprs (arg);\n "}, {"sha": "3df139052242c91bcbfceea00eef93138b5220d1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -1154,8 +1154,7 @@ void\n add_method (type, fields, method)\n      tree type, *fields, method;\n {\n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n+  push_permanent_obstack ();\n \n   /* Setting the DECL_CONTEXT and DECL_CLASS_CONTEXT here is probably\n      redundant.  */\n@@ -5379,6 +5378,9 @@ build_self_reference ()\n   DECL_CLASS_CONTEXT (value) = current_class_type;\n   DECL_ARTIFICIAL (value) = 1;\n \n+  if (processing_template_decl)\n+    value = push_template_decl (value);\n+\n   saved_cas = current_access_specifier;\n   current_access_specifier = access_public_node;\n   finish_member_declaration (value);"}, {"sha": "fecbbe5be58cb4e9f363e9d14474d79af37889de", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -217,7 +217,7 @@ DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", 'e', 1)\n \n DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", 'e', 1)\n-DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 3)\n+DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n DEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)"}, {"sha": "410dc7a8681deda56fbf9d13a39a8e05ae105dd8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -77,6 +77,7 @@ Boston, MA 02111-1307, USA.  */\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n+      DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n    4: DECL_MAYBE_TEMPLATE.\n    5: DECL_INTERFACE_KNOWN.\n@@ -1192,11 +1193,8 @@ struct lang_decl_flags\n   tree access;\n   tree context;\n \n-  /* In a template FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n-  tree saved_tree;\n-\n   union {\n-    /* In a FUNCTION_DECL, this is DECL_TEMPLATE_INFO.  */\n+    /* In a FUNCTION_DECL or a VAR_DECL, this is DECL_TEMPLATE_INFO.  */\n     tree template_info;\n \n     /* In a NAMESPACE_DECL, this is NAMESPACE_LEVEL.  */\n@@ -1210,10 +1208,17 @@ struct lang_decl\n \n   tree main_decl_variant;\n   tree befriending_classes;\n+\n+  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n+  tree saved_tree;\n+\n   union\n   {\n     tree sorted_fields;\n     struct pending_inline *pending_inline_info;\n+    /* The lang_decls on the free_lang_decl_chain are chained together\n+       through this pointer.  */\n+    struct lang_decl *next;\n   } u;\n };\n \n@@ -1502,7 +1507,7 @@ struct lang_decl\n /* In a template FUNCTION_DECL, the tree structure that will be\n    substituted into to obtain instantiations.  */\n #define DECL_SAVED_TREE(NODE) \\\n-  (DECL_LANG_SPECIFIC ((NODE))->decl_flags.saved_tree)\n+  (DECL_LANG_SPECIFIC ((NODE))->saved_tree)\n \n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n@@ -1984,6 +1989,18 @@ extern int flag_new_for_scope;\n #define DECL_DECLARES_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == TYPE_DECL || DECL_CLASS_TEMPLATE_P (NODE))\n \n+/* Nonzero if NODE is the typedef implicitly generated for a type when\n+   the type is declared.  (In C++, `struct S {};' is roughly equivalent\n+   to `struct S {}; typedef struct S S;' in C.  This macro will hold\n+   for the typedef indicated in this example.  Note that in C++, there\n+   is a second implicit typedef for each class, in the scope of `S'\n+   itself, so that you can `S::S'.  This macro does *not* hold for\n+   those typedefs.  */\n+#define DECL_IMPLICIT_TYPEDEF_P(NODE) \\\n+  (TREE_CODE ((NODE)) == TYPE_DECL && DECL_LANG_FLAG_2 ((NODE)))\n+#define SET_DECL_IMPLICIT_TYPEDEF_P(NODE) \\\n+  (DECL_LANG_FLAG_2 ((NODE)) = 1)\n+\n /* A `primary' template is one that has its own template header.  A\n    member function of a class template is a template, but not primary.\n    A member template is primary.  Friend templates are primary, too.  */\n@@ -2120,6 +2137,7 @@ extern int flag_new_for_scope;\n #define ASM_OUTPUTS(NODE)       TREE_OPERAND (NODE, 2)\n #define ASM_INPUTS(NODE)        TREE_OPERAND (NODE, 3)\n #define ASM_CLOBBERS(NODE)      TREE_OPERAND (NODE, 4)\n+#define DECL_STMT_DECL(NODE)    TREE_OPERAND (NODE, 0)\n \n /* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n #define ASM_VOLATILE_P(NODE)\t\t\t\\\n@@ -2936,6 +2954,8 @@ extern int walk_namespaces                      PROTO((walk_namespaces_fn,\n \t\t\t\t\t\t       void *));\n extern int wrapup_globals_for_namespace         PROTO((tree, void *));\n extern tree cp_namespace_decls                  PROTO((tree));\n+extern tree create_implicit_typedef             PROTO((tree, tree));\n+extern tree maybe_push_decl                     PROTO((tree));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));\n@@ -3191,7 +3211,6 @@ extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n extern tree do_poplevel\t\t\t\tPROTO((void));\n extern tree get_bindings\t\t\tPROTO((tree, tree, tree));\n-/* CONT ... */\n extern void add_tree\t\t\t\tPROTO((tree));\n extern void begin_tree                          PROTO((void));\n extern void end_tree                            PROTO((void));\n@@ -3210,6 +3229,7 @@ extern void maybe_check_template_type           PROTO((tree));\n extern tree most_specialized_instantiation      PROTO((tree, tree));\n extern void print_candidates                    PROTO((tree));\n extern int instantiate_pending_templates        PROTO((void));\n+extern tree tsubst_default_argument             PROTO((tree, tree, tree));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;\n@@ -3257,6 +3277,7 @@ extern void print_search_statistics\t\tPROTO((void));\n extern void init_search_processing\t\tPROTO((void));\n extern void reinit_search_statistics\t\tPROTO((void));\n extern tree current_scope\t\t\tPROTO((void));\n+extern int at_function_scope_p                  PROTO((void));\n extern tree lookup_conversions\t\t\tPROTO((tree));\n extern tree binfo_for_vtable\t\t\tPROTO((tree));\n extern int  binfo_from_vbase\t\t\tPROTO((tree));\n@@ -3342,6 +3363,7 @@ extern tree finish_base_specifier               PROTO((tree, tree));\n extern void finish_member_declaration           PROTO((tree));\n extern void check_multiple_declarators          PROTO((void));\n extern tree finish_typeof\t\t\tPROTO((tree));\n+extern void add_decl_stmt                       PROTO((tree));\n \n /* in spew.c */\n extern void init_spew\t\t\t\tPROTO((void));\n@@ -3420,6 +3442,7 @@ extern tree mapcar\t\t\t\tPROTO((tree, tree (*) (tree)));\n extern tree no_linkage_check\t\t\tPROTO((tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n extern void push_expression_obstack\t\tPROTO((void));\n+extern void push_permanent_obstack              PROTO((void));\n extern tree build_dummy_object\t\t\tPROTO((tree));\n extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n extern int is_dummy_object\t\t\tPROTO((tree));"}, {"sha": "8c960202514a0279efa1f6e50b55a19d569ce35c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 124, "deletions": 142, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -923,9 +923,7 @@ declare_namespace_level ()\n int\n pseudo_global_level_p ()\n {\n-  struct binding_level *b = innermost_nonclass_level ();\n-\n-  return b->pseudo_global;\n+  return current_binding_level->pseudo_global;\n }\n \n void\n@@ -1018,8 +1016,7 @@ push_binding (id, decl, level)\n   if (!free_binding_nodes)\n     {\n       /* There are no free nodes, so we must build one here.  */\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n       binding = make_node (CPLUS_BINDING);\n       pop_obstacks ();\n     }\n@@ -2761,6 +2758,29 @@ maybe_process_template_type_declaration (type, globalize, b)\n   return decl;\n }\n \n+/* In C++, you don't have to write `struct S' to refer to `S'; you\n+   can just use `S'.  We accomplish this by creating a TYPE_DECL as\n+   if the user had written `typedef struct S S'.  Create and return\n+   the TYPE_DECL for TYPE.  */\n+\n+tree\n+create_implicit_typedef (name, type)\n+     tree name;\n+     tree type;\n+{\n+  tree decl;\n+\n+  decl = build_decl (TYPE_DECL, name, type);\n+  SET_DECL_ARTIFICIAL (decl);\n+  /* There are other implicit type declarations, like the one *within*\n+     a class that allows you to write `S::S'.  We must distinguish\n+     amongst these.  */\n+  SET_DECL_IMPLICIT_TYPEDEF_P (decl);\n+  TYPE_NAME (type) = decl;\n+\n+  return decl;\n+}\n+\n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n    Normally put it into the inner-most non-tag-transparent scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n@@ -2790,9 +2810,8 @@ pushtag (name, type, globalize)\n         {\n           register tree d = NULL_TREE;\n \t  int in_class = 0;\n-\t  tree context;\n+\t  tree context = TYPE_CONTEXT (type);\n \n-\t  context = type ? TYPE_CONTEXT (type) : NULL_TREE;\n \t  if (! context)\n \t    {\n \t      tree cs = current_scope ();\n@@ -2813,15 +2832,13 @@ pushtag (name, type, globalize)\n \t      || b->parm_flag == 2)\n \t    in_class = 1;\n \n-\t  d = build_decl (TYPE_DECL, name, type);\n \t  if (current_lang_name == lang_name_java)\n \t    TYPE_FOR_JAVA (type) = 1;\n-\t  SET_DECL_ARTIFICIAL (d);\n-\t  if (! in_class)\n-\t    set_identifier_type_value_with_scope (name, type, b);\n \n-\t  TYPE_NAME (type) = d;\n+\t  d = create_implicit_typedef (name, type);\n \t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n+\t  if (! in_class)\n+\t    set_identifier_type_value_with_scope (name, type, b);\n \n \t  d = maybe_process_template_type_declaration (type,\n \t\t\t\t\t\t       globalize, b);\n@@ -3449,10 +3466,7 @@ duplicate_decls (newdecl, olddecl)\n       if (oldtype)\n \tpush_obstacks (TYPE_OBSTACK (oldtype), TYPE_OBSTACK (oldtype));\n       else\n-\t{\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\t}\n+\tpush_permanent_obstack ();\n \n       /* Merge the data types specified in the two decls.  */\n       newtype = common_type (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n@@ -3733,14 +3747,13 @@ duplicate_decls (newdecl, olddecl)\n \t{\n \t  if (DECL_MAIN_VARIANT (olddecl) == olddecl)\n \t    {\n-\t      /* Save these lang_decls that would otherwise be lost.  */\n-\t      extern tree free_lang_decl_chain;\n-\t      tree free_lang_decl = (tree) ol;\n+\t      struct lang_decl *free_lang_decl = ol;\n \n+\t      /* Save these lang_decls that would otherwise be lost.  */\n \t      if (DECL_LANG_SPECIFIC (olddecl) == ol)\n \t\tabort ();\n \n-\t      TREE_CHAIN (free_lang_decl) = free_lang_decl_chain;\n+\t      free_lang_decl->u.next = free_lang_decl_chain;\n \t      free_lang_decl_chain = free_lang_decl;\n \t    }\n \t  else\n@@ -4310,6 +4323,35 @@ pushdecl_class_level (x)\n     }\n }\n \n+/* Enter DECL into the symbol table, if that's appropriate.  Returns\n+   DECL, or a modified version thereof.  */\n+\n+tree\n+maybe_push_decl (decl)\n+     tree decl;\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  /* Add this decl to the current binding level, but not if it comes\n+     from another scope, e.g. a static member variable.  TEM may equal\n+     DECL or it may be a previous decl of the same name.  */\n+  if ((TREE_CODE (decl) != PARM_DECL \n+       && DECL_CONTEXT (decl) != NULL_TREE \n+       /* Definitions of namespace members outside their namespace are\n+\t  possible. */\n+       && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n+      || (TREE_CODE (decl) == TEMPLATE_DECL && !namespace_bindings_p ())\n+      || TREE_CODE (type) == UNKNOWN_TYPE\n+      /* The declaration of template specializations does not affect\n+\t the functions available for overload resolution, so we do not\n+\t call pushdecl.  */\n+      || (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && DECL_TEMPLATE_SPECIALIZATION (decl)))\n+    return decl;\n+  else\n+    return pushdecl (decl);\n+}\n+\n #if 0\n /* This function is used to push the mangled decls for nested types into\n    the appropriate scope.  Previously pushdecl_top_level was used, but that\n@@ -6987,34 +7029,22 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t\t    decl);\n     }\n \n-  /* Add this decl to the current binding level, but not if it\n-     comes from another scope, e.g. a static member variable.\n-     TEM may equal DECL or it may be a previous decl of the same name.  */\n-  \n-  if ((TREE_CODE (decl) != PARM_DECL && DECL_CONTEXT (decl) != NULL_TREE \n-       /* Definitions of namespace members outside their namespace are\n-\t  possible. */\n-       && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n-      || (TREE_CODE (decl) == TEMPLATE_DECL && !namespace_bindings_p ())\n-      || TREE_CODE (type) == LANG_TYPE\n-      /* The declaration of template specializations does not affect\n-\t the functions available for overload resolution, so we do not\n-\t call pushdecl.  */\n-      || (TREE_CODE (decl) == FUNCTION_DECL\n-\t  && DECL_TEMPLATE_SPECIALIZATION (decl)))\n-    tem = decl;\n-  else\n-    tem = pushdecl (decl);\n+  /* Enter this declaration into the symbol table.  */\n+  tem = maybe_push_decl (decl);\n \n   if (processing_template_decl)\n     {\n-      if (! current_function_decl)\n-\ttem = push_template_decl (tem);\n-      else\n-\tDECL_VINDEX (tem)\n-\t    = build_min_nt (DECL_STMT, copy_to_permanent (declarator),\n-\t\t\t    copy_to_permanent (declspecs),\n-\t\t\t    NULL_TREE);\n+      if (at_function_scope_p ())\n+\tpush_permanent_obstack ();\n+\n+      tem = push_template_decl (tem);\n+      /* In a a local scope, add a representation of this declaration\n+\t to the statement tree.  */\n+      if (at_function_scope_p ())\n+\t{\n+\t  add_decl_stmt (decl);\n+\t  pop_obstacks ();\n+\t}\n     }\n \n \n@@ -7033,32 +7063,6 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   /* Corresponding pop_obstacks is done in `cp_finish_decl'.  */\n   push_obstacks_nochange ();\n \n-#if 0\n-  /* We have no way of knowing whether the initializer will need to be\n-     evaluated at run-time or not until we've parsed it, so let's just put\n-     it in the permanent obstack.  (jason) */\n-  if (init_written\n-      && ! (TREE_CODE (tem) == PARM_DECL\n-\t    || (TREE_READONLY (tem)\n-\t\t&& (TREE_CODE (tem) == VAR_DECL\n-\t\t    || TREE_CODE (tem) == FIELD_DECL))))\n-    {\n-      /* When parsing and digesting the initializer,\n-\t use temporary storage.  Do this even if we will ignore the value.  */\n-      if (toplevel_bindings_p () && debug_temp_inits)\n-\t{\n-\t  if (processing_template_decl\n-\t      || TYPE_NEEDS_CONSTRUCTING (type)\n-\t      || TREE_CODE (type) == REFERENCE_TYPE)\n-\t    /* In this case, the initializer must lay down in permanent\n-\t       storage, since it will be saved until `finish_file' is run.   */\n-\t    ;\n-\t  else\n-\t    temporary_allocation ();\n-\t}\n-    }\n-#endif\n-\n   return tem;\n }\n \n@@ -7130,23 +7134,6 @@ start_decl_1 (decl)\n \t}\n     }\n \n-#if 0\n-  /* We don't do this yet for GNU C++.  */\n-  /* For a local variable, define the RTL now.  */\n-  if (! toplevel_bindings_p ()\n-      /* But not if this is a duplicate decl\n-\t and we preserved the rtl from the previous one\n-\t (which may or may not happen).  */\n-      && DECL_RTL (tem) == NULL_RTX)\n-    {\n-      if (TYPE_SIZE (TREE_TYPE (tem)) != NULL_TREE)\n-\texpand_decl (tem);\n-      else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n-\t       && DECL_INITIAL (tem) != NULL_TREE)\n-\texpand_decl (tem);\n-    }\n-#endif\n-\n   if (! initialized)\n     DECL_INITIAL (decl) = NULL_TREE;\n }\n@@ -7380,22 +7367,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   if (processing_template_decl)\n     {\n       if (init && DECL_INITIAL (decl))\n-\tDECL_INITIAL (decl) = init;\n-      if (current_function_decl && ! DECL_ARTIFICIAL (decl))\n-\t{\n-\t  tree stmt = DECL_VINDEX (decl);\n-\t  /* If the decl is declaring a member of a local class (in a\n-\t     template function), the DECL_VINDEX will either be NULL,\n-\t     or it will be an actual virtual function index, not a\n-\t     DECL_STMT.  */\n-\t  if (stmt != NULL_TREE && TREE_CODE (stmt) == DECL_STMT)\n-\t    {\n-\t      DECL_VINDEX (decl) = NULL_TREE;\n-\t      TREE_OPERAND (stmt, 2) = copy_to_permanent (init);\n-\t      add_tree (stmt);\n-\t    }\n-\t}\n-\n+\tDECL_INITIAL (decl) = copy_to_permanent (init);\n       goto finish_end0;\n     }\n \n@@ -7466,9 +7438,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   else if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       if (TREE_STATIC (decl))\n-\tmake_decl_rtl (decl, NULL_PTR,\n-\t\t       toplevel_bindings_p ()\n-\t\t       || pseudo_global_level_p ());\n+\tmake_decl_rtl (decl, NULL_PTR, toplevel_bindings_p ());\n       grok_reference_init (decl, type, init);\n       init = NULL_TREE;\n     }\n@@ -7678,7 +7648,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       || TREE_CODE (decl) == RESULT_DECL)\n     {\n       /* ??? FIXME: What about nested classes?  */\n-      int toplev = toplevel_bindings_p () || pseudo_global_level_p ();\n+      int toplev = toplevel_bindings_p ();\n       int was_temp\n \t= (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n \t   && allocation_temporary_p ());\n@@ -8647,7 +8617,17 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       else\n \tcontext = NULL_TREE;\n \n-      decl = build_decl (VAR_DECL, declarator, complete_type (type));\n+      if (processing_template_decl) \n+\t{\n+\t  /* If we're in a template, we need DECL_LANG_SPECIFIC so that\n+\t     we can call push_template_decl.  */\n+\t  push_permanent_obstack ();\n+\t  decl = build_lang_field_decl (VAR_DECL, declarator,\n+\t\t\t\t\tcomplete_type (type));\n+\t  pop_obstacks ();\n+\t}\n+      else\n+\tdecl = build_decl (VAR_DECL, declarator, complete_type (type));\n \n       if (context)\n \tset_decl_namespace (decl, context, 0);\n@@ -9259,8 +9239,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n      We also want to avoid calling this a PARM if it is in a namespace.  */\n \n-  if (decl_context == NORMAL && ! namespace_bindings_p ()\n-      && ! pseudo_global_level_p ())\n+  if (decl_context == NORMAL && !toplevel_bindings_p ())\n     {\n       struct binding_level *b = current_binding_level;\n       current_binding_level = b->level_chain;\n@@ -10568,15 +10547,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t     since it might be used as a template parameter. */\n \t  if (type != error_mark_node)\n \t    push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n-\t  decl = build_decl (TYPE_DECL, declarator, type);\n+\t  if (processing_template_decl)\n+\t    decl = build_lang_field_decl (TYPE_DECL, declarator, type);\n+\t  else\n+\t    decl = build_decl (TYPE_DECL, declarator, type);\n \t  if (type != error_mark_node)\n \t    pop_obstacks ();\n \t}\n \n-      /* If the user declares \"struct {...} foo\" then `foo' will have\n-\t an anonymous name.  Fill that name in now.  Nothing can\n-\t refer to it, so nothing needs know about the name change.\n-\t The TYPE_NAME field was filled in by build_struct_xref.  */\n+      /* If the user declares \"typedef struct {...} foo\" then the\n+\t struct will have an anonymous name.  Fill that name in now.\n+\t Nothing can refer to it, so nothing needs know about the name\n+\t change.  */\n       if (type != error_mark_node\n \t  && TYPE_NAME (type)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n@@ -11039,7 +11021,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      {\n \t\t/* C++ allows static class members.\n \t\t   All other work for this is done by grokfield.\n-\t\t   This VAR_DCL is built by build_lang_field_decl.\n+\t\t   This VAR_DECL is built by build_lang_field_decl.\n \t\t   All other VAR_DECLs are built by build_decl.  */\n \t\tdecl = build_lang_field_decl (VAR_DECL, declarator, type);\n \t\tTREE_STATIC (decl) = 1;\n@@ -12913,6 +12895,31 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   if (pre_parsed_p == 2)\n     maybe_begin_member_template_processing (decl1);\n \n+  /* Effective C++ rule 15.  See also c_expand_return.  */\n+  if (warn_ecpp\n+      && DECL_NAME (decl1) == ansi_opname[(int) MODIFY_EXPR]\n+      && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)\n+    cp_warning (\"`operator=' should return a reference to `*this'\");\n+\n+  /* Make the init_value nonzero so pushdecl knows this is not tentative.\n+     error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n+  DECL_INITIAL (decl1) = error_mark_node;\n+\n+#ifdef SET_DEFAULT_DECL_ATTRIBUTES\n+  SET_DEFAULT_DECL_ATTRIBUTES (decl1, attrs);\n+#endif\n+  \n+  /* This function exists in static storage.\n+     (This does not mean `static' in the C sense!)  */\n+  TREE_STATIC (decl1) = 1;\n+\n+  /* We must call push_template_decl after current_class_type is set\n+     up.  (If we are processing inline definitions after exiting a\n+     class scope, current_class_type will be NULL_TREE until set above\n+     by push_nested_class.)  */\n+  if (processing_template_decl)\n+    decl1 = push_template_decl (decl1);\n+\n   /* We are now in the scope of the function being defined.  */\n   current_function_decl = decl1;\n \n@@ -12955,31 +12962,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       abstract_virtuals_error (decl1, TREE_TYPE (fntype));\n     }\n \n-  /* Effective C++ rule 15.  See also c_expand_return.  */\n-  if (warn_ecpp\n-      && DECL_NAME (decl1) == ansi_opname[(int) MODIFY_EXPR]\n-      && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)\n-    cp_warning (\"`operator=' should return a reference to `*this'\");\n-\n-  /* Make the init_value nonzero so pushdecl knows this is not tentative.\n-     error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n-  DECL_INITIAL (decl1) = error_mark_node;\n-\n-#ifdef SET_DEFAULT_DECL_ATTRIBUTES\n-  SET_DEFAULT_DECL_ATTRIBUTES (decl1, attrs);\n-#endif\n-  \n-  /* This function exists in static storage.\n-     (This does not mean `static' in the C sense!)  */\n-  TREE_STATIC (decl1) = 1;\n-\n-  /* We must call push_template_decl after current_class_type is set\n-     up.  (If we are processing inline definitions after exiting a\n-     class scope, current_class_type will be NULL_TREE until set above\n-     by push_nested_class.)  */\n-  if (processing_template_decl)\n-    decl1 = push_template_decl (decl1);\n-\n   /* Record the decl so that the function name is defined.\n      If we already have a decl for this name, and it is a FUNCTION_DECL,\n      use the old decl.  */"}, {"sha": "3cebe815640ff7c3406f9b100c0f24e6d7bb4b63", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -1644,6 +1644,9 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \tDECL_ASSEMBLER_NAME (value) =\n \t  get_identifier (build_overload_name (TREE_TYPE (value), 1, 1));\n \n+      if (processing_template_decl)\n+\tvalue = push_template_decl (value);\n+\n       return value;\n     }\n \n@@ -2823,8 +2826,7 @@ get_sentry (base)\n   tree sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n   if (! sentry)\n     {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n       sentry = build_decl (VAR_DECL, sname, integer_type_node);\n       TREE_PUBLIC (sentry) = 1;\n       DECL_ARTIFICIAL (sentry) = 1;"}, {"sha": "e04655264a8ca3f47a9bffc80d82007964ed1286", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -662,12 +662,8 @@ dequeue_and_dump (di)\n \n     case DECL_STMT:\n       dump_stmt (di, t);\n-#if 0\n-      /* We do not yet have DECL_STMT_DECL; there are declarators and\n-\t such hanging about in DECL_STMTs.  */\n       if (dump_children_p)\n \tdump_child (\"decl\", DECL_STMT_DECL (t));\n-#endif\n       break;\n       \n     case DO_STMT:"}, {"sha": "0ef6e82795bcccc90a5a5b3c105b85b3343a8fa8", "filename": "gcc/cp/except.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -240,8 +240,7 @@ call_eh_info ()\n \n       /* Declare cp_eh_info * __start_cp_handler (void),\n \t as defined in exception.cc. */\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n \n       /* struct cp_eh_info.  This must match exception.cc.  Note that this\n \t type is not pushed anywhere.  */\n@@ -422,8 +421,7 @@ build_eh_type_type_ref (type)\n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n+  push_permanent_obstack ();\n \n   if (flag_rtti)\n     {\n@@ -502,8 +500,7 @@ do_pop_exception ()\n     {\n       /* Declare void __cp_pop_exception (void *),\n \t as defined in exception.cc. */\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n       fn = build_lang_decl\n \t(FUNCTION_DECL, fn,\n \t build_function_type (void_type_node, tree_cons\n@@ -773,8 +770,7 @@ expand_end_eh_spec (raises)\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n \n       tmp = tree_cons\n \t(NULL_TREE, integer_type_node, tree_cons\n@@ -920,8 +916,7 @@ alloc_eh_object (type)\n     {\n       /* Declare __eh_alloc (size_t), as defined in exception.cc.  */\n       tree tmp;\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n       tmp = tree_cons (NULL_TREE, sizetype, void_list_node);\n       fn = build_lang_decl (FUNCTION_DECL, fn,\n \t\t\t    build_function_type (ptr_type_node, tmp));\n@@ -973,8 +968,7 @@ expand_throw (exp)\n \t the internal type of a destructor. */\n       if (cleanup_type == NULL_TREE)\n \t{\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n+\t  push_permanent_obstack ();\n \t  cleanup_type = build_pointer_type\n \t    (build_function_type\n \t     (void_type_node, tree_cons\n@@ -1074,8 +1068,7 @@ expand_throw (exp)\n \t  /* Declare __cp_push_exception (void*, void*, void (*)(void*, int)),\n \t     as defined in exception.cc.  */\n \t  tree tmp;\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n+\t  push_permanent_obstack ();\n \t  tmp = tree_cons\n \t    (NULL_TREE, ptr_type_node, tree_cons\n \t     (NULL_TREE, ptr_type_node, tree_cons\n@@ -1108,8 +1101,7 @@ expand_throw (exp)\n \t{\n \t  /* Declare void __uncatch_exception (void)\n \t     as defined in exception.cc. */\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n+\t  push_permanent_obstack ();\n \t  fn = build_lang_decl (FUNCTION_DECL, fn,\n \t\t\t\tbuild_function_type (void_type_node,\n \t\t\t\t\t\t     void_list_node));"}, {"sha": "69758a62a459d293f0d8ae5ae7bea9d5b313cb35", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -2141,8 +2141,7 @@ build_java_class_ref (type)\n   class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n   if (class_decl == NULL_TREE)\n     {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n       class_decl = build_decl (VAR_DECL, name, TREE_TYPE (jclass_node));\n       TREE_STATIC (class_decl) = 1;\n       DECL_EXTERNAL (class_decl) = 1;"}, {"sha": "f36da5319919bbd7aa9810e071bdbee86d8ad53c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -330,8 +330,7 @@ get_time_identifier (name)\n   time_identifier = get_identifier (buf);\n   if (TIME_IDENTIFIER_TIME (time_identifier) == NULL_TREE)\n     {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n       TIME_IDENTIFIER_TIME (time_identifier) = build_int_2 (0, 0);\n       TIME_IDENTIFIER_FILEINFO (time_identifier) \n \t= build_int_2 (0, 1);\n@@ -4716,8 +4715,8 @@ extern int tree_node_sizes[];\n #endif\n \n /* Place to save freed lang_decls which were allocated on the\n-   permanent_obstack.  @@ Not currently used.  */\n-tree free_lang_decl_chain;\n+   permanent_obstack.  */\n+struct lang_decl *free_lang_decl_chain;\n \n tree\n build_lang_decl (code, name, type)\n@@ -4738,8 +4737,7 @@ retrofit_lang_decl (t)\n      tree t;\n {\n   struct obstack *obstack = current_obstack;\n-  register int i = sizeof (struct lang_decl) / sizeof (int);\n-  register int *pi;\n+  struct lang_decl *ld;\n \n   if (! TREE_PERMANENT (t))\n     obstack = saveable_obstack;\n@@ -4749,20 +4747,18 @@ retrofit_lang_decl (t)\n \n   if (free_lang_decl_chain && obstack == &permanent_obstack)\n     {\n-      pi = (int *)free_lang_decl_chain;\n-      free_lang_decl_chain = TREE_CHAIN (free_lang_decl_chain);\n+      ld = free_lang_decl_chain;\n+      free_lang_decl_chain = free_lang_decl_chain->u.next;\n     }\n   else\n-    pi = (int *) obstack_alloc (obstack, sizeof (struct lang_decl));\n+    ld = ((struct lang_decl *) \n+\t  obstack_alloc (obstack, sizeof (struct lang_decl)));\n \n-  while (i > 0)\n-    pi[--i] = 0;\n+  bzero (ld, sizeof (struct lang_decl));\n \n-  DECL_LANG_SPECIFIC (t) = (struct lang_decl *) pi;\n-  LANG_DECL_PERMANENT ((struct lang_decl *) pi)\n-    = obstack == &permanent_obstack;\n-  my_friendly_assert (LANG_DECL_PERMANENT ((struct lang_decl *) pi)\n-\t  == TREE_PERMANENT  (t), 234);\n+  DECL_LANG_SPECIFIC (t) = ld;\n+  LANG_DECL_PERMANENT (ld) = obstack == &permanent_obstack;\n+  my_friendly_assert (LANG_DECL_PERMANENT (ld) == TREE_PERMANENT  (t), 234);\n   DECL_MAIN_VARIANT (t) = t;\n   if (current_lang_name == lang_name_cplusplus)\n     DECL_LANGUAGE (t) = lang_cplusplus;\n@@ -4772,21 +4768,15 @@ retrofit_lang_decl (t)\n     DECL_LANGUAGE (t) = lang_java;\n   else my_friendly_abort (64);\n \n-#if 0 /* not yet, should get fixed properly later */\n-  if (code == TYPE_DECL)\n-    {\n-      tree id;\n-      id = get_identifier (build_overload_name (type, 1, 1));\n-      DECL_ASSEMBLER_NAME (t) = id;\n-    }\n-\n-#endif\n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)lang_decl] += 1;\n   tree_node_sizes[(int)lang_decl] += sizeof (struct lang_decl);\n #endif\n }\n \n+/* Like build_decl, except that a new lang_decl_flags structure is\n+   placed in DECL_LANG_SPECIFIC.  */\n+\n tree\n build_lang_field_decl (code, name, type)\n      enum tree_code code;\n@@ -4796,28 +4786,16 @@ build_lang_field_decl (code, name, type)\n   extern struct obstack *current_obstack, *saveable_obstack;\n   register tree t = build_decl (code, name, type);\n   struct obstack *obstack = current_obstack;\n-  register int i = sizeof (struct lang_decl_flags) / sizeof (int);\n-  register int *pi;\n-#if 0 /* not yet, should get fixed properly later */\n-\n-  if (code == TYPE_DECL)\n-    {\n-      tree id;\n-      id = get_identifier (build_overload_name (type, 1, 1));\n-      DECL_ASSEMBLER_NAME (t) = id;\n-    }\n-#endif\n \n   if (! TREE_PERMANENT (t))\n     obstack = saveable_obstack;\n   else\n     my_friendly_assert (obstack == &permanent_obstack, 235);\n \n-  pi = (int *) obstack_alloc (obstack, sizeof (struct lang_decl_flags));\n-  while (i > 0)\n-    pi[--i] = 0;\n-\n-  DECL_LANG_SPECIFIC (t) = (struct lang_decl *) pi;\n+  DECL_LANG_SPECIFIC (t) \n+    = ((struct lang_decl *) \n+       obstack_alloc (obstack, sizeof (struct lang_decl_flags)));\n+  bzero (DECL_LANG_SPECIFIC (t), sizeof (struct lang_decl_flags));\n   return t;\n }\n "}, {"sha": "337e55aa7ca4e6e8e74c08481886596300dcc197", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -131,3 +131,5 @@ extern tree got_object;\n extern int pending_lang_change;\n \n extern int yylex PROTO((void));\n+\n+extern struct lang_decl *free_lang_decl_chain;"}, {"sha": "b2b85c94a62437d00b2700fc147f1ee8f21a9158", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -4444,7 +4444,7 @@ case 12:\n     break;}\n case 13:\n #line 386 \"parse.y\"\n-{ if (! toplevel_bindings_p () && ! pseudo_global_level_p())\n+{ if (! toplevel_bindings_p ())\n \t\t  pop_everything (); ;\n     break;}\n case 14:"}, {"sha": "5698789e35b38842736f9fa1c53e5a70cbb9bf26", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -383,7 +383,7 @@ asm_keyword:\n lang_extdef:\n \t\t{ if (pending_lang_change) do_pending_lang_change(); }\n \t  extdef\n-\t\t{ if (! toplevel_bindings_p () && ! pseudo_global_level_p())\n+\t\t{ if (! toplevel_bindings_p ())\n \t\t  pop_everything (); }\n \t;\n "}, {"sha": "e00afbd2c667589064cbcca45459af70bd3e9232", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 176, "deletions": 52, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -123,7 +123,9 @@ static tree build_template_parm_index PROTO((int, int, int, tree, tree));\n static int inline_needs_template_parms PROTO((tree));\n static void push_inline_template_parms_recursive PROTO((tree, int));\n static tree retrieve_specialization PROTO((tree, tree));\n+static tree retrieve_local_specialization PROTO((tree, tree));\n static tree register_specialization PROTO((tree, tree, tree));\n+static tree register_local_specialization PROTO((tree, tree, tree));\n static int unregister_specialization PROTO((tree, tree));\n static tree reduce_template_parm_level PROTO((tree, tree, int));\n static tree build_template_decl PROTO((tree, tree));\n@@ -160,6 +162,7 @@ static int coerce_template_template_parms PROTO((tree, tree, int,\n static tree determine_specialization PROTO((tree, tree, tree *, int));\n static int template_args_equal PROTO((tree, tree));\n static void print_template_context PROTO((int));\n+static void tsubst_default_arguments PROTO((tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -756,6 +759,18 @@ retrieve_specialization (tmpl, args)\n   return NULL_TREE;\n }\n \n+/* Like retrieve_speciailization, but for local declarations.  FN is\n+   the function in which we are looking for an instantiation.  */\n+\n+static tree\n+retrieve_local_specialization (tmpl, fn)\n+     tree tmpl;\n+     tree fn;\n+{\n+  tree s = purpose_member (fn, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+  return s ? TREE_VALUE (s) : NULL_TREE;\n+}\n+\n /* Returns non-zero iff DECL is a specialization of TMPL.  */\n \n int\n@@ -911,6 +926,22 @@ unregister_specialization (spec, tmpl)\n   return 0;\n }\n \n+/* Like register_specialization, but for local declarations.  FN is\n+   the function in which we are registering SPEC, an instantiation of\n+   TMPL.  */\n+\n+static tree\n+register_local_specialization (spec, tmpl, fn)\n+     tree spec;\n+     tree tmpl;\n+     tree fn;\n+{\n+  DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n+     = perm_tree_cons (fn, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+\n+  return spec;\n+}\n+\n /* Print the list of candidate FNS in an error message.  */\n \n void\n@@ -2350,7 +2381,7 @@ push_template_decl_real (decl, is_friend)\n   int is_partial;\n \n   /* See if this is a partial specialization.  */\n-  is_partial = (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl)\n+  is_partial = (DECL_IMPLICIT_TYPEDEF_P (decl)\n \t\t&& TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n \t\t&& CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)));\n \n@@ -2368,30 +2399,16 @@ push_template_decl_real (decl, is_friend)\n   else\n     /* Otherwise, if we're currently definining some class, the DECL\n        is assumed to be a member of the class.  */\n-    ctx = current_class_type;\n+    ctx = current_scope ();\n \n   if (ctx && TREE_CODE (ctx) == NAMESPACE_DECL)\n     ctx = NULL_TREE;\n \n   if (!DECL_CONTEXT (decl))\n     DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \n-  /* For determining whether this is a primary template or not, we're really\n-     interested in the lexical context, not the true context.  */\n-  if (is_friend)\n-    info = current_class_type;\n-  else\n-    info = ctx;\n-\n   /* See if this is a primary template.  */\n-  if (info && TREE_CODE (info) == FUNCTION_DECL)\n-    primary = 0;\n-  /* Note that template_class_depth returns 0 if given NULL_TREE, so\n-     this next line works even when we are at global scope.  */\n-  else if (processing_template_decl > template_class_depth (info))\n-    primary = 1;\n-  else\n-    primary = 0;\n+  primary = pseudo_global_level_p ();\n \n   if (primary)\n     {\n@@ -2546,7 +2563,7 @@ push_template_decl_real (decl, is_friend)\n \n   info = perm_tree_cons (tmpl, args, NULL_TREE);\n \n-  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n+  if (DECL_IMPLICIT_TYPEDEF_P (decl))\n     {\n       SET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n       if ((!ctx || TREE_CODE (ctx) != FUNCTION_DECL)\n@@ -3932,16 +3949,13 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t{\n \t  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n \t  \n-\t  /* Create a stub TYPE_DECL for it.  */\n-\t  type_decl = build_decl (TYPE_DECL, DECL_NAME (template), t);\n-\t  SET_DECL_ARTIFICIAL (type_decl);\n+\t  type_decl = create_implicit_typedef (DECL_NAME (template), t);\n \t  DECL_CONTEXT (type_decl) = TYPE_CONTEXT (t);\n-\t  \n+\t  TYPE_STUB_DECL (t) = type_decl;\n \t  DECL_SOURCE_FILE (type_decl) \n \t    = DECL_SOURCE_FILE (TYPE_STUB_DECL (template_type));\n \t  DECL_SOURCE_LINE (type_decl) \n \t    = DECL_SOURCE_LINE (TYPE_STUB_DECL (template_type));\n-\t  TYPE_STUB_DECL (t) = TYPE_NAME (t) = type_decl;\n \t}\n       else\n \ttype_decl = TYPE_NAME (t);\n@@ -5193,6 +5207,18 @@ instantiate_class_template (type)\n   TYPE_BEING_DEFINED (type) = 0;\n   repo_template_used (type);\n \n+  /* Now that the class is complete, instantiate default arguments for\n+     any member functions.  We don't do this earlier because the\n+     default arguments may reference members of the class.  */\n+  if (!PRIMARY_TEMPLATE_P (template))\n+    for (t = TYPE_METHODS (type); t; t = TREE_CHAIN (t))\n+      if (TREE_CODE (t) == FUNCTION_DECL \n+\t  /* Implicitly generated member functions will not have tmplate\n+\t     information; they are not instantiations, but instead are\n+\t     created \"fresh\" for each instantiation.  */\n+\t  && DECL_TEMPLATE_INFO (t))\n+\ttsubst_default_arguments (t);\n+\n   popclass ();\n   pop_from_top_level ();\n   pop_tinst_level ();\n@@ -5417,6 +5443,66 @@ tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n     }\n }\n \n+/* Substitute into the default argument ARG (a default argument for\n+   FN), which has the indicated TYPE.  */\n+\n+tree\n+tsubst_default_argument (fn, type, arg)\n+     tree fn;\n+     tree type;\n+     tree arg;\n+{\n+  /* This default argument came from a template.  Instantiate the\n+     default argument here, not in tsubst.  In the case of\n+     something like: \n+     \n+       template <class T>\n+       struct S {\n+\t static T t();\n+\t void f(T = t());\n+       };\n+     \n+     we must be careful to do name lookup in the scope of S<T>,\n+     rather than in the current class.  */\n+  if (DECL_CLASS_SCOPE_P (fn))\n+    pushclass (DECL_REAL_CONTEXT (fn), 2);\n+\n+  arg = tsubst_expr (arg, DECL_TI_ARGS (fn), /*complain=*/1, NULL_TREE);\n+  \n+  if (DECL_CLASS_SCOPE_P (fn))\n+    popclass ();\n+\n+  /* Make sure the default argument is reasonable.  */\n+  arg = check_default_argument (type, arg);\n+\n+  return arg;\n+}\n+\n+/* Substitute into all the default arguments for FN.  */\n+\n+static void\n+tsubst_default_arguments (fn)\n+     tree fn;\n+{\n+  tree arg;\n+  tree tmpl_args;\n+\n+  tmpl_args = DECL_TI_ARGS (fn);\n+\n+  /* If this function is not yet instantiated, we certainly don't need\n+     its default arguments.  */\n+  if (uses_template_parms (tmpl_args))\n+    return;\n+\n+  for (arg = TYPE_ARG_TYPES (TREE_TYPE (fn)); \n+       arg; \n+       arg = TREE_CHAIN (arg))\n+    if (TREE_PURPOSE (arg))\n+      TREE_PURPOSE (arg) = tsubst_default_argument (fn, \n+\t\t\t\t\t\t    TREE_VALUE (arg),\n+\t\t\t\t\t\t    TREE_PURPOSE (arg));\n+}\n+\n /* Substitute the ARGS into the T, which is a _DECL.  TYPE is the\n    (already computed) substitution of ARGS into TREE_TYPE (T), if\n    appropriate.  Return the result of the substitution.  IN_DECL is as\n@@ -5804,6 +5890,22 @@ tsubst_decl (t, args, type, in_decl)\n \t\t&& (IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r)) \n \t\t    == NULL_TREE))\n \t      SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r), r);\n+\n+\t    /* We're not supposed to instantiate default arguments\n+\t       until they are called, for a template.  But, for a\n+\t       declaration like:\n+\n+\t         template <class T> void f () \n+                 { extern void g(int i = T()); }\n+\t\t \n+\t       we should do the substitution when the template is\n+\t       instantiated.  We handle the member function case in\n+\t       instantiate_class_template since the default arguments\n+\t       might refer to other members of the class.  */\n+\t    if (!member\n+\t\t&& !PRIMARY_TEMPLATE_P (gen_tmpl)\n+\t\t&& !uses_template_parms (argvec))\n+\t      tsubst_default_arguments (r);\n \t  }\n \n \t/* Copy the list of befriending classes.  */\n@@ -5877,26 +5979,56 @@ tsubst_decl (t, args, type, in_decl)\n       }\n       break;\n \n+    case TYPE_DECL:\n+      if (DECL_IMPLICIT_TYPEDEF_P (t))\n+\t{\n+\t  /* For an implicit typedef, we just want the implicit\n+\t     typedef for the tsubst'd type.  We've already got the\n+\t     tsubst'd type, as TYPE, so we just need it's associated\n+\t     declaration.  */\n+\t  r = TYPE_NAME (type);\n+\t  break;\n+\t}\n+      else if (!DECL_LANG_SPECIFIC (t))\n+\t{\n+\t  /* For a template type parameter, we don't have to do\n+\t     anything special.  */\n+\t  r= TYPE_NAME (type);\n+\t  break;\n+\t}\n+\n+      /* Fall through.  */\n+\n     case VAR_DECL:\n       {\n \ttree argvec;\n \ttree gen_tmpl;\n \ttree spec;\n \ttree tmpl;\n-\ttree ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n-\t\t\t\t     /*complain=*/1,\n-\t\t\t\t     in_decl, /*entering_scope=*/1);\n-\t\n+\ttree ctx;\n+\n \t/* Nobody should be tsubst'ing into non-template variables.  */\n \tmy_friendly_assert (DECL_LANG_SPECIFIC (t) \n \t\t\t    && DECL_TEMPLATE_INFO (t) != NULL_TREE, 0);\n \n+\tif (TYPE_P (DECL_CONTEXT (t)))\n+\t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n+\t\t\t\t  /*complain=*/1,\n+\t\t\t\t  in_decl, /*entering_scope=*/1);\n+\telse\n+\t  /* Subsequent calls to pushdecl will fill this in.  */\n+\t  ctx = NULL_TREE;\n+\n \t/* Check to see if we already have this specialization.  */\n \ttmpl = DECL_TI_TEMPLATE (t);\n \tgen_tmpl = most_general_template (tmpl);\n \targvec = tsubst (DECL_TI_ARGS (t), args, /*complain=*/1, in_decl);\n-\tspec = retrieve_specialization (gen_tmpl, argvec);\n-\t\n+\tif (ctx)\n+\t  spec = retrieve_specialization (gen_tmpl, argvec);\n+\telse\n+\t  spec = retrieve_local_specialization (gen_tmpl,\n+\t\t\t\t\t\tcurrent_function_decl);\n+\n \tif (spec)\n \t  {\n \t    r = spec;\n@@ -5923,26 +6055,18 @@ tsubst_decl (t, args, type, in_decl)\n \n \tDECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \tSET_DECL_IMPLICIT_INSTANTIATION (r);\n-\tregister_specialization (r, gen_tmpl, argvec);\n+\tif (ctx)\n+\t  register_specialization (r, gen_tmpl, argvec);\n+\telse\n+\t  register_local_specialization (r, gen_tmpl,\n+\t\t\t\t\t current_function_decl);\n \n \tTREE_CHAIN (r) = NULL_TREE;\n-\tif (TREE_CODE (type) == VOID_TYPE)\n+\tif (TREE_CODE (r) == VAR_DECL && TREE_CODE (type) == VOID_TYPE)\n \t  cp_error_at (\"instantiation of `%D' as type void\", r);\n       }\n       break;\n \n-    case TYPE_DECL:\n-      if (t == TYPE_NAME (TREE_TYPE (t)))\n-\tr = TYPE_NAME (type);\n-      else\n-\t{\n-\t  r = copy_node (t);\n-\t  TREE_TYPE (r) = type;\n-\t  DECL_CONTEXT (r) = current_class_type;\n-\t  TREE_CHAIN (r) = NULL_TREE;\n-\t}\n-      break;\n-\n     default:\n       my_friendly_abort (0);\n     } \n@@ -6759,15 +6883,15 @@ tsubst_copy (t, args, complain, in_decl)\n \t  return t;\n \n \t/* Unfortunately, we cannot just call lookup_name here.\n-\t Consider:\n-\n-\t template <int I> int f() {\n-\t   enum E { a = I };\n-\t   struct S { void g() { E e = a; } };\n-\t };\n-\n-\t When we instantiate f<7>::S::g(), say, lookup_name is not\n-\t clever enough to find f<7>::a.  */\n+\t   Consider:\n+\t   \n+\t     template <int I> int f() {\n+\t     enum E { a = I };\n+\t     struct S { void g() { E e = a; } };\n+\t     };\n+\t   \n+\t   When we instantiate f<7>::S::g(), say, lookup_name is not\n+\t   clever enough to find f<7>::a.  */\n \tenum_type \n \t  = tsubst_aggr_type (TREE_TYPE (t), args, complain, in_decl, \n \t\t\t      /*entering_scope=*/0);"}, {"sha": "300d7107cf4a9c6d92c48439c207d2cdf5d6673b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -622,6 +622,17 @@ current_scope ()\n   return current_class_type;\n }\n \n+/* Returns non-zero if we are currently in a function scope.  Note\n+   that this function returns zero if we are within a local class, but\n+   not within a member function body of the local class.  */\n+\n+int\n+at_function_scope_p ()\n+{\n+  tree cs = current_scope ();\n+  return cs && TREE_CODE (cs) == FUNCTION_DECL;\n+}\n+\n /* Return the scope of DECL, as appropriate when doing name-lookup.  */\n \n static tree\n@@ -1212,9 +1223,9 @@ lookup_field_queue_p (binfo, data)\n     return binfo;\n }\n \n-/* Within the scope of a template class, you can refer to the\n-   particular to the current specialization with the name of the\n-   template itself.  For example:\n+/* Within the scope of a template class, you can refer to the to the\n+   current specialization with the name of the template itself.  For\n+   example:\n    \n      template <typename T> struct S { S* sp; }\n "}, {"sha": "0711da3df608e3b6d6fd32f6f51d9e79e223dabe", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -780,12 +780,9 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n   if (TREE_CHAIN (string))\n     {\n       if (processing_template_decl)\n-\t{\n-\t  /* We need to build the combined string on the permanent\n-\t     obstack so that we can use it during instantiations.  */\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\t}\n+\t/* We need to build the combined string on the permanent\n+\t   obstack so that we can use it during instantiations.  */\n+\tpush_permanent_obstack ();\n \n       string = combine_strings (string);\n \n@@ -842,8 +839,7 @@ finish_label_stmt (name)\n \n   if (processing_template_decl)\n     {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n+      push_permanent_obstack ();\n       decl = build_decl (LABEL_DECL, name, void_type_node);\n       pop_obstacks ();\n       DECL_SOURCE_LINE (decl) = lineno;\n@@ -858,6 +854,21 @@ finish_label_stmt (name)\n     }\n }\n \n+/* Create a declaration statement for the declaration given by the\n+   DECL.  */\n+\n+void\n+add_decl_stmt (decl)\n+     tree decl;\n+{\n+  tree decl_stmt;\n+\n+  /* We need the type to last until instantiation time.  */\n+  TREE_TYPE (decl) = copy_to_permanent (TREE_TYPE (decl));\n+  decl_stmt = build_min_nt (DECL_STMT, decl);\n+  add_tree (decl_stmt);\n+}\n+\n /* Finish a parenthesized expression EXPR.  */\n \n tree\n@@ -1302,9 +1313,8 @@ tree\n begin_class_definition (t)\n      tree t;\n {\n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-  \n+  push_permanent_obstack ();\n+\n   if (t == error_mark_node\n       || ! IS_AGGR_TYPE (t))\n     {\n@@ -1726,12 +1736,9 @@ finish_typeof (expr)\n     {\n       tree t;\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n+      push_permanent_obstack ();\n       t = make_lang_type (TYPEOF_TYPE);\n       TYPE_FIELDS (t) = expr;\n-\n       pop_obstacks ();\n \n       return t;"}, {"sha": "7a35b47a0b108c4f0f10dcff1c0c6134228bac8c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -442,7 +442,7 @@ build_cplus_array_type_1 (elt_type, index_type)\n \n   push_obstacks_nochange ();\n \n-  /* We need a new one.  If both ELT_TYPE and INDEX_TYPE are permanent,\n+  /* If both ELT_TYPE and INDEX_TYPE are permanent,\n      make this permanent too.  */\n   if (TREE_PERMANENT (elt_type)\n       && (index_type == 0 || TREE_PERMANENT (index_type)))\n@@ -1533,8 +1533,7 @@ copy_template_template_parm (t)\n   tree t2;\n \n   /* Make sure these end up on the permanent_obstack.  */\n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n+  push_permanent_obstack ();\n   \n   t2 = make_lang_type (TEMPLATE_TEMPLATE_PARM);\n   template = copy_node (template);\n@@ -2086,11 +2085,8 @@ copy_to_permanent (t)\n   if (t == NULL_TREE || TREE_PERMANENT (t))\n     return t;\n \n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-\n+  push_permanent_obstack ();\n   t = mapcar (t, perm_manip);\n-\n   pop_obstacks ();\n \n   return t;\n@@ -2622,6 +2618,17 @@ push_expression_obstack ()\n   current_obstack = expression_obstack;\n }\n \n+/* Begin allocating on the permanent obstack.  When you're done\n+   allocating there, call pop_obstacks to return to the previous set\n+   of obstacks.  */\n+\n+void\n+push_permanent_obstack ()\n+{\n+  push_obstacks_nochange ();\n+  end_temporary_allocation ();\n+}\n+\n /* The type of ARG when used as an lvalue.  */\n \n tree"}, {"sha": "044f48fdaa83665d69d127bdcef4655e660d6126", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -5090,8 +5090,7 @@ mark_addressable (exp)\n \t  {\n \t    /* We thought this would make a good constant variable,\n \t       but we were wrong.  */\n-\t    push_obstacks_nochange ();\n-\t    end_temporary_allocation ();\n+\t    push_permanent_obstack ();\n \n \t    TREE_ASM_WRITTEN (x) = 0;\n \t    DECL_RTL (x) = 0;"}, {"sha": "d0af82f9f3dd905e35b1f8214b50ca67e688ecd9", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash15.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash15.C?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -6,5 +6,5 @@ struct A { // ERROR - too many template parameter lists\n public:\n   A() {}\n \n-  A(const A<T>& b) {} // ERROR - invalid use of template\n+  A(const A<T>& b) {}\n };"}, {"sha": "3c53e8e1fb64be62e7a69508c44fea7ae5ab1e15", "filename": "gcc/testsuite/g++.old-deja/g++.pt/defarg12.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg12.C?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T = int>\n+struct S \n+{\n+  void f ()\n+    {\n+      struct U {\n+      };\n+    }\n+};"}, {"sha": "1082bf567e0a64e6b6533c45c48ea92508c7a212", "filename": "gcc/testsuite/g++.old-deja/g++.pt/defarg13.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9188c36364c9a8bdd993a5d911b875ce124bb04d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg13.C?ref=9188c36364c9a8bdd993a5d911b875ce124bb04d", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+void f (int i)\n+{\n+  struct S { void g (int j = i) {} }; // ERROR - default argument uses local\n+\n+  S s; // ERROR - instantiated here\n+}\n+\n+template void f<double>(int); // ERROR - instantiated here\n+"}]}