{"sha": "d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY4ZDU2YjU3ZjczNmQzNjJjMDY2YmMxMmQ0NGFlNzZjYmIyZmI5Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-04-25T11:19:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-04-25T11:19:08Z"}, "message": "tree-vectorizer.h (vect_loop_versioning): Adjust prototype.\n\n2012-04-25  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_loop_versioning): Adjust prototype.\n\t* tree-vect-loop.c (vect_transform_loop): Adjust.\n\t* tree-vect-loop-manip.c (vect_do_peeling_for_loop_bound): Record\n\tthe maximum number of iterations for the epilogue loop.\n\t(vect_loop_versioning): Remove case re-using the peeled\n\tepilogue loop.\n\nFrom-SVN: r186813", "tree": {"sha": "066b73005eea15d209698d78ab6abea4ef8273ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/066b73005eea15d209698d78ab6abea4ef8273ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fdce1719a552ed44439cea61e795f67e82d446e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdce1719a552ed44439cea61e795f67e82d446e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdce1719a552ed44439cea61e795f67e82d446e8"}], "stats": {"total": 85, "additions": 39, "deletions": 46}, "files": [{"sha": "3770d39aa16f45b4f332cc04badb57e16d3e5662", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "patch": "@@ -1,3 +1,12 @@\n+2012-04-25  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_loop_versioning): Adjust prototype.\n+\t* tree-vect-loop.c (vect_transform_loop): Adjust.\n+\t* tree-vect-loop-manip.c (vect_do_peeling_for_loop_bound): Record\n+\tthe maximum number of iterations for the epilogue loop.\n+\t(vect_loop_versioning): Remove case re-using the peeled\n+\tepilogue loop.\n+\n 2012-04-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/52880"}, {"sha": "63885f9578a289ad8913c197e412b868b1737320", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "patch": "@@ -1907,6 +1907,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   bool check_profitability = false;\n   unsigned int th = 0;\n   int min_profitable_iters;\n+  int max_iter;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_loop_bound ===\");\n@@ -1966,15 +1967,11 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n      by ratio_mult_vf_name steps.  */\n   vect_update_ivs_after_vectorizer (loop_vinfo, ratio_mult_vf_name, update_e);\n \n-  if (!LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n-      && !LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    {\n-      int max_iter = MAX (LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1, (int) th);\n-      record_niter_bound (new_loop, shwi_to_double_int (max_iter), false, true);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Setting upper bound of nb iterations for epilogue \"\n-\t\t \"loop to %d\\n\", max_iter);\n-    }\n+  max_iter = MAX (LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1, (int) th);\n+  record_niter_bound (new_loop, shwi_to_double_int (max_iter), false, true);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Setting upper bound of nb iterations for epilogue \"\n+\t     \"loop to %d\\n\", max_iter);\n \n   /* After peeling we have to reset scalar evolution analyzer.  */\n   scev_reset ();\n@@ -2547,12 +2544,10 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n    cost model initially.\n \n    The versioning precondition(s) are placed in *COND_EXPR and\n-   *COND_EXPR_STMT_LIST.  If DO_VERSIONING is true versioning is\n-   also performed, otherwise only the conditions are generated.  */\n+   *COND_EXPR_STMT_LIST.  */\n \n void\n-vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n-\t\t      tree *cond_expr, gimple_seq *cond_expr_stmt_list)\n+vect_loop_versioning (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block condition_bb;\n@@ -2561,6 +2556,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n   basic_block new_exit_bb;\n   edge new_exit_e, e;\n   gimple orig_phi, new_phi;\n+  tree cond_expr;\n+  gimple_seq cond_expr_stmt_list = NULL;\n   tree arg;\n   unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n   gimple_seq gimplify_stmt_list = NULL;\n@@ -2574,30 +2571,25 @@ vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n   th = conservative_cost_threshold (loop_vinfo,\n \t\t\t\t    min_profitable_iters);\n \n-  *cond_expr = fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters,\n-\t\t\t    build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n-  *cond_expr = force_gimple_operand_1 (*cond_expr, cond_expr_stmt_list,\n-\t\t\t\t       is_gimple_condexpr, NULL_TREE);\n+  cond_expr = fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters,\n+\t\t\t   build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n+  cond_expr = force_gimple_operand_1 (cond_expr, &cond_expr_stmt_list,\n+\t\t\t\t      is_gimple_condexpr, NULL_TREE);\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo))\n-    vect_create_cond_for_align_checks (loop_vinfo, cond_expr,\n-\t\t\t\t       cond_expr_stmt_list);\n+    vect_create_cond_for_align_checks (loop_vinfo, &cond_expr,\n+\t\t\t\t       &cond_expr_stmt_list);\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    vect_create_cond_for_alias_checks (loop_vinfo, cond_expr,\n-\t\t\t\t       cond_expr_stmt_list);\n+    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr,\n+\t\t\t\t       &cond_expr_stmt_list);\n \n-  *cond_expr = force_gimple_operand_1 (*cond_expr, &gimplify_stmt_list,\n-\t\t\t\t       is_gimple_condexpr, NULL_TREE);\n-  gimple_seq_add_seq (cond_expr_stmt_list, gimplify_stmt_list);\n-\n-  /* If we only needed the extra conditions and a new loop copy\n-     bail out here.  */\n-  if (!do_versioning)\n-    return;\n+  cond_expr = force_gimple_operand_1 (cond_expr, &gimplify_stmt_list,\n+\t\t\t\t      is_gimple_condexpr, NULL_TREE);\n+  gimple_seq_add_seq (&cond_expr_stmt_list, gimplify_stmt_list);\n \n   initialize_original_copy_tables ();\n-  loop_version (loop, *cond_expr, &condition_bb,\n+  loop_version (loop, cond_expr, &condition_bb,\n \t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n   free_original_copy_tables();\n \n@@ -2629,13 +2621,11 @@ vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n   /* End loop-exit-fixes after versioning.  */\n \n   update_ssa (TODO_update_ssa);\n-  if (*cond_expr_stmt_list)\n+  if (cond_expr_stmt_list)\n     {\n       cond_exp_gsi = gsi_last_bb (condition_bb);\n-      gsi_insert_seq_before (&cond_exp_gsi, *cond_expr_stmt_list,\n+      gsi_insert_seq_before (&cond_exp_gsi, cond_expr_stmt_list,\n \t\t\t     GSI_SAME_STMT);\n-      *cond_expr_stmt_list = NULL;\n     }\n-  *cond_expr = NULL_TREE;\n }\n "}, {"sha": "fa38c524f09eeabb9fe0570b63bf58dcede787a4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "patch": "@@ -5229,7 +5229,6 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   unsigned int nunits;\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n-  bool do_peeling_for_loop_bound;\n   gimple stmt, pattern_stmt;\n   gimple_seq pattern_def_seq = NULL;\n   gimple_stmt_iterator pattern_def_si = gsi_start (NULL);\n@@ -5244,17 +5243,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     vect_do_peeling_for_alignment (loop_vinfo);\n \n-  do_peeling_for_loop_bound\n-    = (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-       || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n-       || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n-\n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n       || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    vect_loop_versioning (loop_vinfo,\n-\t\t\t  !do_peeling_for_loop_bound,\n-\t\t\t  &cond_expr, &cond_expr_stmt_list);\n+    vect_loop_versioning (loop_vinfo);\n \n   /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a\n      compile time constant), or it is a constant that doesn't divide by the\n@@ -5264,7 +5255,10 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      will remain scalar and will compute the remaining (n%VF) iterations.\n      (VF is the vectorization factor).  */\n \n-  if (do_peeling_for_loop_bound)\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+       || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n+       || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     vect_do_peeling_for_loop_bound (loop_vinfo, &ratio,\n \t\t\t\t    cond_expr, cond_expr_stmt_list);\n   else"}, {"sha": "095af937358848f4e400cf68d7a3bf17b5fae833", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68d56b57f736d362c066bc12d44ae76cbb2fb9f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d68d56b57f736d362c066bc12d44ae76cbb2fb9f", "patch": "@@ -807,7 +807,7 @@ extern LOC vect_loop_location;\n    in tree-vect-loop-manip.c.  */\n extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n-extern void vect_loop_versioning (loop_vec_info, bool, tree *, gimple_seq *);\n+extern void vect_loop_versioning (loop_vec_info);\n extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *,\n                                             tree, gimple_seq);\n extern void vect_do_peeling_for_alignment (loop_vec_info);"}]}