{"sha": "d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDViYTJlYWY3MDMyZjIzNGZkY2YxMWQ5Y2ZjNTEzY2U3YmUwYTI1NQ==", "commit": {"author": {"name": "Christoph Muellner", "email": "cmuellner@gcc.gnu.org", "date": "2021-05-10T12:39:03Z"}, "committer": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2021-06-02T21:01:35Z"}, "message": "REE: PR rtl-optimization/100264: Handle more PARALLEL SET expressions\n\nMove the check for register targets (i.e. REG_P ()) into the function\nget_sub_rtx () and change the restriction of REE to \"only one child of\na PARALLEL expression is a SET register expression\" (was \"only one child of\na PARALLEL expression is a SET expression\").\n\nThis allows to handle more PARALLEL SET expressions.\n\ngcc/ChangeLog:\n\tPR rtl-optimization/100264\n\t* ree.c (get_sub_rtx): Ignore SET expressions without register\n\tdestinations and remove assertion, as it is not valid anymore\n\twith this new behaviour.\n\t(merge_def_and_ext): Eliminate destination check for register\n\tas such SET expressions can't occur anymore.\n\t(combine_reaching_defs): Likewise.", "tree": {"sha": "7729bde85ac525d322da192cb4fa01dcad591bb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7729bde85ac525d322da192cb4fa01dcad591bb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255/comments", "author": {"login": "cmuellner", "id": 92810, "node_id": "MDQ6VXNlcjkyODEw", "avatar_url": "https://avatars.githubusercontent.com/u/92810?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cmuellner", "html_url": "https://github.com/cmuellner", "followers_url": "https://api.github.com/users/cmuellner/followers", "following_url": "https://api.github.com/users/cmuellner/following{/other_user}", "gists_url": "https://api.github.com/users/cmuellner/gists{/gist_id}", "starred_url": "https://api.github.com/users/cmuellner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cmuellner/subscriptions", "organizations_url": "https://api.github.com/users/cmuellner/orgs", "repos_url": "https://api.github.com/users/cmuellner/repos", "events_url": "https://api.github.com/users/cmuellner/events{/privacy}", "received_events_url": "https://api.github.com/users/cmuellner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50b1de860a58bf85b40a72219bc2fdfaf0dff355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b1de860a58bf85b40a72219bc2fdfaf0dff355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b1de860a58bf85b40a72219bc2fdfaf0dff355"}], "stats": {"total": 30, "additions": 14, "deletions": 16}, "files": [{"sha": "e31ca2fa1a8073c09b054602c2fa19cfe0cb23c4", "filename": "gcc/ree.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=d5ba2eaf7032f234fdcf11d9cfc513ce7be0a255", "patch": "@@ -658,10 +658,11 @@ make_defs_and_copies_lists (rtx_insn *extend_insn, const_rtx set_pat,\n   return ret;\n }\n \n-/* If DEF_INSN has single SET expression, possibly buried inside\n-   a PARALLEL, return the address of the SET expression, else\n-   return NULL.  This is similar to single_set, except that\n-   single_set allows multiple SETs when all but one is dead.  */\n+/* If DEF_INSN has single SET expression with a register\n+   destination, possibly buried inside a PARALLEL, return\n+   the address of the SET expression, else return NULL.\n+   This is similar to single_set, except that single_set\n+   allows multiple SETs when all but one is dead.  */\n static rtx *\n get_sub_rtx (rtx_insn *def_insn)\n {\n@@ -675,6 +676,8 @@ get_sub_rtx (rtx_insn *def_insn)\n           rtx s_expr = XVECEXP (PATTERN (def_insn), 0, i);\n           if (GET_CODE (s_expr) != SET)\n             continue;\n+\t  if (!REG_P (SET_DEST (s_expr)))\n+\t    continue;\n \n           if (sub_rtx == NULL)\n             sub_rtx = &XVECEXP (PATTERN (def_insn), 0, i);\n@@ -686,14 +689,12 @@ get_sub_rtx (rtx_insn *def_insn)\n         }\n     }\n   else if (code == SET)\n-    sub_rtx = &PATTERN (def_insn);\n-  else\n     {\n-      /* It is not a PARALLEL or a SET, what could it be ? */\n-      return NULL;\n+\trtx s_expr = PATTERN (def_insn);\n+\tif (REG_P (SET_DEST (s_expr)))\n+\t  sub_rtx = &PATTERN (def_insn);\n     }\n \n-  gcc_assert (sub_rtx != NULL);\n   return sub_rtx;\n }\n \n@@ -712,13 +713,12 @@ merge_def_and_ext (ext_cand *cand, rtx_insn *def_insn, ext_state *state)\n   if (sub_rtx == NULL)\n     return false;\n \n-  if (REG_P (SET_DEST (*sub_rtx))\n-      && (GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode\n+  if (GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode\n \t  || ((state->modified[INSN_UID (def_insn)].kind\n \t       == (cand->code == ZERO_EXTEND\n \t\t   ? EXT_MODIFIED_ZEXT : EXT_MODIFIED_SEXT))\n \t      && state->modified[INSN_UID (def_insn)].mode\n-\t\t == ext_src_mode)))\n+\t\t == ext_src_mode))\n     {\n       if (GET_MODE_UNIT_SIZE (GET_MODE (SET_DEST (*sub_rtx)))\n \t  >= GET_MODE_UNIT_SIZE (cand->mode))\n@@ -853,8 +853,7 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \t CAND->insn, then this transformation is not safe.  Note we have\n \t to test in the widened mode.  */\n       rtx *dest_sub_rtx = get_sub_rtx (def_insn);\n-      if (dest_sub_rtx == NULL\n-\t  || !REG_P (SET_DEST (*dest_sub_rtx)))\n+      if (dest_sub_rtx == NULL)\n \treturn false;\n \n       rtx tmp_reg = gen_rtx_REG (GET_MODE (SET_DEST (set)),\n@@ -947,8 +946,7 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \t    break;\n \n \t  rtx *dest_sub_rtx2 = get_sub_rtx (def_insn2);\n-\t  if (dest_sub_rtx2 == NULL\n-\t      || !REG_P (SET_DEST (*dest_sub_rtx2)))\n+\t  if (dest_sub_rtx2 == NULL)\n \t    break;\n \n \t  /* On RISC machines we must make sure that changing the mode of"}]}