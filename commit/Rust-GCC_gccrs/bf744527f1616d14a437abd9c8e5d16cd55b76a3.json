{"sha": "bf744527f1616d14a437abd9c8e5d16cd55b76a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY3NDQ1MjdmMTYxNmQxNGE0MzdhYmQ5YzhlNWQxNmNkNTViNzZhMw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-14T19:30:59Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-14T19:30:59Z"}, "message": "re PR rtl-optimization/38711 (ira should not be using df-lr except at -O1.)\n\n\tPR rtl-optimization/38711\n\t* df.h (df_get_live_out, df_get_live_in): Make static inline functions.\n\t* df-problems.c (df_get_live_out, df_get_live_in): Moved to df.h.\n\t* ira-lives.c (process_bb_node_lives): Use df_get_live_out instead of\n\tDF_LR_OUT.\n\t* ira-build.c (create_bb_allocnos): Likewise.\n\t(create_loop_allocnos): Likewise, and use df_get_live_in instead of\n\tDF_LR_IN.\n\t* ira-emit.c (generate_edge_moves): Likewise.\n\t(add_ranges_and_copies): Likewise.\n\t* ira-color.c (ira_loop_edge_freq): Use df_get_live_out instead of\n\tDF_LR_OUT, and df_get_live_in instead of DF_LR_IN.\n\t* ira.c (mark_elimination): Update DF_LR and DF_LIVE.\n\t(build_insn_chain): Use df_get_live_out instead of DF_LR_OUT.\n\t(do_reload): Remove the DF_LIVE problem for -O1.\n\nFrom-SVN: r192440", "tree": {"sha": "3654fdb428a81ff03c682364de4dd6c378669f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3654fdb428a81ff03c682364de4dd6c378669f51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf744527f1616d14a437abd9c8e5d16cd55b76a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf744527f1616d14a437abd9c8e5d16cd55b76a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf744527f1616d14a437abd9c8e5d16cd55b76a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf744527f1616d14a437abd9c8e5d16cd55b76a3/comments", "author": null, "committer": null, "parents": [{"sha": "6e74642b2c37305436269a8c036f1519b4c8c111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e74642b2c37305436269a8c036f1519b4c8c111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e74642b2c37305436269a8c036f1519b4c8c111"}], "stats": {"total": 162, "additions": 92, "deletions": 70}, "files": [{"sha": "2f72c5300d4664714cb8a4ceededb658a3ac1bd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -1,3 +1,22 @@\n+2012-10-14  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR rtl-optimization/38711\n+\t* df.h (df_get_live_out, df_get_live_in): Make static inline functions.\n+\t* df-problems.c (df_get_live_out, df_get_live_in): Moved to df.h.\n+\t* ira-lives.c (process_bb_node_lives): Use df_get_live_out instead of\n+\tDF_LR_OUT.\n+\t* ira-build.c (create_bb_allocnos): Likewise.\n+\t(create_loop_allocnos): Likewise, and use df_get_live_in instead of\n+\tDF_LR_IN.\n+\t* ira-emit.c (generate_edge_moves): Likewise.\n+\t(add_ranges_and_copies): Likewise.\n+\t* ira-color.c (ira_loop_edge_freq): Use df_get_live_out instead of\n+\tDF_LR_OUT, and df_get_live_in instead of DF_LR_IN.\n+\t* ira.c (mark_elimination): Update DF_LR and DF_LIVE.\n+\t(build_insn_chain): Use df_get_live_out instead of DF_LR_OUT.\n+\t(do_reload): Remove the DF_LIVE problem for -O1.\n+\n+\n 2012-10-14  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR rtl-optimization/54919"}, {"sha": "b4df2ba2a1493441b8b6d95e04bb393e080aada1", "filename": "gcc/df-problems.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -57,42 +57,6 @@ along with GCC; see the file COPYING3.  If not see\n static bitmap_head seen_in_block;\n static bitmap_head seen_in_insn;\n \n-\f\n-/*----------------------------------------------------------------------------\n-   Public functions access functions for the dataflow problems.\n-----------------------------------------------------------------------------*/\n-/* Get the live at out set for BB no matter what problem happens to be\n-   defined.  This function is used by the register allocators who\n-   choose different dataflow problems depending on the optimization\n-   level.  */\n-\n-bitmap\n-df_get_live_out (basic_block bb)\n-{\n-  gcc_assert (df_lr);\n-\n-  if (df_live)\n-    return DF_LIVE_OUT (bb);\n-  else\n-    return DF_LR_OUT (bb);\n-}\n-\n-/* Get the live at in set for BB no matter what problem happens to be\n-   defined.  This function is used by the register allocators who\n-   choose different dataflow problems depending on the optimization\n-   level.  */\n-\n-bitmap\n-df_get_live_in (basic_block bb)\n-{\n-  gcc_assert (df_lr);\n-\n-  if (df_live)\n-    return DF_LIVE_IN (bb);\n-  else\n-    return DF_LR_IN (bb);\n-}\n-\n /*----------------------------------------------------------------------------\n    Utility functions.\n ----------------------------------------------------------------------------*/"}, {"sha": "c0902b16d7a3017a9815eace4f41fe5c4a917ebd", "filename": "gcc/df.h", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -951,8 +951,6 @@ extern void debug_df_chain (struct df_link *);\n extern struct df_link *df_chain_create (df_ref, df_ref);\n extern void df_chain_unlink (df_ref);\n extern void df_chain_copy (df_ref, struct df_link *);\n-extern bitmap df_get_live_in (basic_block);\n-extern bitmap df_get_live_out (basic_block);\n extern void df_grow_bb_info (struct dataflow *);\n extern void df_chain_dump (struct df_link *, FILE *);\n extern void df_print_bb_index (basic_block bb, FILE *file);\n@@ -1023,7 +1021,10 @@ extern void df_compute_regs_ever_live (bool);\n extern bool df_read_modify_subreg_p (rtx);\n extern void df_scan_verify (void);\n \n-/* Get basic block info.  */\n+\f\n+/*----------------------------------------------------------------------------\n+   Public functions access functions for the dataflow problems.\n+----------------------------------------------------------------------------*/\n \n static inline struct df_scan_bb_info *\n df_scan_get_bb_info (unsigned int index)\n@@ -1079,6 +1080,39 @@ df_word_lr_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n+/* Get the live at out set for BB no matter what problem happens to be\n+   defined.  This function is used by the register allocators who\n+   choose different dataflow problems depending on the optimization\n+   level.  */\n+\n+static inline bitmap\n+df_get_live_out (basic_block bb)\n+{\n+  gcc_checking_assert (df_lr);\n+\n+  if (df_live)\n+    return DF_LIVE_OUT (bb);\n+  else\n+    return DF_LR_OUT (bb);\n+}\n+\n+/* Get the live at in set for BB no matter what problem happens to be\n+   defined.  This function is used by the register allocators who\n+   choose different dataflow problems depending on the optimization\n+   level.  */\n+\n+static inline bitmap\n+df_get_live_in (basic_block bb)\n+{\n+  gcc_checking_assert (df_lr);\n+\n+  if (df_live)\n+    return DF_LIVE_IN (bb);\n+  else\n+    return DF_LR_IN (bb);\n+}\n+\n+/* Get basic block info.  */\n /* Get the artificial defs for a basic block.  */\n \n static inline df_ref *"}, {"sha": "986bb5e5f621f013af208d84bdb773f629163dc2", "filename": "gcc/ira-build.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -1715,7 +1715,7 @@ create_bb_allocnos (ira_loop_tree_node_t bb_node)\n       create_insn_allocnos (PATTERN (insn), false);\n   /* It might be a allocno living through from one subloop to\n      another.  */\n-  EXECUTE_IF_SET_IN_REG_SET (DF_LR_IN (bb), FIRST_PSEUDO_REGISTER, i, bi)\n+  EXECUTE_IF_SET_IN_REG_SET (df_get_live_in (bb), FIRST_PSEUDO_REGISTER, i, bi)\n     if (ira_curr_regno_allocno_map[i] == NULL)\n       ira_create_allocno (i, false, ira_curr_loop_tree_node);\n }\n@@ -1731,9 +1731,9 @@ create_loop_allocnos (edge e)\n   bitmap_iterator bi;\n   ira_loop_tree_node_t parent;\n \n-  live_in_regs = DF_LR_IN (e->dest);\n+  live_in_regs = df_get_live_in (e->dest);\n   border_allocnos = ira_curr_loop_tree_node->border_allocnos;\n-  EXECUTE_IF_SET_IN_REG_SET (DF_LR_OUT (e->src),\n+  EXECUTE_IF_SET_IN_REG_SET (df_get_live_out (e->src),\n \t\t\t     FIRST_PSEUDO_REGISTER, i, bi)\n     if (bitmap_bit_p (live_in_regs, i))\n       {"}, {"sha": "bcf03216af85df523dfb1181d189e0e65d163e2b", "filename": "gcc/ira-color.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -2014,17 +2014,17 @@ ira_loop_edge_freq (ira_loop_tree_node_t loop_node, int regno, bool exit_p)\n       FOR_EACH_EDGE (e, ei, loop_node->loop->header->preds)\n \tif (e->src != loop_node->loop->latch\n \t    && (regno < 0\n-\t\t|| (bitmap_bit_p (DF_LR_OUT (e->src), regno)\n-\t\t    && bitmap_bit_p (DF_LR_IN (e->dest), regno))))\n+\t\t|| (bitmap_bit_p (df_get_live_out (e->src), regno)\n+\t\t    && bitmap_bit_p (df_get_live_in (e->dest), regno))))\n \t  freq += EDGE_FREQUENCY (e);\n     }\n   else\n     {\n       edges = get_loop_exit_edges (loop_node->loop);\n       FOR_EACH_VEC_ELT (edge, edges, i, e)\n \tif (regno < 0\n-\t    || (bitmap_bit_p (DF_LR_OUT (e->src), regno)\n-\t\t&& bitmap_bit_p (DF_LR_IN (e->dest), regno)))\n+\t    || (bitmap_bit_p (df_get_live_out (e->src), regno)\n+\t\t&& bitmap_bit_p (df_get_live_in (e->dest), regno)))\n \t  freq += EDGE_FREQUENCY (e);\n       VEC_free (edge, heap, edges);\n     }"}, {"sha": "b0d9a825124d4e6740930a5184f10494dafdf721", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -495,6 +495,7 @@ generate_edge_moves (edge e)\n   bitmap_iterator bi;\n   ira_allocno_t src_allocno, dest_allocno, *src_map, *dest_map;\n   move_t move;\n+  bitmap regs_live_in_dest, regs_live_out_src;\n \n   src_loop_node = IRA_BB_NODE (e->src)->parent;\n   dest_loop_node = IRA_BB_NODE (e->dest)->parent;\n@@ -503,9 +504,11 @@ generate_edge_moves (edge e)\n     return;\n   src_map = src_loop_node->regno_allocno_map;\n   dest_map = dest_loop_node->regno_allocno_map;\n-  EXECUTE_IF_SET_IN_REG_SET (DF_LR_IN (e->dest),\n+  regs_live_in_dest = df_get_live_in (e->dest);\n+  regs_live_out_src = df_get_live_out (e->src);\n+  EXECUTE_IF_SET_IN_REG_SET (regs_live_in_dest,\n \t\t\t     FIRST_PSEUDO_REGISTER, regno, bi)\n-    if (bitmap_bit_p (DF_LR_OUT (e->src), regno))\n+    if (bitmap_bit_p (regs_live_out_src, regno))\n       {\n \tsrc_allocno = src_map[regno];\n \tdest_allocno = dest_map[regno];\n@@ -1206,15 +1209,16 @@ add_ranges_and_copies (void)\n \t destination block) to use for searching allocnos by their\n \t regnos because of subsequent IR flattening.  */\n       node = IRA_BB_NODE (bb)->parent;\n-      bitmap_copy (live_through, DF_LR_IN (bb));\n+      bitmap_copy (live_through, df_get_live_in (bb));\n       add_range_and_copies_from_move_list\n \t(at_bb_start[bb->index], node, live_through, REG_FREQ_FROM_BB (bb));\n-      bitmap_copy (live_through, DF_LR_OUT (bb));\n+      bitmap_copy (live_through, df_get_live_out (bb));\n       add_range_and_copies_from_move_list\n \t(at_bb_end[bb->index], node, live_through, REG_FREQ_FROM_BB (bb));\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  bitmap_and (live_through, DF_LR_IN (e->dest), DF_LR_OUT (bb));\n+\t  bitmap_and (live_through,\n+\t\t      df_get_live_in (e->dest), df_get_live_out (bb));\n \t  add_range_and_copies_from_move_list\n \t    ((move_t) e->aux, node, live_through,\n \t     REG_FREQ_FROM_EDGE_FREQ (EDGE_FREQUENCY (e)));"}, {"sha": "940cd681f2a475ff9c0599490f5d6c81cb6793ae", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -1148,7 +1148,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  high_pressure_start_point[ira_pressure_classes[i]] = -1;\n \t}\n       curr_bb_node = loop_tree_node;\n-      reg_live_out = DF_LR_OUT (bb);\n+      reg_live_out = df_get_live_out (bb);\n       sparseset_clear (objects_live);\n       REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n       AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);"}, {"sha": "a79a0dcdff3d52dac1ccd675553e27405ead3482", "filename": "gcc/ira.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf744527f1616d14a437abd9c8e5d16cd55b76a3/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=bf744527f1616d14a437abd9c8e5d16cd55b76a3", "patch": "@@ -2337,16 +2337,23 @@ void\n mark_elimination (int from, int to)\n {\n   basic_block bb;\n+  bitmap r;\n \n   FOR_EACH_BB (bb)\n     {\n-      /* We don't use LIVE info in IRA.  */\n-      bitmap r = DF_LR_IN (bb);\n-\n-      if (REGNO_REG_SET_P (r, from))\n+      r = DF_LR_IN (bb);\n+      if (bitmap_bit_p (r, from))\n+\t{\n+\t  bitmap_clear_bit (r, from);\n+\t  bitmap_set_bit (r, to);\n+\t}\n+      if (! df_live)\n+        continue;\n+      r = DF_LIVE_IN (bb);\n+      if (bitmap_bit_p (r, from))\n \t{\n-\t  CLEAR_REGNO_REG_SET (r, from);\n-\t  SET_REGNO_REG_SET (r, to);\n+\t  bitmap_clear_bit (r, from);\n+\t  bitmap_set_bit (r, to);\n \t}\n     }\n }\n@@ -3194,10 +3201,12 @@ update_equiv_regs (void)\n     {\n       FOR_EACH_BB (bb)\n \t{\n-\t  bitmap_and_compl_into (DF_LIVE_IN (bb), cleared_regs);\n-\t  bitmap_and_compl_into (DF_LIVE_OUT (bb), cleared_regs);\n \t  bitmap_and_compl_into (DF_LR_IN (bb), cleared_regs);\n \t  bitmap_and_compl_into (DF_LR_OUT (bb), cleared_regs);\n+\t  if (! df_live)\n+\t    continue;\n+\t  bitmap_and_compl_into (DF_LIVE_IN (bb), cleared_regs);\n+\t  bitmap_and_compl_into (DF_LIVE_OUT (bb), cleared_regs);\n \t}\n \n       /* Last pass - adjust debug insns referencing cleared regs.  */\n@@ -3319,14 +3328,14 @@ build_insn_chain (void)\n       CLEAR_REG_SET (live_relevant_regs);\n       bitmap_clear (live_subregs_used);\n \n-      EXECUTE_IF_SET_IN_BITMAP (DF_LR_OUT (bb), 0, i, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb), 0, i, bi)\n \t{\n \t  if (i >= FIRST_PSEUDO_REGISTER)\n \t    break;\n \t  bitmap_set_bit (live_relevant_regs, i);\n \t}\n \n-      EXECUTE_IF_SET_IN_BITMAP (DF_LR_OUT (bb),\n+      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb),\n \t\t\t\tFIRST_PSEUDO_REGISTER, i, bi)\n \t{\n \t  if (pseudo_for_reload_consideration_p (i))\n@@ -4157,12 +4166,6 @@ ira (FILE *f)\n   setup_prohibited_mode_move_regs ();\n \n   df_note_add_problem ();\n-\n-  if (optimize == 1)\n-    {\n-      df_live_add_problem ();\n-      df_live_set_all_dirty ();\n-    }\n #ifdef ENABLE_CHECKING\n   df->changeable_flags |= DF_VERIFY_SCHEDULED;\n #endif\n@@ -4397,8 +4400,6 @@ do_reload (void)\n      df_rescan_all_insns is not going to help here because it does not\n      touch the artificial uses and defs.  */\n   df_finish_pass (true);\n-  if (optimize > 1)\n-    df_live_add_problem ();\n   df_scan_alloc (NULL);\n   df_scan_blocks ();\n "}]}