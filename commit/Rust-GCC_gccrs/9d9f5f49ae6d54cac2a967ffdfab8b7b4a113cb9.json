{"sha": "9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ5ZjVmNDlhZTZkNTRjYWMyYTk2N2ZmZGZhYjhiN2I0YTExM2NiOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-05T09:22:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-05T09:22:21Z"}, "message": "[multiple changes]\n\n2010-10-05  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch5.adb (Make_Field_Expr): Revert previous change (removed).\n\n2010-10-05  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-dect.adb, prj-nmsc.adb, prj-attr.adb, snames.ads-tmpl\n\t(Aggregate projects): added support for parsing aggregate projects.\n\tIn particular, check the presence and value of the new attributes\n\trelated to aggregate projects, ie Project_Files, Project_Path\n\tand External.\n\t(Check_Attribute_Allowed, Check_Package_Allowed,\n\tRename_Obsolescent_Attributes): new subprogram, extracting code\n\tfrom existing subprogram to keep their sizes smaller.\n\t(Check_Aggregate_Project, Check_Abstract_Project,\n\tCheck_Missing_Sources): new subprograms\n\t(Check): remove comments that duplicated either the name of the\n\tfollowing subprogram call, or the comment on that subprogram.\n\t* prj-part.adb (Check_Extending_All_Imports): New subprogram, extracted\n\tfrom Parse_Single_Project.\n\t(Check_Aggregate_Imports): new subprogram.\n\nFrom-SVN: r164968", "tree": {"sha": "5575696fde08e5ca04737aa1967877e45236e0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5575696fde08e5ca04737aa1967877e45236e0e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/comments", "author": null, "committer": null, "parents": [{"sha": "98ee5fc4773c6c7d7d58085d0443a0634b9af809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ee5fc4773c6c7d7d58085d0443a0634b9af809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ee5fc4773c6c7d7d58085d0443a0634b9af809"}], "stats": {"total": 995, "additions": 643, "deletions": 352}, "files": [{"sha": "c6a1af151b0f8f0e85231050ba5708ac1c456a2b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "patch": "@@ -1,3 +1,25 @@\n+2010-10-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch5.adb (Make_Field_Expr): Revert previous change (removed).\n+\n+2010-10-05  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-dect.adb, prj-nmsc.adb, prj-attr.adb, snames.ads-tmpl\n+\t(Aggregate projects): added support for parsing aggregate projects.\n+\tIn particular, check the presence and value of the new attributes\n+\trelated to aggregate projects, ie Project_Files, Project_Path\n+\tand External.\n+\t(Check_Attribute_Allowed, Check_Package_Allowed,\n+\tRename_Obsolescent_Attributes): new subprogram, extracting code\n+\tfrom existing subprogram to keep their sizes smaller.\n+\t(Check_Aggregate_Project, Check_Abstract_Project,\n+\tCheck_Missing_Sources): new subprograms\n+\t(Check): remove comments that duplicated either the name of the\n+\tfollowing subprogram call, or the comment on that subprogram.\n+\t* prj-part.adb (Check_Extending_All_Imports): New subprogram, extracted\n+\tfrom Parse_Single_Project.\n+\t(Check_Aggregate_Imports): new subprogram.\n+\n 2010-10-05  Vincent Celier  <celier@adacore.com>\n \n \t* make.adb (Check): When compiling with -gnatc, recompile if the ALI"}, {"sha": "60593b590c2e170e981d9d93d903fcc1e59ad756", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "patch": "@@ -1223,13 +1223,6 @@ package body Exp_Ch5 is\n          --  declaration for Typ. We need to use the actual entity because the\n          --  type may be private and resolution by identifier alone would fail.\n \n-         function Make_Field_Expr\n-           (Comp_Ent : Entity_Id;\n-            U_U      : Boolean) return Node_Id;\n-         --  Common processing for one component for Make_Component_List_Assign\n-         --  and Make_Field_Assign. Return the expression to be assigned for\n-         --  component Comp_Ent.\n-\n          function Make_Component_List_Assign\n            (CL  : Node_Id;\n             U_U : Boolean := False) return List_Id;\n@@ -1289,6 +1282,7 @@ package body Exp_Ch5 is\n             Alts   : List_Id;\n             DC     : Node_Id;\n             DCH    : List_Id;\n+            Expr   : Node_Id;\n             Result : List_Id;\n             V      : Node_Id;\n \n@@ -1314,9 +1308,28 @@ package body Exp_Ch5 is\n                   Next_Non_Pragma (V);\n                end loop;\n \n+               --  If we have an Unchecked_Union, use the value of the inferred\n+               --  discriminant of the variant part expression as the switch\n+               --  for the case statement. The case statement may later be\n+               --  folded.\n+\n+               if U_U then\n+                  Expr :=\n+                    New_Copy (Get_Discriminant_Value (\n+                      Entity (Name (VP)),\n+                      Etype (Rhs),\n+                      Discriminant_Constraint (Etype (Rhs))));\n+               else\n+                  Expr :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix => Duplicate_Subexpr (Rhs),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc, Chars (Name (VP))));\n+               end if;\n+\n                Append_To (Result,\n                  Make_Case_Statement (Loc,\n-                   Expression   => Make_Field_Expr (Entity (Name (VP)), U_U),\n+                   Expression => Expr,\n                    Alternatives => Alts));\n             end if;\n \n@@ -1332,19 +1345,32 @@ package body Exp_Ch5 is\n             U_U : Boolean := False) return Node_Id\n          is\n             A    : Node_Id;\n+            Expr : Node_Id;\n \n          begin\n             --  In the case of an Unchecked_Union, use the discriminant\n             --  constraint value as on the right hand side of the assignment.\n \n+            if U_U then\n+               Expr :=\n+                 New_Copy (Get_Discriminant_Value (C,\n+                   Etype (Rhs),\n+                   Discriminant_Constraint (Etype (Rhs))));\n+            else\n+               Expr :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix => Duplicate_Subexpr (Rhs),\n+                   Selector_Name => New_Occurrence_Of (C, Loc));\n+            end if;\n+\n             A :=\n               Make_Assignment_Statement (Loc,\n-                Name       =>\n+                Name =>\n                   Make_Selected_Component (Loc,\n-                    Prefix        => Duplicate_Subexpr (Lhs),\n+                    Prefix => Duplicate_Subexpr (Lhs),\n                     Selector_Name =>\n                       New_Occurrence_Of (Find_Component (L_Typ, C), Loc)),\n-                Expression => Make_Field_Expr (C, U_U));\n+                Expression => Expr);\n \n             --  Set Assignment_OK, so discriminants can be assigned\n \n@@ -1369,8 +1395,9 @@ package body Exp_Ch5 is\n             Result : List_Id;\n \n          begin\n-            Result := New_List;\n             Item := First (CI);\n+            Result := New_List;\n+\n             while Present (Item) loop\n \n                --  Look for components, but exclude _tag field assignment if\n@@ -1390,32 +1417,6 @@ package body Exp_Ch5 is\n             return Result;\n          end Make_Field_Assigns;\n \n-         ---------------------\n-         -- Make_Field_Expr --\n-         ---------------------\n-\n-         function Make_Field_Expr\n-           (Comp_Ent : Entity_Id;\n-            U_U      : Boolean) return Node_Id\n-         is\n-         begin\n-            --  If we have an Unchecked_Union, use the value of the inferred\n-            --  discriminant of the variant part expression.\n-\n-            if U_U then\n-               return\n-                 New_Copy (Get_Discriminant_Value\n-                   (Comp_Ent,\n-                    Etype (Rhs),\n-                    Discriminant_Constraint (Etype (Rhs))));\n-            else\n-               return\n-                 Make_Selected_Component (Loc,\n-                   Prefix        => Duplicate_Subexpr (Rhs),\n-                   Selector_Name => New_Occurrence_Of (Comp_Ent, Loc));\n-            end if;\n-         end Make_Field_Expr;\n-\n       --  Start of processing for Expand_Assign_Record\n \n       begin"}, {"sha": "86f5af1739d524fbbf1908388b356e6dc9b07368", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "patch": "@@ -91,6 +91,12 @@ package body Prj.Attr is\n    \"SVexcluded_source_list_file#\" &\n    \"LVinterfaces#\" &\n \n+   --  Projects (in aggregate projects)\n+\n+   \"LVproject_files#\" &\n+   \"LVproject_path#\" &\n+   \"SAexternal#\" &\n+\n    --  Libraries\n \n    \"SVlibrary_dir#\" &\n@@ -147,18 +153,20 @@ package body Prj.Attr is\n    \"Saruntime_source_dir#\" &\n \n    --  package Naming\n+   --  Some attributes are obsolescent, and renamed in the tree (see\n+   --  Prj.Dect.Rename_Obsolescent_Attributes).\n \n    \"Pnaming#\" &\n-   \"Saspecification_suffix#\" &\n+   \"Saspecification_suffix#\" &  --  Always renamed to \"spec_suffix\" in tree\n    \"Saspec_suffix#\" &\n-   \"Saimplementation_suffix#\" &\n+   \"Saimplementation_suffix#\" & --  Always renamed to \"body_suffix\" in tree\n    \"Sabody_suffix#\" &\n    \"SVseparate_suffix#\" &\n    \"SVcasing#\" &\n    \"SVdot_replacement#\" &\n-   \"sAspecification#\" &\n+   \"sAspecification#\" &  --  Always renamed to \"spec\" in project tree\n    \"sAspec#\" &\n-   \"sAimplementation#\" &\n+   \"sAimplementation#\" & --  Always renamed to \"body\" in project tree\n    \"sAbody#\" &\n    \"Laspecification_exceptions#\" &\n    \"Laimplementation_exceptions#\" &"}, {"sha": "cd4b2d163a7c29084d34d1870e97eda01b78b344", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 188, "deletions": 57, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "patch": "@@ -48,6 +48,31 @@ package body Prj.Dect is\n    --  a case construction (In_Case_Construction) or none of those two\n    --  (In_Project).\n \n+   procedure Rename_Obsolescent_Attributes\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Attribute       : Project_Node_Id;\n+      Current_Package : Project_Node_Id);\n+   --  Rename obsolescent attributes in the tree.\n+   --  When the attribute has been renamed since its initial introduction in\n+   --  the design of projects, we replace the old name in the tree with the\n+   --  new name, so that the code does not have to check both names forever.\n+\n+   procedure Check_Attribute_Allowed\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Project         : Project_Node_Id;\n+      Attribute       : Project_Node_Id;\n+      Flags           : Processing_Flags);\n+   --  Chech whether the attribute is valid in this project.\n+   --  In particular, depending on the type of project (qualifier), some\n+   --  attributes might be disabled.\n+\n+   procedure Check_Package_Allowed\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Project         : Project_Node_Id;\n+      Current_Package : Project_Node_Id;\n+      Flags           : Processing_Flags);\n+   --  Check whether the package is valid in this project\n+\n    procedure Parse_Attribute_Declaration\n      (In_Tree           : Project_Node_Tree_Ref;\n       Attribute         : out Project_Node_Id;\n@@ -147,6 +172,111 @@ package body Prj.Dect is\n         (Declarations, In_Tree, To => First_Declarative_Item);\n    end Parse;\n \n+   -----------------------------------\n+   -- Rename_Obsolescent_Attributes --\n+   -----------------------------------\n+\n+   procedure Rename_Obsolescent_Attributes\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Attribute       : Project_Node_Id;\n+      Current_Package : Project_Node_Id) is\n+   begin\n+      if Present (Current_Package)\n+        and then Expression_Kind_Of (Current_Package, In_Tree) /= Ignored\n+      then\n+         case Name_Of (Attribute, In_Tree) is\n+         when Snames.Name_Specification =>\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec);\n+\n+         when Snames.Name_Specification_Suffix =>\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec_Suffix);\n+\n+         when Snames.Name_Implementation =>\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body);\n+\n+         when Snames.Name_Implementation_Suffix =>\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body_Suffix);\n+\n+         when others =>\n+            null;\n+         end case;\n+      end if;\n+   end Rename_Obsolescent_Attributes;\n+\n+   ---------------------------\n+   -- Check_Package_Allowed --\n+   ---------------------------\n+\n+   procedure Check_Package_Allowed\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Project         : Project_Node_Id;\n+      Current_Package : Project_Node_Id;\n+      Flags           : Processing_Flags)\n+   is\n+      Qualif : constant Project_Qualifier :=\n+        Project_Qualifier_Of (Project, In_Tree);\n+      Name   : constant Name_Id := Name_Of (Current_Package, In_Tree);\n+   begin\n+      if Qualif = Aggregate\n+        and then Name /= Snames.Name_Builder\n+      then\n+         Error_Msg_Name_1 := Name;\n+         Error_Msg\n+           (Flags,\n+            \"package %% is forbidden in aggregate projects\",\n+            Location_Of (Current_Package, In_Tree));\n+      end if;\n+   end Check_Package_Allowed;\n+\n+   -----------------------------\n+   -- Check_Attribute_Allowed --\n+   -----------------------------\n+\n+   procedure Check_Attribute_Allowed\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Project         : Project_Node_Id;\n+      Attribute       : Project_Node_Id;\n+      Flags           : Processing_Flags)\n+   is\n+      Qualif : constant Project_Qualifier :=\n+        Project_Qualifier_Of (Project, In_Tree);\n+      Name   : constant Name_Id := Name_Of (Attribute, In_Tree);\n+   begin\n+      case Qualif is\n+         when Aggregate =>\n+            if Name = Snames.Name_Languages\n+              or else Name = Snames.Name_Source_Files\n+              or else Name = Snames.Name_Source_List_File\n+              or else Name = Snames.Name_Locally_Removed_Files\n+              or else Name = Snames.Name_Excluded_Source_Files\n+              or else Name = Snames.Name_Excluded_Source_List_File\n+              or else Name = Snames.Name_Interfaces\n+              or else Name = Snames.Name_Object_Dir\n+              or else Name = Snames.Name_Exec_Dir\n+              or else Name = Snames.Name_Source_Dirs\n+              or else Name = Snames.Name_Inherit_Source_Path\n+            then\n+               Error_Msg_Name_1 := Name;\n+               Error_Msg\n+                 (Flags,\n+                  \"%% is not valid in aggregate projects\",\n+                  Location_Of (Attribute, In_Tree));\n+            end if;\n+\n+         when others =>\n+            if Name = Snames.Name_Project_Files\n+              or else Name = Snames.Name_Project_Path\n+              or else Name = Snames.Name_External\n+            then\n+               Error_Msg_Name_1 := Name;\n+               Error_Msg\n+                 (Flags,\n+                  \"%% is only valid in aggregate projects\",\n+                  Location_Of (Attribute, In_Tree));\n+            end if;\n+      end case;\n+   end Check_Attribute_Allowed;\n+\n    ---------------------------------\n    -- Parse_Attribute_Declaration --\n    ---------------------------------\n@@ -165,37 +295,28 @@ package body Prj.Dect is\n       Attribute_Name         : Name_Id           := No_Name;\n       Optional_Index         : Boolean           := False;\n       Pkg_Id                 : Package_Node_Id   := Empty_Package;\n-      Ignore                 : Boolean           := False;\n-\n-   begin\n-      Attribute :=\n-        Default_Project_Node\n-          (Of_Kind => N_Attribute_Declaration, In_Tree => In_Tree);\n-      Set_Location_Of (Attribute, In_Tree, To => Token_Ptr);\n-      Set_Previous_Line_Node (Attribute);\n \n-      --  Scan past \"for\"\n+      procedure Process_Attribute_Name;\n+      --  Read the name of the attribute, and check its type\n \n-      Scan (In_Tree);\n-\n-      --  Body may be an attribute name\n+      procedure Process_Associative_Array_Index;\n+      --  Read the index of the associative array and check its validity\n \n-      if Token = Tok_Body then\n-         Token := Tok_Identifier;\n-         Token_Name := Snames.Name_Body;\n-      end if;\n+      ----------------------------\n+      -- Process_Attribute_Name --\n+      ----------------------------\n \n-      Expect (Tok_Identifier, \"identifier\");\n-\n-      if Token = Tok_Identifier then\n+      procedure Process_Attribute_Name is\n+         Ignore : Boolean;\n+      begin\n          Attribute_Name := Token_Name;\n-         Set_Name_Of (Attribute, In_Tree, To => Token_Name);\n+         Set_Name_Of (Attribute, In_Tree, To => Attribute_Name);\n          Set_Location_Of (Attribute, In_Tree, To => Token_Ptr);\n \n          --  Find the attribute\n \n          Current_Attribute :=\n-           Attribute_Node_Id_Of (Token_Name, First_Attribute);\n+           Attribute_Node_Id_Of (Attribute_Name, First_Attribute);\n \n          --  If the attribute cannot be found, create the attribute if inside\n          --  an unknown package.\n@@ -254,35 +375,22 @@ package body Prj.Dect is\n          end if;\n \n          Scan (In_Tree); --  past the attribute name\n-      end if;\n-\n-      --  Change obsolete names of attributes to the new names\n-\n-      if Present (Current_Package)\n-        and then Expression_Kind_Of (Current_Package, In_Tree) /= Ignored\n-      then\n-         case Name_Of (Attribute, In_Tree) is\n-         when Snames.Name_Specification =>\n-            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec);\n \n-         when Snames.Name_Specification_Suffix =>\n-            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec_Suffix);\n-\n-         when Snames.Name_Implementation =>\n-            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body);\n-\n-         when Snames.Name_Implementation_Suffix =>\n-            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body_Suffix);\n-\n-         when others =>\n-            null;\n-         end case;\n-      end if;\n+         --  Set the expression kind of the attribute\n \n-      --  Associative array attributes\n+         if Current_Attribute /= Empty_Attribute then\n+            Set_Expression_Kind_Of\n+              (Attribute, In_Tree, To => Variable_Kind_Of (Current_Attribute));\n+            Optional_Index := Optional_Index_Of (Current_Attribute);\n+         end if;\n+      end Process_Attribute_Name;\n \n-      if Token = Tok_Left_Paren then\n+      -------------------------------------\n+      -- Process_Associative_Array_Index --\n+      -------------------------------------\n \n+      procedure Process_Associative_Array_Index is\n+      begin\n          --  If the attribute is not an associative array attribute, report\n          --  an error. If this information is still unknown, set the kind\n          --  to Associative_Array.\n@@ -292,9 +400,8 @@ package body Prj.Dect is\n          then\n             Error_Msg (Flags,\n                        \"the attribute \"\"\" &\n-                       Get_Name_String\n-                          (Attribute_Name_Of (Current_Attribute)) &\n-                       \"\"\" cannot be an associative array\",\n+                       Get_Name_String (Attribute_Name_Of (Current_Attribute))\n+                       & \"\"\" cannot be an associative array\",\n                        Location_Of (Attribute, In_Tree));\n \n          elsif Attribute_Kind_Of (Current_Attribute) = Unknown then\n@@ -371,6 +478,35 @@ package body Prj.Dect is\n          if Token = Tok_Right_Paren then\n             Scan (In_Tree); --  past the right parenthesis\n          end if;\n+      end Process_Associative_Array_Index;\n+\n+   begin\n+      Attribute :=\n+        Default_Project_Node\n+          (Of_Kind => N_Attribute_Declaration, In_Tree => In_Tree);\n+      Set_Location_Of (Attribute, In_Tree, To => Token_Ptr);\n+      Set_Previous_Line_Node (Attribute);\n+\n+      --  Scan past \"for\"\n+\n+      Scan (In_Tree);\n+\n+      --  Body may be an attribute name\n+\n+      if Token = Tok_Body then\n+         Token := Tok_Identifier;\n+         Token_Name := Snames.Name_Body;\n+      end if;\n+\n+      Expect (Tok_Identifier, \"identifier\");\n+      Process_Attribute_Name;\n+      Rename_Obsolescent_Attributes (In_Tree, Attribute, Current_Package);\n+      Check_Attribute_Allowed (In_Tree, Current_Project, Attribute, Flags);\n+\n+      --  Associative array attributes\n+\n+      if Token = Tok_Left_Paren then\n+         Process_Associative_Array_Index;\n \n       else\n          --  If it is an associative array attribute and there are no left\n@@ -390,14 +526,6 @@ package body Prj.Dect is\n          end if;\n       end if;\n \n-      --  Set the expression kind of the attribute\n-\n-      if Current_Attribute /= Empty_Attribute then\n-         Set_Expression_Kind_Of\n-           (Attribute, In_Tree, To => Variable_Kind_Of (Current_Attribute));\n-         Optional_Index := Optional_Index_Of (Current_Attribute);\n-      end if;\n-\n       Expect (Tok_Use, \"USE\");\n \n       if Token = Tok_Use then\n@@ -1149,6 +1277,9 @@ package body Prj.Dect is\n          Scan (In_Tree);\n       end if;\n \n+      Check_Package_Allowed\n+        (In_Tree, Current_Project, Package_Declaration, Flags);\n+\n       if Token = Tok_Renames then\n          Renaming := True;\n       elsif Token = Tok_Extends then"}, {"sha": "b4c91e828ed9f6767276a8671c534ef3bbf5964f", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 159, "deletions": 125, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "patch": "@@ -282,6 +282,16 @@ package body Prj.Nmsc is\n    --  Check the library attributes of project Project in project tree\n    --  and modify its data Data accordingly.\n \n+   procedure Check_Aggregate_Project\n+     (Project : Project_Id;\n+      Data    : in out Tree_Processing_Data);\n+   --  Check aggregate projects attributes\n+\n+   procedure Check_Abstract_Project\n+     (Project : Project_Id;\n+      Data    : in out Tree_Processing_Data);\n+   --  Check abstract projects attributes\n+\n    procedure Check_Programming_Languages\n      (Project : Project_Id;\n       Data    : in out Tree_Processing_Data);\n@@ -432,9 +442,8 @@ package body Prj.Nmsc is\n      (Project : in out Project_Processing_Data;\n       Data    : in out Tree_Processing_Data);\n    --  Find all the sources of project Project in project tree Data.Tree and\n-   --  update its Data accordingly. This assumes that Data.First_Source has\n-   --  been initialized with the list of excluded sources and special naming\n-   --  exceptions.\n+   --  update its Data accordingly. This assumes that the special naming\n+   --  exceptions have already been processed.\n \n    function Path_Name_Of\n      (File_Name : File_Name_Type;\n@@ -854,6 +863,73 @@ package body Prj.Nmsc is\n       end if;\n    end Canonical_Case_File_Name;\n \n+   -----------------------------\n+   -- Check_Aggregate_Project --\n+   -----------------------------\n+\n+   procedure Check_Aggregate_Project\n+     (Project : Project_Id;\n+      Data    : in out Tree_Processing_Data)\n+   is\n+      Project_Files : constant Prj.Variable_Value :=\n+                        Prj.Util.Value_Of\n+                          (Snames.Name_Project_Files,\n+                           Project.Decl.Attributes,\n+                           Data.Tree);\n+   begin\n+      if Project_Files.Default then\n+         Error_Msg_Name_1 := Snames.Name_Project_Files;\n+         Error_Msg\n+           (Data.Flags,\n+            \"Attribute %% must be specified in aggregate project\",\n+            Project.Location, Project);\n+      end if;\n+   end Check_Aggregate_Project;\n+\n+   ----------------------------\n+   -- Check_Abstract_Project --\n+   ----------------------------\n+\n+   procedure Check_Abstract_Project\n+     (Project : Project_Id;\n+      Data    : in out Tree_Processing_Data)\n+   is\n+      Source_Dirs      : constant Variable_Value :=\n+                           Util.Value_Of\n+                             (Name_Source_Dirs,\n+                              Project.Decl.Attributes, Data.Tree);\n+      Source_Files     : constant Variable_Value :=\n+                           Util.Value_Of\n+                             (Name_Source_Files,\n+                              Project.Decl.Attributes, Data.Tree);\n+      Source_List_File : constant Variable_Value :=\n+                           Util.Value_Of\n+                             (Name_Source_List_File,\n+                              Project.Decl.Attributes, Data.Tree);\n+      Languages        : constant Variable_Value :=\n+                           Util.Value_Of\n+                             (Name_Languages,\n+                              Project.Decl.Attributes, Data.Tree);\n+\n+   begin\n+      if Project.Source_Dirs /= Nil_String then\n+         if Source_Dirs.Values  = Nil_String\n+           and then Source_Files.Values = Nil_String\n+           and then Languages.Values = Nil_String\n+           and then Source_List_File.Default\n+         then\n+            Project.Source_Dirs := Nil_String;\n+\n+         else\n+            Error_Msg\n+              (Data.Flags,\n+               \"at least one of Source_Files, Source_Dirs or Languages \"\n+               & \"must be declared empty for an abstract project\",\n+               Project.Location, Project);\n+         end if;\n+      end if;\n+   end Check_Abstract_Project;\n+\n    -----------\n    -- Check --\n    -----------\n@@ -862,152 +938,45 @@ package body Prj.Nmsc is\n      (Project : Project_Id;\n       Data    : in out Tree_Processing_Data)\n    is\n-      Extending : Boolean := False;\n       Prj_Data  : Project_Processing_Data;\n \n    begin\n       Initialize (Prj_Data, Project);\n \n-      Check_If_Externally_Built (Project, Data);\n-\n-      --  Object, exec and source directories\n-\n-      Get_Directories (Project, Data);\n-\n-      --  Get the programming languages\n-\n+      Check_If_Externally_Built   (Project, Data);\n+      Get_Directories             (Project, Data);\n       Check_Programming_Languages (Project, Data);\n \n-      if Project.Qualifier = Dry\n-        and then Project.Source_Dirs /= Nil_String\n-      then\n-         declare\n-            Source_Dirs      : constant Variable_Value :=\n-                                 Util.Value_Of\n-                                   (Name_Source_Dirs,\n-                                    Project.Decl.Attributes, Data.Tree);\n-            Source_Files     : constant Variable_Value :=\n-                                 Util.Value_Of\n-                                   (Name_Source_Files,\n-                                    Project.Decl.Attributes, Data.Tree);\n-            Source_List_File : constant Variable_Value :=\n-                                 Util.Value_Of\n-                                   (Name_Source_List_File,\n-                                    Project.Decl.Attributes, Data.Tree);\n-            Languages        : constant Variable_Value :=\n-                                 Util.Value_Of\n-                                   (Name_Languages,\n-                                    Project.Decl.Attributes, Data.Tree);\n-\n-         begin\n-            if Source_Dirs.Values  = Nil_String\n-              and then Source_Files.Values = Nil_String\n-              and then Languages.Values = Nil_String\n-              and then Source_List_File.Default\n-            then\n-               Project.Source_Dirs := Nil_String;\n-\n-            else\n-               Error_Msg\n-                 (Data.Flags,\n-                  \"at least one of Source_Files, Source_Dirs or Languages \"\n-                    & \"must be declared empty for an abstract project\",\n-                  Project.Location, Project);\n-            end if;\n-         end;\n-      end if;\n+      case Project.Qualifier is\n+         when Aggregate => Check_Aggregate_Project (Project, Data);\n+         when Dry       => Check_Abstract_Project  (Project, Data);\n+         when others    => null;\n+      end case;\n \n       --  Check configuration. This must be done even for gnatmake (even though\n       --  no user configuration file was provided) since the default config we\n       --  generate indicates whether libraries are supported for instance.\n \n       Check_Configuration (Project, Data);\n \n-      --  Library attributes\n-\n       Check_Library_Attributes (Project, Data);\n \n       if Current_Verbosity = High then\n          Show_Source_Dirs (Project, Data.Tree);\n       end if;\n \n-      Extending := Project.Extends /= No_Project;\n-\n       Check_Package_Naming (Project, Data);\n \n-      --  Find the sources\n-\n-      if Project.Source_Dirs /= Nil_String then\n+      if Project.Qualifier /= Aggregate then\n          Look_For_Sources (Prj_Data, Data);\n-\n-         if not Project.Externally_Built\n-           and then not Extending\n-         then\n-            declare\n-               Language     : Language_Ptr;\n-               Source       : Source_Id;\n-               Alt_Lang     : Language_List;\n-               Continuation : Boolean := False;\n-               Iter         : Source_Iterator;\n-\n-            begin\n-               Language := Project.Languages;\n-               while Language /= No_Language_Index loop\n-\n-                  --  If there are no sources for this language, check if there\n-                  --  are sources for which this is an alternate language.\n-\n-                  if Language.First_Source = No_Source\n-                    and then (Data.Flags.Require_Sources_Other_Lang\n-                               or else Language.Name = Name_Ada)\n-                  then\n-                     Iter := For_Each_Source (In_Tree => Data.Tree,\n-                                              Project => Project);\n-                     Source_Loop : loop\n-                        Source := Element (Iter);\n-                        exit Source_Loop when Source = No_Source\n-                          or else Source.Language = Language;\n-\n-                        Alt_Lang := Source.Alternate_Languages;\n-                        while Alt_Lang /= null loop\n-                           exit Source_Loop when Alt_Lang.Language = Language;\n-                           Alt_Lang := Alt_Lang.Next;\n-                        end loop;\n-\n-                        Next (Iter);\n-                     end loop Source_Loop;\n-\n-                     if Source = No_Source then\n-\n-                        Report_No_Sources\n-                          (Project,\n-                           Get_Name_String (Language.Display_Name),\n-                           Data,\n-                           Prj_Data.Source_List_File_Location,\n-                           Continuation);\n-                        Continuation := True;\n-                     end if;\n-                  end if;\n-\n-                  Language := Language.Next;\n-               end loop;\n-            end;\n-         end if;\n       end if;\n \n-      --  If a list of sources is specified in attribute Interfaces, set\n-      --  In_Interfaces only for the sources specified in the list.\n-\n       Check_Interfaces (Project, Data);\n \n-      --  If it is a library project file, check if it is a standalone library\n-\n       if Project.Library then\n          Check_Stand_Alone_Library (Project, Data);\n       end if;\n \n-      --  Put the list of Mains, if any, in the project data\n-\n       Get_Mains (Project, Data);\n \n       Free (Prj_Data);\n@@ -7242,6 +7211,68 @@ package body Prj.Nmsc is\n       procedure Mark_Excluded_Sources;\n       --  Mark as such the sources that are declared as excluded\n \n+      procedure Check_Missing_Sources;\n+      --  Check whether one of the languages has no sources, and report an\n+      --  error when appropriate\n+\n+      ---------------------------\n+      -- Check_Missing_Sources --\n+      ---------------------------\n+\n+      procedure Check_Missing_Sources is\n+         Extending    : constant Boolean :=\n+           Project.Project.Extends /= No_Project;\n+         Language     : Language_Ptr;\n+         Source       : Source_Id;\n+         Alt_Lang     : Language_List;\n+         Continuation : Boolean := False;\n+         Iter         : Source_Iterator;\n+      begin\n+         if not Project.Project.Externally_Built\n+           and then not Extending\n+         then\n+            Language := Project.Project.Languages;\n+            while Language /= No_Language_Index loop\n+\n+               --  If there are no sources for this language, check if there\n+               --  are sources for which this is an alternate language.\n+\n+               if Language.First_Source = No_Source\n+                 and then (Data.Flags.Require_Sources_Other_Lang\n+                           or else Language.Name = Name_Ada)\n+               then\n+                  Iter := For_Each_Source (In_Tree => Data.Tree,\n+                                           Project => Project.Project);\n+                  Source_Loop : loop\n+                     Source := Element (Iter);\n+                     exit Source_Loop when Source = No_Source\n+                       or else Source.Language = Language;\n+\n+                     Alt_Lang := Source.Alternate_Languages;\n+                     while Alt_Lang /= null loop\n+                        exit Source_Loop when Alt_Lang.Language = Language;\n+                        Alt_Lang := Alt_Lang.Next;\n+                     end loop;\n+\n+                     Next (Iter);\n+                  end loop Source_Loop;\n+\n+                  if Source = No_Source then\n+                     Report_No_Sources\n+                       (Project.Project,\n+                        Get_Name_String (Language.Display_Name),\n+                        Data,\n+                        Project.Source_List_File_Location,\n+                        Continuation);\n+                     Continuation := True;\n+                  end if;\n+               end if;\n+\n+               Language := Language.Next;\n+            end loop;\n+         end if;\n+      end Check_Missing_Sources;\n+\n       ------------------\n       -- Check_Object --\n       ------------------\n@@ -7416,13 +7447,16 @@ package body Prj.Nmsc is\n    --  Start of processing for Look_For_Sources\n \n    begin\n-      Find_Excluded_Sources (Project, Data);\n-\n-      if Project.Project.Languages /= No_Language_Index then\n-         Load_Naming_Exceptions (Project, Data);\n-         Find_Sources (Project, Data);\n-         Mark_Excluded_Sources;\n-         Check_Object_Files;\n+      if Project.Project.Source_Dirs /= Nil_String then\n+         Find_Excluded_Sources (Project, Data);\n+\n+         if Project.Project.Languages /= No_Language_Index then\n+            Load_Naming_Exceptions (Project, Data);\n+            Find_Sources (Project, Data);\n+            Mark_Excluded_Sources;\n+            Check_Object_Files;\n+            Check_Missing_Sources;\n+         end if;\n       end if;\n \n       Object_File_Names_Htable.Reset (Object_Files);"}, {"sha": "b10b5664573423f96aaaf6b4d24eadf60252955d", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 221, "deletions": 128, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "patch": "@@ -125,8 +125,37 @@ package body Prj.Part is\n       Key        => Name_Id,\n       Hash       => Hash,\n       Equal      => \"=\");\n+\n+   function Has_Circular_Dependencies\n+     (Flags               : Processing_Flags;\n+      Normed_Path_Name    : Path_Name_Type;\n+      Canonical_Path_Name : Path_Name_Type) return Boolean;\n+   --  Check for a circular dependency in the loaded project.\n+   --  Generates an error message in such a case.\n+\n+   procedure Read_Project_Qualifier\n+     (Flags              : Processing_Flags;\n+      In_Tree            : Project_Node_Tree_Ref;\n+      Is_Config_File     : Boolean;\n+      Qualifier_Location : out Source_Ptr;\n+      Project            : Project_Node_Id);\n+   --  Check if there is a qualifier before the reserved word \"project\"\n+\n    --  Hash table to cache project path to avoid looking for them on the path\n \n+   procedure Check_Extending_All_Imports\n+     (Flags : Processing_Flags;\n+      In_Tree : Project_Node_Tree_Ref;\n+      Project : Project_Node_Id);\n+   --  Check that a non extending-all project does not import an\n+   --  extending-all project.\n+\n+   procedure Check_Aggregate_Imports\n+     (Flags   : Processing_Flags;\n+      In_Tree : Project_Node_Tree_Ref;\n+      Project : Project_Node_Id);\n+   --  Check that an aggregate project only imports abstract projects\n+\n    procedure Create_Virtual_Extending_Project\n      (For_Project  : Project_Node_Id;\n       Main_Project : Project_Node_Id;\n@@ -916,6 +945,185 @@ package body Prj.Part is\n       end loop;\n    end Post_Parse_Context_Clause;\n \n+   ---------------------------------\n+   -- Check_Extending_All_Imports --\n+   ---------------------------------\n+\n+   procedure Check_Extending_All_Imports\n+     (Flags   : Processing_Flags;\n+      In_Tree : Project_Node_Tree_Ref;\n+      Project : Project_Node_Id)\n+   is\n+      With_Clause, Imported : Project_Node_Id;\n+   begin\n+      if not Is_Extending_All (Project, In_Tree) then\n+         With_Clause := First_With_Clause_Of (Project, In_Tree);\n+\n+         while Present (With_Clause) loop\n+            Imported := Project_Node_Of (With_Clause, In_Tree);\n+\n+            if Is_Extending_All (With_Clause, In_Tree) then\n+               Error_Msg_Name_1 := Name_Of (Imported, In_Tree);\n+               Error_Msg (Flags, \"cannot import extending-all project %%\",\n+                          Token_Ptr);\n+               exit;\n+            end if;\n+\n+            With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n+         end loop;\n+      end if;\n+   end Check_Extending_All_Imports;\n+\n+   -----------------------------\n+   -- Check_Aggregate_Imports --\n+   -----------------------------\n+\n+   procedure Check_Aggregate_Imports\n+     (Flags   : Processing_Flags;\n+      In_Tree : Project_Node_Tree_Ref;\n+      Project : Project_Node_Id)\n+   is\n+      With_Clause, Imported : Project_Node_Id;\n+   begin\n+      if Project_Qualifier_Of (Project, In_Tree) = Aggregate then\n+         With_Clause := First_With_Clause_Of (Project, In_Tree);\n+\n+         while Present (With_Clause) loop\n+            Imported := Project_Node_Of (With_Clause, In_Tree);\n+\n+            if Project_Qualifier_Of (Imported, In_Tree) /= Dry then\n+               Error_Msg_Name_1 := Name_Id (Path_Name_Of (Imported, In_Tree));\n+               Error_Msg (Flags, \"can only import abstract projects, not %%\",\n+                          Token_Ptr);\n+               exit;\n+            end if;\n+\n+            With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n+         end loop;\n+      end if;\n+   end Check_Aggregate_Imports;\n+\n+   ----------------------------\n+   -- Read_Project_Qualifier --\n+   ----------------------------\n+\n+   procedure Read_Project_Qualifier\n+     (Flags              : Processing_Flags;\n+      In_Tree            : Project_Node_Tree_Ref;\n+      Is_Config_File     : Boolean;\n+      Qualifier_Location : out Source_Ptr;\n+      Project            : Project_Node_Id)\n+   is\n+      Proj_Qualifier : Project_Qualifier := Unspecified;\n+   begin\n+      Qualifier_Location := Token_Ptr;\n+\n+      if Token = Tok_Abstract then\n+         Proj_Qualifier := Dry;\n+         Scan (In_Tree);\n+\n+      elsif Token = Tok_Identifier then\n+         case Token_Name is\n+            when Snames.Name_Standard =>\n+               Proj_Qualifier := Standard;\n+               Scan (In_Tree);\n+\n+            when Snames.Name_Aggregate =>\n+               Proj_Qualifier := Aggregate;\n+               Scan (In_Tree);\n+\n+               if Token = Tok_Identifier and then\n+                 Token_Name = Snames.Name_Library\n+               then\n+                  Proj_Qualifier := Aggregate_Library;\n+                  Scan (In_Tree);\n+               end if;\n+\n+            when Snames.Name_Library =>\n+               Proj_Qualifier := Library;\n+               Scan (In_Tree);\n+\n+            when Snames.Name_Configuration =>\n+               if not Is_Config_File then\n+                  Error_Msg\n+                    (Flags,\n+                     \"configuration projects cannot belong to a user\" &\n+                     \" project tree\",\n+                     Token_Ptr);\n+               end if;\n+\n+               Proj_Qualifier := Configuration;\n+               Scan (In_Tree);\n+\n+            when others =>\n+               null;\n+         end case;\n+      end if;\n+\n+      if Is_Config_File and then Proj_Qualifier = Unspecified then\n+\n+         --  Set the qualifier to Configuration, even if the token doesn't\n+         --  exist in the source file itself, so that we can differentiate\n+         --  project files and configuration files later on.\n+\n+         Proj_Qualifier := Configuration;\n+      end if;\n+\n+      if Proj_Qualifier /= Unspecified then\n+         if Is_Config_File\n+           and then Proj_Qualifier /= Configuration\n+         then\n+            Error_Msg (Flags,\n+                       \"a configuration project cannot be qualified except \" &\n+                       \"as configuration project\",\n+                       Qualifier_Location);\n+         end if;\n+\n+         Set_Project_Qualifier_Of (Project, In_Tree, Proj_Qualifier);\n+      end if;\n+   end Read_Project_Qualifier;\n+\n+   -------------------------------\n+   -- Has_Circular_Dependencies --\n+   -------------------------------\n+\n+   function Has_Circular_Dependencies\n+     (Flags               : Processing_Flags;\n+      Normed_Path_Name    : Path_Name_Type;\n+      Canonical_Path_Name : Path_Name_Type) return Boolean is\n+   begin\n+      for Index in reverse 1 .. Project_Stack.Last loop\n+         exit when Project_Stack.Table (Index).Limited_With;\n+\n+         if Canonical_Path_Name =\n+           Project_Stack.Table (Index).Canonical_Path_Name\n+         then\n+            Error_Msg (Flags, \"circular dependency detected\", Token_Ptr);\n+            Error_Msg_Name_1 := Name_Id (Normed_Path_Name);\n+            Error_Msg (Flags, \"\\  %% is imported by\", Token_Ptr);\n+\n+            for Current in reverse 1 .. Project_Stack.Last loop\n+               Error_Msg_Name_1 :=\n+                 Name_Id (Project_Stack.Table (Current).Path_Name);\n+\n+               if Project_Stack.Table (Current).Canonical_Path_Name /=\n+                 Canonical_Path_Name\n+               then\n+                  Error_Msg\n+                    (Flags, \"\\  %% which itself is imported by\", Token_Ptr);\n+\n+               else\n+                  Error_Msg (Flags, \"\\  %%\", Token_Ptr);\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            return True;\n+         end if;\n+      end loop;\n+      return False;\n+   end Has_Circular_Dependencies;\n+\n    --------------------------\n    -- Parse_Single_Project --\n    --------------------------\n@@ -962,7 +1170,6 @@ package body Prj.Part is\n \n       Project_Comment_State : Tree.Comment_State;\n \n-      Proj_Qualifier     : Project_Qualifier := Unspecified;\n       Qualifier_Location : Source_Ptr;\n \n    begin\n@@ -988,38 +1195,12 @@ package body Prj.Part is\n          Canonical_Path_Name := Name_Find;\n       end;\n \n-      --  Check for a circular dependency\n-\n-      for Index in reverse 1 .. Project_Stack.Last loop\n-         exit when Project_Stack.Table (Index).Limited_With;\n-\n-         if Canonical_Path_Name =\n-              Project_Stack.Table (Index).Canonical_Path_Name\n-         then\n-            Error_Msg (Flags, \"circular dependency detected\", Token_Ptr);\n-            Error_Msg_Name_1 := Name_Id (Normed_Path_Name);\n-            Error_Msg (Flags, \"\\  %% is imported by\", Token_Ptr);\n-\n-            for Current in reverse 1 .. Project_Stack.Last loop\n-               Error_Msg_Name_1 :=\n-                 Name_Id (Project_Stack.Table (Current).Path_Name);\n-\n-               if Project_Stack.Table (Current).Canonical_Path_Name /=\n-                    Canonical_Path_Name\n-               then\n-                  Error_Msg\n-                    (Flags, \"\\  %% which itself is imported by\", Token_Ptr);\n-\n-               else\n-                  Error_Msg (Flags, \"\\  %%\", Token_Ptr);\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            Project := Empty_Node;\n-            return;\n-         end if;\n-      end loop;\n+      if Has_Circular_Dependencies\n+        (Flags, Normed_Path_Name, Canonical_Path_Name)\n+      then\n+         Project := Empty_Node;\n+         return;\n+      end if;\n \n       --  Put the new path name on the stack\n \n@@ -1156,73 +1337,8 @@ package body Prj.Part is\n       Set_Directory_Of (Project, In_Tree, Project_Directory);\n       Set_Path_Name_Of (Project, In_Tree,  Normed_Path_Name);\n \n-      --  Check if there is a qualifier before the reserved word \"project\"\n-\n-      Qualifier_Location := Token_Ptr;\n-\n-      if Token = Tok_Abstract then\n-         Proj_Qualifier := Dry;\n-         Scan (In_Tree);\n-\n-      elsif Token = Tok_Identifier then\n-         case Token_Name is\n-            when Snames.Name_Standard =>\n-               Proj_Qualifier := Standard;\n-               Scan (In_Tree);\n-\n-            when Snames.Name_Aggregate =>\n-               Proj_Qualifier := Aggregate;\n-               Scan (In_Tree);\n-\n-               if Token = Tok_Identifier and then\n-                 Token_Name = Snames.Name_Library\n-               then\n-                  Proj_Qualifier := Aggregate_Library;\n-                  Scan (In_Tree);\n-               end if;\n-\n-            when Snames.Name_Library =>\n-               Proj_Qualifier := Library;\n-               Scan (In_Tree);\n-\n-            when Snames.Name_Configuration =>\n-               if not Is_Config_File then\n-                  Error_Msg\n-                    (Flags,\n-                     \"configuration projects cannot belong to a user\" &\n-                     \" project tree\",\n-                     Token_Ptr);\n-               end if;\n-\n-               Proj_Qualifier := Configuration;\n-               Scan (In_Tree);\n-\n-            when others =>\n-               null;\n-         end case;\n-      end if;\n-\n-      if Is_Config_File and then Proj_Qualifier = Unspecified then\n-\n-         --  Set the qualifier to Configuration, even if the token doesn't\n-         --  exist in the source file itself, so that we can differentiate\n-         --  project files and configuration files later on.\n-\n-         Proj_Qualifier := Configuration;\n-      end if;\n-\n-      if Proj_Qualifier /= Unspecified then\n-         if Is_Config_File\n-           and then Proj_Qualifier /= Configuration\n-         then\n-            Error_Msg (Flags,\n-                       \"a configuration project cannot be qualified except \" &\n-                       \"as configuration project\",\n-                       Qualifier_Location);\n-         end if;\n-\n-         Set_Project_Qualifier_Of (Project, In_Tree, Proj_Qualifier);\n-      end if;\n+      Read_Project_Qualifier\n+        (Flags, In_Tree, Is_Config_File, Qualifier_Location, Project);\n \n       Set_Location_Of (Project, In_Tree, Token_Ptr);\n \n@@ -1513,7 +1629,7 @@ package body Prj.Part is\n                      --  with sources, if it inherits sources from the project\n                      --  it extends.\n \n-                     if Proj_Qualifier = Dry and then\n+                     if Project_Qualifier_Of (Project, In_Tree) = Dry and then\n                        Project_Qualifier_Of (Extended_Project, In_Tree) /= Dry\n                      then\n                         Error_Msg\n@@ -1529,31 +1645,8 @@ package body Prj.Part is\n          end if;\n       end if;\n \n-      --  Check that a non extending-all project does not import an\n-      --  extending-all project.\n-\n-      if not Is_Extending_All (Project, In_Tree) then\n-         declare\n-            With_Clause : Project_Node_Id :=\n-                            First_With_Clause_Of (Project, In_Tree);\n-            Imported    : Project_Node_Id := Empty_Node;\n-\n-         begin\n-            With_Clause_Loop :\n-            while Present (With_Clause) loop\n-               Imported := Project_Node_Of (With_Clause, In_Tree);\n-\n-               if Is_Extending_All (With_Clause, In_Tree) then\n-                  Error_Msg_Name_1 := Name_Of (Imported, In_Tree);\n-                  Error_Msg (Flags, \"cannot import extending-all project %%\",\n-                             Token_Ptr);\n-                  exit With_Clause_Loop;\n-               end if;\n-\n-               With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n-            end loop With_Clause_Loop;\n-         end;\n-      end if;\n+      Check_Extending_All_Imports (Flags, In_Tree, Project);\n+      Check_Aggregate_Imports (Flags, In_Tree, Project);\n \n       --  Check that a project with a name including a dot either imports\n       --  or extends the project whose name precedes the last dot.\n@@ -1571,7 +1664,7 @@ package body Prj.Part is\n          Name_Len := Name_Len - 1;\n       end loop;\n \n-      --  If a dot was find, check if the parent project is imported\n+      --  If a dot was found, check if the parent project is imported\n       --  or extended.\n \n       if Name_Len > 0 then\n@@ -1728,7 +1821,7 @@ package body Prj.Part is\n                   Node           => Project,\n                   Canonical_Path => Canonical_Path_Name,\n                   Extended       => Extended,\n-                  Proj_Qualifier => Proj_Qualifier));\n+                  Proj_Qualifier => Project_Qualifier_Of (Project, In_Tree)));\n       end if;\n \n       declare"}, {"sha": "efba4c6fc3401e5b4beb19927a5c59cab44f0dfb", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "patch": "@@ -1133,6 +1133,8 @@ package Snames is\n    Name_Prefix                           : constant Name_Id := N + $;\n    Name_Project                          : constant Name_Id := N + $;\n    Name_Project_Dir                      : constant Name_Id := N + $;\n+   Name_Project_Files                    : constant Name_Id := N + $;\n+   Name_Project_Path                     : constant Name_Id := N + $;\n    Name_Response_File_Format             : constant Name_Id := N + $;\n    Name_Response_File_Switches           : constant Name_Id := N + $;\n    Name_Roots                            : constant Name_Id := N + $; --  GPR"}]}