{"sha": "13187a454dca9455422877ab1db31e92882c18f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMxODdhNDU0ZGNhOTQ1NTQyMjg3N2FiMWRiMzFlOTI4ODJjMThmNQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-01-16T07:55:26Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-01-16T07:55:26Z"}, "message": "C++STYLE (classname): Add more existing and stylish patterns.\n\n\n2001-01-16  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* docs/html/17_intro/C++STYLE (classname): Add more existing\n\tand stylish patterns.\n\n\tlibstdc++/944\n\t* include/bits/istream.tcc (istream::sentry::sentry()): Set\n\tfailbit if the state of the stream is not good.\n\t* testsuite/27_io/istream_sentry.cc (test02): Add test.\n\t* testsuite/27_io/istream_manip.cc (test01): Modify.\n\n\tlibstdc++/1019\n\treported by Paolo Carlini <pcarlini@unitus.it>\n\t* include/bits/istream.tcc (operator>>(istream&, string&)): Fix.\n\t* testsuite/21_strings/inserters_extractors.cc (test08): Add test.\n\n\tlibstdc++/1057\n\t* include/bits/std_streambuf.h (setp): Set _M_buf_size correctly.\n\t* include/bits/streambuf.tcc (xsputn): Remove outside if clause.\n\t(xsgetn): Same. Simplify.\n\t* testsuite/27_io/streambuf.cc (test04): Add testcases.\n\n\treported by Larry Evans <jcampbell3@prodigy.net>\n\t* include/bits/streambuf.tcc (streambuf::xsputn): Just check for\n\tequality with eof on returned value from overflow.\n\nFrom-SVN: r39059", "tree": {"sha": "bfe7d8a82d9aaf725040a4ca862242de45d5855a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe7d8a82d9aaf725040a4ca862242de45d5855a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13187a454dca9455422877ab1db31e92882c18f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13187a454dca9455422877ab1db31e92882c18f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13187a454dca9455422877ab1db31e92882c18f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13187a454dca9455422877ab1db31e92882c18f5/comments", "author": null, "committer": null, "parents": [{"sha": "6488ac06d9160469a65ac870225b4333461d4e44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6488ac06d9160469a65ac870225b4333461d4e44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6488ac06d9160469a65ac870225b4333461d4e44"}], "stats": {"total": 506, "additions": 344, "deletions": 162}, "files": [{"sha": "dc0461fcbd439838692fbd799db8129174fe95d7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,3 +1,29 @@\n+2001-01-16  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* docs/html/17_intro/C++STYLE (classname): Add more existing\n+\tand stylish patterns.\n+\n+\tlibstdc++/944\n+\t* include/bits/istream.tcc (istream::sentry::sentry()): Set\n+\tfailbit if the tate of the stream is not good.\n+\t* testsuite/27_io/istream_sentry.cc (test02): Add test.\n+\t* testsuite/27_io/istream_manip.cc (test01): Modify.\n+\n+\tlibstdc++/1019\n+\treported by Paolo Carlini <pcarlini@unitus.it>\n+\t* include/bits/istream.tcc (operator>>(istream&, string&)): Fix. \n+\t* testsuite/21_strings/inserters_extractors.cc (test08): Add test.\n+\n+\tlibstdc++/1057\n+\t* include/bits/std_streambuf.h (setp): Set _M_buf_size correctly.\n+\t* include/bits/streambuf.tcc (xsputn): Remove outside if clause.\n+\t(xsgetn): Same. Simplify.\n+\t* testsuite/27_io/streambuf.cc (test04): Add testcases.\n+\n+\treported by Larry Evans <jcampbell3@prodigy.net> \n+\t* include/bits/streambuf.tcc (streambuf::xsputn): Just check for\n+\tequality with eof on returned value from overflow.\n+\n 2001-01-14  Andreas Jaeger  <aj@suse.de>\n \n \t* libio/libio.h: Add test for glibc 2.0."}, {"sha": "5c010ed276ebb0416c82f6b2e8da0f38fe52086c", "filename": "libstdc++-v3/docs/html/17_intro/C++STYLE", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FC%2B%2BSTYLE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FC%2B%2BSTYLE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FC%2B%2BSTYLE?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,5 +1,5 @@\n \n-C++ Standard Library Style Guidelines  DRAFT 1999-02-26\n+C++ Standard Library Style Guidelines  DRAFT 2001-01-15\n -------------------------------------\n \n This library is written to appropriate C++ coding standards.  As such,\n@@ -99,8 +99,8 @@ Notable areas of divergence from what may be previous local practice\n 07. Member initialization lists\n    All one line, separate from class name.\n \n-  gribble::gribble()\n-  : _M_private_data(0), _M_more_stuff(0), _M_helper(0);\n+  gribble::gribble() :\n+  _M_private_data(0), _M_more_stuff(0), _M_helper(0);\n   { }\n   -NOT-\n   gribble::gribble() : _M_private_data(0), _M_more_stuff(0), _M_helper(0);\n@@ -148,15 +148,42 @@ Notable areas of divergence from what may be previous local practice\n \n \tReason: Koenig lookup.\n \n-11. constructor member intialization lists\n+11. Namespaces\n+  namespace std\n+  {\n+    blah blah blah;\n+  } // namespace std\n+\n+  -NOT-\n+\n+  namespace std {\n+    blah blah blah;\n+  } // namespace std\n+\n+12. Spacing under protected and private in class declarations:\n+   space above, none below\n+   ie\n+\n+   public:\n+     int foo;\n+\n+   -NOT-\n+   public:\n+   \n+     int foo;\n+\n+13. Spacing WRT return statements.\n+   no extra spacing before returns\n+   ie\n+\n+   }\n+   return __ret;\n+\n+   -NOT-\n+   }\n+\n+   return __ret;\n \n-  should look like this:\n-  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs) : \n-  __ctype_abstract_base<char>(__refs), _M_del(__table != 0 && __del), \n-  _M_toupper(__ctype_toupper), _M_tolower(__ctype_tolower),\n-  _M_ctable(static_cast<const mask*>(__ctype_b), \n-  _M_table(__table == 0 ? _M_ctable : __table) \n-  { }\n \n \n The library currently has a mixture of GNU-C and modern C++ coding\n@@ -264,8 +291,8 @@ namespace std\n   extern long long _G_global_with_a_good_long_name;  // avoid globals!\n # endif\n \n-  // avoid in-class inline definitions, define separately;\n-  //   likewise for member class definitions:\n+  // Avoid in-class inline definitions, define separately;\n+  // likewise for member class definitions:\n   inline int\n   gribble::public_member() const\n   { int __local = 0; return __local; }\n@@ -285,8 +312,8 @@ namespace std\n #endif /* _HEADER_ */\n \n \n-namespace std {\n-\n+namespace std \n+{\n   template<typename T>  // notice: \"typename\", not \"class\", no space\n     long_return_value_type<with_many, args>  \n     function_name(char* pointer,               // \"char *pointer\" is wrong.\n@@ -321,8 +348,8 @@ namespace std {\n   {\n     // doesn't fit in one line.\n   }\n+} // namespace std\n \n-}\n \n \n "}, {"sha": "f1ffda23eee6e955bd874aa3a2a2fc7fbd7382fc", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -41,39 +41,44 @@ namespace std\n     basic_filebuf<_CharT, _Traits>::\n     _M_filebuf_init()\n     {\n-      _M_buf_unified = true; // Tie input to output for basic_filebuf.\n-      _M_buf_size = _M_buf_size_opt;\n-      try {\n-\t_M_file = new __file_type(&_M_lock);\n-      }\n-      catch(...) {\n-\tdelete _M_file;\n-\tthrow;\n-      }\n-     }\n+      if (!_M_file)\n+\t{\n+\t  _M_buf_unified = true; // Tie input to output for basic_filebuf.\n+\t  try \n+\t    { _M_file = new __file_type(&_M_lock); }\n+\t  catch(...) \n+\t    {\n+\t      delete _M_file;\n+\t      throw;\n+\t    }\n+\t}\n+    }\n \n   template<typename _CharT, typename _Traits>\n     void\n     basic_filebuf<_CharT, _Traits>::\n     _M_allocate_buffers()\n     {\n-      // Allocate internal buffer.\n-      try {\n-\t_M_buf = new char_type[_M_buf_size];\n-      }\n-      catch(...) {\n-\tdelete [] _M_buf;\n-\tthrow;\n-      }\n-      \n-      // Allocate pback buffer.\n-      try {\n-\t_M_pback = new char_type[_M_pback_size];\n-      }\n-      catch(...) {\n-\tdelete [] _M_pback;\n-\tthrow;\n-      }\n+      if (!_M_buf)\n+\t{\n+\t  _M_buf_size = _M_buf_size_opt;\n+\t  // Allocate internal buffer.\n+\t  try { _M_buf = new char_type[_M_buf_size]; }\n+\t  catch(...) \n+\t    {\n+\t      delete [] _M_buf;\n+\t      throw;\n+\t    }\n+\t  \n+\t  // Allocate pback buffer.\n+\t  try \n+\t    { _M_pback = new char_type[_M_pback_size]; }\n+\t  catch(...) \n+\t    {\n+\t      delete [] _M_pback;\n+\t      throw;\n+\t    }\n+\t}\n     }\n \n   template<typename _CharT, typename _Traits>\n@@ -86,13 +91,13 @@ namespace std\n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::\n     basic_filebuf(int __fd, const char* /*__name*/, ios_base::openmode __mode)\n-    : __streambuf_type(), _M_state_cur(__state_type()), \n+    : __streambuf_type(),  _M_file(NULL), _M_state_cur(__state_type()), \n     _M_state_beg(__state_type()), _M_last_overflowed(false)\n     {\n       _M_fcvt = &use_facet<__codecvt_type>(this->getloc());\n       _M_filebuf_init();\n       _M_file->sys_open(__fd, __mode);\n-      if (this->is_open() && _M_buf_size)\n+      if (this->is_open())\n \t{\n \t  _M_allocate_buffers();\n \t  _M_mode = __mode;\n@@ -116,7 +121,7 @@ namespace std\n \t{\n \t  _M_filebuf_init();\n \t  _M_file->open(__s, __mode);\n-\t  if (this->is_open() && _M_buf_size)\n+\t  if (this->is_open())\n \t    {\n \t      _M_allocate_buffers();\n \t      _M_mode = __mode;\n@@ -157,13 +162,15 @@ namespace std\n #endif\n \n \t  _M_mode = ios_base::openmode(0);\n-\t  if (_M_buf_size)\n-\t    delete [] _M_buf;\n-\t  _M_buf = NULL;\n-\t  delete [] _M_pback;\n-\t  _M_pback = NULL;\n-\t  this->setg(NULL, NULL, NULL);\n-\t  this->setp(NULL, NULL);\n+\t  if (_M_buf)\n+\t    {\n+\t      delete [] _M_buf;\n+\t      _M_buf = NULL;\n+\t      delete [] _M_pback;\n+\t      _M_pback = NULL;\n+\t      this->setg(NULL, NULL, NULL);\n+\t      this->setp(NULL, NULL);\n+\t    }\n \t  __ret = this;\n \t}\n "}, {"sha": "c25790708ac18f6386a3bdacc70e24c067a0e756", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -66,7 +66,14 @@ namespace std {\n #endif\n \t    }\n \t}\n-      _M_ok = __in.good();\n+\n+      if (__in.good())\n+\t_M_ok = true;\n+      else\n+\t{\n+\t  _M_ok = false;\n+\t  __in.setstate(ios_base::failbit);\n+\t}\n     }\n \n   template<typename _CharT, typename _Traits>\n@@ -1123,7 +1130,7 @@ namespace std {\n \t  bool __testsp = __ctype->is(ctype_base::space, __c);\n \t  bool __testeof =  __c == __eof;\n \n-\t  while (__extracted <= __n && !__testeof && !__testsp)\n+\t  while (__extracted < __n && !__testeof && !__testsp)\n \t    {\n \t      __str += _Traits::to_char_type(__c);\n \t      ++__extracted;"}, {"sha": "5cf7b023f4c0588327a10d47f45cdd0485a73c5b", "filename": "libstdc++-v3/include/bits/std_streambuf.h", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,6 +1,6 @@\n // Stream buffer classes -*- C++ -*-\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -44,7 +44,7 @@ namespace std {\n \n   template<typename _CharT, typename _Traits>\n     static streamsize\n-    _S_copy_streambufs(basic_ios<_CharT, _Traits>& __ios,\n+    _S_copy_streambufs(basic_ios<_CharT, _Traits>& _ios,\n \t\t       basic_streambuf<_CharT, _Traits>* __sbin,\n \t\t       basic_streambuf<_CharT, _Traits>* __sbout);\n   \n@@ -83,7 +83,7 @@ namespace std {\n       // leave it NULL.\n       char_type*\t\t_M_buf; \t\n \n-      // Actual size of internal buffer, in bytes.\n+      // Actual size of allocated internal buffer, in bytes.\n       int_type\t\t\t_M_buf_size;\n \n       // Optimal or preferred size of internal buffer, in bytes.\n@@ -172,6 +172,17 @@ namespace std {\n \t  }\n       }\n \n+      // Correctly sets the _M_in_cur pointer, and bumps the\n+      // _M_out_cur pointer as well if necessary.\n+      void \n+      _M_in_cur_move(off_type __n) // argument needs to be +-\n+      {\n+\tbool __testout = _M_out_cur;\n+\t_M_in_cur += __n;\n+\tif (__testout && _M_buf_unified)\n+\t  _M_out_cur += __n;\n+      }\n+\n       // Correctly sets the _M_out_cur pointer, and bumps the\n       // appropriate _M_*_end pointers as well. Necessary for the\n       // un-tied stringbufs, in in|out mode.\n@@ -183,7 +194,7 @@ namespace std {\n       void \n       _M_out_cur_move(off_type __n) // argument needs to be +-\n       {\n-\tbool __testin = _M_mode & ios_base::in;\n+\tbool __testin = _M_in_cur;\n \n \t_M_out_cur += __n;\n \tif (__testin && _M_buf_unified)\n@@ -197,6 +208,25 @@ namespace std {\n \t  }\n       }\n \n+      // Return the size of the output buffer.  This depends on the\n+      // buffer in use: allocated buffers have a stored size in\n+      // _M_buf_size and setbuf() buffers don't.\n+      off_type\n+      _M_out_buf_size()\n+      {\n+\toff_type __ret = 0;\n+\tif (_M_out_cur)\n+\t  {\n+\t    // Using allocated buffer.\n+\t    if (_M_out_beg == _M_buf)\n+\t      __ret = _M_out_beg + _M_buf_size - _M_out_cur;\n+\t    // Using non-allocated buffer.\n+\t    else\n+\t      __ret = _M_out_end - _M_out_cur;\n+\t  }\n+\treturn __ret;\n+      }\n+\n       // These three functions are used to clarify internal buffer\n       // maintenance. After an overflow, or after a seekoff call that\n       // started at beg or end, or possibly when the stream becomes\n@@ -219,11 +249,7 @@ namespace std {\n \tbool __testin = _M_mode & ios_base::in;\n \tbool __testout = _M_mode & ios_base::out;\n \tif (__testin)\n-\t  {\n-\t    this->setg(_M_buf, _M_buf, _M_buf + __off);\n-\t    if (!__testout)\n-\t      _M_buf_size = static_cast<int_type>(__off);\n-\t  }\n+\t  this->setg(_M_buf, _M_buf, _M_buf + __off);\n \tif (__testout)\n \t  this->setp(_M_buf, _M_buf + __off);\n \n@@ -404,12 +430,6 @@ namespace std {\n \t_M_out_end = __pend; \n \tif (!(_M_mode & ios_base::out) && __pbeg && __pend)\n \t  _M_mode = _M_mode | ios_base::out;\n-\t// The output sequence is highly tied to _M_buf and\n-\t// _M_buf_size in addition to the actual pointers into the\n-\t// buffer. Because of this, (re)set _M_buf_size here, as\n-\t// sputc/xsputn need _M_buf_size to be accurate. (The\n-\t// corresponding input functions rely instead on _M_in_end.)\n-\t_M_buf_size = max(_M_buf_size, static_cast<int_type>(__pend - __pbeg));\n       }\n \n       // Virtual functions:\n@@ -460,7 +480,6 @@ namespace std {\n \tint_type __ret = traits_type::eof();\n \tbool __testeof = this->underflow() == __ret;\n \tbool __testpending = _M_in_cur && _M_in_cur < _M_in_end;\n-\t\n \tif (!__testeof && __testpending)\n \t  {\n \t    __ret = traits_type::to_int_type(*_M_in_cur);"}, {"sha": "8424e4610ab31f8a9ffb9239a63d2c976f6d5477", "filename": "libstdc++-v3/include/bits/streambuf.tcc", "status": "modified", "additions": 44, "deletions": 76, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,6 +1,6 @@\n // Stream buffer classes -*- C++ -*-\n \n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -45,9 +45,7 @@ namespace std {\n       if (_M_in_cur && _M_in_cur < _M_in_end)\n \t{\n \t  char_type __c = *gptr();\n-\t  ++_M_in_cur;\n-\t  if (_M_buf_unified &&  _M_mode & ios_base::out)\n-\t    ++_M_out_cur;\n+\t  _M_in_cur_move(1);\n \t  __ret = traits_type::to_int_type(__c);\n \t}\n       else \n@@ -67,9 +65,7 @@ namespace std {\n \t__ret = pbackfail(traits_type::to_int_type(__c));\n       else \n \t{\n-\t  --_M_in_cur;\n-\t  if (_M_buf_unified && _M_mode & ios_base::out)\n-\t    --_M_out_cur;\n+\t  _M_in_cur_move(-1);\n \t  __ret = traits_type::to_int_type(*this->gptr());\n \t}\n       return __ret;\n@@ -83,9 +79,7 @@ namespace std {\n       int_type __ret;\n       if (_M_in_cur && _M_in_beg < _M_in_cur)\n \t{\n-\t  --_M_in_cur;\n-\t  if (_M_buf_unified && _M_mode & ios_base::out)\n-\t    --_M_out_cur;\n+\t  _M_in_cur_move(-1);\n \t  __ret = traits_type::to_int_type(*_M_in_cur);\n \t}\n       else \n@@ -104,8 +98,7 @@ namespace std {\n     sputc(char_type __c)\n     {\n       int_type __ret;\n-\n-      if (_M_out_cur && _M_out_cur < _M_out_beg + _M_buf_size)\n+      if (_M_out_buf_size())\n \t{\n \t  *_M_out_cur = __c;\n \t  _M_out_cur_move(1);\n@@ -121,37 +114,27 @@ namespace std {\n     basic_streambuf<_CharT, _Traits>::\n     xsgetn(char_type* __s, streamsize __n)\n     {\n-      bool __testout = _M_mode & ios_base::out;\n       streamsize __ret = 0;\n-\n-      if (__n)\n+      while (__ret < __n)\n \t{\n-\t  while (__ret < __n)\n+\t  size_t __buf_len = _M_in_end - _M_in_cur;\n+\t  if (__buf_len > 0)\n \t    {\n-\t      if (_M_in_cur < _M_in_end)\n-\t\t{\n-\t\t  size_t __len;\n-\t\t  if (_M_in_cur + __n - __ret <= _M_in_end)\n-\t\t    __len = __n - __ret;\n-\t\t  else\n-\t\t    __len = _M_in_end - _M_in_cur;\n-\t\t  traits_type::copy(__s, _M_in_cur, __len);\n-\t\t  __ret += __len;\n-\t\t  __s += __len;\n-\t\t  _M_in_cur += __len;\n-\t\t  if (_M_buf_unified && __testout)\n-\t\t    _M_out_cur += __len;\n-\t\t}\n-\t      \n-\t      if (__ret != __n)\n-\t\t{\n-\t\t  int_type __c = this->uflow();  \n-\t\t  if (traits_type::eq_int_type(__c, traits_type::eof()))\n-                    break;\n-\n-\t\t  traits_type::assign(*__s++, traits_type::to_char_type(__c));\n-                  ++__ret;\n-\t\t}\n+\t      size_t __remaining = __n - __ret;\n+\t      size_t __len = min(__buf_len, __remaining);\n+\t      traits_type::copy(__s, _M_in_cur, __len);\n+\t      __ret += __len;\n+\t      __s += __len;\n+\t      _M_in_cur_move(__len);\n+\t    }\n+\t  \n+\t  if (__ret < __n)\n+\t    {\n+\t      int_type __c = this->uflow();  \n+\t      if (traits_type::eq_int_type(__c, traits_type::eof()))\n+\t\tbreak;\n+\t      traits_type::assign(*__s++, traits_type::to_char_type(__c));\n+\t      ++__ret;\n \t    }\n \t}\n       return __ret;\n@@ -168,44 +151,32 @@ namespace std {\n     xsputn(const char_type* __s, streamsize __n)\n     {\n       streamsize __ret = 0;\n-\n-      if (__n)\n+      while (__ret < __n)\n \t{\n-\t  while (__ret < __n)\n+\t  off_type __buf_len = _M_out_buf_size();\n+\t  if (__buf_len > 0)\n \t    {\n-\t      bool __testput = _M_out_cur < _M_out_beg + _M_buf_size;\n-\t      bool __testout = _M_mode & ios_base::out;\n-\t      if (!(__testput && __testout))\n-\t\t{\n-\t\t  int_type __c = traits_type::to_int_type(*__s);\n-\t\t  int_type __overfc = this->overflow(__c);\n-\t\t  if (traits_type::eq_int_type(__c, __overfc))\n-\t\t    {\n-\t\t      ++__ret;\n-\t\t      ++__s;\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\t      \n-\t      if (__ret != __n)\n-\t\t{\n-\t\t  size_t __len;\n-\t\t  if (_M_out_cur + __n - __ret <= _M_out_beg + _M_buf_size)\n-\t\t    __len = __n - __ret;\n-\t\t  else\n-\t\t    __len = _M_out_beg + _M_buf_size - _M_out_cur;\n-\t\t  traits_type::copy(_M_out_cur, __s, __len);\n-\t\t  __ret += __len;\n-\t\t  __s += __len;\n-\t\t  _M_out_cur_move(__len);\n-\t\t}\n+\t      off_type __remaining = __n - __ret;\n+\t      off_type __len = min(__buf_len, __remaining);\n+\t      traits_type::copy(_M_out_cur, __s, __len);\n+\t      __ret += __len;\n+\t      __s += __len;\n+\t      _M_out_cur_move(__len);\n+\t    }\n+\n+\t  if (__ret < __n)\n+\t    {\n+\t      int_type __c = traits_type::to_int_type(*__s);\n+\t      int_type __overfc = this->overflow(__c);\n+\t      if (traits_type::eq_int_type(__overfc, traits_type::eof()))\n+\t\tbreak;\n+\t      ++__ret;\n+\t      ++__s;\n \t    }\n \t}\n       return __ret;\n     }\n \n-\n   // Conceivably, this could be used to implement buffer-to-buffer\n   // copies, if this was ever desired in an un-ambiguous way by the\n   // standard. If so, then checks for __ios being zero would be\n@@ -221,16 +192,13 @@ namespace std {\n       streamsize __ret = 0;\n       streamsize __bufsize = __sbin->in_avail();\n       streamsize __xtrct;\n-      bool __testout = __sbin->_M_mode & ios_base::out;\n       bool __testput = __sbout->_M_mode & ios_base::out;\n       try {\n \twhile (__testput && __bufsize != -1)\n \t  {\n \t    __xtrct = __sbout->sputn(__sbin->gptr(), __bufsize);\n \t    __ret += __xtrct;\n-\t    __sbin->_M_in_cur += __xtrct;\n-\t    if (__testout && __sbin->_M_buf_unified)\n-\t      __sbin->_M_out_cur += __xtrct;\n+\t    __sbin->_M_in_cur_move(__xtrct);\n \t    if (__xtrct == __bufsize)\n \t      {\n \t\tint_type __c = __sbin->sgetc();\n@@ -251,11 +219,11 @@ namespace std {\n       }\n       return __ret;\n     }\n-\n } // namespace std\n \n #endif // _CPP_BITS_STREAMBUF_TCC\n \n \n \n \n+"}, {"sha": "733278288a1b488a4f0f7101e8883fd218521e05", "filename": "libstdc++-v3/testsuite/21_strings/inserters_extractors.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finserters_extractors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finserters_extractors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finserters_extractors.cc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,6 +1,6 @@\n // 1999-07-01 bkoz\n \n-// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,6 +29,7 @@\n #include <sstream>\n #include <fstream>\n #include <iostream>\n+#include <iomanip>\n #include <debug_assert.h>\n \n bool test01(void)\n@@ -287,6 +288,23 @@ void test07(void)\n #endif\n }\n \n+// libstdc++/1019\n+void test08()\n+{\n+  using namespace std;\n+\n+  bool \t\ttest = true;\n+  istringstream istrm(\"enero:2001\");\n+  int \t\tyear;\n+  char \t\tsep;\n+  string \tmonth;\n+  \n+  istrm >> setw(5) >> month >> sep >> year;\n+  VERIFY( month.size() == 5 );\n+  VERIFY( sep == ':' );\n+  VERIFY( year == 2001 );\n+}\n+\n int main()\n { \n   test01();\n@@ -302,6 +320,7 @@ int main()\n   test06();\n   test07();\n \n+  test08();\n   return 0;\n }\n "}, {"sha": "ba3826c79bb2d13baeb848a9455aad6e30dc48ae", "filename": "libstdc++-v3/testsuite/27_io/istream_manip.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_manip.cc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,6 +1,6 @@\n // 1999-07-22 bkoz\n \n-// Copyright (C) 1994, 1999 Free Software Foundation, Inc.\n+// Copyright (C) 1994, 1999, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -70,7 +70,7 @@ bool test01(void)\n   VERIFY( !iss02.eof() );\n \n   iss01 >> std::ws;\n-  VERIFY( !iss01.fail() );\n+  VERIFY( iss01.fail() );\n   VERIFY( iss01.eof() );\n \n #ifdef DEBUG_ASSERT"}, {"sha": "cf4a1bb809960b7befa55a88caf8c25e8acf9fc0", "filename": "libstdc++-v3/testsuite/27_io/istream_sentry.cc", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_sentry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_sentry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_sentry.cc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,6 +1,6 @@\n // 1999-10-14 bkoz\n \n-// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -57,16 +57,30 @@ void test01()\n \n   std::istream::sentry sentry04(istr02, true);\n   VERIFY( bool(sentry04) == true ); \n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n }\n \n-\n-int main() {\n-  \n+// libstdc++/944\n+void \n+test02()\n+{\n+  using namespace std;\n+  istringstream in(\"80.21 56.89 12.3\");\n+  bool  test = true;\n+  int i = 0;\n+  double x;\n+\n+  // ios_base::eof == 2\n+  while(in >> x)\n+    {\n+      ++i;\n+    }\n+  VERIFY( i == 3 );\n+}    \n+\n+int main() \n+{\n   test01();\n+  test02();\n   return 0;\n }\n "}, {"sha": "76464d73ffa5e8d323a0de8dff5d45009e18d043", "filename": "libstdc++-v3/testsuite/27_io/istream_unformatted.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_unformatted.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_unformatted.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_unformatted.cc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,6 +1,6 @@\n // 1999-08-11 bkoz\n \n-// Copyright (C) 1999, 2000 Free Software Foundation\n+// Copyright (C) 1999, 2000, 2001 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -103,7 +103,7 @@ test01()\n   VERIFY( is_04.peek() == traits_type::eof() );\n   VERIFY( is_04.gcount() == 0 );\n   state2 = is_04.rdstate();\n-  VERIFY( state1 == state2 );\n+  VERIFY( state1 != state2 );\n \n \n   // istream& putback(char c)"}, {"sha": "4aaa8958408ec0ca5401d0228e1d81758c5c8c65", "filename": "libstdc++-v3/testsuite/27_io/streambuf.cc", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13187a454dca9455422877ab1db31e92882c18f5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc?ref=13187a454dca9455422877ab1db31e92882c18f5", "patch": "@@ -1,6 +1,6 @@\n // 1999-10-11 bkoz\n \n-// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,6 +31,7 @@\n \n #include <cstring> // for memset, memcmp\n #include <streambuf>\n+#include <string>\n #include <ostream>\n #include <debug_assert.h>\n \n@@ -232,13 +233,107 @@ void test03()\n #endif\n }\n \n+class setpbuf : public std::streambuf\n+{\n+  char \t\tbuffer[4];\n+  std::string \tresult;\n+\n+public:\n+\n+  std::string&\n+  get_result()\n+  { return result; }\n+\n+  setpbuf()\n+  {\n+    char foo [32];\n+    setp(foo, foo + 32);\n+    setp(buffer, buffer + 4);\n+  }\n+\n+  ~setpbuf()\n+  { sync(); }\n+\n+  virtual int_type \n+  overflow(int_type n)\n+  {\n+    if (sync() != 0)\n+      return traits_type::eof();\n+    \n+    result += traits_type::to_char_type(n);\n+    \n+    return n;\n+  }\n+  \n+  virtual int \n+  sync()\n+  {\n+    result.append(pbase(), pptr());\n+    setp(buffer, buffer + 4);\n+    return 0;\n+  }\n+};\n+\n+// libstdc++/1057\n+void test04()\n+{\n+  bool test = true;\n+  std::string text = \"abcdefghijklmn\";\n+  \n+  // 01\n+  setpbuf sp1;\n+  // Here xsputn writes over sp1.result\n+  sp1.sputn(text.c_str(), text.length());\n+\n+  // This crashes when result is accessed\n+  sp1.pubsync();\n+  VERIFY( sp1.get_result() == text );\n+  \n+\n+  // 02\n+  setpbuf sp2;\n+  for (std::string::size_type i = 0; i < text.length(); ++i)\n+    {\n+      // sputc also writes over result\n+      sp2.sputc(text[i]);\n+    }\n+  \n+  // Crash here\n+  sp2.pubsync();\n+  VERIFY( sp2.get_result() == text );\n+}\n+\n+class nullsetpbuf : public std::streambuf\n+{\n+  char foo[64];\n+public:\n+  nullsetpbuf()\n+  {\n+    setp(foo, foo + 64);\n+    setp(NULL, NULL);\n+  }\n+};\n+\n+// libstdc++/1057\n+void test05()\n+{\n+    std::string text1 = \"abcdefghijklmn\";\n+\n+    nullsetpbuf nsp;\n+    // Immediate crash as xsputn writes to null pointer\n+    nsp.sputn(text1.c_str(), text1.length());\n+    // ditto\n+    nsp.sputc('a');\n+}\n \n int main() \n {\n   test01();\n   test02();\n   test03();\n \n+  test04();\n+  test05();\n   return 0;\n }\n "}]}