{"sha": "7984a2f04bb29eff5850be9f99c2ef0f879c862a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk4NGEyZjA0YmIyOWVmZjU4NTBiZTlmOTljMmVmMGY4NzljODYyYQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-28T19:48:02Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-28T19:48:02Z"}, "message": "re PR libfortran/17195 (Infinite loop in output_float in libgfortran/io/write.c)\n\n\tPR libfortran/17195\n\t* libgfortran.h (rtoa): Remove prototype.\n\t* runtime/error.c (rtoa): Remove.\n\t* io/write.c (calculate_G_format): Don't add blanks if E format is\n\tused.  Add correct number of blanks when exponent width is specified.\n\t(output_float): Rewrite.\ntestsuite/\n\t* gfortran.dg/edit_real_1.f90: New test.\n\nFrom-SVN: r86701", "tree": {"sha": "0371510fa89dbbdbb79289c112c2ac3536729a99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0371510fa89dbbdbb79289c112c2ac3536729a99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7984a2f04bb29eff5850be9f99c2ef0f879c862a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7984a2f04bb29eff5850be9f99c2ef0f879c862a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7984a2f04bb29eff5850be9f99c2ef0f879c862a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7984a2f04bb29eff5850be9f99c2ef0f879c862a/comments", "author": null, "committer": null, "parents": [{"sha": "39b8ce7f98a09a10142cfb3dd9bfe4636dd86d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39b8ce7f98a09a10142cfb3dd9bfe4636dd86d3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39b8ce7f98a09a10142cfb3dd9bfe4636dd86d3d"}], "stats": {"total": 645, "additions": 395, "deletions": 250}, "files": [{"sha": "beb4aa114a38954471d86efa370f7ee4bd9c63f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984a2f04bb29eff5850be9f99c2ef0f879c862a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984a2f04bb29eff5850be9f99c2ef0f879c862a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7984a2f04bb29eff5850be9f99c2ef0f879c862a", "patch": "@@ -1,3 +1,8 @@\n+2004-08-28  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR libfortran/17195\n+\t* gfortran.dg/edit_real_1.f90: New test.\n+\n 2004-08-27  Paul Brook  <paul@codesourcery.com>\n \n \t* gfortran.dg/rewind_1.f90: New test."}, {"sha": "3ecd4ff1a3a1690c0376d10621407dc73b60ada5", "filename": "gcc/testsuite/gfortran.dg/edit_real_1.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984a2f04bb29eff5850be9f99c2ef0f879c862a/gcc%2Ftestsuite%2Fgfortran.dg%2Fedit_real_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984a2f04bb29eff5850be9f99c2ef0f879c862a/gcc%2Ftestsuite%2Fgfortran.dg%2Fedit_real_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fedit_real_1.f90?ref=7984a2f04bb29eff5850be9f99c2ef0f879c862a", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! Check real value edit descriptors\n+! Also checks that rounding is performed correctly\n+program edit_real_1\n+  character(len=20) s\n+  character(len=20) x\n+  character(len=200) t\n+  parameter (x = \"xxxxxxxxxxxxxxxxxxxx\")\n+\n+  ! W append a \"z\" onto each test to check the field is the correct width\n+  s = x\n+  ! G -> F format\n+  write (s, '(G10.3,A)') 12.36, \"z\"\n+  if (s .ne. \"  12.4    z\") call abort\n+  s = x\n+  ! G -> E format\n+  write (s, '(G10.3,A)') -0.0012346, \"z\"\n+  if (s .ne. \"-0.123E-02z\") call abort\n+  s = x\n+  ! Gw.eEe format\n+  write (s, '(G10.3e1,a)') 12.34, \"z\"\n+  if (s .ne. \"   12.3   z\") call abort\n+  ! E format with excessive precision\n+  write (t, '(E199.192,A)') 1.5, \"z\"\n+  if ((t(1:7) .ne. \" 0.1500\") .or. (t(194:200) .ne. \"00E+01z\")) call abort\n+  ! EN format\n+  s = x\n+  write (s, '(EN15.3,A)') 12873.6, \"z\"\n+  if (s .ne. \"     12.874E+03z\") call abort\n+  ! EN format, negative exponent\n+  s = x\n+  write (s, '(EN15.3,A)') 12.345e-6, \"z\"\n+  if (s .ne. \"     12.345E-06z\") call abort\n+  ! ES format\n+  s = x\n+  write (s, '(ES10.3,A)') 16.235, \"z\"\n+  if (s .ne. \" 1.624E+01z\") call abort\n+  ! F format, small number\n+  s = x\n+  write (s, '(F10.8,A)') 1.0e-20, \"z\"\n+  if (s .ne. \"0.00000000z\") call abort\n+  ! E format, very large number.\n+  ! Used to overflow with positive scale factor\n+  s = x\n+  write (s, '(1PE10.3,A)') huge(0d0), \"z\"\n+  ! The actual value is target specific, so just do a basic check\n+  if ((s(1:1) .eq. \"*\") .or. (s(7:7) .ne. \"+\") .or. &\n+      (s(11:11) .ne. \"z\")) call abort\n+  ! F format, round up with carry to most significant digit.\n+  s = x\n+  write (s, '(F10.3,A)') 0.9999, \"z\"\n+  if (s .ne. \"     1.000z\") call abort\n+  ! F format, round up with carry to most significant digit < 0.1.\n+  s = x\n+  write (s, '(F10.3,A)') 0.0099, \"z\"\n+  if (s .ne. \"     0.010z\") call abort\n+  ! E format, round up with carry to most significant digit.\n+  s = x\n+  write (s, '(E10.3,A)') 0.9999, \"z\"\n+  if (s .ne. \" 0.100E+01z\") call abort\n+  ! EN format, round up with carry to most significant digit.\n+  s = x\n+  write (s, '(EN15.3,A)') 999.9999, \"z\"\n+  if (s .ne. \"      1.000E+03z\") call abort\n+end\n+"}, {"sha": "765016922c9580a793a15f3dc8ed320656bd42e2", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=7984a2f04bb29eff5850be9f99c2ef0f879c862a", "patch": "@@ -1,3 +1,12 @@\n+2004-08-28  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR libfortran/17195\n+\t* libgfortran.h (rtoa): Remove prototype.\n+\t* runtime/error.c (rtoa): Remove.\n+\t* io/write.c (calculate_G_format): Don't add blanks if E format is\n+\tused.  Add correct number of blanks when exponent width is specified.\n+\t(output_float): Rewrite.\n+\n 2004-08-27  Paul Brook  <paul@codesourcery.com>\n \n \t* io/rewind.c (st_rewind): Reset unit to read mode."}, {"sha": "152754f184feaeab9a185836e8de714bbe41573b", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 315, "deletions": 191, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=7984a2f04bb29eff5850be9f99c2ef0f879c862a", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"libgfortran.h\"\n #include \"io.h\"\n #include <stdio.h>\n+#include <stdlib.h>\n \n \n #define star_fill(p, n) memset(p, '*', n)\n@@ -150,7 +151,7 @@ calculate_exp (int d)\n \n \n /* Generate corresponding I/O format for FMT_G output.\n-   The rules to translate FMT_G to FMT_E or FNT_F from DEC fortran\n+   The rules to translate FMT_G to FMT_E or FMT_F from DEC fortran\n    LRM (table 11-2, Chapter 11, \"I/O Formatting\", P11-25) is:\n \n    Data Magnitude                              Equivalent Conversion\n@@ -192,7 +193,7 @@ calculate_G_format (fnode *f, double value, int len, int *num_blank)\n       newf->u.real.w = w;\n       newf->u.real.d = d;\n       newf->u.real.e = e;\n-      *num_blank = e + 2;\n+      *num_blank = 0;\n       return newf;\n     }\n \n@@ -232,18 +233,22 @@ calculate_G_format (fnode *f, double value, int len, int *num_blank)\n         break;\n     }\n \n-  /* Generate the F editing. F(w-4).(-(mid-d-1)), 4' '.  */\n+  /* Pad with blanks where the exponent would be.  */\n+  if (e < 0)\n+    *num_blank = 4;\n+  else\n+    *num_blank = e + 2;\n+\n+  /* Generate the F editing. F(w-n).(-(mid-d-1)), n' '.  */\n   newf->format = FMT_F;\n-  newf->u.real.w = f->u.real.w - 4;\n+  newf->u.real.w = f->u.real.w - *num_blank;\n \n   /* Special case.  */\n   if (m == 0.0)\n     newf->u.real.d = d - 1;\n   else\n     newf->u.real.d = - (mid - d - 1);\n \n-  *num_blank = 4;\n-\n   /* For F editing, the scale factor is ignored.  */\n   g.scale_factor = 0;\n   return newf;\n@@ -255,229 +260,348 @@ calculate_G_format (fnode *f, double value, int len, int *num_blank)\n static void\n output_float (fnode *f, double value, int len)\n {\n-  int w, d, e, e_new;\n-  int digits;\n-  int nsign, nblank, nesign;\n-  int sca, neval, itmp;\n-  char *p;\n-  const char *q, *intstr, *base;\n-  double n;\n+  /* This must be large enough to accurately hold any value.  */ \n+  char buffer[32];\n+  char *out;\n+  char *digits;\n+  int e;\n+  char expchar;\n   format_token ft;\n-  char exp_char = 'E';\n-  int with_exp = 1;\n-  int scale_flag = 1 ;\n-  double minv = 0.0, maxv = 0.0;\n-  sign_t sign = SIGN_NONE, esign = SIGN_NONE;\n-\n-  int intval = 0, intlen = 0;\n-  int j;\n-  \n-  /* EXP value for this number.  */\n-  neval = 0;\n-\n-  /* Width of EXP and it's sign.  */\n-  nesign = 0;\n+  int w;\n+  int d;\n+  int edigits;\n+  int ndigits;\n+  /* Number of digits before the decimal point.  */\n+  int nbefore;\n+  /* Number of zeros after the decimal point.  */\n+  int nzero;\n+  /* Number of digits after the decimal point.  */\n+  int nafter;\n+  int leadzero;\n+  int nblanks;\n+  int i;\n+  sign_t sign;\n \n   ft = f->format;\n   w = f->u.real.w;\n-  d = f->u.real.d + 1;\n-\n-  /* Width of the EXP.  */\n-  e = 0;\n-\n-  sca = g.scale_factor;\n-  n = value;\n-\n-  sign = calculate_sign (n < 0.0);\n-  if (n < 0)\n-    n = -n;\n-\n-  /* Width of the sign for the whole number.  */\n-  nsign = (sign == SIGN_NONE ? 0 : 1);\n-\n-  digits = 0;\n-  if (ft != FMT_F)\n+  d = f->u.real.d;\n+\n+  /* We should always know the field width and precision.  */\n+  if (d < 0)\n+    internal_error (\"Uspecified precision\");\n+\n+  /* Use sprintf to print the number in the format +D.DDDDe+ddd\n+     For an N digit exponent, this gives us (32-6)-N digits after the\n+     decimal point, plus annother one before the decimal point.  */\n+  sign = calculate_sign (value < 0.0);\n+  if (value < 0)\n+    value = -value;\n+\n+  /* Printf always prints at least two exponent digits.  */\n+  if (value == 0)\n+    edigits = 2;\n+  else\n     {\n-      e = f->u.real.e;\n+      edigits = 1 + (int) log10 (fabs(log10 (value)));\n+      if (edigits < 2)\n+\tedigits = 2;\n     }\n-  if (ft == FMT_F || ft == FMT_E || ft == FMT_D)\n+  \n+  if (FMT_F || FMT_ES)\n     {\n-      if (ft == FMT_F)\n-        scale_flag = 0;\n-      if (ft == FMT_D)\n-        exp_char = 'D' ;\n-      minv = 0.1;\n-      maxv = 1.0;\n-\n-      /* Calculate the new val of the number with consideration\n-         of global scale value.  */\n-      while (sca >  0)\n-        {\n-          minv *= 10.0;\n-          maxv *= 10.0;\n-          n *= 10.0;\n-          sca -- ;\n-          neval --;\n-        }\n+      /* Always convert at full precision to avoid double rounding.  */\n+      ndigits = 27 - edigits;\n+    }\n+  else\n+    {\n+      /* We know the number of digits, so can let printf do the rounding\n+\t for us.  */\n+      if (ft == FMT_ES)\n+\tndigits = d + 1;\n+      else\n+\tndigits = d;\n+      if (ndigits > 27 - edigits)\n+\tndigits = 27 - edigits;\n+    }\n \n-      /* Now calculate the new Exp value for this number.  */\n-      sca = g.scale_factor;\n-      while(sca >= 1)\n-        {\n-          sca /= 10;\n-          digits ++ ;\n-        }\n+  sprintf (buffer, \"%+-31.*e\", ndigits - 1, value);\n+  \n+  /* Check the resulting string has punctuation in the correct places.  */\n+  if (buffer[2] != '.' || buffer[ndigits + 2] != 'e')\n+    {\n+      printf (\"'%s', %d\\n\", buffer, ndigits);\n+      internal_error (\"printf is broken\");\n     }\n \n-   if (ft == FMT_EN )\n-     {\n-       minv = 1.0;\n-       maxv = 1000.0;\n-     }\n-   if (ft == FMT_ES)\n-     {\n-       minv = 1.0;\n-       maxv = 10.0;\n-     }\n+  /* Read the exponent back in.  */\n+  e = atoi (&buffer[ndigits + 3]) + 1;\n \n-   /* OK, let's scale the number to appropriate range.  */\n-   while (scale_flag && n > 0.0 && n < minv)\n-     {\n-       if (n < minv)\n-         {\n-           n = n * 10.0 ;\n-           neval --;\n-         }\n-     }\n-   while (scale_flag && n > 0.0 && n > maxv)\n-     {\n-       if (n > maxv)\n-         {\n-           n = n / 10.0 ;\n-           neval ++;\n-         }\n-     }\n+  /* Make sure zero comes out as 0.0e0.  */\n+  if (value == 0.0)\n+    e = 0;\n \n-  /* It is time to process the EXP part of the number.\n-     Value of 'nesign' is 0 unless following codes is executed.  */\n-  if (ft != FMT_F)\n-    {\n-     /* Sign of the EXP value.  */\n-     if (neval >= 0)\n-       esign = SIGN_PLUS;\n-     else\n-       {\n-         esign = SIGN_MINUS;\n-         neval = - neval ;\n-       }\n+  /* Normalize the fractional component.  */\n+  buffer[2] = buffer[1];\n+  digits = &buffer[2];\n \n-      /* Width of the EXP.  */\n-      e_new = 0;\n-      j = neval;\n-      while (j > 0)\n-        {\n-           j = j / 10;\n-           e_new ++ ;\n-        }\n-      if (e <= e_new)\n-         e = e_new;\n+  /* Figure out where to place the decimal point.  */\n+  switch (ft)\n+    {\n+    case FMT_F:\n+      nbefore = e + g.scale_factor;\n+      if (nbefore < 0)\n+\t{\n+\t  nzero = -nbefore;\n+\t  if (nzero > d)\n+\t    nzero = d;\n+\t  nafter = d - nzero;\n+\t  nbefore = 0;\n+\t}\n+      else\n+\t{\n+\t  nzero = 0;\n+\t  nafter = d;\n+\t}\n+      expchar = 0;\n+      break;\n \n-     /* Got the width of EXP.  */\n-     if (e < digits)\n-       e = digits ;\n+    case FMT_E:\n+    case FMT_D:\n+      i = g.scale_factor;\n+      if (i < 0)\n+\t{\n+\t  nbefore = 0;\n+\t  nzero = -i;\n+\t  nafter = d + i;\n+\t}\n+      else\n+\t{\n+\t  nbefore = i;\n+\t  nzero = 0;\n+\t  nafter = d - i;\n+\t}\n+      if (ft = FMT_E)\n+\texpchar = 'E';\n+      else\n+\texpchar = 'D';\n+      break;\n \n-     /* Minimum value of the width would be 2.  */\n-     if (e < 2)\n-       e = 2;\n+    case FMT_EN:\n+      /* The exponent must be a multiple of three, with 1-3 digits before\n+\t the decimal point.  */\n+      e--;\n+      if (e >= 0)\n+\tnbefore = e % 3;\n+      else\n+\t{\n+\t  nbefore = (-e) % 3;\n+\t  if (nbefore != 0)\n+\t    nbefore = 3 - nbefore;\n+\t}\n+      e -= nbefore;\n+      nbefore++;\n+      nzero = 0;\n+      nafter = d;\n+      expchar = 'E';\n+      break;\n \n-     nesign =  1 ;  /* We must give a position for the 'exp_char'  */\n-     if (e > 0)\n-       nesign = e + nesign + (esign != SIGN_NONE ? 1 : 0);\n-   }\n+    case FMT_ES:\n+      e--;\n+      nbefore = 1;\n+      nzero = 0;\n+      nafter = d;\n+      expchar = 'E';\n+      break;\n \n+    default:\n+      /* Should never happen.  */\n+      internal_error (\"Unexpected format token\");\n+    }\n \n-  intval = n;\n-  intstr = itoa (intval);\n-  intlen = strlen (intstr);\n+  /* Round the value.  */\n+  if (nbefore + nafter < ndigits && nbefore + nafter > 0)\n+    {\n+      i = nbefore + nafter;\n+      if (digits[i] >= '5')\n+\t{\n+\t  /* Propagate the carry.  */\n+\t  for (i--; i >= 0; i--)\n+\t    {\n+\t      if (digits[i] != '9')\n+\t\t{\n+\t\t  digits[i]++;\n+\t\t  break;\n+\t\t}\n+\t      digits[i] = '0';\n+\t    }\n+\n+\t  if (i < 0)\n+\t    {\n+\t      /* The carry overflowed.  Fortunately we have some spare space\n+\t\t at the start of the buffer.  We may discard some digits, but\n+\t\t this is ok because we already know they are zero.  */\n+\t      digits--;\n+\t      digits[0] = '1';\n+\t      if (ft == FMT_F)\n+\t\t{\n+\t\t  if (nzero > 0)\n+\t\t    {\n+\t\t      nzero--;\n+\t\t      nafter++;\n+\t\t    }\n+\t\t  else\n+\t\t    nbefore++;\n+\t\t}\n+\t      else if (ft == FMT_EN)\n+\t\t{\n+\t\t  nbefore++;\n+\t\t  if (nbefore == 4)\n+\t\t    {\n+\t\t      nbefore = 1;\n+\t\t      e += 3;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\te++;\n+\t    }\n+\t}\n+    }\n \n-  q = rtoa (n, len, d);\n-  digits = strlen (q);\n+  /* Calculate the format of the exponent field.  */\n+  if (expchar)\n+    {\n+      edigits = 1;\n+      for (i = abs (e); i >= 10; i /= 10)\n+\tedigits++;\n+      \n+      if (f->u.real.e < 0)\n+\t{\n+\t  /* Width not specified.  Must be no more than 3 digits.  */\n+\t  if (e > 999 || e < -999)\n+\t    edigits = -1;\n+\t  else\n+\t    {\n+\t      edigits = 4;\n+\t      if (e > 99 || e < -99)\n+\t\texpchar = ' ';\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Exponent width specified, check it is wide enough.  */\n+\t  if (edigits > f->u.real.e)\n+\t    edigits = -1;\n+\t  else\n+\t    edigits = f->u.real.e + 2;\n+\t}\n+    }\n+  else\n+    edigits = 0;\n \n-  /* Select a width if none was specified.  */\n+  /* Pick a field size if none was specified.  */\n   if (w <= 0)\n-    w = digits + nsign;\n+    w = nbefore + nzero + nafter + 2;\n \n-  p = write_block (w);\n-  if (p == NULL)\n+  /* Create the ouput buffer.  */\n+  out = write_block (w);\n+  if (out == NULL)\n     return;\n \n-  base = p;\n-\n-  nblank = w - (nsign + intlen + d + nesign);\n-  if (nblank == -1 && ft != FMT_F)\n-     {\n-       with_exp = 0;\n-       nesign -= 1;\n-       nblank = w - (nsign + intlen + d + nesign);\n-     }\n-  /* Don't let a leading '0' cause field overflow.  */\n-  if (nblank == -1 && ft == FMT_F && q[0] == '0')\n-     {\n-        q++;\n-        nblank = 0;\n-     }\n+  /* Work out how much padding is needed.  */\n+  nblanks = w - (nbefore + nzero + nafter + edigits + 1);\n+  if (sign != SIGN_NONE)\n+    nblanks--;\n+  \n+  /* Check the value fits in the specified field width.  */\n+  if (nblanks < 0 || edigits == -1)\n+    {\n+      star_fill (out, w);\n+      return;\n+    }\n \n-  if (nblank < 0)\n+  /* See if we have space for a zero before the decimal point.  */\n+  if (nbefore == 0 && nblanks > 0)\n     {\n-      star_fill (p, w);\n-      goto done;\n+      leadzero = 1;\n+      nblanks--;\n     }\n-  memset (p, ' ', nblank);\n-  p += nblank;\n+  else\n+    leadzero = 0;\n \n-  switch (sign)\n+  /* Padd to full field width.  */\n+  if (nblanks > 0)\n     {\n-    case SIGN_PLUS:\n-      *p++ = '+';\n-      break;\n-    case SIGN_MINUS:\n-      *p++ = '-';\n-      break;\n-    case SIGN_NONE:\n-      break;\n+      memset (out, ' ', nblanks);\n+      out += nblanks;\n     }\n \n-  memcpy (p, q, intlen + d + 1);\n-  p += intlen + d;\n+  /* Output the initial sign (if any).  */\n+  if (sign == SIGN_PLUS)\n+    *(out++) = '+';\n+  else if (sign == SIGN_MINUS)\n+    *(out++) = '-';\n+\n+  /* Output an optional leading zero.  */\n+  if (leadzero)\n+    *(out++) = '0';\n \n-  if (nesign > 0)\n+  /* Output the part before the decimal point, padding with zeros.  */\n+  if (nbefore > 0)\n     {\n-      if (with_exp)\n-         *p++ = exp_char;\n-      switch (esign)\n-        {\n-        case SIGN_PLUS:\n-          *p++ = '+';\n-          break;\n-        case SIGN_MINUS:\n-          *p++ = '-';\n-          break;\n-        case SIGN_NONE:\n-          break;\n-        }\n-      q = itoa (neval);\n-      digits = strlen (q);\n+      if (nbefore > ndigits)\n+\ti = ndigits;\n+      else\n+\ti = nbefore;\n+\n+      memcpy (out, digits, i);\n+      while (i < nbefore)\n+\tout[i++] = '0';\n \n-      for (itmp = 0; itmp < e - digits; itmp++)\n-        *p++ = '0';\n-      memcpy (p, q, digits);\n-      p[digits]  = 0;\n+      digits += i;\n+      ndigits -= i;\n+      out += nbefore;\n     }\n+  /* Output the decimal point.  */\n+  *(out++) = '.';\n \n-done:\n-  return ;\n+  /* Output leading zeros after the decimal point.  */\n+  if (nzero > 0)\n+    {\n+      for (i = 0; i < nzero; i++)\n+\t*(out++) = '0';\n+    }\n+\n+  /* Output digits after the decimal point, padding with zeros.  */\n+  if (nafter > 0)\n+    {\n+      if (nafter > ndigits)\n+\ti = ndigits;\n+      else\n+\ti = nafter;\n+\n+      memcpy (out, digits, i);\n+      while (i < nafter)\n+\tout[i++] = '0';\n+\n+      digits += i;\n+      ndigits -= i;\n+      out += nafter;\n+    }\n+  \n+  /* Output the exponent.  */\n+  if (expchar)\n+    {\n+      if (expchar != ' ')\n+\t{\n+\t  *(out++) = expchar;\n+\t  edigits--;\n+\t}\n+      snprintf (buffer, 32, \"%+0*d\", edigits, e);\n+      memcpy (out, buffer, edigits);\n+    }\n }\n \n+\n void\n write_l (fnode * f, char *source, int len)\n {"}, {"sha": "b87dde69471d627d7107ec554eff4109fd0ba650", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=7984a2f04bb29eff5850be9f99c2ef0f879c862a", "patch": "@@ -250,9 +250,6 @@ void get_args (int *, char ***);\n \n \n /* error.c */\n-#define rtoa prefix(rtoa)\n-char *rtoa (double f, int length, int oprec);\n-\n #define itoa prefix(itoa)\n char *itoa (int64_t);\n "}, {"sha": "74670b56d28d426d0457feb29d753607c1382950", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7984a2f04bb29eff5850be9f99c2ef0f879c862a/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=7984a2f04bb29eff5850be9f99c2ef0f879c862a", "patch": "@@ -53,62 +53,6 @@ unsigned line;\n \n static char buffer[32];\t\t/* buffer for integer/ascii conversions */\n \n-/* rtoa()-- Real to ascii conversion for base 10 and below.\n- * Returns a pointer to a static buffer.  */\n-\n-char *\n-rtoa (double f, int length, int oprec)\n-{\n-  double n = f;\n-  double fval, minval;\n-  int negative, prec;\n-  unsigned k;\n-  char formats[16];\n-\n-  prec = 0;\n-  negative = 0;\n-  if (n < 0.0)\n-    {\n-      negative = 1;\n-      n = -n;\n-    }\n-\n-  if (length >= 8)\n-    minval = FLT_MIN;\n-  else\n-    minval = DBL_MIN;\n-\n-\n-  if (n <= minval)\n-    {\n-      buffer[0] = '0';\n-      buffer[1] = '.';\n-      for (k = 2; k < 28 ; k++)\n-        buffer[k] = '0';\n-      buffer[k+1] = '\\0';\n-      return buffer;\n-    }\n-  fval = n;\n-  while (fval > 1.0)\n-    {\n-      fval = fval / 10.0;\n-      prec ++;\n-    }\n-\n-  prec = sizeof (buffer) - 2 - prec;\n-  if (prec > 20)\n-     prec = 20;\n-  prec = prec > oprec ? oprec : prec ;\n-\n-  if (negative)\n-     sprintf (formats, \"-%%.%df\", prec);\n-  else\n-     sprintf (formats, \"%%.%df\", prec);\n-\n-  sprintf (buffer, formats, n);\n-  return buffer;\n-}\n-\n \n /* Returns a pointer to a static buffer. */\n "}]}