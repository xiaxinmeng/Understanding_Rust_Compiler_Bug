{"sha": "991278ab90aa132805caaf3f2b6394348c850160", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkxMjc4YWI5MGFhMTMyODA1Y2FhZjNmMmI2Mzk0MzQ4Yzg1MDE2MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-27T17:28:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-27T17:28:51Z"}, "message": "inline-9.c: New testcase.\n\n\t* testsuite/gcc.dg/tree-ssa/inline-9.c: New testcase.\n\t* ipa-inline.h (struct inline_edge_summary): Add predicate pointer.\n\t* ipa-inline-analysis.c: Include alloc-pool.h.\n\t(edge_predicate_pool): New.\n\t(trye_predicate_p): New function\n\t(false_predicate_p): New function.\n\t(add_clause): Sanity check that false clauses are \"optimized\";\n\tnever add clauses to predicate that is already known to be false.\n\t(and_predicate): Use flase_predicate_p.\n\t(evaulate_predicate): Rename to ...\n\t(evaluate_predicate): ... this one; update all callers; assert\n\tthat false is not listed among possible truths.\n\t(dump_predicate): Use true_predicate_p.\n\t(account_size_time): Use false_predicate_p.\n\t(evaulate_conditions_for_edge): Rename to ...\n\t(evaluate_conditions_for_edge) ... this one.\n\t(edge_set_predicate): New function.\n\t(inline_edge_duplication_hook): Duplicate edge predicates.\n\t(inline_edge_removal_hook): Free edge predicates.\n\t(dump_inline_edge_summary): Add INFO parameter; dump\n\tedge predicates.\n\t(dump_inline_summary): Update.\n\t(estimate_function_body_sizes): Set edge predicates.\n\t(estimate_calls_size_and_time): Handle predicates.\n\t(estimate_callee_size_and_time): Update.\n\t(remap_predicate): Add toplev_predicate; update comment.\n\t(remap_edge_predicates): New function.\n\t(inline_merge_summary): Compute toplev predicate; update.\n\t(read_predicate): New function.\n\t(read_inline_edge_summary): Use it.\n\t(inline_read_section): Likewise.\n\t(write_predicate): New function.\n\t(write_inline_edge_summary): Use it.\n\t(inline_write_summary): Likewise.\n\t(inline_free_summary): Free alloc pool and edge summary vec.\n\nFrom-SVN: r173042", "tree": {"sha": "9697add388cfd4243871035ff391fcd84fd2bf18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9697add388cfd4243871035ff391fcd84fd2bf18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/991278ab90aa132805caaf3f2b6394348c850160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991278ab90aa132805caaf3f2b6394348c850160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/991278ab90aa132805caaf3f2b6394348c850160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991278ab90aa132805caaf3f2b6394348c850160/comments", "author": null, "committer": null, "parents": [{"sha": "648b5f85f5761c324323549e3048a86ac0d7ff73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648b5f85f5761c324323549e3048a86ac0d7ff73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/648b5f85f5761c324323549e3048a86ac0d7ff73"}], "stats": {"total": 377, "additions": 320, "deletions": 57}, "files": [{"sha": "3c9412d5be86d1497b380e531a6a8cd343f36889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991278ab90aa132805caaf3f2b6394348c850160/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991278ab90aa132805caaf3f2b6394348c850160/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=991278ab90aa132805caaf3f2b6394348c850160", "patch": "@@ -1,3 +1,40 @@\n+2011-04-27  Jan Hubcika  <jh@suse.cz>\n+\n+\t* ipa-inline.h (struct inline_edge_summary): Add predicate pointer.\n+\t* ipa-inline-analysis.c: Include alloc-pool.h.\n+\t(edge_predicate_pool): New.\n+\t(trye_predicate_p): New function\n+\t(false_predicate_p): New function.\n+\t(add_clause): Sanity check that false clauses are \"optimized\";\n+\tnever add clauses to predicate that is already known to be false.\n+\t(and_predicate): Use flase_predicate_p.\n+\t(evaulate_predicate): Rename to ...\n+\t(evaluate_predicate): ... this one; update all callers; assert\n+\tthat false is not listed among possible truths.\n+\t(dump_predicate): Use true_predicate_p.\n+\t(account_size_time): Use false_predicate_p.\n+\t(evaulate_conditions_for_edge): Rename to ...\n+\t(evaluate_conditions_for_edge) ... this one.\n+\t(edge_set_predicate): New function.\n+\t(inline_edge_duplication_hook): Duplicate edge predicates.\n+\t(inline_edge_removal_hook): Free edge predicates.\n+\t(dump_inline_edge_summary): Add INFO parameter; dump\n+\tedge predicates.\n+\t(dump_inline_summary): Update.\n+\t(estimate_function_body_sizes): Set edge predicates.\n+\t(estimate_calls_size_and_time): Handle predicates.\n+\t(estimate_callee_size_and_time): Update.\n+\t(remap_predicate): Add toplev_predicate; update comment.\n+\t(remap_edge_predicates): New function.\n+\t(inline_merge_summary): Compute toplev predicate; update.\n+\t(read_predicate): New function.\n+\t(read_inline_edge_summary): Use it.\n+\t(inline_read_section): Likewise.\n+\t(write_predicate): New function.\n+\t(write_inline_edge_summary): Use it.\n+\t(inline_write_summary): Likewise.\n+\t(inline_free_summary): Free alloc pool and edge summary vec.\n+\n 2011-04-27  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-structalias.c (changed_count): Remove."}, {"sha": "f96e09ef1f4471913a32c9ec4585842e042db8e9", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 254, "deletions": 57, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=991278ab90aa132805caaf3f2b6394348c850160", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"lto-streamer.h\"\n #include \"ipa-inline.h\"\n+#include \"alloc-pool.h\"\n \n /* Estimate runtime of function can easilly run into huge numbers with many\n    nested loops.  Be sure we can compute time * INLINE_SIZE_SCALE in integer.\n@@ -129,6 +130,8 @@ VEC(inline_edge_summary_t,heap) *inline_edge_summary_vec;\n VEC(int,heap) *node_growth_cache;\n VEC(edge_growth_cache_entry,heap) *edge_growth_cache;\n \n+/* Edge predicates goes here.  */\n+static alloc_pool edge_predicate_pool;\n \n /* Return true predicate (tautology).\n    We represent it by empty list of clauses.  */\n@@ -163,6 +166,30 @@ false_predicate (void)\n }\n \n \n+/* Return true if P is (false).  */\n+\n+static inline bool\n+true_predicate_p (struct predicate *p)\n+{\n+  return !p->clause[0];\n+}\n+\n+\n+/* Return true if P is (false).  */\n+\n+static inline bool\n+false_predicate_p (struct predicate *p)\n+{\n+  if (p->clause[0] == (1 << predicate_false_condition))\n+    {\n+      gcc_checking_assert (!p->clause[1]\n+\t\t\t   && p->clause[0] == 1 << predicate_false_condition);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n /* Return predicate that is set true when function is not inlined.  */\n static inline struct predicate\n not_inlined_predicate (void)\n@@ -207,16 +234,21 @@ add_clause (struct predicate *p, clause_t clause)\n {\n   int i;\n   int insert_here = -1;\n+\n   /* True clause.  */\n   if (!clause)\n     return;\n \n   /* Flase clause makes the whole predicate false.  Kill the other variants.  */\n-  if (clause & (1 << predicate_false_condition))\n+  if (clause == (1 << predicate_false_condition))\n     {\n       p->clause[0] = (1 << predicate_false_condition);\n       p->clause[1] = 0;\n+      return;\n     }\n+  if (false_predicate_p (p))\n+    return;\n+  gcc_assert (!(clause & (1 << predicate_false_condition)));\n   for (i = 0; i < MAX_CLAUSES - 1; i++)\n     {\n       if (p->clause[i] == clause)\n@@ -247,6 +279,7 @@ and_predicates (struct predicate *p, struct predicate *p2)\n {\n   struct predicate out = *p;\n   int i;\n+\n   for (i = 0; p2->clause[i]; i++)\n     {\n       gcc_checking_assert (i < MAX_CLAUSES);\n@@ -263,17 +296,12 @@ or_predicates (struct predicate *p, struct predicate *p2)\n {\n   struct predicate out = true_predicate ();\n   int i,j;\n+\n   /* If one of conditions is false, return the other.  */\n-  if (p2->clause[0] == 1 << predicate_false_condition)\n-    {\n-      gcc_checking_assert (!p2->clause[1]);\n-      return *p;\n-    }\n-  if (p->clause[0] == 1 << predicate_false_condition)\n-    {\n-      gcc_checking_assert (!p->clause[1]);\n-      return *p2;\n-    }\n+  if (false_predicate_p (p2))\n+    return *p;\n+  if (false_predicate_p (p))\n+    return *p2;\n   for (i = 0; p->clause[i]; i++)\n     for (j = 0; p2->clause[j]; j++)\n       {\n@@ -304,14 +332,16 @@ predicates_equal_p (struct predicate *p, struct predicate *p2)\n    to be false.  */\n \n static bool\n-evaulate_predicate (struct predicate *p, clause_t possible_truths)\n+evaluate_predicate (struct predicate *p, clause_t possible_truths)\n {\n   int i;\n \n   /* True remains true.  */\n-  if (!p->clause[0])\n+  if (true_predicate_p (p))\n     return true;\n \n+  gcc_assert (!(possible_truths & (1 << predicate_false_condition)));\n+\n   /* See if we can find clause we can disprove.  */\n   for (i = 0; p->clause[i]; i++)\n     {\n@@ -376,7 +406,7 @@ static void\n dump_predicate (FILE *f, conditions conds, struct predicate *pred)\n {\n   int i;\n-  if (!pred->clause[0])\n+  if (true_predicate_p (pred))\n     dump_clause (f, conds, 0);\n   else\n     for (i = 0; pred->clause[i]; i++)\n@@ -398,7 +428,7 @@ account_size_time (struct inline_summary *summary, int size, int time, struct pr\n   bool found = false;\n   int i;\n \n-  if (pred->clause[0] == (1 << predicate_false_condition))\n+  if (false_predicate_p (pred))\n     return;\n \n   /* We need to create initial empty unconitional clause, but otherwie\n@@ -448,11 +478,31 @@ account_size_time (struct inline_summary *summary, int size, int time, struct pr\n     }\n }\n \n+/* Set predicate for edge E.  */\n+\n+static void\n+edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n+{\n+  struct inline_edge_summary *es = inline_edge_summary (e);\n+  if (predicate && !true_predicate_p (predicate))\n+    {\n+      if (!es->predicate)\n+        es->predicate = (struct predicate *)pool_alloc (edge_predicate_pool);\n+      *es->predicate = *predicate;\n+    }\n+  else\n+    {\n+      if (es->predicate)\n+        pool_free (edge_predicate_pool, es->predicate);\n+      es->predicate = NULL;\n+    }\n+}\n+\n \n /* Work out what conditions might be true at invocation of E.  */\n \n static clause_t\n-evaulate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n+evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n   struct inline_summary *info = inline_summary (e->callee);\n@@ -536,6 +586,9 @@ inline_summary_alloc (void)\n       <= (unsigned) cgraph_edge_max_uid)\n     VEC_safe_grow_cleared (inline_edge_summary_t, heap,\n \t\t\t   inline_edge_summary_vec, cgraph_edge_max_uid + 1);\n+  if (!edge_predicate_pool)\n+    edge_predicate_pool = create_alloc_pool (\"edge predicates\", sizeof (struct predicate),\n+\t\t\t\t\t     10);\n }\n \n /* Hook that is called by cgraph.c when a node is removed.  */\n@@ -580,10 +633,14 @@ inline_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t\t\t      ATTRIBUTE_UNUSED void *data)\n {\n   struct inline_edge_summary *info;\n+  struct inline_edge_summary *srcinfo;\n   inline_summary_alloc ();\n   info = inline_edge_summary (dst);\n-  memcpy (info, inline_edge_summary (src),\n+  srcinfo = inline_edge_summary (src);\n+  memcpy (info, srcinfo,\n \t  sizeof (struct inline_edge_summary));\n+  info->predicate = NULL;\n+  edge_set_predicate (dst, srcinfo->predicate);\n }\n \n \n@@ -595,7 +652,10 @@ inline_edge_removal_hook (struct cgraph_edge *edge, void *data ATTRIBUTE_UNUSED)\n   if (edge_growth_cache)\n     reset_edge_growth_cache (edge);\n   if (edge->uid < (int)VEC_length (inline_edge_summary_t, inline_edge_summary_vec))\n-    memset (inline_edge_summary (edge), 0, sizeof (struct inline_edge_summary));\n+    {\n+      edge_set_predicate (edge, NULL);\n+      memset (inline_edge_summary (edge), 0, sizeof (struct inline_edge_summary));\n+    }\n }\n \n \n@@ -628,24 +688,32 @@ free_growth_caches (void)\n    Indent by INDENT.  */\n \n static void\n-dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node)\n+dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n+\t\t\t  struct inline_summary *info)\n {\n   struct cgraph_edge *edge;\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n-      fprintf (f, \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i time: %2i\\n\",\n+      fprintf (f, \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i time: %2i\",\n \t       indent, \"\", cgraph_node_name (edge->callee),\n \t       edge->callee->uid, \n-\t       edge->inline_failed ? \"inlined\"\n+\t       !edge->inline_failed ? \"inlined\"\n \t       : cgraph_inline_failed_string (edge->inline_failed),\n \t       indent, \"\",\n \t       es->loop_depth,\t\n                edge->frequency,\n \t       es->call_stmt_size,\n \t       es->call_stmt_time);\n+      if (es->predicate)\n+\t{\n+\t  fprintf (f, \" predicate: \");\n+\t  dump_predicate (f, info->conds, es->predicate);\n+\t}\n+      else\n+\t  fprintf (f, \"\\n\");\n       if (!edge->inline_failed)\n-\tdump_inline_edge_summary (f, indent+2, edge->callee);\n+\tdump_inline_edge_summary (f, indent+2, edge->callee, info);\n     }\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     {\n@@ -656,6 +724,13 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node)\n                edge->frequency,\n \t       es->call_stmt_size,\n \t       es->call_stmt_time);\n+      if (es->predicate)\n+\t{\n+\t  fprintf (f, \"predicate: \");\n+\t  dump_predicate (f, info->conds, es->predicate);\n+\t}\n+      else\n+\t  fprintf (f, \"\\n\");\n     }\n }\n \n@@ -696,7 +771,7 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n \t  dump_predicate (f, s->conds, &e->predicate);\n \t}\n       fprintf (f, \"  calls:\\n\");\n-      dump_inline_edge_summary (f, 4, node);\n+      dump_inline_edge_summary (f, 4, node, s);\n       fprintf (f, \"\\n\");\n     }\n }\n@@ -991,6 +1066,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      es->call_stmt_size = this_size;\n \t      es->call_stmt_time = this_time;\n \t      es->loop_depth = bb->loop_depth;\n+\t      edge_set_predicate (edge, &bb_predicate);\n \n \t      /* Do not inline calls where we cannot triviall work around\n \t\t mismatches in argument or return types.  */\n@@ -1158,17 +1234,29 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time)\n /* Increase SIZE and TIME for size and time needed to handle all calls in NODE.  */\n \n static void\n-estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time)\n+estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n+\t\t\t      clause_t possible_truths)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n-    if (e->inline_failed)\n-      estimate_edge_size_and_time (e, size, time);\n-    else\n-      estimate_calls_size_and_time (e->callee, size, time);\n+    {\n+      struct inline_edge_summary *es = inline_edge_summary (e);\n+      if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n+\t{\n+\t  if (e->inline_failed)\n+\t    estimate_edge_size_and_time (e, size, time);\n+\t  else\n+\t    estimate_calls_size_and_time (e->callee, size, time,\n+\t\t\t\t\t  possible_truths);\n+\t}\n+    }\n   /* TODO: look for devirtualizing oppurtunities.  */\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    estimate_edge_size_and_time (e, size, time);\n+    {\n+      struct inline_edge_summary *es = inline_edge_summary (e);\n+      if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n+        estimate_edge_size_and_time (e, size, time);\n+    }\n }\n \n \n@@ -1182,7 +1270,7 @@ estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n \t\t       \t       int *ret_size, int *ret_time)\n {\n   struct inline_summary *info = inline_summary (edge->callee);\n-  clause_t clause = evaulate_conditions_for_edge (edge, inline_p);\n+  clause_t clause = evaluate_conditions_for_edge (edge, inline_p);\n   size_time_entry *e;\n   int size = 0, time = 0;\n   int i;\n@@ -1209,13 +1297,13 @@ estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n     }\n \n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n-    if (evaulate_predicate (&e->predicate, clause))\n+    if (evaluate_predicate (&e->predicate, clause))\n       time += e->time, size += e->size;\n \n   if (time > MAX_TIME * INLINE_TIME_SCALE)\n     time = MAX_TIME * INLINE_TIME_SCALE;\n \n-  estimate_calls_size_and_time (edge->callee, &size, &time);\n+  estimate_calls_size_and_time (edge->callee, &size, &time, clause);\n   time = (time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   size = (size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n \n@@ -1231,21 +1319,28 @@ estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n }\n \n \n-/* Translate all conditions from callee representation into caller representaiton and\n-   symbolically evaulate predicate P into new predicate.  */\n+/* Translate all conditions from callee representation into caller representation and\n+   symbolically evaluate predicate P into new predicate.\n+\n+   INFO is inline_summary of function we are adding predicate into, CALLEE_INFO is summary\n+   of function predicate P is from. OPERAND_MAP is array giving callee formal IDs the\n+   caller formal IDs. POSSSIBLE_TRUTHS is clausule of all callee conditions that\n+   may be true in caller context. TOPLEV_PREDICATE is predicate under which callee\n+   is executed.  */\n \n static struct predicate\n remap_predicate (struct inline_summary *info, struct inline_summary *callee_info,\n \t\t struct predicate *p,\n \t\t VEC (int, heap) *operand_map,\n-\t\t clause_t possible_truths)\n+\t\t clause_t possible_truths,\n+\t\t struct predicate *toplev_predicate)\n {\n   int i;\n   struct predicate out = true_predicate ();\n \n   /* True predicate is easy.  */\n-  if (p->clause[0] == 0)\n-    return *p;\n+  if (true_predicate_p (p))\n+    return *toplev_predicate;\n   for (i = 0; p->clause[i]; i++)\n     {\n       clause_t clause = p->clause[i];\n@@ -1289,7 +1384,7 @@ remap_predicate (struct inline_summary *info, struct inline_summary *callee_info\n \t  }\n       out = and_predicates (&out, &clause_predicate);\n     }\n-  return out;\n+  return and_predicates (&out, toplev_predicate);\n }\n \n \n@@ -1325,6 +1420,64 @@ inline_update_callee_summaries (struct cgraph_node *node,\n }\n \n \n+/* Remap predicates of callees of NODE.  Rest of arguments match\n+   remap_predicate.  */\n+\n+static void\n+remap_edge_predicates (struct cgraph_node *node,\n+\t\t       struct inline_summary *info,\n+\t\t       struct inline_summary *callee_info,\n+\t\t       VEC (int, heap) *operand_map,\n+\t\t       clause_t possible_truths,\n+\t\t       struct predicate *toplev_predicate)\n+{\n+  struct cgraph_edge *e;\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      struct inline_edge_summary *es = inline_edge_summary (e);\n+      struct predicate p;\n+      if (es->predicate)\n+\t{\n+\t  p = remap_predicate (info, callee_info,\n+\t\t\t       es->predicate, operand_map, possible_truths,\n+\t\t\t       toplev_predicate);\n+\t  edge_set_predicate (e, &p);\n+\t  /* TODO: We should remove the edge for code that will be optimized out,\n+\t     but we need to keep verifiers and tree-inline happy.\n+\t     Make it cold for now.  */\n+\t  if (false_predicate_p (&p))\n+\t    {\n+\t      e->count = 0;\n+\t      e->frequency = 0;\n+\t    }\n+\t}\n+      if (!e->inline_failed)\n+\tremap_edge_predicates (e->callee, info, callee_info, operand_map,\n+\t\t\t       possible_truths, toplev_predicate);\n+    }\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    {\n+      struct inline_edge_summary *es = inline_edge_summary (e);\n+      struct predicate p;\n+      if (es->predicate)\n+\t{\n+\t  p = remap_predicate (info, callee_info,\n+\t\t\t       es->predicate, operand_map, possible_truths,\n+\t\t\t       toplev_predicate);\n+\t  edge_set_predicate (e, &p);\n+\t  /* TODO: We should remove the edge for code that will be optimized out,\n+\t     but we need to keep verifiers and tree-inline happy.\n+\t     Make it cold for now.  */\n+\t  if (false_predicate_p (&p))\n+\t    {\n+\t      e->count = 0;\n+\t      e->frequency = 0;\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n /* We inlined EDGE.  Update summary of the function we inlined into.  */\n \n void\n@@ -1338,6 +1491,13 @@ inline_merge_summary (struct cgraph_edge *edge)\n   size_time_entry *e;\n   VEC (int, heap) *operand_map = NULL;\n   int i;\n+  struct predicate toplev_predicate;\n+  struct inline_edge_summary *es = inline_edge_summary (edge);\n+\n+  if (es->predicate)\n+    toplev_predicate = *es->predicate;\n+  else\n+    toplev_predicate = true_predicate ();\n \n   if (ipa_node_params_vector && callee_info->conds\n       /* FIXME: it seems that we forget to get argument count in some cases,\n@@ -1349,7 +1509,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n       int count = ipa_get_cs_argument_count (args);\n       int i;\n \n-      clause = evaulate_conditions_for_edge (edge, true);\n+      clause = evaluate_conditions_for_edge (edge, true);\n       VEC_safe_grow_cleared (int, heap, operand_map, count);\n       for (i = 0; i < count; i++)\n \t{\n@@ -1366,18 +1526,22 @@ inline_merge_summary (struct cgraph_edge *edge)\n   for (i = 0; VEC_iterate (size_time_entry, callee_info->entry, i, e); i++)\n     {\n       struct predicate p = remap_predicate (info, callee_info,\n-\t\t\t\t\t    &e->predicate, operand_map, clause);\n+\t\t\t\t\t    &e->predicate, operand_map, clause,\n+\t\t\t\t\t    &toplev_predicate);\n       gcov_type add_time = ((gcov_type)e->time * edge->frequency\n \t\t\t    + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n       if (add_time > MAX_TIME)\n \tadd_time = MAX_TIME;\n       account_size_time (info, e->size, add_time, &p);\n     }\n+  remap_edge_predicates (edge->callee, info, callee_info, operand_map,\n+\t\t\t clause, &toplev_predicate);\n   info->size = 0;\n   info->time = 0;\n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n     info->size += e->size, info->time += e->time;\n-  estimate_calls_size_and_time (to, &info->size, &info->time);\n+  estimate_calls_size_and_time (to, &info->size, &info->time,\n+\t\t\t\t~(clause_t)(1 << predicate_false_condition));\n \n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n@@ -1602,15 +1766,38 @@ inline_generate_summary (void)\n }\n \n \n+/* Read predicate from IB.  */\n+\n+static struct predicate\n+read_predicate (struct lto_input_block *ib)\n+{\n+  struct predicate out;\n+  clause_t clause;\n+  int k = 0;\n+\n+  do \n+    {\n+      clause = out.clause[k++] = lto_input_uleb128 (ib);\n+      gcc_assert (k < MAX_CLAUSES);\n+    }\n+  while (clause);\n+  return out;\n+}\n+\n+\n /* Write inline summary for edge E to OB.  */\n \n static void\n read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n+  struct predicate p;\n+\n   es->call_stmt_size = lto_input_uleb128 (ib);\n   es->call_stmt_time = lto_input_uleb128 (ib);\n   es->loop_depth = lto_input_uleb128 (ib);\n+  p = read_predicate (ib);\n+  edge_set_predicate (e, &p);\n }\n \n \n@@ -1675,17 +1862,10 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       for (j = 0; j < count2; j++)\n \t{\n \t  struct size_time_entry e;\n-\t  clause_t clause;\n-\t  int k = 0;\n \n \t  e.size = lto_input_uleb128 (&ib);\n \t  e.time = lto_input_uleb128 (&ib);\n-\t  do \n-\t    {\n-\t      clause = e.predicate.clause[k++] = lto_input_uleb128 (&ib);\n-\t      gcc_assert (k < MAX_CLAUSES);\n-\t    }\n-\t  while (clause);\n+\t  e.predicate = read_predicate (&ib);\n \n \t  VEC_safe_push (size_time_entry, gc, info->entry, &e);\n \t}\n@@ -1736,6 +1916,24 @@ inline_read_summary (void)\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n }\n \n+\n+/* Write predicate P to OB.  */\n+\n+static void\n+write_predicate (struct output_block *ob, struct predicate *p)\n+{\n+  int j;\n+  if (p)\n+    for (j = 0; p->clause[j]; j++)\n+      {\n+\t gcc_assert (j < MAX_CLAUSES);\n+\t lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t    p->clause[j]);\n+      }\n+  lto_output_uleb128_stream (ob->main_stream, 0);\n+}\n+\n+\n /* Write inline summary for edge E to OB.  */\n \n static void\n@@ -1745,6 +1943,7 @@ write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n   lto_output_uleb128_stream (ob->main_stream, es->call_stmt_size);\n   lto_output_uleb128_stream (ob->main_stream, es->call_stmt_time);\n   lto_output_uleb128_stream (ob->main_stream, es->loop_depth);\n+  write_predicate (ob, es->predicate);\n }\n \n \n@@ -1808,18 +2007,11 @@ inline_write_summary (cgraph_node_set set,\n \t       VEC_iterate (size_time_entry, info->entry, i, e);\n \t       i++)\n \t    {\n-\t      int j;\n \t      lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t\t e->size);\n \t      lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t\t e->time);\n-\t      for (j = 0; e->predicate.clause[j]; j++)\n-\t\t{\n-\t\t   gcc_assert (j < MAX_CLAUSES);\n-\t\t   lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t\t      e->predicate.clause[j]);\n-\t\t}\n-\t      lto_output_uleb128_stream (ob->main_stream, 0);\n+\t      write_predicate (ob, &e->predicate);\n \t    }\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    write_inline_edge_summary (ob, edge);\n@@ -1856,4 +2048,9 @@ inline_free_summary (void)\n   node_duplication_hook_holder = NULL;\n   VEC_free (inline_summary_t, gc, inline_summary_vec);\n   inline_summary_vec = NULL;\n+  VEC_free (inline_edge_summary_t, heap, inline_edge_summary_vec);\n+  inline_edge_summary_vec = NULL;\n+  if (edge_predicate_pool)\n+    free_alloc_pool (edge_predicate_pool);\n+  edge_predicate_pool = 0;\n }"}, {"sha": "8281d07ae50a911c404825820344fa6878094afc", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=991278ab90aa132805caaf3f2b6394348c850160", "patch": "@@ -120,6 +120,7 @@ struct inline_edge_summary\n   int call_stmt_time;\n   /* Depth of loop nest, 0 means no nesting.  */\n   unsigned short int loop_depth;\n+  struct predicate *predicate;\n };\n \n typedef struct inline_edge_summary inline_edge_summary_t;"}, {"sha": "a99f1c423ba96d5c9ee8d5a4c7c8428a89b2d7d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=991278ab90aa132805caaf3f2b6394348c850160", "patch": "@@ -1,3 +1,7 @@\n+2011-04-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/inline-9.c: New testcase.\n+\n 2011-04-27  Jason Merrill  <jason@redhat.com>\n \n \t* g++.old-deja/g++.oliva/overload1.C: Adjust."}, {"sha": "812b4b01140a381009e6ab718a82d505f873920b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/inline-9.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991278ab90aa132805caaf3f2b6394348c850160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-9.c?ref=991278ab90aa132805caaf3f2b6394348c850160", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fdump-tree-optimized\" } */\n+\n+/* When optimizing for size, t should be inlined when it expands to one call only.  */\n+extern int q(int);\n+int t(int a)\n+{\n+  if (a > 12)\n+    {\n+      q(a+5);\n+      q(a+5);\n+    }\n+  else\n+      q(a+10);\n+}\n+\n+main()\n+{\n+   t(5);\n+   t(20);\n+}\n+/* { dg-final { scan-tree-dump-times \"q \\\\(15\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"t \\\\(20\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}