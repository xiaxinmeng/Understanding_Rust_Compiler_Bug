{"sha": "bbaab9162a854dd2225f38cb42e0c3666a9462ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJhYWI5MTYyYTg1NGRkMjIyNWYzOGNiNDJlMGMzNjY2YTk0NjJlYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-01-25T18:02:43Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-01-25T18:02:43Z"}, "message": "re PR c++/9403 (parse error on template keyword used for disambiguation)\n\ncp:\n\tPR c++/9403\n\t* parser.c (cp_parser_class_or_namespace_name): Reject duplicate\n\ttemplate keyword.\n\t(cp_parser_base_specifier): Look for and consume a\n\tTEMPLATE keyword. Replace switch with array index.\n\n\tPR c++/795\n\t* semantics.c (finish_non_static_data_member): Remember the\n\tfield's type even in a template.\n\n\tPR c++/9415\n\t* pt.c (tsubst_copy_and_build, CALL_EXPR): BASELINK exprs are\n\talready scoped.\n\n\tPR c++/8545\n\t* parser.c (cp_parser_cast_expression): Be more tentative.\ntestsuite:\n\tPR c++/9403\n\t* g++.dg/parse/template3.C: New test.\n\t* g++.old-deja/g++.pt/memclass5.C: Add needed template keyword.\n\n\tPR c++/795\n\t* g++.dg/parse/template4.C: New test.\n\n\tPR c++/9415\n\t* g++.dg/template/qual2.C: New test.\n\n\tPR c++/8545\n\t* g++.old-deja/g++.brendan/parse3.C: Remove XFAIL.\n\n\t* g++.old-deja/g++.ns/bogus1.C: Change expected error.\n\nFrom-SVN: r61791", "tree": {"sha": "bbea47d7b8e0183a5f7884bf430c0c75e59768f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbea47d7b8e0183a5f7884bf430c0c75e59768f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbaab9162a854dd2225f38cb42e0c3666a9462ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbaab9162a854dd2225f38cb42e0c3666a9462ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbaab9162a854dd2225f38cb42e0c3666a9462ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbaab9162a854dd2225f38cb42e0c3666a9462ec/comments", "author": null, "committer": null, "parents": [{"sha": "8324663fcbeb40a837e46fa65d1252124345d565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8324663fcbeb40a837e46fa65d1252124345d565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8324663fcbeb40a837e46fa65d1252124345d565"}], "stats": {"total": 224, "additions": 150, "deletions": 74}, "files": [{"sha": "fe8898f28d6997a21be5279f919ffc151a854dc4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -1,3 +1,22 @@\n+2003-01-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9403\n+\t* parser.c (cp_parser_class_or_namespace_name): Reject duplicate\n+\ttemplate keyword.\n+\t(cp_parser_base_specifier): Look for and consume a\n+\tTEMPLATE keyword. Replace switch with array index.\n+\n+\tPR c++/795\n+\t* semantics.c (finish_non_static_data_member): Remember the\n+\tfield's type even in a template.\n+\n+\tPR c++/9415\n+\t* pt.c (tsubst_copy_and_build, CALL_EXPR): BASELINK exprs are\n+\talready scoped.\n+\t\n+\tPR c++/8545\n+\t* parser.c (cp_parser_cast_expression): Be more tentative.\n+\n 2003-01-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* cp-tree.h (flagged_type_tree_s): Remove."}, {"sha": "7e172abd55580bb51e1fc4a440e5ea0395b0fd4b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 26, "deletions": 59, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -3392,16 +3392,6 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n   tree scope;\n   bool only_class_p;\n \n-  /* If the next token is the `template' keyword, we know that we are\n-     looking at a class-name.  */\n-  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TEMPLATE))\n-    return cp_parser_class_name (parser, \n-\t\t\t\t typename_keyword_p,\n-\t\t\t\t template_keyword_p,\n-\t\t\t\t type_p,\n-\t\t\t\t /*check_access_p=*/true,\n-\t\t\t\t check_dependency_p,\n-\t\t\t\t /*class_head_p=*/false);\n   /* Before we try to parse the class-name, we must save away the\n      current PARSER->SCOPE since cp_parser_class_name will destroy\n      it.  */\n@@ -3410,7 +3400,7 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n   saved_object_scope = parser->object_scope;\n   /* Try for a class-name first.  If the SAVED_SCOPE is a type, then\n      there is no need to look for a namespace-name.  */\n-  only_class_p = saved_scope && TYPE_P (saved_scope);\n+  only_class_p = template_keyword_p || (saved_scope && TYPE_P (saved_scope));\n   if (!only_class_p)\n     cp_parser_parse_tentatively (parser);\n   scope = cp_parser_class_name (parser, \n@@ -3931,7 +3921,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t      postfix_expression = build_x_arrow (postfix_expression);\n \t    /* Check to see whether or not the expression is\n \t       type-dependent.  */\n-\t    dependent_p = (type_dependent_expression_p (postfix_expression));\n+\t    dependent_p = type_dependent_expression_p (postfix_expression);\n \t    /* The identifier following the `->' or `.' is not\n \t       qualified.  */\n \t    parser->scope = NULL_TREE;\n@@ -4761,23 +4751,26 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n       /* Restore the saved message.  */\n       parser->type_definition_forbidden_message = saved_message;\n \n-      /* If all went well, this is a cast.  */\n+      /* If ok so far, parse the dependent expression. We cannot be\n+         sure it is a cast. Consider `(T ())'.  It is a parenthesized\n+         ctor of T, but looks like a cast to function returning T\n+         without a dependent expression.  */\n+      if (!cp_parser_error_occurred (parser))\n+\texpr = cp_parser_cast_expression (parser, /*address_p=*/false);\n+\n       if (cp_parser_parse_definitely (parser))\n \t{\n-\t  /* Parse the dependent expression.  */\n-\t  expr = cp_parser_cast_expression (parser, /*address_p=*/false);\n \t  /* Warn about old-style casts, if so requested.  */\n \t  if (warn_old_style_cast \n \t      && !in_system_header \n \t      && !VOID_TYPE_P (type) \n \t      && current_lang_name != lang_name_c)\n \t    warning (\"use of old-style cast\");\n+\t  \n \t  /* Perform the cast.  */\n \t  expr = build_c_cast (type, expr);\n+\t  return expr;\n \t}\n-\n-      if (expr)\n-\treturn expr;\n     }\n \n   /* If we get here, then it's not a cast, so it must be a\n@@ -12175,12 +12168,20 @@ cp_parser_base_clause (cp_parser* parser)\n static tree\n cp_parser_base_specifier (cp_parser* parser)\n {\n+  static const tree *const access_nodes[][2] =\n+  {\n+    /* This ordering must match the access_kind enumeration.  */\n+    {&access_default_node,   &access_default_virtual_node},\n+    {&access_public_node,    &access_public_virtual_node},\n+    {&access_protected_node, &access_protected_virtual_node},\n+    {&access_private_node,   &access_private_virtual_node}\n+  };\n   cp_token *token;\n   bool done = false;\n   bool virtual_p = false;\n   bool duplicate_virtual_error_issued_p = false;\n   bool duplicate_access_error_issued_p = false;\n-  bool class_scope_p;\n+  bool class_scope_p, template_p;\n   access_kind access = ak_none;\n   tree access_node;\n   tree type;\n@@ -12236,45 +12237,9 @@ cp_parser_base_specifier (cp_parser* parser)\n \t}\n     }\n \n-  /* Map `virtual_p' and `access' onto one of the access \n-     tree-nodes.  */\n-  if (!virtual_p)\n-    switch (access)\n-      {\n-      case ak_none:\n-\taccess_node = access_default_node;\n-\tbreak;\n-      case ak_public:\n-\taccess_node = access_public_node;\n-\tbreak;\n-      case ak_protected:\n-\taccess_node = access_protected_node;\n-\tbreak;\n-      case ak_private:\n-\taccess_node = access_private_node;\n-\tbreak;\n-      default:\n-\tabort ();\n-      }\n-  else\n-    switch (access)\n-      {\n-      case ak_none:\n-\taccess_node = access_default_virtual_node;\n-\tbreak;\n-      case ak_public:\n-\taccess_node = access_public_virtual_node;\n-\tbreak;\n-      case ak_protected:\n-\taccess_node = access_protected_virtual_node;\n-\tbreak;\n-      case ak_private:\n-\taccess_node = access_private_virtual_node;\n-\tbreak;\n-      default:\n-\tabort ();\n-      }\n-\n+  /* Map `virtual_p' and `access' onto one of the access tree-nodes.  */\n+  access_node = *access_nodes[access][virtual_p];\n+  \n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n   /* Look for the nested-name-specifier.  The simplest way to\n@@ -12296,10 +12261,12 @@ cp_parser_base_specifier (cp_parser* parser)\n   /* If the base class is given by a qualified name, assume that names\n      we see are type names or templates, as appropriate.  */\n   class_scope_p = (parser->scope && TYPE_P (parser->scope));\n+  template_p = class_scope_p && cp_parser_optional_template_keyword (parser);\n+  \n   /* Finally, look for the class-name.  */\n   type = cp_parser_class_name (parser, \n \t\t\t       class_scope_p,\n-\t\t\t       class_scope_p,\n+\t\t\t       template_p,\n \t\t\t       /*type_p=*/true,\n \t\t\t       /*check_access=*/true,\n \t\t\t       /*check_dependency_p=*/true,"}, {"sha": "bbfec1483f083ca919bb5748002752c10a69b912", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -8129,28 +8129,32 @@ tsubst_copy_and_build (t, args, complain, in_decl)\n \n     case CALL_EXPR:\n       {\n-\ttree function\n-\t  = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\tif (TREE_CODE (function) == SCOPE_REF)\n+\ttree function, copy_args;\n+\n+\tfunction = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\tcopy_args = tsubst_copy_and_build (TREE_OPERAND (t, 1), args,\n+\t\t\t\t\t   complain, in_decl);\n+\t  \n+\tif (BASELINK_P (function))\n+\t  return build_call_from_tree (function, copy_args, 1);\n+\telse if (TREE_CODE (function) == SCOPE_REF)\n \t  {\n \t    tree name = TREE_OPERAND (function, 1);\n \t    if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n \t      name = build_nt (TEMPLATE_ID_EXPR,\n \t\t\t       TREE_OPERAND (name, 0),\n \t\t\t       TREE_OPERAND (name, 1));\n-\n-\t    return build_call_from_tree\n-\t      (resolve_scoped_fn_name (TREE_OPERAND (function, 0), name),\n-\t       tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t      in_decl),\n-\t       1);\n+\t    \n+\t    function = resolve_scoped_fn_name (TREE_OPERAND (function, 0),\n+\t\t\t\t\t       name);\n+\t    \n+\t    return build_call_from_tree (function, copy_args, 1);\n \t  }\n \telse\n \t  {\n \t    tree name = function;\n \t    tree id;\n-\t    tree copy_args = tsubst_copy_and_build\n-\t      (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\t    \n \t    if (copy_args != NULL_TREE && TREE_CODE (name) == LOOKUP_EXPR\n \t\t&& !LOOKUP_EXPR_GLOBAL (name)\n \t\t&& (TREE_CODE ((id = TREE_OPERAND (name, 0)))"}, {"sha": "fb6f25d116ffb63d1d0af57afc8c19fca02e9f04", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -1214,7 +1214,8 @@ finish_non_static_data_member (tree decl, tree qualifying_scope)\n     }\n   TREE_USED (current_class_ptr) = 1;\n   if (processing_template_decl)\n-    return build_min_nt (COMPONENT_REF, current_class_ref, DECL_NAME (decl));\n+    return build_min (COMPONENT_REF, TREE_TYPE (decl),\n+\t\t      current_class_ref, DECL_NAME (decl));\n   else\n     {\n       tree access_type = current_class_type;"}, {"sha": "7c331f1a98a167440450e539a048b6248cf421e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -1,3 +1,20 @@\n+2003-01-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9403\n+\t* g++.dg/parse/template3.C: New test.\n+\t* g++.old-deja/g++.pt/memclass5.C: Add needed template keyword.\n+\t\n+\tPR c++/795\n+\t* g++.dg/parse/template4.C: New test.\n+\t\n+\tPR c++/9415\n+\t* g++.dg/template/qual2.C: New test.\n+\t\n+\tPR c++/8545\n+\t* g++.old-deja/g++.brendan/parse3.C: Remove XFAIL.\n+\n+\t* g++.old-deja/g++.ns/bogus1.C: Change expected error.\n+\n 2003-01-25  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.c-torture/execute/switch-1.c: New test case."}, {"sha": "290721eaa53c1ed9979c561da0c24d9cc4827a63", "filename": "gcc/testsuite/g++.dg/parse/template3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate3.C?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 24 Jan 2003 <nathan@codesourcery.com>\n+\n+// PR 9403. We failed to parse template keyword, and we accepted code\n+// which required one.\n+\n+template<bool> struct Outer;\n+\n+template <bool b, typename T>\n+struct X : Outer<b>::template Inner<T>\n+{};\n+\n+template <bool b, typename T>\n+struct Y : Outer<b>::Inner<T> {}; // { dg-error \"\" \"\" }\n+"}, {"sha": "11f11d53525a8b7c2467480a0b6fbbf652b92ad6", "filename": "gcc/testsuite/g++.dg/parse/template4.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate4.C?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 32 Jan 2003 <nathan@codesourcery.com>\n+\n+// PR 795. fields are not necessarily a dependent type.\n+\n+struct V\n+{\n+  template<typename T> T get ();\n+};\n+\n+struct L\n+{\n+  V v;\n+  \n+  template<typename T> T at (int i)\n+  {\n+    return v.get<T> ();\n+  }\n+};"}, {"sha": "aa6b10ea4a5bae865b0be8b2f0de44fc9d5896f8", "filename": "gcc/testsuite/g++.dg/template/qual2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqual2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqual2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqual2.C?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 23 Jan 2003 <nathan@codesourcery.com>\n+\n+// PR9415. Forgot a lookup was scoped\n+\n+int here;\n+int there;\n+\n+struct B\n+{\n+  virtual int activate() {return !here++;}\n+};\n+\n+template <class K>\n+struct TPL : public B\n+{\n+  int activate()\n+  {\n+    return !there++ && B::activate();\n+  }\n+};\n+\n+int main ()\n+{\n+  TPL<int> i;\n+  return !i.activate ();\n+}"}, {"sha": "ffe72d2a38aa8bd914cef5b6b0d62cef105a6ccb", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/parse3.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fparse3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fparse3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fparse3.C?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -6,6 +6,7 @@\n // when the parser's been cleaned up or rewritten, these two error\n // markers can go away, since they'll no longer occur.\n \n+// Fixed. PR 8545, 2001 01 23\n class A\n {\n   public:\n@@ -19,5 +20,5 @@ A A::operator+(const A in)\n     if (high==0)\n       return A();    // this works\n     else\n-      return (A());  // this works not // gets bogus error - XFAIL *-*-* \n+      return (A());  // this works not\n }"}, {"sha": "373688a99c3a053fd2dbb18f64be2b3c92488219", "filename": "gcc/testsuite/g++.old-deja/g++.ns/bogus1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fbogus1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fbogus1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fbogus1.C?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -2,7 +2,7 @@\n \n namespace N {}\n \n-void f(int N::k); // ERROR - cannot use `::' in parameter declaration\n+void f(int N::k); // ERROR - \n \n class Foo\n {"}, {"sha": "5a0c037e7d2a6eedf2f71addbaa4af8e5da4e693", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbaab9162a854dd2225f38cb42e0c3666a9462ec/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass5.C?ref=bbaab9162a854dd2225f38cb42e0c3666a9462ec", "patch": "@@ -14,7 +14,7 @@ void f ()\n   b.A<T>::template B<U>::~B();\n }\n \n-template <class T> struct C: public A<T>::B<T> { };\n+template <class T> struct C: public A<T>::template B<T> { };\n   \n int main ()\n {"}]}