{"sha": "b0770c0f18133105bddbc841f435a7cb5ccf9747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA3NzBjMGYxODEzMzEwNWJkZGJjODQxZjQzNWE3Y2I1Y2NmOTc0Nw==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2015-08-13T11:28:42Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2015-08-13T11:28:42Z"}, "message": "* config/aarch64/aarch64-protos.h\n\t(aarch64_gen_atomic_cas): Declare.\n\t* config/aarch64/aarch64.c (aarch64_expand_compare_and_swap):\n\tChoose appropriate instruction pattern for the target.\n\t(aarch64_gen_atomic_cas): New.\n\t* config/aarch64/atomics.md (UNSPECV_ATOMIC_CAS): New.\n\t(atomic_compare_and_swap<mode>_1): Rename to\n\taarch64_compare_and_swap<mode>.  Fix some indentation.\n\t(aarch64_compare_and_swap<mode>_lse): New.\n\t(aarch64_atomic_cas<mode>): New.\n\nFrom-SVN: r226858", "tree": {"sha": "3bc09bb15618e9177907e536179a7f1bbec4a466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bc09bb15618e9177907e536179a7f1bbec4a466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0770c0f18133105bddbc841f435a7cb5ccf9747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0770c0f18133105bddbc841f435a7cb5ccf9747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0770c0f18133105bddbc841f435a7cb5ccf9747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0770c0f18133105bddbc841f435a7cb5ccf9747/comments", "author": null, "committer": null, "parents": [{"sha": "045c2d32d9f8c0338cfffb0152088447acaced5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/045c2d32d9f8c0338cfffb0152088447acaced5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/045c2d32d9f8c0338cfffb0152088447acaced5e"}], "stats": {"total": 197, "additions": 185, "deletions": 12}, "files": [{"sha": "7b80e3892f5c4f673db5f3af5a08e1c43b8bbd88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0770c0f18133105bddbc841f435a7cb5ccf9747", "patch": "@@ -1,3 +1,16 @@\n+2015-08-13  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_gen_atomic_cas): Declare.\n+\t* config/aarch64/aarch64.c (aarch64_expand_compare_and_swap):\n+\tChoose appropriate instruction pattern for the target.\n+\t(aarch64_gen_atomic_cas): New.\n+\t* config/aarch64/atomics.md (UNSPECV_ATOMIC_CAS): New.\n+\t(atomic_compare_and_swap<mode>_1): Rename to\n+\taarch64_compare_and_swap<mode>.  Fix some indentation.\n+\t(aarch64_compare_and_swap<mode>_lse): New.\n+\t(aarch64_atomic_cas<mode>): New.\n+\n 2015-08-13  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* config/aarch64/aarch64.h (AARCH64_ISA_LSE): New."}, {"sha": "0b09d49f6702c7734c05c907788d4e2231701355", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=b0770c0f18133105bddbc841f435a7cb5ccf9747", "patch": "@@ -362,6 +362,7 @@ rtx aarch64_load_tp (rtx);\n \n void aarch64_expand_compare_and_swap (rtx op[]);\n void aarch64_split_compare_and_swap (rtx op[]);\n+void aarch64_gen_atomic_cas (rtx, rtx, rtx, rtx, rtx);\n void aarch64_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx, rtx);\n \n bool aarch64_gen_adjusted_ldpstp (rtx *, bool, enum machine_mode, RTX_CODE);"}, {"sha": "aa268aeff4db26b621de6069b6b34be956003a74", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b0770c0f18133105bddbc841f435a7cb5ccf9747", "patch": "@@ -10754,7 +10754,23 @@ aarch64_expand_compare_and_swap (rtx operands[])\n {\n   rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n   machine_mode mode, cmp_mode;\n-  rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx (*gen_cas_fn) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  int idx;\n+  gen_cas_fn gen;\n+  const gen_cas_fn split_cas[] =\n+  {\n+    gen_aarch64_compare_and_swapqi,\n+    gen_aarch64_compare_and_swaphi,\n+    gen_aarch64_compare_and_swapsi,\n+    gen_aarch64_compare_and_swapdi\n+  };\n+  const gen_cas_fn atomic_cas[] =\n+  {\n+    gen_aarch64_compare_and_swapqi_lse,\n+    gen_aarch64_compare_and_swaphi_lse,\n+    gen_aarch64_compare_and_swapsi_lse,\n+    gen_aarch64_compare_and_swapdi_lse\n+  };\n \n   bval = operands[0];\n   rval = operands[1];\n@@ -10799,13 +10815,17 @@ aarch64_expand_compare_and_swap (rtx operands[])\n \n   switch (mode)\n     {\n-    case QImode: gen = gen_atomic_compare_and_swapqi_1; break;\n-    case HImode: gen = gen_atomic_compare_and_swaphi_1; break;\n-    case SImode: gen = gen_atomic_compare_and_swapsi_1; break;\n-    case DImode: gen = gen_atomic_compare_and_swapdi_1; break;\n+    case QImode: idx = 0; break;\n+    case HImode: idx = 1; break;\n+    case SImode: idx = 2; break;\n+    case DImode: idx = 3; break;\n     default:\n       gcc_unreachable ();\n     }\n+  if (TARGET_LSE)\n+    gen = atomic_cas[idx];\n+  else\n+    gen = split_cas[idx];\n \n   emit_insn (gen (rval, mem, oldval, newval, is_weak, mod_s, mod_f));\n \n@@ -10834,6 +10854,42 @@ aarch64_emit_post_barrier (enum memmodel model)\n     }\n }\n \n+/* Emit an atomic compare-and-swap operation.  RVAL is the destination register\n+   for the data in memory.  EXPECTED is the value expected to be in memory.\n+   DESIRED is the value to store to memory.  MEM is the memory location.  MODEL\n+   is the memory ordering to use.  */\n+\n+void\n+aarch64_gen_atomic_cas (rtx rval, rtx mem,\n+\t\t\trtx expected, rtx desired,\n+\t\t\trtx model)\n+{\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n+  machine_mode mode;\n+\n+  mode = GET_MODE (mem);\n+\n+  switch (mode)\n+    {\n+    case QImode: gen = gen_aarch64_atomic_casqi; break;\n+    case HImode: gen = gen_aarch64_atomic_cashi; break;\n+    case SImode: gen = gen_aarch64_atomic_cassi; break;\n+    case DImode: gen = gen_aarch64_atomic_casdi; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Move the expected value into the CAS destination register.  */\n+  emit_insn (gen_rtx_SET (rval, expected));\n+\n+  /* Emit the CAS.  */\n+  emit_insn (gen (rval, mem, desired, model));\n+\n+  /* Compare the expected value with the value loaded by the CAS, to establish\n+     whether the swap was made.  */\n+  aarch64_gen_compare_reg (EQ, rval, expected);\n+}\n+\n /* Split a compare and swap pattern.  */\n \n void"}, {"sha": "7082f619696852ad28b0ad06335996efec2259a9", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 110, "deletions": 7, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0770c0f18133105bddbc841f435a7cb5ccf9747/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=b0770c0f18133105bddbc841f435a7cb5ccf9747", "patch": "@@ -26,6 +26,7 @@\n     UNSPECV_STL\t\t\t\t; Represent an atomic store or store-release.\n     UNSPECV_ATOMIC_CMPSW\t\t; Represent an atomic compare swap.\n     UNSPECV_ATOMIC_EXCHG\t\t; Represent an atomic exchange.\n+    UNSPECV_ATOMIC_CAS\t\t\t; Represent an atomic CAS.\n     UNSPECV_ATOMIC_OP\t\t\t; Represent an atomic operation.\n ])\n \n@@ -45,10 +46,10 @@\n   }\n )\n \n-(define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n+(define_insn_and_split \"aarch64_compare_and_swap<mode>\"\n   [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n-   (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t\t;; val out\n+   (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t   ;; val out\n     (zero_extend:SI\n       (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\"))) ;; memory\n    (set (match_dup 1)\n@@ -57,7 +58,7 @@\n        (match_operand:SHORT 3 \"register_operand\" \"r\")\t;; desired\n        (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n        (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n-       (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+       (match_operand:SI 6 \"const_int_operand\")]\t;; mod_f\n       UNSPECV_ATOMIC_CMPSW))\n    (clobber (match_scratch:SI 7 \"=&r\"))]\n   \"\"\n@@ -70,17 +71,17 @@\n   }\n )\n \n-(define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n+(define_insn_and_split \"aarch64_compare_and_swap<mode>\"\n   [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n     (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n    (set (match_operand:GPI 0 \"register_operand\" \"=&r\")\t\t;; val out\n-    (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\")) ;; memory\n+    (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\"))   ;; memory\n    (set (match_dup 1)\n     (unspec_volatile:GPI\n       [(match_operand:GPI 2 \"aarch64_plus_operand\" \"rI\")\t;; expect\n        (match_operand:GPI 3 \"register_operand\" \"r\")\t\t;; desired\n-       (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n-       (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n+       (match_operand:SI 4 \"const_int_operand\")\t\t\t;; is_weak\n+       (match_operand:SI 5 \"const_int_operand\")\t\t\t;; mod_s\n        (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n       UNSPECV_ATOMIC_CMPSW))\n    (clobber (match_scratch:SI 7 \"=&r\"))]\n@@ -94,6 +95,57 @@\n   }\n )\n \n+(define_insn_and_split \"aarch64_compare_and_swap<mode>_lse\"\n+  [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n+   (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t\t;; val out\n+    (zero_extend:SI\n+      (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\"))) ;; memory\n+   (set (match_dup 1)\n+    (unspec_volatile:SHORT\n+      [(match_operand:SI 2 \"aarch64_plus_operand\" \"rI\")\t;; expected\n+       (match_operand:SHORT 3 \"register_operand\" \"r\")\t;; desired\n+       (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n+       (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n+       (match_operand:SI 6 \"const_int_operand\")]\t;; mod_f\n+      UNSPECV_ATOMIC_CMPSW))]\n+  \"TARGET_LSE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_gen_atomic_cas (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3],\n+\t\t\t    operands[5]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"aarch64_compare_and_swap<mode>_lse\"\n+  [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n+   (set (match_operand:GPI 0 \"register_operand\" \"=&r\")\t\t;; val out\n+    (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\"))   ;; memory\n+   (set (match_dup 1)\n+    (unspec_volatile:GPI\n+      [(match_operand:GPI 2 \"aarch64_plus_operand\" \"rI\")\t;; expect\n+       (match_operand:GPI 3 \"register_operand\" \"r\")\t\t;; desired\n+       (match_operand:SI 4 \"const_int_operand\")\t\t\t;; is_weak\n+       (match_operand:SI 5 \"const_int_operand\")\t\t\t;; mod_s\n+       (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+      UNSPECV_ATOMIC_CMPSW))]\n+  \"TARGET_LSE \"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_gen_atomic_cas (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3],\n+\t\t\t    operands[5]);\n+    DONE;\n+  }\n+)\n+\n (define_insn_and_split \"atomic_exchange<mode>\"\n   [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\t\t;; output\n     (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\")) ;; memory\n@@ -370,3 +422,54 @@\n       return \"dmb\\\\tish\";\n   }\n )\n+\n+;; ARMv8.1 LSE instructions.\n+\n+;; Atomic compare-and-swap: HI and smaller modes.\n+\n+(define_insn \"aarch64_atomic_cas<mode>\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"+&r\")\t\t  ;; out\n+   (zero_extend:SI\n+    (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\")))  ;; memory.\n+  (set (match_dup 1)\n+   (unspec_volatile:SHORT\n+    [(match_dup 0)\n+     (match_operand:SHORT 2 \"register_operand\" \"r\")\t;; value.\n+     (match_operand:SI 3 \"const_int_operand\" \"\")]\t;; model.\n+    UNSPECV_ATOMIC_CAS))]\n+ \"TARGET_LSE && reload_completed\"\n+{\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+  if (is_mm_relaxed (model))\n+    return \"cas<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else if (is_mm_acquire (model) || is_mm_consume (model))\n+    return \"casa<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else if (is_mm_release (model))\n+    return \"casl<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else\n+    return \"casal<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+})\n+\n+;; Atomic compare-and-swap: SI and larger modes.\n+\n+(define_insn \"aarch64_atomic_cas<mode>\"\n+ [(set (match_operand:GPI 0 \"register_operand\" \"+&r\")\t      ;; out\n+   (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\"))  ;; memory.\n+  (set (match_dup 1)\n+   (unspec_volatile:GPI\n+    [(match_dup 0)\n+     (match_operand:GPI 2 \"register_operand\" \"r\")\t;; value.\n+     (match_operand:SI 3 \"const_int_operand\" \"\")]\t;; model.\n+    UNSPECV_ATOMIC_CAS))]\n+  \"TARGET_LSE && reload_completed\"\n+{\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+    if (is_mm_relaxed (model))\n+      return \"cas<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+    else if (is_mm_acquire (model) || is_mm_consume (model))\n+      return \"casa<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+    else if (is_mm_release (model))\n+      return \"casl<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+    else\n+      return \"casal<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+})"}]}