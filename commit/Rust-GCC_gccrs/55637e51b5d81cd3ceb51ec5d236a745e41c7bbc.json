{"sha": "55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU2MzdlNTFiNWQ4MWNkM2NlYjUxZWM1ZDIzNmE3NDVlNDFjN2JiYw==", "commit": {"author": {"name": "Lee Millward", "email": "lee.millward@gmail.com", "date": "2007-07-16T19:12:44Z"}, "committer": {"name": "Lee Millward", "email": "lmillward@gcc.gnu.org", "date": "2007-07-16T19:12:44Z"}, "message": "re PR fortran/32222 (ICE in gfc_trans_assignment_1)\n\n\tPR fortran/32222\n\tPR fortran/32238\n\tPR fortran/32242\t\n\t* trans-intrinsic.c (gfc_conv_intrinsic_function_args): Adjust\n\tto operate on a stack allocated array for the intrinsic arguments\n\tinstead of creating a TREE_LIST. Add two new parameters for the\n\tarray and the number of elements. Update all callers to allocate\n\tan array of the correct length to pass in. Update comment.\n\t(gfc_intrinsic_argument_list_length): New function.\n\t(gfc_conv_intrinsic_conversion): Call it.\n\t(gfc_conv_intrinsic_mnimax): Likewise.\n\t(gfc_conv_intrinsic_merge): Likewise.\n\t(gfc_conv_intrinsic_lib_function): Call it. Use new CALL_EXPR\n\tconstructors.\n\t(gfc_conv_intrinsic_cmplx): Likewise.\n\t(gfc_conv_intrinsic_ctime): Likewise.\n\t(gfc_covn_intrinsic_fdate): Likewise.\n\t(gfc_conv_intrinsic_ttynam): Likewise.\n\t(gfc_conv_intrinsic_ishftc): Likewise.\n\t(gfc_conv_intrinsic_index): Likewise.\n\t(gfc_conv_intrinsic_scan): Likewise.\n\t(gfc_conv_intrinsic_verify): Likewise.\n\t(gfc_conv_intrinsic_trim): Likewise.\n\t(gfc_conv_intrinsic_aint): Use new CALL_EXPR constructors.\n\t(gfc_conv_intrinsic_exponent): Likewise.\n\t(gfc_conv_intrinsic_bound): Likewise.\n\t(gfc_conv_intrinsic_abs): Likewise.\n\t(gfc_conv_intrinsic_mod): Likewise.\n\t(gfc_conv_intrinsic_sign): Likewise.\n\t(gfc_conv_intrinsic_len): Likewise.\n\t(gfc_conv_intrinsic_adjust): Likewise.\n\t(gfc_conv_intrinsic_si_kind): Likewise. \n\n\t* gfortran.dg/cmplx_intrinsic_1.f90: New test.\n\n\tPR fortran/32238\n\t* gfortran.dg/pr32238.f90: New test.\n\n\tPR fortran/32222\n\t* gfortran.dg/pr32222.f90: New test.\n\n\tPR fortran/32242\n\t* gfortran.dg/pr32242.f90: New test.\n\nFrom-SVN: r126689", "tree": {"sha": "5374b6beff2b442a1f414fcd12122025a91ccdf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5374b6beff2b442a1f414fcd12122025a91ccdf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/comments", "author": {"login": "lee-m", "id": 1028098, "node_id": "MDQ6VXNlcjEwMjgwOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1028098?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lee-m", "html_url": "https://github.com/lee-m", "followers_url": "https://api.github.com/users/lee-m/followers", "following_url": "https://api.github.com/users/lee-m/following{/other_user}", "gists_url": "https://api.github.com/users/lee-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/lee-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lee-m/subscriptions", "organizations_url": "https://api.github.com/users/lee-m/orgs", "repos_url": "https://api.github.com/users/lee-m/repos", "events_url": "https://api.github.com/users/lee-m/events{/privacy}", "received_events_url": "https://api.github.com/users/lee-m/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d56b9f12225da2bdee2c3b2b5da3a1482784ce36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56b9f12225da2bdee2c3b2b5da3a1482784ce36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d56b9f12225da2bdee2c3b2b5da3a1482784ce36"}], "stats": {"total": 779, "additions": 469, "deletions": 310}, "files": [{"sha": "f88667cf0b8a4fa21821e28f081794962d04c08c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "patch": "@@ -1,3 +1,38 @@\n+2007-07-16  Lee Millward  <lee.millward@gmail.com>\n+\n+\tPR fortran/32222\n+\tPR fortran/32238\n+\tPR fortran/32242\t\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_function_args): Adjust\n+\tto operate on a stack allocated array for the intrinsic arguments\n+\tinstead of creating a TREE_LIST. Add two new parameters for the\n+\tarray and the number of elements. Update all callers to allocate\n+\tan array of the correct length to pass in. Update comment.\n+\t(gfc_intrinsic_argument_list_length): New function.\n+\t(gfc_conv_intrinsic_conversion): Call it.\n+\t(gfc_conv_intrinsic_mnimax): Likewise.\n+\t(gfc_conv_intrinsic_merge): Likewise.\n+\t(gfc_conv_intrinsic_lib_function): Call it. Use new CALL_EXPR\n+\tconstructors.\n+\t(gfc_conv_intrinsic_cmplx): Likewise.\n+\t(gfc_conv_intrinsic_ctime): Likewise.\n+\t(gfc_covn_intrinsic_fdate): Likewise.\n+\t(gfc_conv_intrinsic_ttynam): Likewise.\n+\t(gfc_conv_intrinsic_ishftc): Likewise.\n+\t(gfc_conv_intrinsic_index): Likewise.\n+\t(gfc_conv_intrinsic_scan): Likewise.\n+\t(gfc_conv_intrinsic_verify): Likewise.\n+\t(gfc_conv_intrinsic_trim): Likewise.\n+\t(gfc_conv_intrinsic_aint): Use new CALL_EXPR constructors.\n+\t(gfc_conv_intrinsic_exponent): Likewise.\n+\t(gfc_conv_intrinsic_bound): Likewise.\n+\t(gfc_conv_intrinsic_abs): Likewise.\n+\t(gfc_conv_intrinsic_mod): Likewise.\n+\t(gfc_conv_intrinsic_sign): Likewise.\n+\t(gfc_conv_intrinsic_len): Likewise.\n+\t(gfc_conv_intrinsic_adjust): Likewise.\n+\t(gfc_conv_intrinsic_si_kind): Likewise. \n+\t\n 2007-07-16  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/32748"}, {"sha": "e1383f65fb50e982081007de2fbdfff077df50f2", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 326, "deletions": 310, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "patch": "@@ -163,29 +163,36 @@ real_compnt_info;\n \n enum rounding_mode { RND_ROUND, RND_TRUNC, RND_CEIL, RND_FLOOR };\n \n-/* Evaluate the arguments to an intrinsic function.  */\n-/* FIXME: This function and its callers should be rewritten so that it's\n-   not necessary to cons up a list to hold the arguments.  */\n+/* Evaluate the arguments to an intrinsic function.  The value\n+   of NARGS may be less than the actual number of arguments in EXPR\n+   to allow optional \"KIND\" arguments that are not included in the\n+   generated code to be ignored.  */\n \n-static tree\n-gfc_conv_intrinsic_function_args (gfc_se * se, gfc_expr * expr)\n+static void\n+gfc_conv_intrinsic_function_args (gfc_se *se, gfc_expr *expr,\n+\t\t\t\t  tree *argarray, int nargs)\n {\n   gfc_actual_arglist *actual;\n   gfc_expr *e;\n   gfc_intrinsic_arg  *formal;\n   gfc_se argse;\n-  tree args;\n+  int curr_arg;\n \n-  args = NULL_TREE;\n   formal = expr->value.function.isym->formal;\n+  actual = expr->value.function.actual;\n \n-  for (actual = expr->value.function.actual; actual; actual = actual->next,\n-       formal = formal ? formal->next : NULL)\n+   for (curr_arg = 0; curr_arg < nargs; curr_arg++,\n+\tactual = actual->next,\n+\tformal = formal ? formal->next : NULL)\n     {\n+      gcc_assert (actual);\n       e = actual->expr;\n       /* Skip omitted optional arguments.  */\n       if (!e)\n-\tcontinue;\n+\t{\n+\t  --curr_arg;\n+\t  continue;\n+\t}\n \n       /* Evaluate the parameter.  This will substitute scalarized\n          references automatically.  */\n@@ -195,7 +202,8 @@ gfc_conv_intrinsic_function_args (gfc_se * se, gfc_expr * expr)\n \t{\n \t  gfc_conv_expr (&argse, e);\n \t  gfc_conv_string_parameter (&argse);\n-\t  args = gfc_chainon_list (args, argse.string_length);\n+          argarray[curr_arg++] = argse.string_length;\n+\t  gcc_assert (curr_arg < nargs);\n \t}\n       else\n         gfc_conv_expr_val (&argse, e);\n@@ -210,9 +218,31 @@ gfc_conv_intrinsic_function_args (gfc_se * se, gfc_expr * expr)\n \n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);\n-      args = gfc_chainon_list (args, argse.expr);\n+      argarray[curr_arg] = argse.expr;\n+    }\n+}\n+\n+/* Count the number of actual arguments to the intrinsic function EXPR\n+   including any \"hidden\" string length arguments.  */\n+\n+static unsigned int\n+gfc_intrinsic_argument_list_length (gfc_expr *expr)\n+{\n+  int n = 0;\n+  gfc_actual_arglist *actual;\n+\n+  for (actual = expr->value.function.actual; actual; actual = actual->next)\n+    {\n+      if (!actual->expr)\n+\tcontinue;\n+\n+      if (actual->expr->ts.type == BT_CHARACTER)\n+\tn += 2;\n+      else\n+\tn++;\n     }\n-  return args;\n+\n+  return n;\n }\n \n \n@@ -223,26 +253,31 @@ static void\n gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n {\n   tree type;\n-  tree arg;\n+  tree *args;\n+  int nargs;\n \n-  /* Evaluate the argument.  */\n+  nargs = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * nargs);\n+\n+  /* Evaluate all the arguments passed. Whilst we're only interested in the \n+     first one here, there are other parts of the front-end that assume this \n+     and will trigger an ICE if it's not the case.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n   gcc_assert (expr->value.function.actual->expr);\n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg = TREE_VALUE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, nargs);\n \n   /* Conversion from complex to non-complex involves taking the real\n      component of the value.  */\n-  if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE\n+  if (TREE_CODE (TREE_TYPE (args[0])) == COMPLEX_TYPE\n       && expr->ts.type != BT_COMPLEX)\n     {\n       tree artype;\n \n-      artype = TREE_TYPE (TREE_TYPE (arg));\n-      arg = build1 (REALPART_EXPR, artype, arg);\n+      artype = TREE_TYPE (TREE_TYPE (args[0]));\n+      args[0] = build1 (REALPART_EXPR, artype, args[0]);\n     }\n \n-  se->expr = convert (type, arg);\n+  se->expr = convert (type, args[0]);\n }\n \n /* This is needed because the gcc backend only implements\n@@ -402,20 +437,19 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n \n   /* Evaluate the argument.  */\n   gcc_assert (expr->value.function.actual->expr);\n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   /* Use a builtin function if one exists.  */\n   if (n != END_BUILTINS)\n     {\n       tmp = built_in_decls[n];\n-      se->expr = build_function_call_expr (tmp, arg);\n+      se->expr = build_call_expr (tmp, 1, arg);\n       return;\n     }\n \n   /* This code is probably redundant, but we'll keep it lying around just\n      in case.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n-  arg = TREE_VALUE (arg);\n   arg = gfc_evaluate_now (arg, &se->pre);\n \n   /* Test if the value is too large to handle sensibly.  */\n@@ -450,8 +484,7 @@ gfc_conv_intrinsic_int (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   /* Evaluate the argument.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n   gcc_assert (expr->value.function.actual->expr);\n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg = TREE_VALUE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   if (TREE_CODE (TREE_TYPE (arg)) == INTEGER_TYPE)\n     {\n@@ -483,8 +516,7 @@ gfc_conv_intrinsic_imagpart (gfc_se * se, gfc_expr * expr)\n {\n   tree arg;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg = TREE_VALUE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   se->expr = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n }\n \n@@ -496,8 +528,7 @@ gfc_conv_intrinsic_conjg (gfc_se * se, gfc_expr * expr)\n {\n   tree arg;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg = TREE_VALUE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   se->expr = build1 (CONJ_EXPR, TREE_TYPE (arg), arg);\n }\n \n@@ -647,8 +678,10 @@ static void\n gfc_conv_intrinsic_lib_function (gfc_se * se, gfc_expr * expr)\n {\n   gfc_intrinsic_map_t *m;\n-  tree args;\n   tree fndecl;\n+  tree rettype;\n+  tree *args;\n+  unsigned int num_args;\n   gfc_isym_id id;\n \n   id = expr->value.function.isym->id;\n@@ -666,20 +699,26 @@ gfc_conv_intrinsic_lib_function (gfc_se * se, gfc_expr * expr)\n     }\n \n   /* Get the decl and generate the call.  */\n-  args = gfc_conv_intrinsic_function_args (se, expr);\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * num_args);\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n   fndecl = gfc_get_intrinsic_lib_fndecl (m, expr);\n-  se->expr = build_function_call_expr (fndecl, args);\n+  rettype = TREE_TYPE (TREE_TYPE (fndecl));\n+\n+  fndecl = build_addr (fndecl, current_function_decl);\n+  se->expr = build_call_array (rettype, fndecl, num_args, args);\n }\n \n /* Generate code for EXPONENT(X) intrinsic function.  */\n \n static void\n gfc_conv_intrinsic_exponent (gfc_se * se, gfc_expr * expr)\n {\n-  tree args, fndecl;\n+  tree arg, fndecl;\n   gfc_expr *a1;\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   a1 = expr->value.function.actual->expr;\n   switch (a1->ts.kind)\n@@ -700,7 +739,7 @@ gfc_conv_intrinsic_exponent (gfc_se * se, gfc_expr * expr)\n       gcc_unreachable ();\n     }\n \n-  se->expr = build_function_call_expr (fndecl, args);\n+  se->expr = build_call_expr (fndecl, 1, arg);\n }\n \n /* Evaluate a single upper or lower bound.  */\n@@ -904,19 +943,16 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n static void\n gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n {\n-  tree args;\n-  tree val;\n+  tree arg;\n   int n;\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n-  gcc_assert (args && TREE_CHAIN (args) == NULL_TREE);\n-  val = TREE_VALUE (args);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   switch (expr->value.function.actual->expr->ts.type)\n     {\n     case BT_INTEGER:\n     case BT_REAL:\n-      se->expr = build1 (ABS_EXPR, TREE_TYPE (val), val);\n+      se->expr = build1 (ABS_EXPR, TREE_TYPE (arg), arg);\n       break;\n \n     case BT_COMPLEX:\n@@ -935,7 +971,7 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_function_call_expr (built_in_decls[n], args);\n+      se->expr = build_call_expr (built_in_decls[n], 1, arg);\n       break;\n \n     default:\n@@ -949,20 +985,23 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n {\n-  tree arg;\n   tree real;\n   tree imag;\n   tree type;\n+  tree *args;\n+  unsigned int num_args;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * num_args);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  real = convert (TREE_TYPE (type), TREE_VALUE (arg));\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  real = convert (TREE_TYPE (type), args[0]);\n   if (both)\n-    imag = convert (TREE_TYPE (type), TREE_VALUE (TREE_CHAIN (arg)));\n-  else if (TREE_CODE (TREE_TYPE (TREE_VALUE (arg))) == COMPLEX_TYPE)\n+    imag = convert (TREE_TYPE (type), args[1]);\n+  else if (TREE_CODE (TREE_TYPE (args[0])) == COMPLEX_TYPE)\n     {\n-      arg = TREE_VALUE (arg);\n-      imag = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+      imag = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (args[0])), args[0]);\n       imag = convert (TREE_TYPE (type), imag);\n     }\n   else\n@@ -978,30 +1017,27 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n static void\n gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n {\n-  tree arg;\n-  tree arg2;\n   tree type;\n   tree itype;\n   tree tmp;\n   tree test;\n   tree test2;\n   mpfr_t huge;\n   int n, ikind;\n+  tree args[2];\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n   switch (expr->ts.type)\n     {\n     case BT_INTEGER:\n       /* Integer case is easy, we've got a builtin op.  */\n-      arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-      arg = TREE_VALUE (arg);\n-      type = TREE_TYPE (arg);\n+      type = TREE_TYPE (args[0]);\n \n       if (modulo)\n-       se->expr = build2 (FLOOR_MOD_EXPR, type, arg, arg2);\n+       se->expr = build2 (FLOOR_MOD_EXPR, type, args[0], args[1]);\n       else\n-       se->expr = build2 (TRUNC_MOD_EXPR, type, arg, arg2);\n+       se->expr = build2 (TRUNC_MOD_EXPR, type, args[0], args[1]);\n       break;\n \n     case BT_REAL:\n@@ -1029,18 +1065,17 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       /* Use it if it exists.  */\n       if (n != END_BUILTINS)\n \t{\n-\t  tmp = built_in_decls[n];\n-\t  se->expr = build_function_call_expr (tmp, arg);\n+  \t  tmp = build_addr (built_in_decls[n], current_function_decl);\n+\t  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (built_in_decls[n])),\n+                                       tmp, 2, args);\n \t  if (modulo == 0)\n \t    return;\n \t}\n \n-      arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-      arg = TREE_VALUE (arg);\n-      type = TREE_TYPE (arg);\n+      type = TREE_TYPE (args[0]);\n \n-      arg = gfc_evaluate_now (arg, &se->pre);\n-      arg2 = gfc_evaluate_now (arg2, &se->pre);\n+      args[0] = gfc_evaluate_now (args[0], &se->pre);\n+      args[1] = gfc_evaluate_now (args[1], &se->pre);\n \n       /* Definition:\n \t modulo = arg - floor (arg/arg2) * arg2, so\n@@ -1053,20 +1088,20 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t{\n \t  tree zero = gfc_build_const (type, integer_zero_node);\n \t  tmp = gfc_evaluate_now (se->expr, &se->pre);\n-\t  test = build2 (LT_EXPR, boolean_type_node, arg, zero);\n-\t  test2 = build2 (LT_EXPR, boolean_type_node, arg2, zero);\n+\t  test = build2 (LT_EXPR, boolean_type_node, args[0], zero);\n+\t  test2 = build2 (LT_EXPR, boolean_type_node, args[1], zero);\n \t  test2 = build2 (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n \t  test = build2 (NE_EXPR, boolean_type_node, tmp, zero);\n \t  test = build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n \t  test = gfc_evaluate_now (test, &se->pre);\n \t  se->expr = build3 (COND_EXPR, type, test,\n-\t\t\t     build2 (PLUS_EXPR, type, tmp, arg2), tmp);\n+\t\t\t     build2 (PLUS_EXPR, type, tmp, args[1]), tmp);\n \t  return;\n \t}\n \n       /* If we do not have a built_in fmod, the calculation is going to\n \t have to be done longhand.  */\n-      tmp = build2 (RDIV_EXPR, type, arg, arg2);\n+      tmp = build2 (RDIV_EXPR, type, args[0], args[1]);\n \n       /* Test if the value is too large to handle sensibly.  */\n       gfc_set_model_kind (expr->ts.kind);\n@@ -1093,9 +1128,9 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       else\n        tmp = build_fix_expr (&se->pre, tmp, itype, RND_TRUNC);\n       tmp = convert (type, tmp);\n-      tmp = build3 (COND_EXPR, type, test2, tmp, arg);\n-      tmp = build2 (MULT_EXPR, type, tmp, arg2);\n-      se->expr = build2 (MINUS_EXPR, type, arg, tmp);\n+      tmp = build3 (COND_EXPR, type, test2, tmp, args[0]);\n+      tmp = build2 (MULT_EXPR, type, tmp, args[1]);\n+      se->expr = build2 (MINUS_EXPR, type, args[0], tmp);\n       mpfr_clear (huge);\n       break;\n \n@@ -1109,19 +1144,16 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n static void\n gfc_conv_intrinsic_dim (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n-  tree arg2;\n   tree val;\n   tree tmp;\n   tree type;\n   tree zero;\n+  tree args[2];\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n-  type = TREE_TYPE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  type = TREE_TYPE (args[0]);\n \n-  val = build2 (MINUS_EXPR, type, arg, arg2);\n+  val = build2 (MINUS_EXPR, type, args[0], args[1]);\n   val = gfc_evaluate_now (val, &se->pre);\n \n   zero = gfc_build_const (type, integer_zero_node);\n@@ -1140,11 +1172,10 @@ static void\n gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n {\n   tree tmp;\n-  tree arg;\n-  tree arg2;\n   tree type;\n+  tree args[2];\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   if (expr->ts.type == BT_REAL)\n     {\n       switch (expr->ts.kind)\n@@ -1162,30 +1193,28 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_function_call_expr (tmp, arg);\n+      se->expr = build_call_expr (tmp, 2, args[0], args[1]);\n       return;\n     }\n \n   /* Having excluded floating point types, we know we are now dealing\n      with signed integer types.  */\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n-  type = TREE_TYPE (arg);\n+  type = TREE_TYPE (args[0]);\n \n-  /* Arg is used multiple times below.  */\n-  arg = gfc_evaluate_now (arg, &se->pre);\n+  /* Args[0] is used multiple times below.  */\n+  args[0] = gfc_evaluate_now (args[0], &se->pre);\n \n   /* Construct (A ^ B) >> 31, which generates a bit mask of all zeros if\n      the signs of A and B are the same, and of all ones if they differ.  */\n-  tmp = fold_build2 (BIT_XOR_EXPR, type, arg, arg2);\n+  tmp = fold_build2 (BIT_XOR_EXPR, type, args[0], args[1]);\n   tmp = fold_build2 (RSHIFT_EXPR, type, tmp,\n \t\t     build_int_cst (type, TYPE_PRECISION (type) - 1));\n   tmp = gfc_evaluate_now (tmp, &se->pre);\n \n   /* Construct (A + tmp) ^ tmp, which is A if tmp is zero, and -A if tmp]\n      is all ones (i.e. -1).  */\n   se->expr = fold_build2 (BIT_XOR_EXPR, type,\n-\t\t\t  fold_build2 (PLUS_EXPR, type, arg, tmp),\n+\t\t\t  fold_build2 (PLUS_EXPR, type, args[0], tmp),\n \t\t\t  tmp);\n }\n \n@@ -1209,19 +1238,16 @@ gfc_conv_intrinsic_present (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_dprod (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n-  tree arg2;\n   tree type;\n+  tree args[2];\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n   /* Convert the args to double precision before multiplying.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n-  arg = convert (type, arg);\n-  arg2 = convert (type, arg2);\n-  se->expr = build2 (MULT_EXPR, type, arg, arg2);\n+  args[0] = convert (type, args[0]);\n+  args[1] = convert (type, args[1]);\n+  se->expr = build2 (MULT_EXPR, type, args[0], args[1]);\n }\n \n \n@@ -1234,8 +1260,7 @@ gfc_conv_intrinsic_char (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree type;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg = TREE_VALUE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   /* We currently don't support character types != 1.  */\n   gcc_assert (expr->ts.kind == 1);\n@@ -1255,21 +1280,27 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree len;\n   tree tmp;\n-  tree arglist;\n   tree type;\n   tree cond;\n   tree gfc_int8_type_node = gfc_get_int_type (8);\n+  tree fndecl;\n+  tree *args;\n+  unsigned int num_args;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n+  args = alloca (sizeof (tree) * num_args);\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   len = gfc_create_var (gfc_int8_type_node, \"len\");\n \n-  tmp = gfc_conv_intrinsic_function_args (se, expr);\n-  arglist = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (var));\n-  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n-  arglist = chainon (arglist, tmp);\n+  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n+  args[0] = build_fold_addr_expr (var);\n+  args[1] = build_fold_addr_expr (len);\n \n-  tmp = build_function_call_expr (gfor_fndecl_ctime, arglist);\n+  fndecl = build_addr (gfor_fndecl_ctime, current_function_decl);\n+  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ctime)),\n+\t\t\t  fndecl, num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -1290,21 +1321,27 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree len;\n   tree tmp;\n-  tree arglist;\n   tree type;\n   tree cond;\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n+  tree fndecl;\n+  tree *args;\n+  unsigned int num_args;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n+  args = alloca (sizeof (tree) * num_args);\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   len = gfc_create_var (gfc_int4_type_node, \"len\");\n \n-  tmp = gfc_conv_intrinsic_function_args (se, expr);\n-  arglist = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (var));\n-  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n-  arglist = chainon (arglist, tmp);\n+  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n+  args[0] = build_fold_addr_expr (var);\n+  args[1] = build_fold_addr_expr (len);\n \n-  tmp = build_function_call_expr (gfor_fndecl_fdate, arglist);\n+  fndecl = build_addr (gfor_fndecl_fdate, current_function_decl);\n+  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_fdate)),\n+\t\t\t  fndecl, num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -1327,21 +1364,27 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree len;\n   tree tmp;\n-  tree arglist;\n   tree type;\n   tree cond;\n+  tree fndecl;\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n+  tree *args;\n+  unsigned int num_args;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n+  args = alloca (sizeof (tree) * num_args);\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   len = gfc_create_var (gfc_int4_type_node, \"len\");\n \n-  tmp = gfc_conv_intrinsic_function_args (se, expr);\n-  arglist = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (var));\n-  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n-  arglist = chainon (arglist, tmp);\n+  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n+  args[0] = build_fold_addr_expr (var);\n+  args[1] = build_fold_addr_expr (len);\n \n-  tmp = build_function_call_expr (gfor_fndecl_ttynam, arglist);\n+  fndecl = build_addr (gfor_fndecl_ttynam, current_function_decl);\n+  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ttynam)),\n+\t\t\t  fndecl, num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -1381,52 +1424,54 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n   tree val;\n   tree thencase;\n   tree elsecase;\n-  tree arg, arg1, arg2;\n+  tree *args;\n   tree type;\n   gfc_actual_arglist *argexpr;\n   unsigned int i;\n+  unsigned int nargs;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg1 = TREE_VALUE (arg);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  nargs = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * nargs);\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, nargs);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n   /* The first and second arguments should be present, if they are\n      optional dummy arguments.  */\n   argexpr = expr->value.function.actual;\n   if (argexpr->expr->expr_type == EXPR_VARIABLE\n       && argexpr->expr->symtree->n.sym->attr.optional\n-      && TREE_CODE (arg1) == INDIRECT_REF)\n+      && TREE_CODE (args[0]) == INDIRECT_REF)\n     {\n       /* Check the first argument.  */\n       tree cond;\n       char *msg;\n \n       asprintf (&msg, \"First argument of '%s' intrinsic should be present\",\n \t\texpr->symtree->n.sym->name);\n-      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (arg1, 0),\n-\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (arg1, 0)), 0));\n+      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (args[0], 0),\n+\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (args[0], 0)), 0));\n       gfc_trans_runtime_check (cond, msg, &se->pre, &expr->where);\n       gfc_free (msg);\n     }\n \n   if (argexpr->next->expr->expr_type == EXPR_VARIABLE\n       && argexpr->next->expr->symtree->n.sym->attr.optional\n-      && TREE_CODE (arg2) == INDIRECT_REF)\n+      && TREE_CODE (args[1]) == INDIRECT_REF)\n     {\n       /* Check the second argument.  */\n       tree cond;\n       char *msg;\n \n       asprintf (&msg, \"Second argument of '%s' intrinsic should be present\",\n \t\texpr->symtree->n.sym->name);\n-      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (arg2, 0),\n-\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (arg2, 0)), 0));\n+      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (args[1], 0),\n+\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (args[1], 0)), 0));\n       gfc_trans_runtime_check (cond, msg, &se->pre, &expr->where);\n       gfc_free (msg);\n     }\n \n-  limit = TREE_VALUE (arg);\n+  limit = args[0];\n   if (TREE_TYPE (limit) != type)\n     limit = convert (type, limit);\n   /* Only evaluate the argument once.  */\n@@ -1435,12 +1480,11 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \n   mvar = gfc_create_var (type, \"M\");\n   elsecase = build2_v (MODIFY_EXPR, mvar, limit);\n-  for (arg = TREE_CHAIN (arg), i = 0, argexpr = argexpr->next;\n-       arg != NULL_TREE; arg = TREE_CHAIN (arg), i++)\n+  for (i = 1, argexpr = argexpr->next; i < nargs; i++)\n     {\n       tree cond;\n \n-      val = TREE_VALUE (arg);\n+      val = args[i]; \n \n       /* Handle absent optional arguments by ignoring the comparison.  */\n       if (i > 0 && argexpr->expr->expr_type == EXPR_VARIABLE\n@@ -2328,18 +2372,15 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n static void\n gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n-  tree arg2;\n+  tree args[2];\n   tree type;\n   tree tmp;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n-  type = TREE_TYPE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  type = TREE_TYPE (args[0]);\n \n-  tmp = build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), arg2);\n-  tmp = build2 (BIT_AND_EXPR, type, arg, tmp);\n+  tmp = build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n+  tmp = build2 (BIT_AND_EXPR, type, args[0], tmp);\n   tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n \t\t     build_int_cst (type, 0));\n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -2350,16 +2391,10 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_bitop (gfc_se * se, gfc_expr * expr, int op)\n {\n-  tree arg;\n-  tree arg2;\n-  tree type;\n-\n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n-  type = TREE_TYPE (arg);\n+  tree args[2];\n \n-  se->expr = fold_build2 (op, type, arg, arg2);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  se->expr = fold_build2 (op, TREE_TYPE (args[0]), args[0], args[1]);\n }\n \n /* Bitwise not.  */\n@@ -2368,62 +2403,51 @@ gfc_conv_intrinsic_not (gfc_se * se, gfc_expr * expr)\n {\n   tree arg;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg = TREE_VALUE (arg);\n-\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   se->expr = build1 (BIT_NOT_EXPR, TREE_TYPE (arg), arg);\n }\n \n /* Set or clear a single bit.  */\n static void\n gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n {\n-  tree arg;\n-  tree arg2;\n+  tree args[2];\n   tree type;\n   tree tmp;\n   int op;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n-  type = TREE_TYPE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  type = TREE_TYPE (args[0]);\n \n-  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), arg2);\n+  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n   if (set)\n     op = BIT_IOR_EXPR;\n   else\n     {\n       op = BIT_AND_EXPR;\n       tmp = fold_build1 (BIT_NOT_EXPR, type, tmp);\n     }\n-  se->expr = fold_build2 (op, type, arg, tmp);\n+  se->expr = fold_build2 (op, type, args[0], tmp);\n }\n \n /* Extract a sequence of bits.\n     IBITS(I, POS, LEN) = (I >> POS) & ~((~0) << LEN).  */\n static void\n gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n-  tree arg2;\n-  tree arg3;\n+  tree args[3];\n   tree type;\n   tree tmp;\n   tree mask;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_CHAIN (arg);\n-  arg3 = TREE_VALUE (TREE_CHAIN (arg2));\n-  arg = TREE_VALUE (arg);\n-  arg2 = TREE_VALUE (arg2);\n-  type = TREE_TYPE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 3);\n+  type = TREE_TYPE (args[0]);\n \n   mask = build_int_cst (type, -1);\n-  mask = build2 (LSHIFT_EXPR, type, mask, arg3);\n+  mask = build2 (LSHIFT_EXPR, type, mask, args[2]);\n   mask = build1 (BIT_NOT_EXPR, type, mask);\n \n-  tmp = build2 (RSHIFT_EXPR, type, arg, arg2);\n+  tmp = build2 (RSHIFT_EXPR, type, args[0], args[1]);\n \n   se->expr = fold_build2 (BIT_AND_EXPR, type, tmp, mask);\n }\n@@ -2433,15 +2457,12 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_rlshift (gfc_se * se, gfc_expr * expr, int right_shift)\n {\n-  tree arg;\n-  tree arg2;\n+  tree args[2];\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n   se->expr = fold_build2 (right_shift ? RSHIFT_EXPR : LSHIFT_EXPR,\n-\t\t\t  TREE_TYPE (arg), arg, arg2);\n+\t\t\t  TREE_TYPE (args[0]), args[0], args[1]);\n }\n \n /* ISHFT (I, SHIFT) = (abs (shift) >= BIT_SIZE (i))\n@@ -2451,8 +2472,7 @@ gfc_conv_intrinsic_rlshift (gfc_se * se, gfc_expr * expr, int right_shift)\n static void\n gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n-  tree arg2;\n+  tree args[2];\n   tree type;\n   tree utype;\n   tree tmp;\n@@ -2462,33 +2482,31 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   tree lshift;\n   tree rshift;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n-  arg = TREE_VALUE (arg);\n-  type = TREE_TYPE (arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  type = TREE_TYPE (args[0]);\n   utype = unsigned_type_for (type);\n \n-  width = fold_build1 (ABS_EXPR, TREE_TYPE (arg2), arg2);\n+  width = fold_build1 (ABS_EXPR, TREE_TYPE (args[1]), args[1]);\n \n   /* Left shift if positive.  */\n-  lshift = fold_build2 (LSHIFT_EXPR, type, arg, width);\n+  lshift = fold_build2 (LSHIFT_EXPR, type, args[0], width);\n \n   /* Right shift if negative.\n      We convert to an unsigned type because we want a logical shift.\n      The standard doesn't define the case of shifting negative\n      numbers, and we try to be compatible with other compilers, most\n      notably g77, here.  */\n   rshift = fold_convert (type, build2 (RSHIFT_EXPR, utype, \n-\t\t\t\t       convert (utype, arg), width));\n+\t\t\t\t       convert (utype, args[0]), width));\n \n-  tmp = fold_build2 (GE_EXPR, boolean_type_node, arg2,\n-\t\t     build_int_cst (TREE_TYPE (arg2), 0));\n+  tmp = fold_build2 (GE_EXPR, boolean_type_node, args[1],\n+\t\t     build_int_cst (TREE_TYPE (args[1]), 0));\n   tmp = fold_build3 (COND_EXPR, type, tmp, lshift, rshift);\n \n   /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n-  num_bits = build_int_cst (TREE_TYPE (arg2), TYPE_PRECISION (type));\n+  num_bits = build_int_cst (TREE_TYPE (args[0]), TYPE_PRECISION (type));\n   cond = fold_build2 (GE_EXPR, boolean_type_node, width, num_bits);\n \n   se->expr = fold_build3 (COND_EXPR, type, cond,\n@@ -2499,38 +2517,37 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n-  tree arg2;\n-  tree arg3;\n+  tree *args;\n   tree type;\n   tree tmp;\n   tree lrot;\n   tree rrot;\n   tree zero;\n+  unsigned int num_args;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_CHAIN (arg);\n-  arg3 = TREE_CHAIN (arg2);\n-  if (arg3)\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * num_args);\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+\n+  if (num_args == 3)\n     {\n       /* Use a library function for the 3 parameter version.  */\n       tree int4type = gfc_get_int_type (4);\n \n-      type = TREE_TYPE (TREE_VALUE (arg));\n+      type = TREE_TYPE (args[0]);\n       /* We convert the first argument to at least 4 bytes, and\n \t convert back afterwards.  This removes the need for library\n \t functions for all argument sizes, and function will be\n \t aligned to at least 32 bits, so there's no loss.  */\n       if (expr->ts.kind < 4)\n-\t{\n-\t  tmp = convert (int4type, TREE_VALUE (arg));\n-\t  TREE_VALUE (arg) = tmp;\n-\t}\n+\targs[0] = convert (int4type, args[0]);\n+\n       /* Convert the SHIFT and SIZE args to INTEGER*4 otherwise we would\n          need loads of library  functions.  They cannot have values >\n \t BIT_SIZE (I) so the conversion is safe.  */\n-      TREE_VALUE (arg2) = convert (int4type, TREE_VALUE (arg2));\n-      TREE_VALUE (arg3) = convert (int4type, TREE_VALUE (arg3));\n+      args[1] = convert (int4type, args[1]);\n+      args[2] = convert (int4type, args[2]);\n \n       switch (expr->ts.kind)\n \t{\n@@ -2548,32 +2565,30 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_function_call_expr (tmp, arg);\n+      se->expr = build_call_expr (tmp, 3, args[0], args[1], args[2]);\n       /* Convert the result back to the original type, if we extended\n \t the first argument's width above.  */\n       if (expr->ts.kind < 4)\n \tse->expr = convert (type, se->expr);\n \n       return;\n     }\n-  arg = TREE_VALUE (arg);\n-  arg2 = TREE_VALUE (arg2);\n-  type = TREE_TYPE (arg);\n+  type = TREE_TYPE (args[0]);\n \n   /* Rotate left if positive.  */\n-  lrot = fold_build2 (LROTATE_EXPR, type, arg, arg2);\n+  lrot = fold_build2 (LROTATE_EXPR, type, args[0], args[1]);\n \n   /* Rotate right if negative.  */\n-  tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n-  rrot = fold_build2 (RROTATE_EXPR, type, arg, tmp);\n+  tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (args[1]), args[1]);\n+  rrot = fold_build2 (RROTATE_EXPR, type, args[0], tmp);\n \n-  zero = build_int_cst (TREE_TYPE (arg2), 0);\n-  tmp = fold_build2 (GT_EXPR, boolean_type_node, arg2, zero);\n+  zero = build_int_cst (TREE_TYPE (args[1]), 0);\n+  tmp = fold_build2 (GT_EXPR, boolean_type_node, args[1], zero);\n   rrot = fold_build3 (COND_EXPR, type, tmp, lrot, rrot);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = fold_build2 (EQ_EXPR, boolean_type_node, arg2, zero);\n-  se->expr = fold_build3 (COND_EXPR, type, tmp, arg, rrot);\n+  tmp = fold_build2 (EQ_EXPR, boolean_type_node, args[1], zero);\n+  se->expr = fold_build3 (COND_EXPR, type, tmp, args[0], rrot);\n }\n \n /* The length of a character string.  */\n@@ -2646,12 +2661,12 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_len_trim (gfc_se * se, gfc_expr * expr)\n {\n-  tree args;\n+  tree args[2];\n   tree type;\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = build_function_call_expr (gfor_fndecl_string_len_trim, args);\n+  se->expr = build_call_expr (gfor_fndecl_string_len_trim, 2, args[0], args[1]);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -2662,44 +2677,45 @@ static void\n gfc_conv_intrinsic_index (gfc_se * se, gfc_expr * expr)\n {\n   tree logical4_type_node = gfc_get_logical_type (4);\n-  tree args;\n-  tree back;\n   tree type;\n-  tree tmp;\n+  tree fndecl;\n+  tree *args;\n+  unsigned int num_args;\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * 5);\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n   type = gfc_typenode_for_spec (&expr->ts);\n-  tmp = gfc_advance_chain (args, 3);\n-  if (TREE_CHAIN (tmp) == NULL_TREE)\n-    {\n-      back = tree_cons (NULL_TREE, build_int_cst (logical4_type_node, 0),\n-\t\t\tNULL_TREE);\n-      TREE_CHAIN (tmp) = back;\n-    }\n+\n+  if (num_args == 4)\n+    args[4] = build_int_cst (logical4_type_node, 0);\n   else\n     {\n-      back = TREE_CHAIN (tmp);\n-      TREE_VALUE (back) = convert (logical4_type_node, TREE_VALUE (back));\n+      gcc_assert (num_args == 5);\n+      args[4] = convert (logical4_type_node, args[4]);\n     }\n \n-  se->expr = build_function_call_expr (gfor_fndecl_string_index, args);\n+  fndecl = build_addr (gfor_fndecl_string_index, current_function_decl);\n+  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_index)),\n+\t\t\t       fndecl, 5, args);\n   se->expr = convert (type, se->expr);\n+\n }\n \n /* The ascii value for a single character.  */\n static void\n gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n+  tree args[2];\n   tree type;\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n-  arg = TREE_VALUE (TREE_CHAIN (arg));\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (arg)));\n-  arg = build1 (NOP_EXPR, pchar_type_node, arg);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (args[1])));\n+  args[1] = build1 (NOP_EXPR, pchar_type_node, args[1]);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n-  se->expr = build_fold_indirect_ref (arg);\n+  se->expr = build_fold_indirect_ref (args[1]);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -2709,32 +2725,33 @@ gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_merge (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n   tree tsource;\n   tree fsource;\n   tree mask;\n   tree type;\n   tree len;\n+  tree *args;\n+  unsigned int num_args;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * num_args);\n \n-  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n   if (expr->ts.type != BT_CHARACTER)\n     {\n-      tsource = TREE_VALUE (arg);\n-      arg = TREE_CHAIN (arg);\n-      fsource = TREE_VALUE (arg);\n-      mask = TREE_VALUE (TREE_CHAIN (arg));\n+      tsource = args[0];\n+      fsource = args[1];\n+      mask = args[2];\n     }\n   else\n     {\n       /* We do the same as in the non-character case, but the argument\n \t list is different because of the string length arguments. We\n \t also have to set the string length for the result.  */\n-      len = TREE_VALUE (arg);\n-      arg = TREE_CHAIN (arg);\n-      tsource = TREE_VALUE (arg);\n-      arg = TREE_CHAIN (TREE_CHAIN (arg));\n-      fsource = TREE_VALUE (arg);\n-      mask = TREE_VALUE (TREE_CHAIN (arg));\n+      len = args[0];\n+      tsource = args[1];\n+      fsource = args[3];\n+      mask = args[4];\n \n       se->string_length = len;\n     }\n@@ -2891,16 +2908,11 @@ static void\n gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n {\n   tree type;\n-  tree args;\n-  tree arg2;\n+  tree args[4];\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n-  arg2 = TREE_CHAIN (TREE_CHAIN (args));\n-\n-  se->expr = gfc_build_compare_string (TREE_VALUE (args),\n-\t\tTREE_VALUE (TREE_CHAIN (args)), TREE_VALUE (arg2),\n-\t\tTREE_VALUE (TREE_CHAIN (arg2)));\n+  gfc_conv_intrinsic_function_args (se, expr, args, 4);\n \n+  se->expr = gfc_build_compare_string (args[0], args[1], args[2], args[3]);\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = fold_build2 (op, type, se->expr,\n \t\t     build_int_cst (TREE_TYPE (se->expr), 0));\n@@ -2910,20 +2922,20 @@ gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n static void\n gfc_conv_intrinsic_adjust (gfc_se * se, gfc_expr * expr, tree fndecl)\n {\n-  tree args;\n+  tree args[3];\n   tree len;\n   tree type;\n   tree var;\n   tree tmp;\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n-  len = TREE_VALUE (args);\n+  gfc_conv_intrinsic_function_args (se, expr, &args[1], 2);\n+  len = args[1];\n \n-  type = TREE_TYPE (TREE_VALUE (TREE_CHAIN (args)));\n+  type = TREE_TYPE (args[2]);\n   var = gfc_conv_string_tmp (se, type, len);\n-  args = tree_cons (NULL_TREE, var, args);\n+  args[0] = var;\n \n-  tmp = build_function_call_expr (fndecl, args);\n+  tmp = build_call_expr (fndecl, 3, args[0], args[1], args[2]);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   se->expr = var;\n   se->string_length = len;\n@@ -3372,27 +3384,28 @@ static void\n gfc_conv_intrinsic_scan (gfc_se * se, gfc_expr * expr)\n {\n   tree logical4_type_node = gfc_get_logical_type (4);\n-  tree args;\n-  tree back;\n   tree type;\n-  tree tmp;\n+  tree fndecl;\n+  tree *args;\n+  unsigned int num_args;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * 5);\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n   type = gfc_typenode_for_spec (&expr->ts);\n-  tmp = gfc_advance_chain (args, 3);\n-  if (TREE_CHAIN (tmp) == NULL_TREE)\n-    {\n-      back = tree_cons (NULL_TREE, build_int_cst (logical4_type_node, 0),\n-\t\t\tNULL_TREE);\n-      TREE_CHAIN (tmp) = back;\n-    }\n+\n+  if (num_args == 4)\n+    args[4] = build_int_cst (logical4_type_node, 0);\n   else\n     {\n-      back = TREE_CHAIN (tmp);\n-      TREE_VALUE (back) = convert (logical4_type_node, TREE_VALUE (back));\n+      gcc_assert (num_args == 5);\n+      args[4] = convert (logical4_type_node, args[4]);\n     }\n \n-  se->expr = build_function_call_expr (gfor_fndecl_string_scan, args);\n+  fndecl = build_addr (gfor_fndecl_string_scan, current_function_decl);\n+  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_scan)),\n+\t\t\t       fndecl, 5, args);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -3405,27 +3418,29 @@ static void\n gfc_conv_intrinsic_verify (gfc_se * se, gfc_expr * expr)\n {\n   tree logical4_type_node = gfc_get_logical_type (4);\n-  tree args;\n-  tree back;\n   tree type;\n-  tree tmp;\n+  tree fndecl;\n+  tree *args;\n+  unsigned int num_args;\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = alloca (sizeof (tree) * 5);\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n   type = gfc_typenode_for_spec (&expr->ts);\n-  tmp = gfc_advance_chain (args, 3);\n-  if (TREE_CHAIN (tmp) == NULL_TREE)\n-    {\n-      back = tree_cons (NULL_TREE, build_int_cst (logical4_type_node, 0),\n-\t\t\tNULL_TREE);\n-      TREE_CHAIN (tmp) = back;\n-    }\n+\n+  if (num_args == 4)\n+    args[4] = build_int_cst (logical4_type_node, 0);\n   else\n     {\n-      back = TREE_CHAIN (tmp);\n-      TREE_VALUE (back) = convert (logical4_type_node, TREE_VALUE (back));\n+      gcc_assert (num_args == 5);\n+      args[4] = convert (logical4_type_node, args[4]);\n     }\n \n-  se->expr = build_function_call_expr (gfor_fndecl_string_verify, args);\n+  fndecl = build_addr (gfor_fndecl_string_verify, current_function_decl);\n+  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_verify)),\n+\t\t\t       fndecl, 5, args);\n+\n   se->expr = convert (type, se->expr);\n }\n \n@@ -3435,12 +3450,11 @@ gfc_conv_intrinsic_verify (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_si_kind (gfc_se * se, gfc_expr * expr)\n {\n-  tree args;\n+  tree arg;\n \n-  args = gfc_conv_intrinsic_function_args (se, expr);\n-  args = TREE_VALUE (args);\n-  args = build_fold_addr_expr (args);\n-  se->expr = build_call_expr (gfor_fndecl_si_kind, 1, args);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = build_fold_addr_expr (arg);\n+  se->expr = build_call_expr (gfor_fndecl_si_kind, 1, arg);\n }\n \n /* Generate code for SELECTED_REAL_KIND (P, R) intrinsic function.  */\n@@ -3481,23 +3495,27 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   tree len;\n   tree addr;\n   tree tmp;\n-  tree arglist;\n   tree type;\n   tree cond;\n+  tree fndecl;\n+  tree *args;\n+  unsigned int num_args;\n \n-  arglist = NULL_TREE;\n+  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n+  args = alloca (sizeof (tree) * num_args);\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   addr = gfc_build_addr_expr (ppvoid_type_node, var);\n   len = gfc_create_var (gfc_int4_type_node, \"len\");\n \n-  tmp = gfc_conv_intrinsic_function_args (se, expr);\n-  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n-  arglist = gfc_chainon_list (arglist, addr);\n-  arglist = chainon (arglist, tmp);\n+  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n+  args[0] = build_fold_addr_expr (len);\n+  args[1] = addr;\n \n-  tmp = build_function_call_expr (gfor_fndecl_string_trim, arglist);\n+  fndecl = build_addr (gfor_fndecl_string_trim, current_function_decl);\n+  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_trim)),\n+\t\t\t  fndecl, num_args, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -3517,18 +3535,16 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n {\n-  tree args, ncopies, dest, dlen, src, slen, ncopies_type;\n+  tree args[3], ncopies, dest, dlen, src, slen, ncopies_type;\n   tree type, cond, tmp, count, exit_label, n, max, largest;\n   stmtblock_t block, body;\n   int i;\n \n   /* Get the arguments.  */\n-  args = gfc_conv_intrinsic_function_args (se, expr);\n-  slen = fold_convert (size_type_node, gfc_evaluate_now (TREE_VALUE (args),\n-\t\t\t\t\t\t\t &se->pre));\n-  src = TREE_VALUE (TREE_CHAIN (args));\n-  ncopies = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n-  ncopies = gfc_evaluate_now (ncopies, &se->pre);\n+  gfc_conv_intrinsic_function_args (se, expr, args, 3);\n+  slen = fold_convert (size_type_node, gfc_evaluate_now (args[0], &se->pre));\n+  src = args[1];\n+  ncopies = gfc_evaluate_now (args[2], &se->pre);\n   ncopies_type = TREE_TYPE (ncopies);\n \n   /* Check that NCOPIES is not negative.  */"}, {"sha": "c025a088678614145fc9919e0a492b1775e02721", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "patch": "@@ -1,3 +1,16 @@\n+2007-07-16  Lee Millward  <lee.millward@gmail.com>\n+\n+\t* gfortran.dg/cmplx_intrinsic_1.f90: New test.\n+\n+\tPR fortran/32238\n+\t* gfortran.dg/pr32238.f90: New test.\n+\n+\tPR fortran/32222\n+\t* gfortran.dg/pr32222.f90: New test.\n+\n+\tPR fortran/32242\n+\t* gfortran.dg/pr32242.f90: New test.\n+\t\n 2007-07-16  Sandra Loosemore  <sandra@codesourcery.com>\n \t    David Ung  <davidu@mips.com>\n "}, {"sha": "bc4b9dfb2f96145a13c9966f31aa93791344fb82", "filename": "gcc/testsuite/gfortran.dg/cmplx_intrinsic_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcmplx_intrinsic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcmplx_intrinsic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcmplx_intrinsic_1.f90?ref=55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+\n+CONTAINS\n+SUBROUTINE send_forward ()\n+\n+    INTEGER, DIMENSION(3)                    :: lz, ub, uz\n+    REAL, ALLOCATABLE, DIMENSION(:, :, :)    :: buffer\n+    COMPLEX, DIMENSION ( :, :, : ), POINTER  :: cc3d\n+\n+    cc3d ( lz(1):uz(1), lz(2):uz(2), lz(3):uz(3) ) = &\n+           CMPLX ( buffer ( lz(1):uz(1), lz(2):uz(2), lz(3):uz(3) ), &\n+                   KIND = SELECTED_REAL_KIND ( 14, 200 ) )\n+   \n+END SUBROUTINE send_forward\n+END\n+"}, {"sha": "1daac1ef178473f41adb893bb49b5f0f17b09c49", "filename": "gcc/testsuite/gfortran.dg/pr32222.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32222.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32222.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32222.f90?ref=55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "patch": "@@ -0,0 +1,18 @@\n+!PR fortran/32222\n+! { dg-do compile }\n+! { dg-final { cleanup-modules \"splinemod\" } }\n+\n+module splinemod\n+implicit none\n+integer, parameter :: dl = KIND(1.d0)\n+Type lSamples\n+  integer l(10)\n+end Type lSamples\n+end module splinemod\n+\n+subroutine InterpolateClArr(lSet)\n+use splinemod\n+type (lSamples), intent(in) :: lSet\n+real(dl) xl(10)\n+xl = real(lSet%l,dl)\n+end subroutine InterpolateClArr"}, {"sha": "2c88b356561414e59a6ed4886761958026ef9662", "filename": "gcc/testsuite/gfortran.dg/pr32238.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32238.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32238.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32238.f90?ref=55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "patch": "@@ -0,0 +1,22 @@\n+!PR fortran/32238\n+! { dg-do compile }\n+! { dg-final { cleanup-modules \"bug_test\" } }\n+\n+module bug_test\n+\n+contains\n+  subroutine bug(c)\n+\n+  implicit none\n+\n+  integer, parameter :: fp = selected_real_kind(13)\n+  complex(kind=fp)              :: c(:,:)\n+  where( abs( aimag( c ) ) < 1.e-10_fp )                             &\n+  &    c = cmplx( real( c , fp ) , 0._fp , fp )\n+  where( abs( real( c , fp ) ) < 1.e-10_fp )                         &\n+  &    c = cmplx( 0._fp , aimag( c ) , fp )\n+\n+  return\n+  end subroutine bug\n+\n+end module bug_test"}, {"sha": "6928f4f52d41dcdb2c30eee8d4e67eca7382b63d", "filename": "gcc/testsuite/gfortran.dg/pr32242.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32242.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55637e51b5d81cd3ceb51ec5d236a745e41c7bbc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32242.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32242.f90?ref=55637e51b5d81cd3ceb51ec5d236a745e41c7bbc", "patch": "@@ -0,0 +1,39 @@\n+!PR fortran/32242\n+! { dg-do compile }\n+! { dg-final { cleanup-modules \"kahan_sum\" } }\n+\n+MODULE kahan_sum\n+  INTEGER, PARAMETER :: dp=KIND(0.0D0)\n+  INTERFACE accurate_sum\n+    MODULE PROCEDURE kahan_sum_d1, kahan_sum_z1\n+  END INTERFACE accurate_sum\n+  TYPE pw_grid_type\n+     REAL (KIND=dp), DIMENSION ( : ), POINTER :: gsq\n+  END TYPE pw_grid_type\n+  TYPE pw_type\n+     REAL (KIND=dp), DIMENSION ( : ), POINTER :: cr\n+     COMPLEX (KIND=dp), DIMENSION ( : ), POINTER :: cc\n+     TYPE ( pw_grid_type ), POINTER :: pw_grid\n+  END TYPE pw_type\n+CONTAINS\n+ FUNCTION kahan_sum_d1(array,mask) RESULT(ks)\n+   REAL(KIND=dp), DIMENSION(:), INTENT(IN)  :: array\n+   LOGICAL, DIMENSION(:), INTENT(IN), &\n+     OPTIONAL                               :: mask\n+   REAL(KIND=dp)                            :: ks\n+ END FUNCTION kahan_sum_d1\n+  FUNCTION kahan_sum_z1(array,mask) RESULT(ks)\n+    COMPLEX(KIND=dp), DIMENSION(:), &\n+      INTENT(IN)                             :: array\n+    LOGICAL, DIMENSION(:), INTENT(IN), &\n+      OPTIONAL                               :: mask\n+    COMPLEX(KIND=dp)                         :: ks\n+  END FUNCTION kahan_sum_z1\n+\n+FUNCTION pw_integral_a2b ( pw1, pw2 ) RESULT ( integral_value )\n+    TYPE(pw_type), INTENT(IN)                :: pw1, pw2\n+    REAL(KIND=dp)                            :: integral_value\n+     integral_value = accurate_sum ( REAL ( CONJG ( pw1 % cc ( : ) ) &\n+          *  pw2 % cc ( : ) ,KIND=dp) * pw1 % pw_grid % gsq ( : ) )  ! { dg-warning \"Function return value not set\" }\n+END FUNCTION pw_integral_a2b\n+END MODULE"}]}