{"sha": "68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhmOWM1ZTIxZTM4MWIyOGVkMmYxZDk2ZGVkZjUwN2FmNTNkNGU1NA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-08-10T21:46:33Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-08-10T21:46:33Z"}, "message": "s390-protos.h (s390_canonicalize_comparison): Declare.\n\n\t* config/s390/s390-protos.h (s390_canonicalize_comparison): Declare.\n\t* config/s390/s390.c (s390_canonicalize_comparison): New function.\n\t* config/s390/s390.h (CANONICALIZE_COMPARISON): Define.\n\t* config/s390/s390.md (\"*tmdi_ext\", \"*tmsi_ext\", \"*tmqisi_ext\",\n\t\"*tmqidi_ext\", \"*tmdi_mem\", \"*tmsi_mem\", \"*tmhi_mem\"): Remove.\n\t(\"*tmqi_mem\"): Remove SUBREG from pattern.\n\t(\"*anddi3_cconly\"): Prevent accidentally matching TM pattern.\n\t(\"*andsi3_cconly\"): Likewise.\n\nFrom-SVN: r85770", "tree": {"sha": "781339f082dfe283dcdf2fd34b5eb0a02d795e0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/781339f082dfe283dcdf2fd34b5eb0a02d795e0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/comments", "author": null, "committer": null, "parents": [{"sha": "22116d840af84286597e0ad501240d35b9a0c5cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22116d840af84286597e0ad501240d35b9a0c5cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22116d840af84286597e0ad501240d35b9a0c5cf"}], "stats": {"total": 257, "additions": 106, "deletions": 151}, "files": [{"sha": "0f02c9de6fc46fb3c74dc0a8c1371c69a0f9074f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "patch": "@@ -1,3 +1,14 @@\n+2004-08-10  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_canonicalize_comparison): Declare.\n+\t* config/s390/s390.c (s390_canonicalize_comparison): New function.\n+\t* config/s390/s390.h (CANONICALIZE_COMPARISON): Define.\n+\t* config/s390/s390.md (\"*tmdi_ext\", \"*tmsi_ext\", \"*tmqisi_ext\",\n+\t\"*tmqidi_ext\", \"*tmdi_mem\", \"*tmsi_mem\", \"*tmhi_mem\"): Remove.\n+\t(\"*tmqi_mem\"): Remove SUBREG from pattern.\n+\t(\"*anddi3_cconly\"): Prevent accidentally matching TM pattern.\n+\t(\"*andsi3_cconly\"): Likewise.\n+\t\n 2004-08-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/16909"}, {"sha": "a7498e2d2f36d117e18879156f861c73ec1e993d", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "patch": "@@ -50,6 +50,7 @@ extern int tls_symbolic_operand (rtx);\n extern int s390_match_ccmode (rtx, enum machine_mode);\n extern enum machine_mode s390_tm_ccmode (rtx, rtx, int);\n extern enum machine_mode s390_select_ccmode (enum rtx_code, rtx, rtx);\n+extern void s390_canonicalize_comparison (enum rtx_code *, rtx *, rtx *);\n extern int s390_alc_comparison (rtx op, enum machine_mode mode);\n extern int s390_slb_comparison (rtx op, enum machine_mode mode);\n extern rtx s390_emit_compare (enum rtx_code, rtx, rtx);"}, {"sha": "083d7259fdb65e181edf161283b26251278f681f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "patch": "@@ -474,6 +474,87 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n     }\n }\n \n+/* Replace the comparison OP0 CODE OP1 by a semantically equivalent one\n+   that we can implement more efficiently.  */\n+\n+void\n+s390_canonicalize_comparison (enum rtx_code *code, rtx *op0, rtx *op1)\n+{\n+  /* Convert ZERO_EXTRACT back to AND to enable TM patterns.  */\n+  if ((*code == EQ || *code == NE)\n+      && *op1 == const0_rtx\n+      && GET_CODE (*op0) == ZERO_EXTRACT\n+      && GET_CODE (XEXP (*op0, 1)) == CONST_INT\n+      && GET_CODE (XEXP (*op0, 2)) == CONST_INT\n+      && SCALAR_INT_MODE_P (GET_MODE (XEXP (*op0, 0))))\n+    {\n+      rtx inner = XEXP (*op0, 0);\n+      HOST_WIDE_INT modesize = GET_MODE_BITSIZE (GET_MODE (inner));\n+      HOST_WIDE_INT len = INTVAL (XEXP (*op0, 1));\n+      HOST_WIDE_INT pos = INTVAL (XEXP (*op0, 2));\n+\n+      if (len > 0 && len < modesize\n+\t  && pos >= 0 && pos + len <= modesize\n+\t  && modesize <= HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  unsigned HOST_WIDE_INT block;\n+\t  block = ((unsigned HOST_WIDE_INT) 1 << len) - 1;\n+\t  block <<= modesize - pos - len;\n+\n+\t  *op0 = gen_rtx_AND (GET_MODE (inner), inner,\n+\t\t\t      gen_int_mode (block, GET_MODE (inner)));\n+\t}\n+    }\n+\n+  /* Narrow AND of memory against immediate to enable TM.  */\n+  if ((*code == EQ || *code == NE)\n+      && *op1 == const0_rtx\n+      && GET_CODE (*op0) == AND\n+      && GET_CODE (XEXP (*op0, 1)) == CONST_INT\n+      && SCALAR_INT_MODE_P (GET_MODE (XEXP (*op0, 0))))\n+    {\n+      rtx inner = XEXP (*op0, 0);\n+      rtx mask = XEXP (*op0, 1);\n+\n+      /* Ignore paradoxical SUBREGs if all extra bits are masked out.  */\n+      if (GET_CODE (inner) == SUBREG\n+\t  && SCALAR_INT_MODE_P (GET_MODE (SUBREG_REG (inner)))\n+\t  && (GET_MODE_SIZE (GET_MODE (inner))\n+\t      >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (inner))))\n+\t  && ((INTVAL (mask)\n+               & GET_MODE_MASK (GET_MODE (inner))\n+               & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (inner))))\n+\t      == 0))\n+\tinner = SUBREG_REG (inner);\n+\n+      /* Do not change volatile MEMs.  */\n+      if (MEM_P (inner) && !MEM_VOLATILE_P (inner))\n+\t{\n+\t  int part = s390_single_part (XEXP (*op0, 1),\n+\t\t\t\t       GET_MODE (inner), QImode, 0);\n+\t  if (part >= 0)\n+\t    {\n+\t      mask = gen_int_mode (s390_extract_part (mask, QImode, 0), QImode);\n+\t      inner = adjust_address_nv (inner, QImode, part);\n+\t      *op0 = gen_rtx_AND (QImode, inner, mask);\n+\t    }\n+\t}\n+    }\n+\n+  /* Narrow comparisons against 0xffff to HImode if possible.  */\n+\n+  if ((*code == EQ || *code == NE)\n+      && GET_CODE (*op1) == CONST_INT\n+      && INTVAL (*op1) == 0xffff\n+      && SCALAR_INT_MODE_P (GET_MODE (*op0))\n+      && (nonzero_bits (*op0, GET_MODE (*op0)) \n+\t  & ~(unsigned HOST_WIDE_INT) 0xffff) == 0)\n+    {\n+      *op0 = gen_lowpart (HImode, *op0);\n+      *op1 = constm1_rtx;\n+    }\n+}\n+\n /* Emit a compare instruction suitable to implement the comparison\n    OP0 CODE OP1.  Return the correct condition RTL to be placed in\n    the IF_THEN_ELSE of the conditional branch testing the result.  */"}, {"sha": "c92d6ad272d20e29409113c7229f512110209ee8", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "patch": "@@ -813,6 +813,10 @@ CUMULATIVE_ARGS;\n    return the mode to be used for the comparison.  */\n #define SELECT_CC_MODE(OP, X, Y) s390_select_ccmode ((OP), (X), (Y))\n \n+/* Canonicalize a comparison from one we don't have to one we do have.  */\n+#define CANONICALIZE_COMPARISON(CODE, OP0, OP1) \\\n+  s390_canonicalize_comparison (&(CODE), &(OP0), &(OP1))\n+\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */"}, {"sha": "f18fe13d64713693973c5f5764b3b04a96fdf6bc", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 9, "deletions": 151, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9c5e21e381b28ed2f1d96dedf507af53d4e54/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=68f9c5e21e381b28ed2f1d96dedf507af53d4e54", "patch": "@@ -286,159 +286,13 @@\n })\n \n \n-; Test-under-Mask (zero_extract) instructions\n-\n-(define_insn \"*tmdi_ext\"\n-  [(set (reg 33)\n-        (compare (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"d\")\n-\t                          (match_operand:DI 1 \"const_int_operand\" \"n\")\n-                                  (match_operand:DI 2 \"const_int_operand\" \"n\"))\n-                 (const_int 0)))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\n-   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0\n-   && INTVAL (operands[1]) + INTVAL (operands[2]) <= 64\n-   && (INTVAL (operands[1]) + INTVAL (operands[2]) - 1) >> 4\n-      == INTVAL (operands[2]) >> 4\"\n-{\n-  int part = INTVAL (operands[2]) >> 4;\n-  int block = (1 << INTVAL (operands[1])) - 1;\n-  int shift = 16 - INTVAL (operands[1]) - (INTVAL (operands[2]) & 15);\n-\n-  operands[2] = GEN_INT (block << shift);\n-\n-  switch (part)\n-    {\n-      case 0: return \"tmhh\\t%0,%x2\";\n-      case 1: return \"tmhl\\t%0,%x2\";\n-      case 2: return \"tmlh\\t%0,%x2\";\n-      case 3: return \"tmll\\t%0,%x2\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"RI\")])\n-\n-(define_insn \"*tmsi_ext\"\n-  [(set (reg 33)\n-        (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t                          (match_operand:SI 1 \"const_int_operand\" \"n\")\n-                                  (match_operand:SI 2 \"const_int_operand\" \"n\"))\n-                 (const_int 0)))]\n-  \"s390_match_ccmode(insn, CCTmode)\n-   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0\n-   && INTVAL (operands[1]) + INTVAL (operands[2]) <= 32\n-   && (INTVAL (operands[1]) + INTVAL (operands[2]) - 1) >> 4\n-      == INTVAL (operands[2]) >> 4\"\n-{\n-  int part = INTVAL (operands[2]) >> 4;\n-  int block = (1 << INTVAL (operands[1])) - 1;\n-  int shift = 16 - INTVAL (operands[1]) - (INTVAL (operands[2]) & 15);\n-\n-  operands[2] = GEN_INT (block << shift);\n-\n-  switch (part)\n-    {\n-      case 0: return \"tmh\\t%0,%x2\";\n-      case 1: return \"tml\\t%0,%x2\";\n-      default: abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"RI\")])\n-\n-(define_insn \"*tmqisi_ext\"\n-  [(set (reg 33)\n-        (compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"Q,S\")\n-\t                          (match_operand:SI 1 \"const_int_operand\" \"n,n\")\n-                                  (match_operand:SI 2 \"const_int_operand\" \"n,n\"))\n-                 (const_int 0)))]\n-  \"!TARGET_64BIT && s390_match_ccmode(insn, CCTmode)\n-   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0\n-   && INTVAL (operands[1]) + INTVAL (operands[2]) <= 8\"\n-{\n-  int block = (1 << INTVAL (operands[1])) - 1;\n-  int shift = 8 - INTVAL (operands[1]) - INTVAL (operands[2]);\n-\n-  operands[2] = GEN_INT (block << shift);\n-  return which_alternative == 0 ? \"tm\\t%0,%b2\" : \"tmy\\t%0,%b2\";\n-}\n-  [(set_attr \"op_type\" \"SI,SIY\")])\n-\n-(define_insn \"*tmqidi_ext\"\n-  [(set (reg 33)\n-        (compare (zero_extract:DI (match_operand:QI 0 \"memory_operand\" \"Q,S\")\n-\t                          (match_operand:SI 1 \"const_int_operand\" \"n,n\")\n-                                  (match_operand:SI 2 \"const_int_operand\" \"n,n\"))\n-                 (const_int 0)))]\n-  \"TARGET_64BIT && s390_match_ccmode(insn, CCTmode)\n-   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0\n-   && INTVAL (operands[1]) + INTVAL (operands[2]) <= 8\"\n-{\n-  int block = (1 << INTVAL (operands[1])) - 1;\n-  int shift = 8 - INTVAL (operands[1]) - INTVAL (operands[2]);\n-\n-  operands[2] = GEN_INT (block << shift);\n-  return which_alternative == 0 ? \"tm\\t%0,%b2\" : \"tmy\\t%0,%b2\";\n-}\n-  [(set_attr \"op_type\" \"SI,SIY\")])\n-\n-\n ; Test-under-Mask instructions\n \n-(define_insn \"*tmdi_mem\"\n-  [(set (reg 33)\n-        (compare (and:DI (match_operand:DI 0 \"memory_operand\" \"Q,S\")\n-                         (match_operand:DI 1 \"immediate_operand\" \"n,n\"))\n-                 (match_operand:DI 2 \"immediate_operand\" \"n,n\")))]\n-  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n-   && s390_single_part (operands[1], DImode, QImode, 0) >= 0\"\n-{\n-  int part = s390_single_part (operands[1], DImode, QImode, 0);\n-  operands[1] = GEN_INT (s390_extract_part (operands[1], QImode, 0));\n-\n-  operands[0] = gen_rtx_MEM (QImode,\n-\t\t\t     plus_constant (XEXP (operands[0], 0), part));\n-  return which_alternative == 0 ? \"tm\\t%0,%b1\" : \"tmy\\t%0,%b1\";\n-}\n-  [(set_attr \"op_type\" \"SI,SIY\")])\n-\n-(define_insn \"*tmsi_mem\"\n-  [(set (reg 33)\n-        (compare (and:SI (match_operand:SI 0 \"memory_operand\" \"Q,S\")\n-                         (match_operand:SI 1 \"immediate_operand\" \"n,n\"))\n-                 (match_operand:SI 2 \"immediate_operand\" \"n,n\")))]\n-  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n-   && s390_single_part (operands[1], SImode, QImode, 0) >= 0\"\n-{\n-  int part = s390_single_part (operands[1], SImode, QImode, 0);\n-  operands[1] = GEN_INT (s390_extract_part (operands[1], QImode, 0));\n-\n-  operands[0] = gen_rtx_MEM (QImode,\n-\t\t\t     plus_constant (XEXP (operands[0], 0), part));\n-  return which_alternative == 0 ? \"tm\\t%0,%b1\" : \"tmy\\t%0,%b1\";\n-}\n-  [(set_attr \"op_type\" \"SI\")])\n-\n-(define_insn \"*tmhi_mem\"\n-  [(set (reg 33)\n-        (compare (and:SI (subreg:SI (match_operand:HI 0 \"memory_operand\" \"Q,S\") 0)\n-                         (match_operand:SI 1 \"immediate_operand\" \"n,n\"))\n-                 (match_operand:SI 2 \"immediate_operand\" \"n,n\")))]\n-  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n-   && s390_single_part (operands[1], HImode, QImode, 0) >= 0\"\n-{\n-  int part = s390_single_part (operands[1], HImode, QImode, 0);\n-  operands[1] = GEN_INT (s390_extract_part (operands[1], QImode, 0));\n-\n-  operands[0] = gen_rtx_MEM (QImode,\n-\t\t\t     plus_constant (XEXP (operands[0], 0), part));\n-  return which_alternative == 0 ? \"tm\\t%0,%b1\" : \"tmy\\t%0,%b1\";\n-}\n-  [(set_attr \"op_type\" \"SI\")])\n-\n (define_insn \"*tmqi_mem\"\n   [(set (reg 33)\n-        (compare (and:SI (subreg:SI (match_operand:QI 0 \"memory_operand\" \"Q,S\") 0)\n-                         (match_operand:SI 1 \"immediate_operand\" \"n,n\"))\n-                 (match_operand:SI 2 \"immediate_operand\" \"n,n\")))]\n+        (compare (and:QI (match_operand:QI 0 \"memory_operand\" \"Q,S\")\n+                         (match_operand:QI 1 \"immediate_operand\" \"n,n\"))\n+                 (match_operand:QI 2 \"immediate_operand\" \"n,n\")))]\n   \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\"\n   \"@\n    tm\\t%0,%b1\n@@ -5196,7 +5050,9 @@\n                          (match_operand:DI 2 \"general_operand\" \"d,m\"))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d,d\"))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\n+   /* Do not steal TM patterns.  */\n+   && s390_single_part (operands[2], DImode, HImode, 0) < 0\"\n   \"@\n    ngr\\t%0,%2\n    ng\\t%0,%2\"\n@@ -5262,7 +5118,9 @@\n                          (match_operand:SI 2 \"general_operand\" \"d,R,T\"))\n                  (const_int 0)))\n    (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n-  \"s390_match_ccmode(insn, CCTmode)\"\n+  \"s390_match_ccmode(insn, CCTmode)\n+   /* Do not steal TM patterns.  */\n+   && s390_single_part (operands[2], SImode, HImode, 0) < 0\"\n   \"@\n    nr\\t%0,%2\n    n\\t%0,%2"}]}