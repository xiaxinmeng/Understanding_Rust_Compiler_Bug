{"sha": "917dd789e55c88123d804a8a411e4a61ee7b6e43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE3ZGQ3ODllNTVjODgxMjNkODA0YThhNDExZTRhNjFlZTdiNmU0Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-01T23:30:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-01T23:30:55Z"}, "message": "omp-general.h (omp_context_selector_set_compare): Declare.\n\n\t* omp-general.h (omp_context_selector_set_compare): Declare.\n\t* omp-general.c (omp_construct_simd_compare,\n\tomp_context_selector_props_compare, omp_context_selector_set_compare,\n\tomp_context_selector_compare): New functions.\n\t(omp_resolve_declare_variant): Prune variants that are strict subset\n\tof another variant.\nc-family/\n\t* c-omp.c (c_omp_mark_declare_variant): Use\n\tomp_context_selector_set_compare.\ntestsuite/\n\t* c-c++-common/gomp/declare-variant-6.c: Expect construct rather than\n\tconstructor in diagnostic messages.\n\t* c-c++-common/gomp/declare-variant-7.c: Likewise.\n\t* c-c++-common/gomp/declare-variant-11.c: New test.\n\nFrom-SVN: r277734", "tree": {"sha": "f9f2f596da38caa176b5dafe2a18ac61f1957f4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9f2f596da38caa176b5dafe2a18ac61f1957f4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/917dd789e55c88123d804a8a411e4a61ee7b6e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917dd789e55c88123d804a8a411e4a61ee7b6e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917dd789e55c88123d804a8a411e4a61ee7b6e43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917dd789e55c88123d804a8a411e4a61ee7b6e43/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94"}], "stats": {"total": 602, "additions": 475, "deletions": 127}, "files": [{"sha": "17beb66d25655ba414fef78368e3649fb89ed381", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -1,3 +1,12 @@\n+2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-general.h (omp_context_selector_set_compare): Declare.\n+\t* omp-general.c (omp_construct_simd_compare,\n+\tomp_context_selector_props_compare, omp_context_selector_set_compare,\n+\tomp_context_selector_compare): New functions.\n+\t(omp_resolve_declare_variant): Prune variants that are strict subset\n+\tof another variant.\n+\n 2019-11-01  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/91679"}, {"sha": "dfc78a4617379fd6c4cb68518c36a70a80c12039", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -1,5 +1,8 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-omp.c (c_omp_mark_declare_variant): Use\n+\tomp_context_selector_set_compare.\n+\n \tPR c++/88335 - Implement P1073R3: Immediate functions\n \t* c-common.h (enum rid): Add RID_CONSTEVAL.\n \t* c-common.c (c_common_reswords): Add consteval."}, {"sha": "fdf778f93abccdc952606200576f6f4d37a5d9ad", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 5, "deletions": 108, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -2275,113 +2275,10 @@ c_omp_mark_declare_variant (location_t loc, tree variant, tree construct)\n       DECL_ATTRIBUTES (variant) = attr;\n       return;\n     }\n-  tree t1 = TREE_VALUE (attr);\n-  tree t2 = construct;\n-  tree simd = get_identifier (\"simd\");\n-  while (t1 && t2)\n-    {\n-      if (TREE_PURPOSE (t1) != TREE_PURPOSE (t2))\n-\tbreak;\n-      if (TREE_PURPOSE (t1) == simd)\n-\t{\n-\t  if ((TREE_VALUE (t1) == NULL_TREE)\n-\t      != (TREE_VALUE (t2) == NULL_TREE))\n-\t    break;\n-\t  if (TREE_VALUE (t1))\n-\t    {\n-\t      struct declare_variant_simd_data {\n-\t\tbool inbranch, notinbranch;\n-\t\ttree simdlen;\n-\t\tauto_vec<tree,16> data_sharing;\n-\t\tauto_vec<tree,16> aligned;\n-\t\tdeclare_variant_simd_data ()\n-\t\t  : inbranch(false), notinbranch(false), simdlen(NULL_TREE) {}\n-\t      } data[2];\n-\t      unsigned int i;\n-\t      for (i = 0; i < 2; i++)\n-\t\tfor (tree c = TREE_VALUE (i ? t2 : t1);\n-\t\t     c; c = OMP_CLAUSE_CHAIN (c))\n-\t\t  {\n-\t\t    vec<tree> *v;\n-\t\t    switch (OMP_CLAUSE_CODE (c))\n-\t\t      {\n-\t\t      case OMP_CLAUSE_INBRANCH:\n-\t\t\tdata[i].inbranch = true;\n-\t\t\tcontinue;\n-\t\t      case OMP_CLAUSE_NOTINBRANCH:\n-\t\t\tdata[i].notinbranch = true;\n-\t\t\tcontinue;\n-\t\t      case OMP_CLAUSE_SIMDLEN:\n-\t\t\tdata[i].simdlen = OMP_CLAUSE_SIMDLEN_EXPR (c);\n-\t\t\tcontinue;\n-\t\t      case OMP_CLAUSE_UNIFORM:\n-\t\t      case OMP_CLAUSE_LINEAR:\n-\t\t\tv = &data[i].data_sharing;\n-\t\t\tbreak;\n-\t\t      case OMP_CLAUSE_ALIGNED:\n-\t\t\tv = &data[i].aligned;\n-\t\t\tbreak;\n-\t\t      default:\n-\t\t\tgcc_unreachable ();\n-\t\t      }\n-\t\t    unsigned HOST_WIDE_INT argno\n-\t\t      = tree_to_uhwi (OMP_CLAUSE_DECL (c));\n-\t\t    if (argno >= v->length ())\n-\t\t      v->safe_grow_cleared (argno + 1);\n-\t\t    (*v)[argno] = c;\n-\t\t  }\n-\t      if (data[0].inbranch != data[1].inbranch\n-\t\t  || data[0].notinbranch != data[1].notinbranch\n-\t\t  || !simple_cst_equal (data[0].simdlen,\n-\t\t\t\t\tdata[1].simdlen)\n-\t\t  || (data[0].data_sharing.length ()\n-\t\t      != data[1].data_sharing.length ())\n-\t\t  || (data[0].aligned.length ()\n-\t\t      != data[1].aligned.length ()))\n-\t\tbreak;\n-\t      tree c1, c2;\n-\t      FOR_EACH_VEC_ELT (data[0].data_sharing, i, c1)\n-\t\t{\n-\t\t  c2 = data[1].data_sharing[i];\n-\t\t  if ((c1 == NULL_TREE) != (c2 == NULL_TREE))\n-\t\t    break;\n-\t\t  if (c1 == NULL_TREE)\n-\t\t    continue;\n-\t\t  if (OMP_CLAUSE_CODE (c1) != OMP_CLAUSE_CODE (c2))\n-\t\t    break;\n-\t\t  if (OMP_CLAUSE_CODE (c1) != OMP_CLAUSE_LINEAR)\n-\t\t    continue;\n-\t\t  if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c1)\n-\t\t      != OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c2))\n-\t\t    break;\n-\t\t  if (OMP_CLAUSE_LINEAR_KIND (c1)\n-\t\t      != OMP_CLAUSE_LINEAR_KIND (c2))\n-\t\t    break;\n-\t\t  if (!simple_cst_equal (OMP_CLAUSE_LINEAR_STEP (c1),\n-\t\t\t\t\t OMP_CLAUSE_LINEAR_STEP (c2)))\n-\t\t    break;\n-\t\t}\n-\t      if (i < data[0].data_sharing.length ())\n-\t\tbreak;\n-\t      FOR_EACH_VEC_ELT (data[0].aligned, i, c1)\n-\t\t{\n-\t\t  c2 = data[1].aligned[i];\n-\t\t  if ((c1 == NULL_TREE) != (c2 == NULL_TREE))\n-\t\t    break;\n-\t\t  if (c1 == NULL_TREE)\n-\t\t    continue;\n-\t\t  if (!simple_cst_equal (OMP_CLAUSE_ALIGNED_ALIGNMENT (c1),\n-\t\t\t\t\t OMP_CLAUSE_ALIGNED_ALIGNMENT (c2)))\n-\t\t    break;\n-\t\t}\n-\t      if (i < data[0].aligned.length ())\n-\t\tbreak;\n-\t    }\n-\t}\n-      t1 = TREE_CHAIN (t1);\n-      t2 = TREE_CHAIN (t2);\n-    }\n-  if (t1 || t2)\n-    error_at (loc, \"%qD used as a variant with incompatible %<constructor%> \"\n+  if ((TREE_VALUE (attr) != NULL_TREE) != (construct != NULL_TREE)\n+      || (construct != NULL_TREE\n+\t  && omp_context_selector_set_compare (\"construct\", TREE_VALUE (attr),\n+\t\t\t\t\t       construct)))\n+    error_at (loc, \"%qD used as a variant with incompatible %<construct%> \"\n \t\t   \"selector sets\", variant);\n }"}, {"sha": "6700e7fdb8684585dbbb570c2a9804db22e97813", "filename": "gcc/omp-general.c", "status": "modified", "additions": 358, "deletions": 8, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -947,18 +947,335 @@ omp_context_selector_matches (tree ctx)\n   return ret;\n }\n \n+/* Compare construct={simd} CLAUSES1 with CLAUSES2, return 0/-1/1/2 as\n+   in omp_context_selector_set_compare.  */\n+\n+static int\n+omp_construct_simd_compare (tree clauses1, tree clauses2)\n+{\n+  if (clauses1 == NULL_TREE)\n+    return clauses2 == NULL_TREE ? 0 : -1;\n+  if (clauses2 == NULL_TREE)\n+    return 1;\n+\n+  int r = 0;\n+  struct declare_variant_simd_data {\n+    bool inbranch, notinbranch;\n+    tree simdlen;\n+    auto_vec<tree,16> data_sharing;\n+    auto_vec<tree,16> aligned;\n+    declare_variant_simd_data ()\n+      : inbranch(false), notinbranch(false), simdlen(NULL_TREE) {}\n+  } data[2];\n+  unsigned int i;\n+  for (i = 0; i < 2; i++)\n+    for (tree c = i ? clauses2 : clauses1; c; c = OMP_CLAUSE_CHAIN (c))\n+      {\n+\tvec<tree> *v;\n+\tswitch (OMP_CLAUSE_CODE (c))\n+\t  {\n+\t  case OMP_CLAUSE_INBRANCH:\n+\t    data[i].inbranch = true;\n+\t    continue;\n+\t  case OMP_CLAUSE_NOTINBRANCH:\n+\t    data[i].notinbranch = true;\n+\t    continue;\n+\t  case OMP_CLAUSE_SIMDLEN:\n+\t    data[i].simdlen = OMP_CLAUSE_SIMDLEN_EXPR (c);\n+\t    continue;\n+\t  case OMP_CLAUSE_UNIFORM:\n+\t  case OMP_CLAUSE_LINEAR:\n+\t    v = &data[i].data_sharing;\n+\t    break;\n+\t  case OMP_CLAUSE_ALIGNED:\n+\t    v = &data[i].aligned;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tunsigned HOST_WIDE_INT argno = tree_to_uhwi (OMP_CLAUSE_DECL (c));\n+\tif (argno >= v->length ())\n+\t  v->safe_grow_cleared (argno + 1);\n+\t(*v)[argno] = c;\n+      }\n+  /* Here, r is used as a bitmask, 2 is set if CLAUSES1 has something\n+     CLAUSES2 doesn't, 1 is set if CLAUSES2 has something CLAUSES1\n+     doesn't.  Thus, r == 3 implies return value 2, r == 1 implies\n+     -1, r == 2 implies 1 and r == 0 implies 0.  */\n+  if (data[0].inbranch != data[1].inbranch)\n+    r |= data[0].inbranch ? 2 : 1;\n+  if (data[0].notinbranch != data[1].notinbranch)\n+    r |= data[0].notinbranch ? 2 : 1;\n+  if (!simple_cst_equal (data[0].simdlen, data[1].simdlen))\n+    {\n+      if (data[0].simdlen && data[1].simdlen)\n+\treturn 2;\n+      r |= data[0].simdlen ? 2 : 1;\n+    }\n+  if (data[0].data_sharing.length () < data[1].data_sharing.length ()\n+      || data[0].aligned.length () < data[1].aligned.length ())\n+    r |= 1;\n+  tree c1, c2;\n+  FOR_EACH_VEC_ELT (data[0].data_sharing, i, c1)\n+    {\n+      c2 = (i < data[1].data_sharing.length ()\n+\t    ? data[1].data_sharing[i] : NULL_TREE);\n+      if ((c1 == NULL_TREE) != (c2 == NULL_TREE))\n+\t{\n+\t  r |= c1 != NULL_TREE ? 2 : 1;\n+\t  continue;\n+\t}\n+      if (c1 == NULL_TREE)\n+\tcontinue;\n+      if (OMP_CLAUSE_CODE (c1) != OMP_CLAUSE_CODE (c2))\n+\treturn 2;\n+      if (OMP_CLAUSE_CODE (c1) != OMP_CLAUSE_LINEAR)\n+\tcontinue;\n+      if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c1)\n+\t  != OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (c2))\n+\treturn 2;\n+      if (OMP_CLAUSE_LINEAR_KIND (c1) != OMP_CLAUSE_LINEAR_KIND (c2))\n+\treturn 2;\n+      if (!simple_cst_equal (OMP_CLAUSE_LINEAR_STEP (c1),\n+\t\t\t     OMP_CLAUSE_LINEAR_STEP (c2)))\n+\treturn 2;\n+    }\n+  FOR_EACH_VEC_ELT (data[0].aligned, i, c1)\n+    {\n+      c2 = i < data[1].aligned.length () ? data[1].aligned[i] : NULL_TREE;\n+      if ((c1 == NULL_TREE) != (c2 == NULL_TREE))\n+\t{\n+\t  r |= c1 != NULL_TREE ? 2 : 1;\n+\t  continue;\n+\t}\n+      if (c1 == NULL_TREE)\n+\tcontinue;\n+      if (!simple_cst_equal (OMP_CLAUSE_ALIGNED_ALIGNMENT (c1),\n+\t\t\t     OMP_CLAUSE_ALIGNED_ALIGNMENT (c2)))\n+\treturn 2;\n+    }\n+  switch (r)\n+    {\n+    case 0: return 0;\n+    case 1: return -1;\n+    case 2: return 1;\n+    case 3: return 2;\n+    default: gcc_unreachable ();\n+    }\n+}\n+\n+/* Compare properties of selectors SEL from SET other than construct.\n+   Return 0/-1/1/2 as in omp_context_selector_set_compare.\n+   Unlike set names or selector names, properties can have duplicates.  */\n+\n+static int\n+omp_context_selector_props_compare (const char *set, const char *sel,\n+\t\t\t\t    tree ctx1, tree ctx2)\n+{\n+  int ret = 0;\n+  for (int pass = 0; pass < 2; pass++)\n+    for (tree t1 = pass ? ctx2 : ctx1; t1; t1 = TREE_CHAIN (t1))\n+      {\n+\ttree t2;\n+\tfor (t2 = pass ? ctx1 : ctx2; t2; t2 = TREE_CHAIN (t2))\n+\t  if (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t    {\n+\t      if (TREE_PURPOSE (t1) == NULL_TREE)\n+\t\t{\n+\t\t  if (set[0] == 'u' && strcmp (sel, \"condition\") == 0)\n+\t\t    {\n+\t\t      if (integer_zerop (TREE_VALUE (t1))\n+\t\t\t  != integer_zerop (TREE_VALUE (t2)))\n+\t\t\treturn 2;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (simple_cst_equal (TREE_VALUE (t1), TREE_VALUE (t2)))\n+\t\t    break;\n+\t\t}\n+\t      else if (strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n+\t\t\t       \" score\") == 0)\n+\t\t{\n+\t\t  if (!simple_cst_equal (TREE_VALUE (t1), TREE_VALUE (t2)))\n+\t\t    return 2;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t    }\n+\tif (t2 == NULL_TREE)\n+\t  {\n+\t    int r = pass ? -1 : 1;\n+\t    if (ret && ret != r)\n+\t      return 2;\n+\t    else if (pass)\n+\t      return r;\n+\t    else\n+\t      {\n+\t\tret = r;\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+  return ret;\n+}\n+\n+/* Compare single context selector sets CTX1 and CTX2 with SET name.\n+   Return 0 if CTX1 is equal to CTX2,\n+   -1 if CTX1 is a strict subset of CTX2,\n+   1 if CTX2 is a strict subset of CTX1, or\n+   2 if neither context is a subset of another one.  */\n+\n+int\n+omp_context_selector_set_compare (const char *set, tree ctx1, tree ctx2)\n+{\n+  bool swapped = false;\n+  int ret = 0;\n+  int len1 = list_length (ctx1);\n+  int len2 = list_length (ctx2);\n+  int cnt = 0;\n+  if (len1 < len2)\n+    {\n+      swapped = true;\n+      std::swap (ctx1, ctx2);\n+      std::swap (len1, len2);\n+    }\n+  if (set[0] == 'c')\n+    {\n+      tree t1;\n+      tree t2 = ctx2;\n+      tree simd = get_identifier (\"simd\");\n+      /* Handle construct set specially.  In this case the order\n+\t of the selector matters too.  */\n+      for (t1 = ctx1; t1; t1 = TREE_CHAIN (t1))\n+\tif (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t  {\n+\t    int r = 0;\n+\t    if (TREE_PURPOSE (t1) == simd)\n+\t      r = omp_construct_simd_compare (TREE_VALUE (t1),\n+\t\t\t\t\t      TREE_VALUE (t2));\n+\t    if (r == 2 || (ret && r && (ret < 0) != (r < 0)))\n+\t      return 2;\n+\t    if (ret == 0)\n+\t      ret = r;\n+\t    t2 = TREE_CHAIN (t2);\n+\t    if (t2 == NULL_TREE)\n+\t      {\n+\t\tt1 = TREE_CHAIN (t1);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse if (ret < 0)\n+\t  return 2;\n+\telse\n+\t  ret = 1;\n+      if (t2 != NULL_TREE)\n+\treturn 2;\n+      if (t1 != NULL_TREE)\n+\t{\n+\t  if (ret < 0)\n+\t    return 2;\n+\t  ret = 1;\n+\t}\n+      if (ret == 0)\n+\treturn 0;\n+      return swapped ? -ret : ret;\n+    }\n+  for (tree t1 = ctx1; t1; t1 = TREE_CHAIN (t1))\n+    {\n+      tree t2;\n+      for (t2 = ctx2; t2; t2 = TREE_CHAIN (t2))\n+\tif (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t  {\n+\t    const char *sel = IDENTIFIER_POINTER (TREE_PURPOSE (t1));\n+\t    int r = omp_context_selector_props_compare (set, sel,\n+\t\t\t\t\t\t\tTREE_VALUE (t1),\n+\t\t\t\t\t\t\tTREE_VALUE (t2));\n+\t    if (r == 2 || (ret && r && (ret < 0) != (r < 0)))\n+\t      return 2;\n+\t    if (ret == 0)\n+\t      ret = r;\n+\t    cnt++;\n+\t    break;\n+\t  }\n+      if (t2 == NULL_TREE)\n+\t{\n+\t  if (ret == -1)\n+\t    return 2;\n+\t  ret = 1;\n+\t}\n+    }\n+  if (cnt < len2)\n+    return 2;\n+  if (ret == 0)\n+    return 0;\n+  return swapped ? -ret : ret;\n+}\n+\n+/* Compare whole context selector specification CTX1 and CTX2.\n+   Return 0 if CTX1 is equal to CTX2,\n+   -1 if CTX1 is a strict subset of CTX2,\n+   1 if CTX2 is a strict subset of CTX1, or\n+   2 if neither context is a subset of another one.  */\n+\n+static int\n+omp_context_selector_compare (tree ctx1, tree ctx2)\n+{\n+  bool swapped = false;\n+  int ret = 0;\n+  int len1 = list_length (ctx1);\n+  int len2 = list_length (ctx2);\n+  int cnt = 0;\n+  if (len1 < len2)\n+    {\n+      swapped = true;\n+      std::swap (ctx1, ctx2);\n+      std::swap (len1, len2);\n+    }\n+  for (tree t1 = ctx1; t1; t1 = TREE_CHAIN (t1))\n+    {\n+      tree t2;\n+      for (t2 = ctx2; t2; t2 = TREE_CHAIN (t2))\n+\tif (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t  {\n+\t    const char *set = IDENTIFIER_POINTER (TREE_PURPOSE (t1));\n+\t    int r = omp_context_selector_set_compare (set, TREE_VALUE (t1),\n+\t\t\t\t\t\t      TREE_VALUE (t2));\n+\t    if (r == 2 || (ret && r && (ret < 0) != (r < 0)))\n+\t      return 2;\n+\t    if (ret == 0)\n+\t      ret = r;\n+\t    cnt++;\n+\t    break;\n+\t  }\n+      if (t2 == NULL_TREE)\n+\t{\n+\t  if (ret == -1)\n+\t    return 2;\n+\t  ret = 1;\n+\t}\n+    }\n+  if (cnt < len2)\n+    return 2;\n+  if (ret == 0)\n+    return 0;\n+  return swapped ? -ret : ret;\n+}\n+\n /* Try to resolve declare variant, return the variant decl if it should\n    be used instead of base, or base otherwise.  */\n \n tree\n omp_resolve_declare_variant (tree base)\n {\n   tree variant = NULL_TREE;\n+  auto_vec <tree, 16> variants;\n   for (tree attr = DECL_ATTRIBUTES (base); attr; attr = TREE_CHAIN (attr))\n     {\n       attr = lookup_attribute (\"omp declare variant base\", attr);\n       if (attr == NULL_TREE)\n \tbreak;\n+      if (TREE_CODE (TREE_PURPOSE (TREE_VALUE (attr))) != FUNCTION_DECL)\n+\tcontinue;\n       switch (omp_context_selector_matches (TREE_VALUE (TREE_VALUE (attr))))\n \t{\n \tcase 0:\n@@ -968,16 +1285,49 @@ omp_resolve_declare_variant (tree base)\n \t  /* Needs to be deferred.  */\n \t  return base;\n \tdefault:\n-\t  /* FIXME: Scoring not implemented yet, so just resolve it\n-\t     if there is a single variant only.  */\n-\t  if (variant)\n-\t    return base;\n-\t  if (TREE_CODE (TREE_PURPOSE (TREE_VALUE (attr))) == FUNCTION_DECL)\n-\t    variant = TREE_PURPOSE (TREE_VALUE (attr));\n-\t  else\n-\t    return base;\n+\t  variants.safe_push (attr);\n \t}\n     }\n+  if (variants.length () == 0)\n+    return base;\n+  if (variants.length () == 1)\n+    return TREE_PURPOSE (TREE_VALUE (variants[0]));\n+\n+  /* A context selector that is a strict subset of another context selector has a score\n+     of zero.  */\n+  tree attr1, attr2;\n+  unsigned int i, j;\n+  FOR_EACH_VEC_ELT (variants, i, attr1)\n+    if (attr1)\n+      {\n+\ttree ctx1 = TREE_VALUE (TREE_VALUE (attr1));\n+\tFOR_EACH_VEC_ELT_FROM (variants, j, attr2, i + 1)\n+\t  if (attr2)\n+\t    {\n+\t      tree ctx2 = TREE_VALUE (TREE_VALUE (attr2));\n+\t      int r = omp_context_selector_compare (ctx1, ctx2);\n+\t      if (r == -1)\n+\t\t{\n+\t\t  /* ctx1 is a strict subset of ctx2, remove\n+\t\t     attr1 from the vector.  */\n+\t\t  variants[i] = NULL_TREE;\n+\t\t  break;\n+\t\t}\n+\t      else if (r == 1)\n+\t\t/* ctx2 is a strict subset of ctx1, remove attr2\n+\t\t   from the vector.  */\n+\t\tvariants[j] = NULL_TREE;\n+\t    }\n+      }\n+  /* FIXME: Scoring not implemented yet, so just resolve it\n+     if there is a single variant left.  */\n+  FOR_EACH_VEC_ELT (variants, i, attr1)\n+    if (attr1)\n+      {\n+\tif (variant)\n+\t  return base;\n+\tvariant = TREE_PURPOSE (TREE_VALUE (attr1));\n+      }\n   return variant ? variant : base;\n }\n "}, {"sha": "c6f95eb776f66f9b815d0ba27bd6be30c19eaea9", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -86,6 +86,7 @@ extern poly_uint64 omp_max_vf (void);\n extern int omp_max_simt_vf (void);\n extern int omp_constructor_traits_to_codes (tree, enum tree_code *);\n extern int omp_context_selector_matches (tree);\n+extern int omp_context_selector_set_compare (const char *, tree, tree);\n extern tree omp_resolve_declare_variant (tree);\n extern tree oacc_launch_pack (unsigned code, tree device, unsigned op);\n extern tree oacc_replace_fn_attrib_attr (tree attribs, tree dims);"}, {"sha": "e8a3856afebd588a1855caf03b0330fc21d21e32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -1,5 +1,10 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/gomp/declare-variant-6.c: Expect construct rather than\n+\tconstructor in diagnostic messages.\n+\t* c-c++-common/gomp/declare-variant-7.c: Likewise.\n+\t* c-c++-common/gomp/declare-variant-11.c: New test.\n+\n \tPR c++/88335 - Implement P1073R3: Immediate functions\n \t* g++.dg/cpp2a/consteval1.C: New test.\n \t* g++.dg/cpp2a/consteval2.C: New test."}, {"sha": "9879a9b5da527a10d049c07f7353ea1600f96557", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-11.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-11.c?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-foffload=disable -fdump-tree-gimple\" } */\n+/* { dg-additional-options \"-mavx512bw -mavx512vl\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+void f01 (void);\n+void f02 (void);\n+#pragma omp declare variant (f01) match (device={isa(avx512f,avx512vl)})\n+#pragma omp declare variant (f02) match (device={isa(avx512bw,avx512vl,avx512f)})\n+void f03 (void);\n+void f04 (void);\n+void f05 (void);\n+#pragma omp declare variant (f04) match (device={isa(avx512f,avx512vl)})\n+#pragma omp declare variant (f05) match (device={isa(avx512bw,avx512vl,avx512f)})\n+void f06 (void);\n+void f07 (void);\n+void f08 (void);\n+#pragma omp declare variant (f07) match (device={isa(sse4,sse3,avx)})\n+#pragma omp declare variant (f08) match (device={isa(avx,sse3)})\n+void f09 (void);\n+void f10 (void);\n+void f11 (void);\n+void f12 (void);\n+#pragma omp declare variant (f10) match (device={isa(avx512f)})\n+#pragma omp declare variant (f11) match (user={condition(1)},device={isa(avx512f)},implementation={vendor(gnu)})\n+#pragma omp declare variant (f12) match (user={condition(2 + 1)},device={isa(avx512f)})\n+void f13 (void);\n+void f14 (void);\n+void f15 (void);\n+void f16 (void);\n+void f17 (void);\n+#pragma omp declare variant (f14) match (construct={teams,for})\n+#pragma omp declare variant (f15) match (construct={teams,parallel,for})\n+#pragma omp declare variant (f16) match (construct={for})\n+#pragma omp declare variant (f17) match (construct={parallel,for})\n+void f18 (void);\n+void f19 (void);\n+void f20 (void);\n+void f21 (void);\n+void f22 (void);\n+#pragma omp declare variant (f19) match (construct={teams,for})\n+#pragma omp declare variant (f20) match (construct={teams,parallel,for})\n+#pragma omp declare variant (f21) match (construct={for})\n+#pragma omp declare variant (f22) match (construct={parallel,for})\n+void f23 (void);\n+void f24 (void);\n+void f25 (void);\n+void f26 (void);\n+#pragma omp declare variant (f24) match (device={kind(cpu)})\n+#pragma omp declare variant (f25) match (device={kind(cpu),isa(avx512f),arch(x86_64)})\n+#pragma omp declare variant (f26) match (device={arch(x86_64),kind(cpu)})\n+void f27 (void);\n+\n+void\n+test1 (void)\n+{\n+  int i;\n+  f03 ();\t/* { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f03 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } } */\n+  f09 ();\t/* { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f09 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } } */\n+  f13 ();\t/* { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f13 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } } */\n+  #pragma omp teams distribute parallel for\n+  for (i = 0; i < 1; i++)\n+    f18 ();\t/* { dg-final { scan-tree-dump-times \"f15 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  #pragma omp parallel for\n+  for (i = 0; i < 1; i++)\n+    f23 ();\t/* { dg-final { scan-tree-dump-times \"f22 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  f27 ();\t/* { dg-final { scan-tree-dump-times \"f25 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f24 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f24 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* i?86-*-* x86_64-*-* } } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f27 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { nvptx*-*-* amdgcn*-*-* } } } } */\n+}\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+__attribute__((target (\"no-avx512bw,avx512f,avx512vl\")))\n+#endif\n+void\n+test2 (void)\n+{\n+  f06 ();\t/* { dg-final { scan-tree-dump-times \"f04 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f06 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } } */\n+}"}, {"sha": "159da07d4cb520ddc050475735dc955e33c5137d", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-6.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -7,29 +7,29 @@ double f4 (int, long, float);\n double f5 (int, long, float);\n #pragma omp declare variant (f5) match (user={condition(0)})\n double f6 (int, long, float);\n-#pragma omp declare variant (f5) match (construct={parallel},user={condition(score(1):1)})\t/* { dg-error \"'\\[^'\\n\\r]*f5\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n+#pragma omp declare variant (f5) match (construct={parallel},user={condition(score(1):1)})\t/* { dg-error \"'\\[^'\\n\\r]*f5\\[^'\\n\\r]*' used as a variant with incompatible 'construct' selector sets\" } */\n double f7 (int, long, float);\n double f8 (int, long, float);\n #pragma omp declare variant (f8) match (user={condition(0)},construct={for})\n double f9 (int, long, float);\n-#pragma omp declare variant (f8) match (user={condition(1)})\t\t\t\t\t/* { dg-error \"'\\[^'\\n\\r]*f8\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n+#pragma omp declare variant (f8) match (user={condition(1)})\t\t\t\t\t/* { dg-error \"'\\[^'\\n\\r]*f8\\[^'\\n\\r]*' used as a variant with incompatible 'construct' selector sets\" } */\n double f10 (int, long, float);\n double f11 (int, long, float);\n #pragma omp declare variant (f11) match (construct={target,teams,parallel,for})\n double f12 (int, long, float);\n #pragma omp declare variant (f11) match (user={condition(score(1):1)},construct={target,teams,parallel,for})\n double f13 (int, long, float);\n-#pragma omp declare variant (f11) match (implementation={vendor(gnu)},construct={target,teams,parallel})\t/* { dg-error \"'\\[^'\\n\\r]*f11\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n+#pragma omp declare variant (f11) match (implementation={vendor(gnu)},construct={target,teams,parallel})\t/* { dg-error \"'\\[^'\\n\\r]*f11\\[^'\\n\\r]*' used as a variant with incompatible 'construct' selector sets\" } */\n double f14 (int, long, float);\n-#pragma omp declare variant (f11) match (device={kind(any)},construct={teams,parallel})\t\t/* { dg-error \"'\\[^'\\n\\r]*f11\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n+#pragma omp declare variant (f11) match (device={kind(any)},construct={teams,parallel})\t\t/* { dg-error \"'\\[^'\\n\\r]*f11\\[^'\\n\\r]*' used as a variant with incompatible 'construct' selector sets\" } */\n double f15 (int, long, float);\n double f16 (int, long, float);\n #pragma omp declare variant (f16) match (construct={teams,parallel})\n double f17 (int, long, float);\n-#pragma omp declare variant (f16) match(construct={teams,parallel,for})\t\t\t\t/* { dg-error \"'\\[^'\\n\\r]*f16\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n+#pragma omp declare variant (f16) match(construct={teams,parallel,for})\t\t\t\t/* { dg-error \"'\\[^'\\n\\r]*f16\\[^'\\n\\r]*' used as a variant with incompatible 'construct' selector sets\" } */\n double f18 (int, long, float);\n double f19 (int, long, float);\n #pragma omp declare variant (f19) match (construct={parallel})\n double f20 (int, long, float);\n-#pragma omp declare variant (f19) match (construct={for},implementation={vendor(gnu,llvm)})\t/* { dg-error \"'\\[^'\\n\\r]*f19\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n+#pragma omp declare variant (f19) match (construct={for},implementation={vendor(gnu,llvm)})\t/* { dg-error \"'\\[^'\\n\\r]*f19\\[^'\\n\\r]*' used as a variant with incompatible 'construct' selector sets\" } */\n double f21 (int, long, float);"}, {"sha": "4eebcbcd1d20e718a8b180dd39203bfde03cd781", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-7.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917dd789e55c88123d804a8a411e4a61ee7b6e43/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-7.c?ref=917dd789e55c88123d804a8a411e4a61ee7b6e43", "patch": "@@ -13,23 +13,23 @@ __v4si f3 (__v4si, int, __v4si);\n int f4 (float x, float y, float *z);\n #pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),simdlen(8*2-12),aligned(w:4*sizeof (float)),notinbranch)})\n int f5 (float u, float v, float *w);\n-#pragma omp declare variant (f1) match (construct={parallel,for,simd(linear(w),notinbranch,simdlen(4),aligned(w:4*sizeof (float)))})\t/* { dg-error \"'f1' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(linear(w),notinbranch,simdlen(4),aligned(w:4*sizeof (float)))})\t/* { dg-error \"'f1' used as a variant with incompatible 'construct' selector sets\" \"\" { target c } } */\n int f6 (float u, float v, float *w);\n-#pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),notinbranch,simdlen(4),aligned(w:2*sizeof (float)))})\t/* { dg-error \"'f1' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),notinbranch,simdlen(4),aligned(w:2*sizeof (float)))})\t/* { dg-error \"'f1' used as a variant with incompatible 'construct' selector sets\" \"\" { target c } } */\n int f7 (float u, float v, float *w);\n-#pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),notinbranch,simdlen(4),aligned(w))})\t\t\t/* { dg-error \"'f1' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f1) match (construct={parallel,for,simd(uniform(w),notinbranch,simdlen(4),aligned(w))})\t\t\t/* { dg-error \"'f1' used as a variant with incompatible 'construct' selector sets\" \"\" { target c } } */\n int f8 (float u, float v, float *w);\n #pragma omp declare variant (f2) match (construct={for,simd(uniform(z),simdlen(8),notinbranch)})\n int f9 (float x, float y, float *z);\n #pragma omp declare variant (f2) match (construct={for,simd(notinbranch,simdlen(2+2+4),uniform (q))})\n int f10 (float x, float y, float *q);\n-#pragma omp declare variant (f2) match (construct={for,simd(linear(z:2),simdlen(8),notinbranch)})\t/* { dg-error \"'f2' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f2) match (construct={for,simd(linear(z:2),simdlen(8),notinbranch)})\t/* { dg-error \"'f2' used as a variant with incompatible 'construct' selector sets\" \"\" { target c } } */\n int f11 (float x, float y, float *z);\n #pragma omp declare variant (f3) match (construct={simd(simdlen(4),inbranch,linear(y:1))})\n int f12 (int x, int y);\n #pragma omp declare variant (f3) match (construct={simd(inbranch, simdlen (5-1), linear (q:4-3))})\n int f13 (int x, int q);\n-#pragma omp declare variant (f3) match (construct={simd(inbranch,simdlen(4),linear(q:2))})\t\t/* { dg-error \"'f3' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f3) match (construct={simd(inbranch,simdlen(4),linear(q:2))})\t\t/* { dg-error \"'f3' used as a variant with incompatible 'construct' selector sets\" \"\" { target c } } */\n int f14 (int x, int q);\n #pragma omp declare variant (f3) match (construct={simd(inbranch simdlen (4) linear (q:1))})\t\t/* { dg-error \"clauses in 'simd' trait should be separated by ','\" } */\n int f15 (int x, int q);"}]}