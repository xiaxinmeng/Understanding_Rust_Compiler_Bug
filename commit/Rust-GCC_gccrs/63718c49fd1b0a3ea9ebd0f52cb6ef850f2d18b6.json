{"sha": "63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM3MThjNDlmZDFiMGEzZWE5ZWJkMGY1MmNiNmVmODUwZjJkMThiNg==", "commit": {"author": {"name": "Gerald Baumgartner", "email": "gb@cs.purdue.edu", "date": "1994-06-30T05:35:06Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-30T05:35:06Z"}, "message": "some changes from gb.\n\nFrom-SVN: r7615", "tree": {"sha": "c1be78a9cb5ab3807dd7e284ca6884ea3cd96e7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1be78a9cb5ab3807dd7e284ca6884ea3cd96e7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/comments", "author": null, "committer": null, "parents": [{"sha": "3cf2715de96f3eaafb80120ce4171a0ebf97957f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf2715de96f3eaafb80120ce4171a0ebf97957f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf2715de96f3eaafb80120ce4171a0ebf97957f"}], "stats": {"total": 159, "additions": 114, "deletions": 45}, "files": [{"sha": "a08869685ae90db5741f91ff68e3e4e612227a1d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "patch": "@@ -1,3 +1,36 @@\n+Tue Jun 28 11:58:38 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n+\n+\t* class.c (finish_struct): Don't `cons_up_default_function's\n+\tfor signatures.\n+\t(finish_struct): Handle an empty method_vec correctly.\n+\n+\t* decl.c (grokdeclarator): Don't warn about a signature being\n+\tempty in a signature pointer declaration if we only saw a\n+\tforward declaration of the signature.  Changed `warning's into\n+\t`cp_warning's.\n+\n+\t* sig.c (build_sigtable): Don't die if a null signature table\n+\tconstructor is returned.\n+\t(build_signature_pointer_constructor): If the signature table\n+\tconstructor is null, the _sptr field is set to a null pointer\n+\tand cast to the appropriate type.  Make copies of all null\n+\tpointers so that the type null_pointer_node doesn't get changed.\n+\t(build_signature_table_constructor): Added comments.\n+\n+\t* sig.c (build_signature_pointer_constructor): Complain if we\n+\ttry to assign to/initialize a signature pointer/reference of\n+\tan undefined signature.\n+\n+Mon Jun 27 14:05:16 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n+\n+\t* typeck2.c (store_init_value): Don't be pedantic about\n+\tnon-constant initializers of signature tables/pointers/references.\n+\n+Fri Jun 24 16:49:41 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n+\n+\t* decl.c (grokdeclarator): If we are grokking an opaque typedef\n+\tin a signature, don't complain about it begin static.\n+\n Wed Jun 29 16:44:45 1994  Mike Stump  (mrs@cygnus.com)\n \n \tFixes a problem of the this pointer being wrong in virtual calls to\n@@ -64,7 +97,7 @@ Thu Jun 23 00:22:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \tspecify, say, 'long'.\n \n \t* init.c (do_friend): Do overload C functions (or call pushdecl,\n-        anyaway).\n+\tanyaway).\n \n Wed Jun 22 13:40:49 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n@@ -611,10 +644,10 @@ Tue May 17 13:34:46 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n Mon May 16 23:04:01 1994  Stephen R. van den Berg  (berg@pool.informatik.rwth-aachen.de)\n \n-        * cp/typeck.c (common_type): Attribute merging.\n-        (comp_types): Utilise COMP_TYPE_ATTRIBUTES macro.\n+\t* cp/typeck.c (common_type): Attribute merging.\n+\t(comp_types): Utilise COMP_TYPE_ATTRIBUTES macro.\n \n-        * cp/parse.y: Revamp attribute parsing.\n+\t* cp/parse.y: Revamp attribute parsing.\n \n Mon May 16 01:40:34 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n@@ -1443,7 +1476,7 @@ Fri Apr 22 12:55:42 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t[ cp/* changes propagated from c-* changes in 940206 snapshot ]\n \t* cp/typeck.c (signed_or_unsigned_type): Check for any\n-        INTEGRAL_TYPE_P not just INTEGER_TYPE.\n+\tINTEGRAL_TYPE_P not just INTEGER_TYPE.\n \n \tMon Dec  6 13:35:31 1993  Norbert Kiesel  (norbert@i3.INformatik.rwth-aachen.DE)\n \n@@ -1652,9 +1685,9 @@ Fri Apr 15 16:36:33 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n Fri Apr 15 15:56:35 1994  Kung Hsu  (kung@mexican.cygnus.com)\n \n-        * class.c (build_vtable_entry): revert Apr 4 change.\n-        * decl2.c (mark_vtable_entries): replace pure virtual function\n-        decl with abort's.\n+\t* class.c (build_vtable_entry): revert Apr 4 change.\n+\t* decl2.c (mark_vtable_entries): replace pure virtual function\n+\tdecl with abort's.\n \n Fri Apr 15 13:49:33 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n@@ -2158,8 +2191,8 @@ Wed Mar 30 14:20:50 1994  Mike Stump  (mrs@cygnus.com)\n \tbase class member should be called in some MI situations.\n \n \t* search.c (make_binfo): Use more the more specialized base\n-        binfos from the binfo given as the second argument to make_binfo,\n-        instead of the unspecialized ones from the TYPE_BINFO.\n+\tbinfos from the binfo given as the second argument to make_binfo,\n+\tinstead of the unspecialized ones from the TYPE_BINFO.\n \t* class.c (finish_base_struct): Ditto, update callers.\n \t* search.c (dfs_get_vbase_types): Ditto.\n \t* tree.c (propagate_binfo_offsets, layout_vbasetypes): Ditto.\n@@ -2928,7 +2961,7 @@ Fri Feb 11 11:52:26 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n hu Jan 13 17:55:51 EST 1994 Gnanasekaran Swaminathan (gs4t@virginia.edu)\n \n-            * cp-tree.h (DESTRUCTOR_NAME_P): do not confuse AUTO_TEMP names\n+\t    * cp-tree.h (DESTRUCTOR_NAME_P): do not confuse AUTO_TEMP names\n \t    with destructor names when either NO_DOLLAR_IN_LABEL or\n \t    NO_DOT_IN_LABEL are not defined.\n \n@@ -3950,10 +3983,10 @@ Wed Dec  8 17:38:06 1993  Mike Stump  (mrs@cygnus.com)\n \n Wed Dec  8 13:01:54 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \n-        * cp-call.c (print_harshness) [DEBUG_MATCHING]: New function.\n-        (compute_conversion_costs_ansi) [DEBUG_MATCHING]: Print out\n-        argument matching diagnostics to make instantly clear what the\n-        compiler is doing.\n+\t* cp-call.c (print_harshness) [DEBUG_MATCHING]: New function.\n+\t(compute_conversion_costs_ansi) [DEBUG_MATCHING]: Print out\n+\targument matching diagnostics to make instantly clear what the\n+\tcompiler is doing.\n \n \t* cp-call.c (convert_harshness_ansi): If the parm isn't an lvalue,\n \tthen check to see if the penalty was increased due to\n@@ -3982,19 +4015,19 @@ Tue Dec  7 16:09:34 1993  Jason Merrill  (jason@deneb.cygnus.com)\n \n        Mon Oct  4 12:50:02 1993  Chip Salzenberg  (chip@fin.uucp)\n \n-        [changes propagated from 930810 snapshot]\n-        * cp-decl.c (init_decl_processing): Make long long available for use\n-        as SIZE_TYPE and PTRDIFF_TYPE.\n-        (finish_decl): Allow file-scope static incomplete array.\n-        (grokdeclarator): Don't pass on const and volatile fron function\n-        value type to function type.\n-        Warn here for volatile fn returning non-void type.\n-        * cp-parse.y (attrib): Accept attributes `volatile' with alias\n-        `noreturn', and `const'.\n-        * cp-typeck.c (default_conversion): Don't lose const and volatile.\n-        (build_binary_op_nodefault): Generate pedantic warning for comparison\n-        of complete pointer type with incomplete pointer type.\n-        (build_c_cast): Be careful that null pointer constant be INTEGER_CST.\n+\t[changes propagated from 930810 snapshot]\n+\t* cp-decl.c (init_decl_processing): Make long long available for use\n+\tas SIZE_TYPE and PTRDIFF_TYPE.\n+\t(finish_decl): Allow file-scope static incomplete array.\n+\t(grokdeclarator): Don't pass on const and volatile fron function\n+\tvalue type to function type.\n+\tWarn here for volatile fn returning non-void type.\n+\t* cp-parse.y (attrib): Accept attributes `volatile' with alias\n+\t`noreturn', and `const'.\n+\t* cp-typeck.c (default_conversion): Don't lose const and volatile.\n+\t(build_binary_op_nodefault): Generate pedantic warning for comparison\n+\tof complete pointer type with incomplete pointer type.\n+\t(build_c_cast): Be careful that null pointer constant be INTEGER_CST.\n \n Tue Dec  7 10:46:48 1993  Jason Merrill  (jason@deneb.cygnus.com)\n \n@@ -4278,7 +4311,7 @@ Mon Nov 22 14:22:23 1993  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* cp-decl.c (grokfndecl): Move call to grok_op_properties back\n \tafter grokclassfn so that it's dealing with the right decl.\n-        (grok_op_properties): Don't assert !methodp for op new and op delete.\n+\t(grok_op_properties): Don't assert !methodp for op new and op delete.\n \n \t* cp-init.c (build_delete): Don't use TYPE_BUILT_IN (there are now\n \tno uses of it in the compiler)."}, {"sha": "02282554748b7212f94a7903f38a1d8d22ffc6a7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "patch": "@@ -3270,15 +3270,17 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n      only if no constructor has been declared for class X.  So we\n      check TYPE_HAS_CONSTRUCTOR also, to make sure we don't generate\n      one if they declared a constructor in this class.  */\n-  if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor)\n+  if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor\n+      && ! IS_SIGNATURE (t))\n     {\n       tree default_fn = cons_up_default_function (t, name, fields, 2);\n       TREE_CHAIN (default_fn) = fn_fields;\n       fn_fields = default_fn;\n     }\n \n   /* Create default copy constructor, if needed.  */\n-  if (! TYPE_HAS_INIT_REF (t) && ! cant_synth_copy_ctor)\n+  if (! TYPE_HAS_INIT_REF (t) && ! cant_synth_copy_ctor\n+      && ! IS_SIGNATURE (t))\n     {\n       /* ARM 12.18: You get either X(X&) or X(const X&), but\n \t not both.  --Chip  */\n@@ -3295,7 +3297,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     |= (TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n \t|| has_virtual || first_vfn_base_index >= 0);\n \n-  if (! TYPE_HAS_ASSIGN_REF (t) && ! cant_synth_asn_ref)\n+  if (! TYPE_HAS_ASSIGN_REF (t) && ! cant_synth_asn_ref\n+      && ! IS_SIGNATURE (t))\n     {\n       tree default_fn =\n \tcons_up_default_function (t, name, fields,\n@@ -3341,7 +3344,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     }\n \n   {\n-    int n_methods = TREE_VEC_LENGTH (method_vec);\n+    int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n     \n     for (access_decls = nreverse (access_decls); access_decls;\n \t access_decls = TREE_CHAIN (access_decls))"}, {"sha": "7a0b61466e15d94b4a3580df76c4a990adb5853b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "patch": "@@ -7742,7 +7742,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n   \t  return loc_typedecl;\n \t}\n       else if (decl_context == FIELD\n-\t       && (! IS_SIGNATURE (current_class_type))\n+\t       && (! IS_SIGNATURE (current_class_type)\n+\t\t   || SIGNATURE_GROKKING_TYPEDEF (current_class_type))\n  \t       /* C++ allows static class elements  */\n  \t       && RIDBIT_SETP (RID_STATIC, specbits))\n  \t/* C++ also allows inlines and signed and unsigned elements,\n@@ -8238,9 +8239,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    {\n \t      if (TREE_CODE (declarator) == ADDR_EXPR)\n \t\t{\n-\t\t  if (CLASSTYPE_METHOD_VEC (type) == NULL_TREE)\n-\t\t    warning (\"empty signature `%s' used in signature reference declaration\",\n-\t\t\t     TYPE_NAME_STRING(type));\n+\t\t  if (CLASSTYPE_METHOD_VEC (type) == NULL_TREE\n+\t\t      && TYPE_SIZE (type))\n+\t\t    cp_warning (\"empty signature `%T' used in signature reference declaration\",\n+\t\t\t\ttype);\n #if 0\n \t\t  type = build_signature_reference_type (type,\n \t\t\t\t\t\t\t constp, volatilep);\n@@ -8251,9 +8253,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (CLASSTYPE_METHOD_VEC (type) == NULL_TREE)\n-\t\t    warning (\"empty signature `%s' used in signature pointer declaration\",\n-\t\t\t     TYPE_NAME_STRING(type));\n+\t\t  if (CLASSTYPE_METHOD_VEC (type) == NULL_TREE\n+\t\t      && TYPE_SIZE (type))\n+\t\t    cp_warning (\"empty signature `%T' used in signature pointer declaration\",\n+\t\t\t\ttype);\n \t\t  type = build_signature_pointer_type (type,\n \t\t\t\t\t\t       constp, volatilep);\n \t\t}"}, {"sha": "4f27b9441015643efabbb910cd1f77df74d40ec4", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "patch": "@@ -610,6 +610,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \n   if (result == NULL_TREE)\n     {\n+      /* The signature was empty, we don't need a signature table.  */\n       undo_casts (sig_ty);\n       return NULL_TREE;\n     }\n@@ -618,17 +619,20 @@ build_signature_table_constructor (sig_ty, rhs)\n     {\n       if (first_rhs_field == TYPE_FIELDS (rhstype))\n \t{\n+\t  /* The sptr field on the lhs can be copied from the rhs.  */\n \t  undo_casts (sig_ty);\n \t  return integer_zero_node;\n \t}\n       else\n \t{\n+\t  /* The sptr field on the lhs will point into the rhs sigtable.  */\n \t  undo_casts (sig_ty);\n \t  return build_component_ref (rhs, DECL_NAME (first_rhs_field),\n \t\t\t\t      NULL_TREE, 0);\n \t}\n     }\n \n+  /* We need to construct a new signature table.  */\n   result = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (result));\n   TREE_HAS_CONSTRUCTOR (result) = 1;\n   TREE_CONSTANT (result) = !sig_ptr_p;\n@@ -679,7 +683,7 @@ build_sigtable (sig_type, rhs_type, init_from)\n       SIGTABLE_HAS_BEEN_GENERATED (sig_type) = 1;\n \n       init_expr = build_signature_table_constructor (sig_type, init_from);\n-      if (TREE_CODE (init_expr) != CONSTRUCTOR)\n+      if (init_expr == NULL_TREE || TREE_CODE (init_expr) != CONSTRUCTOR)\n \treturn init_expr;\n \n       if (name == NULL_TREE)\n@@ -748,6 +752,14 @@ build_signature_pointer_constructor (lhs, rhs)\n       return error_mark_node;\n     }\n \n+  if (TYPE_SIZE (sig_ty) == NULL_TREE)\n+    {\n+      cp_error (\"undefined signature `%T' used in signature %s declaration\",\n+\t\tsig_ty,\n+\t\tIS_SIGNATURE_POINTER (lhstype) ? \"pointer\" : \"reference\");\n+      return error_mark_node;\n+    }\n+\n   /* If SIG_TY is permanent, make the signature table constructor and\n      the signature pointer/reference constructor permanent too.  */\n   if (TREE_PERMANENT (sig_ty))\n@@ -779,7 +791,11 @@ build_signature_pointer_constructor (lhs, rhs)\n \t    return error_mark_node;\n \n \t  optr_expr = build_optr_ref (rhs);\n-\t  if (sig_tbl == integer_zero_node)\n+\t  if (sig_tbl == NULL_TREE)\n+\t    /* The signature was empty.  The signature pointer is\n+\t       pretty useless, but the user has been warned.  */\n+\t    sptr_expr = copy_node (null_pointer_node);\n+\t  else if (sig_tbl == integer_zero_node)\n \t    sptr_expr = rhs_sptr_ref;\n \t  else\n \t    sptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n@@ -802,15 +818,23 @@ build_signature_pointer_constructor (lhs, rhs)\n \treturn error_mark_node;\n \n       optr_expr = rhs;\n-      sptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n+      if (sig_tbl == NULL_TREE)\n+\t/* The signature was empty.  The signature pointer is\n+\t   pretty useless, but the user has been warned.  */\n+\t{\n+\t  sptr_expr = copy_node (null_pointer_node);\n+\t  TREE_TYPE (sptr_expr) = build_pointer_type (sig_ty);\n+\t}\n+      else\n+\tsptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n       if (CLASSTYPE_VFIELD (TREE_TYPE (rhstype)))\n \t{\n \t  rhs_vptr = DECL_NAME (CLASSTYPE_VFIELD (TREE_TYPE (rhstype)));\n \t  vptr_expr = build_component_ref (build_indirect_ref (rhs, 0),\n \t\t\t\t\t   rhs_vptr, NULL_TREE, 0);\n \t}\n       else\n-\tvptr_expr = null_pointer_node;\n+\tvptr_expr = copy_node (null_pointer_node);\n       TREE_TYPE (vptr_expr) = build_pointer_type (vtbl_type_node);\n     }\n "}, {"sha": "5935ee934516254aa242e3774fb296555178ec86", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=63718c49fd1b0a3ea9ebd0f52cb6ef850f2d18b6", "patch": "@@ -601,7 +601,13 @@ store_init_value (decl, init)\n     return value;\n   else\n     {\n-      if (pedantic && TREE_CODE (value) == CONSTRUCTOR)\n+      if (pedantic && TREE_CODE (value) == CONSTRUCTOR\n+\t  /* Don't complain about non-constant initializers of\n+\t     signature tables and signature pointers/references.  */\n+\t  && ! (TYPE_LANG_SPECIFIC (type)\n+\t\t&& (IS_SIGNATURE (type)\n+\t\t    || IS_SIGNATURE_POINTER (type)\n+\t\t    || IS_SIGNATURE_REFERENCE (type))))\n \t{\n \t  if (! TREE_CONSTANT (value) || ! TREE_STATIC (value))\n \t    pedwarn (\"ANSI C++ forbids non-constant aggregate initializer expressions\");"}]}