{"sha": "ba325ebaef75a8f698c543eb111e7756a252d3ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzMjVlYmFlZjc1YThmNjk4YzU0M2ViMTExZTc3NTZhMjUyZDNjYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-04-14T01:03:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-04-14T01:03:03Z"}, "message": "When clobbering a reg, check for later words of a multi word reg value\n\nFrom-SVN: r13899", "tree": {"sha": "0f33d4d89db45110779bc3f9b61a7a1c83aee384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f33d4d89db45110779bc3f9b61a7a1c83aee384"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba325ebaef75a8f698c543eb111e7756a252d3ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba325ebaef75a8f698c543eb111e7756a252d3ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba325ebaef75a8f698c543eb111e7756a252d3ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba325ebaef75a8f698c543eb111e7756a252d3ca/comments", "author": null, "committer": null, "parents": [{"sha": "a22ad972279e38bdac5b057846daeb00f1644dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a22ad972279e38bdac5b057846daeb00f1644dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a22ad972279e38bdac5b057846daeb00f1644dce"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "a8774507cb3f4ddf4f5cc5c2d24f931068971223", "filename": "gcc/reload1.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba325ebaef75a8f698c543eb111e7756a252d3ca/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba325ebaef75a8f698c543eb111e7756a252d3ca/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ba325ebaef75a8f698c543eb111e7756a252d3ca", "patch": "@@ -7551,6 +7551,12 @@ count_occurrences (x, find)\n \n static rtx *reg_values;\n \n+/* This is a preallocated REG rtx which we use as a temporary in\n+   reload_cse_invalidate_regno, so that we don't need to allocate a\n+   new one each time through a loop in that function.  */\n+\n+static rtx invalidate_regno_rtx;\n+\n /* Invalidate any entries in reg_values which depend on REGNO,\n    including those for REGNO itself.  This is called if REGNO is\n    changing.  If CLOBBER is true, then always forget anything we\n@@ -7608,6 +7614,33 @@ reload_cse_invalidate_regno (regno, mode, clobber)\n \t    }\n \t}\n     }\n+\n+  /* We must look at earlier registers, in case REGNO is part of a\n+     multi word value but is not the first register.  If an earlier\n+     register has a value in a mode which overlaps REGNO, then we must\n+     invalidate that earlier register.  Note that we do not need to\n+     check REGNO or later registers (we must not check REGNO itself,\n+     because we would incorrectly conclude that there was a conflict).  */\n+\n+  for (i = 0; i < regno; i++)\n+    {\n+      rtx x;\n+\n+      for (x = reg_values[i]; x; x = XEXP (x, 1))\n+\t{\n+\t  if (XEXP (x, 0) != 0)\n+\t    {\n+\t      PUT_MODE (invalidate_regno_rtx, GET_MODE (XEXP (x, 0)));\n+\t      REGNO (invalidate_regno_rtx) = i;\n+\t      if (refers_to_regno_p (regno, endregno, invalidate_regno_rtx,\n+\t\t\t\t     NULL_PTR))\n+\t\t{\n+\t\t  reload_cse_invalidate_regno (i, VOIDmode, 1);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n }\n \n /* The memory at address (plus MEM_BASE MEM_OFFSET), where MEM_OFFSET\n@@ -7800,6 +7833,10 @@ reload_cse_regs (first)\n      memory for a non-const call instruction.  */\n   callmem = gen_rtx (MEM, BLKmode, const0_rtx);\n \n+  /* This is used in reload_cse_invalidate_regno to avoid consing a\n+     new REG in a loop in that function.  */\n+  invalidate_regno_rtx = gen_rtx (REG, VOIDmode, 0);\n+\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       rtx body;"}]}