{"sha": "2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ1OTU4ODc1ZDJkZjE1ZDZkMDRhMzM3MWRkNmI1NGVjMTRhNGU1Mw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2015-12-17T14:10:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2015-12-17T14:10:32Z"}, "message": "DWARF: describe properly Ada packed arrays\n\ngcc/ada/ChangeLog:\n\n\t* gcc-interface/ada-tree.h\n\t(TYPE_IMPLEMENTS_PACKED_ARRAY_P, TYPE_CAN_HAVE_DEBUG_TYPE_P,\n\tTYPE_ORIGINAL_PACKED_ARRAY, SET_TYPE_ORIGINAL_PACKED_ARRAY): New\n\tmacros.\n\t* gcc-interface/decl.c (add_parallel_type_for_packed_array):\n\tRename to associate_original_type_to_packed_array.  When\n\t-fgnat-encodings=minimal, set original packed array type as so\n\tinstead of as a parallel type to the implementation type.  In\n\tthis case, also rename the implementation type to the name of\n\tthe original array type.\n\t(gnat_to_gnu_entity): Update invocations to\n\tadd_parallel_type_for_packed_array.  Tag ARRAY_TYPE nodes for\n\tpacked arrays with the TYPE_PACKED flag.\n\tWhen -fgnat-encodings=minimal:\n\t  - strip ___XP suffixes in packed arrays' names;\n\t  - set the debug type for padding records around packed arrays\n\t    to the packed array;\n\t  - do not attach ___XUP types as parallel types of constrained\n\t    array types.\n\t* gcc-interface/misc.c (gnat_print_type): Update to handle\n\torignal packed arrays.\n\t(gnat_get_debug_type): Update to reject packed arrays\n\timplementation types.\n\t(get_array_bit_stride): New.\n\t(gnat_get_array_descr_info): Add packed arrays handling.\n\t* gcc-interface/utils.c (maybe_pad_type): When\n\t-fgnat-encodings=minimal, set the name of the padding type to\n\tthe one of the original packed type, if any.  Fix TYPE_DECL\n\tpeeling around the name of the input type.\n\nFrom-SVN: r231768", "tree": {"sha": "5c7367eb96eaa74caac0e65ec96a0af93b99340e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c7367eb96eaa74caac0e65ec96a0af93b99340e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69c5f9d7b57c82797154bdc199e69326ac981101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69c5f9d7b57c82797154bdc199e69326ac981101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69c5f9d7b57c82797154bdc199e69326ac981101"}], "stats": {"total": 281, "additions": 252, "deletions": 29}, "files": [{"sha": "0ad84e2bb763f6d72429cd0c818caf7dfc21582f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "patch": "@@ -1,3 +1,35 @@\n+2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h\n+\t(TYPE_IMPLEMENTS_PACKED_ARRAY_P, TYPE_CAN_HAVE_DEBUG_TYPE_P,\n+\tTYPE_ORIGINAL_PACKED_ARRAY, SET_TYPE_ORIGINAL_PACKED_ARRAY): New\n+\tmacros.\n+\t* gcc-interface/decl.c (add_parallel_type_for_packed_array):\n+\tRename to associate_original_type_to_packed_array.  When\n+\t-fgnat-encodings=minimal, set original packed array type as so\n+\tinstead of as a parallel type to the implementation type.  In\n+\tthis case, also rename the implementation type to the name of\n+\tthe original array type.\n+\t(gnat_to_gnu_entity): Update invocations to\n+\tadd_parallel_type_for_packed_array.  Tag ARRAY_TYPE nodes for\n+\tpacked arrays with the TYPE_PACKED flag.\n+\tWhen -fgnat-encodings=minimal:\n+\t  - strip ___XP suffixes in packed arrays' names;\n+\t  - set the debug type for padding records around packed arrays\n+\t    to the packed array;\n+\t  - do not attach ___XUP types as parallel types of constrained\n+\t    array types.\n+\t* gcc-interface/misc.c (gnat_print_type): Update to handle\n+\torignal packed arrays.\n+\t(gnat_get_debug_type): Update to reject packed arrays\n+\timplementation types.\n+\t(get_array_bit_stride): New.\n+\t(gnat_get_array_descr_info): Add packed arrays handling.\n+\t* gcc-interface/utils.c (maybe_pad_type): When\n+\t-fgnat-encodings=minimal, set the name of the padding type to\n+\tthe one of the original packed type, if any.  Fix TYPE_DECL\n+\tpeeling around the name of the input type.\n+\n 2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc-interface/misc.c (gnat_get_type_bias): New."}, {"sha": "830062791b9734c62d0e839ca0a1441c6f8d0d49", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "patch": "@@ -187,6 +187,17 @@ do {\t\t\t\t\t\t\t \\\n    alignment value the type ought to have.  */\n #define TYPE_MAX_ALIGN(NODE) (TYPE_PRECISION (RECORD_OR_UNION_CHECK (NODE)))\n \n+/* True for types that implement a packed array and for original packed array\n+   types.  */\n+#define TYPE_IMPLEMENTS_PACKED_ARRAY_P(NODE) \\\n+  ((TREE_CODE (NODE) == ARRAY_TYPE && TYPE_PACKED (NODE))\t\t      \\\n+    || (TREE_CODE (NODE) == INTEGER_TYPE && TYPE_PACKED_ARRAY_TYPE_P (NODE))) \\\n+\n+/* True for types that can hold a debug type.  */\n+#define TYPE_CAN_HAVE_DEBUG_TYPE_P(NODE)  \\\n+ (!TYPE_IMPLEMENTS_PACKED_ARRAY_P (NODE)  \\\n+  && TYPE_DEBUG_TYPE (NODE) != NULL_TREE)\n+\n /* For an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the\n    template and the object.\n \n@@ -374,6 +385,21 @@ do {\t\t\t\t\t\t   \\\n #define SET_TYPE_SCALE_FACTOR(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n+/* For types with TYPE_CAN_HAVE_DEBUG_TYPE_P, this is the type to use in\n+   debugging information.  */\n+#define TYPE_DEBUG_TYPE(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC2(NODE)\n+#define SET_TYPE_DEBUG_TYPE(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC2(NODE, X)\n+\n+/* For types with TYPE_IMPLEMENTS_PACKED_ARRAY_P, this is the original packed\n+   array type.  Note that this predicate is trou for original packed array\n+   types, so these cannot have a debug type.  */\n+#define TYPE_ORIGINAL_PACKED_ARRAY(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC2(NODE)\n+#define SET_TYPE_ORIGINAL_PACKED_ARRAY(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC2(NODE, X)\n+\n \n /* Flags added to decl nodes.  */\n "}, {"sha": "7058ef0809fea541ed67c1495b579b7c616f1a3a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "patch": "@@ -195,7 +195,7 @@ static tree get_rep_part (tree);\n static tree create_variant_part_from (tree, vec<variant_desc> , tree,\n \t\t\t\t      tree, vec<subst_pair> );\n static void copy_and_substitute_in_size (tree, tree, vec<subst_pair> );\n-static void add_parallel_type_for_packed_array (tree, Entity_Id);\n+static void associate_original_type_to_packed_array (tree, Entity_Id);\n static const char *get_entity_char (Entity_Id);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n@@ -1806,9 +1806,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TYPE_STUB_DECL (gnu_type)\n \t= create_type_stub_decl (gnu_entity_name, gnu_type);\n \n-      /* For a packed array, make the original array type a parallel type.  */\n+      /* For a packed array, make the original array type a parallel/debug\n+\t type.  */\n       if (debug_info_p && Is_Packed_Array_Impl_Type (gnat_entity))\n-\tadd_parallel_type_for_packed_array (gnu_type, gnat_entity);\n+\tassociate_original_type_to_packed_array (gnu_type, gnat_entity);\n \n     discrete_type:\n \n@@ -1841,6 +1842,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n \n+\t  /* Strip the ___XP suffix for standard DWARF.  */\n+\t  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t    gnu_entity_name = TYPE_NAME (gnu_type);\n+\n \t  /* Create a stripped-down declaration, mainly for debugging.  */\n \t  create_type_decl (gnu_entity_name, gnu_type, true, debug_info_p,\n \t\t\t    gnat_entity);\n@@ -1885,8 +1890,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  if (debug_info_p)\n \t    {\n-\t      /* Make the original array type a parallel type.  */\n-\t      add_parallel_type_for_packed_array (gnu_type, gnat_entity);\n+\t      /* Make the original array type a parallel/debug type.  */\n+\t      associate_original_type_to_packed_array (gnu_type, gnat_entity);\n+\n+\t      /* Since GNU_TYPE is a padding type around the packed array\n+\t\t implementation type, the padded type is its debug type.  */\n+\t      if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t\tSET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n \n \t      rest_of_record_type_compilation (gnu_type);\n \t    }\n@@ -2241,6 +2251,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \tTYPE_CONVENTION_FORTRAN_P (tem) = convention_fortran_p;\n \n+\t/* Tag top-level ARRAY_TYPE nodes for packed arrays and their\n+\t   implementation types as such so that the debug information back-end\n+\t   can output the appropriate description for them.  */\n+\tTYPE_PACKED (tem)\n+\t  = (Is_Packed (gnat_entity)\n+\t     || Is_Packed_Array_Impl_Type (gnat_entity));\n+\n \tif (Treat_As_Volatile (gnat_entity))\n \t  tem = change_qualified_type (tem, TYPE_QUAL_VOLATILE);\n \n@@ -2603,6 +2620,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n \t    }\n \n+\t  /* Strip the ___XP suffix for standard DWARF.  */\n+\t  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n+\t      && Is_Packed_Array_Impl_Type (gnat_entity))\n+\t    {\n+\t      Entity_Id gnat_original_array_type\n+\t\t= Underlying_Type (Original_Array_Type (gnat_entity));\n+\n+\t      gnu_entity_name\n+\t\t= get_entity_name (gnat_original_array_type);\n+\t    }\n+\n \t  /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n \t  TYPE_STUB_DECL (gnu_type)\n \t    = create_type_stub_decl (gnu_entity_name, gnu_type);\n@@ -2677,17 +2705,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n \t  /* If this is a packed array type, make the original array type a\n-\t     parallel type.  Otherwise, do it for the base array type if it\n-\t     isn't artificial to make sure it is kept in the debug info.  */\n+\t     parallel/debug type.  Otherwise, if such GNAT encodings are\n+\t     required, do it for the base array type if it isn't artificial to\n+\t     make sure it is kept in the debug info.  */\n \t  if (debug_info_p)\n \t    {\n \t      if (Is_Packed_Array_Impl_Type (gnat_entity))\n-\t\tadd_parallel_type_for_packed_array (gnu_type, gnat_entity);\n+\t\tassociate_original_type_to_packed_array (gnu_type,\n+\t\t\t\t\t\t\t gnat_entity);\n \t      else\n \t\t{\n \t\t  tree gnu_base_decl\n \t\t    = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, 0);\n-\t\t  if (!DECL_ARTIFICIAL (gnu_base_decl))\n+\t\t  if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\t\t      && !DECL_ARTIFICIAL (gnu_base_decl))\n \t\t    add_parallel_type (gnu_type,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (gnu_base_decl)));\n \t\t}\n@@ -2698,6 +2729,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    = (Is_Packed_Array_Impl_Type (gnat_entity)\n \t       && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n \n+\t/* Tag top-level ARRAY_TYPE nodes for packed arrays and their\n+\t   implementation types as such so that the debug information back-end\n+\t   can output the appropriate description for them.  */\n+\t  TYPE_PACKED (gnu_type)\n+\t    = (Is_Packed (gnat_entity)\n+\t       || Is_Packed_Array_Impl_Type (gnat_entity));\n+\n \t  /* If the size is self-referential and the maximum size doesn't\n \t     overflow, use it.  */\n \t  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n@@ -2754,6 +2792,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t      NULL_TREE, 0);\n \t      this_made_decl = true;\n \t      gnu_type = TREE_TYPE (gnu_decl);\n+\n \t      save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n \t      gnu_inner = gnu_type;\n@@ -8832,12 +8871,14 @@ copy_and_substitute_in_size (tree new_type, tree old_type,\n   TYPE_SIZE_UNIT (new_type) = variable_size (TYPE_SIZE_UNIT (new_type));\n }\n \n-/* Add a parallel type to GNU_TYPE, the translation of GNAT_ENTITY, which is\n-   the implementation type of a packed array type (Is_Packed_Array_Impl_Type).\n-   The parallel type is the original array type if it has been translated.  */\n+/* Associate to GNU_TYPE, the translation of GNAT_ENTITY, which is\n+   the implementation type of a packed array type (Is_Packed_Array_Impl_Type),\n+   the original array type if it has been translated.  This association is a\n+   parallel type for GNAT encodings or a debug type for standard DWARF.  Note\n+   that for standard DWARF, we also want to get the original type name.  */\n \n static void\n-add_parallel_type_for_packed_array (tree gnu_type, Entity_Id gnat_entity)\n+associate_original_type_to_packed_array (tree gnu_type, Entity_Id gnat_entity)\n {\n   Entity_Id gnat_original_array_type\n     = Underlying_Type (Original_Array_Type (gnat_entity));\n@@ -8851,7 +8892,18 @@ add_parallel_type_for_packed_array (tree gnu_type, Entity_Id gnat_entity)\n   if (TYPE_IS_DUMMY_P (gnu_original_array_type))\n     return;\n \n-  add_parallel_type (gnu_type, gnu_original_array_type);\n+  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+    {\n+      tree original_name = TYPE_NAME (gnu_original_array_type);\n+\n+      if (TREE_CODE (original_name) == TYPE_DECL)\n+\toriginal_name = DECL_NAME (original_name);\n+\n+      SET_TYPE_ORIGINAL_PACKED_ARRAY (gnu_type, gnu_original_array_type);\n+      TYPE_NAME (gnu_type) = original_name;\n+    }\n+  else\n+    add_parallel_type (gnu_type, gnu_original_array_type);\n }\n \f\n /* Given a type T, a FIELD_DECL F, and a replacement value R, return a"}, {"sha": "adaea7f6465618fd29004a8ac22def43ad49cfd0", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 117, "deletions": 14, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "patch": "@@ -528,9 +528,12 @@ gnat_print_type (FILE *file, tree node, int indent)\n       break;\n     }\n \n-  if (TYPE_DEBUG_TYPE (node) != NULL_TREE)\n-    print_node_brief (file, \"debug type\", TYPE_DEBUG_TYPE (node),\n-\t\t      indent + 4);\n+  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (node) && TYPE_DEBUG_TYPE (node) != NULL_TREE)\n+    print_node_brief (file, \"debug type\", TYPE_DEBUG_TYPE (node), indent + 4);\n+  else if (TYPE_IMPLEMENTS_PACKED_ARRAY_P (node)\n+\t   && TYPE_ORIGINAL_PACKED_ARRAY (node) != NULL_TREE)\n+    print_node_brief (file, \"original packed array\",\n+\t\t      TYPE_ORIGINAL_PACKED_ARRAY (node), indent + 4);\n }\n \n /* Return the name to be printed for DECL.  */\n@@ -578,7 +581,18 @@ gnat_descriptive_type (const_tree type)\n static tree\n gnat_get_debug_type (const_tree type)\n {\n-  return TYPE_DEBUG_TYPE (type);\n+  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type))\n+    {\n+      type = TYPE_DEBUG_TYPE (type);\n+      /* ??? Kludge: the get_debug_type language hook is processed after the\n+\t array descriptor language hook, so if there is an array behind this\n+\t type, the latter is supposed to handle it.  Still, we can get here\n+\t with a type we are not supposed to handle (when the DWARF back-end\n+\t processes the type of a variable), so keep this guard.  */\n+      if (type != NULL_TREE && !TYPE_IMPLEMENTS_PACKED_ARRAY_P (type))\n+\treturn const_cast<tree> (type);\n+    }\n+  return NULL_TREE;\n }\n \n /* Provide information in INFO for debugging output about the TYPE fixed-point\n@@ -732,17 +746,21 @@ gnat_type_max_size (const_tree gnu_type)\n   return max_unitsize;\n }\n \n+static tree get_array_bit_stride (tree comp_type);\n+\n /* Provide information in INFO for debug output about the TYPE array type.\n    Return whether TYPE is handled.  */\n \n static bool\n-gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n+gnat_get_array_descr_info (const_tree const_type,\n+\t\t\t   struct array_descr_info *info)\n {\n   bool convention_fortran_p;\n   bool is_array = false;\n   bool is_fat_ptr = false;\n+  bool is_packed_array = false;\n \n-  const tree type_ = const_cast<tree> (type);\n+  tree type = const_cast<tree> (const_type);\n \n   const_tree first_dimen = NULL_TREE;\n   const_tree last_dimen = NULL_TREE;\n@@ -756,6 +774,20 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   tree thinptr_template_expr = NULL_TREE;\n   tree thinptr_bound_field = NULL_TREE;\n \n+  /* ??? Kludge: see gnat_get_debug_type.  */\n+  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type)\n+      && TYPE_DEBUG_TYPE (type) != NULL_TREE)\n+    type = TYPE_DEBUG_TYPE (type);\n+\n+  /* If we have an implementation type for a packed array, get the orignial\n+     array type.  */\n+  if (TYPE_IMPLEMENTS_PACKED_ARRAY_P (type)\n+      && TYPE_ORIGINAL_PACKED_ARRAY (type) != NULL_TREE)\n+    {\n+      is_packed_array = true;\n+      type = TYPE_ORIGINAL_PACKED_ARRAY (type);\n+    }\n+\n   /* First pass: gather all information about this array except everything\n      related to dimensions.  */\n \n@@ -772,10 +804,10 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   else if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n \t   && TYPE_IS_FAT_POINTER_P (type))\n     {\n-      const tree ua_type = TYPE_UNCONSTRAINED_ARRAY (type_);\n+      const tree ua_type = TYPE_UNCONSTRAINED_ARRAY (type);\n \n       /* This will be our base object address.  */\n-      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type_);\n+      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n \n       /* We assume below that maybe_unconstrained_array returns an INDIRECT_REF\n \t node.  */\n@@ -803,7 +835,7 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n       /* This will be our base object address.  Note that we assume that\n \t pointers to these will actually point to the array field (thin\n \t pointers are shifted).  */\n-      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type_);\n+      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n       const tree placeholder_addr\n         = build_unary_op (ADDR_EXPR, NULL_TREE, placeholder_expr);\n \n@@ -838,6 +870,8 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   /* Second pass: compute the remaining information: dimensions and\n      corresponding bounds.  */\n \n+  if (TYPE_PACKED (first_dimen))\n+    is_packed_array = true;\n   /* If this array has fortran convention, it's arranged in column-major\n      order, so our view here has reversed dimensions.  */\n   convention_fortran_p = TYPE_CONVENTION_FORTRAN_P (first_dimen);\n@@ -937,13 +971,13 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   info->allocated = NULL_TREE;\n   info->associated = NULL_TREE;\n \n-  /* When arrays contain dynamically-sized elements, we usually wrap them in\n-     padding types, or we create constrained types for them.  Then, if such\n-     types are stripped in the debugging information output, the debugger needs\n-     a way to know the size that is reserved for each element.  This is why we\n-     emit a stride in such situations.  */\n   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     {\n+      /* When arrays contain dynamically-sized elements, we usually wrap them\n+\t in padding types, or we create constrained types for them.  Then, if\n+\t such types are stripped in the debugging information output, the\n+\t debugger needs a way to know the size that is reserved for each\n+\t element.  This is why we emit a stride in such situations.  */\n       tree source_element_type = info->element_type;\n \n       while (1)\n@@ -962,11 +996,80 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n \t  info->stride = TYPE_SIZE_UNIT (info->element_type);\n \t  info->stride_in_bits = false;\n \t}\n+\n+      /* We need to specify a bit stride when it does not correspond to the\n+\t natural size of the contained elements.  ??? Note that we do not\n+\t support packed records and nested packed arrays.  */\n+      else if (is_packed_array)\n+\t{\n+\t  info->stride = get_array_bit_stride (info->element_type);\n+\t  info->stride_in_bits = true;\n+\t}\n     }\n \n   return true;\n }\n \n+/* Given the component type COMP_TYPE of a packed array, return an expression\n+   that computes the bit stride of this packed array.  Return NULL_TREE when\n+   unsuccessful.  */\n+\n+static tree\n+get_array_bit_stride (tree comp_type)\n+{\n+  struct array_descr_info info;\n+  tree stride;\n+\n+  /* Simple case: the array contains an integral type: return its RM size.  */\n+  if (INTEGRAL_TYPE_P (comp_type))\n+    return TYPE_RM_SIZE (comp_type);\n+\n+  /* Otherwise, see if this is an array we can analyze.  */\n+  memset (&info, 0, sizeof (info));\n+  if (!gnat_get_array_descr_info (comp_type, &info)\n+      || info.stride == NULL_TREE)\n+    /* If it's not, give it up.  */\n+    return NULL_TREE;\n+\n+  /* Otherwise, the array stride is the inner array's stride multiplied by the\n+     number of elements it contains.  Note that if the inner array is not\n+     packed, then the stride is \"natural\" and thus does not deserve an\n+     attribute.  */\n+  stride = info.stride;\n+  if (!info.stride_in_bits)\n+    {\n+      stride = fold_convert (bitsizetype, stride);\n+      stride = build_binary_op (MULT_EXPR, bitsizetype,\n+\t\t\t\tstride, build_int_cstu (bitsizetype, 8));\n+    }\n+\n+  for (int i = 0; i < info.ndimensions; ++i)\n+    {\n+      tree count;\n+\n+      if (info.dimen[i].lower_bound == NULL_TREE\n+\t  || info.dimen[i].upper_bound == NULL_TREE)\n+\treturn NULL_TREE;\n+\n+      /* Put in count an expression that computes the length of this\n+\t dimension.  */\n+      count = build_binary_op (MINUS_EXPR, sbitsizetype,\n+\t\t\t       fold_convert (sbitsizetype,\n+\t\t\t\t\t     info.dimen[i].upper_bound),\n+\t\t\t       fold_convert (sbitsizetype,\n+\t\t\t\t\t     info.dimen[i].lower_bound)),\n+      count = build_binary_op (PLUS_EXPR, sbitsizetype,\n+\t\t\t       count, build_int_cstu (sbitsizetype, 1));\n+      count = build_binary_op (MAX_EXPR, sbitsizetype,\n+\t\t\t       count,\n+\t\t\t       build_int_cstu (sbitsizetype, 0));\n+      count = fold_convert (bitsizetype, count);\n+      stride = build_binary_op (MULT_EXPR, bitsizetype, stride, count);\n+    }\n+\n+  return stride;\n+}\n+\n /* GNU_TYPE is a subtype of an integral type.  Set LOWVAL to the low bound\n    and HIGHVAL to the high bound, respectively.  */\n "}, {"sha": "be3565a503f209ce0dd58720f1a087be0db27915", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5958875d2df15d6d04a3371dd6b54ec14a4e53/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=2d5958875d2df15d6d04a3371dd6b54ec14a4e53", "patch": "@@ -1281,7 +1281,17 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     SET_TYPE_DEBUG_TYPE (record, type);\n \n-  if (Present (gnat_entity))\n+  /* ??? Kludge: padding types around packed array implementation types will be\n+     considered as root types in the array descriptor language hook (see\n+     gnat_get_array_descr_info). Give them the original packed array type\n+     name so that the one coming from sources appears in the debugging\n+     information.  */\n+  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n+      && TYPE_IMPLEMENTS_PACKED_ARRAY_P (type)\n+      && TYPE_ORIGINAL_PACKED_ARRAY (type) != NULL_TREE)\n+    TYPE_NAME (record)\n+      = TYPE_NAME (TYPE_ORIGINAL_PACKED_ARRAY (type));\n+  else if (Present (gnat_entity))\n     TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n \n   TYPE_ALIGN (record) = align ? align : orig_align;"}]}