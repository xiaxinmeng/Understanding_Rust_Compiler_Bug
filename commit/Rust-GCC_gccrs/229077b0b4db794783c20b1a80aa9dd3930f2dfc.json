{"sha": "229077b0b4db794783c20b1a80aa9dd3930f2dfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5MDc3YjBiNGRiNzk0NzgzYzIwYjFhODBhYTlkZDM5MzBmMmRmYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-07T07:56:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-07T07:56:11Z"}, "message": "decl.c (compile_time_known_address_p): Rewrite and move around.\n\n\t* decl.c (compile_time_known_address_p): Rewrite and move around.\n\t(gnat_to_gnu_type): Move around.\n\t(get_unpadded_type): Likewise.\n\t* utils.c (update_pointer_to): Use synthetic macro.  Tidy comments.\n\nFrom-SVN: r145654", "tree": {"sha": "081d242e0ca0a5eddc2247ac83e5a3a9af09d3f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/081d242e0ca0a5eddc2247ac83e5a3a9af09d3f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/229077b0b4db794783c20b1a80aa9dd3930f2dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229077b0b4db794783c20b1a80aa9dd3930f2dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229077b0b4db794783c20b1a80aa9dd3930f2dfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229077b0b4db794783c20b1a80aa9dd3930f2dfc/comments", "author": null, "committer": null, "parents": [{"sha": "c22ba5ffd45f706eda740bbc727b33995565da95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22ba5ffd45f706eda740bbc727b33995565da95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c22ba5ffd45f706eda740bbc727b33995565da95"}], "stats": {"total": 155, "additions": 81, "deletions": 74}, "files": [{"sha": "b20183b752087ae29847f11d02c12a7baed2d335", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229077b0b4db794783c20b1a80aa9dd3930f2dfc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229077b0b4db794783c20b1a80aa9dd3930f2dfc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=229077b0b4db794783c20b1a80aa9dd3930f2dfc", "patch": "@@ -1,3 +1,10 @@\n+2009-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (compile_time_known_address_p): Rewrite and move around.\n+\t(gnat_to_gnu_type): Move around.\n+\t(get_unpadded_type): Likewise.\n+\t* utils.c (update_pointer_to): Use synthetic macro.  Tidy comments.\n+\n 2009-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (check_for_eliminated_entity): New function."}, {"sha": "ed484c4a542e5a32a4a52e8a978b12556efb5851", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229077b0b4db794783c20b1a80aa9dd3930f2dfc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229077b0b4db794783c20b1a80aa9dd3930f2dfc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=229077b0b4db794783c20b1a80aa9dd3930f2dfc", "patch": "@@ -139,6 +139,7 @@ static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (Entity_Id, tree);\n+static bool compile_time_known_address_p (Node_Id);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n \t\t\t\t  bool, bool, bool, bool);\n static Uint annotate_value (tree);\n@@ -152,36 +153,6 @@ static unsigned int ceil_alignment (unsigned HOST_WIDE_INT);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n static int compatible_signatures_p (tree ftype1, tree ftype2);\n static void rest_of_type_decl_compilation_no_defer (tree);\n-\n-/* Return true if GNAT_ADDRESS is a compile time known value.\n-   In particular catch System'To_Address.  */\n-\n-static bool\n-compile_time_known_address_p (Node_Id gnat_address)\n-{\n-  return ((Nkind (gnat_address) == N_Unchecked_Type_Conversion\n-\t   && Compile_Time_Known_Value (Expression (gnat_address)))\n-\t  || Compile_Time_Known_Value (gnat_address));\n-}\n-\n-/* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n-   GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n-   refer to an Ada type.  */\n-\n-tree\n-gnat_to_gnu_type (Entity_Id gnat_entity)\n-{\n-  tree gnu_decl;\n-\n-  /* The back end never attempts to annotate generic types */\n-  if (Is_Generic_Type (gnat_entity) && type_annotate_only)\n-     return void_type_node;\n-\n-  /* Convert the ada entity type into a GCC TYPE_DECL node.  */\n-  gnu_decl = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n-  gcc_assert (TREE_CODE (gnu_decl) == TYPE_DECL);\n-  return TREE_TYPE (gnu_decl);\n-}\n \f\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, this routine returns the equivalent GCC tree for that entity\n@@ -4757,6 +4728,38 @@ gnat_to_gnu_field_decl (Entity_Id gnat_entity)\n   return gnu_field;\n }\n \n+/* Similar, but GNAT_ENTITY is assumed to refer to a GNAT type.  Return\n+   the GCC type corresponding to that entity.  */\n+\n+tree\n+gnat_to_gnu_type (Entity_Id gnat_entity)\n+{\n+  tree gnu_decl;\n+\n+  /* The back end never attempts to annotate generic types.  */\n+  if (Is_Generic_Type (gnat_entity) && type_annotate_only)\n+     return void_type_node;\n+\n+  gnu_decl = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+  gcc_assert (TREE_CODE (gnu_decl) == TYPE_DECL);\n+\n+  return TREE_TYPE (gnu_decl);\n+}\n+\n+/* Similar, but GNAT_ENTITY is assumed to refer to a GNAT type.  Return\n+   the unpadded version of the GCC type corresponding to that entity.  */\n+\n+tree\n+get_unpadded_type (Entity_Id gnat_entity)\n+{\n+  tree type = gnat_to_gnu_type (gnat_entity);\n+\n+  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+    type = TREE_TYPE (TYPE_FIELDS (type));\n+\n+  return type;\n+}\n+\f\n /* Wrap up compilation of DECL, a TYPE_DECL, possibly deferring it.\n    Every TYPE_DECL generated for a type definition must be passed\n    to this function once everything else has been done for it.  */\n@@ -5093,6 +5096,18 @@ array_type_has_nonaliased_component (Entity_Id gnat_type, tree gnu_type)\n \n   return type_for_nonaliased_component_p (TREE_TYPE (gnu_type));\n }\n+\n+/* Return true if GNAT_ADDRESS is a value known at compile-time.  */\n+\n+static bool\n+compile_time_known_address_p (Node_Id gnat_address)\n+{\n+  /* Catch System'To_Address.  */\n+  if (Nkind (gnat_address) == N_Unchecked_Type_Conversion)\n+    gnat_address = Expression (gnat_address);\n+\n+  return Compile_Time_Known_Value (gnat_address);\n+}\n \f\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n@@ -5440,19 +5455,6 @@ prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n       }\n }\n \f\n-/* Get the unpadded version of a GNAT type.  */\n-\n-tree\n-get_unpadded_type (Entity_Id gnat_entity)\n-{\n-  tree type = gnat_to_gnu_type (gnat_entity);\n-\n-  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n-    type = TREE_TYPE (TYPE_FIELDS (type));\n-\n-  return type;\n-}\n-\f\n /* Called when we need to protect a variable object using a save_expr.  */\n \n tree"}, {"sha": "c46b7ddc1cc72a3aa890c6b7f03682d18aaf1f0a", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229077b0b4db794783c20b1a80aa9dd3930f2dfc/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229077b0b4db794783c20b1a80aa9dd3930f2dfc/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=229077b0b4db794783c20b1a80aa9dd3930f2dfc", "patch": "@@ -3738,9 +3738,9 @@ shift_unc_components_for_thin_pointers (tree type)\n   DECL_FIELD_BIT_OFFSET (array_field) = bitsize_zero_node;\n }\n \f\n-/* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n-   the normal case this is just two adjustments, but we have more to do\n-   if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */\n+/* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.\n+   In the normal case this is just two adjustments, but we have more to\n+   do if NEW_TYPE is an UNCONSTRAINED_ARRAY_TYPE.  */\n \n void\n update_pointer_to (tree old_type, tree new_type)\n@@ -3756,35 +3756,34 @@ update_pointer_to (tree old_type, tree new_type)\n \t type = TYPE_NEXT_VARIANT (type))\n       update_pointer_to (type, new_type);\n \n-  /* If no pointer or reference, we are done.  */\n+  /* If no pointers and no references, we are done.  */\n   if (!ptr && !ref)\n     return;\n \n   /* Merge the old type qualifiers in the new type.\n \n      Each old variant has qualifiers for specific reasons, and the new\n-     designated type as well. Each set of qualifiers represents useful\n+     designated type as well.  Each set of qualifiers represents useful\n      information grabbed at some point, and merging the two simply unifies\n      these inputs into the final type description.\n \n      Consider for instance a volatile type frozen after an access to constant\n-     type designating it. After the designated type freeze, we get here with a\n-     volatile new_type and a dummy old_type with a readonly variant, created\n-     when the access type was processed. We shall make a volatile and readonly\n+     type designating it; after the designated type's freeze, we get here with\n+     a volatile NEW_TYPE and a dummy OLD_TYPE with a readonly variant, created\n+     when the access type was processed.  We will make a volatile and readonly\n      designated type, because that's what it really is.\n \n-     We might also get here for a non-dummy old_type variant with different\n-     qualifiers than the new_type ones, for instance in some cases of pointers\n+     We might also get here for a non-dummy OLD_TYPE variant with different\n+     qualifiers than those of NEW_TYPE, for instance in some cases of pointers\n      to private record type elaboration (see the comments around the call to\n-     this routine from gnat_to_gnu_entity/E_Access_Type). We have to merge the\n-     qualifiers in those cases too, to avoid accidentally discarding the\n-     initial set, and will often end up with old_type == new_type then.  */\n-  new_type = build_qualified_type (new_type,\n-\t\t\t\t   TYPE_QUALS (old_type)\n-\t\t\t\t   | TYPE_QUALS (new_type));\n-\n-  /* If the new type and the old one are identical, there is nothing to\n-     update.  */\n+     this routine in gnat_to_gnu_entity <E_Access_Type>).  We have to merge\n+     the qualifiers in those cases too, to avoid accidentally discarding the\n+     initial set, and will often end up with OLD_TYPE == NEW_TYPE then.  */\n+  new_type\n+    = build_qualified_type (new_type,\n+\t\t\t    TYPE_QUALS (old_type) | TYPE_QUALS (new_type));\n+\n+  /* If old type and new type are identical, there is nothing to do.  */\n   if (old_type == new_type)\n     return;\n \n@@ -3805,10 +3804,10 @@ update_pointer_to (tree old_type, tree new_type)\n \t  TREE_TYPE (ref1) = new_type;\n     }\n \n-  /* Now deal with the unconstrained array case. In this case the \"pointer\"\n+  /* Now deal with the unconstrained array case.  In this case the \"pointer\"\n      is actually a RECORD_TYPE where both fields are pointers to dummy nodes.\n      Turn them into pointers to the correct types using update_pointer_to.  */\n-  else if (TREE_CODE (ptr) != RECORD_TYPE || !TYPE_IS_FAT_POINTER_P (ptr))\n+  else if (!TYPE_FAT_POINTER_P (ptr))\n     gcc_unreachable ();\n \n   else\n@@ -3826,26 +3825,25 @@ update_pointer_to (tree old_type, tree new_type)\n \t TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_ptr)))));\n \n       /* The references to the template bounds present in the array type\n-\t are made through a PLACEHOLDER_EXPR of type new_ptr.  Since we\n-\t are updating ptr to make it a full replacement for new_ptr as\n-\t pointer to new_type, we must rework the PLACEHOLDER_EXPR so as\n-\t to make it of type ptr.  */\n+\t are made through a PLACEHOLDER_EXPR of type NEW_PTR.  Since we\n+\t are updating PTR to make it a full replacement for NEW_PTR as\n+\t pointer to NEW_TYPE, we must rework the PLACEHOLDER_EXPR so as\n+\t to make it of type PTR.  */\n       new_ref = build3 (COMPONENT_REF, TREE_TYPE (bounds_field),\n \t\t\tbuild0 (PLACEHOLDER_EXPR, ptr),\n \t\t\tbounds_field, NULL_TREE);\n \n-      /* Create the new array for the new PLACEHOLDER_EXPR and make\n-\t pointers to the dummy array point to it.\n+      /* Create the new array for the new PLACEHOLDER_EXPR and make pointers\n+\t to the dummy array point to it.\n \n-\t ??? This is now the only use of substitute_in_type,\n-\t which is a very \"heavy\" routine to do this, so it\n-\t should be replaced at some point.  */\n+\t ??? This is now the only use of substitute_in_type, which is a very\n+\t \"heavy\" routine to do this, it should be replaced at some point.  */\n       update_pointer_to\n \t(TREE_TYPE (TREE_TYPE (array_field)),\n \t substitute_in_type (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (new_ptr))),\n \t\t\t     TREE_CHAIN (TYPE_FIELDS (new_ptr)), new_ref));\n \n-      /* Make ptr the pointer to new_type.  */\n+      /* Make PTR the pointer to NEW_TYPE.  */\n       TYPE_POINTER_TO (new_type) = TYPE_REFERENCE_TO (new_type)\n \t= TREE_TYPE (new_type) = ptr;\n "}]}