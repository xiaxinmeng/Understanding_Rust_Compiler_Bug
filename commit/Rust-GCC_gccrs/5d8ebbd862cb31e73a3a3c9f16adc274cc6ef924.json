{"sha": "5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ4ZWJiZDg2MmNiMzFlNzNhM2EzYzlmMTZhZGMyNzRjYzZlZjkyNA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-01-03T21:43:09Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-01-03T21:43:09Z"}, "message": "cpperror.c: Update comments and copyright.\n\n\t* cpperror.c: Update comments and copyright.\n\t* cppexp.c, cppfiles.c, cpphash.c, cpphash.h, cppinit.c,\n\tcpplex.c, cpplib.c, cpplib.h, cppmacro.c, cppmain.c: Similarly.\n\nFrom-SVN: r48522", "tree": {"sha": "3504047f1de0b4702b0d0d4991c780df4a3aad89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3504047f1de0b4702b0d0d4991c780df4a3aad89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/comments", "author": null, "committer": null, "parents": [{"sha": "518c131126e5829ed7e911b3421327ebef4dfb00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518c131126e5829ed7e911b3421327ebef4dfb00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/518c131126e5829ed7e911b3421327ebef4dfb00"}], "stats": {"total": 205, "additions": 99, "deletions": 106}, "files": [{"sha": "c7da52f140b98bbabdd42500bc7abd08fc554b75", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,3 +1,9 @@\n+2002-01-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpperror.c: Update comments and copyright.\n+\t* cppexp.c, cppfiles.c, cpphash.c, cpphash.h, cppinit.c,\n+\tcpplex.c, cpplib.c, cpplib.h, cppmacro.c, cppmain.c: Similarly.\n+\n 2002-01-03  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* collect2.c (main): Use strcmp when testing for \"-shared\"."}, {"sha": "375dc2ba5b38143344d7d9eff29ecb4b5e8befad", "filename": "gcc/cpperror.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,6 +1,6 @@\n /* Default error handlers for CPP Library.\n-   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000,\n+   2001, 2002  Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -36,6 +36,8 @@ static void print_location PARAMS ((cpp_reader *, unsigned int, unsigned int));\n #define v_message(msgid, ap) \\\n  do { vfprintf (stderr, _(msgid), ap); putc ('\\n', stderr); } while (0)\n \n+/* Print the logical file location (LINE, COL) in preparation for a\n+   diagnostic.  Outputs the #include chain if it has changed.  */\n static void\n print_location (pfile, line, col)\n      cpp_reader *pfile;\n@@ -77,7 +79,6 @@ print_location (pfile, line, col)\n    counter, etc.  LINE is the logical line number; zero means to print\n    at the location of the previously lexed token, which tends to be the\n    correct place by default.  Returns 0 if the error has been suppressed.  */\n-\n int\n _cpp_begin_message (pfile, code, line, column)\n      cpp_reader *pfile;\n@@ -137,7 +138,6 @@ _cpp_begin_message (pfile, code, line, column)\n \n /* For reporting internal errors.  Prints \"internal error: \" for you,\n    otherwise identical to cpp_fatal.  */\n-\n void\n cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n {  \n@@ -156,7 +156,6 @@ cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n    (We do not exit, to support use of cpplib as a library.\n    Instead, it is the caller's responsibility to check\n    CPP_FATAL_ERRORS.  */\n-\n void\n cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n {  \n@@ -170,6 +169,7 @@ cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   VA_CLOSE (ap);\n }\n \n+/* Print an error at the location of the previously lexed token.  */\n void\n cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n {\n@@ -183,6 +183,7 @@ cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   VA_CLOSE (ap);\n }\n \n+/* Print an error at a specific location.  */\n void\n cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n \t\t\t     const char *msgid, ...))\n@@ -208,6 +209,7 @@ cpp_error_from_errno (pfile, name)\n   cpp_error (pfile, \"%s: %s\", name, xstrerror (errno));\n }\n \n+/* Print a warning at the location of the previously lexed token.  */\n void\n cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n {\n@@ -221,6 +223,7 @@ cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   VA_CLOSE (ap);\n }\n \n+/* Print a warning at a specific location.  */\n void\n cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n \t\t\t       const char *msgid, ...))\n@@ -237,6 +240,7 @@ cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   VA_CLOSE (ap);\n }\n \n+/* Pedwarn at the location of the previously lexed token.  */\n void\n cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n {\n@@ -250,6 +254,7 @@ cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   VA_CLOSE (ap);\n }\n \n+/* Pedwarn at a specific location.  */\n void\n cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n \t\t\t       const char *msgid, ...))\n@@ -266,7 +271,7 @@ cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   VA_CLOSE (ap);\n }\n \n-/* Print an error message not associated with a file.  */\n+/* Print an error message not associated with the translation unit.  */\n void\n cpp_notice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n {\n@@ -282,6 +287,8 @@ cpp_notice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   VA_CLOSE (ap);\n }\n \n+/* Print an error message originating from ERRNO and not associated\n+   with the translation unit.  */\n void\n cpp_notice_from_errno (pfile, name)\n      cpp_reader *pfile;"}, {"sha": "1f225c373073f14888bed8ebb86c697cf6a0660a", "filename": "gcc/cppexp.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,6 +1,6 @@\n /* Parse C expressions for cpplib.\n-   Copyright (C) 1987, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation.\n+   Copyright (C) 1987, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n+   2002 Free Software Foundation.\n    Contributed by Per Bothner, 1994.\n \n This program is free software; you can redistribute it and/or modify it\n@@ -85,10 +85,9 @@ static const struct suffix vsuf_3[] = {\n };\n #define Nsuff(tab) (sizeof tab / sizeof (struct suffix))\n \n-/* Parse and convert an integer for #if.  Accepts decimal, hex, or\n-   octal with or without size suffixes.  Returned op is CPP_ERROR on\n-   error, otherwise it is a CPP_NUMBER.  */\n-\n+/* Parse and convert what is presumably an integer in TOK.  Accepts\n+   decimal, hex, or octal with or without size suffixes.  Returned op\n+   is CPP_ERROR on error, otherwise it is a CPP_NUMBER.  */\n static struct op\n parse_number (pfile, tok)\n      cpp_reader *pfile;\n@@ -206,6 +205,7 @@ parse_number (pfile, tok)\n   return op;\n }\n \n+/* Handle meeting \"defined\" in a preprocessor expression.  */\n static struct op\n parse_defined (pfile)\n      cpp_reader *pfile;\n@@ -275,7 +275,6 @@ parse_defined (pfile)\n    (an interpreted preprocessing number or character constant, or the\n    result of the \"defined\" or \"#\" operators), CPP_ERROR on error,\n    CPP_EOF, or the type of an operator token.  */\n-\n static struct op\n lex (pfile, skip_evaluation)\n      cpp_reader *pfile;\n@@ -372,6 +371,7 @@ lex (pfile, skip_evaluation)\n   return op;\n }\n \n+/* Warn if appropriate on overflow.  */\n static void\n integer_overflow (pfile)\n      cpp_reader *pfile;\n@@ -380,6 +380,8 @@ integer_overflow (pfile)\n     cpp_pedwarn (pfile, \"integer overflow in preprocessor expression\");\n }\n \n+/* Handle shifting A left by B bits.  UNSIGNEDP is non-zero if A is\n+   unsigned.  */\n static HOST_WIDEST_INT\n left_shift (pfile, a, unsignedp, b)\n      cpp_reader *pfile;\n@@ -404,6 +406,8 @@ left_shift (pfile, a, unsignedp, b)\n     }\n }\n \n+/* Handle shifting A right by B bits.  UNSIGNEDP is non-zero if A is\n+   unsigned.  */\n static HOST_WIDEST_INT\n right_shift (pfile, a, unsignedp, b)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n@@ -547,7 +551,6 @@ op_to_prio[] =\n \n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n-\n int\n _cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n@@ -870,6 +873,7 @@ _cpp_parse_expr (pfile)\n   return result;\n }\n \n+/* Output OP as text for diagnostics.  */\n static const unsigned char *\n op_as_text (pfile, op)\n      cpp_reader *pfile;"}, {"sha": "b60e4eba0f0241c9ca420c458d3ec683d30f865b", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,6 +1,6 @@\n /* Part of CPP library.  (include file handling)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -212,7 +212,6 @@ _cpp_fake_include (pfile, fname)\n \n    Returns an include_file structure with an open file descriptor on\n    success, or NULL on failure.  */\n-\n static struct include_file *\n open_file (pfile, filename)\n      cpp_reader *pfile;\n@@ -276,7 +275,6 @@ open_file (pfile, filename)\n    stack, unless there are errors, or the file is not re-included\n    because of e.g. multiple-include guards.  Returns true if a buffer\n    is stacked.  */\n-\n static bool\n stack_include_file (pfile, inc)\n      cpp_reader *pfile;\n@@ -351,7 +349,6 @@ stack_include_file (pfile, inc)\n    and block devices.\n \n    FIXME: Flush file cache and try again if we run out of memory.  */\n-\n static int\n read_include_file (pfile, inc)\n      cpp_reader *pfile;\n@@ -467,6 +464,7 @@ read_include_file (pfile, inc)\n   return 1;\n }\n \n+/* Drop INC's buffer from memory, if we are unlikely to need it again.  */\n static void\n purge_cache (inc)\n      struct include_file *inc;\n@@ -524,8 +522,7 @@ cpp_included (pfile, fname)\n    un-openable), in which case an error code will be in errno.  If\n    there is no include path to use it returns NO_INCLUDE_PATH,\n    otherwise an include_file structure.  If this request originates\n-   from a #include_next directive, set INCLUDE_NEXT to true.  */\n-\n+   from a directive of TYPE #include_next, set INCLUDE_NEXT to true.  */\n static struct include_file *\n find_include_file (pfile, header, type)\n      cpp_reader *pfile;\n@@ -612,6 +609,7 @@ _cpp_report_missing_guards (pfile)\n \t\t      (PTR) &banner);\n }\n \n+/* Callback function for splay_tree_foreach().  */\n static int\n report_missing_guard (n, b)\n      splay_tree_node n;\n@@ -633,7 +631,9 @@ report_missing_guard (n, b)\n   return 0;\n }\n \n-/* Create a dependency, or issue an error message as appropriate.  */\n+/* Create a dependency for file FNAME, or issue an error message as\n+   appropriate.  ANGLE_BRACKETS is non-zero if the file was bracketed\n+   like <..>.  */\n static void\n handle_missing_header (pfile, fname, angle_brackets)\n      cpp_reader *pfile;\n@@ -679,8 +679,9 @@ handle_missing_header (pfile, fname, angle_brackets)\n     cpp_error_from_errno (pfile, fname);\n }\n \n-/* Handles #include-family directives, and the command line -imacros\n-   and -include.  Returns true if a buffer was stacked.  */\n+/* Handles #include-family directives (distinguished by TYPE),\n+   including HEADER, and the command line -imacros and -include.\n+   Returns true if a buffer was stacked.  */\n bool\n _cpp_execute_include (pfile, header, type)\n      cpp_reader *pfile;\n@@ -746,8 +747,8 @@ _cpp_read_file (pfile, fname)\n   return stack_include_file (pfile, f);\n }\n \n-/* Do appropriate cleanup when a file buffer is popped off the input\n-   stack.  Push the next -include file, if any remain.  */\n+/* Do appropriate cleanup when a file INC's buffer is popped off the\n+   input stack.  Push the next -include file, if any remain.  */\n bool\n _cpp_pop_file_buffer (pfile, inc)\n      cpp_reader *pfile;\n@@ -841,7 +842,6 @@ search_from (pfile, type)\n    such as DOS.  The format of the file name map file is just a series\n    of lines with two tokens on each line.  The first token is the name\n    to map, and the second token is the actual name to use.  */\n-\n struct file_name_map\n {\n   struct file_name_map *map_next;\n@@ -852,8 +852,7 @@ struct file_name_map\n #define FILE_NAME_MAP_FILE \"header.gcc\"\n \n /* Read a space delimited string of unlimited length from a stdio\n-   file.  */\n-\n+   file F.  */\n static char *\n read_filename_string (ch, f)\n      int ch;\n@@ -884,7 +883,6 @@ read_filename_string (ch, f)\n }\n \n /* This structure holds a linked list of file name maps, one per directory.  */\n-\n struct file_name_map_list\n {\n   struct file_name_map_list *map_list_next;\n@@ -893,7 +891,6 @@ struct file_name_map_list\n };\n \n /* Read the file name map file for DIRNAME.  */\n-\n static struct file_name_map *\n read_name_map (pfile, dirname)\n      cpp_reader *pfile;\n@@ -1069,7 +1066,6 @@ remove_component_p (path)\n    Guarantees no trailing slashes.  All transforms reduce the length\n    of the string.  Returns PATH.  errno is 0 if no error occurred;\n    nonzero if an error occurred when using stat () or lstat ().  */\n-\n char *\n _cpp_simplify_pathname (path)\n     char *path;"}, {"sha": "8be1b2f1a659417ad19c5f6ec2e8c326bd3e83af", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,6 +1,6 @@\n /* Hash tables for the CPP library.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -32,7 +32,6 @@ static cpp_hashnode *alloc_node PARAMS ((hash_table *));\n \n /* Return an identifier node for hashtable.c.  Used by cpplib except\n    when integrated with the C front ends.  */\n-\n static cpp_hashnode *\n alloc_node (table)\n      hash_table *table;\n@@ -47,7 +46,6 @@ alloc_node (table)\n \n /* Set up the identifier hash table.  Use TABLE if non-null, otherwise\n    create our own.  */\n-\n void\n _cpp_init_hashtable (pfile, table)\n      cpp_reader *pfile;\n@@ -81,7 +79,6 @@ _cpp_init_hashtable (pfile, table)\n }\n \n /* Tear down the identifier hash table.  */\n-\n void\n _cpp_destroy_hashtable (pfile)\n      cpp_reader *pfile;\n@@ -95,7 +92,6 @@ _cpp_destroy_hashtable (pfile)\n \n /* Returns the hash entry for the STR of length LEN, creating one\n    if necessary.  */\n-\n cpp_hashnode *\n cpp_lookup (pfile, str, len)\n      cpp_reader *pfile;\n@@ -107,7 +103,6 @@ cpp_lookup (pfile, str, len)\n }\n \n /* Determine whether the str STR, of length LEN, is a defined macro.  */\n-\n int\n cpp_defined (pfile, str, len)\n      cpp_reader *pfile;\n@@ -124,7 +119,6 @@ cpp_defined (pfile, str, len)\n \n /* For all nodes in the hashtable, callback CB with parameters PFILE,\n    the node, and V.  */\n-\n void\n cpp_forall_identifiers (pfile, cb, v)\n      cpp_reader *pfile;"}, {"sha": "be8d902154b62cbc19a15acf984d31e8cb29d17f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,5 +1,6 @@\n /* Part of CPP library.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+   Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -43,7 +44,6 @@ struct directive;\t\t/* Deliberately incomplete.  */\n #define CPP_STACK_MAX 200\n \n /* A generic memory buffer, and operations on it.  */\n-\n typedef struct _cpp_buff _cpp_buff;\n struct _cpp_buff\n {\n@@ -93,6 +93,7 @@ union utoken\n   const cpp_token **ptoken;\n };\n \n+/* A \"run\" of tokens; part of a chain of runs.  */\n typedef struct tokenrun tokenrun;\n struct tokenrun\n {\n@@ -167,6 +168,7 @@ struct spec_nodes\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n };\n \n+/* Represents the contents of a file cpplib has read in.  */\n struct cpp_buffer\n {\n   const unsigned char *cur;\t /* current position */\n@@ -224,7 +226,6 @@ struct cpp_buffer\n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n    Applying cpp_get_token repeatedly yields a stream of pre-processor\n    tokens.  Usually, there is only one cpp_reader object active.  */\n-\n struct cpp_reader\n {\n   /* Top of buffer stack.  */"}, {"sha": "93b27025d47bed8c8062fbf8717db7f18d1fb75f", "filename": "gcc/cppinit.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -54,7 +54,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* A `struct pending_option' remembers one -D, -A, -U, -include, or\n    -imacros switch.  */\n-\n typedef void (* cl_directive_handler) PARAMS ((cpp_reader *, const char *));\n struct pending_option\n {\n@@ -158,7 +157,6 @@ END\n \n /* Given a colon-separated list of file names PATH,\n    add all the names to the search path for include files.  */\n-\n static void\n path_include (pfile, list, path)\n      cpp_reader *pfile;\n@@ -200,7 +198,9 @@ path_include (pfile, list, path)\n }\n \n /* Append DIR to include path PATH.  DIR must be allocated on the\n-   heap; this routine takes responsibility for freeing it.  */\n+   heap; this routine takes responsibility for freeing it.  CXX_AWARE\n+   is non-zero if the header contains extern \"C\" guards for C++,\n+   otherwise it is zero.  */\n static void\n append_include_chain (pfile, dir, path, cxx_aware)\n      cpp_reader *pfile;\n@@ -331,11 +331,7 @@ remove_dup_dirs (pfile, head)\n    system, after.  Remove duplicate dirs (as determined by\n    INO_T_EQ()).  The system_include and after_include chains are never\n    referred to again after this function; all access is through the\n-   bracket_include path.\n-\n-   For the future: Check if the directory is empty (but\n-   how?) and possibly preload the include hash.  */\n-\n+   bracket_include path.  */\n static void\n merge_include_chains (pfile)\n      cpp_reader *pfile;\n@@ -389,9 +385,8 @@ merge_include_chains (pfile)\n   CPP_OPTION (pfile, bracket_include) = brack;\n }\n \n-/* Sets internal flags correctly for a given language, and defines\n-   macros if necessary.  */\n-\n+/* A set of booleans indicating what CPP features each source language\n+   requires.  */\n struct lang_flags\n {\n   char c99;\n@@ -419,6 +414,7 @@ static const struct lang_flags lang_defaults[] =\n   /* ASM    */  { 0,  0,   0,  1,   0,   0,     1,      0     }\n };\n \n+/* Sets internal flags correctly for a given language.  */\n static void\n set_lang (pfile, lang)\n      cpp_reader *pfile;\n@@ -453,7 +449,6 @@ opt_comp (p1, p2)\n \n /* init initializes library global state.  It might not need to\n    do anything depending on the platform and compiler.  */\n-\n static void\n init_library ()\n {\n@@ -540,7 +535,7 @@ cpp_create_reader (lang)\n }\n \n /* Free resources used by PFILE.  Accessing PFILE after this function\n-   returns leads to undefined behaviour.  */\n+   returns leads to undefined behaviour.  Returns the error count.  */\n int\n cpp_destroy (pfile)\n      cpp_reader *pfile;\n@@ -613,7 +608,6 @@ cpp_destroy (pfile)\n    ULP\t\tvalue is the global user_label_prefix\n \n    Also, macros with CPLUS set in the flags field are entered only for C++.  */\n-\n struct builtin\n {\n   const U_CHAR *name;\n@@ -689,7 +683,7 @@ static const struct builtin builtin_array[] =\n  builtin_array + sizeof(builtin_array)/sizeof(struct builtin)\n \n /* Subroutine of cpp_read_main_file; reads the builtins table above and\n-   enters the macros into the hash table.  */\n+   enters them, and language-specific macros, into the hash table.  */\n static void\n init_builtins (pfile)\n      cpp_reader *pfile;\n@@ -865,7 +859,7 @@ init_standard_includes (pfile)\n     }\n }\n \n-/* Pushes a -imacro and -include file given on the command line onto\n+/* Pushes a command line -imacro and -include file indicated by P onto\n    the buffer stack.  Returns non-zero if successful.  */\n static bool\n push_include (pfile, p)\n@@ -1126,6 +1120,7 @@ cpp_finish (pfile)\n     _cpp_report_missing_guards (pfile);\n }\n \n+/* Add a directive to be handled later in the initialization phase.  */\n static void\n new_pending_directive (pend, text, handler)\n      struct cpp_pending *pend;\n@@ -1318,7 +1313,6 @@ parse_option (input)\n /* Handle one command-line option in (argc, argv).\n    Can be called multiple times, to handle multiple sets of options.\n    Returns number of strings consumed.  */\n-\n int\n cpp_handle_option (pfile, argc, argv)\n      cpp_reader *pfile;\n@@ -1871,6 +1865,7 @@ init_dependency_output (pfile)\n     }\n }\n \n+/* Handle --help output.  */\n static void\n print_help ()\n {"}, {"sha": "8465350c654d103b039663436df95f9b70dad282", "filename": "gcc/cpplex.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,5 +1,5 @@\n /* CPP Library - lexical analysis.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -97,7 +97,6 @@ static _cpp_buff *new_buff PARAMS ((size_t));\n \n    Compares, the token TOKEN to the NUL-terminated string STRING.\n    TOKEN must be a CPP_NAME.  Returns 1 for equal, 0 for unequal.  */\n-\n int\n cpp_ideq (token, string)\n      const cpp_token *token;\n@@ -414,7 +413,6 @@ name_p (pfile, string)\n    Poisson-like).  Second most common case is a new identifier, not\n    split and no dollar sign.  The other possibilities are rare and\n    have been relegated to parse_identifier_slow.  */\n-\n static cpp_hashnode *\n parse_identifier (pfile)\n      cpp_reader *pfile;\n@@ -517,7 +515,9 @@ parse_identifier_slow (pfile, cur)\n     ht_lookup (pfile->hash_table, obstack_finish (stack), len, HT_ALLOCED);\n }\n \n-/* Parse a number, skipping embedded backslash-newlines.  */\n+/* Parse a number, beginning with character C, skipping embedded\n+   backslash-newlines.  LEADING_PERIOD is non-zero if there was a \".\"\n+   before C.  Place the result in NUMBER.  */\n static void\n parse_number (pfile, number, c, leading_period)\n      cpp_reader *pfile;\n@@ -1289,7 +1289,7 @@ _cpp_lex_direct (pfile)\n   return result;\n }\n \n-/* An upper bound on the number of bytes needed to spell a token,\n+/* An upper bound on the number of bytes needed to spell TOKEN,\n    including preceding whitespace.  */\n unsigned int\n cpp_token_len (token)\n@@ -1383,8 +1383,8 @@ cpp_spell_token (pfile, token, buffer)\n   return buffer;\n }\n \n-/* Returns a token as a null-terminated string.  The string is\n-   temporary, and automatically freed later.  Useful for diagnostics.  */\n+/* Returns TOKEN spelt as a null-terminated string.  The string is\n+   freed when the reader is destroyed.  Useful for diagnostics.  */\n unsigned char *\n cpp_token_as_text (pfile, token)\n      cpp_reader *pfile;\n@@ -1399,7 +1399,8 @@ cpp_token_as_text (pfile, token)\n   return start;\n }\n \n-/* Used by C front ends.  Should really move to using cpp_token_as_text.  */\n+/* Used by C front ends, which really should move to using\n+   cpp_token_as_text.  */\n const char *\n cpp_type2name (type)\n      enum cpp_ttype type;\n@@ -1508,7 +1509,6 @@ _cpp_equiv_tokens (a, b)\n    accidental token paste for output.  For simplicity, it is\n    conservative, and occasionally advises a space where one is not\n    needed, e.g. \".\" and \".2\".  */\n-\n int\n cpp_avoid_paste (pfile, token1, token2)\n      cpp_reader *pfile;\n@@ -1689,7 +1689,6 @@ maybe_read_ucs (pfile, pstr, limit, pc)\n    interpret escapes that did not exist in traditional C.\n \n    Handles all relevant diagnostics.  */\n-\n unsigned int\n cpp_parse_escape (pfile, pstr, limit, mask, traditional)\n      cpp_reader *pfile;"}, {"sha": "12baa101ef2d3d8eff9d419f08ed1d42101c249f", "filename": "gcc/cpplib.c", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,6 +1,6 @@\n /* CPP Library. (Directive handling.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -36,7 +36,6 @@ struct answer\n \n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n-\n struct if_stack\n {\n   struct if_stack *next;\n@@ -263,7 +262,6 @@ end_directive (pfile, skip_line)\n \n /* Output diagnostics for a directive DIR.  INDENTED is non-zero if\n    the '#' was indented.  */\n-\n static void\n directive_diagnostics (pfile, dir, indented)\n      cpp_reader *pfile;\n@@ -311,7 +309,6 @@ directive_diagnostics (pfile, dir, indented)\n    to save unnecessarily exporting dtable etc. to cpplex.c.  Returns\n    non-zero if the line of tokens has been handled, zero if we should\n    continue processing the line.  */\n-\n int\n _cpp_handle_directive (pfile, indented)\n      cpp_reader *pfile;\n@@ -479,7 +476,7 @@ do_define (pfile)\n     }\n }\n \n-/* Handle #undef.  Marks the identifier NT_VOID in the hash table.  */\n+/* Handle #undef.  Mark the identifier NT_VOID in the hash table.  */\n static void\n do_undef (pfile)\n      cpp_reader *pfile;\n@@ -659,7 +656,6 @@ do_include_next (pfile)\n /* Subroutine of do_line.  Read possible flags after file name.  LAST\n    is the last flag seen; 0 if this is the first flag. Return the flag\n    if it is valid, 0 at the end of the directive. Otherwise complain.  */\n-\n static unsigned int\n read_flag (pfile, last)\n      cpp_reader *pfile;\n@@ -709,7 +705,6 @@ strtoul_for_line (str, len, nump)\n /* Interpret #line command.\n    Note that the filename string (if any) is treated as if it were an\n    include filename.  That means no escape handling.  */\n-\n static void\n do_line (pfile)\n      cpp_reader *pfile;\n@@ -807,11 +802,8 @@ _cpp_do_file_change (pfile, reason, to_file, file_line, sysp)\n     (*pfile->cb.file_change) (pfile, pfile->map);\n }\n \n-/*\n- * Report a warning or error detected by the program we are\n- * processing.  Use the directive's tokens in the error message.\n- */\n-\n+/* Report a warning or error detected by the program we are\n+   processing.  Use the directive's tokens in the error message.  */\n static void\n do_diagnostic (pfile, code, print_dir)\n      cpp_reader *pfile;\n@@ -844,7 +836,6 @@ do_warning (pfile)\n }\n \n /* Report program identification.  */\n-\n static void\n do_ident (pfile)\n      cpp_reader *pfile;\n@@ -1015,6 +1006,7 @@ do_pragma (pfile)\n   pfile->state.prevent_expansion--;\n }\n \n+/* Handle #pragma once.  */\n static void\n do_pragma_once (pfile)\n      cpp_reader *pfile;\n@@ -1029,12 +1021,12 @@ do_pragma_once (pfile)\n   check_eol (pfile);\n }\n \n+/* Handle #pragma poison, to poison one or more identifiers so that\n+   the lexer produces a hard error for each subsequent usage.  */\n static void\n do_pragma_poison (pfile)\n      cpp_reader *pfile;\n {\n-  /* Poison these symbols so that all subsequent usage produces an\n-     error message.  */\n   const cpp_token *tok;\n   cpp_hashnode *hp;\n \n@@ -1208,6 +1200,7 @@ do_sccs (pfile)\n }\n #endif\n \n+/* Handle #ifdef.  */\n static void\n do_ifdef (pfile)\n      cpp_reader *pfile;\n@@ -1228,6 +1221,7 @@ do_ifdef (pfile)\n   push_conditional (pfile, skip, T_IFDEF, 0);\n }\n \n+/* Handle #ifndef.  */\n static void\n do_ifndef (pfile)\n      cpp_reader *pfile;\n@@ -1253,7 +1247,6 @@ do_ifndef (pfile)\n    optimisations.  If macro expansion occurs in the expression, we\n    cannot treat it as a controlling conditional, since the expansion\n    could change in the future.  That is handled by cpp_get_token.  */\n-\n static void\n do_if (pfile)\n      cpp_reader *pfile;\n@@ -1269,7 +1262,6 @@ do_if (pfile)\n /* Flip skipping state if appropriate and continue without changing\n    if_stack; this is so that the error message for missing #endif's\n    etc. will point to the original #if.  */\n-\n static void\n do_else (pfile)\n      cpp_reader *pfile;\n@@ -1302,9 +1294,8 @@ do_else (pfile)\n     }\n }\n \n-/* handle a #elif directive by not changing if_stack either.  see the\n+/* Handle a #elif directive by not changing if_stack either.  See the\n    comment above do_else.  */\n-\n static void\n do_elif (pfile)\n      cpp_reader *pfile;\n@@ -1341,7 +1332,6 @@ do_elif (pfile)\n }\n \n /* #endif pops the if stack and resets pfile->state.skipping.  */\n-\n static void\n do_endif (pfile)\n      cpp_reader *pfile;\n@@ -1370,10 +1360,10 @@ do_endif (pfile)\n     }\n }\n \n-/* Push an if_stack entry and set pfile->state.skipping accordingly.\n-   If this is a #if or #ifndef, CMACRO is a potentially controlling\n-   macro - we need to check here that we are at the top of the file.  */\n-\n+/* Push an if_stack entry for a preprocessor conditional, and set\n+   pfile->state.skipping to SKIP.  If TYPE indicates the conditional\n+   is #if or #ifndef, CMACRO is a potentially controlling macro, and\n+   we need to check here that we are at the top of the file.  */\n static void\n push_conditional (pfile, skip, type, cmacro)\n      cpp_reader *pfile;\n@@ -1400,10 +1390,10 @@ push_conditional (pfile, skip, type, cmacro)\n   buffer->if_stack = ifs;\n }\n \n-/* Read the tokens of the answer into the macro pool.  Only commit the\n-   memory if we intend it as permanent storage, i.e. the #assert case.\n-   Returns 0 on success.  */\n-\n+/* Read the tokens of the answer into the macro pool, in a directive\n+   of type TYPE.  Only commit the memory if we intend it as permanent\n+   storage, i.e. the #assert case.  Returns 0 on success, and sets\n+   ANSWERP to point to the answer.  */\n static int\n parse_answer (pfile, answerp, type)\n      cpp_reader *pfile;\n@@ -1480,9 +1470,9 @@ parse_answer (pfile, answerp, type)\n   return 0;\n }\n \n-/* Parses an assertion, returning a pointer to the hash node of the\n-   predicate, or 0 on error.  If an answer was supplied, it is placed\n-   in ANSWERP, otherwise it is set to 0.  */\n+/* Parses an assertion directive of type TYPE, returning a pointer to\n+   the hash node of the predicate, or 0 on error.  If an answer was\n+   supplied, it is placed in ANSWERP, otherwise it is set to 0.  */\n static cpp_hashnode *\n parse_assertion (pfile, answerp, type)\n      cpp_reader *pfile;\n@@ -1516,7 +1506,7 @@ parse_assertion (pfile, answerp, type)\n   return result;\n }\n \n-/* Returns a pointer to the pointer to the answer in the answer chain,\n+/* Returns a pointer to the pointer to CANDIDATE in the answer chain,\n    or a pointer to NULL if the answer is not in the chain.  */\n static struct answer **\n find_answer (node, candidate)\n@@ -1564,6 +1554,7 @@ _cpp_test_assertion (pfile, value)\n   return node == 0;\n }\n \n+/* Handle #assert.  */\n static void\n do_assert (pfile)\n      cpp_reader *pfile;\n@@ -1596,6 +1587,7 @@ do_assert (pfile)\n     }\n }\n \n+/* Handle #unassert.  */\n static void\n do_unassert (pfile)\n      cpp_reader *pfile;\n@@ -1635,7 +1627,6 @@ do_unassert (pfile)\n    If STR is just an identifier, define it with value 1.\n    If STR has anything after the identifier, then it should\n    be identifier=definition.  */\n-\n void\n cpp_define (pfile, str)\n      cpp_reader *pfile;\n@@ -1826,14 +1817,14 @@ _cpp_pop_buffer (pfile)\n     obstack_free (&pfile->buffer_ob, buffer);\n }\n \n+/* Enter all recognised directives in the hash table.  */\n void\n _cpp_init_directives (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int i;\n   cpp_hashnode *node;\n \n-  /* Register the directives.  */\n   for (i = 0; i < (unsigned int) N_DIRECTIVES; i++)\n     {\n       node = cpp_lookup (pfile, dtable[i].name, dtable[i].length);"}, {"sha": "367491b226e250dbfcfa7eab5c1930d76b965a8c", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for CPP library.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n    Written by Per Bothner, 1994-95.\n \n@@ -152,7 +152,7 @@ enum cpp_ttype\n enum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_STDC89, CLK_STDC94, CLK_STDC99,\n \t     CLK_GNUCXX, CLK_CXX98, CLK_OBJC, CLK_OBJCXX, CLK_ASM};\n \n-/* Payload of a NUMBER, FLOAT, STRING, or COMMENT token.  */\n+/* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */\n struct cpp_string\n {\n   unsigned int len;"}, {"sha": "538c689b1e5eee11f3996f6e50d93853973c962e", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,6 +1,6 @@\n /* Part of CPP library.  (Macro and #define handling.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987"}, {"sha": "ee157ca61ec4df2e62958a071d275446f2b6b3bd", "filename": "gcc/cppmain.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=5d8ebbd862cb31e73a3a3c9f16adc274cc6ef924", "patch": "@@ -1,5 +1,5 @@\n /* CPP main program, using CPP Library.\n-   Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n    Written by Per Bothner, 1994-95.\n "}]}