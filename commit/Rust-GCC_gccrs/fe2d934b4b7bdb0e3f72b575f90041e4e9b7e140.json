{"sha": "fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUyZDkzNGI0YjdiZGIwZTNmNzJiNTc1ZjkwMDQxZTRlOWI3ZTE0MA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2007-03-01T22:58:40Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2007-03-01T22:58:40Z"}, "message": "arm.c (arm_legitimate_index_p): Limit iWMMXt addressing modes to LDRD for DImode.\n\n2007-03-01  Paul Brook  <paul@codesourcery.com>\n\n\t* config/arm/arm.c (arm_legitimate_index_p): Limit iWMMXt addressing\n\tmodes to LDRD for DImode.\n\t(output_move_double): Fixup out of range ldrd/strd.\n\t(vfp_secondary_reload_class): Rename...\n\t(coproc_secondary_reload_class): ... to this.  Add wb argument.\n\t* config/arm/arm.h (SECONDARY_OUTPUT_RELOAD_CLASS): Use\n\tcoproc_secondary_reload_class for CLASS_IWMMXT.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Ditto.\n\t* arm-protos.h (coproc_secondary_reload_class): Update prototype.\n\nFrom-SVN: r122437", "tree": {"sha": "ea80e92e5fd211797f4d35d15f47aa342c1aa013", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea80e92e5fd211797f4d35d15f47aa342c1aa013"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/comments", "author": null, "committer": null, "parents": [{"sha": "2711355fbc306e7e0f59b3247943614eba4a382b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2711355fbc306e7e0f59b3247943614eba4a382b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2711355fbc306e7e0f59b3247943614eba4a382b"}], "stats": {"total": 101, "additions": 85, "deletions": 16}, "files": [{"sha": "c3d0a7e3fb9c54f8358095b2f513259eb8aa428b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "patch": "@@ -1,3 +1,15 @@\n+2007-03-01  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_legitimate_index_p): Limit iWMMXt addressing\n+\tmodes to LDRD for DImode.\n+\t(output_move_double): Fixup out of range ldrd/strd.\n+\t(vfp_secondary_reload_class): Rename...\n+\t(coproc_secondary_reload_class): ... to this.  Add wb argument.\n+\t* config/arm/arm.h (SECONDARY_OUTPUT_RELOAD_CLASS): Use\n+\tcoproc_secondary_reload_class for CLASS_IWMMXT.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Ditto.\n+\t* arm-protos.h (coproc_secondary_reload_class): Update prototype.\n+\n 2007-03-01  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-loop-prefetch.c (determine_unroll_factor):  Bound the unroll"}, {"sha": "9d24cd2b8770ab269297b22e71c7dab07d10c5e5", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "patch": "@@ -68,7 +68,8 @@ extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n \t\t\t\t\t    int);\n extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n-extern enum reg_class vfp_secondary_reload_class (enum machine_mode, rtx);\n+extern enum reg_class coproc_secondary_reload_class (enum machine_mode, rtx,\n+\t\t\t\t\t\t     bool);\n extern bool arm_tls_referenced_p (rtx);\n \n extern int cirrus_memory_offset (rtx);"}, {"sha": "74a9e008ca52d906e08434e877734318a7324b42", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 63, "deletions": 11, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "patch": "@@ -3922,10 +3922,15 @@ thumb2_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n \t    && (INTVAL (index) & 3) == 0);\n \n   if (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (mode))\n-    return (code == CONST_INT\n-\t    && INTVAL (index) < 1024\n-\t    && INTVAL (index) > -1024\n-\t    && (INTVAL (index) & 3) == 0);\n+    {\n+      /* For DImode assume values will usually live in core regs\n+\t and only allow LDRD addressing modes.  */\n+      if (!TARGET_LDRD || mode != DImode)\n+\treturn (code == CONST_INT\n+\t\t&& INTVAL (index) < 1024\n+\t\t&& INTVAL (index) > -1024\n+\t\t&& (INTVAL (index) & 3) == 0);\n+    }\n \n   if (arm_address_register_rtx_p (index, strict_p)\n       && (GET_MODE_SIZE (mode) <= 4))\n@@ -5764,12 +5769,12 @@ arm_eliminable_register (rtx x)\n }\n \n /* Return GENERAL_REGS if a scratch register required to reload x to/from\n-   VFP registers.  Otherwise return NO_REGS.  */\n+   coprocessor registers.  Otherwise return NO_REGS.  */\n \n enum reg_class\n-vfp_secondary_reload_class (enum machine_mode mode, rtx x)\n+coproc_secondary_reload_class (enum machine_mode mode, rtx x, bool wb)\n {\n-  if (arm_coproc_mem_operand (x, FALSE) || s_register_operand (x, mode))\n+  if (arm_coproc_mem_operand (x, wb) || s_register_operand (x, mode))\n     return NO_REGS;\n \n   return GENERAL_REGS;\n@@ -9146,12 +9151,37 @@ output_move_double (rtx *operands)\n \t\t  output_asm_insn (\"ldr%(d%)\\t%0, [%1] @split\", otherops);\n \t\t}\n \t      else\n-\t\toutput_asm_insn (\"ldr%(d%)\\t%0, [%1, %2]!\", otherops);\n+\t\t{\n+\t\t  /* IWMMXT allows offsets larger than ldrd can handle,\n+\t\t     fix these up with a pair of ldr.  */\n+\t\t  if (GET_CODE (otherops[2]) == CONST_INT\n+\t\t      && (INTVAL(otherops[2]) <= -256\n+\t\t\t  || INTVAL(otherops[2]) >= 256))\n+\t\t    {\n+\t\t      output_asm_insn (\"ldr%?\\t%0, [%1, %2]!\", otherops);\n+\t\t      otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n+\t\t      output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n+\t\t    }\n+\t\t  else\n+\t\t    output_asm_insn (\"ldr%(d%)\\t%0, [%1, %2]!\", otherops);\n+\t\t}\n \t    }\n \t  else\n \t    {\n-\t      /* We only allow constant increments, so this is safe.  */\n-\t      output_asm_insn (\"ldr%(d%)\\t%0, [%1], %2\", otherops);\n+\t      /* IWMMXT allows offsets larger than ldrd can handle,\n+\t\t fix these up with a pair of ldr.  */\n+\t      if (GET_CODE (otherops[2]) == CONST_INT\n+\t\t  && (INTVAL(otherops[2]) <= -256\n+\t\t      || INTVAL(otherops[2]) >= 256))\n+\t\t{\n+\t\t  otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n+\t\t  output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n+\t\t  otherops[0] = operands[0];\n+\t\t  output_asm_insn (\"ldr%?\\t%0, [%1], %2\", otherops);\n+\t\t}\n+\t      else\n+\t\t/* We only allow constant increments, so this is safe.  */\n+\t\toutput_asm_insn (\"ldr%(d%)\\t%0, [%1], %2\", otherops);\n \t    }\n \t  break;\n \n@@ -9289,7 +9319,29 @@ output_move_double (rtx *operands)\n \t  otherops[1] = XEXP (XEXP (XEXP (operands[0], 0), 1), 0);\n \t  otherops[2] = XEXP (XEXP (XEXP (operands[0], 0), 1), 1);\n \n-\t  if (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)\n+\t  /* IWMMXT allows offsets larger than ldrd can handle,\n+\t     fix these up with a pair of ldr.  */\n+\t  if (GET_CODE (otherops[2]) == CONST_INT\n+\t      && (INTVAL(otherops[2]) <= -256\n+\t\t  || INTVAL(otherops[2]) >= 256))\n+\t    {\n+\t      rtx reg1;\n+\t      reg1 = gen_rtx_REG (SImode, 1 + REGNO (operands[1]));\n+\t      if (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)\n+\t\t{\n+\t\t  output_asm_insn (\"ldr%?\\t%0, [%1, %2]!\", otherops);\n+\t\t  otherops[0] = reg1;\n+\t\t  output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  otherops[0] = reg1;\n+\t\t  output_asm_insn (\"ldr%?\\t%0, [%1, #4]\", otherops);\n+\t\t  otherops[0] = operands[1];\n+\t\t  output_asm_insn (\"ldr%?\\t%0, [%1], %2\", otherops);\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)\n \t    output_asm_insn (\"str%(d%)\\t%0, [%1, %2]!\", otherops);\n \t  else\n \t    output_asm_insn (\"str%(d%)\\t%0, [%1], %2\", otherops);"}, {"sha": "d09bb734e2dcc712e3ee71796a4d6183a52d3bf8", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=fe2d934b4b7bdb0e3f72b575f90041e4e9b7e140", "patch": "@@ -1121,21 +1121,25 @@ enum reg_class\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n-  /* Restrict which direct reloads are allowed for VFP regs.  */ \\\n+  /* Restrict which direct reloads are allowed for VFP/iWMMXt regs.  */ \\\n   ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n     && (CLASS) == VFP_REGS)\t\t\t\t\t\\\n-   ? vfp_secondary_reload_class (MODE, X)\t\t\t\\\n+   ? coproc_secondary_reload_class (MODE, X, FALSE)\t\t\\\n+   : (TARGET_IWMMXT && (CLASS) == IWMMXT_REGS)\t\t\t\\\n+   ? coproc_secondary_reload_class (MODE, X, TRUE)\t\t\\\n    : TARGET_32BIT\t\t\t\t\t\t\\\n    ? (((MODE) == HImode && ! arm_arch4 && true_regnum (X) == -1) \\\n     ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n    : THUMB_SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X))\n \n /* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n-  /* Restrict which direct reloads are allowed for VFP regs.  */ \\\n+  /* Restrict which direct reloads are allowed for VFP/iWMMXt regs.  */ \\\n   ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n     && (CLASS) == VFP_REGS)\t\t\t\t\t\\\n-    ? vfp_secondary_reload_class (MODE, X) :\t\t\t\\\n+    ? coproc_secondary_reload_class (MODE, X, FALSE) :\t\t\\\n+    (TARGET_IWMMXT && (CLASS) == IWMMXT_REGS) ?\t\t\t\\\n+    coproc_secondary_reload_class (MODE, X, TRUE) :\t\t\\\n   /* Cannot load constants into Cirrus registers.  */\t\t\\\n    (TARGET_MAVERICK && TARGET_HARD_FLOAT\t\t\t\\\n      && (CLASS) == CIRRUS_REGS\t\t\t\t\t\\"}]}