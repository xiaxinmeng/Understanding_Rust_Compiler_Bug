{"sha": "bbe3c88351bc98a9866720e03ef76e8caf516461", "node_id": "C_kwDOANBUbNoAKGJiZTNjODgzNTFiYzk4YTk4NjY3MjBlMDNlZjc2ZThjYWY1MTY0NjE", "commit": {"author": {"name": "Pierre-Alexandre Bazin", "email": "bazin@adacore.com", "date": "2021-11-04T09:48:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-11-10T08:57:40Z"}, "message": "[Ada] Prove double precision integer arithmetic unit\n\ngcc/ada/\n\n\t* libgnat/a-nbnbig.ads: Mark the unit as Pure.\n\t* libgnat/s-aridou.adb: Add contracts and ghost code for proof.\n\t(Scaled_Divide): Reorder operations and use of temporaries in\n\ttwo places to facilitate proof.\n\t* libgnat/s-aridou.ads: Add full functional contracts.\n\t* libgnat/s-arit64.adb: Mark in SPARK.\n\t* libgnat/s-arit64.ads: Add contracts similar to those from\n\ts-aridou.ads.\n\t* rtsfind.ads: Document the limitation that runtime units\n\tloading does not work for private with-clauses.", "tree": {"sha": "0bbac2b99c63e565ca7ff967c14b065b238f2cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bbac2b99c63e565ca7ff967c14b065b238f2cdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbe3c88351bc98a9866720e03ef76e8caf516461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe3c88351bc98a9866720e03ef76e8caf516461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe3c88351bc98a9866720e03ef76e8caf516461", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe3c88351bc98a9866720e03ef76e8caf516461/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99f8a653683b2e3f14713656c79dc2b721c38e0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99f8a653683b2e3f14713656c79dc2b721c38e0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99f8a653683b2e3f14713656c79dc2b721c38e0f"}], "stats": {"total": 2628, "additions": 2515, "deletions": 113}, "files": [{"sha": "f574e78f8dcbbe4083ec3760b2692ae5f7f69923", "filename": "gcc/ada/libgnat/a-nbnbig.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads?ref=bbe3c88351bc98a9866720e03ef76e8caf516461", "patch": "@@ -30,7 +30,7 @@ pragma Assertion_Policy (Ghost => Ignore);\n package Ada.Numerics.Big_Numbers.Big_Integers_Ghost with\n    SPARK_Mode,\n    Ghost,\n-   Preelaborate\n+   Pure\n is\n    type Big_Integer is private\n      with Integer_Literal => From_Universal_Image;"}, {"sha": "67f2440192cf0034accda27a66dacad793567301", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 2320, "deletions": 97, "changes": 2417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=bbe3c88351bc98a9866720e03ef76e8caf516461"}, {"sha": "7c32f7fa6d6f217a88e53ea085dd38248b2ec336", "filename": "gcc/ada/libgnat/s-aridou.ads", "status": "modified", "additions": 91, "deletions": 7, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.ads?ref=bbe3c88351bc98a9866720e03ef76e8caf516461", "patch": "@@ -33,6 +33,9 @@\n --  signed integer values in cases where either overflow checking is required,\n --  or intermediate results are longer than the result type.\n \n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+\n generic\n \n    type Double_Int is range <>;\n@@ -50,27 +53,93 @@ generic\n    with function Shift_Left (A : Single_Uns; B : Natural) return Single_Uns\n      is <>;\n \n-package System.Arith_Double is\n-   pragma Pure;\n+package System.Arith_Double\n+  with Pure, SPARK_Mode\n+is\n+   --  Preconditions in this unit are meant for analysis only, not for run-time\n+   --  checking, so that the expected exceptions are raised. This is enforced\n+   --  by setting the corresponding assertion policy to Ignore. Postconditions\n+   --  and contract cases should not be executed at runtime as well, in order\n+   --  not to slow down the execution of these functions.\n+\n+   pragma Assertion_Policy (Pre            => Ignore,\n+                            Post           => Ignore,\n+                            Contract_Cases => Ignore,\n+                            Ghost          => Ignore);\n+\n+   package Signed_Conversion is new Signed_Conversions (Int => Double_Int);\n+\n+   function Big (Arg : Double_Int) return Big_Integer is\n+     (Signed_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   package Unsigned_Conversion is new Unsigned_Conversions (Int => Double_Uns);\n \n-   function Add_With_Ovflo_Check (X, Y : Double_Int) return Double_Int;\n+   function Big (Arg : Double_Uns) return Big_Integer is\n+     (Unsigned_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   function In_Double_Int_Range (Arg : Big_Integer) return Boolean is\n+     (In_Range (Arg, Big (Double_Int'First), Big (Double_Int'Last)))\n+   with Ghost;\n+\n+   function Add_With_Ovflo_Check (X, Y : Double_Int) return Double_Int\n+   with\n+     Pre  => In_Double_Int_Range (Big (X) + Big (Y)),\n+     Post => Add_With_Ovflo_Check'Result = X + Y;\n    --  Raises Constraint_Error if sum of operands overflows Double_Int,\n    --  otherwise returns the signed integer sum.\n \n-   function Subtract_With_Ovflo_Check (X, Y : Double_Int) return Double_Int;\n+   function Subtract_With_Ovflo_Check (X, Y : Double_Int) return Double_Int\n+   with\n+     Pre  => In_Double_Int_Range (Big (X) - Big (Y)),\n+     Post => Subtract_With_Ovflo_Check'Result = X - Y;\n    --  Raises Constraint_Error if difference of operands overflows Double_Int,\n    --  otherwise returns the signed integer difference.\n \n-   function Multiply_With_Ovflo_Check (X, Y : Double_Int) return Double_Int;\n+   function Multiply_With_Ovflo_Check (X, Y : Double_Int) return Double_Int\n+   with\n+     Pre  => In_Double_Int_Range (Big (X) * Big (Y)),\n+     Post => Multiply_With_Ovflo_Check'Result = X * Y;\n    pragma Convention (C, Multiply_With_Ovflo_Check);\n    --  Raises Constraint_Error if product of operands overflows Double_Int,\n    --  otherwise returns the signed integer product. Gigi may also call this\n    --  routine directly.\n \n+   function Same_Sign (X, Y : Big_Integer) return Boolean is\n+     (X = Big (Double_Int'(0))\n+        or else Y = Big (Double_Int'(0))\n+        or else (X < Big (Double_Int'(0))) = (Y < Big (Double_Int'(0))))\n+   with Ghost;\n+\n+   function Round_Quotient (X, Y, Q, R : Big_Integer) return Big_Integer is\n+     (if abs R > (abs Y - Big (Double_Int'(1))) / Big (Double_Int'(2)) then\n+       (if Same_Sign (X, Y) then Q + Big (Double_Int'(1))\n+        else Q - Big (Double_Int'(1)))\n+      else\n+        Q)\n+   with\n+     Ghost,\n+     Pre => Y /= 0 and then Q = X / Y and then R = X rem Y;\n+\n    procedure Scaled_Divide\n      (X, Y, Z : Double_Int;\n       Q, R    : out Double_Int;\n-      Round   : Boolean);\n+      Round   : Boolean)\n+   with\n+     Pre  => Z /= 0\n+       and then In_Double_Int_Range\n+         (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                        Big (X) * Big (Y) / Big (Z),\n+                                        Big (X) * Big (Y) rem Big (Z))\n+          else Big (X) * Big (Y) / Big (Z)),\n+     Post => Big (R) = Big (X) * Big (Y) rem Big (Z)\n+       and then\n+         (if Round then\n+            Big (Q) = Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                      Big (X) * Big (Y) / Big (Z), Big (R))\n+          else\n+            Big (Q) = Big (X) * Big (Y) / Big (Z));\n    --  Performs the division of (X * Y) / Z, storing the quotient in Q\n    --  and the remainder in R. Constraint_Error is raised if Z is zero,\n    --  or if the quotient does not fit in Double_Int. Round indicates if\n@@ -82,7 +151,22 @@ package System.Arith_Double is\n    procedure Double_Divide\n      (X, Y, Z : Double_Int;\n       Q, R    : out Double_Int;\n-      Round   : Boolean);\n+      Round   : Boolean)\n+   with\n+     Pre  => Y /= 0\n+       and then Z /= 0\n+       and then In_Double_Int_Range\n+         (if Round then Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                                        Big (X) / (Big (Y) * Big (Z)),\n+                                        Big (X) rem (Big (Y) * Big (Z)))\n+          else Big (X) / (Big (Y) * Big (Z))),\n+     Post => Big (R) = Big (X) rem (Big (Y) * Big (Z))\n+       and then\n+         (if Round then\n+            Big (Q) = Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                                      Big (X) / (Big (Y) * Big (Z)), Big (R))\n+          else\n+            Big (Q) = Big (X) / (Big (Y) * Big (Z)));\n    --  Performs the division X / (Y * Z), storing the quotient in Q and\n    --  the remainder in R. Constraint_Error is raised if Y or Z is zero,\n    --  or if the quotient does not fit in Double_Int. Round indicates if the"}, {"sha": "23b76d9fa1e9d6f0132234aaf0ea0aa4f9a2d7c2", "filename": "gcc/ada/libgnat/s-arit64.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-arit64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-arit64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit64.adb?ref=bbe3c88351bc98a9866720e03ef76e8caf516461", "patch": "@@ -31,7 +31,9 @@\n \n with System.Arith_Double;\n \n-package body System.Arith_64 is\n+package body System.Arith_64\n+  with SPARK_Mode\n+is\n \n    subtype Uns64 is Interfaces.Unsigned_64;\n    subtype Uns32 is Interfaces.Unsigned_32;"}, {"sha": "fbfd0f6546888663895190b538189fc33552e93e", "filename": "gcc/ada/libgnat/s-arit64.ads", "status": "modified", "additions": 94, "deletions": 7, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit64.ads?ref=bbe3c88351bc98a9866720e03ef76e8caf516461", "patch": "@@ -36,31 +36,103 @@\n pragma Restrictions (No_Elaboration_Code);\n --  Allow direct call from gigi generated code\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced\n+--  by setting the corresponding assertion policy to Ignore. Postconditions\n+--  and contract cases should not be executed at runtime as well, in order\n+--  not to slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n with Interfaces;\n \n-package System.Arith_64 is\n-   pragma Pure;\n+package System.Arith_64\n+  with Pure, SPARK_Mode\n+is\n+   use type Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer;\n+   use type Interfaces.Integer_64;\n \n    subtype Int64 is Interfaces.Integer_64;\n \n-   function Add_With_Ovflo_Check64 (X, Y : Int64) return Int64;\n+   subtype Big_Integer is\n+     Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer\n+     with Ghost;\n+\n+   package Signed_Conversion is new\n+     Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Signed_Conversions\n+     (Int => Int64);\n+\n+   function Big (Arg : Int64) return Big_Integer is\n+     (Signed_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   function In_Int64_Range (Arg : Big_Integer) return Boolean is\n+     (Ada.Numerics.Big_Numbers.Big_Integers_Ghost.In_Range\n+       (Arg, Big (Int64'First), Big (Int64'Last)))\n+   with Ghost;\n+\n+   function Add_With_Ovflo_Check64 (X, Y : Int64) return Int64\n+   with\n+     Pre  => In_Int64_Range (Big (X) + Big (Y)),\n+     Post => Add_With_Ovflo_Check64'Result = X + Y;\n    --  Raises Constraint_Error if sum of operands overflows 64 bits,\n    --  otherwise returns the 64-bit signed integer sum.\n \n-   function Subtract_With_Ovflo_Check64 (X, Y : Int64) return Int64;\n+   function Subtract_With_Ovflo_Check64 (X, Y : Int64) return Int64\n+   with\n+     Pre  => In_Int64_Range (Big (X) - Big (Y)),\n+     Post => Subtract_With_Ovflo_Check64'Result = X - Y;\n    --  Raises Constraint_Error if difference of operands overflows 64\n    --  bits, otherwise returns the 64-bit signed integer difference.\n \n-   function Multiply_With_Ovflo_Check64 (X, Y : Int64) return Int64;\n+   function Multiply_With_Ovflo_Check64 (X, Y : Int64) return Int64\n+   with\n+     Pure_Function,\n+     Pre  => In_Int64_Range (Big (X) * Big (Y)),\n+     Post => Multiply_With_Ovflo_Check64'Result = X * Y;\n    pragma Export (C, Multiply_With_Ovflo_Check64, \"__gnat_mulv64\");\n    --  Raises Constraint_Error if product of operands overflows 64\n    --  bits, otherwise returns the 64-bit signed integer product.\n    --  Gigi may also call this routine directly.\n \n+   function Same_Sign (X, Y : Big_Integer) return Boolean is\n+     (X = Big (Int64'(0))\n+        or else Y = Big (Int64'(0))\n+        or else (X < Big (Int64'(0))) = (Y < Big (Int64'(0))))\n+   with Ghost;\n+\n+   function Round_Quotient (X, Y, Q, R : Big_Integer) return Big_Integer is\n+     (if abs R > (abs Y - Big (Int64'(1))) / Big (Int64'(2)) then\n+       (if Same_Sign (X, Y) then Q + Big (Int64'(1))\n+        else Q - Big (Int64'(1)))\n+      else\n+        Q)\n+   with\n+     Ghost,\n+     Pre => Y /= 0 and then Q = X / Y and then R = X rem Y;\n+\n    procedure Scaled_Divide64\n      (X, Y, Z : Int64;\n       Q, R    : out Int64;\n-      Round   : Boolean);\n+      Round   : Boolean)\n+   with\n+     Pre  => Z /= 0\n+       and then In_Int64_Range\n+         (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                        Big (X) * Big (Y) / Big (Z),\n+                                        Big (X) * Big (Y) rem Big (Z))\n+          else Big (X) * Big (Y) / Big (Z)),\n+     Post => Big (R) = Big (X) * Big (Y) rem Big (Z)\n+       and then\n+         (if Round then\n+            Big (Q) = Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                      Big (X) * Big (Y) / Big (Z), Big (R))\n+          else\n+            Big (Q) = Big (X) * Big (Y) / Big (Z));\n    --  Performs the division of (X * Y) / Z, storing the quotient in Q\n    --  and the remainder in R. Constraint_Error is raised if Z is zero,\n    --  or if the quotient does not fit in 64 bits. Round indicates if\n@@ -78,7 +150,22 @@ package System.Arith_64 is\n    procedure Double_Divide64\n      (X, Y, Z : Int64;\n       Q, R    : out Int64;\n-      Round   : Boolean);\n+      Round   : Boolean)\n+   with\n+     Pre  => Y /= 0\n+       and then Z /= 0\n+       and then In_Int64_Range\n+         (if Round then Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                                        Big (X) / (Big (Y) * Big (Z)),\n+                                        Big (X) rem (Big (Y) * Big (Z)))\n+          else Big (X) / (Big (Y) * Big (Z))),\n+     Post => Big (R) = Big (X) rem (Big (Y) * Big (Z))\n+       and then\n+         (if Round then\n+            Big (Q) = Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                                      Big (X) / (Big (Y) * Big (Z)), Big (R))\n+          else\n+            Big (Q) = Big (X) / (Big (Y) * Big (Z)));\n    --  Performs the division X / (Y * Z), storing the quotient in Q and\n    --  the remainder in R. Constraint_Error is raised if Y or Z is zero,\n    --  or if the quotient does not fit in 64 bits. Round indicates if the"}, {"sha": "bedea071c7fc150989d5f770c036de8726edb381", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe3c88351bc98a9866720e03ef76e8caf516461/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=bbe3c88351bc98a9866720e03ef76e8caf516461", "patch": "@@ -60,6 +60,12 @@ package Rtsfind is\n    --  the compilation except in the presence of use clauses, which might\n    --  result in unexpected ambiguities.\n \n+   --  IMPORTANT NOTE: the specs of packages and procedures with'ed using\n+   --  this mechanism must not contain private with clauses. This is because\n+   --  the special context installation/removal for private with clauses\n+   --  only works in a clean environment for compilation, and could lead\n+   --  here to removing visibility over lib units in the calling context.\n+\n    --  NOTE: If RTU_Id is modified, the subtypes of RTU_Id in the package body\n    --  might need to be modified. See Get_Unit_Name.\n "}]}