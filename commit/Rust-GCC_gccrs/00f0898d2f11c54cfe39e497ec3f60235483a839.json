{"sha": "00f0898d2f11c54cfe39e497ec3f60235483a839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmMDg5OGQyZjExYzU0Y2ZlMzllNDk3ZWMzZjYwMjM1NDgzYTgzOQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-05-14T16:18:06Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-05-14T16:18:06Z"}, "message": "i386.md (any_div): New code iterator.\n\n\t* config/i386/i386.md (any_div): New code iterator.\n\t(paired_mod): New code attribute.\n\t(sgnprefix): Handle DIV and UDIV RTXes.\n\t(u): Ditto.\n\t(<u>divmod<mode>4): Macroize expander from divmod<mode>4\n\tand udivmod<mode>4 patterns using any_div code iterator.\n\t(divmod splitters): Macroize splitters using any_div code iterator.\n\t(*udivmodsi4_pow2_zext_1): Use exactl_log2 in insn condition.\n\t(*udivmodsi4_pow2_zext_2): Ditto.\n\t(*<u>divmod<mode>4_noext): Macroize insn from *divmod<mode>4_noext\n\tand *udivmod<mode>4_noext patterns using any_div code iterator.\n\t(*<u>divmod<mode>4_noext_zext_1): Macroize insn from\n\t*divmod<mode>4_noext_zext_1 and *udivmod<mode>4_noext_zext_1\n\tpatterns using any_div code iterator.\n\t(*<u>divmod<mode>4_noext_zext_2): Macroize insn from\n\t*divmod<mode>4_noext_zext_2 and *udivmod<mode>4_noext_zext_2\n\tpatterns using any_div code iterator.\n\t(<u>divmodhiqi3): Macroize insn from divmodhiqi3 and\n\tudivmodhiqi3 patterns using any_extend code iterator.\n\nFrom-SVN: r271179", "tree": {"sha": "5617c8e645fb54f1f426f9ffc5112094e1ecabf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5617c8e645fb54f1f426f9ffc5112094e1ecabf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00f0898d2f11c54cfe39e497ec3f60235483a839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f0898d2f11c54cfe39e497ec3f60235483a839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f0898d2f11c54cfe39e497ec3f60235483a839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f0898d2f11c54cfe39e497ec3f60235483a839/comments", "author": null, "committer": null, "parents": [{"sha": "a73d2fa852c5104c458f2877a0fc361ab8507660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73d2fa852c5104c458f2877a0fc361ab8507660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a73d2fa852c5104c458f2877a0fc361ab8507660"}], "stats": {"total": 672, "additions": 289, "deletions": 383}, "files": [{"sha": "0e7bce8a46db046411edf4e47755ad1f297c9ca8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f0898d2f11c54cfe39e497ec3f60235483a839/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f0898d2f11c54cfe39e497ec3f60235483a839/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00f0898d2f11c54cfe39e497ec3f60235483a839", "patch": "@@ -1,12 +1,34 @@\n+2019-05-14  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (any_div): New code iterator.\n+\t(paired_mod): New code attribute.\n+\t(sgnprefix): Handle DIV and UDIV RTXes.\n+\t(u): Ditto.\n+\t(<u>divmod<mode>4): Macroize expander from divmod<mode>4\n+\tand udivmod<mode>4 patterns using any_div code iterator.\n+\t(divmod splitters): Macroize splitters using any_div code iterator.\n+\t(*udivmodsi4_pow2_zext_1): Use exactl_log2 in insn condition.\n+\t(*udivmodsi4_pow2_zext_2): Ditto.\n+\t(*<u>divmod<mode>4_noext): Macroize insn from *divmod<mode>4_noext\n+\tand *udivmod<mode>4_noext patterns using any_div code iterator.\n+\t(*<u>divmod<mode>4_noext_zext_1): Macroize insn from\n+\t*divmod<mode>4_noext_zext_1 and *udivmod<mode>4_noext_zext_1\n+\tpatterns using any_div code iterator.\n+\t(*<u>divmod<mode>4_noext_zext_2): Macroize insn from\n+\t*divmod<mode>4_noext_zext_2 and *udivmod<mode>4_noext_zext_2\n+\tpatterns using any_div code iterator.\n+\t(<u>divmodhiqi3): Macroize insn from divmodhiqi3 and\n+\tudivmodhiqi3 patterns using any_extend code iterator.\n+\n 2019-05-14  Richard Biener  <rguenther@suse.de>\n-\tH.J. Lu  <hongjiu.lu@intel.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR tree-optimization/88828\n \t* tree-ssa-forwprop.c (simplify_vector_constructor): Handle\n \tpermuting in a single non-constant element not extracted\n \tfrom a vector.\n \n-2019-05-14  Przemyslaw Wirkus  <przemyslaw.wirkus@arm.com\\>\n+2019-05-14  Przemyslaw Wirkus  <przemyslaw.wirkus@arm.com>\n \n \t* internal-fn.def (SIGNBIT): New.\n \t* config/aarch64/aarch64-simd.md (signbitv2sf2): New expand"}, {"sha": "05411221197fd25e86b6fc71f252a7d6211ad3c3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 265, "deletions": 381, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f0898d2f11c54cfe39e497ec3f60235483a839/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f0898d2f11c54cfe39e497ec3f60235483a839/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=00f0898d2f11c54cfe39e497ec3f60235483a839", "patch": "@@ -933,11 +933,12 @@\n (define_code_iterator any_extend [sign_extend zero_extend])\n \n ;; Prefix for insn menmonic.\n-(define_code_attr sgnprefix [(sign_extend \"i\") (zero_extend \"\")])\n-\n+(define_code_attr sgnprefix [(sign_extend \"i\") (zero_extend \"\")\n+\t\t\t     (div \"i\") (udiv \"\")])\n ;; Prefix for define_insn\n-(define_code_attr u [(sign_extend \"\") (zero_extend \"u\")])\n (define_code_attr s [(sign_extend \"s\") (zero_extend \"u\")])\n+(define_code_attr u [(sign_extend \"\") (zero_extend \"u\")\n+\t\t     (div \"\") (udiv \"u\")])\n (define_code_attr u_bool [(sign_extend \"false\") (zero_extend \"true\")])\n \n ;; Used in signed and unsigned truncations.\n@@ -7475,13 +7476,16 @@\n \f\n ;; Divmod instructions.\n \n-(define_expand \"divmod<mode>4\"\n+(define_code_iterator any_div [div udiv])\n+(define_code_attr paired_mod [(div \"mod\") (udiv \"umod\")])\n+\n+(define_expand \"<u>divmod<mode>4\"\n   [(parallel [(set (match_operand:SWIM248 0 \"register_operand\")\n-\t\t   (div:SWIM248\n+\t\t   (any_div:SWIM248\n \t\t     (match_operand:SWIM248 1 \"register_operand\")\n \t\t     (match_operand:SWIM248 2 \"nonimmediate_operand\")))\n \t      (set (match_operand:SWIM248 3 \"register_operand\")\n-\t\t   (mod:SWIM248 (match_dup 1) (match_dup 2)))\n+\t\t   (<paired_mod>:SWIM248 (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])])\n \n ;; Split with 8bit unsigned divide:\n@@ -7491,10 +7495,10 @@\n ;;\t   use original integer divide\n (define_split\n   [(set (match_operand:SWI48 0 \"register_operand\")\n-\t(div:SWI48 (match_operand:SWI48 2 \"register_operand\")\n-\t\t    (match_operand:SWI48 3 \"nonimmediate_operand\")))\n+\t(any_div:SWI48 (match_operand:SWI48 2 \"register_operand\")\n+\t\t       (match_operand:SWI48 3 \"nonimmediate_operand\")))\n    (set (match_operand:SWI48 1 \"register_operand\")\n-\t(mod:SWI48 (match_dup 2) (match_dup 3)))\n+\t(<paired_mod>:SWI48 (match_dup 2) (match_dup 3)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_USE_8BIT_IDIV\n    && TARGET_QIMODE_MATH\n@@ -7506,12 +7510,13 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\")\n \t(zero_extend:DI\n-\t  (div:SI (match_operand:SI 2 \"register_operand\")\n-\t\t  (match_operand:SI 3 \"nonimmediate_operand\"))))\n+\t  (any_div:SI (match_operand:SI 2 \"register_operand\")\n+\t\t      (match_operand:SI 3 \"nonimmediate_operand\"))))\n    (set (match_operand:SI 1 \"register_operand\")\n-\t(mod:SI (match_dup 2) (match_dup 3)))\n+\t(<paired_mod>:SI (match_dup 2) (match_dup 3)))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_USE_8BIT_IDIV\n+  \"TARGET_64BIT\n+   && TARGET_USE_8BIT_IDIV\n    && TARGET_QIMODE_MATH\n    && can_create_pseudo_p ()\n    && !optimize_insn_for_size_p ()\"\n@@ -7521,12 +7526,13 @@\n (define_split\n   [(set (match_operand:DI 1 \"register_operand\")\n \t(zero_extend:DI\n-\t  (mod:SI (match_operand:SI 2 \"register_operand\")\n-\t\t  (match_operand:SI 3 \"nonimmediate_operand\"))))\n+\t  (<paired_mod>:SI (match_operand:SI 2 \"register_operand\")\n+\t\t\t   (match_operand:SI 3 \"nonimmediate_operand\"))))\n    (set (match_operand:SI 0 \"register_operand\")\n-\t(div:SI  (match_dup 2) (match_dup 3)))\n+\t(any_div:SI  (match_dup 2) (match_dup 3)))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_USE_8BIT_IDIV\n+  \"TARGET_64BIT\n+   && TARGET_USE_8BIT_IDIV\n    && TARGET_QIMODE_MATH\n    && can_create_pseudo_p ()\n    && !optimize_insn_for_size_p ()\"\n@@ -7568,6 +7574,28 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"udivmod<mode>4_1\"\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"=a\")\n+\t(udiv:SWI48 (match_operand:SWI48 2 \"register_operand\" \"0\")\n+\t\t    (match_operand:SWI48 3 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:SWI48 1 \"register_operand\" \"=&d\")\n+\t(umod:SWI48 (match_dup 2) (match_dup 3)))\n+   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (udiv:SWI48 (match_dup 2) (match_dup 3)))\n+\t      (set (match_dup 1)\n+\t\t   (umod:SWI48 (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn_and_split \"divmodsi4_zext_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n \t(zero_extend:DI\n@@ -7579,7 +7607,7 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n   \"#\"\n-  \"reload_completed\"\n+  \"&& reload_completed\"\n   [(parallel [(set (match_dup 1)\n \t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n \t      (clobber (reg:CC FLAGS_REG))])\n@@ -7604,6 +7632,29 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"udivmodsi4_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (udiv:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 1)\n+\t\t   (umod:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn_and_split \"divmodsi4_zext_2\"\n   [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n \t(zero_extend:DI\n@@ -7615,7 +7666,7 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n   \"#\"\n-  \"reload_completed\"\n+  \"&& reload_completed\"\n   [(parallel [(set (match_dup 6)\n \t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n \t      (clobber (reg:CC FLAGS_REG))])\n@@ -7641,6 +7692,29 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"udivmodsi4_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:SI (match_dup 2) (match_dup 3)))\n+   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 4) (const_int 0))\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (umod:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 0)\n+\t\t   (udiv:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 4))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"operands[4] = gen_lowpart (SImode, operands[1]);\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn_and_split \"*divmod<mode>4\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n \t(div:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n@@ -7676,6 +7750,52 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*udivmod<mode>4\"\n+  [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n+\t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n+\t\t      (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:SWIM248 1 \"register_operand\" \"=&d\")\n+\t(umod:SWIM248 (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (udiv:SWIM248 (match_dup 2) (match_dup 3)))\n+\t      (set (match_dup 1)\n+\t\t   (umod:SWIM248 (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Optimize division or modulo by constant power of 2, if the constant\n+;; materializes only after expansion.\n+(define_insn_and_split \"*udivmod<mode>4_pow2\"\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n+\t(udiv:SWI48 (match_operand:SWI48 2 \"register_operand\" \"0\")\n+\t\t    (match_operand:SWI48 3 \"const_int_operand\" \"n\")))\n+   (set (match_operand:SWI48 1 \"register_operand\" \"=r\")\n+\t(umod:SWI48 (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"IN_RANGE (exact_log2 (UINTVAL (operands[3])), 1, 31)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (parallel [(set (match_dup 0) (lshiftrt:<MODE> (match_dup 2) (match_dup 4)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 1) (and:<MODE> (match_dup 1) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  int v = exact_log2 (UINTVAL (operands[3]));\n+  operands[4] = GEN_INT (v);\n+  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn_and_split \"*divmodsi4_zext_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n \t(zero_extend:DI\n@@ -7686,7 +7806,7 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n   \"#\"\n-  \"reload_completed\"\n+  \"&& reload_completed\"\n   [(parallel [(set (match_dup 1)\n \t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n \t      (clobber (reg:CC FLAGS_REG))])\n@@ -7711,6 +7831,54 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"*udivmodsi4_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (udiv:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 1)\n+\t\t   (umod:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*udivmodsi4_pow2_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\n+   && exact_log2 (UINTVAL (operands[3])) > 0\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (lshiftrt:SI (match_dup 2) (match_dup 4))))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 1) (and:SI (match_dup 1) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  int v = exact_log2 (UINTVAL (operands[3]));\n+  operands[4] = GEN_INT (v);\n+  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn_and_split \"*divmodsi4_zext_2\"\n   [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n \t(zero_extend:DI\n@@ -7721,7 +7889,7 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n   \"#\"\n-  \"reload_completed\"\n+  \"&& reload_completed\"\n   [(parallel [(set (match_dup 6)\n \t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n \t      (clobber (reg:CC FLAGS_REG))])\n@@ -7747,44 +7915,93 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*divmod<mode>4_noext\"\n+(define_insn_and_split \"*udivmodsi4_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 4) (const_int 0))\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (umod:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 0)\n+\t\t   (udiv:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 4))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"operands[4] = gen_lowpart (SImode, operands[1]);\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*udivmodsi4_pow2_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\n+   && exact_log2 (UINTVAL (operands[3])) > 0\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (parallel [(set (match_dup 0) (lshiftrt:SI (match_dup 2) (match_dup 4)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (and:SI (match_dup 1) (match_dup 5))))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  int v = exact_log2 (UINTVAL (operands[3]));\n+  operands[4] = GEN_INT (v);\n+  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*<u>divmod<mode>4_noext\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n-\t(div:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n-\t\t    (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n+\t(any_div:SWIM248\n+\t  (match_operand:SWIM248 2 \"register_operand\" \"0\")\n+\t  (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n    (set (match_operand:SWIM248 1 \"register_operand\" \"=d\")\n-\t(mod:SWIM248 (match_dup 2) (match_dup 3)))\n+\t(<paired_mod>:SWIM248 (match_dup 2) (match_dup 3)))\n    (use (match_operand:SWIM248 4 \"register_operand\" \"1\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n-  \"idiv{<imodesuffix>}\\t%3\"\n+  \"<sgnprefix>div{<imodesuffix>}\\t%3\"\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*divmodsi4_noext_zext_1\"\n+(define_insn \"*<u>divmodsi4_noext_zext_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n \t(zero_extend:DI\n-\t  (div:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+\t  (any_div:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t      (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n    (set (match_operand:SI 1 \"register_operand\" \"=d\")\n-\t(mod:SI (match_dup 2) (match_dup 3)))\n+\t(<paired_mod>:SI (match_dup 2) (match_dup 3)))\n    (use (match_operand:SI 4 \"register_operand\" \"1\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n-  \"idiv{l}\\t%3\"\n+  \"<sgnprefix>div{l}\\t%3\"\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*divmodsi4_noext_zext_2\"\n+(define_insn \"*<u>divmodsi4_noext_zext_2\"\n   [(set (match_operand:DI 1 \"register_operand\" \"=d\")\n \t(zero_extend:DI\n-\t  (mod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+\t  (<paired_mod>:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n    (set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(div:SI (match_dup 2) (match_dup 3)))\n+\t(any_div:SI (match_dup 2) (match_dup 3)))\n    (use (match_operand:SI 4 \"register_operand\" \"1\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n-  \"idiv{l}\\t%3\"\n+  \"<sgnprefix>div{l}\\t%3\"\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"SI\")])\n \n@@ -7800,7 +8017,7 @@\n {\n   rtx div, mod;\n   rtx tmp0, tmp1;\n-  \n+\n   tmp0 = gen_reg_rtx (HImode);\n   tmp1 = gen_reg_rtx (HImode);\n \n@@ -7825,345 +8042,6 @@\n   DONE;\n })\n \n-;; Divide AX by r/m8, with result stored in\n-;; AL <- Quotient\n-;; AH <- Remainder\n-;; Change div/mod to HImode and extend the second argument to HImode\n-;; so that mode of div/mod matches with mode of arguments.  Otherwise\n-;; combine may fail.\n-(define_insn \"divmodhiqi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n-\t(ior:HI\n-\t  (ashift:HI\n-\t    (zero_extend:HI\n-\t      (truncate:QI\n-\t\t(mod:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t\t(sign_extend:HI\n-\t\t\t  (match_operand:QI 2 \"nonimmediate_operand\" \"qm\")))))\n-\t    (const_int 8))\n-\t  (zero_extend:HI\n-\t    (truncate:QI\n-\t      (div:HI (match_dup 1) (sign_extend:HI (match_dup 2)))))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"idiv{b}\\t%2\"\n-  [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_expand \"udivmod<mode>4\"\n-  [(parallel [(set (match_operand:SWIM248 0 \"register_operand\")\n-\t\t   (udiv:SWIM248\n-\t\t     (match_operand:SWIM248 1 \"register_operand\")\n-\t\t     (match_operand:SWIM248 2 \"nonimmediate_operand\")))\n-\t      (set (match_operand:SWIM248 3 \"register_operand\")\n-\t\t   (umod:SWIM248 (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-;; Split with 8bit unsigned divide:\n-;; \tif (dividend an divisor are in [0-255])\n-;;\t   use 8bit unsigned integer divide\n-;;\t else\n-;;\t   use original integer divide\n-(define_split\n-  [(set (match_operand:SWI48 0 \"register_operand\")\n-\t(udiv:SWI48 (match_operand:SWI48 2 \"register_operand\")\n-\t\t    (match_operand:SWI48 3 \"nonimmediate_operand\")))\n-   (set (match_operand:SWI48 1 \"register_operand\")\n-\t(umod:SWI48 (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_USE_8BIT_IDIV\n-   && TARGET_QIMODE_MATH\n-   && can_create_pseudo_p ()\n-   && !optimize_insn_for_size_p ()\"\n-  [(const_int 0)]\n-  \"ix86_split_idivmod (<MODE>mode, operands, false); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(zero_extend:DI\n-\t  (udiv:SI (match_operand:SI 2 \"register_operand\")\n-\t\t   (match_operand:SI 3 \"nonimmediate_operand\"))))\n-   (set (match_operand:SI 1 \"register_operand\")\n-\t(umod:SI (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && TARGET_USE_8BIT_IDIV\n-   && TARGET_QIMODE_MATH\n-   && can_create_pseudo_p ()\n-   && !optimize_insn_for_size_p ()\"\n-  [(const_int 0)]\n-  \"ix86_split_idivmod (SImode, operands, false); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:DI 1 \"register_operand\")\n-\t(zero_extend:DI\n-\t  (umod:SI (match_operand:SI 2 \"register_operand\")\n-\t\t   (match_operand:SI 3 \"nonimmediate_operand\"))))\n-   (set (match_operand:SI 0 \"register_operand\")\n-\t(udiv:SI (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && TARGET_USE_8BIT_IDIV\n-   && TARGET_QIMODE_MATH\n-   && can_create_pseudo_p ()\n-   && !optimize_insn_for_size_p ()\"\n-  [(const_int 0)]\n-  \"ix86_split_idivmod (SImode, operands, false); DONE;\")\n-\n-(define_insn_and_split \"udivmod<mode>4_1\"\n-  [(set (match_operand:SWI48 0 \"register_operand\" \"=a\")\n-\t(udiv:SWI48 (match_operand:SWI48 2 \"register_operand\" \"0\")\n-\t\t    (match_operand:SWI48 3 \"nonimmediate_operand\" \"rm\")))\n-   (set (match_operand:SWI48 1 \"register_operand\" \"=&d\")\n-\t(umod:SWI48 (match_dup 2) (match_dup 3)))\n-   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 1) (const_int 0))\n-   (parallel [(set (match_dup 0)\n-\t\t   (udiv:SWI48 (match_dup 2) (match_dup 3)))\n-\t      (set (match_dup 1)\n-\t\t   (umod:SWI48 (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn_and_split \"udivmodsi4_zext_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-\t(zero_extend:DI\n-\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n-   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n-\t(umod:SI (match_dup 2) (match_dup 3)))\n-   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 1) (const_int 0))\n-   (parallel [(set (match_dup 0)\n-\t\t   (zero_extend:DI (udiv:SI (match_dup 2) (match_dup 3))))\n-\t      (set (match_dup 1)\n-\t\t   (umod:SI (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn_and_split \"udivmodsi4_zext_2\"\n-  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n-\t(zero_extend:DI\n-\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(udiv:SI (match_dup 2) (match_dup 3)))\n-   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 4) (const_int 0))\n-   (parallel [(set (match_dup 1)\n-\t\t   (zero_extend:DI (umod:SI (match_dup 2) (match_dup 3))))\n-\t      (set (match_dup 0)\n-\t\t   (udiv:SI (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 4))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[4] = gen_lowpart (SImode, operands[1]);\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn_and_split \"*udivmod<mode>4\"\n-  [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n-\t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n-\t\t      (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n-   (set (match_operand:SWIM248 1 \"register_operand\" \"=&d\")\n-\t(umod:SWIM248 (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 1) (const_int 0))\n-   (parallel [(set (match_dup 0)\n-\t\t   (udiv:SWIM248 (match_dup 2) (match_dup 3)))\n-\t      (set (match_dup 1)\n-\t\t   (umod:SWIM248 (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn_and_split \"*udivmodsi4_zext_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-\t(zero_extend:DI\n-\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n-   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n-\t(umod:SI (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 1) (const_int 0))\n-   (parallel [(set (match_dup 0)\n-\t\t   (zero_extend:DI (udiv:SI (match_dup 2) (match_dup 3))))\n-\t      (set (match_dup 1)\n-\t\t   (umod:SI (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 1))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn_and_split \"*udivmodsi4_zext_2\"\n-  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n-\t(zero_extend:DI\n-\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(udiv:SI (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 4) (const_int 0))\n-   (parallel [(set (match_dup 1)\n-\t\t   (zero_extend:DI (umod:SI (match_dup 2) (match_dup 3))))\n-\t      (set (match_dup 0)\n-\t\t   (udiv:SI (match_dup 2) (match_dup 3)))\n-\t      (use (match_dup 4))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[4] = gen_lowpart (SImode, operands[1]);\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; Optimize division or modulo by constant power of 2, if the constant\n-;; materializes only after expansion.\n-(define_insn_and_split \"*udivmod<mode>4_pow2\"\n-  [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n-\t(udiv:SWI48 (match_operand:SWI48 2 \"register_operand\" \"0\")\n-\t\t    (match_operand:SWI48 3 \"const_int_operand\" \"n\")))\n-   (set (match_operand:SWI48 1 \"register_operand\" \"=r\")\n-\t(umod:SWI48 (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"IN_RANGE (INTVAL (operands[3]), 2, HOST_WIDE_INT_UC (0x80000000))\n-   && (UINTVAL (operands[3]) & (UINTVAL (operands[3]) - 1)) == 0\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (parallel [(set (match_dup 0) (lshiftrt:<MODE> (match_dup 2) (match_dup 4)))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (parallel [(set (match_dup 1) (and:<MODE> (match_dup 1) (match_dup 5)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  int v = exact_log2 (UINTVAL (operands[3]));\n-  operands[4] = GEN_INT (v);\n-  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn_and_split \"*udivmodsi4_pow2_zext_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\"))))\n-   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n-\t(umod:SI (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && IN_RANGE (INTVAL (operands[3]), 2, HOST_WIDE_INT_UC (0x80000000))\n-   && (UINTVAL (operands[3]) & (UINTVAL (operands[3]) - 1)) == 0\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (parallel [(set (match_dup 0)\n-\t\t   (zero_extend:DI (lshiftrt:SI (match_dup 2) (match_dup 4))))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (parallel [(set (match_dup 1) (and:SI (match_dup 1) (match_dup 5)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  int v = exact_log2 (UINTVAL (operands[3]));\n-  operands[4] = GEN_INT (v);\n-  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn_and_split \"*udivmodsi4_pow2_zext_2\"\n-  [(set (match_operand:DI 1 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(umod:SI (match_dup 2) (match_dup 3)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && IN_RANGE (INTVAL (operands[3]), 2, HOST_WIDE_INT_UC (0x80000000))\n-   && (UINTVAL (operands[3]) & (UINTVAL (operands[3]) - 1)) == 0\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (parallel [(set (match_dup 0) (lshiftrt:SI (match_dup 2) (match_dup 4)))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (parallel [(set (match_dup 1)\n-\t\t   (zero_extend:DI (and:SI (match_dup 1) (match_dup 5))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  int v = exact_log2 (UINTVAL (operands[3]));\n-  operands[4] = GEN_INT (v);\n-  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*udivmod<mode>4_noext\"\n-  [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n-\t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n-\t\t      (match_operand:SWIM248 3 \"nonimmediate_operand\" \"rm\")))\n-   (set (match_operand:SWIM248 1 \"register_operand\" \"=d\")\n-\t(umod:SWIM248 (match_dup 2) (match_dup 3)))\n-   (use (match_operand:SWIM248 4 \"register_operand\" \"1\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"div{<imodesuffix>}\\t%3\"\n-  [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*udivmodsi4_noext_zext_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-\t(zero_extend:DI\n-\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n-   (set (match_operand:SI 1 \"register_operand\" \"=d\")\n-\t(umod:SI (match_dup 2) (match_dup 3)))\n-   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"div{l}\\t%3\"\n-  [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*udivmodsi4_noext_zext_2\"\n-  [(set (match_operand:DI 1 \"register_operand\" \"=d\")\n-\t(zero_extend:DI\n-\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(udiv:SI (match_dup 2) (match_dup 3)))\n-   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"div{l}\\t%3\"\n-  [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"SI\")])\n-\n (define_expand \"udivmodqi4\"\n   [(parallel [(set (match_operand:QI 0 \"register_operand\")\n \t\t   (udiv:QI\n@@ -8176,7 +8054,7 @@\n {\n   rtx div, mod;\n   rtx tmp0, tmp1;\n-  \n+\n   tmp0 = gen_reg_rtx (HImode);\n   tmp1 = gen_reg_rtx (HImode);\n \n@@ -8201,22 +8079,28 @@\n   DONE;\n })\n \n-(define_insn \"udivmodhiqi3\"\n+;; Divide AX by r/m8, with result stored in\n+;; AL <- Quotient\n+;; AH <- Remainder\n+;; Change div/mod to HImode and extend the second argument to HImode\n+;; so that mode of div/mod matches with mode of arguments.  Otherwise\n+;; combine may fail.\n+(define_insn \"<u>divmodhiqi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(ior:HI\n \t  (ashift:HI\n \t    (zero_extend:HI\n \t      (truncate:QI\n \t\t(mod:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t\t(zero_extend:HI\n+\t\t\t(any_extend:HI\n \t\t\t  (match_operand:QI 2 \"nonimmediate_operand\" \"qm\")))))\n \t    (const_int 8))\n \t  (zero_extend:HI\n \t    (truncate:QI\n-\t      (div:HI (match_dup 1) (zero_extend:HI (match_dup 2)))))))\n+\t      (div:HI (match_dup 1) (any_extend:HI (match_dup 2)))))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_QIMODE_MATH\"\n-  \"div{b}\\t%2\"\n+  \"<sgnprefix>div{b}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"QI\")])\n "}]}