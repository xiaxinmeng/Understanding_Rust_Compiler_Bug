{"sha": "bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY4NGY0MmQ2MTk5ZTgzYjkxZjM5NjNmZDRkMTBkYTI3YzVlYWFmMA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2011-10-26T21:14:56Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-10-26T21:14:56Z"}, "message": "Canonicalize sparc movcc patterns such that operand 0 always appears in operand 4.\n\n\t* config/sparc/sparc-protos.h (sparc_expand_conditional_move): Declare.\n\t* config/sparc/sparc.md (mov<I:mode>cc, mov<F:mode>cc): Call it.\n\t(*mov<I:mode>_cc_v9): Normalize to expect operand 0 always in operand 4.\n\t(*mov<I:mode>_cc_reg_sp64): Likewise.\n\t(*movsf_cc_v9): Likewise.\n\t(*movsf_cc_reg_sp64): Likewise.\n\t(*movdf_cc_v9): Likewise.\n\t(*movdf_cc_reg_sp64): Likewise.\n\t(*movtf_cc_hq_v9): Likewise.\n\t(*movtf_cc_reg_hq_sp64): Likewise.\n\t(*movtf_cc_v9): Likewise.\n\t(*movtf_cc_reg_sp64): Likewise.\n\t* config/sparc/sparc.c (sparc_expand_conditional_move): New function.\n\t(sparc_print_operand): Delete 'c' and 'd' handling, no longer used.\n\nFrom-SVN: r180542", "tree": {"sha": "f897ba589ccba4119111c7885a9f89be5d708897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f897ba589ccba4119111c7885a9f89be5d708897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1586f8a371bc576969febc98a0ac96db2b013517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1586f8a371bc576969febc98a0ac96db2b013517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1586f8a371bc576969febc98a0ac96db2b013517"}], "stats": {"total": 295, "additions": 144, "deletions": 151}, "files": [{"sha": "d6d1382028b01be40d1be9a50e1eb27a6b655904", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "patch": "@@ -1,3 +1,20 @@\n+2011-10-26  David S. Miller  <davem@davemloft.net>\n+\n+\t* config/sparc/sparc-protos.h (sparc_expand_conditional_move): Declare.\n+\t* config/sparc/sparc.md (mov<I:mode>cc, mov<F:mode>cc): Call it.\n+\t(*mov<I:mode>_cc_v9): Normalize to expect operand 0 always in operand 4.\n+\t(*mov<I:mode>_cc_reg_sp64): Likewise.\n+\t(*movsf_cc_v9): Likewise.\n+\t(*movsf_cc_reg_sp64): Likewise.\n+\t(*movdf_cc_v9): Likewise.\n+\t(*movdf_cc_reg_sp64): Likewise.\n+\t(*movtf_cc_hq_v9): Likewise.\n+\t(*movtf_cc_reg_hq_sp64): Likewise.\n+\t(*movtf_cc_v9): Likewise.\n+\t(*movtf_cc_reg_sp64): Likewise.\n+\t* config/sparc/sparc.c (sparc_expand_conditional_move): New function.\n+\t(sparc_print_operand): Delete 'c' and 'd' handling, no longer used.\n+\n 2011-10-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* reload.c (reload_inner_reg_of_subreg): Change type of return value"}, {"sha": "108e105cbeacbc3019e426f788e38d4e75f86530", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "patch": "@@ -107,6 +107,7 @@ extern void sparc_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n extern const char *output_v8plus_mult (rtx, rtx *, const char *);\n extern void sparc_expand_vector_init (rtx, rtx);\n extern void sparc_expand_vec_perm_bmask(enum machine_mode, rtx);\n+extern bool sparc_expand_conditional_move (enum machine_mode, rtx *);\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "964bcaf15d6b75f4516e29cbaa33c9daf8e99c32", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "patch": "@@ -8162,20 +8162,11 @@ sparc_print_operand (FILE *file, rtx x, int code)\n \t}\n       return;\n \n-      /* These are used by the conditional move instructions.  */\n-    case 'c' :\n+      /* This is used by the conditional move instructions.  */\n     case 'C':\n       {\n \tenum rtx_code rc = GET_CODE (x);\n \t\n-\tif (code == 'c')\n-\t  {\n-\t    enum machine_mode mode = GET_MODE (XEXP (x, 0));\n-\t    if (mode == CCFPmode || mode == CCFPEmode)\n-\t      rc = reverse_condition_maybe_unordered (GET_CODE (x));\n-\t    else\n-\t      rc = reverse_condition (GET_CODE (x));\n-\t  }\n \tswitch (rc)\n \t  {\n \t  case NE: fputs (\"ne\", file); break;\n@@ -8196,20 +8187,15 @@ sparc_print_operand (FILE *file, rtx x, int code)\n \t  case UNGT: fputs (\"ug\", file); break;\n \t  case UNGE: fputs (\"uge\", file); break;\n \t  case UNEQ: fputs (\"ue\", file); break;\n-\t  default: output_operand_lossage (code == 'c'\n-\t\t\t\t\t   ? \"invalid %%c operand\"\n-\t\t\t\t\t   : \"invalid %%C operand\");\n+\t  default: output_operand_lossage (\"invalid %%C operand\");\n \t  }\n \treturn;\n       }\n \n-      /* These are used by the movr instruction pattern.  */\n-    case 'd':\n+      /* This are used by the movr instruction pattern.  */\n     case 'D':\n       {\n-\tenum rtx_code rc = (code == 'd'\n-\t\t\t    ? reverse_condition (GET_CODE (x))\n-\t\t\t    : GET_CODE (x));\n+\tenum rtx_code rc = GET_CODE (x);\n \tswitch (rc)\n \t  {\n \t  case NE: fputs (\"ne\", file); break;\n@@ -8218,9 +8204,7 @@ sparc_print_operand (FILE *file, rtx x, int code)\n \t  case LT: fputs (\"lz\", file); break;\n \t  case LE: fputs (\"lez\", file); break;\n \t  case GT: fputs (\"gz\", file); break;\n-\t  default: output_operand_lossage (code == 'd'\n-\t\t\t\t\t   ? \"invalid %%d operand\"\n-\t\t\t\t\t   : \"invalid %%D operand\");\n+\t  default: output_operand_lossage (\"invalid %%D operand\");\n \t  }\n \treturn;\n       }\n@@ -11377,4 +11361,58 @@ sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+bool\n+sparc_expand_conditional_move (enum machine_mode mode, rtx *operands)\n+{\n+  enum rtx_code rc = GET_CODE (operands[1]);\n+  enum machine_mode cmp_mode;\n+  rtx cc_reg, dst, cmp;\n+\n+  cmp = operands[1];\n+  cmp_mode = GET_MODE (XEXP (cmp, 0));\n+  if (cmp_mode == DImode && !TARGET_ARCH64)\n+    return false;\n+\n+  dst = operands[0];\n+\n+  if (! rtx_equal_p (operands[2], dst)\n+      && ! rtx_equal_p (operands[3], dst))\n+    {\n+      if (reg_overlap_mentioned_p (dst, cmp))\n+\tdst = gen_reg_rtx (mode);\n+\n+      emit_move_insn (dst, operands[3]);\n+    }\n+  else if (operands[2] == dst)\n+    {\n+      operands[2] = operands[3];\n+\n+      if (GET_MODE_CLASS (cmp_mode) == MODE_FLOAT)\n+        rc = reverse_condition_maybe_unordered (rc);\n+      else\n+        rc = reverse_condition (rc);\n+    }\n+\n+  if (cmp_mode == TFmode && !TARGET_HARD_QUAD)\n+    cmp = sparc_emit_float_lib_cmp (XEXP (cmp, 0), XEXP (cmp, 1), rc);\n+\n+  if (XEXP (cmp, 1) == const0_rtx\n+      && GET_CODE (XEXP (cmp, 0)) == REG\n+      && cmp_mode == DImode\n+      && v9_regcmp_p (rc))\n+    cc_reg = XEXP (cmp, 0);\n+  else\n+    cc_reg = gen_compare_reg_1 (rc, XEXP (cmp, 0), XEXP (cmp, 1));\n+\n+  cmp = gen_rtx_fmt_ee (rc, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, dst,\n+\t\t\t  gen_rtx_IF_THEN_ELSE (mode, cmp, operands[2], dst)));\n+\n+  if (dst != operands[0])\n+    emit_move_insn (operands[0], dst);\n+\n+  return true;\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "2bae28e6e1979fb8169da5b55cbb22ce108cd54b", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 67, "deletions": 130, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf84f42d6199e83b91f3963fd4d10da27c5eaaf0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=bf84f42d6199e83b91f3963fd4d10da27c5eaaf0", "patch": "@@ -2456,6 +2456,9 @@\n ;; Note that emit_conditional_move canonicalizes operands 2,3 so that operand\n ;; 3 contains the constant if one is present, but we handle either for\n ;; generality (sparc.c puts a constant in operand 2).\n+;;\n+;; Our instruction patterns, on the other hand, canonicalize such that\n+;; operand 3 must be the set destination.\n \n (define_expand \"mov<I:mode>cc\"\n   [(set (match_operand:I 0 \"register_operand\" \"\")\n@@ -2464,27 +2467,9 @@\n \t\t\t(match_operand:I 3 \"arith10_operand\" \"\")))]\n   \"TARGET_V9 && !(<I:MODE>mode == DImode && TARGET_ARCH32)\"\n {\n-  rtx cc_reg;\n-\n-  if (GET_MODE (XEXP (operands[1], 0)) == DImode && !TARGET_ARCH64)\n+  if (! sparc_expand_conditional_move (<I:MODE>mode, operands))\n     FAIL;\n-\n-  if (GET_MODE (XEXP (operands[1], 0)) == TFmode && !TARGET_HARD_QUAD)\n-    operands[1]\n-      = sparc_emit_float_lib_cmp (XEXP (operands[1], 0), XEXP (operands[1], 1),\n-\t\t\t\t  GET_CODE (operands[1]));\n-\n-  if (XEXP (operands[1], 1) == const0_rtx\n-      && GET_CODE (XEXP (operands[1], 0)) == REG\n-      && GET_MODE (XEXP (operands[1], 0)) == DImode\n-      && v9_regcmp_p (GET_CODE (operands[1])))\n-    cc_reg = XEXP (operands[1], 0);\n-  else\n-    cc_reg = gen_compare_reg (operands[1]);\n-\n-  operands[1]\n-    = gen_rtx_fmt_ee (GET_CODE (operands[1]), GET_MODE (cc_reg), cc_reg,\n-\t\t      const0_rtx);\n+  DONE;\n })\n \n (define_expand \"mov<F:mode>cc\"\n@@ -2494,220 +2479,172 @@\n \t\t\t(match_operand:F 3 \"register_operand\" \"\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n {\n-  rtx cc_reg;\n-\n-  if (GET_MODE (XEXP (operands[1], 0)) == DImode && !TARGET_ARCH64)\n+  if (! sparc_expand_conditional_move (<F:MODE>mode, operands))\n     FAIL;\n-\n-  if (GET_MODE (XEXP (operands[1], 0)) == TFmode && !TARGET_HARD_QUAD)\n-    operands[1]\n-      = sparc_emit_float_lib_cmp (XEXP (operands[1], 0), XEXP (operands[1], 1),\n-\t\t\t\t  GET_CODE (operands[1]));\n-\n-  if (XEXP (operands[1], 1) == const0_rtx\n-      && GET_CODE (XEXP (operands[1], 0)) == REG\n-      && GET_MODE (XEXP (operands[1], 0)) == DImode\n-      && v9_regcmp_p (GET_CODE (operands[1])))\n-    cc_reg = XEXP (operands[1], 0);\n-  else\n-    cc_reg = gen_compare_reg (operands[1]);\n-\n-  operands[1]\n-    = gen_rtx_fmt_ee (GET_CODE (operands[1]), GET_MODE (cc_reg), cc_reg,\n-\t\t      const0_rtx);\n+  DONE;\n })\n \n ;; Conditional move define_insns\n \n (define_insn \"*mov<I:mode>_cc_v9\"\n-  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n \t(if_then_else:I (match_operator 1 \"comparison_operator\"\n-\t\t\t       [(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n+\t\t\t       [(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t(const_int 0)])\n-\t\t\t(match_operand:I 3 \"arith11_operand\" \"rL,0\")\n-\t\t\t(match_operand:I 4 \"arith11_operand\" \"0,rL\")))]\n+\t\t\t(match_operand:I 3 \"arith11_operand\" \"rL\")\n+\t\t\t(match_operand:I 4 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && !(<I:MODE>mode == DImode && TARGET_ARCH32)\"\n-  \"@\n-   mov%C1\\t%x2, %3, %0\n-   mov%c1\\t%x2, %4, %0\"\n+  \"mov%C1\\t%x2, %3, %0\"\n   [(set_attr \"type\" \"cmove\")])\n \n (define_insn \"*mov<I:mode>_cc_reg_sp64\"\n-  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n \t(if_then_else:I (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n-\t\t\t(match_operand:I 3 \"arith10_operand\" \"rM,0\")\n-\t\t\t(match_operand:I 4 \"arith10_operand\" \"0,rM\")))]\n+\t\t\t(match_operand:I 3 \"arith10_operand\" \"rM\")\n+\t\t\t(match_operand:I 4 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64\"\n-  \"@\n-   movr%D1\\t%2, %r3, %0\n-   movr%d1\\t%2, %r4, %0\"\n+  \"movr%D1\\t%2, %r3, %0\"\n   [(set_attr \"type\" \"cmove\")])\n \n (define_insn \"*movsf_cc_v9\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(if_then_else:SF (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t (const_int 0)])\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"f,0\")\n-\t\t\t (match_operand:SF 4 \"register_operand\" \"0,f\")))]\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"f\")\n+\t\t\t (match_operand:SF 4 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n-  \"@\n-   fmovs%C1\\t%x2, %3, %0\n-   fmovs%c1\\t%x2, %4, %0\"\n+  \"fmovs%C1\\t%x2, %3, %0\"\n   [(set_attr \"type\" \"fpcmove\")])\n \n (define_insn \"*movsf_cc_reg_sp64\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(if_then_else:SF (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"f,0\")\n-\t\t\t (match_operand:SF 4 \"register_operand\" \"0,f\")))]\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"f\")\n+\t\t\t (match_operand:SF 4 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"@\n-   fmovrs%D1\\t%2, %3, %0\n-   fmovrs%d1\\t%2, %4, %0\"\n+  \"fmovrs%D1\\t%2, %3, %0\"\n   [(set_attr \"type\" \"fpcrmove\")])\n \n ;; Named because invoked by movtf_cc_v9\n (define_insn \"movdf_cc_v9\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(if_then_else:DF (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t (const_int 0)])\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"e,0\")\n-\t\t\t (match_operand:DF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"e\")\n+\t\t\t (match_operand:DF 4 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n-  \"@\n-   fmovd%C1\\t%x2, %3, %0\n-   fmovd%c1\\t%x2, %4, %0\"\n+  \"fmovd%C1\\t%x2, %3, %0\"\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"fptype\" \"double\")])\n \n ;; Named because invoked by movtf_cc_reg_sp64\n (define_insn \"movdf_cc_reg_sp64\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(if_then_else:DF (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"e,0\")\n-\t\t\t (match_operand:DF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"e\")\n+\t\t\t (match_operand:DF 4 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"@\n-   fmovrd%D1\\t%2, %3, %0\n-   fmovrd%d1\\t%2, %4, %0\"\n+  \"fmovrd%D1\\t%2, %3, %0\"\n   [(set_attr \"type\" \"fpcrmove\")\n    (set_attr \"fptype\" \"double\")])\n \n (define_insn \"*movtf_cc_hq_v9\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t (const_int 0)])\n-\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n-\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"@\n-   fmovq%C1\\t%x2, %3, %0\n-   fmovq%c1\\t%x2, %4, %0\"\n+  \"fmovq%C1\\t%x2, %3, %0\"\n   [(set_attr \"type\" \"fpcmove\")])\n \n (define_insn \"*movtf_cc_reg_hq_sp64\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n-\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n-\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"@\n-   fmovrq%D1\\t%2, %3, %0\n-   fmovrq%d1\\t%2, %4, %0\"\n+  \"fmovrq%D1\\t%2, %3, %0\"\n   [(set_attr \"type\" \"fpcrmove\")])\n \n (define_insn_and_split \"*movtf_cc_v9\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n-\t\t\t    [(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n+\t\t\t    [(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t     (const_int 0)])\n-\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n-\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0\")))]\n   \"TARGET_V9 && TARGET_FPU && !TARGET_HARD_QUAD\"\n   \"#\"\n   \"&& reload_completed\"\n   [(clobber (const_int 0))]\n {\n   rtx set_dest = operands[0];\n   rtx set_srca = operands[3];\n-  rtx set_srcb = operands[4];\n-  int third = rtx_equal_p (set_dest, set_srca);\n   rtx dest1, dest2;\n-  rtx srca1, srca2, srcb1, srcb2;\n+  rtx srca1, srca2;\n \n   dest1 = gen_df_reg (set_dest, 0);\n   dest2 = gen_df_reg (set_dest, 1);\n   srca1 = gen_df_reg (set_srca, 0);\n   srca2 = gen_df_reg (set_srca, 1);\n-  srcb1 = gen_df_reg (set_srcb, 0);\n-  srcb2 = gen_df_reg (set_srcb, 1);\n \n-  /* Now emit using the real source and destination we found, swapping\n-     the order if we detect overlap.  */\n-  if ((third && reg_overlap_mentioned_p (dest1, srcb2))\n-      || (!third && reg_overlap_mentioned_p (dest1, srca2)))\n+  if (reg_overlap_mentioned_p (dest1, srca2))\n     {\n-      emit_insn (gen_movdf_cc_v9 (dest2, operands[1], operands[2], srca2, srcb2));\n-      emit_insn (gen_movdf_cc_v9 (dest1, operands[1], operands[2], srca1, srcb1));\n+      emit_insn (gen_movdf_cc_v9 (dest2, operands[1], operands[2], srca2, dest2));\n+      emit_insn (gen_movdf_cc_v9 (dest1, operands[1], operands[2], srca1, dest1));\n     }\n   else\n     {\n-      emit_insn (gen_movdf_cc_v9 (dest1, operands[1], operands[2], srca1, srcb1));\n-      emit_insn (gen_movdf_cc_v9 (dest2, operands[1], operands[2], srca2, srcb2));\n+      emit_insn (gen_movdf_cc_v9 (dest1, operands[1], operands[2], srca1, dest1));\n+      emit_insn (gen_movdf_cc_v9 (dest2, operands[1], operands[2], srca2, dest2));\n     }\n   DONE;\n }\n   [(set_attr \"length\" \"2\")])\n \n (define_insn_and_split \"*movtf_cc_reg_sp64\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n-\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n-\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0\")))]\n   \"TARGET_ARCH64 && TARGET_FPU && ! TARGET_HARD_QUAD\"\n   \"#\"\n   \"&& reload_completed\"\n   [(clobber (const_int 0))]\n {\n   rtx set_dest = operands[0];\n   rtx set_srca = operands[3];\n-  rtx set_srcb = operands[4];\n-  int third = rtx_equal_p (set_dest, set_srca);\n   rtx dest1, dest2;\n-  rtx srca1, srca2, srcb1, srcb2;\n+  rtx srca1, srca2;\n \n   dest1 = gen_df_reg (set_dest, 0);\n   dest2 = gen_df_reg (set_dest, 1);\n   srca1 = gen_df_reg (set_srca, 0);\n   srca2 = gen_df_reg (set_srca, 1);\n-  srcb1 = gen_df_reg (set_srcb, 0);\n-  srcb2 = gen_df_reg (set_srcb, 1);\n \n-  /* Now emit using the real source and destination we found, swapping\n-     the order if we detect overlap.  */\n-  if ((third && reg_overlap_mentioned_p (dest1, srcb2))\n-      || (!third && reg_overlap_mentioned_p (dest1, srca2)))\n+  if (reg_overlap_mentioned_p (dest1, srca2))\n     {\n-      emit_insn (gen_movdf_cc_reg_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n-      emit_insn (gen_movdf_cc_reg_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest2, operands[1], operands[2], srca2, dest2));\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest1, operands[1], operands[2], srca1, dest1));\n     }\n   else\n     {\n-      emit_insn (gen_movdf_cc_reg_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n-      emit_insn (gen_movdf_cc_reg_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest1, operands[1], operands[2], srca1, dest1));\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest2, operands[1], operands[2], srca2, dest2));\n     }\n   DONE;\n }"}]}