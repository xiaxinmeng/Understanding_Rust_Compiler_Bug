{"sha": "148909bc700e4f52aa582346a29abc5bc51a9bda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ4OTA5YmM3MDBlNGY1MmFhNTgyMzQ2YTI5YWJjNWJjNTFhOWJkYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T18:01:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T18:01:47Z"}, "message": "Add \"fast\" conversions from arrays to bitmaps\n\nThis patch adds a bitmap_view<X> class that creates a read-only,\non-stack bitmap representation of an array-like object X.  The main\nuse case is to allow HARD_REG_SETs to be used in REG_SET (i.e. bitmap)\noperations.\n\nFor now it only handles constant-sized arrays, but I've tried to\ndefine the types in a way that could handle variable-sized arrays\nin future (although less efficiently).  E.g. this might be useful\nfor combining bitmaps and sbitmaps.\n\nFor the read-only view to work as intended, I needed to make\nbitmap_bit_p take a const_bitmap instead of a bitmap.  Logically\nthe bitmap really is read-only, but we update the \"current\" and\n\"indx\" fields of the bitmap_head after doing a search.\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* array-traits.h: New file.\n\t* coretypes.h (array_traits, bitmap_view): New types.\n\t* bitmap.h: Include \"array-traits.h\"\n\t(bitmap_bit_p): Take a const_bitmap instead of a bitmap.\n\t(base_bitmap_view, bitmap_view): New classes.\n\t* bitmap.c (bitmap_bit_p): Take a const_bitmap instead of a bitmap.\n\t* hard-reg-set.h: Include array-traits.h.\n\t(array_traits<HARD_REG_SET>): New struct.\n\t* regset.h (IOR_REG_SET_HRS): New macro.\n\t* loop-iv.c (simplify_using_initial_values): Use IOR_REG_SET_HRS\n\trather than iterating over each hard register.\n\t* sched-deps.c (sched_analyze_insn): Likewise.\n\t* sel-sched-ir.c (setup_id_implicit_regs): Likewise.\n\nFrom-SVN: r275536", "tree": {"sha": "7b27abf27f2bb98254bf0f77a70414b4673a5fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b27abf27f2bb98254bf0f77a70414b4673a5fed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/148909bc700e4f52aa582346a29abc5bc51a9bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148909bc700e4f52aa582346a29abc5bc51a9bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/148909bc700e4f52aa582346a29abc5bc51a9bda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148909bc700e4f52aa582346a29abc5bc51a9bda/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75f4e3a1b322e16a1aca28bd0ced9af57cb0a683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f4e3a1b322e16a1aca28bd0ced9af57cb0a683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75f4e3a1b322e16a1aca28bd0ced9af57cb0a683"}], "stats": {"total": 240, "additions": 219, "deletions": 21}, "files": [{"sha": "248c5a5ec4b447f702d185de57281d26baba57d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -1,3 +1,19 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* array-traits.h: New file.\n+\t* coretypes.h (array_traits, bitmap_view): New types.\n+\t* bitmap.h: Include \"array-traits.h\"\n+\t(bitmap_bit_p): Take a const_bitmap instead of a bitmap.\n+\t(base_bitmap_view, bitmap_view): New classes.\n+\t* bitmap.c (bitmap_bit_p): Take a const_bitmap instead of a bitmap.\n+\t* hard-reg-set.h: Include array-traits.h.\n+\t(array_traits<HARD_REG_SET>): New struct.\n+\t* regset.h (IOR_REG_SET_HRS): New macro.\n+\t* loop-iv.c (simplify_using_initial_values): Use IOR_REG_SET_HRS\n+\trather than iterating over each hard register.\n+\t* sched-deps.c (sched_analyze_insn): Likewise.\n+\t* sel-sched-ir.c (setup_id_implicit_regs): Likewise.\n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* ira-int.h (ior_hard_reg_conflicts): Take a const_hard_reg_set"}, {"sha": "eb65ede9458b3b61f53e5e1ac10fac8de4cb9a67", "filename": "gcc/array-traits.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Farray-traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Farray-traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Farray-traits.h?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -0,0 +1,48 @@\n+/* Descriptions of array-like objects.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ARRAY_TRAITS_H\n+#define GCC_ARRAY_TRAITS_H\n+\n+/* Implementation for single integers (and similar types).  */\n+template<typename T, T zero = T (0)>\n+struct scalar_array_traits\n+{\n+  typedef T element_type;\n+  static const bool has_constant_size = true;\n+  static const size_t constant_size = 1;\n+  static const T *base (const T &x) { return &x; }\n+  static size_t size (const T &) { return 1; }\n+};\n+\n+template<typename T>\n+struct array_traits : scalar_array_traits<T> {};\n+\n+/* Implementation for arrays with a static size.  */\n+template<typename T, size_t N>\n+struct array_traits<T[N]>\n+{\n+  typedef T element_type;\n+  static const bool has_constant_size = true;\n+  static const size_t constant_size = N;\n+  static const T *base (const T (&x)[N]) { return x; }\n+  static size_t size (const T (&x)[N]) { return N; }\n+};\n+\n+#endif"}, {"sha": "c6afa3f1835efcee6d627248b6c6bc5039393931", "filename": "gcc/bitmap.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -979,17 +979,17 @@ bitmap_set_bit (bitmap head, int bit)\n /* Return whether a bit is set within a bitmap.  */\n \n int\n-bitmap_bit_p (bitmap head, int bit)\n+bitmap_bit_p (const_bitmap head, int bit)\n {\n   unsigned int indx = bit / BITMAP_ELEMENT_ALL_BITS;\n-  bitmap_element *ptr;\n+  const bitmap_element *ptr;\n   unsigned bit_num;\n   unsigned word_num;\n \n   if (!head->tree_form)\n-    ptr = bitmap_list_find_element (head, indx);\n+    ptr = bitmap_list_find_element (const_cast<bitmap> (head), indx);\n   else\n-    ptr = bitmap_tree_find_element (head, indx);\n+    ptr = bitmap_tree_find_element (const_cast<bitmap> (head), indx);\n   if (ptr == 0)\n     return 0;\n "}, {"sha": "6502acbd2d76334800b7c5d8eb2797618417a2c4", "filename": "gcc/bitmap.h", "status": "modified", "additions": 121, "deletions": 1, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -210,6 +210,7 @@ along with GCC; see the file COPYING3.  If not see\n    on which many random-access membership tests will happen.  */\n \n #include \"obstack.h\"\n+#include \"array-traits.h\"\n \n /* Bitmap memory usage.  */\n class bitmap_usage: public mem_usage\n@@ -435,7 +436,7 @@ extern bool bitmap_clear_bit (bitmap, int);\n extern bool bitmap_set_bit (bitmap, int);\n \n /* Return true if a bit is set in a bitmap.  */\n-extern int bitmap_bit_p (bitmap, int);\n+extern int bitmap_bit_p (const_bitmap, int);\n \n /* Debug functions to print a bitmap.  */\n extern void debug_bitmap (const_bitmap);\n@@ -956,4 +957,123 @@ class auto_bitmap\n   bitmap_head m_bits;\n };\n \n+/* Base class for bitmap_view; see there for details.  */\n+template<typename T, typename Traits = array_traits<T> >\n+class base_bitmap_view\n+{\n+public:\n+  typedef typename Traits::element_type array_element_type;\n+\n+  base_bitmap_view (const T &, bitmap_element *);\n+  operator const_bitmap () const { return &m_head; }\n+\n+private:\n+  base_bitmap_view (const base_bitmap_view &);\n+\n+  bitmap_head m_head;\n+};\n+\n+/* Provides a read-only bitmap view of a single integer bitmask or a\n+   constant-sized array of integer bitmasks, or of a wrapper around such\n+   bitmasks.  */\n+template<typename T, typename Traits>\n+class bitmap_view<T, Traits, true> : public base_bitmap_view<T, Traits>\n+{\n+public:\n+  bitmap_view (const T &array)\n+    : base_bitmap_view<T, Traits> (array, m_bitmap_elements) {}\n+\n+private:\n+  /* How many bitmap_elements we need to hold a full T.  */\n+  static const size_t num_bitmap_elements\n+    = CEIL (CHAR_BIT\n+\t    * sizeof (typename Traits::element_type)\n+\t    * Traits::constant_size,\n+\t    BITMAP_ELEMENT_ALL_BITS);\n+  bitmap_element m_bitmap_elements[num_bitmap_elements];\n+};\n+\n+/* Initialize the view for array ARRAY, using the array of bitmap\n+   elements in BITMAP_ELEMENTS (which is known to contain enough\n+   entries).  */\n+template<typename T, typename Traits>\n+base_bitmap_view<T, Traits>::base_bitmap_view (const T &array,\n+\t\t\t\t\t       bitmap_element *bitmap_elements)\n+{\n+  m_head.obstack = NULL;\n+\n+  /* The code currently assumes that each element of ARRAY corresponds\n+     to exactly one bitmap_element.  */\n+  const size_t array_element_bits = CHAR_BIT * sizeof (array_element_type);\n+  STATIC_ASSERT (BITMAP_ELEMENT_ALL_BITS % array_element_bits == 0);\n+  size_t array_step = BITMAP_ELEMENT_ALL_BITS / array_element_bits;\n+  size_t array_size = Traits::size (array);\n+\n+  /* Process each potential bitmap_element in turn.  The loop is written\n+     this way rather than per array element because usually there are\n+     only a small number of array elements per bitmap element (typically\n+     two or four).  The inner loops should therefore unroll completely.  */\n+  const array_element_type *array_elements = Traits::base (array);\n+  unsigned int indx = 0;\n+  for (size_t array_base = 0;\n+       array_base < array_size;\n+       array_base += array_step, indx += 1)\n+    {\n+      /* How many array elements are in this particular bitmap_element.  */\n+      unsigned int array_count\n+\t= (STATIC_CONSTANT_P (array_size % array_step == 0)\n+\t   ? array_step : MIN (array_step, array_size - array_base));\n+\n+      /* See whether we need this bitmap element.  */\n+      array_element_type ior = array_elements[array_base];\n+      for (size_t i = 1; i < array_count; ++i)\n+\tior |= array_elements[array_base + i];\n+      if (ior == 0)\n+\tcontinue;\n+\n+      /* Grab the next bitmap element and chain it.  */\n+      bitmap_element *bitmap_element = bitmap_elements++;\n+      if (m_head.current)\n+\tm_head.current->next = bitmap_element;\n+      else\n+\tm_head.first = bitmap_element;\n+      bitmap_element->prev = m_head.current;\n+      bitmap_element->next = NULL;\n+      bitmap_element->indx = indx;\n+      m_head.current = bitmap_element;\n+      m_head.indx = indx;\n+\n+      /* Fill in the bits of the bitmap element.  */\n+      if (array_element_bits < BITMAP_WORD_BITS)\n+\t{\n+\t  /* Multiple array elements fit in one element of\n+\t     bitmap_element->bits.  */\n+\t  size_t array_i = array_base;\n+\t  for (unsigned int word_i = 0; word_i < BITMAP_ELEMENT_WORDS;\n+\t       ++word_i)\n+\t    {\n+\t      BITMAP_WORD word = 0;\n+\t      for (unsigned int shift = 0;\n+\t\t   shift < BITMAP_WORD_BITS && array_i < array_size;\n+\t\t   shift += array_element_bits)\n+\t\tword |= array_elements[array_i++] << shift;\n+\t      bitmap_element->bits[word_i] = word;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Array elements are the same size as elements of\n+\t     bitmap_element->bits, or are an exact multiple of that size.  */\n+\t  unsigned int word_i = 0;\n+\t  for (unsigned int i = 0; i < array_count; ++i)\n+\t    for (unsigned int shift = 0; shift < array_element_bits;\n+\t\t shift += BITMAP_WORD_BITS)\n+\t      bitmap_element->bits[word_i++]\n+\t\t= array_elements[array_base + i] >> shift;\n+\t  while (word_i < BITMAP_ELEMENT_WORDS)\n+\t    bitmap_element->bits[word_i++] = 0;\n+\t}\n+    }\n+}\n+\n #endif /* GCC_BITMAP_H */"}, {"sha": "fc0e09b20006aa59c90abd408553845494700dc0", "filename": "gcc/coretypes.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -153,6 +153,14 @@ struct cl_option_handlers;\n struct diagnostic_context;\n class pretty_printer;\n \n+template<typename T> struct array_traits;\n+\n+/* Provides a read-only bitmap view of a single integer bitmask or an\n+   array of integer bitmasks, or of a wrapper around such bitmasks.  */\n+template<typename T, typename Traits = array_traits<T>,\n+\t bool has_constant_size = Traits::has_constant_size>\n+class bitmap_view;\n+\n /* Address space number for named address space support.  */\n typedef unsigned char addr_space_t;\n "}, {"sha": "274956e1ec333159e213c874cdb1b3617102dda4", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_HARD_REG_SET_H\n #define GCC_HARD_REG_SET_H\n \n+#include \"array-traits.h\"\n+\n /* Define the type of a set of hard registers.  */\n \n /* HARD_REG_ELT_TYPE is a typedef of the unsigned integral type which\n@@ -115,6 +117,16 @@ struct HARD_REG_SET\n };\n typedef const HARD_REG_SET &const_hard_reg_set;\n \n+template<>\n+struct array_traits<HARD_REG_SET>\n+{\n+  typedef HARD_REG_ELT_TYPE element_type;\n+  static const bool has_constant_size = true;\n+  static const size_t constant_size = HARD_REG_SET_LONGS;\n+  static const element_type *base (const HARD_REG_SET &x) { return x.elts; }\n+  static size_t size (const HARD_REG_SET &) { return HARD_REG_SET_LONGS; }\n+};\n+\n #endif\n \n /* HARD_REG_SET wrapped into a structure, to make it possible to"}, {"sha": "33be75add72cbf2a61cfc2f705d7b9b09c157b4b", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -1972,14 +1972,8 @@ simplify_using_initial_values (class loop *loop, enum rtx_code op, rtx *expr)\n \t  CLEAR_REG_SET (this_altered);\n \t  note_stores (insn, mark_altered, this_altered);\n \t  if (CALL_P (insn))\n-\t    {\n-\t      /* Kill all call clobbered registers.  */\n-\t      unsigned int i;\n-\t      hard_reg_set_iterator hrsi;\n-\t      EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call,\n-\t\t\t\t\t      0, i, hrsi)\n-\t\tSET_REGNO_REG_SET (this_altered, i);\n-\t    }\n+\t    /* Kill all call clobbered registers.  */\n+\t    IOR_REG_SET_HRS (this_altered, regs_invalidated_by_call);\n \n \t  if (suitable_set_for_replacement (insn, &dest, &src))\n \t    {"}, {"sha": "f5e3d390b142ac41d6e50adde38836075f2bd878", "filename": "gcc/regset.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fregset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fregset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregset.h?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -64,6 +64,10 @@ typedef bitmap regset;\n /* Inclusive or a register set with a second register set.  */\n #define IOR_REG_SET(TO, FROM) bitmap_ior_into (TO, FROM)\n \n+/* Same, but with FROM being a HARD_REG_SET.  */\n+#define IOR_REG_SET_HRS(TO, FROM) \\\n+  bitmap_ior_into (TO, bitmap_view<HARD_REG_SET> (FROM))\n+\n /* Exclusive or a register set with a second register set.  */\n #define XOR_REG_SET(TO, FROM) bitmap_xor_into (TO, FROM)\n "}, {"sha": "52db3cc1523656f69230d7e13adfe0e35c088b44", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -3332,10 +3332,9 @@ sched_analyze_insn (class deps_desc *deps, rtx x, rtx_insn *insn)\n       IOR_REG_SET (&deps->reg_last_in_use, reg_pending_uses);\n       IOR_REG_SET (&deps->reg_last_in_use, reg_pending_clobbers);\n       IOR_REG_SET (&deps->reg_last_in_use, reg_pending_sets);\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (implicit_reg_pending_uses, i)\n-\t    || TEST_HARD_REG_BIT (implicit_reg_pending_clobbers, i))\n-\t  SET_REGNO_REG_SET (&deps->reg_last_in_use, i);\n+      IOR_REG_SET_HRS (&deps->reg_last_in_use,\n+\t\t       implicit_reg_pending_uses\n+\t\t       | implicit_reg_pending_clobbers);\n \n       /* Set up the pending barrier found.  */\n       deps->last_reg_pending_barrier = reg_pending_barrier;"}, {"sha": "e4f5a454fdb5f57c1b0dc67b72634f1e47c382be", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148909bc700e4f52aa582346a29abc5bc51a9bda/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=148909bc700e4f52aa582346a29abc5bc51a9bda", "patch": "@@ -2661,12 +2661,9 @@ setup_id_implicit_regs (idata_t id, insn_t insn)\n     return;\n \n   HARD_REG_SET temp;\n-  unsigned regno;\n-  hard_reg_set_iterator hrsi;\n \n   get_implicit_reg_pending_clobbers (&temp, insn);\n-  EXECUTE_IF_SET_IN_HARD_REG_SET (temp, 0, regno, hrsi)\n-    SET_REGNO_REG_SET (IDATA_REG_SETS (id), regno);\n+  IOR_REG_SET_HRS (IDATA_REG_SETS (id), temp);\n }\n \n /* Setup register sets describing INSN in ID.  */"}]}