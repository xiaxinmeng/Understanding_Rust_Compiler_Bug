{"sha": "ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "node_id": "C_kwDOANBUbNoAKGVjMDlhNTMzNWYwYWRlNzA3MWY2MTU3ZGZkOTdkYmIzZGUzZTRmOTc", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-31T21:12:53Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-02-01T21:56:16Z"}, "message": "libstdc++: Reset filesystem::recursive_directory_iterator on error\n\nThe standard requires directory iterators to become equal to the end\niterator value if they report an error. Some members functions of\nfilesystem::recursive_directory_iterator fail to do that.\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/fs_dir.cc (recursive_directory_iterator::increment):\n\tReset state to past-the-end iterator on error.\n\t(fs::recursive_directory_iterator::pop(error_code&)): Likewise.\n\t(fs::recursive_directory_iterator::pop()): Check _M_dirs before\n\tit might get reset.\n\t* src/filesystem/dir.cc (recursive_directory_iterator): Likewise,\n\tfor the TS implementation.\n\t* testsuite/27_io/filesystem/iterators/error_reporting.cc: New test.\n\t* testsuite/experimental/filesystem/iterators/error_reporting.cc: New test.", "tree": {"sha": "cca20f16242dda1452a0a0d179a859b097ecc767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cca20f16242dda1452a0a0d179a859b097ecc767"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90263a48303a5ae552ea04c68ed7fa5da49b1876", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90263a48303a5ae552ea04c68ed7fa5da49b1876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90263a48303a5ae552ea04c68ed7fa5da49b1876"}], "stats": {"total": 295, "additions": 291, "deletions": 4}, "files": [{"sha": "149a8b0740cf82d8092c2cd25f9a6d93a9dbc65b", "filename": "libstdc++-v3/src/c++17/fs_dir.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc?ref=ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "patch": "@@ -311,6 +311,10 @@ fs::recursive_directory_iterator::increment(error_code& ec)\n \t  return *this;\n \t}\n     }\n+\n+  if (ec)\n+    _M_dirs.reset();\n+\n   return *this;\n }\n \n@@ -334,16 +338,20 @@ fs::recursive_directory_iterator::pop(error_code& ec)\n \tec.clear();\n \treturn;\n       }\n-  } while (!_M_dirs->top().advance(skip_permission_denied, ec));\n+  } while (!_M_dirs->top().advance(skip_permission_denied, ec) && !ec);\n+\n+  if (ec)\n+    _M_dirs.reset();\n }\n \n void\n fs::recursive_directory_iterator::pop()\n {\n+  const bool dereferenceable = _M_dirs != nullptr;\n   error_code ec;\n   pop(ec);\n   if (ec)\n-    _GLIBCXX_THROW_OR_ABORT(filesystem_error(_M_dirs\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(dereferenceable\n \t  ? \"recursive directory iterator cannot pop\"\n \t  : \"non-dereferenceable recursive directory iterator cannot pop\",\n \t  ec));"}, {"sha": "ac9e70da5168f620a95be71090c30601e6841553", "filename": "libstdc++-v3/src/filesystem/dir.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc?ref=ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "patch": "@@ -298,6 +298,10 @@ fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n \t  return *this;\n \t}\n     }\n+\n+  if (ec)\n+    _M_dirs.reset();\n+\n   return *this;\n }\n \n@@ -321,16 +325,20 @@ fs::recursive_directory_iterator::pop(error_code& ec)\n \tec.clear();\n \treturn;\n       }\n-  } while (!_M_dirs->top().advance(skip_permission_denied, ec));\n+  } while (!_M_dirs->top().advance(skip_permission_denied, ec) && !ec);\n+\n+  if (ec)\n+    _M_dirs.reset();\n }\n \n void\n fs::recursive_directory_iterator::pop()\n {\n+  const bool dereferenceable = _M_dirs != nullptr;\n   error_code ec;\n   pop(ec);\n   if (ec)\n-    _GLIBCXX_THROW_OR_ABORT(filesystem_error(_M_dirs\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(dereferenceable\n \t  ? \"recursive directory iterator cannot pop\"\n \t  : \"non-dereferenceable recursive directory iterator cannot pop\",\n \t  ec));"}, {"sha": "81ef10693675bda2751b019eeee1837316ba5c6f", "filename": "libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Ferror_reporting.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Ferror_reporting.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fiterators%2Ferror_reporting.cc?ref=ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "patch": "@@ -0,0 +1,135 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target { c++17 } } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <filesystem>\n+#include <cerrno>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <dirent.h>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+int choice;\n+\n+struct dirent global_dirent;\n+\n+extern \"C\" struct dirent* readdir(DIR*)\n+{\n+  switch (choice)\n+  {\n+  case 1:\n+    global_dirent.d_ino = 999;\n+    global_dirent.d_type = DT_REG;\n+    global_dirent.d_reclen = 0;\n+    std::char_traits<char>::copy(global_dirent.d_name, \"file\", 5);\n+    choice = 0;\n+    return &global_dirent;\n+  case 2:\n+    global_dirent.d_ino = 111;\n+    global_dirent.d_type = DT_DIR;\n+    global_dirent.d_reclen = 60;\n+    std::char_traits<char>::copy(global_dirent.d_name, \"subdir\", 7);\n+    choice = 1;\n+    return &global_dirent;\n+  default:\n+    errno = EIO;\n+    return nullptr;\n+  }\n+  return &global_dirent;\n+}\n+\n+void\n+test01()\n+{\n+  namespace fs = std::filesystem;\n+  std::error_code ec;\n+  choice = 1;\n+  fs::recursive_directory_iterator it(\".\", ec);\n+  if (choice == 0) // custom readdir was called\n+  {\n+    it.increment(ec);\n+    VERIFY( ec.value() == EIO );\n+    VERIFY( it == end(it) );\n+  }\n+  else\n+  {\n+    puts(\"Custom readdir not used, cannot test error handling\");\n+    exit(0);\n+  }\n+\n+#if __cpp_exceptions\n+  choice = 1;\n+  fs::recursive_directory_iterator it2(\".\", ec);\n+  if (choice == 0)\n+  {\n+    try {\n+      ++it2;\n+      VERIFY( false );\n+    } catch (const fs::filesystem_error& e) {\n+      VERIFY( e.code().value() == EIO );\n+      VERIFY( it2 == end(it2) );\n+    }\n+  }\n+#endif\n+}\n+\n+void\n+test02()\n+{\n+  namespace fs = std::filesystem;\n+  auto dir = __gnu_test::nonexistent_path();\n+  fs::create_directories(dir/\"subdir\");\n+\n+  std::error_code ec;\n+  choice = 2;\n+  fs::recursive_directory_iterator it(dir, ec);\n+  if (choice == 1)\n+  {\n+    ++it;\n+    it.pop(ec);\n+    VERIFY( ec.value() == EIO );\n+    VERIFY( it == end(it) );\n+  }\n+\n+#if __cpp_exceptions\n+  choice = 2;\n+  fs::recursive_directory_iterator it2(dir, ec);\n+  if (choice == 1)\n+  {\n+    ++it2;\n+    try {\n+      it2.pop();\n+      VERIFY( false );\n+    } catch (const fs::filesystem_error& e) {\n+      VERIFY( e.code().value() == EIO );\n+      VERIFY( it2 == end(it2) );\n+    }\n+  }\n+#endif\n+\n+  fs::remove_all(dir, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "ade62732028d32ea3e40e39a56f181548e148186", "filename": "libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Ferror_reporting.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec09a5335f0ade7071f6157dfd97dbb3de3e4f97/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Ferror_reporting.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Ferror_reporting.cc?ref=ec09a5335f0ade7071f6157dfd97dbb3de3e4f97", "patch": "@@ -0,0 +1,136 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-DUSE_FILESYSTEM_TS -lstdc++fs\" }\n+// { dg-do run { target { c++11 } } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <cerrno>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <dirent.h>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+int choice;\n+\n+struct dirent global_dirent;\n+\n+extern \"C\" struct dirent* readdir(DIR*)\n+{\n+  switch (choice)\n+  {\n+  case 1:\n+    global_dirent.d_ino = 999;\n+    global_dirent.d_type = DT_REG;\n+    global_dirent.d_reclen = 0;\n+    std::char_traits<char>::copy(global_dirent.d_name, \"file\", 5);\n+    choice = 0;\n+    return &global_dirent;\n+  case 2:\n+    global_dirent.d_ino = 111;\n+    global_dirent.d_type = DT_DIR;\n+    global_dirent.d_reclen = 60;\n+    std::char_traits<char>::copy(global_dirent.d_name, \"subdir\", 7);\n+    choice = 1;\n+    return &global_dirent;\n+  default:\n+    errno = EIO;\n+    return nullptr;\n+  }\n+  return &global_dirent;\n+}\n+\n+void\n+test01()\n+{\n+  namespace fs = std::experimental::filesystem;\n+  std::error_code ec;\n+  choice = 1;\n+  fs::recursive_directory_iterator it(\".\", ec);\n+  if (choice == 0) // custom readdir was called\n+  {\n+    it.increment(ec);\n+    VERIFY( ec.value() == EIO );\n+    VERIFY( it == end(it) );\n+  }\n+  else\n+  {\n+    puts(\"Custom readdir not used, cannot test error handling\");\n+    exit(0);\n+  }\n+\n+#if __cpp_exceptions\n+  choice = 1;\n+  fs::recursive_directory_iterator it2(\".\", ec);\n+  if (choice == 0) // custom readdir was called\n+  {\n+    try {\n+      ++it2;\n+      VERIFY( false );\n+    } catch (const fs::filesystem_error& e) {\n+      VERIFY( e.code().value() == EIO );\n+      VERIFY( it2 == end(it2) );\n+    }\n+  }\n+#endif\n+}\n+\n+void\n+test02()\n+{\n+  namespace fs = std::experimental::filesystem;\n+  auto dir = __gnu_test::nonexistent_path();\n+  fs::create_directories(dir/\"subdir\");\n+\n+  std::error_code ec;\n+  choice = 2;\n+  fs::recursive_directory_iterator it(dir, ec);\n+  if (choice == 1)\n+  {\n+    ++it;\n+    it.pop(ec);\n+    VERIFY( ec.value() == EIO );\n+    VERIFY( it == end(it) );\n+  }\n+\n+#if __cpp_exceptions\n+  choice = 2;\n+  fs::recursive_directory_iterator it2(dir, ec);\n+  if (choice == 1)\n+  {\n+    ++it2;\n+    try {\n+      it2.pop();\n+      VERIFY( false );\n+    } catch (const fs::filesystem_error& e) {\n+      VERIFY( e.code().value() == EIO );\n+      VERIFY( it2 == end(it2) );\n+    }\n+  }\n+#endif\n+\n+  fs::remove_all(dir, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}