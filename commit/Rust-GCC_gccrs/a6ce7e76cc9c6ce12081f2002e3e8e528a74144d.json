{"sha": "a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZjZTdlNzZjYzljNmNlMTIwODFmMjAwMmUzZThlNTI4YTc0MTQ0ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:17:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:17:15Z"}, "message": "[multiple changes]\n\n2014-02-19  Yannick Moy  <moy@adacore.com>\n\n\t* gnat_rm.texi: Doc clarifications.\n\n2014-02-19  Yannick Moy  <moy@adacore.com>\n\n\t* exp_util.adb (Remove_Side_Effects): Do not remove side-effects\n\tinside a generic.\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Get_Cursor_Type): Obtain cursor type from\n\tspecified First primitive, rather than by name.\n\t(Validate_Iterable_Aspect, Resolve_Iterable_Operation): Use it,\n\tand extend error checking for missing primitives and incorrect\n\tsignatures.\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Check_Pragma_Implemented): Detect additional\n\terrors when a Synchronization aspect on an overriding protected\n\toperation does not match the given aspect on the overridden\n\toperation of an ancestor interface.\n\n2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Check_Loop_Pragma_Grouping): New routine.\n\t(Check_Loop_Pragma_Placement): Update\n\tcomment on usage. Remove local variables Orig_Stmt and\n\tWithin_Same_Sequence. Check that the current Loop_Invariant or\n\tLoop_Variant pragma is grouped together with other such pragmas.\n\t(Is_Loop_Pragma): New routine.\n\t(Prev_In_Loop): Removed.\n\nFrom-SVN: r207894", "tree": {"sha": "72b260d465183e929aa6b2e86bc179f0c65c182b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72b260d465183e929aa6b2e86bc179f0c65c182b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/comments", "author": null, "committer": null, "parents": [{"sha": "0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7f0f0e87a381ab6aaa84b512bf8165115c5874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b7f0f0e87a381ab6aaa84b512bf8165115c5874"}], "stats": {"total": 500, "additions": 315, "deletions": 185}, "files": [{"sha": "d801603c6249b1f8e01ef58cd8e4fff9b7935247", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "patch": "@@ -1,3 +1,37 @@\n+2014-02-19  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat_rm.texi: Doc clarifications.\n+\n+2014-02-19  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_util.adb (Remove_Side_Effects): Do not remove side-effects\n+\tinside a generic.\n+\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Get_Cursor_Type): Obtain cursor type from\n+\tspecified First primitive, rather than by name.\n+\t(Validate_Iterable_Aspect, Resolve_Iterable_Operation): Use it,\n+\tand extend error checking for missing primitives and incorrect\n+\tsignatures.\n+\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Pragma_Implemented): Detect additional\n+\terrors when a Synchronization aspect on an overriding protected\n+\toperation does not match the given aspect on the overridden\n+\toperation of an ancestor interface.\n+\n+2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Check_Loop_Pragma_Grouping): New routine.\n+\t(Check_Loop_Pragma_Placement): Update\n+\tcomment on usage. Remove local variables Orig_Stmt and\n+\tWithin_Same_Sequence. Check that the current Loop_Invariant or\n+\tLoop_Variant pragma is grouped together with other such pragmas.\n+\t(Is_Loop_Pragma): New routine.\n+\t(Prev_In_Loop): Removed.\n+\n 2014-02-19  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch6.adb (P_Return): For extended return, end column lines"}, {"sha": "d9ad0e1c3f23a881168a232ba9a3be2d728ff61b", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "patch": "@@ -6638,9 +6638,12 @@ package body Exp_Util is\n    begin\n       --  Handle cases in which there is nothing to do. In GNATprove mode,\n       --  removal of side effects is useful for the light expansion of\n-      --  renamings.\n+      --  renamings. This removal should only occur when not inside a\n+      --  generic and not doing a pre-analysis.\n \n-      if not (Expander_Active or (Full_Analysis and GNATprove_Mode)) then\n+      if not Expander_Active\n+        and (Inside_A_Generic or not Full_Analysis or not GNATprove_Mode)\n+      then\n          return;\n       end if;\n "}, {"sha": "78c605244d0ee33077ffbcba503c2ba463d33120", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "patch": "@@ -4357,7 +4357,7 @@ achieving its purpose.\n \n Multiple @code{Loop_Invariant} and @code{Loop_Variant} pragmas that\n apply to the same loop should be grouped in the same sequence of\n-statements, with only the same pragmas in between.\n+statements.\n \n To aid in writing such invariants, the special attribute @code{Loop_Entry}\n may be used to refer to the value of an expression on entry to the loop. This\n@@ -4456,7 +4456,7 @@ syntax.\n \n Multiple @code{Loop_Invariant} and @code{Loop_Variant} pragmas that\n apply to the same loop should be grouped in the same sequence of\n-statements, with only the same pragmas in between.\n+statements.\n \n The @code{Loop_Entry} attribute may be used within the expressions of the\n @code{Loop_Variant} pragma to refer to values on entry to the loop."}, {"sha": "952e770ffb1495e8f64bf4c915ba6293160283f1", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 84, "deletions": 22, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "patch": "@@ -128,9 +128,11 @@ package body Sem_Ch13 is\n    --  Uint value. If the value is inappropriate, then error messages are\n    --  posted as required, and a value of No_Uint is returned.\n \n-   function Get_Cursor_Type (S : Entity_Id) return Entity_Id;\n-   --  Find Cursor type by name in the scope of an iterable type, for use in\n-   --  resolving the primitive operations of the type.\n+   function Get_Cursor_Type\n+     (Aspect : Node_Id;\n+       Typ   : Entity_Id) return Entity_Id;\n+   --  Find Cursor type in scope of Typ, by locating primitive operation First.\n+   --  For use in resolving the other primitive operations of an Iterable type.\n \n    function Is_Operational_Item (N : Node_Id) return Boolean;\n    --  A specification for a stream attribute is allowed before the full type\n@@ -8059,16 +8061,25 @@ package body Sem_Ch13 is\n             T := Entity (ASN);\n \n             declare\n-               Cursor : constant Entity_Id := Get_Cursor_Type (Scope (T));\n+               Cursor : constant Entity_Id := Get_Cursor_Type (ASN, T);\n                Assoc  : Node_Id;\n                Expr   : Node_Id;\n+\n             begin\n+               if Cursor = Any_Type then\n+                  return;\n+               end if;\n+\n                Assoc := First (Component_Associations (Expression (ASN)));\n                while Present (Assoc) loop\n                   Expr := Expression (Assoc);\n                   Analyze (Expr);\n-                  Resolve_Iterable_Operation\n-                    (Expr, Cursor, T, Chars (First (Choices (Assoc))));\n+\n+                  if not Error_Posted (Expr) then\n+                     Resolve_Iterable_Operation\n+                       (Expr, Cursor, T, Chars (First (Choices (Assoc))));\n+                  end if;\n+\n                   Next (Assoc);\n                end loop;\n             end;\n@@ -9749,26 +9760,75 @@ package body Sem_Ch13 is\n    -- Get_Cursor_Type --\n    ---------------------\n \n-   function Get_Cursor_Type (S : Entity_Id) return Entity_Id is\n-      C : Entity_Id;\n-      E : Entity_Id;\n+   function Get_Cursor_Type\n+     (Aspect : Node_Id;\n+      Typ    : Entity_Id) return Entity_Id\n+   is\n+      Assoc    : Node_Id;\n+      Func     : Entity_Id;\n+      First_Op : Entity_Id;\n+      Cursor   : Entity_Id;\n \n    begin\n-      --  There must be a cursor type declared in the same package, to be\n-      --  used in iterable primitives.\n-\n-      C := Empty;\n-      E := First_Entity (S);\n-      while Present (E) loop\n-         if Chars (E) = Name_Cursor and then Is_Type (E) then\n-            C := E;\n+      --  If error already detected, return.\n+\n+      if Error_Posted (Aspect) then\n+         return Any_Type;\n+      end if;\n+\n+      --  The cursor type for an Iterable aspect is the return type of\n+      --  a non-overloaded First primitive operation. Locate association\n+      --  for First.\n+\n+      Assoc := First (Component_Associations (Expression (Aspect)));\n+      First_Op  := Any_Id;\n+      while Present (Assoc) loop\n+         if Chars (First (Choices (Assoc))) = Name_First then\n+            First_Op := Expression (Assoc);\n             exit;\n          end if;\n \n-         Next_Entity (E);\n+         Next (Assoc);\n+      end loop;\n+\n+      if First_Op = Any_Id then\n+         Error_Msg_N (\"aspect Iterable must specify First operation\", Aspect);\n+         return Any_Type;\n+      end if;\n+\n+      Cursor := Any_Type;\n+\n+      --  Locate function with desired name and profile in scope of type.\n+\n+      Func := First_Entity (Scope (Typ));\n+      while Present (Func) loop\n+         if Chars (Func) = Chars (First_Op)\n+           and then Ekind (Func) = E_Function\n+           and then Present (First_Formal (Func))\n+           and then Etype (First_Formal (Func)) = Typ\n+           and then No (Next_Formal (First_Formal (Func)))\n+         then\n+            if Cursor /= Any_Type then\n+               Error_Msg_N\n+                  (\"Operation First for iterable type must be unique\", Aspect);\n+               return Any_Type;\n+\n+            else\n+               Cursor :=  Etype (Func);\n+            end if;\n+         end if;\n+\n+         Next_Entity (Func);\n       end loop;\n \n-      return C;\n+      --  If not found, no way to resolve remaining primitives.\n+\n+      if Cursor = Any_Type then\n+         Error_Msg_N\n+            (\"No legal primitive operation First for Iterable type\", Aspect);\n+      end if;\n+\n+      return Cursor;\n    end Get_Cursor_Type;\n \n    -------------------------------------\n@@ -10876,6 +10936,7 @@ package body Sem_Ch13 is\n          then\n             Error_Msg_N (\"iterable primitive must be local function name \"\n                          & \"whose first formal is an iterable type\", N);\n+            return;\n          end if;\n \n          Ent := Entity (N);\n@@ -11455,16 +11516,17 @@ package body Sem_Ch13 is\n       Expr  : Node_Id;\n \n       Prim   : Node_Id;\n-      Cursor : constant Entity_Id := Get_Cursor_Type (Scope (Typ));\n+      Cursor : constant Entity_Id := Get_Cursor_Type (ASN, Typ);\n \n       First_Id       : Entity_Id;\n       Next_Id        : Entity_Id;\n       Has_Element_Id : Entity_Id;\n       Element_Id     : Entity_Id;\n \n    begin\n-      if No (Cursor) then\n-         Error_Msg_N (\"Iterable aspect requires a cursor type\", ASN);\n+      --  If previous error aspect is unusable.\n+\n+      if Cursor = Any_Type then\n          return;\n       end if;\n "}, {"sha": "daa4f4e51ce1262f942d82de2d4944d9b3acff5e", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "patch": "@@ -9377,7 +9377,26 @@ package body Sem_Ch3 is\n                Error_Msg_NE\n                  (\"type & must implement abstract subprogram & with a \" &\n                   \"procedure\", Subp_Alias, Contr_Typ);\n+\n+            elsif Present (Get_Rep_Pragma (Impl_Subp, Name_Implemented))\n+              and then Implementation_Kind (Impl_Subp) /= Impl_Kind\n+            then\n+               Error_Msg_Name_1 := Impl_Kind;\n+               Error_Msg_N\n+                (\"overriding operation& must have synchronization%\",\n+                   Subp_Alias);\n             end if;\n+\n+         --  If primitive has Optional synchronization, overriding operation\n+         --  must match if it has an explicit synchronization..\n+\n+         elsif Present (Get_Rep_Pragma (Impl_Subp, Name_Implemented))\n+           and then Implementation_Kind (Impl_Subp) /= Impl_Kind\n+         then\n+               Error_Msg_Name_1 := Impl_Kind;\n+               Error_Msg_N\n+                (\"overriding operation& must have syncrhonization%\",\n+                   Subp_Alias);\n          end if;\n       end Check_Pragma_Implemented;\n "}, {"sha": "b7d867462659252b0517af2649d5f41bb399c601", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 171, "deletions": 159, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ce7e76cc9c6ce12081f2002e3e8e528a74144d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a6ce7e76cc9c6ce12081f2002e3e8e528a74144d", "patch": "@@ -3103,10 +3103,9 @@ package body Sem_Prag is\n       --  pragma Attach_Handler.\n \n       procedure Check_Loop_Pragma_Placement;\n-      --  Verify whether pragma Loop_Invariant or Loop_Optimize or Loop_Variant\n+      --  Verify whether pragmas Loop_Invariant, Loop_Optimize and Loop_Variant\n       --  appear immediately within a construct restricted to loops, and that\n-      --  pragmas Loop_Invariant and Loop_Variant applying to the same loop all\n-      --  appear grouped in the same sequence of statements.\n+      --  pragmas Loop_Invariant and Loop_Variant are grouped together.\n \n       procedure Check_Is_In_Decl_Part_Or_Package_Spec;\n       --  Check that pragma appears in a declarative part, or in a package\n@@ -4576,140 +4575,209 @@ package body Sem_Prag is\n       ---------------------------------\n \n       procedure Check_Loop_Pragma_Placement is\n+         procedure Check_Loop_Pragma_Grouping (Loop_Stmt : Node_Id);\n+         --  Verify whether the current pragma is properly grouped with other\n+         --  pragma Loop_Invariant and/or Loop_Variant. Node Loop_Stmt is the\n+         --  related loop where the pragma appears.\n+\n+         function Is_Loop_Pragma (Stmt : Node_Id) return Boolean;\n+         --  Determine whether an arbitrary statement Stmt denotes pragma\n+         --  Loop_Invariant or Loop_Variant.\n+\n          procedure Placement_Error (Constr : Node_Id);\n          pragma No_Return (Placement_Error);\n          --  Node Constr denotes the last loop restricted construct before we\n          --  encountered an illegal relation between enclosing constructs. Emit\n          --  an error depending on what Constr was.\n \n-         function Prev_In_Loop (Stmt : Node_Id) return Node_Id;\n-         --  Returns the statement or declaration preceding Stmt in the\n-         --  same loop, or Empty if the head of the loop is reached. Block\n-         --  statements are entered during this traversal.\n+         --------------------------------\n+         -- Check_Loop_Pragma_Grouping --\n+         --------------------------------\n \n-         ---------------------\n-         -- Placement_Error --\n-         ---------------------\n+         procedure Check_Loop_Pragma_Grouping (Loop_Stmt : Node_Id) is\n+            Stop_Search : exception;\n+            --  This exception is used to terminate the recursive descent of\n+            --  routine Check_Grouping.\n \n-         procedure Placement_Error (Constr : Node_Id) is\n-            LA : constant String := \" with Loop_Entry\";\n-         begin\n-            if Prag_Id = Pragma_Assert then\n-               Error_Msg_String (1 .. LA'Length) := LA;\n-               Error_Msg_Strlen := LA'Length;\n-            else\n-               Error_Msg_Strlen := 0;\n-            end if;\n+            procedure Check_Grouping (L : List_Id);\n+            --  Find the first group of pragmas in list L and if successful,\n+            --  ensure that the current pragma is part of that group. The\n+            --  routine raises Stop_Search once such a check is performed to\n+            --  halt the recursive descent.\n \n-            if Nkind (Constr) = N_Pragma then\n-               Error_Pragma\n-                 (\"pragma %~ must appear immediately within the statements \"\n-                  & \"of a loop\");\n-            else\n-               Error_Pragma_Arg\n-                 (\"block containing pragma %~ must appear immediately within \"\n-                  & \"the statements of a loop\", Constr);\n-            end if;\n-         end Placement_Error;\n+            procedure Grouping_Error (Prag : Node_Id);\n+            pragma No_Return (Grouping_Error);\n+            --  Emit an error concerning the current pragma indicating that it\n+            --  should be placed after pragma Prag.\n \n-         ------------------\n-         -- Prev_In_Loop --\n-         ------------------\n+            --------------------\n+            -- Check_Grouping --\n+            --------------------\n \n-         function Prev_In_Loop (Stmt : Node_Id) return Node_Id is\n-            Prev : Node_Id;\n-            Reach_Inside_Blocks : Boolean;\n+            procedure Check_Grouping (L : List_Id) is\n+               HSS  : Node_Id;\n+               Prag : Node_Id;\n+               Stmt : Node_Id;\n \n-         begin\n-            Reach_Inside_Blocks := True;\n+            begin\n+               --  Inspect the list of declarations or statements looking for\n+               --  the first grouping of pragmas:\n \n-            --  Try the previous statement in the same list\n+               --    loop\n+               --       pragma Loop_Invariant ...;\n+               --       pragma Loop_Variant ...;\n+               --       . . .                     -- (1)\n+               --       pragma Loop_Variant ...;  --  current pragma\n \n-            Prev := Nlists.Prev (Stmt);\n+               --  If the current pragma is not in the grouping, then it must\n+               --  either appear in a different declarative or statement list\n+               --  or the construct at (1) is separating the pragma from the\n+               --  grouping.\n \n-            --  Otherwise reach to the previous statement through the parent\n+               Stmt := First (L);\n+               while Present (Stmt) loop\n \n-            if No (Prev) then\n+                  --  Pragmas Loop_Invariant and Loop_Variant may only appear\n+                  --  inside a loop or a block housed inside a loop. Inspect\n+                  --  the declarations and statements of the block as they may\n+                  --  contain the first grouping.\n \n-               --  If we're inside the statements of a block which contains\n-               --  declarations, continue with the last declaration of the\n-               --  block if any.\n+                  if Nkind (Stmt) = N_Block_Statement then\n+                     HSS := Handled_Statement_Sequence (Stmt);\n \n-               if Nkind (Parent (Stmt)) = N_Handled_Sequence_Of_Statements\n-                 and then Nkind (Parent (Parent (Stmt))) = N_Block_Statement\n-                 and then Present (Declarations (Parent (Parent (Stmt))))\n-               then\n-                  Prev := Last (Declarations (Parent (Parent (Stmt))));\n+                     Check_Grouping (Declarations (Stmt));\n \n-               --  Ignore a handled statement sequence\n+                     if Present (HSS) then\n+                        Check_Grouping (Statements (HSS));\n+                     end if;\n \n-               elsif\n-                 Nkind (Parent (Stmt)) = N_Handled_Sequence_Of_Statements\n-               then\n-                  Reach_Inside_Blocks := False;\n-                  Prev := Parent (Parent (Stmt));\n+                  --  The first pragma of the first topmost grouping has been\n+                  --  found.\n \n-               --  Do not reach past the head of the current loop\n+                  elsif Is_Loop_Pragma (Stmt) then\n \n-               elsif Nkind (Parent (Stmt)) = N_Loop_Statement then\n-                  null;\n+                     --  The group and the current pragma are not in the same\n+                     --  declarative or statement list.\n \n-               --  Otherwise use the parent statement\n+                     if List_Containing (Stmt) /= List_Containing (N) then\n+                        Grouping_Error (Stmt);\n \n-               else\n-                  Reach_Inside_Blocks := False;\n-                  Prev := Parent (Stmt);\n-               end if;\n-            end if;\n+                     --  Try to reach the current pragma from the first pragma\n+                     --  of the grouping while skipping other members:\n \n-            --  Skip block statements\n+                     --    pragma Loop_Invariant ...;  --  first pragma\n+                     --    pragma Loop_Variant ...;    --  member\n+                     --    . . .\n+                     --    pragma Loop_Variant ...;    --  current pragma\n \n-            while Nkind (Prev) = N_Block_Statement loop\n+                     else\n+                        while Present (Stmt) loop\n \n-               --  If a block is reached from statements that follow it, then\n-               --  we should reach inside the block to its last contained\n-               --  statement.\n+                           --  The current pragma is either the first pragma\n+                           --  of the group or is a member of the group. Stop\n+                           --  the search as the placement is legal.\n \n-               if Reach_Inside_Blocks then\n-                  Prev :=\n-                    Last (Statements (Handled_Statement_Sequence (Prev)));\n+                           if Stmt = N then\n+                              raise Stop_Search;\n \n-               --  If a block is reached from statements and declarations\n-               --  inside it, continue with the statements preceding the\n-               --  block if any.\n+                           --  Skip group members, but keep track of the last\n+                           --  pragma in the group.\n \n-               elsif Present (Nlists.Prev (Prev)) then\n-                  Reach_Inside_Blocks := True;\n-                  Prev := Nlists.Prev (Prev);\n+                           elsif Is_Loop_Pragma (Stmt) then\n+                              Prag := Stmt;\n \n-               --  Ignore a handled statement sequence\n+                           --  A non-pragma is separating the group from the\n+                           --  current pragma, the placement is erroneous.\n \n-               elsif\n-                 Nkind (Parent (Prev)) = N_Handled_Sequence_Of_Statements\n-               then\n-                  Prev := Parent (Parent (Prev));\n+                           else\n+                              Grouping_Error (Prag);\n+                           end if;\n \n-               --  Do not reach past the head of the current loop\n+                           Next (Stmt);\n+                        end loop;\n \n-               elsif Nkind (Parent (Prev)) = N_Loop_Statement then\n-                  Prev := Empty;\n+                        --  If the traversal did not reach the current pragma,\n+                        --  then the list must be malformed.\n \n-               --  Otherwise use the parent statement\n+                        raise Program_Error;\n+                     end if;\n+                  end if;\n \n-               else\n-                  Prev := Parent (Prev);\n-               end if;\n-            end loop;\n+                  Next (Stmt);\n+               end loop;\n+            end Check_Grouping;\n+\n+            --------------------\n+            -- Grouping_Error --\n+            --------------------\n+\n+            procedure Grouping_Error (Prag : Node_Id) is\n+            begin\n+               Error_Msg_Sloc := Sloc (Prag);\n+               Error_Pragma (\"pragma% must appear immediately after pragma#\");\n+            end Grouping_Error;\n+\n+         --  Start of processing for Check_Loop_Pragma_Grouping\n+\n+         begin\n+            --  Inspect the statements of the loop or nested blocks housed\n+            --  within to determine whether the current pragma is part of the\n+            --  first topmost grouping of Loop_Invariant and Loop_Variant.\n+\n+            Check_Grouping (Statements (Loop_Stmt));\n \n-            return Prev;\n-         end Prev_In_Loop;\n+         exception\n+            when Stop_Search => null;\n+         end Check_Loop_Pragma_Grouping;\n+\n+         --------------------\n+         -- Is_Loop_Pragma --\n+         --------------------\n+\n+         function Is_Loop_Pragma (Stmt : Node_Id) return Boolean is\n+         begin\n+            --  Inspect the original node as Loop_Invariant and Loop_Variant\n+            --  pragmas are rewritten to null when assertions are disabled.\n+\n+            if Nkind (Original_Node (Stmt)) = N_Pragma then\n+               return\n+                 Nam_In (Pragma_Name (Original_Node (Stmt)),\n+                         Name_Loop_Invariant,\n+                         Name_Loop_Variant);\n+            else\n+               return False;\n+            end if;\n+         end Is_Loop_Pragma;\n+\n+         ---------------------\n+         -- Placement_Error --\n+         ---------------------\n+\n+         procedure Placement_Error (Constr : Node_Id) is\n+            LA : constant String := \" with Loop_Entry\";\n+         begin\n+            if Prag_Id = Pragma_Assert then\n+               Error_Msg_String (1 .. LA'Length) := LA;\n+               Error_Msg_Strlen := LA'Length;\n+            else\n+               Error_Msg_Strlen := 0;\n+            end if;\n+\n+            if Nkind (Constr) = N_Pragma then\n+               Error_Pragma\n+                 (\"pragma %~ must appear immediately within the statements \"\n+                  & \"of a loop\");\n+            else\n+               Error_Pragma_Arg\n+                 (\"block containing pragma %~ must appear immediately within \"\n+                  & \"the statements of a loop\", Constr);\n+            end if;\n+         end Placement_Error;\n \n          --  Local declarations\n \n-         Prev                 : Node_Id;\n-         Stmt                 : Node_Id;\n-         Orig_Stmt            : Node_Id;\n-         Within_Same_Sequence : Boolean;\n+         Prev : Node_Id;\n+         Stmt : Node_Id;\n \n       --  Start of processing for Check_Loop_Pragma_Placement\n \n@@ -4771,71 +4839,15 @@ package body Sem_Prag is\n             end if;\n          end loop;\n \n-         --  For a Loop_Invariant or Loop_Variant pragma, check that previous\n-         --  Loop_Invariant and Loop_Variant pragmas for the same loop appear\n-         --  in the same sequence of statements, with only intervening similar\n-         --  pragmas.\n-\n-         if Prag_Id = Pragma_Loop_Invariant\n-              or else\n-            Prag_Id = Pragma_Loop_Variant\n-         then\n-            Stmt := Prev_In_Loop (N);\n-            Within_Same_Sequence := True;\n-\n-            while Present (Stmt) loop\n-\n-               --  The pragma may have been rewritten as a null statement if\n-               --  assertions are not enabled, in which case the original node\n-               --  should be used.\n-\n-               Orig_Stmt := Original_Node (Stmt);\n+         --  Check that the current pragma Loop_Invariant or Loop_Variant is\n+         --  grouped together with other such pragmas.\n \n-               --  Issue an error on a non-consecutive Loop_Invariant or\n-               --  Loop_Variant pragma.\n+         if Is_Loop_Pragma (N) then\n \n-               if Nkind (Orig_Stmt) = N_Pragma then\n-                  declare\n-                     Stmt_Prag_Id : constant Pragma_Id :=\n-                                      Get_Pragma_Id (Pragma_Name (Orig_Stmt));\n+            --  The previous check should have located the related loop\n \n-                  begin\n-                     if Stmt_Prag_Id = Pragma_Loop_Invariant\n-                          or else\n-                        Stmt_Prag_Id = Pragma_Loop_Variant\n-                     then\n-                        if List_Containing (Stmt) /= List_Containing (N)\n-                          or else not Within_Same_Sequence\n-                        then\n-                           Error_Msg_Sloc := Sloc (Orig_Stmt);\n-                           Error_Pragma\n-                             (\"pragma% must appear immediately after pragma#\");\n-\n-                        --  Continue searching for previous Loop_Invariant and\n-                        --  Loop_Variant pragmas even after finding a previous\n-                        --  correct pragma, so that an error is also issued\n-                        --  for the current pragma in case there is a previous\n-                        --  non-consecutive pragma.\n-\n-                        else\n-                           null;\n-                        end if;\n-\n-                     --  Mark the end of the consecutive sequence of pragmas\n-\n-                     else\n-                        Within_Same_Sequence := False;\n-                     end if;\n-                  end;\n-\n-               --  Mark the end of the consecutive sequence of pragmas\n-\n-               else\n-                  Within_Same_Sequence := False;\n-               end if;\n-\n-               Stmt := Prev_In_Loop (Stmt);\n-            end loop;\n+            pragma Assert (Nkind (Stmt) = N_Loop_Statement);\n+            Check_Loop_Pragma_Grouping (Stmt);\n          end if;\n       end Check_Loop_Pragma_Placement;\n "}]}