{"sha": "1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwN2E3MWE0YjYwYzY5MjBkMGM3Yjc3MTUwYThkNGE3MDQ5ZjEzNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T09:38:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T09:38:56Z"}, "message": "[multiple changes]\n\n2011-08-29  Robert Dewar  <dewar@adacore.com>\n\n\t* frontend.adb, gnat1drv.adb: Minor reformatting.\n\n2011-08-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-pooglo.adb (Allocate, Deallocate): Take into account the alignment.\n\t* a-fihema.adb (Allocate, Deallocate): Ditto.  Possibly add padding\n\tspace in front of the header.\n\nFrom-SVN: r178181", "tree": {"sha": "26927fb78adfdea0e761cec9119def7a7960cab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26927fb78adfdea0e761cec9119def7a7960cab6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/comments", "author": null, "committer": null, "parents": [{"sha": "4bcd6411417e4bd46d5f6416f72c71bf69cd577a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcd6411417e4bd46d5f6416f72c71bf69cd577a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bcd6411417e4bd46d5f6416f72c71bf69cd577a"}], "stats": {"total": 125, "additions": 100, "deletions": 25}, "files": [{"sha": "b63a9f351c503f6a6a56897f665071bdc462278c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "patch": "@@ -1,3 +1,13 @@\n+2011-08-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* frontend.adb, gnat1drv.adb: Minor reformatting.\n+\n+2011-08-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-pooglo.adb (Allocate, Deallocate): Take into account the alignment.\n+\t* a-fihema.adb (Allocate, Deallocate): Ditto.  Possibly add padding\n+\tspace in front of the header.\n+\n 2011-08-29  Johannes Kanig  <kanig@adacore.com>\n \n \t* frontend.adb (Frontend): Exit after creating Standard package when"}, {"sha": "2eadd0cdf16475d0617532ad12d2ad02b59b7afa", "filename": "gcc/ada/a-fihema.adb", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "patch": "@@ -51,10 +51,6 @@ package body Ada.Finalization.Heap_Management is\n    --  Allocate/Deallocate to determine the Storage_Size passed to the\n    --  underlying pool.\n \n-   Header_Offset : constant Storage_Offset := Header_Size;\n-   --  Offset from the header to the actual object. Used to get from the\n-   --  address of a header to the address of the actual object, and vice-versa.\n-\n    function Address_To_Node_Ptr is\n      new Ada.Unchecked_Conversion (Address, Node_Ptr);\n \n@@ -136,10 +132,21 @@ package body Ada.Finalization.Heap_Management is\n          end if;\n \n          declare\n-            N_Addr : Address;\n-            N_Ptr  : Node_Ptr;\n+            Header_Offset : Storage_Offset;\n+            N_Addr        : Address;\n+            N_Ptr         : Node_Ptr;\n \n          begin\n+            --  Offset from the header to the actual object. The header is\n+            --  just in front of the object. There may be padding space before\n+            --  the header.\n+\n+            if Alignment > Header_Size then\n+               Header_Offset := Alignment;\n+            else\n+               Header_Offset := Header_Size;\n+            end if;\n+\n             --  Use the underlying pool to allocate enough space for the object\n             --  and the list header. The returned address points to the list\n             --  header. If locking is necessary, it will be done by the\n@@ -148,13 +155,14 @@ package body Ada.Finalization.Heap_Management is\n             Allocate\n               (Collection.Base_Pool.all,\n                N_Addr,\n-               Storage_Size + Header_Size,\n+               Storage_Size + Header_Offset,\n                Alignment);\n \n             --  Map the allocated memory into a Node record. This converts the\n             --  top of the allocated bits into a list header.\n \n-            N_Ptr := Address_To_Node_Ptr (N_Addr);\n+            N_Ptr := Address_To_Node_Ptr\n+              (N_Addr + Header_Offset - Header_Size);\n             Attach (N_Ptr, Collection.Objects'Unchecked_Access);\n \n             --  Move the address from Prev to the start of the object. This\n@@ -224,19 +232,28 @@ package body Ada.Finalization.Heap_Management is\n \n       if Has_Header then\n          declare\n-            N_Addr : Address;\n-            N_Ptr  : Node_Ptr;\n+            Header_Offset : Storage_Offset;\n+            N_Addr        : Address;\n+            N_Ptr         : Node_Ptr;\n \n          begin\n-            --  Move address from the object to beginning of the list header\n+            --  Offset from the header to the actual object.\n \n-            N_Addr := Addr - Header_Offset;\n+            if Alignment > Header_Size then\n+               Header_Offset := Alignment;\n+            else\n+               Header_Offset := Header_Size;\n+            end if;\n \n-            --  Converts the bits preceding the object into a list header\n+            --  Converts from the object to the list header\n \n-            N_Ptr := Address_To_Node_Ptr (N_Addr);\n+            N_Ptr := Address_To_Node_Ptr (Addr - Header_Size);\n             Detach (N_Ptr);\n \n+            --  Converts the bits preceding the object the block address.\n+\n+            N_Addr := Addr - Header_Offset;\n+\n             --  Use the underlying pool to destroy the object along with the\n             --  list header.\n \n@@ -340,7 +357,7 @@ package body Ada.Finalization.Heap_Management is\n             if Collection.Finalize_Address /= null then\n                declare\n                   Object_Address : constant Address :=\n-                                     Node.all'Address + Header_Offset;\n+                                     Node.all'Address + Header_Size;\n                   --  Get address of object from address of header\n \n                begin"}, {"sha": "6e829d20517229cd7af9a68f6b647831d0726006", "filename": "gcc/ada/a-fihema.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fa-fihema.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fa-fihema.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.ads?ref=1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "patch": "@@ -119,7 +119,8 @@ private\n    --  full view of Limited_Controlled, which is NOT limited. Note that default\n    --  initialization does not happen for this type (the pointers will not be\n    --  automatically set to null), because of the games we're playing with\n-   --  address arithmetic.\n+   --  address arithmetic. Code in the body assumes that the size of\n+   --  this record is a power of 2 to deal with alignment.\n \n    type Node is record\n       Prev : Node_Ptr;"}, {"sha": "2dad57a3b3b18909f389466e3e0b08a20fc157a9", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "patch": "@@ -100,6 +100,7 @@ begin\n \n    --  If the -gnatd.H flag is present, we are only interested in the Standard\n    --  package, so the frontend has done its job here.\n+\n    if Debug_Flag_Dot_HH then\n       return;\n    end if;"}, {"sha": "7ae04fe62c7ac7fea0c51bd818565cafa2af3684", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "patch": "@@ -770,12 +770,18 @@ begin\n       Original_Operating_Mode := Operating_Mode;\n       Frontend;\n \n-      --  Exit with errors if the main source could not be parsed\n-      --  Also, when -gnatd.H is present, the source file is not set.\n+      --  Exit with errors if the main source could not be parsed. Also, when\n+      --  -gnatd.H is present, the source file is not set.\n+\n       if Sinput.Main_Source_File = No_Source_File then\n+\n+         --  Handle -gnatd.H debug mode\n+\n          if Debug_Flag_Dot_HH then\n-            --  We lock all the tables to keep the convention that the backend\n-            --  needs to unlock the tables it wants to touch.\n+\n+            --  For -gnatd.H, lock all the tables to keep the convention that\n+            --  the backend needs to unlock the tables it wants to touch.\n+\n             Atree.Lock;\n             Elists.Lock;\n             Fname.UF.Lock;\n@@ -786,8 +792,12 @@ begin\n             Sinput.Lock;\n             Namet.Lock;\n             Stringt.Lock;\n+\n+            --  And all we need to do is to call the back end\n+\n             Back_End.Call_Back_End (Back_End.Generate_Object);\n          end if;\n+\n          Errout.Finalize (Last_Call => True);\n          Errout.Output_Messages;\n          Exit_Program (E_Errors);"}, {"sha": "de96aa0f57dacd2867005a7fb0ed85ce6e3d038e", "filename": "gcc/ada/s-pooglo.adb", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fs-pooglo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a07a71a4b60c6920d0c7b77150a8d4a7049f134/gcc%2Fada%2Fs-pooglo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-pooglo.adb?ref=1a07a71a4b60c6920d0c7b77150a8d4a7049f134", "patch": "@@ -46,20 +46,44 @@ package body System.Pool_Global is\n       Storage_Size : SSE.Storage_Count;\n       Alignment    : SSE.Storage_Count)\n    is\n+      use SSE;\n       pragma Warnings (Off, Pool);\n-      pragma Warnings (Off, Alignment);\n \n-      Allocated : System.Address;\n+      Aligned_Size    : Storage_Count := Storage_Size;\n+      Aligned_Address : System.Address;\n+      Allocated       : System.Address;\n \n    begin\n-      Allocated := Memory.Alloc (Memory.size_t (Storage_Size));\n+      if Alignment > Standard'System_Allocator_Alignment then\n+         Aligned_Size := Aligned_Size + Alignment;\n+      end if;\n+\n+      Allocated := Memory.Alloc (Memory.size_t (Aligned_Size));\n \n       --  The call to Alloc returns an address whose alignment is compatible\n       --  with the worst case alignment requirement for the machine; thus the\n       --  Alignment argument can be safely ignored.\n \n       if Allocated = Null_Address then\n          raise Storage_Error;\n+      end if;\n+\n+      if Alignment > Standard'System_Allocator_Alignment then\n+         --  Realign the returned address.\n+         Aligned_Address := To_Address\n+           (To_Integer (Allocated) + Integer_Address (Alignment)\n+              - (To_Integer (Allocated) mod Integer_Address (Alignment)));\n+         --  Save the block address.\n+         declare\n+            Saved_Address : System.Address;\n+            pragma Import (Ada, Saved_Address);\n+            for Saved_Address'Address use\n+               Aligned_Address\n+               - Storage_Offset (System.Address'Size / Storage_Unit);\n+         begin\n+            Saved_Address := Allocated;\n+         end;\n+         Address := Aligned_Address;\n       else\n          Address := Allocated;\n       end if;\n@@ -75,12 +99,24 @@ package body System.Pool_Global is\n       Storage_Size : SSE.Storage_Count;\n       Alignment    : SSE.Storage_Count)\n    is\n+      use System.Storage_Elements;\n       pragma Warnings (Off, Pool);\n       pragma Warnings (Off, Storage_Size);\n-      pragma Warnings (Off, Alignment);\n \n    begin\n-      Memory.Free (Address);\n+      if Alignment > Standard'System_Allocator_Alignment then\n+         --  Retrieve the block address.\n+         declare\n+            Saved_Address : System.Address;\n+            pragma Import (Ada, Saved_Address);\n+            for Saved_Address'Address use\n+              Address - Storage_Offset (System.Address'Size / Storage_Unit);\n+         begin\n+            Memory.Free (Saved_Address);\n+         end;\n+      else\n+         Memory.Free (Address);\n+      end if;\n    end Deallocate;\n \n    ------------------"}]}