{"sha": "0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyODM3YjVjNDA4ZjhmZDJiMDIzYTdiZjAwYmU5YWJkMWUyOGEyOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-08-30T15:12:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-08-30T15:12:20Z"}, "message": "gigi.h (aggregate_type_contains_array_p): Declare.\n\n\t* gcc-interface/gigi.h (aggregate_type_contains_array_p): Declare.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: For an\n\textension, test Has_Record_Rep_Clause instead of Has_Specified_Layout.\n\t(adjust_packed): Return 0 if the type of the field is an aggregate\n\ttype that contains (or is) a self-referential array.\n\t(type_has_variable_size): Delete.\n\t* gcc-interface/utils.c (inish_record_type): Constify a variable.\n\t(aggregate_type_contains_array_p): Add parameter SELF_REFERENTIAL.\n\t<RECORD_TYPE>: Pass it in the recursive call.\n\t<ARRAY_TYPE>: If it is true, return true only if the array type is\n\tself-referential.\n\t(create_field_decl): Streamline the setting of the alignment on the\n\tfield.  Pass false to aggregate_type_contains_array_p.\n\nFrom-SVN: r275196", "tree": {"sha": "706ae520a2d14fa4f31a700f4138b4b994367b57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/706ae520a2d14fa4f31a700f4138b4b994367b57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/comments", "author": null, "committer": null, "parents": [{"sha": "c85dbadc061f7c7f3575e335976150370d8652be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85dbadc061f7c7f3575e335976150370d8652be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85dbadc061f7c7f3575e335976150370d8652be"}], "stats": {"total": 175, "additions": 112, "deletions": 63}, "files": [{"sha": "636eb7c9dcd5616c49df3cbd03dd89fa40dc1177", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "patch": "@@ -1,3 +1,19 @@\n+2019-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (aggregate_type_contains_array_p): Declare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: For an\n+\textension, test Has_Record_Rep_Clause instead of Has_Specified_Layout.\n+\t(adjust_packed): Return 0 if the type of the field is an aggregate\n+\ttype that contains (or is) a self-referential array.\n+\t(type_has_variable_size): Delete.\n+\t* gcc-interface/utils.c (inish_record_type): Constify a variable.\n+\t(aggregate_type_contains_array_p): Add parameter SELF_REFERENTIAL.\n+\t<RECORD_TYPE>: Pass it in the recursive call.\n+\t<ARRAY_TYPE>: If it is true, return true only if the array type is\n+\tself-referential.\n+\t(create_field_decl): Streamline the setting of the alignment on the\n+\tfield.  Pass false to aggregate_type_contains_array_p.\n+\n 2019-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (lvalue_required_p) <N_Slice>: Adjust GNU_TYPE"}, {"sha": "5fce2ad772d50a62cb1fae03193e8fe099704433", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "patch": "@@ -202,7 +202,6 @@ static void prepend_one_attribute_pragma (struct attrib **, Node_Id);\n static void prepend_attributes (struct attrib **, Entity_Id);\n static tree elaborate_expression (Node_Id, Entity_Id, const char *, bool, bool,\n \t\t\t\t  bool);\n-static bool type_has_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, const char *, bool, bool);\n static tree elaborate_expression_2 (tree, Entity_Id, const char *, bool, bool,\n \t\t\t\t    unsigned int);\n@@ -2953,10 +2952,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t      : 0;\n \tconst bool has_align = Known_Alignment (gnat_entity);\n \tconst bool has_discr = Has_Discriminants (gnat_entity);\n-\tconst bool has_rep = Has_Specified_Layout (gnat_entity);\n \tconst bool is_extension\n \t  = (Is_Tagged_Type (gnat_entity)\n \t     && Nkind (record_definition) == N_Derived_Type_Definition);\n+\tconst bool has_rep\n+\t  = is_extension\n+\t    ? Has_Record_Rep_Clause (gnat_entity)\n+\t    : Has_Specified_Layout (gnat_entity);\n \tconst bool is_unchecked_union = Is_Unchecked_Union (gnat_entity);\n \tbool all_rep = has_rep;\n \n@@ -6865,11 +6867,13 @@ choices_to_gnu (tree gnu_operand, Node_Id gnat_choices)\n static int\n adjust_packed (tree field_type, tree record_type, int packed)\n {\n-  /* If the field contains an item of variable size, we cannot pack it\n-     because we cannot create temporaries of non-fixed size in case\n-     we need to take the address of the field.  See addressable_p and\n-     the notes on the addressability issues for further details.  */\n-  if (type_has_variable_size (field_type))\n+  /* If the field contains an array with self-referential size, we'd better\n+     not pack it because this would misalign it and, therefore, cause large\n+     temporaries to be created in case we need to take the address of the\n+     field.  See addressable_p and the notes on the addressability issues\n+     for further details.  */\n+  if (AGGREGATE_TYPE_P (field_type)\n+      && aggregate_type_contains_array_p (field_type, true))\n     return 0;\n \n   /* In the other cases, we can honor the packing.  */\n@@ -7274,31 +7278,6 @@ components_need_strict_alignment (Node_Id component_list)\n   return false;\n }\n \n-/* Return true if TYPE is a type with variable size or a padding type with a\n-   field of variable size or a record that has a field with such a type.  */\n-\n-static bool\n-type_has_variable_size (tree type)\n-{\n-  tree field;\n-\n-  if (!TREE_CONSTANT (TYPE_SIZE (type)))\n-    return true;\n-\n-  if (TYPE_IS_PADDING_P (type)\n-      && !TREE_CONSTANT (DECL_SIZE (TYPE_FIELDS (type))))\n-    return true;\n-\n-  if (!RECORD_OR_UNION_TYPE_P (type))\n-    return false;\n-\n-  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-    if (type_has_variable_size (TREE_TYPE (field)))\n-      return true;\n-\n-  return false;\n-}\n-\f\n /* Return true if FIELD is an artificial field.  */\n \n static bool"}, {"sha": "edfcbd5a782a27c74ea858c5281ad06c9c78c764", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "patch": "@@ -835,6 +835,11 @@ extern tree get_base_type (tree type);\n    in bits.  If we don't know anything about the alignment, return 0.  */\n extern unsigned int known_alignment (tree exp);\n \n+/* Return true if TYPE, an aggregate type, contains (or is) an array.\n+   If SELF_REFERENTIAL is true, then an additional requirement on the\n+   array is that it be self-referential.  */\n+extern bool aggregate_type_contains_array_p (tree type, bool self_referential);\n+\n /* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n    of 2.  */\n extern bool value_factor_p (tree value, unsigned HOST_WIDE_INT factor);"}, {"sha": "8a38b3474b33066eea7d8233d43385c8e4c70ab1", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "patch": "@@ -1948,7 +1948,7 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n       if (DECL_BIT_FIELD (field)\n \t  && operand_equal_p (this_size, TYPE_SIZE (type), 0))\n \t{\n-\t  unsigned int align = TYPE_ALIGN (type);\n+\t  const unsigned int align = TYPE_ALIGN (type);\n \n \t  /* In the general case, type alignment is required.  */\n \t  if (value_factor_p (pos, align))\n@@ -2764,10 +2764,12 @@ create_var_decl (tree name, tree asm_name, tree type, tree init,\n   return var_decl;\n }\n \f\n-/* Return true if TYPE, an aggregate type, contains (or is) an array.  */\n+/* Return true if TYPE, an aggregate type, contains (or is) an array.\n+   If SELF_REFERENTIAL is true, then an additional requirement on the\n+   array is that it be self-referential.  */\n \n-static bool\n-aggregate_type_contains_array_p (tree type)\n+bool\n+aggregate_type_contains_array_p (tree type, bool self_referential)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -2778,13 +2780,14 @@ aggregate_type_contains_array_p (tree type)\n \ttree field;\n \tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (field))\n-\t      && aggregate_type_contains_array_p (TREE_TYPE (field)))\n+\t      && aggregate_type_contains_array_p (TREE_TYPE (field),\n+\t\t\t\t\t\t  self_referential))\n \t    return true;\n \treturn false;\n       }\n \n     case ARRAY_TYPE:\n-      return true;\n+      return self_referential ? type_contains_placeholder_p (type) : true;\n \n     default:\n       gcc_unreachable ();\n@@ -2808,18 +2811,6 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n   DECL_CONTEXT (field_decl) = record_type;\n   TREE_READONLY (field_decl) = TYPE_READONLY (type);\n \n-  /* If FIELD_TYPE is BLKmode, we must ensure this is aligned to at least a\n-     byte boundary since GCC cannot handle less-aligned BLKmode bitfields.\n-     Likewise for an aggregate without specified position that contains an\n-     array, because in this case slices of variable length of this array\n-     must be handled by GCC and variable-sized objects need to be aligned\n-     to at least a byte boundary.  */\n-  if (packed && (TYPE_MODE (type) == BLKmode\n-\t\t || (!pos\n-\t\t     && AGGREGATE_TYPE_P (type)\n-\t\t     && aggregate_type_contains_array_p (type))))\n-    SET_DECL_ALIGN (field_decl, BITS_PER_UNIT);\n-\n   /* If a size is specified, use it.  Otherwise, if the record type is packed\n      compute a size to use, which may differ from the object's natural size.\n      We always set a size in this case to trigger the checks for bitfield\n@@ -2872,23 +2863,39 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n \n   DECL_PACKED (field_decl) = pos ? DECL_BIT_FIELD (field_decl) : packed;\n \n+  /* If FIELD_TYPE is BLKmode, we must ensure this is aligned to at least a\n+     byte boundary since GCC cannot handle less-aligned BLKmode bitfields.\n+     Likewise for an aggregate without specified position that contains an\n+     array, because in this case slices of variable length of this array\n+     must be handled by GCC and variable-sized objects need to be aligned\n+     to at least a byte boundary.  */\n+  if (packed && (TYPE_MODE (type) == BLKmode\n+\t\t || (!pos\n+\t\t     && AGGREGATE_TYPE_P (type)\n+\t\t     && aggregate_type_contains_array_p (type, false))))\n+    SET_DECL_ALIGN (field_decl, BITS_PER_UNIT);\n+\n   /* Bump the alignment if need be, either for bitfield/packing purposes or\n-     to satisfy the type requirements if no such consideration applies.  When\n+     to satisfy the type requirements if no such considerations apply.  When\n      we get the alignment from the type, indicate if this is from an explicit\n      user request, which prevents stor-layout from lowering it later on.  */\n-  {\n-    unsigned int bit_align\n-      = (DECL_BIT_FIELD (field_decl) ? 1\n-\t : packed && TYPE_MODE (type) != BLKmode ? BITS_PER_UNIT : 0);\n+  else\n+    {\n+      const unsigned int field_align\n+\t= DECL_BIT_FIELD (field_decl)\n+\t  ? 1\n+\t  : packed\n+\t    ? BITS_PER_UNIT\n+\t    : 0;\n \n-    if (bit_align > DECL_ALIGN (field_decl))\n-      SET_DECL_ALIGN (field_decl, bit_align);\n-    else if (!bit_align && TYPE_ALIGN (type) > DECL_ALIGN (field_decl))\n-      {\n-\tSET_DECL_ALIGN (field_decl, TYPE_ALIGN (type));\n-\tDECL_USER_ALIGN (field_decl) = TYPE_USER_ALIGN (type);\n-      }\n-  }\n+      if (field_align > DECL_ALIGN (field_decl))\n+\tSET_DECL_ALIGN (field_decl, field_align);\n+      else if (!field_align && TYPE_ALIGN (type) > DECL_ALIGN (field_decl))\n+\t{\n+\t  SET_DECL_ALIGN (field_decl, TYPE_ALIGN (type));\n+\t  DECL_USER_ALIGN (field_decl) = TYPE_USER_ALIGN (type);\n+\t}\n+    }\n \n   if (pos)\n     {"}, {"sha": "715c4173ce5dc84801f81e6175ca7534cc7f1adb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "patch": "@@ -1,3 +1,7 @@\n+2019-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/pack24.adb: New test.\n+\n 2019-08-30  Jeff Law  <law@redhat.com>\n \n \t* gcc.target/mips/r10k-cache-barrier-9.c: Suppress warnings."}, {"sha": "90d6134c7ab8e3dd7ebc343508c580e63b05c718", "filename": "gcc/testsuite/gnat.dg/pack24.adb", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Ftestsuite%2Fgnat.dg%2Fpack24.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2837b5c408f8fd2b023a7bf00be9abd1e28a28/gcc%2Ftestsuite%2Fgnat.dg%2Fpack24.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fpack24.adb?ref=0c2837b5c408f8fd2b023a7bf00be9abd1e28a28", "patch": "@@ -0,0 +1,38 @@\n+--  { dg-do run }\n+\n+with Interfaces;\n+\n+procedure Pack24 is\n+\n+   type Enum_1 is (Lit_1);\n+   for Enum_1'SIZE use 16;\n+\n+   type Rec1(D1 : Enum_1 := Lit_1) is\n+      record\n+         case D1 is\n+         when Lit_1 =>\n+            F1 : Interfaces.Unsigned_16;\n+         when others =>\n+            Null;\n+         end case;\n+      end record;\n+   pragma Pack(Rec1);\n+\n+   type Rec2 is\n+      record\n+         F1 : Interfaces.Unsigned_16;\n+         F2 : Rec1;\n+   end record;\n+   pragma Pack(Rec2);\n+\n+   type Rec3 is record\n+      F1 : Interfaces.Unsigned_8;\n+      F2 : Rec2;\n+   end record;\n+   pragma Pack(Rec3);\n+\n+begin\n+  if Rec3'Size /= 56 then\n+    raise Program_Error;\n+  end if;\n+end;"}]}