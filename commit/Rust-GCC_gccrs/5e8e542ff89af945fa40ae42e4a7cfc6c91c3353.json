{"sha": "5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4ZTU0MmZmODlhZjk0NWZhNDBhZTQyZTRhN2NmYzZjOTFjMzM1Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-26T22:19:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-26T22:19:23Z"}, "message": "arith.c: Include system.h, not real system headers.\n\n        * arith.c: Include system.h, not real system headers.\n        (MPZ_NULL, MPF_NULL, DEF_GFC_INTEGER_KIND, DEF_GFC_LOGICAL_KIND,\n        DEF_GFC_REAL_KIND, GFC_SP_KIND, GFC_SP_PREC, GFC_SP_EMIN, GFC_SP_EMAX,\n        GFC_DP_KIND, GFC_DP_PREC, GFC_DP_EMIN, GFC_DP_EMAX, GFC_QP_KIND,\n        GFC_QP_PREC, GFC_QP_EMIN, GFC_QP_EMAX): Remove.\n        (gfc_integer_kinds, gfc_logical_kinds, gfc_real_kinds,\n        gfc_index_integer_kind, gfc_default_integer_kind,\n        gfc_default_real_kind,gfc_default_double_kind,\n        gfc_default_character_kind, gfc_default_logical_kind,\n        gfc_default_complex_kind, validate_integer, validate_real,\n        validate_logical, validate_character,\n        gfc_validate_kind): Move to trans-types.c.\n        (gfc_set_model_kind): Use gfc_validate_kind.\n        (gfc_set_model): Just copy the current precision to default.\n        (gfc_arith_init_1): Use mpfr precision 128 for integer setup.\n        * f95-lang.c (gfc_init_decl_processing): Invoke gfc_init_kinds.\n        * gfortran.h: Update file commentary.\n        * trans-types.c (MAX_INT_KINDS, MAX_REAL_KINDS): New.\n        (gfc_default_integer_kind_1, gfc_default_real_kind_1,\n        gfc_default_double_kind_1, gfc_default_character_kind_1,\n        gfc_default_logical_kind_1, gfc_default_complex_kind_1): New.\n        (gfc_init_kinds): New.\n        (gfc_init_types): Don't set gfc_index_integer_kind here.\n        * trans-types.h (gfc_init_kinds): Declare.\n        * doc/invoke.texi: Clarify DOUBLE PRECISION behaviour wrt -r8.\n\nFrom-SVN: r86637", "tree": {"sha": "5cc3da8fc89c95f86ccf55b71c9a0dcae6c637fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cc3da8fc89c95f86ccf55b71c9a0dcae6c637fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/comments", "author": null, "committer": null, "parents": [{"sha": "0b410f0b88b3fc969f85708883e6acb3226827f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b410f0b88b3fc969f85708883e6acb3226827f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b410f0b88b3fc969f85708883e6acb3226827f2"}], "stats": {"total": 602, "additions": 345, "deletions": 257}, "files": [{"sha": "d1f9195b5d67e49bb76a39061746e4abaf152945", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "patch": "@@ -1,3 +1,31 @@\n+2004-08-26  Richard Henderson  <rth@redhat.com>\n+\n+        * arith.c: Include system.h, not real system headers.\n+        (MPZ_NULL, MPF_NULL, DEF_GFC_INTEGER_KIND, DEF_GFC_LOGICAL_KIND,\n+        DEF_GFC_REAL_KIND, GFC_SP_KIND, GFC_SP_PREC, GFC_SP_EMIN, GFC_SP_EMAX,\n+        GFC_DP_KIND, GFC_DP_PREC, GFC_DP_EMIN, GFC_DP_EMAX, GFC_QP_KIND,\n+        GFC_QP_PREC, GFC_QP_EMIN, GFC_QP_EMAX): Remove.\n+        (gfc_integer_kinds, gfc_logical_kinds, gfc_real_kinds,\n+        gfc_index_integer_kind, gfc_default_integer_kind,\n+        gfc_default_real_kind,gfc_default_double_kind,\n+        gfc_default_character_kind, gfc_default_logical_kind,\n+        gfc_default_complex_kind, validate_integer, validate_real,\n+        validate_logical, validate_character,\n+        gfc_validate_kind): Move to trans-types.c.\n+        (gfc_set_model_kind): Use gfc_validate_kind.\n+        (gfc_set_model): Just copy the current precision to default.\n+        (gfc_arith_init_1): Use mpfr precision 128 for integer setup.\n+        * f95-lang.c (gfc_init_decl_processing): Invoke gfc_init_kinds.\n+        * gfortran.h: Update file commentary.\n+        * trans-types.c (MAX_INT_KINDS, MAX_REAL_KINDS): New.\n+        (gfc_default_integer_kind_1, gfc_default_real_kind_1,\n+        gfc_default_double_kind_1, gfc_default_character_kind_1,\n+        gfc_default_logical_kind_1, gfc_default_complex_kind_1): New.\n+        (gfc_init_kinds): New.\n+        (gfc_init_types): Don't set gfc_index_integer_kind here.\n+        * trans-types.h (gfc_init_kinds): Declare.\n+\t* doc/invoke.texi: Clarify DOUBLE PRECISION behaviour wrt -r8.\n+\n 2004-08-26  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* check.c (gfc_check_atan2): New function."}, {"sha": "85f5138555fb62b37dd799fc0bd122c8d93ba36e", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 10, "deletions": 251, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "patch": "@@ -26,82 +26,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    and this file provides the interface.  */\n \n #include \"config.h\"\n-\n-#include <string.h>\n-\n+#include \"system.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"\n \n-/* The gfc_(integer|real)_kinds[] structures have everything the front\n-   end needs to know about integers and real numbers on the target.\n-   Other entries of the structure are calculated from these values.\n-   The first entry is the default kind, the second entry of the real\n-   structure is the default double kind.  */\n-\n-#define MPZ_NULL {{0,0,0}}\n-#define MPF_NULL {{0,0,0,0}}\n-\n-#define DEF_GFC_INTEGER_KIND(KIND,RADIX,DIGITS,BIT_SIZE)\t\t\\\n-\t{KIND, RADIX, DIGITS, BIT_SIZE, 0, MPZ_NULL, MPZ_NULL, MPZ_NULL}\n-\n-#define DEF_GFC_LOGICAL_KIND(KIND,BIT_SIZE)\t\t\t\t\\\n-\t{KIND, BIT_SIZE}\n-\n-#define DEF_GFC_REAL_KIND(KIND,RADIX,DIGITS,MIN_EXP, MAX_EXP)\t\t\\\n-\t{KIND, RADIX, DIGITS, MIN_EXP, MAX_EXP,\t\t\t\t\\\n-\t 0, 0, MPF_NULL, MPF_NULL, MPF_NULL}\n-\n-gfc_integer_info gfc_integer_kinds[] = {\n-  DEF_GFC_INTEGER_KIND (4, 2, 31, 32),\n-  DEF_GFC_INTEGER_KIND (8, 2, 63, 64),\n-  DEF_GFC_INTEGER_KIND (2, 2, 15, 16),\n-  DEF_GFC_INTEGER_KIND (1, 2,  7,  8),\n-  DEF_GFC_INTEGER_KIND (0, 0,  0,  0)\n-};\n-\n-gfc_logical_info gfc_logical_kinds[] = {\n-  DEF_GFC_LOGICAL_KIND (4, 32),\n-  DEF_GFC_LOGICAL_KIND (8, 64),\n-  DEF_GFC_LOGICAL_KIND (2, 16),\n-  DEF_GFC_LOGICAL_KIND (1,  8),\n-  DEF_GFC_LOGICAL_KIND (0,  0)\n-};\n-\n-\n-/* IEEE-754 uses 1.xEe representation whereas the fortran standard\n-   uses 0.xEe representation.  Hence the exponents below are biased\n-   by one.  */\n-\n-#define GFC_SP_KIND      4\n-#define GFC_SP_PREC     24   /* p    =   24, IEEE-754  */\n-#define GFC_SP_EMIN   -125   /* emin = -126, IEEE-754  */\n-#define GFC_SP_EMAX    128   /* emin =  127, IEEE-754  */\n-\n-/* Double precision model numbers.  */\n-#define GFC_DP_KIND      8\n-#define GFC_DP_PREC     53   /* p    =    53, IEEE-754  */\n-#define GFC_DP_EMIN  -1021   /* emin = -1022, IEEE-754  */\n-#define GFC_DP_EMAX   1024   /* emin =  1023, IEEE-754  */\n-\n-/* Quad precision model numbers.  Not used.  */\n-#define GFC_QP_KIND     16\n-#define GFC_QP_PREC    113   /* p    =    113, IEEE-754  */\n-#define GFC_QP_EMIN -16381   /* emin = -16382, IEEE-754  */\n-#define GFC_QP_EMAX  16384   /* emin =  16383, IEEE-754  */\n-\n-gfc_real_info gfc_real_kinds[] = {\n-  DEF_GFC_REAL_KIND (GFC_SP_KIND, 2, GFC_SP_PREC, GFC_SP_EMIN, GFC_SP_EMAX),\n-  DEF_GFC_REAL_KIND (GFC_DP_KIND, 2, GFC_DP_PREC, GFC_DP_EMIN, GFC_DP_EMAX),\n-  DEF_GFC_REAL_KIND (0, 0,  0,     0,    0)\n-};\n-\n-\n-/* The integer kind to use for array indices.  This will be set to the\n-   proper value based on target information from the backend.  */\n-\n-int gfc_index_integer_kind;\n-\n-\n /* MPFR does not have a direct replacement for mpz_set_f() from GMP.\n    It's easily implemented with a few calls though.  */\n \n@@ -128,20 +56,13 @@ gfc_mpfr_to_mpz (mpz_t z, mpfr_t x)\n void\n gfc_set_model_kind (int kind)\n {\n-  switch (kind)\n-\t{\n-    case GFC_SP_KIND:\n-      mpfr_set_default_prec (GFC_SP_PREC);\n-      break;\n-    case GFC_DP_KIND:\n-      mpfr_set_default_prec (GFC_DP_PREC);\n-      break;\n-    case GFC_QP_KIND:\n-      mpfr_set_default_prec (GFC_QP_PREC);\n-      break;\n-    default:\n-      gfc_internal_error (\"gfc_set_model_kind(): Bad model number\");\n-    }\n+  int index = gfc_validate_kind (BT_REAL, kind, false);\n+  int base2prec;\n+\n+  base2prec = gfc_real_kinds[index].digits;\n+  if (gfc_real_kinds[index].radix != 2)\n+    base2prec *= gfc_real_kinds[index].radix / 2;\n+  mpfr_set_default_prec (base2prec);\n }\n \n \n@@ -150,20 +71,7 @@ gfc_set_model_kind (int kind)\n void\n gfc_set_model (mpfr_t x)\n {\n-  switch (mpfr_get_prec (x))\n-    {\n-    case GFC_SP_PREC:\n-      mpfr_set_default_prec (GFC_SP_PREC);\n-      break;\n-    case GFC_DP_PREC:\n-      mpfr_set_default_prec (GFC_DP_PREC);\n-      break;\n-    case GFC_QP_PREC:\n-      mpfr_set_default_prec (GFC_QP_PREC);\n-      break;\n-    default:\n-      gfc_internal_error (\"gfc_set_model(): Bad model number\");\n-    }\n+  mpfr_set_default_prec (mpfr_get_prec (x));\n }\n \n /* Calculate atan2 (y, x)\n@@ -268,8 +176,7 @@ gfc_arith_init_1 (void)\n   mpz_t r;\n   int i;\n \n-  gfc_set_model_kind (GFC_QP_KIND);\n-\n+  mpfr_set_default_prec (128);\n   mpfr_init (a);\n   mpz_init (r);\n \n@@ -409,154 +316,6 @@ gfc_arith_done_1 (void)\n }\n \n \n-/* Return default kinds.  */\n-\n-int\n-gfc_default_integer_kind (void)\n-{\n-  return gfc_integer_kinds[gfc_option.i8 ? 1 : 0].kind;\n-}\n-\n-int\n-gfc_default_real_kind (void)\n-{\n-  return gfc_real_kinds[gfc_option.r8 ? 1 : 0].kind;\n-}\n-\n-int\n-gfc_default_double_kind (void)\n-{\n-  return gfc_real_kinds[1].kind;\n-}\n-\n-int\n-gfc_default_character_kind (void)\n-{\n-  return 1;\n-}\n-\n-int\n-gfc_default_logical_kind (void)\n-{\n-  return gfc_logical_kinds[gfc_option.i8 ? 1 : 0].kind;\n-}\n-\n-int\n-gfc_default_complex_kind (void)\n-{\n-  return gfc_default_real_kind ();\n-}\n-\n-\n-/* Make sure that a valid kind is present.  Returns an index into the\n-   gfc_integer_kinds array, -1 if the kind is not present.  */\n-\n-static int\n-validate_integer (int kind)\n-{\n-  int i;\n-\n-  for (i = 0;; i++)\n-    {\n-      if (gfc_integer_kinds[i].kind == 0)\n-\t{\n-\t  i = -1;\n-\t  break;\n-\t}\n-      if (gfc_integer_kinds[i].kind == kind)\n-\tbreak;\n-    }\n-\n-  return i;\n-}\n-\n-\n-static int\n-validate_real (int kind)\n-{\n-  int i;\n-\n-  for (i = 0;; i++)\n-    {\n-      if (gfc_real_kinds[i].kind == 0)\n-\t{\n-\t  i = -1;\n-\t  break;\n-\t}\n-      if (gfc_real_kinds[i].kind == kind)\n-\tbreak;\n-    }\n-\n-  return i;\n-}\n-\n-\n-static int\n-validate_logical (int kind)\n-{\n-  int i;\n-\n-  for (i = 0;; i++)\n-    {\n-      if (gfc_logical_kinds[i].kind == 0)\n-\t{\n-\t  i = -1;\n-\t  break;\n-\t}\n-      if (gfc_logical_kinds[i].kind == kind)\n-\tbreak;\n-    }\n-\n-  return i;\n-}\n-\n-\n-static int\n-validate_character (int kind)\n-{\n-\n-  if (kind == gfc_default_character_kind ())\n-    return 0;\n-  return -1;\n-}\n-\n-\n-/* Validate a kind given a basic type.  The return value is the same\n-   for the child functions, with -1 indicating nonexistence of the\n-   type.  */\n-\n-int\n-gfc_validate_kind (bt type, int kind, bool may_fail)\n-{\n-  int rc;\n-\n-  switch (type)\n-    {\n-    case BT_REAL:\t\t/* Fall through */\n-    case BT_COMPLEX:\n-      rc = validate_real (kind);\n-      break;\n-    case BT_INTEGER:\n-      rc = validate_integer (kind);\n-      break;\n-    case BT_LOGICAL:\n-      rc = validate_logical (kind);\n-      break;\n-    case BT_CHARACTER:\n-      rc = validate_character (kind);\n-      break;\n-\n-    default:\n-      gfc_internal_error (\"gfc_validate_kind(): Got bad type\");\n-    }\n-\n-  if (!may_fail && rc < 0)\n-    gfc_internal_error (\"gfc_validate_kind(): Got bad kind\");\n-\n-  return rc;\n-}\n-\n-\n /* Given an integer and a kind, make sure that the integer lies within\n    the range of the kind.  Returns ARITH_OK or ARITH_OVERFLOW.  */\n "}, {"sha": "673e20837a9297c01f2fecbf0e93f614d756ba7e", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "patch": "@@ -576,6 +576,7 @@ gfc_init_decl_processing (void)\n   build_common_tree_nodes_2 (0);\n \n   /* Set up F95 type nodes.  */\n+  gfc_init_kinds ();\n   gfc_init_types ();\n }\n "}, {"sha": "31dc7846a02f67cf6cff24a2dd8d8173b25ce6c7", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "patch": "@@ -1504,6 +1504,7 @@ void gfc_get_errors (int *, int *);\n void gfc_arith_init_1 (void);\n void gfc_arith_done_1 (void);\n \n+/* trans-types.c */\n /* FIXME: These should go to symbol.c, really...  */\n int gfc_default_integer_kind (void);\n int gfc_default_real_kind (void);"}, {"sha": "845b10de82554c00bf00569ae0aa8258ce60bd3f", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "patch": "@@ -242,9 +242,13 @@ Conform to the specified standard.  Allowed values for @var{std} are\n @item -i8\n @item -r8\n @item -d8\n-The @option{-i8} and @option{-j8} options set the default INTEGER and REAL\n-kinds to KIND=8.  The @option{-d8} option is equivalent to specifying\n-both @option{-i8} and @option{-r8}.\n+The @option{-i8} and @option{-r8} options set the default @code{INTEGER}\n+and @code{REAL} kinds to @code{KIND=8}.  The @option{-d8} option is\n+equivalent to specifying both @option{-i8} and @option{-r8}.\n+\n+When @option{-r8} is specified, the @code{DOUBLE PRECISION} kind is set\n+to @code{KIND=16} if the target supports a 16 byte floating point format.\n+If no such format exists, the @code{DOUBLE PRECISION} kind is unchanged.\n \n @end table\n "}, {"sha": "b9bb474e2012d9f3d0390f969608015c31e46fa8", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 297, "deletions": 3, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "patch": "@@ -26,14 +26,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include <stdio.h>\n+#include \"tm.h\"\n+#include \"target.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n-#include <assert.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n+#include \"real.h\"\n+#include <assert.h>\n \f\n \n #if (GFC_MAX_DIMENSIONS < 10)\n@@ -59,6 +61,299 @@ static GTY(()) tree gfc_desc_dim_type = NULL;\n \n static GTY(()) tree gfc_max_array_element_size;\n \n+/* Arrays for all integral and real kinds.  We'll fill this in at runtime\n+   after the target has a chance to process command-line options.  */\n+\n+#define MAX_INT_KINDS 5\n+gfc_integer_info gfc_integer_kinds[MAX_INT_KINDS + 1];\n+gfc_logical_info gfc_logical_kinds[MAX_INT_KINDS + 1];\n+\n+#define MAX_REAL_KINDS 4\n+gfc_real_info gfc_real_kinds[MAX_REAL_KINDS + 1];\n+\n+/* The integer kind to use for array indices.  This will be set to the\n+   proper value based on target information from the backend.  */\n+\n+int gfc_index_integer_kind;\n+\n+/* The default kinds of the various types.  */\n+\n+static int gfc_default_integer_kind_1;\n+static int gfc_default_real_kind_1;\n+static int gfc_default_double_kind_1;\n+static int gfc_default_character_kind_1;\n+static int gfc_default_logical_kind_1;\n+static int gfc_default_complex_kind_1;\n+\n+/* Query the target to determine which machine modes are available for\n+   computation.  Choose KIND numbers for them.  */\n+\n+void\n+gfc_init_kinds (void)\n+{\n+  enum machine_mode mode;\n+  int i_index, r_index;\n+  bool saw_i4 = false, saw_i8 = false;\n+  bool saw_r4 = false, saw_r8 = false, saw_r16 = false;\n+\n+  for (i_index = 0, mode = MIN_MODE_INT; mode <= MAX_MODE_INT; mode++)\n+    {\n+      int kind, bitsize;\n+\n+      if (!targetm.scalar_mode_supported_p (mode))\n+\tcontinue;\n+\n+      if (i_index == MAX_INT_KINDS)\n+\tabort ();\n+\n+      /* Let the kind equal the bit size divided by 8.  This insulates the\n+\t programmer from the underlying byte size.  */\n+      bitsize = GET_MODE_BITSIZE (mode);\n+      kind = bitsize / 8;\n+\n+      if (kind == 4)\n+\tsaw_i4 = true;\n+      if (kind == 8)\n+\tsaw_i8 = true;\n+\n+      gfc_integer_kinds[i_index].kind = kind;\n+      gfc_integer_kinds[i_index].radix = 2;\n+      gfc_integer_kinds[i_index].digits = bitsize - 1;\n+      gfc_integer_kinds[i_index].bit_size = bitsize;\n+\n+      gfc_logical_kinds[i_index].kind = kind;\n+      gfc_logical_kinds[i_index].bit_size = bitsize;\n+\n+      i_index += 1;\n+    }\n+\n+  for (r_index = 0, mode = MIN_MODE_FLOAT; mode <= MAX_MODE_FLOAT; mode++)\n+    {\n+      const struct real_format *fmt = REAL_MODE_FORMAT (mode);\n+      int kind;\n+\n+      if (fmt == NULL)\n+\tcontinue;\n+      if (!targetm.scalar_mode_supported_p (mode))\n+\tcontinue;\n+\n+      /* Let the kind equal the precision divided by 8, rounding up.  Again,\n+\t this insulates the programmer from the underlying byte size.\n+\n+\t Also, it effectively deals with IEEE extended formats.  There, the\n+\t total size of the type may equal 16, but it's got 6 bytes of padding\n+\t and the increased size can get in the way of a real IEEE quad format\n+\t which may also be supported by the target.\n+\n+\t We round up so as to handle IA-64 __floatreg (RFmode), which is an\n+\t 82 bit type.  Not to be confused with __float80 (XFmode), which is\n+\t an 80 bit type also supported by IA-64.  So XFmode should come out\n+\t to be kind=10, and RFmode should come out to be kind=11.  Egads.  */\n+\n+      kind = (GET_MODE_PRECISION (mode) + 7) / 8;\n+\n+      if (kind == 4)\n+\tsaw_r4 = true;\n+      if (kind == 8)\n+\tsaw_r8 = true;\n+      if (kind == 16)\n+\tsaw_r16 = true;\n+\n+      /* Careful we don't stumble a wierd internal mode.  */\n+      if (r_index > 0 && gfc_real_kinds[r_index-1].kind == kind)\n+\tabort ();\n+      /* Or have too many modes for the allocated space.  */\n+      if (r_index == MAX_REAL_KINDS)\n+\tabort ();\n+\n+      gfc_real_kinds[r_index].kind = kind;\n+      gfc_real_kinds[r_index].radix = fmt->b;\n+      gfc_real_kinds[r_index].digits = fmt->p;\n+      gfc_real_kinds[r_index].min_exponent = fmt->emin;\n+      gfc_real_kinds[r_index].max_exponent = fmt->emax;\n+      r_index += 1;\n+    }\n+\n+  /* Choose the default integer kind.  We choose 4 unless the user\n+     directs us otherwise.  */\n+  if (gfc_option.i8)\n+    {\n+      if (!saw_i8)\n+\tfatal_error (\"integer kind=8 not available for -i8 option\");\n+      gfc_default_integer_kind_1 = 8;\n+    }\n+  else if (saw_i4)\n+    gfc_default_integer_kind_1 = 4;\n+  else\n+    gfc_default_integer_kind_1 = gfc_integer_kinds[i_index - 1].kind;\n+\n+  /* Choose the default real kind.  Again, we choose 4 when possible.  */\n+  if (gfc_option.r8)\n+    {\n+      if (!saw_r8)\n+\tfatal_error (\"real kind=8 not available for -r8 option\");\n+      gfc_default_real_kind_1 = 8;\n+    }\n+  else if (saw_r4)\n+    gfc_default_real_kind_1 = 4;\n+  else\n+    gfc_default_real_kind_1 = gfc_real_kinds[0].kind;\n+\n+  /* Choose the default double kind.  If -r8 is specified, we use kind=16,\n+     if it's available, otherwise we do not change anything.  */\n+  if (gfc_option.r8 && saw_r16)\n+    gfc_default_double_kind_1 = 16;\n+  else if (saw_r4 && saw_r8)\n+    gfc_default_double_kind_1 = 8;\n+  else\n+    {\n+      /* F95 14.6.3.1: A nonpointer scalar object of type double precision\n+\t real ... occupies two contiguous numeric storage units.\n+\n+\t Therefore we must be supplied a kind twice as large as we chose\n+\t for single precision.  There are loopholes, in that double\n+\t precision must *occupy* two storage units, though it doesn't have\n+\t to *use* two storage units.  Which means that you can make this\n+\t kind artificially wide by padding it.  But at present there are\n+\t no GCC targets for which a two-word type does not exist, so we\n+\t just let gfc_validate_kind abort and tell us if something breaks.  */\n+\n+      gfc_default_double_kind_1\n+\t= gfc_validate_kind (BT_REAL, gfc_default_real_kind_1 * 2, false);\n+    }\n+\n+  /* The default logical kind is constrained to be the same as the\n+     default integer kind.  Similarly with complex and real.  */\n+  gfc_default_logical_kind_1 = gfc_default_integer_kind_1;\n+  gfc_default_complex_kind_1 = gfc_default_real_kind_1;\n+\n+  /* Choose the smallest integer kind for our default character.  */\n+  gfc_default_character_kind_1 = gfc_integer_kinds[0].kind;\n+\n+  /* Choose the integer kind the same size as \"void*\" for our index kind.  */\n+  gfc_index_integer_kind = POINTER_SIZE / 8;\n+}\n+\n+/* ??? These functions should go away in favor of direct access to\n+   the relevant variables.  */\n+\n+int\n+gfc_default_integer_kind (void)\n+{\n+  return gfc_default_integer_kind_1;\n+}\n+\n+int\n+gfc_default_real_kind (void)\n+{\n+  return gfc_default_real_kind_1;\n+}\n+\n+int\n+gfc_default_double_kind (void)\n+{\n+  return gfc_default_double_kind_1;\n+}\n+\n+int\n+gfc_default_character_kind (void)\n+{\n+  return gfc_default_character_kind_1;\n+}\n+\n+int\n+gfc_default_logical_kind (void)\n+{\n+  return gfc_default_logical_kind_1;\n+}\n+\n+int\n+gfc_default_complex_kind (void)\n+{\n+  return gfc_default_complex_kind_1;\n+}\n+\n+/* Make sure that a valid kind is present.  Returns an index into the\n+   associated kinds array, -1 if the kind is not present.  */\n+\n+static int\n+validate_integer (int kind)\n+{\n+  int i;\n+\n+  for (i = 0; gfc_integer_kinds[i].kind != 0; i++)\n+    if (gfc_integer_kinds[i].kind == kind)\n+      return i;\n+\n+  return -1;\n+}\n+\n+static int\n+validate_real (int kind)\n+{\n+  int i;\n+\n+  for (i = 0; gfc_real_kinds[i].kind != 0; i++)\n+    if (gfc_real_kinds[i].kind == kind)\n+      return i;\n+\n+  return -1;\n+}\n+\n+static int\n+validate_logical (int kind)\n+{\n+  int i;\n+\n+  for (i = 0; gfc_logical_kinds[i].kind; i++)\n+    if (gfc_logical_kinds[i].kind == kind)\n+      return i;\n+\n+  return -1;\n+}\n+\n+static int\n+validate_character (int kind)\n+{\n+  return kind == gfc_default_character_kind_1 ? 0 : -1;\n+}\n+\n+/* Validate a kind given a basic type.  The return value is the same\n+   for the child functions, with -1 indicating nonexistence of the\n+   type.  If MAY_FAIL is false, then -1 is never returned, and we ICE.  */\n+\n+int\n+gfc_validate_kind (bt type, int kind, bool may_fail)\n+{\n+  int rc;\n+\n+  switch (type)\n+    {\n+    case BT_REAL:\t\t/* Fall through */\n+    case BT_COMPLEX:\n+      rc = validate_real (kind);\n+      break;\n+    case BT_INTEGER:\n+      rc = validate_integer (kind);\n+      break;\n+    case BT_LOGICAL:\n+      rc = validate_logical (kind);\n+      break;\n+    case BT_CHARACTER:\n+      rc = validate_character (kind);\n+      break;\n+\n+    default:\n+      gfc_internal_error (\"gfc_validate_kind(): Got bad type\");\n+    }\n+\n+  if (rc < 0 && !may_fail)\n+    gfc_internal_error (\"gfc_validate_kind(): Got bad kind\");\n+\n+  return rc;\n+}\n+\n+\n /* Create the backend type nodes. We map them to their\n    equivalent C type, at least for now.  We also give\n    names to the types here, and we push them in the\n@@ -148,7 +443,6 @@ gfc_init_types (void)\n   ppvoid_type_node = build_pointer_type (pvoid_type_node);\n   pchar_type_node = build_pointer_type (gfc_character1_type_node);\n \n-  gfc_index_integer_kind = TYPE_PRECISION (long_unsigned_type_node) / 8;\n   gfc_array_index_type = gfc_get_int_type (gfc_index_integer_kind);\n \n   /* The maximum array element size that can be handled is determined"}, {"sha": "4a6e59dcb87177d4d27581032d7450782daae808", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8e542ff89af945fa40ae42e4a7cfc6c91c3353/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=5e8e542ff89af945fa40ae42e4a7cfc6c91c3353", "patch": "@@ -105,6 +105,7 @@ extern GTY(()) tree pchar_type_node;\n void gfc_convert_function_code (gfc_namespace *);\n \n /* trans-types.c */\n+void gfc_init_kinds (void);\n void gfc_init_types (void);\n \n tree gfc_get_int_type (int);"}]}