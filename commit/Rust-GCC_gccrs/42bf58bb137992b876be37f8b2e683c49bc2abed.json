{"sha": "42bf58bb137992b876be37f8b2e683c49bc2abed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJiZjU4YmIxMzc5OTJiODc2YmUzN2Y4YjJlNjgzYzQ5YmMyYWJlZA==", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2019-09-03T20:04:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-09-03T20:04:32Z"}, "message": "rust-demangle.c (unescape): Remove.\n\n\t* rust-demangle.c (unescape): Remove.\n\t(parse_lower_hex_nibble): New function.\n\t(parse_legacy_escape): New function.\n\t(is_prefixed_hash): Use parse_lower_hex_nibble.\n\t(looks_like_rust): Use parse_legacy_escape.\n\t(rust_demangle_sym): Use parse_legacy_escape.\n\t* testsuite/rust-demangle-expected: Add 'llv$u6d$' test.\n\nFrom-SVN: r275353", "tree": {"sha": "ae44d285ea6fca8c341430ea1ca003cc1c4add31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae44d285ea6fca8c341430ea1ca003cc1c4add31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42bf58bb137992b876be37f8b2e683c49bc2abed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42bf58bb137992b876be37f8b2e683c49bc2abed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42bf58bb137992b876be37f8b2e683c49bc2abed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42bf58bb137992b876be37f8b2e683c49bc2abed/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f76ab159a4b86b8e4d74f40b8189994646d562f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f76ab159a4b86b8e4d74f40b8189994646d562f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f76ab159a4b86b8e4d74f40b8189994646d562f"}], "stats": {"total": 295, "additions": 148, "deletions": 147}, "files": [{"sha": "712c4fe55493d6270ff3644b18e620b2d0caa9d1", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42bf58bb137992b876be37f8b2e683c49bc2abed/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42bf58bb137992b876be37f8b2e683c49bc2abed/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=42bf58bb137992b876be37f8b2e683c49bc2abed", "patch": "@@ -1,3 +1,13 @@\n+2019-09-03  Eduard-Mihai Burtescu  <eddyb@lyken.rs>\n+\n+\t* rust-demangle.c (unescape): Remove.\n+\t(parse_lower_hex_nibble): New function.\n+\t(parse_legacy_escape): New function.\n+\t(is_prefixed_hash): Use parse_lower_hex_nibble.\n+\t(looks_like_rust): Use parse_legacy_escape.\n+\t(rust_demangle_sym): Use parse_legacy_escape.\n+\t* testsuite/rust-demangle-expected: Add 'llv$u6d$' test.\n+\n 2019-08-27  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/91478"}, {"sha": "da591902db11c6a73f23198303ea60e67aabeb33", "filename": "libiberty/rust-demangle.c", "status": "modified", "additions": 134, "deletions": 147, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42bf58bb137992b876be37f8b2e683c49bc2abed/libiberty%2Frust-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42bf58bb137992b876be37f8b2e683c49bc2abed/libiberty%2Frust-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frust-demangle.c?ref=42bf58bb137992b876be37f8b2e683c49bc2abed", "patch": "@@ -50,7 +50,7 @@ extern void *memset(void *s, int c, size_t n);\n #include \"rust-demangle.h\"\n \n \n-/* Mangled Rust symbols look like this:\n+/* Mangled (legacy) Rust symbols look like this:\n      _$LT$std..sys..fd..FileDesc$u20$as$u20$core..ops..Drop$GT$::drop::hc68340e1baa4987a\n \n    The original symbol is:\n@@ -74,16 +74,7 @@ extern void *memset(void *s, int c, size_t n);\n    \">\"  =>  $GT$\n    \"(\"  =>  $LP$\n    \")\"  =>  $RP$\n-   \" \"  =>  $u20$\n-   \"\\\"\" =>  $u22$\n-   \"'\"  =>  $u27$\n-   \"+\"  =>  $u2b$\n-   \";\"  =>  $u3b$\n-   \"[\"  =>  $u5b$\n-   \"]\"  =>  $u5d$\n-   \"{\"  =>  $u7b$\n-   \"}\"  =>  $u7d$\n-   \"~\"  =>  $u7e$\n+   \"\\u{XY}\"  =>  $uXY$\n \n    A double \"..\" means \"::\" and a single \".\" means \"-\".\n \n@@ -95,7 +86,8 @@ static const size_t hash_len = 16;\n \n static int is_prefixed_hash (const char *start);\n static int looks_like_rust (const char *sym, size_t len);\n-static int unescape (const char **in, char **out, const char *seq, char value);\n+static int parse_lower_hex_nibble (char nibble);\n+static char parse_legacy_escape (const char **in);\n \n /* INPUT: sym: symbol that has been through C++ (gnu v3) demangling\n \n@@ -149,20 +141,20 @@ is_prefixed_hash (const char *str)\n   const char *end;\n   char seen[16];\n   size_t i;\n-  int count;\n+  int count, nibble;\n \n   if (strncmp (str, hash_prefix, hash_prefix_len))\n     return 0;\n   str += hash_prefix_len;\n \n   memset (seen, 0, sizeof(seen));\n   for (end = str + hash_len; str < end; str++)\n-    if (*str >= '0' && *str <= '9')\n-      seen[*str - '0'] = 1;\n-    else if (*str >= 'a' && *str <= 'f')\n-      seen[*str - 'a' + 10] = 1;\n-    else\n-      return 0;\n+    {\n+      nibble = parse_lower_hex_nibble (*str);\n+      if (nibble < 0)\n+        return 0;\n+      seen[nibble] = 1;\n+    }\n \n   /* Count how many distinct digits seen */\n   count = 0;\n@@ -179,57 +171,17 @@ looks_like_rust (const char *str, size_t len)\n   const char *end = str + len;\n \n   while (str < end)\n-    switch (*str)\n-      {\n-      case '$':\n-\tif (!strncmp (str, \"$C$\", 3))\n-\t  str += 3;\n-\telse if (!strncmp (str, \"$SP$\", 4)\n-\t\t || !strncmp (str, \"$BP$\", 4)\n-\t\t || !strncmp (str, \"$RF$\", 4)\n-\t\t || !strncmp (str, \"$LT$\", 4)\n-\t\t || !strncmp (str, \"$GT$\", 4)\n-\t\t || !strncmp (str, \"$LP$\", 4)\n-\t\t || !strncmp (str, \"$RP$\", 4))\n-\t  str += 4;\n-\telse if (!strncmp (str, \"$u20$\", 5)\n-\t\t || !strncmp (str, \"$u22$\", 5)\n-\t\t || !strncmp (str, \"$u27$\", 5)\n-\t\t || !strncmp (str, \"$u2b$\", 5)\n-\t\t || !strncmp (str, \"$u3b$\", 5)\n-\t\t || !strncmp (str, \"$u5b$\", 5)\n-\t\t || !strncmp (str, \"$u5d$\", 5)\n-\t\t || !strncmp (str, \"$u7b$\", 5)\n-\t\t || !strncmp (str, \"$u7d$\", 5)\n-\t\t || !strncmp (str, \"$u7e$\", 5))\n-\t  str += 5;\n-\telse\n-\t  return 0;\n-\tbreak;\n-      case '.':\n-\t/* Do not allow three or more consecutive dots */\n-\tif (!strncmp (str, \"...\", 3))\n-\t  return 0;\n-\t/* Fall through */\n-      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-      case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n-      case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n-      case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n-      case 'y': case 'z':\n-      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n-      case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n-      case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n-      case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n-      case 'Y': case 'Z':\n-      case '0': case '1': case '2': case '3': case '4': case '5':\n-      case '6': case '7': case '8': case '9':\n-      case '_':\n-      case ':':\n-\tstr++;\n-\tbreak;\n-      default:\n-\treturn 0;\n-      }\n+    {\n+      if (*str == '$')\n+        {\n+          if (!parse_legacy_escape (&str))\n+            return 0;\n+        }\n+      else if (*str == '.' || *str == '_' || *str == ':' || ISALNUM (*str))\n+        str++;\n+      else\n+        return 0;\n+    }\n \n   return 1;\n }\n@@ -246,6 +198,7 @@ rust_demangle_sym (char *sym)\n   const char *in;\n   char *out;\n   const char *end;\n+  char unescaped;\n \n   if (!sym)\n     return;\n@@ -255,75 +208,49 @@ rust_demangle_sym (char *sym)\n   end = sym + strlen (sym) - (hash_prefix_len + hash_len);\n \n   while (in < end)\n-    switch (*in)\n-      {\n-      case '$':\n-\tif (!(unescape (&in, &out, \"$C$\", ',')\n-\t      || unescape (&in, &out, \"$SP$\", '@')\n-\t      || unescape (&in, &out, \"$BP$\", '*')\n-\t      || unescape (&in, &out, \"$RF$\", '&')\n-\t      || unescape (&in, &out, \"$LT$\", '<')\n-\t      || unescape (&in, &out, \"$GT$\", '>')\n-\t      || unescape (&in, &out, \"$LP$\", '(')\n-\t      || unescape (&in, &out, \"$RP$\", ')')\n-\t      || unescape (&in, &out, \"$u20$\", ' ')\n-\t      || unescape (&in, &out, \"$u22$\", '\\\"')\n-\t      || unescape (&in, &out, \"$u27$\", '\\'')\n-\t      || unescape (&in, &out, \"$u2b$\", '+')\n-\t      || unescape (&in, &out, \"$u3b$\", ';')\n-\t      || unescape (&in, &out, \"$u5b$\", '[')\n-\t      || unescape (&in, &out, \"$u5d$\", ']')\n-\t      || unescape (&in, &out, \"$u7b$\", '{')\n-\t      || unescape (&in, &out, \"$u7d$\", '}')\n-\t      || unescape (&in, &out, \"$u7e$\", '~'))) {\n-\t  /* unexpected escape sequence, not looks_like_rust. */\n-\t  goto fail;\n-\t}\n-\tbreak;\n-      case '_':\n-\t/* If this is the start of a path component and the next\n-\t   character is an escape sequence, ignore the underscore. The\n-\t   mangler inserts an underscore to make sure the path\n-\t   component begins with a XID_Start character. */\n-\tif ((in == sym || in[-1] == ':') && in[1] == '$')\n-\t  in++;\n-\telse\n-\t  *out++ = *in++;\n-\tbreak;\n-      case '.':\n-\tif (in[1] == '.')\n-\t  {\n-\t    /* \"..\" becomes \"::\" */\n-\t    *out++ = ':';\n-\t    *out++ = ':';\n-\t    in += 2;\n-\t  }\n-\telse\n-\t  {\n-\t    /* \".\" becomes \"-\" */\n-\t    *out++ = '-';\n-\t    in++;\n-\t  }\n-\tbreak;\n-      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-      case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n-      case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n-      case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n-      case 'y': case 'z':\n-      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n-      case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n-      case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n-      case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n-      case 'Y': case 'Z':\n-      case '0': case '1': case '2': case '3': case '4': case '5':\n-      case '6': case '7': case '8': case '9':\n-      case ':':\n-\t*out++ = *in++;\n-\tbreak;\n-      default:\n-\t/* unexpected character in symbol, not looks_like_rust.  */\n-\tgoto fail;\n-      }\n+    {\n+      if (*in == '$')\n+        {\n+          unescaped = parse_legacy_escape (&in);\n+          if (unescaped)\n+            *out++ = unescaped;\n+          else\n+            /* unexpected escape sequence, not looks_like_rust. */\n+            goto fail;\n+        }\n+      else if (*in == '_')\n+        {\n+          /* If this is the start of a path component and the next\n+             character is an escape sequence, ignore the underscore. The\n+             mangler inserts an underscore to make sure the path\n+             component begins with a XID_Start character. */\n+          if ((in == sym || in[-1] == ':') && in[1] == '$')\n+            in++;\n+          else\n+            *out++ = *in++;\n+        }\n+      else if (*in == '.')\n+        {\n+          if (in[1] == '.')\n+            {\n+              /* \"..\" becomes \"::\" */\n+              *out++ = ':';\n+              *out++ = ':';\n+              in += 2;\n+            }\n+          else\n+            {\n+              /* \".\" becomes \"-\" */\n+              *out++ = '-';\n+              in++;\n+            }\n+        }\n+      else if (*in == ':' || ISALNUM (*in))\n+        *out++ = *in++;\n+      else\n+        /* unexpected character in symbol, not looks_like_rust.  */\n+        goto fail;\n+    }\n   goto done;\n \n fail:\n@@ -332,18 +259,78 @@ rust_demangle_sym (char *sym)\n   *out = '\\0';\n }\n \n+/* Return a 0x0-0xf value if the char is 0-9a-f, and -1 otherwise. */\n static int\n-unescape (const char **in, char **out, const char *seq, char value)\n+parse_lower_hex_nibble (char nibble)\n {\n-  size_t len = strlen (seq);\n+  if ('0' <= nibble && nibble <= '9')\n+    return nibble - '0';\n+  if ('a' <= nibble && nibble <= 'f')\n+    return 0xa + (nibble - 'a');\n+  return -1;\n+}\n \n-  if (strncmp (*in, seq, len))\n-    return 0;\n+/* Return the unescaped character for a \"$...$\" escape, or 0 if invalid. */\n+static char\n+parse_legacy_escape (const char **in)\n+{\n+  char c = 0;\n+  const char *e;\n+  size_t escape_len = 0;\n+  int lo_nibble = -1, hi_nibble = -1;\n \n-  **out = value;\n+  if ((*in)[0] != '$')\n+    return 0;\n \n-  *in += len;\n-  *out += 1;\n+  e = *in + 1;\n+\n+  if (e[0] == 'C')\n+    {\n+      escape_len = 1;\n+\n+      c = ',';\n+    }\n+  else\n+    {\n+      escape_len = 2;\n+\n+      if (e[0] == 'S' && e[1] == 'P')\n+        c = '@';\n+      else if (e[0] == 'B' && e[1] == 'P')\n+        c = '*';\n+      else if (e[0] == 'R' && e[1] == 'F')\n+        c = '&';\n+      else if (e[0] == 'L' && e[1] == 'T')\n+        c = '<';\n+      else if (e[0] == 'G' && e[1] == 'T')\n+        c = '>';\n+      else if (e[0] == 'L' && e[1] == 'P')\n+        c = '(';\n+      else if (e[0] == 'R' && e[1] == 'P')\n+        c = ')';\n+      else if (e[0] == 'u')\n+        {\n+          escape_len = 3;\n+\n+          hi_nibble = parse_lower_hex_nibble (e[1]);\n+          if (hi_nibble < 0)\n+            return 0;\n+          lo_nibble = parse_lower_hex_nibble (e[2]);\n+          if (lo_nibble < 0)\n+            return 0;\n+\n+          /* Only allow non-control ASCII characters. */\n+          if (hi_nibble > 7)\n+            return 0;\n+          c = (hi_nibble << 4) | lo_nibble;\n+          if (c < 0x20)\n+            return 0;\n+        }\n+    }\n+\n+  if (!c || e[escape_len] != '$')\n+    return 0;\n \n-  return 1;\n+  *in += 2 + escape_len;\n+  return c;\n }"}, {"sha": "c3b03f9f02d01b0503e8c8a2fea5a11115a851f4", "filename": "libiberty/testsuite/rust-demangle-expected", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42bf58bb137992b876be37f8b2e683c49bc2abed/libiberty%2Ftestsuite%2Frust-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42bf58bb137992b876be37f8b2e683c49bc2abed/libiberty%2Ftestsuite%2Frust-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Frust-demangle-expected?ref=42bf58bb137992b876be37f8b2e683c49bc2abed", "patch": "@@ -159,3 +159,7 @@ _ZN68_$LT$core..nonzero..NonZero$LT$T$GT$$u20$as$u20$core..ops..Deref$GT$5deref1\n --format=rust\n _ZN63_$LT$core..ptr..Unique$LT$T$GT$$u20$as$u20$core..ops..Deref$GT$5deref17h19f2ad4920655e85E\n <core::ptr::Unique<T> as core::ops::Deref>::deref\n+#\n+--format=rust\n+_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17h059a991a004536adE\n+issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo"}]}