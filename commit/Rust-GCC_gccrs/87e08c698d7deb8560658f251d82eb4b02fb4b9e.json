{"sha": "87e08c698d7deb8560658f251d82eb4b02fb4b9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlMDhjNjk4ZDdkZWI4NTYwNjU4ZjI1MWQ4MmViNGIwMmZiNGI5ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-06T21:24:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-06T21:24:04Z"}, "message": "bitmap.c (bitmap_release_memory): Move adjacent to the allocation functions.\n\n        * bitmap.c (bitmap_release_memory): Move adjacent to the\n        allocation functions.\n        (bitmap_first_set_bit, bitmap_last_set_bit): Streamline knowing\n        the implementation.  Binary search for the set bit.\n        (bitmap_union_of_diff): Allocate the temporary on the stack\n        instead of using xmalloc.\n\nFrom-SVN: r43822", "tree": {"sha": "c8a9983bb6fed181d95eb9f6497dc559443ed420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8a9983bb6fed181d95eb9f6497dc559443ed420"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e08c698d7deb8560658f251d82eb4b02fb4b9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e08c698d7deb8560658f251d82eb4b02fb4b9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e08c698d7deb8560658f251d82eb4b02fb4b9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e08c698d7deb8560658f251d82eb4b02fb4b9e/comments", "author": null, "committer": null, "parents": [{"sha": "0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73"}], "stats": {"total": 191, "additions": 142, "deletions": 49}, "files": [{"sha": "fc7155a39056be9dffb7458d9bd820050e580aee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e08c698d7deb8560658f251d82eb4b02fb4b9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e08c698d7deb8560658f251d82eb4b02fb4b9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87e08c698d7deb8560658f251d82eb4b02fb4b9e", "patch": "@@ -1,3 +1,12 @@\n+2001-07-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* bitmap.c (bitmap_release_memory): Move adjacent to the\n+\tallocation functions.\n+\t(bitmap_first_set_bit, bitmap_last_set_bit): Streamline knowing\n+\tthe implementation.  Binary search for the set bit.\n+\t(bitmap_union_of_diff): Allocate the temporary on the stack\n+\tinstead of using xmalloc.\n+\n 2001-07-06  Richard Henderson  <rth@redhat.com>\n \n \t* genrecog.c (validate_pattern): Warn for constraints in"}, {"sha": "ee068c6f8a38c0b8f2b6d183080395ef7f640ca7", "filename": "gcc/bitmap.c", "status": "modified", "additions": 133, "deletions": 49, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e08c698d7deb8560658f251d82eb4b02fb4b9e/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e08c698d7deb8560658f251d82eb4b02fb4b9e/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=87e08c698d7deb8560658f251d82eb4b02fb4b9e", "patch": "@@ -135,6 +135,19 @@ bitmap_element_allocate ()\n   return element;\n }\n \n+/* Release any memory allocated by bitmaps.  */\n+\n+void\n+bitmap_release_memory ()\n+{\n+  bitmap_free = 0;\n+  if (bitmap_obstack_init)\n+    {\n+      bitmap_obstack_init = FALSE;\n+      obstack_free (&bitmap_obstack, NULL);\n+    }\n+}\n+\n /* Return nonzero if all bits in an element are zero.  */\n \n static INLINE int\n@@ -384,6 +397,107 @@ bitmap_bit_p (head, bit)\n   return (ptr->bits[word_num] >> bit_num) & 1;\n }\n \f\n+\n+int \n+bitmap_first_set_bit (a)\n+     bitmap a;\n+{\n+  bitmap_element *ptr = a->first;\n+  unsigned HOST_WIDE_INT word;\n+  unsigned word_num, bit_num;\n+\n+  if (ptr == NULL)\n+    return -1;\n+\n+#if BITMAP_ELEMENT_WORDS == 2\n+  word_num = 0, word = ptr->bits[0];\n+  if (word == 0)\n+    word_num = 1, word = ptr->bits[1];\n+#else\n+  for (word_num = 0; word_num < BITMAP_ELEMENT_WORDS; ++word_num)\n+    if ((word = ptr->bits[word_num]) != 0)\n+      break;\n+#endif\n+\n+  /* Binary search for the first set bit.  */\n+  /* ??? It'd be nice to know if ffs or ffsl was available.  */\n+\n+  bit_num = 0;\n+  word = word & -word;\n+\n+#if HOST_BITS_PER_WIDE_INT > 64\n+ #error \"Fill out the table.\"\n+#endif\n+#if HOST_BITS_PER_WIDE_INT > 32\n+  if ((word & 0xffffffff) == 0)\n+    word >>= 32, bit_num += 32;\n+#endif\n+  if ((word & 0xffff) == 0)\n+    word >>= 16, bit_num += 16;\n+  if ((word & 0xff) == 0)\n+    word >>= 8, bit_num += 8;\n+  if (word & 0xf0)\n+    bit_num += 4;\n+  if (word & 0xcc)\n+    bit_num += 2;\n+  if (word & 0xaa)\n+    bit_num += 1;\n+\n+  return (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n+\t  + word_num * HOST_BITS_PER_WIDE_INT\n+\t  + bit_num);\n+}\n+\n+int \n+bitmap_last_set_bit (a)\n+     bitmap a;\n+{\n+  bitmap_element *ptr = a->first;\n+  unsigned HOST_WIDE_INT word;\n+  unsigned word_num, bit_num;\n+\n+  if (ptr == NULL)\n+    return -1;\n+\n+  while (ptr->next != NULL)\n+    ptr = ptr->next;\n+\n+#if BITMAP_ELEMENT_WORDS == 2\n+  word_num = 1, word = ptr->bits[1];\n+  if (word == 0)\n+    word_num = 0, word = ptr->bits[0];\n+#else\n+  for (word_num = BITMAP_ELEMENT_WORDS; word_num-- > 0; )\n+    if ((word = ptr->bits[word_num]) != 0)\n+      break;\n+#endif\n+\n+  /* Binary search for the last set bit.  */\n+\n+  bit_num = 0;\n+#if HOST_BITS_PER_WIDE_INT > 64\n+ #error \"Fill out the table.\"\n+#endif\n+#if HOST_BITS_PER_WIDE_INT > 32\n+  if (word & ~ (unsigned HOST_WIDE_INT) 0xffffffff)\n+    word >>= 32, bit_num += 32;\n+#endif\n+  if (word & 0xffff0000)\n+    word >>= 16, bit_num += 16;\n+  if (word & 0xff00)\n+    word >>= 8, bit_num += 8;\n+  if (word & 0xf0)\n+    word >>= 4, bit_num += 4;\n+  if (word & 0xc)\n+    word >>= 2, bit_num += 2;\n+  if (word & 0x2)\n+    word >>= 1, bit_num += 1;\n+\n+  return (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n+\t  + word_num * HOST_BITS_PER_WIDE_INT\n+\t  + bit_num);\n+}\n+\f\n /* Store in bitmap TO the result of combining bitmap FROM1 and FROM2 using\n    a specific bit manipulation.  Return true if TO changes.  */\n \n@@ -576,6 +690,25 @@ bitmap_ior_and_compl (to, from1, from2)\n   bitmap_operation (to, to, &tmp, BITMAP_IOR);\n   bitmap_clear (&tmp);\n }\n+\n+int\n+bitmap_union_of_diff (dst, a, b, c)\n+     bitmap dst;\n+     bitmap a;\n+     bitmap b;\n+     bitmap c;\n+{\n+  bitmap_head tmp;\n+  int changed;\n+\n+  tmp.first = tmp.current = 0;\n+\n+  bitmap_operation (&tmp, b, c, BITMAP_AND_COMPL);\n+  changed = bitmap_operation (dst, &tmp, a, BITMAP_IOR);\n+  bitmap_clear (&tmp);\n+\n+  return changed;\n+}\n \f\n /* Initialize a bitmap header.  */\n \n@@ -665,52 +798,3 @@ bitmap_print (file, head, prefix, suffix)\n \t\t\t    });\n   fputs (suffix, file);\n }\n-\f\n-/* Release any memory allocated by bitmaps.  */\n-\n-void\n-bitmap_release_memory ()\n-{\n-  bitmap_free = 0;\n-  if (bitmap_obstack_init)\n-    {\n-      bitmap_obstack_init = FALSE;\n-      obstack_free (&bitmap_obstack, NULL);\n-    }\n-}\n-\n-int\n-bitmap_union_of_diff (dst, a, b, c)\n-     bitmap dst;\n-     bitmap a;\n-     bitmap b;\n-     bitmap c;\n-{\n-  int changed = 0;\n-  bitmap temp = BITMAP_XMALLOC ();\n-  \n-  bitmap_operation (temp, b, c, BITMAP_AND_COMPL);\n-  changed = bitmap_operation (dst, temp, a, BITMAP_IOR);\n-  BITMAP_XFREE (temp);\n-  return changed;\n-}\n-\n-int \n-bitmap_first_set_bit (a)\n-     bitmap a;\n-{\n-  int i;\n-  EXECUTE_IF_SET_IN_BITMAP (a, 0, i, return i;);\n-  return -1;\n-}\n-\n-int \n-bitmap_last_set_bit (a)\n-     bitmap a;\n-{\n-  int i;\n-  EXECUTE_IF_SET_IN_BITMAP (a, 0, i, ;);\n-  if (bitmap_bit_p (a, i))\n-    return i;\n-  return -1;\n-}"}]}