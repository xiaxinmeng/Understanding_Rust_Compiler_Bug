{"sha": "4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFjMmJiYmQwNTcxNTllNDRjYmU4ZDAzNWViMGI2ZmM1MzZiYzQwYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T11:02:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T11:02:42Z"}, "message": "[multiple changes]\n\n2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb Last_Aggregate_Assignment is now Node 30.\n\t(Last_Aggregate_Assignment): Include\n\tconstants in the assertion. Update the underlying node.\n\t(Set_Last_Aggregate_Assignment): Include constants in the\n\tassertion. Update the underlying node.\t(Write_Field11_Name):\n\tRemove the entry for Last_Aggregate_Assignment.\n\t(Write_Field30_Name): Add an entry for Last_Aggregate_Assignment.\n\t* einfo.ads Update the node designation and usage of attribute\n\tLast_Aggregate_Assignment.\n\t* exp_aggr.adb (Expand_Array_Aggregate): Store the last\n\tassignment statement used to initialize a controlled object.\n\t(Late_Expansion): Store the last assignment statement used to\n\tinitialize a controlled record or an array of controlled objects.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Default\n\tinitialization of objects is now performed in a separate routine.\n\t(Default_Initialize_Object): New routine.\n\t* exp_ch7.adb (Build_BIP_Cleanup_Stmts): Add formal parameter\n\tObj_Id. Update the comment on usage.\n\t(Find_Last_Init): Remove formal parameter Typ. Update comment on usage.\n\tReimplement the logic.\t(Find_Last_Init_In_Block): New routine.\n\t(Is_Init_Call): Add formal parameter Init_Typ. Update the\n\tcomment on usage.  Account for the type init proc when trying\n\tto determine whether a statement is an initialization call.\n\t(Make_Adjust_Call): Rename formal parameter For_Parent to\n\tSkip_Self. Update all occurrences of For_Parent. Account for\n\tnon-tagged types. Update the call to Make_Call.\n\t(Make_Call): Rename formal parameter For_Parent to Skip_Self. Update\n\tcomment on usage. Update all occurrences of For_Parent.\n\t(Make_Final_Call): Rename formal parameter For_Parent to\n\tSkip_Self. Update all occurrences of For_Parent. Account\n\tfor non-tagged types. Update the call to Make_Call.\n\t(Process_Object_Declaration): Most variables and constants are\n\tnow local to the routine.\n\t* exp_ch7.ads (Make_Adjust_Call): Rename formal parameter\n\tFor_Parent to Skip_Self. Update the comment on usage.\n\t(Make_Final_Call): Rename formal parameter For_Parent to\n\tSkip_Self. Update the comment on usage.\n\n2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch9.adb (Analyze_Requeue): The entry being referenced\n\tcan be a procedure that is implemented by entry, and have a\n\tformal that is a synchronized interface.  It does not have to\n\tbe declared as a protected operation.\n\nFrom-SVN: r212814", "tree": {"sha": "03c3c732e2769e977e4aa9e687237e1734f097e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03c3c732e2769e977e4aa9e687237e1734f097e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/comments", "author": null, "committer": null, "parents": [{"sha": "2941bf7dabfa03f232316f2c29fa7e13328b09ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2941bf7dabfa03f232316f2c29fa7e13328b09ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2941bf7dabfa03f232316f2c29fa7e13328b09ba"}], "stats": {"total": 1020, "additions": 642, "deletions": 378}, "files": [{"sha": "ac04798710c2f585cadee5b2dab3ccf9eddc8b1a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -1,3 +1,50 @@\n+2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb Last_Aggregate_Assignment is now Node 30.\n+\t(Last_Aggregate_Assignment): Include\n+\tconstants in the assertion. Update the underlying node.\n+\t(Set_Last_Aggregate_Assignment): Include constants in the\n+\tassertion. Update the underlying node.\t(Write_Field11_Name):\n+\tRemove the entry for Last_Aggregate_Assignment.\n+\t(Write_Field30_Name): Add an entry for Last_Aggregate_Assignment.\n+\t* einfo.ads Update the node designation and usage of attribute\n+\tLast_Aggregate_Assignment.\n+\t* exp_aggr.adb (Expand_Array_Aggregate): Store the last\n+\tassignment statement used to initialize a controlled object.\n+\t(Late_Expansion): Store the last assignment statement used to\n+\tinitialize a controlled record or an array of controlled objects.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Default\n+\tinitialization of objects is now performed in a separate routine.\n+\t(Default_Initialize_Object): New routine.\n+\t* exp_ch7.adb (Build_BIP_Cleanup_Stmts): Add formal parameter\n+\tObj_Id. Update the comment on usage.\n+\t(Find_Last_Init): Remove formal parameter Typ. Update comment on usage.\n+\tReimplement the logic.\t(Find_Last_Init_In_Block): New routine.\n+\t(Is_Init_Call): Add formal parameter Init_Typ. Update the\n+\tcomment on usage.  Account for the type init proc when trying\n+\tto determine whether a statement is an initialization call.\n+\t(Make_Adjust_Call): Rename formal parameter For_Parent to\n+\tSkip_Self. Update all occurrences of For_Parent. Account for\n+\tnon-tagged types. Update the call to Make_Call.\n+\t(Make_Call): Rename formal parameter For_Parent to Skip_Self. Update\n+\tcomment on usage. Update all occurrences of For_Parent.\n+\t(Make_Final_Call): Rename formal parameter For_Parent to\n+\tSkip_Self. Update all occurrences of For_Parent. Account\n+\tfor non-tagged types. Update the call to Make_Call.\n+\t(Process_Object_Declaration): Most variables and constants are\n+\tnow local to the routine.\n+\t* exp_ch7.ads (Make_Adjust_Call): Rename formal parameter\n+\tFor_Parent to Skip_Self. Update the comment on usage.\n+\t(Make_Final_Call): Rename formal parameter For_Parent to\n+\tSkip_Self. Update the comment on usage.\n+\n+2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch9.adb (Analyze_Requeue): The entry being referenced\n+\tcan be a procedure that is implemented by entry, and have a\n+\tformal that is a synchronized interface.  It does not have to\n+\tbe declared as a protected operation.\n+\n 2014-07-18  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Remove mention of obsolete attributes"}, {"sha": "634d92acaeab3cbd172928ef9d2b31a10dd2fa5b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -101,7 +101,6 @@ package body Einfo is\n    --    Entry_Component                 Node11\n    --    Enumeration_Pos                 Uint11\n    --    Generic_Homonym                 Node11\n-   --    Last_Aggregate_Assignment       Node11\n    --    Protected_Body_Subprogram       Node11\n    --    Block_Node                      Node11\n \n@@ -246,6 +245,7 @@ package body Einfo is\n    --    Subprograms_For_Type            Node29\n \n    --    Corresponding_Equality          Node30\n+   --    Last_Aggregate_Assignment       Node30\n    --    Static_Initialization           Node30\n \n    --    Thunk_Entity                    Node31\n@@ -2433,8 +2433,8 @@ package body Einfo is\n \n    function Last_Aggregate_Assignment (Id : E) return N is\n    begin\n-      pragma Assert (Ekind (Id) = E_Variable);\n-      return Node11 (Id);\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      return Node30 (Id);\n    end Last_Aggregate_Assignment;\n \n    function Last_Assignment (Id : E) return N is\n@@ -5195,8 +5195,8 @@ package body Einfo is\n \n    procedure Set_Last_Aggregate_Assignment (Id : E; V : N) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Variable);\n-      Set_Node11 (Id, V);\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      Set_Node30 (Id, V);\n    end Set_Last_Aggregate_Assignment;\n \n    procedure Set_Last_Assignment (Id : E; V : N) is\n@@ -8727,9 +8727,6 @@ package body Einfo is\n          when E_Generic_Package                            =>\n             Write_Str (\"Generic_Homonym\");\n \n-         when E_Variable                                   =>\n-            Write_Str (\"Last_Aggregate_Assignment\");\n-\n          when E_Function                                   |\n               E_Procedure                                  |\n               E_Entry                                      |\n@@ -9526,6 +9523,10 @@ package body Einfo is\n          when E_Function                                   =>\n             Write_Str (\"Corresponding_Equality\");\n \n+         when E_Constant                                   |\n+              E_Variable                                   =>\n+            Write_Str (\"Last_Aggregate_Assignment\");\n+\n          when E_Procedure                                  =>\n             Write_Str (\"Static_Initialization\");\n "}, {"sha": "3422ac0455c76e30c730f581dca0796a14660dec", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -3068,11 +3068,11 @@ package Einfo is\n --       initialization, it may or may not be set if the type does have\n --       preelaborable initialization.\n \n---    Last_Aggregate_Assignment (Node11)\n---       Applies to controlled variables initialized by an aggregate. Points to\n---       the last statement associated with the expansion of the aggregate. The\n---       attribute is used by the finalization machinery when marking an object\n---       as successfully initialized.\n+--    Last_Aggregate_Assignment (Node30)\n+--       Applies to controlled constants and variables initialized by an\n+--       aggregate. Points to the last statement associated with the expansion\n+--       of the aggregate. The attribute is used by the finalization machinery\n+--       when marking an object as successfully initialized.\n \n --    Last_Assignment (Node26)\n --       Defined in entities for variables, and OUT or IN OUT formals. Set for\n@@ -5412,6 +5412,7 @@ package Einfo is\n    --    Related_Type                        (Node27)   (constants only)\n    --    Initialization_Statements           (Node28)\n    --    BIP_Initialization_Call             (Node29)\n+   --    Last_Aggregate_Assignment           (Node30)\n    --    Linker_Section_Pragma               (Node33)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n@@ -6102,7 +6103,6 @@ package Einfo is\n    --    Hiding_Loop_Variable                (Node8)\n    --    Current_Value                       (Node9)\n    --    Encapsulating_State                 (Node10)\n-   --    Last_Aggregate_Assignment           (Node11)\n    --    Esize                               (Uint12)\n    --    Extra_Accessibility                 (Node13)\n    --    Alignment                           (Uint14)\n@@ -6121,6 +6121,7 @@ package Einfo is\n    --    Related_Type                        (Node27)\n    --    Initialization_Statements           (Node28)\n    --    BIP_Initialization_Call             (Node29)\n+   --    Last_Aggregate_Assignment           (Node30)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Has_Alignment_Clause                (Flag46)"}, {"sha": "de784b2daf9c6757e2e85e09738f7f46ec1e865a", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -75,6 +75,15 @@ package body Exp_Aggr is\n    type Case_Table_Type is array (Nat range <>) of Case_Bounds;\n    --  Table type used by Check_Case_Choices procedure\n \n+   procedure Collect_Initialization_Statements\n+     (Obj        : Entity_Id;\n+      N          : Node_Id;\n+      Node_After : Node_Id);\n+   --  If Obj is not frozen, collect actions inserted after N until, but not\n+   --  including, Node_After, for initialization of Obj, and move them to an\n+   --  expression with actions, which becomes the Initialization_Statements for\n+   --  Obj.\n+\n    function Has_Default_Init_Comps (N : Node_Id) return Boolean;\n    --  N is an aggregate (record or array). Checks the presence of default\n    --  initialization (<>) in any component (Ada 2005: AI-287).\n@@ -103,15 +112,6 @@ package body Exp_Aggr is\n    --  statement of variant part will usually be small and probably in near\n    --  sorted order.\n \n-   procedure Collect_Initialization_Statements\n-     (Obj        : Entity_Id;\n-      N          : Node_Id;\n-      Node_After : Node_Id);\n-   --  If Obj is not frozen, collect actions inserted after N until, but not\n-   --  including, Node_After, for initialization of Obj, and move them to an\n-   --  expression with actions, which becomes the Initialization_Statements for\n-   --  Obj.\n-\n    ------------------------------------------------------\n    -- Local subprograms for Record Aggregate Expansion --\n    ------------------------------------------------------\n@@ -5233,6 +5233,19 @@ package body Exp_Aggr is\n              Index       => First_Index (Typ),\n              Into        => Target,\n              Scalar_Comp => Is_Scalar_Type (Ctyp));\n+\n+         --  Save the last assignment statement associated with the aggregate\n+         --  when building a controlled object. This reference is utilized by\n+         --  the finalization machinery when marking an object as successfully\n+         --  initialized.\n+\n+         if Needs_Finalization (Typ)\n+           and then Is_Entity_Name (Target)\n+           and then Present (Entity (Target))\n+           and then Ekind_In (Entity (Target), E_Constant, E_Variable)\n+         then\n+            Set_Last_Aggregate_Assignment (Entity (Target), Last (Aggr_Code));\n+         end if;\n       end;\n \n       --  If the aggregate is the expression in a declaration, the expanded\n@@ -6210,23 +6223,8 @@ package body Exp_Aggr is\n       if Is_Record_Type (Etype (N)) then\n          Aggr_Code := Build_Record_Aggr_Code (N, Typ, Target);\n \n-         --  Save the last assignment statement associated with the aggregate\n-         --  when building a controlled object. This reference is utilized by\n-         --  the finalization machinery when marking an object as successfully\n-         --  initialized.\n-\n-         if Needs_Finalization (Typ)\n-           and then Is_Entity_Name (Target)\n-           and then Present (Entity (Target))\n-           and then Ekind (Entity (Target)) = E_Variable\n-         then\n-            Set_Last_Aggregate_Assignment (Entity (Target), Last (Aggr_Code));\n-         end if;\n-\n-         return Aggr_Code;\n-\n       else pragma Assert (Is_Array_Type (Etype (N)));\n-         return\n+         Aggr_Code :=\n            Build_Array_Aggr_Code\n              (N           => N,\n               Ctype       => Component_Type (Etype (N)),\n@@ -6235,6 +6233,21 @@ package body Exp_Aggr is\n               Scalar_Comp => Is_Scalar_Type (Component_Type (Typ)),\n               Indexes     => No_List);\n       end if;\n+\n+      --  Save the last assignment statement associated with the aggregate\n+      --  when building a controlled object. This reference is utilized by\n+      --  the finalization machinery when marking an object as successfully\n+      --  initialized.\n+\n+      if Needs_Finalization (Typ)\n+        and then Is_Entity_Name (Target)\n+        and then Present (Entity (Target))\n+        and then Ekind_In (Entity (Target), E_Constant, E_Variable)\n+      then\n+         Set_Last_Aggregate_Assignment (Entity (Target), Last (Aggr_Code));\n+      end if;\n+\n+      return Aggr_Code;\n    end Late_Expansion;\n \n    ----------------------------------"}, {"sha": "160cfea761f4f1b75dc5d7dd439772936d0694c8", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 279, "deletions": 163, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -2623,9 +2623,8 @@ package body Exp_Ch3 is\n \n                    Statements => New_List (\n                      Make_Procedure_Call_Statement (Loc,\n-                       Name =>\n+                       Name                   =>\n                          New_Occurrence_Of (Local_DF_Id, Loc),\n-\n                        Parameter_Associations => New_List (\n                          Make_Identifier (Loc, Name_uInit),\n                          New_Occurrence_Of (Standard_False, Loc))),\n@@ -4857,20 +4856,16 @@ package body Exp_Ch3 is\n       Typ      : constant Entity_Id  := Etype (Def_Id);\n       Base_Typ : constant Entity_Id  := Base_Type (Typ);\n       Expr_Q   : Node_Id;\n-      Id_Ref   : Node_Id;\n-      New_Ref  : Node_Id;\n-\n-      Init_After : Node_Id := N;\n-      --  Node after which the init proc call is to be inserted. This is\n-      --  normally N, except for the case of a shared passive variable, in\n-      --  which case the init proc call must be inserted only after the bodies\n-      --  of the shared variable procedures have been seen.\n \n       function Build_Equivalent_Aggregate return Boolean;\n       --  If the object has a constrained discriminated type and no initial\n       --  value, it may be possible to build an equivalent aggregate instead,\n       --  and prevent an actual call to the initialization procedure.\n \n+      procedure Default_Initialize_Object (After : Node_Id);\n+      --  Generate all default initialization actions for object Def_Id. Any\n+      --  new code is inserted after node After.\n+\n       function Rewrite_As_Renaming return Boolean;\n       --  Indicate whether to rewrite a declaration with initialization into an\n       --  object renaming declaration (see below).\n@@ -4911,11 +4906,10 @@ package body Exp_Ch3 is\n          end if;\n \n          if Ekind (Current_Scope) = E_Package\n-          and then\n-            (Restriction_Active (No_Elaboration_Code)\n-              or else Is_Preelaborated (Current_Scope))\n+           and then\n+             (Restriction_Active (No_Elaboration_Code)\n+               or else Is_Preelaborated (Current_Scope))\n          then\n-\n             --  Building a static aggregate is possible if the discriminants\n             --  have static values and the other components have static\n             --  defaults or none.\n@@ -5005,6 +4999,263 @@ package body Exp_Ch3 is\n          end if;\n       end Build_Equivalent_Aggregate;\n \n+      -------------------------------\n+      -- Default_Initialize_Object --\n+      -------------------------------\n+\n+      procedure Default_Initialize_Object (After : Node_Id) is\n+         function New_Object_Reference return Node_Id;\n+         --  Return a new reference to Def_Id with attributes Assignment_OK and\n+         --  Must_Not_Freeze already set.\n+\n+         --------------------------\n+         -- New_Object_Reference --\n+         --------------------------\n+\n+         function New_Object_Reference return Node_Id is\n+            Obj_Ref : constant Node_Id := New_Occurrence_Of (Def_Id, Loc);\n+\n+         begin\n+            --  The call to the type init proc or [Deep_]Finalize must not\n+            --  freeze the related object as the call is internally generated.\n+            --  This way legal rep clauses that apply to the object will not be\n+            --  flagged. Note that the initialization call may be removed if\n+            --  pragma Import is encountered or moved to the freeze actions of\n+            --  the object because of an address clause.\n+\n+            Set_Assignment_OK   (Obj_Ref);\n+            Set_Must_Not_Freeze (Obj_Ref);\n+\n+            return Obj_Ref;\n+         end New_Object_Reference;\n+\n+         --  Local variables\n+\n+         Abrt_HSS   : Node_Id;\n+         Abrt_Id    : Entity_Id;\n+         Abrt_Stmts : List_Id;\n+         Aggr_Init  : Node_Id;\n+         Comp_Init  : List_Id := No_List;\n+         Fin_Call   : Node_Id;\n+         Fin_Stmts  : List_Id := No_List;\n+         Obj_Init   : Node_Id := Empty;\n+         Obj_Ref    : Node_Id;\n+\n+      --  Start of processing for Default_Initialize_Object\n+\n+      begin\n+         --  Step 1: Initialize the object\n+\n+         if Needs_Finalization (Typ) and then not No_Initialization (N) then\n+            Obj_Init :=\n+              Make_Init_Call\n+                (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                 Typ     => Typ);\n+         end if;\n+\n+         --  Step 2: Initialize the components of the object\n+\n+         --  Do not initialize the components if their initialization is\n+         --  prohibited or the type represents a value type in a .NET VM.\n+\n+         if Has_Non_Null_Base_Init_Proc (Typ)\n+           and then not No_Initialization (N)\n+           and then not Initialization_Suppressed (Typ)\n+           and then not Is_Value_Type (Typ)\n+         then\n+            --  Do not initialize the components if No_Default_Initialization\n+            --  applies as the the actual restriction check will occur later\n+            --  when the object is frozen as it is not known yet whether the\n+            --  object is imported or not.\n+\n+            if not Restriction_Active (No_Default_Initialization) then\n+\n+               --  If the values of the components are compile-time known, use\n+               --  their prebuilt aggregate form directly.\n+\n+               Aggr_Init := Static_Initialization (Base_Init_Proc (Typ));\n+\n+               if Present (Aggr_Init) then\n+                  Set_Expression\n+                    (N, New_Copy_Tree (Aggr_Init, New_Scope => Current_Scope));\n+\n+               --  If type has discriminants, try to build an equivalent\n+               --  aggregate using discriminant values from the declaration.\n+               --  This is a useful optimization, in particular if restriction\n+               --  No_Elaboration_Code is active.\n+\n+               elsif Build_Equivalent_Aggregate then\n+                  null;\n+\n+               --  Otherwise invoke the type init proc\n+\n+               else\n+                  Obj_Ref := New_Object_Reference;\n+\n+                  if Comes_From_Source (Def_Id) then\n+                     Initialization_Warning (Obj_Ref);\n+                  end if;\n+\n+                  Comp_Init := Build_Initialization_Call (Loc, Obj_Ref, Typ);\n+               end if;\n+            end if;\n+\n+         --  Provide a default value if the object needs simple initialization\n+         --  and does not already have an initial value. A generated temporary\n+         --  do not require initialization because it will be assigned later.\n+\n+         elsif Needs_Simple_Initialization\n+                 (Typ, Initialize_Scalars\n+                         and then not Has_Following_Address_Clause (N))\n+           and then not Is_Internal (Def_Id)\n+           and then not Has_Init_Expression (N)\n+         then\n+            Set_No_Initialization (N, False);\n+            Set_Expression (N, Get_Simple_Init_Val (Typ, N, Esize (Def_Id)));\n+            Analyze_And_Resolve (Expression (N), Typ);\n+         end if;\n+\n+         --  Step 3: Add partial finalization and abort actions, generate:\n+\n+         --    Type_Init_Proc (Obj);\n+         --    begin\n+         --       Deep_Initialize (Obj);\n+         --    exception\n+         --       when others =>\n+         --          Deep_Finalize (Obj, Self => False);\n+         --          raise;\n+         --    end;\n+\n+         --  Step 3a: Build the finalization block (if applicable)\n+\n+         --  The finalization block is required when both the object and its\n+         --  controlled components are to be initialized. The block finalizes\n+         --  the components if the object initialization fails.\n+\n+         if Has_Controlled_Component (Typ)\n+           and then Present (Comp_Init)\n+           and then Present (Obj_Init)\n+           and then not Restriction_Active (No_Exception_Propagation)\n+         then\n+            --  Generate:\n+            --    Type_Init_Proc (Obj);\n+\n+            Fin_Stmts := Comp_Init;\n+\n+            --  Generate:\n+            --    begin\n+            --       Deep_Initialize (Obj);\n+            --    exception\n+            --       when others =>\n+            --          Deep_Finalize (Obj, Self => False);\n+            --          raise;\n+            --    end;\n+\n+            Fin_Call :=\n+              Make_Final_Call\n+                (Obj_Ref   => New_Object_Reference,\n+                 Typ       => Typ,\n+                 Skip_Self => True);\n+\n+            if Present (Fin_Call) then\n+\n+               --  Do not emit warnings related to the elaboration order when a\n+               --  controlled object is declared before the body of Finalize is\n+               --  seen.\n+\n+               Set_No_Elaboration_Check (Fin_Call);\n+\n+               Append_To (Fin_Stmts,\n+                 Make_Block_Statement (Loc,\n+                   Declarations               => No_List,\n+\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements         => New_List (Obj_Init),\n+\n+                       Exception_Handlers => New_List (\n+                         Make_Exception_Handler (Loc,\n+                           Exception_Choices => New_List (\n+                             Make_Others_Choice (Loc)),\n+\n+                           Statements        => New_List (\n+                             Fin_Call,\n+                             Make_Raise_Statement (Loc)))))));\n+            end if;\n+\n+         --  Finalization is not required, the initialization calls are passed\n+         --  to the abort block building circuitry, generate:\n+\n+         --    Type_Init_Proc (Obj);\n+         --    Deep_Initialize (Obj);\n+\n+         else\n+            if Present (Comp_Init) then\n+               Fin_Stmts := Comp_Init;\n+            end if;\n+\n+            if Present (Obj_Init) then\n+               if No (Fin_Stmts) then\n+                  Fin_Stmts := New_List;\n+               end if;\n+\n+               Append_To (Fin_Stmts, Obj_Init);\n+            end if;\n+         end if;\n+\n+         --  Step 3b: Build the abort block (if applicable)\n+\n+         --  The abort block is required when aborts are allowed and there is\n+         --  at least one initialization call that needs protection.\n+\n+         if Abort_Allowed\n+           and then Present (Comp_Init)\n+           and then Present (Obj_Init)\n+         then\n+            --  Generate:\n+            --    Abort_Defer;\n+\n+            Prepend_To (Fin_Stmts, Build_Runtime_Call (Loc, RE_Abort_Defer));\n+\n+            --  Generate:\n+            --    begin\n+            --       Abort_Defer;\n+            --       <finalization statements>\n+            --    at end\n+            --       Abort_Undefer_Direct;\n+            --    end;\n+\n+            Abrt_Id := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n+            Set_Etype (Abrt_Id, Standard_Void_Type);\n+            Set_Scope (Abrt_Id, Current_Scope);\n+\n+            Abrt_HSS :=\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements  => Fin_Stmts,\n+                At_End_Proc =>\n+                  New_Occurrence_Of (RTE (RE_Abort_Undefer_Direct), Loc));\n+\n+            Abrt_Stmts := New_List (\n+              Make_Block_Statement (Loc,\n+                Identifier                 => New_Occurrence_Of (Abrt_Id, Loc),\n+                Declarations               => No_List,\n+                Handled_Statement_Sequence => Abrt_HSS));\n+\n+            Expand_At_End_Handler (Abrt_HSS, Abrt_Id);\n+\n+         --  Abort is not required, the construct from Step 3a is to be added\n+         --  in the tree (either finalization block or single initialization\n+         --  call).\n+\n+         else\n+            Abrt_Stmts := Fin_Stmts;\n+         end if;\n+\n+         --  Step 4: Insert the whole initialization sequence into the tree\n+\n+         Insert_Actions_After (After, Abrt_Stmts);\n+      end Default_Initialize_Object;\n+\n       -------------------------\n       -- Rewrite_As_Renaming --\n       -------------------------\n@@ -5018,6 +5269,17 @@ package body Exp_Ch3 is\n            and then Is_Entity_Name (Obj_Def);\n       end Rewrite_As_Renaming;\n \n+      --  Local variables\n+\n+      Id_Ref  : Node_Id;\n+      New_Ref : Node_Id;\n+\n+      Init_After : Node_Id := N;\n+      --  Node after which the initialization actions are to be inserted. This\n+      --  is normally N, except for the case of a shared passive variable, in\n+      --  which case the init proc call must be inserted only after the bodies\n+      --  of the shared variable procedures have been seen.\n+\n    --  Start of processing for Expand_N_Object_Declaration\n \n    begin\n@@ -5118,153 +5380,7 @@ package body Exp_Ch3 is\n               Make_Invariant_Call (New_Occurrence_Of (Def_Id, Loc)));\n          end if;\n \n-         --  Expand Initialize call for controlled objects. One may wonder why\n-         --  the Initialize Call is not done in the regular Init procedure\n-         --  attached to the record type. That's because the init procedure is\n-         --  recursively called on each component, including _Parent, thus the\n-         --  Init call for a controlled object would generate not only one\n-         --  Initialize call as it is required but one for each ancestor of\n-         --  its type. This processing is suppressed if No_Initialization set.\n-\n-         if not Needs_Finalization (Typ) or else No_Initialization (N) then\n-            null;\n-\n-         elsif not Abort_Allowed or else not Comes_From_Source (N) then\n-            Insert_Action_After (Init_After,\n-              Make_Init_Call\n-                (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                 Typ     => Base_Typ));\n-\n-         --  Abort allowed\n-\n-         else\n-            --  We need to protect the initialize call\n-\n-            --  begin\n-            --     Defer_Abort.all;\n-            --     Initialize (...);\n-            --  at end\n-            --     Undefer_Abort.all;\n-            --  end;\n-\n-            --  ??? this won't protect the initialize call for controlled\n-            --  components which are part of the init proc, so this block\n-            --  should probably also contain the call to _init_proc but this\n-            --  requires some code reorganization...\n-\n-            declare\n-               L   : constant List_Id := New_List (\n-                       Make_Init_Call\n-                         (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                          Typ     => Base_Typ));\n-\n-               Blk : constant Node_Id :=\n-                       Make_Block_Statement (Loc,\n-                         Handled_Statement_Sequence =>\n-                           Make_Handled_Sequence_Of_Statements (Loc, L));\n-\n-            begin\n-               Prepend_To (L, Build_Runtime_Call (Loc, RE_Abort_Defer));\n-               Set_At_End_Proc (Handled_Statement_Sequence (Blk),\n-                 New_Occurrence_Of (RTE (RE_Abort_Undefer_Direct), Loc));\n-               Insert_Actions_After (Init_After, New_List (Blk));\n-               Expand_At_End_Handler\n-                 (Handled_Statement_Sequence (Blk), Entity (Identifier (Blk)));\n-            end;\n-         end if;\n-\n-         --  Call type initialization procedure if there is one. We build the\n-         --  call and put it immediately after the object declaration, so that\n-         --  it will be expanded in the usual manner. Note that this will\n-         --  result in proper handling of defaulted discriminants.\n-\n-         --  Need call if there is a base init proc\n-\n-         if Has_Non_Null_Base_Init_Proc (Typ)\n-\n-           --  Suppress call if No_Initialization set on declaration\n-\n-           and then not No_Initialization (N)\n-\n-           --  Suppress call for special case of value type for VM\n-\n-           and then not Is_Value_Type (Typ)\n-\n-           --  Suppress call if initialization suppressed for the type\n-\n-           and then not Initialization_Suppressed (Typ)\n-         then\n-            --  Return without initializing when No_Default_Initialization\n-            --  applies. Note that the actual restriction check occurs later,\n-            --  when the object is frozen, because we don't know yet whether\n-            --  the object is imported, which is a case where the check does\n-            --  not apply.\n-\n-            if Restriction_Active (No_Default_Initialization) then\n-               return;\n-            end if;\n-\n-            --  The call to the initialization procedure does NOT freeze the\n-            --  object being initialized. This is because the call is not a\n-            --  source level call. This works fine, because the only possible\n-            --  statements depending on freeze status that can appear after the\n-            --  Init_Proc call are rep clauses which can safely appear after\n-            --  actual references to the object. Note that this call may\n-            --  subsequently be removed (if a pragma Import is encountered),\n-            --  or moved to the freeze actions for the object (e.g. if an\n-            --  address clause is applied to the object, causing it to get\n-            --  delayed freezing).\n-\n-            Id_Ref := New_Occurrence_Of (Def_Id, Loc);\n-            Set_Must_Not_Freeze (Id_Ref);\n-            Set_Assignment_OK (Id_Ref);\n-\n-            declare\n-               Init_Expr : constant Node_Id :=\n-                             Static_Initialization (Base_Init_Proc (Typ));\n-\n-            begin\n-               if Present (Init_Expr) then\n-                  Set_Expression\n-                    (N, New_Copy_Tree (Init_Expr, New_Scope => Current_Scope));\n-                  return;\n-\n-               --  If type has discriminants, try to build equivalent aggregate\n-               --  using discriminant values from the declaration. This\n-               --  is a useful optimization, in particular if restriction\n-               --  No_Elaboration_Code is active.\n-\n-               elsif Build_Equivalent_Aggregate then\n-                  return;\n-\n-               else\n-                  Initialization_Warning (Id_Ref);\n-\n-                  Insert_Actions_After (Init_After,\n-                    Build_Initialization_Call (Loc, Id_Ref, Typ));\n-               end if;\n-            end;\n-\n-         --  If simple initialization is required, then set an appropriate\n-         --  simple initialization expression in place. This special\n-         --  initialization is required even though No_Init_Flag is present,\n-         --  but is not needed if there was an explicit initialization.\n-\n-         --  An internally generated temporary needs no initialization because\n-         --  it will be assigned subsequently. In particular, there is no point\n-         --  in applying Initialize_Scalars to such a temporary.\n-\n-         elsif Needs_Simple_Initialization\n-                 (Typ,\n-                  Initialize_Scalars\n-                    and then not Has_Following_Address_Clause (N))\n-           and then not Is_Internal (Def_Id)\n-           and then not Has_Init_Expression (N)\n-         then\n-            Set_No_Initialization (N, False);\n-            Set_Expression (N, Get_Simple_Init_Val (Typ, N, Esize (Def_Id)));\n-            Analyze_And_Resolve (Expression (N), Typ);\n-         end if;\n+         Default_Initialize_Object (Init_After);\n \n          --  Generate attribute for Persistent_BSS if needed\n \n@@ -7971,8 +8087,8 @@ package body Exp_Ch3 is\n \n                if Warning_Needed then\n                   Error_Msg_N\n-                    (\"Objects of the type cannot be initialized \"\n-                     & \"statically by default??\", Parent (E));\n+                    (\"Objects of the type cannot be initialized statically \"\n+                     & \"by default??\", Parent (E));\n                end if;\n             end if;\n "}, {"sha": "c6bec4b1fa8f34795efcb833e89ba4af6a8887ce", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 241, "deletions": 160, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -380,14 +380,14 @@ package body Exp_Ch7 is\n    --  Initial_Condition. N denotes the package spec or body.\n \n    function Make_Call\n-     (Loc        : Source_Ptr;\n-      Proc_Id    : Entity_Id;\n-      Param      : Node_Id;\n-      For_Parent : Boolean := False) return Node_Id;\n+     (Loc       : Source_Ptr;\n+      Proc_Id   : Entity_Id;\n+      Param     : Node_Id;\n+      Skip_Self : Boolean := False) return Node_Id;\n    --  Subsidiary to Make_Adjust_Call and Make_Final_Call. Given the entity of\n-   --  routine [Deep_]Adjust / Finalize and an object parameter, create an\n-   --  adjust / finalization call. Flag For_Parent should be set when field\n-   --  _parent is being processed.\n+   --  routine [Deep_]Adjust or [Deep_]Finalize and an object parameter, create\n+   --  an adjust or finalization call. Wnen flag Skip_Self is set, the related\n+   --  action has an effect on the components only (if any).\n \n    function Make_Deep_Proc\n      (Prim  : Final_Primitives;\n@@ -2066,22 +2066,13 @@ package body Exp_Ch7 is\n          Has_No_Init  : Boolean := False;\n          Is_Protected : Boolean := False)\n       is\n-         Obj_Id    : constant Entity_Id := Defining_Identifier (Decl);\n-         Loc       : constant Source_Ptr := Sloc (Decl);\n-         Body_Ins  : Node_Id;\n-         Count_Ins : Node_Id;\n-         Fin_Call  : Node_Id;\n-         Fin_Stmts : List_Id;\n-         Inc_Decl  : Node_Id;\n-         Label     : Node_Id;\n-         Label_Id  : Entity_Id;\n-         Obj_Ref   : Node_Id;\n-         Obj_Typ   : Entity_Id;\n+         Loc : constant Source_Ptr := Sloc (Decl);\n \n-         function Build_BIP_Cleanup_Stmts (Func_Id : Entity_Id) return Node_Id;\n-         --  Once it has been established that the current object is in fact a\n-         --  return object of build-in-place function Func_Id, generate the\n-         --  following cleanup code:\n+         function Build_BIP_Cleanup_Stmts\n+           (Func_Id : Entity_Id;\n+            Obj_Id  : Entity_Id) return Node_Id;\n+         --  Func_Id denotes a build-in-place function. Obj_Id is the return\n+         --  object of Func_Id. Generate the following cleanup code:\n          --\n          --    if BIPallocfrom > Secondary_Stack'Pos\n          --      and then BIPfinalizationmaster /= null\n@@ -2100,21 +2091,20 @@ package body Exp_Ch7 is\n \n          procedure Find_Last_Init\n            (Decl        : Node_Id;\n-            Typ         : Entity_Id;\n             Last_Init   : out Node_Id;\n             Body_Insert : out Node_Id);\n-         --  An object declaration has at least one and at most two init calls:\n-         --  that of the type and the user-defined initialize. Given an object\n-         --  declaration, Last_Init denotes the last initialization call which\n-         --  follows the declaration. Body_Insert denotes the place where the\n-         --  finalizer body could be potentially inserted.\n+         --  Find the last initialization call related to object declaration\n+         --  Decl. Last_Init denotes the last initialization call which follows\n+         --  Decl. Body_Insert denotes the finalizer body could be potentially\n+         --  inserted.\n \n          -----------------------------\n          -- Build_BIP_Cleanup_Stmts --\n          -----------------------------\n \n          function Build_BIP_Cleanup_Stmts\n-           (Func_Id : Entity_Id) return Node_Id\n+           (Func_Id : Entity_Id;\n+            Obj_Id  : Entity_Id) return Node_Id\n          is\n             Decls      : constant List_Id := New_List;\n             Fin_Mas_Id : constant Entity_Id :=\n@@ -2255,58 +2245,109 @@ package body Exp_Ch7 is\n \n          procedure Find_Last_Init\n            (Decl        : Node_Id;\n-            Typ         : Entity_Id;\n             Last_Init   : out Node_Id;\n             Body_Insert : out Node_Id)\n          is\n+            function Find_Last_Init_In_Block\n+              (Blk      : Node_Id;\n+               Init_Typ : Entity_Id) return Node_Id;\n+            --  Find the last initialization call within the statements of\n+            --  block Blk. Init_Typ is type of the object being initialized.\n+\n             function Is_Init_Call\n-              (N   : Node_Id;\n-               Typ : Entity_Id) return Boolean;\n-            --  Given an arbitrary node, determine whether N is a procedure\n-            --  call and if it is, try to match the name of the call with the\n-            --  [Deep_]Initialize proc of Typ.\n+              (N        : Node_Id;\n+               Init_Typ : Entity_Id) return Boolean;\n+            --  Determine whether node N denotes one of the initialization\n+            --  procedures of type Init_Typ.\n \n             function Next_Suitable_Statement (Stmt : Node_Id) return Node_Id;\n             --  Given a statement which is part of a list, return the next\n-            --  real statement while skipping over dynamic elab checks.\n+            --  statement while skipping over dynamic elab checks.\n+\n+            -----------------------------\n+            -- Find_Last_Init_In_Block --\n+            -----------------------------\n+\n+            function Find_Last_Init_In_Block\n+              (Blk      : Node_Id;\n+               Init_Typ : Entity_Id) return Node_Id\n+            is\n+               HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n+               Stmt : Node_Id;\n+\n+            begin\n+               --  Examine the individual statements of the block in reverse to\n+               --  locate the last initialization call.\n+\n+               if Present (HSS) and then Present (Statements (HSS)) then\n+                  Stmt := Last (Statements (HSS));\n+                  while Present (Stmt) loop\n+\n+                     --  Peek inside nested blocks in case aborts are allowed\n+\n+                     if Nkind (Stmt) = N_Block_Statement then\n+                        return Find_Last_Init_In_Block (Stmt, Init_Typ);\n+\n+                     elsif Is_Init_Call (Stmt, Init_Typ) then\n+                        return Stmt;\n+                     end if;\n+\n+                     Prev (Stmt);\n+                  end loop;\n+               end if;\n+\n+               return Empty;\n+            end Find_Last_Init_In_Block;\n \n             ------------------\n             -- Is_Init_Call --\n             ------------------\n \n             function Is_Init_Call\n-              (N   : Node_Id;\n-               Typ : Entity_Id) return Boolean\n+              (N        : Node_Id;\n+               Init_Typ : Entity_Id) return Boolean\n             is\n-            begin\n-               --  A call to [Deep_]Initialize is always direct\n+               Call_Id   : Entity_Id;\n+               Deep_Init : Entity_Id := Empty;\n+               Prim_Init : Entity_Id := Empty;\n+               Type_Init : Entity_Id := Empty;\n \n+            begin\n                if Nkind (N) = N_Procedure_Call_Statement\n                  and then Nkind (Name (N)) = N_Identifier\n                then\n-                  declare\n-                     Call_Ent  : constant Entity_Id := Entity (Name (N));\n-                     Deep_Init : constant Entity_Id :=\n-                                   TSS (Typ, TSS_Deep_Initialize);\n-                     Init      : Entity_Id := Empty;\n+                  Call_Id := Entity (Name (N));\n \n-                  begin\n-                     --  A type may have controlled components but not be\n-                     --  controlled.\n+                  --  Obtain all possible initialization routines of the object\n+                  --  type and try to match the procedure call against one of\n+                  --  them.\n+\n+                  --  Deep_Initialize\n+\n+                  Deep_Init := TSS (Init_Typ, TSS_Deep_Initialize);\n+\n+                  --  Primitive Initialize\n \n-                     if Is_Controlled (Typ) then\n-                        Init := Find_Prim_Op (Typ, Name_Initialize);\n+                  if Is_Controlled (Init_Typ) then\n+                     Prim_Init := Find_Prim_Op (Init_Typ, Name_Initialize);\n \n-                        if Present (Init) then\n-                           Init := Ultimate_Alias (Init);\n-                        end if;\n+                     if Present (Prim_Init) then\n+                        Prim_Init := Ultimate_Alias (Prim_Init);\n                      end if;\n+                  end if;\n \n-                     return\n-                       (Present (Deep_Init) and then Call_Ent = Deep_Init)\n-                         or else\n-                       (Present (Init)      and then Call_Ent = Init);\n-                  end;\n+                  --  Type initialization routine\n+\n+                  if Has_Non_Null_Base_Init_Proc (Init_Typ) then\n+                     Type_Init := Base_Init_Proc (Init_Typ);\n+                  end if;\n+\n+                  return\n+                    (Present (Deep_Init) and then Call_Id = Deep_Init)\n+                      or else\n+                    (Present (Prim_Init) and then Call_Id = Prim_Init)\n+                      or else\n+                    (Present (Type_Init) and then Call_Id = Type_Init);\n                end if;\n \n                return False;\n@@ -2333,11 +2374,13 @@ package body Exp_Ch7 is\n \n             --  Local variables\n \n-            Obj_Id : constant Entity_Id := Defining_Entity (Decl);\n-            Nod_1  : Node_Id := Empty;\n-            Nod_2  : Node_Id := Empty;\n-            Stmt   : Node_Id;\n-            Utyp   : Entity_Id;\n+            Obj_Id   : constant Entity_Id := Defining_Entity (Decl);\n+            Obj_Typ  : constant Entity_Id := Base_Type (Etype (Obj_Id));\n+            Call     : Node_Id;\n+            Init_Typ : Entity_Id := Obj_Typ;\n+            Is_Conc  : Boolean   := False;\n+            Stmt     : Node_Id;\n+            Stmt_2   : Node_Id;\n \n          --  Start of processing for Find_Last_Init\n \n@@ -2346,24 +2389,42 @@ package body Exp_Ch7 is\n             Body_Insert := Empty;\n \n             --  Object renamings and objects associated with controlled\n-            --  function results do not have initialization calls.\n+            --  function results do not require initialization.\n \n             if Has_No_Init then\n                return;\n             end if;\n \n-            if Is_Concurrent_Type (Typ) then\n-               Utyp := Corresponding_Record_Type (Typ);\n-            else\n-               Utyp := Typ;\n-            end if;\n+            --  Obtain the proper type of the object being initialized\n \n-            if Is_Private_Type (Utyp)\n-              and then Present (Full_View (Utyp))\n-            then\n-               Utyp := Full_View (Utyp);\n+            loop\n+               if Is_Concurrent_Type (Init_Typ)\n+                 and then Present (Corresponding_Record_Type (Init_Typ))\n+               then\n+                  Is_Conc  := True;\n+                  Init_Typ := Corresponding_Record_Type (Init_Typ);\n+\n+               elsif Is_Private_Type (Init_Typ)\n+                  and then Present (Full_View (Init_Typ))\n+               then\n+                  Init_Typ := Full_View (Init_Typ);\n+\n+               elsif Is_Untagged_Derivation (Init_Typ)\n+                 and then not Is_Conc\n+               then\n+                  Init_Typ := Root_Type (Init_Typ);\n+\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            if Init_Typ /= Base_Type (Init_Typ) then\n+               Init_Typ := Base_Type (Init_Typ);\n             end if;\n \n+            Stmt := Next_Suitable_Statement (Decl);\n+\n             --  A limited controlled object initialized by a function call uses\n             --  the build-in-place machinery to obtain its value.\n \n@@ -2381,11 +2442,10 @@ package body Exp_Ch7 is\n             --  In this scenario the declaration of the temporary acts as the\n             --  last initialization statement.\n \n-            if Is_Limited_Type (Utyp)\n+            if Is_Limited_Type (Init_Typ)\n               and then Has_Init_Expression (Decl)\n               and then No (Expression (Decl))\n             then\n-               Stmt := Next (Decl);\n                while Present (Stmt) loop\n                   if Nkind (Stmt) = N_Object_Declaration\n                     and then Present (Expression (Stmt))\n@@ -2400,68 +2460,77 @@ package body Exp_Ch7 is\n                   Next (Stmt);\n                end loop;\n \n-            --  The init procedures are arranged as follows:\n-\n-            --    Object : Controlled_Type;\n-            --    Controlled_TypeIP (Object);\n-            --    [[Deep_]Initialize (Object);]\n-\n-            --  where the user-defined initialize may be optional or may appear\n-            --  inside a block when abort deferral is needed.\n+            --  In all other cases the initialization calls follow the related\n+            --  object. The general structure of object initialization built by\n+            --  routine Default_Initialize_Object is as follows:\n+\n+            --   [begin                                --  aborts allowed\n+            --       Abort_Defer;]\n+            --       Type_Init_Proc (Obj);\n+            --      [begin]                            --  exceptions allowed\n+            --          Deep_Initialize (Obj);\n+            --      [exception                         --  exceptions allowed\n+            --          when others =>\n+            --             Deep_Finalize (Obj, Self => False);\n+            --             raise;\n+            --       end;]\n+            --   [at end                               --  aborts allowed\n+            --       Abort_Undefer;\n+            --    end;]\n+\n+            --  When aborts are allowed, the initialization calls are housed\n+            --  within a block.\n+\n+            elsif Nkind (Stmt) = N_Block_Statement then\n+               Last_Init   := Find_Last_Init_In_Block (Stmt, Init_Typ);\n+               Body_Insert := Stmt;\n+\n+            --  Otherwise the initialization calls follow the related object\n \n             else\n-               Nod_1 := Next_Suitable_Statement (Decl);\n-\n-               if Present (Nod_1) then\n-                  Nod_2 := Next_Suitable_Statement (Nod_1);\n+               Stmt_2 := Next_Suitable_Statement (Stmt);\n \n-                  --  The statement following an object declaration is always a\n-                  --  call to the type init proc.\n+               --  Check for an optional call to Deep_Initialize which may\n+               --  appear within a block depending on whether the object has\n+               --  controlled components.\n \n-                  Last_Init := Nod_1;\n-               end if;\n-\n-               --  Optional user-defined init or deep init processing\n-\n-               if Present (Nod_2) then\n-\n-                  --  The statement following the type init proc may be a block\n-                  --  statement in cases where abort deferral is required.\n-\n-                  if Nkind (Nod_2) = N_Block_Statement then\n-                     declare\n-                        HSS  : constant Node_Id :=\n-                                 Handled_Statement_Sequence (Nod_2);\n-                        Stmt : Node_Id;\n-\n-                     begin\n-                        if Present (HSS)\n-                          and then Present (Statements (HSS))\n-                        then\n-                           --  Examine individual block statements and locate\n-                           --  the call to [Deep_]Initialze.\n+               if Present (Stmt_2) then\n+                  if Nkind (Stmt_2) = N_Block_Statement then\n+                     Call := Find_Last_Init_In_Block (Stmt_2, Init_Typ);\n \n-                           Stmt := First (Statements (HSS));\n-                           while Present (Stmt) loop\n-                              if Is_Init_Call (Stmt, Utyp) then\n-                                 Last_Init   := Stmt;\n-                                 Body_Insert := Nod_2;\n+                     if Present (Call) then\n+                        Last_Init   := Call;\n+                        Body_Insert := Stmt_2;\n+                     end if;\n \n-                                 exit;\n-                              end if;\n+                  elsif Is_Init_Call (Stmt_2, Init_Typ) then\n+                     Last_Init   := Stmt_2;\n+                     Body_Insert := Last_Init;\n+                  end if;\n \n-                              Next (Stmt);\n-                           end loop;\n-                        end if;\n-                     end;\n+               --  If the object lacks a call to Deep_Initialize, then it must\n+               --  have a call to its related type init proc.\n \n-                  elsif Is_Init_Call (Nod_2, Utyp) then\n-                     Last_Init := Nod_2;\n-                  end if;\n+               elsif Is_Init_Call (Stmt, Init_Typ) then\n+                  Last_Init   := Stmt;\n+                  Body_Insert := Last_Init;\n                end if;\n             end if;\n          end Find_Last_Init;\n \n+         --  Local variables\n+\n+         Obj_Id    : constant Entity_Id := Defining_Identifier (Decl);\n+         Body_Ins  : Node_Id;\n+         Count_Ins : Node_Id;\n+         Fin_Call  : Node_Id;\n+         Fin_Stmts : List_Id;\n+         Inc_Decl  : Node_Id;\n+         Label     : Node_Id;\n+         Label_Id  : Entity_Id;\n+         Obj_Ref   : Node_Id;\n+         Obj_Typ   : Entity_Id;\n+\n       --  Start of processing for Process_Object_Declaration\n \n       begin\n@@ -2492,7 +2561,7 @@ package body Exp_Ch7 is\n          --  initialized via an aggregate, then the counter must be inserted\n          --  after the last aggregate assignment.\n \n-         if Ekind (Obj_Id) = E_Variable\n+         if Ekind_In (Obj_Id, E_Constant, E_Variable)\n            and then Present (Last_Aggregate_Assignment (Obj_Id))\n          then\n             Count_Ins := Last_Aggregate_Assignment (Obj_Id);\n@@ -2502,7 +2571,7 @@ package body Exp_Ch7 is\n          --  either [Deep_]Initialize or the type specific init proc.\n \n          else\n-            Find_Last_Init (Decl, Obj_Typ, Count_Ins, Body_Ins);\n+            Find_Last_Init (Decl, Count_Ins, Body_Ins);\n          end if;\n \n          Insert_After (Count_Ins, Inc_Decl);\n@@ -2526,7 +2595,7 @@ package body Exp_Ch7 is\n          end if;\n \n          --  Create the associated label with this object, generate:\n-         --\n+\n          --    L<counter> : label;\n \n          Label_Id :=\n@@ -2541,7 +2610,7 @@ package body Exp_Ch7 is\n              Label_Construct     => Label));\n \n          --  Create the associated jump with this object, generate:\n-\n+         --\n          --    when <counter> =>\n          --       goto L<counter>;\n \n@@ -2685,7 +2754,8 @@ package body Exp_Ch7 is\n                   if Is_Build_In_Place_Function (Func_Id)\n                     and then Needs_BIP_Finalization_Master (Func_Id)\n                   then\n-                     Append_To (Fin_Stmts, Build_BIP_Cleanup_Stmts (Func_Id));\n+                     Append_To\n+                       (Fin_Stmts, Build_BIP_Cleanup_Stmts (Func_Id, Obj_Id));\n                   end if;\n                end;\n             end if;\n@@ -4933,9 +5003,9 @@ package body Exp_Ch7 is\n    -----------------------\n \n    function Make_Adjust_Call\n-     (Obj_Ref    : Node_Id;\n-      Typ        : Entity_Id;\n-      For_Parent : Boolean := False) return Node_Id\n+     (Obj_Ref   : Node_Id;\n+      Typ       : Entity_Id;\n+      Skip_Self : Boolean := False) return Node_Id\n    is\n       Loc    : constant Source_Ptr := Sloc (Obj_Ref);\n       Adj_Id : Entity_Id := Empty;\n@@ -4972,11 +5042,13 @@ package body Exp_Ch7 is\n          Ref  := Unchecked_Convert_To (Utyp, Ref);\n       end if;\n \n-      --  Select the appropriate version of adjust\n-\n-      if For_Parent then\n+      if Skip_Self then\n          if Has_Controlled_Component (Utyp) then\n-            Adj_Id := Find_Prim_Op (Utyp, TSS_Deep_Adjust);\n+            if Is_Tagged_Type (Utyp) then\n+               Adj_Id := Find_Prim_Op (Utyp, TSS_Deep_Adjust);\n+            else\n+               Adj_Id := TSS (Utyp, TSS_Deep_Adjust);\n+            end if;\n          end if;\n \n       --  Class-wide types, interfaces and types with controlled components\n@@ -5027,7 +5099,11 @@ package body Exp_Ch7 is\n             Ref := Convert_View (Adj_Id, Ref);\n          end if;\n \n-         return Make_Call (Loc, Adj_Id, New_Copy_Tree (Ref), For_Parent);\n+         return\n+           Make_Call (Loc,\n+             Proc_Id   => Adj_Id,\n+             Param     => New_Copy_Tree (Ref),\n+             Skip_Self => Skip_Self);\n       else\n          return Empty;\n       end if;\n@@ -5075,19 +5151,18 @@ package body Exp_Ch7 is\n    ---------------\n \n    function Make_Call\n-     (Loc        : Source_Ptr;\n-      Proc_Id    : Entity_Id;\n-      Param      : Node_Id;\n-      For_Parent : Boolean := False) return Node_Id\n+     (Loc       : Source_Ptr;\n+      Proc_Id   : Entity_Id;\n+      Param     : Node_Id;\n+      Skip_Self : Boolean := False) return Node_Id\n    is\n       Params : constant List_Id := New_List (Param);\n \n    begin\n-      --  When creating a call to Deep_Finalize for a _parent field of a\n-      --  derived type, disable the invocation of the nested Finalize by giving\n-      --  the corresponding flag a False value.\n+      --  Do not apply the controlled action to the object itself by signaling\n+      --  the related routine to avoid self.\n \n-      if For_Parent then\n+      if Skip_Self then\n          Append_To (Params, New_Occurrence_Of (Standard_False, Loc));\n       end if;\n \n@@ -6307,13 +6382,13 @@ package body Exp_Ch7 is\n                if Needs_Finalization (Par_Typ) then\n                   Call :=\n                     Make_Adjust_Call\n-                      (Obj_Ref    =>\n+                      (Obj_Ref   =>\n                          Make_Selected_Component (Loc,\n                            Prefix        => Make_Identifier (Loc, Name_V),\n                            Selector_Name =>\n                              Make_Identifier (Loc, Name_uParent)),\n-                       Typ        => Par_Typ,\n-                       For_Parent => True);\n+                       Typ       => Par_Typ,\n+                       Skip_Self => True);\n \n                   --  Generate:\n                   --    Deep_Adjust (V._parent, False);  --  No_Except_Propagat\n@@ -6882,13 +6957,13 @@ package body Exp_Ch7 is\n                if Needs_Finalization (Par_Typ) then\n                   Call :=\n                     Make_Final_Call\n-                      (Obj_Ref    =>\n+                      (Obj_Ref   =>\n                          Make_Selected_Component (Loc,\n                            Prefix        => Make_Identifier (Loc, Name_V),\n                            Selector_Name =>\n                              Make_Identifier (Loc, Name_uParent)),\n-                       Typ        => Par_Typ,\n-                       For_Parent => True);\n+                       Typ       => Par_Typ,\n+                       Skip_Self => True);\n \n                   --  Generate:\n                   --    Deep_Finalize (V._parent, False);  --  No_Except_Propag\n@@ -7118,9 +7193,9 @@ package body Exp_Ch7 is\n    ----------------------\n \n    function Make_Final_Call\n-     (Obj_Ref    : Node_Id;\n-      Typ        : Entity_Id;\n-      For_Parent : Boolean := False) return Node_Id\n+     (Obj_Ref   : Node_Id;\n+      Typ       : Entity_Id;\n+      Skip_Self : Boolean := False) return Node_Id\n    is\n       Loc    : constant Source_Ptr := Sloc (Obj_Ref);\n       Atyp   : Entity_Id;\n@@ -7203,11 +7278,13 @@ package body Exp_Ch7 is\n          Set_Assignment_OK (Ref);\n       end if;\n \n-      --  Select the appropriate version of Finalize\n-\n-      if For_Parent then\n+      if Skip_Self then\n          if Has_Controlled_Component (Utyp) then\n-            Fin_Id := Find_Prim_Op (Utyp, TSS_Deep_Finalize);\n+            if Is_Tagged_Type (Utyp) then\n+               Fin_Id := Find_Prim_Op (Utyp, TSS_Deep_Finalize);\n+            else\n+               Fin_Id := TSS (Utyp, TSS_Deep_Finalize);\n+            end if;\n          end if;\n \n       --  Class-wide types, interfaces and types with controlled components\n@@ -7278,7 +7355,11 @@ package body Exp_Ch7 is\n             Ref := Convert_View (Fin_Id, Ref);\n          end if;\n \n-         return Make_Call (Loc, Fin_Id, New_Copy_Tree (Ref), For_Parent);\n+         return\n+           Make_Call (Loc,\n+             Proc_Id   => Fin_Id,\n+             Param     => New_Copy_Tree (Ref),\n+             Skip_Self => Skip_Self);\n       else\n          return Empty;\n       end if;"}, {"sha": "1217e5b5f3bc2aba8563175ccb13abcbe1e83e6c", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -162,14 +162,14 @@ package Exp_Ch7 is\n    --  latest extension contains a controlled component.\n \n    function Make_Adjust_Call\n-     (Obj_Ref    : Node_Id;\n-      Typ        : Entity_Id;\n-      For_Parent : Boolean := False) return Node_Id;\n+     (Obj_Ref   : Node_Id;\n+      Typ       : Entity_Id;\n+      Skip_Self : Boolean := False) return Node_Id;\n    --  Create a call to either Adjust or Deep_Adjust depending on the structure\n    --  of type Typ. Obj_Ref is an expression with no-side effect (not required\n    --  to have been previously analyzed) that references the object to be\n-   --  adjusted. Typ is the expected type of Obj_Ref. Flag For_Parent must be\n-   --  set when an adjustment call is being created for field _parent.\n+   --  adjusted. Typ is the expected type of Obj_Ref. When Skip_Self is set,\n+   --  only the components (if any) are adjusted.\n \n    function Make_Attach_Call\n      (Obj_Ref : Node_Id;\n@@ -191,15 +191,14 @@ package Exp_Ch7 is\n    --      (System.Finalization_Root.Root_Controlled_Ptr (Obj_Ref));\n \n    function Make_Final_Call\n-     (Obj_Ref    : Node_Id;\n-      Typ        : Entity_Id;\n-      For_Parent : Boolean := False) return Node_Id;\n+     (Obj_Ref   : Node_Id;\n+      Typ       : Entity_Id;\n+      Skip_Self : Boolean := False) return Node_Id;\n    --  Create a call to either Finalize or Deep_Finalize depending on the\n-   --  structure of type Typ. Obj_Ref is an expression (with no-side effect and\n-   --  is not required to have been previously analyzed) that references the\n-   --  object to be finalized. Typ is the expected type of Obj_Ref. Flag For_\n-   --  Parent must be set when a finalization call is being created for field\n-   --  _parent.\n+   --  structure of type Typ. Obj_Ref is an expression (with no-side effect\n+   --  and is not required to have been previously analyzed) that references\n+   --  the object to be finalized. Typ is the expected type of Obj_Ref. When\n+   --  Skip_Self is set, only the components (if any) are finalized.\n \n    procedure Make_Finalize_Address_Body (Typ : Entity_Id);\n    --  Create the body of TSS routine Finalize_Address if Typ is controlled and\n@@ -300,7 +299,12 @@ package Exp_Ch7 is\n    procedure Store_After_Actions_In_Scope (L : List_Id);\n    --  Prepend the list L of actions to the beginning of the after-actions\n    --  stored in the top of the scope stack (also analyzes these actions).\n-   --  Why prepend rather than append ???\n+   --\n+   --  Note that we are prepending here rather than appending. This means that\n+   --  if several calls are made to this procedure for the same scope, the\n+   --  actions will be executed in reverse order of the calls (actions for the\n+   --  last call executed first). Within the list L for a single call, the\n+   --  actions are executed in the order in which they appear in this list.\n \n    procedure Store_Cleanup_Actions_In_Scope (L : List_Id);\n    --  Prepend the list L of actions to the beginning of the cleanup-actions"}, {"sha": "fb479561ed494a702278933669c18564b26cbf28", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=4ac2bbbd057159e44cbe8d035eb0b6fc536bc40c", "patch": "@@ -2436,10 +2436,11 @@ package body Sem_Ch9 is\n \n       --  AI05-0225: the target protected object of a requeue must be a\n       --  variable. This is a binding interpretation that applies to all\n-      --  versions of the language.\n+      --  versions of the language. Note that the subprogram does not have\n+      --  to be a protected operation: it can be an primitive implemented\n+      --  by entry with a formal that is a protected interface.\n \n       if Present (Target_Obj)\n-        and then Ekind (Scope (Entry_Id)) in Protected_Kind\n         and then not Is_Variable (Target_Obj)\n       then\n          Error_Msg_N"}]}