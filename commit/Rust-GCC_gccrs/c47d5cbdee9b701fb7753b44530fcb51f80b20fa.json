{"sha": "c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "node_id": "C_kwDOANBUbNoAKGM0N2Q1Y2JkZWU5YjcwMWZiNzc1M2I0NDUzMGZjYjUxZjgwYjIwZmE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-16T13:54:43Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-16T14:09:23Z"}, "message": "Initial support operator overloading on [lang = \"add\"]\n\nThis change incorporates a few changes.\n\n1. Create new gcc/rust/backend/rust-compile-expr.cc to split out\n   implementation code\n2. Create new type check context api calls:\n   - TypeCheckContext::lookup_operator_overload\n   - TypeCheckContext::insert_operator_overload\n3. Update type checking for ArithmeticOrLogicalExpr to look for any\n   operator overloading\n\nWhen we are looking for operator overloads we must look up the associated\nlang item type for this paticular operation, to resolve the operation to\nany known lang_items by looking up the specified lang_item to DefId. Then\nwe must probe for the lang_item candidate for this paticular lang_item\nDefID to see if we can resolve it to a method call. Then based on the\nautoderef rules in a MethodCallExpr we must verify that we don't end up\nin a recursive operator overload by checking that the current context\nis not the same as the actual operator overload for this type. Finally\nwe mark this expression as operator overload and setup everything as a\nresolved MethodCallExpr.\n\nFixes #249", "tree": {"sha": "2cd74fceb2f9cc92ae47988507fdf424fb3d3682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cd74fceb2f9cc92ae47988507fdf424fb3d3682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89e02f52d86c7120046236e654e49749c4b4ecb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e02f52d86c7120046236e654e49749c4b4ecb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e02f52d86c7120046236e654e49749c4b4ecb3"}], "stats": {"total": 925, "additions": 696, "deletions": 229}, "files": [{"sha": "f3302c2e3fb6861694fb512c932a51fbd30ffe7b", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -90,6 +90,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-path.o \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-base62.o \\\n+    rust/rust-compile-expr.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "c7941bc2014fc45b0a8656318f30fcb60b310217", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -0,0 +1,316 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (!is_op_overload)\n+    {\n+      translated = ctx->get_backend ()->arithmetic_or_logical_expression (\n+\top, lhs, rhs, expr.get_locus ());\n+      return;\n+    }\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n+      return;\n+    }\n+\n+  // reverse lookup\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t  &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      arguments.push_back (expr.get_rhs ());\n+\n+      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, lhs,\n+\t\t\t\t\t      arguments, expr.get_locus ());\n+      return;\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathIdentSegment segment_name (\"add\");\n+  Bexpression *fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  Bexpression *self = lhs;\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self = ctx->get_backend ()->address_expression (\n+\t    self, expr.get_lhs ()->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  Btype *expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self = ctx->get_backend ()->indirect_expression (\n+\t    expected_type, self, true, /* known_valid*/\n+\t    expr.get_lhs ()->get_locus ());\n+\t  break;\n+\t}\n+    }\n+\n+  std::vector<Bexpression *> args;\n+  args.push_back (self); // adjusted self\n+  args.push_back (rhs);\n+\n+  auto fncontext = ctx->peek_fn ();\n+  translated\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t    nullptr, expr.get_locus ());\n+}\n+\n+Bexpression *\n+CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t\tTyTy::BaseType *receiver,\n+\t\t\t\t\tTyTy::FnType *fntype,\n+\t\t\t\t\tBexpression *receiver_ref,\n+\t\t\t\t\tstd::vector<HIR::Expr *> &arguments,\n+\t\t\t\t\tLocation expr_locus)\n+{\n+  size_t offs = 0;\n+  const Resolver::TraitItemReference *ref = nullptr;\n+  for (auto &bound : dyn->get_object_items ())\n+    {\n+      const Resolver::TraitItemReference *item = bound.first;\n+      auto t = item->get_tyty ();\n+      rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n+      auto ft = static_cast<TyTy::FnType *> (t);\n+\n+      if (ft->get_id () == fntype->get_id ())\n+\t{\n+\t  ref = item;\n+\t  break;\n+\t}\n+      offs++;\n+    }\n+\n+  if (ref == nullptr)\n+    return ctx->get_backend ()->error_expression ();\n+\n+  // get any indirection sorted out\n+  if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      auto indirect_ty = r->get_base ();\n+      Btype *indrect_compiled_tyty\n+\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n+\n+      Bexpression *indirect\n+\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n+\t\t\t\t\t\t    receiver_ref, true,\n+\t\t\t\t\t\t    expr_locus);\n+      receiver_ref = indirect;\n+    }\n+\n+  // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n+  Bexpression *self_argument\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n+\t\t\t\t\t\t    expr_locus);\n+\n+  // access the vtable for the fn\n+  Bexpression *fn_vtable_access\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n+\t\t\t\t\t\t    expr_locus);\n+\n+  // cast it to the correct fntype\n+  Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+  Bexpression *fn_convert_expr\n+    = ctx->get_backend ()->convert_expression (expected_fntype,\n+\t\t\t\t\t       fn_vtable_access, expr_locus);\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  bool is_address_taken = false;\n+  Bstatement *ret_var_stmt = nullptr;\n+  Bvariable *fn_convert_expr_tmp\n+    = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n+\t\t\t\t\t       expected_fntype, fn_convert_expr,\n+\t\t\t\t\t       is_address_taken, expr_locus,\n+\t\t\t\t\t       &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n+\n+  std::vector<Bexpression *> args;\n+  args.push_back (self_argument);\n+  for (auto &argument : arguments)\n+    {\n+      Bexpression *compiled_expr = CompileExpr::Compile (argument, ctx);\n+      args.push_back (compiled_expr);\n+    }\n+\n+  Bexpression *fn_expr\n+    = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n+\n+  return ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n+\t\t\t\t\t       nullptr, expr_locus);\n+}\n+\n+Bexpression *\n+CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t\t     TyTy::BaseType *receiver,\n+\t\t\t\t     HIR::PathIdentSegment &segment,\n+\t\t\t\t     Analysis::NodeMapping expr_mappings,\n+\t\t\t\t     Location expr_locus)\n+{\n+  // lookup compiled functions since it may have already been compiled\n+  Bfunction *fn = nullptr;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+    {\n+      return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+    }\n+\n+  // Now we can try and resolve the address since this might be a forward\n+  // declared function, generic function which has not be compiled yet or\n+  // its an not yet trait bound function\n+  HIR::ImplItem *resolved_item\n+    = ctx->get_mappings ()->lookup_hir_implitem (expr_mappings.get_crate_num (),\n+\t\t\t\t\t\t ref, nullptr);\n+  if (resolved_item != nullptr)\n+    {\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n+\t\t\t\t\t\t true);\n+\n+      return CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n+\t\t\t\t\t       true, fntype);\n+    }\n+\n+  // it might be resolved to a trait item\n+  HIR::TraitItem *trait_item = ctx->get_mappings ()->lookup_hir_trait_item (\n+    expr_mappings.get_crate_num (), ref);\n+  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+    trait_item->get_mappings ().get_hirid ());\n+\n+  Resolver::TraitReference *trait_ref\n+    = &Resolver::TraitReference::error_node ();\n+  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+    trait->get_mappings ().get_defid (), &trait_ref);\n+  rust_assert (ok);\n+\n+  // the type resolver can only resolve type bounds to their trait\n+  // item so its up to us to figure out if this path should resolve\n+  // to an trait-impl-block-item or if it can be defaulted to the\n+  // trait-impl-item's definition\n+\n+  auto root = receiver->get_root ();\n+  std::vector<Resolver::PathProbeCandidate> candidates\n+    = Resolver::PathProbeType::Probe (root, segment, true, false, true);\n+\n+  if (candidates.size () == 0)\n+    {\n+      // this means we are defaulting back to the trait_item if\n+      // possible\n+      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+      bool ok = trait_ref->lookup_hir_trait_item (*trait_item, &trait_item_ref);\n+      rust_assert (ok);\t\t\t\t    // found\n+      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+      // FIXME Optional means it has a definition and an associated\n+      // block which can be a default implementation, if it does not\n+      // contain an implementation we should actually return\n+      // error_mark_node\n+\n+      return CompileTraitItem::Compile (receiver,\n+\t\t\t\t\ttrait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\tctx, fntype, true, expr_locus);\n+    }\n+  else\n+    {\n+      std::vector<Resolver::Adjustment> adjustments;\n+      Resolver::PathProbeCandidate *candidate\n+\t= Resolver::MethodResolution::Select (candidates, root, adjustments);\n+\n+      // FIXME this will be a case to return error_mark_node, there is\n+      // an error scenario where a Trait Foo has a method Bar, but this\n+      // receiver does not implement this trait or has an incompatible\n+      // implementation and we should just return error_mark_node\n+      rust_assert (candidate != nullptr);\n+      rust_assert (candidate->is_impl_candidate ());\n+\n+      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (receiver, impl_item, ctx,\n+\t\t\t\t\t\t true);\n+\n+      return CompileInherentImplItem::Compile (receiver, impl_item, ctx, true,\n+\t\t\t\t\t       fntype);\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "c9d3c304aab6bcd6f0f6a73d7a99070894cf1686", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -448,17 +448,7 @@ class CompileExpr : public HIRCompileBase\n       constructor.push_back (translated_expr);\n   }\n \n-  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    auto op = expr.get_expr_type ();\n-    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n-    auto location = expr.get_locus ();\n-\n-    translated\n-      = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t       location);\n-  }\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n \n   void visit (HIR::ComparisonExpr &expr) override\n   {\n@@ -999,6 +989,20 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t  expr.get_locus ());\n   }\n \n+protected:\n+  Bexpression *compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t\t  TyTy::BaseType *receiver,\n+\t\t\t\t\t  TyTy::FnType *fntype,\n+\t\t\t\t\t  Bexpression *receiver_ref,\n+\t\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n+\t\t\t\t\t  Location expr_locus);\n+\n+  Bexpression *resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t\t       TyTy::BaseType *receiver,\n+\t\t\t\t       HIR::PathIdentSegment &segment,\n+\t\t\t\t       Analysis::NodeMapping expr_mappings,\n+\t\t\t\t       Location expr_locus);\n+\n private:\n   CompileExpr (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)"}, {"sha": "e53993a8cbe98a7efb2e807eeadf3d1a6d0eb218", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 10, "deletions": 209, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -242,220 +242,21 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       const TyTy::DynamicObjectType *dyn\n \t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n \n-      size_t offs = 0;\n-      const Resolver::TraitItemReference *ref = nullptr;\n-      for (auto &bound : dyn->get_object_items ())\n-\t{\n-\t  const Resolver::TraitItemReference *item = bound.first;\n-\t  auto t = item->get_tyty ();\n-\t  rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n-\t  auto ft = static_cast<TyTy::FnType *> (t);\n-\n-\t  if (ft->get_id () == fntype->get_id ())\n-\t    {\n-\t      ref = item;\n-\t      break;\n-\t    }\n-\t  offs++;\n-\t}\n-\n-      if (ref == nullptr)\n-\t{\n-\t  translated = ctx->get_backend ()->error_expression ();\n-\t  return;\n-\t}\n-\n-      // get any indirection sorted out\n-      auto receiver_ref = self;\n-      if (receiver->get_kind () == TyTy::TypeKind::REF)\n-\t{\n-\t  TyTy::ReferenceType *r\n-\t    = static_cast<TyTy::ReferenceType *> (receiver);\n-\t  auto indirect_ty = r->get_base ();\n-\t  Btype *indrect_compiled_tyty\n-\t    = TyTyResolveCompile::compile (ctx, indirect_ty);\n-\n-\t  Bexpression *indirect\n-\t    = ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n-\t\t\t\t\t\t\treceiver_ref, true,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\t  receiver_ref = indirect;\n-\t}\n+      std::vector<HIR::Expr *> arguments;\n+      for (auto &arg : expr.get_arguments ())\n+\targuments.push_back (arg.get ());\n \n-      // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n-      Bexpression *self_argument\n-\t= ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\n-      // access the vtable for the fn\n-      Bexpression *fn_vtable_access\n-\t= ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\n-      // cast it to the correct fntype\n-      Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n-      Bexpression *fn_convert_expr\n-\t= ctx->get_backend ()->convert_expression (expected_fntype,\n-\t\t\t\t\t\t   fn_vtable_access,\n-\t\t\t\t\t\t   expr.get_locus ());\n-\n-      fncontext fnctx = ctx->peek_fn ();\n-      Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-      bool is_address_taken = false;\n-      Bstatement *ret_var_stmt = nullptr;\n-\n-      Bvariable *fn_convert_expr_tmp = ctx->get_backend ()->temporary_variable (\n-\tfnctx.fndecl, enclosing_scope, expected_fntype, fn_convert_expr,\n-\tis_address_taken, expr.get_locus (), &ret_var_stmt);\n-      ctx->add_statement (ret_var_stmt);\n-\n-      std::vector<Bexpression *> args;\n-      args.push_back (self_argument);\n-      for (auto &argument : expr.get_arguments ())\n-\t{\n-\t  Bexpression *compiled_expr\n-\t    = CompileExpr::Compile (argument.get (), ctx);\n-\t  args.push_back (compiled_expr);\n-\t}\n-\n-      Bexpression *fn_expr\n-\t= ctx->get_backend ()->var_expression (fn_convert_expr_tmp,\n-\t\t\t\t\t       expr.get_locus ());\n-\n-      translated\n-\t= ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n-\t\t\t\t\t\tnullptr, expr.get_locus ());\n+      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n+\t\t\t\t\t      arguments, expr.get_locus ());\n       return;\n     }\n \n-  // address of compiled function\n-  Bexpression *fn_expr = ctx->get_backend ()->error_expression ();\n-\n   // lookup compiled functions since it may have already been compiled\n-  Bfunction *fn = nullptr;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-    {\n-      fn_expr\n-\t= ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n-    }\n-  else\n-    {\n-      // Now we can try and resolve the address since this might be a forward\n-      // declared function, generic function which has not be compiled yet or\n-      // its an not yet trait bound function\n-      HIR::ImplItem *resolved_item = ctx->get_mappings ()->lookup_hir_implitem (\n-\texpr.get_mappings ().get_crate_num (), ref, nullptr);\n-      if (resolved_item == nullptr)\n-\t{\n-\t  // it might be resolved to a trait item\n-\t  HIR::TraitItem *trait_item\n-\t    = ctx->get_mappings ()->lookup_hir_trait_item (\n-\t      expr.get_mappings ().get_crate_num (), ref);\n-\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n-\t    trait_item->get_mappings ().get_hirid ());\n-\n-\t  Resolver::TraitReference *trait_ref\n-\t    = &Resolver::TraitReference::error_node ();\n-\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n-\t    trait->get_mappings ().get_defid (), &trait_ref);\n-\t  rust_assert (ok);\n-\n-\t  // the type resolver can only resolve type bounds to their trait\n-\t  // item so its up to us to figure out if this path should resolve\n-\t  // to an trait-impl-block-item or if it can be defaulted to the\n-\t  // trait-impl-item's definition\n-\n-\t  auto root = receiver->get_root ();\n-\t  std::vector<Resolver::PathProbeCandidate> candidates\n-\t    = Resolver::PathProbeType::Probe (\n-\t      root, expr.get_method_name ().get_segment (), true, false, true);\n-\n-\t  if (candidates.size () == 0)\n-\t    {\n-\t      // this means we are defaulting back to the trait_item if\n-\t      // possible\n-\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n-\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n-\t\t\t\t\t\t\t  &trait_item_ref);\n-\t      rust_assert (ok);\t\t\t\t    // found\n-\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n-\n-\t      // FIXME Optional means it has a definition and an associated\n-\t      // block which can be a default implementation, if it does not\n-\t      // contain an implementation we should actually return\n-\t      // error_mark_node\n-\n-\t      TyTy::BaseType *self_type = nullptr;\n-\t      if (!ctx->get_tyctx ()->lookup_type (\n-\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n-\t\t    &self_type))\n-\t\t{\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"failed to resolve type for self param\");\n-\t\t  return;\n-\t\t}\n-\n-\t      fn_expr = CompileTraitItem::Compile (\n-\t\tself_type, trait_item_ref->get_hir_trait_item (), ctx, fntype,\n-\t\ttrue, expr.get_locus ());\n-\t    }\n-\t  else\n-\t    {\n-\t      std::vector<Resolver::Adjustment> adjustments;\n-\t      Resolver::PathProbeCandidate *candidate\n-\t\t= Resolver::MethodResolution::Select (candidates, root,\n-\t\t\t\t\t\t      adjustments);\n-\n-\t      // FIXME this will be a case to return error_mark_node, there is\n-\t      // an error scenario where a Trait Foo has a method Bar, but this\n-\t      // receiver does not implement this trait or has an incompatible\n-\t      // implementation and we should just return error_mark_node\n-\t      rust_assert (candidate != nullptr);\n-\t      rust_assert (candidate->is_impl_candidate ());\n-\n-\t      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n-\n-\t      TyTy::BaseType *self_type = nullptr;\n-\t      if (!ctx->get_tyctx ()->lookup_type (\n-\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n-\t\t    &self_type))\n-\t\t{\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"failed to resolve type for self param\");\n-\t\t  return;\n-\t\t}\n-\n-\t      if (!fntype->has_subsititions_defined ())\n-\t\tfn_expr\n-\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t      true);\n-\t      else\n-\t\tfn_expr\n-\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t      true, fntype);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  TyTy::BaseType *self_type = nullptr;\n-\t  if (!ctx->get_tyctx ()->lookup_type (\n-\t\texpr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"failed to resolve type for self param\");\n-\t      return;\n-\t    }\n-\n-\t  if (!fntype->has_subsititions_defined ())\n-\t    fn_expr\n-\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t\t  true);\n-\t  else\n-\t    fn_expr\n-\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t\t  true, fntype);\n-\t}\n-    }\n+  HIR::PathExprSegment method_name = expr.get_method_name ();\n+  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n+  Bexpression *fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n \n   // lookup the autoderef mappings\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;"}, {"sha": "b332a684ad48ef34bf6bb2b3c8269afb64734e51", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 192, "deletions": 9, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -699,20 +699,203 @@ class TypeCheckExpr : public TypeCheckBase\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n \n-    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n-    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n-    bool valid = valid_lhs && valid_rhs;\n-    if (!valid)\n+    // in order to probe of the correct type paths we need the root type, which\n+    // strips any references\n+    const TyTy::BaseType *root = lhs->get_root ();\n+\n+    // look up lang item for arithmetic type\n+    std::vector<PathProbeCandidate> candidates;\n+    auto lang_item_type\n+      = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+    std::string associated_item_name\n+      = Analysis::RustLangItem::ToString (lang_item_type);\n+    DefId respective_lang_item_id = UNKNOWN_DEFID;\n+    bool lang_item_defined\n+      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+    // handle the case where we are within the impl block for this lang_item\n+    // otherwise we end up with a recursive operator overload such as the i32\n+    // operator overload trait\n+    if (lang_item_defined)\n+      {\n+\tTypeCheckContextItem &fn_context = context->peek_context ();\n+\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+\t  {\n+\t    auto &impl_item = fn_context.get_impl_item ();\n+\t    HIR::ImplBlock *parent = impl_item.first;\n+\t    HIR::Function *fn = impl_item.second;\n+\n+\t    if (parent->has_trait_ref ()\n+\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n+\t      {\n+\t\tTraitReference *trait_reference\n+\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t\tif (!trait_reference->is_error ())\n+\t\t  {\n+\t\t    TyTy::BaseType *lookup = nullptr;\n+\t\t    bool ok\n+\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t\t    rust_assert (ok);\n+\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t\t    rust_assert (fntype->is_method ());\n+\n+\t\t    bool is_lang_item_impl\n+\t\t      = trait_reference->get_mappings ().get_defid ()\n+\t\t\t== respective_lang_item_id;\n+\t\t    bool self_is_lang_item_self\n+\t\t      = fntype->get_self_type ()->is_equal (*lhs);\n+\n+\t\t    bool recursive_operator_overload\n+\t\t      = is_lang_item_impl && self_is_lang_item_self;\n+\t\t    lang_item_defined = !recursive_operator_overload;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // probe for the lang-item\n+    if (lang_item_defined)\n+      {\n+\tbool receiver_is_type_param\n+\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !receiver_is_generic;\n+\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n+\n+\tcandidates = PathProbeType::Probe (\n+\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n+\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n+      }\n+\n+    bool have_implementation_for_lang_item = candidates.size () > 0;\n+    if (!lang_item_defined || !have_implementation_for_lang_item)\n+      {\n+\tbool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+\tbool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+\tbool valid = valid_lhs && valid_rhs;\n+\tif (!valid)\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"cannot apply this operator to types %s and %s\",\n+\t\t\t   lhs->as_string ().c_str (),\n+\t\t\t   rhs->as_string ().c_str ());\n+\t    return;\n+\t  }\n+\n+\tinfered = lhs->unify (rhs);\n+\treturn;\n+      }\n+\n+    // now its just like a method-call-expr\n+    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+    // autoderef\n+    std::vector<Adjustment> adjustments;\n+    PathProbeCandidate *resolved_candidate\n+      = MethodResolution::Select (candidates, lhs, adjustments);\n+    rust_assert (resolved_candidate != nullptr);\n+\n+    // store the adjustments for code-generation to know what to do\n+    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\tstd::move (adjustments));\n+\n+    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n+    NodeId resolved_node_id\n+      = resolved_candidate->is_impl_candidate ()\n+\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n+\t      .get_nodeid ()\n+\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n+\t      .get_nodeid ();\n+\n+    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::BaseType *lookup = lookup_tyty;\n+    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (fn->is_method ());\n+\n+    if (root->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+\tif (adt->has_substitutions () && fn->needs_substitution ())\n+\t  {\n+\t    // consider the case where we have:\n+\t    //\n+\t    // struct Foo<X,Y>(X,Y);\n+\t    //\n+\t    // impl<T> Foo<T, i32> {\n+\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t    // }\n+\t    //\n+\t    // In this case we end up with an fn type of:\n+\t    //\n+\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t    //\n+\t    // This means the instance or self we are calling this method for\n+\t    // will be substituted such that we can get the inherited type\n+\t    // arguments but then need to use the turbo fish if available or\n+\t    // infer the remaining arguments. Luckily rust does not allow for\n+\t    // default types GenericParams on impl blocks since these must\n+\t    // always be at the end of the list\n+\n+\t    auto s = fn->get_self_type ()->get_root ();\n+\t    rust_assert (s->can_eq (adt, false, false));\n+\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t    const TyTy::ADTType *self_adt\n+\t      = static_cast<const TyTy::ADTType *> (s);\n+\n+\t    // we need to grab the Self substitutions as the inherit type\n+\t    // parameters for this\n+\t    if (self_adt->needs_substitution ())\n+\t      {\n+\t\trust_assert (adt->was_substituted ());\n+\n+\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t  = GetUsedSubstArgs::From (adt);\n+\n+\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n+\t\t    used_args_in_prev_segment);\n+\n+\t\t// there may or may not be inherited type arguments\n+\t\tif (!inherit_type_args.is_error ())\n+\t\t  {\n+\t\t    // need to apply the inherited type arguments to the\n+\t\t    // function\n+\t\t    lookup = fn->handle_substitions (inherit_type_args);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // type check the arguments\n+    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (type->num_params () == 2);\n+    auto fnparam = type->param_at (1);\n+    auto resolved_argument_type = fnparam.second->unify (rhs);\n+    if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"cannot apply this operator to types %s and %s\",\n-\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+\t\t       \"Type Resolution failure on parameter\");\n \treturn;\n       }\n \n-    infered = lhs->unify (rhs);\n-    infered->append_reference (lhs->get_ref ());\n-    infered->append_reference (rhs->get_ref ());\n+    // get the return type\n+    TyTy::BaseType *function_ret_tyty = fn->get_return_type ()->clone ();\n+\n+    // store the expected fntype\n+    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+    // set up the resolved name on the path\n+    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t    resolved_node_id);\n+\n+    // return the result of the function back\n+    infered = function_ret_tyty;\n   }\n \n   void visit (HIR::ComparisonExpr &expr) override"}, {"sha": "1add4faa59ae1aba9a1d8a2425d14e9a505329a2", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -296,6 +296,24 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_operator_overload (HirId id, TyTy::FnType *call_site)\n+  {\n+    auto it = operator_overloads.find (id);\n+    rust_assert (it == operator_overloads.end ());\n+\n+    operator_overloads[id] = call_site;\n+  }\n+\n+  bool lookup_operator_overload (HirId id, TyTy::FnType **call)\n+  {\n+    auto it = operator_overloads.find (id);\n+    if (it == operator_overloads.end ())\n+      return false;\n+\n+    *call = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -318,6 +336,9 @@ class TypeCheckContext\n   // adjustment mappings\n   std::map<HirId, std::vector<Adjustment>> autoderef_mappings;\n \n+  // operator overloads\n+  std::map<HirId, TyTy::FnType *> operator_overloads;\n+\n   // variants\n   std::map<HirId, HirId> variants;\n };"}, {"sha": "e52b3947980bb77c7b646741c246a12068cc5b40", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_1.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+impl Add for i32 {\n+    type Output = i32;\n+\n+    fn add(self, other: i32) -> i32 {\n+        let res = self + other;\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = 1 + 2;\n+\n+    0\n+}"}, {"sha": "9d5615d13814d882d04493145447adaf0a9dc8a0", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_2.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+struct Foo(i32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, other: Foo) -> Foo {\n+        let res = Foo(self.0 + other.0);\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res.0);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(1) + Foo(2);\n+\n+    0\n+}"}, {"sha": "bd99b50a4fd567cd2e7028a231520791952b4c19", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_3.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d5cbdee9b701fb7753b44530fcb51f80b20fa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs?ref=c47d5cbdee9b701fb7753b44530fcb51f80b20fa", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-output \"3\\n3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+impl Add for i32 {\n+    type Output = i32;\n+\n+    fn add(self, other: i32) -> i32 {\n+        let res = self + other;\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res);\n+        }\n+\n+        res\n+    }\n+}\n+\n+struct Foo(i32);\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, other: Foo) -> Foo {\n+        let res = Foo(self.0 + other.0);\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res.0);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(1) + Foo(2);\n+\n+    0\n+}"}]}