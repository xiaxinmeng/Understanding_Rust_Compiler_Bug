{"sha": "efe646c468656959236de0fbe2224561873fb189", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlNjQ2YzQ2ODY1Njk1OTIzNmRlMGZiZTIyMjQ1NjE4NzNmYjE4OQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-10-28T23:53:08Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-10-28T23:53:08Z"}, "message": "tree-ssa-strlen.c (get_addr_stridx): Add argument and use it.\n\n\ngcc/ChangeLog:\n\n\t* tree-ssa-strlen.c (get_addr_stridx): Add argument and use it.\n\t(handle_store): Pass argument to get_addr_stridx.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/strlenopt-89.c: New test.\n\t* gcc.dg/strlenopt-90.c: New test.\n\t* gcc.dg/Wstringop-overflow-20.c: New test.\n\nFrom-SVN: r277546", "tree": {"sha": "dbf3a51d2e92be9f3a8a1d7b0358423b3a5b815a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbf3a51d2e92be9f3a8a1d7b0358423b3a5b815a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efe646c468656959236de0fbe2224561873fb189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe646c468656959236de0fbe2224561873fb189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efe646c468656959236de0fbe2224561873fb189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe646c468656959236de0fbe2224561873fb189/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02c4de7631a177ea44149332aa1294a60ed9adad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02c4de7631a177ea44149332aa1294a60ed9adad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02c4de7631a177ea44149332aa1294a60ed9adad"}], "stats": {"total": 230, "additions": 227, "deletions": 3}, "files": [{"sha": "8b8a6c6f647d5371fb0baf3c810b9c4b5f9fbe94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe646c468656959236de0fbe2224561873fb189/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe646c468656959236de0fbe2224561873fb189/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efe646c468656959236de0fbe2224561873fb189", "patch": "@@ -1,3 +1,8 @@\n+2019-10-28  Martin Sebor  <msebor@redhat.com>\n+\n+\t* tree-ssa-strlen.c (get_addr_stridx): Add argument and use it.\n+\t(handle_store): Pass argument to get_addr_stridx.\n+\n 2019-10-28  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/92226"}, {"sha": "a3ef28625e414d70293cdb2369140bd83f4edbe4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=efe646c468656959236de0fbe2224561873fb189", "patch": "@@ -1,3 +1,9 @@\n+2019-10-28  Martin Sebor  <msebor@redhat.com>\n+\n+\t* gcc.dg/strlenopt-89.c: New test.\n+\t* gcc.dg/strlenopt-90.c: New test.\n+\t* gcc.dg/Wstringop-overflow-20.c: New test.\n+\n 2019-10-28  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/92226"}, {"sha": "4a6fe8ea35233657bf52cb4fd08ee08c5e96570f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-20.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-20.c?ref=efe646c468656959236de0fbe2224561873fb189", "patch": "@@ -0,0 +1,40 @@\n+/* PR tree-optimization/92226 - live nul char store to array eliminated\n+   Test to verify warnings are issued for overflow detected thanks to\n+   the enhancement committed on top of the fix for PR 92226.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+#define T(MIN, MAX, SIZE, IDX)\t\t\t\t\t\t\\\n+  NOIPA void\t\t\t\t\t\t\t\t\\\n+  test_ ## MIN ## _ ## MAX ## _ ## SIZE ## _ ## IDX (const char *s)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    size_t len = strlen (s);\t\t\t\t\t\t\\\n+    if (MIN <= len && len <= MAX)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\textern char d[];\t\t\t\t\t\t\\\n+\tstrcpy (d, s);\t\t\t\t\t\t\t\\\n+\td[IDX] = 0;\t\t\t\t\t\t\t\\\n+\textern char a ## SIZE[SIZE];\t\t\t\t\t\\\n+\tstrcpy (a ## SIZE, d);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } typedef void dummy_type\n+\n+\n+T (2, 2, 1, 0);\n+T (2, 2, 1, 1);     // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+T (2, 2, 1, 2);     // { dg-warning \"writing 3 bytes into a region of size 1\" }\n+\n+T (2, 3, 1, 0);\n+T (2, 3, 1, 1);     // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+T (2, 3, 1, 2);     // { dg-warning \"writing 3 bytes into a region of size 1\" \"\" { xfail *-*-*} }\n+T (2, 3, 1, 3);     // { dg-warning \"writing 4 bytes into a region of size 1\" \"\" { xfail *-*-* } }\n+\n+T (5, 7, 3, 1);\n+T (5, 7, 3, 2);\n+T (5, 7, 3, 3);     // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+T (5, 7, 3, 4);     // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+T (5, 7, 3, 5);     // { dg-warning \"writing 6 bytes into a region of size 3\" \"\" { xfail *-*-* } }"}, {"sha": "ead451ffb0e812284d04f84d25ca07ea047f24d6", "filename": "gcc/testsuite/gcc.dg/strlenopt-89.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-89.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-89.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-89.c?ref=efe646c468656959236de0fbe2224561873fb189", "patch": "@@ -0,0 +1,89 @@\n+/* PR tree-optimization/92226 - live nul char store to array eliminated\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+/* Verify that the nul store  into the destination is only eliminated\n+   when overwrites the existing terminating nul added by the strcpy call.\n+   Also verify that the second strlen call is eliminated in all cases.  */\n+#define T(SIZE, IDX)\t\t\t\t\t\t\t\\\n+  NOIPA void test_ ## SIZE ## _store_nul_ ## IDX (const char *s)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    extern char a ## SIZE[SIZE];\t\t\t\t\t\\\n+    char *d = a ## SIZE;\t\t\t\t\t\t\\\n+    size_t len = SIZE - 1;\t\t\t\t\t\t\\\n+    size_t idx = IDX;\t\t\t\t\t\t\t\\\n+    if (strlen (s) == len)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tstrcpy (d, s);\t\t\t\t\t\t\t\\\n+\td[idx] = 0;\t\t\t\t\t\t\t\\\n+\tif (strlen (d) != idx)\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } typedef void dummy_type\n+\n+\n+T (1, 0);   // expect nul store to be eliminated\n+\n+T (2, 0);   // nul store must be retained\n+T (2, 1);   // expect nul store to be eliminated\n+\n+// Same as above but for larger arrays.\n+T (3, 0);\n+T (3, 1);\n+T (3, 2);\n+\n+T (4, 0);\n+T (4, 1);\n+T (4, 2);\n+T (4, 3);\n+\n+T (5, 0);\n+T (5, 1);\n+T (5, 2);\n+T (5, 3);\n+T (5, 4);\n+\n+T (6, 0);\n+T (6, 1);\n+T (6, 2);\n+T (6, 3);\n+T (6, 4);\n+T (6, 5);\n+\n+T (7, 0);\n+T (7, 1);\n+T (7, 2);\n+T (7, 3);\n+T (7, 4);\n+T (7, 5);\n+T (7, 6);\n+\n+T (8, 0);\n+T (8, 1);\n+T (8, 2);\n+T (8, 3);\n+T (8, 4);\n+T (8, 5);\n+T (8, 6);\n+T (8, 7);\n+\n+/* Verify that each function makes just one call to strlen to compute\n+   the length of its argument (and not also to compute the length of\n+   the copy):\n+  { dg-final { scan-tree-dump-times \"strlen \\\\(s_\" 36 \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"strlen \\\\(\\\\&a\" \"strlen1\" } }\n+\n+  Verify that nul stores into the last array element have been eliminated\n+  (they are preceded by a strcpy storing into all the elements of the array:\n+  { dg-final { scan-tree-dump-not \"a1\\\\\\] = 0;\" \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"a2 \\\\\\+ 1B\\\\\\] = 0;\" \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"a3 \\\\\\+ 2B\\\\\\] = 0;\" \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"a4 \\\\\\+ 3B\\\\\\] = 0;\" \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"a5 \\\\\\+ 4B\\\\\\] = 0;\" \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"a6 \\\\\\+ 5B\\\\\\] = 0;\" \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"a7 \\\\\\+ 6B\\\\\\] = 0;\" \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"a8 \\\\\\+ 7B\\\\\\] = 0;\" \"strlen1\" } } */"}, {"sha": "2d4dad186720f050c5a9aa16d895bf817660230e", "filename": "gcc/testsuite/gcc.dg/strlenopt-90.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-90.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-90.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-90.c?ref=efe646c468656959236de0fbe2224561873fb189", "patch": "@@ -0,0 +1,83 @@\n+/* PR tree-optimization/92226 - live nul char store to array eliminated\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+#define T(MIN, MAX, SIZE, IDX)\t\t\t\t\t\t\\\n+  NOIPA void\t\t\t\t\t\t\t\t\\\n+  test_ ## MIN ## _ ## MAX ## _ ## SIZE ## _ ## IDX (const char *s)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    extern char a ## SIZE[SIZE];\t\t\t\t\t\\\n+    char *d = a ## SIZE;\t\t\t\t\t\t\\\n+    size_t len = strlen (s);\t\t\t\t\t\t\\\n+    size_t idx = IDX;\t\t\t\t\t\t\t\\\n+    if (MIN <= len && len <= MAX)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tstrcpy (d, s);\t\t\t\t\t\t\t\\\n+\td[idx] = 0;\t\t\t\t\t\t\t\\\n+\tif (strlen (d) != idx)\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } typedef void dummy_type\n+\n+\n+/* The final nul store must be retained but the second strlen call should\n+   be eliminated because the final length of the destination after the nul\n+   store must be equal to the index of the store.  */\n+T (0, 2, 4, 0);\n+\n+/* Not handled yet (see below):\n+   T (0, 2, 4, 1);  */\n+\n+/* Not handled yet: in addition to the cases above, the second strlen\n+   call can also be eliminated in those below because in both the final\n+   length of the destination after the nul store must be in the same\n+   range as the length of the source.\n+   T (0, 2, 4, 2);\n+   T (0, 2, 4, 3);  */\n+\n+T (2, 3, 4, 0);\n+T (2, 3, 4, 1);\n+\n+/* Not handled yet (see above):\n+   T (2, 3, 4, 2);\n+   T (2, 3, 4, 3);  */\n+\n+T (3, 4, 5, 0);\n+T (3, 4, 5, 1);\n+T (3, 4, 5, 2);\n+\n+/* Not handled yet (see above):\n+   T (3, 4, 5, 3);\n+   T (3, 4, 5, 4);  */\n+\n+T (3, 4, 6, 0);\n+T (3, 4, 6, 1);\n+T (3, 4, 6, 2);\n+\n+/* Not handled yet (see above):\n+   T (3, 4, 6, 3);\n+   T (3, 4, 6, 4);\n+   T (3, 4, 6, 5);  */\n+\n+\n+/* Verify that each function makes just one call to strlen to compute\n+   the length of its argument (and not also to compute the length of\n+   the copy):\n+  { dg-final { scan-tree-dump-times \"strlen \\\\(s_\" 9 \"strlen1\" } }\n+  { dg-final { scan-tree-dump-not \"strlen \\\\(\\\\&a\" \"strlen1\" } }\n+\n+  Verify that nul stores into the destination have not been eliminated:\n+  { dg-final { scan-tree-dump-times \"a4\\\\\\] = 0;\" 2 \"strlen1\" } }\n+  { dg-final { scan-tree-dump-times \"a4 \\\\\\+ 1B\\\\\\] = 0;\" 1 \"strlen1\" } }\n+\n+  { dg-final { scan-tree-dump-times \"a5\\\\\\] = 0;\" 1 \"strlen1\" } }\n+  { dg-final { scan-tree-dump-times \"a5 \\\\\\+ 1B\\\\\\] = 0;\" 1 \"strlen1\" } }\n+  { dg-final { scan-tree-dump-times \"a5 \\\\\\+ 2B\\\\\\] = 0;\" 1 \"strlen1\" } }\n+\n+  { dg-final { scan-tree-dump-times \"a6\\\\\\] = 0;\" 1 \"strlen1\" } }\n+  { dg-final { scan-tree-dump-times \"a6 \\\\\\+ 1B\\\\\\] = 0;\" 1 \"strlen1\" } }\n+  { dg-final { scan-tree-dump-times \"a6 \\\\\\+ 2B\\\\\\] = 0;\" 1 \"strlen1\" } }  */"}, {"sha": "50cc442a61f75924b2a6ac3a01d6ba7fde580e55", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe646c468656959236de0fbe2224561873fb189/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=efe646c468656959236de0fbe2224561873fb189", "patch": "@@ -281,7 +281,8 @@ get_next_strinfo (strinfo *si)\n    *OFFSET_OUT.  */\n \n static int\n-get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out)\n+get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n+\t\t const vr_values *rvals = NULL)\n {\n   HOST_WIDE_INT off;\n   struct stridxlist *list, *last = NULL;\n@@ -319,7 +320,7 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out)\n       unsigned HOST_WIDE_INT rel_off\n \t= (unsigned HOST_WIDE_INT) off - last->offset;\n       strinfo *si = get_strinfo (last->idx);\n-      if (si && compare_nonzero_chars (si, rel_off) >= 0)\n+      if (si && compare_nonzero_chars (si, rel_off, rvals) >= 0)\n \t{\n \t  if (offset_out)\n \t    {\n@@ -4328,7 +4329,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write, const vr_values *rval\n     }\n   else\n     {\n-      idx = get_addr_stridx (lhs, NULL_TREE, &offset);\n+      idx = get_addr_stridx (lhs, NULL_TREE, &offset, rvals);\n       if (idx > 0)\n \tsi = get_strinfo (idx);\n     }"}]}