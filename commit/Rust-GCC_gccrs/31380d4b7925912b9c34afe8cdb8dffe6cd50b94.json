{"sha": "31380d4b7925912b9c34afe8cdb8dffe6cd50b94", "node_id": "C_kwDOANBUbNoAKDMxMzgwZDRiNzkyNTkxMmI5YzM0YWZlOGNkYjhkZmZlNmNkNTBiOTQ", "commit": {"author": {"name": "zhongjuzhe", "email": "juzhe.zhong@rivai.ai", "date": "2022-08-27T11:07:56Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-08-29T02:16:06Z"}, "message": "RISC-V: Add RVV registers\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv.cc (riscv_v_ext_vector_mode_p): New function.\n\t(riscv_classify_address): Disallow PLUS/LO_SUM/CONST_INT address types for RVV.\n\t(riscv_address_insns): Add RVV modes condition.\n\t(riscv_binary_cost): Ditto.\n\t(riscv_rtx_costs): Adjust cost for RVV.\n\t(riscv_secondary_memory_needed): Add RVV modes condition.\n\t(riscv_hard_regno_nregs): Add RVV register allocation.\n\t(riscv_hard_regno_mode_ok): Add RVV register allocation.\n\t(riscv_class_max_nregs): Add RVV register allocation.\n\t* config/riscv/riscv.h (DWARF_FRAME_REGNUM): Add VL/VTYPE and vector registers in Dwarf.\n\t(UNITS_PER_V_REG): New macro.\n\t(FIRST_PSEUDO_REGISTER): Adjust first pseudo num for RVV.\n\t(V_REG_FIRST): New macro.\n\t(V_REG_LAST): Ditto.\n\t(V_REG_NUM): Ditto.\n\t(V_REG_P): Ditto.\n\t(VL_REG_P): Ditto.\n\t(VTYPE_REG_P): Ditto.\n\t(RISCV_DWARF_VL): Ditto.\n\t(RISCV_DWARF_VTYPE): Ditto.\n\t(enum reg_class): Add RVV register types.\n\t(REG_CLASS_CONTENTS): Add RVV register types.\n\t* config/riscv/riscv.md: Add VL/VTYPE register number constants.", "tree": {"sha": "ecd116c6a4a85decbbe5080821878ccc021a35dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd116c6a4a85decbbe5080821878ccc021a35dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31380d4b7925912b9c34afe8cdb8dffe6cd50b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31380d4b7925912b9c34afe8cdb8dffe6cd50b94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31380d4b7925912b9c34afe8cdb8dffe6cd50b94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31380d4b7925912b9c34afe8cdb8dffe6cd50b94/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b842690086b588349637125c114d5fdcbb79531f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b842690086b588349637125c114d5fdcbb79531f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b842690086b588349637125c114d5fdcbb79531f"}], "stats": {"total": 192, "additions": 173, "deletions": 19}, "files": [{"sha": "6341dc98daa8cda15d33659c1544ccacbe0691d7", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31380d4b7925912b9c34afe8cdb8dffe6cd50b94/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31380d4b7925912b9c34afe8cdb8dffe6cd50b94/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=31380d4b7925912b9c34afe8cdb8dffe6cd50b94", "patch": "@@ -279,7 +279,22 @@ const enum reg_class riscv_regno_to_class[FIRST_PSEUDO_REGISTER] = {\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  FRAME_REGS,\tFRAME_REGS,\n+  FRAME_REGS,\tFRAME_REGS,\tVL_REGS,\tVTYPE_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  VM_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n+  VD_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n+  VD_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n+  VD_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n+  VD_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n+  VD_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n+  VD_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n+  VD_REGS,\tVD_REGS,\tVD_REGS,\tVD_REGS,\n };\n \n /* Costs to use when optimizing for rocket.  */\n@@ -894,6 +909,14 @@ riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, machine_mode mode,\n   return true;\n }\n \n+/* Return true if mode is the RVV mode.  */\n+\n+static bool\n+riscv_v_ext_vector_mode_p (machine_mode mode)\n+{\n+  return VECTOR_MODE_P (mode);\n+}\n+\n /* Return true if X is a valid address for machine mode MODE.  If it is,\n    fill in INFO appropriately.  STRICT_P is true if REG_OK_STRICT is in\n    effect.  */\n@@ -912,13 +935,21 @@ riscv_classify_address (struct riscv_address_info *info, rtx x,\n       return riscv_valid_base_register_p (info->reg, mode, strict_p);\n \n     case PLUS:\n+      /* RVV load/store disallow any offset.  */\n+      if (riscv_v_ext_vector_mode_p (mode))\n+\treturn false;\n+\n       info->type = ADDRESS_REG;\n       info->reg = XEXP (x, 0);\n       info->offset = XEXP (x, 1);\n       return (riscv_valid_base_register_p (info->reg, mode, strict_p)\n \t      && riscv_valid_offset_p (info->offset, mode));\n \n     case LO_SUM:\n+      /* RVV load/store disallow LO_SUM.  */\n+      if (riscv_v_ext_vector_mode_p (mode))\n+\treturn false;\n+\n       info->type = ADDRESS_LO_SUM;\n       info->reg = XEXP (x, 0);\n       info->offset = XEXP (x, 1);\n@@ -937,6 +968,10 @@ riscv_classify_address (struct riscv_address_info *info, rtx x,\n \t      && riscv_valid_lo_sum_p (info->symbol_type, mode, info->offset));\n \n     case CONST_INT:\n+      /* RVV load/store disallow CONST_INT.  */\n+      if (riscv_v_ext_vector_mode_p (mode))\n+\treturn false;\n+\n       /* Small-integer addresses don't occur very often, but they\n \t are legitimate if x0 is a valid base register.  */\n       info->type = ADDRESS_CONST_INT;\n@@ -1022,7 +1057,7 @@ riscv_address_insns (rtx x, machine_mode mode, bool might_split_p)\n \n   /* BLKmode is used for single unaligned loads and stores and should\n      not count as a multiword mode. */\n-  if (mode != BLKmode && might_split_p)\n+  if (!riscv_v_ext_vector_mode_p (mode) && mode != BLKmode && might_split_p)\n     n += (GET_MODE_SIZE (mode).to_constant () + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n   if (addr.type == ADDRESS_LO_SUM)\n@@ -1759,7 +1794,8 @@ riscv_immediate_operand_p (int code, HOST_WIDE_INT x)\n static int\n riscv_binary_cost (rtx x, int single_insns, int double_insns)\n {\n-  if (GET_MODE_SIZE (GET_MODE (x)).to_constant () == UNITS_PER_WORD * 2)\n+  if (!riscv_v_ext_vector_mode_p (GET_MODE (x))\n+      && GET_MODE_SIZE (GET_MODE (x)).to_constant () == UNITS_PER_WORD * 2)\n     return COSTS_N_INSNS (double_insns);\n   return COSTS_N_INSNS (single_insns);\n }\n@@ -1806,6 +1842,14 @@ static bool\n riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t\t int *total, bool speed)\n {\n+  /* TODO: We set RVV instruction cost as 1 by default.\n+     Cost Model need to be well analyzed and supported in the future. */\n+  if (riscv_v_ext_vector_mode_p (mode))\n+    {\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+    }\n+\n   bool float_mode_p = FLOAT_MODE_P (mode);\n   int cost;\n \n@@ -4869,7 +4913,8 @@ static bool\n riscv_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n \t\t\t       reg_class_t class2)\n {\n-  return (GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD\n+  return (!riscv_v_ext_vector_mode_p (mode)\n+\t  && GET_MODE_SIZE (mode).to_constant () > UNITS_PER_WORD\n \t  && (class1 == FP_REGS) != (class2 == FP_REGS));\n }\n \n@@ -4891,6 +4936,25 @@ riscv_register_move_cost (machine_mode mode,\n static unsigned int\n riscv_hard_regno_nregs (unsigned int regno, machine_mode mode)\n {\n+  if (riscv_v_ext_vector_mode_p (mode))\n+    {\n+      /* Handle fractional LMUL, it only occupy part of vector register but\n+\t still need one vector register to hold.  */\n+      if (maybe_lt (GET_MODE_SIZE (mode), UNITS_PER_V_REG))\n+\treturn 1;\n+\n+      return exact_div (GET_MODE_SIZE (mode), UNITS_PER_V_REG).to_constant ();\n+    }\n+\n+  /* mode for VL or VTYPE are just a marker, not holding value,\n+     so it always consume one register.  */\n+  if (regno == VTYPE_REGNUM || regno == VL_REGNUM)\n+    return 1;\n+\n+  /* Assume every valid non-vector mode fits in one vector register.  */\n+  if (V_REG_P (regno))\n+    return 1;\n+\n   if (FP_REG_P (regno))\n     return (GET_MODE_SIZE (mode).to_constant () + UNITS_PER_FP_REG - 1) / UNITS_PER_FP_REG;\n \n@@ -4907,11 +4971,17 @@ riscv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \n   if (GP_REG_P (regno))\n     {\n+      if (riscv_v_ext_vector_mode_p (mode))\n+\treturn false;\n+\n       if (!GP_REG_P (regno + nregs - 1))\n \treturn false;\n     }\n   else if (FP_REG_P (regno))\n     {\n+      if (riscv_v_ext_vector_mode_p (mode))\n+\treturn false;\n+\n       if (!FP_REG_P (regno + nregs - 1))\n \treturn false;\n \n@@ -4926,6 +4996,19 @@ riscv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \t      && GET_MODE_UNIT_SIZE (mode) > UNITS_PER_FP_ARG))\n \treturn false;\n     }\n+  else if (V_REG_P (regno))\n+    {\n+      if (!riscv_v_ext_vector_mode_p (mode))\n+\treturn false;\n+\n+      /* 3.3.2. LMUL = 2,4,8, register numbers should be multiple of 2,4,8.\n+\t but for mask vector register, register numbers can be any number. */\n+      int lmul = 1;\n+      if (known_gt (GET_MODE_SIZE (mode), UNITS_PER_V_REG))\n+\tlmul = exact_div (GET_MODE_SIZE (mode), UNITS_PER_V_REG).to_constant ();\n+      if (lmul != 1)\n+\treturn ((regno % lmul) == 0);\n+    }\n   else\n     return false;\n \n@@ -4962,6 +5045,15 @@ riscv_class_max_nregs (reg_class_t rclass, machine_mode mode)\n   if (reg_class_subset_p (rclass, GR_REGS))\n     return riscv_hard_regno_nregs (GP_REG_FIRST, mode);\n \n+  if (reg_class_subset_p (rclass, V_REGS))\n+    return riscv_hard_regno_nregs (V_REG_FIRST, mode);\n+\n+  if (reg_class_subset_p (rclass, VL_REGS))\n+    return 1;\n+\n+  if (reg_class_subset_p (rclass, VTYPE_REGS))\n+    return 1;\n+\n   return 0;\n }\n "}, {"sha": "1d8139c2c9b5d3e086792f4e69c861c6aacf291d", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 75, "deletions": 15, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31380d4b7925912b9c34afe8cdb8dffe6cd50b94/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31380d4b7925912b9c34afe8cdb8dffe6cd50b94/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=31380d4b7925912b9c34afe8cdb8dffe6cd50b94", "patch": "@@ -122,8 +122,13 @@ ASM_MISA_SPEC\n #define DWARF_CIE_DATA_ALIGNMENT -4\n \n /* The mapping from gcc register number to DWARF 2 CFA column number.  */\n-#define DWARF_FRAME_REGNUM(REGNO) \\\n-  (GP_REG_P (REGNO) || FP_REG_P (REGNO) ? REGNO : INVALID_REGNUM)\n+#define DWARF_FRAME_REGNUM(REGNO)                                              \\\n+  (VL_REG_P (REGNO) ? RISCV_DWARF_VL                                           \\\n+   : VTYPE_REG_P (REGNO)                                                       \\\n+     ? RISCV_DWARF_VTYPE                                                       \\\n+     : (GP_REG_P (REGNO) || FP_REG_P (REGNO) || V_REG_P (REGNO)                \\\n+\t  ? REGNO                                                              \\\n+\t  : INVALID_REGNUM))\n \n /* The DWARF 2 CFA column which tracks the return address.  */\n #define DWARF_FRAME_RETURN_COLUMN RETURN_ADDR_REGNUM\n@@ -155,6 +160,8 @@ ASM_MISA_SPEC\n \n /* The `Q' extension is not yet supported.  */\n #define UNITS_PER_FP_REG (TARGET_DOUBLE_FLOAT ? 8 : 4)\n+/* Size per vector register. For zve32*, size = poly (4, 4). Otherwise, size = poly (8, 8). */\n+#define UNITS_PER_V_REG (riscv_vector_chunks * riscv_bytes_per_vector_chunk)\n \n /* The largest type that can be passed in floating-point registers.  */\n #define UNITS_PER_FP_ARG\t\t\t\t\t\t\\\n@@ -289,9 +296,13 @@ ASM_MISA_SPEC\n    - 32 floating point registers\n    - 2 fake registers:\n \t- ARG_POINTER_REGNUM\n-\t- FRAME_POINTER_REGNUM */\n+\t- FRAME_POINTER_REGNUM\n+   - 1 vl register\n+   - 1 vtype register\n+   - 30 unused registers for future expansion\n+   - 32 vector registers  */\n \n-#define FIRST_PSEUDO_REGISTER 66\n+#define FIRST_PSEUDO_REGISTER 128\n \n /* x0, sp, gp, and tp are fixed.  */\n \n@@ -303,7 +314,11 @@ ASM_MISA_SPEC\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   /* Others.  */\t\t\t\t\t\t\t\\\n-  1, 1\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* Vector registers.  */\t\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\t\t\t\\\n }\n \n /* a0-a7, t0-t6, fa0-fa7, and ft0-ft11 are volatile across calls.\n@@ -317,7 +332,11 @@ ASM_MISA_SPEC\n   1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\t\t\t\\\n   /* Others.  */\t\t\t\t\t\t\t\\\n-  1, 1\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* Vector registers.  */\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\\\n }\n \n /* Select a register mode required for caller save of hard regno REGNO.\n@@ -337,6 +356,10 @@ ASM_MISA_SPEC\n #define FP_REG_LAST  63\n #define FP_REG_NUM   (FP_REG_LAST - FP_REG_FIRST + 1)\n \n+#define V_REG_FIRST 96\n+#define V_REG_LAST  127\n+#define V_REG_NUM   (V_REG_LAST - V_REG_FIRST + 1)\n+\n /* The DWARF 2 CFA column which tracks the return address from a\n    signal handler context.  This means that to maintain backwards\n    compatibility, no hard register can be assigned this column if it\n@@ -347,6 +370,10 @@ ASM_MISA_SPEC\n   ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n #define FP_REG_P(REGNO)  \\\n   ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n+#define V_REG_P(REGNO)  \\\n+  ((unsigned int) ((int) (REGNO) - V_REG_FIRST) < V_REG_NUM)\n+#define VL_REG_P(REGNO) ((REGNO) == VL_REGNUM)\n+#define VTYPE_REG_P(REGNO) ((REGNO) == VTYPE_REGNUM)\n \n /* True when REGNO is in SIBCALL_REGS set.  */\n #define SIBCALL_REG_P(REGNO)\t\\\n@@ -364,6 +391,10 @@ ASM_MISA_SPEC\n #define ARG_POINTER_REGNUM 64\n #define FRAME_POINTER_REGNUM 65\n \n+/* Define Dwarf for RVV.  */\n+#define RISCV_DWARF_VL (4096 + 0xc20)\n+#define RISCV_DWARF_VTYPE (4096 + 0xc21)\n+\n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_TEMP_FIRST + 2)\n \n@@ -430,6 +461,11 @@ enum reg_class\n   GR_REGS,\t\t\t/* integer registers */\n   FP_REGS,\t\t\t/* floating-point registers */\n   FRAME_REGS,\t\t\t/* arg pointer and frame pointer */\n+  VL_REGS,\t\t\t/* vl register */\n+  VTYPE_REGS,\t\t\t/* vype register */\n+  VM_REGS,\t\t\t/* v0.t registers */\n+  VD_REGS,\t\t\t/* vector registers except v0.t */\n+  V_REGS,\t\t\t/* vector registers */\n   ALL_REGS,\t\t\t/* all registers */\n   LIM_REG_CLASSES\t\t/* max value + 1 */\n };\n@@ -450,6 +486,11 @@ enum reg_class\n   \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FRAME_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"VL_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"VTYPE_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"VM_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"VD_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"V_REGS\",\t\t\t\t\t\t\t\t\\\n   \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n }\n \n@@ -466,13 +507,18 @@ enum reg_class\n \n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n-  { 0xf003fcc0, 0x00000000, 0x00000000 },\t/* SIBCALL_REGS */\t\\\n-  { 0xffffffc0, 0x00000000, 0x00000000 },\t/* JALR_REGS */\t\t\\\n-  { 0xffffffff, 0x00000000, 0x00000000 },\t/* GR_REGS */\t\t\\\n-  { 0x00000000, 0xffffffff, 0x00000000 },\t/* FP_REGS */\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000003 },\t/* FRAME_REGS */\t\\\n-  { 0xffffffff, 0xffffffff, 0x00000003 }\t/* ALL_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n+  { 0xf003fcc0, 0x00000000, 0x00000000, 0x00000000 },\t/* SIBCALL_REGS */\t\\\n+  { 0xffffffc0, 0x00000000, 0x00000000, 0x00000000 },\t/* JALR_REGS */\t\t\\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },\t/* GR_REGS */\t\t\\\n+  { 0x00000000, 0xffffffff, 0x00000000, 0x00000000 },\t/* FP_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000003, 0x00000000 },\t/* FRAME_REGS */\t\\\n+  { 0x00000000, 0x00000000, 0x00000004, 0x00000000 },\t/* VL_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000008, 0x00000000 },\t/* VTYPE_REGS */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000001 },\t/* V0_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0xfffffffe },\t/* VNoV0_REGS */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0xffffffff },\t/* V_REGS */\t\t\\\n+  { 0xffffffff, 0xffffffff, 0x00000003, 0x00000000 }\t/* ALL_REGS */\t\t\\\n }\n \n /* A C expression whose value is a register class containing hard\n@@ -512,9 +558,16 @@ enum reg_class\n   60, 61, 62, 63,\t\t\t\t\t\t\t\\\n   /* Call-saved FPRs.  */\t\t\t\t\t\t\\\n   40, 41, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\t\t\t\\\n+  /* V24 ~ V31.  */\t\t\t\t\t\t\t\\\n+  120, 121, 122, 123, 124, 125, 126, 127,\t\t\t\t\\\n+  /* V8 ~ V23.  */\t\t\t\t\t\t\t\\\n+  104, 105, 106, 107, 108, 109, 110, 111,\t\t\t\t\\\n+  112, 113, 114, 115, 116, 117, 118, 119,\t\t\t\t\\\n+  /* V0 ~ V7.  */\t\t\t\t\t\t\t\\\n+  96, 97, 98, 99, 100, 101, 102, 103,\t\t\t\t\t\\\n   /* None of the remaining classes have defined call-saved\t\t\\\n      registers.  */\t\t\t\t\t\t\t\\\n-  64, 65\t\t\t\t\t\t\t\t\\\n+  64, 65, 66, 67\t\t\t\t\t\t\t\\\n }\n \n /* True if VALUE is a signed 12-bit number.  */\n@@ -783,7 +836,14 @@ typedef struct {\n   \"fs0\", \"fs1\", \"fa0\", \"fa1\", \"fa2\", \"fa3\", \"fa4\", \"fa5\",\t\\\n   \"fa6\", \"fa7\", \"fs2\", \"fs3\", \"fs4\", \"fs5\", \"fs6\", \"fs7\",\t\\\n   \"fs8\", \"fs9\", \"fs10\",\"fs11\",\"ft8\", \"ft9\", \"ft10\",\"ft11\",\t\\\n-  \"arg\", \"frame\", }\n+  \"arg\", \"frame\", \"vl\", \"vtype\", \"N/A\", \"N/A\", \"N/A\", \"N/A\",    \\\n+  \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\",\t\\\n+  \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\",\t\\\n+  \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\", \"N/A\",\t\\\n+  \"v0\",  \"v1\",  \"v2\",  \"v3\",  \"v4\",  \"v5\",  \"v6\",  \"v7\",\t\\\n+  \"v8\",  \"v9\",  \"v10\", \"v11\", \"v12\", \"v13\", \"v14\", \"v15\",\t\\\n+  \"v16\", \"v17\", \"v18\", \"v19\", \"v20\", \"v21\", \"v22\", \"v23\",\t\\\n+  \"v24\", \"v25\", \"v26\", \"v27\", \"v28\", \"v29\", \"v30\", \"v31\",}\n \n #define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "63bb3c8debc04530fd703b319d2c0dbda96d4fe5", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31380d4b7925912b9c34afe8cdb8dffe6cd50b94/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31380d4b7925912b9c34afe8cdb8dffe6cd50b94/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=31380d4b7925912b9c34afe8cdb8dffe6cd50b94", "patch": "@@ -118,6 +118,8 @@\n    (NORMAL_RETURN\t\t0)\n    (SIBCALL_RETURN\t\t1)\n    (EXCEPTION_RETURN\t\t2)\n+   (VL_REGNUM\t\t\t66)\n+   (VTYPE_REGNUM\t\t67)\n ])\n \n (include \"predicates.md\")"}]}