{"sha": "42907632860e44cc8c8b49a0b74444f62791fb9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5MDc2MzI4NjBlNDRjYzhjOGI0OWEwYjc0NDQ0ZjYyNzkxZmI5Yw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-04-06T09:15:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:15:21Z"}, "message": "a-calend-vms.ads, [...]: New version of Ada.Calendar which supports the new upper bound of Ada time...\n\n2007-04-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Vincent Celier  <celier@adacore.com>\n\n\t* a-calend-vms.ads, a-calend.ads, a-calend.adb, a-calend-vms.adb:\n\tNew version of Ada.Calendar which supports the new upper bound of Ada\n\ttime (2399-12-31 86_399.999999999).\n\tThe following modifications have been made to the package:\n\t - New representation of time as count of nanoseconds since the start of\n\t   Ada time (1901-1-1 0.0).\n\t - Target independent Split and Time_Of routines which service both\n\t   Ada 95 and Ada 2005 code.\n\t - Target independent interface to the Ada 2005 children of Calendar.\n\t - Integrated leap seconds into Ada 95 and Ada 2005 mode.\n\t - Handling of non-leap centenial years.\n\t - Updated clock function.\n\t - Updated arithmetic and comparison operators.\n\n\t* a-caldel.adb (To_Duration): Add call to target independent routine in\n\tAda.Calendar to handle the conversion of time to duration.\n\n\t* sysdep.c (__gnat_localtime_tzoff): Test timezone before setting off\n\t(UTC Offset).\n\tIf timezone is obviously incorrect (outside of -14 hours .. 14 hours),\n\tset off to 0.\n\t(__gnat_localtime_tzoff for Lynx and VxWorks): Even though these\n\ttargets do not have a natural time zone, GMT is used as a default.\n\t(__gnat_get_task_options): New.\n\n\t* a-direct.adb (Modification_Time): Add with and use clauses for\n\tAda.Calendar and Ada.\n\tCalendar.Formatting. Remove with clause for Ada.Unchecked_Conversion\n\tsince it is no longer needed.\n\t(Duration_To_Time): Removed.\n\t(OS_Time_To_Long_Integer): Removed.\n\t(Modification_Time): Rewritten to use Ada.Calendar and Ada.Calendar.\n\tFormatting Time_Of routines which automatically handle time zones,\n\tbuffer periods and leap seconds.\n\n\t* a-calari.ads, a-calari.adb (\"+\", \"-\", Difference): Add calls to\n\ttarget independent routines in Ada.Calendar.\n\n\t* a-calfor.ads, a-calfor.adb: \n\tCode cleanup and addition of validity checks in various routines.\n\t(Day_Of_Week, Split, Time_Of): Add call to target independent routine in\n\tAda.Calendar.\n\n\t* a-catizo.ads, a-catizo.adb (UTC_Time_Offset): Add call to target\n\tindependent routine in Ada.Calendar.\n\nFrom-SVN: r123543", "tree": {"sha": "7a061f08c1577dcad5f77bb59e183a711e8af6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a061f08c1577dcad5f77bb59e183a711e8af6e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42907632860e44cc8c8b49a0b74444f62791fb9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42907632860e44cc8c8b49a0b74444f62791fb9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42907632860e44cc8c8b49a0b74444f62791fb9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42907632860e44cc8c8b49a0b74444f62791fb9c/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d3bf932b985baee7ac3973208c0d775dcb93b5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3bf932b985baee7ac3973208c0d775dcb93b5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d3bf932b985baee7ac3973208c0d775dcb93b5d"}], "stats": {"total": 4344, "additions": 2933, "deletions": 1411}, "files": [{"sha": "bf1e103dedfe07f9979a3d3387f58f6e907996ba", "filename": "gcc/ada/a-calari.adb", "status": "modified", "additions": 24, "deletions": 67, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calari.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calari.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calari.adb?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -31,112 +31,69 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Unchecked_Conversion;\n-\n package body Ada.Calendar.Arithmetic is\n \n-   use Leap_Sec_Ops;\n+   --------------------------\n+   -- Implementation Notes --\n+   --------------------------\n \n-   Day_Duration : constant Duration := 86_400.0;\n+   --  All operations in this package are target and time representation\n+   --  independent, thus only one source file is needed for multiple targets.\n \n    ---------\n    -- \"+\" --\n    ---------\n \n    function \"+\" (Left : Time; Right : Day_Count) return Time is\n+      R : constant Long_Integer := Long_Integer (Right);\n    begin\n-      return Left + Integer (Right) * Day_Duration;\n+      return Arithmetic_Operations.Add (Left, R);\n    end \"+\";\n \n    function \"+\" (Left : Day_Count; Right : Time) return Time is\n+      L : constant Long_Integer := Long_Integer (Left);\n    begin\n-      return Integer (Left) * Day_Duration + Right;\n+      return Arithmetic_Operations.Add (Right, L);\n    end \"+\";\n \n    ---------\n    -- \"-\" --\n    ---------\n \n    function \"-\" (Left : Time; Right : Day_Count) return Time is\n+      R : constant Long_Integer := Long_Integer (Right);\n    begin\n-      return Left - Integer (Right) * Day_Duration;\n+      return Arithmetic_Operations.Subtract (Left, R);\n    end \"-\";\n \n    function \"-\" (Left, Right : Time) return Day_Count is\n-      Days         : Day_Count;\n+      Days         : Long_Integer;\n       Seconds      : Duration;\n-      Leap_Seconds : Leap_Seconds_Count;\n-\n+      Leap_Seconds : Integer;\n    begin\n-      Difference (Left, Right, Days, Seconds, Leap_Seconds);\n-      return Days;\n+      Arithmetic_Operations.Difference\n+        (Left, Right, Days, Seconds, Leap_Seconds);\n+      return Day_Count (Days);\n    end \"-\";\n \n    ----------------\n    -- Difference --\n    ----------------\n \n    procedure Difference\n-     (Left, Right  : Time;\n+     (Left         : Time;\n+      Right        : Time;\n       Days         : out Day_Count;\n       Seconds      : out Duration;\n       Leap_Seconds : out Leap_Seconds_Count)\n    is\n-      Diff        : Duration;\n-      Earlier     : Time;\n-      Later       : Time;\n-      Leaps_Dur   : Duration;\n-      Negate      : Boolean;\n-      Next_Leap   : Time;\n-      Secs_Diff   : Long_Integer;\n-      Sub_Seconds : Duration;\n-\n+      Op_Days  : Long_Integer;\n+      Op_Leaps : Integer;\n    begin\n-      if Left >= Right then\n-         Later   := Left;\n-         Earlier := Right;\n-         Negate  := False;\n-      else\n-         Later   := Right;\n-         Earlier := Left;\n-         Negate  := True;\n-      end if;\n-\n-      Diff := Later - Earlier;\n-\n-      Cumulative_Leap_Secs (Earlier, Later, Leaps_Dur, Next_Leap);\n-\n-      if Later >= Next_Leap then\n-         Leaps_Dur := Leaps_Dur + 1.0;\n-      end if;\n-\n-      Diff := Diff - Leaps_Dur;\n-\n-      declare\n-         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n-         for D_Int'Size use Duration'Size;\n-\n-         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n-         D_As_Int  : D_Int;\n-\n-         function To_D_As_Int is new Unchecked_Conversion (Duration, D_Int);\n-         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n-\n-      begin\n-         D_As_Int    := To_D_As_Int (Diff);\n-         Secs_Diff   := Long_Integer (D_As_Int / Small_Div);\n-         Sub_Seconds := To_Duration (D_As_Int rem Small_Div);\n-      end;\n-\n-      Days    := Day_Count (Secs_Diff / 86_400);\n-      Seconds := Duration (Secs_Diff mod 86_400) + Sub_Seconds;\n-      Leap_Seconds := Leap_Seconds_Count (Leaps_Dur);\n-\n-      if Negate then\n-         Days         := -Days;\n-         Seconds      := -Seconds;\n-         Leap_Seconds := -Leap_Seconds;\n-      end if;\n+      Arithmetic_Operations.Difference\n+        (Left, Right, Op_Days, Seconds, Op_Leaps);\n+      Days := Day_Count (Op_Days);\n+      Leap_Seconds := Leap_Seconds_Count (Op_Leaps);\n    end Difference;\n \n end Ada.Calendar.Arithmetic;"}, {"sha": "95967a6e8517ba54dbedbe5780a4ffc279838a63", "filename": "gcc/ada/a-calari.ads", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calari.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calari.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calari.ads?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---        Copyright (C) 2005 - 2006, Free Software Foundation, Inc.         --\n+--         Copyright (C) 2005-2006, Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,26 +35,51 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  This package provides arithmetic operations of time values using days\n+--  and leap seconds. Ada.Calendar.Arithmetic is defined in the Ada 2005\n+--  RM (9.6.1).\n+\n package Ada.Calendar.Arithmetic is\n \n    --  Arithmetic on days:\n \n+   --  Rough estimate on the number of days over the range of Ada time\n+\n    type Day_Count is range\n      -(366 * (1 + Year_Number'Last - Year_Number'First))\n         ..\n      +(366 * (1 + Year_Number'Last - Year_Number'First));\n \n+   --  Negative leap seconds occur whenever the astronomical time is faster\n+   --  than the atomic time or as a result of Difference when Left < Right.\n+\n    subtype Leap_Seconds_Count is Integer range -2047 .. 2047;\n \n    procedure Difference\n-     (Left, Right  : Time;\n+     (Left         : Time;\n+      Right        : Time;\n       Days         : out Day_Count;\n       Seconds      : out Duration;\n       Leap_Seconds : out Leap_Seconds_Count);\n+   --  Returns the difference between Left and Right. Days is the number of\n+   --  days of difference, Seconds is the remainder seconds of difference\n+   --  excluding leap seconds, and Leap_Seconds is the number of leap seconds.\n+   --  If Left < Right, then Seconds <= 0.0, Days <= 0, and Leap_Seconds <= 0,\n+   --  otherwise all values are nonnegative. The absolute value of Seconds is\n+   --  always less than 86_400.0. For the returned values, if Days = 0, then\n+   --  Seconds + Duration (Leap_Seconds) = Calendar.\"-\" (Left, Right)\n+\n+   function \"+\" (Left : Time;      Right : Day_Count) return Time;\n+   function \"+\" (Left : Day_Count; Right : Time)      return Time;\n+   --  Adds a number of days to a time value. Time_Error is raised if the\n+   --  result is not representable as a value of type Time.\n+\n+   function \"-\" (Left : Time;      Right : Day_Count) return Time;\n+   --  Subtracts a number of days from a time value. Time_Error is raised if\n+   --  the result is not representable as a value of type Time.\n \n-   function \"+\" (Left : Time; Right : Day_Count) return Time;\n-   function \"+\" (Left : Day_Count; Right : Time) return Time;\n-   function \"-\" (Left : Time; Right : Day_Count) return Time;\n-   function \"-\" (Left, Right : Time) return Day_Count;\n+   function \"-\" (Left : Time;      Right : Time)      return Day_Count;\n+   --  Subtracts two time values, and returns the number of days between them.\n+   --  This is the same value that Difference would return in Days.\n \n end Ada.Calendar.Arithmetic;"}, {"sha": "8c42afb6d13df710dceae31fc13d421577efc916", "filename": "gcc/ada/a-caldel.adb", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-caldel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-caldel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-caldel.adb?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2005, AdaCore                     --\n+--                     Copyright (C) 1995-2006, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,12 +54,12 @@ package body Ada.Calendar.Delays is\n \n    use System.Traces;\n \n-   --  Earlier, the following operations were implemented using\n-   --  System.Time_Operations.  The idea was to avoid sucking in the tasking\n-   --  packages.  This did not work.  Logically, we can't have it both ways.\n-   --  There is no way to implement time delays that will have correct task\n-   --  semantics without reference to the tasking run-time system.\n-   --  To achieve this goal, we now use soft links.\n+   --  Earlier, System.Time_Opeations was used to implement the following\n+   --  operations. The idea was to avoid sucking in the tasking packages. This\n+   --  did not work. Logically, we can't have it both ways. There is no way to\n+   --  implement time delays that will have correct task semantics without\n+   --  reference to the tasking run-time system. To achieve this goal, we now\n+   --  use soft links.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -120,18 +120,23 @@ package body Ada.Calendar.Delays is\n \n    function To_Duration (T : Time) return Duration is\n    begin\n-      return Duration (T);\n+      --  Since time has multiple representations on different platforms, a\n+      --  target independent operation in Ada.Calendar is used to perform\n+      --  this conversion.\n+\n+      return Delays_Operations.To_Duration (T);\n    end To_Duration;\n \n begin\n-   --  Set up the Timed_Delay soft link to the non tasking version\n-   --  if it has not been already set.\n+   --  Set up the Timed_Delay soft link to the non tasking version if it has\n+   --  not been already set.\n \n-   --  If tasking is present, Timed_Delay has already set this soft\n-   --  link, or this will be overriden during the elaboration of\n+   --  If tasking is present, Timed_Delay has already set this soft link, or\n+   --  this will be overriden during the elaboration of\n    --  System.Tasking.Initialization\n \n    if SSL.Timed_Delay = null then\n       SSL.Timed_Delay := Timed_Delay_NT'Access;\n    end if;\n+\n end Ada.Calendar.Delays;"}, {"sha": "7c8fa12bbfeccff7d2090744c5b193d187c54cc0", "filename": "gcc/ada/a-calend-vms.adb", "status": "modified", "additions": 852, "deletions": 198, "changes": 1050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.adb?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -35,45 +35,90 @@\n \n with System.Aux_DEC; use System.Aux_DEC;\n \n+with Ada.Unchecked_Conversion;\n+\n package body Ada.Calendar is\n \n-   ------------------------------\n-   -- Use of Pragma Unsuppress --\n-   ------------------------------\n+   --------------------------\n+   -- Implementation Notes --\n+   --------------------------\n \n-   --  This implementation of Calendar takes advantage of the permission in\n-   --  Ada 95 of using arithmetic overflow checks to check for out of bounds\n-   --  time values. This means that we must catch the constraint error that\n-   --  results from arithmetic overflow, so we use pragma Unsuppress to make\n-   --  sure that overflow is enabled, using software overflow checking if\n-   --  necessary. That way, compiling Calendar with options to suppress this\n-   --  checking will not affect its correctness.\n+   --  Variables of type Ada.Calendar.Time have suffix _S or _M to denote\n+   --  units of seconds or milis.\n \n-   ------------------------\n-   -- Local Declarations --\n-   ------------------------\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n \n-   Ada_Year_Min : constant := 1901;\n-   Ada_Year_Max : constant := 2099;\n+   function All_Leap_Seconds return Natural;\n+   --  Return the number of all leap seconds allocated so far\n+\n+   procedure Cumulative_Leap_Seconds\n+     (Start_Date    : Time;\n+      End_Date      : Time;\n+      Elapsed_Leaps : out Natural;\n+      Next_Leap_Sec : out Time);\n+   --  Elapsed_Leaps is the sum of the leap seconds that have occured on or\n+   --  after Start_Date and before (strictly before) End_Date. Next_Leap_Sec\n+   --  represents the next leap second occurence on or after End_Date. If there\n+   --  are no leaps seconds after End_Date, After_Last_Leap is returned.\n+   --  After_Last_Leap can be used as End_Date to count all the leap seconds\n+   --  that have occured on or after Start_Date.\n+   --\n+   --  Note: Any sub seconds of Start_Date and End_Date are discarded before\n+   --  the calculations are done. For instance: if 113 seconds is a leap\n+   --  second (it isn't) and 113.5 is input as an End_Date, the leap second\n+   --  at 113 will not be counted in Leaps_Between, but it will be returned\n+   --  as Next_Leap_Sec. Thus, if the caller wants to know if the End_Date is\n+   --  a leap second, the comparison should be:\n+   --\n+   --     End_Date >= Next_Leap_Sec;\n+   --\n+   --  After_Last_Leap is designed so that this comparison works without\n+   --  having to first check if Next_Leap_Sec is a valid leap second.\n+\n+   function To_Duration (T : Time) return Duration;\n+   function To_Relative_Time (D : Duration) return Time;\n+   --  It is important to note that duration's fractional part denotes nano\n+   --  seconds while the units of Time are 100 nanoseconds. If a regular\n+   --  Unchecked_Conversion was employed, the resulting values would be off\n+   --  by 100.\n \n-   --  Some basic constants used throughout\n+   ---------------------\n+   -- Local Constants --\n+   ---------------------\n \n-   function To_Relative_Time (D : Duration) return Time;\n+   After_Last_Leap : constant Time := Time'Last;\n+   N_Leap_Seconds  : constant Natural := 23;\n \n-   function To_Relative_Time (D : Duration) return Time is\n-   begin\n-      return Time (Long_Integer'Integer_Value (D) / 100);\n-   end To_Relative_Time;\n+   Cumulative_Days_Before_Month :\n+     constant array (Month_Number) of Natural :=\n+       (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n+\n+   Leap_Second_Times : array (1 .. N_Leap_Seconds) of Time;\n+   --  Each value represents a time value which is one second before a leap\n+   --  second occurence. This table is populated during the elaboration of\n+   --  Ada.Calendar.\n \n    ---------\n    -- \"+\" --\n    ---------\n \n    function \"+\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n+\n+      Ada_High_And_Leaps : constant Time :=\n+                             Ada_High + Time (All_Leap_Seconds) * Mili;\n+      Result             : constant Time := Left + To_Relative_Time (Right);\n+\n    begin\n-      return (Left + To_Relative_Time (Right));\n+      if Result < Ada_Low\n+        or else Result >= Ada_High_And_Leaps\n+      then\n+         raise Time_Error;\n+      end if;\n \n+      return Result;\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -82,8 +127,7 @@ package body Ada.Calendar is\n    function \"+\" (Left : Duration; Right : Time) return Time is\n       pragma Unsuppress (Overflow_Check);\n    begin\n-      return (To_Relative_Time (Left) + Right);\n-\n+      return Right + Left;\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -93,10 +137,21 @@ package body Ada.Calendar is\n    -- \"-\" --\n    ---------\n \n-   function \"-\" (Left : Time; Right : Duration)  return Time is\n+   function \"-\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n+\n+      Ada_High_And_Leaps : constant Time :=\n+                             Ada_High + Time (All_Leap_Seconds) * Mili;\n+      Result             : constant Time := Left - To_Relative_Time (Right);\n+\n    begin\n-      return Left - To_Relative_Time (Right);\n+      if Result < Ada_Low\n+        or else Result >= Ada_High_And_Leaps\n+      then\n+         raise Time_Error;\n+      end if;\n+\n+      return Result;\n \n    exception\n       when Constraint_Error =>\n@@ -105,9 +160,19 @@ package body Ada.Calendar is\n \n    function \"-\" (Left : Time; Right : Time) return Duration is\n       pragma Unsuppress (Overflow_Check);\n+\n+      Diff     : constant Time := Left - Right;\n+      Dur_High : constant Time := Time (Duration'Last) * 100;\n+      Dur_Low  : constant Time := Time (Duration'First) * 100;\n+\n    begin\n-      return Duration'Fixed_Value\n-        ((Long_Integer (Left) - Long_Integer (Right)) * 100);\n+      if Diff < Dur_Low\n+        or else Diff > Dur_High\n+      then\n+         raise Time_Error;\n+      end if;\n+\n+      return To_Duration (Diff);\n \n    exception\n       when Constraint_Error =>\n@@ -150,64 +215,194 @@ package body Ada.Calendar is\n       return Long_Integer (Left) >= Long_Integer (Right);\n    end \">=\";\n \n+   ----------------------\n+   -- All_Leap_Seconds --\n+   ----------------------\n+\n+   function All_Leap_Seconds return Natural is\n+   begin\n+      return N_Leap_Seconds;\n+   end All_Leap_Seconds;\n+\n    -----------\n    -- Clock --\n    -----------\n \n-   --  The Ada.Calendar.Clock function gets the time.\n-   --  Note that on other targets a soft-link is used to get a different clock\n-   --  depending whether tasking is used or not. On VMS this isn't needed\n-   --  since all clock calls end up using SYS$GETTIM, so call the\n-   --  OS_Primitives version for efficiency.\n-\n    function Clock return Time is\n+      Elapsed_Leaps : Natural;\n+      Next_Leap     : Time;\n+      Now           : constant Time := Time (OSP.OS_Clock);\n+      Rounded_Now   : constant Time := Now - (Now mod Mili);\n+\n    begin\n-      return Time (OSP.OS_Clock);\n+      --  Note that on other targets a soft-link is used to get a different\n+      --  clock depending whether tasking is used or not. On VMS this isn't\n+      --  needed since all clock calls end up using SYS$GETTIM, so call the\n+      --  OS_Primitives version for efficiency.\n+\n+      --  Determine the number of leap seconds elapsed until this moment\n+\n+      Cumulative_Leap_Seconds (Ada_Low, Now, Elapsed_Leaps, Next_Leap);\n+\n+      --  It is possible that OS_Clock falls exactly on a leap second\n+\n+      if Rounded_Now = Next_Leap then\n+         return Now + Time (Elapsed_Leaps + 1) * Mili;\n+      else\n+         return Now + Time (Elapsed_Leaps) * Mili;\n+      end if;\n    end Clock;\n \n+   -----------------------------\n+   -- Cumulative_Leap_Seconds --\n+   -----------------------------\n+\n+   procedure Cumulative_Leap_Seconds\n+     (Start_Date    : Time;\n+      End_Date      : Time;\n+      Elapsed_Leaps : out Natural;\n+      Next_Leap_Sec : out Time)\n+   is\n+      End_Index   : Positive;\n+      End_T       : Time := End_Date;\n+      Start_Index : Positive;\n+      Start_T     : Time := Start_Date;\n+\n+   begin\n+      pragma Assert (Start_Date >= End_Date);\n+\n+      Next_Leap_Sec := After_Last_Leap;\n+\n+      --  Make sure that the end date does not excede the upper bound\n+      --  of Ada time.\n+\n+      if End_Date > Ada_High then\n+         End_T := Ada_High;\n+      end if;\n+\n+      --  Remove the sub seconds from both dates\n+\n+      Start_T := Start_T - (Start_T mod Mili);\n+      End_T   := End_T   - (End_T   mod Mili);\n+\n+      --  Some trivial cases\n+\n+      if End_T < Leap_Second_Times (1) then\n+         Elapsed_Leaps := 0;\n+         Next_Leap_Sec := Leap_Second_Times (1);\n+         return;\n+\n+      elsif Start_T > Leap_Second_Times (N_Leap_Seconds) then\n+         Elapsed_Leaps := 0;\n+         Next_Leap_Sec := After_Last_Leap;\n+         return;\n+      end if;\n+\n+      --  Perform the calculations only if the start date is within the leap\n+      --  second occurences table.\n+\n+      if Start_T <= Leap_Second_Times (N_Leap_Seconds) then\n+\n+         --    1    2                  N - 1   N\n+         --  +----+----+--  . . .  --+-------+---+\n+         --  | T1 | T2 |             | N - 1 | N |\n+         --  +----+----+--  . . .  --+-------+---+\n+         --         ^                   ^\n+         --         | Start_Index       | End_Index\n+         --         +-------------------+\n+         --             Leaps_Between\n+\n+         --  The idea behind the algorithm is to iterate and find two closest\n+         --  dates which are after Start_T and End_T. Their corresponding index\n+         --  difference denotes the number of leap seconds elapsed.\n+\n+         Start_Index := 1;\n+         loop\n+            exit when Leap_Second_Times (Start_Index) >= Start_T;\n+            Start_Index := Start_Index + 1;\n+         end loop;\n+\n+         End_Index := Start_Index;\n+         loop\n+            exit when End_Index > N_Leap_Seconds\n+              or else Leap_Second_Times (End_Index) >= End_T;\n+            End_Index := End_Index + 1;\n+         end loop;\n+\n+         if End_Index <= N_Leap_Seconds then\n+            Next_Leap_Sec := Leap_Second_Times (End_Index);\n+         end if;\n+\n+         Elapsed_Leaps := End_Index - Start_Index;\n+\n+      else\n+         Elapsed_Leaps := 0;\n+      end if;\n+   end Cumulative_Leap_Seconds;\n+\n    ---------\n    -- Day --\n    ---------\n \n    function Day (Date : Time) return Day_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DD;\n+      Split (Date, Y, M, D, S);\n+      return D;\n    end Day;\n \n+   -------------\n+   -- Is_Leap --\n+   -------------\n+\n+   function Is_Leap (Year : Year_Number) return Boolean is\n+   begin\n+      --  Leap centenial years\n+\n+      if Year mod 400 = 0 then\n+         return True;\n+\n+      --  Non-leap centenial years\n+\n+      elsif Year mod 100 = 0 then\n+         return False;\n+\n+      --  Regular years\n+\n+      else\n+         return Year mod 4 = 0;\n+      end if;\n+   end Is_Leap;\n+\n    -----------\n    -- Month --\n    -----------\n \n    function Month (Date : Time) return Month_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DM;\n+      Split (Date, Y, M, D, S);\n+      return M;\n    end Month;\n \n    -------------\n    -- Seconds --\n    -------------\n \n    function Seconds (Date : Time) return Day_Duration is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DS;\n+      Split (Date, Y, M, D, S);\n+      return S;\n    end Seconds;\n \n    -----------\n@@ -221,57 +416,27 @@ package body Ada.Calendar is\n       Day     : out Day_Number;\n       Seconds : out Day_Duration)\n    is\n-      procedure Numtim (\n-        Status : out Unsigned_Longword;\n-        Timbuf : out Unsigned_Word_Array;\n-        Timadr : Time);\n-\n-      pragma Interface (External, Numtim);\n-\n-      pragma Import_Valued_Procedure (Numtim, \"SYS$NUMTIM\",\n-        (Unsigned_Longword, Unsigned_Word_Array, Time),\n-        (Value, Reference, Reference));\n-\n-      Status   : Unsigned_Longword;\n-      Timbuf   : Unsigned_Word_Array (1 .. 7);\n-\n-      Subsecs   : constant Time := Date mod 10_000_000;\n-      Date_Secs : constant Time := Date - Subsecs;\n+      H  : Integer;\n+      M  : Integer;\n+      Se : Integer;\n+      Ss : Duration;\n+      Le : Boolean;\n \n    begin\n-      Numtim (Status, Timbuf, Date_Secs);\n+      Formatting_Operations.Split\n+        (Date, Year, Month, Day, Seconds, H, M, Se, Ss, Le, 0);\n \n-      if Status mod 2 /= 1\n-        or else Timbuf (1) not in Ada_Year_Min .. Ada_Year_Max\n+      --  Validity checks\n+\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Seconds'Valid\n       then\n          raise Time_Error;\n       end if;\n-\n-      Seconds := Day_Duration (Timbuf (6)\n-                   + 60 * (Timbuf (5) + 60 * Timbuf (4)))\n-                   + Duration (Subsecs) / 10_000_000.0;\n-\n-      Day   := Integer (Timbuf (3));\n-      Month := Integer (Timbuf (2));\n-      Year  := Integer (Timbuf (1));\n    end Split;\n \n-   -----------------------\n-   -- Split_With_Offset --\n-   -----------------------\n-\n-   procedure Split_With_Offset\n-     (Date    : Time;\n-      Year    : out Year_Number;\n-      Month   : out Month_Number;\n-      Day     : out Day_Number;\n-      Seconds : out Day_Duration;\n-      Offset  : out Long_Integer)\n-   is\n-   begin\n-      raise Unimplemented;\n-   end Split_With_Offset;\n-\n    -------------\n    -- Time_Of --\n    -------------\n@@ -280,137 +445,626 @@ package body Ada.Calendar is\n      (Year    : Year_Number;\n       Month   : Month_Number;\n       Day     : Day_Number;\n-      Seconds : Day_Duration := 0.0)\n-      return    Time\n+      Seconds : Day_Duration := 0.0) return Time\n    is\n+      --  The values in the following constants are irrelevant, they are just\n+      --  placeholders; the choice of constructing a Day_Duration value is\n+      --  controlled by the Use_Day_Secs flag.\n \n-      procedure Cvt_Vectim (\n-        Status         : out Unsigned_Longword;\n-        Input_Time     : Unsigned_Word_Array;\n-        Resultant_Time : out Time);\n-\n-      pragma Interface (External, Cvt_Vectim);\n-\n-      pragma Import_Valued_Procedure (Cvt_Vectim, \"LIB$CVT_VECTIM\",\n-        (Unsigned_Longword, Unsigned_Word_Array, Time),\n-        (Value, Reference, Reference));\n-\n-      Status      : Unsigned_Longword;\n-      Timbuf      : Unsigned_Word_Array (1 .. 7);\n-      Date        : Time;\n-      Int_Secs    : Integer;\n-      Day_Hack    : Boolean := False;\n-      Subsecs     : Day_Duration;\n+      H  : constant Integer := 1;\n+      M  : constant Integer := 1;\n+      Se : constant Integer := 1;\n+      Ss : constant Duration := 0.1;\n \n    begin\n-      --  The following checks are redundant with respect to the constraint\n-      --  error checks that should normally be made on parameters, but we\n-      --  decide to raise Constraint_Error in any case if bad values come\n-      --  in (as a result of checks being off in the caller, or for other\n-      --  erroneous or bounded error cases).\n-\n-      if        not Year   'Valid\n-        or else not Month  'Valid\n-        or else not Day    'Valid\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n         or else not Seconds'Valid\n       then\n-         raise Constraint_Error;\n-      end if;\n-\n-      --  Truncate seconds value by subtracting 0.5 and rounding,\n-      --  but be careful with 0.0 since that will give -1.0 unless\n-      --  it is treated specially.\n-\n-      if Seconds > 0.0 then\n-         Int_Secs := Integer (Seconds - 0.5);\n-      else\n-         Int_Secs := Integer (Seconds);\n-      end if;\n-\n-      Subsecs := Seconds - Day_Duration (Int_Secs);\n-\n-      --  Cvt_Vectim barfs on the largest Day_Duration, so trick it by\n-      --  setting it to zero and then adding the difference after conversion.\n-\n-      if Int_Secs = 86_400 then\n-         Int_Secs := 0;\n-         Day_Hack := True;\n+         raise Time_Error;\n       end if;\n \n-      Timbuf (7) := 0;\n-      Timbuf (6) := Unsigned_Word (Int_Secs mod 60);\n-      Timbuf (5) := Unsigned_Word ((Int_Secs / 60) mod 60);\n-      Timbuf (4) := Unsigned_Word (Int_Secs / 3600);\n-      Timbuf (3) := Unsigned_Word (Day);\n-      Timbuf (2) := Unsigned_Word (Month);\n-      Timbuf (1) := Unsigned_Word (Year);\n+      return\n+        Formatting_Operations.Time_Of\n+          (Year, Month, Day, Seconds, H, M, Se, Ss,\n+           Leap_Sec     => False,\n+           Leap_Checks  => False,\n+           Use_Day_Secs => True,\n+           Time_Zone    => 0);\n+   end Time_Of;\n \n-      Cvt_Vectim (Status, Timbuf, Date);\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n \n-      if Status mod 2 /= 1 then\n-         raise Time_Error;\n-      end if;\n+   function To_Duration (T : Time) return Duration is\n+      function Time_To_Duration is\n+        new Ada.Unchecked_Conversion (Time, Duration);\n+   begin\n+      return Time_To_Duration (T * 100);\n+   end To_Duration;\n \n-      if Day_Hack then\n-         Date := Date + 10_000_000 * 86_400;\n-      end if;\n+   ----------------------\n+   -- To_Relative_Time --\n+   ----------------------\n \n-      Date := Date + Time (10_000_000.0 * Subsecs);\n-      return Date;\n-   end Time_Of;\n+   function To_Relative_Time (D : Duration) return Time is\n+      function Duration_To_Time is\n+        new Ada.Unchecked_Conversion (Duration, Time);\n+   begin\n+      return Duration_To_Time (D / 100.0);\n+   end To_Relative_Time;\n \n    ----------\n    -- Year --\n    ----------\n \n    function Year (Date : Time) return Year_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DY;\n+      Split (Date, Y, M, D, S);\n+      return Y;\n    end Year;\n \n-   -------------------\n-   --  Leap_Sec_Ops --\n-   -------------------\n+   --  The following packages assume that Time is a Long_Integer, the units\n+   --  are 100 nanoseconds and the starting point in the VMS Epoch.\n \n-   --  The package that is used by the Ada 2005 children of Ada.Calendar:\n-   --  Ada.Calendar.Arithmetic and Ada.Calendar.Formatting.\n+   ---------------------------\n+   -- Arithmetic_Operations --\n+   ---------------------------\n \n-   package body Leap_Sec_Ops is\n+   package body Arithmetic_Operations is\n \n-      --------------------------\n-      -- Cumulative_Leap_Secs --\n-      --------------------------\n+      ---------\n+      -- Add --\n+      ---------\n \n-      procedure Cumulative_Leap_Secs\n-        (Start_Date    : Time;\n-         End_Date      : Time;\n-         Leaps_Between : out Duration;\n-         Next_Leap_Sec : out Time)\n+      function Add (Date : Time; Days : Long_Integer) return Time is\n+         Ada_High_And_Leaps : constant Time :=\n+                                Ada_High + Time (All_Leap_Seconds) * Mili;\n+      begin\n+         if Days = 0 then\n+            return Date;\n+\n+         elsif Days < 0 then\n+            return Subtract (Date, abs (Days));\n+\n+         else\n+            declare\n+               Result : constant Time := Date + Time (Days) * Milis_In_Day;\n+\n+            begin\n+               --  The result excedes the upper bound of Ada time\n+\n+               if Result >= Ada_High_And_Leaps then\n+                  raise Time_Error;\n+               end if;\n+\n+               return Result;\n+            end;\n+         end if;\n+\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end Add;\n+\n+      ----------------\n+      -- Difference --\n+      ----------------\n+\n+      procedure Difference\n+        (Left         : Time;\n+         Right        : Time;\n+         Days         : out Long_Integer;\n+         Seconds      : out Duration;\n+         Leap_Seconds : out Integer)\n       is\n+         Mili_F : constant Duration := 10_000_000.0;\n+\n+         Diff_M        : Time;\n+         Diff_S        : Time;\n+         Earlier       : Time;\n+         Elapsed_Leaps : Natural;\n+         Later         : Time;\n+         Negate        : Boolean;\n+         Next_Leap     : Time;\n+         Sub_Seconds   : Duration;\n+\n       begin\n-         raise Unimplemented;\n-      end Cumulative_Leap_Secs;\n+         --  This classification is necessary in order to avoid a Time_Error\n+         --  being raised by the arithmetic operators in Ada.Calendar.\n+\n+         if Left >= Right then\n+            Later   := Left;\n+            Earlier := Right;\n+            Negate  := False;\n+         else\n+            Later   := Right;\n+            Earlier := Left;\n+            Negate  := True;\n+         end if;\n+\n+         --  First process the leap seconds\n+\n+         Cumulative_Leap_Seconds (Earlier, Later, Elapsed_Leaps, Next_Leap);\n+\n+         if Later >= Next_Leap then\n+            Elapsed_Leaps := Elapsed_Leaps + 1;\n+         end if;\n+\n+         Diff_M := Later - Earlier - Time (Elapsed_Leaps) * Mili;\n+\n+         --  Sub second processing\n+\n+         Sub_Seconds := Duration (Diff_M mod Mili) / Mili_F;\n+\n+         --  Convert to seconds. Note that his action eliminates the sub\n+         --  seconds automatically.\n+\n+         Diff_S := Diff_M / Mili;\n+\n+         Days := Long_Integer (Diff_S / Secs_In_Day);\n+         Seconds := Duration (Diff_S mod Secs_In_Day) + Sub_Seconds;\n+         Leap_Seconds := Integer (Elapsed_Leaps);\n+\n+         if Negate then\n+            Days         := -Days;\n+            Seconds      := -Seconds;\n+            Leap_Seconds := -Leap_Seconds;\n+         end if;\n+      end Difference;\n+\n+      --------------\n+      -- Subtract --\n+      --------------\n+\n+      function Subtract (Date : Time; Days : Long_Integer) return Time is\n+      begin\n+         if Days = 0 then\n+            return Date;\n+\n+         elsif Days < 0 then\n+            return Add (Date, abs (Days));\n+\n+         else\n+            declare\n+               Days_T : constant Time := Time (Days) * Milis_In_Day;\n+               Result : constant Time := Date - Days_T;\n+\n+            begin\n+               --  Subtracting a larger number of days from a smaller time\n+               --  value will cause wrap around since time is a modular type.\n+               --  Also the result may be lower than the start of Ada time.\n+\n+               if Date < Days_T\n+                 or Result < Ada_Low\n+               then\n+                  raise Time_Error;\n+               end if;\n+\n+               return Date - Days_T;\n+            end;\n+         end if;\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end Subtract;\n+   end Arithmetic_Operations;\n+\n+   ---------------------------\n+   -- Formatting_Operations --\n+   ---------------------------\n+\n+   package body Formatting_Operations is\n+\n+      -----------------\n+      -- Day_Of_Week --\n+      -----------------\n+\n+      function Day_Of_Week (Date : Time) return Integer is\n+         Y : Year_Number;\n+         M : Month_Number;\n+         D : Day_Number;\n+         S : Day_Duration;\n+\n+         Day_Count     : Long_Integer;\n+         Midday_Date_S : Time;\n+\n+      begin\n+         Split (Date, Y, M, D, S);\n+\n+         --  Build a time value in the middle of the same day and convert the\n+         --  time value to seconds.\n+\n+         Midday_Date_S := Time_Of (Y, M, D, 43_200.0) / Mili;\n+\n+         --  Count the number of days since the start of VMS time. 1858-11-17\n+         --  was a Wednesday.\n+\n+         Day_Count := Long_Integer (Midday_Date_S / Secs_In_Day) + 2;\n+\n+         return Integer (Day_Count mod 7);\n+      end Day_Of_Week;\n+\n+      -----------\n+      -- Split --\n+      -----------\n+\n+      procedure Split\n+        (Date         : Time;\n+         Year         : out Year_Number;\n+         Month        : out Month_Number;\n+         Day          : out Day_Number;\n+         Day_Secs     : out Day_Duration;\n+         Hour         : out Integer;\n+         Minute       : out Integer;\n+         Second       : out Integer;\n+         Sub_Sec      : out Duration;\n+         Leap_Sec     : out Boolean;\n+         Time_Zone    : Long_Integer)\n+      is\n+         procedure Numtim\n+           (Status : out Unsigned_Longword;\n+            Timbuf : out Unsigned_Word_Array;\n+            Timadr : Time);\n+\n+         pragma Interface (External, Numtim);\n+\n+         pragma Import_Valued_Procedure\n+           (Numtim, \"SYS$NUMTIM\",\n+           (Unsigned_Longword, Unsigned_Word_Array, Time),\n+           (Value, Reference, Reference));\n+\n+         Status : Unsigned_Longword;\n+         Timbuf : Unsigned_Word_Array (1 .. 7);\n+\n+         Ada_Min_Year : constant := 1901;\n+         Ada_Max_Year : constant := 2399;\n+         Mili_F       : constant Duration := 10_000_000.0;\n+\n+         Abs_Time_Zone   : Time;\n+         Elapsed_Leaps   : Natural;\n+         Modified_Date_M : Time;\n+         Next_Leap_M     : Time;\n+         Rounded_Date_M  : Time;\n+\n+      begin\n+         Modified_Date_M := Date;\n+\n+         --  Step 1: Leap seconds processing\n+\n+         Cumulative_Leap_Seconds (Ada_Low, Date, Elapsed_Leaps, Next_Leap_M);\n+\n+         Rounded_Date_M  := Modified_Date_M - (Modified_Date_M mod Mili);\n+         Leap_Sec        := Rounded_Date_M = Next_Leap_M;\n+         Modified_Date_M := Modified_Date_M - Time (Elapsed_Leaps) * Mili;\n+\n+         if Leap_Sec then\n+            Modified_Date_M := Modified_Date_M - Time (1) * Mili;\n+         end if;\n+\n+         --  Step 2: Time zone processing\n+\n+         if Time_Zone /= 0 then\n+            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Mili;\n+\n+            if Time_Zone < 0 then\n+               Modified_Date_M := Modified_Date_M - Abs_Time_Zone;\n+            else\n+               Modified_Date_M := Modified_Date_M + Abs_Time_Zone;\n+            end if;\n+         end if;\n+\n+         --  After the leap seconds and time zone have been accounted for,\n+         --  the date should be within the bounds of Ada time.\n+\n+         if Modified_Date_M < Ada_Low\n+           or else Modified_Date_M >= Ada_High\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Step 3: Sub second processing\n+\n+         Sub_Sec := Duration (Modified_Date_M mod Mili) / Mili_F;\n+\n+         --  Drop the sub seconds\n+\n+         Modified_Date_M := Modified_Date_M - (Modified_Date_M mod Mili);\n+\n+         --  Step 4: VMS system call\n+\n+         Numtim (Status, Timbuf, Modified_Date_M);\n+\n+         if Status mod 2 /= 1\n+           or else Timbuf (1) not in Ada_Min_Year .. Ada_Max_Year\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Step 5: Time components processing\n+\n+         Year   := Year_Number (Timbuf (1));\n+         Month  := Month_Number (Timbuf (2));\n+         Day    := Day_Number (Timbuf (3));\n+         Hour   := Integer (Timbuf (4));\n+         Minute := Integer (Timbuf (5));\n+         Second := Integer (Timbuf (6));\n \n-      ----------------------\n-      -- All_Leap_Seconds --\n-      ----------------------\n+         Day_Secs := Day_Duration (Hour   * 3_600) +\n+                     Day_Duration (Minute *    60) +\n+                     Day_Duration (Second)         +\n+                                   Sub_Sec;\n+      end Split;\n+\n+      -------------\n+      -- Time_Of --\n+      -------------\n+\n+      function Time_Of\n+        (Year         : Year_Number;\n+         Month        : Month_Number;\n+         Day          : Day_Number;\n+         Day_Secs     : Day_Duration;\n+         Hour         : Integer;\n+         Minute       : Integer;\n+         Second       : Integer;\n+         Sub_Sec      : Duration;\n+         Leap_Sec     : Boolean;\n+         Leap_Checks  : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Time_Zone    : Long_Integer) return Time\n+      is\n+         procedure Cvt_Vectim\n+           (Status         : out Unsigned_Longword;\n+            Input_Time     : Unsigned_Word_Array;\n+            Resultant_Time : out Time);\n+\n+         pragma Interface (External, Cvt_Vectim);\n+\n+         pragma Import_Valued_Procedure\n+           (Cvt_Vectim, \"LIB$CVT_VECTIM\",\n+           (Unsigned_Longword, Unsigned_Word_Array, Time),\n+           (Value, Reference, Reference));\n+\n+         Status : Unsigned_Longword;\n+         Timbuf : Unsigned_Word_Array (1 .. 7);\n+\n+         Mili_F : constant := 10_000_000.0;\n+\n+         Ada_High_And_Leaps : constant Time :=\n+                                Ada_High + Time (All_Leap_Seconds) * Mili;\n+\n+         H  : Integer  := Hour;\n+         Mi : Integer  := Minute;\n+         Se : Integer  := Second;\n+         Su : Duration := Sub_Sec;\n+\n+         Abs_Time_Zone    : Time;\n+         Adjust_Day       : Boolean := False;\n+         Elapsed_Leaps    : Natural;\n+         Int_Day_Secs     : Integer;\n+         Next_Leap_M      : Time;\n+         Result_M         : Time;\n+         Rounded_Result_M : Time;\n \n-      function All_Leap_Seconds return Duration is\n       begin\n-         raise Unimplemented;\n-         return 0.0;\n-      end All_Leap_Seconds;\n+         --  No validity checks are performed on the input values since it is\n+         --  assumed that the called has already performed them.\n+\n+         --  Step 1: Hour, minute, second and sub second processing\n+\n+         if Use_Day_Secs then\n+\n+            --  A day seconds value of 86_400 designates a new day. The time\n+            --  components are reset to zero, but an additional day will be\n+            --  added after the system call.\n+\n+            if Day_Secs = 86_400.0 then\n+               Adjust_Day := True;\n+               H  := 0;\n+               Mi := 0;\n+               Se := 0;\n+\n+            else\n+               --  Sub second extraction\n+\n+               if Day_Secs > 0.0 then\n+                  Int_Day_Secs := Integer (Day_Secs - 0.5);\n+               else\n+                  Int_Day_Secs := Integer (Day_Secs);\n+               end if;\n+\n+               H  := Int_Day_Secs / 3_600;\n+               Mi := (Int_Day_Secs / 60) mod 60;\n+               Se := Int_Day_Secs mod 60;\n+               Su := Day_Secs - Duration (Int_Day_Secs);\n+            end if;\n+         end if;\n+\n+         --  Step 2: System call to VMS\n+\n+         Timbuf (1) := Unsigned_Word (Year);\n+         Timbuf (2) := Unsigned_Word (Month);\n+         Timbuf (3) := Unsigned_Word (Day);\n+         Timbuf (4) := Unsigned_Word (H);\n+         Timbuf (5) := Unsigned_Word (Mi);\n+         Timbuf (6) := Unsigned_Word (Se);\n+         Timbuf (7) := 0;\n+\n+         Cvt_Vectim (Status, Timbuf, Result_M);\n+\n+         if Status mod 2 /= 1 then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Step 3: Potential day adjustment\n+\n+         if Use_Day_Secs\n+           and then Adjust_Day\n+         then\n+            Result_M := Result_M + Milis_In_Day;\n+         end if;\n+\n+         --  Step 4: Sub second adjustment\n+\n+         Result_M := Result_M + Time (Su * Mili_F);\n+\n+         --  Step 5: Time zone processing\n+\n+         if Time_Zone /= 0 then\n+            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Mili;\n+\n+            if Time_Zone < 0 then\n+               Result_M := Result_M + Abs_Time_Zone;\n+            else\n+               Result_M := Result_M - Abs_Time_Zone;\n+            end if;\n+         end if;\n+\n+         --  Step 6: Leap seconds processing\n \n-   --  Start of processing in package Leap_Sec_Ops\n+         Cumulative_Leap_Seconds\n+           (Ada_Low, Result_M, Elapsed_Leaps, Next_Leap_M);\n+\n+         Result_M := Result_M + Time (Elapsed_Leaps) * Mili;\n+\n+         --  An Ada 2005 caller requesting an explicit leap second or an Ada\n+         --  95 caller accounting for an invisible leap second.\n+\n+         Rounded_Result_M := Result_M - (Result_M mod Mili);\n+\n+         if Leap_Sec\n+           or else Rounded_Result_M = Next_Leap_M\n+         then\n+            Result_M := Result_M + Time (1) * Mili;\n+            Rounded_Result_M := Rounded_Result_M + Time (1) * Mili;\n+         end if;\n+\n+         --  Leap second validity check\n+\n+         if Leap_Checks\n+           and then Leap_Sec\n+           and then Rounded_Result_M /= Next_Leap_M\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Bounds check\n+\n+         if Result_M < Ada_Low\n+           or else Result_M >= Ada_High_And_Leaps\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         return Result_M;\n+      end Time_Of;\n+   end Formatting_Operations;\n+\n+   ---------------------------\n+   -- Time_Zones_Operations --\n+   ---------------------------\n+\n+   package body Time_Zones_Operations is\n+\n+      ---------------------\n+      -- UTC_Time_Offset --\n+      ---------------------\n+\n+      function UTC_Time_Offset (Date : Time) return Long_Integer is\n+         --  Formal parameter Date is here for interfacing, but is never\n+         --  actually used.\n+\n+         pragma Unreferenced (Date);\n+\n+         function get_gmtoff return Long_Integer;\n+         pragma Import (C, get_gmtoff, \"get_gmtoff\");\n+\n+      begin\n+         --  VMS is not capable of determining the time zone in some past or\n+         --  future point in time denoted by Date, thus the current time zone\n+         --  is retrieved.\n+\n+         return get_gmtoff;\n+      end UTC_Time_Offset;\n+   end Time_Zones_Operations;\n+\n+--  Start of elaboration code for Ada.Calendar\n+\n+begin\n+   --  Population of the leap seconds table\n+\n+   declare\n+      type Leap_Second_Date is record\n+         Year  : Year_Number;\n+         Month : Month_Number;\n+         Day   : Day_Number;\n+      end record;\n+\n+      Leap_Second_Dates :\n+        constant array (1 .. N_Leap_Seconds) of Leap_Second_Date :=\n+          ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n+           (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n+           (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n+           (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n+           (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n+           (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n+\n+      Ada_Min_Year       : constant Year_Number := Year_Number'First;\n+      Days_In_Four_Years : constant := 365 * 3 + 366;\n+      VMS_Days           : constant := 10 * 366 + 32 * 365 + 45;\n+\n+      Days  : Natural;\n+      Leap  : Leap_Second_Date;\n+      Years : Natural;\n \n    begin\n-      null;\n-   end Leap_Sec_Ops;\n+      for Index in 1 .. N_Leap_Seconds loop\n+         Leap := Leap_Second_Dates (Index);\n+\n+         --  Calculate the number of days from the start of Ada time until\n+         --  the current leap second occurence. Non-leap centenial years\n+         --  are not accounted for in these calculations since there are\n+         --  no leap seconds after 2100 yet.\n+\n+         Years := Leap.Year - Ada_Min_Year;\n+         Days  := (Years / 4) * Days_In_Four_Years;\n+         Years := Years mod 4;\n+\n+         if Years = 1 then\n+            Days := Days + 365;\n+\n+         elsif Years = 2 then\n+            Days := Days + 365 * 2;\n+\n+         elsif Years = 3 then\n+            Days := Days + 365 * 3;\n+         end if;\n+\n+         Days := Days + Cumulative_Days_Before_Month (Leap.Month);\n+\n+         if Is_Leap (Leap.Year)\n+           and then Leap.Month > 2\n+         then\n+            Days := Days + 1;\n+         end if;\n+\n+         --  Add the number of days since the start of VMS time till the\n+         --  start of Ada time.\n+\n+         Days := Days + Leap.Day + VMS_Days;\n+\n+         --  Index - 1 previous leap seconds are added to Time (Index)\n+\n+         Leap_Second_Times (Index) :=\n+           (Time (Days) * Secs_In_Day + Time (Index - 1)) * Mili;\n+      end loop;\n+   end;\n \n end Ada.Calendar;"}, {"sha": "6fc05f3f80ab84c6b18353475e79c2a8ce6a0cb1", "filename": "gcc/ada/a-calend-vms.ads", "status": "modified", "additions": 99, "deletions": 76, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.ads?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -44,11 +44,12 @@ package Ada.Calendar is\n \n    type Time is private;\n \n-   --  Declarations representing limits of allowed local time values. Note that\n-   --  these do NOT constrain the possible stored values of time which may well\n-   --  permit a larger range of times (this is explicitly allowed in Ada 95).\n+   --  Declarations representing limits of allowed local time values. Note\n+   --  that these do NOT constrain the possible stored values of time which\n+   --  may well permit a larger range of times (this is explicitly allowed\n+   --  in Ada 95).\n \n-   subtype Year_Number  is Integer range 1901 .. 2099;\n+   subtype Year_Number  is Integer range 1901 .. 2399;\n    subtype Month_Number is Integer range 1 .. 12;\n    subtype Day_Number   is Integer range 1 .. 31;\n \n@@ -72,8 +73,7 @@ package Ada.Calendar is\n      (Year    : Year_Number;\n       Month   : Month_Number;\n       Day     : Day_Number;\n-      Seconds : Day_Duration := 0.0)\n-      return    Time;\n+      Seconds : Day_Duration := 0.0) return Time;\n \n    function \"+\" (Left : Time;     Right : Duration) return Time;\n    function \"+\" (Left : Duration; Right : Time)     return Time;\n@@ -87,10 +87,7 @@ package Ada.Calendar is\n \n    Time_Error : exception;\n \n-   Unimplemented : exception;\n-\n private\n-\n    pragma Inline (Clock);\n \n    pragma Inline (Year);\n@@ -105,81 +102,107 @@ private\n    pragma Inline (\">\");\n    pragma Inline (\">=\");\n \n-   --  Time is represented as the number of 100-nanosecond (ns) units offset\n-   --  from the system base date and time, which is 00:00 o'clock,\n-   --  November 17, 1858 (the Smithsonian base date and time for the\n-   --  astronomic calendar).\n+   --  Although the units are 100 nanoseconds, for the purpose of better\n+   --  readability, this unit will be called \"mili\".\n+\n+   Mili         : constant := 10_000_000;\n+   Milis_In_Day : constant := 864_000_000_000;\n+   Secs_In_Day  : constant := 86_400;\n+\n+   --  Time is represented as the number of 100-nanosecond (ns) units from the\n+   --  system base date and time 1858-11-17 0.0 (the Smithsonian base date and\n+   --  time for the astronomic calendar).\n \n    --  The time value stored is typically a GMT value, as provided in standard\n    --  Unix environments. If this is the case then Split and Time_Of perform\n    --  required conversions to and from local times.\n \n-   type Time is new OSP.OS_Time;\n-\n    --  Notwithstanding this definition, Time is not quite the same as OS_Time.\n    --  Relative Time is positive, whereas relative OS_Time is negative,\n    --  but this declaration makes for easier conversion.\n \n-   --  The following package provides handling of leap seconds. It is\n-   --  used by Ada.Calendar.Arithmetic and Ada.Calendar.Formatting, both\n-   --  Ada 2005 children of Ada.Calendar.\n-\n-   package Leap_Sec_Ops is\n-\n-      After_Last_Leap : constant Time := Time'Last;\n-      --  Bigger by far than any leap second value. Not within range of\n-      --  Ada.Calendar specified dates.\n-\n-      procedure Cumulative_Leap_Secs\n-        (Start_Date    : Time;\n-         End_Date      : Time;\n-         Leaps_Between : out Duration;\n-         Next_Leap_Sec : out Time);\n-      --  Leaps_Between is the sum of the leap seconds that have occured\n-      --  on or after Start_Date and before (strictly before) End_Date.\n-      --  Next_Leap_Sec represents the next leap second occurence on or\n-      --  after End_Date. If there are no leaps seconds after End_Date,\n-      --  After_Last_Leap is returned. This does not provide info about\n-      --  the next leap second (pos/neg or ?). After_Last_Leap can be used\n-      --  as End_Date to count all the leap seconds that have occured on\n-      --  or after Start_Date.\n-      --\n-      --  Important Notes: any fractional parts of Start_Date and End_Date\n-      --  are discarded before the calculations are done. For instance: if\n-      --  113 seconds is a leap second (it isn't) and 113.5 is input as an\n-      --  End_Date, the leap second at 113 will not be counted in\n-      --  Leaps_Between, but it will be returned as Next_Leap_Sec. Thus, if\n-      --  the caller wants to know if the End_Date is a leap second, the\n-      --  comparison should be:\n-      --\n-      --     End_Date >= Next_Leap_Sec;\n-      --\n-      --  After_Last_Leap is designed so that this comparison works without\n-      --  having to first check if Next_Leap_Sec is a valid leap second.\n-\n-      function All_Leap_Seconds return Duration;\n-      --  Returns the sum off all of the leap seoncds.\n-\n-   end Leap_Sec_Ops;\n-\n-   procedure Split_With_Offset\n-     (Date    : Time;\n-      Year    : out Year_Number;\n-      Month   : out Month_Number;\n-      Day     : out Day_Number;\n-      Seconds : out Day_Duration;\n-      Offset  : out Long_Integer);\n-   --  Split_W_Offset has the same spec as Split with the addition of an\n-   --  offset value which give the offset of the local time zone from UTC\n-   --  at the input Date. This value comes for free during the implementation\n-   --  of Split and is needed by UTC_Time_Offset. The returned Offset time\n-   --  is straight from the C tm struct and is in seconds. If the system\n-   --  dependent code has no way to find the offset it will return the value\n-   --  Invalid_TZ_Offset declared below. Otherwise no checking is done, so\n-   --  it is up to the user to check both for Invalid_TZ_Offset and otherwise\n-   --  for a value that is acceptable.\n-\n-   Invalid_TZ_Offset : Long_Integer;\n-   pragma Import (C, Invalid_TZ_Offset, \"__gnat_invalid_tzoff\");\n+   type Time is new OSP.OS_Time;\n+\n+   --  The range of Ada time expressed as milis since the VMS Epoch\n+\n+   Ada_Low  : constant Time :=  (10 * 366 +  32 * 365 + 45) * Milis_In_Day;\n+   Ada_High : constant Time := (131 * 366 + 410 * 365 + 45) * Milis_In_Day;\n+\n+   Days_In_Month : constant array (Month_Number) of Day_Number :=\n+                     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n+\n+   Invalid_Time_Zone_Offset : Long_Integer;\n+   pragma Import (C, Invalid_Time_Zone_Offset, \"__gnat_invalid_tzoff\");\n+\n+   function Is_Leap (Year : Year_Number) return Boolean;\n+   --  Determine whether a given year is leap\n+\n+   --  The following packages provide a target independent interface to the\n+   --  children of Calendar - Arithmetic, Formatting and Time_Zones.\n+\n+   --  NOTE: Delays does not need a target independent interface because\n+   --  VMS already has a target specific file for that package.\n+\n+   package Arithmetic_Operations is\n+      function Add (Date : Time; Days : Long_Integer) return Time;\n+      --  Add X number of days to a time value\n+\n+      procedure Difference\n+        (Left         : Time;\n+         Right        : Time;\n+         Days         : out Long_Integer;\n+         Seconds      : out Duration;\n+         Leap_Seconds : out Integer);\n+      --  Calculate the difference between two time values in terms of days,\n+      --  seconds and leap seconds elapsed. The leap seconds are not included\n+      --  in the seconds returned. If Left is greater than Right, the returned\n+      --  values are positive, negative otherwise.\n+\n+      function Subtract (Date : Time; Days : Long_Integer) return Time;\n+      --  Subtract X number of days from a time value\n+   end Arithmetic_Operations;\n+\n+   package Formatting_Operations is\n+      function Day_Of_Week (Date : Time) return Integer;\n+      --  Determine which day of week Date falls on. The returned values are\n+      --  within the range of 0 .. 6 (Monday .. Sunday).\n+\n+      procedure Split\n+        (Date       : Time;\n+         Year       : out Year_Number;\n+         Month      : out Month_Number;\n+         Day        : out Day_Number;\n+         Day_Secs   : out Day_Duration;\n+         Hour       : out Integer;\n+         Minute     : out Integer;\n+         Second     : out Integer;\n+         Sub_Sec    : out Duration;\n+         Leap_Sec   : out Boolean;\n+         Time_Zone  : Long_Integer);\n+      --  Split a time value into its components\n+\n+      function Time_Of\n+        (Year         : Year_Number;\n+         Month        : Month_Number;\n+         Day          : Day_Number;\n+         Day_Secs     : Day_Duration;\n+         Hour         : Integer;\n+         Minute       : Integer;\n+         Second       : Integer;\n+         Sub_Sec      : Duration;\n+         Leap_Sec     : Boolean;\n+         Leap_Checks  : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Time_Zone    : Long_Integer) return Time;\n+      --  Given all the components of a date, return the corresponding time\n+      --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n+      --  day duration will be calculated from Hour, Minute, Second and Sub_\n+      --  Sec. Set flag Leap_Checks to verify the validity of a leap second.\n+   end Formatting_Operations;\n+\n+   package Time_Zones_Operations is\n+      function UTC_Time_Offset (Date : Time) return Long_Integer;\n+      --  Return the offset in seconds from GMT\n+   end Time_Zones_Operations;\n \n end Ada.Calendar;"}, {"sha": "0af43fd7536ecbc9284db5f94c13f0ecccce55fd", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 1299, "deletions": 462, "changes": 1761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -31,140 +31,273 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n with System.OS_Primitives;\n --  used for Clock\n \n package body Ada.Calendar is\n \n-   ------------------------------\n-   -- Use of Pragma Unsuppress --\n-   ------------------------------\n-\n-   --  This implementation of Calendar takes advantage of the permission in\n-   --  Ada 95 of using arithmetic overflow checks to check for out of bounds\n-   --  time values. This means that we must catch the constraint error that\n-   --  results from arithmetic overflow, so we use pragma Unsuppress to make\n-   --  sure that overflow is enabled, using software overflow checking if\n-   --  necessary. That way, compiling Calendar with options to suppress this\n-   --  checking will not affect its correctness.\n-\n-   ------------------------\n-   -- Local Declarations --\n-   ------------------------\n-\n-   type char_Pointer is access Character;\n-   subtype int is Integer;\n-   subtype long is Long_Integer;\n-   type long_Pointer is access all long;\n-   --  Synonyms for C types. We don't want to get them from Interfaces.C\n-   --  because there is no point in loading that unit just for calendar.\n-\n-   type tm is record\n-      tm_sec    : int;           -- seconds after the minute (0 .. 60)\n-      tm_min    : int;           -- minutes after the hour (0 .. 59)\n-      tm_hour   : int;           -- hours since midnight (0 .. 24)\n-      tm_mday   : int;           -- day of the month (1 .. 31)\n-      tm_mon    : int;           -- months since January (0 .. 11)\n-      tm_year   : int;           -- years since 1900\n-      tm_wday   : int;           -- days since Sunday (0 .. 6)\n-      tm_yday   : int;           -- days since January 1 (0 .. 365)\n-      tm_isdst  : int;           -- Daylight Savings Time flag (-1 .. +1)\n-      tm_gmtoff : long;          -- offset from CUT in seconds\n-      tm_zone   : char_Pointer;  -- timezone abbreviation\n-   end record;\n-\n-   type tm_Pointer is access all tm;\n-\n-   subtype time_t is long;\n-\n-   type time_t_Pointer is access all time_t;\n-\n-   procedure localtime_tzoff\n-     (C   : time_t_Pointer;\n-      res : tm_Pointer;\n-      off : long_Pointer);\n-   pragma Import (C, localtime_tzoff, \"__gnat_localtime_tzoff\");\n-   --  This is a lightweight wrapper around the system library localtime_r\n-   --  function. Parameter 'off' captures the UTC offset which is either\n-   --  retrieved from the tm struct or calculated from the 'timezone' extern\n-   --  and the tm_isdst flag in the tm struct.\n-\n-   function mktime (TM : tm_Pointer) return time_t;\n-   pragma Import (C, mktime);\n-   --  mktime returns -1 in case the calendar time given by components of\n-   --  TM.all cannot be represented.\n-\n-   --  The following constants are used in adjusting Ada dates so that they\n-   --  fit into a 56 year range that can be handled by Unix (1970 included -\n-   --  2026 excluded). Dates that are not in this 56 year range are shifted\n-   --  by multiples of 56 years to fit in this range.\n-\n-   --  The trick is that the number of days in any four year period in the Ada\n-   --  range of years (1901 - 2099) has a constant number of days. This is\n-   --  because we have the special case of 2000 which, contrary to the normal\n-   --  exception for centuries, is a leap year after all. 56 has been chosen,\n-   --  because it is not only a multiple of 4, but also a multiple of 7. Thus\n-   --  two dates 56 years apart fall on the same day of the week, and the\n-   --  Daylight Saving Time change dates are usually the same for these two\n-   --  years.\n-\n-   Unix_Year_Min : constant := 1970;\n-   Unix_Year_Max : constant := 2026;\n-\n-   Ada_Year_Min : constant := 1901;\n-   Ada_Year_Max : constant := 2099;\n-\n-   --  Some basic constants used throughout\n-\n-   Days_In_Month : constant array (Month_Number) of Day_Number :=\n-                     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n-\n-   Days_In_4_Years      : constant := 365 * 3 + 366;\n-   Seconds_In_4_Years   : constant := 86_400 * Days_In_4_Years;\n-   Seconds_In_56_Years  : constant := Seconds_In_4_Years * 14;\n-   Seconds_In_56_YearsD : constant := Duration (Seconds_In_56_Years);\n+   --------------------------\n+   -- Implementation Notes --\n+   --------------------------\n+\n+   --  In complex algorithms, some variables of type Ada.Calendar.Time carry\n+   --  suffix _S or _N to denote units of seconds or nanoseconds.\n+   --\n+   --  Because time is measured in different units and from different origins\n+   --  on various targets, a system independent model is incorporated into\n+   --  Ada.Calendar. The idea behing the design is to encapsulate all target\n+   --  dependent machinery in a single package, thus providing a uniform\n+   --  interface to any existing and potential children.\n+\n+   --     package Ada.Calendar\n+   --        procedure Split (5 parameters) -------+\n+   --                                              | Call from local routine\n+   --     private                                  |\n+   --        package Formatting_Operations         |\n+   --           procedure Split (11 parameters) <--+\n+   --        end Formatting_Operations             |\n+   --     end Ada.Calendar                         |\n+   --                                              |\n+   --     package Ada.Calendar.Formatting          | Call from child routine\n+   --        procedure Split (9 or 10 parameters) -+\n+   --     end Ada.Calendar.Formatting\n+\n+   --  The behaviour of the interfacing routines is controlled via various\n+   --  flags. All new Ada 2005 types from children of Ada.Calendar are\n+   --  emulated by a similar type. For instance, type Day_Number is replaced\n+   --  by Integer in various routines. One ramification of this model is that\n+   --  the caller site must perform validity checks on returned results.\n+   --  The end result of this model is the lack of target specific files per\n+   --  child of Ada.Calendar (a-calfor, a-calfor-vms, a-calfor-vxwors, etc).\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Cumulative_Leap_Seconds\n+     (Start_Date    : Time;\n+      End_Date      : Time;\n+      Elapsed_Leaps : out Natural;\n+      Next_Leap_Sec : out Time);\n+   --  Elapsed_Leaps is the sum of the leap seconds that have occured on or\n+   --  after Start_Date and before (strictly before) End_Date. Next_Leap_Sec\n+   --  represents the next leap second occurence on or after End_Date. If\n+   --  there are no leaps seconds after End_Date, After_Last_Leap is returned.\n+   --  After_Last_Leap can be used as End_Date to count all the leap seconds\n+   --  that have occured on or after Start_Date.\n+   --\n+   --  Note: Any sub seconds of Start_Date and End_Date are discarded before\n+   --  the calculations are done. For instance: if 113 seconds is a leap\n+   --  second (it isn't) and 113.5 is input as an End_Date, the leap second\n+   --  at 113 will not be counted in Leaps_Between, but it will be returned\n+   --  as Next_Leap_Sec. Thus, if the caller wants to know if the End_Date is\n+   --  a leap second, the comparison should be:\n+   --\n+   --     End_Date >= Next_Leap_Sec;\n+   --\n+   --  After_Last_Leap is designed so that this comparison works without\n+   --  having to first check if Next_Leap_Sec is a valid leap second.\n+\n+   function To_Abs_Duration (T : Time) return Duration;\n+   --  Convert a time value into a duration value. Note that the returned\n+   --  duration is always positive.\n+\n+   function To_Abs_Time (D : Duration) return Time;\n+   --  Return the time equivalent of a duration value. Since time cannot be\n+   --  negative, the absolute value of D is used. It is upto the called to\n+   --  decide how to handle negative durations converted into time.\n+\n+   ---------------------\n+   -- Local Constants --\n+   ---------------------\n+\n+   Ada_Min_Year          : constant Year_Number := Year_Number'First;\n+   After_Last_Leap       : constant Time := Time'Last;\n+   Leap_Seconds_Count    : constant Natural := 23;\n+   Secs_In_Four_Years    : constant := (3 * 365 + 366) * Secs_In_Day;\n+   Secs_In_Non_Leap_Year : constant := 365 * Secs_In_Day;\n+   Time_Zero             : constant Time := Time'First;\n+\n+   --  Even though the upper bound of Ada time is 2399-12-31 86_399.999999999\n+   --  GMT, it must be shifted to include all leap seconds.\n+\n+   Ada_High_And_Leaps : constant Time :=\n+                          Ada_High + Time (Leap_Seconds_Count) * Nano;\n+\n+   Hard_Ada_High_And_Leaps : constant Time :=\n+                               Hard_Ada_High +\n+                               Time (Leap_Seconds_Count) * Nano;\n+\n+   --  The Unix lower time bound expressed as nanoseconds since the\n+   --  start of Ada time in GMT.\n+\n+   Unix_Min : constant Time := (17 * 366 + 52 * 365) * Nanos_In_Day;\n+\n+   Cumulative_Days_Before_Month :\n+     constant array (Month_Number) of Natural :=\n+       (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n+\n+   Leap_Second_Times : array (1 .. Leap_Seconds_Count) of Time;\n+   --  Each value represents a time value which is one second before a leap\n+   --  second occurence. This table is populated during the elaboration of\n+   --  Ada.Calendar.\n \n    ---------\n    -- \"+\" --\n    ---------\n \n    function \"+\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n+\n    begin\n-      return (Left + Time (Right));\n+      if Right = 0.0 then\n+         return Left;\n+\n+      elsif Right < 0.0 then\n+\n+         --  Type Duration has one additional number in its negative subrange,\n+         --  which is Duration'First. The subsequent invocation of \"-\" will\n+         --  perform among other things an Unchecked_Conversion on that\n+         --  particular value, causing overflow. If not properly handled,\n+         --  the erroneous value will cause an infinite recursion between \"+\"\n+         --  and \"-\". To properly handle this boundary case, we make a small\n+         --  adjustment of one second to Duration'First.\n+\n+         if Right = Duration'First then\n+            return Left - abs (Right + 1.0) - 1.0;\n+         else\n+            return Left - abs (Right);\n+         end if;\n+\n+      else\n+         declare\n+            --  The input time value has been normalized to GMT\n+\n+            Result : constant Time := Left + To_Abs_Time (Right);\n+\n+         begin\n+            --  The end result may excede the upper bound of Ada time. Note\n+            --  that the comparison operator is \">=\" rather than \">\" since\n+            --  the smallest increment of 0.000000001 to the legal end of\n+            --  time (2399-12-31 86_399.999999999) will render the result\n+            --  equal to Ada_High (2400-1-1 0.0).\n+\n+            if Result >= Ada_High_And_Leaps then\n+               raise Time_Error;\n+            end if;\n+\n+            return Result;\n+         end;\n+      end if;\n+\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n    end \"+\";\n \n    function \"+\" (Left : Duration; Right : Time) return Time is\n-      pragma Unsuppress (Overflow_Check);\n    begin\n-      return (Time (Left) + Right);\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n+      return Right + Left;\n    end \"+\";\n \n    ---------\n    -- \"-\" --\n    ---------\n \n-   function \"-\" (Left : Time; Right : Duration)  return Time is\n+   function \"-\" (Left : Time; Right : Duration) return Time is\n       pragma Unsuppress (Overflow_Check);\n+\n    begin\n-      return Left - Time (Right);\n+      if Right = 0.0 then\n+         return Left;\n+\n+      elsif Right < 0.0 then\n+         return Left + abs (Right);\n+\n+      else\n+         declare\n+            Result  : Time;\n+            Right_T : constant Time := To_Abs_Time (Right);\n+\n+         begin\n+            --  Subtracting a larger time value from a smaller time value\n+            --  will cause a wrap around since Time is a modular type. Note\n+            --  that the time value has been normalized to GMT.\n+\n+            if Left < Right_T then\n+               raise Time_Error;\n+            end if;\n+\n+            Result := Left - Right_T;\n+\n+            if Result < Ada_Low\n+              or else Result > Ada_High_And_Leaps\n+            then\n+               raise Time_Error;\n+            end if;\n+\n+            return Result;\n+         end;\n+      end if;\n+\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n    end \"-\";\n \n    function \"-\" (Left : Time; Right : Time) return Duration is\n       pragma Unsuppress (Overflow_Check);\n+\n+      function To_Time is new Ada.Unchecked_Conversion (Duration, Time);\n+\n+      --  Since the absolute values of the upper and lower bound of duration\n+      --  are denoted by the same number, it is sufficend to use Duration'Last\n+      --  when performing out of range checks.\n+\n+      Duration_Bound : constant Time := To_Time (Duration'Last);\n+\n+      Earlier  : Time;\n+      Later    : Time;\n+      Negate   : Boolean := False;\n+      Result   : Time;\n+      Result_D : Duration;\n+\n    begin\n-      return Duration (Left) - Duration (Right);\n+      --  This routine becomes a little tricky since time cannot be negative,\n+      --  but the subtraction of two time values can produce a negative value.\n+\n+      if Left > Right then\n+         Later   := Left;\n+         Earlier := Right;\n+      else\n+         Later   := Right;\n+         Earlier := Left;\n+         Negate  := True;\n+      end if;\n+\n+      Result := Later - Earlier;\n+\n+      --  Check whether the resulting difference is within the range of type\n+      --  Duration. The following two conditions are examined with the same\n+      --  piece of code:\n+      --\n+      --     positive result > positive upper bound of duration\n+      --\n+      --     negative (negative result) > abs (negative bound of duration)\n+\n+      if Result > Duration_Bound then\n+         raise Time_Error;\n+      end if;\n+\n+      Result_D := To_Abs_Duration (Result);\n+\n+      if Negate then\n+         Result_D := -Result_D;\n+      end if;\n+\n+      return Result_D;\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -176,7 +309,7 @@ package body Ada.Calendar is\n \n    function \"<\" (Left, Right : Time) return Boolean is\n    begin\n-      return Duration (Left) < Duration (Right);\n+      return Time_Rep (Left) < Time_Rep (Right);\n    end \"<\";\n \n    ----------\n@@ -185,7 +318,7 @@ package body Ada.Calendar is\n \n    function \"<=\" (Left, Right : Time) return Boolean is\n    begin\n-      return Duration (Left) <= Duration (Right);\n+      return Time_Rep (Left) <= Time_Rep (Right);\n    end \"<=\";\n \n    ---------\n@@ -194,7 +327,7 @@ package body Ada.Calendar is\n \n    function \">\" (Left, Right : Time) return Boolean is\n    begin\n-      return Duration (Left) > Duration (Right);\n+      return Time_Rep (Left) > Time_Rep (Right);\n    end \">\";\n \n    ----------\n@@ -203,58 +336,201 @@ package body Ada.Calendar is\n \n    function \">=\" (Left, Right : Time) return Boolean is\n    begin\n-      return Duration (Left) >= Duration (Right);\n+      return Time_Rep (Left) >= Time_Rep (Right);\n    end \">=\";\n \n    -----------\n    -- Clock --\n    -----------\n \n    function Clock return Time is\n+      Elapsed_Leaps : Natural;\n+      Next_Leap     : Time;\n+\n+      --  The system clock returns the time in GMT since the Unix Epoch of\n+      --  1970-1-1 0.0. We perform an origin shift to the Ada Epoch by adding\n+      --  the number of nanoseconds between the two origins.\n+\n+      Now : Time := To_Abs_Time (System.OS_Primitives.Clock) + Unix_Min;\n+\n+      Rounded_Now : constant Time := Now - (Now mod Nano);\n+\n    begin\n-      return Time (System.OS_Primitives.Clock);\n+      --  Determine how many leap seconds have elapsed until this moment\n+\n+      Cumulative_Leap_Seconds (Time_Zero, Now, Elapsed_Leaps, Next_Leap);\n+\n+      Now := Now + Time (Elapsed_Leaps) * Nano;\n+\n+      --  The system clock may fall exactly on a leap second occurence\n+\n+      if Rounded_Now = Next_Leap then\n+         Now := Now + Time (1) * Nano;\n+      end if;\n+\n+      --  Add the buffer set aside for time zone processing since Split in\n+      --  Ada.Calendar.Formatting_Operations expects it to be there.\n+\n+      return Now + Buffer_N;\n    end Clock;\n \n+   -----------------------------\n+   -- Cumulative_Leap_Seconds --\n+   -----------------------------\n+\n+   procedure Cumulative_Leap_Seconds\n+     (Start_Date    : Time;\n+      End_Date      : Time;\n+      Elapsed_Leaps : out Natural;\n+      Next_Leap_Sec : out Time)\n+   is\n+      End_Index   : Positive;\n+      End_T       : Time := End_Date;\n+      Start_Index : Positive;\n+      Start_T     : Time := Start_Date;\n+\n+   begin\n+      --  Both input dates need to be normalized to GMT in order for this\n+      --  routine to work properly.\n+\n+      pragma Assert (End_Date >= Start_Date);\n+\n+      Next_Leap_Sec := After_Last_Leap;\n+\n+      --  Make sure that the end date does not excede the upper bound\n+      --  of Ada time.\n+\n+      if End_Date > Ada_High then\n+         End_T := Ada_High;\n+      end if;\n+\n+      --  Remove the sub seconds from both dates\n+\n+      Start_T := Start_T - (Start_T mod Nano);\n+      End_T   := End_T   - (End_T   mod Nano);\n+\n+      --  Some trivial cases:\n+      --                     Leap 1 . . . Leap N\n+      --  ---+========+------+############+-------+========+-----\n+      --     Start_T  End_T                       Start_T  End_T\n+\n+      if End_T < Leap_Second_Times (1) then\n+         Elapsed_Leaps := 0;\n+         Next_Leap_Sec := Leap_Second_Times (1);\n+         return;\n+\n+      elsif Start_T > Leap_Second_Times (Leap_Seconds_Count) then\n+         Elapsed_Leaps := 0;\n+         Next_Leap_Sec := After_Last_Leap;\n+         return;\n+      end if;\n+\n+      --  Perform the calculations only if the start date is within the leap\n+      --  second occurences table.\n+\n+      if Start_T <= Leap_Second_Times (Leap_Seconds_Count) then\n+\n+         --    1    2                  N - 1   N\n+         --  +----+----+--  . . .  --+-------+---+\n+         --  | T1 | T2 |             | N - 1 | N |\n+         --  +----+----+--  . . .  --+-------+---+\n+         --         ^                   ^\n+         --         | Start_Index       | End_Index\n+         --         +-------------------+\n+         --             Leaps_Between\n+\n+         --  The idea behind the algorithm is to iterate and find two\n+         --  closest dates which are after Start_T and End_T. Their\n+         --  corresponding index difference denotes the number of leap\n+         --  seconds elapsed.\n+\n+         Start_Index := 1;\n+         loop\n+            exit when Leap_Second_Times (Start_Index) >= Start_T;\n+            Start_Index := Start_Index + 1;\n+         end loop;\n+\n+         End_Index := Start_Index;\n+         loop\n+            exit when End_Index > Leap_Seconds_Count\n+              or else Leap_Second_Times (End_Index) >= End_T;\n+            End_Index := End_Index + 1;\n+         end loop;\n+\n+         if End_Index <= Leap_Seconds_Count then\n+            Next_Leap_Sec := Leap_Second_Times (End_Index);\n+         end if;\n+\n+         Elapsed_Leaps := End_Index - Start_Index;\n+\n+      else\n+         Elapsed_Leaps := 0;\n+      end if;\n+   end Cumulative_Leap_Seconds;\n+\n    ---------\n    -- Day --\n    ---------\n \n    function Day (Date : Time) return Day_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DD;\n+      Split (Date, Y, M, D, S);\n+      return D;\n    end Day;\n \n+   -------------\n+   -- Is_Leap --\n+   -------------\n+\n+   function Is_Leap (Year : Year_Number) return Boolean is\n+   begin\n+      --  Leap centenial years\n+\n+      if Year mod 400 = 0 then\n+         return True;\n+\n+      --  Non-leap centenial years\n+\n+      elsif Year mod 100 = 0 then\n+         return False;\n+\n+      --  Regular years\n+\n+      else\n+         return Year mod 4 = 0;\n+      end if;\n+   end Is_Leap;\n+\n    -----------\n    -- Month --\n    -----------\n \n    function Month (Date : Time) return Month_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DM;\n+      Split (Date, Y, M, D, S);\n+      return M;\n    end Month;\n \n    -------------\n    -- Seconds --\n    -------------\n \n    function Seconds (Date : Time) return Day_Duration is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DS;\n+      Split (Date, Y, M, D, S);\n+      return S;\n    end Seconds;\n \n    -----------\n@@ -268,438 +544,999 @@ package body Ada.Calendar is\n       Day     : out Day_Number;\n       Seconds : out Day_Duration)\n    is\n-      Offset : Long_Integer;\n+      H  : Integer;\n+      M  : Integer;\n+      Se : Integer;\n+      Ss : Duration;\n+      Le : Boolean;\n+      Tz : constant Long_Integer :=\n+             Time_Zones_Operations.UTC_Time_Offset (Date) / 60;\n \n    begin\n-      Split_With_Offset (Date, Year, Month, Day, Seconds, Offset);\n-   end Split;\n+      Formatting_Operations.Split\n+        (Date, Year, Month, Day, Seconds, H, M, Se, Ss, Le, Tz);\n \n-   -----------------------\n-   -- Split_With_Offset --\n-   -----------------------\n+      --  Validity checks\n \n-   procedure Split_With_Offset\n-     (Date    : Time;\n-      Year    : out Year_Number;\n-      Month   : out Month_Number;\n-      Day     : out Day_Number;\n-      Seconds : out Day_Duration;\n-      Offset  : out Long_Integer)\n-   is\n-      --  The following declare bounds for duration that are comfortably\n-      --  wider than the maximum allowed output result for the Ada range\n-      --  of representable split values. These are used for a quick check\n-      --  that the value is not wildly out of range.\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Seconds'Valid\n+      then\n+         raise Time_Error;\n+      end if;\n+   end Split;\n \n-      Low  : constant := (Ada_Year_Min - Unix_Year_Min - 2) * 365 * 86_400;\n-      High : constant := (Ada_Year_Max - Unix_Year_Min + 2) * 365 * 86_400;\n+   -------------\n+   -- Time_Of --\n+   -------------\n \n-      LowD  : constant Duration := Duration (Low);\n-      HighD : constant Duration := Duration (High);\n+   function Time_Of\n+     (Year    : Year_Number;\n+      Month   : Month_Number;\n+      Day     : Day_Number;\n+      Seconds : Day_Duration := 0.0) return Time\n+   is\n+      --  The values in the following constants are irrelevant, they are just\n+      --  placeholders; the choice of constructing a Day_Duration value is\n+      --  controlled by the Use_Day_Secs flag.\n \n-      --  Finally the actual variables used in the computation\n+      H  : constant Integer := 1;\n+      M  : constant Integer := 1;\n+      Se : constant Integer := 1;\n+      Ss : constant Duration := 0.1;\n \n-      Adjusted_Seconds : aliased time_t;\n-      D                : Duration;\n-      Frac_Sec         : Duration;\n-      Local_Offset     : aliased long;\n-      Tm_Val           : aliased tm;\n-      Year_Val         : Integer;\n+      Mid_Offset : Long_Integer;\n+      Mid_Result : Time;\n+      Offset     : Long_Integer;\n \n    begin\n-      --  For us a time is simply a signed duration value, so we work with\n-      --  this duration value directly. Note that it can be negative.\n-\n-      D := Duration (Date);\n-\n-      --  First of all, filter out completely ludicrous values. Remember that\n-      --  we use the full stored range of duration values, which may be\n-      --  significantly larger than the allowed range of Ada times. Note that\n-      --  these checks are wider than required to make absolutely sure that\n-      --  there are no end effects from time zone differences.\n-\n-      if D < LowD or else D > HighD then\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Seconds'Valid\n+      then\n          raise Time_Error;\n       end if;\n \n-      --  The unix localtime_r function is more or less exactly what we need\n-      --  here. The less comes from the fact that it does not support the\n-      --  required range of years (the guaranteed range available is only\n-      --  EPOCH through EPOCH + N seconds). N is in practice 2 ** 31 - 1.\n+      --  Building a time value in a local time zone is tricky since the\n+      --  local time zone offset at the point of creation may not be the\n+      --  same as the actual time zone offset designated by the input\n+      --  values. The following example is relevant to New York, USA.\n+      --\n+      --     Creation date: 2006-10-10 0.0  Offset -240 mins (in DST)\n+      --     Actual date  : 1901-01-01 0.0  Offset -300 mins (no DST)\n \n-      --  If we have a value outside this range, then we first adjust it to be\n-      --  in the required range by adding multiples of 56 years. For the range\n-      --  we are interested in, the number of days in any consecutive 56 year\n-      --  period is constant. Then we do the split on the adjusted value, and\n-      --  readjust the years value accordingly.\n-\n-      Year_Val := 0;\n-\n-      while D < 0.0 loop\n-         D := D + Seconds_In_56_YearsD;\n-         Year_Val := Year_Val - 56;\n-      end loop;\n+      --  We first start by obtaining the current local time zone offset\n+      --  using Ada.Calendar.Clock, then building an intermediate time\n+      --  value using that offset.\n \n-      while D >= Seconds_In_56_YearsD loop\n-         D := D - Seconds_In_56_YearsD;\n-         Year_Val := Year_Val + 56;\n-      end loop;\n+      Mid_Offset := Time_Zones_Operations.UTC_Time_Offset (Clock) / 60;\n+      Mid_Result := Formatting_Operations.Time_Of\n+                      (Year, Month, Day, Seconds, H, M, Se, Ss,\n+                       Leap_Sec     => False,\n+                       Leap_Checks  => False,\n+                       Use_Day_Secs => True,\n+                       Time_Zone    => Mid_Offset);\n \n-      --  Now we need to take the value D, which is now non-negative, and\n-      --  break it down into seconds (to pass to the localtime_r function) and\n-      --  fractions of seconds (for the adjustment below).\n+      --  This is the true local time zone offset of the input time values\n \n-      --  Surprisingly there is no easy way to do this in Ada, and certainly\n-      --  no easy way to do it and generate efficient code. Therefore we do it\n-      --  at a low level, knowing that it is really represented as an integer\n-      --  with units of Small\n+      Offset := Time_Zones_Operations.UTC_Time_Offset (Mid_Result) / 60;\n \n-      declare\n-         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n-         for D_Int'Size use Duration'Size;\n+      --  It is possible that at the point of invocation of Time_Of, both\n+      --  the current local time zone offset and the one designated by the\n+      --  input values are in the same DST mode.\n \n-         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n-         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n+      if Offset = Mid_Offset then\n+         return Mid_Result;\n \n-         D_As_Int  : constant D_Int := To_D_Int (D);\n-         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+      --  In this case we must calculate the new time with the new offset. It\n+      --  is no sufficient to just take the relative difference between the\n+      --  two offsets and adjust the intermediate result, because this does not\n+      --  work around leap second times.\n \n-      begin\n-         Adjusted_Seconds := time_t (D_As_Int / Small_Div);\n-         Frac_Sec := To_Duration (D_As_Int rem Small_Div);\n-      end;\n-\n-      localtime_tzoff\n-        (Adjusted_Seconds'Unchecked_Access,\n-         Tm_Val'Unchecked_Access,\n-         Local_Offset'Unchecked_Access);\n-\n-      Year_Val := Tm_Val.tm_year + 1900 + Year_Val;\n-      Month    := Tm_Val.tm_mon + 1;\n-      Day      := Tm_Val.tm_mday;\n-      Offset   := Long_Integer (Local_Offset);\n-\n-      --  The Seconds value is a little complex. The localtime function\n-      --  returns the integral number of seconds, which is what we want, but\n-      --  we want to retain the fractional part from the original Time value,\n-      --  since this is typically stored more accurately.\n-\n-      Seconds := Duration (Tm_Val.tm_hour * 3600 +\n-                           Tm_Val.tm_min  * 60 +\n-                           Tm_Val.tm_sec)\n-                   + Frac_Sec;\n-\n-      --  Note: the above expression is pretty horrible, one of these days we\n-      --  should stop using time_of and do everything ourselves to avoid these\n-      --  unnecessary divides and multiplies???.\n-\n-      --  The Year may still be out of range, since our entry test was\n-      --  deliberately crude. Trying to make this entry test accurate is\n-      --  tricky due to time zone adjustment issues affecting the exact\n-      --  boundary. It is interesting to note that whether or not a given\n-      --  Calendar.Time value gets Time_Error when split depends on the\n-      --  current time zone setting.\n-\n-      if Year_Val not in Ada_Year_Min .. Ada_Year_Max then\n-         raise Time_Error;\n       else\n-         Year := Year_Val;\n+         declare\n+            Result : constant Time :=\n+                       Formatting_Operations.Time_Of\n+                         (Year, Month, Day, Seconds, H, M, Se, Ss,\n+                         Leap_Sec     => False,\n+                         Leap_Checks  => False,\n+                         Use_Day_Secs => True,\n+                         Time_Zone    => Offset);\n+\n+         begin\n+            return Result;\n+         end;\n       end if;\n-   end Split_With_Offset;\n-\n-   -------------\n-   -- Time_Of --\n-   -------------\n+   end Time_Of;\n \n-   function Time_Of\n-     (Year    : Year_Number;\n-      Month   : Month_Number;\n-      Day     : Day_Number;\n-      Seconds : Day_Duration := 0.0)\n-      return    Time\n-   is\n-      Result_Secs : aliased time_t;\n-      TM_Val      : aliased tm;\n-      Int_Secs    : constant Integer := Integer (Seconds);\n+   ---------------------\n+   -- To_Abs_Duration --\n+   ---------------------\n \n-      Year_Val        : Integer := Year;\n-      Duration_Adjust : Duration := 0.0;\n+   function To_Abs_Duration (T : Time) return Duration is\n+      pragma Unsuppress (Overflow_Check);\n+      function To_Duration is new Ada.Unchecked_Conversion (Time, Duration);\n \n    begin\n-      --  The following checks are redundant with respect to the constraint\n-      --  error checks that should normally be made on parameters, but we\n-      --  decide to raise Constraint_Error in any case if bad values come in\n-      --  (as a result of checks being off in the caller, or for other\n-      --  erroneous or bounded error cases).\n-\n-      if        not Year   'Valid\n-        or else not Month  'Valid\n-        or else not Day    'Valid\n-        or else not Seconds'Valid\n-      then\n-         raise Constraint_Error;\n-      end if;\n+      return To_Duration (T);\n \n-      --  Check for Day value too large (one might expect mktime to do this\n-      --  check, as well as the basic checks we did with 'Valid, but it seems\n-      --  that at least on some systems, this built-in check is too weak).\n-\n-      if Day > Days_In_Month (Month)\n-        and then (Day /= 29 or Month /= 2 or Year mod 4 /= 0)\n-      then\n+   exception\n+      when Constraint_Error =>\n          raise Time_Error;\n-      end if;\n-\n-      TM_Val.tm_sec  := Int_Secs mod 60;\n-      TM_Val.tm_min  := (Int_Secs / 60) mod 60;\n-      TM_Val.tm_hour := (Int_Secs / 60) / 60;\n-      TM_Val.tm_mday := Day;\n-      TM_Val.tm_mon  := Month - 1;\n-\n-      --  For the year, we have to adjust it to a year that Unix can handle.\n-      --  We do this in 56 year steps, since the number of days in 56 years is\n-      --  constant, so the timezone effect on the conversion from local time\n-      --  to GMT is unaffected; also the DST change dates are usually not\n-      --  modified.\n-\n-      while Year_Val < Unix_Year_Min loop\n-         Year_Val := Year_Val + 56;\n-         Duration_Adjust := Duration_Adjust - Seconds_In_56_YearsD;\n-      end loop;\n+   end To_Abs_Duration;\n \n-      while Year_Val >= Unix_Year_Max loop\n-         Year_Val := Year_Val - 56;\n-         Duration_Adjust := Duration_Adjust + Seconds_In_56_YearsD;\n-      end loop;\n+   -----------------\n+   -- To_Abs_Time --\n+   -----------------\n \n-      TM_Val.tm_year := Year_Val - 1900;\n+   function To_Abs_Time (D : Duration) return Time is\n+      pragma Unsuppress (Overflow_Check);\n+      function To_Time is new Ada.Unchecked_Conversion (Duration, Time);\n \n-      --  If time is very close to UNIX epoch mktime may behave uncorrectly\n-      --  because of the way the different time zones are handled (a date\n-      --  after epoch in a given time zone may correspond to a GMT date\n-      --  before epoch). Adding one day to the date (this amount is latter\n-      --  substracted) avoids this problem.\n+   begin\n+      --  This operation assumes that D is positive\n \n-      if Year_Val = Unix_Year_Min\n-        and then Month = 1\n-        and then Day = 1\n-      then\n-         TM_Val.tm_mday := TM_Val.tm_mday + 1;\n-         Duration_Adjust := Duration_Adjust - Duration (86400.0);\n+      if D < 0.0 then\n+         raise Constraint_Error;\n       end if;\n \n-      --  Since we do not have information on daylight savings, rely on the\n-      --  default information.\n+      return To_Time (D);\n \n-      TM_Val.tm_isdst := -1;\n-      Result_Secs := mktime (TM_Val'Unchecked_Access);\n-\n-      --  That gives us the basic value in seconds. Two adjustments are\n-      --  needed. First we must undo the year adjustment carried out above.\n-      --  Second we put back the fraction seconds value since in general the\n-      --  Day_Duration value we received has additional precision which we do\n-      --  not want to lose in the constructed result.\n-\n-      return\n-        Time (Duration (Result_Secs) +\n-              Duration_Adjust +\n-              (Seconds - Duration (Int_Secs)));\n-   end Time_Of;\n+   exception\n+      when Constraint_Error =>\n+         raise Time_Error;\n+   end To_Abs_Time;\n \n    ----------\n    -- Year --\n    ----------\n \n    function Year (Date : Time) return Year_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n+      Y : Year_Number;\n+      M : Month_Number;\n+      D : Day_Number;\n+      S : Day_Duration;\n    begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DY;\n+      Split (Date, Y, M, D, S);\n+      return Y;\n    end Year;\n \n-   -------------------\n-   --  Leap_Sec_Ops --\n-   -------------------\n+   --  The following packages assume that Time is a modular 64 bit integer\n+   --  type, the units are nanoseconds and the origin is the start of Ada\n+   --  time (1901-1-1 0.0).\n \n-   --  The package that is used by the Ada 2005 children of Ada.Calendar:\n-   --  Ada.Calendar.Arithmetic and Ada.Calendar.Formatting.\n+   ---------------------------\n+   -- Arithmetic_Operations --\n+   ---------------------------\n \n-   package body Leap_Sec_Ops is\n+   package body Arithmetic_Operations is\n \n-      --  This package must be updated when leap seconds are added. Adding a\n-      --  leap second requires incrementing the value of N_Leap_Secs and adding\n-      --  the day of the new leap second to the end of Leap_Second_Dates.\n+      ---------\n+      -- Add --\n+      ---------\n \n-      --  Elaboration of the Leap_Sec_Ops package takes care of converting the\n-      --  Leap_Second_Dates table to a form that is better suited for the\n-      --  procedures provided by this package (a table that would be more\n-      --  difficult to maintain by hand).\n+      function Add (Date : Time; Days : Long_Integer) return Time is\n+      begin\n+         if Days = 0 then\n+            return Date;\n \n-      N_Leap_Secs : constant := 23;\n+         elsif Days < 0 then\n+            return Subtract (Date, abs (Days));\n \n-      type Leap_Second_Date is record\n-         Year  : Year_Number;\n-         Month : Month_Number;\n-         Day   : Day_Number;\n-      end record;\n+         else\n+            declare\n+               Result : constant Time := Date + Time (Days) * Nanos_In_Day;\n \n-      Leap_Second_Dates :\n-        constant array (1 .. N_Leap_Secs) of Leap_Second_Date :=\n-          ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n-           (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n-           (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n-           (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n-           (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n-           (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n+            begin\n+               --  The result excedes the upper bound of Ada time\n \n-      Leap_Second_Times : array (1 .. N_Leap_Secs) of Time;\n-      --  This is the needed internal representation that is calculated\n-      --  from Leap_Second_Dates during elaboration;\n+               if Result > Ada_High_And_Leaps then\n+                  raise Time_Error;\n+               end if;\n \n-      --------------------------\n-      -- Cumulative_Leap_Secs --\n-      --------------------------\n+               return Result;\n+            end;\n+         end if;\n \n-      procedure Cumulative_Leap_Secs\n-        (Start_Date    : Time;\n-         End_Date      : Time;\n-         Leaps_Between : out Duration;\n-         Next_Leap_Sec : out Time)\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end Add;\n+\n+      ----------------\n+      -- Difference --\n+      ----------------\n+\n+      procedure Difference\n+        (Left         : Time;\n+         Right        : Time;\n+         Days         : out Long_Integer;\n+         Seconds      : out Duration;\n+         Leap_Seconds : out Integer)\n       is\n-         End_T      : Time;\n-         K          : Positive;\n-         Leap_Index : Positive;\n-         Start_Tmp  : Time;\n-         Start_T    : Time;\n+         Diff_N        : Time;\n+         Diff_S        : Time;\n+         Earlier       : Time;\n+         Elapsed_Leaps : Natural;\n+         Later         : Time;\n+         Negate        : Boolean := False;\n+         Next_Leap     : Time;\n+         Sub_Seconds   : Duration;\n \n-         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n-         for  D_Int'Size use Duration'Size;\n-\n-         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n-         D_As_Int  : D_Int;\n+      begin\n+         --  Both input time values are assumed to be in GMT\n \n-         function To_D_As_Int is new Unchecked_Conversion (Duration, D_Int);\n+         if Left >= Right then\n+            Later   := Left;\n+            Earlier := Right;\n+         else\n+            Later   := Right;\n+            Earlier := Left;\n+            Negate  := True;\n+         end if;\n \n-      begin\n-         Next_Leap_Sec := After_Last_Leap;\n+         --  First process the leap seconds\n \n-         --  We want to throw away the fractional part of seconds. Before\n-         --  proceding with this operation, make sure our working values\n-         --  are non-negative.\n+         Cumulative_Leap_Seconds (Earlier, Later, Elapsed_Leaps, Next_Leap);\n \n-         if End_Date < 0.0 then\n-            Leaps_Between := 0.0;\n-            return;\n+         if Later >= Next_Leap then\n+            Elapsed_Leaps := Elapsed_Leaps + 1;\n          end if;\n \n-         if Start_Date < 0.0 then\n-            Start_Tmp := Time (0.0);\n-         else\n-            Start_Tmp := Start_Date;\n+         Diff_N := Later - Earlier - Time (Elapsed_Leaps) * Nano;\n+\n+         --  Sub second processing\n+\n+         Sub_Seconds := Duration (Diff_N mod Nano) / Nano_F;\n+\n+         --  Convert to seconds. Note that his action eliminates the sub\n+         --  seconds automatically.\n+\n+         Diff_S := Diff_N / Nano;\n+\n+         Days := Long_Integer (Diff_S / Secs_In_Day);\n+         Seconds := Duration (Diff_S mod Secs_In_Day) + Sub_Seconds;\n+         Leap_Seconds := Integer (Elapsed_Leaps);\n+\n+         if Negate then\n+            Days         := -Days;\n+            Seconds      := -Seconds;\n+            Leap_Seconds := -Leap_Seconds;\n          end if;\n+      end Difference;\n \n-         if Start_Date <= Leap_Second_Times (N_Leap_Secs) then\n-\n-            --  Manipulate the fixed point value as an integer, similar to\n-            --  Ada.Calendar.Split in order to remove the fractional part\n-            --  from the time we will work with, Start_T and End_T.\n-\n-            D_As_Int := To_D_As_Int (Duration (Start_Tmp));\n-            D_As_Int := D_As_Int / Small_Div;\n-            Start_T  := Time (D_As_Int);\n-            D_As_Int := To_D_As_Int (Duration (End_Date));\n-            D_As_Int := D_As_Int / Small_Div;\n-            End_T    := Time (D_As_Int);\n-\n-            Leap_Index := 1;\n-            loop\n-               exit when Leap_Second_Times (Leap_Index) >= Start_T;\n-               Leap_Index := Leap_Index + 1;\n-            end loop;\n-\n-            K := Leap_Index;\n-            loop\n-               exit when K > N_Leap_Secs or else\n-                 Leap_Second_Times (K) >= End_T;\n-               K := K + 1;\n-            end loop;\n-\n-            if K <= N_Leap_Secs then\n-               Next_Leap_Sec := Leap_Second_Times (K);\n-            end if;\n+      --------------\n+      -- Subtract --\n+      --------------\n+\n+      function Subtract (Date : Time; Days : Long_Integer) return Time is\n+      begin\n+         if Days = 0 then\n+            return Date;\n+\n+         elsif Days < 0 then\n+            return Add (Date, abs (Days));\n \n-            Leaps_Between := Duration (K - Leap_Index);\n          else\n-            Leaps_Between := Duration (0.0);\n+            declare\n+               Days_T : constant Time := Time (Days) * Nanos_In_Day;\n+               Result : Time;\n+\n+            begin\n+               --  Subtracting a larger number of days from a smaller time\n+               --  value will cause wrap around since time is a modular type.\n+\n+               if Date < Days_T then\n+                  raise Time_Error;\n+               end if;\n+\n+               Result := Date - Days_T;\n+\n+               if Result < Ada_Low\n+                 or else Result > Ada_High_And_Leaps\n+               then\n+                  raise Time_Error;\n+               end if;\n+\n+               return Result;\n+            end;\n          end if;\n-      end Cumulative_Leap_Secs;\n \n-      ----------------------\n-      -- All_Leap_Seconds --\n-      ----------------------\n+      exception\n+         when Constraint_Error =>\n+            raise Time_Error;\n+      end Subtract;\n+   end Arithmetic_Operations;\n+\n+   ----------------------\n+   -- Delay_Operations --\n+   ----------------------\n+\n+   package body Delays_Operations is\n+\n+      -----------------\n+      -- To_Duration --\n+      -----------------\n+\n+      function To_Duration (Ada_Time : Time) return Duration is\n+         Elapsed_Leaps : Natural;\n+         Modified_Time : Time;\n+         Next_Leap     : Time;\n+         Result        : Duration;\n+         Rounded_Time  : Time;\n \n-      function All_Leap_Seconds return Duration is\n       begin\n-         return Duration (N_Leap_Secs);\n-         --  Presumes each leap second is +1.0 second;\n-      end All_Leap_Seconds;\n+         Modified_Time := Ada_Time;\n+         Rounded_Time  := Modified_Time - (Modified_Time mod Nano);\n \n-   --  Start of processing in package Leap_Sec_Ops\n+         --  Remove all leap seconds\n+\n+         Cumulative_Leap_Seconds\n+           (Time_Zero, Modified_Time, Elapsed_Leaps, Next_Leap);\n+\n+         Modified_Time := Modified_Time - Time (Elapsed_Leaps) * Nano;\n+\n+         --  The input time value may fall on a leap second occurence\n+\n+         if Rounded_Time = Next_Leap then\n+            Modified_Time := Modified_Time - Time (1) * Nano;\n+         end if;\n+\n+         --  Perform a shift in origins\n+\n+         Result := Modified_Time - Unix_Min;\n+\n+         --  Remove the buffer period used in time zone processing\n+\n+         return Result - Buffer_D;\n+      end To_Duration;\n+   end Delays_Operations;\n+\n+   ---------------------------\n+   -- Formatting_Operations --\n+   ---------------------------\n+\n+   package body Formatting_Operations is\n+\n+      -----------------\n+      -- Day_Of_Week --\n+      -----------------\n+\n+      function Day_Of_Week (Date : Time) return Integer is\n+         Y  : Year_Number;\n+         Mo : Month_Number;\n+         D  : Day_Number;\n+         Dd : Day_Duration;\n+         H  : Integer;\n+         Mi : Integer;\n+         Se : Integer;\n+         Su : Duration;\n+         Le : Boolean;\n+\n+         Day_Count     : Long_Integer;\n+         Midday_Date_S : Time;\n+\n+      begin\n+         Formatting_Operations.Split\n+           (Date, Y, Mo, D, Dd, H, Mi, Se, Su, Le, 0);\n+\n+         --  Build a time value in the middle of the same day, remove the\n+         --  lower buffer and convert the time value to seconds.\n+\n+         Midday_Date_S := (Formatting_Operations.Time_Of\n+                             (Y, Mo, D, 0.0, 12, 0, 0, 0.0,\n+                              Leap_Sec     => False,\n+                              Leap_Checks  => False,\n+                              Use_Day_Secs => False,\n+                              Time_Zone    => 0) - Buffer_N) / Nano;\n+\n+         --  Count the number of days since the start of Ada time. 1901-1-1\n+         --  GMT was a Tuesday.\n+\n+         Day_Count := Long_Integer (Midday_Date_S / Secs_In_Day) + 1;\n+\n+         return Integer (Day_Count mod 7);\n+      end Day_Of_Week;\n+\n+      -----------\n+      -- Split --\n+      -----------\n+\n+      procedure Split\n+        (Date         : Time;\n+         Year         : out Year_Number;\n+         Month        : out Month_Number;\n+         Day          : out Day_Number;\n+         Day_Secs     : out Day_Duration;\n+         Hour         : out Integer;\n+         Minute       : out Integer;\n+         Second       : out Integer;\n+         Sub_Sec      : out Duration;\n+         Leap_Sec     : out Boolean;\n+         Time_Zone    : Long_Integer)\n+      is\n+         --  The following constants represent the number of nanoseconds\n+         --  elapsed since the start of Ada time to and including the non\n+         --  leap centenial years.\n+\n+         Year_2101 : constant Time := (49 * 366 + 151 * 365) * Nanos_In_Day;\n+         Year_2201 : constant Time := (73 * 366 + 227 * 365) * Nanos_In_Day;\n+         Year_2301 : constant Time := (97 * 366 + 303 * 365) * Nanos_In_Day;\n+\n+         Abs_Time_Zone   : Time;\n+         Day_Seconds     : Natural;\n+         Elapsed_Leaps   : Natural;\n+         Four_Year_Segs  : Natural;\n+         Hour_Seconds    : Natural;\n+         Is_Leap_Year    : Boolean;\n+         Modified_Date_N : Time;\n+         Modified_Date_S : Time;\n+         Next_Leap_N     : Time;\n+         Rem_Years       : Natural;\n+         Rounded_Date_N  : Time;\n+         Year_Day        : Natural;\n \n-   begin\n-      declare\n-         Days         : Natural;\n-         Is_Leap_Year : Boolean;\n-         Years        : Natural;\n-\n-         Cumulative_Days_Before_Month :\n-           constant array (Month_Number) of Natural :=\n-             (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n       begin\n-         for J in 1 .. N_Leap_Secs loop\n-            Years := Leap_Second_Dates (J).Year - Unix_Year_Min;\n-            Days  := (Years / 4) * Days_In_4_Years;\n-            Years := Years mod 4;\n-            Is_Leap_Year := False;\n+         Modified_Date_N := Date;\n+\n+         if Modified_Date_N < Hard_Ada_Low\n+           or else Modified_Date_N > Hard_Ada_High_And_Leaps\n+         then\n+            raise Time_Error;\n+         end if;\n \n-            if Years = 1 then\n-               Days := Days + 365;\n+         --  Step 1: Leap seconds processing in GMT\n+\n+         --  Day_Duration:    86_398  86_399  X (86_400) 0 (1)  1 (2)\n+         --  Time        :  --+-------+-------+----------+------+-->\n+         --  Seconds     :    58      59      60 (Leap)  1      2\n+\n+         --   o Modified_Date_N falls between 86_399 and X (86_400)\n+         --       Elapsed_Leaps  = X - 1 leaps\n+         --       Rounded_Date_N = 86_399\n+         --       Next_Leap_N    = X (86_400)\n+         --       Leap_Sec       = False\n+\n+         --   o Modified_Date_N falls exactly on X (86_400)\n+         --       Elapsed_Leaps  = X - 1 leaps\n+         --       Rounded_Date_N = X (86_400)\n+         --       Next_Leap_N    = X (86_400)\n+         --       Leap_Sec       = True\n+         --     An invisible leap second will be added.\n+\n+         --   o Modified_Date_N falls between X (86_400) and 0 (1)\n+         --       Elapsed_Leaps  = X - 1 leaps\n+         --       Rounded_Date_N = X (86_400)\n+         --       Next_Leap_N    = X (86_400)\n+         --       Leap_Sec       = True\n+         --     An invisible leap second will be added.\n+\n+         --   o Modified_Date_N falls on 0 (1)\n+         --       Elapsed_Leaps  = X\n+         --       Rounded_Date_N = 0 (1)\n+         --       Next_Leap_N    = X + 1\n+         --       Leap_Sec       = False\n+         --     The invisible leap second has already been accounted for in\n+         --     Elapsed_Leaps.\n+\n+         Cumulative_Leap_Seconds\n+           (Time_Zero, Modified_Date_N, Elapsed_Leaps, Next_Leap_N);\n+\n+         Rounded_Date_N  := Modified_Date_N - (Modified_Date_N mod Nano);\n+         Leap_Sec        := Rounded_Date_N = Next_Leap_N;\n+         Modified_Date_N := Modified_Date_N - Time (Elapsed_Leaps) * Nano;\n+\n+         if Leap_Sec then\n+            Modified_Date_N := Modified_Date_N - Time (1) * Nano;\n+         end if;\n \n-            elsif Years = 2 then\n-               Is_Leap_Year := True;\n+         --  Step 2: Time zone processing. This action converts the input date\n+         --  from GMT to the requested time zone.\n \n-               --  1972 or multiple of 4 after\n+         if Time_Zone /= 0 then\n+            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Nano;\n \n-               Days := Days + 365 * 2;\n+            if Time_Zone < 0 then\n+               --  The following test is obsolete since the date already\n+               --  contains the dedicated buffer for time zones, thus no\n+               --  error will be raised. However it is a good idea to keep\n+               --  it should the representation of time change.\n \n-            elsif Years = 3 then\n-               Days := Days + 365 * 3 + 1;\n+               Modified_Date_N := Modified_Date_N - Abs_Time_Zone;\n+            else\n+               Modified_Date_N := Modified_Date_N + Abs_Time_Zone;\n             end if;\n+         end if;\n+\n+         --  After the elapsed leap seconds have been removed and the date\n+         --  has been normalized, it should fall withing the soft bounds of\n+         --  Ada time.\n+\n+         if Modified_Date_N < Ada_Low\n+           or else Modified_Date_N > Ada_High\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Before any additional arithmetic is performed we must remove the\n+         --  lower buffer period since it will be accounted as few additional\n+         --  days.\n \n-            Days := Days + Cumulative_Days_Before_Month\n-                             (Leap_Second_Dates (J).Month);\n+         Modified_Date_N := Modified_Date_N - Buffer_N;\n+\n+         --  Step 3: Non-leap centenial year adjustment in local time zone\n+\n+         --  In order for all divisions to work properly and to avoid more\n+         --  complicated arithmetic, we add fake Febriary 29s to dates which\n+         --  occur after a non-leap centenial year.\n+\n+         if Modified_Date_N >= Year_2301 then\n+            Modified_Date_N := Modified_Date_N + Time (3) * Nanos_In_Day;\n+\n+         elsif Modified_Date_N >= Year_2201 then\n+            Modified_Date_N := Modified_Date_N + Time (2) * Nanos_In_Day;\n+\n+         elsif Modified_Date_N >= Year_2101 then\n+            Modified_Date_N := Modified_Date_N + Time (1) * Nanos_In_Day;\n+         end if;\n \n-            if Is_Leap_Year\n-              and then Leap_Second_Dates (J).Month > 2\n+         --  Step 4: Sub second processing in local time zone\n+\n+         Sub_Sec := Duration (Modified_Date_N mod Nano) / Nano_F;\n+\n+         --  Convert the date into seconds, the sub seconds are automatically\n+         --  dropped.\n+\n+         Modified_Date_S := Modified_Date_N / Nano;\n+\n+         --  Step 5: Year processing in local time zone. Determine the number\n+         --  of four year segments since the start of Ada time and the input\n+         --  date.\n+\n+         Four_Year_Segs := Natural (Modified_Date_S / Secs_In_Four_Years);\n+\n+         if Four_Year_Segs > 0 then\n+            Modified_Date_S := Modified_Date_S - Time (Four_Year_Segs) *\n+                                                 Secs_In_Four_Years;\n+         end if;\n+\n+         --  Calculate the remaining non-leap years\n+\n+         Rem_Years := Natural (Modified_Date_S / Secs_In_Non_Leap_Year);\n+\n+         if Rem_Years > 3 then\n+            Rem_Years := 3;\n+         end if;\n+\n+         Modified_Date_S := Modified_Date_S - Time (Rem_Years) *\n+                                              Secs_In_Non_Leap_Year;\n+\n+         Year := Ada_Min_Year + Natural (4 * Four_Year_Segs + Rem_Years);\n+         Is_Leap_Year := Is_Leap (Year);\n+\n+         --  Step 6: Month and day processing in local time zone\n+\n+         Year_Day := Natural (Modified_Date_S / Secs_In_Day) + 1;\n+\n+         Month := 1;\n+\n+         --  Processing for months after January\n+\n+         if Year_Day > 31 then\n+            Month    := 2;\n+            Year_Day := Year_Day - 31;\n+\n+            --  Processing for a new month or a leap February\n+\n+            if Year_Day > 28\n+              and then (not Is_Leap_Year\n+                          or else Year_Day > 29)\n             then\n-               Days := Days + 1;\n+               Month    := 3;\n+               Year_Day := Year_Day - 28;\n+\n+               if Is_Leap_Year then\n+                  Year_Day := Year_Day - 1;\n+               end if;\n+\n+               --  Remaining months\n+\n+               while Year_Day > Days_In_Month (Month) loop\n+                  Year_Day := Year_Day - Days_In_Month (Month);\n+                  Month    := Month + 1;\n+               end loop;\n             end if;\n+         end if;\n \n-            Days := Days + Leap_Second_Dates (J).Day;\n+         --  Step 7: Hour, minute, second and sub second processing in local\n+         --  time zone.\n+\n+         Day          := Day_Number (Year_Day);\n+         Day_Seconds  := Integer (Modified_Date_S mod Secs_In_Day);\n+         Day_Secs     := Duration (Day_Seconds) + Sub_Sec;\n+         Hour         := Day_Seconds / 3_600;\n+         Hour_Seconds := Day_Seconds mod 3_600;\n+         Minute       := Hour_Seconds / 60;\n+         Second       := Hour_Seconds mod 60;\n+      end Split;\n+\n+      -------------\n+      -- Time_Of --\n+      -------------\n+\n+      function Time_Of\n+        (Year         : Year_Number;\n+         Month        : Month_Number;\n+         Day          : Day_Number;\n+         Day_Secs     : Day_Duration;\n+         Hour         : Integer;\n+         Minute       : Integer;\n+         Second       : Integer;\n+         Sub_Sec      : Duration;\n+         Leap_Sec     : Boolean;\n+         Leap_Checks  : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Time_Zone    : Long_Integer) return Time\n+      is\n+         Abs_Time_Zone    : Time;\n+         Count            : Integer;\n+         Elapsed_Leaps    : Natural;\n+         Next_Leap_N      : Time;\n+         Result_N         : Time;\n+         Rounded_Result_N : Time;\n+\n+      begin\n+         --  Step 1: Check whether the day, month and year form a valid date\n+\n+         if Day > Days_In_Month (Month)\n+           and then (Day /= 29 or else Month /= 2 or else not Is_Leap (Year))\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Start accumulating nanoseconds from the low bound of Ada time.\n+         --  Note: This starting point includes the lower buffer dedicated\n+         --  to time zones.\n+\n+         Result_N := Ada_Low;\n+\n+         --  Step 2: Year processing and centenial year adjustment. Determine\n+         --  the number of four year segments since the start of Ada time and\n+         --  the input date.\n+\n+         Count    := (Year - Year_Number'First) / 4;\n+         Result_N := Result_N + Time (Count) * Secs_In_Four_Years * Nano;\n+\n+         --  Note that non-leap centenial years are automatically considered\n+         --  leap in the operation above. An adjustment of several days is\n+         --  required to compensate for this.\n+\n+         if Year > 2300 then\n+            Result_N := Result_N - Time (3) * Nanos_In_Day;\n+\n+         elsif Year > 2200 then\n+            Result_N := Result_N - Time (2) * Nanos_In_Day;\n \n-            Leap_Second_Times (J) :=\n-              Time (Days * Duration (86_400.0) + Duration (J - 1));\n+         elsif Year > 2100 then\n+            Result_N := Result_N - Time (1) * Nanos_In_Day;\n+         end if;\n+\n+         --  Add the remaining non-leap years\n+\n+         Count    := (Year - Year_Number'First) mod 4;\n+         Result_N := Result_N + Time (Count) * Secs_In_Non_Leap_Year * Nano;\n+\n+         --  Step 3: Day of month processing. Determine the number of days\n+         --  since the start of the current year. Do not add the current\n+         --  day since it has not elapsed yet.\n+\n+         Count := Cumulative_Days_Before_Month (Month) + Day - 1;\n+\n+         --  The input year is leap and we have passed February\n \n-            --  Add one to get to the leap second. Add J - 1 previous\n-            --  leap seconds.\n+         if Is_Leap (Year)\n+           and then Month > 2\n+         then\n+            Count := Count + 1;\n+         end if;\n+\n+         Result_N := Result_N + Time (Count) * Nanos_In_Day;\n+\n+         --  Step 4: Hour, minute, second and sub second processing\n+\n+         if Use_Day_Secs then\n+            Result_N := Result_N + To_Abs_Time (Day_Secs);\n+\n+         else\n+            Result_N := Result_N +\n+              Time (Hour * 3_600 + Minute * 60 + Second) * Nano;\n \n+            if Sub_Sec = 1.0 then\n+               Result_N := Result_N + Time (1) * Nano;\n+            else\n+               Result_N := Result_N + To_Abs_Time (Sub_Sec);\n+            end if;\n+         end if;\n+\n+         --  Step 4: Time zone processing. At this point we have built an\n+         --  arbitrary time value which is not related to any time zone.\n+         --  For simplicity, the time value is normalized to GMT, producing\n+         --  a uniform representation which can be treated by arithmetic\n+         --  operations for instance without any additional corrections.\n+\n+         if Result_N < Ada_Low\n+           or else Result_N > Ada_High\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         if Time_Zone /= 0 then\n+            Abs_Time_Zone := Time (abs (Time_Zone)) * 60 * Nano;\n+\n+            if Time_Zone < 0 then\n+               Result_N := Result_N + Abs_Time_Zone;\n+            else\n+               --  The following test is obsolete since the result already\n+               --  contains the dedicated buffer for time zones, thus no\n+               --  error will be raised. However it is a good idea to keep\n+               --  this comparison should the representation of time change.\n+\n+               if Result_N < Abs_Time_Zone then\n+                  raise Time_Error;\n+               end if;\n+\n+               Result_N := Result_N - Abs_Time_Zone;\n+            end if;\n+         end if;\n+\n+         --  Step 5: Leap seconds processing in GMT\n+\n+         Cumulative_Leap_Seconds\n+           (Time_Zero, Result_N, Elapsed_Leaps, Next_Leap_N);\n+\n+         Result_N := Result_N + Time (Elapsed_Leaps) * Nano;\n+\n+         --  An Ada 2005 caller requesting an explicit leap second or an Ada\n+         --  95 caller accounting for an invisible leap second.\n+\n+         Rounded_Result_N := Result_N - (Result_N mod Nano);\n+\n+         if Leap_Sec\n+           or else Rounded_Result_N = Next_Leap_N\n+         then\n+            Result_N := Result_N + Time (1) * Nano;\n+            Rounded_Result_N := Rounded_Result_N + Time (1) * Nano;\n+         end if;\n+\n+         --  Leap second validity check\n+\n+         if Leap_Checks\n+           and then Leap_Sec\n+           and then Rounded_Result_N /= Next_Leap_N\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         --  Final bounds check\n+\n+         if Result_N < Hard_Ada_Low\n+           or else Result_N > Hard_Ada_High_And_Leaps\n+         then\n+            raise Time_Error;\n+         end if;\n+\n+         return Result_N;\n+      end Time_Of;\n+   end Formatting_Operations;\n+\n+   ---------------------------\n+   -- Time_Zones_Operations --\n+   ---------------------------\n+\n+   package body Time_Zones_Operations is\n+\n+      --  The Unix time bounds in seconds: 1970/1/1 .. 2037/1/1\n+\n+      Unix_Min : constant Time :=\n+                   Time (17 * 366 + 52 * 365 + 2) * Secs_In_Day;\n+      --  1970/1/1\n+\n+      Unix_Max : constant Time :=\n+                   Time (34 * 366 + 102 * 365 + 2) * Secs_In_Day +\n+                   Time (Leap_Seconds_Count);\n+      --  2037/1/1\n+\n+      --  The following constants denote February 28 during non-leap\n+      --  centenial years, the units are nanoseconds.\n+\n+      T_2100_2_28 : constant Time :=\n+                      (Time (49 * 366 + 150 * 365 + 59 + 2) * Secs_In_Day +\n+                         Time (Leap_Seconds_Count)) * Nano;\n+\n+      T_2200_2_28 : constant Time :=\n+                      (Time (73 * 366 + 226 * 365 + 59 + 2) * Secs_In_Day +\n+                         Time (Leap_Seconds_Count)) * Nano;\n+\n+      T_2300_2_28 : constant Time :=\n+                      (Time (97 * 366 + 302 * 365 + 59 + 2) * Secs_In_Day +\n+                         Time (Leap_Seconds_Count)) * Nano;\n+\n+      --  56 years (14 leap years + 42 non leap years) in seconds:\n+\n+      Secs_In_56_Years : constant := (14 * 366 + 42 * 365) * Secs_In_Day;\n+\n+      --  Base C types. There is no point dragging in Interfaces.C just for\n+      --  these four types.\n+\n+      type char_Pointer is access Character;\n+      subtype int is Integer;\n+      subtype long is Long_Integer;\n+      type long_Pointer is access all long;\n+\n+      --  The Ada equivalent of struct tm and type time_t\n+\n+      type tm is record\n+         tm_sec    : int;           -- seconds after the minute (0 .. 60)\n+         tm_min    : int;           -- minutes after the hour (0 .. 59)\n+         tm_hour   : int;           -- hours since midnight (0 .. 24)\n+         tm_mday   : int;           -- day of the month (1 .. 31)\n+         tm_mon    : int;           -- months since January (0 .. 11)\n+         tm_year   : int;           -- years since 1900\n+         tm_wday   : int;           -- days since Sunday (0 .. 6)\n+         tm_yday   : int;           -- days since January 1 (0 .. 365)\n+         tm_isdst  : int;           -- Daylight Savings Time flag (-1 .. 1)\n+         tm_gmtoff : long;          -- offset from UTC in seconds\n+         tm_zone   : char_Pointer;  -- timezone abbreviation\n+      end record;\n+\n+      type tm_Pointer is access all tm;\n+\n+      subtype time_t is long;\n+      type time_t_Pointer is access all time_t;\n+\n+      procedure localtime_tzoff\n+       (C   : time_t_Pointer;\n+        res : tm_Pointer;\n+        off : long_Pointer);\n+      pragma Import (C, localtime_tzoff, \"__gnat_localtime_tzoff\");\n+      --  This is a lightweight wrapper around the system library function\n+      --  localtime_r. Parameter 'off' captures the UTC offset which is either\n+      --  retrieved from the tm struct or calculated from the 'timezone' extern\n+      --  and the tm_isdst flag in the tm struct.\n+\n+      ---------------------\n+      -- UTC_Time_Offset --\n+      ---------------------\n+\n+      function UTC_Time_Offset (Date : Time) return Long_Integer is\n+\n+         Adj_Cent   : Integer := 0;\n+         Adj_Date_N : Time;\n+         Adj_Date_S : Time;\n+         Offset     : aliased long;\n+         Secs_T     : aliased time_t;\n+         Secs_TM    : aliased tm;\n+\n+      begin\n+         Adj_Date_N := Date;\n+\n+         --  Dates which are 56 years appart fall on the same day, day light\n+         --  saving and so on. Non-leap centenial years violate this rule by\n+         --  one day and as a consequence, special adjustment is needed.\n+\n+         if Adj_Date_N > T_2100_2_28 then\n+            if Adj_Date_N > T_2200_2_28 then\n+               if Adj_Date_N > T_2300_2_28 then\n+                  Adj_Cent := 3;\n+               else\n+                  Adj_Cent := 2;\n+               end if;\n+\n+            else\n+               Adj_Cent := 1;\n+            end if;\n+         end if;\n+\n+         if Adj_Cent > 0 then\n+            Adj_Date_N := Adj_Date_N - Time (Adj_Cent) * Nanos_In_Day;\n+         end if;\n+\n+         --  Convert to seconds and shift date within bounds of Unix time\n+\n+         Adj_Date_S := Adj_Date_N / Nano;\n+         while Adj_Date_S < Unix_Min loop\n+            Adj_Date_S := Adj_Date_S + Secs_In_56_Years;\n+         end loop;\n+\n+         while Adj_Date_S >= Unix_Max loop\n+            Adj_Date_S := Adj_Date_S - Secs_In_56_Years;\n          end loop;\n-      end;\n-   end Leap_Sec_Ops;\n+\n+         --  Perform a shift in origins from Ada to Unix\n+\n+         Adj_Date_S := Adj_Date_S - Unix_Min;\n+\n+         Secs_T := time_t (Adj_Date_S);\n+\n+         localtime_tzoff\n+           (Secs_T'Unchecked_Access,\n+            Secs_TM'Unchecked_Access,\n+            Offset'Unchecked_Access);\n+\n+         return Offset;\n+      end UTC_Time_Offset;\n+   end Time_Zones_Operations;\n+\n+--  Start of elaboration code for Ada.Calendar\n \n begin\n    System.OS_Primitives.Initialize;\n+\n+   --  Population of the leap seconds table\n+\n+   declare\n+      type Leap_Second_Date is record\n+         Year  : Year_Number;\n+         Month : Month_Number;\n+         Day   : Day_Number;\n+      end record;\n+\n+      Leap_Second_Dates :\n+        constant array (1 .. Leap_Seconds_Count) of Leap_Second_Date :=\n+          ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n+           (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n+           (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n+           (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n+           (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n+           (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n+\n+      Days_In_Four_Years : constant := 365 * 3 + 366;\n+\n+      Days  : Natural;\n+      Leap  : Leap_Second_Date;\n+      Years : Natural;\n+\n+   begin\n+      for Index in 1 .. Leap_Seconds_Count loop\n+         Leap := Leap_Second_Dates (Index);\n+\n+         --  Calculate the number of days from the start of Ada time until\n+         --  the current leap second occurence. Non-leap centenial years\n+         --  are not accounted for in these calculations since there are\n+         --  no leap seconds after 2100 yet.\n+\n+         Years := Leap.Year - Ada_Min_Year;\n+         Days  := (Years / 4) * Days_In_Four_Years;\n+         Years := Years mod 4;\n+\n+         if Years = 1 then\n+            Days := Days + 365;\n+\n+         elsif Years = 2 then\n+            Days := Days + 365 * 2;\n+\n+         elsif Years = 3 then\n+            Days := Days + 365 * 3;\n+         end if;\n+\n+         Days := Days + Cumulative_Days_Before_Month (Leap.Month);\n+\n+         if Is_Leap (Leap.Year)\n+           and then Leap.Month > 2\n+         then\n+            Days := Days + 1;\n+         end if;\n+\n+         Days := Days + Leap.Day;\n+\n+         --  Index - 1 previous leap seconds are added to Time (Index) as\n+         --  well as the lower buffer for time zones.\n+\n+         Leap_Second_Times (Index) := Ada_Low +\n+           (Time (Days) * Secs_In_Day + Time (Index - 1)) * Nano;\n+      end loop;\n+   end;\n+\n end Ada.Calendar;"}, {"sha": "7bac8b762f0ef16a27fad8f47c8ddbb81f76cde2", "filename": "gcc/ada/a-calend.ads", "status": "modified", "additions": 191, "deletions": 79, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -43,13 +43,17 @@ package Ada.Calendar is\n    --  these do NOT constrain the possible stored values of time which may well\n    --  permit a larger range of times (this is explicitly allowed in Ada 95).\n \n-   subtype Year_Number  is Integer range 1901 .. 2099;\n+   subtype Year_Number  is Integer range 1901 .. 2399;\n    subtype Month_Number is Integer range 1 .. 12;\n    subtype Day_Number   is Integer range 1 .. 31;\n \n+   --  A Day_Duration value of 86_400.0 designates a new day\n+\n    subtype Day_Duration is Duration range 0.0 .. 86_400.0;\n \n    function Clock return Time;\n+   --  The returned time value is the number of nanoseconds since the start\n+   --  of Ada time (1901-1-1 0.0 GMT).\n \n    function Year    (Date : Time) return Year_Number;\n    function Month   (Date : Time) return Month_Number;\n@@ -62,6 +66,10 @@ package Ada.Calendar is\n       Month   : out Month_Number;\n       Day     : out Day_Number;\n       Seconds : out Day_Duration);\n+   --  Break down a time value into its date components set in the current\n+   --  time zone. If Split is called on a time value created using Ada 2005\n+   --  Time_Of in some arbitrary time zone, the input value always will be\n+   --  interpreted as some point in time relative to the local time zone.\n \n    function Time_Of\n      (Year    : Year_Number;\n@@ -87,6 +95,10 @@ package Ada.Calendar is\n    function \"+\" (Left : Duration; Right : Time)     return Time;\n    function \"-\" (Left : Time;     Right : Duration) return Time;\n    function \"-\" (Left : Time;     Right : Time)     return Duration;\n+   --  The first three functions will raise Time_Error if the resulting time\n+   --  value is less than the start of Ada time in GMT or greater than the\n+   --  end of Ada time in GMT. The last function will raise Time_Error if the\n+   --  resulting difference cannot fit into a duration value.\n \n    function \"<\"  (Left, Right : Time) return Boolean;\n    function \"<=\" (Left, Right : Time) return Boolean;\n@@ -110,83 +122,183 @@ private\n    pragma Inline (\">\");\n    pragma Inline (\">=\");\n \n-   --  Time is represented as a signed duration from the base point which is\n-   --  what Unix calls the EPOCH (i.e. 12 midnight (24:00:00), Dec 31st, 1969,\n-   --  or if you prefer 0:00:00 on Jan 1st, 1970). Since Ada allows dates\n-   --  before this EPOCH value, the stored duration value may be negative.\n-\n-   --  The time value stored is typically a GMT value, as provided in standard\n-   --  Unix environments. If this is the case then Split and Time_Of perform\n-   --  required conversions to and from local times. The range of times that\n-   --  can be stored in Time values depends on the declaration of the type\n-   --  Duration, which must at least cover the required Ada range represented\n-   --  by the declaration of Year_Number, but may be larger (we take full\n-   --  advantage of the new permission in Ada 95 to store time values outside\n-   --  the range that would be acceptable to Split). The Duration type is a\n-   --  real value representing a time interval in seconds.\n-\n-   type Time is new Duration;\n-\n-   --  The following package provides handling of leap seconds. It is\n-   --  used by Ada.Calendar.Arithmetic and Ada.Calendar.Formatting, both\n-   --  Ada 2005 children of Ada.Calendar.\n-\n-   package Leap_Sec_Ops is\n-\n-      After_Last_Leap : constant Time := Time'Last;\n-      --  Bigger by far than any leap second value. Not within range of\n-      --  Ada.Calendar specified dates.\n-\n-      procedure Cumulative_Leap_Secs\n-        (Start_Date    : Time;\n-         End_Date      : Time;\n-         Leaps_Between : out Duration;\n-         Next_Leap_Sec : out Time);\n-      --  Leaps_Between is the sum of the leap seconds that have occured\n-      --  on or after Start_Date and before (strictly before) End_Date.\n-      --  Next_Leap_Sec represents the next leap second occurence on or\n-      --  after End_Date. If there are no leaps seconds after End_Date,\n-      --  After_Last_Leap is returned. This does not provide info about\n-      --  the next leap second (pos/neg or ?). After_Last_Leap can be used\n-      --  as End_Date to count all the leap seconds that have occured on\n-      --  or after Start_Date.\n-      --\n-      --  Important Notes: any fractional parts of Start_Date and End_Date\n-      --  are discarded before the calculations are done. For instance: if\n-      --  113 seconds is a leap second (it isn't) and 113.5 is input as an\n-      --  End_Date, the leap second at 113 will not be counted in\n-      --  Leaps_Between, but it will be returned as Next_Leap_Sec. Thus, if\n-      --  the caller wants to know if the End_Date is a leap second, the\n-      --  comparison should be:\n-      --\n-      --     End_Date >= Next_Leap_Sec;\n-      --\n-      --  After_Last_Leap is designed so that this comparison works without\n-      --  having to first check if Next_Leap_Sec is a valid leap second.\n-\n-      function All_Leap_Seconds return Duration;\n-      --  Returns the sum off all of the leap seoncds.\n-\n-   end Leap_Sec_Ops;\n-\n-   procedure Split_With_Offset\n-     (Date    : Time;\n-      Year    : out Year_Number;\n-      Month   : out Month_Number;\n-      Day     : out Day_Number;\n-      Seconds : out Day_Duration;\n-      Offset  : out Long_Integer);\n-   --  Split_W_Offset has the same spec as Split with the addition of an\n-   --  offset value which give the offset of the local time zone from UTC\n-   --  at the input Date. This value comes for free during the implementation\n-   --  of Split and is needed by UTC_Time_Offset. The returned Offset time\n-   --  is straight from the C tm struct and is in seconds. If the system\n-   --  dependent code has no way to find the offset it will return the value\n-   --  Invalid_TZ_Offset declared below. Otherwise no checking is done, so\n-   --  it is up to the user to check both for Invalid_TZ_Offset and otherwise\n-   --  for a value that is acceptable.\n-\n-   Invalid_TZ_Offset : Long_Integer;\n-   pragma Import (C, Invalid_TZ_Offset, \"__gnat_invalid_tzoff\");\n+   --  The units used in this version of Ada.Calendar are nanoseconds. The\n+   --  following constants provide values used in conversions of seconds or\n+   --  days to the underlying units.\n+\n+   Nano         : constant := 1_000_000_000;\n+   Nano_F       : constant := 1_000_000_000.0;\n+   Nanos_In_Day : constant := 86_400_000_000_000;\n+   Secs_In_Day  : constant := 86_400;\n+\n+   ----------------------------\n+   -- Implementation of Time --\n+   ----------------------------\n+\n+   --  Time is represented as an unsigned 64 bit integer count of nanoseconds\n+   --  since the start of Ada time (1901-1-1 0.0 GMT). Time values produced\n+   --  by Time_Of are internaly normalized to GMT regardless of their local\n+   --  time zone. This representation ensures correct handling of leap seconds\n+   --  as well as performing arithmetic. In Ada 95, Split will treat a time\n+   --  value as being in the local time zone and break it down accordingly.\n+   --  In Ada 2005, Split will treat a time value as being in the designated\n+   --  time zone by the corresponding formal parameter or in GMT by default.\n+   --  The size of the type is large enough to cover the Ada 2005 range of\n+   --  time (1901-1-1 0.0 GMT - 2399-12-31-86_399.999999999 GMT).\n+\n+   ------------------\n+   -- Leap seconds --\n+   ------------------\n+\n+   --  Due to Earth's slowdown, the astronomical time is not as precise as the\n+   --  International Atomic Time. To compensate for this inaccuracy, a single\n+   --  leap second is added after the last day of June or December. The count\n+   --  of seconds during those occurences becomes:\n+\n+   --    ... 58, 59, leap second 60, 1, 2 ...\n+\n+   --  Unlike leap days, leap seconds occur simultaneously around the world.\n+   --  In other words, if a leap second occurs at 23:59:60 GMT, it also occurs\n+   --  on 18:59:60 -5 or 2:59:60 +2 on the next day.\n+   --  Leap seconds do not follow a formula. The International Earth Rotation\n+   --  and Reference System Service decides when to add one. Leap seconds are\n+   --  included in the representation of time in Ada 95 mode. As a result,\n+   --  the following two time values will conceptually differ by two seconds:\n+\n+   --    Time_Of (1972, 7, 1, 0.0) - Time_Of (1972, 6, 30, 86_399.0) = 2 secs\n+\n+   --  When a new leap second is added, the following steps must be carried\n+   --  out:\n+\n+   --     1) Increment Leap_Seconds_Count by one\n+   --     2) Add an entry to the end of table Leap_Second_Dates\n+\n+   --  The algorithms that build the actual leap second values and discover\n+   --  how many leap seconds have occured between two dates do not need any\n+   --  modification.\n+\n+   ------------------------------\n+   -- Non-leap centenial years --\n+   ------------------------------\n+\n+   --  Over the range of Ada time, centenial years 2100, 2200 and 2300 are\n+   --  non-leap. As a consequence, seven non-leap years occur over the period\n+   --  of year - 4 to year + 4. Internaly, routines Split and Time_Of add or\n+   --  subtract a \"fake\" February 29 to facilitate the arithmetic involved.\n+   --  This small \"cheat\" remains hidden and the following calculations do\n+   --  produce the correct difference.\n+\n+   --    Time_Of (2100, 3, 1, 0.0) - Time_Of (2100,  2, 28, 0.0) = 1 day\n+   --    Time_Of (2101, 1, 1, 0.0) - Time_Of (2100, 12, 31, 0.0) = 1 day\n+\n+   type Time_Rep is mod 2 ** 64;\n+   type Time is new Time_Rep;\n+\n+   --  Due to boundary time values and time zones, two days of buffer space\n+   --  are set aside at both end points of Ada time:\n+\n+   --    Abs zero  Hard low     Soft low          Soft high    Hard high\n+   --    +---------+============+#################+============+----------->\n+   --                 Buffer 1     Real Ada time     Buffer 2\n+\n+   --  A time value in a any time zone may not excede the hard bounds of Ada\n+   --  time, while a value in GMT may not go over the soft bounds.\n+\n+   Buffer_D : constant Duration := 2.0 * Secs_In_Day;\n+   Buffer_N : constant Time     := 2   * Nanos_In_Day;\n+\n+   --  Lower and upper bound of Ada time shifted by two days from the absolute\n+   --  zero. Note that the upper bound includes the non-leap centenial years.\n+\n+   Ada_Low  : constant Time := Buffer_N;\n+   Ada_High : constant Time := (121 * 366 + 378 * 365) * Nanos_In_Day +\n+                                  Buffer_N;\n+\n+   --  Both of these hard bounds are 28 hours before and after their regular\n+   --  counterpart. The value of 28 is taken from Ada.Calendar.Time_Zones.\n+\n+   Hard_Ada_Low  : constant Time := Ada_Low  - 100_800 * Nano;\n+   Hard_Ada_High : constant Time := Ada_High + 100_800 * Nano;\n+\n+   Days_In_Month : constant array (Month_Number) of Day_Number :=\n+                     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n+\n+   Invalid_Time_Zone_Offset : Long_Integer;\n+   pragma Import (C, Invalid_Time_Zone_Offset, \"__gnat_invalid_tzoff\");\n+\n+   function Is_Leap (Year : Year_Number) return Boolean;\n+   --  Determine whether a given year is leap\n+\n+   --  The following packages provide a target independent interface to the\n+   --  children of Calendar - Arithmetic, Delays, Formatting and Time_Zones.\n+\n+   package Arithmetic_Operations is\n+      function Add (Date : Time; Days : Long_Integer) return Time;\n+      --  Add X number of days to a time value\n+\n+      procedure Difference\n+        (Left         : Time;\n+         Right        : Time;\n+         Days         : out Long_Integer;\n+         Seconds      : out Duration;\n+         Leap_Seconds : out Integer);\n+      --  Calculate the difference between two time values in terms of days,\n+      --  seconds and leap seconds elapsed. The leap seconds are not included\n+      --  in the seconds returned. If Left is greater than Right, the returned\n+      --  values are positive, negative otherwise.\n+\n+      function Subtract (Date : Time; Days : Long_Integer) return Time;\n+      --  Subtract X number of days from a time value\n+   end Arithmetic_Operations;\n+\n+   package Delays_Operations is\n+      function To_Duration (Ada_Time : Time) return Duration;\n+      --  Given a time value in nanoseconds since 1901, convert it into a\n+      --  duration value giving the number of nanoseconds since the Unix Epoch.\n+   end Delays_Operations;\n+\n+   package Formatting_Operations is\n+      function Day_Of_Week (Date : Time) return Integer;\n+      --  Determine which day of week Date falls on. The returned values are\n+      --  within the range of 0 .. 6 (Monday .. Sunday).\n+\n+      procedure Split\n+        (Date       : Time;\n+         Year       : out Year_Number;\n+         Month      : out Month_Number;\n+         Day        : out Day_Number;\n+         Day_Secs   : out Day_Duration;\n+         Hour       : out Integer;\n+         Minute     : out Integer;\n+         Second     : out Integer;\n+         Sub_Sec    : out Duration;\n+         Leap_Sec   : out Boolean;\n+         Time_Zone  : Long_Integer);\n+      --  Split a time value into its components\n+\n+      function Time_Of\n+        (Year         : Year_Number;\n+         Month        : Month_Number;\n+         Day          : Day_Number;\n+         Day_Secs     : Day_Duration;\n+         Hour         : Integer;\n+         Minute       : Integer;\n+         Second       : Integer;\n+         Sub_Sec      : Duration;\n+         Leap_Sec     : Boolean;\n+         Leap_Checks  : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Time_Zone    : Long_Integer) return Time;\n+      --  Given all the components of a date, return the corresponding time\n+      --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n+      --  day duration will be calculated from Hour, Minute, Second and Sub_\n+      --  Sec. Set flag Leap_Checks to verify the validity of a leap second.\n+\n+   end Formatting_Operations;\n+\n+   package Time_Zones_Operations is\n+      function UTC_Time_Offset (Date : Time) return Long_Integer;\n+      --  Return the offset in seconds from GMT\n+   end Time_Zones_Operations;\n \n end Ada.Calendar;"}, {"sha": "c870362d400a3b981c6ee10ac46aeee2710b1074", "filename": "gcc/ada/a-calfor.adb", "status": "modified", "additions": 188, "deletions": 460, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calfor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calfor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.adb?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -33,33 +33,15 @@\n \n with Ada.Calendar;            use Ada.Calendar;\n with Ada.Calendar.Time_Zones; use Ada.Calendar.Time_Zones;\n-with Unchecked_Conversion;\n \n package body Ada.Calendar.Formatting is\n \n-   use Leap_Sec_Ops;\n+   --------------------------\n+   -- Implementation Notes --\n+   --------------------------\n \n-   Days_In_4_Years          : constant := 365 * 3 + 366;\n-   Seconds_In_Day           : constant := 86_400;\n-   Seconds_In_4_Years       : constant := Days_In_4_Years * Seconds_In_Day;\n-   Seconds_In_Non_Leap_Year : constant := 365 * Seconds_In_Day;\n-\n-   --  Exact time bounds for the range of Ada time: January 1, 1901 -\n-   --  December 31, 2099. These bounds are based on the Unix Time of Epoc,\n-   --  January 1, 1970. Start of Time is -69 years from TOE while End of\n-   --  time is +130 years and one second from TOE.\n-\n-   Start_Of_Time : constant Time :=\n-                     Time (-(17 * Seconds_In_4_Years +\n-                                  Seconds_In_Non_Leap_Year));\n-\n-   End_Of_Time   : constant Time :=\n-                     Time (32 * Seconds_In_4_Years +\n-                            2 * Seconds_In_Non_Leap_Year) +\n-                                All_Leap_Seconds;\n-\n-   Days_In_Month : constant array (Month_Number) of Day_Number :=\n-     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n+   --  All operations in this package are target and time representation\n+   --  independent, thus only one source file is needed for multiple targets.\n \n    procedure Check_Char (S : String; C : Character; Index : Integer);\n    --  Subsidiary to the two versions of Value. Determine whether the\n@@ -102,71 +84,27 @@ package body Ada.Calendar.Formatting is\n      (Date      : Time;\n       Time_Zone : Time_Zones.Time_Offset := 0) return Day_Number\n    is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n+      Y  : Year_Number;\n+      Mo : Month_Number;\n+      D  : Day_Number;\n+      H  : Hour_Number;\n+      Mi : Minute_Number;\n+      Se : Second_Number;\n+      Ss : Second_Duration;\n+      Le : Boolean;\n \n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n-      return Day;\n+      Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n+      return D;\n    end Day;\n \n    -----------------\n    -- Day_Of_Week --\n    -----------------\n \n    function Day_Of_Week (Date : Time) return Day_Name is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n-\n-      D           : Duration;\n-      Day_Count   : Long_Long_Integer;\n-      Midday_Date : Time;\n-      Secs_Count  : Long_Long_Integer;\n-\n    begin\n-      --  Split the Date to obtain the year, month and day, then build a time\n-      --  value for the middle of the same day, so that we don't have to worry\n-      --  about leap seconds in the subsequent arithmetic.\n-\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second);\n-\n-      Midday_Date := Time_Of (Year, Month, Day, 12, 0, 0);\n-      D           := Midday_Date - Start_Of_Time;\n-\n-      --  D is a positive Duration value counting seconds since 1901. Convert\n-      --  it into an integer for ease of arithmetic.\n-\n-      declare\n-         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n-         for D_Int'Size use Duration'Size;\n-\n-         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n-\n-         D_As_Int  : constant D_Int := To_D_Int (D);\n-         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n-\n-      begin\n-         Secs_Count := Long_Long_Integer (D_As_Int / Small_Div);\n-      end;\n-\n-      Day_Count := Secs_Count / Seconds_In_Day;\n-      Day_Count := Day_Count + 1;  --  Jan 1, 1901 was a Tuesday;\n-\n-      return Day_Name'Val (Day_Count mod 7);\n+      return Day_Name'Val (Formatting_Operations.Day_Of_Week (Date));\n    end Day_Of_Week;\n \n    ----------\n@@ -177,19 +115,18 @@ package body Ada.Calendar.Formatting is\n      (Date      : Time;\n       Time_Zone : Time_Zones.Time_Offset := 0) return Hour_Number\n    is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n+      Y  : Year_Number;\n+      Mo : Month_Number;\n+      D  : Day_Number;\n+      H  : Hour_Number;\n+      Mi : Minute_Number;\n+      Se : Second_Number;\n+      Ss : Second_Duration;\n+      Le : Boolean;\n \n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n-      return Hour;\n+      Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n+      return H;\n    end Hour;\n \n    -----------\n@@ -377,19 +314,17 @@ package body Ada.Calendar.Formatting is\n      (Date      : Time;\n       Time_Zone : Time_Zones.Time_Offset := 0) return Minute_Number\n    is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n-\n+      Y  : Year_Number;\n+      Mo : Month_Number;\n+      D  : Day_Number;\n+      H  : Hour_Number;\n+      Mi : Minute_Number;\n+      Se : Second_Number;\n+      Ss : Second_Duration;\n+      Le : Boolean;\n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n-      return Minute;\n+      Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n+      return Mi;\n    end Minute;\n \n    -----------\n@@ -400,39 +335,35 @@ package body Ada.Calendar.Formatting is\n      (Date      : Time;\n       Time_Zone : Time_Zones.Time_Offset := 0) return Month_Number\n    is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n-\n+      Y  : Year_Number;\n+      Mo : Month_Number;\n+      D  : Day_Number;\n+      H  : Hour_Number;\n+      Mi : Minute_Number;\n+      Se : Second_Number;\n+      Ss : Second_Duration;\n+      Le : Boolean;\n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n-      return Month;\n+      Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n+      return Mo;\n    end Month;\n \n    ------------\n    -- Second --\n    ------------\n \n    function Second (Date : Time) return Second_Number is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n-\n+      Y  : Year_Number;\n+      Mo : Month_Number;\n+      D  : Day_Number;\n+      H  : Hour_Number;\n+      Mi : Minute_Number;\n+      Se : Second_Number;\n+      Ss : Second_Duration;\n+      Le : Boolean;\n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second);\n-      return Second;\n+      Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le);\n+      return Se;\n    end Second;\n \n    ----------------\n@@ -456,9 +387,9 @@ package body Ada.Calendar.Formatting is\n          raise Constraint_Error;\n       end if;\n \n-      return Day_Duration (Hour   * 3600) +\n-             Day_Duration (Minute *   60) +\n-             Day_Duration (Second)        +\n+      return Day_Duration (Hour   * 3_600) +\n+             Day_Duration (Minute *    60) +\n+             Day_Duration (Second)         +\n                            Sub_Second;\n    end Seconds_Of;\n \n@@ -489,10 +420,20 @@ package body Ada.Calendar.Formatting is\n       end if;\n \n       Sub_Second := Second_Duration (Seconds - Day_Duration (Secs));\n-      Hour       := Hour_Number (Secs / 3600);\n-      Secs       := Secs mod 3600;\n+      Hour       := Hour_Number (Secs / 3_600);\n+      Secs       := Secs mod 3_600;\n       Minute     := Minute_Number (Secs / 60);\n       Second     := Second_Number (Secs mod 60);\n+\n+      --  Validity checks\n+\n+      if not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Sub_Second'Valid\n+      then\n+         raise Time_Error;\n+      end if;\n    end Split;\n \n    -----------\n@@ -508,16 +449,25 @@ package body Ada.Calendar.Formatting is\n       Leap_Second : out Boolean;\n       Time_Zone   : Time_Zones.Time_Offset := 0)\n    is\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n+      H  : Integer;\n+      M  : Integer;\n+      Se : Integer;\n+      Su : Duration;\n+      Tz : constant Long_Integer := Long_Integer (Time_Zone);\n \n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+      Formatting_Operations.Split\n+        (Date, Year, Month, Day, Seconds, H, M, Se, Su, Leap_Second, Tz);\n+\n+      --  Validity checks\n \n-      Seconds := Seconds_Of (Hour, Minute, Second, Sub_Second);\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Seconds'Valid\n+      then\n+         raise Time_Error;\n+      end if;\n    end Split;\n \n    -----------\n@@ -535,11 +485,27 @@ package body Ada.Calendar.Formatting is\n       Sub_Second : out Second_Duration;\n       Time_Zone  : Time_Zones.Time_Offset := 0)\n    is\n-      Leap_Second : Boolean;\n+      Dd : Day_Duration;\n+      Le : Boolean;\n+      Tz : constant Long_Integer := Long_Integer (Time_Zone);\n \n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+      Formatting_Operations.Split\n+        (Date, Year, Month, Day, Dd,\n+         Hour, Minute, Second, Sub_Second, Le, Tz);\n+\n+      --  Validity checks\n+\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Sub_Second'Valid\n+      then\n+         raise Time_Error;\n+      end if;\n    end Split;\n \n    -----------\n@@ -558,160 +524,44 @@ package body Ada.Calendar.Formatting is\n       Leap_Second : out Boolean;\n       Time_Zone   : Time_Zones.Time_Offset := 0)\n    is\n-      Ada_Year_Min    : constant Year_Number := Year_Number'First;\n-      Day_In_Year     : Integer;\n-      Day_Second      : Integer;\n-      Elapsed_Leaps   : Duration;\n-      Hour_Second     : Integer;\n-      In_Leap_Year    : Boolean;\n-      Modified_Date   : Time;\n-      Next_Leap       : Time;\n-      Remaining_Years : Integer;\n-      Seconds_Count   : Long_Long_Integer;\n+      Dd : Day_Duration;\n+      Tz : constant Long_Integer := Long_Integer (Time_Zone);\n \n    begin\n-      --  Our measurement of time is the number of seconds that have elapsed\n-      --  since the Unix TOE. To calculate a UTC date from this we do a\n-      --  sequence of divides and mods to get the components of a date based\n-      --  on 86,400 seconds in each day. Since, UTC time depends upon the\n-      --  occasional insertion of leap seconds, the number of leap seconds\n-      --  that have been added prior to the input time are then subtracted\n-      --  from the previous calculation. In fact, it is easier to do the\n-      --  subtraction first, so a more accurate discription of what is\n-      --  actually done, is that the number of added leap seconds is looked\n-      --  up using the input Time value, than that number of seconds is\n-      --  subtracted before the sequence of divides and mods.\n-      --\n-      --  If the input date turns out to be a leap second, we don't add it to\n-      --  date (we want to return 23:59:59) but we set the Leap_Second output\n-      --  to true.\n-\n-      --  Is there a need to account for a difference from Unix time prior\n-      --  to the first leap second ???\n-\n-      --  Step 1: Determine the number of leap seconds since the start\n-      --  of Ada time and the input date as well as the next leap second\n-      --  occurence and process accordingly.\n-\n-      Cumulative_Leap_Secs (Start_Of_Time, Date, Elapsed_Leaps, Next_Leap);\n-\n-      Leap_Second   := Date >= Next_Leap;\n-      Modified_Date := Date - Elapsed_Leaps;\n-\n-      if Leap_Second then\n-         Modified_Date := Modified_Date - Duration (1.0);\n-      end if;\n+      Formatting_Operations.Split\n+       (Date, Year, Month, Day, Dd,\n+        Hour, Minute, Second, Sub_Second, Leap_Second, Tz);\n \n-      --  Step 2: Process the time zone\n-\n-      Modified_Date := Modified_Date + Duration (Time_Zone * 60);\n-\n-      --  Step 3: Sanity check on the calculated date. Since the leap\n-      --  seconds and the time zone have been eliminated, the result needs\n-      --  to be within the range of Ada time.\n+      --  Validity checks\n \n-      if Modified_Date < Start_Of_Time\n-        or else Modified_Date >= (End_Of_Time - All_Leap_Seconds)\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Sub_Second'Valid\n       then\n          raise Time_Error;\n       end if;\n-\n-      Modified_Date := Modified_Date - Start_Of_Time;\n-\n-      declare\n-         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n-         for D_Int'Size use Duration'Size;\n-\n-         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n-         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n-         function To_Duration is new Unchecked_Conversion (Time, Duration);\n-\n-         D_As_Int  : constant D_Int := To_D_Int (To_Duration (Modified_Date));\n-         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n-\n-      begin\n-         Seconds_Count := Long_Long_Integer (D_As_Int / Small_Div);\n-         Sub_Second    := Second_Duration\n-                            (To_Duration (D_As_Int rem Small_Div));\n-      end;\n-\n-      --  Step 4: Calculate the number of years since the start of Ada time.\n-      --  First consider sequences of four years, then the remaining years.\n-\n-      Year := Ada_Year_Min + 4 * Integer (Seconds_Count / Seconds_In_4_Years);\n-      Seconds_Count   := Seconds_Count mod Seconds_In_4_Years;\n-      Remaining_Years := Integer (Seconds_Count / Seconds_In_Non_Leap_Year);\n-\n-      if Remaining_Years > 3 then\n-         Remaining_Years := 3;\n-      end if;\n-\n-      Year := Year + Remaining_Years;\n-\n-      --  Remove the seconds elapsed in those remaining years\n-\n-      Seconds_Count := Seconds_Count - Long_Long_Integer\n-                         (Remaining_Years * Seconds_In_Non_Leap_Year);\n-      In_Leap_Year := (Year mod 4) = 0;\n-\n-      --  Step 5: Month and day processing. Determine the day to which the\n-      --  remaining seconds map to.\n-\n-      Day_In_Year := Integer (Seconds_Count / Seconds_In_Day) + 1;\n-\n-      Month := 1;\n-\n-      if Day_In_Year > 31 then\n-         Month       := 2;\n-         Day_In_Year := Day_In_Year - 31;\n-\n-         if Day_In_Year > 28\n-           and then ((not In_Leap_Year)\n-                        or else Day_In_Year > 29)\n-         then\n-            Month       := 3;\n-            Day_In_Year := Day_In_Year - 28;\n-\n-            if In_Leap_Year then\n-               Day_In_Year := Day_In_Year - 1;\n-            end if;\n-\n-            while Day_In_Year > Days_In_Month (Month) loop\n-               Day_In_Year := Day_In_Year - Days_In_Month (Month);\n-               Month := Month + 1;\n-            end loop;\n-         end if;\n-      end if;\n-\n-      --  Step 6: Hour, minute and second processing\n-\n-      Day         := Day_In_Year;\n-      Day_Second  := Integer (Seconds_Count mod Seconds_In_Day);\n-      Hour        := Day_Second / 3600;\n-      Hour_Second := Day_Second mod 3600;\n-      Minute      := Hour_Second / 60;\n-      Second      := Hour_Second mod 60;\n    end Split;\n \n    ----------------\n    -- Sub_Second --\n    ----------------\n \n    function Sub_Second (Date : Time) return Second_Duration is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n-\n+      Y  : Year_Number;\n+      Mo : Month_Number;\n+      D  : Day_Number;\n+      H  : Hour_Number;\n+      Mi : Minute_Number;\n+      Se : Second_Number;\n+      Ss : Second_Duration;\n+      Le : Boolean;\n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second);\n-\n-      return Sub_Second;\n+      Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le);\n+      return Ss;\n    end Sub_Second;\n \n    -------------\n@@ -726,79 +576,56 @@ package body Ada.Calendar.Formatting is\n       Leap_Second : Boolean := False;\n       Time_Zone   : Time_Zones.Time_Offset := 0) return Time\n    is\n-      Hour       : Hour_Number;\n-      Minute     : Minute_Number;\n-      Sec_Num    : Second_Number;\n-      Sub_Sec    : Second_Duration;\n-      Whole_Part : Integer;\n+      Adj_Year  : Year_Number  := Year;\n+      Adj_Month : Month_Number := Month;\n+      Adj_Day   : Day_Number   := Day;\n+\n+      H  : constant Integer := 1;\n+      M  : constant Integer := 1;\n+      Se : constant Integer := 1;\n+      Ss : constant Duration := 0.1;\n+      Tz : constant Long_Integer := Long_Integer (Time_Zone);\n \n    begin\n-      if not Seconds'Valid then\n+      --  Validity checks\n+\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Seconds'Valid\n+        or else not Time_Zone'Valid\n+      then\n          raise Constraint_Error;\n       end if;\n \n-      --  The fact that Seconds can go to 86,400 creates all this extra work.\n-      --  Perhaps a Time_Of just like the next one but allowing the Second_\n-      --  Number input to reach 60 should become an internal version that this\n-      --  and the next version call.... but for now we do the ugly bumping up\n-      --  of Day, Month and Year;\n+      --  A Seconds value of 86_400 denotes a new day. This case requires an\n+      --  adjustment to the input values.\n \n       if Seconds = 86_400.0 then\n-         declare\n-            Adj_Year  : Year_Number  := Year;\n-            Adj_Month : Month_Number := Month;\n-            Adj_Day   : Day_Number   := Day;\n-\n-         begin\n-            Hour    := 0;\n-            Minute  := 0;\n-            Sec_Num := 0;\n-            Sub_Sec := 0.0;\n-\n-            if Day < Days_In_Month (Month)\n-              or else (Month = 2\n-                         and then Year mod 4 = 0)\n-            then\n-               Adj_Day := Day + 1;\n+         if Day < Days_In_Month (Month)\n+           or else (Is_Leap (Year)\n+                      and then Month = 2)\n+         then\n+            Adj_Day := Day + 1;\n+         else\n+            Adj_Day := 1;\n+\n+            if Month < 12 then\n+               Adj_Month := Month + 1;\n             else\n-               Adj_Day := 1;\n-\n-               if Month < 12 then\n-                  Adj_Month := Month + 1;\n-               else\n-                  Adj_Month := 1;\n-                  Adj_Year  := Year + 1;\n-               end if;\n+               Adj_Month := 1;\n+               Adj_Year  := Year + 1;\n             end if;\n-\n-            return Time_Of (Adj_Year, Adj_Month, Adj_Day, Hour, Minute,\n-                            Sec_Num, Sub_Sec, Leap_Second, Time_Zone);\n-         end;\n+         end if;\n       end if;\n \n-      declare\n-         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n-         for D_Int'Size use Duration'Size;\n-\n-         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n-         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n-\n-         D_As_Int  : constant D_Int := To_D_Int (Seconds);\n-         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n-\n-      begin\n-         Whole_Part := Integer (D_As_Int / Small_Div);\n-         Sub_Sec    := Second_Duration\n-                         (To_Duration (D_As_Int rem Small_Div));\n-      end;\n-\n-      Hour       := Hour_Number (Whole_Part / 3600);\n-      Whole_Part := Whole_Part mod 3600;\n-      Minute     := Minute_Number (Whole_Part / 60);\n-      Sec_Num    := Second_Number (Whole_Part mod 60);\n-\n-      return Time_Of (Year, Month, Day,\n-                      Hour, Minute, Sec_Num, Sub_Sec, Leap_Second, Time_Zone);\n+      return\n+        Formatting_Operations.Time_Of\n+          (Adj_Year, Adj_Month, Adj_Day, Seconds, H, M, Se, Ss,\n+           Leap_Sec     => Leap_Second,\n+           Leap_Checks  => True,\n+           Use_Day_Secs => True,\n+           Time_Zone    => Tz);\n    end Time_Of;\n \n    -------------\n@@ -816,23 +643,11 @@ package body Ada.Calendar.Formatting is\n       Leap_Second : Boolean := False;\n       Time_Zone   : Time_Zones.Time_Offset := 0) return Time\n    is\n-      Cumulative_Days_Before_Month :\n-        constant array (Month_Number) of Natural :=\n-          (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n-\n-      Ada_Year_Min         : constant Year_Number := Year_Number'First;\n-      Count                : Integer;\n-      Elapsed_Leap_Seconds : Duration;\n-      Fractional_Second    : Duration;\n-      Next_Leap            : Time;\n-      Result               : Time;\n+      Dd : constant Day_Duration := Day_Duration'First;\n+      Tz : constant Long_Integer := Long_Integer (Time_Zone);\n \n    begin\n-      --  The following checks are redundant with respect to the constraint\n-      --  error checks that should normally be made on parameters, but we\n-      --  decide to raise Constraint_Error in any case if bad values come in\n-      --  (as a result of checks being off in the caller, or for other\n-      --  erroneous or bounded error cases).\n+      --  Validity checks\n \n       if not Year'Valid\n         or else not Month'Valid\n@@ -846,99 +661,13 @@ package body Ada.Calendar.Formatting is\n          raise Constraint_Error;\n       end if;\n \n-      --  Start the accumulation from the beginning of Ada time\n-\n-      Result := Start_Of_Time;\n-\n-      --  Step 1: Determine the number of leap and non-leap years since 1901\n-      --  and the input date.\n-\n-      --  Count the number of four year segments\n-\n-      Count  := (Year - Ada_Year_Min) / 4;\n-      Result := Result + Duration (Count * Seconds_In_4_Years);\n-\n-      --  Count the number of remaining non-leap years\n-\n-      Count  := (Year - Ada_Year_Min) mod 4;\n-      Result := Result + Duration (Count * Seconds_In_Non_Leap_Year);\n-\n-      --  Step 2: Determine the number of days elapsed singe the start of the\n-      --  input year and add them to the result.\n-\n-      --  Do not include the current day since it is not over yet\n-\n-      Count := Cumulative_Days_Before_Month (Month) + Day - 1;\n-\n-      --  The input year is a leap year and we have passed February\n-\n-      if (Year mod 4) = 0\n-        and then Month > 2\n-      then\n-         Count := Count + 1;\n-      end if;\n-\n-      Result := Result + Duration (Count * Seconds_In_Day);\n-\n-      --  Step 3: Hour, minute and second processing\n-\n-      Result := Result + Duration (Hour   * 3600) +\n-                         Duration (Minute *   60) +\n-                         Duration (Second);\n-\n-      --  The sub second may designate a whole second\n-\n-      if Sub_Second = 1.0 then\n-         Result            := Result + Duration (1.0);\n-         Fractional_Second := 0.0;\n-      else\n-         Fractional_Second := Sub_Second;\n-      end if;\n-\n-      --  Step 4: Time zone processing\n-\n-      Result := Result - Duration (Time_Zone * 60);\n-\n-      --  Step 5: The caller wants a leap second\n-\n-      if Leap_Second then\n-         Result := Result + Duration (1.0);\n-      end if;\n-\n-      --  Step 6: Calculate the number of leap seconds occured since the\n-      --  start of Ada time and the current point in time. The following\n-      --  is an approximation which does not yet count leap seconds. It\n-      --  can be pushed beyond 1 leap second, but not more.\n-\n-      Cumulative_Leap_Secs\n-        (Start_Of_Time, Result, Elapsed_Leap_Seconds, Next_Leap);\n-\n-      Result := Result + Elapsed_Leap_Seconds;\n-\n-      --  Step 7: Validity check of a leap second occurence. It requires an\n-      --  additional comparison to Next_Leap to ensure that we landed right\n-      --  on a valid occurence and that Elapsed_Leap_Seconds did not shoot\n-      --  past it.\n-\n-      if Leap_Second\n-        and then\n-           not (Result >= Next_Leap\n-                  and then Result - Duration (1.0) < Next_Leap)\n-      then\n-         raise Time_Error;\n-      end if;\n-\n-      --  Step 8: Final sanity check on the calculated duration value\n-\n-      if Result < Start_Of_Time\n-        or else Result >= End_Of_Time\n-      then\n-         raise Time_Error;\n-      end if;\n-\n-      --  Step 9: Lastly, add the sub second part\n-\n-      return Result + Fractional_Second;\n+      return\n+        Formatting_Operations.Time_Of\n+          (Year, Month, Day, Dd, Hour, Minute, Second, Sub_Second,\n+           Leap_Sec     => Leap_Second,\n+           Leap_Checks  => True,\n+           Use_Day_Secs => False,\n+           Time_Zone    => Tz);\n    end Time_Of;\n \n    -----------\n@@ -1117,19 +846,18 @@ package body Ada.Calendar.Formatting is\n      (Date      : Time;\n       Time_Zone : Time_Zones.Time_Offset := 0) return Year_Number\n    is\n-      Year        : Year_Number;\n-      Month       : Month_Number;\n-      Day         : Day_Number;\n-      Hour        : Hour_Number;\n-      Minute      : Minute_Number;\n-      Second      : Second_Number;\n-      Sub_Second  : Second_Duration;\n-      Leap_Second : Boolean;\n+      Y  : Year_Number;\n+      Mo : Month_Number;\n+      D  : Day_Number;\n+      H  : Hour_Number;\n+      Mi : Minute_Number;\n+      Se : Second_Number;\n+      Ss : Second_Duration;\n+      Le : Boolean;\n \n    begin\n-      Split (Date, Year, Month, Day,\n-             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n-      return Year;\n+      Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n+      return Y;\n    end Year;\n \n end Ada.Calendar.Formatting;"}, {"sha": "66fcdb1a987edda307c8f80d829843c710c9d4a0", "filename": "gcc/ada/a-calfor.ads", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calfor.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-calfor.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.ads?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---        Copyright (C) 2005 - 2006, Free Software Foundation, Inc.         --\n+--         Copyright (C) 2005-2006, Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,6 +35,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  This package provides additional components to Time, as well as new\n+--  Time_Of and Split routines which handle time zones and leap seconds.\n+--  This package is defined in the Ada 2005 RM (9.6.1).\n+\n with Ada.Calendar.Time_Zones;\n \n package Ada.Calendar.Formatting is\n@@ -84,13 +88,22 @@ package Ada.Calendar.Formatting is\n       Minute     : Minute_Number;\n       Second     : Second_Number := 0;\n       Sub_Second : Second_Duration := 0.0) return Day_Duration;\n+   --  Returns a Day_Duration value for the combination of the given Hour,\n+   --  Minute, Second, and Sub_Second. This value can be used in Ada.Calendar.\n+   --  Time_Of as well as the argument to Calendar.\"+\" and Calendar.\"\u2013\". If\n+   --  Seconds_Of is called with a Sub_Second value of 1.0, the value returned\n+   --  is equal to the value of Seconds_Of for the next second with a Sub_\n+   --  Second value of 0.0.\n \n    procedure Split\n      (Seconds    : Day_Duration;\n       Hour       : out Hour_Number;\n       Minute     : out Minute_Number;\n       Second     : out Second_Number;\n       Sub_Second : out Second_Duration);\n+   --  Splits Seconds into Hour, Minute, Second and Sub_Second in such a way\n+   --  that the resulting values all belong to their respective subtypes. The\n+   --  value returned in the Sub_Second parameter is always less than 1.0.\n \n    procedure Split\n      (Date       : Time;\n@@ -102,6 +115,9 @@ package Ada.Calendar.Formatting is\n       Second     : out Second_Number;\n       Sub_Second : out Second_Duration;\n       Time_Zone  : Time_Zones.Time_Offset := 0);\n+   --  Splits Date into its constituent parts (Year, Month, Day, Hour, Minute,\n+   --  Second, Sub_Second), relative to the specified time zone offset. The\n+   --  value returned in the Sub_Second parameter is always less than 1.0.\n \n    function Time_Of\n      (Year        : Year_Number;\n@@ -113,6 +129,14 @@ package Ada.Calendar.Formatting is\n       Sub_Second  : Second_Duration := 0.0;\n       Leap_Second : Boolean := False;\n       Time_Zone   : Time_Zones.Time_Offset := 0) return Time;\n+   --  If Leap_Second is False, returns a Time built from the date and time\n+   --  values, relative to the specified time zone offset. If Leap_Second is\n+   --  True, returns the Time that represents the time within the leap second\n+   --  that is one second later than the time specified by the parameters.\n+   --  Time_Error is raised if the parameters do not form a proper date or\n+   --  time. If Time_Of is called with a Sub_Second value of 1.0, the value\n+   --  returned is equal to the value of Time_Of for the next second with a\n+   --  Sub_Second value of 0.0.\n \n    function Time_Of\n      (Year        : Year_Number;\n@@ -121,6 +145,14 @@ package Ada.Calendar.Formatting is\n       Seconds     : Day_Duration := 0.0;\n       Leap_Second : Boolean := False;\n       Time_Zone   : Time_Zones.Time_Offset := 0) return Time;\n+   --  If Leap_Second is False, returns a Time built from the date and time\n+   --  values, relative to the specified time zone offset. If Leap_Second is\n+   --  True, returns the Time that represents the time within the leap second\n+   --  that is one second later than the time specified by the parameters.\n+   --  Time_Error is raised if the parameters do not form a proper date or\n+   --  time. If Time_Of is called with a Seconds value of 86_400.0, the value\n+   --  returned is equal to the value of Time_Of for the next day with a\n+   --  Seconds value of 0.0.\n \n    procedure Split\n      (Date        : Time;\n@@ -133,6 +165,14 @@ package Ada.Calendar.Formatting is\n       Sub_Second  : out Second_Duration;\n       Leap_Second : out Boolean;\n       Time_Zone   : Time_Zones.Time_Offset := 0);\n+   --  If Date does not represent a time within a leap second, splits Date\n+   --  into its constituent parts (Year, Month, Day, Hour, Minute, Second,\n+   --  Sub_Second), relative to the specified time zone offset, and sets\n+   --  Leap_Second to False. If Date represents a time within a leap second,\n+   --  set the constituent parts to values corresponding to a time one second\n+   --  earlier than that given by Date, relative to the specified time zone\n+   --  offset, and sets Leap_Seconds to True. The value returned in the\n+   --  Sub_Second parameter is always less than 1.0.\n \n    procedure Split\n      (Date        : Time;\n@@ -142,22 +182,54 @@ package Ada.Calendar.Formatting is\n       Seconds     : out Day_Duration;\n       Leap_Second : out Boolean;\n       Time_Zone   : Time_Zones.Time_Offset := 0);\n+   --  If Date does not represent a time within a leap second, splits Date\n+   --  into its constituent parts (Year, Month, Day, Seconds), relative to the\n+   --  specified time zone offset, and sets Leap_Second to False. If Date\n+   --  represents a time within a leap second, set the constituent parts to\n+   --  values corresponding to a time one second earlier than that given by\n+   --  Date, relative to the specified time zone offset, and sets Leap_Seconds\n+   --  to True. The value returned in the Seconds parameter is always less\n+   --  than 86_400.0.\n \n    --  Simple image and value\n \n    function Image\n      (Date                  : Time;\n       Include_Time_Fraction : Boolean := False;\n       Time_Zone             : Time_Zones.Time_Offset := 0) return String;\n+   --  Returns a string form of the Date relative to the given Time_Zone. The\n+   --  format is \"Year-Month-Day Hour:Minute:Second\", where the Year is a\n+   --  4-digit value, and all others are 2-digit values, of the functions\n+   --  defined in Ada.Calendar and Ada.Calendar.Formatting, including a\n+   --  leading zero, if needed. The separators between the values are a minus,\n+   --  another minus, a colon, and a single space between the Day and Hour. If\n+   --  Include_Time_Fraction is True, the integer part of Sub_Seconds*100 is\n+   --  suffixed to the string as a point followed by a 2-digit value.\n \n    function Value\n      (Date       : String;\n       Time_Zone  : Time_Zones.Time_Offset := 0) return Time;\n+   --  Returns a Time value for the image given as Date, relative to the given\n+   --  time zone. Constraint_Error is raised if the string is not formatted as\n+   --  described for Image, or the function cannot interpret the given string\n+   --  as a Time value.\n \n    function Image\n      (Elapsed_Time          : Duration;\n       Include_Time_Fraction : Boolean := False) return String;\n+   --  Returns a string form of the Elapsed_Time. The format is \"Hour:Minute:\n+   --  Second\", where all values are 2-digit values, including a leading zero,\n+   --  if needed. The separators between the values are colons. If Include_\n+   --  Time_Fraction is True, the integer part of Sub_Seconds*100 is suffixed\n+   --  to the string as a point followed by a 2-digit value. If Elapsed_Time <\n+   --  0.0, the result is Image (abs Elapsed_Time, Include_Time_Fraction)\n+   --  prefixed with a minus sign. If abs Elapsed_Time represents 100 hours or\n+   --  more, the result is implementation-defined.\n \n    function Value (Elapsed_Time : String) return Duration;\n+   --  Returns a Duration value for the image given as Elapsed_Time.\n+   --  Constraint_Error is raised if the string is not formatted as described\n+   --  for Image, or the function cannot interpret the given string as a\n+   --  Duration value.\n \n end Ada.Calendar.Formatting;"}, {"sha": "f6277397d73bd2c5ffa939a8fd90c35d76ce2ae4", "filename": "gcc/ada/a-catizo.adb", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-catizo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-catizo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-catizo.adb?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -33,35 +33,39 @@\n \n package body Ada.Calendar.Time_Zones is\n \n+   --------------------------\n+   -- Implementation Notes --\n+   --------------------------\n+\n+   --  All operations in this package are target and time representation\n+   --  independent, thus only one source file is needed for multiple targets.\n+\n    ---------------------\n    -- UTC_Time_Offset --\n    ---------------------\n \n    function UTC_Time_Offset (Date : Time := Clock) return Time_Offset is\n-      Year    : Year_Number;\n-      Month   : Month_Number;\n-      Day     : Day_Number;\n-      Seconds : Day_Duration;\n-      Offset  : Long_Integer;\n+      Offset_L : constant Long_Integer :=\n+                   Time_Zones_Operations.UTC_Time_Offset (Date);\n+      Offset   : Time_Offset;\n \n    begin\n-      Split_With_Offset (Date, Year, Month, Day, Seconds, Offset);\n-\n-      --  The system dependent code does not support time zones\n-\n-      if Offset = Invalid_TZ_Offset then\n+      if Offset_L = Invalid_Time_Zone_Offset then\n          raise Unknown_Zone_Error;\n       end if;\n \n-      Offset := Offset / 60;\n+      --  The offset returned by Time_Zones_Operations.UTC_Time_Offset is in\n+      --  seconds, the returned value needs to be in minutes.\n+\n+      Offset := Time_Offset (Offset_L / 60);\n+\n+      --  Validity checks\n \n-      if Offset < Long_Integer (Time_Offset'First)\n-        or else Offset > Long_Integer (Time_Offset'Last)\n-      then\n+      if not Offset'Valid then\n          raise Unknown_Zone_Error;\n       end if;\n \n-      return Time_Offset (Offset);\n+      return Offset;\n    end UTC_Time_Offset;\n \n end Ada.Calendar.Time_Zones;"}, {"sha": "decdf52b1177dec09032644cf1fba489cf4627a4", "filename": "gcc/ada/a-catizo.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-catizo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-catizo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-catizo.ads?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---        Copyright (C) 2005 - 2006, Free Software Foundation, Inc.         --\n+--         Copyright (C) 2005-2006, Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,6 +35,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  This package provides routines to determine the offset of dates to GMT.\n+--  It is defined in the Ada 2005 RM (9.6.1).\n+\n package Ada.Calendar.Time_Zones is\n \n    --  Time zone manipulation\n@@ -44,5 +47,9 @@ package Ada.Calendar.Time_Zones is\n    Unknown_Zone_Error : exception;\n \n    function UTC_Time_Offset (Date : Time := Clock) return Time_Offset;\n+   --  Returns, as a number of minutes, the difference between the\n+   --  implementation-defined time zone of Calendar, and UTC time, at the time\n+   --  Date. If the time zone of the Calendar implementation is unknown, then\n+   --  Unknown_Zone_Error is raised.\n \n end Ada.Calendar.Time_Zones;"}, {"sha": "fcb122a037b6dc3c33ff1ac1336a782a436664bb", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -31,10 +31,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Calendar;               use Ada.Calendar;\n+with Ada.Calendar.Formatting;    use Ada.Calendar.Formatting;\n with Ada.Directories.Validity;   use Ada.Directories.Validity;\n with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;\n with Ada.Unchecked_Deallocation;\n-with Ada.Unchecked_Conversion;\n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n \n with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n@@ -46,13 +47,6 @@ with System;\n \n package body Ada.Directories is\n \n-   function Duration_To_Time is new\n-     Ada.Unchecked_Conversion (Duration, Ada.Calendar.Time);\n-   function OS_Time_To_Long_Integer is new\n-     Ada.Unchecked_Conversion (OS_Time, Long_Integer);\n-   --  These two unchecked conversions are used in function Modification_Time\n-   --  to convert an OS_Time to a Calendar.Time.\n-\n    type Search_Data is record\n       Is_Valid      : Boolean := False;\n       Name          : Ada.Strings.Unbounded.Unbounded_String;\n@@ -724,16 +718,15 @@ package body Ada.Directories is\n    -- Modification_Time --\n    -----------------------\n \n-   function Modification_Time (Name : String) return Ada.Calendar.Time is\n+   function Modification_Time (Name : String) return Time is\n       Date   : OS_Time;\n       Year   : Year_Type;\n       Month  : Month_Type;\n       Day    : Day_Type;\n       Hour   : Hour_Type;\n       Minute : Minute_Type;\n       Second : Second_Type;\n-\n-      Result : Ada.Calendar.Time;\n+      Result : Time;\n \n    begin\n       --  First, the invalid cases\n@@ -744,26 +737,31 @@ package body Ada.Directories is\n       else\n          Date := File_Time_Stamp (Name);\n \n-         --  ??? This implementation should be revisited when AI 00351 has\n-         --  implemented.\n+         --  Break down the time stamp into its constituents relative to GMT.\n+         --  This version of Split does not recognize leap seconds or buffer\n+         --  space for time zone processing.\n \n-         if OpenVMS then\n+         GM_Split (Date, Year, Month, Day, Hour, Minute, Second);\n \n-            --  On OpenVMS, OS_Time is in local time\n+         --  On OpenVMS, the resulting time value must be in the local time\n+         --  zone. Ada.Calendar.Time_Of is exactly what we need. Note that\n+         --  in both cases, the sub seconds are set to zero (0.0) because the\n+         --  time stamp does not store them in its value.\n \n-            GM_Split (Date, Year, Month, Day, Hour, Minute, Second);\n+         if OpenVMS then\n+            Result :=\n+              Ada.Calendar.Time_Of\n+                (Year, Month, Day, Seconds_Of (Hour, Minute, Second, 0.0));\n \n-            return Ada.Calendar.Time_Of\n-              (Year, Month, Day,\n-               Duration (Second + 60 * (Minute + 60 * Hour)));\n+         --  On Unix and Windows, the result must be in GMT. Ada.Calendar.\n+         --  Formatting.Time_Of with default time zone of zero (0) is the\n+         --  routine of choice.\n \n          else\n-            --  On Unix and Windows, OS_Time is in GMT\n-\n-            Result :=\n-              Duration_To_Time (Duration (OS_Time_To_Long_Integer (Date)));\n-            return Result;\n+            Result := Time_Of (Year, Month, Day, Hour, Minute, Second, 0.0);\n          end if;\n+\n+         return Result;\n       end if;\n    end Modification_Time;\n "}, {"sha": "595cc3d9edfc341b69a93aefeb892081f5383459", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 110, "deletions": 10, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907632860e44cc8c8b49a0b74444f62791fb9c/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=42907632860e44cc8c8b49a0b74444f62791fb9c", "patch": "@@ -687,7 +687,7 @@ get_gmtoff (void)\n \n /* This value is returned as the time zone offset when a valid value\n    cannot be determined. It is simply a bizarre value that will never\n-   occur. It is 3 days plus 73 seconds (offset is in seconds. */\n+   occur. It is 3 days plus 73 seconds (offset is in seconds). */\n \n long __gnat_invalid_tzoff = 259273;\n \n@@ -755,8 +755,9 @@ __gnat_localtime_tzoff (const time_t *, struct tm *, long *);\n struct tm *\n __gnat_localtime_tzoff (const time_t *timer, struct tm *tp, long *off)\n {\n+  /* Treat all time values in GMT */\n   localtime_r (tp, timer);\n-  *off = __gnat_invalid_tzoff;\n+  *off = 0;\n   return NULL;\n }\n \n@@ -779,21 +780,120 @@ __gnat_localtime_tzoff (const time_t *timer, struct tm *tp, long *off)\n \n /* AIX, HPUX, SGI Irix, Sun Solaris */\n #if defined (_AIX) || defined (__hpux__) || defined (sgi) || defined (sun)\n-  *off = (long) -timezone;\n-  if (tp->tm_isdst > 0)\n-    *off = *off + 3600;\n+  /* The contents of external variable \"timezone\" may not always be\n+     initialized. Instead of returning an incorrect offset, treat the local\n+     time zone as 0 (UTC). The value of 28 hours is the maximum valid offset\n+     allowed by Ada.Calendar.Time_Zones. */\n+  if ((timezone < -28 * 3600) || (timezone > 28 * 3600))\n+    *off = 0;\n+  else\n+  {\n+    *off = (long) -timezone;\n+    if (tp->tm_isdst > 0)\n+      *off = *off + 3600;\n+   }\n+/* Lynx - Treat all time values in GMT */\n+#elif defined (__Lynx__)\n+  *off = 0;\n+\n+/* VxWorks */\n+#elif defined (__vxworks)\n+#include <stdlib.h>\n+{\n+  /* Try to read the environment variable TIMEZONE. The variable may not have\n+     been initialize, in that case return an offset of zero (0) for UTC. */\n+  char *tz_str = getenv (\"TIMEZONE\");\n \n-/* Lynx, VXWorks */\n-#elif defined (__Lynx__) || defined (__vxworks)\n-  *off = __gnat_invalid_tzoff;\n+  if ((tz_str == NULL) || (*tz_str == '\\0'))\n+    *off = 0;\n+  else\n+  {\n+    char *tz_start, *tz_end;\n+\n+    /* The format of the data contained in TIMEZONE is N::U:S:E where N is the\n+       name of the time zone, U are the minutes difference from UTC, S is the\n+       start of DST in mmddhh and E is the end of DST in mmddhh. Extracting\n+       the value of U involves setting two pointers, one at the beginning and\n+       one at the end of the value. The end pointer is then set to null in\n+       order to delimit a string slice for atol to process. */\n+    tz_start = index (tz_str, ':') + 2;\n+    tz_end = index (tz_start, ':');\n+    tz_end = '\\0';\n+\n+    /* The Ada layer expects an offset in seconds */\n+    *off = atol (tz_start) * 60;\n+  }\n+}\n \n-/* Darwin, Free BSD, Linux, Tru64 */\n-#else\n+/* Darwin, Free BSD, Linux, Tru64, where there exists a component tm_gmtoff\n+   in struct tm */\n+#elif defined (__APPLE__) || defined (__FreeBSD__) || defined (linux) ||\\\n+     (defined (__alpha__) && defined (__osf__))\n   *off = tp->tm_gmtoff;\n+\n+/* All other platforms: Treat all time values in GMT */\n+#else\n+  *off = 0;\n #endif\n    return NULL;\n }\n \n #endif\n #endif\n #endif\n+\n+#ifdef __vxworks\n+\n+#include <taskLib.h>\n+\n+/* __gnat_get_task_options is used by s-taprop.adb only for VxWorks. This\n+   function returns the options to be set when creating a new task. It fetches\n+   the options assigned to the current task (parent), so offering some user\n+   level control over the options for a task hierarchy. It forces VX_FP_TASK\n+   because it is almost always required. */\n+extern int __gnat_get_task_options (void);\n+\n+int\n+__gnat_get_task_options (void)\n+{\n+  int options;\n+\n+  /* Get the options for the task creator */\n+  taskOptionsGet (taskIdSelf (), &options);\n+\n+  /* Force VX_FP_TASK because it is almost always required */\n+  options |= VX_FP_TASK;\n+\n+  /* Mask those bits that are not under user control */\n+#ifdef VX_USR_TASK_OPTIONS\n+  return options & VX_USR_TASK_OPTIONS;\n+#else\n+  return options;\n+#endif\n+}\n+\n+#endif\n+\n+#ifdef __Lynx__\n+\n+/*\n+   The following code works around a problem in LynxOS version 4.2. As\n+   of that version, the symbol pthread_mutex_lock has been removed\n+   from libc and replaced with an inline C function in a system\n+   header.\n+\n+   LynuxWorks has indicated that this is a bug and that they intend to\n+   put that symbol back in libc in a future patch level, following\n+   which this patch can be removed. However, for the time being we use\n+   a wrapper which can be imported from the runtime.\n+*/\n+\n+#include <pthread.h>\n+\n+int\n+__gnat_pthread_mutex_lock (pthread_mutex_t *mutex)\n+{\n+  return pthread_mutex_lock (mutex);\n+}\n+\n+#endif /* __Lynx__ */"}]}