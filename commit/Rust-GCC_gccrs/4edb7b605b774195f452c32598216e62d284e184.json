{"sha": "4edb7b605b774195f452c32598216e62d284e184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkYjdiNjA1Yjc3NDE5NWY0NTJjMzI1OTgyMTZlNjJkMjg0ZTE4NA==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-19T23:21:54Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-19T23:21:54Z"}, "message": "x\n\nFrom-SVN: r13207", "tree": {"sha": "28fbce19720def88464fedbeef973d4afe953a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28fbce19720def88464fedbeef973d4afe953a7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4edb7b605b774195f452c32598216e62d284e184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4edb7b605b774195f452c32598216e62d284e184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4edb7b605b774195f452c32598216e62d284e184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4edb7b605b774195f452c32598216e62d284e184/comments", "author": null, "committer": null, "parents": [{"sha": "1240b4abee6e5e43f2059c8afdeb4e258a13b7ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1240b4abee6e5e43f2059c8afdeb4e258a13b7ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1240b4abee6e5e43f2059c8afdeb4e258a13b7ed"}], "stats": {"total": 93, "additions": 47, "deletions": 46}, "files": [{"sha": "6d0e84b00abcc2a6cd8a9e5be2ffb0b03e8db4e9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4edb7b605b774195f452c32598216e62d284e184/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4edb7b605b774195f452c32598216e62d284e184/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4edb7b605b774195f452c32598216e62d284e184", "patch": "@@ -36,22 +36,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* #define NDEBUG 1 */\n #include \"assert.h\"\n-#if defined(DWARF_TIMESTAMPS)\n-#if defined(POSIX)\n-#include <time.h>\n-#else /* !defined(POSIX) */\n-#include <sys/types.h>\n-#if defined(__STDC__)\n-extern time_t time (time_t *);\n-#else /* !defined(__STDC__) */\n-extern time_t time ();\n-#endif /* !defined(__STDC__) */\n-#endif /* !defined(POSIX) */\n-#endif /* defined(DWARF_TIMESTAMPS) */\n \n extern char *getpwd ();\n-extern char *index ();\n-extern char *rindex ();\n \n /* IMPORTANT NOTE: Please see the file README.DWARF for important details\n    regarding the GNU implementation of DWARF.  */\n@@ -60,8 +46,6 @@ extern char *rindex ();\n    \"Debugging Information Entries\".  This term is abbreviated as `DIE'\n    throughout the remainder of this file.  */\n \n-/* NOTE: The implementation of C++ support is unfinished.  */\n-\n #if defined(__GNUC__) && (NDEBUG == 1)\n #define inline static inline\n #else\n@@ -6085,6 +6069,8 @@ gen_array_type_die (type, context_die)\n #endif\n \n #ifdef MIPS_DEBUGGING_INFO\n+  /* The SGI compilers handle arrays of unknown bound by setting\n+     AT_declaration and not emitting any subrange DIEs.  */\n   if (! TYPE_DOMAIN (type))\n     add_AT_unsigned (array_die, DW_AT_declaration, 1);\n   else\n@@ -6379,6 +6365,7 @@ gen_subprogram_die (decl, context_die)\n   register tree fn_arg_types;\n   register tree outer_scope;\n   dw_die_ref old_die = lookup_decl_die (decl);\n+  int declaration = (current_function_decl != decl);\n \n   if (origin != NULL)\n     {\n@@ -6418,8 +6405,16 @@ gen_subprogram_die (decl, context_die)\n     }\n   else\n     {\n-      subr_die = new_die (DW_TAG_subprogram,\n-\t\t\t  scope_die_for (decl, context_die));\n+      register dw_die_ref scope_die;\n+\n+      if (DECL_CONTEXT (decl))\n+\tscope_die = scope_die_for (decl, context_die);\n+      else\n+\t/* Don't put block extern declarations under comp_unit_die.  */\n+\tscope_die = context_die;\n+\n+      subr_die = new_die (DW_TAG_subprogram, scope_die);\n+\t\t\t \n       if (TREE_PUBLIC (decl))\n \tadd_AT_flag (subr_die, DW_AT_external, 1);\n       add_name_and_src_coords_attributes (subr_die, decl);\n@@ -6432,14 +6427,8 @@ gen_subprogram_die (decl, context_die)\n       add_pure_or_virtual_attribute (subr_die, decl);\n       if (DECL_ARTIFICIAL (decl))\n \tadd_AT_flag (subr_die, DW_AT_artificial, 1);\n-\n-      /* The first time we see a member function, it is in the context of\n-         the class to which it belongs.  We make sure of this by emitting\n-         the class first.  The next time is the definition, which is\n-         handled above.  The two may come from the same source text.  */\n-      if (! DECL_INITIAL (decl))\n-\tadd_AT_flag (subr_die, DW_AT_declaration, 1);\n     }\n+\n   if (DECL_ABSTRACT (decl))\n     {\n       if (DECL_DEFER_OUTPUT (decl))\n@@ -6452,13 +6441,25 @@ gen_subprogram_die (decl, context_die)\n \t}\n       else if (DECL_INLINE (decl))\n \tadd_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n+      else if (declaration)\n+\t/* block extern declaration in an inline function.  */\n+\tadd_AT_flag (subr_die, DW_AT_declaration, 1);\n       else\n \tabort ();\n \n       equate_decl_number_to_die (decl, subr_die);\n     }\n-  else if (!DECL_INITIAL (decl))\n-    equate_decl_number_to_die (decl, subr_die);\n+  else if (declaration)\n+    {\n+      add_AT_flag (subr_die, DW_AT_declaration, 1);\n+\n+      /* The first time we see a member function, it is in the context of\n+         the class to which it belongs.  We make sure of this by emitting\n+         the class first.  The next time is the definition, which is\n+         handled above.  The two may come from the same source text.  */\n+      if (decl_class_context (decl))\n+\tequate_decl_number_to_die (decl, subr_die);\n+    }\n   else if (!DECL_EXTERNAL (decl))\n     {\n       if (origin == NULL)\n@@ -6515,10 +6516,8 @@ gen_subprogram_die (decl, context_die)\n      its formal parameters.  */\n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n     /* do nothing */;\n-  else if (DECL_INITIAL (decl) == NULL_TREE)\n-    {\n-      gen_formal_types_die (TREE_TYPE (decl), subr_die);\n-    }\n+  else if (declaration)\n+    gen_formal_types_die (TREE_TYPE (decl), subr_die);\n   else\n     {\n       /* Generate DIEs to represent all known formal parameters */\n@@ -6587,7 +6586,7 @@ gen_subprogram_die (decl, context_die)\n      node representing the function's outermost pair of curly braces, and\n      any blocks used for the base and member initializers of a C++\n      constructor function.  */\n-  if (outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n+  if (! declaration && TREE_CODE (outer_scope) != ERROR_MARK)\n     {\n       current_function_has_inlines = 0;\n       decls_for_scope (outer_scope, subr_die, 0);\n@@ -6615,7 +6614,10 @@ gen_variable_die (decl, context_die)\n   register tree origin = decl_ultimate_origin (decl);\n   register dw_die_ref var_die = new_die (DW_TAG_variable, context_die);\n   dw_die_ref old_die = lookup_decl_die (decl);\n-  \n+  int declaration\n+    = (DECL_EXTERNAL (decl)\n+       || current_function_decl != decl_function_context (decl));\n+\n   if (origin != NULL)\n     {\n       add_abstract_origin_attribute (var_die, origin);\n@@ -6648,22 +6650,20 @@ gen_variable_die (decl, context_die)\n       if (DECL_ARTIFICIAL (decl))\n \tadd_AT_flag (var_die, DW_AT_artificial, 1);\n     }\n-  if (DECL_ABSTRACT (decl))\n-    {\n-      equate_decl_number_to_die (decl, var_die);\n-    }\n-  else if (!DECL_EXTERNAL (decl))\n+\n+  if (declaration)\n+    add_AT_flag (var_die, DW_AT_declaration, 1);\n+  \n+  if ((declaration && decl_class_context (decl)) || DECL_ABSTRACT (decl))\n+    equate_decl_number_to_die (decl, var_die);\n+\n+  if (! declaration && ! DECL_ABSTRACT (decl))\n     {\n       if (TREE_STATIC (decl))\n \tequate_decl_number_to_die (decl, var_die);\n       add_location_or_const_value_attribute (var_die, decl);\n       add_pubname (decl, var_die);\n     }\n-  else if (decl_class_context (decl))\n-    {\n-      equate_decl_number_to_die (decl, var_die);\n-      add_AT_flag (var_die, DW_AT_declaration, 1);\n-    }\n }\n \n /* Generate a DIE to represent a label identifier.  */\n@@ -7379,9 +7379,10 @@ gen_decl_die (decl, context_die)\n       break;\n \n     case FUNCTION_DECL:\n-      /* If we are in terse mode, don't output any DIEs to represent mere\n-         function declarations, unless they are class members.  */\n-      if (DECL_INITIAL (decl) == NULL_TREE && DECL_CONTEXT (decl) == NULL_TREE)\n+      /* Don't output any DIEs to represent mere function declarations,\n+\t unless they are class members or explicit block externs.  */\n+      if (DECL_INITIAL (decl) == NULL_TREE && DECL_CONTEXT (decl) == NULL_TREE\n+\t  && (current_function_decl == NULL_TREE || ! DECL_ARTIFICIAL (decl)))\n \t{\n \t  break;\n \t}"}]}