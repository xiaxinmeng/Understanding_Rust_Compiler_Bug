{"sha": "378b307d0d7e789c69570cba4a9388b781c3f062", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc4YjMwN2QwZDdlNzg5YzY5NTcwY2JhNGE5Mzg4Yjc4MWMzZjA2Mg==", "commit": {"author": {"name": "Andrew Sutton", "email": "andrew.n.sutton@gmail.com", "date": "2015-09-17T18:26:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-09-17T18:26:06Z"}, "message": "Implement N4295 fold-expressions.\n\n\t* cp-tree.def: Add UNARY_LEFT_FOLD_EXPR, UNARY_RIGHT_FOLD_EXPR,\n\tBINARY_LEFT_FOLD_EXPR, BINARY_RIGHT_FOLD_EXPR.\n\t* cp-objcp-common.c (cp_common_init_ts): Handle them.\n\t* cp-tree.h (FOLD_EXPR_CHECK, BINARY_FOLD_EXPR_CHECK, FOLD_EXPR_P)\n\t(FOLD_EXPR_MODIFY_P, FOLD_EXPR_OP, FOLD_EXPR_PACK, FOLD_EXPR_INIT): New.\n\t* parser.c (cp_parser_skip_to_closing_parenthesis): Split out...\n\t(cp_parser_skip_to_closing_parenthesis_1): This function.  Change\n\tor_comma parameter to or_ttype.\n\t(cp_parser_fold_operator, cp_parser_fold_expr_p)\n\t(cp_parser_fold_expression): New.\n\t(cp_parser_primary_expression): Use them.\n\t* pt.c (expand_empty_fold, fold_expression, tsubst_fold_expr_pack)\n\t(tsubst_fold_expr_init, expand_left_fold, tsubst_unary_left_fold)\n\t(tsubst_binary_left_fold, expand_right_fold)\n\t(tsubst_unary_right_fold, tsubst_binary_right_fold): New.\n\t(tsubst_copy): Use them.\n\t(type_dependent_expression_p): Handle fold-expressions.\n\t* semantics.c (finish_unary_fold_expr)\n\t(finish_left_unary_fold_expr, finish_right_unary_fold_expr)\n\t(finish_binary_fold_expr): New.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r227883", "tree": {"sha": "6946be114431b50821732989faea2214c6fb345a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6946be114431b50821732989faea2214c6fb345a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/378b307d0d7e789c69570cba4a9388b781c3f062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378b307d0d7e789c69570cba4a9388b781c3f062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/378b307d0d7e789c69570cba4a9388b781c3f062", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378b307d0d7e789c69570cba4a9388b781c3f062/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "750cdaf713adb0a6c873f729ec7ac48ec4cd25b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/750cdaf713adb0a6c873f729ec7ac48ec4cd25b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/750cdaf713adb0a6c873f729ec7ac48ec4cd25b8"}], "stats": {"total": 878, "additions": 865, "deletions": 13}, "files": [{"sha": "0f0d07dae1795e7793e0fd97dbb5faf441a61a48", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -1,3 +1,28 @@\n+2015-09-17  Andrew Sutton  <andrew.n.sutton@gmail.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tImplement N4295 fold-expressions.\n+\t* cp-tree.def: Add UNARY_LEFT_FOLD_EXPR, UNARY_RIGHT_FOLD_EXPR,\n+\tBINARY_LEFT_FOLD_EXPR, BINARY_RIGHT_FOLD_EXPR.\n+\t* cp-objcp-common.c (cp_common_init_ts): Handle them.\n+\t* cp-tree.h (FOLD_EXPR_CHECK, BINARY_FOLD_EXPR_CHECK, FOLD_EXPR_P)\n+\t(FOLD_EXPR_MODIFY_P, FOLD_EXPR_OP, FOLD_EXPR_PACK, FOLD_EXPR_INIT): New.\n+\t* parser.c (cp_parser_skip_to_closing_parenthesis): Split out...\n+\t(cp_parser_skip_to_closing_parenthesis_1): This function.  Change\n+\tor_comma parameter to or_ttype.\n+\t(cp_parser_fold_operator, cp_parser_fold_expr_p)\n+\t(cp_parser_fold_expression): New.\n+\t(cp_parser_primary_expression): Use them.\n+\t* pt.c (expand_empty_fold, fold_expression, tsubst_fold_expr_pack)\n+\t(tsubst_fold_expr_init, expand_left_fold, tsubst_unary_left_fold)\n+\t(tsubst_binary_left_fold, expand_right_fold)\n+\t(tsubst_unary_right_fold, tsubst_binary_right_fold): New.\n+\t(tsubst_copy): Use them.\n+\t(type_dependent_expression_p): Handle fold-expressions.\n+\t* semantics.c (finish_unary_fold_expr)\n+\t(finish_left_unary_fold_expr, finish_right_unary_fold_expr)\n+\t(finish_binary_fold_expr): New.\n+\n 2015-09-17  Richard Biener  <rguenther@suse.de>\n \n \t* cp-tree.h (note_decl_for_pch): Remove."}, {"sha": "22f063b70931ecac92a76db8de308077b04ffc7a", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -311,6 +311,10 @@ cp_common_init_ts (void)\n   MARK_TS_TYPED (CTOR_INITIALIZER);\n   MARK_TS_TYPED (ARRAY_NOTATION_REF);\n   MARK_TS_TYPED (REQUIRES_EXPR);\n+  MARK_TS_TYPED (UNARY_LEFT_FOLD_EXPR);\n+  MARK_TS_TYPED (UNARY_RIGHT_FOLD_EXPR);\n+  MARK_TS_TYPED (BINARY_LEFT_FOLD_EXPR);\n+  MARK_TS_TYPED (BINARY_RIGHT_FOLD_EXPR);\n }\n \n #include \"gt-cp-cp-objcp-common.h\""}, {"sha": "7df72c53522c3fbdb5a93e94f795c913149aa2cb", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -432,6 +432,26 @@ DEFTREECODE (EXPR_PACK_EXPANSION, \"expr_pack_expansion\", tcc_expression, 3)\n    index is a machine integer.  */\n DEFTREECODE (ARGUMENT_PACK_SELECT, \"argument_pack_select\", tcc_exceptional, 0)\n \n+/* Fold expressions allow the expansion of a template argument pack\n+   over a binary operator.\n+\n+   FOLD_EXPR_MOD_P is true when the fold operation is a compound assignment\n+   operator.\n+\n+   FOLD_EXPR_OP is an INTEGER_CST storing the tree code for the folded\n+   expression. Note that when FOLDEXPR_MOD_P is true, the operator is\n+   a compound assignment operator for that kind of expression.\n+\n+   FOLD_EXPR_PACK is an expression containing an unexpanded parameter pack;\n+   when expanded, each term becomes an argument of the folded expression.\n+\n+   In a BINARY_FOLD_EXPRESSION, FOLD_EXPR_INIT is the non-pack argument. */\n+DEFTREECODE (UNARY_LEFT_FOLD_EXPR, \"unary_left_fold_expr\", tcc_expression, 2)\n+DEFTREECODE (UNARY_RIGHT_FOLD_EXPR, \"unary_right_fold_expr\", tcc_expression, 2)\n+DEFTREECODE (BINARY_LEFT_FOLD_EXPR, \"binary_left_fold_expr\", tcc_expression, 3)\n+DEFTREECODE (BINARY_RIGHT_FOLD_EXPR, \"binary_right_fold_expr\", tcc_expression, 3)\n+\n+\n /** C++ extensions. */\n \n /* Represents a trait expression during template expansion.  */"}, {"sha": "80d6c4e4a2f69e73ae2e51d4f1bf594d58ac9a37", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -80,6 +80,7 @@ c-common.h, not after.\n       COMPOUND_REQ_NOEXCEPT_P (in COMPOUND_REQ)\n       WILDCARD_PACK_P (in WILDCARD_DECL)\n       BLOCK_OUTER_CURLY_BRACE_P (in BLOCK)\n+      FOLD_EXPR_MODOP_P (*_FOLD_EXPR)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -3249,6 +3250,37 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n   TREE_VEC_ELT (ARGUMENT_PACK_ARGS (ARGUMENT_PACK_SELECT_FROM_PACK (NODE)), \\\n \t        ARGUMENT_PACK_SELECT_INDEX (NODE))\n \n+#define FOLD_EXPR_CHECK(NODE)\t\t\t\t\t\t\\\n+  TREE_CHECK4 (NODE, UNARY_LEFT_FOLD_EXPR, UNARY_RIGHT_FOLD_EXPR,\t\\\n+\t       BINARY_LEFT_FOLD_EXPR, BINARY_RIGHT_FOLD_EXPR)\n+\n+#define BINARY_FOLD_EXPR_CHECK(NODE) \\\n+  TREE_CHECK2 (NODE, BINARY_LEFT_FOLD_EXPR, BINARY_RIGHT_FOLD_EXPR)\n+\n+/* True if NODE is UNARY_FOLD_EXPR or a BINARY_FOLD_EXPR */\n+#define FOLD_EXPR_P(NODE) \\\n+  TREE_CODE (NODE) == UNARY_LEFT_FOLD_EXPR \\\n+    || TREE_CODE (NODE) == UNARY_RIGHT_FOLD_EXPR \\\n+    || TREE_CODE (NODE) == BINARY_LEFT_FOLD_EXPR \\\n+    || TREE_CODE (NODE) == BINARY_RIGHT_FOLD_EXPR\n+\n+/* True when NODE is a fold over a compound assignment operator. */\n+#define FOLD_EXPR_MODIFY_P(NODE) \\\n+  TREE_LANG_FLAG_0 (FOLD_EXPR_CHECK (NODE))\n+\n+/* An INTEGER_CST containing the tree code of the folded operator. */\n+#define FOLD_EXPR_OP(NODE) \\\n+  TREE_OPERAND (FOLD_EXPR_CHECK (NODE), 0)\n+\n+/* The expression containing an unexpanded parameter pack. */\n+#define FOLD_EXPR_PACK(NODE) \\\n+  TREE_OPERAND (FOLD_EXPR_CHECK (NODE), 1)\n+\n+/* In a binary fold expression, the argument with no unexpanded\n+   parameter packs. */\n+#define FOLD_EXPR_INIT(NODE) \\\n+  TREE_OPERAND (BINARY_FOLD_EXPR_CHECK (NODE), 2)\n+\n /* In a FUNCTION_DECL, the saved language-specific per-function data.  */\n #define DECL_SAVED_FUNCTION_DATA(NODE)\t\t\t\\\n   (LANG_DECL_FN_CHECK (FUNCTION_DECL_CHECK (NODE))\t\\\n@@ -6567,6 +6599,10 @@ extern bool check_literal_operator_args\t\t(const_tree, bool *, bool *);\n extern void maybe_warn_about_useless_cast       (tree, tree, tsubst_flags_t);\n extern tree cp_perform_integral_promotions      (tree, tsubst_flags_t);\n \n+extern tree finish_left_unary_fold_expr      (tree, int);\n+extern tree finish_right_unary_fold_expr     (tree, int);\n+extern tree finish_binary_fold_expr          (tree, tree, int);\n+\n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);\n extern void cxx_incomplete_type_diagnostic\t(const_tree, const_tree, diagnostic_t);"}, {"sha": "4f424b64f42c0e6dced71abd5d7b22c502c48ae8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 216, "deletions": 13, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -3175,27 +3175,32 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n \n /* Consume tokens up to, and including, the next non-nested closing `)'.\n    Returns 1 iff we found a closing `)'.  RECOVERING is true, if we\n-   are doing error recovery. Returns -1 if OR_COMMA is true and we\n-   found an unnested comma.  */\n+   are doing error recovery. Returns -1 if OR_TTYPE is not CPP_EOF and we\n+   found an unnested token of that type.  */\n \n static int\n-cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n-\t\t\t\t       bool recovering,\n-\t\t\t\t       bool or_comma,\n-\t\t\t\t       bool consume_paren)\n+cp_parser_skip_to_closing_parenthesis_1 (cp_parser *parser,\n+\t\t\t\t\t bool recovering,\n+\t\t\t\t\t cpp_ttype or_ttype,\n+\t\t\t\t\t bool consume_paren)\n {\n   unsigned paren_depth = 0;\n   unsigned brace_depth = 0;\n   unsigned square_depth = 0;\n \n-  if (recovering && !or_comma\n+  if (recovering && or_ttype == CPP_EOF\n       && cp_parser_uncommitted_to_tentative_parse_p (parser))\n     return 0;\n \n   while (true)\n     {\n       cp_token * token = cp_lexer_peek_token (parser->lexer);\n \n+      /* Have we found what we're looking for before the closing paren?  */\n+      if (token->type == or_ttype && or_ttype != CPP_EOF\n+\t  && !brace_depth && !paren_depth && !square_depth)\n+\treturn -1;\n+\n       switch (token->type)\n \t{\n \tcase CPP_EOF:\n@@ -3226,12 +3231,6 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n \t    return 0;\n \t  break;\n \n-\tcase CPP_COMMA:\n-\t  if (recovering && or_comma && !brace_depth && !paren_depth\n-\t      && !square_depth)\n-\t    return -1;\n-\t  break;\n-\n \tcase CPP_OPEN_PAREN:\n \t  if (!brace_depth)\n \t    ++paren_depth;\n@@ -3255,6 +3254,22 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n     }\n }\n \n+/* Consume tokens up to, and including, the next non-nested closing `)'.\n+   Returns 1 iff we found a closing `)'.  RECOVERING is true, if we\n+   are doing error recovery. Returns -1 if OR_COMMA is true and we\n+   found an unnested token of that type.  */\n+\n+static int\n+cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n+\t\t\t\t       bool recovering,\n+\t\t\t\t       bool or_comma,\n+\t\t\t\t       bool consume_paren)\n+{\n+  cpp_ttype ttype = or_comma ? CPP_COMMA : CPP_EOF;\n+  return cp_parser_skip_to_closing_parenthesis_1 (parser, recovering,\n+\t\t\t\t\t\t  ttype, consume_paren);\n+}\n+\n /* Consume tokens until we reach the end of the current statement.\n    Normally, that will be just before consuming a `;'.  However, if a\n    non-nested `}' comes first, then we stop before consuming that.  */\n@@ -4260,6 +4275,186 @@ cp_parser_statement_expr (cp_parser *parser)\n \n /* Expressions [gram.expr] */\n \n+/* Parse a fold-operator.\n+\n+    fold-operator:\n+        -  *  /  %  ^  &  |  =  <  >  <<  >>\n+      =  -=  *=  /=  %=  ^=  &=  |=  <<=  >>=\n+      ==  !=  <=  >=  &&  ||  ,  .*  ->*\n+\n+   This returns the tree code corresponding to the matched operator\n+   as an int. When the current token matches a compound assignment\n+   opertor, the resulting tree code is the negative value of the\n+   non-assignment operator. */\n+\n+static int\n+cp_parser_fold_operator (cp_token *token)\n+{\n+  switch (token->type)\n+    {\n+    case CPP_PLUS: return PLUS_EXPR;\n+    case CPP_MINUS: return MINUS_EXPR;\n+    case CPP_MULT: return MULT_EXPR;\n+    case CPP_DIV: return TRUNC_DIV_EXPR;\n+    case CPP_MOD: return TRUNC_MOD_EXPR;\n+    case CPP_XOR: return BIT_XOR_EXPR;\n+    case CPP_AND: return BIT_AND_EXPR;\n+    case CPP_OR: return BIT_IOR_EXPR;\n+    case CPP_LSHIFT: return LSHIFT_EXPR;\n+    case CPP_RSHIFT: return RSHIFT_EXPR;\n+\n+    case CPP_EQ: return -NOP_EXPR;\n+    case CPP_PLUS_EQ: return -PLUS_EXPR;\n+    case CPP_MINUS_EQ: return -MINUS_EXPR;\n+    case CPP_MULT_EQ: return -MULT_EXPR;\n+    case CPP_DIV_EQ: return -TRUNC_DIV_EXPR;\n+    case CPP_MOD_EQ: return -TRUNC_MOD_EXPR;\n+    case CPP_XOR_EQ: return -BIT_XOR_EXPR;\n+    case CPP_AND_EQ: return -BIT_AND_EXPR;\n+    case CPP_OR_EQ: return -BIT_IOR_EXPR;\n+    case CPP_LSHIFT_EQ: return -LSHIFT_EXPR;\n+    case CPP_RSHIFT_EQ: return -RSHIFT_EXPR;\n+\n+    case CPP_EQ_EQ: return EQ_EXPR;\n+    case CPP_NOT_EQ: return NE_EXPR;\n+    case CPP_LESS: return LT_EXPR;\n+    case CPP_GREATER: return GT_EXPR;\n+    case CPP_LESS_EQ: return LE_EXPR;\n+    case CPP_GREATER_EQ: return GE_EXPR;\n+\n+    case CPP_AND_AND: return TRUTH_ANDIF_EXPR;\n+    case CPP_OR_OR: return TRUTH_ORIF_EXPR;\n+\n+    case CPP_COMMA: return COMPOUND_EXPR;\n+\n+    case CPP_DOT_STAR: return DOTSTAR_EXPR;\n+    case CPP_DEREF_STAR: return MEMBER_REF;\n+\n+    default: return ERROR_MARK;\n+    }\n+}\n+\n+/* If the next token is a suitable fold operator, consume it and return as\n+   the function above.  */\n+\n+static int\n+cp_parser_fold_operator (cp_parser *parser)\n+{\n+  cp_token* token = cp_lexer_peek_token (parser->lexer);\n+  int code = cp_parser_fold_operator (token);\n+  if (code != ERROR_MARK)\n+    cp_lexer_consume_token (parser->lexer);\n+  return code;\n+}\n+\n+/* Returns true iff we're at the beginning of an N4191 fold-expression, after\n+   the left parenthesis.  Rather than do tentative parsing, we scan the tokens\n+   up to the matching right paren for an ellipsis next to a binary\n+   operator.  */\n+\n+static bool\n+cp_parser_fold_expr_p (cp_parser *parser)\n+{\n+  /* An ellipsis right after the left paren always indicates a\n+     fold-expression.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+    {\n+      /* But if there isn't a fold operator after the ellipsis,\n+         give a different error.  */\n+      cp_token *token = cp_lexer_peek_nth_token (parser->lexer, 2);\n+      return (cp_parser_fold_operator (token) != ERROR_MARK);\n+    }\n+\n+  /* Otherwise, look for an ellipsis.  */\n+  cp_lexer_save_tokens (parser->lexer);\n+  int ret = cp_parser_skip_to_closing_parenthesis_1 (parser, false,\n+\t\t\t\t\t\t     CPP_ELLIPSIS, false);\n+  bool found = (ret == -1);\n+  if (found)\n+    {\n+      /* We found an ellipsis, is the previous token an operator?  */\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      --token;\n+      if (cp_parser_fold_operator (token) == ERROR_MARK)\n+\tfound = false;\n+    }\n+  cp_lexer_rollback_tokens (parser->lexer);\n+  return found;\n+}\n+\n+/* Parse a fold-expression.\n+\n+     fold-expression:\n+       ( ... folding-operator cast-expression)\n+       ( cast-expression folding-operator ... )\n+       ( cast-expression folding operator ... folding-operator cast-expression)\n+\n+   Note that the '(' and ')' are matched in primary expression. */\n+\n+static tree\n+cp_parser_fold_expression (cp_parser *parser)\n+{\n+  cp_id_kind pidk;\n+\n+  if (cxx_dialect < cxx1z && !in_system_header_at (input_location))\n+    pedwarn (input_location, 0, \"fold-expressions only available with \"\n+\t     \"-std=c++1z or -std=gnu++1z\");\n+\n+  // Left fold.\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      int op = cp_parser_fold_operator (parser);\n+      if (op == ERROR_MARK)\n+        {\n+          cp_parser_error (parser, \"expected binary operator\");\n+          return error_mark_node;\n+        }\n+\n+      tree expr = cp_parser_cast_expression (parser, false, false,\n+\t\t\t\t\t     false, &pidk);\n+      if (expr == error_mark_node)\n+        return error_mark_node;\n+      return finish_left_unary_fold_expr (expr, op);\n+    }\n+\n+  tree expr1 = cp_parser_cast_expression (parser, false, false, false, &pidk);\n+  if (expr1 == error_mark_node)\n+    return error_mark_node;\n+\n+  const cp_token* token = cp_lexer_peek_token (parser->lexer);\n+  int op = cp_parser_fold_operator (parser);\n+  if (op == ERROR_MARK)\n+    {\n+      cp_parser_error (parser, \"expected binary operator\");\n+      return error_mark_node;\n+    }\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_ELLIPSIS))\n+    {\n+      cp_parser_error (parser, \"expected ...\");\n+      return error_mark_node;\n+    }\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  // Right fold.\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+    return finish_right_unary_fold_expr (expr1, op);\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, token->type))\n+    {\n+      cp_parser_error (parser, \"mismatched operator in fold-expression\");\n+      return error_mark_node;\n+    }\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  // Binary left or right fold.\n+  tree expr2 = cp_parser_cast_expression (parser, false, false, false, &pidk);\n+  if (expr2 == error_mark_node)\n+    return error_mark_node;\n+  return finish_binary_fold_expr (expr1, expr2, op);\n+}\n+\n /* Parse a primary-expression.\n \n    primary-expression:\n@@ -4468,6 +4663,14 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  = parser->greater_than_is_operator_p;\n \tparser->greater_than_is_operator_p = true;\n \n+\t// Handle a fold-expression.\n+\tif (cp_parser_fold_expr_p (parser))\n+\t  {\n+\t    tree fold = cp_parser_fold_expression (parser);\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t    return fold;\n+\t  }\n+\n \t/* Parse the parenthesized expression.  */\n \texpr = cp_parser_expression (parser, idk, cast_p, decltype_p);\n \t/* Let the front end know that this expression was"}, {"sha": "10a12ea72881ba3dcec0dac7e3fc29615bd1060a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -10506,6 +10506,208 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n   return t;\n }\n \n+/* When the unexpanded parameter pack in a fold expression expands to an empty\n+   sequence, the value of the expression is as follows; the program is\n+   ill-formed if the operator is not listed in this table.\n+\n+   *\t1\n+   +\t0\n+   &\t-1\n+   |\t0\n+   &&\ttrue\n+   ||\tfalse\n+   ,\tvoid()  */\n+\n+tree\n+expand_empty_fold (tree t, tsubst_flags_t complain)\n+{\n+  tree_code code = (tree_code)TREE_INT_CST_LOW (TREE_OPERAND (t, 0));\n+  if (!FOLD_EXPR_MODIFY_P (t))\n+    switch (code)\n+      {\n+      case MULT_EXPR:\n+\treturn integer_one_node;\n+      case PLUS_EXPR:\n+\treturn integer_zero_node;\n+      case BIT_AND_EXPR:\n+\treturn integer_minus_one_node;\n+      case BIT_IOR_EXPR:\n+\treturn integer_zero_node;\n+      case TRUTH_ANDIF_EXPR:\n+\treturn boolean_true_node;\n+      case TRUTH_ORIF_EXPR:\n+\treturn boolean_false_node;\n+      case COMPOUND_EXPR:\n+\treturn void_node;\n+      default:\n+\tbreak;\n+      }\n+\n+  if (complain & tf_error)\n+    error_at (location_of (t),\n+\t      \"fold of empty expansion over %O\", code);\n+  return error_mark_node;\n+}\n+\n+/* Given a fold-expression T and a current LEFT and RIGHT operand,\n+   form an expression that combines the two terms using the\n+   operator of T. */\n+\n+static tree\n+fold_expression (tree t, tree left, tree right, tsubst_flags_t complain)\n+{\n+  tree op = FOLD_EXPR_OP (t);\n+  tree_code code = (tree_code)TREE_INT_CST_LOW (op);\n+\n+  // Handle compound assignment operators.\n+  if (FOLD_EXPR_MODIFY_P (t))\n+    return build_x_modify_expr (input_location, left, code, right, complain);\n+\n+  switch (code)\n+    {\n+    case COMPOUND_EXPR:\n+      return build_x_compound_expr (input_location, left, right, complain);\n+    case DOTSTAR_EXPR:\n+      return build_m_component_ref (left, right, complain);\n+    default:\n+      return build_x_binary_op (input_location, code,\n+                                left, TREE_CODE (left),\n+                                right, TREE_CODE (right),\n+                                /*overload=*/NULL,\n+                                complain);\n+    }\n+}\n+\n+/* Substitute ARGS into the pack of a fold expression T. */\n+\n+static inline tree\n+tsubst_fold_expr_pack (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  return tsubst_pack_expansion (FOLD_EXPR_PACK (t), args, complain, in_decl);\n+}\n+\n+/* Substitute ARGS into the pack of a fold expression T. */\n+\n+static inline tree\n+tsubst_fold_expr_init (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  return tsubst_expr (FOLD_EXPR_INIT (t), args, complain, in_decl, false);\n+}\n+\n+/* Expand a PACK of arguments into a grouped as left fold.\n+   Given a pack containing elements A0, A1, ..., An and an\n+   operator @, this builds the expression:\n+\n+      ((A0 @ A1) @ A2) ... @ An\n+\n+   Note that PACK must not be empty.\n+\n+   The operator is defined by the original fold expression T. */\n+\n+static tree\n+expand_left_fold (tree t, tree pack, tsubst_flags_t complain)\n+{\n+  tree left = TREE_VEC_ELT (pack, 0);\n+  for (int i = 1; i < TREE_VEC_LENGTH (pack); ++i)\n+    {\n+      tree right = TREE_VEC_ELT (pack, i);\n+      left = fold_expression (t, left, right, complain);\n+    }\n+  return left;\n+}\n+\n+/* Substitute into a unary left fold expression. */\n+\n+static tree\n+tsubst_unary_left_fold (tree t, tree args, tsubst_flags_t complain,\n+                        tree in_decl)\n+{\n+  tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  if (TREE_VEC_LENGTH (pack) == 0)\n+    return expand_empty_fold (t, complain);\n+  else\n+    return expand_left_fold (t, pack, complain);\n+}\n+\n+/* Substitute into a binary left fold expression.\n+\n+   Do ths by building a single (non-empty) vector of argumnts and\n+   building the expression from those elements. */\n+\n+static tree\n+tsubst_binary_left_fold (tree t, tree args, tsubst_flags_t complain,\n+                         tree in_decl)\n+{\n+  tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  tree init = tsubst_fold_expr_init (t, args, complain, in_decl);\n+\n+  tree vec = make_tree_vec (TREE_VEC_LENGTH (pack) + 1);\n+  TREE_VEC_ELT (vec, 0) = init;\n+  for (int i = 0; i < TREE_VEC_LENGTH (pack); ++i)\n+    TREE_VEC_ELT (vec, i + 1) = TREE_VEC_ELT (pack, i);\n+\n+  return expand_left_fold (t, vec, complain);\n+}\n+\n+/* Expand a PACK of arguments into a grouped as right fold.\n+   Given a pack containing elementns A0, A1, ..., and an\n+   operator @, this builds the expression:\n+\n+      A0@ ... (An-2 @ (An-1 @ An))\n+\n+   Note that PACK must not be empty.\n+\n+   The operator is defined by the original fold expression T. */\n+\n+tree\n+expand_right_fold (tree t, tree pack, tsubst_flags_t complain)\n+{\n+  // Build the expression.\n+  int n = TREE_VEC_LENGTH (pack);\n+  tree right = TREE_VEC_ELT (pack, n - 1);\n+  for (--n; n != 0; --n)\n+    {\n+      tree left = TREE_VEC_ELT (pack, n - 1);\n+      right = fold_expression (t, left, right, complain);\n+    }\n+  return right;\n+}\n+\n+/* Substitute into a unary right fold expression. */\n+\n+static tree\n+tsubst_unary_right_fold (tree t, tree args, tsubst_flags_t complain,\n+                         tree in_decl)\n+{\n+  tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  if (TREE_VEC_LENGTH (pack) == 0)\n+    return expand_empty_fold (t, complain);\n+  else\n+    return expand_right_fold (t, pack, complain);\n+}\n+\n+/* Substitute into a binary right fold expression.\n+\n+   Do ths by building a single (non-empty) vector of arguments and\n+   building the expression from those elements. */\n+\n+static tree\n+tsubst_binary_right_fold (tree t, tree args, tsubst_flags_t complain,\n+                         tree in_decl)\n+{\n+  tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  tree init = tsubst_fold_expr_init (t, args, complain, in_decl);\n+\n+  int n = TREE_VEC_LENGTH (pack);\n+  tree vec = make_tree_vec (n + 1);\n+  for (int i = 0; i < n; ++i)\n+    TREE_VEC_ELT (vec, i) = TREE_VEC_ELT (pack, i);\n+  TREE_VEC_ELT (vec, n) = init;\n+\n+  return expand_right_fold (t, vec, complain);\n+}\n+\n+\n /* Substitute ARGS into T, which is an pack expansion\n    (i.e. TYPE_PACK_EXPANSION or EXPR_PACK_EXPANSION). Returns a\n    TREE_VEC with the substituted arguments, a PACK_EXPANSION_* node\n@@ -14050,6 +14252,15 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       gcc_assert (!uses_template_parms (t));\n       return t;\n \n+    case UNARY_LEFT_FOLD_EXPR:\n+      return tsubst_unary_left_fold (t, args, complain, in_decl);\n+    case UNARY_RIGHT_FOLD_EXPR:\n+      return tsubst_unary_right_fold (t, args, complain, in_decl);\n+    case BINARY_LEFT_FOLD_EXPR:\n+      return tsubst_binary_left_fold (t, args, complain, in_decl);\n+    case BINARY_RIGHT_FOLD_EXPR:\n+      return tsubst_binary_right_fold (t, args, complain, in_decl);\n+\n     default:\n       /* We shouldn't get here, but keep going if !ENABLE_CHECKING.  */\n       gcc_checking_assert (false);\n@@ -22052,6 +22263,13 @@ type_dependent_expression_p (tree expression)\n       || TREE_CODE (expression) == WILDCARD_DECL)\n     return true;\n \n+  /* A fold expression is type-dependent. */\n+  if (TREE_CODE (expression) == UNARY_LEFT_FOLD_EXPR\n+      || TREE_CODE (expression) == UNARY_RIGHT_FOLD_EXPR\n+      || TREE_CODE (expression) == BINARY_LEFT_FOLD_EXPR\n+      || TREE_CODE (expression) == BINARY_RIGHT_FOLD_EXPR)\n+    return true;\n+\n   /* Some expression forms are never type-dependent.  */\n   if (TREE_CODE (expression) == PSEUDO_DTOR_EXPR\n       || TREE_CODE (expression) == SIZEOF_EXPR"}, {"sha": "f5bb0c1beb4b31f94d6053c593dc7617108c6ed0", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -7763,4 +7763,73 @@ capture_decltype (tree decl)\n   return type;\n }\n \n+/* Build a unary fold expression of EXPR over OP. If IS_RIGHT is true,\n+   this is a right unary fold. Otherwise it is a left unary fold. */\n+\n+static tree\n+finish_unary_fold_expr (tree expr, int op, tree_code dir)\n+{\n+  // Build a pack expansion (assuming expr has pack type).\n+  if (!uses_parameter_packs (expr))\n+    {\n+      error_at (location_of (expr), \"operand of fold expression has no \"\n+\t\t\"unexpanded parameter packs\");\n+      return error_mark_node;\n+    }\n+  tree pack = make_pack_expansion (expr);\n+\n+  // Build the fold expression.\n+  tree code = build_int_cstu (integer_type_node, abs (op));\n+  tree fold = build_min (dir, unknown_type_node, code, pack);\n+  FOLD_EXPR_MODIFY_P (fold) = (op < 0);\n+  return fold;\n+}\n+\n+tree\n+finish_left_unary_fold_expr (tree expr, int op)\n+{\n+  return finish_unary_fold_expr (expr, op, UNARY_LEFT_FOLD_EXPR);\n+}\n+\n+tree\n+finish_right_unary_fold_expr (tree expr, int op)\n+{\n+  return finish_unary_fold_expr (expr, op, UNARY_RIGHT_FOLD_EXPR);\n+}\n+\n+/* Build a binary fold expression over EXPR1 and EXPR2. The\n+   associativity of the fold is determined by EXPR1 and EXPR2 (whichever\n+   has an unexpanded parameter pack). */\n+\n+tree\n+finish_binary_fold_expr (tree pack, tree init, int op, tree_code dir)\n+{\n+  pack = make_pack_expansion (pack);\n+  tree code = build_int_cstu (integer_type_node, abs (op));\n+  tree fold = build_min (dir, unknown_type_node, code, pack, init);\n+  FOLD_EXPR_MODIFY_P (fold) = (op < 0);\n+  return fold;\n+}\n+\n+tree\n+finish_binary_fold_expr (tree expr1, tree expr2, int op)\n+{\n+  // Determine which expr has an unexpanded parameter pack and\n+  // set the pack and initial term.\n+  bool pack1 = uses_parameter_packs (expr1);\n+  bool pack2 = uses_parameter_packs (expr2);\n+  if (pack1 && !pack2)\n+    return finish_binary_fold_expr (expr1, expr2, op, BINARY_RIGHT_FOLD_EXPR);\n+  else if (pack2 && !pack1)\n+    return finish_binary_fold_expr (expr2, expr1, op, BINARY_LEFT_FOLD_EXPR);\n+  else\n+    {\n+      if (pack1)\n+        error (\"both arguments in binary fold have unexpanded parameter packs\");\n+      else\n+        error (\"no unexpanded parameter packs in binary fold\");\n+    }\n+  return error_mark_node;\n+}\n+\n #include \"gt-cp-semantics.h\""}, {"sha": "3c33651ffd8cd647138aa184de5b96ba8269a263", "filename": "gcc/testsuite/g++.dg/cpp1z/fold1.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold1.C?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -0,0 +1,56 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+// Check the semantics of a couple of operations to make sure\n+// that the expressions are formed correctly.\n+\n+#define COMMA ,\n+\n+#define MAKE_FNS(name, op) \\\n+  template<typename... Ts> \\\n+    auto unary_left_ ## name (Ts... ts) { return (... op ts); } \\\n+  template<typename... Ts> \\\n+    auto unary_right_ ## name (Ts... ts) { return (ts op ...); } \\\n+  template<typename T, typename... Ts> \\\n+    auto binary_left_ ## name (T x, Ts... ts) { return (x op ... op ts); } \\\n+  template<typename T, typename... Ts> \\\n+    auto binary_right_ ## name (T x, Ts... ts) { return (ts op ... op x); }\n+\n+MAKE_FNS (add, +);\n+MAKE_FNS (sub, -);\n+\n+int main() {\n+  assert(unary_left_add() == 0);\n+  assert(unary_left_add(1) == 1);\n+  assert(unary_left_add(1, 2, 3) == 6);\n+\n+  assert(unary_right_add() == 0);\n+  assert(unary_right_add(1) == 1);\n+  assert(unary_right_add(1, 2, 3) == 6);\n+\n+  assert(binary_left_add(1) == 1);\n+  assert(binary_left_add(1, 1) == 2);\n+  assert(binary_left_add(1, 1, 2, 3) == 7);\n+\n+  assert(binary_right_add(1) == 1);\n+  assert(binary_right_add(1, 1) == 2);\n+  assert(binary_right_add(1, 1, 2, 3) == 7);\n+\n+  // unary_left_sub(); // { dg-error \"empty\"}\n+  assert(unary_left_sub(1) == 1);\n+  assert(unary_left_sub(1, 2, 3) == -4);\n+\n+  // unary_right_sub(); // { dg-error \"empty\"}\n+  assert(unary_right_sub(1) == 1);\n+  assert(unary_right_sub(1, 2, 3) == 2);\n+\n+  assert(binary_left_sub(1) == 1);\n+  assert(binary_left_sub(1, 1) == 0);\n+  assert(binary_left_sub(1, 1, 2, 3) == -5);\n+\n+  assert(binary_right_sub(1) == 1);\n+  assert(binary_right_sub(1, 1) == 0);\n+  assert(binary_right_sub(1, 1, 2, 3) == 1);\n+}"}, {"sha": "e42a39d889027c1181b08d4813f79432661965a0", "filename": "gcc/testsuite/g++.dg/cpp1z/fold2.C", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold2.C?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -0,0 +1,118 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check that we can fold over all of the operators required\n+// by the standard in every possible way.\n+\n+#define COMMA ,\n+\n+#define MAKE_FNS(name, op) \\\n+  template<typename... Ts> \\\n+    auto unary_left_ ## name (Ts... ts) { return (... op ts); } \\\n+  template<typename... Ts> \\\n+    auto unary_right_ ## name (Ts... ts) { return (ts op ...); } \\\n+  template<typename T, typename... Ts> \\\n+    auto binary_left_ ## name (T x, Ts... ts) { return (x op ... op ts); } \\\n+  template<typename T, typename... Ts> \\\n+    auto binary_right_ ## name (T x, Ts... ts) { return (ts op ... op x); }\n+\n+// TODO: These are compile-only tests...\n+#define CHECK_FN(name) \\\n+  unary_left_ ## name (a); \\\n+  unary_left_ ## name (a, b, c); \\\n+  unary_right_ ## name (a); \\\n+  unary_right_ ## name (a, b, c); \\\n+  binary_left_ ## name (a); \\\n+  binary_left_ ## name (a, b, c, d); \\\n+  binary_right_ ## name (d); \\\n+  binary_right_ ## name (d, a, b, c);\n+\n+MAKE_FNS (add, +);\n+MAKE_FNS (sub, -);\n+MAKE_FNS (mul, *);\n+MAKE_FNS (div, /);\n+MAKE_FNS (mod, %);\n+MAKE_FNS (bxor, ^);\n+MAKE_FNS (bor, |);\n+MAKE_FNS (band, &);\n+MAKE_FNS (lsh, <<);\n+MAKE_FNS (rsh, >>);\n+\n+MAKE_FNS (assign, =);\n+MAKE_FNS (addi, +=);\n+MAKE_FNS (subi, -=);\n+MAKE_FNS (muli, *=);\n+MAKE_FNS (divi, /=);\n+MAKE_FNS (modi, %=);\n+MAKE_FNS (bxori, ^=);\n+MAKE_FNS (bori, |=);\n+MAKE_FNS (bandi, &=);\n+MAKE_FNS (lshi, <<=);\n+MAKE_FNS (rshi, >>=);\n+\n+MAKE_FNS (eq, ==);\n+MAKE_FNS (ne, !=);\n+MAKE_FNS (lt, <);\n+MAKE_FNS (gt, >);\n+MAKE_FNS (le, <);\n+MAKE_FNS (ge, >);\n+\n+MAKE_FNS (land, &&);\n+MAKE_FNS (lor, ||);\n+\n+MAKE_FNS (comma, COMMA);\n+MAKE_FNS (dot_star, .*);\n+MAKE_FNS (arrow_star, ->*);\n+\n+int main() {\n+  int a = 0, b = 0, c = 0, d = 0;\n+\n+  CHECK_FN (add);\n+  CHECK_FN (sub);\n+  CHECK_FN (mul);\n+  CHECK_FN (div);\n+  CHECK_FN (mod);\n+  CHECK_FN (bxor);\n+  CHECK_FN (bor);\n+  CHECK_FN (band);\n+  CHECK_FN (lsh);\n+  CHECK_FN (rsh);\n+\n+  // CHECK_FN (assign);\n+  CHECK_FN (addi);\n+  CHECK_FN (subi);\n+  CHECK_FN (muli);\n+  CHECK_FN (divi);\n+  CHECK_FN (modi);\n+  CHECK_FN (bxori);\n+  CHECK_FN (bori);\n+  CHECK_FN (bandi);\n+  CHECK_FN (lshi);\n+  CHECK_FN (rshi);\n+\n+  CHECK_FN (eq);\n+  CHECK_FN (ne);\n+  CHECK_FN (lt);\n+  CHECK_FN (gt);\n+  CHECK_FN (le);\n+  CHECK_FN (ge);\n+  CHECK_FN (eq);\n+  CHECK_FN (ne);\n+\n+  CHECK_FN (comma);\n+\n+  struct X {\n+    int a;\n+  } x, *px = &x;\n+\n+  int X::* pm = &X::a;\n+  unary_left_arrow_star (px, pm); // px ->* pm\n+  unary_right_arrow_star (px, pm); // px ->* pm\n+  binary_left_arrow_star (px, pm); // px ->* pm\n+  binary_right_arrow_star (pm, px); // px ->* pm\n+\n+  unary_left_dot_star (x, pm); // x ->* pm\n+  unary_right_dot_star (x, pm); // x ->* pm\n+  binary_left_dot_star (x, pm); // x ->* pm\n+  binary_right_dot_star (pm, x); // x ->* pm\n+}"}, {"sha": "307818f55c81521caf99887f9038dd8013f01d6f", "filename": "gcc/testsuite/g++.dg/cpp1z/fold3.C", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold3.C?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -0,0 +1,85 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check that empty expansions and required failures.\n+\n+#define COMMA ,\n+\n+#define MAKE_FN(name, op) \\\n+  template<typename... Ts> \\\n+    constexpr auto name (Ts... ts) { return (... op ts); } // { dg-error \"empty\" }\n+\n+MAKE_FN (add, +);\n+MAKE_FN (sub, -);\n+MAKE_FN (mul, *);\n+MAKE_FN (div, /);\n+MAKE_FN (mod, %);\n+MAKE_FN (bxor, ^);\n+MAKE_FN (bor, |);\n+MAKE_FN (band, &);\n+MAKE_FN (lsh, <<);\n+MAKE_FN (rsh, >>);\n+\n+MAKE_FN (assign, =);\n+MAKE_FN (addi, +=);\n+MAKE_FN (subi, -=);\n+MAKE_FN (muli, *=);\n+MAKE_FN (divi, /=);\n+MAKE_FN (modi, %=);\n+MAKE_FN (bxori, ^=);\n+MAKE_FN (bori, |=);\n+MAKE_FN (bandi, &=);\n+MAKE_FN (lshi, <<=);\n+MAKE_FN (rshi, >>=);\n+\n+MAKE_FN (eq, ==);\n+MAKE_FN (ne, !=);\n+MAKE_FN (lt, <);\n+MAKE_FN (gt, >);\n+MAKE_FN (le, <);\n+MAKE_FN (ge, >);\n+\n+MAKE_FN (land, &&);\n+MAKE_FN (lor, ||);\n+\n+MAKE_FN (comma, COMMA);\n+MAKE_FN (dot_star, .*);\n+MAKE_FN (arrow_star, ->*);\n+\n+int main() {\n+  static_assert(add() == int(), \"\");\n+  static_assert(mul() == 1, \"\");\n+  static_assert(bor() == int(), \"\");\n+  static_assert(band() == -1, \"\");\n+  static_assert(land() == true, \"\");\n+  static_assert(lor() == false, \"\");\n+  comma(); // No value to theck\n+\n+  // These are all errors, but the error is emitted at the point\n+  // of instantiation (line 10).\n+  sub();\t\t\t// { dg-message \"required from here\" }\n+  div();\t\t\t// { dg-message \"required from here\" }\n+  mod();\t\t\t// { dg-message \"required from here\" }\n+  lsh();\t\t\t// { dg-message \"required from here\" }\n+  rsh();\t\t\t// { dg-message \"required from here\" }\n+  assign();\t\t\t// { dg-message \"required from here\" }\n+  addi();\t\t\t// { dg-message \"required from here\" }\n+  subi();\t\t\t// { dg-message \"required from here\" }\n+  muli();\t\t\t// { dg-message \"required from here\" }\n+  divi();\t\t\t// { dg-message \"required from here\" }\n+  modi();\t\t\t// { dg-message \"required from here\" }\n+  bxor();\t\t\t// { dg-message \"required from here\" }\n+  bxori();\t\t\t// { dg-message \"required from here\" }\n+  bori();\t\t\t// { dg-message \"required from here\" }\n+  bandi();\t\t\t// { dg-message \"required from here\" }\n+  lshi();\t\t\t// { dg-message \"required from here\" }\n+  rshi();\t\t\t// { dg-message \"required from here\" }\n+  eq();\t\t\t\t// { dg-message \"required from here\" }\n+  ne();\t\t\t\t// { dg-message \"required from here\" }\n+  lt();\t\t\t\t// { dg-message \"required from here\" }\n+  gt();\t\t\t\t// { dg-message \"required from here\" }\n+  le();\t\t\t\t// { dg-message \"required from here\" }\n+  ge();\t\t\t\t// { dg-message \"required from here\" }\n+  dot_star();\t\t\t// { dg-message \"required from here\" }\n+  arrow_star();\t\t\t// { dg-message \"required from here\" }\n+}"}, {"sha": "fbe672079b434ebcf923d32382b34cd22fde6747", "filename": "gcc/testsuite/g++.dg/cpp1z/fold4.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold4.C?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++1z }\n+\n+template <class...T>\n+constexpr auto f(T... t)\n+{\n+  return (... + *t);\n+}\n+\n+const int i = 42, j = 24;\n+static_assert (f(&i,&j) == i+j);"}, {"sha": "0721419adb48ad11d2d588ca82ec91813c0a7e89", "filename": "gcc/testsuite/g++.dg/cpp1z/fold5.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/378b307d0d7e789c69570cba4a9388b781c3f062/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold5.C?ref=378b307d0d7e789c69570cba4a9388b781c3f062", "patch": "@@ -0,0 +1,8 @@\n+// Test that we complain about fold-expressions in C++11 and C++14.\n+// { dg-do compile { target c++11 } }\n+\n+template <class...T>\n+constexpr int f(T... t)\n+{\n+  return (... + t);\t\t// { dg-error \"fold\" }\n+}"}]}