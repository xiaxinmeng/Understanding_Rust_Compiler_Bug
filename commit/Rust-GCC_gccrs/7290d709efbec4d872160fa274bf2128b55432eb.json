{"sha": "7290d709efbec4d872160fa274bf2128b55432eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5MGQ3MDllZmJlYzRkODcyMTYwZmEyNzRiZjIxMjhiNTU0MzJlYg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2006-12-10T21:25:40Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2006-12-10T21:25:40Z"}, "message": "New out of ssa Coalescer.\n\n2006-12-10  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* common.opt (-ftree-lrs): Remove live range splitting option.\n\t* makefile.in: Add tree-ssa-coalesce.o and reduce header dependancies.\n\t* opts.c (decode_options): Remove flag_tree_live_range_split.\n\t* tree-flow.h (struct var_ann_d): Rename fields from root_ to base_.\n\t* tree-flow-inline.h (single_imm_use_p): New.  Check for single use.\n\t* tree-outof-ssa.c: Remove header files which aren't needed.\n\t(SSANORM_*): Remove flags.\n\t(print_exprs_edge, coalesce_abnormal_edges, coalesce_phi_operands, \n\tcoalesce_result_decls_and_copies, coalesce_asm_operands): Remove.\n\t(coalesce_ssa_name): Move to tree-ssa-coalesce.c.\n\t(assign_vars): Use Basevar instead of root_var structure.\n\t(replace_def_variable): Dont do anything if def is replaceable.\n\t(remove_ssa_form): Integrate functional changes.\n\t(rewrite_out_of_ssa): Remove live-range_split option.\n\t* tree-ssa-coalesce.c: New File for ssa-name coalescing.\n\t(coalesce_cost): Calculate the cost of a coalesce.\n\t(coalesce_cost_bb): Calculate the coalesce cost within a BB.\n\t(coalesce_cost_edge): Calculate the coalesce cost on an edge.\n\t(pop_cost_one_pair): Remove the best coalesce with cost 1 from the list.\n\t(pop_best_coalesce): Remove the best coalesce from the list.\n\t(coalesce_pair_map_hash): Calculate coalesce pair hash.\n\t(coalesce_pair_map_eq): Compare 2 coalesce pairs for hash function.\n\t(create_coalesce_list): Create a coalesce list object.\n\t(delete_coalesce_list): Free a coalesce list object.\n\t(find_coalesce_pair): Find matching pair in the coalesce list.\n\t(add_cost_one_coalesce): Add a coalesce to the \"cost one\" list.\n\t(add_coalesce): Add a coalesce to the coalesce list.\n\t(compare_pairs): Comparision function to determine pair sorted order.\n\t(num_coalesce_pairs): Number of coalesced pairs.\n\t(first_coalesce_pair, end_coalesce_pair_p, next_coalesce_pair):\n\tCoalesce pair iterator functions.\n\t(sort_coalesce_list): Sort coalesce pairs in order of expense.\n\t(dump_coalesce_list): Show coalesce list.\n\t(ssa_conflicts_new): Create an SSA conflict graph.\n\t(ssa_conflicts_delete): Delete an SSA conflict graph.\n\t(ssa_conflicts_test_p): Test for conflicts.\n\t(ssa_conflicts_add_one): Add a single conflict.\n\t(ssa_conflicts_add): Add a conflict pair.\n\t(ssa_conflicts_merge): Merge conflicts.\n\t(struct live_track_d): Struct for tracking live partitions.\n\t(new_live_track): Create new live_track object.\n\t(delete_live_track): Delete a live_track object.\n\t(live_track_remove_partition): Remove a partition from the live list.\n\t(live_track_add_partition): Add a partition from the live list.\n\t(live_track_clear_var): Take VAR from the live list.\n\t(live_track_live_p): Is var live?\n\t(live_track_process_use): Make var come alive.\n\t(live_track_process_def): Make var go dead, add conflicts.\n\t(live_track_init): Initialize to a live on exit set.\n\t(live_track_clear_base_vars): Clear live partitions.\n\t(build_ssa_conflict_graph): Build a conflict graph.\n\t(print_exprs): Common debug output routine.\n\t(abnormal_corrupt): Output info about a failed coalesce across an\n\tabnormal edge.\n\t(fail_abnormal_edge_coalesce): Output info about a failed MUST_COALESCE.\n\t(create_outofssa_var_map): Create a var map and coalesce list.\n\t(attempt_coalesce): Coalesce a pair.\n\t(coalesce_partitions): Coalesce all pairs in a coalesce list.\n\t(coalesce_ssa_name): Entry point.  Determine what ssa_names to coalesce.\n\t* tree-ssa-live.c: Remove header files which aren't needed.\n\t(var_map_base_init): New.  Initialize a basevar list.\n\t(var_map_base_fini): New.  Finish a basevar list.\n\t(init_var_map): Initialize new fields.\n\t(delete_var_map): Free new fields.\n\t(var_union): Use renamed fields.\n\t(compact_var_map): Remove.\n\t(partition_to_view_init): Use renamed fields, change order of an if.\n\t(partition_view_fini): Use renamed fields.\n\t(partition_view_normal): Create basevar list if requested.\n\t(partition_view_bitmap): Create a view based on a bitmap of partitions.\n\t(change_partition_var): Use renamed fields.\n\t(create_ssa_var_map): Remove.\n\t(tpa_init, tpa_remove_partition, tpa_delete, tpa_compact,\n\troot_var_init): Remove.\n\t(partition_pair_map_hash, partition_pair_map_eq, create_coalesce_list,\n\tdelete_coalesce_list, find_partition_pair, coalesce_cost, add_coalesce,\n\tcompare_pairs, num_coalesce_pairs, first_partition_pair,\n\tend_partition_pair_p, next_partition_pair, sort_coalesce_list,\n\tpop_best_coalesce, add_conflicts_if_valid, set_if_valid,\n\tbuild_tree_conflict_graph, coalesce_tpa_members, dump_coalesce_list,\n\ttpa_dump): Moved to tree-ssa-coalesce.c and/or renamed there.\n\t(dump_var_map): Use renamed fields.\n\t* tree-ssa-live.h (struct  _var_map): Modify fields.\n\t(partition_to_var, version_to_var, var_to_partition): Use renamed \n\tfields.\n\t(basevar_index): New.  Index of the base variable of a partition.\n\t(num_basevars): New.  Number of unique base variables in partition map.\n\t(register_ssa_partition): Use renamed fields.\n\t(struct tree_partition_associator_d): Remove.\n\t(tpa_num_trees, tpa_tree, tpa_first_partition, tpa_next_partition,\n\ttpa_find_tree, tpa_decompact, root_var_init, root_var_num,\n\troot_var, root_var_first_partition, root_var_next_partition,\n\troot_var_dump, root_var_delete, root_var_remove_partition, \n\troot_var_find, root_var_compact, root_var_decompact): Remove.\n\t(struct partition_pair, struct coalesce_list_d): Moved to \n\ttree-ssa-coalesce.c\n\t* tree-ssa-ter.c: Remove header files which aren't needed.\n\nFrom-SVN: r119711", "tree": {"sha": "02feab0e9ac8689b190a759c435c1c7653207328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02feab0e9ac8689b190a759c435c1c7653207328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7290d709efbec4d872160fa274bf2128b55432eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7290d709efbec4d872160fa274bf2128b55432eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7290d709efbec4d872160fa274bf2128b55432eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7290d709efbec4d872160fa274bf2128b55432eb/comments", "author": null, "committer": null, "parents": [{"sha": "669353d549aedd17bc36ca74bc30d28d21e7795f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/669353d549aedd17bc36ca74bc30d28d21e7795f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/669353d549aedd17bc36ca74bc30d28d21e7795f"}], "stats": {"total": 3894, "additions": 1851, "deletions": 2043}, "files": [{"sha": "60ff40a5e8257026fbbe2f85e4489b43130582b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -1,3 +1,103 @@\n+2006-12-10  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* common.opt (-ftree-lrs): Remove live range splitting option.\n+\t* makefile.in: Add tree-ssa-coalesce.o and reduce header dependancies.\n+\t* opts.c (decode_options): Remove flag_tree_live_range_split.\n+\t* tree-flow.h (struct var_ann_d): Rename fields from root_ to base_.\n+\t* tree-flow-inline.h (single_imm_use_p): New.  Check for single use.\n+\t* tree-outof-ssa.c: Remove header files which aren't needed.\n+\t(SSANORM_*): Remove flags.\n+\t(print_exprs_edge, coalesce_abnormal_edges, coalesce_phi_operands, \n+\tcoalesce_result_decls_and_copies, coalesce_asm_operands): Remove.\n+\t(coalesce_ssa_name): Move to tree-ssa-coalesce.c.\n+\t(assign_vars): Use Basevar instead of root_var structure.\n+\t(replace_def_variable): Dont do anything if def is replaceable.\n+\t(remove_ssa_form): Integrate functional changes.\n+\t(rewrite_out_of_ssa): Remove live-range_split option.\n+\t* tree-ssa-coalesce.c: New File for ssa-name coalescing.\n+\t(coalesce_cost): Calculate the cost of a coalesce.\n+\t(coalesce_cost_bb): Calculate the coalesce cost within a BB.\n+\t(coalesce_cost_edge): Calculate the coalesce cost on an edge.\n+\t(pop_cost_one_pair): Remove the best coalesce with cost 1 from the list.\n+\t(pop_best_coalesce): Remove the best coalesce from the list.\n+\t(coalesce_pair_map_hash): Calculate coalesce pair hash.\n+\t(coalesce_pair_map_eq): Compare 2 coalesce pairs for hash function.\n+\t(create_coalesce_list): Create a coalesce list object.\n+\t(delete_coalesce_list): Free a coalesce list object.\n+\t(find_coalesce_pair): Find matching pair in the coalesce list.\n+\t(add_cost_one_coalesce): Add a coalesce to the \"cost one\" list.\n+\t(add_coalesce): Add a coalesce to the coalesce list.\n+\t(compare_pairs): Comparision function to determine pair sorted order.\n+\t(num_coalesce_pairs): Number of coalesced pairs.\n+\t(first_coalesce_pair, end_coalesce_pair_p, next_coalesce_pair):\n+\tCoalesce pair iterator functions.\n+\t(sort_coalesce_list): Sort coalesce pairs in order of expense.\n+\t(dump_coalesce_list): Show coalesce list.\n+\t(ssa_conflicts_new): Create an SSA conflict graph.\n+\t(ssa_conflicts_delete): Delete an SSA conflict graph.\n+\t(ssa_conflicts_test_p): Test for conflicts.\n+\t(ssa_conflicts_add_one): Add a single conflict.\n+\t(ssa_conflicts_add): Add a conflict pair.\n+\t(ssa_conflicts_merge): Merge conflicts.\n+\t(struct live_track_d): Struct for tracking live partitions.\n+\t(new_live_track): Create new live_track object.\n+\t(delete_live_track): Delete a live_track object.\n+\t(live_track_remove_partition): Remove a partition from the live list.\n+\t(live_track_add_partition): Add a partition from the live list.\n+\t(live_track_clear_var): Take VAR from the live list.\n+\t(live_track_live_p): Is var live?\n+\t(live_track_process_use): Make var come alive.\n+\t(live_track_process_def): Make var go dead, add conflicts.\n+\t(live_track_init): Initialize to a live on exit set.\n+\t(live_track_clear_base_vars): Clear live partitions.\n+\t(build_ssa_conflict_graph): Build a conflict graph.\n+\t(print_exprs): Common debug output routine.\n+\t(abnormal_corrupt): Output info about a failed coalesce across an\n+\tabnormal edge.\n+\t(fail_abnormal_edge_coalesce): Output info about a failed MUST_COALESCE.\n+\t(create_outofssa_var_map): Create a var map and coalesce list.\n+\t(attempt_coalesce): Coalesce a pair.\n+\t(coalesce_partitions): Coalesce all pairs in a coalesce list.\n+\t(coalesce_ssa_name): Entry point.  Determine what ssa_names to coalesce.\n+\t* tree-ssa-live.c: Remove header files which aren't needed.\n+\t(var_map_base_init): New.  Initialize a basevar list.\n+\t(var_map_base_fini): New.  Finish a basevar list.\n+\t(init_var_map): Initialize new fields.\n+\t(delete_var_map): Free new fields.\n+\t(var_union): Use renamed fields.\n+\t(compact_var_map): Remove.\n+\t(partition_to_view_init): Use renamed fields, change order of an if.\n+\t(partition_view_fini): Use renamed fields.\n+\t(partition_view_normal): Create basevar list if requested.\n+\t(partition_view_bitmap): Create a view based on a bitmap of partitions.\n+\t(change_partition_var): Use renamed fields.\n+\t(create_ssa_var_map): Remove.\n+\t(tpa_init, tpa_remove_partition, tpa_delete, tpa_compact,\n+\troot_var_init): Remove.\n+\t(partition_pair_map_hash, partition_pair_map_eq, create_coalesce_list,\n+\tdelete_coalesce_list, find_partition_pair, coalesce_cost, add_coalesce,\n+\tcompare_pairs, num_coalesce_pairs, first_partition_pair,\n+\tend_partition_pair_p, next_partition_pair, sort_coalesce_list,\n+\tpop_best_coalesce, add_conflicts_if_valid, set_if_valid,\n+\tbuild_tree_conflict_graph, coalesce_tpa_members, dump_coalesce_list,\n+\ttpa_dump): Moved to tree-ssa-coalesce.c and/or renamed there.\n+\t(dump_var_map): Use renamed fields.\n+\t* tree-ssa-live.h (struct  _var_map): Modify fields.\n+\t(partition_to_var, version_to_var, var_to_partition): Use renamed \n+\tfields.\n+\t(basevar_index): New.  Index of the base variable of a partition.\n+\t(num_basevars): New.  Number of unique base variables in partition map.\n+\t(register_ssa_partition): Use renamed fields.\n+\t(struct tree_partition_associator_d): Remove.\n+\t(tpa_num_trees, tpa_tree, tpa_first_partition, tpa_next_partition,\n+\ttpa_find_tree, tpa_decompact, root_var_init, root_var_num,\n+\troot_var, root_var_first_partition, root_var_next_partition,\n+\troot_var_dump, root_var_delete, root_var_remove_partition, \n+\troot_var_find, root_var_compact, root_var_decompact): Remove.\n+\t(struct partition_pair, struct coalesce_list_d): Moved to \n+\ttree-ssa-coalesce.c\n+\t* tree-ssa-ter.c: Remove header files which aren't needed.\n+\n 2006-12-10  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cse.c: (struct cse_basic_block_data): Remove LAST field."}, {"sha": "8da131d5ee0c6d3ce07db317f4de23872e0d1101", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -985,7 +985,7 @@ OBJS-common = \\\n  tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o\t\t   \\\n  tree-ssa-loop-manip.o tree-ssa-threadupdate.o tree-ssa-threadedge.o\t   \\\n  tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o\t\t   \\\n- tree-vect-patterns.o tree-ssa-loop-prefetch.o\t\t\t\t   \\\n+ tree-vect-patterns.o tree-ssa-loop-prefetch.o tree-ssa-coalesce.o\t   \\\n  tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-address.o\t   \\\n  tree-ssa-math-opts.o\t\t\t\t\t\t\t   \\\n  tree-ssa-loop-ivopts.o tree-if-conv.o tree-ssa-loop-unswitch.o\t\t   \\\n@@ -1851,17 +1851,14 @@ tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    bitmap.h $(CFGLOOP_H) $(FLAGS_H) hard-reg-set.h $(HASHTAB_H) \\\n    $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) vecprim.h\n tree-ssa-ter.o : tree-ssa-ter.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n-   $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   langhooks.h tree-pass.h $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) bitmap.h \\\n-   $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n-   $(TREE_INLINE_H) $(VARRAY_H) toplev.h vecprim.h\n+   $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(TREE_SSA_LIVE_H) bitmap.h \n+tree-ssa-coalesce.o : tree-ssa-coalesce.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(TREE_SSA_LIVE_H) bitmap.h $(FLAGS_H) $(HASHTAB_H) toplev.h \n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n-   $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   langhooks.h tree-pass.h $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) bitmap.h \\\n-   $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n-   $(TREE_INLINE_H) $(VARRAY_H) toplev.h vecprim.h\n+   $(TREE_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) bitmap.h $(GGC_H) toplev.h \n tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) domwalk.h $(FLAGS_H) \\\n@@ -1913,10 +1910,8 @@ tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) domwalk.h $(GGC_H)\n tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   $(TREE_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) \\\n-   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) \\\n-   bitmap.h $(FLAGS_H) $(HASHTAB_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) \\\n-   $(VARRAY_H) toplev.h vecprim.h\n+   $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(TREE_SSA_LIVE_H) bitmap.h toplev.h \n tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) tree-pass.h \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) \\"}, {"sha": "7ec6f4723cd4c7618af7b7c73d7dda1307d48121", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -1003,10 +1003,6 @@ ftree-ter\n Common Report Var(flag_tree_ter)\n Replace temporary expressions in the SSA->normal pass\n \n-ftree-lrs\n-Common Report Var(flag_tree_live_range_split)\n-Perform live range splitting during the SSA->normal pass\n-\n ftree-vrp\n Common Report Var(flag_tree_vrp) Init(0)\n Perform Value Range Propagation on trees"}, {"sha": "b31d67d94a617d3cde44e2f04cf4d31e019fe657", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -449,7 +449,6 @@ decode_options (unsigned int argc, const char **argv)\n       flag_tree_dom = 1;\n       flag_tree_dse = 1;\n       flag_tree_ter = 1;\n-      flag_tree_live_range_split = 1;\n       flag_tree_sra = 1;\n       flag_tree_copyrename = 1;\n       flag_tree_fre = 1;"}, {"sha": "bc4c3946335b3ed4d292c03cfea1fc26bb545358", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -541,6 +541,18 @@ has_single_use (tree var)\n   return (ptr != ptr->next && ptr == ptr->next->next);\n }\n \n+\n+/* If VAR has only a single immediate use, return true.  */\n+static inline bool\n+single_imm_use_p (tree var)\n+{\n+  ssa_use_operand_t *ptr;\n+\n+  ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  return (ptr != ptr->next && ptr == ptr->next->next);\n+}\n+\n+\n /* If VAR has only a single immediate use, return true, and set USE_P and STMT\n    to the use pointer and stmt of occurrence.  */\n static inline bool"}, {"sha": "bb6b4ae2113a998941332ceb7d2e8b65899d7e06", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -218,8 +218,8 @@ struct var_ann_d GTY(())\n      been seen yet or not.  */\n   unsigned out_of_ssa_tag : 1;\n \n-  /* Used when building root_var structures in tree_ssa_live.[ch].  */\n-  unsigned root_var_processed : 1;\n+  /* Used when building base variable structures in a var_map.  */\n+  unsigned base_var_processed : 1;\n \n   /* Nonzero if this variable is in the alias set of another variable.  */\n   unsigned is_aliased : 1;\n@@ -257,8 +257,8 @@ struct var_ann_d GTY(())\n      variable represents storage for.  */\n   unsigned partition;\n \n-  /* Used by the root-var object in tree-ssa-live.[ch].  */\n-  unsigned root_index;\n+  /* Used by var_map for the base index of ssa base variables.  */\n+  unsigned base_index;\n \n   /* During into-ssa and the dominator optimizer, this field holds the\n      current version of this variable (an SSA_NAME).  */"}, {"sha": "f591eb5ed97fa7fd7fbf0ad3c633f784b2a9239b", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 52, "deletions": 549, "changes": 601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -1,5 +1,5 @@\n /* Convert a program in SSA form into Normal form.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Andrew Macleod <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -24,34 +24,17 @@ Boston, MA 02110-1301, USA.  */\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n-#include \"flags.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n #include \"ggc.h\"\n-#include \"langhooks.h\"\n-#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n-#include \"output.h\"\n-#include \"expr.h\"\n-#include \"function.h\"\n #include \"diagnostic.h\"\n #include \"bitmap.h\"\n #include \"tree-flow.h\"\n-#include \"tree-gimple.h\"\n-#include \"tree-inline.h\"\n-#include \"varray.h\"\n #include \"timevar.h\"\n-#include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\"\n #include \"tree-pass.h\"\n #include \"toplev.h\"\n-#include \"vecprim.h\"\n \n-/* Flags to pass to remove_ssa_form.  */\n-\n-#define SSANORM_PERFORM_TER\t\t0x1\n-#define SSANORM_COALESCE_PARTITIONS\t0x4\n \n /* Used to hold all the components required to do SSA PHI elimination.\n    The node and pred/succ list is a simple linear list of nodes and\n@@ -101,36 +84,6 @@ typedef struct _elim_graph {\n } *elim_graph;\n \n \n-/* Local functions.  */\n-static tree create_temp (tree);\n-static void insert_copy_on_edge (edge, tree, tree);\n-static elim_graph new_elim_graph (int);\n-static inline void delete_elim_graph (elim_graph);\n-static inline void clear_elim_graph (elim_graph);\n-static inline int elim_graph_size (elim_graph);\n-static inline void elim_graph_add_node (elim_graph, tree);\n-static inline void elim_graph_add_edge (elim_graph, int, int);\n-static inline int elim_graph_remove_succ_edge (elim_graph, int);\n-\n-static inline void eliminate_name (elim_graph, tree);\n-static void eliminate_build (elim_graph, basic_block);\n-static void elim_forward (elim_graph, int);\n-static int elim_unvisited_predecessor (elim_graph, int);\n-static void elim_backward (elim_graph, int);\n-static void elim_create (elim_graph, int);\n-static void eliminate_phi (edge, elim_graph);\n-static tree_live_info_p coalesce_ssa_name (var_map, int);\n-static void assign_vars (var_map);\n-static bool replace_use_variable (var_map, use_operand_p, tree *);\n-static bool replace_def_variable (var_map, def_operand_p, tree *);\n-static void eliminate_virtual_phis (void);\n-static void coalesce_abnormal_edges (var_map, conflict_graph, root_var_p);\n-static void print_exprs (FILE *, const char *, tree, const char *, tree,\n-\t\t\t const char *);\n-static void print_exprs_edge (FILE *, edge, const char *, tree, const char *,\n-\t\t\t      tree);\n-\n-\n /* Create a temporary variable based on the type of variable T.  Use T's name\n    as the prefix.  */\n \n@@ -489,6 +442,7 @@ elim_create (elim_graph g, int T)\n   \n }\n \n+\n /* Eliminate all the phi nodes on edge E in graph G.  */\n \n static void\n@@ -541,471 +495,51 @@ eliminate_phi (edge e, elim_graph g)\n }\n \n \n-/* Shortcut routine to print messages to file F of the form:\n-   \"STR1 EXPR1 STR2 EXPR2 STR3.\"  */\n-\n-static void\n-print_exprs (FILE *f, const char *str1, tree expr1, const char *str2,\n-\t     tree expr2, const char *str3)\n-{\n-  fprintf (f, \"%s\", str1);\n-  print_generic_expr (f, expr1, TDF_SLIM);\n-  fprintf (f, \"%s\", str2);\n-  print_generic_expr (f, expr2, TDF_SLIM);\n-  fprintf (f, \"%s\", str3);\n-}\n-\n-\n-/* Shortcut routine to print abnormal edge messages to file F of the form:\n-   \"STR1 EXPR1 STR2 EXPR2 across edge E.  */\n-\n-static void\n-print_exprs_edge (FILE *f, edge e, const char *str1, tree expr1, \n-\t\t  const char *str2, tree expr2)\n-{\n-  print_exprs (f, str1, expr1, str2, expr2, \" across an abnormal edge\");\n-  fprintf (f, \" from BB%d->BB%d\\n\", e->src->index,\n-\t       e->dest->index);\n-}\n-\n-\n-/* Coalesce partitions in MAP which are live across abnormal edges in GRAPH.\n-   RV is the root variable groupings of the partitions in MAP.  Since code \n-   cannot be inserted on these edges, failure to coalesce something across\n-   an abnormal edge is an error.  */\n-\n-static void\n-coalesce_abnormal_edges (var_map map, conflict_graph graph, root_var_p rv)\n-{\n-  basic_block bb;\n-  edge e;\n-  tree phi, var, tmp;\n-  int x, y, z;\n-  edge_iterator ei;\n-\n-  /* Code cannot be inserted on abnormal edges. Look for all abnormal \n-     edges, and coalesce any PHI results with their arguments across \n-     that edge.  */\n-\n-  FOR_EACH_BB (bb)\n-    FOR_EACH_EDGE (e, ei, bb->succs)\n-      if (e->dest != EXIT_BLOCK_PTR && e->flags & EDGE_ABNORMAL)\n-\tfor (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t  {\n-\t    /* Visit each PHI on the destination side of this abnormal\n-\t       edge, and attempt to coalesce the argument with the result.  */\n-\t    var = PHI_RESULT (phi);\n-\t    x = var_to_partition (map, var);\n-\n-\t    /* Ignore results which are not relevant.  */\n-\t    if (x == NO_PARTITION)\n-\t      continue;\n-\n-\t    tmp = PHI_ARG_DEF (phi, e->dest_idx);\n-#ifdef ENABLE_CHECKING\n-\t    if (!phi_ssa_name_p (tmp))\n-\t      {\n-\t        print_exprs_edge (stderr, e,\n-\t\t\t\t  \"\\nConstant argument in PHI. Can't insert :\",\n-\t\t\t\t  var, \" = \", tmp);\n-\t\tinternal_error (\"SSA corruption\");\n-\t      }\n-#else\n-\t    gcc_assert (phi_ssa_name_p (tmp));\n-#endif\n-\t    y = var_to_partition (map, tmp);\n-\t    gcc_assert (x != NO_PARTITION);\n-\t    gcc_assert (y != NO_PARTITION);\n-#ifdef ENABLE_CHECKING\n-\t    if (root_var_find (rv, x) != root_var_find (rv, y))\n-\t      {\n-\t\tprint_exprs_edge (stderr, e, \"\\nDifferent root vars: \",\n-\t\t\t\t  root_var (rv, root_var_find (rv, x)), \n-\t\t\t\t  \" and \", \n-\t\t\t\t  root_var (rv, root_var_find (rv, y)));\n-\t\tinternal_error (\"SSA corruption\");\n-\t      }\n-#else\n-\t    gcc_assert (root_var_find (rv, x) == root_var_find (rv, y));\n-#endif\n-\n-\t    if (x != y)\n-\t      {\n-#ifdef ENABLE_CHECKING\n-\t\tif (conflict_graph_conflict_p (graph, x, y))\n-\t\t  {\n-\t\t    print_exprs_edge (stderr, e, \"\\n Conflict \", \n-\t\t\t\t      partition_to_var (map, x),\n-\t\t\t\t      \" and \", partition_to_var (map, y));\n-\t\t    internal_error (\"SSA corruption\");\n-\t\t  }\n-#else\n-\t\tgcc_assert (!conflict_graph_conflict_p (graph, x, y));\n-#endif\n-\t\t\n-\t\t/* Now map the partitions back to their real variables.  */\n-\t\tvar = partition_to_var (map, x);\n-\t\ttmp = partition_to_var (map, y);\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  {\n-\t\t    print_exprs_edge (dump_file, e, \n-\t\t\t\t      \"ABNORMAL: Coalescing \",\n-\t\t\t\t      var, \" and \", tmp);\n-\t\t  }\n-\t        z = var_union (map, var, tmp);\n-#ifdef ENABLE_CHECKING\n-\t\tif (z == NO_PARTITION)\n-\t\t  {\n-\t\t    print_exprs_edge (stderr, e, \"\\nUnable to coalesce\", \n-\t\t\t\t      partition_to_var (map, x), \" and \", \n-\t\t\t\t      partition_to_var (map, y));\n-\t\t    internal_error (\"SSA corruption\");\n-\t\t  }\n-#else\n-\t\tgcc_assert (z != NO_PARTITION);\n-#endif\n-\t\tgcc_assert (z == x || z == y);\n-\t\tif (z == x)\n-\t\t  conflict_graph_merge_regs (graph, x, y);\n-\t\telse\n-\t\t  conflict_graph_merge_regs (graph, y, x);\n-\t      }\n-\t  }\n-}\n-\n-/* Coalesce potential copies via PHI arguments.  */\n-\n-static void\n-coalesce_phi_operands (var_map map, coalesce_list_p cl)\n-{\n-  basic_block bb;\n-  tree phi;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  tree res = PHI_RESULT (phi);\n-\t  int p = var_to_partition (map, res);\n-\t  int x;\n-\n-\t  if (p == NO_PARTITION)\n-\t    continue;\n-\n-\t  for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n-\t    {\n-\t      tree arg = PHI_ARG_DEF (phi, x);\n-\t      int p2;\n-\n-\t      if (TREE_CODE (arg) != SSA_NAME)\n-\t\tcontinue;\n-\t      if (SSA_NAME_VAR (res) != SSA_NAME_VAR (arg))\n-\t\tcontinue;\n-\t      p2 = var_to_partition (map, PHI_ARG_DEF (phi, x));\n-\t      if (p2 != NO_PARTITION)\n-\t\t{\n-\t\t  edge e = PHI_ARG_EDGE (phi, x);\n-\t\t  add_coalesce (cl, p, p2,\n-\t\t\t\tcoalesce_cost (EDGE_FREQUENCY (e),\n-\t\t\t\t\t       maybe_hot_bb_p (bb),\n-\t\t\t\t\t       EDGE_CRITICAL_P (e)));\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Coalesce all the result decls together.  */\n-\n-static void\n-coalesce_result_decls (var_map map, coalesce_list_p cl)\n-{\n-  unsigned int i, x;\n-  tree var = NULL;\n-\n-  for (i = x = 0; x < num_var_partitions (map); x++)\n-    {\n-      tree p = partition_to_var (map, x);\n-      if (TREE_CODE (SSA_NAME_VAR (p)) == RESULT_DECL)\n-\t{\n-\t  if (var == NULL_TREE)\n-\t    {\n-\t      var = p;\n-\t      i = x;\n-\t    }\n-\t  else\n-\t    add_coalesce (cl, i, x,\n-\t\t\t  coalesce_cost (EXIT_BLOCK_PTR->frequency,\n-\t\t\t\t\t maybe_hot_bb_p (EXIT_BLOCK_PTR),\n-\t\t\t\t\t false));\n-\t}\n-    }\n-}\n-\n-/* Coalesce matching constraints in asms.  */\n-\n-static void\n-coalesce_asm_operands (var_map map, coalesce_list_p cl)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator bsi;\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  tree stmt = bsi_stmt (bsi);\n-\t  unsigned long noutputs, i;\n-\t  tree *outputs, link;\n-\n-\t  if (TREE_CODE (stmt) != ASM_EXPR)\n-\t    continue;\n-\n-\t  noutputs = list_length (ASM_OUTPUTS (stmt));\n-\t  outputs = (tree *) alloca (noutputs * sizeof (tree));\n-\t  for (i = 0, link = ASM_OUTPUTS (stmt); link;\n-\t       ++i, link = TREE_CHAIN (link))\n-\t    outputs[i] = TREE_VALUE (link);\n-\n-\t  for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n-\t    {\n-\t      const char *constraint\n-\t\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n-\t      tree input = TREE_VALUE (link);\n-\t      char *end;\n-\t      unsigned long match;\n-\t      int p1, p2;\n-\n-\t      if (TREE_CODE (input) != SSA_NAME && !DECL_P (input))\n-\t\tcontinue;\n-\n-\t      match = strtoul (constraint, &end, 10);\n-\t      if (match >= noutputs || end == constraint)\n-\t\tcontinue;\n-\n-\t      if (TREE_CODE (outputs[match]) != SSA_NAME\n-\t\t  && !DECL_P (outputs[match]))\n-\t\tcontinue;\n-\n-\t      p1 = var_to_partition (map, outputs[match]);\n-\t      if (p1 == NO_PARTITION)\n-\t\tcontinue;\n-\t      p2 = var_to_partition (map, input);\n-\t      if (p2 == NO_PARTITION)\n-\t\tcontinue;\n-\n-\t      add_coalesce (cl, p1, p2, coalesce_cost (REG_BR_PROB_BASE,\n-\t\t\t\t\t\t       maybe_hot_bb_p (bb),\n-\t\t\t\t\t\t       false));\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Reduce the number of live ranges in MAP.  Live range information is \n-   returned if FLAGS indicates that we are combining temporaries, otherwise \n-   NULL is returned.  The only partitions which are associated with actual \n-   variables at this point are those which are forced to be coalesced for \n-   various reason. (live on entry, live across abnormal edges, etc.).  */\n-\n-static tree_live_info_p\n-coalesce_ssa_name (var_map map, int flags)\n-{\n-  unsigned num, x;\n-  sbitmap live;\n-  root_var_p rv;\n-  tree_live_info_p liveinfo;\n-  conflict_graph graph;\n-  coalesce_list_p cl = NULL;\n-  sbitmap_iterator sbi;\n-\n-  if (num_var_partitions (map) <= 1)\n-    return NULL;\n-\n-  liveinfo = calculate_live_ranges (map);\n-  rv = root_var_init (map);\n-\n-  /* Remove single element variable from the list.  */\n-  root_var_compact (rv);\n-\n-  cl = create_coalesce_list (map);\n-\n-  coalesce_phi_operands (map, cl);\n-  coalesce_result_decls (map, cl);\n-  coalesce_asm_operands (map, cl);\n-\n-  /* Build a conflict graph.  */\n-  graph = build_tree_conflict_graph (liveinfo, rv, cl);\n-\n-  if (cl)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Before sorting:\\n\");\n-\t  dump_coalesce_list (dump_file, cl);\n-\t}\n-\n-      sort_coalesce_list (cl);\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"\\nAfter sorting:\\n\");\n-\t  dump_coalesce_list (dump_file, cl);\n-\t}\n-    }\n-\n-  /* Put the single element variables back in.  */\n-  root_var_decompact (rv);\n-\n-  /* First, coalesce all live on entry variables to their root variable. \n-     This will ensure the first use is coming from the correct location.  */\n-\n-  num = num_var_partitions (map);\n-  live = sbitmap_alloc (num);\n-  sbitmap_zero (live);\n-\n-  /* Set 'live' vector to indicate live on entry partitions.  */\n-  for (x = 0 ; x < num; x++)\n-    {\n-      tree var = partition_to_var (map, x);\n-      if (gimple_default_def (cfun, SSA_NAME_VAR (var)) == var)\n-\tSET_BIT (live, x);\n-    }\n-\n-  delete_tree_live_info (liveinfo);\n-  liveinfo = NULL;\n-\n-  /* Assign root variable as partition representative for each live on entry\n-     partition.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (live, 0, x, sbi)\n-    {\n-      tree var = root_var (rv, root_var_find (rv, x));\n-      var_ann_t ann = var_ann (var);\n-      /* If these aren't already coalesced...  */\n-      if (partition_to_var (map, x) != var)\n-\t{\n-\t  /* This root variable should have not already been assigned\n-\t     to another partition which is not coalesced with this one.  */\n-\t  gcc_assert (!ann->out_of_ssa_tag);\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      print_exprs (dump_file, \"Must coalesce \", \n-\t\t\t   partition_to_var (map, x),\n-\t\t\t   \" with the root variable \", var, \".\\n\");\n-\t    }\n-\n-\t  change_partition_var (map, var, x);\n-\t}\n-    }\n-\n-  sbitmap_free (live);\n-\n-  /* Coalesce partitions live across abnormal edges.  */\n-  coalesce_abnormal_edges (map, graph, rv);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_var_map (dump_file, map);\n-\n-  /* Coalesce partitions.  */\n-  coalesce_tpa_members (rv, graph, map, cl,\n-\t\t\t((dump_flags & TDF_DETAILS) ? dump_file\n-\t\t\t : NULL));\n-\n-  if (flags & SSANORM_COALESCE_PARTITIONS)\n-    coalesce_tpa_members (rv, graph, map, NULL,\n-\t\t\t  ((dump_flags & TDF_DETAILS) ? dump_file\n-\t\t\t   : NULL));\n-  if (cl)\n-    delete_coalesce_list (cl);\n-  root_var_delete (rv);\n-  conflict_graph_delete (graph);\n-\n-  return liveinfo;\n-}\n-\n-\n /* Take the ssa-name var_map MAP, and assign real variables to each \n    partition.  */\n \n static void\n assign_vars (var_map map)\n {\n-  int x, i, num, rep;\n-  tree t, var;\n+  int x, num;\n+  tree var, root;\n   var_ann_t ann;\n-  root_var_p rv;\n-\n-  rv = root_var_init (map);\n-  if (!rv) \n-    return;\n-\n-  /* Coalescing may already have forced some partitions to their root \n-     variable. Find these and tag them.  */\n \n   num = num_var_partitions (map);\n   for (x = 0; x < num; x++)\n     {\n       var = partition_to_var (map, x);\n       if (TREE_CODE (var) != SSA_NAME)\n \t{\n-\t  /* Coalescing will already have verified that more than one\n-\t     partition doesn't have the same root variable. Simply marked\n-\t     the variable as assigned.  */\n \t  ann = var_ann (var);\n-\t  ann->out_of_ssa_tag = 1;\n+\t  /* It must already be coalesced.  */\n+\t  gcc_assert (ann->out_of_ssa_tag == 1);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file, \"partition %d has variable \", x);\n+\t      fprintf (dump_file, \"partition %d already has variable \", x);\n \t      print_generic_expr (dump_file, var, TDF_SLIM);\n \t      fprintf (dump_file, \" assigned to it.\\n\");\n \t    }\n-\n \t}\n-    }\n-\n-  num = root_var_num (rv);\n-  for (x = 0; x < num; x++)\n-    {\n-      var = root_var (rv, x);\n-      ann = var_ann (var);\n-      for (i = root_var_first_partition (rv, x);\n-\t   i != ROOT_VAR_NONE;\n-\t   i = root_var_next_partition (rv, i))\n-\t{\n-\t  t = partition_to_var (map, i);\n-\n-\t  if (t == var || TREE_CODE (t) != SSA_NAME)\n-\t    continue;\n-\n-\t  rep = var_to_partition (map, t);\n-\t  \n-\t  if (!ann->out_of_ssa_tag)\n+      else\n+        {\n+\t  root = SSA_NAME_VAR (var);\n+\t  ann = var_ann (root);\n+\t  /* If ROOT is already associated, create a new one.  */\n+\t  if (ann->out_of_ssa_tag)\n \t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tprint_exprs (dump_file, \"\", t, \"  --> \", var, \"\\n\");\n-\t      change_partition_var (map, var, rep);\n-\t      continue;\n+\t      root = create_temp (root);\n+\t      ann = var_ann (root);\n \t    }\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    print_exprs (dump_file, \"\", t, \" not coalesced with \", var, \n-\t\t\t \"\");\n-\n-\t  var = create_temp (t);\n-\t  change_partition_var (map, var, rep);\n-\t  ann = var_ann (var);\n-\n+\t  /* ROOT has not been coalesced yet, so use it.  */\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file, \" -->  New temp:  '\");\n-\t      print_generic_expr (dump_file, var, TDF_SLIM);\n-\t      fprintf (dump_file, \"'\\n\");\n+\t      fprintf (dump_file, \"Partition %d is assigned to var \", x);\n+\t      print_generic_stmt (dump_file, root, TDF_SLIM);\n \t    }\n+\t  change_partition_var (map, root, x);\n \t}\n     }\n-\n-  root_var_delete (rv);\n }\n \n \n@@ -1028,6 +562,7 @@ replace_use_variable (var_map map, use_operand_p p, tree *expr)\n         {\n \t  tree new_expr = GIMPLE_STMT_OPERAND (expr[version], 1);\n \t  SET_USE (p, new_expr);\n+\n \t  /* Clear the stmt's RHS, or GC might bite us.  */\n \t  GIMPLE_STMT_OPERAND (expr[version], 1) = NULL_TREE;\n \t  return true;\n@@ -1056,19 +591,9 @@ replace_def_variable (var_map map, def_operand_p def_p, tree *expr)\n   tree new_var;\n   tree var = DEF_FROM_PTR (def_p);\n \n-  /* Check if we are replacing this variable with an expression.  */\n-  if (expr)\n-    {\n-      int version = SSA_NAME_VERSION (var);\n-      if (expr[version])\n-        {\n-\t  tree new_expr = TREE_OPERAND (expr[version], 1);\n-\t  SET_DEF (def_p, new_expr);\n-\t  /* Clear the stmt's RHS, or GC might bite us.  */\n-\t  TREE_OPERAND (expr[version], 1) = NULL_TREE;\n-\t  return true;\n-\t}\n-    }\n+  /* Do nothing if we are replacing this variable with an expression.  */\n+  if (expr && expr[SSA_NAME_VERSION (var)])\n+    return true;\n \n   new_var = var_to_partition_to_var (map, var);\n   if (new_var)\n@@ -1144,15 +669,12 @@ rewrite_trees (var_map map, tree *values)\n   FOR_EACH_BB (bb)\n     {\n       tree phi;\n-\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  tree T0 = var_to_partition_to_var (map, PHI_RESULT (phi));\n-      \n \t  if (T0 == NULL_TREE)\n \t    {\n \t      int i;\n-\n \t      for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n \t\t{\n \t\t  tree arg = PHI_ARG_DEF (phi, i);\n@@ -1261,15 +783,18 @@ static edge leader_match = NULL;\n \n \n /* Pass this function to make_forwarder_block so that all the edges with\n-   matching PENDING_STMT lists to 'curr_stmt_list' get redirected.  */\n-static bool \n+   matching PENDING_STMT lists to 'curr_stmt_list' get redirected.  E is the\n+   edge to test for a match.  */\n+\n+static inline bool \n same_stmt_list_p (edge e)\n {\n   return (e->aux == (PTR) leader_match) ? true : false;\n }\n \n \n /* Return TRUE if S1 and S2 are equivalent copies.  */\n+\n static inline bool\n identical_copies_p (tree s1, tree s2)\n {\n@@ -1293,7 +818,7 @@ identical_copies_p (tree s1, tree s2)\n }\n \n \n-/* Compare the PENDING_STMT list for two edges, and return true if the lists\n+/* Compare the PENDING_STMT list for edges E1 and E2. Return true if the lists\n    contain the same sequence of copies.  */\n \n static inline bool \n@@ -1380,6 +905,7 @@ analyze_edges_for_bb (basic_block bb)\n \t  bsi_commit_one_edge_insert (e, NULL);\n       return;\n     }\n+\n   /* Find out how many edges there are with interesting pending stmts on them.  \n      Commit the stmts on edges we are not interested in.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -1470,11 +996,9 @@ analyze_edges_for_bb (basic_block bb)\n       return;\n     }\n \n-\n   if (dump_file)\n     fprintf (dump_file, \"\\nOpportunities in BB %d for stmt/block reduction:\\n\",\n \t     bb->index);\n-\n   \n   /* For each common list, create a forwarding block and issue the stmt's\n      in that block.  */\n@@ -1601,36 +1125,31 @@ perform_edge_inserts (void)\n }\n \n \n-/* Remove the variables specified in MAP from SSA form.  FLAGS indicate what\n-   options should be used.  */\n+/* Remove the ssa-names in the current function and translate them into normal\n+   compiler variables.  PERFORM_TER is true if Temporary Expression Replacement\n+   should also be used.  */\n \n static void\n-remove_ssa_form (var_map map, int flags)\n+remove_ssa_form (bool perform_ter)\n {\n-  tree_live_info_p liveinfo;\n   basic_block bb;\n   tree phi, next;\n   tree *values = NULL;\n+  var_map map;\n \n-  /* If we are not combining temps, don't calculate live ranges for variables\n-     with only one SSA version.  */\n-  compact_var_map (map, VARMAP_NO_SINGLE_DEFS);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_var_map (dump_file, map);\n-\n-  liveinfo = coalesce_ssa_name (map, flags);\n+  map = coalesce_ssa_name ();\n \n-  /* Make sure even single occurrence variables are in the list now.  */\n-  compact_var_map (map, VARMAP_NORMAL);\n+  /* Return to viewing the variable list as just all reference variables after\n+     coalescing has been performed.  */\n+  partition_view_normal (map, false);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"After Coalescing:\\n\");\n       dump_var_map (dump_file, map);\n     }\n \n-  if (flags & SSANORM_PERFORM_TER)\n+  if (perform_ter)\n     {\n       values = find_replaceable_exprs (map);\n       if (values && dump_file && (dump_flags & TDF_DETAILS))\n@@ -1642,13 +1161,10 @@ remove_ssa_form (var_map map, int flags)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"After Root variable replacement:\\n\");\n+      fprintf (dump_file, \"After Base variable replacement:\\n\");\n       dump_var_map (dump_file, map);\n     }\n \n-  if (liveinfo)\n-    delete_tree_live_info (liveinfo);\n-\n   rewrite_trees (map, values);\n \n   if (values)\n@@ -1669,8 +1185,11 @@ remove_ssa_form (var_map map, int flags)\n \n   /* If any copies were inserted on edges, analyze and insert them now.  */\n   perform_edge_inserts ();\n+\n+  delete_var_map (map);\n }\n \n+\n /* Search every PHI node for arguments associated with backedges which\n    we can trivially determine will need a copy (the argument is either\n    not an SSA_NAME or the argument has a different underlying variable\n@@ -1704,11 +1223,10 @@ insert_backedge_copies (void)\n \t      tree arg = PHI_ARG_DEF (phi, i);\n \t      edge e = PHI_ARG_EDGE (phi, i);\n \n-\t      /* If the argument is not an SSA_NAME, then we will\n-\t\t need a constant initialization.  If the argument is\n-\t\t an SSA_NAME with a different underlying variable and\n-\t\t we are not combining temporaries, then we will\n-\t\t need a copy statement.  */\n+\t      /* If the argument is not an SSA_NAME, then we will need a \n+\t\t constant initialization.  If the argument is an SSA_NAME with\n+\t\t a different underlying variable then a copy statement will be \n+\t\t needed.  */\n \t      if ((e->flags & EDGE_DFS_BACK)\n \t\t  && (TREE_CODE (arg) != SSA_NAME\n \t\t      || SSA_NAME_VAR (arg) != result_var))\n@@ -1723,7 +1241,6 @@ insert_backedge_copies (void)\n \t\t  /* In theory the only way we ought to get back to the\n \t\t     start of a loop should be with a COND_EXPR or GOTO_EXPR.\n \t\t     However, better safe than sorry. \n-\n \t\t     If the block ends with a control statement or\n \t\t     something that might throw, then we have to\n \t\t     insert this assignment before the last\n@@ -1738,8 +1255,8 @@ insert_backedge_copies (void)\n \t\t\tcontinue;\n \t\t    }\n \n-\t\t  /* Create a new instance of the underlying\n-\t\t     variable of the PHI result.  */\n+\t\t  /* Create a new instance of the underlying variable of the \n+\t\t     PHI result.  */\n \t\t  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (result_var),\n \t\t\t\t NULL_TREE, PHI_ARG_DEF (phi, i));\n \t\t  name = make_ssa_name (result_var, stmt);\n@@ -1758,16 +1275,13 @@ insert_backedge_copies (void)\n     }\n }\n \n-/* Take the current function out of SSA form, as described in\n+/* Take the current function out of SSA form, translating PHIs as described in\n    R. Morgan, ``Building an Optimizing Compiler'',\n    Butterworth-Heinemann, Boston, MA, 1998. pp 176-186.  */\n \n static unsigned int\n rewrite_out_of_ssa (void)\n {\n-  var_map map;\n-  int ssa_flags = 0;\n-\n   /* If elimination of a PHI requires inserting a copy on a backedge,\n      then we will have to split the backedge which has numerous\n      undesirable performance effects.\n@@ -1776,27 +1290,16 @@ rewrite_out_of_ssa (void)\n      copies into the loop itself.  */\n   insert_backedge_copies ();\n \n-  if (!flag_tree_live_range_split)\n-    ssa_flags |= SSANORM_COALESCE_PARTITIONS;\n-    \n   eliminate_virtual_phis ();\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_tree_cfg (dump_file, dump_flags & ~TDF_DETAILS);\n \n-  map = create_ssa_var_map ();\n-\n-  if (flag_tree_ter && !flag_mudflap)\n-    ssa_flags |= SSANORM_PERFORM_TER;\n-\n-  remove_ssa_form (map, ssa_flags);\n+  remove_ssa_form (flag_tree_ter && !flag_mudflap);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_tree_cfg (dump_file, dump_flags & ~TDF_DETAILS);\n \n-  /* Flush out flow graph and SSA data.  */\n-  delete_var_map (map);\n-\n   cfun->gimple_df->in_ssa_p = false;\n   return 0;\n }"}, {"sha": "00793618d67504bbca7c3ac80003b84d83e306d0", "filename": "gcc/tree-ssa-coalesce.c", "status": "added", "additions": 1355, "deletions": 0, "changes": 1355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -0,0 +1,1355 @@\n+/* Coalesce SSA_NAMES together for the out-of-ssa pass.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"diagnostic.h\"\n+#include \"bitmap.h\"\n+#include \"tree-flow.h\"\n+#include \"hashtab.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-ssa-live.h\"\n+#include \"toplev.h\"\n+\n+\n+/* This set of routines implements a coalesce_list.  This is an object which\n+   is used to track pairs of ssa_names which are desirable to coalesce\n+   together to avoid copies.  Costs are associated with each pair, and when \n+   all desired information has been collected, the object can be used to \n+   order the pairs for processing.  */\n+\n+/* This structure defines a pair entry.  */\n+\n+typedef struct coalesce_pair\n+{\n+  int first_element;\n+  int second_element;\n+  int cost;\n+} * coalesce_pair_p;\n+\n+typedef struct cost_one_pair_d\n+{\n+  int first_element;\n+  int second_element;\n+  struct cost_one_pair_d *next;\n+} * cost_one_pair_p;\n+\n+/* This structure maintains the list of coalesce pairs.  */\n+\n+typedef struct coalesce_list_d \n+{\n+  htab_t list;\t\t\t/* Hash table.  */\n+  coalesce_pair_p *sorted;\t/* List when sorted.  */\n+  int num_sorted;\t\t/* Number in the sorted list.  */\n+  cost_one_pair_p cost_one_list;/* Single use coalesces with cost 1.  */\n+} *coalesce_list_p;\n+\n+#define NO_BEST_COALESCE\t-1\n+#define MUST_COALESCE_COST\tINT_MAX\n+\n+\n+/* Return cost of execution of copy instruction with FREQUENCY\n+   possibly on CRITICAL edge and in HOT basic block.  */\n+\n+static inline int\n+coalesce_cost (int frequency, bool hot, bool critical)\n+{\n+  /* Base costs on BB frequencies bounded by 1.  */\n+  int cost = frequency;\n+\n+  if (!cost)\n+    cost = 1;\n+\n+  if (optimize_size)\n+    cost = 1;\n+  else\n+    /* It is more important to coalesce in HOT blocks.  */\n+    if (hot)\n+      cost *= 2;\n+\n+  /* Inserting copy on critical edge costs more than inserting it elsewhere.  */\n+  if (critical)\n+    cost *= 2;\n+  return cost;\n+}\n+\n+\n+/* Return the cost of executing a copy instruction in basic block BB.  */\n+\n+static inline int \n+coalesce_cost_bb (basic_block bb)\n+{\n+  return coalesce_cost (bb->frequency, maybe_hot_bb_p (bb), false);\n+}\n+\n+\n+/* Return the cost of executing a copy instruction on edge E.  */\n+\n+static inline int \n+coalesce_cost_edge (edge e)\n+{\n+  if (e->flags & EDGE_ABNORMAL)\n+    return MUST_COALESCE_COST;\n+\n+  return coalesce_cost (EDGE_FREQUENCY (e), \n+\t\t\tmaybe_hot_bb_p (e->src), \n+\t\t\tEDGE_CRITICAL_P (e));\n+}\n+\n+\n+/* Retrieve a pair to coalesce from the cost_one_list in CL.  Returns the \n+   2 elements via P1 and P2.  1 is returned by the function if there is a pair,\n+   NO_BEST_COALESCE is returned if there aren't any.  */\n+\n+static inline int\n+pop_cost_one_pair (coalesce_list_p cl, int *p1, int *p2)\n+{\n+  cost_one_pair_p ptr;\n+\n+  ptr = cl->cost_one_list;\n+  if (!ptr)\n+    return NO_BEST_COALESCE;\n+\n+  *p1 = ptr->first_element;\n+  *p2 = ptr->second_element;\n+  cl->cost_one_list = ptr->next;\n+\n+  free (ptr);\n+\n+  return 1;\n+}\n+\n+/* Retrieve the most expensive remaining pair to coalesce from CL.  Returns the \n+   2 elements via P1 and P2.  Their calculated cost is returned by the function.\n+   NO_BEST_COALESCE is returned if the coalesce list is empty.  */\n+\n+static inline int\n+pop_best_coalesce (coalesce_list_p cl, int *p1, int *p2)\n+{\n+  coalesce_pair_p node;\n+  int ret;\n+\n+  if (cl->sorted == NULL)\n+    return pop_cost_one_pair (cl, p1, p2);\n+\n+  if (cl->num_sorted == 0)\n+    return pop_cost_one_pair (cl, p1, p2);\n+\n+  node = cl->sorted[--(cl->num_sorted)];\n+  *p1 = node->first_element;\n+  *p2 = node->second_element;\n+  ret = node->cost;\n+  free (node);\n+\n+  return ret;\n+}\n+\n+\n+#define COALESCE_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n+\n+/* Hash function for coalesce list.  Calculate hash for PAIR.   */\n+\n+static unsigned int \n+coalesce_pair_map_hash (const void *pair)\n+{\n+  hashval_t a = (hashval_t)(((coalesce_pair_p)pair)->first_element);\n+  hashval_t b = (hashval_t)(((coalesce_pair_p)pair)->second_element);\n+\n+  return COALESCE_HASH_FN (a,b);\n+}\n+\n+\n+/* Equality function for coalesce list hash table.  Compare PAIR1 and PAIR2,\n+   returning TRUE if the two pairs are equivilent. */\n+\n+static int \n+coalesce_pair_map_eq (const void *pair1, const void *pair2)\n+{\n+  coalesce_pair_p p1 = (coalesce_pair_p) pair1;\n+  coalesce_pair_p p2 = (coalesce_pair_p) pair2;\n+\n+  return (p1->first_element == p2->first_element\n+\t  && p1->second_element == p2->second_element);\n+}\n+\n+\n+/* Create a new empty coalesce list object and return it.  */\n+\n+static inline coalesce_list_p \n+create_coalesce_list (void)\n+{\n+  coalesce_list_p list;\n+  unsigned size = num_ssa_names * 3;\n+\n+  if (size < 40) \n+    size = 40;\n+\n+  list = (coalesce_list_p) xmalloc (sizeof (struct coalesce_list_d));\n+  list->list = htab_create (size, coalesce_pair_map_hash,\n+  \t\t\t    coalesce_pair_map_eq, NULL);\n+  list->sorted = NULL;\n+  list->num_sorted = 0;\n+  list->cost_one_list = NULL;\n+  return list;\n+}\n+\n+\n+/* Delete coalesce list CL.  */\n+\n+static inline void \n+delete_coalesce_list (coalesce_list_p cl)\n+{\n+  gcc_assert (cl->cost_one_list == NULL);\n+  htab_delete (cl->list);\n+  if (cl->sorted)\n+    free (cl->sorted);\n+  gcc_assert (cl->num_sorted == 0);\n+  free (cl);\n+}\n+\n+\n+/* Find a matching coalesce pair object in CL for the pair P1 and P2.  If \n+   one isn't found, return NULL if CREATE is false, otherwise create a new \n+   coalesce pair object and return it.  */\n+\n+static coalesce_pair_p\n+find_coalesce_pair (coalesce_list_p cl, int p1, int p2, bool create)\n+{\n+  struct coalesce_pair p, *pair;\n+  void **slot;\n+  unsigned int hash;\n+    \n+  /* Normalize so that p1 is the smaller value.  */\n+  if (p2 < p1)\n+    {\n+      p.first_element = p2;\n+      p.second_element = p1;\n+    }\n+  else\n+    {\n+      p.first_element = p1;\n+      p.second_element = p2;\n+    }\n+  \n+  \n+  hash = coalesce_pair_map_hash (&p);\n+  pair = (struct coalesce_pair *) htab_find_with_hash (cl->list, &p, hash);\n+\n+  if (create && !pair)\n+    {\n+      gcc_assert (cl->sorted == NULL);\n+      pair = xmalloc (sizeof (struct coalesce_pair));\n+      pair->first_element = p.first_element;\n+      pair->second_element = p.second_element;\n+      pair->cost = 0;\n+      slot = htab_find_slot_with_hash (cl->list, pair, hash, INSERT);\n+      *(struct coalesce_pair **)slot = pair;\n+    }\n+\n+  return pair;\n+}\n+\n+static inline void\n+add_cost_one_coalesce (coalesce_list_p cl, int p1, int p2)\n+{\n+  cost_one_pair_p pair;\n+\n+  pair = xmalloc (sizeof (struct cost_one_pair_d));\n+  pair->first_element = p1;\n+  pair->second_element = p2;\n+  pair->next = cl->cost_one_list;\n+  cl->cost_one_list = pair;\n+}\n+\n+\n+/* Add a coalesce between P1 and P2 in list CL with a cost of VALUE.  */\n+\n+static inline void \n+add_coalesce (coalesce_list_p cl, int p1, int p2,\n+\t      int value)\n+{\n+  coalesce_pair_p node;\n+\n+  gcc_assert (cl->sorted == NULL);\n+  if (p1 == p2)\n+    return;\n+\n+  node = find_coalesce_pair (cl, p1, p2, true);\n+\n+  /* Once the value is MUST_COALESCE_COST, leave it that way.  */\n+  if (node->cost != MUST_COALESCE_COST)\n+    {\n+      if (value == MUST_COALESCE_COST)\n+\tnode->cost = value;\n+      else\n+\tnode->cost += value;\n+    }\n+}\n+\n+\n+/* Comparison function to allow qsort to sort P1 and P2 in Ascendiong order.  */\n+\n+static int \n+compare_pairs (const void *p1, const void *p2)\n+{\n+  return (*(coalesce_pair_p *)p1)->cost - (*(coalesce_pair_p *)p2)->cost;\n+}\n+\n+\n+/* Return the number of unique coalesce pairs in CL.  */\n+\n+static inline int\n+num_coalesce_pairs (coalesce_list_p cl)\n+{\n+  return htab_elements (cl->list);\n+}\n+\n+\n+/* Iterator over hash table pairs.  */\n+typedef struct\n+{\n+  htab_iterator hti;\n+} coalesce_pair_iterator;\n+\n+\n+/* Return first partition pair from list CL, initializing iterator ITER.  */\n+\n+static inline coalesce_pair_p\n+first_coalesce_pair (coalesce_list_p cl, coalesce_pair_iterator *iter)\n+{\n+  coalesce_pair_p pair;\n+\n+  pair = (coalesce_pair_p) first_htab_element (&(iter->hti), cl->list);\n+  return pair;\n+}\n+\n+\n+/* Return TRUE if there are no more partitions in for ITER to process.  */\n+\n+static inline bool\n+end_coalesce_pair_p (coalesce_pair_iterator *iter)\n+{\n+  return end_htab_p (&(iter->hti));\n+}\n+\n+\n+/* Return the next parttition pair to be visited by ITER.  */\n+\n+static inline coalesce_pair_p\n+next_coalesce_pair (coalesce_pair_iterator *iter)\n+{\n+  coalesce_pair_p pair;\n+\n+  pair = (coalesce_pair_p) next_htab_element (&(iter->hti));\n+  return pair;\n+}\n+\n+\n+/* Iterate over CL using ITER, returning values in PAIR.  */\n+\n+#define FOR_EACH_PARTITION_PAIR(PAIR, ITER, CL)\t\t\\\n+  for ((PAIR) = first_coalesce_pair ((CL), &(ITER));\t\\\n+       !end_coalesce_pair_p (&(ITER));\t\t\t\\\n+       (PAIR) = next_coalesce_pair (&(ITER)))\n+\n+\n+/* Prepare CL for removal of preferred pairs.  When finished they are sorted\n+   in order from most important coalesce to least important.  */\n+\n+static void\n+sort_coalesce_list (coalesce_list_p cl)\n+{\n+  unsigned x, num;\n+  coalesce_pair_p p;\n+  coalesce_pair_iterator ppi;\n+\n+  gcc_assert (cl->sorted == NULL);\n+\n+  num = num_coalesce_pairs (cl);\n+  cl->num_sorted = num;\n+  if (num == 0)\n+    return;\n+\n+  /* Allocate a vector for the pair pointers.  */\n+  cl->sorted = XNEWVEC (coalesce_pair_p, num);\n+\n+  /* Populate the vector with pointers to the pairs.  */\n+  x = 0;\n+  FOR_EACH_PARTITION_PAIR (p, ppi, cl)\n+    cl->sorted[x++] = p;\n+  gcc_assert (x == num);\n+\n+  /* Already sorted.  */\n+  if (num == 1)\n+    return;\n+\n+  /* If there are only 2, just pick swap them if the order isn't correct.  */\n+  if (num == 2)\n+    {\n+      if (cl->sorted[0]->cost > cl->sorted[1]->cost)\n+        {\n+\t  p = cl->sorted[0];\n+\t  cl->sorted[0] = cl->sorted[1];\n+\t  cl->sorted[1] = p;\n+\t}\n+      return;\n+    }\n+\n+  /* Only call qsort if there are more than 2 items.  */\n+  if (num > 2)\n+      qsort (cl->sorted, num, sizeof (coalesce_pair_p), compare_pairs);\n+}\n+\n+\n+/* Send debug info for coalesce list CL to file F.  */\n+\n+static void \n+dump_coalesce_list (FILE *f, coalesce_list_p cl)\n+{\n+  coalesce_pair_p node;\n+  coalesce_pair_iterator ppi;\n+  int x;\n+  tree var;\n+\n+  if (cl->sorted == NULL)\n+    {\n+      fprintf (f, \"Coalesce List:\\n\");\n+      FOR_EACH_PARTITION_PAIR (node, ppi, cl)\n+        {\n+\t  tree var1 = ssa_name (node->first_element);\n+\t  tree var2 = ssa_name (node->second_element);\n+\t  print_generic_expr (f, var1, TDF_SLIM);\n+\t  fprintf (f, \" <-> \");\n+\t  print_generic_expr (f, var2, TDF_SLIM);\n+\t  fprintf (f, \"  (%1d), \", node->cost);\n+\t  fprintf (f, \"\\n\");\n+\t}\n+    }\n+  else\n+    {\n+      fprintf (f, \"Sorted Coalesce list:\\n\");\n+      for (x = cl->num_sorted - 1 ; x >=0; x--)\n+        {\n+\t  node = cl->sorted[x];\n+\t  fprintf (f, \"(%d) \", node->cost);\n+\t  var = ssa_name (node->first_element);\n+\t  print_generic_expr (f, var, TDF_SLIM);\n+\t  fprintf (f, \" <-> \");\n+\t  var = ssa_name (node->second_element);\n+\t  print_generic_expr (f, var, TDF_SLIM);\n+\t  fprintf (f, \"\\n\");\n+\t}\n+    }\n+}\n+\n+\n+/* This represents a conflict graph.  Implemented as an array of bitmaps.  \n+   A full matrix isused for conflicts rather than just upper triangular form.\n+   this make sit much simpler and faster to perform conflict merges.  */\n+\n+typedef struct ssa_conflicts_d\n+{\n+  unsigned size;\n+  bitmap *conflicts;\n+} * ssa_conflicts_p;\n+\n+\n+/* Return a empty new conflict graph for SIZE elements.  */\n+\n+static inline ssa_conflicts_p\n+ssa_conflicts_new (unsigned size)\n+{\n+  ssa_conflicts_p ptr;\n+\n+  ptr = XNEW (struct ssa_conflicts_d);\n+  ptr->conflicts = XCNEWVEC (bitmap, size);\n+  ptr->size = size;\n+  return ptr;\n+}\n+\n+\n+/* Free storage for conflict graph PTR.  */\n+\n+static inline void\n+ssa_conflicts_delete (ssa_conflicts_p ptr)\n+{\n+  unsigned x;\n+  for (x = 0; x < ptr->size; x++)\n+    if (ptr->conflicts[x])\n+      BITMAP_FREE (ptr->conflicts[x]);\n+\n+  free (ptr->conflicts);\n+  free (ptr);\n+}\n+\n+\n+/* Test if elements X and Y conflict in graph PTR.  */\n+\n+static inline bool\n+ssa_conflicts_test_p (ssa_conflicts_p ptr, unsigned x, unsigned y)\n+{\n+  bitmap b;\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (x < ptr->size);\n+  gcc_assert (y < ptr->size);\n+  gcc_assert (x != y);\n+#endif\n+\n+  b = ptr->conflicts[x];\n+  if (b)\n+    /* Avoid the lookup if Y has no conflicts.  */\n+    return ptr->conflicts[y] ? bitmap_bit_p (b, y) : false;\n+  else\n+    return false;\n+}\n+\n+\n+/* Add a conflict with Y to the bitmap for X in graph PTR.  */\n+\n+static inline void\n+ssa_conflicts_add_one (ssa_conflicts_p ptr, unsigned x, unsigned y)\n+{\n+  /* If there are no conflicts yet, allocate the bitmap and set bit.  */\n+  if (!ptr->conflicts[x])\n+    ptr->conflicts[x] = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (ptr->conflicts[x], y);\n+}\n+\n+\n+/* Add conflicts between X and Y in graph PTR.  */\n+\n+static inline void\n+ssa_conflicts_add (ssa_conflicts_p ptr, unsigned x, unsigned y)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (x < ptr->size);\n+  gcc_assert (y < ptr->size);\n+  gcc_assert (x != y);\n+#endif\n+  ssa_conflicts_add_one (ptr, x, y);\n+  ssa_conflicts_add_one (ptr, y, x);\n+}\n+\n+\n+/* Merge all Y's conflict into X in graph PTR.  */\n+\n+static inline void\n+ssa_conflicts_merge (ssa_conflicts_p ptr, unsigned x, unsigned y)\n+{\n+  unsigned z;\n+  bitmap_iterator bi;\n+\n+  gcc_assert (x != y);\n+  if (!(ptr->conflicts[y]))\n+    return;\n+\n+  /* Add a conflict between X and every one Y has.  If the bitmap doesn't\n+     exist, then it has already been coalesced, and we dont need to add a \n+     conflict.  */\n+  EXECUTE_IF_SET_IN_BITMAP (ptr->conflicts[y], 0, z, bi)\n+    if (ptr->conflicts[z])\n+      bitmap_set_bit (ptr->conflicts[z], x);\n+\n+  if (ptr->conflicts[x])\n+    {\n+      /* If X has conflicts, add Y's to X.  */\n+      bitmap_ior_into (ptr->conflicts[x], ptr->conflicts[y]);\n+      BITMAP_FREE (ptr->conflicts[y]);\n+    }\n+  else\n+    {\n+      /* If X has no conflicts, simply use Y's.  */\n+      ptr->conflicts[x] = ptr->conflicts[y];\n+      ptr->conflicts[y] = NULL;\n+    }\n+}\n+\n+\n+/* This structure is used to efficiently record the current status of live \n+   SSA_NAMES when building a conflict graph.  \n+   LIVE_BASE_VAR has a bit set for each base variable which has at least one\n+   ssa version live.\n+   LIVE_BASE_PARTITIONS is an array of bitmaps using the basevar table as an \n+   index, and is used to track what partitions of each base variable are \n+   live.  This makes it easy to add conflicts between just live partitions \n+   with the same base variable.  \n+   The values in LIVE_BASE_PARTITIONS are only valid if the base variable is \n+   marked as being live.  This delays clearing of these bitmaps until\n+   they are actually needed again.  */\n+\n+typedef struct live_track_d\n+{\n+  bitmap live_base_var;\t\t/* Indicates if a basevar is live.  */\n+  bitmap *live_base_partitions;\t/* Live partitions for each basevar.  */\n+  var_map map;\t\t\t/* Var_map being used for partition mapping.  */\n+} * live_track_p;\n+\n+\n+/* This routine will create a new live track structure based on the partitions\n+   in MAP.  */\n+\n+static live_track_p\n+new_live_track (var_map map)\n+{\n+  live_track_p ptr;\n+  int lim, x;\n+\n+  /* Make sure there is a partition view in place.  */\n+  gcc_assert (map->partition_to_base_index != NULL);\n+\n+  ptr = (live_track_p) xmalloc (sizeof (struct live_track_d));\n+  ptr->map = map;\n+  lim = num_basevars (map);\n+  ptr->live_base_partitions = (bitmap *) xmalloc(sizeof (bitmap *) * lim);\n+  ptr->live_base_var = BITMAP_ALLOC (NULL);\n+  for (x = 0; x < lim; x++)\n+    ptr->live_base_partitions[x] = BITMAP_ALLOC (NULL);\n+  return ptr;\n+}\n+\n+\n+/* This routine will free the memory associated with PTR.  */\n+\n+static void\n+delete_live_track (live_track_p ptr)\n+{\n+  int x, lim;\n+\n+  lim = num_basevars (ptr->map);\n+  for (x = 0; x < lim; x++)\n+    BITMAP_FREE (ptr->live_base_partitions[x]);\n+  BITMAP_FREE (ptr->live_base_var);\n+  free (ptr->live_base_partitions);\n+  free (ptr);\n+}\n+\n+\n+/* This function will remove PARTITION from the live list in PTR.  */\n+\n+static inline void\n+live_track_remove_partition (live_track_p ptr, int partition)\n+{\n+  int root;\n+\n+  root = basevar_index (ptr->map, partition);\n+  bitmap_clear_bit (ptr->live_base_partitions[root], partition);\n+  /* If the element list is empty, make the base variable not live either.  */\n+  if (bitmap_empty_p (ptr->live_base_partitions[root]))\n+    bitmap_clear_bit (ptr->live_base_var, root);\n+}\n+\n+\n+/* This function will adds PARTITION to the live list in PTR.  */\n+\n+static inline void\n+live_track_add_partition (live_track_p ptr, int partition)\n+{\n+  int root;\n+\n+  root = basevar_index (ptr->map, partition);\n+  /* If this base var wasn't live before, it is now.  Clear the element list \n+     since it was delayed until needed.  */\n+  if (!bitmap_bit_p (ptr->live_base_var, root))\n+    {\n+      bitmap_set_bit (ptr->live_base_var, root);\n+      bitmap_clear (ptr->live_base_partitions[root]);\n+    }\n+  bitmap_set_bit (ptr->live_base_partitions[root], partition);\n+    \n+}\n+\n+\n+/* Clear the live bit for VAR in PTR.  */\n+\n+static inline void\n+live_track_clear_var (live_track_p ptr, tree var)\n+{\n+  int p;\n+\n+  p = var_to_partition (ptr->map, var);\n+  if (p != NO_PARTITION)\n+    live_track_remove_partition (ptr, p);\n+}\n+\n+\n+/* Return TRUE if VAR is live in PTR.  */\n+\n+static inline bool\n+live_track_live_p (live_track_p ptr, tree var)\n+{\n+  int p, root;\n+\n+  p = var_to_partition (ptr->map, var);\n+  if (p != NO_PARTITION)\n+    {\n+      root = basevar_index (ptr->map, p);\n+      if (bitmap_bit_p (ptr->live_base_var, root))\n+\treturn bitmap_bit_p (ptr->live_base_partitions[root], p);\n+    }\n+  return false;\n+}\n+\n+\n+/* This routine will add USE to PTR.  USE will be marked as live in both the \n+   ssa live map and the live bitmap for the root of USE.  */\n+\n+static inline void\n+live_track_process_use (live_track_p ptr, tree use)\n+{\n+  int p;\n+\n+  p = var_to_partition (ptr->map, use);\n+  if (p == NO_PARTITION)\n+    return;\n+\n+  /* Mark as live in the appropriate live list.  */\n+  live_track_add_partition (ptr, p);\n+}\n+\n+\n+/* This routine will process a DEF in PTR.  DEF will be removed from the live\n+   lists, and if there are any other live partitions with the same base \n+   variable, conflicts will be added to GRAPH.  */\n+\n+static inline void\n+live_track_process_def (live_track_p ptr, tree def, ssa_conflicts_p graph)\n+{\n+  int p, root;\n+  bitmap b;\n+  unsigned x;\n+  bitmap_iterator bi;\n+\n+  p = var_to_partition (ptr->map, def);\n+  if (p == NO_PARTITION)\n+    return;\n+\n+  /* Clear the liveness bit.  */\n+  live_track_remove_partition (ptr, p);\n+\n+  /* If the bitmap isn't empty now, conflicts need to be added.  */\n+  root = basevar_index (ptr->map, p);\n+  if (bitmap_bit_p (ptr->live_base_var, root))\n+    {\n+      b = ptr->live_base_partitions[root];\n+      EXECUTE_IF_SET_IN_BITMAP (b, 0, x, bi)\n+        ssa_conflicts_add (graph, p, x);\n+    }\n+}\n+\n+\n+/* Initialize PTR with the partitions set in INIT.  */\n+\n+static inline void\n+live_track_init (live_track_p ptr, bitmap init)\n+{\n+  unsigned p;\n+  bitmap_iterator bi;\n+\n+  /* Mark all live on exit partitions.  */\n+  EXECUTE_IF_SET_IN_BITMAP (init, 0, p, bi)\n+    live_track_add_partition (ptr, p);\n+}\n+\n+\n+/* This routine will clear all live partitions in PTR.   */\n+\n+static inline void\n+live_track_clear_base_vars (live_track_p ptr)\n+{\n+  /* Simply clear the live base list.  Anything marked as live in the element\n+     lists will be cleared later if/when the base variable ever comes alive\n+     again.  */\n+  bitmap_clear (ptr->live_base_var);\n+}\n+\n+\n+/* Build a conflict graph based on LIVEINFO.  Any partitions which are in the\n+   partition view of the var_map liveinfo is based on get entires in the \n+   conflict graph.  Only conflicts between ssa_name partitions with the same \n+   base variableare added.  */\n+\n+static ssa_conflicts_p\n+build_ssa_conflict_graph (tree_live_info_p liveinfo)\n+{\n+  ssa_conflicts_p graph;\n+  var_map map;\n+  basic_block bb;\n+  ssa_op_iter iter;\n+  live_track_p live;\n+\n+  map = live_var_map (liveinfo);\n+  graph = ssa_conflicts_new (num_var_partitions (map));\n+\n+  live = new_live_track (map);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      tree phi;\n+\n+      /* Start with live on exit temporaries.  */\n+      live_track_init (live, live_on_exit (liveinfo, bb));\n+\n+      for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+        {\n+\t  tree var;\n+\t  tree stmt = bsi_stmt (bsi);\n+\n+\t  /* A copy between 2 partitions does not introduce an interference \n+\t     by itself.  If they did, you would never be able to coalesce \n+\t     two things which are copied.  If the two variables really do \n+\t     conflict, they will conflict elsewhere in the program.  \n+\t     \n+\t     This is handled by simply removing the SRC of the copy from the \n+\t     live list, and processing the stmt normally.  */\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t    {\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t      if (TREE_CODE (lhs) == SSA_NAME && TREE_CODE (rhs) == SSA_NAME)\n+\t\tlive_track_clear_var (live, rhs);\n+\t    }\n+\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_DEF)\n+\t    live_track_process_def (live, var, graph);\n+\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n+\t    live_track_process_use (live, var);\n+\t}\n+\n+      /* If result of a PHI is unused, looping over the statements will not \n+\t record any conflicts since the def was never live.  Since the PHI node\n+\t is going to be translated out of SSA form, it will insert a copy.\n+\t There must be a conflict recorded between the result of the PHI and \n+\t any variables that are live.  Otherwise the out-of-ssa translation \n+\t may create incorrect code.  */\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  tree result = PHI_RESULT (phi);\n+\t  if (live_track_live_p (live, result))\n+\t    live_track_process_def (live, result, graph);\n+\t}\n+\n+     live_track_clear_base_vars (live);\n+    }\n+\n+  delete_live_track (live);\n+  return graph;\n+}\n+\n+\n+/* Shortcut routine to print messages to file F of the form:\n+   \"STR1 EXPR1 STR2 EXPR2 STR3.\"  */\n+\n+static inline void\n+print_exprs (FILE *f, const char *str1, tree expr1, const char *str2,\n+\t     tree expr2, const char *str3)\n+{\n+  fprintf (f, \"%s\", str1);\n+  print_generic_expr (f, expr1, TDF_SLIM);\n+  fprintf (f, \"%s\", str2);\n+  print_generic_expr (f, expr2, TDF_SLIM);\n+  fprintf (f, \"%s\", str3);\n+}\n+\n+\n+/* Called if a coalesce across and abnormal edge cannot be performed.  PHI is\n+   the phi node at fault, I is the argument index at fault.  A message is \n+   printed and compilation is then terminated.  */\n+\n+static inline void\n+abnormal_corrupt (tree phi, int i)\n+{\n+  edge e = PHI_ARG_EDGE (phi, i);\n+  tree res = PHI_RESULT (phi);\n+  tree arg = PHI_ARG_DEF (phi, i);\n+\n+  fprintf (stderr, \" Corrupt SSA across abnormal edge BB%d->BB%d\\n\",\n+\t   e->src->index, e->dest->index);\n+  fprintf (stderr, \"Argument %d (\", i);\n+  print_generic_expr (stderr, arg, TDF_SLIM);\n+  if (TREE_CODE (arg) != SSA_NAME)\n+    fprintf (stderr, \") is not an SSA_NAME.\\n\");\n+  else\n+    {\n+      gcc_assert (SSA_NAME_VAR (res) != SSA_NAME_VAR (arg));\n+      fprintf (stderr, \") does not have the same base variable as the result \");\n+      print_generic_stmt (stderr, res, TDF_SLIM);\n+    }\n+\n+  internal_error (\"SSA corruption\");\n+}\n+\n+\n+/* Print a failure to coalesce a MUST_COALESCE pair X and Y.  */\n+\n+static inline void\n+fail_abnormal_edge_coalesce (int x, int y)\n+{\n+  fprintf (stderr, \"\\nUnable to coalesce ssa_names %d  and %d \",x, y);\n+  fprintf (stderr, \" which are marked as MUST COALESCE.\\n\");\n+  print_generic_expr (stderr, ssa_name (x), TDF_SLIM);\n+  fprintf (stderr, \" and  \");\n+  print_generic_stmt (stderr, ssa_name (y), TDF_SLIM);\n+\n+  internal_error (\"SSA corruption\");\n+}\n+\n+\n+/* This function creates a var_map for the current function as well as creating\n+   a coalesce list for use later in the out of ssa process.  */\n+\n+static var_map\n+create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  tree var;\n+  tree stmt;\n+  tree first;\n+  var_map map;\n+  ssa_op_iter iter;\n+  int v1, v2, cost;\n+  unsigned i;\n+\n+#ifdef ENABLE_CHECKING\n+  bitmap used_in_real_ops;\n+  bitmap used_in_virtual_ops;\n+\n+  used_in_real_ops = BITMAP_ALLOC (NULL);\n+  used_in_virtual_ops = BITMAP_ALLOC (NULL);\n+#endif\n+\n+  map = init_var_map (num_ssa_names + 1);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      tree phi, arg;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  int i;\n+\t  int ver;\n+\t  tree res;\n+\t  bool saw_copy = false;\n+\n+\t  res = PHI_RESULT (phi);\n+\t  ver = SSA_NAME_VERSION (res);\n+\t  register_ssa_partition (map, res);\n+\n+\t  /* Register ssa_names and coalesces between the args and the result \n+\t     of all PHI.  */\n+\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+\t    {\n+\t      edge e = PHI_ARG_EDGE (phi, i);\n+\t      arg = PHI_ARG_DEF (phi, i);\n+\t      if (TREE_CODE (arg) == SSA_NAME)\n+\t\tregister_ssa_partition (map, arg);\n+\t      if (TREE_CODE (arg) == SSA_NAME \n+\t\t  && SSA_NAME_VAR (arg) == SSA_NAME_VAR (res))\n+\t        {\n+\t\t  saw_copy = true;\n+\t\t  bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (arg));\n+\t\t  if ((e->flags & EDGE_ABNORMAL) == 0)\n+\t\t    {\n+\t\t      int cost = coalesce_cost_edge (e);\n+\t\t      if (cost == 1 && single_imm_use_p (arg))\n+\t\t        add_cost_one_coalesce (cl, ver, SSA_NAME_VERSION (arg));\n+\t\t      else\n+\t\t\tadd_coalesce (cl, ver, SSA_NAME_VERSION (arg), cost);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        if (e->flags & EDGE_ABNORMAL)\n+\t\t  abnormal_corrupt (phi, i);\n+\t    }\n+\t  if (saw_copy)\n+\t    bitmap_set_bit (used_in_copy, ver);\n+\t}\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+        {\n+\t  stmt = bsi_stmt (bsi);\n+\n+\t  /* Register USE and DEF operands in each statement.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, (SSA_OP_DEF|SSA_OP_USE))\n+\t    register_ssa_partition (map, var);\n+\n+\t  /* Check for copy coalesces.  */\n+\t  switch (TREE_CODE (stmt))\n+\t    {\n+\t    case GIMPLE_MODIFY_STMT:\n+\t      {\n+\t\ttree op1 = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t\ttree op2 = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t\tif (TREE_CODE (op1) == SSA_NAME \n+\t\t    && TREE_CODE (op2) == SSA_NAME\n+\t\t    && SSA_NAME_VAR (op1) == SSA_NAME_VAR (op2))\n+\t\t  {\n+\t\t    v1 = SSA_NAME_VERSION (op1);\n+\t\t    v2 = SSA_NAME_VERSION (op2);\n+\t\t    cost = coalesce_cost_bb (bb);\n+\t\t    add_coalesce (cl, v1, v2, cost);\n+\t\t    bitmap_set_bit (used_in_copy, v1);\n+\t\t    bitmap_set_bit (used_in_copy, v2);\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    case ASM_EXPR:\n+\t      {\n+\t\tunsigned long noutputs, i;\n+\t\ttree *outputs, link;\n+\t\tnoutputs = list_length (ASM_OUTPUTS (stmt));\n+\t\toutputs = (tree *) alloca (noutputs * sizeof (tree));\n+\t\tfor (i = 0, link = ASM_OUTPUTS (stmt); link;\n+\t\t     ++i, link = TREE_CHAIN (link))\n+\t\t  outputs[i] = TREE_VALUE (link);\n+\n+\t\tfor (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n+\t\t  {\n+\t\t    const char *constraint\n+\t\t      = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+\t\t    tree input = TREE_VALUE (link);\n+\t\t    char *end;\n+\t\t    unsigned long match;\n+\n+\t\t    if (TREE_CODE (input) != SSA_NAME && !DECL_P (input))\n+\t\t      continue;\n+\n+\t\t    match = strtoul (constraint, &end, 10);\n+\t\t    if (match >= noutputs || end == constraint)\n+\t\t      continue;\n+\n+\t\t    if (TREE_CODE (outputs[match]) != SSA_NAME)\n+\t\t      continue;\n+\n+\t\t    v1 = SSA_NAME_VERSION (outputs[match]);\n+\t\t    v2 = SSA_NAME_VERSION (input);\n+\n+\t\t    if (SSA_NAME_VAR (outputs[match]) == SSA_NAME_VAR (input))\n+\t\t      {\n+\t\t\tcost = coalesce_cost (REG_BR_PROB_BASE, \n+\t\t\t\t\t      maybe_hot_bb_p (bb),\n+\t\t\t\t\t      false);\n+\t\t\tadd_coalesce (cl, v1, v2, cost);\n+\t\t\tbitmap_set_bit (used_in_copy, v1);\n+\t\t\tbitmap_set_bit (used_in_copy, v2);\n+\t\t      }\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t    \n+#ifdef ENABLE_CHECKING\n+\t  /* Mark real uses and defs.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, (SSA_OP_DEF|SSA_OP_USE))\n+\t    bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (var)));\n+\n+\t  /* Validate that virtual ops don't get used in funny ways.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, \n+\t\t\t\t     SSA_OP_VIRTUAL_USES | SSA_OP_VMUSTDEF)\n+\t    {\n+\t      bitmap_set_bit (used_in_virtual_ops, \n+\t\t\t      DECL_UID (SSA_NAME_VAR (var)));\n+\t    }\n+\n+#endif /* ENABLE_CHECKING */\n+\t}\n+    }\n+\n+  /* Now process result decls and live on entry variables for entry into\n+     the coalesce list.  */\n+  first = NULL_TREE;\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      var = map->partition_to_var[i];\n+      if (var != NULL_TREE)\n+        {\n+\t  /* Add coalesces between all the result decls.  */\n+\t  if (TREE_CODE (SSA_NAME_VAR (var)) == RESULT_DECL)\n+\t    {\n+\t      if (first == NULL_TREE)\n+\t\tfirst = var;\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (SSA_NAME_VAR (var) == SSA_NAME_VAR (first));\n+\t\t  v1 = SSA_NAME_VERSION (first);\n+\t\t  v2 = SSA_NAME_VERSION (var);\n+\t\t  bitmap_set_bit (used_in_copy, v1);\n+\t\t  bitmap_set_bit (used_in_copy, v2);\n+\t\t  cost = coalesce_cost_bb (EXIT_BLOCK_PTR);\n+\t\t  add_coalesce (cl, v1, v2, cost);\n+\t\t}\n+\t    }\n+\t  /* Mark any default_def variables as being in the coalesce list\n+\t     since they will have to be coalesced with the base variable.  If\n+\t     not marked as present, they won't be in the coalesce view. */\n+\t  if (gimple_default_def (cfun, SSA_NAME_VAR (var)) == var)\n+\t    bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (var));\n+\t}\n+    }\n+\n+#if defined ENABLE_CHECKING\n+  {\n+    unsigned i;\n+    bitmap both = BITMAP_ALLOC (NULL);\n+    bitmap_and (both, used_in_real_ops, used_in_virtual_ops);\n+    if (!bitmap_empty_p (both))\n+      {\n+\tbitmap_iterator bi;\n+\n+\tEXECUTE_IF_SET_IN_BITMAP (both, 0, i, bi)\n+\t  fprintf (stderr, \"Variable %s used in real and virtual operands\\n\",\n+\t\t   get_name (referenced_var (i)));\n+\tinternal_error (\"SSA corruption\");\n+      }\n+\n+    BITMAP_FREE (used_in_real_ops);\n+    BITMAP_FREE (used_in_virtual_ops);\n+    BITMAP_FREE (both);\n+  }\n+#endif\n+\n+  return map;\n+}\n+\n+\n+/* Attempt to coalesce ssa verisons X and Y together using the partition\n+   mapping in MAP and checking conflicts in GRAPH.  Output any debug info to\n+   DEBUG, if it is nun-NULL.  */\n+\n+static inline bool\n+attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n+\t\t  FILE *debug)\n+{\n+  int z;\n+  tree var1, var2;\n+  int p1, p2;\n+\n+  p1 = var_to_partition (map, ssa_name (x));\n+  p2 = var_to_partition (map, ssa_name (y));\n+\n+  if (debug)\n+    {\n+      fprintf (debug, \"(%d)\", x);\n+      print_generic_expr (debug, partition_to_var (map, p1), TDF_SLIM);\n+      fprintf (debug, \" & (%d)\", y);\n+      print_generic_expr (debug, partition_to_var (map, p2), TDF_SLIM);\n+    }\n+\n+  if (p1 == p2) \n+    {\n+      if (debug)\n+\tfprintf (debug, \": Already Coalesced.\\n\");\n+      return true;\n+    }\n+\n+  if (debug)\n+    fprintf (debug, \" [map: %d, %d] \", p1, p2);\n+\n+\n+  if (!ssa_conflicts_test_p (graph, p1, p2))\n+    {\n+      var1 = partition_to_var (map, p1);\n+      var2 = partition_to_var (map, p2);\n+      z = var_union (map, var1, var2);\n+      if (z == NO_PARTITION)\n+\t{\n+\t  if (debug)\n+\t    fprintf (debug, \": Unable to perform partition union.\\n\");\n+\t  return false;\n+\t}\n+\n+      /* z is the new combined partition.  Remove the other partition from \n+\t the list, and merge the conflicts.  */\n+      if (z == p1)\n+\tssa_conflicts_merge (graph, p1, p2);\n+      else\n+\tssa_conflicts_merge (graph, p2, p1);\n+\n+      if (debug)\n+\tfprintf (debug, \": Success -> %d\\n\", z);\n+      return true;\n+    }\n+\n+  if (debug)\n+    fprintf (debug, \": Fail due to conflict\\n\");\n+\n+  return false;\n+}\n+\n+\n+/* Attempt to Coalesce partitions in MAP which occur in the list CL using \n+   GRAPH.  Debug output is sent to DEBUG if it is non-NULL.  */\n+\n+static void\n+coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl, \n+\t\t     FILE *debug)\n+{\n+  int x = 0, y = 0;\n+  tree var1, var2, phi;\n+  int cost;\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* First, coalece all the copie across abnormal edges.  These are not placed\n+     in the coalesce list becase they do not need to be sorted, and simply \n+     consume extra memory/compilation time in large programs.  */\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  {\n+\t    for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t      {\n+\t\ttree res = PHI_RESULT (phi);\n+\t        tree arg = PHI_ARG_DEF (phi, e->dest_idx);\n+\t\tint v1 = SSA_NAME_VERSION (res);\n+\t\tint v2 = SSA_NAME_VERSION (arg);\n+\n+\t\tif (SSA_NAME_VAR (arg) != SSA_NAME_VAR (res))\n+\t\t  abnormal_corrupt (phi, e->dest_idx);\n+\n+\t\tif (debug)\n+\t\t  fprintf (debug, \"Abnormal coalesce: \");\n+\n+\t\tif (!attempt_coalesce (map, graph, v1, v2, debug))\n+\t\t  fail_abnormal_edge_coalesce (v1, v2);\n+\t      }\n+\t  }\n+    }\n+\n+  /* Now process the items in the coalesce list.  */\n+\n+  while ((cost = pop_best_coalesce (cl, &x, &y)) != NO_BEST_COALESCE)\n+    {\n+      var1 = ssa_name (x);\n+      var2 = ssa_name (y);\n+\n+      /* Assert the coalesces have the same base variable.  */\n+      gcc_assert (SSA_NAME_VAR (var1) == SSA_NAME_VAR (var2));\n+\n+      if (debug)\n+\tfprintf (debug, \"Coalesce list: \");\n+      attempt_coalesce (map, graph, x, y, debug);\n+    }\n+}\n+\n+\n+/* Reduce the number of copies by coalescing variables in the function.  Return\n+   a partition map with the resulting coalesces.  */\n+\n+extern var_map\n+coalesce_ssa_name (void)\n+{\n+  unsigned num, x;\n+  tree_live_info_p liveinfo;\n+  ssa_conflicts_p graph;\n+  coalesce_list_p cl;\n+  bitmap used_in_copies = BITMAP_ALLOC (NULL);\n+  var_map map;\n+\n+  cl = create_coalesce_list ();\n+  map = create_outofssa_var_map (cl, used_in_copies);\n+\n+  /* Don't calculate live ranges for variables not in the coalesce list.  */\n+  partition_view_bitmap (map, used_in_copies, true);\n+  BITMAP_FREE (used_in_copies);\n+\n+  if (num_var_partitions (map) <= 1)\n+    {\n+      delete_coalesce_list (cl);\n+      return map;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_var_map (dump_file, map);\n+\n+  liveinfo = calculate_live_ranges (map);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_live_info (dump_file, liveinfo, LIVEDUMP_ENTRY);\n+\n+  /* Build a conflict graph.  */\n+  graph = build_ssa_conflict_graph (liveinfo);\n+  delete_tree_live_info (liveinfo);\n+\n+  sort_coalesce_list (cl);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nAfter sorting:\\n\");\n+      dump_coalesce_list (dump_file, cl);\n+    }\n+\n+  /* First, coalesce all live on entry variables to their base variable. \n+     This will ensure the first use is coming from the correct location.  */\n+\n+  num = num_var_partitions (map);\n+  for (x = 0 ; x < num; x++)\n+    {\n+      tree var = partition_to_var (map, x);\n+      tree root;\n+\n+      if (TREE_CODE (var) != SSA_NAME)\n+\tcontinue;\n+\n+      root = SSA_NAME_VAR (var);\n+      if (gimple_default_def (cfun, root) == var)\n+        {\n+\t  /* This root variable should have not already been assigned\n+\t     to another partition which is not coalesced with this one.  */\n+\t  gcc_assert (!var_ann (root)->out_of_ssa_tag);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      print_exprs (dump_file, \"Must coalesce \", var,\n+\t\t\t   \" with the root variable \", root, \".\\n\");\n+\t    }\n+\t  change_partition_var (map, root, x);\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_var_map (dump_file, map);\n+\n+  /* Now coalesce everything in the list.  */\n+  coalesce_partitions (map, graph, cl, \n+\t\t       ((dump_flags & TDF_DETAILS) ? dump_file\n+\t\t\t\t\t\t   : NULL));\n+\n+  delete_coalesce_list (cl);\n+  ssa_conflicts_delete (graph);\n+\n+  return map;\n+}\n+"}, {"sha": "2049e43d0d4caf167e8466d3184442c8f41d1540", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 233, "deletions": 1142, "changes": 1375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -24,44 +24,107 @@ Boston, MA 02110-1301, USA.  */\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n-#include \"flags.h\"\n-#include \"basic-block.h\"\n-#include \"function.h\"\n #include \"diagnostic.h\"\n #include \"bitmap.h\"\n #include \"tree-flow.h\"\n-#include \"tree-gimple.h\"\n-#include \"tree-inline.h\"\n-#include \"varray.h\"\n-#include \"timevar.h\"\n-#include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\"\n #include \"toplev.h\"\n-#include \"vecprim.h\"\n-\n-static void live_worklist (tree_live_info_p);\n-static tree_live_info_p new_tree_live_info (var_map);\n-static inline void set_if_valid (var_map, bitmap, tree);\n-static inline void add_conflicts_if_valid (tpa_p, conflict_graph,\n-\t\t\t\t\t   var_map, bitmap, tree);\n-static partition_pair_p find_partition_pair (coalesce_list_p, int, int, bool);\n+\n #ifdef ENABLE_CHECKING\n static void  verify_live_on_entry (tree_live_info_p);\n #endif\n \n-/* This is where the mapping from SSA version number to real storage variable\n-   is tracked.  \n \n-   All SSA versions of the same variable may not ultimately be mapped back to\n-   the same real variable. In that instance, we need to detect the live\n-   range overlap, and give one of the variable new storage. The vector\n-   'partition_to_var' tracks which partition maps to which variable.\n+/* VARMAP maintains a mapping from SSA version number to real variables.\n+\n+   All SSA_NAMES are divided into partitions.  Initially each ssa_name is the\n+   only member of it's own partition.  Coalescing will attempt to group any\n+   ssa_names which occur in a copy or in a PHI node into the same partition.\n+\n+   At the end of out-of-ssa, each partition becomes a \"real\" variable and is\n+   rewritten as a compiler variable.\n+\n+   The var_map datat structure is used to manage these partitions.  It allows\n+   partitions to be combined, and determines which partition belongs to what\n+   ssa_name or variable, and vice versa.  */\n+\n+\n+/* This routine will initialize the basevar fields of MAP.  */\n+\n+static void\n+var_map_base_init (var_map map)\n+{\n+  int x, num_part, num;\n+  tree var;\n+  var_ann_t ann;\n+  \n+  num = 0;\n+  num_part = num_var_partitions (map);\n+\n+  /* If a base table already exists, clear it, otherwise create it.  */\n+  if (map->partition_to_base_index != NULL)\n+    {\n+      free (map->partition_to_base_index);\n+      VEC_truncate (tree, map->basevars, 0);\n+    }\n+  else\n+    map->basevars = VEC_alloc (tree, heap, MAX (40, (num_part / 10)));\n+\n+  map->partition_to_base_index = (int *) xmalloc (sizeof (int) * num_part);\n+\n+  /* Build the base variable list, and point partitions at their bases.  */\n+  for (x = 0; x < num_part; x++)\n+    {\n+      var = partition_to_var (map, x);\n+      if (TREE_CODE (var) == SSA_NAME)\n+\t var = SSA_NAME_VAR (var);\n+      ann = var_ann (var);\n+      /* If base variable hasn't been seen, set it up.  */\n+      if (!ann->base_var_processed)\n+        {\n+\t  ann->base_var_processed = 1;\n+\t  VAR_ANN_BASE_INDEX (ann) = num++;\n+\t  VEC_safe_push (tree, heap, map->basevars, var);\n+\t}\n+      map->partition_to_base_index[x] = VAR_ANN_BASE_INDEX (ann);\n+    }\n \n-   Given a VAR, it is sometimes desirable to know which partition that VAR\n-   represents.  There is an additional field in the variable annotation to\n-   track that information.  */\n+  map->num_basevars = num;\n \n+  /* Now clear the processed bit.  */\n+  for (x = 0; x < num; x++)\n+    {\n+       var = VEC_index (tree, map->basevars, x);\n+       var_ann (var)->base_var_processed = 0;\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  for (x = 0; x < num_part; x++)\n+    {\n+      tree var2;\n+      var = SSA_NAME_VAR (partition_to_var (map, x));\n+      var2 = VEC_index (tree, map->basevars, basevar_index (map, x));\n+      gcc_assert (var == var2);\n+    }\n+#endif\n+}\n+\n+\n+/* Remove the base table in MAP.  */\n+\n+static void\n+var_map_base_fini (var_map map)\n+{\n+  /* Free the basevar info if it is present.  */\n+  if (map->partition_to_base_index != NULL)\n+    {\n+      VEC_free (tree, heap, map->basevars);\n+      free (map->partition_to_base_index);\n+      map->partition_to_base_index = NULL;\n+      map->num_basevars = 0;\n+    }\n+}\n /* Create a variable partition map of SIZE, initialize and return it.  */\n \n var_map\n@@ -75,10 +138,13 @@ init_var_map (int size)\n \t      = (tree *)xmalloc (size * sizeof (tree));\n   memset (map->partition_to_var, 0, size * sizeof (tree));\n \n-  map->partition_to_compact = NULL;\n-  map->compact_to_partition = NULL;\n+  map->partition_to_view = NULL;\n+  map->view_to_partition = NULL;\n   map->num_partitions = size;\n   map->partition_size = size;\n+  map->num_basevars = 0;\n+  map->partition_to_base_index = NULL;\n+  map->basevars = NULL;\n   return map;\n }\n \n@@ -88,12 +154,13 @@ init_var_map (int size)\n void\n delete_var_map (var_map map)\n {\n+  var_map_base_fini (map);\n   free (map->partition_to_var);\n   partition_delete (map->var_partition);\n-  if (map->partition_to_compact)\n-    free (map->partition_to_compact);\n-  if (map->compact_to_partition)\n-    free (map->compact_to_partition);\n+  if (map->partition_to_view)\n+    free (map->partition_to_view);\n+  if (map->view_to_partition)\n+    free (map->view_to_partition);\n   free (map);\n }\n \n@@ -109,17 +176,17 @@ var_union (var_map map, tree var1, tree var2)\n   tree root_var = NULL_TREE;\n   tree other_var = NULL_TREE;\n \n-  /* This is independent of partition_to_compact. If partition_to_compact is \n+  /* This is independent of partition_to_view. If partition_to_view is \n      on, then whichever one of these partitions is absorbed will never have a\n-     dereference into the partition_to_compact array any more.  */\n+     dereference into the partition_to_view array any more.  */\n \n   if (TREE_CODE (var1) == SSA_NAME)\n     p1 = partition_find (map->var_partition, SSA_NAME_VERSION (var1));\n   else\n     {\n       p1 = var_to_partition (map, var1);\n-      if (map->compact_to_partition)\n-        p1 = map->compact_to_partition[p1];\n+      if (map->view_to_partition)\n+        p1 = map->view_to_partition[p1];\n       root_var = var1;\n     }\n   \n@@ -128,8 +195,8 @@ var_union (var_map map, tree var1, tree var2)\n   else\n     {\n       p2 = var_to_partition (map, var2);\n-      if (map->compact_to_partition)\n-        p2 = map->compact_to_partition[p2];\n+      if (map->view_to_partition)\n+        p2 = map->view_to_partition[p2];\n \n       /* If there is no root_var set, or it's not a user variable, set the\n \t root_var to this one.  */\n@@ -150,8 +217,8 @@ var_union (var_map map, tree var1, tree var2)\n   else\n     p3 = partition_union (map->var_partition, p1, p2);\n \n-  if (map->partition_to_compact)\n-    p3 = map->partition_to_compact[p3];\n+  if (map->partition_to_view)\n+    p3 = map->partition_to_view[p3];\n \n   if (root_var)\n     change_partition_var (map, root_var, p3);\n@@ -161,12 +228,12 @@ var_union (var_map map, tree var1, tree var2)\n   return p3;\n }\n \n-\n+ \n /* Compress the partition numbers in MAP such that they fall in the range \n    0..(num_partitions-1) instead of wherever they turned out during\n    the partitioning exercise.  This removes any references to unused\n    partitions, thereby allowing bitmaps and other vectors to be much\n-   denser.  Compression type is controlled by FLAGS.\n+   denser.  \n \n    This is implemented such that compaction doesn't affect partitioning.\n    Ie., once partitions are created and possibly merged, running one\n@@ -179,96 +246,140 @@ var_union (var_map map, tree var1, tree var2)\n    definitions, and then 'recompact' later to include all the single\n    definitions for assignment to program variables.  */\n \n-void \n-compact_var_map (var_map map, int flags)\n+\n+/* Set MAP back to the initial state of having no partition view.  Return a \n+   bitmap which has a bit set for each partition number which is in use in the \n+   varmap.  */\n+\n+static bitmap\n+partition_view_init (var_map map)\n {\n-  sbitmap used;\n-  int tmp, root, root_i;\n-  unsigned int x, limit, count;\n-  tree var;\n-  root_var_p rv = NULL;\n+  bitmap used;\n+  int tmp;\n+  unsigned int x;\n \n-  limit = map->partition_size;\n-  used = sbitmap_alloc (limit);\n-  sbitmap_zero (used);\n+  used = BITMAP_ALLOC (NULL);\n \n-  /* Already compressed? Abandon the old one.  */\n-  if (map->partition_to_compact)\n+  /* Already in a view? Abandon the old one.  */\n+  if (map->partition_to_view)\n     {\n-      free (map->partition_to_compact);\n-      map->partition_to_compact = NULL;\n+      free (map->partition_to_view);\n+      map->partition_to_view = NULL;\n     }\n-  if (map->compact_to_partition)\n+  if (map->view_to_partition)\n     {\n-      free (map->compact_to_partition);\n-      map->compact_to_partition = NULL;\n+      free (map->view_to_partition);\n+      map->view_to_partition = NULL;\n     }\n \n-  map->num_partitions = map->partition_size;\n-\n-  if (flags & VARMAP_NO_SINGLE_DEFS)\n-    rv = root_var_init (map);\n-\n-  map->partition_to_compact = (int *)xmalloc (limit * sizeof (int));\n-  memset (map->partition_to_compact, 0xff, (limit * sizeof (int)));\n-\n   /* Find out which partitions are actually referenced.  */\n-  count = 0;\n-  for (x = 0; x < limit; x++)\n+  for (x = 0; x < map->partition_size; x++)\n     {\n       tmp = partition_find (map->var_partition, x);\n-      if (!TEST_BIT (used, tmp) && map->partition_to_var[tmp] != NULL_TREE)\n-        {\n-\t  /* It is referenced, check to see if there is more than one version\n-\t     in the root_var table, if one is available.  */\n-\t  if (rv)\n-\t    {\n-\t      root = root_var_find (rv, tmp);\n-\t      root_i = root_var_first_partition (rv, root);\n-\t      /* If there is only one, don't include this in the compaction.  */\n-\t      if (root_var_next_partition (rv, root_i) == ROOT_VAR_NONE)\n-\t        continue;\n-\t    }\n-\t  SET_BIT (used, tmp);\n-\t  count++;\n-\t}\n+      if (map->partition_to_var[tmp] != NULL_TREE && !bitmap_bit_p (used, tmp))\n+\tbitmap_set_bit (used, tmp);\n     }\n \n-  /* Build a compacted partitioning.  */\n-  if (count != limit)\n+  map->num_partitions = map->partition_size;\n+  return used;\n+}\n+\n+\n+/* This routine will finalize the view data for MAP based on the partitions\n+   set in SELECTED.  This is either the same bitmap returned from \n+   partition_view_init, or a trimmed down version if some of those partitions\n+   were not desired in this view.  SELECTED is freed before returning.  */\n+\n+static void \n+partition_view_fini (var_map map, bitmap selected)\n+{\n+  bitmap_iterator bi;\n+  unsigned count, i, x, limit;\n+  tree var;\n+\n+  gcc_assert (selected);\n+\n+  count = bitmap_count_bits (selected);\n+  limit = map->partition_size;\n+\n+  /* If its a one-to-one ratio, we don't need any view compaction.  */\n+  if (count < limit)\n     {\n-      sbitmap_iterator sbi;\n+      map->partition_to_view = (int *)xmalloc (limit * sizeof (int));\n+      memset (map->partition_to_view, 0xff, (limit * sizeof (int)));\n+      map->view_to_partition = (int *)xmalloc (count * sizeof (int));\n \n-      map->compact_to_partition = (int *)xmalloc (count * sizeof (int));\n-      count = 0;\n-      /* SSA renaming begins at 1, so skip 0 when compacting.  */\n-      EXECUTE_IF_SET_IN_SBITMAP (used, 1, x, sbi)\n+      i = 0;\n+      /* Give each selected partition an index.  */\n+      EXECUTE_IF_SET_IN_BITMAP (selected, 0, x, bi)\n \t{\n-\t  map->partition_to_compact[x] = count;\n-\t  map->compact_to_partition[count] = x;\n+\t  map->partition_to_view[x] = i;\n+\t  map->view_to_partition[i] = x;\n \t  var = map->partition_to_var[x];\n+\t  /* If any one of the members of a partition is not an SSA_NAME, make\n+\t     sure it is the representative.  */\n \t  if (TREE_CODE (var) != SSA_NAME)\n-\t    change_partition_var (map, var, count);\n-\t  count++;\n+\t    change_partition_var (map, var, i);\n+\t  i++;\n \t}\n+      gcc_assert (i == count);\n+      map->num_partitions = i;\n     }\n+\n+  BITMAP_FREE (selected);\n+}\n+\n+\n+/* Create a partition view which includes all the used partitions in MAP.  If \n+   WANT_BASES is true, create the base variable map as well.  */\n+\n+extern void\n+partition_view_normal (var_map map, bool want_bases)\n+{\n+  bitmap used;\n+\n+  used = partition_view_init (map);\n+  partition_view_fini (map, used);\n+\n+  if (want_bases)\n+    var_map_base_init (map);\n   else\n+    var_map_base_fini (map);\n+}\n+\n+\n+/* Create a partition view in MAP which includes just partitions which occur in \n+   the bitmap ONLY. If WANT_BASES is true, create the base variable map \n+   as well.  */\n+\n+extern void\n+partition_view_bitmap (var_map map, bitmap only, bool want_bases)\n+{\n+  bitmap used;\n+  bitmap new_partitions = BITMAP_ALLOC (NULL);\n+  unsigned x, p;\n+  bitmap_iterator bi;\n+\n+  used = partition_view_init (map);\n+  EXECUTE_IF_SET_IN_BITMAP (only, 0, x, bi)\n     {\n-      free (map->partition_to_compact);\n-      map->partition_to_compact = NULL;\n+      p = partition_find (map->var_partition, x);\n+      gcc_assert (bitmap_bit_p (used, p));\n+      bitmap_set_bit (new_partitions, p);\n     }\n+  partition_view_fini (map, new_partitions);\n \n-  map->num_partitions = count;\n-\n-  if (rv)\n-    root_var_delete (rv);\n-  sbitmap_free (used);\n+  BITMAP_FREE (used);\n+  if (want_bases)\n+    var_map_base_init (map);\n+  else\n+    var_map_base_fini (map);\n }\n \n \n /* This function is used to change the representative variable in MAP for VAR's \n-   partition from an SSA_NAME variable to a regular variable.  This allows \n-   partitions to be mapped back to real variables.  */\n+   partition to a regular non-ssa variable.  This allows partitions to be \n+   mapped back to real variables.  */\n   \n void \n change_partition_var (var_map map, tree var, int part)\n@@ -280,10 +391,11 @@ change_partition_var (var_map map, tree var, int part)\n   ann = var_ann (var);\n   ann->out_of_ssa_tag = 1;\n   VAR_ANN_PARTITION (ann) = part;\n-  if (map->compact_to_partition)\n-    map->partition_to_var[map->compact_to_partition[part]] = var;\n+  if (map->view_to_partition)\n+    map->partition_to_var[map->view_to_partition[part]] = var;\n }\n \n+\n static inline void mark_all_vars_used (tree *);\n \n /* Helper function for mark_all_vars_used, called via walk_tree.  */\n@@ -319,6 +431,7 @@ mark_all_vars_used_1 (tree *tp, int *walk_subtrees,\n   return NULL;\n }\n \n+\n /* Mark all VAR_DECLS under *EXPR_P as used, so that they won't be \n    eliminated during the tree->rtl conversion process.  */\n \n@@ -394,102 +507,6 @@ remove_unused_locals (void)\n     }\n }\n \n-/* This function looks through the program and uses FLAGS to determine what \n-   SSA versioned variables are given entries in a new partition table.  This\n-   new partition map is returned.  */\n-\n-var_map\n-create_ssa_var_map (void)\n-{\n-  block_stmt_iterator bsi;\n-  basic_block bb;\n-  tree var;\n-  tree stmt;\n-  var_map map;\n-  ssa_op_iter iter;\n-#ifdef ENABLE_CHECKING\n-  bitmap used_in_real_ops;\n-  bitmap used_in_virtual_ops;\n-#endif\n-\n-  map = init_var_map (num_ssa_names + 1);\n-\n-#ifdef ENABLE_CHECKING\n-  used_in_real_ops = BITMAP_ALLOC (NULL);\n-  used_in_virtual_ops = BITMAP_ALLOC (NULL);\n-#endif\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      tree phi, arg;\n-\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  int i;\n-\t  register_ssa_partition (map, PHI_RESULT (phi));\n-\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\t    {\n-\t      arg = PHI_ARG_DEF (phi, i);\n-\t      if (TREE_CODE (arg) == SSA_NAME)\n-\t\tregister_ssa_partition (map, arg);\n-\n-\t      mark_all_vars_used (&PHI_ARG_DEF_TREE (phi, i));\n-\t    }\n-\t}\n-\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-        {\n-\t  stmt = bsi_stmt (bsi);\n-\n-\t  /* Register USE and DEF operands in each statement.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, (SSA_OP_DEF|SSA_OP_USE))\n-\t    {\n-\t      register_ssa_partition (map, var);\n-\n-#ifdef ENABLE_CHECKING\n-\t      bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (var)));\n-#endif\n-\t    }\n-\n-#ifdef ENABLE_CHECKING\n-\t  /* Validate that virtual ops don't get used in funny ways.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, \n-\t\t\t\t     SSA_OP_VIRTUAL_USES | SSA_OP_VMUSTDEF)\n-\t    {\n-\t      bitmap_set_bit (used_in_virtual_ops, \n-\t\t\t      DECL_UID (SSA_NAME_VAR (var)));\n-\t    }\n-\n-#endif /* ENABLE_CHECKING */\n-\n-\t  mark_all_vars_used (bsi_stmt_ptr (bsi));\n-\t}\n-    }\n-\n-#if defined ENABLE_CHECKING\n-  {\n-    unsigned i;\n-    bitmap both = BITMAP_ALLOC (NULL);\n-    bitmap_and (both, used_in_real_ops, used_in_virtual_ops);\n-    if (!bitmap_empty_p (both))\n-      {\n-\tbitmap_iterator bi;\n-\n-\tEXECUTE_IF_SET_IN_BITMAP (both, 0, i, bi)\n-\t  fprintf (stderr, \"Variable %s used in real and virtual operands\\n\",\n-\t\t   get_name (referenced_var (i)));\n-\tinternal_error (\"SSA corruption\");\n-      }\n-\n-    BITMAP_FREE (used_in_real_ops);\n-    BITMAP_FREE (used_in_virtual_ops);\n-    BITMAP_FREE (both);\n-  }\n-#endif\n-\n-  return map;\n-}\n-\n \n /* Allocate and return a new live range information object base on MAP.  */\n \n@@ -541,7 +558,7 @@ delete_tree_live_info (tree_live_info_p live)\n }\n \n \n-/* Visit basic block BB, and propogate any required live on entry bits from \n+/* Visit basic block BB and propogate any required live on entry bits from \n    LIVE into the predecessors.  VISITED is the bitmap of visited blocks.  \n    TMP is a temporary work bitmap which is passed in to avoid reallocting\n    it each time.  */\n@@ -565,8 +582,8 @@ loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited,\n       pred_bb = e->src;\n       if (pred_bb == ENTRY_BLOCK_PTR)\n \tcontinue;\n-      /* tmp is vars live-=on-entry from BB that aren't defined in the\n-\t pred. block.  This should be the live on entry vars to pred.  \n+      /* TMP is variables live-on-entry from BB that aren't defined in the\n+\t predecessor block.  This should be the live on entry vars to pred.  \n \t Note that liveout is the DEFs in a block while live on entry is\n \t being calculated.  */\n       bitmap_and_compl (tmp, loe, live->liveout[pred_bb->index]);\n@@ -636,7 +653,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n   if (stmt)\n     {\n       def_bb = bb_for_stmt (stmt);\n-      /* Mark defs in liveout bitmap for now.  */\n+      /* Mark defs in liveout bitmap temporarily.  */\n       if (def_bb)\n \tbitmap_set_bit (live->liveout[def_bb->index], p);\n     }\n@@ -698,7 +715,7 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n   edge e;\n   edge_iterator ei;\n \n-  /* live on entry calculations used the liveouit vector for defs.  */\n+  /* live on entry calculations used liveout vectors for defs, clear them.  */\n   FOR_EACH_BB (bb)\n     bitmap_clear (liveinfo->liveout[bb->index]);\n \n@@ -720,14 +737,15 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n \t      bitmap_set_bit (liveinfo->liveout[e->src->index], p);\n \t  }\n \n-      /* add each successors live on entry to this bock live on exit.  */\n+      /* Add each successors live on entry to this bock live on exit.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n         if (e->dest != EXIT_BLOCK_PTR)\n \t  bitmap_ior_into (liveinfo->liveout[bb->index],\n \t\t\t   live_on_entry (liveinfo, e->dest));\n     }\n }\n \n+\n /* Given partition map MAP, calculate all the live on entry bitmaps for \n    each partition.  Return a new live info object.  */\n \n@@ -757,936 +775,6 @@ calculate_live_ranges (var_map map)\n }\n \n \n-/* Initialize a tree_partition_associator object using MAP.  */\n-\n-static tpa_p\n-tpa_init (var_map map)\n-{\n-  tpa_p tpa;\n-  int num_partitions = num_var_partitions (map);\n-  int x;\n-\n-  if (num_partitions == 0)\n-    return NULL;\n-\n-  tpa = (tpa_p) xmalloc (sizeof (struct tree_partition_associator_d));\n-  tpa->num_trees = 0;\n-  tpa->uncompressed_num = -1;\n-  tpa->map = map;\n-  tpa->next_partition = (int *)xmalloc (num_partitions * sizeof (int));\n-  memset (tpa->next_partition, TPA_NONE, num_partitions * sizeof (int));\n-\n-  tpa->partition_to_tree_map = (int *)xmalloc (num_partitions * sizeof (int));\n-  memset (tpa->partition_to_tree_map, TPA_NONE, num_partitions * sizeof (int));\n-\n-  x = MAX (40, (num_partitions / 20));\n-  tpa->trees = VEC_alloc (tree, heap, x);\n-  tpa->first_partition = VEC_alloc (int, heap, x);\n-\n-  return tpa;\n-\n-}\n-\n-\n-/* Remove PARTITION_INDEX from TREE_INDEX's list in the tpa structure TPA.  */\n-\n-void\n-tpa_remove_partition (tpa_p tpa, int tree_index, int partition_index)\n-{\n-  int i;\n-\n-  i = tpa_first_partition (tpa, tree_index);\n-  if (i == partition_index)\n-    {\n-      VEC_replace (int, tpa->first_partition, tree_index,\n-\t\t   tpa->next_partition[i]);\n-    }\n-  else\n-    {\n-      for ( ; i != TPA_NONE; i = tpa_next_partition (tpa, i))\n-        {\n-\t  if (tpa->next_partition[i] == partition_index)\n-\t    {\n-\t      tpa->next_partition[i] = tpa->next_partition[partition_index];\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-/* Free the memory used by tree_partition_associator object TPA.  */\n-\n-void\n-tpa_delete (tpa_p tpa)\n-{\n-  if (!tpa)\n-    return;\n-\n-  VEC_free (tree, heap, tpa->trees);\n-  VEC_free (int, heap, tpa->first_partition);\n-  free (tpa->partition_to_tree_map);\n-  free (tpa->next_partition);\n-  free (tpa);\n-}\n-\n-\n-/* This function will remove any tree entries from TPA which have only a single\n-   element.  This will help keep the size of the conflict graph down.  The \n-   function returns the number of remaining tree lists.  */\n-\n-int \n-tpa_compact (tpa_p tpa)\n-{\n-  int last, x, y, first, swap_i;\n-  tree swap_t;\n-\n-  /* Find the last list which has more than 1 partition.  */\n-  for (last = tpa->num_trees - 1; last > 0; last--)\n-    {\n-      first = tpa_first_partition (tpa, last);\n-      if (tpa_next_partition (tpa, first) != NO_PARTITION)\n-        break;\n-    }\n-\n-  x = 0;\n-  while (x < last)\n-    {\n-      first = tpa_first_partition (tpa, x);\n-\n-      /* If there is not more than one partition, swap with the current end\n-\t of the tree list.  */\n-      if (tpa_next_partition (tpa, first) == NO_PARTITION)\n-        {\n-\t  swap_t = VEC_index (tree, tpa->trees, last);\n-\t  swap_i = VEC_index (int, tpa->first_partition, last);\n-\n-\t  /* Update the last entry. Since it is known to only have one\n-\t     partition, there is nothing else to update.  */\n-\t  VEC_replace (tree, tpa->trees, last,\n-\t\t       VEC_index (tree, tpa->trees, x));\n-\t  VEC_replace (int, tpa->first_partition, last,\n-\t\t       VEC_index (int, tpa->first_partition, x));\n-\t  tpa->partition_to_tree_map[tpa_first_partition (tpa, last)] = last;\n-\n-\t  /* Since this list is known to have more than one partition, update\n-\t     the list owner entries.  */\n-\t  VEC_replace (tree, tpa->trees, x, swap_t);\n-\t  VEC_replace (int, tpa->first_partition, x, swap_i);\n-\t  for (y = tpa_first_partition (tpa, x); \n-\t       y != NO_PARTITION; \n-\t       y = tpa_next_partition (tpa, y))\n-\t    tpa->partition_to_tree_map[y] = x;\n-\n-\t  /* Ensure last is a list with more than one partition.  */\n-\t  last--;\n-\t  for (; last > x; last--)\n-\t    {\n-\t      first = tpa_first_partition (tpa, last);\n-\t      if (tpa_next_partition (tpa, first) != NO_PARTITION)\n-\t\tbreak;\n-\t    }\n-\t}\n-      x++;\n-    }\n-\n-  first = tpa_first_partition (tpa, x);\n-  if (tpa_next_partition (tpa, first) != NO_PARTITION)\n-    x++;\n-  tpa->uncompressed_num = tpa->num_trees;\n-  tpa->num_trees = x;\n-  return last;\n-}\n-\n-\n-/* Initialize a root_var object with SSA partitions from MAP which are based \n-   on each root variable.  */\n-\n-root_var_p\n-root_var_init (var_map map)\n-{\n-  root_var_p rv;\n-  int num_partitions = num_var_partitions (map);\n-  int x, p;\n-  tree t;\n-  var_ann_t ann;\n-  sbitmap seen;\n-\n-  rv = tpa_init (map);\n-  if (!rv)\n-    return NULL;\n-\n-  seen = sbitmap_alloc (num_partitions);\n-  sbitmap_zero (seen);\n-\n-  /* Start at the end and work towards the front. This will provide a list\n-     that is ordered from smallest to largest.  */\n-  for (x = num_partitions - 1; x >= 0; x--)\n-    {\n-      t = partition_to_var (map, x);\n-\n-      /* The var map may not be compacted yet, so check for NULL.  */\n-      if (!t) \n-        continue;\n-\n-      p = var_to_partition (map, t);\n-\n-      gcc_assert (p != NO_PARTITION);\n-\n-      /* Make sure we only put coalesced partitions into the list once.  */\n-      if (TEST_BIT (seen, p))\n-        continue;\n-      SET_BIT (seen, p);\n-      if (TREE_CODE (t) == SSA_NAME)\n-\tt = SSA_NAME_VAR (t);\n-      ann = var_ann (t);\n-      if (ann->root_var_processed)\n-        {\n-\t  rv->next_partition[p] = VEC_index (int, rv->first_partition, \n-\t\t\t\t\t     VAR_ANN_ROOT_INDEX (ann));\n-\t  VEC_replace (int, rv->first_partition, VAR_ANN_ROOT_INDEX (ann), p);\n-\t}\n-      else\n-        {\n-\t  ann->root_var_processed = 1;\n-\t  VAR_ANN_ROOT_INDEX (ann) = rv->num_trees++;\n-\t  VEC_safe_push (tree, heap, rv->trees, t);\n-\t  VEC_safe_push (int, heap, rv->first_partition, p);\n-\t}\n-      rv->partition_to_tree_map[p] = VAR_ANN_ROOT_INDEX (ann);\n-    }\n-\n-  /* Reset the out_of_ssa_tag flag on each variable for later use.  */\n-  for (x = 0; x < rv->num_trees; x++)\n-    {\n-      t = VEC_index (tree, rv->trees, x);\n-      var_ann (t)->root_var_processed = 0;\n-    }\n-\n-  sbitmap_free (seen);\n-  return rv;\n-}\n-\n-\n-/* Hash function for 2 integer coalesce pairs.  */\n-#define COALESCE_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n-\n-\n-/* Return hash value for partition pair PAIR.  */\n-\n-unsigned int \n-partition_pair_map_hash (const void *pair)\n-{\n-  hashval_t a = (hashval_t)(((partition_pair_p)pair)->first_partition);\n-  hashval_t b = (hashval_t)(((partition_pair_p)pair)->second_partition);\n-\n-  return COALESCE_HASH_FN (a,b);\n-}\n-\n-\n-/* Return TRUE if PAIR1 is equivalent to PAIR2.  */\n-\n-int \n-partition_pair_map_eq (const void *pair1, const void *pair2)\n-{\n-  partition_pair_p p1 = (partition_pair_p) pair1;\n-  partition_pair_p p2 = (partition_pair_p) pair2;\n-\n-  return (p1->first_partition == p2->first_partition\n-\t  && p1->second_partition == p2->second_partition);\n-}\n-\n-\n-/* Create a new coalesce list object from MAP and return it.  */\n-\n-coalesce_list_p \n-create_coalesce_list (var_map map)\n-{\n-  coalesce_list_p list;\n-  unsigned size = num_ssa_names * 3;\n-\n-  if (size < 40)\n-    size = 40;\n-\n-  list = xmalloc (sizeof (struct coalesce_list_d));\n-  list->list = htab_create (size, partition_pair_map_hash,\n-  \t\t\t    partition_pair_map_eq, NULL);\n-\n-  list->map = map;\n-  list->sorted = NULL;\n-  list->add_mode = true;\n-  list->num_sorted = 0;\n-  return list;\n-}\n-\n-\n-/* Delete coalesce list CL.  */\n-\n-void \n-delete_coalesce_list (coalesce_list_p cl)\n-{\n-  htab_delete (cl->list);\n-  if (cl->sorted)\n-    free (cl->sorted);\n-  gcc_assert (cl->num_sorted == 0);\n-  free (cl);\n-}\n-\n-\n-/* Find a matching coalesce pair object in CL for partitions P1 and P2.  If \n-   one isn't found, return NULL if CREATE is false, otherwise create a new \n-   coalesce pair object and return it.  */\n-\n-static partition_pair_p\n-find_partition_pair (coalesce_list_p cl, int p1, int p2, bool create)\n-{\n-  struct partition_pair p, *pair;\n-  void **slot;\n-  unsigned int hash;\n-    \n-  /* normalize so that p1 is the smaller value.  */\n-  if (p2 < p1)\n-    {\n-      p.first_partition = p2;\n-      p.second_partition = p1;\n-    }\n-  else\n-    {\n-      p.first_partition = p1;\n-      p.second_partition = p2;\n-    }\n-  \n-  \n-  hash = partition_pair_map_hash (&p);\n-  pair = (struct partition_pair *) htab_find_with_hash (cl->list, &p, hash);\n-\n-  if (create && !pair)\n-    {\n-      gcc_assert (cl->add_mode);\n-      pair = xmalloc (sizeof (struct partition_pair));\n-      pair->first_partition = p.first_partition;\n-      pair->second_partition = p.second_partition;\n-      pair->cost = 0;\n-      slot = htab_find_slot_with_hash (cl->list, pair, hash, INSERT);\n-      *(struct partition_pair **)slot = pair;\n-    }\n-\n-  return pair;\n-}\n-\n-/* Return cost of execution of copy instruction with FREQUENCY\n-   possibly on CRITICAL edge and in HOT basic block.  */\n-int\n-coalesce_cost (int frequency, bool hot, bool critical)\n-{\n-  /* Base costs on BB frequencies bounded by 1.  */\n-  int cost = frequency;\n-\n-  if (!cost)\n-    cost = 1;\n-  if (optimize_size || hot)\n-    cost = 1;\n-  /* Inserting copy on critical edge costs more\n-     than inserting it elsewhere.  */\n-  if (critical)\n-    cost *= 2;\n-  return cost;\n-}\n-\n-/* Add a potential coalesce between P1 and P2 in CL with a cost of VALUE.  */\n-\n-void \n-add_coalesce (coalesce_list_p cl, int p1, int p2,\n-\t      int value)\n-{\n-  partition_pair_p node;\n-\n-  gcc_assert (cl->add_mode);\n-\n-  if (p1 == p2)\n-    return;\n-\n-  node = find_partition_pair (cl, p1, p2, true);\n-\n-  node->cost += value;\n-}\n-\n-\n-/* Comparison function to allow qsort to sort P1 and P2 in Ascending order.  */\n-\n-static\n-int compare_pairs (const void *p1, const void *p2)\n-{\n-  return (*(partition_pair_p *)p1)->cost - (*(partition_pair_p *)p2)->cost;\n-}\n-\n-\n-static inline int\n-num_coalesce_pairs (coalesce_list_p cl)\n-{\n-  return htab_elements (cl->list);\n-}\n-\n-typedef struct\n-{\n-  htab_iterator hti;\n-} partition_pair_iterator;\n-\n-static inline partition_pair_p\n-first_partition_pair (coalesce_list_p cl, partition_pair_iterator *iter)\n-{\n-  partition_pair_p pair;\n-\n-  pair = (partition_pair_p) first_htab_element (&(iter->hti), cl->list);\n-  return pair;\n-}\n-\n-static inline bool\n-end_partition_pair_p (partition_pair_iterator *iter)\n-{\n-  return end_htab_p (&(iter->hti));\n-}\n-\n-static inline partition_pair_p\n-next_partition_pair (partition_pair_iterator *iter)\n-{\n-  partition_pair_p pair;\n-\n-  pair = (partition_pair_p) next_htab_element (&(iter->hti));\n-  return pair;\n-}\n-\n-#define FOR_EACH_PARTITION_PAIR(PAIR, ITER, CL)\t\t\\\n-  for ((PAIR) = first_partition_pair ((CL), &(ITER));\t\\\n-       !end_partition_pair_p (&(ITER));\t\t\t\\\n-       (PAIR) = next_partition_pair (&(ITER)))\n-\n-\n-/* Prepare CL for removal of preferred pairs.  When finished, list element \n-   0 has all the coalesce pairs, sorted in order from most important coalesce \n-   to least important.  */\n-\n-void\n-sort_coalesce_list (coalesce_list_p cl)\n-{\n-  unsigned x, num;\n-  partition_pair_p p;\n-  partition_pair_iterator ppi;\n-\n-  gcc_assert (cl->add_mode);\n-\n-  cl->add_mode = false;\n-\n-  /* allocate a vector for the pair pointers.  */\n-  num = num_coalesce_pairs (cl);\n-  cl->num_sorted = num;\n-  if (num == 0)\n-    return;\n-  cl->sorted = XNEWVEC (partition_pair_p, num);\n-\n-  /* Populate the vector with pointers to the partition pairs.  */\n-  \n-  x = 0;\n-  FOR_EACH_PARTITION_PAIR (p, ppi, cl)\n-    cl->sorted[x++] = p;\n-  gcc_assert (x == num);\n-\n-  if (num == 1)\n-    return;\n-\n-  if (num == 2)\n-    {\n-      if (cl->sorted[0]->cost > cl->sorted[1]->cost)\n-        {\n-\t  p = cl->sorted[0];\n-\t  cl->sorted[0] = cl->sorted[1];\n-\t  cl->sorted[1] = p;\n-\t}\n-      return;\n-    }\n-\n-  /* Only call qsort if there are more than 2 items.  */\n-  if (num > 2)\n-      qsort (cl->sorted, num, sizeof (partition_pair_p), compare_pairs);\n-}\n-\n-\n-/* Retrieve the best remaining pair to coalesce from CL.  Returns the 2 \n-   partitions via P1 and P2.  Their calculated cost is returned by the function.\n-   NO_BEST_COALESCE is returned if the coalesce list is empty.  */\n-\n-static int\n-pop_best_coalesce (coalesce_list_p cl, int *p1, int *p2)\n-{\n-  partition_pair_p node;\n-  int ret;\n-\n-  gcc_assert (!cl->add_mode);\n-\n-  if (cl->num_sorted == 0)\n-    return NO_BEST_COALESCE;\n-\n-  node = cl->sorted[--(cl->num_sorted)];\n-\n-  *p1 = node->first_partition;\n-  *p2 = node->second_partition;\n-  ret = node->cost;\n-  free (node);\n-\n-  return ret;\n-}\n-\n-\n-/* If variable VAR is in a partition in MAP, add a conflict in GRAPH between \n-   VAR and any other live partitions in VEC which are associated via TPA.  \n-   Reset the live bit in VEC.  */\n-\n-static inline void \n-add_conflicts_if_valid (tpa_p tpa, conflict_graph graph,\n-\t\t\tvar_map map, bitmap vec, tree var)\n-{ \n-  int p, y, first;\n-  p = var_to_partition (map, var);\n-  if (p != NO_PARTITION)\n-    { \n-      bitmap_clear_bit (vec, p);\n-      first = tpa_find_tree (tpa, p);\n-      /* If find returns nothing, this object isn't interesting.  */\n-      if (first == TPA_NONE)\n-        return;\n-      /* Only add interferences between objects in the same list.  */\n-      for (y = tpa_first_partition (tpa, first);\n-\t   y != TPA_NONE;\n-\t   y = tpa_next_partition (tpa, y))\n-\t{\n-\t  if (bitmap_bit_p (vec, y))\n-\t    conflict_graph_add (graph, p, y);\n-\t}\n-    }\n-}\n-\n-\n-/* If VAR is in a partition of MAP, set the bit for that partition in VEC.  */\n-\n-static inline void\n-set_if_valid (var_map map, bitmap vec, tree var)\n-{\n-  int p = var_to_partition (map, var);\n-  if (p != NO_PARTITION)\n-    bitmap_set_bit (vec, p);\n-}\n-\n-/* Return a conflict graph for the information contained in LIVE_INFO.  Only\n-   conflicts between items in the same TPA list are added.  If optional \n-   coalesce list CL is passed in, any copies encountered are added.  */\n-\n-conflict_graph\n-build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa, \n-\t\t\t   coalesce_list_p cl)\n-{\n-  conflict_graph graph;\n-  var_map map;\n-  bitmap live;\n-  unsigned x, y, i;\n-  basic_block bb;\n-  int *partition_link, *tpa_nodes;\n-  VEC(int,heap) *tpa_to_clear;\n-  unsigned l;\n-  ssa_op_iter iter;\n-  bitmap_iterator bi;\n-\n-  map = live_var_map (liveinfo);\n-  graph = conflict_graph_new (num_var_partitions (map));\n-\n-  if (tpa_num_trees (tpa) == 0)\n-    return graph;\n-\n-  live = BITMAP_ALLOC (NULL);\n-\n-  partition_link = XCNEWVEC (int, num_var_partitions (map) + 1);\n-  tpa_nodes = XCNEWVEC (int, tpa_num_trees (tpa));\n-  tpa_to_clear = VEC_alloc (int, heap, 50);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator bsi;\n-      tree phi;\n-      int idx;\n-\n-      /* Start with live on exit temporaries.  */\n-      bitmap_copy (live, live_on_exit (liveinfo, bb));\n-\n-      for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n-        {\n-\t  bool is_a_copy = false;\n-\t  tree stmt = bsi_stmt (bsi);\n-\n-\t  /* A copy between 2 partitions does not introduce an interference \n-\t     by itself.  If they did, you would never be able to coalesce \n-\t     two things which are copied.  If the two variables really do \n-\t     conflict, they will conflict elsewhere in the program.  \n-\t     \n-\t     This is handled specially here since we may also be interested \n-\t     in copies between real variables and SSA_NAME variables.  We may\n-\t     be interested in trying to coalesce SSA_NAME variables with\n-\t     root variables in some cases.  */\n-\n-\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n-\t    {\n-\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t      int p1, p2;\n-\t      int bit;\n-\n-\t      if (DECL_P (lhs) || TREE_CODE (lhs) == SSA_NAME)\n-\t\tp1 = var_to_partition (map, lhs);\n-\t      else \n-\t\tp1 = NO_PARTITION;\n-\n-\t      if (DECL_P (rhs) || TREE_CODE (rhs) == SSA_NAME)\n-\t\tp2 = var_to_partition (map, rhs);\n-\t      else \n-\t\tp2 = NO_PARTITION;\n-\n-\t      if (p1 != NO_PARTITION && p2 != NO_PARTITION)\n-\t\t{\n-\t\t  is_a_copy = true;\n-\t\t  bit = bitmap_bit_p (live, p2);\n-\t\t  /* If the RHS is live, make it not live while we add\n-\t\t     the conflicts, then make it live again.  */\n-\t\t  if (bit)\n-\t\t    bitmap_clear_bit (live, p2);\n-\t\t  add_conflicts_if_valid (tpa, graph, map, live, lhs);\n-\t\t  if (bit)\n-\t\t    bitmap_set_bit (live, p2);\n-\t\t  if (cl)\n-\t\t    add_coalesce (cl, p1, p2,\n-\t\t\t\t  coalesce_cost (bb->frequency,\n-\t\t\t\t                 maybe_hot_bb_p (bb), false));\n-\t\t  set_if_valid (map, live, rhs);\n-\t\t}\n-\t    }\n-\n-\t  if (!is_a_copy)\n-\t    {\n-\t      tree var;\n-\t      FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_DEF)\n-\t\t{\n-\t\t  add_conflicts_if_valid (tpa, graph, map, live, var);\n-\t\t}\n-\n-\t      FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n-\t\t{\n-\t\t  set_if_valid (map, live, var);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If result of a PHI is unused, then the loops over the statements\n-\t will not record any conflicts.  However, since the PHI node is \n-\t going to be translated out of SSA form we must record a conflict\n-\t between the result of the PHI and any variables with are live. \n-\t Otherwise the out-of-ssa translation may create incorrect code.  */\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  tree result = PHI_RESULT (phi);\n-\t  int p = var_to_partition (map, result);\n-\n-\t  if (p != NO_PARTITION && ! bitmap_bit_p (live, p))\n-\t    add_conflicts_if_valid (tpa, graph, map, live, result);\n-\t}\n-\n-      /* Anything which is still live at this point interferes.  \n-\t In order to implement this efficiently, only conflicts between\n-\t partitions which have the same TPA root need be added.\n-\t TPA roots which have been seen are tracked in 'tpa_nodes'.  A nonzero\n-\t entry points to an index into 'partition_link', which then indexes \n-\t into itself forming a linked list of partitions sharing a tpa root \n-\t which have been seen as live up to this point.  Since partitions start\n-\t at index zero, all entries in partition_link are (partition + 1).\n-\n-\t Conflicts are added between the current partition and any already seen.\n-\t tpa_clear contains all the tpa_roots processed, and these are the only\n-\t entries which need to be zero'd out for a clean restart.  */\n-\n-      EXECUTE_IF_SET_IN_BITMAP (live, 0, x, bi)\n-        {\n-\t  i = tpa_find_tree (tpa, x);\n-\t  if (i != (unsigned)TPA_NONE)\n-\t    {\n-\t      int start = tpa_nodes[i];\n-\t      /* If start is 0, a new root reference list is being started.\n-\t\t Register it to be cleared.  */\n-\t      if (!start)\n-\t\tVEC_safe_push (int, heap, tpa_to_clear, i);\n-\n-\t      /* Add interferences to other tpa members seen.  */\n-\t      for (y = start; y != 0; y = partition_link[y])\n-\t\tconflict_graph_add (graph, x, y - 1);\n-\t      tpa_nodes[i] = x + 1;\n-\t      partition_link[x + 1] = start;\n-\t    }\n-\t}\n-\n-\t/* Now clear the used tpa root references.  */\n-\tfor (l = 0; VEC_iterate (int, tpa_to_clear, l, idx); l++)\n-\t  tpa_nodes[idx] = 0;\n-\tVEC_truncate (int, tpa_to_clear, 0);\n-    }\n-\n-  free (tpa_nodes);\n-  free (partition_link);\n-  VEC_free (int, heap, tpa_to_clear);\n-  BITMAP_FREE (live);\n-  return graph;\n-}\n-\n-\n-/* This routine will attempt to coalesce the elements in TPA subject to the\n-   conflicts found in GRAPH.  If optional coalesce_list CL is provided, \n-   only coalesces specified within the coalesce list are attempted.  Otherwise \n-   an attempt is made to coalesce as many partitions within each TPA grouping \n-   as possible.  If DEBUG is provided, debug output will be sent there.  */\n-\n-void\n-coalesce_tpa_members (tpa_p tpa, conflict_graph graph, var_map map, \n-\t\t      coalesce_list_p cl, FILE *debug)\n-{\n-  int x, y, z, w;\n-  tree var, tmp;\n-\n-  /* Attempt to coalesce any items in a coalesce list.  */\n-  if (cl)\n-    {\n-      while (pop_best_coalesce (cl, &x, &y) != NO_BEST_COALESCE)\n-        {\n-\t  if (debug)\n-\t    {\n-\t      fprintf (debug, \"Coalesce list: (%d)\", x);\n-\t      print_generic_expr (debug, partition_to_var (map, x), TDF_SLIM);\n-\t      fprintf (debug, \" & (%d)\", y);\n-\t      print_generic_expr (debug, partition_to_var (map, y), TDF_SLIM);\n-\t    }\n-\n-\t  w = tpa_find_tree (tpa, x);\n-\t  z = tpa_find_tree (tpa, y);\n-\t  if (w != z || w == TPA_NONE || z == TPA_NONE)\n-\t    {\n-\t      if (debug)\n-\t\t{\n-\t\t  if (w != z)\n-\t\t    fprintf (debug, \": Fail, Non-matching TPA's\\n\");\n-\t\t  if (w == TPA_NONE)\n-\t\t    fprintf (debug, \": Fail %d non TPA.\\n\", x);\n-\t\t  else\n-\t\t    fprintf (debug, \": Fail %d non TPA.\\n\", y);\n-\t\t}\n-\t      continue;\n-\t    }\n-\t  var = partition_to_var (map, x);\n-\t  tmp = partition_to_var (map, y);\n-\t  x = var_to_partition (map, var);\n-\t  y = var_to_partition (map, tmp);\n-\t  if (debug)\n-\t    fprintf (debug, \" [map: %d, %d] \", x, y);\n-\t  if (x == y)\n-\t    {\n-\t      if (debug)\n-\t\tfprintf (debug, \": Already Coalesced.\\n\");\n-\t      continue;\n-\t    }\n-\t  if (!conflict_graph_conflict_p (graph, x, y))\n-\t    {\n-\t      z = var_union (map, var, tmp);\n-\t      if (z == NO_PARTITION)\n-\t        {\n-\t\t  if (debug)\n-\t\t    fprintf (debug, \": Unable to perform partition union.\\n\");\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* z is the new combined partition. We need to remove the other\n-\t         partition from the list. Set x to be that other partition.  */\n-\t      if (z == x)\n-\t        {\n-\t\t  conflict_graph_merge_regs (graph, x, y);\n-\t\t  w = tpa_find_tree (tpa, y);\n-\t\t  tpa_remove_partition (tpa, w, y);\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  conflict_graph_merge_regs (graph, y, x);\n-\t\t  w = tpa_find_tree (tpa, x);\n-\t\t  tpa_remove_partition (tpa, w, x);\n-\t\t}\n-\n-\t      if (debug)\n-\t\tfprintf (debug, \": Success -> %d\\n\", z);\n-\t    }\n-\t  else\n-\t    if (debug)\n-\t      fprintf (debug, \": Fail due to conflict\\n\");\n-\t}\n-      /* If using a coalesce list, don't try to coalesce anything else.  */\n-      return;\n-    }\n-\n-  for (x = 0; x < tpa_num_trees (tpa); x++)\n-    {\n-      while (tpa_first_partition (tpa, x) != TPA_NONE)\n-        {\n-\t  int p1, p2;\n-\t  /* Coalesce first partition with anything that doesn't conflict.  */\n-\t  y = tpa_first_partition (tpa, x);\n-\t  tpa_remove_partition (tpa, x, y);\n-\n-\t  var = partition_to_var (map, y);\n-\t  /* p1 is the partition representative to which y belongs.  */\n-\t  p1 = var_to_partition (map, var);\n-\t  \n-\t  for (z = tpa_next_partition (tpa, y); \n-\t       z != TPA_NONE; \n-\t       z = tpa_next_partition (tpa, z))\n-\t    {\n-\t      tmp = partition_to_var (map, z);\n-\t      /* p2 is the partition representative to which z belongs.  */\n-\t      p2 = var_to_partition (map, tmp);\n-\t      if (debug)\n-\t\t{\n-\t\t  fprintf (debug, \"Coalesce : \");\n-\t\t  print_generic_expr (debug, var, TDF_SLIM);\n-\t\t  fprintf (debug, \" &\");\n-\t\t  print_generic_expr (debug, tmp, TDF_SLIM);\n-\t\t  fprintf (debug, \"  (%d ,%d)\", p1, p2);\n-\t\t}\n-\n-\t      /* If partitions are already merged, don't check for conflict.  */\n-\t      if (tmp == var)\n-\t        {\n-\t\t  tpa_remove_partition (tpa, x, z);\n-\t\t  if (debug)\n-\t\t    fprintf (debug, \": Already coalesced\\n\");\n-\t\t}\n-\t      else\n-\t\tif (!conflict_graph_conflict_p (graph, p1, p2))\n-\t\t  {\n-\t\t    int v;\n-\t\t    if (tpa_find_tree (tpa, y) == TPA_NONE \n-\t\t\t|| tpa_find_tree (tpa, z) == TPA_NONE)\n-\t\t      {\n-\t\t\tif (debug)\n-\t\t\t  fprintf (debug, \": Fail non-TPA member\\n\");\n-\t\t\tcontinue;\n-\t\t      }\n-\t\t    if ((v = var_union (map, var, tmp)) == NO_PARTITION)\n-\t\t      {\n-\t\t\tif (debug)\n-\t\t\t  fprintf (debug, \": Fail cannot combine partitions\\n\");\n-\t\t\tcontinue;\n-\t\t      }\n-\n-\t\t    tpa_remove_partition (tpa, x, z);\n-\t\t    if (v == p1)\n-\t\t      conflict_graph_merge_regs (graph, v, z);\n-\t\t    else\n-\t\t      {\n-\t\t\t/* Update the first partition's representative.  */\n-\t\t\tconflict_graph_merge_regs (graph, v, y);\n-\t\t\tp1 = v;\n-\t\t      }\n-\n-\t\t    /* The root variable of the partition may be changed\n-\t\t       now.  */\n-\t\t    var = partition_to_var (map, p1);\n-\n-\t\t    if (debug)\n-\t\t      fprintf (debug, \": Success -> %d\\n\", v);\n-\t\t  }\n-\t\telse\n-\t\t  if (debug)\n-\t\t    fprintf (debug, \": Fail, Conflict\\n\");\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-/* Send debug info for coalesce list CL to file F.  */\n-\n-void \n-dump_coalesce_list (FILE *f, coalesce_list_p cl)\n-{\n-  partition_pair_p node;\n-  partition_pair_iterator ppi;\n-  int x;\n-  tree var;\n-\n-  if (cl->add_mode)\n-    {\n-      fprintf (f, \"Coalesce List:\\n\");\n-      FOR_EACH_PARTITION_PAIR (node, ppi, cl)\n-        {\n-\t  tree var1 = partition_to_var (cl->map, node->first_partition);\n-\t  tree var2 = partition_to_var (cl->map, node->second_partition);\n-\t  print_generic_expr (f, var1, TDF_SLIM);\n-\t  fprintf (f, \" <-> \");\n-\t  print_generic_expr (f, var2, TDF_SLIM);\n-\t  fprintf (f, \"  (%1d), \", node->cost);\n-\t  fprintf (f, \"\\n\");\n-\t}\n-    }\n-  else\n-    {\n-      fprintf (f, \"Sorted Coalesce list:\\n\");\n-      for (x = cl->num_sorted - 1 ; x >=0; x--)\n-        {\n-\t  node = cl->sorted[x];\n-\t  fprintf (f, \"(%d) \", node->cost);\n-\t  var = partition_to_var (cl->map, node->first_partition);\n-\t  print_generic_expr (f, var, TDF_SLIM);\n-\t  fprintf (f, \" <-> \");\n-\t  var = partition_to_var (cl->map, node->second_partition);\n-\t  print_generic_expr (f, var, TDF_SLIM);\n-\t  fprintf (f, \"\\n\");\n-\t}\n-    }\n-}\n-\n-\n-/* Output tree_partition_associator object TPA to file F..  */\n-\n-void\n-tpa_dump (FILE *f, tpa_p tpa)\n-{\n-  int x, i;\n-\n-  if (!tpa)\n-    return;\n-\n-  for (x = 0; x < tpa_num_trees (tpa); x++)\n-    {\n-      print_generic_expr (f, tpa_tree (tpa, x), TDF_SLIM);\n-      fprintf (f, \" : (\");\n-      for (i = tpa_first_partition (tpa, x); \n-\t   i != TPA_NONE;\n-\t   i = tpa_next_partition (tpa, i))\n-\t{\n-\t  fprintf (f, \"(%d)\",i);\n-\t  print_generic_expr (f, partition_to_var (tpa->map, i), TDF_SLIM);\n-\t  fprintf (f, \" \");\n-\n-#ifdef ENABLE_CHECKING\n-\t  if (tpa_find_tree (tpa, i) != x)\n-\t    fprintf (f, \"**find tree incorrectly set** \");\n-#endif\n-\n-\t}\n-      fprintf (f, \")\\n\");\n-    }\n-  fflush (f);\n-}\n-\n-\n /* Output partition map MAP to file F.  */\n \n void\n@@ -1700,8 +788,8 @@ dump_var_map (FILE *f, var_map map)\n \n   for (x = 0; x < map->num_partitions; x++)\n     {\n-      if (map->compact_to_partition != NULL)\n-\tp = map->compact_to_partition[x];\n+      if (map->view_to_partition != NULL)\n+\tp = map->view_to_partition[x];\n       else\n \tp = x;\n \n@@ -1712,8 +800,8 @@ dump_var_map (FILE *f, var_map map)\n       for (y = 1; y < num_ssa_names; y++)\n         {\n \t  p = partition_find (map->var_partition, y);\n-\t  if (map->partition_to_compact)\n-\t    p = map->partition_to_compact[p];\n+\t  if (map->partition_to_view)\n+\t    p = map->partition_to_view[p];\n \t  if (p == (int)x)\n \t    {\n \t      if (t++ == 0)\n@@ -1771,7 +859,10 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n     }\n }\n \n+\n #ifdef ENABLE_CHECKING\n+/* Verify that SSA_VAR is a non-virtual SSA_NAME.  */\n+\n void\n register_ssa_partition_check (tree ssa_var)\n {\n@@ -1787,6 +878,7 @@ register_ssa_partition_check (tree ssa_var)\n \n \n /* Verify that the info in LIVE matches the current cfg.  */\n+\n static void\n verify_live_on_entry (tree_live_info_p live)\n {\n@@ -1802,7 +894,6 @@ verify_live_on_entry (tree_live_info_p live)\n    /* Check for live on entry partitions and report those with a DEF in\n       the program. This will typically mean an optimization has done\n       something wrong.  */\n-\n   bb = ENTRY_BLOCK_PTR;\n   num = 0;\n   FOR_EACH_EDGE (e, ei, bb->succs)"}, {"sha": "bddd4ba77c67a4f0e4fc56d7c14406c3388150f6", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 85, "deletions": 310, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -26,56 +26,83 @@ Boston, MA 02110-1301, USA.  */\n #include \"partition.h\"\n #include \"vecprim.h\"\n \n-/* Used to create the variable mapping when we go out of SSA form.  */\n+\n+\n+/* Used to create the variable mapping when we go out of SSA form.  \n+\n+   Mapping from an ssa_name to a partition number is maintained, as well as\n+   partition number to back to ssa_name. A parition can also be represented\n+   by a non-ssa_name variable.  This allows ssa_names and thier partition to \n+   be coalesced with live on entry compiler variables, as well as eventually\n+   having real compiler variables assigned to each partition as part of the \n+   final stage of going of of ssa.  \n+\n+   Non-ssa_names maintain their partition index in the variable annotation.\n+\n+   This data structure also supports \"views\", which work on a subset of all\n+   partitions.  This allows the coalescer to decide what partitions are \n+   interesting to it, and only work with those partitions.  Whenever the view\n+   is changed, the partition numbers change, but none of the partition groupings\n+   change. (ie, it is truly a view since it doesnt change anything)\n+\n+   The final component of the data structure is the basevar map.  This provides\n+   a list of all the different base variables which occue in a partition view,\n+   and a unique index for each one. Routines are provided to quickly produce\n+   the base variable of a partition.\n+\n+   Note that members of a partition MUST all have the same base variable.  */\n+\n typedef struct _var_map\n {\n-  /* The partition of all variables.  */\n+  /* The partition manager of all variables.  */\n   partition var_partition;\n \n-  /* Vector for compacting partitions.  */\n-  int *partition_to_compact;\n-  int *compact_to_partition;\n+  /* Vector for managing partitions views.  */\n+  int *partition_to_view;\n+  int *view_to_partition;\n \n-  /* Mapping of partition numbers to vars.  */\n+  /* Mapping of partition numbers to variables.  */\n   tree *partition_to_var;\n \n-  /* Current number of partitions.  */\n+  /* Current number of partitions in var_map based on the current view.  */\n   unsigned int num_partitions;\n \n-  /* Original partition size.  */\n+  /* Original full partition size.  */\n   unsigned int partition_size;\n+\n+  /* Number of base variables in the base var list.  */\n+  int num_basevars;\n+\n+  /* Map of partitions numbers to base variable table indexes.  */\n+  int *partition_to_base_index;\n+\n+  /* Table of base variable's.  */\n+  VEC (tree, heap) *basevars;\n } *var_map;\n \n-#define VAR_ANN_PARTITION(ann) (ann->partition)\n-#define VAR_ANN_ROOT_INDEX(ann) (ann->root_index)\n \n-#define NO_PARTITION\t\t-1\n+/* Partition number of a  non ssa-name variable.  */\n+#define VAR_ANN_PARTITION(ann) (ann->partition)\n+/* Index iot the basevar table of a non ssa-name variable.  */\n+#define VAR_ANN_BASE_INDEX(ann) (ann->base_index)\n \n-/* Flags to pass to compact_var_map  */\n \n-#define VARMAP_NORMAL\t\t0\n-#define VARMAP_NO_SINGLE_DEFS\t1\n+/* Value used to represent no partition number.  */\n+#define NO_PARTITION\t\t-1\n \n extern var_map init_var_map (int);\n extern void delete_var_map (var_map);\n extern void dump_var_map (FILE *, var_map);\n extern int var_union (var_map, tree, tree);\n extern void change_partition_var (var_map, tree, int);\n-extern void compact_var_map (var_map, int);\n+extern void partition_view_normal (var_map, bool);\n+extern void partition_view_bitmap (var_map, bitmap, bool);\n #ifdef ENABLE_CHECKING\n extern void register_ssa_partition_check (tree ssa_var);\n #endif\n \n-static inline unsigned num_var_partitions (var_map);\n-static inline tree var_to_partition_to_var (var_map, tree);\n-static inline tree partition_to_var (var_map, int);\n-static inline int var_to_partition (var_map, tree);\n-static inline tree version_to_var (var_map, int);\n-static inline void register_ssa_partition (var_map, tree);\n \n-extern var_map create_ssa_var_map (void);\n-\n-/* Number of partitions in MAP.  */\n+/* Return number of partitions in MAP.  */\n \n static inline unsigned\n num_var_partitions (var_map map)\n@@ -90,8 +117,8 @@ num_var_partitions (var_map map)\n static inline tree\n partition_to_var (var_map map, int i)\n {\n-  if (map->compact_to_partition)\n-    i = map->compact_to_partition[i];\n+  if (map->view_to_partition)\n+    i = map->view_to_partition[i];\n   i = partition_find (map->var_partition, i);\n   return map->partition_to_var[i];\n }\n@@ -100,12 +127,13 @@ partition_to_var (var_map map, int i)\n /* Given ssa_name VERSION, if it has a partition in MAP,  return the var it \n    is associated with.  Otherwise return NULL.  */\n \n-static inline tree version_to_var (var_map map, int version)\n+static inline tree \n+version_to_var (var_map map, int version)\n {\n   int part;\n   part = partition_find (map->var_partition, version);\n-  if (map->partition_to_compact)\n-    part = map->partition_to_compact[part];\n+  if (map->partition_to_view)\n+    part = map->partition_to_view[part];\n   if (part == NO_PARTITION)\n     return NULL_TREE;\n   \n@@ -125,8 +153,8 @@ var_to_partition (var_map map, tree var)\n   if (TREE_CODE (var) == SSA_NAME)\n     {\n       part = partition_find (map->var_partition, SSA_NAME_VERSION (var));\n-      if (map->partition_to_compact)\n-\tpart = map->partition_to_compact[part];\n+      if (map->partition_to_view)\n+\tpart = map->partition_to_view[part];\n     }\n   else\n     {\n@@ -155,9 +183,29 @@ var_to_partition_to_var (var_map map, tree var)\n }\n \n \n-/* This routine registers a partition for SSA_VAR with MAP.  IS_USE is used \n-   to count references.  Any unregistered partitions may be compacted out \n-   later.  */ \n+/* Return the index into the basevar table for PARTITION's base in MAP.  */\n+\n+static inline int\n+basevar_index (var_map map, int partition)\n+{\n+  gcc_assert (partition >= 0 \n+\t      && partition <= (int) num_var_partitions (map));\n+  return map->partition_to_base_index[partition];\n+}\n+\n+\n+/* Return the number of different base variables in MAP.  */\n+\n+static inline int\n+num_basevars (var_map map)\n+{\n+  return map->num_basevars;\n+}\n+\n+\n+\n+/* This routine registers a partition for SSA_VAR with MAP.  Any unregistered \n+   partitions may be filtered out by a view later.  */ \n \n static inline void\n register_ssa_partition (var_map map, tree ssa_var)\n@@ -170,7 +218,7 @@ register_ssa_partition (var_map map, tree ssa_var)\n \n   version = SSA_NAME_VERSION (ssa_var);\n   if (map->partition_to_var[version] == NULL_TREE)\n-    map->partition_to_var[SSA_NAME_VERSION (ssa_var)] = ssa_var;\n+    map->partition_to_var[version] = ssa_var;\n }\n \n \n@@ -238,13 +286,6 @@ extern void delete_tree_live_info (tree_live_info_p);\n #define LIVEDUMP_ALL\t(LIVEDUMP_ENTRY | LIVEDUMP_EXIT)\n extern void dump_live_info (FILE *, tree_live_info_p, int);\n \n-static inline int partition_is_global (tree_live_info_p, int);\n-static inline bitmap live_on_entry (tree_live_info_p, basic_block);\n-static inline bitmap live_on_exit (tree_live_info_p, basic_block);\n-static inline var_map live_var_map (tree_live_info_p);\n-static inline void live_merge_and_clear (tree_live_info_p, int, int);\n-static inline void make_live_on_entry (tree_live_info_p, basic_block, int);\n-\n \n /*  Return TRUE if P is marked as a global in LIVE.  */\n \n@@ -316,275 +357,9 @@ make_live_on_entry (tree_live_info_p live, basic_block bb , int p)\n }\n \n \n-/* A tree_partition_associator (TPA)object is a base structure which allows\n-   partitions to be associated with a tree object.\n-\n-   A varray of tree elements represent each distinct tree item.\n-   A parallel int array represents the first partition number associated with \n-   the tree.\n-   This partition number is then used as in index into the next_partition\n-   array, which returns the index of the next partition which is associated\n-   with the tree. TPA_NONE indicates the end of the list.  \n-   A varray paralleling the partition list 'partition_to_tree_map' is used\n-   to indicate which tree index the partition is in.  */\n-\n-typedef struct tree_partition_associator_d\n-{\n-  VEC(tree,heap) *trees;\n-  VEC(int,heap) *first_partition;\n-  int *next_partition;\n-  int *partition_to_tree_map;\n-  int num_trees;\n-  int uncompressed_num;\n-  var_map map;\n-} *tpa_p;\n-\n-/* Value returned when there are no more partitions associated with a tree.  */\n-#define TPA_NONE\t\t-1\n-\n-static inline tree tpa_tree (tpa_p, int);\n-static inline int tpa_first_partition (tpa_p, int);\n-static inline int tpa_next_partition (tpa_p, int);\n-static inline int tpa_num_trees (tpa_p);\n-static inline int tpa_find_tree (tpa_p, int);\n-static inline void tpa_decompact (tpa_p);\n-extern void tpa_delete (tpa_p);\n-extern void tpa_dump (FILE *, tpa_p);\n-extern void tpa_remove_partition (tpa_p, int, int);\n-extern int tpa_compact (tpa_p);\n-\n-\n-/* Return the number of distinct tree nodes in TPA.  */\n-\n-static inline int\n-tpa_num_trees (tpa_p tpa)\n-{\n-  return tpa->num_trees;\n-}\n-\n-\n-/* Return the tree node for index I in TPA.  */\n-\n-static inline tree\n-tpa_tree (tpa_p tpa, int i)\n-{\n-  return VEC_index (tree, tpa->trees, i);\n-}\n-\n-\n-/* Return the first partition associated with tree list I in TPA.  */\n-\n-static inline int\n-tpa_first_partition (tpa_p tpa, int i)\n-{\n-  return VEC_index (int, tpa->first_partition, i);\n-}\n-\n-\n-/* Return the next partition after partition I in TPA's list.  */\n-\n-static inline int\n-tpa_next_partition (tpa_p tpa, int i)\n-{\n-  return tpa->next_partition[i];\n-}\n-\n-\n-/* Return the tree index from TPA whose list contains partition I.  \n-   TPA_NONE is returned if I is not associated with any list.  */\n-\n-static inline int \n-tpa_find_tree (tpa_p tpa, int i)\n-{\n-  int index;\n-\n-  index = tpa->partition_to_tree_map[i];\n-  /* When compressed, any index higher than the number of tree elements is \n-     a compressed element, so return TPA_NONE.  */\n-  if (index != TPA_NONE && index >= tpa_num_trees (tpa))\n-    {\n-      gcc_assert (tpa->uncompressed_num != -1);\n-      index = TPA_NONE;\n-    }\n-\n-  return index;\n-}\n-\n-\n-/* This function removes any compaction which was performed on TPA.  */\n-\n-static inline void \n-tpa_decompact(tpa_p tpa)\n-{\n-  gcc_assert (tpa->uncompressed_num != -1);\n-  tpa->num_trees = tpa->uncompressed_num;\n-}\n-\n-\n-/* Once a var_map has been created and compressed, a complementary root_var\n-   object can be built.  This creates a list of all the root variables from\n-   which ssa version names are derived.  Each root variable has a list of \n-   which partitions are versions of that root.  \n-\n-   This is implemented using the tree_partition_associator.\n-\n-   The tree vector is used to represent the root variable.\n-   The list of partitions represent SSA versions of the root variable.  */\n-\n-typedef tpa_p root_var_p;\n-\n-static inline tree root_var (root_var_p, int);\n-static inline int root_var_first_partition (root_var_p, int);\n-static inline int root_var_next_partition (root_var_p, int);\n-static inline int root_var_num (root_var_p);\n-static inline void root_var_dump (FILE *, root_var_p);\n-static inline void root_var_remove_partition (root_var_p, int, int);\n-static inline void root_var_delete (root_var_p);\n-static inline int root_var_find (root_var_p, int);\n-static inline int root_var_compact (root_var_p);\n-static inline void root_var_decompact (tpa_p);\n-\n-extern root_var_p root_var_init (var_map);\n-\n-/* Value returned when there are no more partitions associated with a root\n-   variable.  */\n-#define ROOT_VAR_NONE\t\tTPA_NONE\n-\n-\n-/* Return the number of distinct root variables in RV.  */\n-\n-static inline int \n-root_var_num (root_var_p rv)\n-{\n-  return tpa_num_trees (rv);\n-}\n-\n-\n-/* Return root variable I from RV.  */\n-\n-static inline tree\n-root_var (root_var_p rv, int i)\n-{\n-  return tpa_tree (rv, i);\n-}\n-\n-\n-/* Return the first partition in RV belonging to root variable list I.  */\n-\n-static inline int\n-root_var_first_partition (root_var_p rv, int i)\n-{\n-  return tpa_first_partition (rv, i);\n-}\n-\n-\n-/* Return the next partition after partition I in a root list from RV.  */\n-\n-static inline int\n-root_var_next_partition (root_var_p rv, int i)\n-{\n-  return tpa_next_partition (rv, i);\n-}\n-\n-\n-/* Send debug info for root_var list RV to file F.  */\n-\n-static inline void\n-root_var_dump (FILE *f, root_var_p rv)\n-{\n-  fprintf (f, \"\\nRoot Var dump\\n\");\n-  tpa_dump (f, rv);\n-  fprintf (f, \"\\n\");\n-}\n-\n+/* From tree-ssa-coalesce.c  */\n+extern var_map coalesce_ssa_name (void);\n \n-/* Destroy root_var object RV.  */\n-\n-static inline void\n-root_var_delete (root_var_p rv)\n-{\n-  tpa_delete (rv);\n-}\n-\n-\n-/* Remove partition PARTITION_INDEX from root_var list ROOT_INDEX in RV.  */\n-\n-static inline void\n-root_var_remove_partition (root_var_p rv, int root_index, int partition_index)\n-{\n-  tpa_remove_partition (rv, root_index, partition_index);\n-}\n-\n-\n-/* Return the root_var list index for partition I in RV.  */\n-\n-static inline int\n-root_var_find (root_var_p rv, int i)\n-{\n-  return tpa_find_tree (rv, i);\n-}\n-\n-\n-/* Hide single element lists in RV.  */\n-\n-static inline int \n-root_var_compact (root_var_p rv)\n-{\n-  return tpa_compact (rv);\n-}\n-\n-\n-/* Expose the single element lists in RV.  */\n-\n-static inline void\n-root_var_decompact (root_var_p rv)\n-{\n-  tpa_decompact (rv);\n-}\n-\n-\n-/* This set of routines implements a coalesce_list. This is an object which\n-   is used to track pairs of partitions which are desirable to coalesce\n-   together at some point.  Costs are associated with each pair, and when \n-   all desired information has been collected, the object can be used to \n-   order the pairs for processing.  */\n-\n-/* This structure defines a pair entry.  */\n-\n-typedef struct partition_pair\n-{\n-  int first_partition;\n-  int second_partition;\n-  int cost;\n-} * partition_pair_p;\n-\n-extern unsigned int partition_pair_map_hash (const void *);\n-extern int partition_pair_map_eq (const void *, const void *);\n-\n-/* This structure maintains the list of coalesce pairs.  */\n-\n-typedef struct coalesce_list_d \n-{\n-  var_map map;\n-  htab_t list;\n-  partition_pair_p *sorted;\n-  int num_sorted;\n-  bool add_mode;\n-} *coalesce_list_p;\n-\n-extern coalesce_list_p create_coalesce_list (var_map);\n-extern void add_coalesce (coalesce_list_p, int, int, int);\n-extern int coalesce_cost (int, bool, bool);\n-extern void sort_coalesce_list (coalesce_list_p);\n-extern void dump_coalesce_list (FILE *, coalesce_list_p);\n-extern void delete_coalesce_list (coalesce_list_p);\n-\n-#define NO_BEST_COALESCE\t-1\n-\n-extern conflict_graph build_tree_conflict_graph (tree_live_info_p, tpa_p,\n-\t\t\t\t\t\t coalesce_list_p);\n-extern void coalesce_tpa_members (tpa_p tpa, conflict_graph graph, var_map map,\n-\t\t\t\t  coalesce_list_p cl, FILE *);\n \n /* From tree-ssa-ter.c  */\n extern tree *find_replaceable_exprs (var_map);"}, {"sha": "78f8a121f0993efca89032e5c47a8da054c80bc7", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7290d709efbec4d872160fa274bf2128b55432eb/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=7290d709efbec4d872160fa274bf2128b55432eb", "patch": "@@ -25,29 +25,11 @@ Boston, MA 02110-1301, USA.  */\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n-#include \"flags.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"ggc.h\"\n-#include \"langhooks.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"output.h\"\n-#include \"expr.h\"\n-#include \"function.h\"\n #include \"diagnostic.h\"\n #include \"bitmap.h\"\n #include \"tree-flow.h\"\n-#include \"tree-gimple.h\"\n-#include \"tree-inline.h\"\n-#include \"varray.h\"\n-#include \"timevar.h\"\n-#include \"hashtab.h\"\n #include \"tree-dump.h\"\n #include \"tree-ssa-live.h\"\n-#include \"tree-pass.h\"\n-#include \"toplev.h\"\n-#include \"vecprim.h\"\n \n \n /* Temporary Expression Replacement (TER)"}]}