{"sha": "13e08dc93941675cd6a7cf5470b437c4f640c996", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNlMDhkYzkzOTQxNjc1Y2Q2YTdjZjU0NzBiNDM3YzRmNjQwYzk5Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-12-17T10:05:51Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-12-17T10:05:51Z"}, "message": "Add a loop versioning pass\n\nThis patch adds a pass that versions loops with variable index strides\nfor the case in which the stride is 1.  E.g.:\n\n    for (int i = 0; i < n; ++i)\n      x[i * stride] = ...;\n\nbecomes:\n\n    if (stepx == 1)\n      for (int i = 0; i < n; ++i)\n        x[i] = ...;\n    else\n      for (int i = 0; i < n; ++i)\n        x[i * stride] = ...;\n\nThis is useful for both vector code and scalar code, and in some cases\ncan enable further optimisations like loop interchange or pattern\nrecognition.\n\nThe pass gives a 7.6% improvement on Cortex-A72 for 554.roms_r at -O3\nand a 2.4% improvement for 465.tonto.  I haven't found any SPEC tests\nthat regress.\n\nSizewise, there's a 10% increase in .text for both 554.roms_r and\n465.tonto.  That's obviously a lot, but in tonto's case it's because\nthe whole program is written using assumed-shape arrays and pointers,\nso a large number of functions really do benefit from versioning.\nroms likewise makes heavy use of assumed-shape arrays, and that\nimprovement in performance IMO justifies the code growth.\n\nThe next biggest .text increase is 4.5% for 548.exchange2_r.  I did see\na small (0.4%) speed improvement there, but although both 3-iteration runs\nproduced stable results, that might still be noise.  There was a slightly\nlarger (non-noise) improvement for a 256-bit SVE model.\n\n481.wrf and 521.wrf_r .text grew by 2.8% and 2.5% respectively, but\nwithout any noticeable improvement in performance.  No other test grew\nby more than 2%.\n\nAlthough the main SPEC beneficiaries are all Fortran tests, the\nbenchmarks we use for SVE also include some C and C++ tests that\nbenefit.\n\nUsing -frepack-arrays gives the same benefits in many Fortran cases.\nThe problem is that using that option inappropriately can force a full\narray copy for arguments that the function only reads once, and so it\nisn't really something we can turn on by default.  The new pass is\nsupposed to give most of the benefits of -frepack-arrays without\nthe risk of unnecessary repacking.\n\nThe patch therefore enables the pass by default at -O3.\n\n2018-12-17  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\t    Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\ngcc/\n\t* doc/invoke.texi (-fversion-loops-for-strides): Document\n\t(loop-versioning-group-size, loop-versioning-max-inner-insns)\n\t(loop-versioning-max-outer-insns): Document new --params.\n\t* Makefile.in (OBJS): Add gimple-loop-versioning.o.\n\t* common.opt (fversion-loops-for-strides): New option.\n\t* opts.c (default_options_table): Enable fversion-loops-for-strides\n\tat -O3.\n\t* params.def (PARAM_LOOP_VERSIONING_GROUP_SIZE)\n\t(PARAM_LOOP_VERSIONING_MAX_INNER_INSNS)\n\t(PARAM_LOOP_VERSIONING_MAX_OUTER_INSNS): New parameters.\n\t* passes.def: Add pass_loop_versioning.\n\t* timevar.def (TV_LOOP_VERSIONING): New time variable.\n\t* tree-ssa-propagate.h\n\t(substitute_and_fold_engine::substitute_and_fold): Add an optional\n\tblock parameter.\n\t* tree-ssa-propagate.c\n\t(substitute_and_fold_engine::substitute_and_fold): Likewise.\n\tWhen passed, only walk blocks dominated by that block.\n\t* tree-vrp.h (range_includes_p): Declare.\n\t(range_includes_zero_p): Turn into an inline wrapper around\n\trange_includes_p.\n\t* tree-vrp.c (range_includes_p): New function, generalizing...\n\t(range_includes_zero_p): ...this.\n\t* tree-pass.h (make_pass_loop_versioning): Declare.\n\t* gimple-loop-versioning.cc: New file.\n\ngcc/testsuite/\n\t* gcc.dg/loop-versioning-1.c: New test.\n\t* gcc.dg/loop-versioning-10.c: Likewise.\n\t* gcc.dg/loop-versioning-11.c: Likewise.\n\t* gcc.dg/loop-versioning-2.c: Likewise.\n\t* gcc.dg/loop-versioning-3.c: Likewise.\n\t* gcc.dg/loop-versioning-4.c: Likewise.\n\t* gcc.dg/loop-versioning-5.c: Likewise.\n\t* gcc.dg/loop-versioning-6.c: Likewise.\n\t* gcc.dg/loop-versioning-7.c: Likewise.\n\t* gcc.dg/loop-versioning-8.c: Likewise.\n\t* gcc.dg/loop-versioning-9.c: Likewise.\n\t* gfortran.dg/loop_versioning_1.f90: Likewise.\n\t* gfortran.dg/loop_versioning_2.f90: Likewise.\n\t* gfortran.dg/loop_versioning_3.f90: Likewise.\n\t* gfortran.dg/loop_versioning_4.f90: Likewise.\n\t* gfortran.dg/loop_versioning_5.f90: Likewise.\n\t* gfortran.dg/loop_versioning_6.f90: Likewise.\n\t* gfortran.dg/loop_versioning_7.f90: Likewise.\n\t* gfortran.dg/loop_versioning_8.f90: Likewise.\n\nFrom-SVN: r267197", "tree": {"sha": "86777b79b7db416b5e4abe23fac22576eeb717ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86777b79b7db416b5e4abe23fac22576eeb717ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13e08dc93941675cd6a7cf5470b437c4f640c996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e08dc93941675cd6a7cf5470b437c4f640c996", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13e08dc93941675cd6a7cf5470b437c4f640c996", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e08dc93941675cd6a7cf5470b437c4f640c996/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb2974dcf53f960231e8c4bc2b294f8900b3beef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb2974dcf53f960231e8c4bc2b294f8900b3beef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb2974dcf53f960231e8c4bc2b294f8900b3beef"}], "stats": {"total": 3216, "additions": 3204, "deletions": 12}, "files": [{"sha": "83900c5b67465f9d5c31e1f9064a34c69f1c2e2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1,3 +1,31 @@\n+2018-12-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/invoke.texi (-fversion-loops-for-strides): Document\n+\t(loop-versioning-group-size, loop-versioning-max-inner-insns)\n+\t(loop-versioning-max-outer-insns): Document new --params.\n+\t* Makefile.in (OBJS): Add gimple-loop-versioning.o.\n+\t* common.opt (fversion-loops-for-strides): New option.\n+\t* opts.c (default_options_table): Enable fversion-loops-for-strides\n+\tat -O3.\n+\t* params.def (PARAM_LOOP_VERSIONING_GROUP_SIZE)\n+\t(PARAM_LOOP_VERSIONING_MAX_INNER_INSNS)\n+\t(PARAM_LOOP_VERSIONING_MAX_OUTER_INSNS): New parameters.\n+\t* passes.def: Add pass_loop_versioning.\n+\t* timevar.def (TV_LOOP_VERSIONING): New time variable.\n+\t* tree-ssa-propagate.h\n+\t(substitute_and_fold_engine::substitute_and_fold): Add an optional\n+\tblock parameter.\n+\t* tree-ssa-propagate.c\n+\t(substitute_and_fold_engine::substitute_and_fold): Likewise.\n+\tWhen passed, only walk blocks dominated by that block.\n+\t* tree-vrp.h (range_includes_p): Declare.\n+\t(range_includes_zero_p): Turn into an inline wrapper around\n+\trange_includes_p.\n+\t* tree-vrp.c (range_includes_p): New function, generalizing...\n+\t(range_includes_zero_p): ...this.\n+\t* tree-pass.h (make_pass_loop_versioning): Declare.\n+\t* gimple-loop-versioning.cc: New file.\n+\n 2018-12-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-fnsummary.c (remap_edge_change_prob): Do not ICE when changes"}, {"sha": "7960cace16ab30da1c933ecba9a6adff0031a8f6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1320,6 +1320,7 @@ OBJS = \\\n \tgimple-laddress.o \\\n \tgimple-loop-interchange.o \\\n \tgimple-loop-jam.o \\\n+\tgimple-loop-versioning.o \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n \tgimple-ssa-backprop.o \\"}, {"sha": "45d7f6189e5caab6b5e3020fe6c85ee44decfaa1", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -2775,6 +2775,10 @@ fsplit-loops\n Common Report Var(flag_split_loops) Optimization\n Perform loop splitting.\n \n+fversion-loops-for-strides\n+Common Report Var(flag_version_loops_for_strides) Optimization\n+Version loops based on whether indices have a stride of one.\n+\n funwind-tables\n Common Report Var(flag_unwind_tables) Optimization\n Just generate unwind tables for exception handling."}, {"sha": "ac2ee59d92c3d5bd0e9deb854ba9fcb3dcee4ec9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -8220,7 +8220,8 @@ by @option{-O2} and also turns on the following optimization flags:\n -ftree-partial-pre @gol\n -ftree-slp-vectorize @gol\n -funswitch-loops @gol\n--fvect-cost-model}\n+-fvect-cost-model @gol\n+-fversion-loops-for-strides}\n \n @item -O0\n @opindex O0\n@@ -10772,6 +10773,30 @@ of the loop on both branches (modified according to result of the condition).\n \n Enabled by @option{-fprofile-use} and @option{-fauto-profile}.\n \n+@item -fversion-loops-for-strides\n+@opindex fversion-loops-for-strides\n+If a loop iterates over an array with a variable stride, create another\n+version of the loop that assumes the stride is always one.  For example:\n+\n+@smallexample\n+for (int i = 0; i < n; ++i)\n+  x[i * stride] = @dots{};\n+@end smallexample\n+\n+becomes:\n+\n+@smallexample\n+if (stride == 1)\n+  for (int i = 0; i < n; ++i)\n+    x[i] = @dots{};\n+else\n+  for (int i = 0; i < n; ++i)\n+    x[i * stride] = @dots{};\n+@end smallexample\n+\n+This is particularly useful for assumed-shape arrays in Fortran where\n+(for example) it allows better vectorization assuming contiguous accesses.\n+\n @item -ffunction-sections\n @itemx -fdata-sections\n @opindex ffunction-sections\n@@ -11981,6 +12006,15 @@ Hardware autoprefetcher scheduler model control flag.\n Number of lookahead cycles the model looks into; at '\n ' only enable instruction sorting heuristic.\n \n+@item loop-versioning-max-inner-insns\n+The maximum number of instructions that an inner loop can have\n+before the loop versioning pass considers it too big to copy.\n+\n+@item loop-versioning-max-outer-insns\n+The maximum number of instructions that an outer loop can have\n+before the loop versioning pass considers it too big to copy,\n+discounting any instructions in inner loops that directly benefit\n+from versioning.\n \n @end table\n @end table"}, {"sha": "887b5e77d6ac72932f1f76052f9c9c2515cf0848", "filename": "gcc/gimple-loop-versioning.cc", "status": "added", "additions": 1758, "deletions": 0, "changes": 1758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,1758 @@\n+/* Loop versioning pass.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-pass.h\"\n+#include \"gimplify-me.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"ssa.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-ssa-loop-ivopts.h\"\n+#include \"fold-const.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"tree-inline.h\"\n+#include \"domwalk.h\"\n+#include \"alloc-pool.h\"\n+#include \"vr-values.h\"\n+#include \"gimple-ssa-evrp-analyze.h\"\n+#include \"tree-vectorizer.h\"\n+#include \"omp-general.h\"\n+#include \"predict.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"params.h\"\n+\n+namespace {\n+\n+/* This pass looks for loops that could be simplified if certain loop\n+   invariant conditions were true.  It is effectively a form of loop\n+   splitting in which the pass produces the split conditions itself,\n+   instead of using ones that are already present in the IL.\n+\n+   Versioning for when strides are 1\n+   ---------------------------------\n+\n+   At the moment the only thing the pass looks for are memory references\n+   like:\n+\n+     for (auto i : ...)\n+       ...x[i * stride]...\n+\n+   It considers changing such loops to:\n+\n+     if (stride == 1)\n+       for (auto i : ...)    [A]\n+\t ...x[i]...\n+     else\n+       for (auto i : ...)    [B]\n+\t ...x[i * stride]...\n+\n+   This can have several benefits:\n+\n+   (1) [A] is often easier or cheaper to vectorize than [B].\n+\n+   (2) The scalar code in [A] is simpler than the scalar code in [B]\n+       (if the loops cannot be vectorized or need an epilogue loop).\n+\n+   (3) We might recognize [A] as a pattern, such as a memcpy or memset.\n+\n+   (4) [A] has simpler address evolutions, which can help other passes\n+       like loop interchange.\n+\n+   The optimization is particularly useful for assumed-shape arrays in\n+   Fortran, where the stride of the innermost dimension depends on the\n+   array descriptor but is often equal to 1 in practice.  For example:\n+\n+     subroutine f1(x)\n+       real :: x(:)\n+       x(:) = 100\n+     end subroutine f1\n+\n+   generates the equivalent of:\n+\n+     raw_stride = *x.dim[0].stride;\n+     stride = raw_stride != 0 ? raw_stride : 1;\n+     x_base = *x.data;\n+     ...\n+     tmp1 = stride * S;\n+     tmp2 = tmp1 - stride;\n+     *x_base[tmp2] = 1.0e+2;\n+\n+   but in the common case that stride == 1, the last three statements\n+   simplify to:\n+\n+     tmp3 = S + -1;\n+     *x_base[tmp3] = 1.0e+2;\n+\n+   The optimization is in principle very simple.  The difficult parts are:\n+\n+   (a) deciding which parts of a general address calculation correspond\n+       to the inner dimension of an array, since this usually isn't explicit\n+       in the IL, and for C often isn't even explicit in the source code\n+\n+   (b) estimating when the transformation is worthwhile\n+\n+   Structure\n+   ---------\n+\n+   The pass has four phases:\n+\n+   (1) Walk through the statements looking for and recording potential\n+       versioning opportunities.  Stop if there are none.\n+\n+   (2) Use context-sensitive range information to see whether any versioning\n+       conditions are impossible in practice.  Remove them if so, and stop\n+       if no opportunities remain.\n+\n+       (We do this only after (1) to keep compile time down when no\n+       versioning opportunities exist.)\n+\n+   (3) Apply the cost model.  Decide which versioning opportunities are\n+       worthwhile and at which nesting level they should be applied.\n+\n+   (4) Attempt to version all the loops selected by (3), so that:\n+\n+\t for (...)\n+\t   ...\n+\n+       becomes:\n+\n+\t if (!cond)\n+\t   for (...) // Original loop\n+\t     ...\n+\t else\n+\t   for (...) // New loop\n+\t     ...\n+\n+       Use the version condition COND to simplify the new loop.  */\n+\n+/* Enumerates the likelihood that a particular value indexes the inner\n+   dimension of an array.  */\n+enum inner_likelihood {\n+  INNER_UNLIKELY,\n+  INNER_DONT_KNOW,\n+  INNER_LIKELY\n+};\n+\n+/* Information about one term of an address_info.  */\n+struct address_term_info\n+{\n+  /* The value of the term is EXPR * MULTIPLIER.  */\n+  tree expr;\n+  unsigned HOST_WIDE_INT multiplier;\n+\n+  /* The stride applied by EXPR in each iteration of some unrecorded loop,\n+     or null if no stride has been identified.  */\n+  tree stride;\n+\n+  /* Enumerates the likelihood that EXPR indexes the inner dimension\n+     of an array.  */\n+  enum inner_likelihood inner_likelihood;\n+\n+  /* True if STRIDE == 1 is a versioning opportunity when considered\n+     in isolation.  */\n+  bool versioning_opportunity_p;\n+};\n+\n+/* Information about an address calculation, and the range of constant\n+   offsets applied to it.  */\n+struct address_info\n+{\n+  static const unsigned int MAX_TERMS = 8;\n+\n+  /* One statement that calculates the address.  If multiple statements\n+     share the same address, we only record the first.  */\n+  gimple *stmt;\n+\n+  /* The loop containing STMT (cached for convenience).  If multiple\n+     statements share the same address, they all belong to this loop.  */\n+  struct loop *loop;\n+\n+  /* A decomposition of the calculation into a sum of terms plus an\n+     optional base.  When BASE is provided, it is never an SSA name.\n+     Once initialization is complete, all members of TERMs are SSA names.  */\n+  tree base;\n+  auto_vec<address_term_info, MAX_TERMS> terms;\n+\n+  /* All bytes accessed from the address fall in the offset range\n+     [MIN_OFFSET, MAX_OFFSET).  */\n+  HOST_WIDE_INT min_offset, max_offset;\n+};\n+\n+/* Stores addresses based on their base and terms (ignoring the offsets).  */\n+struct address_info_hasher : nofree_ptr_hash <address_info>\n+{\n+  static hashval_t hash (const address_info *);\n+  static bool equal (const address_info *, const address_info *);\n+};\n+\n+/* Information about the versioning we'd like to apply to a loop.  */\n+struct loop_info\n+{\n+  bool worth_versioning_p () const;\n+\n+  /* True if we've decided not to version this loop.  The remaining\n+     fields are meaningless if so.  */\n+  bool rejected_p;\n+\n+  /* True if at least one subloop of this loop benefits from versioning.  */\n+  bool subloops_benefit_p;\n+\n+  /* An estimate of the total number of instructions in the loop,\n+     excluding those in subloops that benefit from versioning.  */\n+  unsigned int num_insns;\n+\n+  /* The outermost loop that can handle all the version checks\n+     described below.  */\n+  struct loop *outermost;\n+\n+  /* The first entry in the list of blocks that belong to this loop\n+     (and not to subloops).  m_next_block_in_loop provides the chain\n+     pointers for the list.  */\n+  basic_block block_list;\n+\n+  /* We'd like to version the loop for the case in which these SSA names\n+     (keyed off their SSA_NAME_VERSION) are all equal to 1 at runtime.  */\n+  bitmap_head unity_names;\n+\n+  /* If versioning succeeds, this points the version of the loop that\n+     assumes the version conditions holds.  */\n+  struct loop *optimized_loop;\n+};\n+\n+/* The main pass structure.  */\n+class loop_versioning\n+{\n+public:\n+  loop_versioning (function *);\n+  ~loop_versioning ();\n+  unsigned int run ();\n+\n+private:\n+  /* Used to walk the dominator tree to find loop versioning conditions\n+     that are always false.  */\n+  class lv_dom_walker : public dom_walker\n+  {\n+  public:\n+    lv_dom_walker (loop_versioning &);\n+\n+    edge before_dom_children (basic_block) FINAL OVERRIDE;\n+    void after_dom_children (basic_block) FINAL OVERRIDE;\n+\n+  private:\n+    /* The parent pass.  */\n+    loop_versioning &m_lv;\n+\n+    /* Used to build context-dependent range information.  */\n+    evrp_range_analyzer m_range_analyzer;\n+  };\n+\n+  /* Used to simplify statements based on conditions that are established\n+     by the version checks.  */\n+  class name_prop : public substitute_and_fold_engine\n+  {\n+  public:\n+    name_prop (loop_info &li) : m_li (li) {}\n+    tree get_value (tree) FINAL OVERRIDE;\n+\n+  private:\n+    /* Information about the versioning we've performed on the loop.  */\n+    loop_info &m_li;\n+  };\n+\n+  loop_info &get_loop_info (struct loop *loop) { return m_loops[loop->num]; }\n+\n+  unsigned int max_insns_for_loop (struct loop *);\n+  bool expensive_stmt_p (gimple *);\n+\n+  void version_for_unity (gimple *, tree);\n+  bool acceptable_multiplier_p (tree, unsigned HOST_WIDE_INT,\n+\t\t\t\tunsigned HOST_WIDE_INT * = 0);\n+  bool acceptable_type_p (tree, unsigned HOST_WIDE_INT *);\n+  bool multiply_term_by (address_term_info &, tree);\n+  inner_likelihood get_inner_likelihood (tree, unsigned HOST_WIDE_INT);\n+  void analyze_stride (address_info &, address_term_info &,\n+\t\t       tree, struct loop *);\n+  bool find_per_loop_multiplication (address_info &, address_term_info &);\n+  void analyze_term_using_scevs (address_info &, address_term_info &);\n+  void analyze_address_fragment (address_info &);\n+  void record_address_fragment (gimple *, unsigned HOST_WIDE_INT,\n+\t\t\t\ttree, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n+  void analyze_expr (gimple *, tree);\n+  bool analyze_block (basic_block);\n+  bool analyze_blocks ();\n+\n+  void prune_loop_conditions (struct loop *, vr_values *);\n+  bool prune_conditions ();\n+\n+  void merge_loop_info (struct loop *, struct loop *);\n+  void add_loop_to_queue (struct loop *);\n+  bool decide_whether_loop_is_versionable (struct loop *);\n+  bool make_versioning_decisions ();\n+\n+  bool version_loop (struct loop *);\n+  void implement_versioning_decisions ();\n+\n+  /* The function we're optimizing.  */\n+  function *m_fn;\n+\n+  /* The obstack to use for all pass-specific bitmaps.  */\n+  bitmap_obstack m_bitmap_obstack;\n+\n+  /* An obstack to use for general allocation.  */\n+  obstack m_obstack;\n+\n+  /* The number of loops in the function.  */\n+  unsigned int m_nloops;\n+\n+  /* The total number of loop version conditions we've found.  */\n+  unsigned int m_num_conditions;\n+\n+  /* Assume that an address fragment of the form i * stride * scale\n+     (for variable stride and constant scale) will not benefit from\n+     versioning for stride == 1 when scale is greater than this value.  */\n+  unsigned HOST_WIDE_INT m_maximum_scale;\n+\n+  /* Information about each loop.  */\n+  auto_vec<loop_info> m_loops;\n+\n+  /* Used to form a linked list of blocks that belong to a loop,\n+     started by loop_info::block_list.  */\n+  auto_vec<basic_block> m_next_block_in_loop;\n+\n+  /* The list of loops that we've decided to version.  */\n+  auto_vec<struct loop *> m_loops_to_version;\n+\n+  /* A table of addresses in the current loop, keyed off their values\n+     but not their offsets.  */\n+  hash_table <address_info_hasher> m_address_table;\n+\n+  /* A list of all addresses in M_ADDRESS_TABLE, in a predictable order.  */\n+  auto_vec <address_info *, 32> m_address_list;\n+};\n+\n+/* If EXPR is an SSA name and not a default definition, return the\n+   defining statement, otherwise return null.  */\n+\n+static gimple *\n+maybe_get_stmt (tree expr)\n+{\n+  if (TREE_CODE (expr) == SSA_NAME && !SSA_NAME_IS_DEFAULT_DEF (expr))\n+    return SSA_NAME_DEF_STMT (expr);\n+  return NULL;\n+}\n+\n+/* Like maybe_get_stmt, but also return null if the defining\n+   statement isn't an assignment.  */\n+\n+static gassign *\n+maybe_get_assign (tree expr)\n+{\n+  return safe_dyn_cast <gassign *> (maybe_get_stmt (expr));\n+}\n+\n+/* Return true if this pass should look through a cast of expression FROM\n+   to type TYPE when analyzing pieces of an address.  */\n+\n+static bool\n+look_through_cast_p (tree type, tree from)\n+{\n+  return (INTEGRAL_TYPE_P (TREE_TYPE (from)) == INTEGRAL_TYPE_P (type)\n+\t  && POINTER_TYPE_P (TREE_TYPE (from)) == POINTER_TYPE_P (type));\n+}\n+\n+/* Strip all conversions of integers or pointers from EXPR, regardless\n+   of whether the conversions are nops.  This is useful in the context\n+   of this pass because we're not trying to fold or simulate the\n+   expression; we just want to see how it's structured.  */\n+\n+static tree\n+strip_casts (tree expr)\n+{\n+  const unsigned int MAX_NITERS = 4;\n+\n+  tree type = TREE_TYPE (expr);\n+  while (CONVERT_EXPR_P (expr)\n+\t && look_through_cast_p (type, TREE_OPERAND (expr, 0)))\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  for (unsigned int niters = 0; niters < MAX_NITERS; ++niters)\n+    {\n+      gassign *assign = maybe_get_assign (expr);\n+      if (assign\n+\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (assign))\n+\t  && look_through_cast_p (type, gimple_assign_rhs1 (assign)))\n+\texpr = gimple_assign_rhs1 (assign);\n+      else\n+\tbreak;\n+    }\n+  return expr;\n+}\n+\n+/* Compare two address_term_infos in the same address_info.  */\n+\n+static int\n+compare_address_terms (const void *a_uncast, const void *b_uncast)\n+{\n+  const address_term_info *a = (const address_term_info *) a_uncast;\n+  const address_term_info *b = (const address_term_info *) b_uncast;\n+\n+  if (a->expr != b->expr)\n+    return SSA_NAME_VERSION (a->expr) < SSA_NAME_VERSION (b->expr) ? -1 : 1;\n+\n+  if (a->multiplier != b->multiplier)\n+    return a->multiplier < b->multiplier ? -1 : 1;\n+\n+  return 0;\n+}\n+\n+/* Dump ADDRESS using flags FLAGS.  */\n+\n+static void\n+dump_address_info (dump_flags_t flags, address_info &address)\n+{\n+  if (address.base)\n+    dump_printf (flags, \"%T + \", address.base);\n+  for (unsigned int i = 0; i < address.terms.length (); ++i)\n+    {\n+      if (i != 0)\n+\tdump_printf (flags, \" + \");\n+      dump_printf (flags, \"%T\", address.terms[i].expr);\n+      if (address.terms[i].multiplier != 1)\n+\tdump_printf (flags, \" * %wd\", address.terms[i].multiplier);\n+    }\n+  dump_printf (flags, \" + [%wd, %wd]\",\n+\t       address.min_offset, address.max_offset - 1);\n+}\n+\n+/* Hash an address_info based on its base and terms.  */\n+\n+hashval_t\n+address_info_hasher::hash (const address_info *info)\n+{\n+  inchash::hash hash;\n+  hash.add_int (info->base ? TREE_CODE (info->base) : 0);\n+  hash.add_int (info->terms.length ());\n+  for (unsigned int i = 0; i < info->terms.length (); ++i)\n+    {\n+      hash.add_int (SSA_NAME_VERSION (info->terms[i].expr));\n+      hash.add_hwi (info->terms[i].multiplier);\n+    }\n+  return hash.end ();\n+}\n+\n+/* Return true if two address_infos have equal bases and terms.  Other\n+   properties might be different (such as the statement or constant\n+   offset range).  */\n+\n+bool\n+address_info_hasher::equal (const address_info *a, const address_info *b)\n+{\n+  if (a->base != b->base\n+      && (!a->base || !b->base || !operand_equal_p (a->base, b->base, 0)))\n+    return false;\n+\n+  if (a->terms.length () != b->terms.length ())\n+    return false;\n+\n+  for (unsigned int i = 0; i < a->terms.length (); ++i)\n+    if (a->terms[i].expr != b->terms[i].expr\n+\t|| a->terms[i].multiplier != b->terms[i].multiplier)\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Return true if we want to version the loop, i.e. if we have a\n+   specific reason for doing so and no specific reason not to.  */\n+\n+bool\n+loop_info::worth_versioning_p () const\n+{\n+  return (!rejected_p\n+\t  && (!bitmap_empty_p (&unity_names) || subloops_benefit_p));\n+}\n+\n+loop_versioning::lv_dom_walker::lv_dom_walker (loop_versioning &lv)\n+  : dom_walker (CDI_DOMINATORS), m_lv (lv), m_range_analyzer (false)\n+{\n+}\n+\n+/* Process BB before processing the blocks it dominates.  */\n+\n+edge\n+loop_versioning::lv_dom_walker::before_dom_children (basic_block bb)\n+{\n+  m_range_analyzer.enter (bb);\n+\n+  if (bb == bb->loop_father->header)\n+    m_lv.prune_loop_conditions (bb->loop_father,\n+\t\t\t\tm_range_analyzer.get_vr_values ());\n+\n+  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+       gsi_next (&si))\n+    m_range_analyzer.record_ranges_from_stmt (gsi_stmt (si), false);\n+\n+  return NULL;\n+}\n+\n+/* Process BB after processing the blocks it dominates.  */\n+\n+void\n+loop_versioning::lv_dom_walker::after_dom_children (basic_block bb)\n+{\n+  m_range_analyzer.leave (bb);\n+}\n+\n+/* Decide whether to replace VAL with a new value in a versioned loop.\n+   Return the new value if so, otherwise return null.  */\n+\n+tree\n+loop_versioning::name_prop::get_value (tree val)\n+{\n+  if (TREE_CODE (val) == SSA_NAME\n+      && bitmap_bit_p (&m_li.unity_names, SSA_NAME_VERSION (val)))\n+    return build_one_cst (TREE_TYPE (val));\n+  return NULL_TREE;\n+}\n+\n+/* Initialize the structure to optimize FN.  */\n+\n+loop_versioning::loop_versioning (function *fn)\n+  : m_fn (fn),\n+    m_nloops (number_of_loops (fn)),\n+    m_num_conditions (0),\n+    m_address_table (31)\n+{\n+  bitmap_obstack_initialize (&m_bitmap_obstack);\n+  gcc_obstack_init (&m_obstack);\n+\n+  /* Initialize the loop information.  */\n+  m_loops.safe_grow_cleared (m_nloops);\n+  for (unsigned int i = 0; i < m_nloops; ++i)\n+    {\n+      m_loops[i].outermost = get_loop (m_fn, 0);\n+      bitmap_initialize (&m_loops[i].unity_names, &m_bitmap_obstack);\n+    }\n+\n+  /* Initialize the list of blocks that belong to each loop.  */\n+  unsigned int nbbs = last_basic_block_for_fn (fn);\n+  m_next_block_in_loop.safe_grow (nbbs);\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fn)\n+    {\n+      loop_info &li = get_loop_info (bb->loop_father);\n+      m_next_block_in_loop[bb->index] = li.block_list;\n+      li.block_list = bb;\n+    }\n+\n+  /* MAX_FIXED_MODE_SIZE should be a reasonable maximum scale for\n+     unvectorizable code, since it is the largest size that can be\n+     handled efficiently by scalar code.  omp_max_vf calculates the\n+     maximum number of bytes in a vector, when such a value is relevant\n+     to loop optimization.  */\n+  m_maximum_scale = estimated_poly_value (omp_max_vf ());\n+  m_maximum_scale = MAX (m_maximum_scale, MAX_FIXED_MODE_SIZE);\n+}\n+\n+loop_versioning::~loop_versioning ()\n+{\n+  bitmap_obstack_release (&m_bitmap_obstack);\n+  obstack_free (&m_obstack, NULL);\n+}\n+\n+/* Return the maximum number of instructions allowed in LOOP before\n+   it becomes too big for versioning.\n+\n+   There are separate limits for inner and outer loops.  The limit for\n+   inner loops applies only to loops that benefit directly from versioning.\n+   The limit for outer loops applies to all code in the outer loop and\n+   its subloops that *doesn't* benefit directly from versioning; such code\n+   would be \"taken along for the ride\".  The idea is that if the cost of\n+   the latter is small, it is better to version outer loops rather than\n+   inner loops, both to reduce the number of repeated checks and to enable\n+   more of the loop nest to be optimized as a natural nest (e.g. by loop\n+   interchange or outer-loop vectorization).  */\n+\n+unsigned int\n+loop_versioning::max_insns_for_loop (struct loop *loop)\n+{\n+  return (loop->inner\n+\t  ? PARAM_VALUE (PARAM_LOOP_VERSIONING_MAX_OUTER_INSNS)\n+\t  : PARAM_VALUE (PARAM_LOOP_VERSIONING_MAX_INNER_INSNS));\n+}\n+\n+/* Return true if for cost reasons we should avoid versioning any loop\n+   that contains STMT.\n+\n+   Note that we don't need to check whether versioning is invalid for\n+   correctness reasons, since the versioning process does that for us.\n+   The conditions involved are too rare to be worth duplicating here.  */\n+\n+bool\n+loop_versioning::expensive_stmt_p (gimple *stmt)\n+{\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    /* Assume for now that the time spent in an \"expensive\" call would\n+       overwhelm any saving from versioning.  */\n+    return !gimple_inexpensive_call_p (call);\n+  return false;\n+}\n+\n+/* Record that we want to version the loop that contains STMT for the\n+   case in which SSA name NAME is equal to 1.  We already know that NAME\n+   is invariant in the loop.  */\n+\n+void\n+loop_versioning::version_for_unity (gimple *stmt, tree name)\n+{\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  loop_info &li = get_loop_info (loop);\n+\n+  if (bitmap_set_bit (&li.unity_names, SSA_NAME_VERSION (name)))\n+    {\n+      /* This is the first time we've wanted to version LOOP for NAME.\n+\t Keep track of the outermost loop that can handle all versioning\n+\t checks in LI.  */\n+      struct loop *outermost\n+\t= outermost_invariant_loop_for_expr (loop, name);\n+      if (loop_depth (li.outermost) < loop_depth (outermost))\n+\tli.outermost = outermost;\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, stmt, \"want to version containing loop\"\n+\t\t\t   \" for when %T == 1\", name);\n+\t  if (outermost == loop)\n+\t    dump_printf (MSG_NOTE, \"; cannot hoist check further\");\n+\t  else\n+\t    {\n+\t      dump_printf (MSG_NOTE, \"; could implement the check at loop\"\n+\t\t\t   \" depth %d\", loop_depth (outermost));\n+\t      if (loop_depth (li.outermost) > loop_depth (outermost))\n+\t\tdump_printf (MSG_NOTE, \", but other checks only allow\"\n+\t\t\t     \" a depth of %d\", loop_depth (li.outermost));\n+\t    }\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+\n+      m_num_conditions += 1;\n+    }\n+  else\n+    {\n+      /* This is a duplicate request.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, stmt, \"already asked to version containing\"\n+\t\t\t \" loop for when %T == 1\\n\", name);\n+    }\n+}\n+\n+/* Return true if OP1_TREE is constant and if in principle it is worth\n+   versioning an address fragment of the form:\n+\n+     i * OP1_TREE * OP2 * stride\n+\n+   for the case in which stride == 1.  This in practice means testing\n+   whether:\n+\n+     OP1_TREE * OP2 <= M_MAXIMUM_SCALE.\n+\n+   If RESULT is nonnull, store OP1_TREE * OP2 there when returning true.  */\n+\n+bool\n+loop_versioning::acceptable_multiplier_p (tree op1_tree,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT op2,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT *result)\n+{\n+  if (tree_fits_uhwi_p (op1_tree))\n+    {\n+      unsigned HOST_WIDE_INT op1 = tree_to_uhwi (op1_tree);\n+      /* The first part checks for overflow.  */\n+      if (op1 * op2 >= op2 && op1 * op2 <= m_maximum_scale)\n+\t{\n+\t  if (result)\n+\t    *result = op1 * op2;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return true if it is worth using loop versioning on a memory access\n+   of type TYPE.  Store the size of the access in *SIZE if so.  */\n+\n+bool\n+loop_versioning::acceptable_type_p (tree type, unsigned HOST_WIDE_INT *size)\n+{\n+  return (TYPE_SIZE_UNIT (type)\n+\t  && acceptable_multiplier_p (TYPE_SIZE_UNIT (type), 1, size));\n+}\n+\n+/* See whether OP is constant and whether we can multiply TERM by that\n+   constant without exceeding M_MAXIMUM_SCALE.  Return true and update\n+   TERM if so.  */\n+\n+bool\n+loop_versioning::multiply_term_by (address_term_info &term, tree op)\n+{\n+  return acceptable_multiplier_p (op, term.multiplier, &term.multiplier);\n+}\n+\n+/* Decide whether an address fragment of the form STRIDE * MULTIPLIER\n+   is likely to be indexing an innermost dimension, returning the result\n+   as an INNER_* probability.  */\n+\n+inner_likelihood\n+loop_versioning::get_inner_likelihood (tree stride,\n+\t\t\t\t       unsigned HOST_WIDE_INT multiplier)\n+{\n+  const unsigned int MAX_NITERS = 8;\n+\n+  /* Iterate over possible values of STRIDE.  Return INNER_LIKELY if at\n+     least one of those values is likely to be for the innermost dimension.\n+     Record in UNLIKELY_P if at least one of those values is unlikely to be\n+     for the innermost dimension.\n+\n+     E.g. for:\n+\n+       stride = cond ? a * b : 1\n+\n+     we should treat STRIDE as being a likely inner dimension, since\n+     we know that it is 1 under at least some circumstances.  (See the\n+     Fortran example below.)  However:\n+\n+       stride = a * b\n+\n+     on its own is unlikely to be for the innermost dimension, since\n+     that would require both a and b to be 1 at runtime.  */\n+  bool unlikely_p = false;\n+  tree worklist[MAX_NITERS];\n+  unsigned int length = 0;\n+  worklist[length++] = stride;\n+  for (unsigned int i = 0; i < length; ++i)\n+    {\n+      tree expr = worklist[i];\n+\n+      if (CONSTANT_CLASS_P (expr))\n+\t{\n+\t  /* See if EXPR * MULTIPLIER would be consistent with an individual\n+\t     access or a small grouped access.  */\n+\t  if (acceptable_multiplier_p (expr, multiplier))\n+\t    return INNER_LIKELY;\n+\t  else\n+\t    unlikely_p = true;\n+\t}\n+      else if (gimple *stmt = maybe_get_stmt (expr))\n+\t{\n+\t  /* If EXPR is set by a PHI node, queue its arguments in case\n+\t     we find one that is consistent with an inner dimension.\n+\n+\t     An important instance of this is the Fortran handling of array\n+\t     descriptors, which calculates the stride of the inner dimension\n+\t     using a PHI equivalent of:\n+\n+\t\traw_stride = a.dim[0].stride;\n+\t\tstride = raw_stride != 0 ? raw_stride : 1;\n+\n+\t     (Strides for outer dimensions do not treat 0 specially.)  */\n+\t  if (gphi *phi = dyn_cast <gphi *> (stmt))\n+\t    {\n+\t      unsigned int nargs = gimple_phi_num_args (phi);\n+\t      for (unsigned int j = 0; j < nargs && length < MAX_NITERS; ++j)\n+\t\tworklist[length++] = strip_casts (gimple_phi_arg_def (phi, j));\n+\t    }\n+\t  /* If the value is set by an assignment, expect it to be read\n+\t     from memory (such as an array descriptor) rather than be\n+\t     calculated.  */\n+\t  else if (gassign *assign = dyn_cast <gassign *> (stmt))\n+\t    {\n+\t      if (!gimple_assign_load_p (assign))\n+\t\tunlikely_p = true;\n+\t    }\n+\t  /* Things like calls don't really tell us anything.  */\n+\t}\n+    }\n+\n+  /* We didn't find any possible values of STRIDE that were likely to be\n+     for the innermost dimension.  If we found one that was actively\n+     unlikely to be for the innermost dimension, assume that that applies\n+     to STRIDE too.  */\n+  return unlikely_p ? INNER_UNLIKELY : INNER_DONT_KNOW;\n+}\n+\n+/* The caller has identified that STRIDE is the stride of interest\n+   in TERM, and that the stride is applied in OP_LOOP.  Record this\n+   information in TERM, deciding whether STRIDE is likely to be for\n+   the innermost dimension of an array and whether it represents a\n+   versioning opportunity.  ADDRESS is the address that contains TERM.  */\n+\n+void\n+loop_versioning::analyze_stride (address_info &address,\n+\t\t\t\t address_term_info &term,\n+\t\t\t\t tree stride, struct loop *op_loop)\n+{\n+  term.stride = stride;\n+\n+  term.inner_likelihood = get_inner_likelihood (stride, term.multiplier);\n+  if (dump_enabled_p ())\n+    {\n+      if (term.inner_likelihood == INNER_LIKELY)\n+\tdump_printf_loc (MSG_NOTE, address.stmt, \"%T is likely to be the\"\n+\t\t\t \" innermost dimension\\n\", stride);\n+      else if (term.inner_likelihood == INNER_UNLIKELY)\n+\tdump_printf_loc (MSG_NOTE, address.stmt, \"%T is probably not the\"\n+\t\t\t \" innermost dimension\\n\", stride);\n+      else\n+\tdump_printf_loc (MSG_NOTE, address.stmt, \"cannot tell whether %T\"\n+\t\t\t \" is the innermost dimension\\n\", stride);\n+    }\n+\n+  /* To be a versioning opportunity we require:\n+\n+     - The multiplier applied by TERM is equal to the access size,\n+       so that when STRIDE is 1, the accesses in successive loop\n+       iterations are consecutive.\n+\n+       This is deliberately conservative.  We could relax it to handle\n+       other cases (such as those with gaps between iterations) if we\n+       find any real testcases for which it's useful.\n+\n+     - the stride is applied in the same loop as STMT rather than\n+       in an outer loop.  Although versioning for strides applied in\n+       outer loops could help in some cases -- such as enabling\n+       more loop interchange -- the savings are much lower than for\n+       inner loops.\n+\n+     - the stride is an SSA name that is invariant in STMT's loop,\n+       since otherwise versioning isn't possible.  */\n+  unsigned HOST_WIDE_INT access_size = address.max_offset - address.min_offset;\n+  if (term.multiplier == access_size\n+      && address.loop == op_loop\n+      && TREE_CODE (stride) == SSA_NAME\n+      && expr_invariant_in_loop_p (address.loop, stride))\n+    {\n+      term.versioning_opportunity_p = true;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, address.stmt, \"%T == 1 is a versioning\"\n+\t\t\t \" opportunity\\n\", stride);\n+    }\n+}\n+\n+/* See whether address term TERM (which belongs to ADDRESS) is the result\n+   of multiplying a varying SSA name by a loop-invariant SSA name.\n+   Return true and update TERM if so.\n+\n+   This handles both cases that SCEV might handle, such as:\n+\n+     for (int i = 0; i < n; ++i)\n+       res += a[i * stride];\n+\n+   and ones in which the term varies arbitrarily between iterations, such as:\n+\n+     for (int i = 0; i < n; ++i)\n+       res += a[index[i] * stride];  */\n+\n+bool\n+loop_versioning::find_per_loop_multiplication (address_info &address,\n+\t\t\t\t\t       address_term_info &term)\n+{\n+  gimple *mult = maybe_get_assign (term.expr);\n+  if (!mult || gimple_assign_rhs_code (mult) != MULT_EXPR)\n+    return false;\n+\n+  struct loop *mult_loop = loop_containing_stmt (mult);\n+  if (!loop_outer (mult_loop))\n+    return false;\n+\n+  tree op1 = strip_casts (gimple_assign_rhs1 (mult));\n+  tree op2 = strip_casts (gimple_assign_rhs2 (mult));\n+  if (TREE_CODE (op1) != SSA_NAME || TREE_CODE (op2) != SSA_NAME)\n+    return false;\n+\n+  bool invariant1_p = expr_invariant_in_loop_p (mult_loop, op1);\n+  bool invariant2_p = expr_invariant_in_loop_p (mult_loop, op2);\n+  if (invariant1_p == invariant2_p)\n+    return false;\n+\n+  /* Make sure that the loop invariant is OP2 rather than OP1.  */\n+  if (invariant1_p)\n+    std::swap (op1, op2);\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, address.stmt, \"address term %T = varying %T\"\n+\t\t     \" * loop-invariant %T\\n\", term.expr, op1, op2);\n+  analyze_stride (address, term, op2, mult_loop);\n+  return true;\n+}\n+\n+/* Try to use scalar evolutions to find an address stride for TERM,\n+   which belongs to ADDRESS.\n+\n+   Here we are interested in any evolution information we can find,\n+   not just evolutions wrt ADDRESS->LOOP.  For example, if we find that\n+   an outer loop obviously iterates over the inner dimension of an array,\n+   that information can help us eliminate worthless versioning opportunities\n+   in inner loops.  */\n+\n+void\n+loop_versioning::analyze_term_using_scevs (address_info &address,\n+\t\t\t\t\t   address_term_info &term)\n+{\n+  gimple *setter = maybe_get_stmt (term.expr);\n+  if (!setter)\n+    return;\n+\n+  struct loop *wrt_loop = loop_containing_stmt (setter);\n+  if (!loop_outer (wrt_loop))\n+    return;\n+\n+  tree chrec = strip_casts (analyze_scalar_evolution (wrt_loop, term.expr));\n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, address.stmt,\n+\t\t\t \"address term %T = %T\\n\", term.expr, chrec);\n+\n+      /* Peel casts and accumulate constant multiplications, up to the\n+\t limit allowed by M_MAXIMUM_SCALE.  */\n+      tree stride = strip_casts (CHREC_RIGHT (chrec));\n+      while (TREE_CODE (stride) == MULT_EXPR\n+\t     && multiply_term_by (term, TREE_OPERAND (stride, 1)))\n+\tstride = strip_casts (TREE_OPERAND (stride, 0));\n+\n+      gassign *assign;\n+      while ((assign = maybe_get_assign (stride))\n+\t     && gimple_assign_rhs_code (assign) == MULT_EXPR\n+\t     && multiply_term_by (term, gimple_assign_rhs2 (assign)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, address.stmt,\n+\t\t\t     \"looking through %G\", assign);\n+\t  stride = strip_casts (gimple_assign_rhs1 (assign));\n+\t}\n+\n+      analyze_stride (address, term, stride, get_chrec_loop (chrec));\n+    }\n+}\n+\n+/* Try to identify loop strides in ADDRESS and try to choose realistic\n+   versioning opportunities based on these strides.\n+\n+   The main difficulty here isn't finding strides that could be used\n+   in a version check (that's pretty easy).  The problem instead is to\n+   avoid versioning for some stride S that is unlikely ever to be 1 at\n+   runtime.  Versioning for S == 1 on its own would lead to unnecessary\n+   code bloat, while adding S == 1 to more realistic version conditions\n+   would lose the optimisation opportunity offered by those other conditions.\n+\n+   For example, versioning for a stride of 1 in the Fortran code:\n+\n+     integer :: a(:,:)\n+     a(1,:) = 1\n+\n+   is not usually a good idea, since the assignment is iterating over\n+   an outer dimension and is relatively unlikely to have a stride of 1.\n+   (It isn't impossible, since the inner dimension might be 1, or the\n+   array might be transposed.)  Similarly, in:\n+\n+     integer :: a(:,:), b(:,:)\n+     b(:,1) = a(1,:)\n+\n+   b(:,1) is relatively likely to have a stride of 1 while a(1,:) isn't.\n+   Versioning for when both strides are 1 would lose most of the benefit\n+   of versioning for b's access.\n+\n+   The approach we take is as follows:\n+\n+   - Analyze each term to see whether it has an identifiable stride,\n+     regardless of which loop applies the stride.\n+\n+   - Evaluate the likelihood that each such stride is for the innermost\n+     dimension of an array, on the scale \"likely\", \"don't know\" or \"unlikely\".\n+\n+   - If there is a single \"likely\" innermost stride, and that stride is\n+     applied in the loop that contains STMT, version the loop for when the\n+     stride is 1.  This deals with the cases in which we're fairly\n+     confident of doing the right thing, such as the b(:,1) reference above.\n+\n+   - If there are no \"likely\" innermost strides, and the loop that contains\n+     STMT uses a stride that we rated as \"don't know\", version for when\n+     that stride is 1.  This is principally used for C code such as:\n+\n+       for (int i = 0; i < n; ++i)\n+\t a[i * x] = ...;\n+\n+     and:\n+\n+       for (int j = 0; j < n; ++j)\n+\t for (int i = 0; i < n; ++i)\n+\t   a[i * x + j * y] = ...;\n+\n+     where nothing in the way \"x\" and \"y\" are set gives a hint as to\n+     whether \"i\" iterates over the innermost dimension of the array.\n+     In these situations it seems reasonable to assume the the\n+     programmer has nested the loops appropriately (although of course\n+     there are examples like GEMM in which this assumption doesn't hold\n+     for all accesses in the loop).\n+\n+     This case is also useful for the Fortran equivalent of the\n+     above C code.  */\n+\n+void\n+loop_versioning::analyze_address_fragment (address_info &address)\n+{\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, address.stmt, \"analyzing address fragment \");\n+      dump_address_info (MSG_NOTE, address);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  /* Analyze each component of the sum to see whether it involves an\n+     apparent stride.\n+\n+     There is an overlap between the addresses that\n+     find_per_loop_multiplication and analyze_term_using_scevs can handle,\n+     but the former is much cheaper than SCEV analysis, so try it first.  */\n+  for (unsigned int i = 0; i < address.terms.length (); ++i)\n+    if (!find_per_loop_multiplication (address, address.terms[i]))\n+      analyze_term_using_scevs (address, address.terms[i]);\n+\n+  /* Check for strides that are likely to be for the innermost dimension.\n+\n+     1. If there is a single likely inner stride, if it is an SSA name,\n+\tand if it is worth versioning the loop for when the SSA name\n+\tequals 1, record that we want to do so.\n+\n+     2. Otherwise, if there any likely inner strides, bail out.  This means\n+\tone of:\n+\n+\t(a) There are multiple likely inner strides.  This suggests we're\n+\t    confused and be can't be confident of doing the right thing.\n+\n+\t(b) There is a single likely inner stride and it is a constant\n+\t    rather than an SSA name.  This can mean either that the access\n+\t    is a natural one without any variable strides, such as:\n+\n+\t      for (int i = 0; i < n; ++i)\n+\t\ta[i] += 1;\n+\n+\t    or that a variable stride is applied to an outer dimension,\n+\t    such as:\n+\n+\t      for (int i = 0; i < n; ++i)\n+\t\tfor (int j = 0; j < n; ++j)\n+\t\t  a[j * stride][i] += 1;\n+\n+\t(c) There is a single likely inner stride, and it is an SSA name,\n+\t    but it isn't a worthwhile versioning opportunity.  This usually\n+\t    means that the variable stride is applied by an outer loop,\n+\t    such as:\n+\n+\t      for (int i = 0; i < n; ++i)\n+\t\tfor (int j = 0; j < n; ++j)\n+\t\t  a[j][i * stride] += 1;\n+\n+\t    or (using an example with a more natural loop nesting):\n+\n+\t      for (int i = 0; i < n; ++i)\n+\t\tfor (int j = 0; j < n; ++j)\n+\t\t  a[i][j] += b[i * stride];\n+\n+\t    in cases where b[i * stride] cannot (yet) be hoisted for\n+\t    aliasing reasons.\n+\n+     3. If there are no likely inner strides, fall through to the next\n+\tset of checks.\n+\n+     Pointer equality is enough to check for uniqueness in (1), since we\n+     only care about SSA names.  */\n+  tree chosen_stride = NULL_TREE;\n+  tree version_stride = NULL_TREE;\n+  for (unsigned int i = 0; i < address.terms.length (); ++i)\n+    if (chosen_stride != address.terms[i].stride\n+\t&& address.terms[i].inner_likelihood == INNER_LIKELY)\n+      {\n+\tif (chosen_stride)\n+\t  return;\n+\tchosen_stride = address.terms[i].stride;\n+\tif (address.terms[i].versioning_opportunity_p)\n+\t  version_stride = chosen_stride;\n+      }\n+\n+  /* If there are no likely inner strides, see if there is a single\n+     versioning opportunity for a stride that was rated as INNER_DONT_KNOW.\n+     See the comment above the function for the cases that this code\n+     handles.  */\n+  if (!chosen_stride)\n+    for (unsigned int i = 0; i < address.terms.length (); ++i)\n+      if (version_stride != address.terms[i].stride\n+\t  && address.terms[i].inner_likelihood == INNER_DONT_KNOW\n+\t  && address.terms[i].versioning_opportunity_p)\n+\t{\n+\t  if (version_stride)\n+\t    return;\n+\t  version_stride = address.terms[i].stride;\n+\t}\n+\n+  if (version_stride)\n+    version_for_unity (address.stmt, version_stride);\n+}\n+\n+/* Treat EXPR * MULTIPLIER + OFFSET as a fragment of an address that addresses\n+   TYPE_SIZE bytes and record this address fragment for later processing.\n+   STMT is the statement that contains the address.  */\n+\n+void\n+loop_versioning::record_address_fragment (gimple *stmt,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT type_size,\n+\t\t\t\t\t  tree expr,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT multiplier,\n+\t\t\t\t\t  HOST_WIDE_INT offset)\n+{\n+  /* We're only interested in computed values.  */\n+  if (TREE_CODE (expr) != SSA_NAME)\n+    return;\n+\n+  /* Quick exit if no part of the address is calculated in STMT's loop,\n+     since such addresses have no versioning opportunities.  */\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  if (expr_invariant_in_loop_p (loop, expr))\n+    return;\n+\n+  /* Set up an address_info for EXPR * MULTIPLIER.  */\n+  address_info *address = XOBNEW (&m_obstack, address_info);\n+  new (address) address_info;\n+  address->stmt = stmt;\n+  address->loop = loop;\n+  address->base = NULL_TREE;\n+  address->terms.quick_grow (1);\n+  address->terms[0].expr = expr;\n+  address->terms[0].multiplier = multiplier;\n+  address->terms[0].stride = NULL_TREE;\n+  address->terms[0].inner_likelihood = INNER_UNLIKELY;\n+  address->terms[0].versioning_opportunity_p = false;\n+  address->min_offset = offset;\n+\n+  /* Peel apart the expression into a sum of address_terms, where each\n+     term is multiplied by a constant.  Treat a + b and a - b the same,\n+     since it doesn't matter for our purposes whether an address is\n+     increasing or decreasing.  Distribute (a + b) * constant into\n+     a * constant + b * constant.\n+\n+     We don't care which loop each term belongs to, since we want to\n+     examine as many candidate strides as possible when determining\n+     which is likely to be for the innermost dimension.  We therefore\n+     don't limit the search to statements in STMT's loop.  */\n+  for (unsigned int i = 0; i < address->terms.length (); )\n+    {\n+      if (gassign *assign = maybe_get_assign (address->terms[i].expr))\n+\t{\n+\t  tree_code code = gimple_assign_rhs_code (assign);\n+\t  if (code == PLUS_EXPR\n+\t      || code == POINTER_PLUS_EXPR\n+\t      || code == MINUS_EXPR)\n+\t    {\n+\t      tree op1 = gimple_assign_rhs1 (assign);\n+\t      tree op2 = gimple_assign_rhs2 (assign);\n+\t      if (TREE_CODE (op2) == INTEGER_CST)\n+\t\t{\n+\t\t  address->terms[i].expr = strip_casts (op1);\n+\t\t  /* This is heuristic only, so don't worry about truncation\n+\t\t     or overflow.  */\n+\t\t  address->min_offset += (TREE_INT_CST_LOW (op2)\n+\t\t\t\t\t  * address->terms[i].multiplier);\n+\t\t  continue;\n+\t\t}\n+\t      else if (address->terms.length () < address_info::MAX_TERMS)\n+\t\t{\n+\t\t  unsigned int j = address->terms.length ();\n+\t\t  address->terms.quick_push (address->terms[i]);\n+\t\t  address->terms[i].expr = strip_casts (op1);\n+\t\t  address->terms[j].expr = strip_casts (op2);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  if (code == MULT_EXPR)\n+\t    {\n+\t      tree op1 = gimple_assign_rhs1 (assign);\n+\t      tree op2 = gimple_assign_rhs2 (assign);\n+\t      if (multiply_term_by (address->terms[i], op2))\n+\t\t{\n+\t\t  address->terms[i].expr = strip_casts (op1);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+      i += 1;\n+    }\n+\n+  /* Peel off any symbolic pointer.  */\n+  if (TREE_CODE (address->terms[0].expr) != SSA_NAME\n+      && address->terms[0].multiplier == 1)\n+    {\n+      if (address->terms.length () == 1)\n+\t{\n+\t  obstack_free (&m_obstack, address);\n+\t  return;\n+\t}\n+      address->base = address->terms[0].expr;\n+      address->terms.ordered_remove (0);\n+    }\n+\n+  /* Require all remaining terms to be SSA names.  (This could be false\n+     for unfolded statements, but they aren't worth dealing with.)  */\n+  for (unsigned int i = 0; i < address->terms.length (); ++i)\n+    if (TREE_CODE (address->terms[i].expr) != SSA_NAME)\n+      {\n+\tobstack_free (&m_obstack, address);\n+\treturn;\n+      }\n+\n+  /* The loop above set MIN_OFFSET based on the first byte of the\n+     referenced data.  Calculate the end + 1.  */\n+  address->max_offset = address->min_offset + type_size;\n+\n+  /* Put the terms into a canonical order for the hash table lookup below.  */\n+  address->terms.qsort (compare_address_terms);\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, stmt, \"recording address fragment %T\", expr);\n+      if (multiplier != 1)\n+\tdump_printf (MSG_NOTE, \" * %wd\", multiplier);\n+      dump_printf (MSG_NOTE, \" = \");\n+      dump_address_info (MSG_NOTE, *address);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  /* Pool address information with the same terms (but potentially\n+     different offsets).  */\n+  address_info **slot = m_address_table.find_slot (address, INSERT);\n+  if (address_info *old_address = *slot)\n+    {\n+      /* We've already seen an address with the same terms.  Extend the\n+\t offset range to account for this access.  Doing this can paper\n+\t over gaps, such as in:\n+\n+\t   a[i * stride * 4] + a[i * stride * 4 + 3];\n+\n+\t where nothing references \"+ 1\" or \"+ 2\".  However, the vectorizer\n+\t handles such gapped accesses without problems, so it's not worth\n+\t trying to exclude them.  */\n+      if (old_address->min_offset > address->min_offset)\n+\told_address->min_offset = address->min_offset;\n+      if (old_address->max_offset < address->max_offset)\n+\told_address->max_offset = address->max_offset;\n+      obstack_free (&m_obstack, address);\n+    }\n+  else\n+    {\n+      /* This is the first time we've seen an address with these terms.  */\n+      *slot = address;\n+      m_address_list.safe_push (address);\n+    }\n+}\n+\n+/* Analyze expression EXPR, which occurs in STMT.  */\n+\n+void\n+loop_versioning::analyze_expr (gimple *stmt, tree expr)\n+{\n+  unsigned HOST_WIDE_INT type_size;\n+\n+  while (handled_component_p (expr))\n+    {\n+      /* See whether we can use versioning to avoid a multiplication\n+\t in an array index.  */\n+      if (TREE_CODE (expr) == ARRAY_REF\n+\t  && acceptable_type_p (TREE_TYPE (expr), &type_size))\n+\trecord_address_fragment (stmt, type_size,\n+\t\t\t\t TREE_OPERAND (expr, 1), type_size, 0);\n+      expr = TREE_OPERAND (expr, 0);\n+    }\n+\n+  /* See whether we can use versioning to avoid a multiplication\n+     in the pointer calculation of a MEM_REF.  */\n+  if (TREE_CODE (expr) == MEM_REF\n+      && acceptable_type_p (TREE_TYPE (expr), &type_size))\n+    record_address_fragment (stmt, type_size, TREE_OPERAND (expr, 0), 1,\n+\t\t\t     /* This is heuristic only, so don't worry\n+\t\t\t\tabout truncation or overflow.  */\n+\t\t\t     TREE_INT_CST_LOW (TREE_OPERAND (expr, 1)));\n+\n+  /* These would be easy to handle if they existed at this stage.  */\n+  gcc_checking_assert (TREE_CODE (expr) != TARGET_MEM_REF);\n+}\n+\n+/* Analyze all the statements in BB looking for useful version checks.\n+   Return true on success, false if something prevents the block from\n+   being versioned.  */\n+\n+bool\n+loop_versioning::analyze_block (basic_block bb)\n+{\n+  struct loop *loop = bb->loop_father;\n+  loop_info &li = get_loop_info (loop);\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      if (expensive_stmt_p (stmt))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, stmt, \"expensive statement\"\n+\t\t\t     \" prevents versioning: %G\", stmt);\n+\t  return false;\n+\t}\n+\n+      /* Only look for direct versioning opportunities in inner loops\n+\t since the benefit tends to be much smaller for outer loops.  */\n+      if (!loop->inner)\n+\t{\n+\t  unsigned int nops = gimple_num_ops (stmt);\n+\t  for (unsigned int i = 0; i < nops; ++i)\n+\t    if (tree op = gimple_op (stmt, i))\n+\t      analyze_expr (stmt, op);\n+\t}\n+\n+      /* The point of the instruction limit is to prevent excessive\n+\t code growth, so this is a size-based estimate even though\n+\t the optimization is aimed at speed.  */\n+      li.num_insns += estimate_num_insns (stmt, &eni_size_weights);\n+    }\n+\n+  return true;\n+}\n+\n+/* Analyze all the blocks in the function, looking for useful version checks.\n+   Return true if we found one.  */\n+\n+bool\n+loop_versioning::analyze_blocks ()\n+{\n+  AUTO_DUMP_SCOPE (\"analyze_blocks\",\n+\t\t   dump_user_location_t::from_function_decl (m_fn->decl));\n+\n+  /* For now we don't try to version the whole function, although\n+     versioning at that level could be useful in some cases.  */\n+  get_loop_info (get_loop (m_fn, 0)).rejected_p = true;\n+\n+  struct loop *loop;\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n+    {\n+      loop_info &linfo = get_loop_info (loop);\n+\n+      /* Ignore cold loops.  */\n+      if (!optimize_loop_for_speed_p (loop))\n+\tlinfo.rejected_p = true;\n+\n+      /* See whether an inner loop prevents versioning of this loop.  */\n+      if (!linfo.rejected_p)\n+\tfor (struct loop *inner = loop->inner; inner; inner = inner->next)\n+\t  if (get_loop_info (inner).rejected_p)\n+\t    {\n+\t      linfo.rejected_p = true;\n+\t      break;\n+\t    }\n+\n+      /* If versioning the loop is still a possibility, examine the\n+\t statements in the loop to look for versioning opportunities.  */\n+      if (!linfo.rejected_p)\n+\t{\n+\t  void *start_point = obstack_alloc (&m_obstack, 0);\n+\n+\t  for (basic_block bb = linfo.block_list; bb;\n+\t       bb = m_next_block_in_loop[bb->index])\n+\t    if (!analyze_block (bb))\n+\t      {\n+\t\tlinfo.rejected_p = true;\n+\t\tbreak;\n+\t    }\n+\n+\t  if (!linfo.rejected_p)\n+\t    {\n+\t      /* Process any queued address fragments, now that we have\n+\t\t complete grouping information.  */\n+\t      address_info *address;\n+\t      unsigned int i;\n+\t      FOR_EACH_VEC_ELT (m_address_list, i, address)\n+\t\tanalyze_address_fragment (*address);\n+\t    }\n+\n+\t  m_address_table.empty ();\n+\t  m_address_list.truncate (0);\n+\t  obstack_free (&m_obstack, start_point);\n+\t}\n+    }\n+\n+  return m_num_conditions != 0;\n+}\n+\n+/* Use the ranges in VRS to remove impossible versioning conditions from\n+   LOOP.  */\n+\n+void\n+loop_versioning::prune_loop_conditions (struct loop *loop, vr_values *vrs)\n+{\n+  loop_info &li = get_loop_info (loop);\n+\n+  int to_remove = -1;\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  EXECUTE_IF_SET_IN_BITMAP (&li.unity_names, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      value_range *vr = vrs->get_value_range (name);\n+      if (vr && !range_includes_p (vr, 1))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, find_loop_location (loop),\n+\t\t\t     \"%T can never be 1 in this loop\\n\", name);\n+\n+\t  if (to_remove >= 0)\n+\t    bitmap_clear_bit (&li.unity_names, to_remove);\n+\t  to_remove = i;\n+\t  m_num_conditions -= 1;\n+\t}\n+    }\n+  if (to_remove >= 0)\n+    bitmap_clear_bit (&li.unity_names, to_remove);\n+}\n+\n+/* Remove any scheduled loop version conditions that will never be true.\n+   Return true if any remain.  */\n+\n+bool\n+loop_versioning::prune_conditions ()\n+{\n+  AUTO_DUMP_SCOPE (\"prune_loop_conditions\",\n+\t\t   dump_user_location_t::from_function_decl (m_fn->decl));\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  lv_dom_walker dom_walker (*this);\n+  dom_walker.walk (ENTRY_BLOCK_PTR_FOR_FN (m_fn));\n+  return m_num_conditions != 0;\n+}\n+\n+/* Merge the version checks for INNER into immediately-enclosing loop\n+   OUTER.  */\n+\n+void\n+loop_versioning::merge_loop_info (struct loop *outer, struct loop *inner)\n+{\n+  loop_info &inner_li = get_loop_info (inner);\n+  loop_info &outer_li = get_loop_info (outer);\n+\n+  if (dump_enabled_p ())\n+    {\n+      bitmap_iterator bi;\n+      unsigned int i;\n+      EXECUTE_IF_SET_IN_BITMAP (&inner_li.unity_names, 0, i, bi)\n+\tif (!bitmap_bit_p (&outer_li.unity_names, i))\n+\t  dump_printf_loc (MSG_NOTE, find_loop_location (inner),\n+\t\t\t   \"hoisting check that %T == 1 to outer loop\\n\",\n+\t\t\t   ssa_name (i));\n+    }\n+\n+  bitmap_ior_into (&outer_li.unity_names, &inner_li.unity_names);\n+  if (loop_depth (outer_li.outermost) < loop_depth (inner_li.outermost))\n+    outer_li.outermost = inner_li.outermost;\n+}\n+\n+/* Add LOOP to the queue of loops to version.  */\n+\n+void\n+loop_versioning::add_loop_to_queue (struct loop *loop)\n+{\n+  loop_info &li = get_loop_info (loop);\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, find_loop_location (loop),\n+\t\t     \"queuing this loop for versioning\\n\");\n+  m_loops_to_version.safe_push (loop);\n+\n+  /* Don't try to version superloops.  */\n+  li.rejected_p = true;\n+}\n+\n+/* Decide whether the cost model would allow us to version LOOP,\n+   either directly or as part of a parent loop, and return true if so.\n+   This does not imply that the loop is actually worth versioning in its\n+   own right, just that it would be valid to version it if something\n+   benefited.\n+\n+   We have already made this decision for all inner loops of LOOP.  */\n+\n+bool\n+loop_versioning::decide_whether_loop_is_versionable (struct loop *loop)\n+{\n+  loop_info &li = get_loop_info (loop);\n+\n+  if (li.rejected_p)\n+    return false;\n+\n+  /* Examine the decisions made for inner loops.  */\n+  for (struct loop *inner = loop->inner; inner; inner = inner->next)\n+    {\n+      loop_info &inner_li = get_loop_info (inner);\n+      if (inner_li.rejected_p)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, find_loop_location (loop),\n+\t\t\t     \"not versioning this loop because one of its\"\n+\t\t\t     \" inner loops should not be versioned\\n\");\n+\t  return false;\n+\t}\n+\n+      if (inner_li.worth_versioning_p ())\n+\tli.subloops_benefit_p = true;\n+\n+      /* Accumulate the number of instructions from subloops that are not\n+\t the innermost, or that don't benefit from versioning.  Only the\n+\t instructions from innermost loops that benefit from versioning\n+\t should be weighed against loop-versioning-max-inner-insns;\n+\t everything else should be weighed against\n+\t loop-versioning-max-outer-insns.  */\n+      if (!inner_li.worth_versioning_p () || inner->inner)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, find_loop_location (loop),\n+\t\t\t     \"counting %d instructions from this loop\"\n+\t\t\t     \" against its parent loop\\n\", inner_li.num_insns);\n+\t  li.num_insns += inner_li.num_insns;\n+\t}\n+    }\n+\n+  /* Enforce the size limits.  */\n+  if (li.worth_versioning_p ())\n+    {\n+      unsigned int max_num_insns = max_insns_for_loop (loop);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, find_loop_location (loop),\n+\t\t\t \"this loop has %d instructions, against\"\n+\t\t\t \" a versioning limit of %d\\n\",\n+\t\t\t li.num_insns, max_num_insns);\n+      if (li.num_insns > max_num_insns)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION\n+\t\t\t     | MSG_PRIORITY_USER_FACING,\n+\t\t\t     find_loop_location (loop),\n+\t\t\t     \"this loop is too big to version\");\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Hoist all version checks from subloops to this loop.  */\n+  for (struct loop *subloop = loop->inner; subloop; subloop = subloop->next)\n+    merge_loop_info (loop, subloop);\n+\n+  return true;\n+}\n+\n+/* Decide which loops to version and add them to the versioning queue.\n+   Return true if there are any loops to version.  */\n+\n+bool\n+loop_versioning::make_versioning_decisions ()\n+{\n+  AUTO_DUMP_SCOPE (\"make_versioning_decisions\",\n+\t\t   dump_user_location_t::from_function_decl (m_fn->decl));\n+\n+  struct loop *loop;\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n+    {\n+      loop_info &linfo = get_loop_info (loop);\n+      if (decide_whether_loop_is_versionable (loop))\n+\t{\n+\t  /* Commit to versioning LOOP directly if we can't hoist the\n+\t     version checks any further.  */\n+\t  if (linfo.worth_versioning_p ()\n+\t      && (loop_depth (loop) == 1 || linfo.outermost == loop))\n+\t    add_loop_to_queue (loop);\n+\t}\n+      else\n+\t{\n+\t  /* We can't version this loop, so individually version any\n+\t     subloops that would benefit and haven't been versioned yet.  */\n+\t  linfo.rejected_p = true;\n+\t  for (struct loop *subloop = loop->inner; subloop;\n+\t       subloop = subloop->next)\n+\t    if (get_loop_info (subloop).worth_versioning_p ())\n+\t      add_loop_to_queue (subloop);\n+\t}\n+    }\n+\n+  return !m_loops_to_version.is_empty ();\n+}\n+\n+/* Attempt to implement loop versioning for LOOP, using the information\n+   cached in the associated loop_info.  Return true on success.  */\n+\n+bool\n+loop_versioning::version_loop (struct loop *loop)\n+{\n+  loop_info &li = get_loop_info (loop);\n+\n+  /* Build up a condition that selects the original loop instead of\n+     the simplified loop.  */\n+  tree cond = boolean_false_node;\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  EXECUTE_IF_SET_IN_BITMAP (&li.unity_names, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      tree ne_one = fold_build2 (NE_EXPR, boolean_type_node, name,\n+\t\t\t\t build_one_cst (TREE_TYPE (name)));\n+      cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, ne_one);\n+    }\n+\n+  /* Convert the condition into a suitable gcond.  */\n+  gimple_seq stmts = NULL;\n+  cond = force_gimple_operand_1 (cond, &stmts, is_gimple_condexpr, NULL_TREE);\n+\n+  /* Version the loop.  */\n+  initialize_original_copy_tables ();\n+  basic_block cond_bb;\n+  li.optimized_loop = loop_version (loop, cond, &cond_bb,\n+\t\t\t\t    profile_probability::unlikely (),\n+\t\t\t\t    profile_probability::likely (),\n+\t\t\t\t    profile_probability::unlikely (),\n+\t\t\t\t    profile_probability::likely (), true);\n+  free_original_copy_tables ();\n+  if (!li.optimized_loop)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, find_loop_location (loop),\n+\t\t\t \"tried but failed to version this loop for when\"\n+\t\t\t \" certain strides are 1\\n\");\n+      return false;\n+    }\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, find_loop_location (loop),\n+\t\t     \"versioned this loop for when certain strides are 1\\n\");\n+\n+  /* Insert the statements that feed COND.  */\n+  if (stmts)\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (cond_bb);\n+      gsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+    }\n+\n+  return true;\n+}\n+\n+/* Attempt to version all loops in the versioning queue.  */\n+\n+void\n+loop_versioning::implement_versioning_decisions ()\n+{\n+  /* No AUTO_DUMP_SCOPE here since all messages are top-level and\n+     user-facing at this point.  */\n+\n+  bool any_succeeded_p = false;\n+  struct loop *loop;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (m_loops_to_version, i, loop)\n+    if (version_loop (loop))\n+      any_succeeded_p = true;\n+  if (!any_succeeded_p)\n+    return;\n+\n+  update_ssa (TODO_update_ssa);\n+\n+  /* Simplify the new loop, which is used when COND is false.  */\n+  FOR_EACH_VEC_ELT (m_loops_to_version, i, loop)\n+    {\n+      loop_info &linfo = get_loop_info (loop);\n+      if (linfo.optimized_loop)\n+\tname_prop (linfo).substitute_and_fold (linfo.optimized_loop->header);\n+    }\n+}\n+\n+/* Run the pass and return a set of TODO_* flags.  */\n+\n+unsigned int\n+loop_versioning::run ()\n+{\n+  gcc_assert (scev_initialized_p ());\n+\n+  if (analyze_blocks ()\n+      && prune_conditions ()\n+      && make_versioning_decisions ())\n+    implement_versioning_decisions ();\n+\n+  return 0;\n+}\n+\n+/* Loop versioning pass.  */\n+\n+const pass_data pass_data_loop_versioning =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"lversion\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  TV_LOOP_VERSIONING, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_loop_versioning : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_versioning (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_versioning, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_version_loops_for_strides; }\n+  virtual unsigned int execute (function *);\n+};\n+\n+unsigned int\n+pass_loop_versioning::execute (function *fn)\n+{\n+  if (number_of_loops (fn) <= 1)\n+    return 0;\n+\n+  return loop_versioning (fn).run ();\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_loop_versioning (gcc::context *ctxt)\n+{\n+  return new pass_loop_versioning (ctxt);\n+}"}, {"sha": "64e56c2578236aa39aeaeb761ee56a3e5e052032", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -556,6 +556,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_3_PLUS, OPT_ftree_slp_vectorize, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_funswitch_loops, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_DYNAMIC },\n+    { OPT_LEVELS_3_PLUS, OPT_fversion_loops_for_strides, NULL, 1 },\n \n     /* -Ofast adds optimizations to -O3.  */\n     { OPT_LEVELS_FAST, OPT_ffast_math, NULL, 1 },"}, {"sha": "6f98fccd291d93d28848f0298de45b75c1f8b6f5", "filename": "gcc/params.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1365,6 +1365,19 @@ DEFPARAM(PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT,\n \t \"True if a non-short-circuit operation is optimal.\",\n \t -1, -1, 1)\n \n+DEFPARAM(PARAM_LOOP_VERSIONING_MAX_INNER_INSNS,\n+\t \"loop-versioning-max-inner-insns\",\n+\t \"The maximum number of instructions in an inner loop that is being\"\n+\t \" considered for versioning.\",\n+\t 200, 0, 0)\n+\n+DEFPARAM(PARAM_LOOP_VERSIONING_MAX_OUTER_INSNS,\n+\t \"loop-versioning-max-outer-insns\",\n+\t \"The maximum number of instructions in an outer loop that is being\"\n+\t \" considered for versioning, on top of the instructions in inner\"\n+\t \" loops.\",\n+\t 100, 0, 0)\n+\n /*\n \n Local variables:"}, {"sha": "144df4fa417d2ba6f4d795f2e0ad32eba6cb1c4f", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -265,6 +265,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_tree_unswitch);\n \t  NEXT_PASS (pass_scev_cprop);\n \t  NEXT_PASS (pass_loop_split);\n+\t  NEXT_PASS (pass_loop_versioning);\n \t  NEXT_PASS (pass_loop_jam);\n \t  /* All unswitching, final value replacement and splitting can expose\n \t     empty loops.  Remove them now.  */"}, {"sha": "6fc2f0c9e5acc612de7ee94c0d6e6c51d4ddd3a5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1,3 +1,25 @@\n+2018-12-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/loop-versioning-1.c: New test.\n+\t* gcc.dg/loop-versioning-10.c: Likewise.\n+\t* gcc.dg/loop-versioning-11.c: Likewise.\n+\t* gcc.dg/loop-versioning-2.c: Likewise.\n+\t* gcc.dg/loop-versioning-3.c: Likewise.\n+\t* gcc.dg/loop-versioning-4.c: Likewise.\n+\t* gcc.dg/loop-versioning-5.c: Likewise.\n+\t* gcc.dg/loop-versioning-6.c: Likewise.\n+\t* gcc.dg/loop-versioning-7.c: Likewise.\n+\t* gcc.dg/loop-versioning-8.c: Likewise.\n+\t* gcc.dg/loop-versioning-9.c: Likewise.\n+\t* gfortran.dg/loop_versioning_1.f90: Likewise.\n+\t* gfortran.dg/loop_versioning_2.f90: Likewise.\n+\t* gfortran.dg/loop_versioning_3.f90: Likewise.\n+\t* gfortran.dg/loop_versioning_4.f90: Likewise.\n+\t* gfortran.dg/loop_versioning_5.f90: Likewise.\n+\t* gfortran.dg/loop_versioning_6.f90: Likewise.\n+\t* gfortran.dg/loop_versioning_7.f90: Likewise.\n+\t* gfortran.dg/loop_versioning_8.f90: Likewise.\n+\n 2018-12-16  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/88116"}, {"sha": "e61ff7a5d107977ba25d5dc1f660bcfaca0c61ad", "filename": "gcc/testsuite/gcc.dg/loop-versioning-1.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-1.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* The simplest IV case.  */\n+\n+void\n+f1 (double *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[stepx * i] = 100;\n+}\n+\n+void\n+f2 (double *x, int stepx, int limit)\n+{\n+  for (int i = 0; i < limit; i += stepx)\n+    x[i] = 100;\n+}\n+\n+void\n+f3 (double *x, int stepx, int limit)\n+{\n+  for (double *y = x; y < x + limit; y += stepx)\n+    *y = 100;\n+}\n+\n+void\n+f4 (double *x, int stepx, unsigned int n)\n+{\n+  for (unsigned int i = 0; i < n; ++i)\n+    x[stepx * i] = 100;\n+}\n+\n+void\n+f5 (double *x, int stepx, unsigned int limit)\n+{\n+  for (unsigned int i = 0; i < limit; i += stepx)\n+    x[i] = 100;\n+}\n+\n+void\n+f6 (double *x, int stepx, unsigned int limit)\n+{\n+  for (double *y = x; y < x + limit; y += stepx)\n+    *y = 100;\n+}\n+\n+double x[10000];\n+\n+void\n+g1 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[stepx * i] = 100;\n+}\n+\n+void\n+g2 (int stepx, int limit)\n+{\n+  for (int i = 0; i < limit; i += stepx)\n+    x[i] = 100;\n+}\n+\n+void\n+g3 (int stepx, int limit)\n+{\n+  for (double *y = x; y < x + limit; y += stepx)\n+    *y = 100;\n+}\n+\n+void\n+g4 (int stepx, unsigned int n)\n+{\n+  for (unsigned int i = 0; i < n; ++i)\n+    x[stepx * i] = 100;\n+}\n+\n+void\n+g5 (int stepx, unsigned int limit)\n+{\n+  for (unsigned int i = 0; i < limit; i += stepx)\n+    x[i] = 100;\n+}\n+\n+void\n+g6 (int stepx, unsigned int limit)\n+{\n+  for (double *y = x; y < x + limit; y += stepx)\n+    *y = 100;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {want to version containing loop} 12 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {versioned this loop} 12 \"lversion\" } } */"}, {"sha": "f634448c253cfee9cc13c422192408fdec741d17", "filename": "gcc/testsuite/gcc.dg/loop-versioning-10.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-10.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Test that we can version a gather-like operation in which a variable\n+   stride is applied to the index.  */\n+\n+int\n+f1 (int *x, int *index, int step, int n)\n+{\n+  int res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res += x[index[i] * step];\n+  return res;\n+}\n+\n+int\n+f2 (int *x, int *index, int step, int n)\n+{\n+  int res = 0;\n+  for (int i = 0; i < n; ++i)\n+    {\n+      int *ptr = x + index[i] * step;\n+      res += *ptr;\n+    }\n+  return res;\n+}\n+\n+int x[1000];\n+\n+int\n+g1 (int *index, int step, int n)\n+{\n+  int res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res += x[index[i] * step];\n+  return res;\n+}\n+\n+int\n+g2 (int *index, int step, int n)\n+{\n+  int res = 0;\n+  for (int i = 0; i < n; ++i)\n+    {\n+      int *ptr = x + index[i] * step;\n+      res += *ptr;\n+    }\n+  return res;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {address term [^\\n]* \\* loop-invariant} 4 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {want to version containing loop} 4 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {versioned this loop} 4 \"lversion\" } } */"}, {"sha": "77ff484a4c2278f550a4ea1280f2e7e6509cda0a", "filename": "gcc/testsuite/gcc.dg/loop-versioning-11.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-11.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Test that we don't try to version for something that is never 1.  */\n+\n+void\n+f1 (double *x, int stepx, int n)\n+{\n+  if (stepx == 1)\n+    for (int i = 0; i < n; ++i)\n+      x[i] = 100;\n+  else\n+    for (int i = 0; i < n; ++i)\n+      x[stepx * i] = 100;\n+}\n+\n+void\n+f2 (double *x, int stepx, int n)\n+{\n+  if (stepx <= 1)\n+    for (int i = 0; i < n; ++i)\n+      x[i] = 100;\n+  else\n+    for (int i = 0; i < n; ++i)\n+      x[stepx * i] = 100;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {want to version containing loop} 2 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {can never be 1} 2 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "560acc4d80db4fdd0a2702f5e454a3039e0246c7", "filename": "gcc/testsuite/gcc.dg/loop-versioning-12.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-12.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Test that we don't try to version for a step of 1 when that would\n+   cause the iterations to overlap.  */\n+\n+void\n+f1 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx] = 100;\n+      x[i * stepx + 1] = 99;\n+    }\n+}\n+\n+void\n+f2 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx)\n+    {\n+      x[i] = 100;\n+      x[i + 1] = 99;\n+    }\n+}\n+\n+void\n+f3 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx - 16] = 100;\n+      x[i * stepx - 15] = 99;\n+    }\n+}\n+\n+void\n+f4 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx)\n+    {\n+      x[i - 16] = 100;\n+      x[i - 15] = 99;\n+    }\n+}\n+\n+void\n+f5 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx - 16] = 100;\n+      x[i * stepx + 15] = 99;\n+    }\n+}\n+\n+void\n+f6 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx)\n+    {\n+      x[i - 16] = 100;\n+      x[i + 15] = 99;\n+    }\n+}\n+\n+void\n+f7 (unsigned short *x, int stepx, int n)\n+{\n+  for (unsigned short *y = x; y < x + n; y += stepx)\n+    {\n+      y[0] = 100;\n+      y[1] = 99;\n+    }\n+}\n+\n+unsigned short x[1000];\n+\n+void\n+g1 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx] = 100;\n+      x[i * stepx + 1] = 99;\n+    }\n+}\n+\n+void\n+g2 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx)\n+    {\n+      x[i] = 100;\n+      x[i + 1] = 99;\n+    }\n+}\n+\n+void\n+g3 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx - 16] = 100;\n+      x[i * stepx - 15] = 99;\n+    }\n+}\n+\n+void\n+g4 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx)\n+    {\n+      x[i - 16] = 100;\n+      x[i - 15] = 99;\n+    }\n+}\n+\n+void\n+g5 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx - 16] = 100;\n+      x[i * stepx + 15] = 99;\n+    }\n+}\n+\n+void\n+g6 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx)\n+    {\n+      x[i - 16] = 100;\n+      x[i + 15] = 99;\n+    }\n+}\n+\n+void\n+g7 (int stepx, int n)\n+{\n+  for (unsigned short *y = x; y < x + n; y += stepx)\n+    {\n+      y[0] = 100;\n+      y[1] = 99;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not {want to version} \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "c67da047fa6cd81c9af2183187209396f8b908d0", "filename": "gcc/testsuite/gcc.dg/loop-versioning-13.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-13.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Test that we do version for a step of 1 when that would lead the\n+   iterations to access consecutive groups.  */\n+\n+void\n+f1 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 2] = 100;\n+      x[i * stepx * 2 + 1] = 99;\n+    }\n+}\n+\n+void\n+f2 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 2)\n+    {\n+      x[i] = 100;\n+      x[i + 1] = 99;\n+    }\n+}\n+\n+void\n+f3 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 2 - 16] = 100;\n+      x[i * stepx * 2 - 15] = 99;\n+    }\n+}\n+\n+void\n+f4 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 2)\n+    {\n+      x[i - 16] = 100;\n+      x[i - 15] = 99;\n+    }\n+}\n+\n+void\n+f5 (unsigned short *x, int stepx, int n)\n+{\n+  for (unsigned short *y = x; y < x + n; y += stepx * 2)\n+    {\n+      y[0] = 100;\n+      y[1] = 99;\n+    }\n+}\n+\n+unsigned short x[1000];\n+\n+void\n+g1 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 2] = 100;\n+      x[i * stepx * 2 + 1] = 99;\n+    }\n+}\n+\n+void\n+g2 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 2)\n+    {\n+      x[i] = 100;\n+      x[i + 1] = 99;\n+    }\n+}\n+\n+void\n+g3 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 2 - 16] = 100;\n+      x[i * stepx * 2 - 15] = 99;\n+    }\n+}\n+\n+void\n+g4 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 2)\n+    {\n+      x[i - 16] = 100;\n+      x[i - 15] = 99;\n+    }\n+}\n+\n+void\n+g5 (int stepx, int n)\n+{\n+  for (unsigned short *y = x; y < x + n; y += stepx * 2)\n+    {\n+      y[0] = 100;\n+      y[1] = 99;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times {want to version containing loop} 10 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {versioned this loop} 10 \"lversion\" } } */"}, {"sha": "f2926e5650c7cb31e3643be7ad221f578c88b7e3", "filename": "gcc/testsuite/gcc.dg/loop-versioning-14.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-14.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Test that we don't try to version for a step of 1 when that would\n+   cause the iterations to leave a gap between accesses.  */\n+\n+void\n+f1 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 4] = 100;\n+      x[i * stepx * 4 + 1] = 99;\n+    }\n+}\n+\n+void\n+f2 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 4)\n+    {\n+      x[i] = 100;\n+      x[i + 1] = 99;\n+    }\n+}\n+\n+void\n+f3 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 4 - 16] = 100;\n+      x[i * stepx * 4 - 15] = 99;\n+    }\n+}\n+\n+void\n+f4 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 4)\n+    {\n+      x[i - 16] = 100;\n+      x[i - 15] = 99;\n+    }\n+}\n+\n+void\n+f5 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 64 - 16] = 100;\n+      x[i * stepx * 64 + 15] = 99;\n+    }\n+}\n+\n+void\n+f6 (unsigned short *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 64)\n+    {\n+      x[i - 16] = 100;\n+      x[i + 15] = 99;\n+    }\n+}\n+\n+void\n+f7 (unsigned short *x, int stepx, int n)\n+{\n+  for (unsigned short *y = x; y < x + n; y += stepx * 4)\n+    {\n+      y[0] = 100;\n+      y[1] = 99;\n+    }\n+}\n+\n+unsigned short x[1000];\n+\n+void\n+g1 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 4] = 100;\n+      x[i * stepx * 4 + 1] = 99;\n+    }\n+}\n+\n+void\n+g2 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 4)\n+    {\n+      x[i] = 100;\n+      x[i + 1] = 99;\n+    }\n+}\n+\n+void\n+g3 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 4 - 16] = 100;\n+      x[i * stepx * 4 - 15] = 99;\n+    }\n+}\n+\n+void\n+g4 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 4)\n+    {\n+      x[i - 16] = 100;\n+      x[i - 15] = 99;\n+    }\n+}\n+\n+void\n+g5 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[i * stepx * 64 - 16] = 100;\n+      x[i * stepx * 64 + 15] = 99;\n+    }\n+}\n+\n+void\n+g6 (int stepx, int n)\n+{\n+  for (int i = 0; i < n; i += stepx * 64)\n+    {\n+      x[i - 16] = 100;\n+      x[i + 15] = 99;\n+    }\n+}\n+\n+void\n+g7 (int stepx, int n)\n+{\n+  for (unsigned short *y = x; y < x + n; y += stepx * 4)\n+    {\n+      y[0] = 100;\n+      y[1] = 99;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not {want to version} \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "9416b540614b8b8f6291a7b4758022f0e2c94ae1", "filename": "gcc/testsuite/gcc.dg/loop-versioning-2.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-2.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Versioning for step == 1 in these loops would allow loop interchange,\n+   but otherwise isn't worthwhile.  At the moment we decide not to version.  */\n+\n+void\n+f1 (double x[][100], int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j * step][i] = 100;\n+}\n+\n+void\n+f2 (double x[][100], int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j][i * step] = 100;\n+}\n+\n+void\n+f3 (double x[][100], int step, int limit)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    for (int j = 0; j < limit; j += step)\n+      x[j][i] = 100;\n+}\n+\n+void\n+f4 (double x[][100], int step, int limit)\n+{\n+  for (int i = 0; i < limit; i += step)\n+    for (int j = 0; j < 100; ++j)\n+      x[j][i] = 100;\n+}\n+\n+double x[100][100];\n+\n+void\n+g1 (int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j * step][i] = 100;\n+}\n+\n+void\n+g2 (int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j][i * step] = 100;\n+}\n+\n+void\n+g3 (int step, int limit)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    for (int j = 0; j < limit; j += step)\n+      x[j][i] = 100;\n+}\n+\n+void\n+g4 (int step, int limit)\n+{\n+  for (int i = 0; i < limit; i += step)\n+    for (int j = 0; j < 100; ++j)\n+      x[j][i] = 100;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {want to version} \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "6565122cb1e98d1d6b97ee33f8084537dc2a6fe0", "filename": "gcc/testsuite/gcc.dg/loop-versioning-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-3.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Versioning these loops for when both steps are 1 allows loop\n+   interchange, but otherwise isn't worthwhile.  At the moment we decide\n+   not to version.  */\n+\n+void\n+f1 (double x[][100], int step1, int step2, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j * step1][i * step2] = 100;\n+}\n+\n+void\n+f2 (double x[][100], int step1, int step2, int limit)\n+{\n+  for (int i = 0; i < limit; i += step1)\n+    for (int j = 0; j < limit; j += step2)\n+      x[j][i] = 100;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {want to version} \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "0ebb2b0e86f395e44b9c354f71eaba5389d44aea", "filename": "gcc/testsuite/gcc.dg/loop-versioning-4.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-4.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* These shouldn't be versioned; it's extremely likely that the code\n+   is emulating two-dimensional arrays.  */\n+\n+void\n+f1 (double *x, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[i * step + j] = 100;\n+}\n+\n+void\n+f2 (double *x, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j * step + i] = 100;\n+}\n+\n+void\n+f3 (double *x, int *offsets, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[i * step + j + offsets[i]] = 100;\n+}\n+\n+void\n+f4 (double *x, int *offsets, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j * step + i + offsets[i]] = 100;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {want to version} \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "5d4cc2c30195069b3770abc1725a38c74f849063", "filename": "gcc/testsuite/gcc.dg/loop-versioning-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-5.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* There's no information about whether STEP1 or STEP2 is innermost,\n+   so we should assume the code is sensible and version for the inner\n+   evolution, i.e. when STEP2 is 1.  */\n+\n+void\n+f1 (double *x, int step1, int step2, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[i * step1 + j * step2] = 100;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {want to version containing loop for when step2} 1 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {want to version containing loop} 1 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {versioned this loop} 1 \"lversion\" } } */"}, {"sha": "e718c233502f4710c988a71ce31ebac45c1da195", "filename": "gcc/testsuite/gcc.dg/loop-versioning-6.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-6.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* The read from y in f1 will be hoisted to the outer loop.  In general\n+   it's not worth versioning outer loops when the inner loops don't also\n+   benefit.\n+\n+   This test is meant to be a slight counterexample, since versioning\n+   does lead to cheaper outer-loop vectorization.  However, the benefit\n+   isn't enough to justify the cost.  */\n+\n+void\n+f1 (double *restrict x, double *restrict y, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[i + j] = y[i * step];\n+}\n+\n+/* A similar example in which the read can't be hoisted, but could\n+   for example be handled by vectorizer alias checks.  */\n+\n+void\n+f2 (double *x, double *y, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[i + j] = y[i * step];\n+}\n+\n+/* { dg-final { scan-tree-dump-not {want to version} \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "ac0c2018795ca16865117e00c0fd410265cd98f6", "filename": "gcc/testsuite/gcc.dg/loop-versioning-7.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-7.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Check that versioning can handle arrays of structures.  */\n+\n+struct foo {\n+  int a, b, c;\n+};\n+\n+void\n+f1 (struct foo *x, int stepx, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      x[stepx * i].a = 1;\n+      x[stepx * i].b = 2;\n+      x[stepx * i].c = 3;\n+    }\n+}\n+\n+void\n+f2 (struct foo *x, int stepx, int limit)\n+{\n+  for (int i = 0; i < limit; i += stepx)\n+    {\n+      x[i].a = 1;\n+      x[i].b = 2;\n+      x[i].c = 3;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times {want to version containing loop} 2 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {versioned this loop} 2 \"lversion\" } } */"}, {"sha": "5645b13dc1afd2c9b4876a66d5680570df69d6f4", "filename": "gcc/testsuite/gcc.dg/loop-versioning-8.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-8.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Versioning for step == 1 in these loops would allow loop interchange,\n+   but otherwise isn't worthwhile.  At the moment we decide not to version.  */\n+\n+struct foo {\n+  int a[100];\n+};\n+\n+void\n+f1 (struct foo *x, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j * step].a[i] = 100;\n+}\n+\n+void\n+f2 (struct foo *x, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < n; ++j)\n+      x[j].a[i * step] = 100;\n+}\n+\n+void\n+f3 (struct foo *x, int step, int limit)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    for (int j = 0; j < limit; j += step)\n+      x[j].a[i] = 100;\n+}\n+\n+void\n+f4 (struct foo *x, int step, int limit)\n+{\n+  for (int i = 0; i < limit; i += step)\n+    for (int j = 0; j < 100; ++j)\n+      x[j].a[i] = 100;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {want to version} \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-not {versioned} \"lversion\" } } */"}, {"sha": "cfbcd821b227625cca2f55b9e905348241dbc241", "filename": "gcc/testsuite/gcc.dg/loop-versioning-9.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-versioning-9.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-options \"-O3 -fdump-tree-lversion-details\" } */\n+\n+/* Check that versioning can handle small groups of accesses.  */\n+\n+void\n+f1 (int *x, int *y, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[i] = y[i * step * 2] + y[i * step * 2 + 1];\n+}\n+\n+void\n+f2 (int *x, int *y, __INTPTR_TYPE__ step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[i] = y[i * step * 2] + y[i * step * 2 + 1];\n+}\n+\n+void\n+f3 (int *x, int *y, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[i] = y[i * step * 3] + y[i * step * 3 + 2];\n+}\n+\n+void\n+f4 (int *x, int *y, __INTPTR_TYPE__ step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[i] = y[i * step * 3] + y[i * step * 3 + 2];\n+}\n+\n+void\n+f5 (int *x, int *y, int step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[i] = y[i * step * 4] + y[i * step * 4 + 3];\n+}\n+\n+void\n+f6 (int *x, int *y, __INTPTR_TYPE__ step, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    x[i] = y[i * step * 4] + y[i * step * 4 + 3];\n+}\n+\n+/* { dg-final { scan-tree-dump-times {want to version containing loop} 6 \"lversion\" } } */\n+/* { dg-final { scan-tree-dump-times {versioned this loop} 6 \"lversion\" } } */"}, {"sha": "0344cc9862537e197a6b12685eb9136185ad41c1", "filename": "gcc/testsuite/gcc.dg/vect/slp-43.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-43.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1,5 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n-/* { dg-additional-options \"-O3\" } */\n+/* { dg-additional-options \"-O3 -fno-version-loops-for-strides\" } */\n \n #include <string.h>\n #include \"tree-vect.h\""}, {"sha": "d83472ca0954089bd09d0aedfa3b452a9a43c72d", "filename": "gcc/testsuite/gcc.dg/vect/slp-45.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-45.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1,5 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n-/* { dg-additional-options \"-O3\" } */\n+/* { dg-additional-options \"-O3 -fno-version-loops-for-strides\" } */\n \n #include <string.h>\n #include \"tree-vect.h\""}, {"sha": "e80f8920d00c72feeca0b36e8e97691a57c35852", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_1.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_1.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,28 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details\" }\n+\n+! The simplest IV case.\n+\n+subroutine f1(x)\n+  real :: x(:)\n+  x(:) = 100\n+end subroutine f1\n+\n+subroutine f2(x, n, step)\n+  integer :: n, step\n+  real :: x(n * step)\n+  do i = 1, n\n+     x(i * step) = 100\n+  end do\n+end subroutine f2\n+\n+subroutine f3(x, limit, step)\n+  integer :: limit, step\n+  real :: x(limit)\n+  do i = 1, limit, step\n+     x(i) = 100\n+  end do\n+end subroutine f3\n+\n+! { dg-final { scan-tree-dump-times {likely to be the innermost dimension} 1 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {want to version containing loop} 3 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {versioned this loop} 3 \"lversion\" } }"}, {"sha": "522ef912947ea789047e9ee71682aceb193e51e0", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_2.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_2.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,39 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details -fno-frontend-loop-interchange\" }\n+\n+! We could version the loop for when the first dimension has a stride\n+! of 1, but at present there's no real benefit.  The gimple loop\n+! interchange pass couldn't handle the versioned loop, and interchange\n+! is instead done by the frontend (but disabled by the options above).\n+\n+subroutine f1(x)\n+  real :: x(:, :)\n+  do i = lbound(x, 1), ubound(x, 1)\n+     do j = lbound(x, 2), ubound(x, 2)\n+        x(i, j) = 100\n+     end do\n+  end do\n+end subroutine f1\n+\n+subroutine f2(x, n, step)\n+  integer :: n, step\n+  real :: x(100, 100)\n+  do i = 1, n\n+     do j = 1, n\n+        x(i * step, j) = 100\n+     end do\n+  end do\n+end subroutine f2\n+\n+subroutine f3(x, n, step)\n+  integer :: n, step\n+  real :: x(n * step, n)\n+  do i = 1, n\n+     do j = 1, n\n+        x(i * step, j) = 100\n+     end do\n+  end do\n+end subroutine f3\n+\n+! { dg-final { scan-tree-dump-times {likely to be the innermost dimension} 1 \"lversion\" } }\n+! { dg-final { scan-tree-dump-not {want to version} \"lversion\" } }\n+! { dg-final { scan-tree-dump-not {versioned} \"lversion\" } }"}, {"sha": "040b30b51485137c9074f41febd4b5a042f7569b", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_3.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_3.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,30 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details -fno-frontend-loop-interchange\" }\n+\n+! Test a case in which the outer loop iterates over the inner dimension.\n+! The options above prevent the frontend from interchanging the loops.\n+\n+subroutine f1(x, limit, step, n)\n+  integer :: limit, step, n\n+  real :: x(limit, n)\n+  do i = 1, limit, step\n+     do j = 1, n\n+        x(i, j) = 100\n+     end do\n+  end do\n+end subroutine f1\n+\n+subroutine f2(x, n, limit, step)\n+  integer :: n, limit, step\n+  real :: x(limit, n)\n+  do i = 1, n\n+     do j = 1, limit, step\n+        x(j, i) = 100\n+     end do\n+  end do\n+end subroutine f2\n+\n+! FIXME: The frontend doesn't give us enough information to tell which loop\n+! is iterating over the innermost dimension, so we optimistically\n+! assume the inner one is.\n+! { dg-final { scan-tree-dump-not {want to version} \"lversion\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-not {versioned} \"lversion\" { xfail *-*-* } } }"}, {"sha": "2fc4d12c9d1fe66ca11aa01b527c9f72ad0574d4", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_4.f90", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_4.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,95 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details -fno-frontend-loop-interchange\" }\n+\n+! Test cases in which versioning is useful for a two-dimensional array.\n+\n+subroutine f1(x)\n+  real :: x(:, :)\n+  x(:, :) = 100\n+end subroutine f1\n+\n+subroutine f2(x)\n+  real :: x(:, :)\n+  do i = lbound(x, 1), ubound(x, 1)\n+     do j = lbound(x, 2), ubound(x, 2)\n+        x(j, i) = 100\n+     end do\n+  end do\n+end subroutine f2\n+\n+subroutine f3(x, n, step)\n+  integer :: n, step\n+  real :: x(100, 100)\n+  do i = 1, n\n+     do j = 1, n\n+        x(j * step, i) = 100\n+     end do\n+  end do\n+end subroutine f3\n+\n+subroutine f4(x, n, step)\n+  integer :: n, step\n+  real :: x(n * step, n)\n+  do i = 1, n\n+     do j = 1, n\n+        x(j * step, i) = 100\n+     end do\n+  end do\n+end subroutine f4\n+\n+subroutine f5(x, n, limit, step)\n+  integer :: n, limit, step\n+  real :: x(limit, n)\n+  do i = 1, n\n+     do j = 1, limit, step\n+        x(j, i) = 100\n+     end do\n+  end do\n+end subroutine f5\n+\n+subroutine f6(x, y)\n+  real :: x(:, :), y(:)\n+  do i = lbound(x, 1), ubound(x, 1)\n+     do j = lbound(x, 2), ubound(x, 2)\n+        x(j, i) = 100\n+     end do\n+     y(i) = 200\n+  end do\n+end subroutine f6\n+\n+subroutine f7(x, y, n, step)\n+  integer :: n, step\n+  real :: x(100, 100), y(100)\n+  do i = 1, n\n+     do j = 1, n\n+        x(j * step, i) = 100\n+     end do\n+     y(i * step) = 200\n+  end do\n+end subroutine f7\n+\n+subroutine f8(x, y, n, step)\n+  integer :: n, step\n+  real :: x(n * step, n), y(n * step)\n+  do i = 1, n\n+     do j = 1, n\n+        x(j * step, i) = 100\n+     end do\n+     y(i * step) = 200\n+  end do\n+end subroutine f8\n+\n+subroutine f9(x, n, limit, step)\n+  integer :: n, limit, step\n+  real :: x(limit, n), y(limit)\n+  do i = 1, n\n+     do j = 1, limit, step\n+        x(j, i) = 100\n+     end do\n+     y(i) = 200\n+  end do\n+end subroutine f9\n+\n+! { dg-final { scan-tree-dump-times {likely to be the innermost dimension} 3 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {want to version containing loop} 9 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {hoisting check} 9 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {versioned this loop} 9 \"lversion\" } }"}, {"sha": "b08c71633821589da4cdf432546d9ca8ac79c171", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_5.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_5.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,57 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details -fno-frontend-loop-interchange\" }\n+\n+! Make sure that in a \"badly nested\" loop, we don't treat the inner loop\n+! as iterating over the inner dimension with a variable stride.\n+\n+subroutine f1(x, n)\n+  integer :: n\n+  real :: x(100, 100)\n+  do i = 1, n\n+     do j = 1, n\n+        x(i, j) = 100\n+     end do\n+  end do\n+end subroutine f1\n+\n+subroutine f2(x, n, step)\n+  integer :: n, step\n+  real :: x(100, 100)\n+  do i = 1, n\n+     do j = 1, n\n+        x(i, j * step) = 100\n+     end do\n+  end do\n+end subroutine f2\n+\n+subroutine f3(x, n)\n+  integer :: n\n+  real :: x(n, n)\n+  do i = 1, n\n+     do j = 1, n\n+        x(i, j) = 100\n+     end do\n+  end do\n+end subroutine f3\n+\n+subroutine f4(x, n, step)\n+  integer :: n, step\n+  real :: x(n, n * step)\n+  do i = 1, n\n+     do j = 1, n\n+        x(i, j * step) = 100\n+     end do\n+  end do\n+end subroutine f4\n+\n+subroutine f5(x, n, limit, step)\n+  integer :: n, limit, step\n+  real :: x(n, limit)\n+  do i = 1, n\n+     do j = 1, limit, step\n+        x(i, j) = 100\n+     end do\n+  end do\n+end subroutine f5\n+\n+! { dg-final { scan-tree-dump-not {want to version} \"lversion\" } }\n+! { dg-final { scan-tree-dump-not {versioned} \"lversion\" } }"}, {"sha": "450a79c1fdfc4da379518c9d6718ecc62bc22272", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_6.f90", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_6.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,93 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details\" }\n+\n+! Check that versioning can handle small groups of accesses.\n+\n+subroutine f1(x)\n+  real :: x(:)\n+  do i = lbound(x, 1), ubound(x, 1) / 2\n+     x(i * 2) = 100\n+     x(i * 2 + 1) = 101\n+  end do\n+end subroutine f1\n+\n+subroutine f2(x, n, step)\n+  integer :: n, step\n+  real :: x(n * step * 2)\n+  do i = 1, n\n+     x(i * step * 2) = 100\n+     x(i * step * 2 + 1) = 101\n+  end do\n+end subroutine f2\n+\n+subroutine f3(x, limit, step)\n+  integer :: limit, step\n+  real :: x(limit * 2)\n+  do i = 1, limit, step\n+     x(i * 2) = 100\n+     x(i * 2 + 1) = 101\n+  end do\n+end subroutine f3\n+\n+subroutine f4(x)\n+  real :: x(:)\n+  do i = lbound(x, 1), ubound(x, 1) / 3\n+     x(i * 3) = 100\n+     x(i * 3 + 1) = 101\n+     x(i * 3 + 2) = 102\n+  end do\n+end subroutine f4\n+\n+subroutine f5(x, n, step)\n+  integer :: n, step\n+  real :: x(n * step * 3)\n+  do i = 1, n\n+     x(i * step * 3) = 100\n+     x(i * step * 3 + 1) = 101\n+     x(i * step * 3 + 2) = 102\n+  end do\n+end subroutine f5\n+\n+subroutine f6(x, limit, step)\n+  integer :: limit, step\n+  real :: x(limit * 3)\n+  do i = 1, limit, step\n+     x(i * 3) = 100\n+     x(i * 3 + 1) = 101\n+     x(i * 3 + 2) = 102\n+  end do\n+end subroutine f6\n+\n+subroutine f7(x)\n+  real :: x(:)\n+  do i = lbound(x, 1), ubound(x, 1) / 4\n+     x(i * 4) = 100\n+     x(i * 4 + 1) = 101\n+     x(i * 4 + 2) = 102\n+     x(i * 4 + 3) = 103\n+  end do\n+end subroutine f7\n+\n+subroutine f8(x, n, step)\n+  integer :: n, step\n+  real :: x(n * step * 4)\n+  do i = 1, n\n+     x(i * step * 4) = 100\n+     x(i * step * 4 + 1) = 101\n+     x(i * step * 4 + 2) = 102\n+     x(i * step * 4 + 3) = 103\n+  end do\n+end subroutine f8\n+\n+subroutine f9(x, limit, step)\n+  integer :: limit, step\n+  real :: x(limit * 4)\n+  do i = 1, limit, step\n+     x(i * 4) = 100\n+     x(i * 4 + 1) = 101\n+     x(i * 4 + 2) = 102\n+     x(i * 4 + 3) = 103\n+  end do\n+end subroutine f9\n+\n+! { dg-final { scan-tree-dump-times {want to version containing loop} 9 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {versioned this loop} 9 \"lversion\" } }"}, {"sha": "ba827ac3184957231828b9411bf0d2e1b53b94eb", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_7.f90", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_7.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,67 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details\" }\n+\n+! Check that versioning can handle small groups of accesses, with the\n+! group being a separate array dimension.\n+\n+subroutine f1(x, n, step)\n+  integer :: n, step\n+  real :: x(2, n * step)\n+  do i = 1, n\n+     x(1, i * step) = 100\n+     x(2, i * step) = 101\n+  end do\n+end subroutine f1\n+\n+subroutine f2(x, limit, step)\n+  integer :: limit, step\n+  real :: x(2, limit)\n+  do i = 1, limit, step\n+     x(1, i) = 100\n+     x(2, i) = 101\n+  end do\n+end subroutine f2\n+\n+subroutine f3(x, n, step)\n+  integer :: n, step\n+  real :: x(3, n * step)\n+  do i = 1, n\n+     x(1, i * step) = 100\n+     x(2, i * step) = 101\n+     x(3, i * step) = 102\n+  end do\n+end subroutine f3\n+\n+subroutine f4(x, limit, step)\n+  integer :: limit, step\n+  real :: x(3, limit)\n+  do i = 1, limit, step\n+     x(1, i) = 100\n+     x(2, i) = 101\n+     x(3, i) = 102\n+  end do\n+end subroutine f4\n+\n+subroutine f5(x, n, step)\n+  integer :: n, step\n+  real :: x(4, n * step)\n+  do i = 1, n\n+     x(1, i * step) = 100\n+     x(2, i * step) = 101\n+     x(3, i * step) = 102\n+     x(4, i * step) = 103\n+  end do\n+end subroutine f5\n+\n+subroutine f6(x, limit, step)\n+  integer :: limit, step\n+  real :: x(4, limit)\n+  do i = 1, limit, step\n+     x(1, i) = 100\n+     x(2, i) = 101\n+     x(3, i) = 102\n+     x(4, i) = 103\n+  end do\n+end subroutine f6\n+\n+! { dg-final { scan-tree-dump-times {want to version containing loop} 6 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {versioned this loop} 6 \"lversion\" } }"}, {"sha": "193479935f4376ed1334758578b790c53bd87fc4", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_8.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_8.f90?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -0,0 +1,13 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details\" }\n+\n+! Check that versioning is applied to a gather-like reduction operation.\n+\n+function f(x, index, n)\n+  integer :: n\n+  real :: x(:)\n+  integer :: index(n)\n+  f = sum(x(index(:)))\n+end function f\n+\n+! { dg-final { scan-tree-dump-times {want to version containing loop} 1 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {versioned this loop} 1 \"lversion\" } }"}, {"sha": "033b48040bb07307fb77db593105da00dfa12082", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -234,6 +234,7 @@ DEFTIMEVAR (TV_DSE1                  , \"dead store elim1\")\n DEFTIMEVAR (TV_DSE2                  , \"dead store elim2\")\n DEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\n DEFTIMEVAR (TV_LOOP_INIT\t     , \"loop init\")\n+DEFTIMEVAR (TV_LOOP_VERSIONING\t     , \"loop versioning\")\n DEFTIMEVAR (TV_LOOP_MOVE_INVARIANTS  , \"loop invariant motion\")\n DEFTIMEVAR (TV_LOOP_UNROLL           , \"loop unrolling\")\n DEFTIMEVAR (TV_LOOP_DOLOOP           , \"loop doloop\")"}, {"sha": "9f9d85fdbc34ebec26eb4614880fe32098e4f501", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -362,6 +362,7 @@ extern gimple_opt_pass *make_pass_fix_loops (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_loop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_no_loop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_loop_init (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_loop_versioning (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lim (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_linterchange (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_unswitch (gcc::context *ctxt);"}, {"sha": "8225ebee49e72d0c5c211a2e9341ff50cb50b314", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1154,6 +1154,10 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \n \n /* Perform final substitution and folding of propagated values.\n+   Process the whole function if BLOCK is null, otherwise only\n+   process the blocks that BLOCK dominates.  In the latter case,\n+   it is the caller's responsibility to ensure that dominator\n+   information is available and up-to-date.\n \n    PROP_VALUE[I] contains the single value that should be substituted\n    at every use of SSA name N_I.  If PROP_VALUE is NULL, no values are\n@@ -1170,16 +1174,24 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n    Return TRUE when something changed.  */\n \n bool\n-substitute_and_fold_engine::substitute_and_fold (void)\n+substitute_and_fold_engine::substitute_and_fold (basic_block block)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nSubstituting values and folding statements\\n\\n\");\n \n   memset (&prop_stats, 0, sizeof (prop_stats));\n \n-  calculate_dominance_info (CDI_DOMINATORS);\n+  /* Don't call calculate_dominance_info when iterating over a subgraph.\n+     Callers that are using the interface this way are likely to want to\n+     iterate over several disjoint subgraphs, and it would be expensive\n+     in enable-checking builds to revalidate the whole dominance tree\n+     each time.  */\n+  if (block)\n+    gcc_assert (dom_info_state (CDI_DOMINATORS));\n+  else\n+    calculate_dominance_info (CDI_DOMINATORS);\n   substitute_and_fold_dom_walker walker (CDI_DOMINATORS, this);\n-  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  walker.walk (block ? block : ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   /* We cannot remove stmts during the BB walk, especially not release\n      SSA names there as that destroys the lattice of our callers."}, {"sha": "73512f65f28e21a73daec9d3d49560ecdd4468d9", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -104,7 +104,7 @@ class substitute_and_fold_engine\n   virtual bool fold_stmt (gimple_stmt_iterator *) { return false; }\n   virtual tree get_value (tree) { return NULL_TREE; }\n \n-  bool substitute_and_fold (void);\n+  bool substitute_and_fold (basic_block = NULL);\n   bool replace_uses_in (gimple *);\n   bool replace_phi_args_in (gphi *);\n };"}, {"sha": "d4470d2a6b3f643371a51727d2e4921bc9d38a62", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -1173,15 +1173,14 @@ value_inside_range (tree val, tree min, tree max)\n }\n \n \n-/* Return TRUE if *VR includes the value zero.  */\n+/* Return TRUE if *VR includes the value X.  */\n \n bool\n-range_includes_zero_p (const value_range_base *vr)\n+range_includes_p (const value_range_base *vr, HOST_WIDE_INT x)\n {\n   if (vr->varying_p () || vr->undefined_p ())\n     return true;\n-  tree zero = build_int_cst (vr->type (), 0);\n-  return vr->may_contain_p (zero);\n+  return vr->may_contain_p (build_int_cst (vr->type (), x));\n }\n \n /* If *VR has a value range that is a single constant value return that,"}, {"sha": "aaf024423e6c25c270d0bd09a85a98e9f30f29a5", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e08dc93941675cd6a7cf5470b437c4f640c996/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=13e08dc93941675cd6a7cf5470b437c4f640c996", "patch": "@@ -243,7 +243,7 @@ struct assert_info\n extern void register_edge_assert_for (tree, edge, enum tree_code,\n \t\t\t\t      tree, tree, vec<assert_info> &);\n extern bool stmt_interesting_for_vrp (gimple *);\n-extern bool range_includes_zero_p (const value_range_base *);\n+extern bool range_includes_p (const value_range_base *, HOST_WIDE_INT);\n extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n \n extern bool vrp_bitmap_equal_p (const_bitmap, const_bitmap);\n@@ -285,4 +285,12 @@ extern tree get_single_symbol (tree, bool *, tree *);\n extern void maybe_set_nonzero_bits (edge, tree);\n extern value_range_kind determine_value_range (tree, wide_int *, wide_int *);\n \n+/* Return TRUE if *VR includes the value zero.  */\n+\n+inline bool\n+range_includes_zero_p (const value_range_base *vr)\n+{\n+  return range_includes_p (vr, 0);\n+}\n+\n #endif /* GCC_TREE_VRP_H */"}]}