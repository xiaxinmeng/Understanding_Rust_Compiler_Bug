{"sha": "0dc434615966c14944fb1e22dfc645091b98e557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjNDM0NjE1OTY2YzE0OTQ0ZmIxZTIyZGZjNjQ1MDkxYjk4ZTU1Nw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jblomqvi@cc.hut.fi", "date": "2005-10-07T20:02:28Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-10-07T20:02:28Z"}, "message": "re PR libfortran/16339 (Unformatted i/o on large arrays inefficient)\n\n2005-10-07  Janne Blomqvist <jblomqvi@cc.hut.fi>\n\n\tPR fortran/16339\n\tPR fortran/23363\n\t* io/io.h: Add read and write members to stream, define access\n\tmacros.\n\t* io/transfer.c (read_block_direct): New function.\n\t(write_block_direct): New function.\n\t(unformatted_read): Change to use read_block_direct.\n\t(unformatted_write): Change to use write_block_direct.\n\t* io/unix.c: Remove mmap includes and defines.\n\t(writen): Remove.\n\t(readn): Remove.\n\t(reset_stream): New function.\n\t(do_read): New function.\n\t(do_write): New function.\n\t(fd_flush): Change to use do_write() instead of writen().\n\t(fd_alloc_r_at): Change to use do_read().\n\t(fd_seek): Change return type to try, as the prototype. Add check\n\tto avoid syscall overhead if possible.\n\t(fd_read): New function.\n\t(fd_write): New function.\n\t(fd_open): Set pointers for new functions.\n\t(mem_read): New function.\n\t(mem_write): New function.\n\t(open_internal): Set pointers for new functions.\n\t(is_seekable): Clean up comment.\n\nFrom-SVN: r105101", "tree": {"sha": "644a90d57f7546595ef3507a66c957fd39ef1765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/644a90d57f7546595ef3507a66c957fd39ef1765"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dc434615966c14944fb1e22dfc645091b98e557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc434615966c14944fb1e22dfc645091b98e557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc434615966c14944fb1e22dfc645091b98e557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc434615966c14944fb1e22dfc645091b98e557/comments", "author": null, "committer": null, "parents": [{"sha": "b6fb7d460cc513f9564a1ba5aeaa431f32e7858f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fb7d460cc513f9564a1ba5aeaa431f32e7858f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6fb7d460cc513f9564a1ba5aeaa431f32e7858f"}], "stats": {"total": 444, "additions": 373, "deletions": 71}, "files": [{"sha": "d5df1d33a4416223320cd8bc9bc3102cfd91b825", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0dc434615966c14944fb1e22dfc645091b98e557", "patch": "@@ -1,3 +1,31 @@\n+2005-10-07  Janne Blomqvist <jblomqvi@cc.hut.fi>\n+\n+\tPR fortran/16339\n+\tPR fortran/23363\n+\t* io/io.h: Add read and write members to stream, define access\n+\tmacros.\n+\t* io/transfer.c (read_block_direct): New function.\n+\t(write_block_direct): New function.\n+\t(unformatted_read): Change to use read_block_direct.\n+\t(unformatted_write): Change to use write_block_direct.\n+\t* io/unix.c: Remove mmap includes and defines.\n+\t(writen): Remove.\n+\t(readn): Remove.\n+\t(reset_stream): New function.\n+\t(do_read): New function.\n+\t(do_write): New function.\n+\t(fd_flush): Change to use do_write() instead of writen().\n+\t(fd_alloc_r_at): Change to use do_read().\n+\t(fd_seek): Change return type to try, as the prototype. Add check\n+\tto avoid syscall overhead if possible.\n+\t(fd_read): New function.\n+\t(fd_write): New function.\n+\t(fd_open): Set pointers for new functions.\n+\t(mem_read): New function.\n+\t(mem_write): New function.\n+\t(open_internal): Set pointers for new functions.\n+\t(is_seekable): Clean up comment.\n+\n 2005-10-07  Jerry DeLisle  <jvdelisle@verizon.net>\n \n         * io/transfer.c (write_block): Add test for end-of-file condition,"}, {"sha": "3cb98f42ede6428ba40a76788c441b3787ffebd1", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=0dc434615966c14944fb1e22dfc645091b98e557", "patch": "@@ -56,6 +56,8 @@ typedef struct stream\n   try (*close) (struct stream *);\n   try (*seek) (struct stream *, gfc_offset);\n   try (*truncate) (struct stream *);\n+  int (*read) (struct stream *, void *, size_t *);\n+  int (*write) (struct stream *, const void *, size_t *);\n }\n stream;\n \n@@ -73,6 +75,8 @@ stream;\n \n #define sseek(s, pos) ((s)->seek)(s, pos)\n #define struncate(s) ((s)->truncate)(s)\n+#define sread(s, buf, nbytes) ((s)->read)(s, buf, nbytes)\n+#define swrite(s, buf, nbytes) ((s)->write)(s, buf, nbytes)\n \n /* Representation of a namelist object in libgfortran\n "}, {"sha": "1d1b78b374064f7f1be64315a687271cf2cfd276", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=0dc434615966c14944fb1e22dfc645091b98e557", "patch": "@@ -286,6 +286,60 @@ read_block (int *length)\n }\n \n \n+/* Reads a block directly into application data space.  */\n+\n+static void\n+read_block_direct (void * buf, size_t * nbytes)\n+{\n+  int *length;\n+  void *data;\n+  size_t nread;\n+\n+  if (current_unit->flags.form == FORM_FORMATTED &&\n+      current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    {\n+      length = (int*) nbytes;\n+      data = read_sf (length);\t/* Special case.  */\n+      memcpy (buf, data, (size_t) *length);\n+      return;\n+    }\n+\n+  if (current_unit->bytes_left < *nbytes)\n+    {\n+      if (current_unit->flags.pad == PAD_NO)\n+\t{\n+\t  generate_error (ERROR_EOR, NULL); /* Not enough data left.  */\n+\t  return;\n+\t}\n+\n+      *nbytes = current_unit->bytes_left;\n+    }\n+\n+  current_unit->bytes_left -= *nbytes;\n+\n+  nread = *nbytes;\n+  if (sread (current_unit->s, buf, &nread) != 0)\n+    {\n+      generate_error (ERROR_OS, NULL);\n+      return;\n+    }\n+\n+  if (ioparm.size != NULL)\n+    *ioparm.size += (GFC_INTEGER_4) nread;\n+\n+  if (nread != *nbytes)\n+    {\t\t\t\t/* Short read, e.g. if we hit EOF.  */\n+      if (current_unit->flags.pad == PAD_YES)\n+\t{\n+\t  memset (((char *) buf) + nread, ' ', *nbytes - nread);\n+\t  *nbytes = nread;\n+\t}\n+      else\n+\tgenerate_error (ERROR_EOR, NULL);\n+    }\n+}\n+\n+\n /* Function for writing a block of bytes to the current file at the\n    current position, advancing the file pointer. We are given a length\n    and return a pointer to a buffer that the caller must (completely)\n@@ -318,39 +372,49 @@ write_block (int length)\n }\n \n \n+/* Writes a block directly without necessarily allocating space in a\n+   buffer.  */\n+\n+static void\n+write_block_direct (void * buf, size_t * nbytes)\n+{\n+  if (current_unit->bytes_left < *nbytes)\n+    generate_error (ERROR_EOR, NULL);\n+\n+  current_unit->bytes_left -= (gfc_offset) *nbytes;\n+\n+  if (swrite (current_unit->s, buf, nbytes) != 0)\n+    generate_error (ERROR_OS, NULL);\n+\n+  if (ioparm.size != NULL)\n+    *ioparm.size += (GFC_INTEGER_4) *nbytes;\n+}\n+\n+\n /* Master function for unformatted reads.  */\n \n static void\n unformatted_read (bt type, void *dest, int length, size_t nelems)\n {\n-  void *source;\n-  int w;\n+  size_t len;\n \n-  length *= nelems;\n+  len = length * nelems;\n \n   /* Transfer functions get passed the kind of the entity, so we have\n      to fix this for COMPLEX data which are twice the size of their\n      kind.  */\n   if (type == BT_COMPLEX)\n-    length *= 2;\n-\n-  w = length;\n-  source = read_block (&w);\n+    len *= 2;\n \n-  if (source != NULL)\n-    {\n-      memcpy (dest, source, w);\n-      if (length != w)\n-\tmemset (((char *) dest) + w, ' ', length - w);\n-    }\n+  read_block_direct (dest, &len);\n }\n \n+\n /* Master function for unformatted writes.  */\n \n static void\n unformatted_write (bt type, void *source, int length, size_t nelems)\n {\n-  void *dest;\n   size_t len;\n \n   len = length * nelems;\n@@ -359,9 +423,7 @@ unformatted_write (bt type, void *source, int length, size_t nelems)\n   if (type == BT_COMPLEX)\n     len *= 2;\n \n-  dest = write_block (len);\n-  if (dest != NULL)\n-    memcpy (dest, source, len);\n+  write_block_direct (source, &len);\n }\n \n "}, {"sha": "6fe861c573cfec867192a243d9156ae3f07fcf2c", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 262, "deletions": 54, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc434615966c14944fb1e22dfc645091b98e557/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=0dc434615966c14944fb1e22dfc645091b98e557", "patch": "@@ -40,9 +40,6 @@ Boston, MA 02110-1301, USA.  */\n #include <fcntl.h>\n #include <assert.h>\n \n-#ifdef HAVE_SYS_MMAN_H\n-#include <sys/mman.h>\n-#endif\n #include <string.h>\n #include <errno.h>\n \n@@ -53,10 +50,6 @@ Boston, MA 02110-1301, USA.  */\n #define PATH_MAX 1024\n #endif\n \n-#ifndef MAP_FAILED\n-#define MAP_FAILED ((void *) -1)\n-#endif\n-\n #ifndef PROT_READ\n #define PROT_READ 1\n #endif\n@@ -231,58 +224,104 @@ is_preconnected (stream * s)\n     return 0;\n }\n \n-/* write()-- Write a buffer to a descriptor, allowing for short writes */\n \n-static int\n-writen (int fd, char *buffer, int len)\n+/* Reset a stream after reading/writing. Assumes that the buffers have\n+   been flushed.  */\n+\n+inline static void\n+reset_stream (unix_stream * s, size_t bytes_rw)\n {\n-  int n, n0;\n+  s->physical_offset += bytes_rw;\n+  s->logical_offset = s->physical_offset;\n+  if (s->file_length != -1 && s->physical_offset > s->file_length)\n+    s->file_length = s->physical_offset;\n+}\n \n-  n0 = len;\n \n-  while (len > 0)\n-    {\n-      n = write (fd, buffer, len);\n-      if (n < 0)\n-\treturn n;\n+/* Read bytes into a buffer, allowing for short reads.  If the nbytes\n+ * argument is less on return than on entry, it is because we've hit\n+ * the end of file. */\n \n-      buffer += n;\n-      len -= n;\n+static int\n+do_read (unix_stream * s, void * buf, size_t * nbytes)\n+{\n+  ssize_t trans;\n+  size_t bytes_left;\n+  char *buf_st;\n+  int status;\n+\n+  status = 0;\n+  bytes_left = *nbytes;\n+  buf_st = (char *) buf;\n+\n+  /* We must read in a loop since some systems don't restart system\n+     calls in case of a signal.  */\n+  while (bytes_left > 0)\n+    {\n+      /* Requests between SSIZE_MAX and SIZE_MAX are undefined by SUSv3,\n+\t so we must read in chunks smaller than SSIZE_MAX.  */\n+      trans = (bytes_left < SSIZE_MAX) ? bytes_left : SSIZE_MAX;\n+      trans = read (s->fd, buf_st, trans);\n+      if (trans < 0)\n+\t{\n+\t  if (errno == EINTR)\n+\t    continue;\n+\t  else\n+\t    {\n+\t      status = errno;\n+\t      break;\n+\t    }\n+\t}\n+      else if (trans == 0) /* We hit EOF.  */\n+\tbreak;\n+      buf_st += trans;\n+      bytes_left -= trans;\n     }\n \n-  return n0;\n+  *nbytes -= bytes_left;\n+  return status;\n }\n \n \n-#if 0\n-/* readn()-- Read bytes into a buffer, allowing for short reads.  If\n- * fewer than len bytes are returned, it is because we've hit the end\n- * of file. */\n+/* Write a buffer to a stream, allowing for short writes.  */\n \n static int\n-readn (int fd, char *buffer, int len)\n+do_write (unix_stream * s, const void * buf, size_t * nbytes)\n {\n-  int nread, n;\n-\n-  nread = 0;\n-\n-  while (len > 0)\n+  ssize_t trans;\n+  size_t bytes_left;\n+  char *buf_st;\n+  int status;\n+\n+  status = 0;\n+  bytes_left = *nbytes;\n+  buf_st = (char *) buf;\n+\n+  /* We must write in a loop since some systems don't restart system\n+     calls in case of a signal.  */\n+  while (bytes_left > 0)\n     {\n-      n = read (fd, buffer, len);\n-      if (n < 0)\n-\treturn n;\n-\n-      if (n == 0)\n-\treturn nread;\n-\n-      buffer += n;\n-      nread += n;\n-      len -= n;\n+      /* Requests between SSIZE_MAX and SIZE_MAX are undefined by SUSv3,\n+\t so we must write in chunks smaller than SSIZE_MAX.  */\n+      trans = (bytes_left < SSIZE_MAX) ? bytes_left : SSIZE_MAX;\n+      trans = write (s->fd, buf_st, trans);\n+      if (trans < 0)\n+\t{\n+\t  if (errno == EINTR)\n+\t    continue;\n+\t  else\n+\t    {\n+\t      status = errno;\n+\t      break;\n+\t    }\n+\t}\n+      buf_st += trans;\n+      bytes_left -= trans;\n     }\n \n-  return nread;\n+  *nbytes -= bytes_left;\n+  return status;\n }\n-#endif\n \n \n /* get_oserror()-- Get the most recent operating system error.  For\n@@ -308,28 +347,35 @@ sys_exit (int code)\n     File descriptor stream functions\n *********************************************************************/\n \n+\n /* fd_flush()-- Write bytes that need to be written */\n \n static try\n fd_flush (unix_stream * s)\n {\n+  size_t writelen;\n+\n   if (s->ndirty == 0)\n     return SUCCESS;;\n \n   if (s->physical_offset != s->dirty_offset &&\n       lseek (s->fd, s->dirty_offset, SEEK_SET) < 0)\n     return FAILURE;\n \n-  if (writen (s->fd, s->buffer + (s->dirty_offset - s->buffer_offset),\n-\t      s->ndirty) < 0)\n+  writelen = s->ndirty;\n+  if (do_write (s, s->buffer + (s->dirty_offset - s->buffer_offset),\n+\t\t&writelen) != 0)\n     return FAILURE;\n \n-  s->physical_offset = s->dirty_offset + s->ndirty;\n+  s->physical_offset = s->dirty_offset + writelen;\n \n   /* don't increment file_length if the file is non-seekable */\n   if (s->file_length != -1 && s->physical_offset > s->file_length)\n-    s->file_length = s->physical_offset;\n-  s->ndirty = 0;\n+      s->file_length = s->physical_offset; \n+\n+  s->ndirty -= writelen;\n+  if (s->ndirty != 0)\n+    return FAILURE;\n \n   return SUCCESS;\n }\n@@ -394,7 +440,7 @@ static char *\n fd_alloc_r_at (unix_stream * s, int *len, gfc_offset where)\n {\n   gfc_offset m;\n-  int n;\n+  size_t n;\n \n   if (where == -1)\n     where = s->logical_offset;\n@@ -416,8 +462,8 @@ fd_alloc_r_at (unix_stream * s, int *len, gfc_offset where)\n   if (s->physical_offset != m && lseek (s->fd, m, SEEK_SET) < 0)\n     return NULL;\n \n-  n = read (s->fd, s->buffer + s->active, s->len - s->active);\n-  if (n < 0)\n+  n = s->len - s->active;\n+  if (do_read (s, s->buffer + s->active, &n) != 0)\n     return NULL;\n \n   s->physical_offset = where + n;\n@@ -502,9 +548,15 @@ fd_sfree (unix_stream * s)\n }\n \n \n-static int\n+static try\n fd_seek (unix_stream * s, gfc_offset offset)\n {\n+  if (s->physical_offset == offset) /* Are we lucky and avoid syscall?  */\n+    {\n+      s->logical_offset = offset;\n+      return SUCCESS;\n+    }\n+\n   s->physical_offset = s->logical_offset = offset;\n \n   return (lseek (s->fd, offset, SEEK_SET) < 0) ? FAILURE : SUCCESS;\n@@ -543,6 +595,104 @@ fd_truncate (unix_stream * s)\n }\n \n \n+\n+\n+/* Stream read function. Avoids using a buffer for big reads. The\n+   interface is like POSIX read(), but the nbytes argument is a\n+   pointer; on return it contains the number of bytes written. The\n+   function return value is the status indicator (0 for success).  */\n+\n+static int\n+fd_read (unix_stream * s, void * buf, size_t * nbytes)\n+{\n+  void *p;\n+  int tmp, status;\n+\n+  if (*nbytes < BUFFER_SIZE && !s->unbuffered)\n+    {\n+      tmp = *nbytes;\n+      p = fd_alloc_r_at (s, &tmp, -1);\n+      if (p)\n+\t{\n+\t  *nbytes = tmp;\n+\t  memcpy (buf, p, *nbytes);\n+\t  return 0;\n+\t}\n+      else\n+\t{\n+\t  *nbytes = 0;\n+\t  return errno;\n+\t}\n+    }\n+\n+  /* If the request is bigger than BUFFER_SIZE we flush the buffers\n+     and read directly.  */\n+  if (fd_flush (s) == FAILURE)\n+    {\n+      *nbytes = 0;\n+      return errno;\n+    }\n+\n+  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n+    {\n+      *nbytes = 0;\n+      return errno;\n+    }\n+\n+  status = do_read (s, buf, nbytes);\n+  reset_stream (s, *nbytes);\n+  return status;\n+}\n+\n+\n+/* Stream write function. Avoids using a buffer for big writes. The\n+   interface is like POSIX write(), but the nbytes argument is a\n+   pointer; on return it contains the number of bytes written. The\n+   function return value is the status indicator (0 for success).  */\n+\n+static int\n+fd_write (unix_stream * s, const void * buf, size_t * nbytes)\n+{\n+  void *p;\n+  int tmp, status;\n+\n+  if (*nbytes < BUFFER_SIZE && !s->unbuffered)\n+    {\n+      tmp = *nbytes;\n+      p = fd_alloc_w_at (s, &tmp, -1);\n+      if (p)\n+\t{\n+\t  *nbytes = tmp;\n+\t  memcpy (p, buf, *nbytes);\n+\t  return 0;\n+\t}\n+      else\n+\t{\n+\t  *nbytes = 0;\n+\t  return errno;\n+\t}\n+    }\n+\n+  /* If the request is bigger than BUFFER_SIZE we flush the buffers\n+     and write directly.  */\n+  if (fd_flush (s) == FAILURE)\n+    {\n+      *nbytes = 0;\n+      return errno;\n+    }\n+\n+  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n+    {\n+      *nbytes = 0;\n+      return errno;\n+    }\n+\n+  status =  do_write (s, buf, nbytes);\n+  reset_stream (s, *nbytes);\n+  return status;\n+}\n+\n+\n static try\n fd_close (unix_stream * s)\n {\n@@ -576,12 +726,15 @@ fd_open (unix_stream * s)\n   s->st.close = (void *) fd_close;\n   s->st.seek = (void *) fd_seek;\n   s->st.truncate = (void *) fd_truncate;\n+  s->st.read = (void *) fd_read;\n+  s->st.write = (void *) fd_write;\n \n   s->buffer = NULL;\n }\n \n \n \n+\n /*********************************************************************\n   memory stream functions - These are used for internal files\n \n@@ -638,6 +791,60 @@ mem_alloc_w_at (unix_stream * s, int *len, gfc_offset where)\n }\n \n \n+/* Stream read function for internal units. This is not actually used\n+   at the moment, as all internal IO is formatted and the formatted IO\n+   routines use mem_alloc_r_at.  */\n+\n+static int\n+mem_read (unix_stream * s, void * buf, size_t * nbytes)\n+{\n+  void *p;\n+  int tmp;\n+\n+  tmp = *nbytes;\n+  p = mem_alloc_r_at (s, &tmp, -1);\n+  if (p)\n+    {\n+      *nbytes = tmp;\n+      memcpy (buf, p, *nbytes);\n+      return 0;\n+    }\n+  else\n+    {\n+      *nbytes = 0;\n+      return errno;\n+    }\n+}\n+\n+\n+/* Stream write function for internal units. This is not actually used\n+   at the moment, as all internal IO is formatted and the formatted IO\n+   routines use mem_alloc_w_at.  */\n+\n+static int\n+mem_write (unix_stream * s, const void * buf, size_t * nbytes)\n+{\n+  void *p;\n+  int tmp;\n+\n+  errno = 0;\n+\n+  tmp = *nbytes;\n+  p = mem_alloc_w_at (s, &tmp, -1);\n+  if (p)\n+    {\n+      *nbytes = tmp;\n+      memcpy (p, buf, *nbytes);\n+      return 0;\n+    }\n+  else\n+    {\n+      *nbytes = 0;\n+      return errno;\n+    }\n+}\n+\n+\n static int\n mem_seek (unix_stream * s, gfc_offset offset)\n {\n@@ -712,6 +919,8 @@ open_internal (char *base, int length)\n   s->st.close = (void *) mem_close;\n   s->st.seek = (void *) mem_seek;\n   s->st.truncate = (void *) mem_truncate;\n+  s->st.read = (void *) mem_read;\n+  s->st.write = (void *) mem_write;\n \n   return (stream *) s;\n }\n@@ -1350,9 +1559,8 @@ file_position (stream * s)\n int\n is_seekable (stream * s)\n {\n-  /* by convention, if file_length == -1, the file is not seekable\n-     note that a mmapped file is always seekable, an fd_ file may\n-     or may not be. */\n+  /* By convention, if file_length == -1, the file is not\n+     seekable.  */\n   return ((unix_stream *) s)->file_length!=-1;\n }\n "}]}