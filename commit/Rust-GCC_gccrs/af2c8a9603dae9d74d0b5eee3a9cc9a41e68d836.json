{"sha": "af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYyYzhhOTYwM2RhZTlkNzRkMGI1ZWVlM2E5Y2M5YTQxZTY4ZDgzNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-09-25T23:13:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-09-25T23:13:55Z"}, "message": "rs6000-protos.h (output_probe_stack_range): Update prototype for new argument.\n\n\t* config/rs6000/rs6000-protos.h (output_probe_stack_range): Update\n\tprototype for new argument.\n\t* config/rs6000/rs6000.c (rs6000_emit_allocate_stack_1): New function,\n\tmostly extracted from rs6000_emit_allocate_stack.\n\t(rs6000_emit_probe_stack_range_stack_clash): New function.\n\t(rs6000_emit_allocate_stack): Call\n\trs6000_emit_probe_stack_range_stack_clash as needed.\n\t(rs6000_emit_probe_stack_range): Add additional argument\n\tto call to gen_probe_stack_range{si,di}.\n\t(output_probe_stack_range): New.\n\t(output_probe_stack_range_1): Renamed from output_probe_stack_range.\n\t(output_probe_stack_range_stack_clash): New.\n\t(rs6000_emit_prologue): Emit notes into dump file as requested.\n\t* rs6000.md (allocate_stack): Handle -fstack-clash-protection.\n\t(probe_stack_range<P:mode>): Operand 0 is now early-clobbered.\n\tAdd additional operand and pass it to output_probe_stack_range.\n\n\t* lib/target-supports.exp\n\t(check_effective_target_supports_stack_clash_protection): Enable for\n\trs6000 and powerpc targets.\n\nFrom-SVN: r253179", "tree": {"sha": "09dac86157aa5206987a67e6861d1169ed81e416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09dac86157aa5206987a67e6861d1169ed81e416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/comments", "author": null, "committer": null, "parents": [{"sha": "d80d5c38f921543c375c9e8aeabec2e07dba8a9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80d5c38f921543c375c9e8aeabec2e07dba8a9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d80d5c38f921543c375c9e8aeabec2e07dba8a9f"}], "stats": {"total": 442, "additions": 400, "deletions": 42}, "files": [{"sha": "962689bd241c34bace767ade46627f61ba1305a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "patch": "@@ -1,3 +1,22 @@\n+2017-09-25  Jeff Law  <law@redhat.com>\n+\n+\t* config/rs6000/rs6000-protos.h (output_probe_stack_range): Update\n+\tprototype for new argument.\n+\t* config/rs6000/rs6000.c (rs6000_emit_allocate_stack_1): New function,\n+\tmostly extracted from rs6000_emit_allocate_stack.\n+\t(rs6000_emit_probe_stack_range_stack_clash): New function.\n+\t(rs6000_emit_allocate_stack): Call\n+\trs6000_emit_probe_stack_range_stack_clash as needed.\n+\t(rs6000_emit_probe_stack_range): Add additional argument\n+\tto call to gen_probe_stack_range{si,di}.\n+\t(output_probe_stack_range): New.\n+\t(output_probe_stack_range_1): Renamed from output_probe_stack_range.\n+\t(output_probe_stack_range_stack_clash): New.\n+\t(rs6000_emit_prologue): Emit notes into dump file as requested.\n+\t* rs6000.md (allocate_stack): Handle -fstack-clash-protection.\n+\t(probe_stack_range<P:mode>): Operand 0 is now early-clobbered.\n+\tAdd additional operand and pass it to output_probe_stack_range.\n+    \n 2017-09-25  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/82163"}, {"sha": "781349b850e358c6b4b7db819f7dddc3163196fd", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "patch": "@@ -128,7 +128,7 @@ extern void rs6000_emit_sISEL (machine_mode, rtx[]);\n extern void rs6000_emit_sCOND (machine_mode, rtx[]);\n extern void rs6000_emit_cbranch (machine_mode, rtx[]);\n extern char * output_cbranch (rtx, const char *, int, rtx_insn *);\n-extern const char * output_probe_stack_range (rtx, rtx);\n+extern const char * output_probe_stack_range (rtx, rtx, rtx);\n extern void rs6000_emit_dot_insn (rtx dst, rtx src, int dot, rtx ccreg);\n extern bool rs6000_emit_set_const (rtx, rtx);\n extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);"}, {"sha": "f64a091034a5f605015aea3f852d4c8fbd2348f3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 302, "deletions": 34, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "patch": "@@ -25528,6 +25528,221 @@ rs6000_emit_stack_tie (rtx fp, bool hard_frame_needed)\n   emit_insn (gen_stack_tie (gen_rtx_PARALLEL (VOIDmode, p)));\n }\n \n+/* Allocate SIZE_INT bytes on the stack using a store with update style insn\n+   and set the appropriate attributes for the generated insn.  Return the\n+   first insn which adjusts the stack pointer or the last insn before\n+   the stack adjustment loop. \n+\n+   SIZE_INT is used to create the CFI note for the allocation.\n+\n+   SIZE_RTX is an rtx containing the size of the adjustment.  Note that\n+   since stacks grow to lower addresses its runtime value is -SIZE_INT.\n+\n+   ORIG_SP contains the backchain value that must be stored at *sp.  */\n+\n+static rtx_insn *\n+rs6000_emit_allocate_stack_1 (HOST_WIDE_INT size_int, rtx orig_sp)\n+{\n+  rtx_insn *insn;\n+\n+  rtx size_rtx = GEN_INT (-size_int);\n+  if (size_int > 32767)\n+    {\n+      rtx tmp_reg = gen_rtx_REG (Pmode, 0);\n+      /* Need a note here so that try_split doesn't get confused.  */\n+      if (get_last_insn () == NULL_RTX)\n+\temit_note (NOTE_INSN_DELETED);\n+      insn = emit_move_insn (tmp_reg, size_rtx);\n+      try_split (PATTERN (insn), insn, 0);\n+      size_rtx = tmp_reg;\n+    }\n+  \n+  if (Pmode == SImode)\n+    insn = emit_insn (gen_movsi_update_stack (stack_pointer_rtx,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      size_rtx,\n+\t\t\t\t\t      orig_sp));\n+  else\n+    insn = emit_insn (gen_movdi_di_update_stack (stack_pointer_rtx,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t size_rtx,\n+\t\t\t\t\t\t orig_sp));\n+  rtx par = PATTERN (insn);\n+  gcc_assert (GET_CODE (par) == PARALLEL);\n+  rtx set = XVECEXP (par, 0, 0);\n+  gcc_assert (GET_CODE (set) == SET);\n+  rtx mem = SET_DEST (set);\n+  gcc_assert (MEM_P (mem));\n+  MEM_NOTRAP_P (mem) = 1;\n+  set_mem_alias_set (mem, get_frame_alias_set ());\n+\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (stack_pointer_rtx,\n+\t\t\t     gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (-size_int))));\n+\n+  /* Emit a blockage to ensure the allocation/probing insns are\n+     not optimized, combined, removed, etc.  Add REG_STACK_CHECK\n+     note for similar reasons.  */\n+  if (flag_stack_clash_protection)\n+    {\n+      add_reg_note (insn, REG_STACK_CHECK, const0_rtx);\n+      emit_insn (gen_blockage ());\n+    }\n+\n+  return insn;\n+}\n+\n+static HOST_WIDE_INT\n+get_stack_clash_protection_probe_interval (void)\n+{\n+  return (HOST_WIDE_INT_1U\n+\t  << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL));\n+}\n+\n+static HOST_WIDE_INT\n+get_stack_clash_protection_guard_size (void)\n+{\n+  return (HOST_WIDE_INT_1U\n+\t  << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE));\n+}\n+\n+/* Allocate ORIG_SIZE bytes on the stack and probe the newly\n+   allocated space every STACK_CLASH_PROTECTION_PROBE_INTERVAL bytes.\n+\n+   COPY_REG, if non-null, should contain a copy of the original\n+   stack pointer at exit from this function.\n+\n+   This is subtly different than the Ada probing in that it tries hard to\n+   prevent attacks that jump the stack guard.  Thus it is never allowed to\n+   allocate more than STACK_CLASH_PROTECTION_PROBE_INTERVAL bytes of stack\n+   space without a suitable probe.  */\n+static rtx_insn *\n+rs6000_emit_probe_stack_range_stack_clash (HOST_WIDE_INT orig_size,\n+\t\t\t\t\t   rtx copy_reg)\n+{\n+  rtx orig_sp = copy_reg;\n+\n+  HOST_WIDE_INT probe_interval = get_stack_clash_protection_probe_interval ();\n+\n+  /* Round the size down to a multiple of PROBE_INTERVAL.  */\n+  HOST_WIDE_INT rounded_size = ROUND_DOWN (orig_size, probe_interval);\n+\n+  /* If explicitly requested,\n+       or the rounded size is not the same as the original size\n+       or the the rounded size is greater than a page,\n+     then we will need a copy of the original stack pointer.  */\n+  if (rounded_size != orig_size\n+      || rounded_size > probe_interval\n+      || copy_reg)\n+    {\n+      /* If the caller did not request a copy of the incoming stack\n+\t pointer, then we use r0 to hold the copy.  */\n+      if (!copy_reg)\n+\torig_sp = gen_rtx_REG (Pmode, 0);\n+      emit_move_insn (orig_sp, stack_pointer_rtx);\n+    }\n+\n+  /* There's three cases here.\n+\n+     One is a single probe which is the most common and most efficiently\n+     implemented as it does not have to have a copy of the original\n+     stack pointer if there are no residuals.\n+\n+     Second is unrolled allocation/probes which we use if there's just\n+     a few of them.  It needs to save the original stack pointer into a\n+     temporary for use as a source register in the allocation/probe.\n+\n+     Last is a loop.  This is the most uncommon case and least efficient.  */\n+  rtx_insn *retval = NULL;\n+  if (rounded_size == probe_interval)\n+    {\n+      retval = rs6000_emit_allocate_stack_1 (probe_interval, stack_pointer_rtx);\n+\n+      dump_stack_clash_frame_info (PROBE_INLINE, rounded_size != orig_size);\n+    }\n+  else if (rounded_size <= 8 * probe_interval)\n+    {\n+      /* The ABI requires using the store with update insns to allocate\n+\t space and store the backchain into the stack\n+\n+\t So we save the current stack pointer into a temporary, then\n+\t emit the store-with-update insns to store the saved stack pointer\n+\t into the right location in each new page.  */\n+      for (int i = 0; i < rounded_size; i += probe_interval)\n+\t{\n+\t  rtx_insn *insn\n+\t    = rs6000_emit_allocate_stack_1 (probe_interval, orig_sp);\n+\n+\t  /* Save the first stack adjustment in RETVAL.  */\n+\t  if (i == 0)\n+\t    retval = insn;\n+\t}\n+\n+      dump_stack_clash_frame_info (PROBE_INLINE, rounded_size != orig_size);\n+    }\n+  else\n+    {\n+      /* Compute the ending address.  */\n+      rtx end_addr\n+\t= copy_reg ? gen_rtx_REG (Pmode, 0) : gen_rtx_REG (Pmode, 12);\n+      rtx rs = GEN_INT (-rounded_size);\n+      rtx_insn *insn;\n+      if (add_operand (rs, Pmode))\n+\tinsn = emit_insn (gen_add3_insn (end_addr, stack_pointer_rtx, rs));\n+      else\n+\t{\n+\t  emit_move_insn (end_addr, GEN_INT (-rounded_size));\n+\t  insn = emit_insn (gen_add3_insn (end_addr, end_addr,\n+\t\t\t\t\t   stack_pointer_rtx));\n+\t  /* Describe the effect of INSN to the CFI engine.  */\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_SET (end_addr,\n+\t\t\t\t     gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t   rs)));\n+\t}\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* Emit the loop.  */\n+      if (TARGET_64BIT)\n+\tretval = emit_insn (gen_probe_stack_rangedi (stack_pointer_rtx,\n+\t\t\t\t\t\t     stack_pointer_rtx, orig_sp,\n+\t\t\t\t\t\t     end_addr));\n+      else\n+\tretval = emit_insn (gen_probe_stack_rangesi (stack_pointer_rtx,\n+\t\t\t\t\t\t     stack_pointer_rtx, orig_sp,\n+\t\t\t\t\t\t     end_addr));\n+      RTX_FRAME_RELATED_P (retval) = 1;\n+      /* Describe the effect of INSN to the CFI engine.  */\n+      add_reg_note (retval, REG_FRAME_RELATED_EXPR,\n+\t\t    gen_rtx_SET (stack_pointer_rtx, end_addr));\n+\n+      /* Emit a blockage to ensure the allocation/probing insns are\n+\t not optimized, combined, removed, etc.  Other cases handle this\n+\t within their call to rs6000_emit_allocate_stack_1.  */\n+      emit_insn (gen_blockage ());\n+\n+      dump_stack_clash_frame_info (PROBE_LOOP, rounded_size != orig_size);\n+    }\n+\n+  if (orig_size != rounded_size)\n+    {\n+      /* Allocate (and implicitly probe) any residual space.   */\n+      HOST_WIDE_INT residual = orig_size - rounded_size;\n+\n+      rtx_insn *insn = rs6000_emit_allocate_stack_1 (residual, orig_sp);\n+\n+      /* If the residual was the only allocation, then we can return the\n+\t allocating insn.  */\n+      if (!retval)\n+\tretval = insn;\n+    }\n+\n+  return retval;\n+}\n+\n /* Emit the correct code for allocating stack space, as insns.\n    If COPY_REG, make sure a copy of the old frame is left there.\n    The generated code may use hard register 0 as a temporary.  */\n@@ -25539,7 +25754,6 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)\n   rtx stack_reg = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n   rtx tmp_reg = gen_rtx_REG (Pmode, 0);\n   rtx todec = gen_int_mode (-size, Pmode);\n-  rtx par, set, mem;\n \n   if (INTVAL (todec) != -size)\n     {\n@@ -25579,6 +25793,23 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)\n \twarning (0, \"stack limit expression is not supported\");\n     }\n \n+  if (flag_stack_clash_protection)\n+    {\n+      if (size < get_stack_clash_protection_guard_size ())\n+\tdump_stack_clash_frame_info (NO_PROBE_SMALL_FRAME, true);\n+      else\n+\t{\n+\t  rtx_insn *insn = rs6000_emit_probe_stack_range_stack_clash (size,\n+\t\t\t\t\t\t\t\t      copy_reg);\n+\n+\t  /* If we asked for a copy with an offset, then we still need add in\n+\t     the offset.  */\n+\t  if (copy_reg && copy_off)\n+\t    emit_insn (gen_add3_insn (copy_reg, copy_reg, GEN_INT (copy_off)));\n+\t  return insn;\n+\t}\n+    }\n+\n   if (copy_reg)\n     {\n       if (copy_off != 0)\n@@ -25587,38 +25818,11 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)\n \temit_move_insn (copy_reg, stack_reg);\n     }\n \n-  if (size > 32767)\n-    {\n-      /* Need a note here so that try_split doesn't get confused.  */\n-      if (get_last_insn () == NULL_RTX)\n-\temit_note (NOTE_INSN_DELETED);\n-      insn = emit_move_insn (tmp_reg, todec);\n-      try_split (PATTERN (insn), insn, 0);\n-      todec = tmp_reg;\n-    }\n-  \n-  insn = emit_insn (TARGET_32BIT\n-\t\t    ? gen_movsi_update_stack (stack_reg, stack_reg,\n-\t\t\t\t\t      todec, stack_reg)\n-\t\t    : gen_movdi_di_update_stack (stack_reg, stack_reg,\n-\t\t\t\t\t\t todec, stack_reg));\n   /* Since we didn't use gen_frame_mem to generate the MEM, grab\n      it now and set the alias set/attributes. The above gen_*_update\n      calls will generate a PARALLEL with the MEM set being the first\n      operation. */\n-  par = PATTERN (insn);\n-  gcc_assert (GET_CODE (par) == PARALLEL);\n-  set = XVECEXP (par, 0, 0);\n-  gcc_assert (GET_CODE (set) == SET);\n-  mem = SET_DEST (set);\n-  gcc_assert (MEM_P (mem));\n-  MEM_NOTRAP_P (mem) = 1;\n-  set_mem_alias_set (mem, get_frame_alias_set ());\n-\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (stack_reg, gen_rtx_PLUS (Pmode, stack_reg,\n-\t\t\t\t\t\t      GEN_INT (-size))));\n+  insn = rs6000_emit_allocate_stack_1 (size, stack_reg);\n   return insn;\n }\n \n@@ -25700,9 +25904,9 @@ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \t until it is equal to ROUNDED_SIZE.  */\n \n       if (TARGET_64BIT)\n-\temit_insn (gen_probe_stack_rangedi (r12, r12, r0));\n+\temit_insn (gen_probe_stack_rangedi (r12, r12, stack_pointer_rtx, r0));\n       else\n-\temit_insn (gen_probe_stack_rangesi (r12, r12, r0));\n+\temit_insn (gen_probe_stack_rangesi (r12, r12, stack_pointer_rtx, r0));\n \n \n       /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n@@ -25714,10 +25918,10 @@ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n }\n \n /* Probe a range of stack addresses from REG1 to REG2 inclusive.  These are\n-   absolute addresses.  */\n+   addresses, not offsets.  */\n \n-const char *\n-output_probe_stack_range (rtx reg1, rtx reg2)\n+static const char *\n+output_probe_stack_range_1 (rtx reg1, rtx reg2)\n {\n   static int labelno = 0;\n   char loop_lab[32];\n@@ -25784,6 +25988,63 @@ interesting_frame_related_regno (unsigned int regno)\n   return save_reg_p (regno);\n }\n \n+/* Probe a range of stack addresses from REG1 to REG3 inclusive.  These are\n+   addresses, not offsets.\n+\n+   REG2 contains the backchain that must be stored into *sp at each allocation.\n+\n+   This is subtly different than the Ada probing above in that it tries hard\n+   to prevent attacks that jump the stack guard.  Thus, it is never allowed\n+   to allocate more than PROBE_INTERVAL bytes of stack space without a\n+   suitable probe.  */\n+\n+static const char *\n+output_probe_stack_range_stack_clash (rtx reg1, rtx reg2, rtx reg3)\n+{\n+  static int labelno = 0;\n+  char loop_lab[32];\n+  rtx xops[3];\n+\n+  HOST_WIDE_INT probe_interval = get_stack_clash_protection_probe_interval ();\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno++);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n+\n+  /* This allocates and probes.  */\n+  xops[0] = reg1;\n+  xops[1] = reg2;\n+  xops[2] = GEN_INT (-probe_interval);\n+  if (TARGET_64BIT)\n+    output_asm_insn (\"stdu %1,%2(%0)\", xops);\n+  else\n+    output_asm_insn (\"stwu %1,%2(%0)\", xops);\n+\n+  /* Jump to LOOP_LAB if TEST_ADDR != LAST_ADDR.  */\n+  xops[0] = reg1;\n+  xops[1] = reg3;\n+  if (TARGET_64BIT)\n+    output_asm_insn (\"cmpd 0,%0,%1\", xops);\n+  else\n+    output_asm_insn (\"cmpw 0,%0,%1\", xops);\n+\n+  fputs (\"\\tbne 0,\", asm_out_file);\n+  assemble_name_raw (asm_out_file, loop_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  return \"\";\n+}\n+\n+/* Wrapper around the output_probe_stack_range routines.  */\n+const char *\n+output_probe_stack_range (rtx reg1, rtx reg2, rtx reg3)\n+{\n+  if (flag_stack_clash_protection)\n+    return output_probe_stack_range_stack_clash (reg1, reg2, reg3);\n+  else\n+    return output_probe_stack_range_1 (reg1, reg3);\n+}\n+\n /* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced\n    with (plus:P (reg 1) VAL), and with REG2 replaced with REPL2 if REG2\n    is not NULL.  It would be nice if dwarf2out_frame_debug_expr could\n@@ -27397,6 +27658,13 @@ rs6000_emit_prologue (void)\n \t  }\n     }\n \n+  /* If we are emitting stack probes, but allocate no stack, then\n+     just note that in the dump file.  */\n+  if (flag_stack_clash_protection\n+      && dump_file\n+      && !info->push_p)\n+    dump_stack_clash_frame_info (NO_PROBE_NO_FRAME, false);\n+\n   /* Update stack and set back pointer unless this is V.4,\n      for which it was done previously.  */\n   if (!WORLD_SAVE_P (info) && info->push_p"}, {"sha": "9019ba8ae981cf76a006f348a85cacb09db787f4", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 70, "deletions": 5, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "patch": "@@ -10250,10 +10250,20 @@\n ;;\n ;; First, an insn to allocate new stack space for dynamic use (e.g., alloca).\n ;; We move the back-chain and decrement the stack pointer.\n-\n+;;\n+;; Operand1 is more naturally reg_or_short_operand.  However, for a large\n+;; constant alloca, using that predicate will force the generic code to put\n+;; the constant size into a register before calling the expander.\n+;;\n+;; As a result the expander would not have the constant size information\n+;; in those cases and would have to generate less efficient code.\n+;;\n+;; Thus we allow reg_or_cint_operand instead so that the expander can see\n+;; the constant size.  The value is forced into a register if necessary.\n+;;\n (define_expand \"allocate_stack\"\n   [(set (match_operand 0 \"gpc_reg_operand\" \"\")\n-\t(minus (reg 1) (match_operand 1 \"reg_or_short_operand\" \"\")))\n+\t(minus (reg 1) (match_operand 1 \"reg_or_cint_operand\" \"\")))\n    (set (reg 1)\n \t(minus (reg 1) (match_dup 1)))]\n   \"\"\n@@ -10263,6 +10273,15 @@\n   rtx neg_op0;\n   rtx insn, par, set, mem;\n \n+  /* By allowing reg_or_cint_operand as the predicate we can get\n+     better code for stack-clash-protection because we do not lose\n+     size information.  But the rest of the code expects the operand\n+     to be reg_or_short_operand.  If it isn't, then force it into\n+     a register.  */\n+  rtx orig_op1 = operands[1];\n+  if (!reg_or_short_operand (operands[1], Pmode))\n+    operands[1] = force_reg (Pmode, operands[1]);\n+\n   emit_move_insn (chain, stack_bot);\n \n   /* Check stack bounds if necessary.  */\n@@ -10275,6 +10294,51 @@\n       emit_insn (gen_cond_trap (LTU, available, operands[1], const0_rtx));\n     }\n \n+  /* Allocate and probe if requested.\n+     This may look similar to the loop we use for prologue allocations,\n+     but it is critically different.  For the former we know the loop\n+     will iterate, but do not know that generally here.  The former\n+     uses that knowledge to rotate the loop.  Combining them would be\n+     possible with some performance cost.  */\n+  if (flag_stack_clash_protection)\n+    {\n+      rtx rounded_size, last_addr, residual;\n+      HOST_WIDE_INT probe_interval;\n+      compute_stack_clash_protection_loop_data (&rounded_size, &last_addr,\n+\t\t\t\t\t\t&residual, &probe_interval,\n+\t\t\t\t\t\torig_op1);\n+      \n+      /* We do occasionally get in here with constant sizes, we might\n+\t as well do a reasonable job when we obviously can.  */\n+      if (rounded_size != const0_rtx)\n+\t{\n+\t  rtx loop_lab, end_loop;\n+\t  bool rotated = CONST_INT_P (rounded_size);\n+\n+\t  emit_stack_clash_protection_probe_loop_start (&loop_lab, &end_loop,\n+\t\t\t\t\t\t\tlast_addr, rotated);\n+\n+\t  if (Pmode == SImode)\n+\t    emit_insn (gen_movsi_update_stack (stack_pointer_rtx,\n+\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t       GEN_INT (-probe_interval),\n+\t\t\t\t\t       chain));\n+\t  else\n+\t    emit_insn (gen_movdi_di_update_stack (stack_pointer_rtx,\n+\t\t\t\t\t          stack_pointer_rtx,\n+\t\t\t\t\t          GEN_INT (-probe_interval),\n+\t\t\t\t\t          chain));\n+\t  emit_stack_clash_protection_probe_loop_end (loop_lab, end_loop,\n+\t\t\t\t\t\t      last_addr, rotated);\n+\t}\n+\n+      /* Now handle residuals.  We just have to set operands[1] correctly\n+\t and let the rest of the expander run.  */\n+      operands[1] = residual;\n+      if (!CONST_INT_P (residual))\n+\toperands[1] = force_reg (Pmode, operands[1]);\n+    }\n+\n   if (GET_CODE (operands[1]) != CONST_INT\n       || INTVAL (operands[1]) < -32767\n       || INTVAL (operands[1]) > 32768)\n@@ -11413,12 +11477,13 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"probe_stack_range<P:mode>\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:P 0 \"register_operand\" \"=&r\")\n \t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"0\")\n-\t\t\t    (match_operand:P 2 \"register_operand\" \"r\")]\n+\t\t\t    (match_operand:P 2 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:P 3 \"register_operand\" \"r\")]\n \t\t\t   UNSPECV_PROBE_STACK_RANGE))]\n   \"\"\n-  \"* return output_probe_stack_range (operands[0], operands[2]);\"\n+  \"* return output_probe_stack_range (operands[0], operands[2], operands[3]);\"\n   [(set_attr \"type\" \"three\")])\n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,"}, {"sha": "c241b2f4cdc38fbf830d825e548d3b781aaa990f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "patch": "@@ -1,3 +1,9 @@\n+2017-09-25  Jeff Law  <law@redhat.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_supports_stack_clash_protection): Enable for\n+\trs6000 and powerpc targets.\n+\n 2017-09-25  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/82163"}, {"sha": "3ded1e32f49a988a68a5bcdd4fe962f3784ecde8", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=af2c8a9603dae9d74d0b5eee3a9cc9a41e68d836", "patch": "@@ -8639,12 +8639,12 @@ proc check_effective_target_autoincdec { } {\n proc check_effective_target_supports_stack_clash_protection { } {\n \n    # Temporary until the target bits are fully ACK'd.\n-#  if { [istarget aarch*-*-*]\n-#       || [istarget powerpc*-*-*] || [istarget rs6000*-*-*] } {\n+#  if { [istarget aarch*-*-*] } {\n #\treturn 1\n #  }\n \n     if { [istarget x86_64-*-*] || [istarget i?86-*-*] \n+\t  || [istarget powerpc*-*-*] || [istarget rs6000*-*-*]\n \t  || [istarget s390*-*-*] } {\n \treturn 1\n     }"}]}