{"sha": "8926e325dbd81f525a05e02cfad022b60a634590", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkyNmUzMjVkYmQ4MWY1MjVhMDVlMDJjZmFkMDIyYjYwYTYzNDU5MA==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-04-17T09:26:33Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-04-17T09:26:33Z"}, "message": "Add gimple_find_sub_bbs\n\n2015-04-17  Tom de Vries  <tom@codesourcery.com>\n\t    Michael Matz  <matz@suse.de>\n\n\t* tree-cfg.c (make_blocks_1): Factor out of ...\n\t(make_blocks): ... here.\n\t(make_edges_bb): Factor out of ...\n\t(make_edges): ... here.\n\t(gimple_find_sub_bbs): New function.\n\t* tree-cfg.h (gimple_find_sub_bbs): Declare.\n\nCo-Authored-By: Michael Matz <matz@suse.de>\n\nFrom-SVN: r222170", "tree": {"sha": "f97d8f0327b1105dc675e7dc80c7d23f006676da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f97d8f0327b1105dc675e7dc80c7d23f006676da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8926e325dbd81f525a05e02cfad022b60a634590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926e325dbd81f525a05e02cfad022b60a634590", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8926e325dbd81f525a05e02cfad022b60a634590", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926e325dbd81f525a05e02cfad022b60a634590/comments", "author": null, "committer": null, "parents": [{"sha": "cef3bed6547e6db95fa2a835574ece96805900b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cef3bed6547e6db95fa2a835574ece96805900b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cef3bed6547e6db95fa2a835574ece96805900b7"}], "stats": {"total": 273, "additions": 173, "deletions": 100}, "files": [{"sha": "36429850c236c6275ee33b5643bed2142c8c4149", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926e325dbd81f525a05e02cfad022b60a634590/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926e325dbd81f525a05e02cfad022b60a634590/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8926e325dbd81f525a05e02cfad022b60a634590", "patch": "@@ -1,3 +1,13 @@\n+2015-04-17  Tom de Vries  <tom@codesourcery.com>\n+\t    Michael Matz  <matz@suse.de>\n+\n+\t* tree-cfg.c (make_blocks_1): Factor out of ...\n+\t(make_blocks): ... here.\n+\t(make_edges_bb): Factor out of ...\n+\t(make_edges): ... here.\n+\t(gimple_find_sub_bbs): New function.\n+\t* tree-cfg.h (gimple_find_sub_bbs): Declare.\n+\n 2015-04-17  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree.c (free_lang_data): Disable lang_hooks.gimplify_expr."}, {"sha": "1cfb67a4831bb95d650cf4fdcbe56b11cce56d95", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 162, "deletions": 100, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926e325dbd81f525a05e02cfad022b60a634590/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926e325dbd81f525a05e02cfad022b60a634590/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8926e325dbd81f525a05e02cfad022b60a634590", "patch": "@@ -513,16 +513,15 @@ gimple_call_initialize_ctrl_altering (gimple stmt)\n }\n \n \n-/* Build a flowgraph for the sequence of stmts SEQ.  */\n+/* Insert SEQ after BB and build a flowgraph.  */\n \n-static void\n-make_blocks (gimple_seq seq)\n+static basic_block\n+make_blocks_1 (gimple_seq seq, basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start (seq);\n   gimple stmt = NULL;\n   bool start_new_block = true;\n   bool first_stmt_of_seq = true;\n-  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   while (!gsi_end_p (i))\n     {\n@@ -579,8 +578,16 @@ make_blocks (gimple_seq seq)\n       gsi_next (&i);\n       first_stmt_of_seq = false;\n     }\n+  return bb;\n }\n \n+/* Build a flowgraph for the sequence of stmts SEQ.  */\n+\n+static void\n+make_blocks (gimple_seq seq)\n+{\n+  make_blocks_1 (seq, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+}\n \n /* Create and return a new empty basic block after bb AFTER.  */\n \n@@ -807,6 +814,112 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n   make_edge (*dispatcher, for_bb, EDGE_ABNORMAL);\n }\n \n+/* Creates outgoing edges for BB.  Returns 1 when it ends with an\n+   computed goto, returns 2 when it ends with a statement that\n+   might return to this function via an nonlocal goto, otherwise\n+   return 0.  Updates *PCUR_REGION with the OMP region this BB is in.  */\n+\n+static int\n+make_edges_bb (basic_block bb, struct omp_region **pcur_region, int *pomp_index)\n+{\n+  gimple last = last_stmt (bb);\n+  bool fallthru = false;\n+  int ret = 0;\n+\n+  if (!last)\n+    return ret;\n+\n+  switch (gimple_code (last))\n+    {\n+    case GIMPLE_GOTO:\n+      if (make_goto_expr_edges (bb))\n+\tret = 1;\n+      fallthru = false;\n+      break;\n+    case GIMPLE_RETURN:\n+      {\n+\tedge e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+\te->goto_locus = gimple_location (last);\n+\tfallthru = false;\n+      }\n+      break;\n+    case GIMPLE_COND:\n+      make_cond_expr_edges (bb);\n+      fallthru = false;\n+      break;\n+    case GIMPLE_SWITCH:\n+      make_gimple_switch_edges (as_a <gswitch *> (last), bb);\n+      fallthru = false;\n+      break;\n+    case GIMPLE_RESX:\n+      make_eh_edges (last);\n+      fallthru = false;\n+      break;\n+    case GIMPLE_EH_DISPATCH:\n+      fallthru = make_eh_dispatch_edges (as_a <geh_dispatch *> (last));\n+      break;\n+\n+    case GIMPLE_CALL:\n+      /* If this function receives a nonlocal goto, then we need to\n+\t make edges from this call site to all the nonlocal goto\n+\t handlers.  */\n+      if (stmt_can_make_abnormal_goto (last))\n+\tret = 2;\n+\n+      /* If this statement has reachable exception handlers, then\n+\t create abnormal edges to them.  */\n+      make_eh_edges (last);\n+\n+      /* BUILTIN_RETURN is really a return statement.  */\n+      if (gimple_call_builtin_p (last, BUILT_IN_RETURN))\n+\t{\n+\t  make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+\t  fallthru = false;\n+\t}\n+      /* Some calls are known not to return.  */\n+      else\n+\tfallthru = !(gimple_call_flags (last) & ECF_NORETURN);\n+      break;\n+\n+    case GIMPLE_ASSIGN:\n+      /* A GIMPLE_ASSIGN may throw internally and thus be considered\n+\t control-altering.  */\n+      if (is_ctrl_altering_stmt (last))\n+\tmake_eh_edges (last);\n+      fallthru = true;\n+      break;\n+\n+    case GIMPLE_ASM:\n+      make_gimple_asm_edges (bb);\n+      fallthru = true;\n+      break;\n+\n+    CASE_GIMPLE_OMP:\n+      fallthru = make_gimple_omp_edges (bb, pcur_region, pomp_index);\n+      break;\n+\n+    case GIMPLE_TRANSACTION:\n+      {\n+\ttree abort_label\n+\t  = gimple_transaction_label (as_a <gtransaction *> (last));\n+\tif (abort_label)\n+\t  make_edge (bb, label_to_block (abort_label), EDGE_TM_ABORT);\n+\tfallthru = true;\n+      }\n+      break;\n+\n+    default:\n+      gcc_assert (!stmt_ends_bb_p (last));\n+      fallthru = true;\n+      break;\n+    }\n+\n+  if (fallthru)\n+    make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n+\n+  return ret;\n+}\n+\n /* Join all the blocks in the flowgraph.  */\n \n static void\n@@ -828,107 +941,19 @@ make_edges (void)\n   /* Traverse the basic block array placing edges.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple last = last_stmt (bb);\n-      bool fallthru;\n+      int mer;\n \n       if (bb_to_omp_idx)\n \tbb_to_omp_idx[bb->index] = cur_omp_region_idx;\n \n-      if (last)\n-\t{\n-\t  enum gimple_code code = gimple_code (last);\n-\t  switch (code)\n-\t    {\n-\t    case GIMPLE_GOTO:\n-\t      if (make_goto_expr_edges (bb))\n-\t\tab_edge_goto.safe_push (bb);\n-\t      fallthru = false;\n-\t      break;\n-\t    case GIMPLE_RETURN:\n-\t      {\n-\t\tedge e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-\t\te->goto_locus = gimple_location (last);\n-\t\tfallthru = false;\n-\t      }\n-\t      break;\n-\t    case GIMPLE_COND:\n-\t      make_cond_expr_edges (bb);\n-\t      fallthru = false;\n-\t      break;\n-\t    case GIMPLE_SWITCH:\n-\t      make_gimple_switch_edges (as_a <gswitch *> (last), bb);\n-\t      fallthru = false;\n-\t      break;\n-\t    case GIMPLE_RESX:\n-\t      make_eh_edges (last);\n-\t      fallthru = false;\n-\t      break;\n-\t    case GIMPLE_EH_DISPATCH:\n-\t      fallthru = make_eh_dispatch_edges (as_a <geh_dispatch *> (last));\n-\t      break;\n-\n-\t    case GIMPLE_CALL:\n-\t      /* If this function receives a nonlocal goto, then we need to\n-\t\t make edges from this call site to all the nonlocal goto\n-\t\t handlers.  */\n-\t      if (stmt_can_make_abnormal_goto (last))\n-\t\tab_edge_call.safe_push (bb);\n-\n-\t      /* If this statement has reachable exception handlers, then\n-\t\t create abnormal edges to them.  */\n-\t      make_eh_edges (last);\n-\n-\t      /* BUILTIN_RETURN is really a return statement.  */\n-\t      if (gimple_call_builtin_p (last, BUILT_IN_RETURN))\n-\t\t{\n-\t\t  make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-\t\t  fallthru = false;\n-\t\t}\n-\t      /* Some calls are known not to return.  */\n-\t      else\n-\t        fallthru = !(gimple_call_flags (last) & ECF_NORETURN);\n-\t      break;\n+      mer = make_edges_bb (bb, &cur_region, &cur_omp_region_idx);\n+      if (mer == 1)\n+\tab_edge_goto.safe_push (bb);\n+      else if (mer == 2)\n+\tab_edge_call.safe_push (bb);\n \n-\t    case GIMPLE_ASSIGN:\n-\t       /* A GIMPLE_ASSIGN may throw internally and thus be considered\n-\t\t  control-altering. */\n-\t      if (is_ctrl_altering_stmt (last))\n-\t\tmake_eh_edges (last);\n-\t      fallthru = true;\n-\t      break;\n-\n-\t    case GIMPLE_ASM:\n-\t      make_gimple_asm_edges (bb);\n-\t      fallthru = true;\n-\t      break;\n-\n-\t    CASE_GIMPLE_OMP:\n-\t      fallthru = make_gimple_omp_edges (bb, &cur_region,\n-\t\t\t\t\t\t&cur_omp_region_idx);\n-\t      if (cur_region && bb_to_omp_idx == NULL)\n-\t\tbb_to_omp_idx = XCNEWVEC (int, n_basic_blocks_for_fn (cfun));\n-\t      break;\n-\n-\t    case GIMPLE_TRANSACTION:\n-\t      {\n-\t\ttree abort_label\n-\t\t  = gimple_transaction_label (as_a <gtransaction *> (last));\n-\t\tif (abort_label)\n-\t\t  make_edge (bb, label_to_block (abort_label), EDGE_TM_ABORT);\n-\t\tfallthru = true;\n-\t      }\n-\t      break;\n-\n-\t    default:\n-\t      gcc_assert (!stmt_ends_bb_p (last));\n-\t      fallthru = true;\n-\t    }\n-\t}\n-      else\n-\tfallthru = true;\n-\n-      if (fallthru)\n-\tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n+      if (cur_region && bb_to_omp_idx == NULL)\n+\tbb_to_omp_idx = XCNEWVEC (int, n_basic_blocks_for_fn (cfun));\n     }\n \n   /* Computed gotos are hell to deal with, especially if there are\n@@ -1008,6 +1033,43 @@ make_edges (void)\n   fold_cond_expr_cond ();\n }\n \n+/* Add SEQ after GSI.  Start new bb after GSI, and created further bbs as\n+   needed.  Returns true if new bbs were created.\n+   Note: This is transitional code, and should not be used for new code.  We\n+   should be able to get rid of this by rewriting all target va-arg\n+   gimplification hooks to use an interface gimple_build_cond_value as described\n+   in https://gcc.gnu.org/ml/gcc-patches/2015-02/msg01194.html.  */\n+\n+bool\n+gimple_find_sub_bbs (gimple_seq seq, gimple_stmt_iterator *gsi)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  basic_block bb = gimple_bb (stmt);\n+  basic_block lastbb, afterbb;\n+  int old_num_bbs = n_basic_blocks_for_fn (cfun);\n+  edge e;\n+  lastbb = make_blocks_1 (seq, bb);\n+  if (old_num_bbs == n_basic_blocks_for_fn (cfun))\n+    return false;\n+  e = split_block (bb, stmt);\n+  /* Move e->dest to come after the new basic blocks.  */\n+  afterbb = e->dest;\n+  unlink_block (afterbb);\n+  link_block (afterbb, lastbb);\n+  redirect_edge_succ (e, bb->next_bb);\n+  bb = bb->next_bb;\n+  while (bb != afterbb)\n+    {\n+      struct omp_region *cur_region = NULL;\n+      int cur_omp_region_idx = 0;\n+      int mer = make_edges_bb (bb, &cur_region, &cur_omp_region_idx);\n+      gcc_assert (!mer && !cur_region);\n+      add_bb_to_loop (bb, afterbb->loop_father);\n+      bb = bb->next_bb;\n+    }\n+  return true;\n+}\n+\n /* Find the next available discriminator value for LOCUS.  The\n    discriminator distinguishes among several basic blocks that\n    share a common locus, allowing for more accurate sample-based"}, {"sha": "2fc1e886ff0d5bf194c1300c33c4fec7d6522db6", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926e325dbd81f525a05e02cfad022b60a634590/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926e325dbd81f525a05e02cfad022b60a634590/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=8926e325dbd81f525a05e02cfad022b60a634590", "patch": "@@ -103,5 +103,6 @@ extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern unsigned int execute_fixup_cfg (void);\n extern unsigned int split_critical_edges (void);\n extern basic_block insert_cond_bb (basic_block, gimple, gimple);\n+extern bool gimple_find_sub_bbs (gimple_seq, gimple_stmt_iterator *);\n \n #endif /* _TREE_CFG_H  */"}]}