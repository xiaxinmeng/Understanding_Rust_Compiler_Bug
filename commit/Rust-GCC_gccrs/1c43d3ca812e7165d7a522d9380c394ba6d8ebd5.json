{"sha": "1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM0M2QzY2E4MTJlNzE2NWQ3YTUyMmQ5MzgwYzM5NGJhNmQ4ZWJkNQ==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-09-10T09:22:28Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-10T09:22:28Z"}, "message": "lambda-mat.c (lambda_matrix_inverse_hard): Use gcc_assert and gcc_unreachable instead of abort.\n\n\t* lambda-mat.c (lambda_matrix_inverse_hard): Use gcc_assert\n\tand gcc_unreachable instead of abort.\n\t* lambda.h (lambda_vector_min_nz): Likewise.\n\t* langhooks.c lhd_set_decl_assembler_name, lhd_can_use_bit_fields_p,\n\tlhd_incomplete_type_error, lhd_expand_expr, lhd_types_compatible_p,\n\tlhd_gimplify_expr): Likewise.\n\t* lcm.c (optimize_mode_switching): Likewise.\n\t* local-alloc.c (update_equiv_regs, block_alloc, find_free_reg):\n\tLikewise.\n\t* loop-doloop.c (doloop_modify): Likewise.\n\t* loop-invariant.c (record_use): Likewise.\n\t* loop-iv.c (get_biv_step_1, get_biv_step, iv_analyze, get_iv_value,\n\tcanon_condition, simplify_using_condition,\n\tsimplify_using_initial_values, shorten_into_mode,\n\tcanonicalize_iv_subregs, iv_number_of_iterations): Likewise.\n\t* loop-unroll.c (unroll_and_peel_loops, peel_loop_completely,\n\tunroll_loop_constant_iterations, unroll_loop_runtime_iterations,\n\tpeel_loop_simple, unroll_loop_stupid): Likewise.\n\t* loop-unswitch.c (compare_and_jump_seq, unswitch_single_loop,\n\tunswitch_loop): Likewise.\n\t* loop.c (gen_prefetch, loop_optimize, rtx_equal_for_loop_p,\n\tmove_movables, replace_call_address, find_and_verify_loops,\n\trtx_equal_for_prefetch_p, record_giv, general_induction_var,\n\tsimplify_giv_expr, check_ext_dependent_givs, try_copy_prop,\n\tloop_giv_dump): Likewise.\n\t* loop.h (INSN_LUID): Likewise.\n\t* modulo-sched.c (normalize_sched_times, generate_prolog_epilog,\n\tsms_schedule, check_nodes_order): Likewise.\n\t* optabs.c (gen_conditional, add_equal_note, expand_simple_binop,\n\texpand_twoval_unop, expand_twoval_binop, expand_twoval_binop_libfunc,\n\texpand_simple_unop, emit_no_conflict_block, prepare_cmp_insn,\n\temit_cmp_and_jump_insn_1, emit_cmp_and_jump_insns,\n\tprepare_float_lib_cmp, gen_add2_insn, have_add2_insn, gen_sub2_insn,\n\thave_sub2_insn, expand_float, expand_fix, debug_optab_libfuncs):\n\tLikewise.\n\t* opts.c (common_handle_option): Likewise.\n\t* params.c (set_param_value): Likewise.\n\t* passes.c (open_dump_file, rest_of_handle_final): Likewise.\n\t* postreload-gcse.c (expr_equiv_p, oprs_unchanged_p,hash_scan_set,\n\treg_set_between_after_reload_p, reg_used_between_after_reload_p,\n\tget_avail_load_store_reg, eliminate_partially_redundant_load):\n\tLikewise.\n\t* postreload.c (reload_cse_simplify_set, reload_combine_note_use):\n\tLikewise.\n\t* predict.c (tree_predicted_by_p, expected_value_to_br_prob,\n\tpropagate_freq, expensive_function_p): Likewise.\n\t* pretty-print.c (pp_base_format_text)\n\t* profile.c (instrument_edges, instrument_values,\n\tcompute_branch_probabilities, branch_prob, union_groups,\n\tend_branch_prob, tree_register_profile_hooks): Likewise.\n\nFrom-SVN: r87285", "tree": {"sha": "53321caf2b610be1206b5d38f653d831c8fd72e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53321caf2b610be1206b5d38f653d831c8fd72e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b829f3fac7e1c736df642ace45589e8d24ae2731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b829f3fac7e1c736df642ace45589e8d24ae2731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b829f3fac7e1c736df642ace45589e8d24ae2731"}], "stats": {"total": 791, "additions": 385, "deletions": 406}, "files": [{"sha": "715deb1178b309bb570deacd0d3690eee15945ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -1,3 +1,56 @@\n+2004-09-10  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\t* lambda-mat.c (lambda_matrix_inverse_hard): Use gcc_assert\n+\tand gcc_unreachable instead of abort.\n+\t* lambda.h (lambda_vector_min_nz): Likewise.\n+\t* langhooks.c lhd_set_decl_assembler_name, lhd_can_use_bit_fields_p,\n+\tlhd_incomplete_type_error, lhd_expand_expr, lhd_types_compatible_p,\n+\tlhd_gimplify_expr): Likewise.\n+\t* lcm.c (optimize_mode_switching): Likewise.\n+\t* local-alloc.c (update_equiv_regs, block_alloc, find_free_reg):\n+\tLikewise.\n+\t* loop-doloop.c (doloop_modify): Likewise.\n+\t* loop-invariant.c (record_use): Likewise.\n+\t* loop-iv.c (get_biv_step_1, get_biv_step, iv_analyze, get_iv_value,\n+\tcanon_condition, simplify_using_condition,\n+\tsimplify_using_initial_values, shorten_into_mode,\n+\tcanonicalize_iv_subregs, iv_number_of_iterations): Likewise.\n+\t* loop-unroll.c (unroll_and_peel_loops, peel_loop_completely,\n+\tunroll_loop_constant_iterations, unroll_loop_runtime_iterations,\n+\tpeel_loop_simple, unroll_loop_stupid): Likewise.\n+\t* loop-unswitch.c (compare_and_jump_seq, unswitch_single_loop,\n+\tunswitch_loop): Likewise.\n+\t* loop.c (gen_prefetch, loop_optimize, rtx_equal_for_loop_p,\n+\tmove_movables, replace_call_address, find_and_verify_loops,\n+\trtx_equal_for_prefetch_p, record_giv, general_induction_var,\n+\tsimplify_giv_expr, check_ext_dependent_givs, try_copy_prop,\n+\tloop_giv_dump): Likewise.\n+\t* loop.h (INSN_LUID): Likewise.\n+\t* modulo-sched.c (normalize_sched_times, generate_prolog_epilog,\n+\tsms_schedule, check_nodes_order): Likewise.\n+\t* optabs.c (gen_conditional, add_equal_note, expand_simple_binop,\n+\texpand_twoval_unop, expand_twoval_binop, expand_twoval_binop_libfunc,\n+\texpand_simple_unop, emit_no_conflict_block, prepare_cmp_insn,\n+\temit_cmp_and_jump_insn_1, emit_cmp_and_jump_insns,\n+\tprepare_float_lib_cmp, gen_add2_insn, have_add2_insn, gen_sub2_insn,\n+\thave_sub2_insn, expand_float, expand_fix, debug_optab_libfuncs):\n+\tLikewise.\n+\t* opts.c (common_handle_option): Likewise.\n+\t* params.c (set_param_value): Likewise.\n+\t* passes.c (open_dump_file, rest_of_handle_final): Likewise.\n+\t* postreload-gcse.c (expr_equiv_p, oprs_unchanged_p,hash_scan_set,\n+\treg_set_between_after_reload_p, reg_used_between_after_reload_p,\n+\tget_avail_load_store_reg, eliminate_partially_redundant_load):\n+\tLikewise.\n+\t* postreload.c (reload_cse_simplify_set, reload_combine_note_use):\n+\tLikewise.\n+\t* predict.c (tree_predicted_by_p, expected_value_to_br_prob,\n+\tpropagate_freq, expensive_function_p): Likewise.\n+\t* pretty-print.c (pp_base_format_text)\n+\t* profile.c (instrument_edges, instrument_values,\n+\tcompute_branch_probabilities, branch_prob, union_groups,\n+\tend_branch_prob, tree_register_profile_hooks): Likewise.\n+\n 2004-09-10  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-dce.c (remove_dead_stmt): Update profile.\n@@ -7111,7 +7164,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\ufffd  <tfautre@pandora.be>\n+\t    Tanguy Fautr\u00c3  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "92437dfc456d1d12b7be377070db7c7592797bd9", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -379,8 +379,7 @@ lambda_matrix_inverse_hard (lambda_matrix mat, lambda_matrix inv, int n)\n       diagonal = row[j];\n \n       /* If the matrix is singular, abort.  */\n-      if (diagonal == 0)\n-\tabort ();\n+      gcc_assert (diagonal != 0);\n \n       determinant = determinant * diagonal;\n "}, {"sha": "65690455adad7d6db8d0a7ce873ee80589cdd386", "filename": "gcc/lambda.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -290,19 +290,15 @@ lambda_vector_min_nz (lambda_vector vec1, int n, int start)\n {\n   int j;\n   int min = -1;\n-#ifdef ENABLE_CHECKING \n-  if (start > n)\n-    abort ();\n-#endif\n+  gcc_assert (start <= n);\n   for (j = start; j < n; j++)\n     {\n       if (vec1[j])\n \tif (min < 0 || vec1[j] < vec1[min])\n \t  min = j;\n     }\n \n-  if (min < 0)\n-    abort ();\n+  gcc_assert (min >= 0);\n \n   return min;\n }"}, {"sha": "3187f7c167534824eb3bf7fa3d6b8cd8ec0556e3", "filename": "gcc/langhooks.c", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -156,38 +156,35 @@ lhd_set_decl_assembler_name (tree decl)\n   /* The language-independent code should never use the\n      DECL_ASSEMBLER_NAME for lots of DECLs.  Only FUNCTION_DECLs and\n      VAR_DECLs for variables with static storage duration need a real\n-     DECL_ASSEMBLER_NAME.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      || (TREE_CODE (decl) == VAR_DECL\n-\t  && (TREE_STATIC (decl)\n-\t      || DECL_EXTERNAL (decl)\n-\t      || TREE_PUBLIC (decl))))\n+     DECL_ASSEMBLER_NAME.\n+     Nobody should ever be asking for the DECL_ASSEMBLER_NAME of\n+     these DECLs -- unless they're in language-dependent code, in\n+     which case set_decl_assembler_name hook should handle things.  */\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t      || (TREE_CODE (decl) == VAR_DECL\n+\t\t  && (TREE_STATIC (decl)\n+\t\t      || DECL_EXTERNAL (decl)\n+\t\t      || TREE_PUBLIC (decl))));\n+\n+  /* By default, assume the name to use in assembly code is the\n+      same as that used in the source language.  (That's correct\n+      for C, and GCC used to set DECL_ASSEMBLER_NAME to the same\n+      value as DECL_NAME in build_decl, so this choice provides\n+      backwards compatibility with existing front-ends.\n+\n+      Can't use just the variable's own name for a variable whose\n+      scope is less than the whole compilation.  Concatenate a\n+      distinguishing number - we use the DECL_UID.  */\n+  if (TREE_PUBLIC (decl) || DECL_CONTEXT (decl) == NULL_TREE)\n+    SET_DECL_ASSEMBLER_NAME (decl, DECL_NAME (decl));\n+  else\n     {\n-      /* By default, assume the name to use in assembly code is the\n-\t same as that used in the source language.  (That's correct\n-\t for C, and GCC used to set DECL_ASSEMBLER_NAME to the same\n-\t value as DECL_NAME in build_decl, so this choice provides\n-\t backwards compatibility with existing front-ends.\n-\n-         Can't use just the variable's own name for a variable whose\n-\t scope is less than the whole compilation.  Concatenate a\n-\t distinguishing number - we use the DECL_UID.  */\n-      if (TREE_PUBLIC (decl) || DECL_CONTEXT (decl) == NULL_TREE)\n-\tSET_DECL_ASSEMBLER_NAME (decl, DECL_NAME (decl));\n-      else\n-\t{\n-\t  const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-\t  char *label;\n+      const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      char *label;\n \n-\t  ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n-\t  SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n-\t}\n+      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n     }\n-  else\n-    /* Nobody should ever be asking for the DECL_ASSEMBLER_NAME of\n-       these DECLs -- unless they're in language-dependent code, in\n-       which case set_decl_assembler_name hook should handle things.  */\n-    abort ();\n }\n \n /* By default we always allow bit-field based optimizations.  */\n@@ -201,7 +198,7 @@ lhd_can_use_bit_fields_p (void)\n tree\n lhd_type_promotes_to (tree ARG_UNUSED (type))\n {\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Registration of machine- or os-specific builtin types.  */\n@@ -215,10 +212,7 @@ lhd_register_builtin_type (tree ARG_UNUSED (type),\n void\n lhd_incomplete_type_error (tree ARG_UNUSED (value), tree type)\n {\n-  if (TREE_CODE (type) == ERROR_MARK)\n-    return;\n-\n-  abort ();\n+  gcc_assert (TREE_CODE (type) == ERROR_MARK);\n }\n \n /* Provide a default routine for alias sets that always returns -1.  This\n@@ -247,7 +241,7 @@ lhd_expand_expr (tree ARG_UNUSED (t), rtx ARG_UNUSED (r),\n \t\t int ARG_UNUSED (em),\n \t\t rtx * ARG_UNUSED (a))\n {\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* The default language-specific function for expanding a decl.  After\n@@ -287,7 +281,7 @@ lhd_types_compatible_p (tree x, tree y)\n    information associated to common tree codes.  If a tree node is\n    completely handled within this function, it should set *SUBTREES to\n    0, so that generic handling isn't attempted.  For language-specific\n-   tree codes, generic handling would abort(), so make sure it is set\n+   tree codes, generic handling would assert out, so make sure it is set\n    properly.  Both SUBTREES and *SUBTREES is guaranteed to be nonzero\n    when the function is called.  */\n \n@@ -442,8 +436,7 @@ lhd_gimplify_expr (tree *expr_p ATTRIBUTE_UNUSED, tree *pre_p ATTRIBUTE_UNUSED,\n size_t\n lhd_tree_size (enum tree_code c ATTRIBUTE_UNUSED)\n {\n-  abort ();\n-  return 0;\n+  gcc_unreachable ();\n }\n \n /* Return true if decl, which is a function decl, may be called by a"}, {"sha": "2c0d81e01c5b62a66ef277dd603364dadc254dfb", "filename": "gcc/lcm.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -1029,8 +1029,7 @@ optimize_mode_switching (FILE *file)\n \t{\n \t  regset live_at_end = eg->src->global_live_at_end;\n \n-\t  if (pre_exit)\n-\t    abort ();\n+\t  gcc_assert (!pre_exit);\n \t  pre_exit = split_edge (eg);\n \t  COPY_REG_SET (pre_exit->global_live_at_start, live_at_end);\n \t  COPY_REG_SET (pre_exit->global_live_at_end, live_at_end);\n@@ -1208,21 +1207,22 @@ optimize_mode_switching (FILE *file)\n \t\t  emited = true;\n \t\t  if (JUMP_P (BB_END (src_bb)))\n \t\t    emit_insn_before (mode_set, BB_END (src_bb));\n-\t\t  /* It doesn't make sense to switch to normal mode\n-\t\t     after a CALL_INSN, so we're going to abort if we\n-\t\t     find one.  The cases in which a CALL_INSN may\n-\t\t     have an abnormal edge are sibcalls and EH edges.\n-\t\t     In the case of sibcalls, the dest basic-block is\n-\t\t     the EXIT_BLOCK, that runs in normal mode; it is\n-\t\t     assumed that a sibcall insn requires normal mode\n-\t\t     itself, so no mode switch would be required after\n-\t\t     the call (it wouldn't make sense, anyway).  In\n-\t\t     the case of EH edges, EH entry points also start\n-\t\t     in normal mode, so a similar reasoning applies.  */\n-\t\t  else if (NONJUMP_INSN_P (BB_END (src_bb)))\n-\t\t    emit_insn_after (mode_set, BB_END (src_bb));\n \t\t  else\n-\t\t    abort ();\n+\t\t    { \n+\t\t     /* It doesn't make sense to switch to normal mode\n+\t\t\tafter a CALL_INSN, so we're going to abort if we\n+\t\t\tfind one.  The cases in which a CALL_INSN may\n+\t\t\thave an abnormal edge are sibcalls and EH edges.\n+\t\t\tIn the case of sibcalls, the dest basic-block is\n+\t\t\tthe EXIT_BLOCK, that runs in normal mode; it is\n+\t\t\tassumed that a sibcall insn requires normal mode\n+\t\t\titself, so no mode switch would be required after\n+\t\t\tthe call (it wouldn't make sense, anyway).  In\n+\t\t\tthe case of EH edges, EH entry points also start\n+\t\t\tin normal mode, so a similar reasoning applies.  */\n+\t\t      gcc_assert (NONJUMP_INSN_P (BB_END (src_bb)));\n+\t\t      emit_insn_after (mode_set, BB_END (src_bb));\n+\t\t    }\n \t\t  bb_info[j][src_bb->index].computing = mode;\n \t\t  RESET_BIT (transp[src_bb->index], j);\n \t\t}"}, {"sha": "9457074949e3f42cdc2ca14ca1fe2ed2aa5d362b", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -1028,9 +1028,9 @@ update_equiv_regs (void)\n \t\t     once and used once.  (If it were only set, but not used,\n \t\t     flow would have deleted the setting insns.)  Hence\n \t\t     there can only be one insn in reg_equiv[REGNO].init_insns.  */\n-\t\t  if (reg_equiv[regno].init_insns == NULL_RTX\n-\t\t      || XEXP (reg_equiv[regno].init_insns, 1) != NULL_RTX)\n-\t\t    abort ();\n+\t\t  gcc_assert (reg_equiv[regno].init_insns != NULL_RTX);\n+\t\t  gcc_assert (XEXP (reg_equiv[regno].init_insns, 1)\n+\t\t\t      == NULL_RTX);\n \t\t  equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n \n \t\t  /* We may not move instructions that can throw, since\n@@ -1188,8 +1188,10 @@ block_alloc (int b)\n   while (1)\n     {\n       if (!NOTE_P (insn))\n-\tif (++insn_count > max_uid)\n-\t  abort ();\n+\t{\r\n+\t  ++insn_count;\n+\t  gcc_assert (insn_count <= max_uid);\n+\t}\n       if (insn == BB_HEAD (BASIC_BLOCK (b)))\n \tbreak;\n       insn = PREV_INSN (insn);\n@@ -2110,8 +2112,8 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n #endif\n \n   /* Validate our parameters.  */\n-  if (born_index < 0 || born_index > dead_index)\n-    abort ();\n+  gcc_assert (born_index >= 0);\n+  gcc_assert (born_index < dead_index);\n \n   /* Don't let a pseudo live in a reg across a function call\n      if we might get a nonlocal goto.  */"}, {"sha": "dcb22622e569f08773cf2c58ad3998c7cce12133", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -303,16 +303,16 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \t  increment_count = true;\n \t  noloop = const1_rtx;\n \t}\n-      else if (XEXP (condition, 1) == const0_rtx)\n-       \tnoloop = const0_rtx;\n       else\n-\tabort ();\n+\t{\n+\t  gcc_assert (XEXP (condition, 1) == const0_rtx);\n+\t  noloop = const0_rtx;\n+\t}\n       break;\n \n     case GE:\n       /* Currently only GE tests against zero are supported.  */\n-      if (XEXP (condition, 1) != const0_rtx)\n-\tabort ();\n+      gcc_assert (XEXP (condition, 1) == const0_rtx);\n \n       noloop = constm1_rtx;\n \n@@ -327,9 +327,9 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \tnonneg = 1;\n       break;\n \n-      /* Abort if an invalid doloop pattern has been generated.  */\n     default:\n-      abort ();\n+      /* Abort if an invalid doloop pattern has been generated.  */\n+      gcc_unreachable ();\n     }\n \n   if (increment_count)"}, {"sha": "9a27385dcb8f3813b1d1da8fbc66c8f8abcdafc3", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -353,8 +353,7 @@ record_use (struct def *def, rtx *use, rtx insn)\n \n   if (GET_CODE (*use) == SUBREG)\n     use = &SUBREG_REG (*use);\n-  if (!REG_P (*use))\n-    abort ();\n+  gcc_assert (REG_P (*use));\n \n   u->pos = use;\n   u->insn = insn;"}, {"sha": "6430b244f7183a3bf65c4e7fcc056be3868a93f1", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -793,16 +793,15 @@ get_biv_step_1 (rtx insn, rtx reg,\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      if (GET_MODE (op0) != *inner_mode\n-\t  || *extend != UNKNOWN\n-\t  || *outer_step != const0_rtx)\n-\tabort ();\n+      gcc_assert (GET_MODE (op0) == *inner_mode);\n+      gcc_assert (*extend == UNKNOWN);\n+      gcc_assert (*outer_step == const0_rtx);\n \n       *extend = code;\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return true;\n@@ -826,17 +825,9 @@ get_biv_step (rtx reg, rtx *inner_step, enum machine_mode *inner_mode,\n \t\t       outer_step))\n     return false;\n \n-  if (*inner_mode != *outer_mode\n-      && *extend == UNKNOWN)\n-    abort ();\n-\n-  if (*inner_mode == *outer_mode\n-      && *extend != UNKNOWN)\n-    abort ();\n-\n-  if (*inner_mode == *outer_mode\n-      && *outer_step != const0_rtx)\n-    abort ();\n+  gcc_assert (*inner_mode == *outer_mode || *extend != UNKNOWN);\n+  gcc_assert (*inner_mode != *outer_mode || *extend == UNKNOWN);\n+  gcc_assert (*inner_mode != *outer_mode || *outer_step == const0_rtx);\n \n   return true;\n }\n@@ -1085,23 +1076,21 @@ iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n \t  mby = XEXP (rhs, 1);\n \t  if (!CONSTANT_P (mby))\n \t    {\n-\t      if (!CONSTANT_P (op0))\n-\t\tabort ();\n+\t      gcc_assert (CONSTANT_P (op0));\n \t      tmp = op0;\n \t      op0 = mby;\n \t      mby = tmp;\n \t    }\n \t  break;\n \n \tcase ASHIFT:\n-\t  if (CONSTANT_P (XEXP (rhs, 0)))\n-\t    abort ();\n+\t  gcc_assert (!CONSTANT_P (XEXP (rhs, 0)));\n \t  op0 = XEXP (rhs, 0);\n \t  mby = XEXP (rhs, 1);\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       amode = GET_MODE (rhs);\n@@ -1192,8 +1181,7 @@ get_iv_value (struct rtx_iv *iv, rtx iteration)\n \n   /* We would need to generate some if_then_else patterns, and so far\n      it is not needed anywhere.  */\n-  if (iv->first_special)\n-    abort ();\n+  gcc_assert (!iv->first_special);\n \n   if (iv->step != const0_rtx && iteration != const0_rtx)\n     val = simplify_gen_binary (PLUS, iv->extend_mode, iv->base,\n@@ -1529,8 +1517,7 @@ canon_condition (rtx cond)\n   mode = GET_MODE (op0);\n   if (mode == VOIDmode)\n     mode = GET_MODE (op1);\n-  if (mode == VOIDmode)\n-    abort ();\n+  gcc_assert (mode != VOIDmode);\n \n   if (GET_CODE (op1) == CONST_INT\n       && GET_MODE_CLASS (mode) != MODE_CC\n@@ -1659,20 +1646,21 @@ simplify_using_condition (rtx cond, rtx *expr, regset altered)\n static void\n eliminate_implied_condition (enum rtx_code op, rtx a, rtx *b)\n {\n-  if (op == AND)\n+  switch (op)\n     {\n+    case AND:\n       /* If A implies *B, we may replace *B by true.  */\n       if (implies_p (a, *b))\n \t*b = const_true_rtx;\n-    }\n-  else if (op == IOR)\n-    {\n+      break;\n+    case IOR:\n       /* If *B implies A, we may replace *B by false.  */\n       if (implies_p (*b, a))\n \t*b = const0_rtx;\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n }\n \n /* Eliminates the conditions in TAIL that are implied by HEAD.  OP is the\n@@ -1714,18 +1702,19 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \n       eliminate_implied_conditions (op, &head, tail);\n \n-      if (op == AND)\n+      switch (op)\n \t{\n+\tcase AND:\n \t  neutral = const_true_rtx;\n \t  aggr = const0_rtx;\n-\t}\n-      else if (op == IOR)\n-\t{\n+\t  break;\n+\tcase IOR:\n \t  neutral = const0_rtx;\n \t  aggr = const_true_rtx;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n \n       simplify_using_initial_values (loop, UNKNOWN, &head);\n       if (head == aggr)\n@@ -1753,8 +1742,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n       return;\n     }\n \n-  if (op != UNKNOWN)\n-    abort ();\n+  gcc_assert (op == UNKNOWN);\n \n   e = loop_preheader_edge (loop);\n   if (e->src == ENTRY_BLOCK_PTR)\n@@ -1856,7 +1844,7 @@ shorten_into_mode (struct rtx_iv *iv, enum machine_mode mode,\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   iv->mode = mode;\n@@ -1914,7 +1902,7 @@ canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   /* Values of both variables should be computed in the same mode.  These\n@@ -2013,15 +2001,13 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   desc->niter_max = 0;\n \n   cond = GET_CODE (condition);\n-  if (!COMPARISON_P (condition))\n-    abort ();\n+  gcc_assert (COMPARISON_P (condition));\n \n   mode = GET_MODE (XEXP (condition, 0));\n   if (mode == VOIDmode)\n     mode = GET_MODE (XEXP (condition, 1));\n   /* The constant comparisons should be folded.  */\n-  if (mode == VOIDmode)\n-    abort ();\n+  gcc_assert (mode != VOIDmode);\n \n   /* We only handle integers or pointers.  */\n   if (GET_MODE_CLASS (mode) != MODE_INT"}, {"sha": "59533d769db912a77de5a7e87d17d7121634fde6", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 64, "deletions": 47, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -116,7 +116,7 @@ unroll_and_peel_loops (struct loops *loops, int flags)\n \t{\n \tcase LPT_PEEL_COMPLETELY:\n \t  /* Already done.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n \tcase LPT_PEEL_SIMPLE:\n \t  peel_loop_simple (loops, loop);\n \t  break;\n@@ -133,7 +133,7 @@ unroll_and_peel_loops (struct loops *loops, int flags)\n \t  check = false;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       if (check)\n \t{\n@@ -433,6 +433,8 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n \n   if (npeel)\n     {\n+      int ok;\n+\n       wont_exit = sbitmap_alloc (npeel + 1);\n       sbitmap_ones (wont_exit);\n       RESET_BIT (wont_exit, 0);\n@@ -442,11 +444,12 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n       remove_edges = xcalloc (npeel, sizeof (edge));\n       n_remove_edges = 0;\n \n-      if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, npeel,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-\tabort ();\n+      ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t  loops, npeel,\n+\t\t\t\t\t  wont_exit, desc->out_edge,\n+\t\t\t\t\t  remove_edges, &n_remove_edges,\n+\t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ);\n+      gcc_assert (ok);\n \n       free (wont_exit);\n \n@@ -597,11 +600,12 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   unsigned max_unroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n+  int ok;\n \n   niter = desc->niter;\n \n-  if (niter <= max_unroll + 1)\n-    abort ();  /* Should not get here (such loop should be peeled instead).  */\n+  /* Should not assert out here (such loop should be peeled instead).  */\n+  gcc_assert (niter > max_unroll + 1);\n \n   exit_mod = niter % (max_unroll + 1);\n \n@@ -627,12 +631,14 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \n       if (exit_mod)\n \t{\n-\t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t  int ok;\n+\n+\t  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t      loops, exit_mod,\n \t\t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t\t      remove_edges, &n_remove_edges,\n-\t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ))\n-\t    abort ();\n+\t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+\t  gcc_assert (ok);\n \n \t  desc->noloop_assumptions = NULL_RTX;\n \t  desc->niter -= exit_mod;\n@@ -655,15 +661,18 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n       if (exit_mod != max_unroll\n \t  || desc->noloop_assumptions)\n \t{\n+\t  int ok;\n+\n \t  RESET_BIT (wont_exit, 0);\n \t  if (desc->noloop_assumptions)\n \t    RESET_BIT (wont_exit, 1);\n \n-\t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, exit_mod + 1,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-\t    abort ();\n+\t  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t      loops, exit_mod + 1,\n+\t\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+\t  gcc_assert (ok);\n \n \t  desc->niter -= exit_mod + 1;\n \t  desc->niter_max -= exit_mod + 1;\n@@ -677,11 +686,12 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n     }\n \n   /* Now unroll the loop.  */\n-  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\tloops, max_unroll,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\t\t\t      loops, max_unroll,\n+\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   free (wont_exit);\n \n@@ -842,6 +852,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   unsigned max_unroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n+  int ok;\n \n   /* Remember blocks whose dominators will have to be updated.  */\n   dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n@@ -916,11 +927,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       && !desc->noloop_assumptions)\n     SET_BIT (wont_exit, 1);\n   ezc_swtch = loop_preheader_edge (loop)->src;\n-  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, 1,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t      loops, 1,\n+\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   /* Record the place where switch will be built for preconditioning.  */\n   swtch = loop_split_edge_with (loop_preheader_edge (loop),\n@@ -932,11 +944,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       sbitmap_zero (wont_exit);\n       if (i != n_peel - 1 || !last_may_exit)\n \tSET_BIT (wont_exit, 1);\n-      if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, 1,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-\tabort ();\n+      ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t  loops, 1,\n+\t\t\t\t\t  wont_exit, desc->out_edge,\n+\t\t\t\t\t  remove_edges, &n_remove_edges,\n+\t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ);\n+      gcc_assert (ok);\n \n       /* Create item for switch.  */\n       j = n_peel - i - (extra_zero_check ? 0 : 1);\n@@ -979,11 +992,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   sbitmap_ones (wont_exit);\n   RESET_BIT (wont_exit, may_exit_copy);\n \n-  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\tloops, max_unroll,\n-\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\t\t\t      loops, max_unroll,\n+\t\t\t\t      wont_exit, desc->out_edge,\n+\t\t\t\t      remove_edges, &n_remove_edges,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   free (wont_exit);\n \n@@ -1013,8 +1027,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n      preconditioning and the fact that the value must be valid at entry\n      of the loop.  After passing through the above code, we see that\n      the correct new number of iterations is this:  */\n-  if (desc->const_iter)\n-    abort ();\n+  gcc_assert (!desc->const_iter);\n   desc->niter_expr =\n     simplify_gen_binary (UDIV, desc->mode, old_niter, GEN_INT (max_unroll + 1));\n   desc->niter_max /= max_unroll + 1;\n@@ -1138,14 +1151,16 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n   sbitmap wont_exit;\n   unsigned npeel = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n+  int ok;\n \n   wont_exit = sbitmap_alloc (npeel + 1);\n   sbitmap_zero (wont_exit);\n \n-  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\tloops, npeel, wont_exit, NULL, NULL, NULL,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t      loops, npeel, wont_exit,\n+\t\t\t\t      NULL, NULL, NULL,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   free (wont_exit);\n \n@@ -1271,14 +1286,16 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n   sbitmap wont_exit;\n   unsigned nunroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n+  int ok;\n \n   wont_exit = sbitmap_alloc (nunroll + 1);\n   sbitmap_zero (wont_exit);\n \n-  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n-\t\tloops, nunroll, wont_exit, NULL, NULL, NULL,\n-\t\tDLTHE_FLAG_UPDATE_FREQ))\n-    abort ();\n+  ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\t\t\t      loops, nunroll, wont_exit,\n+\t\t\t\t      NULL, NULL, NULL,\n+\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n+  gcc_assert (ok);\n \n   free (wont_exit);\n "}, {"sha": "c39718b3f4958a7b2be4b5ecd8a2052842bc3668", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -103,13 +103,11 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n     {\n       /* A hack -- there seems to be no easy generic way how to make a\n \t conditional jump from a ccmode comparison.  */\n-      if (!cinsn)\n-\tabort ();\n+      gcc_assert (cinsn);\n       cond = XEXP (SET_SRC (pc_set (cinsn)), 0);\n-      if (GET_CODE (cond) != comp\n-\t  || !rtx_equal_p (op0, XEXP (cond, 0))\n-\t  || !rtx_equal_p (op1, XEXP (cond, 1)))\n-\tabort ();\n+      gcc_assert (GET_CODE (cond) == comp);\n+      gcc_assert (rtx_equal_p (op0, XEXP (cond, 0)));\n+      gcc_assert (rtx_equal_p (op1, XEXP (cond, 1)));\n       emit_jump_insn (copy_insn (PATTERN (cinsn)));\n       jump = get_last_insn ();\n       JUMP_LABEL (jump) = JUMP_LABEL (cinsn);\n@@ -118,8 +116,7 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n     }\n   else\n     {\n-      if (cinsn)\n-\tabort ();\n+      gcc_assert (!cinsn);\n \n       op0 = force_operand (op0, NULL_RTX);\n       op1 = force_operand (op1, NULL_RTX);\n@@ -379,8 +376,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n \n   /* Unswitch the loop on this condition.  */\n   nloop = unswitch_loop (loops, loop, bbs[i], cond, cinsn);\n-  if (!nloop)\n-  abort ();\n+  gcc_assert (nloop);\n \n   /* Invoke itself on modified loops.  */\n   unswitch_single_loop (loops, nloop, rconds, num + 1);\n@@ -412,19 +408,17 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   rtx seq;\n \n   /* Some sanity checking.  */\n-  if (!flow_bb_inside_loop_p (loop, unswitch_on))\n-    abort ();\n-  if (!unswitch_on->succ || !unswitch_on->succ->succ_next ||\n-      unswitch_on->succ->succ_next->succ_next)\n-    abort ();\n-  if (!just_once_each_iteration_p (loop, unswitch_on))\n-    abort ();\n-  if (loop->inner)\n-    abort ();\n-  if (!flow_bb_inside_loop_p (loop, unswitch_on->succ->dest))\n-    abort ();\n-  if (!flow_bb_inside_loop_p (loop, unswitch_on->succ->succ_next->dest))\n-    abort ();\n+  gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on));\n+\n+  gcc_assert (unswitch_on->succ);\n+  gcc_assert (unswitch_on->succ->succ_next);\n+  gcc_assert (!unswitch_on->succ->succ_next->succ_next);\n+\n+  gcc_assert (just_once_each_iteration_p (loop, unswitch_on));\n+  gcc_assert (!loop->inner);\n+  gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on->succ->dest));\n+  gcc_assert (flow_bb_inside_loop_p (loop,\n+\t\t\t\t     unswitch_on->succ->succ_next->dest));\n \n   entry = loop_preheader_edge (loop);\n "}, {"sha": "188a4020c408a1cf938a27c55686af63f322c76e", "filename": "gcc/loop.c", "status": "modified", "additions": 44, "deletions": 51, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -77,7 +77,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef HAVE_prefetch\n #define HAVE_prefetch 0\n #define CODE_FOR_prefetch 0\n-#define gen_prefetch(a,b,c) (abort(), NULL_RTX)\n+#define gen_prefetch(a,b,c) (gcc_unreachable(), NULL_RTX)\n #endif\n \n /* Give up the prefetch optimizations once we exceed a given threshold.\n@@ -501,8 +501,8 @@ loop_optimize (rtx f, FILE *dumpfile, int flags)\n \n   /* See if we went too far.  Note that get_max_uid already returns\n      one more that the maximum uid of all insn.  */\n-  if (get_max_uid () > max_uid_for_loop)\n-    abort ();\n+  gcc_assert (get_max_uid () <= max_uid_for_loop);\n+\n   /* Now reset it to the actual size we need.  See above.  */\n   max_uid_for_loop = get_max_uid ();\n \n@@ -1746,7 +1746,7 @@ rtx_equal_for_loop_p (rtx x, rtx y, struct loop_movables *movables,\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -1940,21 +1940,24 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \n \t\t  for (count = m->consec; count >= 0; count--)\n \t\t    {\n-\t\t      /* If this is the first insn of a library call sequence,\n-\t\t\t something is very wrong.  */\n-\t\t      if (!NOTE_P (p)\n-\t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n-\t\t\tabort ();\n-\n-\t\t      /* If this is the last insn of a libcall sequence, then\n-\t\t\t delete every insn in the sequence except the last.\n-\t\t\t The last insn is handled in the normal manner.  */\n-\t\t      if (!NOTE_P (p)\n-\t\t\t  && (temp = find_reg_note (p, REG_RETVAL, NULL_RTX)))\n+\t\t      if (!NOTE_P (p))\n \t\t\t{\n-\t\t\t  temp = XEXP (temp, 0);\n-\t\t\t  while (temp != p)\n-\t\t\t    temp = delete_insn (temp);\n+\t\t\t  /* If this is the first insn of a library call\n+\t\t\t     sequence, something is very wrong.  */\n+\t\t\t  gcc_assert (!find_reg_note (p, REG_LIBCALL,\n+\t\t\t\t\t\t      NULL_RTX));\n+\n+\t\t\t  /* If this is the last insn of a libcall sequence,\n+\t\t\t     then delete every insn in the sequence except\n+\t\t\t     the last. The last insn is handled in the\n+\t\t\t     normal manner.  */\n+\t\t\t  temp = find_reg_note (p, REG_RETVAL, NULL_RTX);\n+\t\t\t  if (temp)\n+\t\t\t    {\n+\t\t\t      temp = XEXP (temp, 0);\n+\t\t\t      while (temp != p)\n+\t\t\t\ttemp = delete_insn (temp);\n+\t\t\t    }\n \t\t\t}\n \n \t\t      temp = p;\n@@ -2118,8 +2121,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t\t\t<< GET_MODE_BITSIZE (m->savemode)))\n \t\t\t\t      - 1),\n \t\t\t     reg, 1, OPTAB_LIB_WIDEN);\n-\t\t\t  if (tem == 0)\n-\t\t\t    abort ();\n+\t\t\t  gcc_assert (tem != 0);\n \t\t\t  if (tem != reg)\n \t\t\t    emit_move_insn (reg, tem);\n \t\t\t  sequence = get_insns ();\n@@ -2407,8 +2409,7 @@ replace_call_address (rtx x, rtx reg, rtx addr)\n     case MEM:\n       /* If this MEM uses a reg other than the one we expected,\n \t something is wrong.  */\n-      if (XEXP (x, 0) != reg)\n-\tabort ();\n+      gcc_assert (XEXP (x, 0) == reg);\n       XEXP (x, 0) = addr;\n       return;\n \n@@ -2723,8 +2724,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t    break;\n \n \t  case NOTE_INSN_LOOP_END:\n-\t    if (! current_loop)\n-\t      abort ();\n+\t    gcc_assert (current_loop);\n \n \t    current_loop->end = insn;\n \t    current_loop = current_loop->outer;\n@@ -2912,6 +2912,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t\t    if (invert_jump (p, new_label, 1))\n \t\t      {\n \t\t\trtx q, r;\n+\t\t\tbool fail;\n \n \t\t\t/* If no suitable BARRIER was found, create a suitable\n \t\t\t   one before TARGET.  Since TARGET is a fall through\n@@ -2936,8 +2937,8 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \n \t\t\t/* Include the BARRIER after INSN and copy the\n \t\t\t   block after LOC.  */\n-\t\t\tif (squeeze_notes (&new_label, &last_insn_to_move))\n-\t\t\t  abort ();\n+\t\t\tfail = squeeze_notes (&new_label, &last_insn_to_move);\n+\t\t\tgcc_assert (!fail);\n \t\t\treorder_insns (new_label, last_insn_to_move, loc);\n \n \t\t\t/* All those insns are now in TARGET_LOOP.  */\n@@ -2972,8 +2973,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \n \t\t\t    /* If we didn't find it, then something is\n \t\t\t       wrong.  */\n-\t\t\t    if (! r)\n-\t\t\t      abort ();\n+\t\t\t    gcc_assert (r);\n \t\t\t  }\n \n \t\t\t/* P is now a jump outside the loop, so it must be put\n@@ -3683,7 +3683,7 @@ rtx_equal_for_prefetch_p (rtx x, rtx y)\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -5721,19 +5721,14 @@ record_giv (const struct loop *loop, struct induction *v, rtx insn,\n   /* Add the giv to the class of givs computed from one biv.  */\n \n   bl = REG_IV_CLASS (ivs, REGNO (src_reg));\n-  if (bl)\n-    {\n-      v->next_iv = bl->giv;\n-      bl->giv = v;\n-      /* Don't count DEST_ADDR.  This is supposed to count the number of\n-\t insns that calculate givs.  */\n-      if (type == DEST_REG)\n-\tbl->giv_count++;\n-      bl->total_benefit += benefit;\n-    }\n-  else\n-    /* Fatal error, biv missing for this giv?  */\n-    abort ();\n+  gcc_assert (bl);  /* Fatal error, biv missing for this giv?  */\n+  v->next_iv = bl->giv;\n+  bl->giv = v;\n+  /* Don't count DEST_ADDR.  This is supposed to count the number of\n+      insns that calculate givs.  */\n+  if (type == DEST_REG)\n+    bl->giv_count++;\n+  bl->total_benefit += benefit;\n \n   if (type == DEST_ADDR)\n     {\n@@ -6388,7 +6383,7 @@ general_induction_var (const struct loop *loop, rtx x, rtx *src_reg,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Remove any enclosing USE from ADD_VAL and MULT_VAL (there will be\n@@ -6507,7 +6502,7 @@ simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n \t\t\t\t ext_val, benefit);\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \n       /* Each argument must be either REG, PLUS, or MULT.  Convert REG to\n@@ -6648,7 +6643,7 @@ simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n \t\t\t\t    ext_val, benefit);\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n     case ASHIFT:\n@@ -7400,7 +7395,7 @@ check_ext_dependent_givs (const struct loop *loop, struct iv_class *bl)\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \n \tif (ok)\n@@ -10040,8 +10035,7 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n \t  && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) == regno)\n \t{\n-\t  if (init_insn)\n-\t    abort ();\n+\t  gcc_assert (!init_insn);\n \n \t  init_insn = insn;\n \t  if (REGNO_FIRST_UID (regno) == INSN_UID (insn))\n@@ -10074,8 +10068,7 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n \t    }\n \t}\n     }\n-  if (! init_insn)\n-    abort ();\n+  gcc_assert (init_insn);\n   if (apply_change_group ())\n     {\n       if (loop_dump_stream)\n@@ -10576,7 +10569,7 @@ loop_giv_dump (const struct induction *v, FILE *file, int verbose)\n \t  fprintf (file, \" ext tr\");\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n "}, {"sha": "0fef86edc7aab72b9e605397d82cb61abc7ea110", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -45,8 +45,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    of an insn added during loop, since these don't have LUIDs.  */\n \n #define INSN_LUID(INSN)\t\t\t\\\n-  (INSN_UID (INSN) < max_uid_for_loop ? uid_luid[INSN_UID (INSN)] \\\n-   : (abort (), -1))\n+  (gcc_assert (INSN_UID (INSN) < max_uid_for_loop), uid_luid[INSN_UID (INSN)])\n \n #define REGNO_FIRST_LUID(REGNO)\t\t\t\\\n   (REGNO_FIRST_UID (REGNO) < max_uid_for_loop\t\\"}, {"sha": "ae1ce4a49b1138b443091cc5a6afc3503ae21800", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -546,8 +546,7 @@ normalize_sched_times (partial_schedule_ptr ps)\n       ddg_node_ptr u = &g->nodes[i];\n       int normalized_time = SCHED_TIME (u) - amount;\n \n-      if (normalized_time < 0)\n-\tabort ();\n+      gcc_assert (normalized_time >= 0);\n \n       SCHED_TIME (u) = normalized_time;\n       SCHED_ROW (u) = normalized_time % ii;\n@@ -714,8 +713,8 @@ generate_prolog_epilog (partial_schedule_ptr ps, rtx orig_loop_beg,\n       label = XEXP (SET_SRC (cmp), 1);\n       cond = XEXP (SET_SRC (cmp), 0);\n \n-      if (! c_reg || GET_CODE (cond) != NE)\n-        abort ();\n+      gcc_assert (c_reg);\n+      gcc_assert (GET_CODE (cond) == NE);\n \n       XEXP (label, 0) = precond_exit_label;\n       JUMP_LABEL (orig_loop_bct) = precond_exit_label_insn;\n@@ -1025,8 +1024,8 @@ sms_schedule (FILE *dump_file)\n \t}\n \n       /* Make sure this is a doloop.  */\n-      if ( !(count_reg = doloop_register_get (tail, &comp)))\n-\tabort ();\n+      count_reg = doloop_register_get (tail, &comp);\n+      gcc_assert (count_reg);\n \n       /* This should be NULL_RTX if the count is unknown at compile time.  */\n       count_init = const_iteration_count (count_reg, pre_header, &loop_count);\n@@ -1457,8 +1456,9 @@ check_nodes_order (int *node_order, int num_nodes)\n     {\n       int u = node_order[i];\n \n-      if (u >= num_nodes || u < 0 || TEST_BIT (tmp, u))\n-\tabort ();\n+      gcc_assert (u < num_nodes);\n+      gcc_assert (u >= 0);\n+      gcc_assert (!TEST_BIT (tmp, u));\n \n       SET_BIT (tmp, u);\n     }"}, {"sha": "864e813099d4b39ef6201ef6cc758ff0e35baa7c", "filename": "gcc/optabs.c", "status": "modified", "additions": 44, "deletions": 70, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -119,7 +119,7 @@ static rtx expand_parity (enum machine_mode, rtx, rtx);\n \n #ifndef HAVE_conditional_trap\n #define HAVE_conditional_trap 0\n-#define gen_conditional_trap(a,b) (abort (), NULL_RTX)\n+#define gen_conditional_trap(a,b) (gcc_unreachable (), NULL_RTX)\n #endif\n \f\n /* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to\n@@ -138,10 +138,9 @@ add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n   rtx last_insn, insn, set;\n   rtx note;\n \n-  if (! insns\n-      || ! INSN_P (insns)\n-      || NEXT_INSN (insns) == NULL_RTX)\n-    abort ();\n+  gcc_assert (insns);\n+  gcc_assert (INSN_P (insns));\n+  gcc_assert (NEXT_INSN (insns) != NULL_RTX);\n \n   if (GET_RTX_CLASS (code) != RTX_COMM_ARITH\n       && GET_RTX_CLASS (code) != RTX_BIN_ARITH\n@@ -672,8 +671,7 @@ expand_simple_binop (enum machine_mode mode, enum rtx_code code, rtx op0,\n \t\t     enum optab_methods methods)\n {\n   optab binop = code_to_optab[(int) code];\n-  if (binop == 0)\n-    abort ();\n+  gcc_assert (binop != 0);\n \n   return expand_binop (mode, binop, op0, op1, target, unsignedp, methods);\n }\n@@ -1712,9 +1710,8 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n       /* We could handle this, but we should always be called with a pseudo\n \t for our targets and all insns should take them as outputs.  */\n-      if (! (*insn_data[icode].operand[0].predicate) (targ0, mode)\n-\t  || ! (*insn_data[icode].operand[1].predicate) (targ1, mode))\n-\tabort ();\n+      gcc_assert ((*insn_data[icode].operand[0].predicate) (targ0, mode));\n+      gcc_assert ((*insn_data[icode].operand[1].predicate) (targ1, mode));\n \n       pat = GEN_FCN (icode) (targ0, targ1, xop0);\n       if (pat)\n@@ -1841,9 +1838,8 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n       /* We could handle this, but we should always be called with a pseudo\n \t for our targets and all insns should take them as outputs.  */\n-      if (! (*insn_data[icode].operand[0].predicate) (targ0, mode)\n-\t  || ! (*insn_data[icode].operand[3].predicate) (targ1, mode))\n-\tabort ();\n+      gcc_assert ((*insn_data[icode].operand[0].predicate) (targ0, mode));\n+      gcc_assert ((*insn_data[icode].operand[3].predicate) (targ1, mode));\n \n       pat = GEN_FCN (icode) (targ0, xop0, xop1, targ1);\n       if (pat)\n@@ -1906,8 +1902,7 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n   rtx insns;\n \n   /* Exactly one of TARG0 or TARG1 should be non-NULL.  */\n-  if (!((targ0 != NULL_RTX) ^ (targ1 != NULL_RTX)))\n-    abort ();\n+  gcc_assert ((targ0 != NULL_RTX) ^ (targ1 != NULL_RTX));\n \n   mode = GET_MODE (op0);\n   if (!binoptab->handlers[(int) mode].libfunc)\n@@ -1944,8 +1939,7 @@ expand_simple_unop (enum machine_mode mode, enum rtx_code code, rtx op0,\n \t\t    rtx target, int unsignedp)\n {\n   optab unop = code_to_optab[(int) code];\n-  if (unop == 0)\n-    abort ();\n+  gcc_assert (unop != 0);\n \n   return expand_unop (mode, unop, op0, target, unsignedp);\n }\n@@ -2620,8 +2614,7 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n \t      }\n \t}\n \n-      if (set == 0)\n-\tabort ();\n+      gcc_assert (set != 0);\n \n       if (! reg_overlap_mentioned_p (target, SET_DEST (set)))\n \t{\n@@ -2932,7 +2925,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \n   /* They could both be VOIDmode if both args are immediate constants,\n      but we should fold that at an earlier stage.\n-     With no special code here, this will call abort,\n+     With no special code here, this will assert out,\n      reminding the programmer to implement such folding.  */\n \n   if (mode != BLKmode && flag_force_mem)\n@@ -2961,11 +2954,10 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n     y = force_reg (mode, y);\n \n #ifdef HAVE_cc0\n-  /* Abort if we have a non-canonical comparison.  The RTL documentation\n+  /* Assert out if we have a non-canonical comparison.  The RTL documentation\n      states that canonical comparisons are required only for targets which\n      have cc0.  */\n-  if (CONSTANT_P (x) && ! CONSTANT_P (y))\n-    abort ();\n+  gcc_assert (!CONSTANT_P (x) || CONSTANT_P (y));\n #endif\n \n   /* Don't let both operands fail to indicate the mode.  */\n@@ -2984,8 +2976,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       rtx opalign\n \t= GEN_INT (MIN (MEM_ALIGN (x), MEM_ALIGN (y)) / BITS_PER_UNIT);\n \n-      if (size == 0)\n-\tabort ();\n+      gcc_assert (size != 0);\n \n       /* Try to use a memory block compare insn - either cmpstr\n \t or cmpmem will do.  */\n@@ -3082,11 +3073,8 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       return;\n     }\n \n-  if (class == MODE_FLOAT)\n-    prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp);\n-\n-  else\n-    abort ();\n+  gcc_assert (class == MODE_FLOAT);\n+  prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp);\n }\n \n /* Before emitting an insn with code ICODE, make sure that X, which is going\n@@ -3126,7 +3114,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n   enum machine_mode wider_mode = mode;\n \n   /* Try combined insns first.  */\n-  do\n+  for (;;)\n     {\n       enum insn_code icode;\n       PUT_MODE (test, wider_mode);\n@@ -3169,15 +3157,12 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t  return;\n \t}\n \n-      if (class != MODE_INT && class != MODE_FLOAT\n-\t  && class != MODE_COMPLEX_FLOAT)\n-\tbreak;\n+      gcc_assert (class == MODE_INT || class == MODE_FLOAT\n+\t\t  || class == MODE_COMPLEX_FLOAT);\n \n       wider_mode = GET_MODE_WIDER_MODE (wider_mode);\n+      gcc_assert (wider_mode != VOIDmode);\n     }\n-  while (wider_mode != VOIDmode);\n-\n-  abort ();\n }\n \n /* Generate code to compare X with Y so that the condition codes are\n@@ -3208,8 +3193,7 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n     {\n       /* If we're not emitting a branch, this means some caller\n          is out of sync.  */\n-      if (! label)\n-\tabort ();\n+      gcc_assert (label);\n \n       op0 = y, op1 = x;\n       comparison = swap_condition (comparison);\n@@ -3280,8 +3264,7 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n \t}\n     }\n \n-  if (mode == VOIDmode)\n-    abort ();\n+  gcc_assert (mode != VOIDmode);\n \n   if (mode != orig_mode)\n     {\n@@ -3339,7 +3322,7 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  equiv = simplify_gen_ternary (IF_THEN_ELSE, word_mode, word_mode,\n \t\t\t\t\tequiv, true_rtx, false_rtx);\n@@ -3641,13 +3624,12 @@ gen_add2_insn (rtx x, rtx y)\n {\n   int icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n-  if (! ((*insn_data[icode].operand[0].predicate)\n-\t (x, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (x, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (y, insn_data[icode].operand[2].mode)))\n-    abort ();\n+  gcc_assert ((*insn_data[icode].operand[0].predicate)\n+\t       (x, insn_data[icode].operand[0].mode));\n+  gcc_assert ((*insn_data[icode].operand[1].predicate)\n+\t       (x, insn_data[icode].operand[1].mode));\n+  gcc_assert ((*insn_data[icode].operand[2].predicate)\n+\t       (y, insn_data[icode].operand[2].mode));\n \n   return (GEN_FCN (icode) (x, x, y));\n }\n@@ -3676,8 +3658,7 @@ have_add2_insn (rtx x, rtx y)\n {\n   int icode;\n \n-  if (GET_MODE (x) == VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (x) != VOIDmode);\n \n   icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n@@ -3702,13 +3683,12 @@ gen_sub2_insn (rtx x, rtx y)\n {\n   int icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n-  if (! ((*insn_data[icode].operand[0].predicate)\n-\t (x, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (x, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (y, insn_data[icode].operand[2].mode)))\n-    abort ();\n+  gcc_assert ((*insn_data[icode].operand[0].predicate)\n+\t       (x, insn_data[icode].operand[0].mode));\n+  gcc_assert ((*insn_data[icode].operand[1].predicate)\n+\t       (x, insn_data[icode].operand[1].mode));\n+  gcc_assert ((*insn_data[icode].operand[2].predicate)\n+\t       (y, insn_data[icode].operand[2].mode));\n \n   return (GEN_FCN (icode) (x, x, y));\n }\n@@ -3737,8 +3717,7 @@ have_sub2_insn (rtx x, rtx y)\n {\n   int icode;\n \n-  if (GET_MODE (x) == VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (x) != VOIDmode);\n \n   icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n@@ -3864,8 +3843,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n   enum machine_mode fmode, imode;\n \n   /* Crash now, because we won't be able to decide which mode to use.  */\n-  if (GET_MODE (from) == VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (from) != VOIDmode);\n \n   /* Look for an insn to do the conversion.  Do it in the specified\n      modes if possible; otherwise convert either input, output or both to\n@@ -4026,8 +4004,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \tfrom = force_not_mem (from);\n \n       libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n-      if (!libfunc)\n-\tabort ();\n+      gcc_assert (libfunc);\n \n       start_sequence ();\n \n@@ -4210,8 +4187,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n       convert_optab tab = unsignedp ? ufix_optab : sfix_optab;\n       libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n-      if (!libfunc)\n-\tabort ();\n+      gcc_assert (libfunc);\n \n       if (flag_force_mem)\n \tfrom = force_not_mem (from);\n@@ -4824,8 +4800,7 @@ debug_optab_libfuncs (void)\n \th = &o->handlers[j];\n \tif (h->libfunc)\n \t  {\n-\t    if (GET_CODE (h->libfunc) != SYMBOL_REF)\n-\t      abort ();\n+\t    gcc_assert (GET_CODE (h->libfunc) == SYMBOL_REF);\n \t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n \t\t     GET_RTX_NAME (o->code),\n \t\t     GET_MODE_NAME (j),\n@@ -4845,8 +4820,7 @@ debug_optab_libfuncs (void)\n \t  h = &o->handlers[j][k];\n \t  if (h->libfunc)\n \t    {\n-\t      if (GET_CODE (h->libfunc) != SYMBOL_REF)\n-\t\tabort ();\n+\t      gcc_assert (GET_CODE (h->libfunc) == SYMBOL_REF);\n \t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n \t\t       GET_RTX_NAME (o->code),\n \t\t       GET_MODE_NAME (j),"}, {"sha": "9b37f021ebc4ee66bdeb02cf85062d56418bbfd1", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -1003,10 +1003,8 @@ common_handle_option (size_t scode, const char *arg, int value)\n     default:\n       /* If the flag was handled in a standard way, assume the lack of\n \t processing here is intentional.  */\n-      if (cl_options[scode].flag_var)\n-\tbreak;\n-\n-      abort ();\n+      gcc_assert (cl_options[scode].flag_var);\n+      break;\n     }\n \n   return 1;"}, {"sha": "e1e60049d18cfaef8d12cd76ff5318d90e745fb9", "filename": "gcc/params.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -61,8 +61,7 @@ set_param_value (const char *name, int value)\n   size_t i;\n \n   /* Make sure nobody tries to set a parameter to an invalid value.  */\n-  if (value == INVALID_PARAM_VAL)\n-    abort ();\n+  gcc_assert (value != INVALID_PARAM_VAL);\n \n   /* Scan the parameter table to find a matching entry.  */\n   for (i = 0; i < num_compiler_params; ++i)"}, {"sha": "1386ff1fb3c47655afbbdce722a8ba3ebfd7664f", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -121,8 +121,8 @@ open_dump_file (enum tree_dump_index index, tree decl)\n \n   timevar_push (TV_DUMP);\n \n-  if (dump_file != NULL || dump_file_name != NULL)\n-    abort ();\n+  gcc_assert (!dump_file);\n+  gcc_assert (!dump_file_name);\n \n   dump_file_name = get_dump_file_name (index);\n   initializing_dump = !dump_initialized_p (index);\n@@ -289,11 +289,9 @@ rest_of_handle_final (void)\n        different from the DECL_NAME name used in the source file.  */\n \n     x = DECL_RTL (current_function_decl);\n-    if (!MEM_P (x))\n-      abort ();\n+    gcc_assert (MEM_P (x));\n     x = XEXP (x, 0);\n-    if (GET_CODE (x) != SYMBOL_REF)\n-      abort ();\n+    gcc_assert (GET_CODE (x) == SYMBOL_REF);\n     fnname = XSTR (x, 0);\n \n     assemble_start_function (current_function_decl, fnname);"}, {"sha": "7c0be2f7b74ea121a538cf80962ebea63fdb8510", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -305,9 +305,7 @@ expr_equiv_p (const void *exp1p, const void *exp2p)\n   struct expr *exp1 = (struct expr *) exp1p;\n   struct expr *exp2 = (struct expr *) exp2p;\n   int equiv_p = exp_equiv_p (exp1->expr, exp2->expr, 0, true);\n-  if (equiv_p\n-      && exp1->hash != exp2->hash)\n-    abort ();\n+  gcc_assert (!equiv_p || exp1->hash == exp2->hash);\n   return equiv_p;\n }\n \f\n@@ -485,11 +483,8 @@ oprs_unchanged_p (rtx x, rtx insn, bool after_insn)\n   switch (code)\n     {\n     case REG:\n-#ifdef ENABLE_CHECKING\n       /* We are called after register allocation.  */\n-      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-\tabort ();\n-#endif\n+      gcc_assert (REGNO (x) < FIRST_PSEUDO_REGISTER);\n       if (after_insn)\n \t/* If the last CUID setting the insn is less than the CUID of\n \t   INSN, then reg X is not changed in or after INSN.  */\n@@ -785,8 +780,7 @@ hash_scan_set (rtx insn)\n \n #ifdef ENABLE_CHEKCING\n   /* We shouldn't have any EH_REGION notes post reload.  */\n-  if (find_reg_note (insn, REG_EH_REGION, NULL_RTX))\n-    abort ();\n+  gcc_assert (!find_reg_note (insn, REG_EH_REGION, NULL_RTX));\n #endif\n \n   if (REG_P (dest))\n@@ -934,11 +928,9 @@ reg_set_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n   rtx insn;\n   int regno;\n \n-#ifdef ENABLE_CHECKING\n   /* We are called after register allocation.  */\n-  if (!REG_P (reg) || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n-#endif\n+  gcc_assert (REG_P (reg));\n+  gcc_assert (REGNO (reg) < FIRST_PSEUDO_REGISTER);\n \n   if (from_insn == to_insn)\n     return NULL_RTX;\n@@ -973,11 +965,9 @@ reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n   rtx insn;\n   int regno;\n \n-#ifdef ENABLE_CHECKING\n   /* We are called after register allocation.  */\n-  if (!REG_P (reg) || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n-#endif\n+  gcc_assert (REG_P (reg));\n+  gcc_assert (REGNO (reg) < FIRST_PSEUDO_REGISTER);\n \n   if (from_insn == to_insn)\n     return NULL_RTX;\n@@ -1027,7 +1017,7 @@ get_avail_load_store_reg (rtx insn)\n     return SET_DEST(PATTERN(insn));\n   if (REG_P (SET_SRC (PATTERN (insn))))  /* A store.  */\n     return SET_SRC (PATTERN (insn));\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Return nonzero if the predecessors of BB are \"well behaved\".  */\n@@ -1109,8 +1099,8 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n \t{\n \t  /* Check if the loaded register is not used.  */\n \t  avail_insn = a_occr->insn;\n-\t  if (! (avail_reg = get_avail_load_store_reg (avail_insn)))\n-\t    abort ();\n+\t  avail_reg = get_avail_load_store_reg (avail_insn);\n+\t  gcc_assert (avail_reg);\n \t  /* Make sure we can generate a move from register avail_reg to\n \t     dest.  */\n \t  extract_insn (gen_move_insn (copy_rtx (dest),\n@@ -1181,8 +1171,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n       /* Set avail_reg to be the register having the value of the\n \t memory.  */\n       avail_reg = get_avail_load_store_reg (avail_insn);\n-      if (! avail_reg)\n-\tabort ();\n+      gcc_assert (avail_reg);\n \n       insert_insn_on_edge (gen_move_insn (copy_rtx (dest),\n \t\t\t\t\t  copy_rtx (avail_reg)),"}, {"sha": "77689704cd611f3b295c64287b5cb26c8593eb3a", "filename": "gcc/postreload.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -280,7 +280,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \t\t  if (this_val == trunc_int_for_mode (this_val, GET_MODE (src)))\n \t\t    break;\n \t\tdefault:\n-\t\t  abort ();\n+\t\t  gcc_unreachable ();\n \t\t}\n \t      this_rtx = GEN_INT (this_val);\n \t    }\n@@ -1057,8 +1057,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n       if (REG_P (SET_DEST (x)))\n \t{\n \t  /* No spurious CLOBBERs of pseudo registers may remain.  */\n-\t  if (REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n+\t  gcc_assert (REGNO (SET_DEST (x)) < FIRST_PSEUDO_REGISTER);\n \t  return;\n \t}\n       break;\n@@ -1078,8 +1077,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n \tint nregs;\n \n \t/* No spurious USEs of pseudo registers may remain.  */\n-\tif (regno >= FIRST_PSEUDO_REGISTER)\n-\t  abort ();\n+\tgcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n \tnregs = hard_regno_nregs[regno][GET_MODE (x)];\n "}, {"sha": "2d1be03f1aaaeeb19a107c809a3a1a49631f3c99", "filename": "gcc/predict.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -179,8 +179,7 @@ tree_predicted_by_p (basic_block bb, enum br_predictor predictor)\n void\n predict_insn (rtx insn, enum br_predictor predictor, int probability)\n {\n-  if (!any_condjump_p (insn))\n-    abort ();\n+  gcc_assert (any_condjump_p (insn));\n   if (!flag_guess_branch_prob)\n     return;\n \n@@ -1106,8 +1105,7 @@ expected_value_to_br_prob (void)\n       cond = simplify_rtx (cond);\n \n       /* Turn the condition into a scaled branch probability.  */\n-      if (cond != const_true_rtx && cond != const0_rtx)\n-\tabort ();\n+      gcc_assert (cond == const_true_rtx || cond == const0_rtx);\n       predict_insn_def (insn, PRED_BUILTIN_EXPECT,\n \t\t        cond == const_true_rtx ? TAKEN : NOT_TAKEN);\n     }\n@@ -1208,8 +1206,8 @@ propagate_freq (struct loop *loop)\n \t{\n #ifdef ENABLE_CHECKING\n \t  for (e = bb->pred; e; e = e->pred_next)\n-\t    if (BLOCK_INFO (e->src)->tovisit && !(e->flags & EDGE_DFS_BACK))\n-\t      abort ();\n+\t    gcc_assert (!BLOCK_INFO (e->src)->tovisit\n+\t\t\t|| (e->flags & EDGE_DFS_BACK));\n #endif\n \n \t  for (e = bb->pred; e; e = e->pred_next)\n@@ -1353,8 +1351,7 @@ expensive_function_p (int threshold)\n \n   /* We can not compute accurately for large thresholds due to scaled\n      frequencies.  */\n-  if (threshold > BB_FREQ_MAX)\n-    abort ();\n+  gcc_assert (threshold < BB_FREQ_MAX);\n \n   /* Frequencies are out of range.  This either means that function contains\n      internal loop executing more than BB_FREQ_MAX times or profile feedback"}, {"sha": "3f5b4f16af50aaa05ed2a4ee213248688258751b", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -231,8 +231,7 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n           break;\n         }\n       /* We don't support precision beyond that of \"long long\".  */\n-      if (precision > 2)\n-        abort();\n+      gcc_assert (precision <= 2);\n \n       if (quoted)\n \tpp_string (pp, open_quote);\n@@ -319,25 +318,27 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n \t    int n;\n \t    const char *s;\n \t    /* We handle no precision specifier but '%.*s'.  */\n-\t    if (*++text->format_spec != '*')\n-\t      abort ();\n-\t    else if (*++text->format_spec != 's')\n-\t      abort ();\n+\t    ++text->format_spec;\n+\t    gcc_assert (*text->format_spec == '*');\n+\t    ++text->format_spec;\n+\t    gcc_assert (*text->format_spec == 's');\n \t    n = va_arg (*text->args_ptr, int);\n \t    s = va_arg (*text->args_ptr, const char *);\n \t    pp_append_text (pp, s, s + n);\n \t  }\n \t  break;\n \n \tdefault:\n-          if (!pp_format_decoder (pp) || !(*pp_format_decoder (pp)) (pp, text))\n-\t    {\n-\t      /* Hmmm.  The client failed to install a format translator\n-                 but called us with an unrecognized format.  Or, maybe, the\n-                 translated string just contains an invalid format, or\n-                 has formats in the wrong order.  Sorry.  */\n-\t      abort ();\n-\t    }\n+\t  {\n+\t    bool ok;\n+\n+\t    /* Make sure there's a format translator. */\n+\t    gcc_assert (pp_format_decoder (pp));\n+\t    ok = pp_format_decoder (pp) (pp, text);\n+\t    /* and make sure it recognized the format.  */\n+\t    gcc_assert (ok);\n+\t    break;\n+\t  }\n \t}\n       if (quoted)\n \tpp_string (pp, close_quote);"}, {"sha": "2472ab1f035b462fff6b8b12b461b7bd4f56e0e9", "filename": "gcc/profile.c", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c43d3ca812e7165d7a522d9380c394ba6d8ebd5/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=1c43d3ca812e7165d7a522d9380c394ba6d8ebd5", "patch": "@@ -149,8 +149,7 @@ instrument_edges (struct edge_list *el)\n \n \t  if (!inf->ignore && !inf->on_tree)\n \t    {\n-\t      if (e->flags & EDGE_ABNORMAL)\n-\t\tabort ();\n+\t      gcc_assert (!(e->flags & EDGE_ABNORMAL));\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Edge %d to %d instrumented%s\\n\",\n \t\t\t e->src->index, e->dest->index,\n@@ -196,7 +195,7 @@ instrument_values (histogram_values values)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       if (!coverage_counter_alloc (t, hist->n_counters))\n \tcontinue;\n@@ -220,7 +219,7 @@ instrument_values (histogram_values values)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -420,8 +419,7 @@ compute_branch_probabilities (void)\n \t\t  /* Calculate count for remaining edge by conservation.  */\n \t\t  total = bb->count - total;\n \n-\t\t  if (! e)\n-\t\t    abort ();\n+\t\t  gcc_assert (e);\n \t\t  EDGE_INFO (e)->count_valid = 1;\n \t\t  e->count = total;\n \t\t  bi->succ_count--;\n@@ -447,8 +445,7 @@ compute_branch_probabilities (void)\n \t\t  /* Calculate count for remaining edge by conservation.  */\n \t\t  total = bb->count - total + e->count;\n \n-\t\t  if (! e)\n-\t\t    abort ();\n+\t\t  gcc_assert (e);\n \t\t  EDGE_INFO (e)->count_valid = 1;\n \t\t  e->count = total;\n \t\t  bi->pred_count--;\n@@ -466,17 +463,18 @@ compute_branch_probabilities (void)\n   if (dump_file)\n     fprintf (dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n \n+#ifdef ENABLE_CHECKING\n   /* If the graph has been correctly solved, every block will have a\n      succ and pred count of zero.  */\n   FOR_EACH_BB (bb)\n     {\n-      if (BB_INFO (bb)->succ_count || BB_INFO (bb)->pred_count)\n-\tabort ();\n+      gcc_assert (!BB_INFO (bb)->succ_count);\n+      gcc_assert (!BB_INFO (bb)->pred_count);\n     }\n-\n+#endif\n+  \n   /* For every edge, calculate its branch probability and add a reg_note\n      to the branch insn to indicate this.  */\n-\n   for (i = 0; i < 20; i++)\n     hist_br_prob[i] = 0;\n   num_never_executed = 0;\n@@ -984,8 +982,7 @@ branch_prob (void)\n     {\n       unsigned n_instrumented = instrument_edges (el);\n \n-      if (n_instrumented != num_instrumented)\n-\tabort ();\n+      gcc_assert (n_instrumented == num_instrumented);\n \n       if (flag_profile_values)\n \tinstrument_values (values);\n@@ -1044,8 +1041,7 @@ union_groups (basic_block bb1, basic_block bb2)\n \n   /* ??? I don't have a place for the rank field.  OK.  Lets go w/o it,\n      this code is unlikely going to be performance problem anyway.  */\n-  if (bb1g == bb2g)\n-    abort ();\n+  gcc_assert (bb1g != bb2g);\n \n   bb1g->aux = bb2g;\n }\n@@ -1190,8 +1186,7 @@ void\n tree_register_profile_hooks (void)\n {\n   profile_hooks = &tree_profile_hooks;\n-  if (!ir_type ())\n-    abort ();\n+  gcc_assert (ir_type ());\n }\n \n /* Set up hooks to enable RTL-based profiling.  */\n@@ -1200,6 +1195,5 @@ void\n rtl_register_profile_hooks (void)\n {\n   profile_hooks = &rtl_profile_hooks;\n-  if (ir_type ())\n-    abort ();\n+  gcc_assert (!ir_type ());\n }"}]}