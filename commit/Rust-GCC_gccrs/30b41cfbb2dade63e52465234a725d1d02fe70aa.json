{"sha": "30b41cfbb2dade63e52465234a725d1d02fe70aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBiNDFjZmJiMmRhZGU2M2U1MjQ2NTIzNGE3MjVkMWQwMmZlNzBhYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-10T14:39:15Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-10T14:42:09Z"}, "message": "libstdc++: handle small max_blocks_per_chunk in pool resources [PR 94160]\n\nWhen a pool resource is constructed with max_blocks_per_chunk=1 it ends\nup creating a pool with blocks_per_chunk=0 which means it never\nallocates anything. Instead it returns null pointers, which should be\nimpossible.\n\nTo avoid this problem, round the max_blocks_per_chunk value to a\nmultiple of four, so it's never smaller than four.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/94160\n\t* src/c++17/memory_resource.cc (munge_options): Round\n\tmax_blocks_per_chunk to a multiple of four.\n\t(__pool_resource::_M_alloc_pools()): Simplify slightly.\n\t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc:\n\tCheck that valid pointers are returned when small values are\n\tused for max_blocks_per_chunk.", "tree": {"sha": "4f573dfe983bb67429b910e2f42f099496bb2e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f573dfe983bb67429b910e2f42f099496bb2e25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30b41cfbb2dade63e52465234a725d1d02fe70aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b41cfbb2dade63e52465234a725d1d02fe70aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30b41cfbb2dade63e52465234a725d1d02fe70aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b41cfbb2dade63e52465234a725d1d02fe70aa/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e718ec51a223d65a09757b999202390871b778d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e718ec51a223d65a09757b999202390871b778d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e718ec51a223d65a09757b999202390871b778d"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "c04ea6a5da4eca9fbb67f876459394864b18cd6c", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b41cfbb2dade63e52465234a725d1d02fe70aa/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b41cfbb2dade63e52465234a725d1d02fe70aa/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=30b41cfbb2dade63e52465234a725d1d02fe70aa", "patch": "@@ -898,7 +898,18 @@ namespace pmr\n       }\n     else\n       {\n-\t// TODO round to preferred granularity ?\n+\t// Round to preferred granularity.\n+\tif (opts.max_blocks_per_chunk < size_t(-4))\n+\t  {\n+\t    // round up\n+\t    opts.max_blocks_per_chunk\n+\t      = aligned_ceil(opts.max_blocks_per_chunk, 4);\n+\t  }\n+\telse\n+\t  {\n+\t    // round down\n+\t    opts.max_blocks_per_chunk &= ~size_t(3);\n+\t  }\n       }\n \n     if (opts.max_blocks_per_chunk > chunk::max_blocks_per_chunk())\n@@ -1039,11 +1050,9 @@ namespace pmr\n \t  : pool_sizes[i];\n \n \t// Decide on initial number of blocks per chunk.\n-\t// Always have at least 16 blocks per chunk:\n-\tconst size_t min_blocks_per_chunk = 16;\n-\t// But for smaller blocks, use a larger initial size:\n-\tsize_t blocks_per_chunk\n-\t  = std::max(1024 / block_size, min_blocks_per_chunk);\n+\t// At least 16 blocks per chunk seems reasonable,\n+\t// more for smaller blocks:\n+\tsize_t blocks_per_chunk = std::max(size_t(16), 1024 / block_size);\n \t// But don't exceed the requested max_blocks_per_chunk:\n \tblocks_per_chunk\n \t  = std::min(blocks_per_chunk, _M_opts.max_blocks_per_chunk);"}, {"sha": "526b7ede13a441d3d84700d84535cff566e8a32e", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b41cfbb2dade63e52465234a725d1d02fe70aa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b41cfbb2dade63e52465234a725d1d02fe70aa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc?ref=30b41cfbb2dade63e52465234a725d1d02fe70aa", "patch": "@@ -300,6 +300,25 @@ test07()\n   }\n }\n \n+void\n+test08()\n+{\n+  std::pmr::pool_options opts;\n+  opts.largest_required_pool_block = 64;\n+\n+  // PR libstdc++/94160\n+  // max_blocks_per_chunk=1 causes pool resources to return null pointers\n+  for (int i = 0; i < 8; ++i)\n+  {\n+    opts.max_blocks_per_chunk = i;\n+    std::pmr::unsynchronized_pool_resource upr(opts);\n+    auto* p = (int*)upr.allocate(4);\n+    VERIFY( p != nullptr );\n+    *p = i;\n+    upr.deallocate(p, 4);\n+  }\n+}\n+\n int\n main()\n {\n@@ -310,4 +329,5 @@ main()\n   test05();\n   test06();\n   test07();\n+  test08();\n }"}]}