{"sha": "bcb34aa3dd4fa492255c0166b1777610962368bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNiMzRhYTNkZDRmYTQ5MjI1NWMwMTY2YjE3Nzc2MTA5NjIzNjhiYg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-03-18T13:52:33Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-03-18T13:52:33Z"}, "message": "combine.c (gen_binary): Remove.\n\n2005-03-01  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* combine.c (gen_binary): Remove.\n\t(known_cond, simplify_shift_const, find_split_point,\n\tcombine_simplify_rtx, simplify_if_then_else, simplify_set,\n\tsimplify_logical, expand_field_assignment, extract_left_shift,\n\tforce_to_mode, if_then_else_cond, apply_distributive_law,\n\tsimplify_and_const_int, simplify_shift_const, gen_lowpart_for_combine,\n\tsimplify_comparison, reversed_comparison): Replace with\n\tsimplify_gen_binary, simplify_gen_relational or\n\tdistribute_and_simplify_rtx.\n\t(distribute_and_simplify_rtx): New function.\n\nFrom-SVN: r96681", "tree": {"sha": "11fd9d6d29cd9caec706b2beeee296f6a37c1e26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11fd9d6d29cd9caec706b2beeee296f6a37c1e26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcb34aa3dd4fa492255c0166b1777610962368bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb34aa3dd4fa492255c0166b1777610962368bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcb34aa3dd4fa492255c0166b1777610962368bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb34aa3dd4fa492255c0166b1777610962368bb/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a0c4f5a502fb59ff2e5e0bb1598fd64e66c68e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0c4f5a502fb59ff2e5e0bb1598fd64e66c68e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0c4f5a502fb59ff2e5e0bb1598fd64e66c68e3"}], "stats": {"total": 606, "additions": 317, "deletions": 289}, "files": [{"sha": "bdd94e44e37e74400c619a3ace025a0afd259406", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb34aa3dd4fa492255c0166b1777610962368bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb34aa3dd4fa492255c0166b1777610962368bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcb34aa3dd4fa492255c0166b1777610962368bb", "patch": "@@ -1,3 +1,16 @@\n+2005-03-01  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* combine.c (gen_binary): Remove.\n+\t(known_cond, simplify_shift_const, find_split_point,\n+\tcombine_simplify_rtx, simplify_if_then_else, simplify_set,\n+\tsimplify_logical, expand_field_assignment, extract_left_shift,\n+\tforce_to_mode, if_then_else_cond, apply_distributive_law,\n+\tsimplify_and_const_int, simplify_shift_const, gen_lowpart_for_combine,\n+\tsimplify_comparison, reversed_comparison): Replace with\n+\tsimplify_gen_binary, simplify_gen_relational or\n+\tdistribute_and_simplify_rtx.\n+\t(distribute_and_simplify_rtx): New function.\n+\n 2005-03-18  Alexey Neyman  <alex.neyman@auriga.ru>\n \t    Paolo Bonzini  <gcc.gnu.org>\n "}, {"sha": "d6ec6ac69c3ed2c54b48c8c5bde821a5b5548128", "filename": "gcc/combine.c", "status": "modified", "additions": 304, "deletions": 289, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcb34aa3dd4fa492255c0166b1777610962368bb/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcb34aa3dd4fa492255c0166b1777610962368bb/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bcb34aa3dd4fa492255c0166b1777610962368bb", "patch": "@@ -386,6 +386,7 @@ static rtx known_cond (rtx, enum rtx_code, rtx, rtx);\n static int rtx_equal_for_field_assignment_p (rtx, rtx);\n static rtx make_field_assignment (rtx);\n static rtx apply_distributive_law (rtx);\n+static rtx distribute_and_simplify_rtx (rtx, int);\n static rtx simplify_and_const_int (rtx, enum machine_mode, rtx,\n \t\t\t\t   unsigned HOST_WIDE_INT);\n static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n@@ -394,7 +395,6 @@ static rtx simplify_shift_const\t(rtx, enum rtx_code, enum machine_mode, rtx,\n \t\t\t\t int);\n static int recog_for_combine (rtx *, rtx, rtx *);\n static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n-static rtx gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);\n static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n static void update_table_tick (rtx);\n static void record_value_for_reg (rtx, rtx, rtx);\n@@ -3211,14 +3211,16 @@ find_split_point (rtx *loc, rtx insn)\n \n \t  if (src == mask)\n \t    SUBST (SET_SRC (x),\n-\t\t   gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n+\t\t   simplify_gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n \t  else\n-\t    SUBST (SET_SRC (x),\n-\t\t   gen_binary (IOR, mode,\n-\t\t\t       gen_binary (AND, mode, dest,\n-\t\t\t\t\t   gen_int_mode (~(mask << pos),\n-\t\t\t\t\t\t\t mode)),\n-\t\t\t       GEN_INT (src << pos)));\n+\t    {\n+\t      rtx negmask = gen_int_mode (~(mask << pos), mode);\n+\t      SUBST (SET_SRC (x),\n+\t\t     simplify_gen_binary (IOR, mode,\n+\t\t\t\t          simplify_gen_binary (AND, mode,\n+\t\t\t\t\t\t\t       dest, negmask),\n+\t\t\t\t\t  GEN_INT (src << pos)));\n+\t    }\n \n \t  SUBST (SET_DEST (x), dest);\n \n@@ -3792,7 +3794,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       new = simplify_shift_const (NULL_RTX, ASHIFTRT, mode, new,\n \t\t\t\t  INTVAL (XEXP (XEXP (x, 0), 1)));\n \n-      SUBST (XEXP (x, 0), gen_binary (PLUS, mode, new, temp));\n+      SUBST (XEXP (x, 0), simplify_gen_binary (PLUS, mode, new, temp));\n     }\n \n   /* If this is a simple operation applied to an IF_THEN_ELSE, try\n@@ -3849,21 +3851,24 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t      /* If the result values are STORE_FLAG_VALUE and zero, we can\n \t\t just make the comparison operation.  */\n \t      if (true_rtx == const_true_rtx && false_rtx == const0_rtx)\n-\t\tx = gen_binary (cond_code, mode, cond, cop1);\n+\t\tx = simplify_gen_relational (cond_code, mode, VOIDmode,\n+\t\t\t\t\t     cond, cop1);\n \t      else if (true_rtx == const0_rtx && false_rtx == const_true_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n-\t\tx = gen_binary (reversed, mode, cond, cop1);\n+\t\tx = simplify_gen_relational (reversed, mode, VOIDmode,\n+\t\t\t\t\t     cond, cop1);\n \n \t      /* Likewise, we can make the negate of a comparison operation\n \t\t if the result values are - STORE_FLAG_VALUE and zero.  */\n \t      else if (GET_CODE (true_rtx) == CONST_INT\n \t\t       && INTVAL (true_rtx) == - STORE_FLAG_VALUE\n \t\t       && false_rtx == const0_rtx)\n \t\tx = simplify_gen_unary (NEG, mode,\n-\t\t\t\t\tgen_binary (cond_code, mode, cond,\n-\t\t\t\t\t\t    cop1),\n+\t\t\t\t\tsimplify_gen_relational (cond_code,\n+\t\t\t\t\t\t\t\t mode, VOIDmode,\n+\t\t\t\t\t\t\t\t cond, cop1),\n \t\t\t\t\tmode);\n \t      else if (GET_CODE (false_rtx) == CONST_INT\n \t\t       && INTVAL (false_rtx) == - STORE_FLAG_VALUE\n@@ -3872,13 +3877,17 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n \t\tx = simplify_gen_unary (NEG, mode,\n-\t\t\t\t\tgen_binary (reversed, mode,\n-\t\t\t\t\t\t    cond, cop1),\n+\t\t\t\t\tsimplify_gen_relational (reversed,\n+\t\t\t\t\t\t\t\t mode, VOIDmode,\n+\t\t\t\t\t\t\t\t cond, cop1),\n \t\t\t\t\tmode);\n \t      else\n \t\treturn gen_rtx_IF_THEN_ELSE (mode,\n-\t\t\t\t\t     gen_binary (cond_code, VOIDmode,\n-\t\t\t\t\t\t\t cond, cop1),\n+\t\t\t\t\t     simplify_gen_relational (cond_code,\n+\t\t\t\t\t\t\t\t      mode,\n+\t\t\t\t\t\t\t\t      VOIDmode,\n+\t\t\t\t\t\t\t\t      cond,\n+\t\t\t\t\t\t\t\t      cop1),\n \t\t\t\t\t     true_rtx, false_rtx);\n \n \t      code = GET_CODE (x);\n@@ -3981,7 +3990,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t    }\n \n \t  if (inner)\n-\t    return gen_binary (code, mode, other, inner);\n+\t    return simplify_gen_binary (code, mode, other, inner);\n \t}\n     }\n \n@@ -4083,7 +4092,8 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       if (GET_CODE (XEXP (x, 0)) == XOR\n \t  && XEXP (XEXP (x, 0), 1) == const1_rtx\n \t  && nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n-\treturn gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n+\treturn simplify_gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t    constm1_rtx);\n \n       temp = expand_compound_operation (XEXP (x, 0));\n \n@@ -4311,8 +4321,9 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = XEXP (XEXP (XEXP (x, 0), 0), 0);\n \t  in2 = XEXP (XEXP (x, 0), 1);\n-\t  return gen_binary (MINUS, mode, XEXP (x, 1),\n-\t\t\t     gen_binary (MULT, mode, in1, in2));\n+\t  return simplify_gen_binary (MINUS, mode, XEXP (x, 1),\n+\t\t\t\t      simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t\t\t   in1, in2));\n \t}\n \n       /* If we have (plus (plus (A const) B)), associate it so that CONST is\n@@ -4321,10 +4332,11 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t they are now checked elsewhere.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && CONSTANT_ADDRESS_P (XEXP (XEXP (x, 0), 1)))\n-\treturn gen_binary (PLUS, mode,\n-\t\t\t   gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t       XEXP (x, 1)),\n-\t\t\t   XEXP (XEXP (x, 0), 1));\n+\treturn simplify_gen_binary (PLUS, mode,\n+\t\t\t   \t    simplify_gen_binary (PLUS, mode,\n+\t\t\t\t\t\t\t XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t\t\t XEXP (x, 1)),\n+\t\t\t\t    XEXP (XEXP (x, 0), 1));\n \n       /* (plus (xor (and <foo> (const_int pow2 - 1)) <c>) <-c>)\n \t when c is (const_int (pow2 + 1) / 2) is a sign extension of a\n@@ -4390,7 +4402,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t      & nonzero_bits (XEXP (x, 1), mode)) == 0)\n \t{\n \t  /* Try to simplify the expression further.  */\n-\t  rtx tor = gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n+\t  rtx tor = simplify_gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n \t  temp = combine_simplify_rtx (tor, mode, in_dest);\n \n \t  /* If we could, great.  If not, do not go ahead with the IOR\n@@ -4430,8 +4442,10 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = XEXP (XEXP (XEXP (x, 1), 0), 0);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n-\t  return gen_binary (PLUS, mode, gen_binary (MULT, mode, in1, in2),\n-\t\t\t     XEXP (x, 0));\n+\t  return simplify_gen_binary (PLUS, mode,\n+\t\t\t\t      simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t\t\t   in1, in2),\n+\t\t\t\t      XEXP (x, 0));\n \t}\n \n       /* Canonicalize (minus (neg A) (mult B C)) to\n@@ -4443,17 +4457,20 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = simplify_gen_unary (NEG, mode, XEXP (XEXP (x, 1), 0), mode);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n-\t  return gen_binary (MINUS, mode, gen_binary (MULT, mode, in1, in2),\n-\t\t\t     XEXP (XEXP (x, 0), 0));\n+\t  return simplify_gen_binary (MINUS, mode,\n+\t\t\t\t      simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t\t\t   in1, in2),\n+\t\t\t\t      XEXP (XEXP (x, 0), 0));\n \t}\n \n       /* Canonicalize (minus A (plus B C)) to (minus (minus A B) C) for\n \t integers.  */\n       if (GET_CODE (XEXP (x, 1)) == PLUS && INTEGRAL_MODE_P (mode))\n-\treturn gen_binary (MINUS, mode,\n-\t\t\t   gen_binary (MINUS, mode, XEXP (x, 0),\n-\t\t\t\t       XEXP (XEXP (x, 1), 0)),\n-\t\t\t   XEXP (XEXP (x, 1), 1));\n+\treturn simplify_gen_binary (MINUS, mode,\n+\t\t\t\t    simplify_gen_binary (MINUS, mode,\n+\t\t\t\t\t\t\t XEXP (x, 0),\n+\t\t\t\t\t\t         XEXP (XEXP (x, 1), 0)),\n+\t\t\t\t    XEXP (XEXP (x, 1), 1));\n       break;\n \n     case MULT:\n@@ -4463,17 +4480,11 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n       if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (PLUS, mode,\n-\t\t\t gen_binary (MULT, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 0), XEXP (x, 1)),\n-\t\t\t gen_binary (MULT, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 1),\n-\t\t\t\t     copy_rtx (XEXP (x, 1)))));\n-\n-\t  if (GET_CODE (x) != MULT)\n-\t    return x;\n+\t  rtx result = distribute_and_simplify_rtx (x, 0);\n+\t  if (result)\n+\t    return result;\n \t}\n+\n       /* Try simplify a*(b/c) as (a*b)/c.  */\n       if (FLOAT_MODE_P (mode) && flag_unsafe_math_optimizations\n \t  && GET_CODE (XEXP (x, 0)) == DIV)\n@@ -4482,7 +4493,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t\t\t       XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t       XEXP (x, 1));\n \t  if (tem)\n-\t    return gen_binary (DIV, mode, tem, XEXP (XEXP (x, 0), 1));\n+\t    return simplify_gen_binary (DIV, mode, tem, XEXP (XEXP (x, 0), 1));\n \t}\n       break;\n \n@@ -4562,9 +4573,9 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return gen_binary (XOR, mode,\n-\t\t\t\t gen_lowpart (mode, op0),\n-\t\t\t\t const1_rtx);\n+\t      return simplify_gen_binary (XOR, mode,\n+\t\t\t\t\t  gen_lowpart (mode, op0),\n+\t\t\t\t\t  const1_rtx);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == 1\n@@ -4806,7 +4817,8 @@ simplify_if_then_else (rtx x)\n \n   /* Simplify storing of the truth value.  */\n   if (comparison_p && true_rtx == const_true_rtx && false_rtx == const0_rtx)\n-    return gen_binary (true_code, mode, XEXP (cond, 0), XEXP (cond, 1));\n+    return simplify_gen_relational (true_code, mode, VOIDmode,\n+\t\t\t\t    XEXP (cond, 0), XEXP (cond, 1));\n \n   /* Also when the truth value has to be reversed.  */\n   if (comparison_p\n@@ -4956,16 +4968,16 @@ simplify_if_then_else (rtx x)\n       {\n       case GE:\n       case GT:\n-\treturn gen_binary (SMAX, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (SMAX, mode, true_rtx, false_rtx);\n       case LE:\n       case LT:\n-\treturn gen_binary (SMIN, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (SMIN, mode, true_rtx, false_rtx);\n       case GEU:\n       case GTU:\n-\treturn gen_binary (UMAX, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (UMAX, mode, true_rtx, false_rtx);\n       case LEU:\n       case LTU:\n-\treturn gen_binary (UMIN, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (UMIN, mode, true_rtx, false_rtx);\n       default:\n \tbreak;\n       }\n@@ -5078,12 +5090,14 @@ simplify_if_then_else (rtx x)\n \n       if (z)\n \t{\n-\t  temp = subst (gen_binary (true_code, m, cond_op0, cond_op1),\n+\t  temp = subst (simplify_gen_relational (true_code, m, VOIDmode,\n+\t\t\t\t\t\t cond_op0, cond_op1),\n \t\t\tpc_rtx, pc_rtx, 0, 0);\n-\t  temp = gen_binary (MULT, m, temp,\n-\t\t\t     gen_binary (MULT, m, c1, const_true_rtx));\n+\t  temp = simplify_gen_binary (MULT, m, temp,\n+\t\t\t\t      simplify_gen_binary (MULT, m, c1,\n+\t\t\t\t\t\t\t   const_true_rtx));\n \t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n-\t  temp = gen_binary (op, m, gen_lowpart (m, z), temp);\n+\t  temp = simplify_gen_binary (op, m, gen_lowpart (m, z), temp);\n \n \t  if (extend_op != UNKNOWN)\n \t    temp = simplify_gen_unary (extend_op, mode, temp, m);\n@@ -5268,7 +5282,8 @@ simplify_set (rtx x)\n \t\t  PUT_CODE (*cc_use, old_code);\n \t\t  other_changed = 0;\n \n-\t\t  op0 = gen_binary (XOR, GET_MODE (op0), op0, GEN_INT (mask));\n+\t\t  op0 = simplify_gen_binary (XOR, GET_MODE (op0),\n+\t\t\t\t\t     op0, GEN_INT (mask));\n \t\t}\n \t    }\n \t}\n@@ -5432,18 +5447,19 @@ simplify_set (rtx x)\n \t       && rtx_equal_p (XEXP (false_rtx, 1), true_rtx))\n \tterm1 = true_rtx, false_rtx = XEXP (false_rtx, 0), true_rtx = const0_rtx;\n \n-      term2 = gen_binary (AND, GET_MODE (src),\n-\t\t\t  XEXP (XEXP (src, 0), 0), true_rtx);\n-      term3 = gen_binary (AND, GET_MODE (src),\n-\t\t\t  simplify_gen_unary (NOT, GET_MODE (src),\n-\t\t\t\t\t      XEXP (XEXP (src, 0), 0),\n-\t\t\t\t\t      GET_MODE (src)),\n-\t\t\t  false_rtx);\n+      term2 = simplify_gen_binary (AND, GET_MODE (src),\n+\t\t\t\t   XEXP (XEXP (src, 0), 0), true_rtx);\n+      term3 = simplify_gen_binary (AND, GET_MODE (src),\n+\t\t\t\t   simplify_gen_unary (NOT, GET_MODE (src),\n+\t\t\t\t\t\t       XEXP (XEXP (src, 0), 0),\n+\t\t\t\t\t\t       GET_MODE (src)),\n+\t\t\t\t   false_rtx);\n \n       SUBST (SET_SRC (x),\n-\t     gen_binary (IOR, GET_MODE (src),\n-\t\t\t gen_binary (IOR, GET_MODE (src), term1, term2),\n-\t\t\t term3));\n+\t     simplify_gen_binary (IOR, GET_MODE (src),\n+\t\t\t\t  simplify_gen_binary (IOR, GET_MODE (src),\n+\t\t\t\t\t\t       term1, term2),\n+\t\t\t\t  term3));\n \n       src = SET_SRC (x);\n     }\n@@ -5478,29 +5494,31 @@ simplify_logical (rtx x)\n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 0), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode,\n-\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n-\t\t\top1);\n+\tx = simplify_gen_binary (AND, mode,\n+\t\t\t\t simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t     XEXP (op0, 1), mode),\n+\t\t\t\t op1);\n \n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode,\n-\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n-\t\t\top1);\n+\tx = simplify_gen_binary (AND, mode,\n+\t\t\t\t simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t     XEXP (op0, 0), mode),\n+\t\t\t\t op1);\n \n       /* Similarly for (~(A ^ B)) & A.  */\n       if (GET_CODE (op0) == NOT\n \t  && GET_CODE (XEXP (op0, 0)) == XOR\n \t  && rtx_equal_p (XEXP (XEXP (op0, 0), 0), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 1), op1);\n+\tx = simplify_gen_binary (AND, mode, XEXP (XEXP (op0, 0), 1), op1);\n \n       if (GET_CODE (op0) == NOT\n \t  && GET_CODE (XEXP (op0, 0)) == XOR\n \t  && rtx_equal_p (XEXP (XEXP (op0, 0), 1), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 0), op1);\n+\tx = simplify_gen_binary (AND, mode, XEXP (XEXP (op0, 0), 0), op1);\n \n       /* We can call simplify_and_const_int only if we don't lose\n \t any (sign) bits when converting INTVAL (op1) to\n@@ -5520,8 +5538,9 @@ simplify_logical (rtx x)\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && GET_CODE (op1) == CONST_INT\n \t      && (INTVAL (XEXP (op0, 1)) & INTVAL (op1)) != 0)\n-\t    return gen_binary (IOR, mode,\n-\t\t\t       gen_binary (AND, mode, XEXP (op0, 0),\n+\t    return simplify_gen_binary (IOR, mode,\n+\t\t\t\t        simplify_gen_binary\n+\t\t\t\t\t  (AND, mode, XEXP (op0, 0),\n \t\t\t\t\t   GEN_INT (INTVAL (XEXP (op0, 1))\n \t\t\t\t\t\t    & ~INTVAL (op1))), op1);\n \n@@ -5540,54 +5559,21 @@ simplify_logical (rtx x)\n \t  && ! side_effects_p (XEXP (op0, 1)))\n \treturn op1;\n \n-      /* In the following group of tests (and those in case IOR below),\n-\t we start with some combination of logical operations and apply\n-\t the distributive law followed by the inverse distributive law.\n-\t Most of the time, this results in no change.  However, if some of\n-\t the operands are the same or inverses of each other, simplifications\n-\t will result.\n-\n-\t For example, (and (ior A B) (not B)) can occur as the result of\n-\t expanding a bit field assignment.  When we apply the distributive\n-\t law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n-\t which then simplifies to (and (A (not B))).\n-\n-\t If we have (and (ior A B) C), apply the distributive law and then\n-\t the inverse distributive law to see if things simplify.  */\n-\n+      /* If we have any of (and (ior A B) C) or (and (xor A B) C),\n+\t apply the distributive law and then the inverse distributive\n+\t law to see if things simplify.  */\n       if (GET_CODE (op0) == IOR || GET_CODE (op0) == XOR)\n \t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (GET_CODE (op0), mode,\n-\t\t\t gen_binary (AND, mode, XEXP (op0, 0), op1),\n-\t\t\t gen_binary (AND, mode, XEXP (op0, 1),\n-\t\t\t\t     copy_rtx (op1))));\n-\t  if (GET_CODE (x) != AND)\n-\t    return x;\n+\t  rtx result = distribute_and_simplify_rtx (x, 0);\n+\t  if (result)\n+\t    return result;\n \t}\n-\n       if (GET_CODE (op1) == IOR || GET_CODE (op1) == XOR)\n-\treturn apply_distributive_law\n-\t  (gen_binary (GET_CODE (op1), mode,\n-\t\t       gen_binary (AND, mode, XEXP (op1, 0), op0),\n-\t\t       gen_binary (AND, mode, XEXP (op1, 1),\n-\t\t\t\t   copy_rtx (op0))));\n-\n-      /* Similarly, taking advantage of the fact that\n-\t (and (not A) (xor B C)) == (xor (ior A B) (ior A C))  */\n-\n-      if (GET_CODE (op0) == NOT && GET_CODE (op1) == XOR)\n-\treturn apply_distributive_law\n-\t  (gen_binary (XOR, mode,\n-\t\t       gen_binary (IOR, mode, XEXP (op0, 0), XEXP (op1, 0)),\n-\t\t       gen_binary (IOR, mode, copy_rtx (XEXP (op0, 0)),\n-\t\t\t\t   XEXP (op1, 1))));\n-\n-      else if (GET_CODE (op1) == NOT && GET_CODE (op0) == XOR)\n-\treturn apply_distributive_law\n-\t  (gen_binary (XOR, mode,\n-\t\t       gen_binary (IOR, mode, XEXP (op1, 0), XEXP (op0, 0)),\n-\t\t       gen_binary (IOR, mode, copy_rtx (XEXP (op1, 0)), XEXP (op0, 1))));\n+\t{\n+\t  rtx result = distribute_and_simplify_rtx (x, 1);\n+\t  if (result)\n+\t    return result;\n+\t}\n       break;\n \n     case IOR:\n@@ -5610,28 +5596,16 @@ simplify_logical (rtx x)\n \n       if (GET_CODE (op0) == AND)\n \t{\n-\t  rtx tmp = apply_distributive_law\n-\t    (gen_binary (AND, mode,\n-\t\t\t gen_binary (IOR, mode, XEXP (op0, 0), op1),\n-\t\t\t gen_binary (IOR, mode, XEXP (op0, 1),\n-\t\t\t\t     copy_rtx (op1))));\n-\n-\t  if (GET_CODE (tmp) != IOR\n-\t      && rtx_cost (tmp, SET) < rtx_cost (x, SET))\n-\t    return tmp;\n+\t  rtx result = distribute_and_simplify_rtx (x, 0);\n+\t  if (result)\n+\t    return result;\n \t}\n \n       if (GET_CODE (op1) == AND)\n \t{\n-\t  rtx tmp = apply_distributive_law\n-\t    (gen_binary (AND, mode,\n-\t\t\t gen_binary (IOR, mode, XEXP (op1, 0), op0),\n-\t\t\t gen_binary (IOR, mode, XEXP (op1, 1),\n-\t\t\t\t     copy_rtx (op0))));\n-\n-\t  if (GET_CODE (tmp) != IOR\n-\t      && rtx_cost (tmp, SET) < rtx_cost (x, SET))\n-\t    return tmp;\n+\t  rtx result = distribute_and_simplify_rtx (x, 1);\n+\t  if (result)\n+\t    return result;\n \t}\n \n       /* Convert (ior (ashift A CX) (lshiftrt A CY)) where CX+CY equals the\n@@ -5680,7 +5654,7 @@ simplify_logical (rtx x)\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (op0, mode)\n \t      & nonzero_bits (op1, mode)) == 0)\n-\treturn (gen_binary (IOR, mode, op0, op1));\n+\treturn (simplify_gen_binary (IOR, mode, op0, op1));\n \n       /* Convert (XOR (NOT x) (NOT y)) to (XOR x y).\n \t Also convert (XOR (NOT x) y) to (NOT (XOR x y)), similarly for\n@@ -5700,7 +5674,8 @@ simplify_logical (rtx x)\n \t  }\n \telse if (num_negated == 1)\n \t  return\n-\t    simplify_gen_unary (NOT, mode, gen_binary (XOR, mode, op0, op1),\n+\t    simplify_gen_unary (NOT, mode,\n+\t\t\t\tsimplify_gen_binary (XOR, mode, op0, op1),\n \t\t\t\tmode);\n       }\n \n@@ -5711,16 +5686,18 @@ simplify_logical (rtx x)\n       if (GET_CODE (op0) == AND\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n-\treturn gen_binary (AND, mode,\n-\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n-\t\t\t   op1);\n+\treturn simplify_gen_binary (AND, mode,\n+\t\t\t\t    simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t\tXEXP (op0, 0), mode),\n+\t\t\t\t    op1);\n \n       else if (GET_CODE (op0) == AND\n \t       && rtx_equal_p (XEXP (op0, 0), op1)\n \t       && ! side_effects_p (op1))\n-\treturn gen_binary (AND, mode,\n-\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n-\t\t\t   op1);\n+\treturn simplify_gen_binary (AND, mode,\n+\t\t\t\t    simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t\tXEXP (op0, 1), mode),\n+\t\t\t\t    op1);\n \n       /* (xor (comparison foo bar) (const_int 1)) can become the reversed\n \t comparison if STORE_FLAG_VALUE is 1.  */\n@@ -5992,7 +5969,7 @@ expand_field_assignment (rtx x)\n   rtx inner;\n   rtx pos;\t\t\t/* Always counts from low bit.  */\n   int len;\n-  rtx mask;\n+  rtx mask, cleared, masked;\n   enum machine_mode compute_mode;\n \n   /* Loop until we find something we can't simplify.  */\n@@ -6030,10 +6007,11 @@ expand_field_assignment (rtx x)\n \t\t/* If position is ADJUST - X, new position is X.  */\n \t\tpos = XEXP (pos, 0);\n \t      else\n-\t\tpos = gen_binary (MINUS, GET_MODE (pos),\n-\t\t\t\t  GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner))\n-\t\t\t\t\t   - len),\n-\t\t\t\t  pos);\n+\t\tpos = simplify_gen_binary (MINUS, GET_MODE (pos),\n+\t\t\t\t\t   GEN_INT (GET_MODE_BITSIZE (\n+\t\t\t\t\t\t    GET_MODE (inner))\n+\t\t\t\t\t\t    - len),\n+\t\t\t\t\t   pos);\n \t    }\n \t}\n \n@@ -6080,30 +6058,30 @@ expand_field_assignment (rtx x)\n \t}\n \n       /* Compute a mask of LEN bits, if we can do this on the host machine.  */\n-      if (len < HOST_BITS_PER_WIDE_INT)\n-\tmask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n-      else\n+      if (len >= HOST_BITS_PER_WIDE_INT)\n \tbreak;\n \n       /* Now compute the equivalent expression.  Make a copy of INNER\n \t for the SET_DEST in case it is a MEM into which we will substitute;\n \t we don't want shared RTL in that case.  */\n-      x = gen_rtx_SET\n-\t(VOIDmode, copy_rtx (inner),\n-\t gen_binary (IOR, compute_mode,\n-\t\t     gen_binary (AND, compute_mode,\n-\t\t\t\t simplify_gen_unary (NOT, compute_mode,\n-\t\t\t\t\t\t     gen_binary (ASHIFT,\n-\t\t\t\t\t\t\t\t compute_mode,\n-\t\t\t\t\t\t\t\t mask, pos),\n-\t\t\t\t\t\t     compute_mode),\n-\t\t\t\t inner),\n-\t\t     gen_binary (ASHIFT, compute_mode,\n-\t\t\t\t gen_binary (AND, compute_mode,\n-\t\t\t\t\t     gen_lowpart\n-\t\t\t\t\t     (compute_mode, SET_SRC (x)),\n-\t\t\t\t\t     mask),\n-\t\t\t\t pos)));\n+      mask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n+      cleared = simplify_gen_binary (AND, compute_mode,\n+\t\t\t\t     simplify_gen_unary (NOT, compute_mode,\n+\t\t\t\t       simplify_gen_binary (ASHIFT,\n+\t\t\t\t\t\t\t    compute_mode,\n+\t\t\t\t\t\t\t    mask, pos),\n+\t\t\t\t       compute_mode),\n+\t\t\t\t     inner);\n+      masked = simplify_gen_binary (ASHIFT, compute_mode,\n+\t\t\t\t    simplify_gen_binary (\n+\t\t\t\t      AND, compute_mode,\n+\t\t\t\t      gen_lowpart (compute_mode, SET_SRC (x)),\n+\t\t\t\t      mask),\n+\t\t\t\t    pos);\n+\n+      x = gen_rtx_SET (VOIDmode, copy_rtx (inner),\n+\t\t       simplify_gen_binary (IOR, compute_mode,\n+\t\t\t\t\t    cleared, masked));\n     }\n \n   return x;\n@@ -6559,8 +6537,8 @@ extract_left_shift (rtx x, int count)\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && (INTVAL (XEXP (x, 1)) & ((((HOST_WIDE_INT) 1 << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n-\treturn gen_binary (code, mode, tem,\n-\t\t\t   GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n+\treturn simplify_gen_binary (code, mode, tem,\n+\t\t\t\t    GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n \n       break;\n \n@@ -7046,7 +7024,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t  && (cval & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n \t\tcval |= (HOST_WIDE_INT) -1 << width;\n \n-\t      y = gen_binary (AND, GET_MODE (x), XEXP (x, 0), GEN_INT (cval));\n+\t      y = simplify_gen_binary (AND, GET_MODE (x),\n+\t\t\t\t       XEXP (x, 0), GEN_INT (cval));\n \t      if (rtx_cost (y, SET) < rtx_cost (x, SET))\n \t\tx = y;\n \t    }\n@@ -7138,10 +7117,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  temp = GEN_INT ((INTVAL (XEXP (x, 1)) & mask)\n \t\t\t  << INTVAL (XEXP (XEXP (x, 0), 1)));\n-\t  temp = gen_binary (GET_CODE (x), GET_MODE (x),\n-\t\t\t     XEXP (XEXP (x, 0), 0), temp);\n-\t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp,\n-\t\t\t  XEXP (XEXP (x, 0), 1));\n+\t  temp = simplify_gen_binary (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t      XEXP (XEXP (x, 0), 0), temp);\n+\t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x), temp,\n+\t\t\t\t   XEXP (XEXP (x, 0), 1));\n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n \n@@ -7157,7 +7136,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t\t\t\treg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n-\tx = gen_binary (code, op_mode, op0, op1);\n+\tx = simplify_gen_binary (code, op_mode, op0, op1);\n       break;\n \n     case ASHIFT:\n@@ -7191,7 +7170,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t\t\t\tmask, reg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n-\tx = gen_binary (code, op_mode, op0, XEXP (x, 1));\n+\tx = simplify_gen_binary (code, op_mode, op0, XEXP (x, 1));\n       break;\n \n     case LSHIFTRT:\n@@ -7218,7 +7197,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  inner = force_to_mode (inner, op_mode, inner_mask, reg, next_select);\n \n \t  if (GET_MODE (x) != op_mode || inner != XEXP (x, 0))\n-\t    x = gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n+\t    x = simplify_gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n \t}\n \n       /* If we have (and (lshiftrt FOO C1) C2) where the combination of the\n@@ -7240,9 +7219,9 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  /* Must be more sign bit copies than the mask needs.  */\n \t  && ((int) num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n \t      >= exact_log2 (mask + 1)))\n-\tx = gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n-\t\t\tGEN_INT (GET_MODE_BITSIZE (GET_MODE (x))\n-\t\t\t\t - exact_log2 (mask + 1)));\n+\tx = simplify_gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t GEN_INT (GET_MODE_BITSIZE (GET_MODE (x))\n+\t\t\t\t\t  - exact_log2 (mask + 1)));\n \n       goto shiftrt;\n \n@@ -7307,7 +7286,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* If MASK is 1, convert this to an LSHIFTRT.  This can be done\n \t even if the shift count isn't a constant.  */\n       if (mask == 1)\n-\tx = gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0), XEXP (x, 1));\n+\tx = simplify_gen_binary (LSHIFTRT, GET_MODE (x),\n+\t\t\t\t XEXP (x, 0), XEXP (x, 1));\n \n     shiftrt:\n \n@@ -7372,8 +7352,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  temp = gen_int_mode (mask << INTVAL (XEXP (XEXP (x, 0), 1)),\n \t\t\t       GET_MODE (x));\n-\t  temp = gen_binary (XOR, GET_MODE (x), XEXP (XEXP (x, 0), 0), temp);\n-\t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp, XEXP (XEXP (x, 0), 1));\n+\t  temp = simplify_gen_binary (XOR, GET_MODE (x),\n+\t\t\t\t      XEXP (XEXP (x, 0), 0), temp);\n+\t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x),\n+\t\t\t\t   temp, XEXP (XEXP (x, 0), 1));\n \n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n@@ -7484,8 +7466,19 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t  else if (cond1 == 0)\n \t    true1 = copy_rtx (true1);\n \n-\t  *ptrue = gen_binary (code, mode, true0, true1);\n-\t  *pfalse = gen_binary (code, mode, false0, false1);\n+\t  if (COMPARISON_P (x))\n+\t    {\n+\t      *ptrue = simplify_gen_relational (code, mode, VOIDmode,\n+\t\t\t\t\t\ttrue0, true1);\n+\t      *pfalse = simplify_gen_relational (code, mode, VOIDmode,\n+\t\t\t\t\t         false0, false1);\n+\t     }\n+\t  else\n+\t    {\n+\t      *ptrue = simplify_gen_binary (code, mode, true0, true1);\n+\t      *pfalse = simplify_gen_binary (code, mode, false0, false1);\n+\t    }\n+\n \t  return cond0 ? cond0 : cond1;\n \t}\n \n@@ -7515,13 +7508,13 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t\t      && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 0))))\n \t      && ! side_effects_p (x))\n \t    {\n-\t      *ptrue = gen_binary (MULT, mode, op0, const_true_rtx);\n-\t      *pfalse = gen_binary (MULT, mode,\n-\t\t\t\t    (code == MINUS\n-\t\t\t\t     ? simplify_gen_unary (NEG, mode, op1,\n-\t\t\t\t\t\t\t   mode)\n-\t\t\t\t     : op1),\n-\t\t\t\t    const_true_rtx);\n+\t      *ptrue = simplify_gen_binary (MULT, mode, op0, const_true_rtx);\n+\t      *pfalse = simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t     (code == MINUS\n+\t\t\t\t\t      ? simplify_gen_unary (NEG, mode,\n+\t\t\t\t\t\t\t\t    op1, mode)\n+\t\t\t\t\t      : op1),\n+\t\t\t\t\t      const_true_rtx);\n \t      return cond0;\n \t    }\n \t}\n@@ -8056,8 +8049,8 @@ apply_distributive_law (rtx x)\n \t  || GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))) > UNITS_PER_WORD)\n \treturn x;\n \n-      tem = gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n-\t\t\tSUBREG_REG (lhs), SUBREG_REG (rhs));\n+      tem = simplify_gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n+\t\t\t\t SUBREG_REG (lhs), SUBREG_REG (rhs));\n       return gen_lowpart (GET_MODE (x), tem);\n \n     default:\n@@ -8083,7 +8076,7 @@ apply_distributive_law (rtx x)\n     return x;\n \n   /* Form the new inner operation, seeing if it simplifies first.  */\n-  tem = gen_binary (code, GET_MODE (x), lhs, rhs);\n+  tem = simplify_gen_binary (code, GET_MODE (x), lhs, rhs);\n \n   /* There is one exception to the general way of distributing:\n      (a | c) ^ (b | c) -> (a ^ b) & ~c  */\n@@ -8096,8 +8089,76 @@ apply_distributive_law (rtx x)\n   /* We may be able to continuing distributing the result, so call\n      ourselves recursively on the inner operation before forming the\n      outer operation, which we return.  */\n-  return gen_binary (inner_code, GET_MODE (x),\n-\t\t     apply_distributive_law (tem), other);\n+  return simplify_gen_binary (inner_code, GET_MODE (x),\n+\t\t\t      apply_distributive_law (tem), other);\n+}\n+\n+/* See if X is of the form (* (+ A B) C), and if so convert to\n+   (+ (* A C) (* B C)) and try to simplify.\n+\n+   Most of the time, this results in no change.  However, if some of\n+   the operands are the same or inverses of each other, simplifications\n+   will result.\n+\n+   For example, (and (ior A B) (not B)) can occur as the result of\n+   expanding a bit field assignment.  When we apply the distributive\n+   law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n+   which then simplifies to (and (A (not B))).\n+ \n+   Note that no checks happen on the validity of applying the inverse\n+   distributive law.  This is pointless since we can do it in the\n+   few places where this routine is called.\n+\n+   N is the index of the term that is decomposed (the arithmetic operation,\n+   i.e. (+ A B) in the first example above).  !N is the index of the term that\n+   is distributed, i.e. of C in the first example above.  */\n+static rtx\n+distribute_and_simplify_rtx (rtx x, int n)\n+{\n+  enum machine_mode mode;\n+  enum rtx_code outer_code, inner_code;\n+  rtx decomposed, distributed, inner_op0, inner_op1, new_op0, new_op1, tmp;\n+\n+  decomposed = XEXP (x, n);\n+  if (!ARITHMETIC_P (decomposed))\n+    return NULL_RTX;\n+\n+  mode = GET_MODE (x);\n+  outer_code = GET_CODE (x);\n+  distributed = XEXP (x, !n);\n+\n+  inner_code = GET_CODE (decomposed);\n+  inner_op0 = XEXP (decomposed, 0);\n+  inner_op1 = XEXP (decomposed, 1);\n+\n+  /* Special case (and (xor B C) (not A)), which is equivalent to\n+     (xor (ior A B) (ior A C))  */\n+  if (outer_code == AND && inner_code == XOR && GET_CODE (distributed) == NOT)\n+    {\n+      distributed = XEXP (distributed, 0);\n+      outer_code = IOR;\n+    }\n+\n+  if (n == 0)\n+    {\n+      /* Distribute the second term.  */\n+      new_op0 = simplify_gen_binary (outer_code, mode, inner_op0, distributed);\n+      new_op1 = simplify_gen_binary (outer_code, mode, inner_op1, distributed);\n+    }\n+  else\n+    {\n+      /* Distribute the first term.  */\n+      new_op0 = simplify_gen_binary (outer_code, mode, distributed, inner_op0);\n+      new_op1 = simplify_gen_binary (outer_code, mode, distributed, inner_op1);\n+    }\n+\n+  tmp = apply_distributive_law (simplify_gen_binary (inner_code, mode,\n+\t\t\t\t\t\t     new_op0, new_op1));\n+  if (GET_CODE (tmp) != outer_code\n+      && rtx_cost (tmp, SET) < rtx_cost (x, SET))\n+    return tmp;\n+\n+  return NULL_RTX;\n }\n \f\n /* We have X, a logical `and' of VAROP with the constant CONSTOP, to be done\n@@ -8164,11 +8225,15 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n       gen_lowpart\n \t(mode,\n \t apply_distributive_law\n-\t (gen_binary (GET_CODE (varop), GET_MODE (varop),\n-\t\t      simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n-\t\t\t\t\t      XEXP (varop, 0), constop),\n-\t\t      simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n-\t\t\t\t\t      XEXP (varop, 1), constop))));\n+\t (simplify_gen_binary (GET_CODE (varop), GET_MODE (varop),\n+\t\t\t       simplify_and_const_int (NULL_RTX,\n+\t\t\t\t\t\t       GET_MODE (varop),\n+\t\t\t\t\t\t       XEXP (varop, 0),\n+\t\t\t\t\t\t       constop),\n+\t\t\t       simplify_and_const_int (NULL_RTX,\n+\t\t\t\t\t\t       GET_MODE (varop),\n+\t\t\t\t\t\t       XEXP (varop, 1),\n+\t\t\t\t\t\t       constop))));\n \n   /* If VAROP is PLUS, and the constant is a mask of low bite, distribute\n      the AND and see if one of the operands simplifies to zero.  If so, we\n@@ -8209,7 +8274,7 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n       constop = trunc_int_for_mode (constop, mode);\n       /* See how much, if any, of X we can use.  */\n       if (x == 0 || GET_CODE (x) != AND || GET_MODE (x) != mode)\n-\tx = gen_binary (AND, mode, varop, GEN_INT (constop));\n+\tx = simplify_gen_binary (AND, mode, varop, GEN_INT (constop));\n \n       else\n \t{\n@@ -8728,8 +8793,10 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n-\t\t= gen_binary (ASHIFT, GET_MODE (varop), XEXP (varop, 0),\n-\t\t\t      GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));\n+\t\t= simplify_gen_binary (ASHIFT, GET_MODE (varop),\n+\t\t\t\t       XEXP (varop, 0),\n+\t\t\t\t       GEN_INT (exact_log2 (\n+\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -8740,8 +8807,10 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n-\t\t= gen_binary (LSHIFTRT, GET_MODE (varop), XEXP (varop, 0),\n-\t\t\t      GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));\n+\t\t= simplify_gen_binary (LSHIFTRT, GET_MODE (varop),\n+\t\t\t\t       XEXP (varop, 0),\n+\t\t\t\t       GEN_INT (exact_log2 (\n+\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -8996,7 +9065,8 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      rtx rhs = simplify_shift_const (NULL_RTX, code, shift_mode,\n \t\t\t\t\t      XEXP (varop, 1), count);\n \n-\t      varop = gen_binary (GET_CODE (varop), shift_mode, lhs, rhs);\n+\t      varop = simplify_gen_binary (GET_CODE (varop), shift_mode,\n+\t\t\t\t\t   lhs, rhs);\n \t      varop = apply_distributive_law (varop);\n \n \t      count = 0;\n@@ -9271,7 +9341,8 @@ simplify_shift_const (rtx x, enum rtx_code code,\n       else if (GET_RTX_CLASS (outer_op) == RTX_UNARY)\n \tx = simplify_gen_unary (outer_op, result_mode, x, result_mode);\n       else\n-\tx = gen_binary (outer_op, result_mode, x, GEN_INT (outer_const));\n+\tx = simplify_gen_binary (outer_op, result_mode, x,\n+\t\t\t\t GEN_INT (outer_const));\n     }\n \n   return x;\n@@ -9506,63 +9577,6 @@ gen_lowpart_for_combine (enum machine_mode omode, rtx x)\n   return gen_rtx_CLOBBER (imode, const0_rtx);\n }\n \f\n-/* These routines make binary and unary operations by first seeing if they\n-   fold; if not, a new expression is allocated.  */\n-\n-static rtx\n-gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0, rtx op1)\n-{\n-  rtx result;\n-  rtx tem;\n-\n-  if (GET_CODE (op0) == CLOBBER)\n-    return op0;\n-  else if (GET_CODE (op1) == CLOBBER)\n-    return op1;\n-  \n-  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-      && swap_commutative_operands_p (op0, op1))\n-    tem = op0, op0 = op1, op1 = tem;\n-\n-  if (GET_RTX_CLASS (code) == RTX_COMPARE\n-      || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n-    {\n-      enum machine_mode op_mode = GET_MODE (op0);\n-\n-      /* Strip the COMPARE from (REL_OP (compare X Y) 0) to get\n-\t just (REL_OP X Y).  */\n-      if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n-\t{\n-\t  op1 = XEXP (op0, 1);\n-\t  op0 = XEXP (op0, 0);\n-\t  op_mode = GET_MODE (op0);\n-\t}\n-\n-      if (op_mode == VOIDmode)\n-\top_mode = GET_MODE (op1);\n-      result = simplify_relational_operation (code, mode, op_mode, op0, op1);\n-    }\n-  else\n-    result = simplify_binary_operation (code, mode, op0, op1);\n-\n-  if (result)\n-    return result;\n-\n-  /* Put complex operands first and constants second.  */\n-  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-      && swap_commutative_operands_p (op0, op1))\n-    return gen_rtx_fmt_ee (code, mode, op1, op0);\n-\n-  /* If we are turning off bits already known off in OP0, we need not do\n-     an AND.  */\n-  else if (code == AND && GET_CODE (op1) == CONST_INT\n-\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t   && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n-    return op0;\n-\n-  return gen_rtx_fmt_ee (code, mode, op0, op1);\n-}\n-\f\n /* Simplify a comparison between *POP0 and *POP1 where CODE is the\n    comparison code that will be tested.\n \n@@ -10431,9 +10445,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t  && c1 != mask\n \t\t  && c1 != GET_MODE_MASK (tmode))\n \t\t{\n-\t\t  op0 = gen_binary (AND, tmode,\n-\t\t\t\t    SUBREG_REG (XEXP (op0, 0)),\n-\t\t\t\t    gen_int_mode (c1, tmode));\n+\t\t  op0 = simplify_gen_binary (AND, tmode,\n+\t\t\t\t\t     SUBREG_REG (XEXP (op0, 0)),\n+\t\t\t\t\t     gen_int_mode (c1, tmode));\n \t\t  op0 = gen_lowpart (mode, op0);\n \t\t  continue;\n \t\t}\n@@ -10577,12 +10591,12 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    {\n \t      rtx inner = XEXP (XEXP (XEXP (op0, 0), 0), 0);\n \t      rtx add_const = XEXP (XEXP (op0, 0), 1);\n-\t      rtx new_const = gen_binary (ASHIFTRT, GET_MODE (op0), add_const,\n-\t\t\t\t\t  XEXP (op0, 1));\n+\t      rtx new_const = simplify_gen_binary (ASHIFTRT, GET_MODE (op0),\n+\t\t\t\t\t\t   add_const, XEXP (op0, 1));\n \n-\t      op0 = gen_binary (PLUS, tmode,\n-\t\t\t\tgen_lowpart (tmode, inner),\n-\t\t\t\tnew_const);\n+\t      op0 = simplify_gen_binary (PLUS, tmode,\n+\t\t\t\t\t gen_lowpart (tmode, inner),\n+\t\t\t\t\t new_const);\n \t      continue;\n \t    }\n \n@@ -10735,11 +10749,11 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t make a new AND in the proper mode.  */\n \t      if (GET_CODE (op0) == AND\n \t\t  && !have_insn_for (AND, mode))\n-\t\top0 = gen_binary (AND, tmode,\n-\t\t\t\t  gen_lowpart (tmode,\n-\t\t\t\t\t       XEXP (op0, 0)),\n-\t\t\t\t  gen_lowpart (tmode,\n-\t\t\t\t\t       XEXP (op0, 1)));\n+\t\top0 = simplify_gen_binary (AND, tmode,\n+\t\t\t\t\t   gen_lowpart (tmode,\n+\t\t\t\t\t\t\tXEXP (op0, 0)),\n+\t\t\t\t\t   gen_lowpart (tmode,\n+\t\t\t\t\t\t\tXEXP (op0, 1)));\n \n \t      op0 = gen_lowpart (tmode, op0);\n \t      if (zero_extended && GET_CODE (op1) == CONST_INT)\n@@ -10754,10 +10768,11 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  if (op1 == const0_rtx && (code == LT || code == GE)\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      op0 = gen_binary (AND, tmode,\n-\t\t\t\tgen_lowpart (tmode, op0),\n-\t\t\t\tGEN_INT ((HOST_WIDE_INT) 1\n-\t\t\t\t\t << (GET_MODE_BITSIZE (mode) - 1)));\n+\t      op0 = simplify_gen_binary (AND, tmode,\n+\t\t\t\t\t gen_lowpart (tmode, op0),\n+\t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t\t  << (GET_MODE_BITSIZE (mode)\n+\t\t\t\t\t\t      - 1)));\n \t      code = (code == LT) ? NE : EQ;\n \t      break;\n \t    }\n@@ -10804,7 +10819,7 @@ reversed_comparison (rtx exp, enum machine_mode mode, rtx op0, rtx op1)\n   if (reversed_code == UNKNOWN)\n     return NULL_RTX;\n   else\n-    return gen_binary (reversed_code, mode, op0, op1);\n+    return simplify_gen_relational (reversed_code, mode, VOIDmode, op0, op1);\n }\n \f\n /* Utility function for record_value_for_reg.  Count number of"}]}