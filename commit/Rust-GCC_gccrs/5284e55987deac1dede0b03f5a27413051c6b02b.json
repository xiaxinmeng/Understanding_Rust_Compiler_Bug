{"sha": "5284e55987deac1dede0b03f5a27413051c6b02b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI4NGU1NTk4N2RlYWMxZGVkZTBiMDNmNWEyNzQxMzA1MWM2YjAyYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-06-12T22:31:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-12T22:31:14Z"}, "message": "Use poly_int rtx accessors instead of hwi accessors\n\nThis patch generalises various places that used hwi rtx accessors so\nthat they can handle poly_ints instead.  In many cases these changes\nare by inspection rather than because something had shown them to be\nnecessary.\n\n2018-06-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* poly-int.h (can_div_trunc_p): Add new overload in which all values\n\tare poly_ints.\n\t* alias.c (get_addr): Extend CONST_INT handling to poly_int_rtx_p.\n\t(memrefs_conflict_p): Likewise.\n\t(init_alias_analysis): Likewise.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* combine.c (combine_simplify_rtx, force_int_to_mode): Likewise.\n\t* cse.c (fold_rtx): Likewise.\n\t* explow.c (adjust_stack, anti_adjust_stack): Likewise.\n\t* expr.c (emit_block_move_hints): Likewise.\n\t(clear_storage_hints, push_block, emit_push_insn): Likewise.\n\t(store_expr_with_bounds, reduce_to_bit_field_precision): Likewise.\n\t(emit_group_load_1): Use rtx_to_poly_int64 for group offsets.\n\t(emit_group_store): Likewise.\n\t(find_args_size_adjust): Use strip_offset.  Use rtx_to_poly_int64\n\tto read the PRE/POST_MODIFY increment.\n\t* calls.c (store_one_arg): Use strip_offset.\n\t* rtlanal.c (rtx_addr_can_trap_p_1): Extend CONST_INT handling to\n\tpoly_int_rtx_p.\n\t(set_noop_p): Use rtx_to_poly_int64 for the elements selected\n\tby a VEC_SELECT.\n\t* simplify-rtx.c (avoid_constant_pool_reference): Use strip_offset.\n\t(simplify_binary_operation_1): Extend CONST_INT handling to\n\tpoly_int_rtx_p.\n\t* var-tracking.c (compute_cfa_pointer): Take a poly_int64 rather\n\tthan a HOST_WIDE_INT.\n\t(hard_frame_pointer_adjustment): Change from HOST_WIDE_INT to\n\tpoly_int64.\n\t(adjust_mems, add_stores): Update accodingly.\n\t(vt_canonicalize_addr): Track polynomial offsets.\n\t(emit_note_insn_var_location): Likewise.\n\t(vt_add_function_parameter): Likewise.\n\t(vt_initialize): Likewise.\n\nFrom-SVN: r261530", "tree": {"sha": "04502798041680f8013e99050bfef168da606090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04502798041680f8013e99050bfef168da606090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5284e55987deac1dede0b03f5a27413051c6b02b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5284e55987deac1dede0b03f5a27413051c6b02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5284e55987deac1dede0b03f5a27413051c6b02b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5284e55987deac1dede0b03f5a27413051c6b02b/comments", "author": null, "committer": null, "parents": [{"sha": "6044eae783cea564ad65fe65646346cb67760934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6044eae783cea564ad65fe65646346cb67760934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6044eae783cea564ad65fe65646346cb67760934"}], "stats": {"total": 281, "additions": 166, "deletions": 115}, "files": [{"sha": "7dce604fb69dda664c75570916ac9951f4288a62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -1,3 +1,39 @@\n+2018-06-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* poly-int.h (can_div_trunc_p): Add new overload in which all values\n+\tare poly_ints.\n+\t* alias.c (get_addr): Extend CONST_INT handling to poly_int_rtx_p.\n+\t(memrefs_conflict_p): Likewise.\n+\t(init_alias_analysis): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* combine.c (combine_simplify_rtx, force_int_to_mode): Likewise.\n+\t* cse.c (fold_rtx): Likewise.\n+\t* explow.c (adjust_stack, anti_adjust_stack): Likewise.\n+\t* expr.c (emit_block_move_hints): Likewise.\n+\t(clear_storage_hints, push_block, emit_push_insn): Likewise.\n+\t(store_expr_with_bounds, reduce_to_bit_field_precision): Likewise.\n+\t(emit_group_load_1): Use rtx_to_poly_int64 for group offsets.\n+\t(emit_group_store): Likewise.\n+\t(find_args_size_adjust): Use strip_offset.  Use rtx_to_poly_int64\n+\tto read the PRE/POST_MODIFY increment.\n+\t* calls.c (store_one_arg): Use strip_offset.\n+\t* rtlanal.c (rtx_addr_can_trap_p_1): Extend CONST_INT handling to\n+\tpoly_int_rtx_p.\n+\t(set_noop_p): Use rtx_to_poly_int64 for the elements selected\n+\tby a VEC_SELECT.\n+\t* simplify-rtx.c (avoid_constant_pool_reference): Use strip_offset.\n+\t(simplify_binary_operation_1): Extend CONST_INT handling to\n+\tpoly_int_rtx_p.\n+\t* var-tracking.c (compute_cfa_pointer): Take a poly_int64 rather\n+\tthan a HOST_WIDE_INT.\n+\t(hard_frame_pointer_adjustment): Change from HOST_WIDE_INT to\n+\tpoly_int64.\n+\t(adjust_mems, add_stores): Update accodingly.\n+\t(vt_canonicalize_addr): Track polynomial offsets.\n+\t(emit_note_insn_var_location): Likewise.\n+\t(vt_add_function_parameter): Likewise.\n+\t(vt_initialize): Likewise.\n+\n 2018-06-12  Jeff Law  <law@redhat.com>\n \n \t* config.gcc (alpha*-*-freebsd*): Remove."}, {"sha": "2091dfbf3d73dc69394bbf614b8b3a6b5107548d", "filename": "gcc/alias.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -2262,9 +2262,10 @@ get_addr (rtx x)\n \t  rtx op0 = get_addr (XEXP (x, 0));\n \t  if (op0 != XEXP (x, 0))\n \t    {\n+\t      poly_int64 c;\n \t      if (GET_CODE (x) == PLUS\n-\t\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t\treturn plus_constant (GET_MODE (x), op0, INTVAL (XEXP (x, 1)));\n+\t\t  && poly_int_rtx_p (XEXP (x, 1), &c))\n+\t\treturn plus_constant (GET_MODE (x), op0, c);\n \t      return simplify_gen_binary (GET_CODE (x), GET_MODE (x),\n \t\t\t\t\t  op0, XEXP (x, 1));\n \t    }\n@@ -2551,10 +2552,11 @@ memrefs_conflict_p (poly_int64 xsize, rtx x, poly_int64 ysize, rtx y,\n \t    return offset_overlap_p (c, xsize, ysize);\n \n \t  /* Can't properly adjust our sizes.  */\n-\t  if (!CONST_INT_P (x1)\n-\t      || !can_div_trunc_p (xsize, INTVAL (x1), &xsize)\n-\t      || !can_div_trunc_p (ysize, INTVAL (x1), &ysize)\n-\t      || !can_div_trunc_p (c, INTVAL (x1), &c))\n+\t  poly_int64 c1;\n+\t  if (!poly_int_rtx_p (x1, &c1)\n+\t      || !can_div_trunc_p (xsize, c1, &xsize)\n+\t      || !can_div_trunc_p (ysize, c1, &ysize)\n+\t      || !can_div_trunc_p (c, c1, &c))\n \t    return -1;\n \t  return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n \t}\n@@ -3407,6 +3409,7 @@ init_alias_analysis (void)\n \t\t\t  && DF_REG_DEF_COUNT (regno) != 1)\n \t\t\tnote = NULL_RTX;\n \n+\t\t      poly_int64 offset;\n \t\t      if (note != NULL_RTX\n \t\t\t  && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n \t\t\t  && ! rtx_varies_p (XEXP (note, 0), 1)\n@@ -3421,10 +3424,9 @@ init_alias_analysis (void)\n \t\t\t       && GET_CODE (src) == PLUS\n \t\t\t       && REG_P (XEXP (src, 0))\n \t\t\t       && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n-\t\t\t       && CONST_INT_P (XEXP (src, 1)))\n+\t\t\t       && poly_int_rtx_p (XEXP (src, 1), &offset))\n \t\t\t{\n-\t\t\t  t = plus_constant (GET_MODE (src), t,\n-\t\t\t\t\t     INTVAL (XEXP (src, 1)));\n+\t\t\t  t = plus_constant (GET_MODE (src), t, offset);\n \t\t\t  set_reg_known_value (regno, t);\n \t\t\t  set_reg_known_equiv_p (regno, false);\n \t\t\t}"}, {"sha": "3311d1cbe2b335678245f66ed04f3455b101186b", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -5676,15 +5676,9 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t  rtx x = arg->value;\n \t  poly_int64 i = 0;\n \n-\t  if (XEXP (x, 0) == crtl->args.internal_arg_pointer\n-\t      || (GET_CODE (XEXP (x, 0)) == PLUS\n-\t\t  && XEXP (XEXP (x, 0), 0) ==\n-\t\t     crtl->args.internal_arg_pointer\n-\t\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))))\n+\t  if (strip_offset (XEXP (x, 0), &i)\n+\t      == crtl->args.internal_arg_pointer)\n \t    {\n-\t      if (XEXP (x, 0) != crtl->args.internal_arg_pointer)\n-\t\ti = rtx_to_poly_int64 (XEXP (XEXP (x, 0), 1));\n-\n \t      /* arg.locate doesn't contain the pretend_args_size offset,\n \t\t it's part of argblock.  Ensure we don't count it in I.  */\n \t      if (STACK_GROWS_DOWNWARD)"}, {"sha": "9bd61b9948ee8acb7d47f9891f3fe2a1bc4fc7bc", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -4373,10 +4373,11 @@ expand_debug_expr (tree exp)\n \t    goto component_ref;\n \n \t  op1 = expand_debug_expr (TREE_OPERAND (exp, 1));\n-\t  if (!op1 || !CONST_INT_P (op1))\n+\t  poly_int64 offset;\n+\t  if (!op1 || !poly_int_rtx_p (op1, &offset))\n \t    return NULL;\n \n-\t  op0 = plus_constant (inner_mode, op0, INTVAL (op1));\n+\t  op0 = plus_constant (inner_mode, op0, offset);\n \t}\n \n       as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))));\n@@ -4890,10 +4891,11 @@ expand_debug_expr (tree exp)\n \t\t{\n \t\t  op1 = expand_debug_expr (TREE_OPERAND (TREE_OPERAND (exp, 0),\n \t\t\t\t\t\t\t 1));\n-\t\t  if (!op1 || !CONST_INT_P (op1))\n+\t\t  poly_int64 offset;\n+\t\t  if (!op1 || !poly_int_rtx_p (op1, &offset))\n \t\t    return NULL;\n \n-\t\t  return plus_constant (mode, op0, INTVAL (op1));\n+\t\t  return plus_constant (mode, op0, offset);\n \t\t}\n \t    }\n "}, {"sha": "cfe0f190ece982e520c132e3921b1964cf1353f2", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -5978,8 +5978,11 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t\t\t      GET_MODE_MASK (mode), 0));\n \n       /* We can truncate a constant value and return it.  */\n-      if (CONST_INT_P (XEXP (x, 0)))\n-\treturn gen_int_mode (INTVAL (XEXP (x, 0)), mode);\n+      {\n+\tpoly_int64 c;\n+\tif (poly_int_rtx_p (XEXP (x, 0), &c))\n+\t  return gen_int_mode (c, mode);\n+      }\n \n       /* Similarly to what we do in simplify-rtx.c, a truncate of a register\n \t whose value is a comparison can be replaced with a subreg if\n@@ -8700,6 +8703,7 @@ force_int_to_mode (rtx x, scalar_int_mode mode, scalar_int_mode xmode,\n   int next_select = just_select || code == XOR || code == NOT || code == NEG;\n   unsigned HOST_WIDE_INT fuller_mask;\n   rtx op0, op1, temp;\n+  poly_int64 const_op0;\n \n   /* When we have an arithmetic operation, or a shift whose count we\n      do not know, we need to assume that all bits up to the highest-order\n@@ -8823,8 +8827,8 @@ force_int_to_mode (rtx x, scalar_int_mode mode, scalar_int_mode xmode,\n     case MINUS:\n       /* If X is (minus C Y) where C's least set bit is larger than any bit\n \t in the mask, then we may replace with (neg Y).  */\n-      if (CONST_INT_P (XEXP (x, 0))\n-\t  && least_bit_hwi (UINTVAL (XEXP (x, 0))) > mask)\n+      if (poly_int_rtx_p (XEXP (x, 0), &const_op0)\n+\t  && (unsigned HOST_WIDE_INT) known_alignment (const_op0) > mask)\n \t{\n \t  x = simplify_gen_unary (NEG, xmode, XEXP (x, 1), xmode);\n \t  return force_to_mode (x, mode, mask, next_select);"}, {"sha": "4e94152b38047d336052f81d93a6d49c3ae2de2a", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -3112,6 +3112,7 @@ fold_rtx (rtx x, rtx_insn *insn)\n   int i;\n   rtx new_rtx = 0;\n   int changed = 0;\n+  poly_int64 xval;\n \n   /* Operands of X.  */\n   /* Workaround -Wmaybe-uninitialized false positive during\n@@ -3592,12 +3593,11 @@ fold_rtx (rtx x, rtx_insn *insn)\n \tcase MINUS:\n \t  /* If we have (MINUS Y C), see if Y is known to be (PLUS Z C2).\n \t     If so, produce (PLUS Z C2-C).  */\n-\t  if (const_arg1 != 0 && CONST_INT_P (const_arg1))\n+\t  if (const_arg1 != 0 && poly_int_rtx_p (const_arg1, &xval))\n \t    {\n \t      rtx y = lookup_as_function (XEXP (x, 0), PLUS);\n-\t      if (y && CONST_INT_P (XEXP (y, 1)))\n-\t\treturn fold_rtx (plus_constant (mode, copy_rtx (y),\n-\t\t\t\t\t\t-INTVAL (const_arg1)),\n+\t      if (y && poly_int_rtx_p (XEXP (y, 1)))\n+\t\treturn fold_rtx (plus_constant (mode, copy_rtx (y), -xval),\n \t\t\t\t NULL);\n \t    }\n "}, {"sha": "9a6182ac5c5f6b7a0d001ad83ab822aa58036f4a", "filename": "gcc/explow.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -955,8 +955,9 @@ adjust_stack (rtx adjust)\n \n   /* We expect all variable sized adjustments to be multiple of\n      PREFERRED_STACK_BOUNDARY.  */\n-  if (CONST_INT_P (adjust))\n-    stack_pointer_delta -= INTVAL (adjust);\n+  poly_int64 const_adjust;\n+  if (poly_int_rtx_p (adjust, &const_adjust))\n+    stack_pointer_delta -= const_adjust;\n \n   adjust_stack_1 (adjust, false);\n }\n@@ -972,8 +973,9 @@ anti_adjust_stack (rtx adjust)\n \n   /* We expect all variable sized adjustments to be multiple of\n      PREFERRED_STACK_BOUNDARY.  */\n-  if (CONST_INT_P (adjust))\n-    stack_pointer_delta += INTVAL (adjust);\n+  poly_int64 const_adjust;\n+  if (poly_int_rtx_p (adjust, &const_adjust))\n+    stack_pointer_delta += const_adjust;\n \n   adjust_stack_1 (adjust, true);\n }"}, {"sha": "d6b3eb4530a3dc08735a0a202978db9414edad2e", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -1612,12 +1612,13 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n \n   /* Set MEM_SIZE as appropriate for this block copy.  The main place this\n      can be incorrect is coming from __builtin_memcpy.  */\n-  if (CONST_INT_P (size))\n+  poly_int64 const_size;\n+  if (poly_int_rtx_p (size, &const_size))\n     {\n       x = shallow_copy_rtx (x);\n       y = shallow_copy_rtx (y);\n-      set_mem_size (x, INTVAL (size));\n-      set_mem_size (y, INTVAL (size));\n+      set_mem_size (x, const_size);\n+      set_mem_size (y, const_size);\n     }\n \n   if (CONST_INT_P (size) && can_move_by_pieces (INTVAL (size), align))\n@@ -2146,7 +2147,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type,\n   for (i = start; i < XVECLEN (dst, 0); i++)\n     {\n       machine_mode mode = GET_MODE (XEXP (XVECEXP (dst, 0, i), 0));\n-      poly_int64 bytepos = INTVAL (XEXP (XVECEXP (dst, 0, i), 1));\n+      poly_int64 bytepos = rtx_to_poly_int64 (XEXP (XVECEXP (dst, 0, i), 1));\n       poly_int64 bytelen = GET_MODE_SIZE (mode);\n       poly_int64 shift = 0;\n \n@@ -2477,7 +2478,8 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n \t{\n \t  inner = GET_MODE (tmps[start]);\n \t  bytepos = subreg_lowpart_offset (inner, outer);\n-\t  if (known_eq (INTVAL (XEXP (XVECEXP (src, 0, start), 1)), bytepos))\n+\t  if (known_eq (rtx_to_poly_int64 (XEXP (XVECEXP (src, 0, start), 1)),\n+\t\t\tbytepos))\n \t    {\n \t      temp = simplify_gen_subreg (outer, tmps[start],\n \t\t\t\t\t  inner, 0);\n@@ -2496,7 +2498,8 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n \t{\n \t  inner = GET_MODE (tmps[finish - 1]);\n \t  bytepos = subreg_lowpart_offset (inner, outer);\n-\t  if (known_eq (INTVAL (XEXP (XVECEXP (src, 0, finish - 1), 1)),\n+\t  if (known_eq (rtx_to_poly_int64 (XEXP (XVECEXP (src, 0,\n+\t\t\t\t\t\t\t  finish - 1), 1)),\n \t\t\tbytepos))\n \t    {\n \t      temp = simplify_gen_subreg (outer, tmps[finish - 1],\n@@ -2518,7 +2521,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n   /* Process the pieces.  */\n   for (i = start; i < finish; i++)\n     {\n-      poly_int64 bytepos = INTVAL (XEXP (XVECEXP (src, 0, i), 1));\n+      poly_int64 bytepos = rtx_to_poly_int64 (XEXP (XVECEXP (src, 0, i), 1));\n       machine_mode mode = GET_MODE (tmps[i]);\n       poly_int64 bytelen = GET_MODE_SIZE (mode);\n       poly_uint64 adj_bytelen;\n@@ -2974,9 +2977,10 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n \n   /* If OBJECT is not BLKmode and SIZE is the same size as its mode,\n      just move a zero.  Otherwise, do this a piece at a time.  */\n+  poly_int64 size_val;\n   if (mode != BLKmode\n-      && CONST_INT_P (size)\n-      && known_eq (INTVAL (size), GET_MODE_SIZE (mode)))\n+      && poly_int_rtx_p (size, &size_val)\n+      && known_eq (size_val, GET_MODE_SIZE (mode)))\n     {\n       rtx zero = CONST0_RTX (mode);\n       if (zero != NULL)\n@@ -3912,9 +3916,10 @@ push_block (rtx size, poly_int64 extra, int below)\n     }\n   else\n     {\n-      if (CONST_INT_P (size))\n+      poly_int64 csize;\n+      if (poly_int_rtx_p (size, &csize))\n \ttemp = plus_constant (Pmode, virtual_outgoing_args_rtx,\n-\t\t\t      -INTVAL (size) - (below ? 0 : extra));\n+\t\t\t      -csize - (below ? 0 : extra));\n       else if (maybe_ne (extra, 0) && !below)\n \ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n \t\t\t     negate_rtx (Pmode, plus_constant (Pmode, size,\n@@ -4034,11 +4039,10 @@ find_args_size_adjust (rtx_insn *insn)\n       /* Look for a trivial adjustment, otherwise assume nothing.  */\n       /* Note that the SPU restore_stack_block pattern refers to\n \t the stack pointer in V4SImode.  Consider that non-trivial.  */\n+      poly_int64 offset;\n       if (SCALAR_INT_MODE_P (GET_MODE (dest))\n-\t  && GET_CODE (SET_SRC (set)) == PLUS\n-\t  && XEXP (SET_SRC (set), 0) == stack_pointer_rtx\n-\t  && CONST_INT_P (XEXP (SET_SRC (set), 1)))\n-\treturn INTVAL (XEXP (SET_SRC (set), 1));\n+\t  && strip_offset (SET_SRC (set), &offset) == stack_pointer_rtx)\n+\treturn offset;\n       /* ??? Reload can generate no-op moves, which will be cleaned\n \t up later.  Recognize it and continue searching.  */\n       else if (rtx_equal_p (dest, SET_SRC (set)))\n@@ -4076,8 +4080,7 @@ find_args_size_adjust (rtx_insn *insn)\n \t  addr = XEXP (addr, 1);\n \t  gcc_assert (GET_CODE (addr) == PLUS);\n \t  gcc_assert (XEXP (addr, 0) == stack_pointer_rtx);\n-\t  gcc_assert (CONST_INT_P (XEXP (addr, 1)));\n-\t  return INTVAL (XEXP (addr, 1));\n+\t  return rtx_to_poly_int64 (XEXP (addr, 1));\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -4419,15 +4422,16 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t  /* Get the address of the stack space.\n \t     In this case, we do not deal with EXTRA separately.\n \t     A single stack adjust will do.  */\n+\t  poly_int64 offset;\n \t  if (! args_addr)\n \t    {\n \t      temp = push_block (size, extra, where_pad == PAD_DOWNWARD);\n \t      extra = 0;\n \t    }\n-\t  else if (CONST_INT_P (args_so_far))\n+\t  else if (poly_int_rtx_p (args_so_far, &offset))\n \t    temp = memory_address (BLKmode,\n \t\t\t\t   plus_constant (Pmode, args_addr,\n-\t\t\t\t\t\t  skip + INTVAL (args_so_far)));\n+\t\t\t\t\t\t  skip + offset));\n \t  else\n \t    temp = memory_address (BLKmode,\n \t\t\t\t   plus_constant (Pmode,\n@@ -5724,12 +5728,11 @@ store_expr (tree exp, rtx target, int call_param_p,\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n \t\t Do all calculations in pointer_mode.  */\n-\t      if (CONST_INT_P (copy_size_rtx))\n+\t      poly_int64 const_copy_size;\n+\t      if (poly_int_rtx_p (copy_size_rtx, &const_copy_size))\n \t\t{\n-\t\t  size = plus_constant (address_mode, size,\n-\t\t\t\t\t-INTVAL (copy_size_rtx));\n-\t\t  target = adjust_address (target, BLKmode,\n-\t\t\t\t\t   INTVAL (copy_size_rtx));\n+\t\t  size = plus_constant (address_mode, size, -const_copy_size);\n+\t\t  target = adjust_address (target, BLKmode, const_copy_size);\n \t\t}\n \t      else\n \t\t{\n@@ -11203,10 +11206,10 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n   if (target && GET_MODE (target) != GET_MODE (exp))\n     target = 0;\n   /* For constant values, reduce using build_int_cst_type. */\n-  if (CONST_INT_P (exp))\n+  poly_int64 const_exp;\n+  if (poly_int_rtx_p (exp, &const_exp))\n     {\n-      HOST_WIDE_INT value = INTVAL (exp);\n-      tree t = build_int_cst_type (type, value);\n+      tree t = build_int_cst_type (type, const_exp);\n       return expand_expr (t, target, VOIDmode, EXPAND_NORMAL);\n     }\n   else if (TYPE_UNSIGNED (type))"}, {"sha": "d6e4deeec0cbbdab6c7246599833968b1ee365e4", "filename": "gcc/poly-int.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -2346,6 +2346,27 @@ can_div_trunc_p (const poly_int_pod<N, Ca> &a, Cb b,\n   return true;\n }\n \n+/* Return true if we can compute A / B at compile time, rounding towards zero.\n+   Store the result in QUOTIENT if so.\n+\n+   This handles cases in which either B is constant or the result is\n+   constant.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cq>\n+inline bool\n+can_div_trunc_p (const poly_int_pod<N, Ca> &a,\n+\t\t const poly_int_pod<N, Cb> &b,\n+\t\t poly_int_pod<N, Cq> *quotient)\n+{\n+  if (b.is_constant ())\n+    return can_div_trunc_p (a, b.coeffs[0], quotient);\n+  if (!can_div_trunc_p (a, b, &quotient->coeffs[0]))\n+    return false;\n+  for (unsigned int i = 1; i < N; ++i)\n+    quotient->coeffs[i] = 0;\n+  return true;\n+}\n+\n /* Return true if there is some constant Q and polynomial r such that:\n \n      (1) a = b * Q + r"}, {"sha": "8e8ee6eb34940d4a73dd35dd81f0c10b92e8bcb4", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -462,6 +462,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, poly_int64 offset, poly_int64 size,\n {\n   enum rtx_code code = GET_CODE (x);\n   gcc_checking_assert (mode == BLKmode || known_size_p (size));\n+  poly_int64 const_x1;\n \n   /* The offset must be a multiple of the mode size if we are considering\n      unaligned memory references on strict alignment machines.  */\n@@ -653,8 +654,8 @@ rtx_addr_can_trap_p_1 (const_rtx x, poly_int64 offset, poly_int64 size,\n \treturn 0;\n \n       /* - or it is an address that can't trap plus a constant integer.  */\n-      if (CONST_INT_P (XEXP (x, 1))\n-\t  && !rtx_addr_can_trap_p_1 (XEXP (x, 0), offset + INTVAL (XEXP (x, 1)),\n+      if (poly_int_rtx_p (XEXP (x, 1), &const_x1)\n+\t  && !rtx_addr_can_trap_p_1 (XEXP (x, 0), offset + const_x1,\n \t\t\t\t     size, mode, unaligned_mems))\n \treturn 0;\n \n@@ -1613,11 +1614,11 @@ set_noop_p (const_rtx set)\n       int i;\n       rtx par = XEXP (src, 1);\n       rtx src0 = XEXP (src, 0);\n-      int c0 = INTVAL (XVECEXP (par, 0, 0));\n-      HOST_WIDE_INT offset = GET_MODE_UNIT_SIZE (GET_MODE (src0)) * c0;\n+      poly_int64 c0 = rtx_to_poly_int64 (XVECEXP (par, 0, 0));\n+      poly_int64 offset = GET_MODE_UNIT_SIZE (GET_MODE (src0)) * c0;\n \n       for (i = 1; i < XVECLEN (par, 0); i++)\n-\tif (INTVAL (XVECEXP (par, 0, i)) != c0 + i)\n+\tif (maybe_ne (rtx_to_poly_int64 (XVECEXP (par, 0, i)), c0 + i))\n \t  return 0;\n       return\n \tsimplify_subreg_regno (REGNO (src0), GET_MODE (src0),"}, {"sha": "90d148c0074b73031e8f2feaa373662d4b7f39df", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -210,7 +210,7 @@ avoid_constant_pool_reference (rtx x)\n {\n   rtx c, tmp, addr;\n   machine_mode cmode;\n-  HOST_WIDE_INT offset = 0;\n+  poly_int64 offset = 0;\n \n   switch (GET_CODE (x))\n     {\n@@ -239,13 +239,7 @@ avoid_constant_pool_reference (rtx x)\n   addr = targetm.delegitimize_address (addr);\n \n   /* Split the address into a base and integer offset.  */\n-  if (GET_CODE (addr) == CONST\n-      && GET_CODE (XEXP (addr, 0)) == PLUS\n-      && CONST_INT_P (XEXP (XEXP (addr, 0), 1)))\n-    {\n-      offset = INTVAL (XEXP (XEXP (addr, 0), 1));\n-      addr = XEXP (XEXP (addr, 0), 0);\n-    }\n+  addr = strip_offset (addr, &offset);\n \n   if (GET_CODE (addr) == LO_SUM)\n     addr = XEXP (addr, 1);\n@@ -261,7 +255,7 @@ avoid_constant_pool_reference (rtx x)\n       /* If we're accessing the constant in a different mode than it was\n          originally stored, attempt to fix that up via subreg simplifications.\n          If that fails we have no choice but to return the original memory.  */\n-      if (offset == 0 && cmode == GET_MODE (x))\n+      if (known_eq (offset, 0) && cmode == GET_MODE (x))\n \treturn c;\n       else if (known_in_range_p (offset, 0, GET_MODE_SIZE (cmode)))\n         {\n@@ -2272,13 +2266,13 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n       if ((GET_CODE (op0) == CONST\n \t   || GET_CODE (op0) == SYMBOL_REF\n \t   || GET_CODE (op0) == LABEL_REF)\n-\t  && CONST_INT_P (op1))\n-\treturn plus_constant (mode, op0, INTVAL (op1));\n+\t  && poly_int_rtx_p (op1, &offset))\n+\treturn plus_constant (mode, op0, offset);\n       else if ((GET_CODE (op1) == CONST\n \t\t|| GET_CODE (op1) == SYMBOL_REF\n \t\t|| GET_CODE (op1) == LABEL_REF)\n-\t       && CONST_INT_P (op0))\n-\treturn plus_constant (mode, op1, INTVAL (op0));\n+\t       && poly_int_rtx_p (op0, &offset))\n+\treturn plus_constant (mode, op1, offset);\n \n       /* See if this is something like X * C - X or vice versa or\n \t if the multiplication is written as a shift.  If so, we can"}, {"sha": "2bbde92086fe8de195f2acdce37b5d5409cbd96b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5284e55987deac1dede0b03f5a27413051c6b02b/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=5284e55987deac1dede0b03f5a27413051c6b02b", "patch": "@@ -917,14 +917,14 @@ static HOST_WIDE_INT cfa_base_offset;\n    or hard_frame_pointer_rtx.  */\n \n static inline rtx\n-compute_cfa_pointer (HOST_WIDE_INT adjustment)\n+compute_cfa_pointer (poly_int64 adjustment)\n {\n   return plus_constant (Pmode, cfa_base_rtx, adjustment + cfa_base_offset);\n }\n \n /* Adjustment for hard_frame_pointer_rtx to cfa base reg,\n    or -1 if the replacement shouldn't be done.  */\n-static HOST_WIDE_INT hard_frame_pointer_adjustment = -1;\n+static poly_int64 hard_frame_pointer_adjustment = -1;\n \n /* Data for adjust_mems callback.  */\n \n@@ -1030,7 +1030,7 @@ adjust_mems (rtx loc, const_rtx old_rtx, void *data)\n \treturn compute_cfa_pointer (amd->stack_adjust);\n       else if (loc == hard_frame_pointer_rtx\n \t       && frame_pointer_needed\n-\t       && hard_frame_pointer_adjustment != -1\n+\t       && maybe_ne (hard_frame_pointer_adjustment, -1)\n \t       && cfa_base_rtx)\n \treturn compute_cfa_pointer (hard_frame_pointer_adjustment);\n       gcc_checking_assert (loc != virtual_incoming_args_rtx);\n@@ -2156,7 +2156,7 @@ get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n static rtx\n vt_canonicalize_addr (dataflow_set *set, rtx oloc)\n {\n-  HOST_WIDE_INT ofst = 0;\n+  poly_int64 ofst = 0, term;\n   machine_mode mode = GET_MODE (oloc);\n   rtx loc = oloc;\n   rtx x;\n@@ -2165,9 +2165,9 @@ vt_canonicalize_addr (dataflow_set *set, rtx oloc)\n   while (retry)\n     {\n       while (GET_CODE (loc) == PLUS\n-\t     && GET_CODE (XEXP (loc, 1)) == CONST_INT)\n+\t     && poly_int_rtx_p (XEXP (loc, 1), &term))\n \t{\n-\t  ofst += INTVAL (XEXP (loc, 1));\n+\t  ofst += term;\n \t  loc = XEXP (loc, 0);\n \t}\n \n@@ -2192,10 +2192,11 @@ vt_canonicalize_addr (dataflow_set *set, rtx oloc)\n \t    loc = get_addr_from_global_cache (loc);\n \n \t  /* Consolidate plus_constants.  */\n-\t  while (ofst && GET_CODE (loc) == PLUS\n-\t\t && GET_CODE (XEXP (loc, 1)) == CONST_INT)\n+\t  while (maybe_ne (ofst, 0)\n+\t\t && GET_CODE (loc) == PLUS\n+\t\t && poly_int_rtx_p (XEXP (loc, 1), &term))\n \t    {\n-\t      ofst += INTVAL (XEXP (loc, 1));\n+\t      ofst += term;\n \t      loc = XEXP (loc, 0);\n \t    }\n \n@@ -2211,12 +2212,10 @@ vt_canonicalize_addr (dataflow_set *set, rtx oloc)\n     }\n \n   /* Add OFST back in.  */\n-  if (ofst)\n+  if (maybe_ne (ofst, 0))\n     {\n       /* Don't build new RTL if we can help it.  */\n-      if (GET_CODE (oloc) == PLUS\n-\t  && XEXP (oloc, 0) == loc\n-\t  && INTVAL (XEXP (oloc, 1)) == ofst)\n+      if (strip_offset (oloc, &term) == loc && known_eq (term, ofst))\n \treturn oloc;\n \n       loc = plus_constant (mode, loc, ofst);\n@@ -6094,7 +6093,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n     }\n \n   if (loc == stack_pointer_rtx\n-      && hard_frame_pointer_adjustment != -1\n+      && maybe_ne (hard_frame_pointer_adjustment, -1)\n       && preserve)\n     cselib_set_value_sp_based (v);\n \n@@ -8765,6 +8764,7 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n \t  && GET_CODE (loc[n_var_parts]) == GET_CODE (loc2))\n \t{\n \t  rtx new_loc = NULL;\n+\t  poly_int64 offset2;\n \n \t  if (REG_P (loc[n_var_parts])\n \t      && hard_regno_nregs (REGNO (loc[n_var_parts]), mode) * 2\n@@ -8789,18 +8789,13 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n \t  else if (MEM_P (loc[n_var_parts])\n \t\t   && GET_CODE (XEXP (loc2, 0)) == PLUS\n \t\t   && REG_P (XEXP (XEXP (loc2, 0), 0))\n-\t\t   && CONST_INT_P (XEXP (XEXP (loc2, 0), 1)))\n+\t\t   && poly_int_rtx_p (XEXP (XEXP (loc2, 0), 1), &offset2))\n \t    {\n-\t      if ((REG_P (XEXP (loc[n_var_parts], 0))\n-\t\t   && rtx_equal_p (XEXP (loc[n_var_parts], 0),\n-\t\t\t\t   XEXP (XEXP (loc2, 0), 0))\n-\t\t   && INTVAL (XEXP (XEXP (loc2, 0), 1)) == size)\n-\t\t  || (GET_CODE (XEXP (loc[n_var_parts], 0)) == PLUS\n-\t\t      && CONST_INT_P (XEXP (XEXP (loc[n_var_parts], 0), 1))\n-\t\t      && rtx_equal_p (XEXP (XEXP (loc[n_var_parts], 0), 0),\n-\t\t\t\t      XEXP (XEXP (loc2, 0), 0))\n-\t\t      && INTVAL (XEXP (XEXP (loc[n_var_parts], 0), 1)) + size\n-\t\t\t == INTVAL (XEXP (XEXP (loc2, 0), 1))))\n+\t      poly_int64 end1 = size;\n+\t      rtx base1 = strip_offset_and_add (XEXP (loc[n_var_parts], 0),\n+\t\t\t\t\t\t&end1);\n+\t      if (rtx_equal_p (base1, XEXP (XEXP (loc2, 0), 0))\n+\t\t  && known_eq (end1, offset2))\n \t\tnew_loc = adjust_address_nv (loc[n_var_parts],\n \t\t\t\t\t     wider_mode, 0);\n \t    }\n@@ -9670,20 +9665,17 @@ vt_add_function_parameter (tree parm)\n      rewrite the incoming location of parameters passed on the stack\n      into MEMs based on the argument pointer, so that incoming doesn't\n      depend on a pseudo.  */\n+  poly_int64 incoming_offset = 0;\n   if (MEM_P (incoming)\n-      && (XEXP (incoming, 0) == crtl->args.internal_arg_pointer\n-\t  || (GET_CODE (XEXP (incoming, 0)) == PLUS\n-\t      && XEXP (XEXP (incoming, 0), 0)\n-\t\t == crtl->args.internal_arg_pointer\n-\t      && CONST_INT_P (XEXP (XEXP (incoming, 0), 1)))))\n+      && (strip_offset (XEXP (incoming, 0), &incoming_offset)\n+\t  == crtl->args.internal_arg_pointer))\n     {\n       HOST_WIDE_INT off = -FIRST_PARM_OFFSET (current_function_decl);\n-      if (GET_CODE (XEXP (incoming, 0)) == PLUS)\n-\toff += INTVAL (XEXP (XEXP (incoming, 0), 1));\n       incoming\n \t= replace_equiv_address_nv (incoming,\n \t\t\t\t    plus_constant (Pmode,\n-\t\t\t\t\t\t   arg_pointer_rtx, off));\n+\t\t\t\t\t\t   arg_pointer_rtx,\n+\t\t\t\t\t\t   off + incoming_offset));\n     }\n \n #ifdef HAVE_window_save\n@@ -9990,7 +9982,7 @@ static bool\n vt_initialize (void)\n {\n   basic_block bb;\n-  HOST_WIDE_INT fp_cfa_offset = -1;\n+  poly_int64 fp_cfa_offset = -1;\n \n   alloc_aux_for_blocks (sizeof (variable_tracking_info));\n \n@@ -10105,7 +10097,7 @@ vt_initialize (void)\n \t{\n \t  if (GET_CODE (elim) == PLUS)\n \t    {\n-\t      fp_cfa_offset -= INTVAL (XEXP (elim, 1));\n+\t      fp_cfa_offset -= rtx_to_poly_int64 (XEXP (elim, 1));\n \t      elim = XEXP (elim, 0);\n \t    }\n \t  if (elim != hard_frame_pointer_rtx)\n@@ -10238,8 +10230,8 @@ vt_initialize (void)\n \t\t      VTI (bb)->out.stack_adjust += post;\n \t\t    }\n \n-\t\t  if (fp_cfa_offset != -1\n-\t\t      && hard_frame_pointer_adjustment == -1\n+\t\t  if (maybe_ne (fp_cfa_offset, -1)\n+\t\t      && known_eq (hard_frame_pointer_adjustment, -1)\n \t\t      && fp_setter_insn (insn))\n \t\t    {\n \t\t      vt_init_cfa_base ();"}]}