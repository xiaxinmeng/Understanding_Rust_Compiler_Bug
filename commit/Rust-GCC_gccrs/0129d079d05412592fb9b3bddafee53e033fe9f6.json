{"sha": "0129d079d05412592fb9b3bddafee53e033fe9f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyOWQwNzlkMDU0MTI1OTJmYjliM2JkZGFmZWU1M2UwMzNmZTlmNg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-11-25T21:23:27Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-11-25T21:23:27Z"}, "message": "cse.c (cse_altered): Remove.\n\n\t* cse.c (cse_altered): Remove.\n\t(record_jump_equiv): Make true/false argument a bool instead\n\tof an int.\n\t(cse_insn): Don't set cse_altered.  Use delete_insn_and_edges\n\twhere appropriate.  Emit a new jump before the existing one\n\tinstead of after so that delete_insn_and_edges removes the\n\tdead edges properly.  Check any_condjump_p before calling\n\trecord_jump_equiv.\n\t(cse_basic_block): Check any_condjump_p before calling\n\trecord_jump_equiv.\n\t(cse_main): Don't set/check cse_altered.  Remove USE_C_ALLOCA.\n\nFrom-SVN: r119209", "tree": {"sha": "4555801976230422922dfb334952ad6333bda406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4555801976230422922dfb334952ad6333bda406"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0129d079d05412592fb9b3bddafee53e033fe9f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0129d079d05412592fb9b3bddafee53e033fe9f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0129d079d05412592fb9b3bddafee53e033fe9f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0129d079d05412592fb9b3bddafee53e033fe9f6/comments", "author": null, "committer": null, "parents": [{"sha": "bbe7da4a15f047443504a5156ec3e8a7718fd867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe7da4a15f047443504a5156ec3e8a7718fd867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe7da4a15f047443504a5156ec3e8a7718fd867"}], "stats": {"total": 57, "additions": 28, "deletions": 29}, "files": [{"sha": "81328c39ad8e641a0ef7dd1f65ad89c631b2c341", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0129d079d05412592fb9b3bddafee53e033fe9f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0129d079d05412592fb9b3bddafee53e033fe9f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0129d079d05412592fb9b3bddafee53e033fe9f6", "patch": "@@ -1,3 +1,17 @@\n+2006-11-25  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cse.c (cse_altered): Remove.\n+\t(record_jump_equiv): Make true/false argument a bool instead\n+\tof an int.\n+\t(cse_insn): Don't set cse_altered.  Use delete_insn_and_edges\n+\twhere appropriate.  Emit a new jump before the existing one\n+\tinstead of after so that delete_insn_and_edges removes the\n+\tdead edges properly.  Check any_condjump_p before calling\n+\trecord_jump_equiv.\n+\t(cse_basic_block): Check any_condjump_p before calling\n+\trecord_jump_equiv.\n+\t(cse_main): Don't set/check cse_altered.  Remove USE_C_ALLOCA.\n+\n 2006-11-25  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* c.opt: Remove -ffixed-form, -ffixed-line-length-none, and"}, {"sha": "452757a3e4743914816f0c344d9d88f1bdd553e8", "filename": "gcc/cse.c", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0129d079d05412592fb9b3bddafee53e033fe9f6/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0129d079d05412592fb9b3bddafee53e033fe9f6/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=0129d079d05412592fb9b3bddafee53e033fe9f6", "patch": "@@ -371,11 +371,6 @@ static int max_uid;\n \n #define INSN_CUID(INSN) (uid_cuid[INSN_UID (INSN)])\n \n-/* Nonzero if this pass has made changes, and therefore it's\n-   worthwhile to run the garbage collector.  */\n-\n-static int cse_altered;\n-\n /* Nonzero if cse has altered conditional jump insns\n    in such a way that jump optimization should be redone.  */\n \n@@ -603,7 +598,7 @@ static enum rtx_code find_comparison_args (enum rtx_code, rtx *, rtx *,\n \t\t\t\t\t   enum machine_mode *);\n static rtx fold_rtx (rtx, rtx);\n static rtx equiv_constant (rtx);\n-static void record_jump_equiv (rtx, int);\n+static void record_jump_equiv (rtx, bool);\n static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n \t\t\t      int);\n static void cse_insn (rtx, rtx);\n@@ -3694,8 +3689,8 @@ equiv_constant (rtx x)\n   return 0;\n }\n \f\n-/* Given INSN, a jump insn, PATH_TAKEN indicates if we are following the \"taken\"\n-   branch.  It will be zero if not.\n+/* Given INSN, a jump insn, TAKEN indicates if we are following the\n+   \"taken\" branch.\n \n    In certain cases, this can cause us to add an equivalence.  For example,\n    if we are following the taken case of\n@@ -3706,7 +3701,7 @@ equiv_constant (rtx x)\n    comparison is seen later, we will know its value.  */\n \n static void\n-record_jump_equiv (rtx insn, int taken)\n+record_jump_equiv (rtx insn, bool taken)\n {\n   int cond_known_true;\n   rtx op0, op1;\n@@ -3716,8 +3711,8 @@ record_jump_equiv (rtx insn, int taken)\n   enum rtx_code code;\n \n   /* Ensure this is the right kind of insn.  */\n-  if (! any_condjump_p (insn))\n-    return;\n+  gcc_assert (any_condjump_p (insn));\n+\n   set = pc_set (insn);\n \n   /* See if this jump condition is known true or false.  */\n@@ -4942,7 +4937,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n       /* If we made a change, recompute SRC values.  */\n       if (src != sets[i].src)\n \t{\n-\t  cse_altered = 1;\n \t  do_not_record = 0;\n \t  hash_arg_in_memory = 0;\n \t  sets[i].src = src;\n@@ -5044,7 +5038,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n       else if (n_sets == 1 && dest == pc_rtx && src == pc_rtx)\n \t{\n \t  /* One less use of the label this insn used to jump to.  */\n-\t  delete_insn (insn);\n+\t  delete_insn_and_edges (insn);\n \t  cse_jumps_altered = 1;\n \t  /* No more processing for this set.  */\n \t  sets[i].rtl = 0;\n@@ -5071,7 +5065,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t    {\n \t      rtx new, note;\n \n-\t      new = emit_jump_insn_after (gen_jump (XEXP (src, 0)), insn);\n+\t      new = emit_jump_insn_before (gen_jump (XEXP (src, 0)), insn);\n \t      JUMP_LABEL (new) = XEXP (src, 0);\n \t      LABEL_NUSES (XEXP (src, 0))++;\n \n@@ -5083,7 +5077,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t  REG_NOTES (new) = note;\n \t\t}\n \n-\t      delete_insn (insn);\n+\t      delete_insn_and_edges (insn);\n \t      insn = new;\n \n \t      /* Now emit a BARRIER after the unconditional jump.  */\n@@ -5636,10 +5630,8 @@ cse_insn (rtx insn, rtx libcall_insn)\n   /* If this is a conditional jump insn, record any known equivalences due to\n      the condition being tested.  */\n \n-  if (JUMP_P (insn)\n-      && n_sets == 1 && GET_CODE (x) == SET\n-      && GET_CODE (SET_SRC (x)) == IF_THEN_ELSE)\n-    record_jump_equiv (insn, 0);\n+  if (n_sets == 1 && any_condjump_p (insn))\n+    record_jump_equiv (insn, false);\n \n #ifdef HAVE_cc0\n   /* If the previous insn set CC0 and this insn no longer references CC0,\n@@ -5649,7 +5641,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n       && (tem = single_set (prev_insn)) != 0\n       && SET_DEST (tem) == cc0_rtx\n       && ! reg_mentioned_p (cc0_rtx, x))\n-    delete_insn (prev_insn);\n+    delete_insn_and_edges (prev_insn);\n \n   prev_insn_cc0 = this_insn_cc0;\n   prev_insn_cc0_mode = this_insn_cc0_mode;\n@@ -6016,7 +6008,6 @@ cse_main (rtx f, int nregs)\n   insn = f;\n   while (insn)\n     {\n-      cse_altered = 0;\n       cse_end_of_basic_block (insn, &val, flag_cse_follow_jumps);\n \n       /* If this basic block was already processed or has no sets, skip it.  */\n@@ -6062,13 +6053,6 @@ cse_main (rtx f, int nregs)\n \n \t  cse_jumps_altered |= old_cse_jumps_altered;\n \t}\n-\n-      if (cse_altered)\n-\tggc_collect ();\n-\n-#ifdef USE_C_ALLOCA\n-      alloca (0);\n-#endif\n     }\n \n   /* Clean up.  */\n@@ -6130,7 +6114,8 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \t  if (status != PATH_NOT_TAKEN)\n \t    {\n \t      gcc_assert (status == PATH_TAKEN);\n-\t      record_jump_equiv (insn, 1);\n+\t      if (any_condjump_p (insn))\n+\t\trecord_jump_equiv (insn, true);\n \n \t      /* Set the last insn as the jump insn; it doesn't affect cc0.\n \t\t Then follow this branch.  */"}]}