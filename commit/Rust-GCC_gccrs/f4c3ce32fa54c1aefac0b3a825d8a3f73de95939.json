{"sha": "f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "node_id": "C_kwDOANBUbNoAKGY0YzNjZTMyZmE1NGMxYWVmYWMwYjNhODI1ZDhhM2Y3M2RlOTU5Mzk", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-14T13:56:59Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-15T10:33:42Z"}, "message": "d: Delay completing aggregate and enum types until after attributes have been applied.\n\nBecause of forward/recursive references, the TYPE_SIZE, TYPE_ALIGN, and\nTYPE_MODE of structs and enums were set before laying out its members.\n\nThis adds a new macro TYPE_FORWARD_REFERENCES for storing those forward\nreferences against the incomplete type, laying them out after the type\nhas been completed.  Construction of the TYPE_DECL has also been moved\non earlier in the type generation pass, which will allow the possibility\nof adding gdc-specific type attributes to the D front-end in the future.\n\ngcc/d/ChangeLog:\n\n\t* d-attribs.cc (apply_user_attributes): Set ATTR_FLAG_TYPE_IN_PLACE\n\tonly on incomplete types.\n\t* d-codegen.cc (copy_aggregate_type): Set TYPE_STUB_DECL after copy.\n\t* d-compiler.cc (Compiler::onParseModule): Adjust.\n\t* d-tree.h (AGGREGATE_OR_ENUM_TYPE_CHECK): Define.\n\t(TYPE_FORWARD_REFERENCES): Define.\n\t* decl.cc (gcc_attribute_p): Update documentation.\n\t(DeclVisitor::visit (StructDeclaration *)): Exit before building type\n\tnode if gcc.attributes symbol.\n\t(DeclVisitor::visit (ClassDeclaration *)): Build type node and add\n\tTYPE_NAME to current binding level before emitting anything else.\n\t(DeclVisitor::visit (InterfaceDeclaration *)): Likewise.\n\t(DeclVisitor::visit (EnumDeclaration *)): Likewise.\n\t(build_type_decl): Move rest_of_decl_compilation() call to\n\tfinish_aggregate_type().\n\t* types.cc (insert_aggregate_field): Move layout_decl() call to\n\tfinish_aggregate_type().\n\t(insert_aggregate_bitfield): Likewise.\n\t(layout_aggregate_members): Adjust.\n\t(finish_incomplete_fields): New function.\n\t(finish_aggregate_type): Handle forward referenced field types.  Call\n\trest_of_type_compilation() after completing the aggregate.\n\t(TypeVisitor::visit (TypeEnum *)): Don't set size and alignment until\n\tafter apply_user_attributes().  Call rest_of_type_compilation() after\n\tcompleting the enumeral.\n\t(TypeVisitor::visit (TypeStruct *)): Call build_type_decl() before\n\tapply_user_attributes().  Don't set size, alignment, and mode until\n\tafter apply_user_attributes().\n\t(TypeVisitor::visit (TypeClass *)): Call build_type_decl() before\n\tapplly_user_attributes().", "tree": {"sha": "d7b38ef3868c7d1619c1d23c513fa43d2800507e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7b38ef3868c7d1619c1d23c513fa43d2800507e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2636660b6f35423e0cfbf53bfad5c5fed6ae6471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2636660b6f35423e0cfbf53bfad5c5fed6ae6471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2636660b6f35423e0cfbf53bfad5c5fed6ae6471"}], "stats": {"total": 229, "additions": 159, "deletions": 70}, "files": [{"sha": "b8ce30cf3c983340b97b9939ac6f9d813bb3077a", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "patch": "@@ -424,9 +424,12 @@ apply_user_attributes (Dsymbol *sym, tree node)\n   location_t saved_location = input_location;\n   input_location = make_location_t (sym->loc);\n \n+  int attr_flags = 0;\n+  if (TYPE_P (node) && !COMPLETE_TYPE_P (node))\n+    attr_flags |= ATTR_FLAG_TYPE_IN_PLACE;\n+\n   Expressions *attrs = sym->userAttribDecl->getAttributes ();\n-  decl_attributes (&node, build_attributes (attrs),\n-\t\t   TYPE_P (node) ? ATTR_FLAG_TYPE_IN_PLACE : 0);\n+  decl_attributes (&node, build_attributes (attrs), attr_flags);\n \n   input_location = saved_location;\n }"}, {"sha": "0e14654e56b8af8b89d1b83f49747a529ff046a0", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "patch": "@@ -115,6 +115,7 @@ tree\n copy_aggregate_type (tree type)\n {\n   tree newtype = build_distinct_type_copy (type);\n+  TYPE_STUB_DECL (newtype) = TYPE_NAME (newtype);\n   TYPE_FIELDS (newtype) = copy_list (TYPE_FIELDS (type));\n \n   for (tree f = TYPE_FIELDS (newtype); f; f = DECL_CHAIN (f))"}, {"sha": "ada9721541bd2402d40c28c02a7c78f00285c567", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "patch": "@@ -129,22 +129,22 @@ Compiler::onParseModule (Module *m)\n   if (md && md->id)\n     {\n       if (md->packages.length == 0)\n-    \t{\n-    \t  Identifier *id = (md && md->id) ? md->id : m->ident;\n-    \t  if (!strcmp (id->toChars (), \"object\"))\n+\t{\n+\t  Identifier *id = (md && md->id) ? md->id : m->ident;\n+\t  if (!strcmp (id->toChars (), \"object\"))\n \t    {\n \t      create_tinfo_types (m);\n \t      return;\n \t    }\n \t}\n       else if (md->packages.length == 1)\n-    \t{\n-    \t  if (!strcmp (md->packages.ptr[0]->toChars (), \"gcc\")\n-    \t      && !strcmp (md->id->toChars (), \"builtins\"))\n-    \t    {\n-    \t      d_build_builtins_module (m);\n-    \t      return;\n-    \t    }\n+\t{\n+\t  if (!strcmp (md->packages.ptr[0]->toChars (), \"gcc\")\n+\t      && !strcmp (md->id->toChars (), \"builtins\"))\n+\t    {\n+\t      d_build_builtins_module (m);\n+\t      return;\n+\t    }\n \t}\n     }\n "}, {"sha": "48a40a6afa47d2c8ef40358353c79294fac374a4", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "patch": "@@ -57,6 +57,9 @@ typedef Array <Expression *> Expressions;\n    4: TYPE_DELEGATE (in RECORD_TYPE).\n    5: TYPE_ASSOCIATIVE_ARRAY (in RECORD_TYPE).\n \n+   Usage of TYPE_LANG_SLOT_?:\n+   1: TYPE_FORWARD_REFERENCES (in RECORD_TYPE, UNION_TYPE).\n+\n    Usage of DECL_LANG_FLAG_?:\n    0: LABEL_VARIABLE_CASE (in LABEL_DECL).\n       DECL_BUILT_IN_CTFE (in FUNCTION_DECL).\n@@ -68,6 +71,10 @@ typedef Array <Expression *> Expressions;\n #define VAR_OR_FUNCTION_DECL_CHECK(NODE) \\\n   TREE_CHECK2 (NODE, VAR_DECL, FUNCTION_DECL)\n \n+#define AGGREGATE_OR_ENUM_TYPE_CHECK(NODE) \\\n+  TREE_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, \\\n+\t       QUAL_UNION_TYPE, ENUMERAL_TYPE)\n+\n /* The kinds of scopes we recognize.  */\n \n enum level_kind\n@@ -378,6 +385,11 @@ lang_tree_node\n #define TYPE_ASSOCIATIVE_ARRAY(NODE) \\\n   (TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE)))\n \n+/* In an incomplete RECORD_TYPE, UNION_TYPE, or ENUMERAL_TYPE, a list of field\n+   declarations whose type would be completed by completing that type.  */\n+#define TYPE_FORWARD_REFERENCES(NODE) \\\n+  (TYPE_LANG_SLOT_1 (AGGREGATE_OR_ENUM_TYPE_CHECK (NODE)))\n+\n /* True if the decl is a variable case label decl.  */\n #define LABEL_VARIABLE_CASE(NODE) \\\n   (DECL_LANG_FLAG_0 (LABEL_DECL_CHECK (NODE)))"}, {"sha": "518d84c1a496acd8eb9f31b1843cab6238cb5177", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "patch": "@@ -99,7 +99,7 @@ mangle_internal_decl (Dsymbol *decl, const char *name, const char *suffix)\n   return ident;\n }\n \n-/* Returns true if DECL is from the gcc.attribute module.  */\n+/* Returns true if DECL is from the gcc.attributes module.  */\n \n static bool\n gcc_attribute_p (Dsymbol *decl)\n@@ -367,6 +367,10 @@ class DeclVisitor : public Visitor\n \treturn;\n       }\n \n+    /* Don't emit any symbols from gcc.attributes module.  */\n+    if (gcc_attribute_p (d))\n+      return;\n+\n     /* Add this decl to the current binding level.  */\n     tree ctype = build_ctype (d->type);\n     if (TYPE_NAME (ctype))\n@@ -377,10 +381,6 @@ class DeclVisitor : public Visitor\n     if (d->isAnonymous () || !d->members)\n       return;\n \n-    /* Don't emit any symbols from gcc.attribute module.  */\n-    if (gcc_attribute_p (d))\n-      return;\n-\n     /* Generate TypeInfo.  */\n     if (have_typeinfo_p (Type::dtypeinfo))\n       create_typeinfo (d->type, NULL);\n@@ -482,6 +482,11 @@ class DeclVisitor : public Visitor\n \treturn;\n       }\n \n+    /* Add this decl to the current binding level.  */\n+    tree ctype = TREE_TYPE (build_ctype (d->type));\n+    if (TYPE_NAME (ctype))\n+      d_pushdecl (TYPE_NAME (ctype));\n+\n     if (!d->members)\n       return;\n \n@@ -533,11 +538,6 @@ class DeclVisitor : public Visitor\n       = build_constructor (TREE_TYPE (vtblsym->csym), elms);\n     d_finish_decl (vtblsym->csym);\n \n-    /* Add this decl to the current binding level.  */\n-    tree ctype = TREE_TYPE (build_ctype (d->type));\n-    if (TYPE_NAME (ctype))\n-      d_pushdecl (TYPE_NAME (ctype));\n-\n     d->semanticRun = PASS::obj;\n   }\n \n@@ -556,6 +556,11 @@ class DeclVisitor : public Visitor\n \treturn;\n       }\n \n+    /* Add this decl to the current binding level.  */\n+    tree ctype = TREE_TYPE (build_ctype (d->type));\n+    if (TYPE_NAME (ctype))\n+      d_pushdecl (TYPE_NAME (ctype));\n+\n     if (!d->members)\n       return;\n \n@@ -576,11 +581,6 @@ class DeclVisitor : public Visitor\n     DECL_INITIAL (d->csym) = layout_classinfo (d);\n     d_finish_decl (d->csym);\n \n-    /* Add this decl to the current binding level.  */\n-    tree ctype = TREE_TYPE (build_ctype (d->type));\n-    if (TYPE_NAME (ctype))\n-      d_pushdecl (TYPE_NAME (ctype));\n-\n     d->semanticRun = PASS::obj;\n   }\n \n@@ -599,6 +599,11 @@ class DeclVisitor : public Visitor\n \treturn;\n       }\n \n+    /* Add this decl to the current binding level.  */\n+    tree ctype = build_ctype (d->type);\n+    if (TREE_CODE (ctype) == ENUMERAL_TYPE && TYPE_NAME (ctype))\n+      d_pushdecl (TYPE_NAME (ctype));\n+\n     if (d->isAnonymous ())\n       return;\n \n@@ -615,11 +620,6 @@ class DeclVisitor : public Visitor\n \td_finish_decl (d->sinit);\n       }\n \n-    /* Add this decl to the current binding level.  */\n-    tree ctype = build_ctype (d->type);\n-    if (TYPE_NAME (ctype))\n-      d_pushdecl (TYPE_NAME (ctype));\n-\n     d->semanticRun = PASS::obj;\n   }\n \n@@ -776,7 +776,7 @@ class DeclVisitor : public Visitor\n     if (d->semanticRun >= PASS::obj)\n       return;\n \n-    /* Don't emit any symbols from gcc.attribute module.  */\n+    /* Don't emit any symbols from gcc.attributes module.  */\n     if (gcc_attribute_p (d))\n       return;\n \n@@ -2336,8 +2336,6 @@ build_type_decl (tree type, Dsymbol *dsym)\n     }\n   else if (type != TYPE_MAIN_VARIANT (type))\n     DECL_ORIGINAL_TYPE (decl) = TYPE_MAIN_VARIANT (type);\n-\n-  rest_of_decl_compilation (decl, DECL_FILE_SCOPE_P (decl), 0);\n }\n \n /* Create a declaration for field NAME of a given TYPE, setting the flags"}, {"sha": "0926715b7dcc2c3063d58b2ebe3a35d5ad422c09", "filename": "gcc/d/types.cc", "status": "modified", "additions": 110, "deletions": 35, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c3ce32fa54c1aefac0b3a825d8a3f73de95939/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=f4c3ce32fa54c1aefac0b3a825d8a3f73de95939", "patch": "@@ -270,7 +270,6 @@ insert_aggregate_field (tree type, tree field, size_t offset)\n \n   TREE_ADDRESSABLE (field) = TYPE_SHARED (TREE_TYPE (field));\n \n-  layout_decl (field, 0);\n   TYPE_FIELDS (type) = chainon (TYPE_FIELDS (type), field);\n }\n \n@@ -326,17 +325,6 @@ insert_aggregate_bitfield (tree type, tree bitfield, size_t width,\n   DECL_BIT_FIELD (bitfield) = 1;\n   DECL_BIT_FIELD_TYPE (bitfield) = TREE_TYPE (bitfield);\n \n-  layout_decl (bitfield, 0);\n-\n-  /* Give bit-field its proper type after layout_decl.  */\n-  tree orig_type = DECL_BIT_FIELD_TYPE (bitfield);\n-  if (width != TYPE_PRECISION (orig_type))\n-    {\n-      TREE_TYPE (bitfield)\n-    \t= d_build_bitfield_integer_type (width, TYPE_UNSIGNED (orig_type));\n-      SET_DECL_MODE (bitfield, TYPE_MODE (TREE_TYPE (bitfield)));\n-    }\n-\n   TYPE_FIELDS (type) = chainon (TYPE_FIELDS (type), bitfield);\n }\n \n@@ -432,7 +420,7 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \t\t\t\t\t     bf->offset, bf->bitOffset);\n \t\t}\n \t      else\n-  \t\tinsert_aggregate_field (context, field, var->offset);\n+\t\tinsert_aggregate_field (context, field, var->offset);\n \n \t      /* Because the front-end shares field decls across classes, don't\n \t\t create the corresponding back-end symbol unless we are adding\n@@ -585,6 +573,35 @@ layout_aggregate_type (AggregateDeclaration *decl, tree type,\n     }\n }\n \n+/* If the aggregate type TYPE completes the type of any previous field\n+   declarations, lay them out now.  */\n+\n+static void\n+finish_incomplete_fields (tree type)\n+{\n+  for (tree fwdref = TYPE_FORWARD_REFERENCES (type); fwdref != NULL_TREE;\n+       fwdref = TREE_CHAIN (fwdref))\n+    {\n+      tree field = TREE_VALUE (fwdref);\n+      tree basetype = TREE_TYPE (field);\n+\n+      /* Arrays of TYPE have layout_type() called from build_array_type(), but\n+\t would skip over setting TYPE_SIZE. Try completing the type again.  */\n+      if (TREE_CODE (basetype) == ARRAY_TYPE)\n+\t{\n+\t  while (TREE_CODE (TREE_TYPE (basetype)) == ARRAY_TYPE)\n+\t    basetype = TREE_TYPE (basetype);\n+\n+\t  layout_type (basetype);\n+\t}\n+\n+      relayout_decl (field);\n+    }\n+\n+  /* No more forward references to process.  */\n+  TYPE_FORWARD_REFERENCES (type) = NULL_TREE;\n+}\n+\n /* Given a record type TYPE, whose size and alignment are determined by\n    STRUCTSIZE and ALIGNSIZE.  Apply any type attributes ATTRS and compute\n    the finalized record mode.  */\n@@ -601,18 +618,73 @@ finish_aggregate_type (unsigned structsize, unsigned alignsize, tree type)\n   /* Set the back-end type mode.  */\n   compute_record_mode (type);\n \n-  /* Fix up all variants of this aggregate type.  */\n+  /* Layout all fields now the type is complete.  */\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      /* If the field type is still being constructed because of recursive\n+\t references, attach it to that class/struct type, so we can go back\n+\t and complete the field later.  */\n+      if (!COMPLETE_TYPE_P (TREE_TYPE (field)))\n+\t{\n+\t  tree basetype = TREE_TYPE (field);\n+\t  while (TREE_CODE (basetype) == ARRAY_TYPE)\n+\t    basetype = TREE_TYPE (basetype);\n+\n+\t  basetype = TYPE_MAIN_VARIANT (basetype);\n+\t  if (RECORD_OR_UNION_TYPE_P (basetype)\n+\t      || TREE_CODE (basetype) == ENUMERAL_TYPE)\n+\t    {\n+\t      gcc_assert (!COMPLETE_TYPE_P (basetype));\n+\t      tree fwdrefs = tree_cons (NULL_TREE, field,\n+\t\t\t\t\tTYPE_FORWARD_REFERENCES (basetype));\n+\t      TYPE_FORWARD_REFERENCES (basetype) = fwdrefs;\n+\t    }\n+\n+\t  continue;\n+\t}\n+\n+      layout_decl (field, 0);\n+\n+      /* Give bit-field its proper type after layout_decl.  */\n+      if (DECL_BIT_FIELD (field))\n+\t{\n+\t  tree orig_type = DECL_BIT_FIELD_TYPE (field);\n+\t  unsigned HOST_WIDE_INT width = tree_to_uhwi (DECL_SIZE (field));\n+\n+\t  if (width != TYPE_PRECISION (orig_type))\n+\t    {\n+\t      bool unsignedp = TYPE_UNSIGNED (orig_type);\n+\n+\t      TREE_TYPE (field)\n+\t\t= d_build_bitfield_integer_type (width, unsignedp);\n+\t      SET_DECL_MODE (field, TYPE_MODE (TREE_TYPE (field)));\n+\t    }\n+\t}\n+    }\n+\n+  /* Fix up all forward-referenced variants of this aggregate type.  */\n   for (tree t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n     {\n       if (t == type)\n \tcontinue;\n \n       TYPE_FIELDS (t) = TYPE_FIELDS (type);\n       TYPE_LANG_SPECIFIC (t) = TYPE_LANG_SPECIFIC (type);\n+      TYPE_SIZE (t) = TYPE_SIZE (type);\n+      TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (type);\n+      TYPE_PACKED (type) = TYPE_PACKED (type);\n+      SET_TYPE_MODE (t, TYPE_MODE (type));\n       SET_TYPE_ALIGN (t, TYPE_ALIGN (type));\n       TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (type);\n-      gcc_assert (TYPE_MODE (t) == TYPE_MODE (type));\n     }\n+\n+  /* Finish debugging output for this type.  */\n+  rest_of_type_compilation (type, TYPE_FILE_SCOPE_P (type));\n+  finish_incomplete_fields (type);\n+\n+  /* Finish processing of TYPE_DECL.  */\n+  rest_of_decl_compilation (TYPE_NAME (type),\n+\t\t\t    DECL_FILE_SCOPE_P (TYPE_NAME (type)), 0);\n }\n \n /* Returns true if the class or struct type TYPE has already been layed out by\n@@ -1021,13 +1093,6 @@ class TypeVisitor : public Visitor\n \tif (flag_short_enums)\n \t  TYPE_PACKED (t->ctype) = 1;\n \n-\tTYPE_PRECISION (t->ctype) = t->size (t->sym->loc) * 8;\n-\tTYPE_SIZE (t->ctype) = 0;\n-\n-\tTYPE_MIN_VALUE (t->ctype) = TYPE_MIN_VALUE (basetype);\n-\tTYPE_MAX_VALUE (t->ctype) = TYPE_MAX_VALUE (basetype);\n-\tlayout_type (t->ctype);\n-\n \ttree values = NULL_TREE;\n \tif (t->sym->members)\n \t  {\n@@ -1057,11 +1122,31 @@ class TypeVisitor : public Visitor\n \t  }\n \n \tTYPE_VALUES (t->ctype) = values;\n-\tTYPE_UNSIGNED (t->ctype) = TYPE_UNSIGNED (basetype);\n \tbuild_type_decl (t->ctype, t->sym);\n       }\n \n     apply_user_attributes (t->sym, t->ctype);\n+\n+    /* Finish the enumeration type.  */\n+    if (TREE_CODE (t->ctype) == ENUMERAL_TYPE)\n+      {\n+\tTYPE_MIN_VALUE (t->ctype) = TYPE_MIN_VALUE (basetype);\n+\tTYPE_MAX_VALUE (t->ctype) = TYPE_MAX_VALUE (basetype);\n+\tTYPE_UNSIGNED (t->ctype) = TYPE_UNSIGNED (basetype);\n+\tSET_TYPE_ALIGN (t->ctype, TYPE_ALIGN (basetype));\n+\tTYPE_SIZE (t->ctype) = NULL_TREE;\n+\tTYPE_PRECISION (t->ctype) = t->size (t->sym->loc) * 8;\n+\n+\tlayout_type (t->ctype);\n+\n+\t/* Finish debugging output for this type.  */\n+\trest_of_type_compilation (t->ctype, TYPE_FILE_SCOPE_P (t->ctype));\n+\tfinish_incomplete_fields (t->ctype);\n+\n+\t/* Finish processing of TYPE_DECL.  */\n+\trest_of_decl_compilation (TYPE_NAME (t->ctype),\n+\t\t\t\t  DECL_FILE_SCOPE_P (TYPE_NAME (t->ctype)), 0);\n+      }\n   }\n \n   /* Build a struct or union type.  Layout should be exactly represented\n@@ -1092,21 +1177,13 @@ class TypeVisitor : public Visitor\n \tunsigned alignsize = t->sym->alignment.isDefault ()\n \t  ? t->sym->alignsize : t->sym->alignment.get ();\n \n-\tTYPE_SIZE (t->ctype) = bitsize_int (structsize * BITS_PER_UNIT);\n-\tTYPE_SIZE_UNIT (t->ctype) = size_int (structsize);\n-\tSET_TYPE_ALIGN (t->ctype, alignsize * BITS_PER_UNIT);\n-\tTYPE_PACKED (t->ctype) = (alignsize == 1);\n-\tcompute_record_mode (t->ctype);\n-\n \t/* Put out all fields.  */\n \tlayout_aggregate_type (t->sym, t->ctype, t->sym);\n+\tbuild_type_decl (t->ctype, t->sym);\n \tapply_user_attributes (t->sym, t->ctype);\n \tfinish_aggregate_type (structsize, alignsize, t->ctype);\n       }\n \n-    TYPE_CONTEXT (t->ctype) = d_decl_context (t->sym);\n-    build_type_decl (t->ctype, t->sym);\n-\n     /* For structs with a user defined postblit, copy constructor, or a\n        destructor, also set TREE_ADDRESSABLE on the type and all variants.\n        This will make the struct be passed around by reference.  */\n@@ -1146,6 +1223,7 @@ class TypeVisitor : public Visitor\n \n     /* Put out all fields, including from each base class.  */\n     layout_aggregate_type (t->sym, basetype, t->sym);\n+    build_type_decl (basetype, t->sym);\n     apply_user_attributes (t->sym, basetype);\n     finish_aggregate_type (t->sym->structsize, t->sym->alignsize, basetype);\n \n@@ -1183,9 +1261,6 @@ class TypeVisitor : public Visitor\n \t    && !chain_member (method, TYPE_FIELDS (basetype)))\n \t  TYPE_FIELDS (basetype) = chainon (TYPE_FIELDS (basetype), method);\n       }\n-\n-    TYPE_CONTEXT (basetype) = d_decl_context (t->sym);\n-    build_type_decl (basetype, t->sym);\n   }\n };\n "}]}