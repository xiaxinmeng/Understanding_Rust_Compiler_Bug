{"sha": "b5d3d7871c2e395fb7162712aebb81c90da3689b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVkM2Q3ODcxYzJlMzk1ZmI3MTYyNzEyYWViYjgxYzkwZGEzNjg5Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-31T10:36:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-31T10:36:56Z"}, "message": "fold-const.c (fold_binary_loc): Remove X ^ C1 == C2 -> X == (C1 ^ C2) which is already implemented in match.pd.\n\n2015-07-31  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (fold_binary_loc): Remove X ^ C1 == C2\n\t-> X == (C1 ^ C2) which is already implemented in match.pd.\n\tRemove redundant dispatching to fold_relational_const.\n\tMove unordered self and NaN compares ...\n\t* match.pd: ... as patterns here.  Remove some stray captures\n\tand add a comment.\n\nFrom-SVN: r226434", "tree": {"sha": "2184e3ed55116144918b7eb478e4f13628a380af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2184e3ed55116144918b7eb478e4f13628a380af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5d3d7871c2e395fb7162712aebb81c90da3689b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d3d7871c2e395fb7162712aebb81c90da3689b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5d3d7871c2e395fb7162712aebb81c90da3689b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d3d7871c2e395fb7162712aebb81c90da3689b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f063c6121671fec8eef28a47f68e66028d86ebed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f063c6121671fec8eef28a47f68e66028d86ebed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f063c6121671fec8eef28a47f68e66028d86ebed"}], "stats": {"total": 86, "additions": 34, "deletions": 52}, "files": [{"sha": "6163e023e28962b42ac2849f304430b507ad9428", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5d3d7871c2e395fb7162712aebb81c90da3689b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5d3d7871c2e395fb7162712aebb81c90da3689b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5d3d7871c2e395fb7162712aebb81c90da3689b", "patch": "@@ -1,3 +1,12 @@\n+2015-07-31  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (fold_binary_loc): Remove X ^ C1 == C2\n+\t-> X == (C1 ^ C2) which is already implemented in match.pd.\n+\tRemove redundant dispatching to fold_relational_const.\n+\tMove unordered self and NaN compares ...\n+\t* match.pd: ... as patterns here.  Remove some stray captures\n+\tand add a comment.\n+\n 2015-07-31  Petr Murzin  <petr.murzin@intel.com>\n \n \t* config/i386/i386.c"}, {"sha": "6c65fe1c7860e8101d6ee1a0ef8885ecd283bac7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5d3d7871c2e395fb7162712aebb81c90da3689b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5d3d7871c2e395fb7162712aebb81c90da3689b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b5d3d7871c2e395fb7162712aebb81c90da3689b", "patch": "@@ -11002,17 +11002,6 @@ fold_binary_loc (location_t loc,\n \t  && code == NE_EXPR)\n         return non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n \n-      /* Similarly for a BIT_XOR_EXPR;  X ^ C1 == C2 is X == (C1 ^ C2).  */\n-      if (TREE_CODE (arg0) == BIT_XOR_EXPR\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\treturn fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0),\n-\t\t\t    fold_build2_loc (loc, BIT_XOR_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t\t fold_convert_loc (loc,\n-\t\t\t\t\t\t\t   TREE_TYPE (arg0),\n-\t\t\t\t\t\t\t   arg1),\n-\t\t\t\t\t TREE_OPERAND (arg0, 1)));\n-\n       /* Transform comparisons of the form X +- Y CMP X to Y CMP 0.  */\n       if ((TREE_CODE (arg0) == PLUS_EXPR\n \t   || TREE_CODE (arg0) == POINTER_PLUS_EXPR\n@@ -11693,45 +11682,6 @@ fold_binary_loc (location_t loc,\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n     case LTGT_EXPR:\n-      if (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n-\t{\n-\t  t1 = fold_relational_const (code, type, arg0, arg1);\n-\t  if (t1 != NULL_TREE)\n-\t    return t1;\n-\t}\n-\n-      /* If the first operand is NaN, the result is constant.  */\n-      if (TREE_CODE (arg0) == REAL_CST\n-\t  && REAL_VALUE_ISNAN (TREE_REAL_CST (arg0))\n-\t  && (code != LTGT_EXPR || ! flag_trapping_math))\n-\t{\n-\t  t1 = (code == ORDERED_EXPR || code == LTGT_EXPR)\n-\t       ? integer_zero_node\n-\t       : integer_one_node;\n-\t  return omit_one_operand_loc (loc, type, t1, arg1);\n-\t}\n-\n-      /* If the second operand is NaN, the result is constant.  */\n-      if (TREE_CODE (arg1) == REAL_CST\n-\t  && REAL_VALUE_ISNAN (TREE_REAL_CST (arg1))\n-\t  && (code != LTGT_EXPR || ! flag_trapping_math))\n-\t{\n-\t  t1 = (code == ORDERED_EXPR || code == LTGT_EXPR)\n-\t       ? integer_zero_node\n-\t       : integer_one_node;\n-\t  return omit_one_operand_loc (loc, type, t1, arg0);\n-\t}\n-\n-      /* Simplify unordered comparison of something with itself.  */\n-      if ((code == UNLE_EXPR || code == UNGE_EXPR || code == UNEQ_EXPR)\n-\t  && operand_equal_p (arg0, arg1, 0))\n-\treturn constant_boolean_node (1, type);\n-\n-      if (code == LTGT_EXPR\n-\t  && !flag_trapping_math\n-\t  && operand_equal_p (arg0, arg1, 0))\n-\treturn constant_boolean_node (0, type);\n-\n       /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n       {\n \ttree targ0 = strip_float_extensions (arg0);"}, {"sha": "80ada214545b82f3f6e01303ff982b2f7433006d", "filename": "gcc/match.pd", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5d3d7871c2e395fb7162712aebb81c90da3689b/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5d3d7871c2e395fb7162712aebb81c90da3689b/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b5d3d7871c2e395fb7162712aebb81c90da3689b", "patch": "@@ -1471,6 +1471,14 @@ along with GCC; see the file COPYING3.  If not see\n        || ! FLOAT_TYPE_P (TREE_TYPE (@0))\n        || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (@0))))\n    { constant_boolean_node (false, type); })))\n+(for cmp (unle unge uneq)\n+ (simplify\n+  (cmp @0 @0)\n+  { constant_boolean_node (true, type); }))\n+(simplify\n+ (ltgt @0 @0)\n+ (if (!flag_trapping_math)\n+  { constant_boolean_node (false, type); }))\n \n /* Fold ~X op ~Y as Y op X.  */\n (for cmp (simple_comparison)\n@@ -1941,19 +1949,34 @@ along with GCC; see the file COPYING3.  If not see\n \t (ge (convert:st @0) { build_zero_cst (st); })\n \t (lt (convert:st @0) { build_zero_cst (st); }))))))))))\n  \n+(for cmp (unordered ordered unlt unle ungt unge uneq ltgt)\n+ /* If the second operand is NaN, the result is constant.  */\n+ (simplify\n+  (cmp @0 REAL_CST@1)\n+  (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@1))\n+       && (cmp != LTGT_EXPR || ! flag_trapping_math))\n+   { constant_boolean_node (cmp == ORDERED_EXPR || code == LTGT_EXPR\n+\t\t\t    ? false : true, type); })))\n \n /* bool_var != 0 becomes bool_var.  */\n (simplify\n- (ne @0 integer_zerop@1)\n+ (ne @0 integer_zerop)\n  (if (TREE_CODE (TREE_TYPE (@0)) == BOOLEAN_TYPE\n       && types_match (type, TREE_TYPE (@0)))\n   (non_lvalue @0)))\n /* bool_var == 1 becomes bool_var.  */\n (simplify\n- (eq @0 integer_onep@1)\n+ (eq @0 integer_onep)\n  (if (TREE_CODE (TREE_TYPE (@0)) == BOOLEAN_TYPE\n       && types_match (type, TREE_TYPE (@0)))\n   (non_lvalue @0)))\n+/* Do not handle\n+   bool_var == 0 becomes !bool_var or\n+   bool_var != 1 becomes !bool_var\n+   here because that only is good in assignment context as long\n+   as we require a tcc_comparison in GIMPLE_CONDs where we'd\n+   replace if (x == 0) with tem = ~x; if (tem != 0) which is\n+   clearly less optimal and which we'll transform again in forwprop.  */\n \n \n /* Simplification of math builtins.  */"}]}