{"sha": "8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4MWZiNGVhMjRiYTc4NjIyOTkxMTQxYjlhZDJmMzZiZWExZWM4NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T08:01:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T08:01:05Z"}, "message": "[multiple changes]\n\n2014-01-21  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Build_Init_Procedure): For\n\tderivations of interfaces, do not move the the initialization\n\tof the _parent field since such assignment is not generated.\n\n2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Rewrite_Renamed_Operator): Do not replace entity\n\twith the operator it renames if we are within an expression of\n\ta pre/postcondition, because the expression will be reanalyzed\n\tat a later point, and the analysis of the renaming may affect\n\tthe visibility of the operator when in an instance.\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* sinfo.ads, sinfo.adb: Change Do_Discriminant_Check to use new Flag1.\n\tAdd this flag to type conversion nodes and assignment nodes.\n\t* treepr.adb: Deal properly with Flag 1,2,3.\n\t* treeprs.adt: Minor comment update.\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_eval.adb (Compile_Time_Known_Value): Add Ignore_CRT\n\tparameter.\n\t* sem_eval.ads (Compile_Time_Known_Value): Add Ignore_CRT\n\tparameter, completely rewrite spec.\n\n2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Install_Withed_Unit): If the unit is a subprogram\n\tinstance that is inlined, it may have been rewritten as a wrapper\n\tpackage. In that case the unit that must be made visible is the\n\trelated instance of the package.\n\n2014-01-21  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch9.adb (Expand_N_Selective_Accept.Add_Accept): Refine\n\tprevious change in codepeer mode.\n\nFrom-SVN: r206874", "tree": {"sha": "fb8bbd826828d0725d3c0eee2dbf21fdf86f3ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb8bbd826828d0725d3c0eee2dbf21fdf86f3ebc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/comments", "author": null, "committer": null, "parents": [{"sha": "6b6041ec651c69871cc4c8d0ba3621c575b97e75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6041ec651c69871cc4c8d0ba3621c575b97e75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6041ec651c69871cc4c8d0ba3621c575b97e75"}], "stats": {"total": 254, "additions": 181, "deletions": 73}, "files": [{"sha": "48891bfc4a410f2252d2d2810b08e9098c9ef2af", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -1,3 +1,43 @@\n+2014-01-21  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Init_Procedure): For\n+\tderivations of interfaces, do not move the the initialization\n+\tof the _parent field since such assignment is not generated.\n+\n+2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Rewrite_Renamed_Operator): Do not replace entity\n+\twith the operator it renames if we are within an expression of\n+\ta pre/postcondition, because the expression will be reanalyzed\n+\tat a later point, and the analysis of the renaming may affect\n+\tthe visibility of the operator when in an instance.\n+\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinfo.ads, sinfo.adb: Change Do_Discriminant_Check to use new Flag1.\n+\tAdd this flag to type conversion nodes and assignment nodes.\n+\t* treepr.adb: Deal properly with Flag 1,2,3.\n+\t* treeprs.adt: Minor comment update.\n+\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_eval.adb (Compile_Time_Known_Value): Add Ignore_CRT\n+\tparameter.\n+\t* sem_eval.ads (Compile_Time_Known_Value): Add Ignore_CRT\n+\tparameter, completely rewrite spec.\n+\n+2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Install_Withed_Unit): If the unit is a subprogram\n+\tinstance that is inlined, it may have been rewritten as a wrapper\n+\tpackage. In that case the unit that must be made visible is the\n+\trelated instance of the package.\n+\n+2014-01-21  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch9.adb (Expand_N_Selective_Accept.Add_Accept): Refine\n+\tprevious change in codepeer mode.\n+\n 2014-01-21  Arnaud Charlet  <charlet@adacore.com>\n \n \t* exp_ch9.adb (Expand_N_Selective_Accept.Add_Accept): Always add"}, {"sha": "da0ac4c01bb0aa563b846345c0159e77cc1542bb", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -2386,10 +2386,16 @@ package body Exp_Ch3 is\n                               Component_List (Record_Extension_Node));\n \n                begin\n-                  --  The parent field must be initialized first because\n-                  --  the offset of the new discriminants may depend on it\n+                  --  The parent field must be initialized first because the\n+                  --  offset of the new discriminants may depend on it. This is\n+                  --  not needed if the parent is an interface type because in\n+                  --  such case the initialization of the _parent field was not\n+                  --  generated.\n+\n+                  if not Is_Interface (Etype (Rec_Ent)) then\n+                     Prepend_To (Body_Stmts, Remove_Head (Stmts));\n+                  end if;\n \n-                  Prepend_To (Body_Stmts, Remove_Head (Stmts));\n                   Append_List_To (Body_Stmts, Stmts);\n                end;\n             end if;"}, {"sha": "a03778ef30df7cfcf968cb1ac1bad353ac292342", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -10339,17 +10339,21 @@ package body Exp_Ch9 is\n          if Present (Handled_Statement_Sequence (Accept_Statement (Alt))) then\n             Null_Body := New_Reference_To (Standard_False, Eloc);\n \n-            --  Always add call to Abort_Undefer, since this is what the\n-            --  runtime expects (abort deferred in Selective_Wait).\n-\n-            Call :=\n-              Make_Procedure_Call_Statement (Eloc,\n-                Name => New_Reference_To (RTE (RE_Abort_Undefer), Eloc));\n-            Insert_Before\n-              (First (Statements (Handled_Statement_Sequence\n-                                    (Accept_Statement (Alt)))),\n-               Call);\n-            Analyze (Call);\n+            --  Always add call to Abort_Undefer when generating code, since\n+            --  this is what the runtime expects (abort deferred in\n+            --  Selective_Wait). In CodePeer mode this only confuses the\n+            --  analysis with unknown calls, so don't do it.\n+\n+            if not CodePeer_Mode then\n+               Call :=\n+                 Make_Procedure_Call_Statement (Eloc,\n+                   Name => New_Reference_To (RTE (RE_Abort_Undefer), Eloc));\n+               Insert_Before\n+                 (First (Statements (Handled_Statement_Sequence\n+                                       (Accept_Statement (Alt)))),\n+                  Call);\n+               Analyze (Call);\n+            end if;\n \n             PB_Ent :=\n               Make_Defining_Identifier (Eloc,"}, {"sha": "52e5c21615ae61ed6ec7234d5db0e89c263b95ac", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -5156,6 +5156,14 @@ package body Sem_Ch10 is\n \n             Set_Is_Visible_Lib_Unit (Uname);\n \n+            --  If the unit is a wrapper package for a compilation unit that is\n+            --  a subprogrm instance, indicate that the instance itself is a\n+            --  visible unit. This is necessary if the instance is inlined.\n+\n+            if Is_Wrapper_Package (Uname) then\n+               Set_Is_Visible_Lib_Unit (Related_Instance (Uname));\n+            end if;\n+\n             --  If the child unit appears in the context of its parent, it is\n             --  immediately visible.\n \n@@ -6447,6 +6455,7 @@ package body Sem_Ch10 is\n \n       --  If the unit is a wrapper package, the subprogram instance is\n       --  what must be removed from visibility.\n+      --  Should we use Related_Instance instead???\n \n       if Is_Wrapper_Package (Unit_Name) then\n          Set_Is_Immediately_Visible (Current_Entity (Unit_Name), False);"}, {"sha": "d69c3414cefcfd2fae01691bc557ecaad420e7d1", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -1287,7 +1287,10 @@ package body Sem_Eval is\n    -- Compile_Time_Known_Value --\n    ------------------------------\n \n-   function Compile_Time_Known_Value (Op : Node_Id) return Boolean is\n+   function Compile_Time_Known_Value\n+     (Op         : Node_Id;\n+      Ignore_CRT : Boolean := False) return Boolean\n+   is\n       K      : constant Node_Kind := Nkind (Op);\n       CV_Ent : CV_Entry renames CV_Cache (Nat (Op) mod CV_Cache_Size);\n \n@@ -1311,9 +1314,9 @@ package body Sem_Eval is\n       --  time. This avoids anomalies where whether something is allowed with a\n       --  given configurable run-time library depends on how good the compiler\n       --  is at optimizing and knowing that things are constant when they are\n-      --  nonstatic.\n+      --  nonstatic. This check is suppressed if Ignore_CRT is True\n \n-      if Configurable_Run_Time_Mode\n+      if (Configurable_Run_Time_Mode and not Ignore_CRT)\n         and then K /= N_Null\n         and then not Is_Static_Expression (Op)\n       then\n@@ -1326,7 +1329,6 @@ package body Sem_Eval is\n            and then Etype (Entity (Op)) = Standard_Boolean\n          then\n             null;\n-\n          else\n             return False;\n          end if;"}, {"sha": "c3a5e30461e1da621aed67162b4ce82458959a30", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -85,23 +85,23 @@ package Sem_Eval is\n    --  does not raise constraint error. In fact for certain legality checks not\n    --  only do we need to ascertain that the expression is static, but we must\n    --  also ensure that it does not raise constraint error.\n-   --\n+\n    --  Neither of Is_Static_Expression and Is_OK_Static_Expression should be\n    --  used for compile time evaluation purposes. In fact certain expression\n-   --  whose value is known at compile time are not static in the RM 4.9 sense.\n-   --  A typical example is:\n-   --\n+   --  whose value may be known at compile time are not static in the RM 4.9\n+   --  sense. A typical example is:\n+\n    --     C : constant Integer := Record_Type'Size;\n-   --\n+\n    --  The expression 'C' is not static in the technical RM sense, but for many\n    --  simple record types, the size is in fact known at compile time. When we\n    --  are trying to perform compile time constant folding (for instance for\n    --  expressions like C + 1, Is_Static_Expression or Is_OK_Static_Expression\n    --  are not the right functions to test if folding is possible. Instead, we\n    --  use Compile_Time_Known_Value. All static expressions that do not raise\n    --  constraint error (i.e. those for which Is_OK_Static_Expression is true)\n-   --  are known at compile time, but as shown by the above example, there are\n-   --  cases of non-static expressions which are known at compile time.\n+   --  are known at compile time, but as shown by the above example, there may\n+   --  be cases of non-static expressions which are known at compile time.\n \n    -----------------\n    -- Subprograms --\n@@ -224,15 +224,60 @@ package Sem_Eval is\n    --  Determine whether two types T1, T2, which have the same base type,\n    --  are statically matching subtypes (RM 4.9.1(1-2)).\n \n-   function Compile_Time_Known_Value (Op : Node_Id) return Boolean;\n+   function Compile_Time_Known_Value\n+     (Op         : Node_Id;\n+      Ignore_CRT : Boolean := False) return Boolean;\n    --  Returns true if Op is an expression not raising Constraint_Error whose\n-   --  value is known at compile time. This is true if Op is a static\n+   --  value is known at compile time and for which a call to Expr_Value can\n+   --  be used to determine this value. This is always true if Op is a static\n    --  expression, but can also be true for expressions which are technically\n-   --  non-static but which are in fact known at compile time, such as the\n-   --  static lower bound of a non-static range or the value of a constant\n-   --  object whose initial value is static. Note that this routine is defended\n-   --  against unanalyzed expressions. Such expressions will not cause a\n-   --  blowup, they may cause pessimistic (i.e. False) results to be returned.\n+   --  non-static but which are in fact known at compile time. Some possible\n+   --  examples of such expressions might be the static lower bound of a\n+   --  non-static range or the value of a constant object whose initial\n+   --  value is itself compile time known in the sense of this routine. Note\n+   --  that this routine is defended against unanalyzed expressions. Such\n+   --  expressions will not cause a blowup, they may cause pessimistic (i.e.\n+   --  False) results to be returned. In general we take a pessimistic view.\n+   --  False does not mean the value could not be known at compile time, but\n+   --  True means that absolutely definition it is known at compile time and\n+   --  it is safe to call Expr_Value on the expression Op.\n+   --\n+   --  Note that we don't define precisely the set of expressions that return\n+   --  True. Callers should not make any assumptions regarding the value that\n+   --  is returned for non-static expressions. Functional behavior should never\n+   --  be affected by whether a given non-static expression returns True or\n+   --  False when this function is called. In other words this is purely for\n+   --  efficiency optimization purposes. The code generated can often be more\n+   --  efficient with compile time known values, e.g. range analysis for the\n+   --  purpose of removing checks is more effective if we know precise bounds.\n+   --\n+   --  The Ignore_CRT parameter has to do with the special case of configurable\n+   --  runtime mode. Consider the following example:\n+   --\n+   --    X := B ** C;\n+   --\n+   --  Now if C is compile time known, and has the value 4, then inline code\n+   --  can be generated at compile time, instead of calling a run-time routine.\n+   --  That's fine in the normal case, but when we have a configurable run-time\n+   --  the run-time routine may not be available. This means that the program\n+   --  will be rejected if C is not known at compile time. We don't want the\n+   --  legality of a program to depend on how clever the implementation of this\n+   --  function is. If the run-time in use lacks the exponentiation routine,\n+   --  then what we say is that exponentiation is permitted if the exponent is\n+   --  officially static and has a value in the range 0 .. 4.\n+   --\n+   --  However, in the normal case, we want efficient code in the case where\n+   --  a non-static exponent is known at compile time. To take care of this,\n+   --  the normal default behavior is that in configurable run-time mode most\n+   --  expressions are considered known at compile time ONLY in the case where\n+   --  they are officially static. An exception is boolean objects which may\n+   --  be considered known at compile time even in configurable run-time mode.\n+   --\n+   --  That loses optimization opportunities, and it would be better to look\n+   --  case by case at each use of Compile_Time_Known_Value to see if this\n+   --  configurable run-time mode special processing is needed. The Ignore_CRT\n+   --  parameter can be set to True to ignore this special handling in cases\n+   --  where it is known to be safe to do so.\n \n    function Compile_Time_Known_Value_Or_Aggr (Op : Node_Id) return Boolean;\n    --  Similar to Compile_Time_Known_Value, but also returns True if the value"}, {"sha": "3dca78ec14fc211c2d5ee1b7d9d5851fe7b4fe1b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -10301,6 +10301,14 @@ package body Sem_Res is\n       Op_Node   : Node_Id;\n \n    begin\n+      --  Do not perform this transformation within a pre/postcondition,\n+      --  because the expression will be re-analyzed, and the transformation\n+      --  might affect the visibility of the operator, e.g. in an instance.\n+\n+      if In_Assertion_Expr > 0 then\n+         return;\n+      end if;\n+\n       --  Rewrite the operator node using the real operator, not its renaming.\n       --  Exclude user-defined intrinsic operations of the same name, which are\n       --  treated separately and rewritten as calls."}, {"sha": "8556f3e776b4e231ee623ccddb375a472255890e", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -930,8 +930,10 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Selected_Component);\n-      return Flag13 (N);\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Selected_Component\n+        or else NT (N).Nkind = N_Type_Conversion);\n+      return Flag1 (N);\n    end Do_Discriminant_Check;\n \n    function Do_Division_Check\n@@ -4078,8 +4080,10 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Selected_Component);\n-      Set_Flag13 (N, Val);\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Selected_Component\n+        or else NT (N).Nkind = N_Type_Conversion);\n+      Set_Flag1 (N, Val);\n    end Set_Do_Discriminant_Check;\n \n    procedure Set_Do_Division_Check"}, {"sha": "f0af4a2cbeae69bb20c7d39cfa334c2cd2470a44", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -638,9 +638,7 @@ package Sinfo is\n    --    A flag set in the N_Subprogram_Body node for a subprogram body which\n    --    is acting as its own spec, except in the case of a library level\n    --    subprogram, in which case the flag is set on the parent compilation\n-   --    unit node instead (see further description in spec of Lib package).\n-   --    ??? Above note about Lib is dubious since lib.ads does not mention\n-   --    Acts_As_Spec at all.\n+   --    unit node instead.\n \n    --  Actual_Designated_Subtype (Node4-Sem)\n    --    Present in N_Free_Statement and N_Explicit_Dereference nodes. If gigi\n@@ -902,14 +900,16 @@ package Sinfo is\n    --    that an accessibility check is required for the parameter. It is\n    --    not yet decided who takes care of this check (TBD ???).\n \n-   --  Do_Discriminant_Check (Flag13-Sem)\n+   --  Do_Discriminant_Check (Flag1-Sem)\n    --    This flag is set on N_Selected_Component nodes to indicate that a\n    --    discriminant check is required using the discriminant check routine\n    --    associated with the selector. The actual check is generated by the\n    --    expander when processing selected components. In the case of\n    --    Unchecked_Union, the flag is also set, but no discriminant check\n    --    routine is associated with the selector, and the expander does not\n-   --    generate a check.\n+   --    generate a check. This flag is also present in assignment statements\n+   --    (and set if the assignment requires a discriminant check), and in type\n+   --    conversion nodes (and set if the conversion requires a check).\n \n    --  Do_Division_Check (Flag13-Sem)\n    --    This flag is set on a division operator (/ mod rem) to indicate\n@@ -1682,11 +1682,10 @@ package Sinfo is\n    --    is undefined and should not be read).\n \n    --  No_Ctrl_Actions (Flag7-Sem)\n-   --    Present in N_Assignment_Statement to indicate that no finalize nor\n-   --    adjust should take place on this assignment even though the rhs is\n+   --    Present in N_Assignment_Statement to indicate that no Finalize nor\n+   --    Adjust should take place on this assignment even though the RHS is\n    --    controlled. This is used in init procs and aggregate expansions where\n-   --    the generated assignments are more initialisations than real\n-   --    assignments.\n+   --    the generated assignments are initializations, not real assignments.\n \n    --  No_Elaboration_Check (Flag14-Sem)\n    --    Present in N_Function_Call and N_Procedure_Call_Statement. Indicates\n@@ -3439,7 +3438,7 @@ package Sinfo is\n       --  Prefix (Node3)\n       --  Selector_Name (Node2)\n       --  Associated_Node (Node4-Sem)\n-      --  Do_Discriminant_Check (Flag13-Sem)\n+      --  Do_Discriminant_Check (Flag1-Sem)\n       --  Is_In_Discriminant_Check (Flag11-Sem)\n       --  Is_Prefixed_Call (Flag17-Sem)\n       --  Atomic_Sync_Required (Flag14-Sem)\n@@ -4197,12 +4196,13 @@ package Sinfo is\n       --  Sloc points to first token of subtype mark\n       --  Subtype_Mark (Node4)\n       --  Expression (Node3)\n-      --  Do_Tag_Check (Flag13-Sem)\n+      --  Do_Discriminant_Check (Flag1-Sem)\n       --  Do_Length_Check (Flag4-Sem)\n-      --  Do_Overflow_Check (Flag17-Sem)\n       --  Float_Truncate (Flag11-Sem)\n-      --  Rounded_Result (Flag18-Sem)\n+      --  Do_Tag_Check (Flag13-Sem)\n       --  Conversion_OK (Flag14-Sem)\n+      --  Do_Overflow_Check (Flag17-Sem)\n+      --  Rounded_Result (Flag18-Sem)\n       --  plus fields for expression\n \n       --  Note: if a range check is required, then the Do_Range_Check flag\n@@ -4360,6 +4360,7 @@ package Sinfo is\n       --  Sloc points to :=\n       --  Name (Node2)\n       --  Expression (Node3)\n+      --  Do_Discriminant_Check (Flag1-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n       --  Do_Length_Check (Flag4-Sem)\n       --  Forwards_OK (Flag5-Sem)\n@@ -8680,7 +8681,7 @@ package Sinfo is\n      (N : Node_Id) return Boolean;    -- Flag13\n \n    function Do_Discriminant_Check\n-     (N : Node_Id) return Boolean;    -- Flag13\n+     (N : Node_Id) return Boolean;    -- Flag1\n \n    function Do_Division_Check\n      (N : Node_Id) return Boolean;    -- Flag13\n@@ -9682,7 +9683,7 @@ package Sinfo is\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n    procedure Set_Do_Discriminant_Check\n-     (N : Node_Id; Val : Boolean := True);    -- Flag13\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n \n    procedure Set_Do_Division_Check\n      (N : Node_Id; Val : Boolean := True);    -- Flag13"}, {"sha": "f14813013b1abc7392b85b10e0ed5154f146feb9", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -1184,10 +1184,9 @@ package body Treepr is\n             when F_Field5 =>\n                Field_To_Be_Printed := Field5 (N) /= Union_Id (Empty);\n \n-            --  Flag3 is obsolete, so this probably gets removed ???\n-\n-            when F_Flag3 => Field_To_Be_Printed := Has_Aspects (N);\n-\n+            when F_Flag1  => Field_To_Be_Printed := Flag1  (N);\n+            when F_Flag2  => Field_To_Be_Printed := Flag2  (N);\n+            when F_Flag3  => Field_To_Be_Printed := Flag3  (N);\n             when F_Flag4  => Field_To_Be_Printed := Flag4  (N);\n             when F_Flag5  => Field_To_Be_Printed := Flag5  (N);\n             when F_Flag6  => Field_To_Be_Printed := Flag6  (N);\n@@ -1203,11 +1202,6 @@ package body Treepr is\n             when F_Flag16 => Field_To_Be_Printed := Flag16 (N);\n             when F_Flag17 => Field_To_Be_Printed := Flag17 (N);\n             when F_Flag18 => Field_To_Be_Printed := Flag18 (N);\n-\n-            --  Flag1,2 are no longer used\n-\n-            when F_Flag1  => raise Program_Error;\n-            when F_Flag2  => raise Program_Error;\n          end case;\n \n          --  Print field if it is to be printed\n@@ -1233,14 +1227,15 @@ package body Treepr is\n                --  Special case End_Span = Uint5\n \n                when F_Field5 =>\n-                  if Nkind (N) = N_Case_Statement\n-                    or else Nkind (N) = N_If_Statement\n-                  then\n+                  if Nkind_In (N, N_Case_Statement, N_If_Statement) then\n                      Print_End_Span (N);\n                   else\n                      Print_Field (Field5 (N), Fmt);\n                   end if;\n \n+               when F_Flag1  => Print_Flag  (Flag1 (N));\n+               when F_Flag2  => Print_Flag  (Flag2 (N));\n+               when F_Flag3  => Print_Flag  (Flag3 (N));\n                when F_Flag4  => Print_Flag  (Flag4 (N));\n                when F_Flag5  => Print_Flag  (Flag5 (N));\n                when F_Flag6  => Print_Flag  (Flag6 (N));\n@@ -1256,15 +1251,6 @@ package body Treepr is\n                when F_Flag16 => Print_Flag  (Flag16 (N));\n                when F_Flag17 => Print_Flag  (Flag17 (N));\n                when F_Flag18 => Print_Flag  (Flag18 (N));\n-\n-               --  Flag1,2 are no longer used\n-\n-               when F_Flag1  => raise Program_Error;\n-               when F_Flag2  => raise Program_Error;\n-\n-               --  Not clear why we need the following ???\n-\n-               when F_Flag3  => Print_Flag (Has_Aspects (N));\n             end case;\n \n             Print_Eol;"}, {"sha": "b65d6c26b58d728cd2acaa075b062ccf9a6fcdf6", "filename": "gcc/ada/treeprs.adt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Ftreeprs.adt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d81fb4ea24ba78622991141b9ad2f36bea1ec84/gcc%2Fada%2Ftreeprs.adt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreeprs.adt?ref=8d81fb4ea24ba78622991141b9ad2f36bea1ec84", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                             T e m p l a t e                              --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,6 +50,9 @@ package Treeprs is\n    --  could never occur in a field name, so they also mark the end of the\n    --  previous name.\n \n+   --  Note the following definitions do not include Flag0. This will have to\n+   --  be addressed if we ever need to use Flag0 (it's not currently used).\n+\n    subtype Fchar is Character range '#' .. '9';\n \n    F_Field1     : constant Fchar := '#'; -- Character'Val (16#23#)"}]}