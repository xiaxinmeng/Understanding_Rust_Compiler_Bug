{"sha": "095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk1YTQ5Yzg2YThhYzY5YjVkZDZkNzhlZGYxN2I5ZTM4MDNlNWJmOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:11:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:50Z"}, "message": "[27/77] Use is_a <scalar_int_mode> before LOAD_EXTEND_OP\n\nThis patch adds is_a <scalar_int_mode> checks before load_extend_op/\nLOAD_EXTEND_OP calls, if that becomes useful for later patches.\n(load_extend_op will return UNKNOWN for any other type of mode.)\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* cse.c (cse_insn): Add is_a <scalar_int_mode> checks.\n\t* reload.c (push_reload): Likewise.\n\t(find_reloads): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251479", "tree": {"sha": "c7baab125a4bc8be7aa0212769be0246a31d4102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7baab125a4bc8be7aa0212769be0246a31d4102"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8/comments", "author": null, "committer": null, "parents": [{"sha": "6b9c3decc38f6f852adf16951b9b1b043112cd1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9c3decc38f6f852adf16951b9b1b043112cd1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9c3decc38f6f852adf16951b9b1b043112cd1c"}], "stats": {"total": 38, "additions": 24, "deletions": 14}, "files": [{"sha": "0500339a0ddc28b58a1db629165fcf99003e7579", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "patch": "@@ -1,3 +1,11 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* cse.c (cse_insn): Add is_a <scalar_int_mode> checks.\n+\t* reload.c (push_reload): Likewise.\n+\t(find_reloads): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "755ac3b8e8d3322033370a71af2aaeb60e938a5e", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "patch": "@@ -4923,7 +4923,8 @@ cse_insn (rtx_insn *insn)\n       rtx_code extend_op;\n       if (flag_expensive_optimizations && src_related == 0\n \t  && MEM_P (src) && ! do_not_record\n-\t  && (extend_op = load_extend_op (mode)) != UNKNOWN)\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && (extend_op = load_extend_op (int_mode)) != UNKNOWN)\n \t{\n \t  struct rtx_def memory_extend_buf;\n \t  rtx memory_extend_rtx = &memory_extend_buf;\n@@ -4935,7 +4936,7 @@ cse_insn (rtx_insn *insn)\n \t  PUT_CODE (memory_extend_rtx, extend_op);\n \t  XEXP (memory_extend_rtx, 0) = src;\n \n-\t  FOR_EACH_WIDER_MODE (tmode, mode)\n+\t  FOR_EACH_WIDER_MODE (tmode, int_mode)\n \t    {\n \t      struct table_elt *larger_elt;\n \n@@ -4952,7 +4953,7 @@ cse_insn (rtx_insn *insn)\n \t\t   larger_elt; larger_elt = larger_elt->next_same_value)\n \t\tif (REG_P (larger_elt->exp))\n \t\t  {\n-\t\t    src_related = gen_lowpart (mode, larger_elt->exp);\n+\t\t    src_related = gen_lowpart (int_mode, larger_elt->exp);\n \t\t    break;\n \t\t  }\n "}, {"sha": "2116332b55aa33babd9ab08023026592f2a471c4", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "patch": "@@ -1050,6 +1050,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      register class.  But if it is inside a STRICT_LOW_PART, we have\n      no choice, so we hope we do get the right register class there.  */\n \n+  scalar_int_mode inner_mode;\n   if (in != 0 && GET_CODE (in) == SUBREG\n       && (subreg_lowpart_p (in) || strict_low)\n #ifdef CANNOT_CHANGE_MODE_CLASS\n@@ -1064,12 +1065,11 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t       || MEM_P (SUBREG_REG (in)))\n \t      && (paradoxical_subreg_p (inmode, GET_MODE (SUBREG_REG (in)))\n \t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n-\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t\t  <= UNITS_PER_WORD)\n-\t\t      && paradoxical_subreg_p (inmode,\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (in)))\n-\t\t      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (in)))\n-\t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != UNKNOWN)\n+\t\t      && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t\t &inner_mode)\n+\t\t      && GET_MODE_SIZE (inner_mode) <= UNITS_PER_WORD\n+\t\t      && paradoxical_subreg_p (inmode, inner_mode)\n+\t\t      && LOAD_EXTEND_OP (inner_mode) != UNKNOWN)\n \t\t  || (WORD_REGISTER_OPERATIONS\n \t\t      && (GET_MODE_PRECISION (inmode)\n \t\t\t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n@@ -3107,6 +3107,7 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t  operand = SUBREG_REG (operand);\n \t\t  /* Force reload if this is a constant or PLUS or if there may\n \t\t     be a problem accessing OPERAND in the outer mode.  */\n+\t\t  scalar_int_mode inner_mode;\n \t\t  if (CONSTANT_P (operand)\n \t\t      || GET_CODE (operand) == PLUS\n \t\t      /* We must force a reload of paradoxical SUBREGs\n@@ -3144,13 +3145,13 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t\t      || BYTES_BIG_ENDIAN\n \t\t\t      || ((GET_MODE_SIZE (operand_mode[i])\n \t\t\t\t   <= UNITS_PER_WORD)\n-\t\t\t\t  && (GET_MODE_SIZE (GET_MODE (operand))\n+\t\t\t\t  && (is_a <scalar_int_mode>\n+\t\t\t\t      (GET_MODE (operand), &inner_mode))\n+\t\t\t\t  && (GET_MODE_SIZE (inner_mode)\n \t\t\t\t      <= UNITS_PER_WORD)\n \t\t\t\t  && paradoxical_subreg_p (operand_mode[i],\n-\t\t\t\t\t\t\t   GET_MODE (operand))\n-\t\t\t\t  && INTEGRAL_MODE_P (GET_MODE (operand))\n-\t\t\t\t  && LOAD_EXTEND_OP (GET_MODE (operand))\n-\t\t\t\t     != UNKNOWN)))\n+\t\t\t\t\t\t\t   inner_mode)\n+\t\t\t\t  && LOAD_EXTEND_OP (inner_mode) != UNKNOWN)))\n \t\t      )\n \t\t    force_reload = 1;\n \t\t}"}]}