{"sha": "aabf90e8ce80ca78708982eee04b776682e2aeb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiZjkwZThjZTgwY2E3ODcwODk4MmVlZTA0Yjc3NjY4MmUyYWViMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-03T14:27:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-03T14:27:47Z"}, "message": "Initial revision\n\nFrom-SVN: r53", "tree": {"sha": "f4ad612dd5acea07657baf95c20b2ac4980aa4b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4ad612dd5acea07657baf95c20b2ac4980aa4b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aabf90e8ce80ca78708982eee04b776682e2aeb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabf90e8ce80ca78708982eee04b776682e2aeb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aabf90e8ce80ca78708982eee04b776682e2aeb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabf90e8ce80ca78708982eee04b776682e2aeb3/comments", "author": null, "committer": null, "parents": [{"sha": "9789a53f20c8b8a0712877967e7a58910442a077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9789a53f20c8b8a0712877967e7a58910442a077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9789a53f20c8b8a0712877967e7a58910442a077"}], "stats": {"total": 326, "additions": 326, "deletions": 0}, "files": [{"sha": "f49ad75a7b3670745e7d51de3e8677849304d26a", "filename": "gcc/genconfig.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabf90e8ce80ca78708982eee04b776682e2aeb3/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabf90e8ce80ca78708982eee04b776682e2aeb3/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=aabf90e8ce80ca78708982eee04b776682e2aeb3", "patch": "@@ -0,0 +1,326 @@\n+/* Generate from machine description:\n+\n+   - some #define configuration flags.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+/* flags to determine output of machine description dependent #define's.  */\n+static int max_recog_operands;\n+static int max_dup_operands;\n+static int max_clobbers_per_insn;\n+static int register_constraint_flag;\n+static int have_cc0_flag;\n+static int have_lo_sum_flag;\n+\n+/* Maximum number of insns seen in a split.  */\n+static int max_insns_per_split = 1;\n+\n+static int clobbers_seen_this_insn;\n+static int dup_operands_seen_this_insn;\n+\n+char *xmalloc ();\n+static void fatal ();\n+void fancy_abort ();\n+\n+/* RECOG_P will be non-zero if this pattern was seen in a context where it will\n+   be used to recognize, rather than just generate an insn.  */\n+\n+static void\n+walk_insn_part (part, recog_p)\n+     rtx part;\n+{\n+  register int i, j;\n+  register RTX_CODE code;\n+  register char *format_ptr;\n+\n+  if (part == 0)\n+    return;\n+\n+  code = GET_CODE (part);\n+  switch (code)\n+    {\n+    case CLOBBER:\n+      clobbers_seen_this_insn++;\n+      break;\n+\n+    case MATCH_OPERAND:\n+      if (XINT (part, 0) > max_recog_operands)\n+\tmax_recog_operands = XINT (part, 0);\n+      if (XSTR (part, 2) && *XSTR (part, 2))\n+\tregister_constraint_flag = 1;\n+      return;\n+\n+    case MATCH_OP_DUP:\n+      ++dup_operands_seen_this_insn;\n+    case MATCH_SCRATCH:\n+    case MATCH_PARALLEL:\n+    case MATCH_OPERATOR:\n+      if (XINT (part, 0) > max_recog_operands)\n+\tmax_recog_operands = XINT (part, 0);\n+      /* Now scan the rtl's in the vector inside the MATCH_OPERATOR or\n+\t MATCH_PARALLEL.  */\n+      break;\n+\n+    case LABEL_REF:\n+      if (GET_CODE (XEXP (part, 0)) == MATCH_OPERAND)\n+\tbreak;\n+      return;\n+\n+    case MATCH_DUP:\n+      ++dup_operands_seen_this_insn;\n+      if (XINT (part, 0) > max_recog_operands)\n+\tmax_recog_operands = XINT (part, 0);\n+      return;\n+\n+    case CC0:\n+      if (recog_p)\n+\thave_cc0_flag = 1;\n+      return;\n+\n+    case LO_SUM:\n+      if (recog_p)\n+\thave_lo_sum_flag = 1;\n+      return;\n+\n+    case REG: case CONST_INT: case SYMBOL_REF:\n+    case PC:\n+      return;\n+    }\n+\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (part));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (part)); i++)\n+    switch (*format_ptr++)\n+      {\n+      case 'e':\n+      case 'u':\n+\twalk_insn_part (XEXP (part, i), recog_p);\n+\tbreak;\n+      case 'E':\n+\tif (XVEC (part, i) != NULL)\n+\t  for (j = 0; j < XVECLEN (part, i); j++)\n+\t    walk_insn_part (XVECEXP (part, i, j), recog_p);\n+\tbreak;\n+      }\n+}\n+\n+static void\n+gen_insn (insn)\n+     rtx insn;\n+{\n+  int i;\n+\n+  /* Walk the insn pattern to gather the #define's status.  */\n+  clobbers_seen_this_insn = 0;\n+  dup_operands_seen_this_insn = 0;\n+  if (XVEC (insn, 1) != 0)\n+    for (i = 0; i < XVECLEN (insn, 1); i++)\n+      walk_insn_part (XVECEXP (insn, 1, i), 1);\n+\n+  if (clobbers_seen_this_insn > max_clobbers_per_insn)\n+    max_clobbers_per_insn = clobbers_seen_this_insn;\n+  if (dup_operands_seen_this_insn > max_dup_operands)\n+    max_dup_operands = dup_operands_seen_this_insn;\n+}\n+\n+/* Similar but scan a define_expand.  */\n+\n+static void\n+gen_expand (insn)\n+     rtx insn;\n+{\n+  int i;\n+\n+  /* Walk the insn pattern to gather the #define's status.  */\n+\n+  /* Note that we don't bother recording the number of MATCH_DUPs\n+     that occur in a gen_expand, because only reload cares about that.  */\n+  if (XVEC (insn, 1) != 0)\n+    for (i = 0; i < XVECLEN (insn, 1); i++)\n+      {\n+\t/* Compute the maximum SETs and CLOBBERS\n+\t   in any one of the sub-insns;\n+\t   don't sum across all of them.  */\n+\tclobbers_seen_this_insn = 0;\n+\n+\twalk_insn_part (XVECEXP (insn, 1, i), 0);\n+\n+\tif (clobbers_seen_this_insn > max_clobbers_per_insn)\n+\t  max_clobbers_per_insn = clobbers_seen_this_insn;\n+      }\n+}\n+\n+/* Similar but scan a define_split.  */\n+\n+static void\n+gen_split (split)\n+     rtx split;\n+{\n+  int i;\n+\n+  /* Look through the patterns that are matched\n+     to compute the maximum operand number.  */\n+  for (i = 0; i < XVECLEN (split, 0); i++)\n+    walk_insn_part (XVECEXP (split, 0, i), 1);\n+  /* Look at the number of insns this insn could split into.  */\n+  if (XVECLEN (split, 2) > max_insns_per_split)\n+    max_insns_per_split = XVECLEN (split, 2);\n+}\n+\n+static void\n+gen_peephole (peep)\n+     rtx peep;\n+{\n+  int i;\n+\n+  /* Look through the patterns that are matched\n+     to compute the maximum operand number.  */\n+  for (i = 0; i < XVECLEN (peep, 0); i++)\n+    walk_insn_part (XVECEXP (peep, 0, i), 1);\n+}\n+\f\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genconfig: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  printf (\"/* Generated automatically by the program `genconfig'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  /* Allow at least 10 operands for the sake of asm constructs.  */\n+  max_recog_operands = 10;\n+  max_dup_operands = 1;\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN)\n+\tgen_insn (desc);\n+      if (GET_CODE (desc) == DEFINE_EXPAND)\n+\tgen_expand (desc);\n+      if (GET_CODE (desc) == DEFINE_SPLIT)\n+\tgen_split (desc);\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n+\tgen_peephole (desc);\n+    }\n+\n+  printf (\"\\n#define MAX_RECOG_OPERANDS %d\\n\", max_recog_operands);\n+\n+  printf (\"\\n#define MAX_DUP_OPERANDS %d\\n\", max_dup_operands);\n+\n+  /* This is conditionally defined, in case the user writes code which emits\n+     more splits than we can readily see (and knows s/he does it).  */\n+  printf (\"#ifndef MAX_INSNS_PER_SPLIT\\n#define MAX_INSNS_PER_SPLIT %d\\n#endif\\n\",\n+\t  max_insns_per_split);\n+\n+  if (register_constraint_flag)\n+    printf (\"#define REGISTER_CONSTRAINTS\\n\");\n+\n+  if (have_cc0_flag)\n+    printf (\"#define HAVE_cc0\\n\");\n+\n+  if (have_lo_sum_flag)\n+    printf (\"#define HAVE_lo_sum\\n\");\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}]}