{"sha": "b7c9bf289f096dd5338f37a4656f13d7b982fd33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdjOWJmMjg5ZjA5NmRkNTMzOGYzN2E0NjU2ZjEzZDdiOTgyZmQzMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-09T12:54:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-09T12:54:19Z"}, "message": "final.c (end_final): Use C trees to output data structures for profiling.\n\n\n\t* final.c (end_final): Use C trees to output data structures for profiling.\n\n\t* Makefile.in (LIBGCC_DEPS): Added missing dependency on gcov-io.h\n        (profile.o): New dependency profile.h\n        (final.o): New dependency profile.h\n        * profile.h: New file. New global structure profile_info.\n        * final.h (count_edges_instrumented_now): Declare.\n        (current_function_cfg_checksum): Declare.\n        (function_list): New structure.\n        (functions_head, functions_tail): New static variables.\n        (end_final): Emits more data, removed some -ax stuff.\n        (final): Stores function names and chcksums.\n        * gcov-io.h (__write_gcov_string): New function.\n        (__read_gcov_string): New function.\n        * gcov.c (read_profile): New function.\n        (create_program_flow_graph): Uses read_profile instead of reading\n\tda_file.\n        (read_files): Removed da_file checking, it's done by read_profile now.\n        * libgcc2.c (bb_function_info): New structure.\n        (bb): New field in structure, removed some -ax stuff.\n        (__bb_exit_func): Changed structure of da_file.\n        * profile.c (count_edges_instrumented_now): New global variable.\n        (current_function_cfg_checksum): New global variable.\n        (max_counter_in_program): New global variable.\n        (get_exec_counts): New function.\n        (compute_checksum): New function.\n        (instrument_edges): Sets count_edges_instrumented_now.\n        (compute_branch_probabilities): Uses get_exec_counts instead of\n\treading da_file.\n        (branch_prob): Calls compute_checksum and writes extra data to bbg_file.\n        (init_branch_prob): Removed da_file checking, done in get_exec_counts\n\tnow.\n        (end_branch_prob): Removed da_file checking, done in get_exec_counts\n\tnow.\n        * gcov.texi: Updated information about gcov file format.\n\nCo-Authored-By: Pavel Nejedly <bim@atrey.karlin.mff.cuni.cz>\n\nFrom-SVN: r53326", "tree": {"sha": "da04474c0297ae3c91b3bdce0c519ca2f9d2e5a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da04474c0297ae3c91b3bdce0c519ca2f9d2e5a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7c9bf289f096dd5338f37a4656f13d7b982fd33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c9bf289f096dd5338f37a4656f13d7b982fd33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c9bf289f096dd5338f37a4656f13d7b982fd33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c9bf289f096dd5338f37a4656f13d7b982fd33/comments", "author": null, "committer": null, "parents": [{"sha": "786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63"}], "stats": {"total": 1276, "additions": 985, "deletions": 291}, "files": [{"sha": "5100e798097b24994c466d6f8198c3703f4353b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -1,3 +1,42 @@\n+Thu May  9 14:52:45 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\t\t\t       Pavel Nejedly  <bim@atrey.karlin.mff.cuni.cz>\n+\n+\t* final.c (end_final): Use C trees to output data structures for profiling.\n+\n+\t* Makefile.in (LIBGCC_DEPS): Added missing dependency on gcov-io.h\n+        (profile.o): New dependency profile.h\n+        (final.o): New dependency profile.h\n+        * profile.h: New file. New global structure profile_info.\n+        * final.h (count_edges_instrumented_now): Declare.\n+        (current_function_cfg_checksum): Declare.\n+        (function_list): New structure.\n+        (functions_head, functions_tail): New static variables.\n+        (end_final): Emits more data, removed some -ax stuff.\n+        (final): Stores function names and chcksums.\n+        * gcov-io.h (__write_gcov_string): New function.\n+        (__read_gcov_string): New function.\n+        * gcov.c (read_profile): New function.\n+        (create_program_flow_graph): Uses read_profile instead of reading\n+\tda_file.\n+        (read_files): Removed da_file checking, it's done by read_profile now.\n+        * libgcc2.c (bb_function_info): New structure.\n+        (bb): New field in structure, removed some -ax stuff.\n+        (__bb_exit_func): Changed structure of da_file.\n+        * profile.c (count_edges_instrumented_now): New global variable.\n+        (current_function_cfg_checksum): New global variable.\n+        (max_counter_in_program): New global variable.\n+        (get_exec_counts): New function.\n+        (compute_checksum): New function.\n+        (instrument_edges): Sets count_edges_instrumented_now.\n+        (compute_branch_probabilities): Uses get_exec_counts instead of\n+\treading da_file.\n+        (branch_prob): Calls compute_checksum and writes extra data to bbg_file.\n+        (init_branch_prob): Removed da_file checking, done in get_exec_counts\n+\tnow.\n+        (end_branch_prob): Removed da_file checking, done in get_exec_counts\n+\tnow.\n+        * gcov.texi: Updated information about gcov file format.\n+\n 2002-05-09  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* sbitmap.c: Fix formatting."}, {"sha": "7affc56800ace1b860ab400ba827f8f403fe0fe3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -1484,7 +1484,7 @@ conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H) $(HASHTAB_H) \\\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h output.h $(REGS_H) $(EXPR_H) function.h \\\n    gcov-io.h toplev.h $(GGC_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TARGET_H) \\\n-   langhooks.h\n+   langhooks.h profile.h libfuncs.h\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h \\\n@@ -1568,7 +1568,7 @@ sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(TARGET_H) real.h\n final.o : final.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) function.h \\\n-   real.h output.h hard-reg-set.h except.h debug.h xcoffout.h \\\n+   real.h output.h hard-reg-set.h except.h debug.h xcoffout.h profile.h \\\n    toplev.h reload.h dwarf2out.h $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n    $(REGS_H) $(RECOG_H) $(EXPR_H) hard-reg-set.h flags.h insn-config.h \\"}, {"sha": "5f5f18bd6d1403a3f9b52ee39ed261d320ab2edf", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -363,6 +363,8 @@ program flow.\n \n In the @file{.bbg} file, the format is:\n @smallexample\n+        name of function #0\n+        checksum of function #0\n         number of basic blocks for function #0 (4-byte number)\n         total number of arcs for function #0 (4-byte number)\n         count of arcs in basic block #0 (4-byte number)\n@@ -383,22 +385,42 @@ A @minus{}1 (stored as a 4-byte number) is used to separate each function's\n list of basic blocks, and to verify that the file has been read\n correctly.\n \n+The function name is stored as a @minus{}1 (4 bytes), the length (4 bytes),\n+the name itself (padded to 4-byte boundary) followed by a @minus{}1 (4 bytes).\n+\n The @file{.da} file is generated when a program containing object files\n built with the GCC @option{-fprofile-arcs} option is executed.  A\n separate @file{.da} file is created for each source file compiled with\n this option, and the name of the @file{.da} file is stored as an\n absolute pathname in the resulting object file.  This path name is\n derived from the source file name by substituting a @file{.da} suffix.\n \n-The format of the @file{.da} file is fairly simple.  The first 8-byte\n-number is the number of counts in the file, followed by the counts\n-(stored as 8-byte numbers).  Each count corresponds to the number of\n-times each arc in the program is executed.  The counts are cumulative;\n-each time the program is executed, it attempts to combine the existing\n-@file{.da} files with the new counts for this invocation of the\n-program.  It ignores the contents of any @file{.da} files whose number of\n-arcs doesn't correspond to the current program, and merely overwrites\n-them instead.\n+The @file{.da} consists of several blocks (one for each run) with the following structure:\n+@smallexample\n+        \"magic\" number @minus{}123 (4-byte number)\n+\tnumber of functions (4-byte number)\n+        length of the \"extension block\" in bytes\n+\textension block (variable length)\n+  \tname of function #0 (the same format as in .bbg file)\n+        checksum of function #0\n+\tnumber of instrumented arcs (4-byte number)\n+        count of arc #0 (8-byte number)\n+        count of arc #1 (8-byte number)\n+        @dots{}\n+\tcount of arc #M_0 (8-byte number)\n+  \tname of function #1 (the same format as in .bbg file)\n+        checksum of function #1\n+\t@dots{}\n+@end smallexample\n+The current structure of the extension block is as follows:\n+@smallexample\n+        number of instrumented arcs in whole program (4-byte number)\n+        sum all of instrumented arcs in whole program (8-byte number)\n+        maximal value of counter in whole program (8-byte number)\n+        number of instrumented arcs in the object file (4-byte number)\n+        sum all of instrumented arcs in the object file (8-byte number)\n+        maximal value of counter in the object file (8-byte number)\n+@end smallexample\n \n All three of these files use the functions in @file{gcov-io.h} to store\n integers; the functions in this header provide a machine-independent"}, {"sha": "57e94e78e4fd5747e171b6064ab2fabd929f9278", "filename": "gcc/final.c", "status": "modified", "additions": 275, "deletions": 108, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -68,6 +68,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"debug.h\"\n #include \"expr.h\"\n+#include \"profile.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -114,9 +115,6 @@ static int high_function_linenum;\n /* Filename of last NOTE.  */\n static const char *last_filename;\n \n-/* Number of instrumented arcs when profile_arc_flag is set.  */\n-extern int count_instrumented_edges;\n-\n extern int length_unit_log; /* This is defined in insn-attrtab.c.  */\n \n /* Nonzero while outputting an `asm' with operands.\n@@ -198,6 +196,17 @@ static char *line_note_exists;\n rtx current_insn_predicate;\n #endif\n \n+struct function_list\n+{\n+  struct function_list *next; \t/* next function */\n+  const char *name; \t\t/* function name */\n+  long cfg_checksum;\t\t/* function checksum */\n+  long count_edges;\t\t/* number of intrumented edges in this function */\n+};\n+\n+static struct function_list *functions_head = 0;\n+static struct function_list **functions_tail = &functions_head;\n+\n #ifdef HAVE_ATTR_length\n static int asm_insn_count\tPARAMS ((rtx));\n #endif\n@@ -237,7 +246,7 @@ init_final (filename)\n }\n \n /* Called at end of source file,\n-   to output the block-profiling table for this entire compilation.  */\n+   to output the arc-profiling table for this entire compilation.  */\n \n void\n end_final (filename)\n@@ -246,128 +255,268 @@ end_final (filename)\n   if (profile_arc_flag)\n     {\n       char name[20];\n-      int align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n-      int size, rounded;\n-      int long_bytes = LONG_TYPE_SIZE / BITS_PER_UNIT;\n-      int gcov_type_bytes = GCOV_TYPE_SIZE / BITS_PER_UNIT;\n-      int pointer_bytes = POINTER_SIZE / BITS_PER_UNIT;\n-      unsigned int align2 = LONG_TYPE_SIZE;\n-\n-      size = gcov_type_bytes * count_instrumented_edges;\n-      rounded = size;\n-\n-      rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n-      rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n-\t\t * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-\n-      /* ??? This _really_ ought to be done with a structure layout\n-\t and with assemble_constructor.  If long_bytes != pointer_bytes\n-\t we'll be emitting unaligned data at some point.  */\n-      if (long_bytes != pointer_bytes)\n-\tabort ();\n-\n-      data_section ();\n-\n-      /* Output the main header, of 11 words:\n-\t 0:  1 if this file is initialized, else 0.\n-\t 1:  address of file name (LPBX1).\n-\t 2:  address of table of counts (LPBX2).\n-\t 3:  number of counts in the table.\n-\t 4:  always 0, for compatibility with Sun.\n+      tree string_type, string_cst;\n+      tree structure_decl, structure_value, structure_pointer_type;\n+      tree field_decl, decl_chain, value_chain;\n+      tree nwords_field_value, domain_type;\n+\n+      /* Build types.  */\n+      string_type = build_pointer_type (char_type_node);\n+\n+      /* Libgcc2 bb structure.  */\n+      structure_decl = make_node (RECORD_TYPE);\n+      TYPE_PACKED (structure_decl) = flag_pack_struct;\n+      structure_pointer_type = build_pointer_type (structure_decl);\n+\n+      /* Output the main header, of 7 words:\n+         0:  1 if this file is initialized, else 0.\n+         1:  address of file name (LPBX1).\n+         2:  address of table of counts (LPBX2).\n+         3:  number of counts in the table.\n+         4:  always 0, libgcc2 uses this as a pointer to next ``struct bb''\n \n          The following are GNU extensions:\n \n-\t 5:  address of table of start addrs of basic blocks (LPBX3).\n-\t 6:  Number of bytes in this header.\n-\t 7:  address of table of function names (LPBX4).\n-\t 8:  address of table of line numbers (LPBX5) or 0.\n-\t 9:  address of table of file names (LPBX6) or 0.\n-\t10:  space reserved for basic block profiling.  */\n-\n-      ASM_OUTPUT_ALIGN (asm_out_file, align);\n+         5:  Number of bytes in this header.\n+         6:  address of table of function checksums (LPBX7).  */\n \n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 0);\n-\n-      /* Zero word.  */\n-      assemble_integer (const0_rtx, long_bytes, align2, 1);\n+      /* The zero word.  */\n+      decl_chain =\n+\tbuild_decl (FIELD_DECL, get_identifier (\"zero_word\"),\n+\t\t    long_integer_type_node);\n+      value_chain = build_tree_list (decl_chain, integer_zero_node);\n \n       /* Address of filename.  */\n-      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 1);\n-      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes,\n-\t\t\talign2, 1);\n+      {\n+\tchar *cwd = getpwd ();\n+\tint da_filename_len = strlen (filename) + strlen (cwd) + 4 + 1;\n+\tchar *da_filename = (char *) alloca (da_filename_len);\n+\n+\tstrcpy (da_filename, cwd);\n+\tstrcat (da_filename, \"/\");\n+\tstrcat (da_filename, filename);\n+\tstrip_off_ending (da_filename, da_filename_len - 3);\n+\tstrcat (da_filename, \".da\");\n+\tfield_decl =\n+\t  build_decl (FIELD_DECL, get_identifier (\"filename\"), string_type);\n+\tstring_cst = build_string (strlen (da_filename) + 1, da_filename);\n+\tdomain_type = build_index_type (build_int_2 (strlen (da_filename) + 1,\n+\t\t\t\t\t\t     0));\n+\tTREE_TYPE (string_cst) =\n+\t  build_array_type (char_type_node, domain_type);\n+\tvalue_chain = tree_cons (field_decl,\n+\t\t\t\t build1 (ADDR_EXPR, string_type, string_cst),\n+\t\t\t\t value_chain);\n+\tTREE_CHAIN (field_decl) = decl_chain;\n+\tdecl_chain = field_decl;\n+      }\n \n-      /* Address of count table.  */\n-      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n-      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes,\n-\t\t\talign2, 1);\n+      /* Table of counts.  */\n+      {\n+\ttree gcov_type_type = make_unsigned_type (GCOV_TYPE_SIZE);\n+\ttree gcov_type_pointer_type = build_pointer_type (gcov_type_type);\n+\ttree gcov_type_array_type, gcov_type_array_pointer_type;\n+\ttree domain_tree = build_index_type (build_int_2\n+\t\t\t\t\t     (profile_info.\n+\t\t\t\t\t      count_instrumented_edges - 1,\n+\t\t\t\t\t      0));\n+\ttree counts_table;\n+\n+\tgcov_type_array_type = build_array_type (gcov_type_type, domain_tree);\n+\tgcov_type_array_pointer_type =\n+\t  build_pointer_type (gcov_type_array_type);\n+\n+\t/* No values.  */\n+\tcounts_table =\n+\t  build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n+\tTREE_STATIC (counts_table) = 1;\n+\tASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n+\tDECL_NAME (counts_table) = get_identifier (name);\n+\tassemble_variable (counts_table, 0, 0, 0);\n+\n+\tfield_decl =\n+\t  build_decl (FIELD_DECL, get_identifier (\"counts\"),\n+\t\t      gcov_type_pointer_type);\n+\tvalue_chain = tree_cons (field_decl,\n+\t\t\t\t build1 (ADDR_EXPR,\n+\t\t\t\t\t gcov_type_array_pointer_type,\n+\t\t\t\t\t counts_table), value_chain);\n+\tTREE_CHAIN (field_decl) = decl_chain;\n+\tdecl_chain = field_decl;\n+      }\n \n       /* Count of the # of instrumented arcs.  */\n-      assemble_integer (GEN_INT (count_instrumented_edges),\n-\t\t\tlong_bytes, align2, 1);\n+      field_decl =\n+\tbuild_decl (FIELD_DECL, get_identifier (\"ncounts\"),\n+\t\t    long_integer_type_node);\n+      value_chain = tree_cons (field_decl,\n+\t\t\t       convert (long_integer_type_node,\n+\t\t\t\t\tbuild_int_2 (profile_info.\n+\t\t\t\t\t\t     count_instrumented_edges,\n+\t\t\t\t\t\t     0)), value_chain);\n+      TREE_CHAIN (field_decl) = decl_chain;\n+      decl_chain = field_decl;\n+\n+      /* Pointer to the next bb.  */\n+      field_decl =\n+\tbuild_decl (FIELD_DECL, get_identifier (\"next\"),\n+\t\t    structure_pointer_type);\n+      value_chain = tree_cons (field_decl, null_pointer_node, value_chain);\n+      TREE_CHAIN (field_decl) = decl_chain;\n+      decl_chain = field_decl;\n+\n+      /* Number of words. We'll set this after entire structure is laid out.  */\n+      field_decl =\n+\tbuild_decl (FIELD_DECL, get_identifier (\"nwords\"),\n+\t\t    long_integer_type_node);\n+      value_chain = nwords_field_value =\n+\ttree_cons (field_decl, NULL, value_chain);\n+      TREE_CHAIN (field_decl) = decl_chain;\n+      decl_chain = field_decl;\n+\n+      /* struct bb_function [].  */\n+      {\n+\tstruct function_list *item;\n+\tint num_nodes;\n+\ttree checksum_field, arc_count_field, name_field;\n+\ttree domain;\n+\ttree array_value_chain = NULL_TREE;\n+\ttree bb_fn_struct_type;\n+\ttree bb_fn_struct_array_type;\n+\ttree bb_fn_struct_array_pointer_type;\n+\ttree bb_fn_struct_pointer_type;\n+\ttree field_value, field_value_chain;\n+\n+\tbb_fn_struct_type = make_node (RECORD_TYPE);\n+\tTYPE_PACKED (bb_fn_struct_type) = flag_pack_struct;\n+\n+\tchecksum_field = build_decl (FIELD_DECL, get_identifier (\"checksum\"),\n+\t\t\t\t     long_integer_type_node);\n+\tarc_count_field =\n+\t  build_decl (FIELD_DECL, get_identifier (\"arc_count\"),\n+\t\t      integer_type_node);\n+\tTREE_CHAIN (checksum_field) = arc_count_field;\n+\tname_field =\n+\t  build_decl (FIELD_DECL, get_identifier (\"name\"), string_type);\n+\tTREE_CHAIN (arc_count_field) = name_field;\n+\n+\tTYPE_FIELDS (bb_fn_struct_type) = checksum_field;\n+\n+\tnum_nodes = 0;\n+\n+\tfor (item = functions_head; item != 0; item = item->next)\n+\t  num_nodes++;\n+\n+\t/* Note that the array contains a terminator, hence no - 1.  */\n+\tdomain = build_index_type (build_int_2 (num_nodes, 0));\n+\n+\tbb_fn_struct_pointer_type = build_pointer_type (bb_fn_struct_type);\n+\tbb_fn_struct_array_type = build_array_type (bb_fn_struct_type,\n+\t\t\t\t\t\t    domain);\n+\tbb_fn_struct_array_pointer_type =\n+\t  build_pointer_type (bb_fn_struct_array_type);\n+\n+\tlayout_type (bb_fn_struct_type);\n+\tlayout_type (bb_fn_struct_pointer_type);\n+\tlayout_type (bb_fn_struct_array_type);\n+\tlayout_type (bb_fn_struct_array_pointer_type);\n+\n+\tfor (item = functions_head; item != 0; item = item->next)\n+\t  {\n+\t    /* create constructor for structure.  */\n+\t    field_value_chain = build_tree_list (checksum_field,\n+\t\t\t\t\t\t convert\n+\t\t\t\t\t\t (long_integer_type_node,\n+\t\t\t\t\t\t  build_int_2 (item->\n+\t\t\t\t\t\t\t       cfg_checksum,\n+\t\t\t\t\t\t\t       0)));\n+\t    field_value_chain =\n+\t      tree_cons (arc_count_field,\n+\t\t\t convert (integer_type_node,\n+\t\t\t\t  build_int_2 (item->count_edges, 0)),\n+\t\t\t field_value_chain);\n+\n+\t    string_cst = build_string (strlen (item->name) + 1, item->name);\n+\t    domain_type = build_index_type (build_int_2 (strlen (item->name) +\n+\t\t\t\t\t\t\t 1, 0));\n+\t    TREE_TYPE (string_cst) = build_array_type (char_type_node,\n+\t\t\t\t\t\t       domain_type);\n+\t    field_value_chain = tree_cons (name_field,\n+\t\t\t\t\t   build1 (ADDR_EXPR, string_type,\n+\t\t\t\t\t\t   string_cst),\n+\t\t\t\t\t   field_value_chain);\n+\n+\t    /* Add to chain.  */\n+\n+\t    array_value_chain = tree_cons (NULL_TREE,\n+\t\t\t\t\t   build (CONSTRUCTOR,\n+\t\t\t\t\t\t  bb_fn_struct_type,\n+\t\t\t\t\t\t  NULL_TREE,\n+\t\t\t\t\t\t  nreverse\n+\t\t\t\t\t\t  (field_value_chain)),\n+\t\t\t\t\t   array_value_chain);\n+\t  }\n \n-      /* Zero word (link field).  */\n-      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n+\t/* Add terminator.  */\n+\tfield_value = build_tree_list (arc_count_field,\n+\t\t\t\t       convert (integer_type_node,\n+\t\t\t\t\t\tbuild_int_2 (-1, 0)));\n+\n+\tarray_value_chain = tree_cons (NULL_TREE,\n+\t\t\t\t       build (CONSTRUCTOR, bb_fn_struct_type,\n+\t\t\t\t\t      NULL_TREE, field_value),\n+\t\t\t\t       array_value_chain);\n+\n+\n+\t/* Create constructor for array.  */\n+\n+\tfield_decl =\n+\t  build_decl (FIELD_DECL, get_identifier (\"function_infos\"),\n+\t\t      bb_fn_struct_pointer_type);\n+\tvalue_chain = tree_cons (field_decl,\n+\t\t\t\t build1 (ADDR_EXPR,\n+\t\t\t\t\t bb_fn_struct_array_pointer_type,\n+\t\t\t\t\t build (CONSTRUCTOR,\n+\t\t\t\t\t\tbb_fn_struct_array_type,\n+\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\tnreverse\n+\t\t\t\t\t\t(array_value_chain))),\n+\t\t\t\t value_chain);\n+\tTREE_CHAIN (field_decl) = decl_chain;\n+\tdecl_chain = field_decl;\n+      }\n \n-      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n \n-      /* Byte count for extended structure.  */\n-      assemble_integer (GEN_INT (11 * UNITS_PER_WORD), long_bytes, align2, 1);\n+      /* Finish structure.  */\n+      TYPE_FIELDS (structure_decl) = nreverse (decl_chain);\n+      layout_type (structure_decl);\n \n-      /* Address of function name table.  */\n-      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n+      structure_value =\n+\tbuild (VAR_DECL, structure_decl, NULL_TREE, NULL_TREE);\n+      DECL_INITIAL (structure_value) =\n+\tbuild (CONSTRUCTOR, structure_decl, NULL_TREE,\n+\t       nreverse (value_chain));\n+      TREE_STATIC (structure_value) = 1;\n+      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n+      DECL_NAME (structure_value) = get_identifier (name);\n \n-      /* Address of line number and filename tables if debugging.  */\n-      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n-      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n+      /* Set number of words in this structure. */\n+      TREE_VALUE (nwords_field_value) =\n+\tbuild_int_2 (TREE_INT_CST_LOW (TYPE_SIZE_UNIT (structure_decl)) /\n+\t\t     (INT_TYPE_SIZE / BITS_PER_UNIT), 0);\n \n-      /* Space for extension ptr (link field).  */\n-      assemble_integer (const0_rtx, UNITS_PER_WORD, align2, 1);\n+      /* Build structure.  */\n+      assemble_variable (structure_value, 0, 0, 0);\n \n-      /* Output the file name changing the suffix to .d for\n-\t Sun tcov compatibility.  */\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 1);\n+      /* Offset to table of arc counters for thread-safe profiling.  */\n       {\n-\tchar *cwd = getpwd ();\n-\tint len = strlen (filename) + strlen (cwd) + 1;\n-\tchar *data_file = (char *) alloca (len + 4);\n-\n-\tstrcpy (data_file, cwd);\n-\tstrcat (data_file, \"/\");\n-\tstrcat (data_file, filename);\n-\tstrip_off_ending (data_file, len);\n-\tstrcat (data_file, \".da\");\n-\tassemble_string (data_file, strlen (data_file) + 1);\n+\ttree table_offset_var = make_node (VAR_DECL);\n+\tTREE_TYPE (table_offset_var) = build_pointer_type (integer_type_node);\n+\tDECL_INITIAL (table_offset_var) = integer_zero_node;\n+\tDECL_NAME (table_offset_var) = get_identifier (\".LPBF0\");\n+\tTREE_STATIC (table_offset_var) = 1;\n+\tassemble_variable (table_offset_var, 0, 0, 0);\n       }\n-\n-      /* Make space for the table of counts.  */\n-      if (size == 0)\n-\t{\n-\t  /* Realign data section.  */\n-\t  ASM_OUTPUT_ALIGN (asm_out_file, align);\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 2);\n-\t  if (size != 0)\n-\t    assemble_zeros (size);\n-\t}\n-      else\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n-#ifdef ASM_OUTPUT_SHARED_LOCAL\n-\t  if (flag_shared_data)\n-\t    ASM_OUTPUT_SHARED_LOCAL (asm_out_file, name, size, rounded);\n-\t  else\n-#endif\n-#ifdef ASM_OUTPUT_ALIGNED_DECL_LOCAL\n-\t    ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, NULL_TREE, name,\n-\t\t\t\t\t   size, BIGGEST_ALIGNMENT);\n-#else\n-#ifdef ASM_OUTPUT_ALIGNED_LOCAL\n-\t    ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size,\n-\t\t\t\t      BIGGEST_ALIGNMENT);\n-#else\n-\t    ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n-#endif\n-#endif\n-\t}\n     }\n }\n \n@@ -1781,6 +1930,24 @@ final (first, file, optimize, prescan)\n       insn = final_scan_insn (insn, file, optimize, prescan, 0);\n     }\n \n+  /* Store function names for edge-profiling.  */\n+\n+  if (profile_arc_flag)\n+  {\n+    struct function_list *new_item = xmalloc (sizeof (struct function_list));\n+\n+    /* Add function to linked list.  */\n+    new_item->next = 0;\n+    *functions_tail = new_item;\n+    functions_tail = &new_item->next;\n+\n+    /* Set values.  */\n+    new_item->cfg_checksum = profile_info.current_function_cfg_checksum;\n+    new_item->count_edges = profile_info.count_edges_instrumented_now;\n+    new_item->name = xstrdup (current_function_name);\n+    \n+  }\n+  \n   free (line_note_exists);\n   line_note_exists = NULL;\n }"}, {"sha": "9f1c00a08b1a1790cea31c0f6479bd1afac60782", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -6318,6 +6318,8 @@ prepare_function_start ()\n \n   current_function_outgoing_args_size = 0;\n \n+  cfun->arc_profile = profile_arc_flag || flag_test_coverage;\n+\n   (*lang_hooks.function.init) (cfun);\n   if (init_machine_status)\n     (*init_machine_status) (cfun);"}, {"sha": "2a566641eca76ffa3cf31fefca6fcda8433a0e6e", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -437,6 +437,9 @@ struct function\n      generated.  */\n   unsigned int instrument_entry_exit : 1;\n \n+  /* Nonzero if no profiling should be done for the function.  */\n+  unsigned int arc_profile : 1;\n+\n   /* Nonzero if profiling code should be generated.  */\n   unsigned int profile : 1;\n "}, {"sha": "9e1c081b16de1c898e1394f357b4c430ada764aa", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 108, "deletions": 7, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -24,13 +24,24 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <stdio.h>\n #include <sys/types.h>\n \n-static int __fetch_long\tPARAMS ((long *, char *, size_t)) ATTRIBUTE_UNUSED;\n-static int __read_long  PARAMS ((long *, FILE *, size_t)) ATTRIBUTE_UNUSED;\n-static int __write_long PARAMS ((long, FILE *, size_t)) ATTRIBUTE_UNUSED;\n-static int __fetch_gcov_type PARAMS ((gcov_type *, char *, size_t)) ATTRIBUTE_UNUSED;\n-static int __store_gcov_type PARAMS ((gcov_type, char *, size_t)) ATTRIBUTE_UNUSED;\n-static int __read_gcov_type  PARAMS ((gcov_type *, FILE *, size_t)) ATTRIBUTE_UNUSED;\n-static int __write_gcov_type PARAMS ((gcov_type, FILE *, size_t)) ATTRIBUTE_UNUSED;\n+static int __fetch_long\tPARAMS ((long *, char *, size_t))\n+\tATTRIBUTE_UNUSED;\n+static int __read_long  PARAMS ((long *, FILE *, size_t))\n+\tATTRIBUTE_UNUSED;\n+static int __write_long PARAMS ((long, FILE *, size_t))\n+\tATTRIBUTE_UNUSED;\n+static int __fetch_gcov_type PARAMS ((gcov_type *, char *, size_t))\n+\tATTRIBUTE_UNUSED;\n+static int __store_gcov_type PARAMS ((gcov_type, char *, size_t))\n+\tATTRIBUTE_UNUSED;\n+static int __read_gcov_type  PARAMS ((gcov_type *, FILE *, size_t))\n+\tATTRIBUTE_UNUSED;\n+static int __write_gcov_type PARAMS ((gcov_type, FILE *, size_t))\n+\tATTRIBUTE_UNUSED;\n+static int __write_gcov_string PARAMS ((const char *, size_t, FILE*, long))\n+\tATTRIBUTE_UNUSED;\n+static int __read_gcov_string PARAMS ((char *, size_t, FILE*, long))\n+\tATTRIBUTE_UNUSED;\n \n /* These routines only work for signed values.  */\n \n@@ -193,4 +204,94 @@ __read_long (dest, file, bytes)\n     return __fetch_long (dest, c, bytes);\n }\n \n+\n+/* Writes string in gcov format.  */\n+\n+static int\n+__write_gcov_string (string, length, file, delim)\n+     const char *string;\n+     size_t length;\n+     FILE *file;\n+     long delim;\n+{\n+  size_t temp = length + 1;\n+\n+  /* delimiter */\n+  if (__write_long (delim, file, 4) != 0)\n+    return 1;\n+\n+  if (__write_long (length, file, 4) != 0)\n+    return 1;\n+\n+  if (fwrite (string, temp, 1, file) != 1)\n+    return 1;\n+\n+  temp &= 3;\n+\n+  if (temp)\n+    {\n+      char c[4];\n+\n+      c[0] = c[1] = c[2] = c[3] = 0;\n+\n+      if (fwrite (c, sizeof (char), 4 - temp, file) != 4 - temp)\n+\treturn 1;\n+    }\n+\n+  if (__write_long (delim, file, 4) != 0)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Reads string in gcov format.  */\n+\n+\n+static int\n+__read_gcov_string (string, max_length, file, delim)\n+     char *string;\n+     size_t max_length;\n+     FILE *file;\n+     long delim;\n+{\n+  long delim_from_file;\n+  long length;\n+  long read_length;\n+  long tmp;\n+\n+  if (__read_long (&delim_from_file, file, 4) != 0)\n+    return 1;\n+\n+  if (delim_from_file != delim)\n+    return 1;\n+\n+  if (__read_long (&length, file, 4) != 0)\n+    return 1;\n+\n+  if (length > (long) max_length)\n+    read_length = max_length;\n+  else\n+    read_length = length;\n+\n+  tmp = (((length + 1) - 1) / 4 + 1) * 4;\n+  /* This is the size occupied by the string in the file */\n+\n+  if (fread (string, read_length, 1, file) != 1)\n+    return 1;\n+\n+  string[read_length] = 0;\n+\n+  if (fseek (file, tmp - read_length, SEEK_CUR) < 0)\n+    return 1;\n+\n+  if (__read_long (&delim_from_file, file, 4) != 0)\n+    return 1;\n+\n+  if (delim_from_file != delim)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+\n #endif /* ! GCC_GCOV_IO_H */"}, {"sha": "fbc3d00e898dcf2897c7df38dc859232663a0ef7", "filename": "gcc/gcov.c", "status": "modified", "additions": 159, "deletions": 23, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -232,6 +232,7 @@ static void print_usage PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void print_version PARAMS ((void)) ATTRIBUTE_NORETURN;\n static void init_arc PARAMS ((struct adj_list *, int, int, struct bb_info *));\n static struct adj_list *reverse_arcs PARAMS ((struct adj_list *));\n+static gcov_type *read_profile PARAMS ((char *, long, int));\n static void create_program_flow_graph PARAMS ((struct bb_info_list *));\n static void solve_program_flow_graph PARAMS ((struct bb_info_list *));\n static void calculate_branch_probs PARAMS ((struct bb_info_list *, int,\n@@ -538,6 +539,130 @@ reverse_arcs (arcptr)\n   return prev;\n }\n \n+/* Reads profiles from the .da file and compute a hybrid profile.  */\n+\n+static gcov_type *\n+read_profile (function_name, cfg_checksum, instr_arcs)\n+     char *function_name;\n+     long cfg_checksum;\n+     int instr_arcs;\n+{\n+  int i;\n+  int okay = 1;\n+  gcov_type *profile;\n+  char *function_name_buffer;\n+  int function_name_buffer_len;\n+\n+  profile = xmalloc (sizeof (gcov_type) * instr_arcs);\n+  rewind (da_file);\n+  function_name_buffer_len = strlen (function_name) + 1;\n+  function_name_buffer = xmalloc (function_name_buffer_len + 1);\n+\n+  for (i = 0; i < instr_arcs; i++)\n+    profile[i] = 0;\n+\n+  if (!da_file)\n+    return profile;\n+\n+  while (1)\n+    {\n+      long magic, extra_bytes;\n+      long func_count;\n+      int i;\n+\n+      if (__read_long (&magic, da_file, 4) != 0)\n+\tbreak;\n+\n+      if (magic != -123)\n+\t{\n+\t  okay = 0;\n+\t  break;\n+\t}\n+\n+      if (__read_long (&func_count, da_file, 4) != 0)\n+\t{\n+\t  okay = 0;\n+\t  break;\n+\t}\n+\n+      if (__read_long (&extra_bytes, da_file, 4) != 0)\n+\t{\n+\t  okay = 0;\n+\t  break;\n+\t}\n+\n+      /* skip extra data emited by __bb_exit_func.  */\n+      fseek (da_file, extra_bytes, SEEK_CUR);\n+\n+      for (i = 0; i < func_count; i++)\n+\t{\n+\t  long arc_count;\n+\t  long chksum;\n+\t  int j;\n+\n+\t  if (__read_gcov_string\n+\t      (function_name_buffer, function_name_buffer_len, da_file,\n+\t       -1) != 0)\n+\t    {\n+\t      okay = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (__read_long (&chksum, da_file, 4) != 0)\n+\t    {\n+\t      okay = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (__read_long (&arc_count, da_file, 4) != 0)\n+\t    {\n+\t      okay = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (strcmp (function_name_buffer, function_name) != 0\n+\t      || arc_count != instr_arcs || chksum != cfg_checksum)\n+\t    {\n+\t      /* skip */\n+\t      if (fseek (da_file, arc_count * 8, SEEK_CUR) < 0)\n+\t\t{\n+\t\t  okay = 0;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      gcov_type tmp;\n+\n+\t      for (j = 0; j < arc_count; j++)\n+\t\tif (__read_gcov_type (&tmp, da_file, 8) != 0)\n+\t\t  {\n+\t\t    okay = 0;\n+\t\t    break;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    profile[j] += tmp;\n+\t\t  }\n+\t    }\n+\t}\n+\n+      if (!okay)\n+\tbreak;\n+\n+    }\n+\n+  free (function_name_buffer);\n+\n+  if (!okay)\n+    {\n+      fprintf (stderr, \".da file corrupted!\\n\");\n+      free (profile);\n+      abort ();\n+    }\n+\n+  return profile;\n+}\n \n /* Construct the program flow graph from the .bbg file, and read in the data\n    in the .da file.  */\n@@ -550,6 +675,29 @@ create_program_flow_graph (bptr)\n   int i;\n   struct adj_list *arcptr;\n   struct bb_info *bb_graph;\n+  long cfg_checksum;\n+  long instr_arcs = 0;\n+  gcov_type *profile;\n+  int profile_pos = 0;\n+  char *function_name;\n+  long function_name_len, tmp;\n+\n+  /* Read function name.  */\n+  __read_long (&tmp, bbg_file, 4);   /* ignore -1.  */\n+  __read_long (&function_name_len, bbg_file, 4);\n+  function_name = xmalloc (function_name_len + 1);\n+  fread (function_name, 1, function_name_len + 1, bbg_file);\n+  \n+  /* Skip padding.  */\n+  tmp = (function_name_len + 1) % 4;\n+\n+  if (tmp)\n+    fseek (bbg_file, 4 - tmp, SEEK_CUR);\n+\n+  __read_long (&tmp, bbg_file, 4);   /* ignore -1.  */\n+  \n+  /* Read the cfg checksum.  */\n+  __read_long (&cfg_checksum, bbg_file, 4);\n \n   /* Read the number of blocks.  */\n   __read_long (&num_blocks, bbg_file, 4);\n@@ -579,7 +727,10 @@ create_program_flow_graph (bptr)\n \t  init_arc (arcptr, src, dest, bb_graph);\n \n \t  __read_long (&flag_bits, bbg_file, 4);\n-\t  arcptr->on_tree = flag_bits & 0x1;\n+\t  if (flag_bits & 0x1)\n+\t    arcptr->on_tree++;\n+\t  else \n+\t    instr_arcs++;\n \t  arcptr->fake = !! (flag_bits & 0x2);\n \t  arcptr->fall_through = !! (flag_bits & 0x4);\n \t}\n@@ -601,6 +752,10 @@ create_program_flow_graph (bptr)\n     if (bb_graph[i].succ)\n       bb_graph[i].succ = reverse_arcs (bb_graph[i].succ);\n \n+  /* Read profile from the .da file.  */\n+\n+  profile = read_profile (function_name, cfg_checksum, instr_arcs);\n+\n   /* For each arc not on the spanning tree, set its execution count from\n      the .da file.  */\n \n@@ -613,15 +768,13 @@ create_program_flow_graph (bptr)\n     for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n       if (! arcptr->on_tree)\n \t{\n-\t  gcov_type tmp_count = 0;\n-\t  if (da_file && __read_gcov_type (&tmp_count, da_file, 8))\n-\t    abort ();\n-\n-\t  arcptr->arc_count = tmp_count;\n+\t  arcptr->arc_count = profile[profile_pos++];\n \t  arcptr->count_valid = 1;\n \t  bb_graph[i].succ_count--;\n \t  bb_graph[arcptr->target].pred_count--;\n \t}\n+  free (profile);\n+  free (function_name);\n }\n \n static void\n@@ -755,12 +908,6 @@ read_files ()\n   struct stat buf;\n   struct bb_info_list *list_end = 0;\n   struct bb_info_list *b_ptr;\n-  long total;\n-\n-  /* Read and ignore the first word of the .da file, which is the count of\n-     how many numbers follow.  */\n-  if (da_file && __read_long (&total, da_file, 8))\n-    abort ();\n \n   while (! feof (bbg_file))\n     {\n@@ -781,17 +928,6 @@ read_files ()\n       ungetc (getc (bbg_file), bbg_file);\n     }\n \n-  /* Check to make sure the .da file data is valid.  */\n-\n-  if (da_file)\n-    {\n-      if (feof (da_file))\n-\tfnotice (stderr, \".da file contents exhausted too early\\n\");\n-      /* Should be at end of file now.  */\n-      if (__read_long (&total, da_file, 8) == 0)\n-\tfnotice (stderr, \".da file contents not exhausted\\n\");\n-    }\n-\n   /* Calculate all of the basic block execution counts and branch\n      taken probabilities.  */\n "}, {"sha": "6c004a59a3b68724105115d1053485075fa4af11", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 115, "deletions": 89, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -1238,12 +1238,11 @@ __eprintf (const char *string, const char *expression,\n \n #ifdef L_bb\n \n-#if LONG_TYPE_SIZE == GCOV_TYPE_SIZE\n-typedef long gcov_type;\n-#else\n-typedef long long gcov_type;\n-#endif\n-\n+struct bb_function_info {\n+  long checksum;\n+  int arc_count;\n+  const char *name;\n+};\n \n /* Structure emitted by -a  */\n struct bb\n@@ -1253,14 +1252,10 @@ struct bb\n   gcov_type *counts;\n   long ncounts;\n   struct bb *next;\n-  const unsigned long *addresses;\n \n   /* Older GCC's did not emit these fields.  */\n   long nwords;\n-  const char **functions;\n-  const long *line_nums;\n-  const char **filenames;\n-  char *flags;\n+  struct bb_function_info *function_infos;\n };\n \n #ifdef BLOCK_PROFILER_CODE\n@@ -1283,39 +1278,66 @@ BLOCK_PROFILER_CODE\n #include <errno.h>\n #endif\n \n+#include <gthr.h>\n+\n static struct bb *bb_head;\n \n+int __global_counters = 0, __gthreads_active = 0;\n+\n void\n __bb_exit_func (void)\n {\n   FILE *da_file;\n-  int i;\n   struct bb *ptr;\n+  long n_counters_p = 0;\n+  gcov_type max_counter_p = 0;\n+  gcov_type sum_counters_p = 0;\n \n   if (bb_head == 0)\n     return;\n \n-  i = strlen (bb_head->filename) - 3;\n+  /* Calculate overall \"statistics\".  */\n \n+  for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n+    {\n+      int i;\n+\n+      n_counters_p += ptr->ncounts;\n+\n+      for (i = 0; i < ptr->ncounts; i++)\n+\t{\n+\t  sum_counters_p += ptr->counts[i];\n+\n+\t  if (ptr->counts[i] > max_counter_p)\n+\t    max_counter_p = ptr->counts[i];\n+\t}\n+    }\n \n   for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n     {\n-      int firstchar;\n+      gcov_type max_counter_o = 0;\n+      gcov_type sum_counters_o = 0;\n+      int i;\n+\n+      /* Calculate the per-object statistics.  */\n \n-      /* Make sure the output file exists -\n-         but don't clobber exiting data.  */\n-      if ((da_file = fopen (ptr->filename, \"a\")) != 0)\n-\tfclose (da_file);\n+      for (i = 0; i < ptr->ncounts; i++)\n+\t{\n+\t  sum_counters_o += ptr->counts[i];\n \n-      /* Need to re-open in order to be able to write from the start.  */\n-      da_file = fopen (ptr->filename, \"r+b\");\n+\t  if (ptr->counts[i] > max_counter_o)\n+\t    max_counter_o = ptr->counts[i];\n+\t}\n+\n+      /* open the file for appending, creating it if necessary.  */\n+      da_file = fopen (ptr->filename, \"ab\");\n       /* Some old systems might not allow the 'b' mode modifier.\n          Therefore, try to open without it.  This can lead to a race\n          condition so that when you delete and re-create the file, the\n          file might be opened in text mode, but then, you shouldn't\n          delete the file in the first place.  */\n       if (da_file == 0)\n-\tda_file = fopen (ptr->filename, \"r+\");\n+\tda_file = fopen (ptr->filename, \"a\");\n       if (da_file == 0)\n \t{\n \t  fprintf (stderr, \"arc profiling: Can't open output file %s.\\n\",\n@@ -1341,92 +1363,96 @@ __bb_exit_func (void)\n       }\n #endif\n \n-      /* If the file is not empty, and the number of counts in it is the\n-         same, then merge them in.  */\n-      firstchar = fgetc (da_file);\n-      if (firstchar == EOF)\n+      if (__write_long (-123, da_file, 4) != 0)\t/* magic */\n \t{\n-\t  if (ferror (da_file))\n-\t    {\n-\t      fprintf (stderr, \"arc profiling: Can't read output file \");\n-\t      perror (ptr->filename);\n-\t    }\n+\t  fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n+\t\t   ptr->filename);\n \t}\n       else\n \t{\n-\t  long n_counts = 0;\n-\n-\t  if (ungetc (firstchar, da_file) == EOF)\n-\t    rewind (da_file);\n-\t  if (__read_long (&n_counts, da_file, 8) != 0)\n-\t    {\n-\t      fprintf (stderr, \"arc profiling: Can't read output file %s.\\n\",\n-\t\t       ptr->filename);\n-\t      continue;\n-\t    }\n \n-\t  if (n_counts == ptr->ncounts)\n+\t  struct bb_function_info *fn_info;\n+\t  gcov_type *count_ptr = ptr->counts;\n+\t  int i;\n+\t  int count_functions = 0;\n+\n+\t  for (fn_info = ptr->function_infos; fn_info->arc_count != -1;\n+\t       fn_info++)\n+\t    count_functions++;\n+\n+\t  /* number of functions in this block.  */\n+\t  __write_long (count_functions, da_file, 4);\n+\n+\t  /* length of extra data in bytes.  */\n+\t  __write_long ((4 + 8 + 8) + (4 + 8 + 8), da_file, 4);\n+\n+\t  /* overall statistics. */\n+\t  /* number of counters.  */\n+\t  __write_long (n_counters_p, da_file, 4);\t\n+\t  /* sum of counters.  */\n+\t  __write_gcov_type (sum_counters_p, da_file, 8);\t\n+\t  /* maximal counter.  */\n+\t  __write_gcov_type (max_counter_p, da_file, 8);\t\n+\n+\t  /* per-object statistics. */\n+\t  /* number of counters.  */\n+\t  __write_long (ptr->ncounts, da_file, 4);\t\n+\t  /* sum of counters.  */\n+\t  __write_gcov_type (sum_counters_o, da_file, 8);\t\n+\t  /* maximal counter.  */\n+\t  __write_gcov_type (max_counter_o, da_file, 8);\t\n+\n+\t  /* write execution counts for each function.  */\n+\n+\t  for (fn_info = ptr->function_infos; fn_info->arc_count != -1;\n+\t       fn_info++)\n \t    {\n-\t      int i;\n-\n-\t      for (i = 0; i < n_counts; i++)\n+\t      /* new function.  */\n+\t      if (__write_gcov_string\n+\t\t  (fn_info->name, strlen (fn_info->name), da_file, -1) != 0)\n \t\t{\n-\t\t  gcov_type v = 0;\n-\n-\t\t  if (__read_gcov_type (&v, da_file, 8) != 0)\n-\t\t    {\n-\t\t      fprintf (stderr,\n-\t\t\t       \"arc profiling: Can't read output file %s.\\n\",\n-\t\t\t       ptr->filename);\n-\t\t      break;\n-\t\t    }\n-\t\t  ptr->counts[i] += v;\n+\t\t  fprintf (stderr,\n+\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  break;\n \t\t}\n-\t    }\n \n-\t}\n-\n-      rewind (da_file);\n-\n-      /* ??? Should first write a header to the file.  Preferably, a 4 byte\n-         magic number, 4 bytes containing the time the program was\n-         compiled, 4 bytes containing the last modification time of the\n-         source file, and 4 bytes indicating the compiler options used.\n+\t      if (__write_long (fn_info->checksum, da_file, 4) != 0)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  break;\n+\t\t}\n \n-         That way we can easily verify that the proper source/executable/\n-         data file combination is being used from gcov.  */\n+\t      if (__write_long (fn_info->arc_count, da_file, 4) != 0)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  break;\n+\t\t}\n \n-      if (__write_gcov_type (ptr->ncounts, da_file, 8) != 0)\n-\t{\n+\t      for (i = fn_info->arc_count; i > 0; i--, count_ptr++)\n+\t\t{\n+\t\t  if (__write_gcov_type (*count_ptr, da_file, 8) != 0)\n+\t\t    break;\n+\t\t}\n \n-\t  fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n-\t\t   ptr->filename);\n-\t}\n-      else\n-\t{\n-\t  int j;\n-\t  gcov_type *count_ptr = ptr->counts;\n-\t  int ret = 0;\n-\t  for (j = ptr->ncounts; j > 0; j--)\n-\t    {\n-\t      if (__write_gcov_type (*count_ptr, da_file, 8) != 0)\n+\t      if (i)\t\t/* there was an error */\n \t\t{\n-\t\t  ret = 1;\n+\t\t  fprintf (stderr,\n+\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n+\t\t\t   ptr->filename);\n \t\t  break;\n \t\t}\n-\t      count_ptr++;\n \t    }\n-\t  if (ret)\n-\t    fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n-\t\t     ptr->filename);\n \t}\n \n-      if (fclose (da_file) == EOF)\n+      if (fclose (da_file) != 0)\n \tfprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n \t\t ptr->filename);\n     }\n-\n-  return;\n }\n \n void\n@@ -1437,8 +1463,8 @@ __bb_init_func (struct bb *blocks)\n \n   if (blocks->zero_word)\n     return;\n-\n-  /* Initialize destructor.  */\n+  \n+  /* Initialize destructor and per-thread data.  */\n   if (!bb_head)\n     atexit (__bb_exit_func);\n \n@@ -1451,7 +1477,7 @@ __bb_init_func (struct bb *blocks)\n /* Called before fork or exec - write out profile information gathered so\n    far and reset it to zero.  This avoids duplication or loss of the\n    profile information gathered so far.  */\n-void\n+void \n __bb_fork_func (void)\n {\n   struct bb *ptr;"}, {"sha": "79c799700578e170888a8988f086adfd524e5677", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -31,9 +31,14 @@ struct bb;\n extern void __bb_exit_func (void);\n extern void __bb_init_func (struct bb *);\n extern void __bb_fork_func (void);\n-extern void __bb_trace_func (void);\n-extern void __bb_trace_ret (void);\n-extern void __bb_init_trace_func (struct bb *, unsigned long);\n+\n+#if LONG_TYPE_SIZE == GCOV_TYPE_SIZE\n+typedef long gcov_type;\n+#else\n+typedef long long gcov_type;\n+#endif\n+\n+extern gcov_type *__bb_find_arc_counters (void);\n \n struct exception_descriptor;\n extern short int __get_eh_table_language (struct exception_descriptor *);"}, {"sha": "6fa4e12f031be225c36b5b1c727969d402213e47", "filename": "gcc/profile.c", "status": "modified", "additions": 234, "deletions": 47, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -49,6 +49,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"gcov-io.h\"\n #include \"target.h\"\n+#include \"profile.h\"\n+#include \"libfuncs.h\"\n #include \"langhooks.h\"\n \n /* Additional information about the edges we need.  */\n@@ -92,11 +94,6 @@ static FILE *bb_file;\n \n static char *last_bb_file_name;\n \n-/* Used by final, for allocating the proper amount of storage for the\n-   instrumented arc execution counts.  */\n-\n-int count_instrumented_edges;\n-\n /* Collect statistics on the performance of this pass for the entire source\n    file.  */\n \n@@ -118,6 +115,8 @@ static rtx gen_edge_profiler PARAMS ((int));\n static void instrument_edges PARAMS ((struct edge_list *));\n static void output_gcov_string PARAMS ((const char *, long));\n static void compute_branch_probabilities PARAMS ((void));\n+static gcov_type * get_exec_counts PARAMS ((void));\n+static long compute_checksum PARAMS ((void));\n static basic_block find_group PARAMS ((basic_block));\n static void union_groups PARAMS ((basic_block, basic_block));\n \n@@ -163,8 +162,9 @@ instrument_edges (el)\n \t}\n     }\n \n+  profile_info.count_edges_instrumented_now = num_instr_edges;\n   total_num_edges_instrumented += num_instr_edges;\n-  count_instrumented_edges = total_num_edges_instrumented;\n+  profile_info.count_instrumented_edges = total_num_edges_instrumented;\n \n   total_num_blocks_created += num_edges;\n   if (rtl_dump_file)\n@@ -205,6 +205,167 @@ output_gcov_string (string, delimiter)\n }\n \f\n \n+/* Computes hybrid profile for all matching entries in da_file. \n+   Sets max_counter_in_program as a side effect.  */\n+\n+static gcov_type *\n+get_exec_counts ()\n+{\n+  int num_edges = 0;\n+  int i;\n+  int okay = 1;\n+  int mismatch = 0;\n+  gcov_type *profile;\n+  char *function_name_buffer;\n+  int function_name_buffer_len;\n+  gcov_type max_counter_in_run;\n+\n+  profile_info.max_counter_in_program = 0;\n+  profile_info.count_profiles_merged = 0;\n+\n+  /* No .da file, no execution counts.  */\n+  if (!da_file)\n+    return 0;\n+\n+  /* Count the edges to be (possibly) instrumented.  */\n+\n+  for (i = 0; i < n_basic_blocks + 2; i++)\n+    {\n+      basic_block bb = GCOV_INDEX_TO_BB (i);\n+      edge e;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (!EDGE_INFO (e)->ignore && !EDGE_INFO (e)->on_tree)\n+\t  {\n+\t    num_edges++;\n+\t  }\n+    }\n+\n+  /* now read and combine all matching profiles. */\n+\n+  profile = xmalloc (sizeof (gcov_type) * num_edges);\n+  rewind (da_file);\n+  function_name_buffer_len = strlen (current_function_name) + 1;\n+  function_name_buffer = xmalloc (function_name_buffer_len + 1);\n+\n+  for (i = 0; i < num_edges; i++)\n+    profile[i] = 0;\n+\n+  while (1)\n+    {\n+      long magic, extra_bytes;\n+      long func_count;\n+      int i;\n+\n+      if (__read_long (&magic, da_file, 4) != 0)\n+\tbreak;\n+\n+      if (magic != -123)\n+\t{\n+\t  okay = 0;\n+\t  break;\n+\t}\n+\n+      if (__read_long (&func_count, da_file, 4) != 0)\n+\t{\n+\t  okay = 0;\n+\t  break;\n+\t}\n+\n+      if (__read_long (&extra_bytes, da_file, 4) != 0)\n+\t{\n+\t  okay = 0;\n+\t  break;\n+\t}\n+\n+      fseek (da_file, 4 + 8, SEEK_CUR);\n+\n+      /* read the maximal counter.  */\n+      __read_gcov_type (&max_counter_in_run, da_file, 8);\n+\n+      /* skip the rest of \"statistics\" emited by __bb_exit_func.  */\n+      fseek (da_file, extra_bytes - (4 + 8 + 8), SEEK_CUR);\n+\n+      for (i = 0; i < func_count; i++)\n+\t{\n+\t  long arc_count;\n+\t  long chksum;\n+\t  int j;\n+\n+\t  if (__read_gcov_string\n+\t      (function_name_buffer, function_name_buffer_len, da_file,\n+\t       -1) != 0)\n+\t    {\n+\t      okay = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (__read_long (&chksum, da_file, 4) != 0)\n+\t    {\n+\t      okay = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (__read_long (&arc_count, da_file, 4) != 0)\n+\t    {\n+\t      okay = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (strcmp (function_name_buffer, current_function_name) != 0)\n+\t    {\n+\t      /* skip */\n+\t      if (fseek (da_file, arc_count * 8, SEEK_CUR) < 0)\n+\t\t{\n+\t\t  okay = 0;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else if (arc_count != num_edges\n+\t\t   || chksum != profile_info.current_function_cfg_checksum)\n+\t    okay = 0, mismatch = 1;\n+\t  else\n+\t    {\n+\t      gcov_type tmp;\n+\n+\t      profile_info.max_counter_in_program += max_counter_in_run;\n+\t      profile_info.count_profiles_merged++;\n+\n+\t      for (j = 0; j < arc_count; j++)\n+\t\tif (__read_gcov_type (&tmp, da_file, 8) != 0)\n+\t\t  {\n+\t\t    okay = 0;\n+\t\t    break;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    profile[j] += tmp;\n+\t\t  }\n+\t    }\n+\t}\n+\n+      if (!okay)\n+\tbreak;\n+\n+    }\n+\n+  free (function_name_buffer);\n+\n+  if (!okay)\n+    {\n+      if (mismatch)\n+\terror\n+\t  (\"Profile does not match flowgraph of function %s (out of date?)\",\n+\t   current_function_name);\n+      else\n+\terror (\".da file corrupted\");\n+      free (profile);\n+      return 0;\n+    }\n+\n+  return profile;\n+}\n+\f\n+\n /* Compute the branch probabilities for the various branches.\n    Annotate them accordingly.  */\n \n@@ -218,6 +379,8 @@ compute_branch_probabilities ()\n   int hist_br_prob[20];\n   int num_never_executed;\n   int num_branches;\n+  gcov_type *exec_counts = get_exec_counts ();\n+  int exec_counts_pos = 0;\n \n   /* Attach extra info block to each bb.  */\n \n@@ -253,14 +416,13 @@ compute_branch_probabilities ()\n \tif (!EDGE_INFO (e)->ignore && !EDGE_INFO (e)->on_tree)\n \t  {\n \t    num_edges++;\n-\t    if (da_file)\n+\t    if (exec_counts)\n \t      {\n-\t\tgcov_type value;\n-\t\t__read_gcov_type (&value, da_file, 8);\n-\t\te->count = value;\n+\t\te->count = exec_counts[exec_counts_pos++];\n \t      }\n \t    else\n \t      e->count = 0;\n+\n \t    EDGE_INFO (e)->count_valid = 1;\n \t    BB_INFO (bb)->succ_count--;\n \t    BB_INFO (e->dest)->pred_count--;\n@@ -517,6 +679,36 @@ compute_branch_probabilities ()\n     }\n \n   free_aux_for_blocks ();\n+  if (exec_counts)\n+    free (exec_counts);\n+}\n+\n+/* Compute checksum for the current function.  */\n+\n+#define CHSUM_HASH\t500000003\n+#define CHSUM_SHIFT\t2\n+\n+static long\n+compute_checksum ()\n+{\n+  long chsum = 0;\n+  int i;\n+\n+  \n+  for (i = 0; i < n_basic_blocks ; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      edge e;\n+\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  chsum = ((chsum << CHSUM_SHIFT) + (BB_TO_GCOV_INDEX (e->dest) + 1)) % CHSUM_HASH;\n+\t}\n+\n+      chsum = (chsum << CHSUM_SHIFT) % CHSUM_HASH;\n+    }\n+\n+  return chsum;\n }\n \n /* Instrument and/or analyze program behavior based on program flow graph.\n@@ -542,6 +734,12 @@ branch_prob ()\n   int num_edges, ignored_edges;\n   struct edge_list *el;\n \n+  profile_info.current_function_cfg_checksum = compute_checksum ();\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"CFG checksum is %ld\\n\", \n+\tprofile_info.current_function_cfg_checksum);\n+  \n   /* Start of a function.  */\n   if (flag_test_coverage)\n     output_gcov_string (current_function_name, (long) -2);\n@@ -758,6 +956,12 @@ branch_prob ()\n     {\n       int flag_bits;\n \n+      __write_gcov_string (current_function_name,\n+\t\t           strlen (current_function_name), bbg_file, -1);\n+\n+      /* write checksum.  */\n+      __write_long (profile_info.current_function_cfg_checksum, bbg_file, 4);\n+      \n       /* The plus 2 stands for entry and exit block.  */\n       __write_long (n_basic_blocks + 2, bbg_file, 4);\n       __write_long (num_edges - ignored_edges + 1, bbg_file, 4);\n@@ -884,14 +1088,21 @@ find_spanning_tree (el)\n   /* Add fake edge exit to entry we can't instrument.  */\n   union_groups (EXIT_BLOCK_PTR, ENTRY_BLOCK_PTR);\n \n-  /* First add all abnormal edges to the tree unless they form an cycle.  */\n+  /* First add all abnormal edges to the tree unless they form an cycle. Also\n+     add all edges to EXIT_BLOCK_PTR to avoid inserting profiling code behind\n+     setting return value from function.  */\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n-      if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_FAKE))\n+      if (((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_FAKE))\n+           || e->dest == EXIT_BLOCK_PTR\n+          )\n \t  && !EDGE_INFO (e)->ignore\n \t  && (find_group (e->src) != find_group (e->dest)))\n \t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Abnormal edge %d to %d put to tree\\n\",\n+                     e->src->index, e->dest->index);\n \t  EDGE_INFO (e)->on_tree = 1;\n \t  union_groups (e->src, e->dest);\n \t}\n@@ -905,6 +1116,9 @@ find_spanning_tree (el)\n \t  && !EDGE_INFO (e)->ignore\n \t  && (find_group (e->src) != find_group (e->dest)))\n \t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Critical edge %d to %d put to tree\\n\",\n+                     e->src->index, e->dest->index);\n \t  EDGE_INFO (e)->on_tree = 1;\n \t  union_groups (e->src, e->dest);\n \t}\n@@ -917,6 +1131,9 @@ find_spanning_tree (el)\n       if (find_group (e->src) != find_group (e->dest)\n \t  && !EDGE_INFO (e)->ignore)\n \t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Normal edge %d to %d put to tree\\n\",\n+                     e->src->index, e->dest->index);\n \t  EDGE_INFO (e)->on_tree = 1;\n \t  union_groups (e->src, e->dest);\n \t}\n@@ -975,12 +1192,6 @@ init_branch_prob (filename)\n       if ((da_file = fopen (da_file_name, \"rb\")) == 0)\n \twarning (\"file %s not found, execution counts assumed to be zero\",\n \t\t da_file_name);\n-\n-      /* The first word in the .da file gives the number of instrumented\n-\t edges, which is not needed for our purposes.  */\n-\n-      if (da_file)\n-\t__read_long (&len, da_file, 8);\n     }\n \n   if (profile_arc_flag)\n@@ -1011,22 +1222,8 @@ end_branch_prob ()\n       fclose (bbg_file);\n     }\n \n-  if (flag_branch_probabilities)\n-    {\n-      if (da_file)\n-\t{\n-\t  long temp;\n-\t  /* This seems slightly dangerous, as it presumes the EOF\n-\t     flag will not be set until an attempt is made to read\n-\t     past the end of the file.  */\n-\t  if (feof (da_file))\n-\t    error (\".da file contents exhausted too early\");\n-\t  /* Should be at end of file now.  */\n-\t  if (__read_long (&temp, da_file, 8) == 0)\n-\t    error (\".da file contents not exhausted\");\n-\t  fclose (da_file);\n-\t}\n-    }\n+  if (flag_branch_probabilities && da_file)\n+    fclose (da_file);\n \n   if (rtl_dump_file)\n     {\n@@ -1097,6 +1294,8 @@ gen_edge_profiler (edgeno)\n   tmp = expand_simple_binop (mode, PLUS, mem_ref, const1_rtx,\n \t\t\t     mem_ref, 0, OPTAB_WIDEN);\n \n+  set_mem_alias_set (mem_ref, new_alias_set ());\n+\n   if (tmp != mem_ref)\n     emit_move_insn (copy_rtx (mem_ref), tmp);\n \n@@ -1118,9 +1317,6 @@ output_func_start_profiler ()\n   rtx table_address;\n   enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n   int save_flag_inline_functions = flag_inline_functions;\n-  int save_flag_test_coverage = flag_test_coverage;\n-  int save_profile_arc_flag = profile_arc_flag;\n-  int save_flag_branch_probabilities = flag_branch_probabilities;\n \n   /* It's either already been output, or we don't need it because we're\n      not doing profile-edges.  */\n@@ -1163,6 +1359,7 @@ output_func_start_profiler ()\n   init_function_start (fndecl, input_filename, lineno);\n   (*lang_hooks.decls.pushlevel) (0);\n   expand_function_start (fndecl, 0);\n+  cfun->arc_profile = 0;\n \n   /* Actually generate the code to call __bb_init_func.  */\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 0);\n@@ -1179,20 +1376,10 @@ output_func_start_profiler ()\n      flag_inline_functions.  */\n   flag_inline_functions = 0;\n \n-  /* Don't instrument the function that turns on instrumentation.  Which\n-     is also handy since we'd get silly warnings about not consuming all\n-     of our da_file input.  */\n-  flag_test_coverage = 0;\n-  profile_arc_flag = 0;\n-  flag_branch_probabilities = 0;\n-\n   rest_of_compilation (fndecl);\n \n   /* Reset flag_inline_functions to its original value.  */\n   flag_inline_functions = save_flag_inline_functions;\n-  flag_test_coverage = save_flag_test_coverage;\n-  profile_arc_flag = save_profile_arc_flag;\n-  flag_branch_probabilities = save_flag_branch_probabilities;\n \n   if (! quiet_flag)\n     fflush (asm_out_file);"}, {"sha": "4170afde8e8e32aab37300ce57f113ba3c1b298b", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c9bf289f096dd5338f37a4656f13d7b982fd33/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b7c9bf289f096dd5338f37a4656f13d7b982fd33", "patch": "@@ -364,6 +364,11 @@ int profile_flag = 0;\n \n int profile_arc_flag = 0;\n \n+/* Nonzero if we should not attempt to generate thread-safe\n+   code to profile program flow graph arcs.  */\n+\n+int flag_unsafe_profile_arcs = 0;\n+\n /* Nonzero if generating info for gcov to calculate line test coverage.  */\n \n int flag_test_coverage = 0;\n@@ -1061,6 +1066,8 @@ static const lang_independent_options f_options[] =\n    N_(\"Support synchronous non-call exceptions\") },\n   {\"profile-arcs\", &profile_arc_flag, 1,\n    N_(\"Insert arc based program profiling code\") },\n+  {\"unsafe-profile-arcs\", &flag_unsafe_profile_arcs, 1,\n+   N_(\"Avoid thread safety profiling overhead\") },\n   {\"test-coverage\", &flag_test_coverage, 1,\n    N_(\"Create data files needed by gcov\") },\n   {\"branch-probabilities\", &flag_branch_probabilities, 1,\n@@ -2891,14 +2898,13 @@ rest_of_compilation (decl)\n   close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n \n   /* Do branch profiling and static profile estimation passes.  */\n-  if (optimize > 0 || profile_arc_flag || flag_test_coverage\n-      || flag_branch_probabilities)\n+  if (optimize > 0 || cfun->arc_profile || flag_branch_probabilities)\n     {\n       struct loops loops;\n \n       timevar_push (TV_BRANCH_PROB);\n       open_dump_file (DFI_bp, decl);\n-      if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+      if (cfun->arc_profile || flag_branch_probabilities)\n \tbranch_prob ();\n \n       /* Discover and record the loop depth at the head of each basic"}]}