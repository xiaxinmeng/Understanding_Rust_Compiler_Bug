{"sha": "23346f368bbbd29d11fc0685be20ecf3ef3b6dc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMzNDZmMzY4YmJiZDI5ZDExZmMwNjg1YmUyMGVjZjNlZjNiNmRjMA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@google.com", "date": "2010-12-08T15:48:50Z"}, "committer": {"name": "Doug Evans", "email": "devans@gcc.gnu.org", "date": "2010-12-08T15:48:50Z"}, "message": "splay-tree.c (splay_tree_foreach_helper): Remove arg `sp', all callers updated.\n\n\t* splay-tree.c (splay_tree_foreach_helper): Remove arg `sp',\n\tall callers updated.  Rewrite to be non-recursive.\n\nFrom-SVN: r167589", "tree": {"sha": "53ea19e3aac1de50620a4110f7182d30acb6f588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53ea19e3aac1de50620a4110f7182d30acb6f588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0/comments", "author": null, "committer": null, "parents": [{"sha": "00c4e97c949ee249c6ed983945d9c0e369dce6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c4e97c949ee249c6ed983945d9c0e369dce6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c4e97c949ee249c6ed983945d9c0e369dce6e2"}], "stats": {"total": 57, "additions": 44, "deletions": 13}, "files": [{"sha": "bc02da4a2bdc18ffd792513967ed5372b74709b9", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=23346f368bbbd29d11fc0685be20ecf3ef3b6dc0", "patch": "@@ -1,3 +1,8 @@\n+2010-12-08  Doug Evans  <dje@google.com>\n+\n+\t* splay-tree.c (splay_tree_foreach_helper): Remove arg `sp',\n+\tall callers updated.  Rewrite to be non-recursive.\n+\n 2010-11-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* setproctitle.c [HAVE_SYS_PRCTL_H]: Include <sys/types.h>."}, {"sha": "27ae4660189c947d771b180a481b82a64e492168", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23346f368bbbd29d11fc0685be20ecf3ef3b6dc0/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=23346f368bbbd29d11fc0685be20ecf3ef3b6dc0", "patch": "@@ -44,7 +44,7 @@ static inline void rotate_left (splay_tree_node *,\n static inline void rotate_right (splay_tree_node *,\n \t\t\t\tsplay_tree_node, splay_tree_node);\n static void splay_tree_splay (splay_tree, splay_tree_key);\n-static int splay_tree_foreach_helper (splay_tree, splay_tree_node,\n+static int splay_tree_foreach_helper (splay_tree_node,\n                                       splay_tree_foreach_fn, void*);\n \n /* Deallocate NODE (a member of SP), and all its sub-trees.  */\n@@ -204,25 +204,51 @@ splay_tree_splay (splay_tree sp, splay_tree_key key)\n    value is returned.  Otherwise, this function returns 0.  */\n \n static int\n-splay_tree_foreach_helper (splay_tree sp, splay_tree_node node,\n+splay_tree_foreach_helper (splay_tree_node node,\n                            splay_tree_foreach_fn fn, void *data)\n {\n   int val;\n+  splay_tree_node *stack;\n+  int stack_ptr, stack_size;\n \n-  if (!node)\n-    return 0;\n+  /* A non-recursive implementation is used to avoid filling the stack\n+     for large trees.  Splay trees are worst case O(n) in the depth of\n+     the tree.  */\n+\n+#define INITIAL_STACK_SIZE 100\n+  stack_size = INITIAL_STACK_SIZE;\n+  stack_ptr = 0;\n+  stack = XNEWVEC (splay_tree_node, stack_size);\n+  val = 0;\n+\n+  for (;;)\n+    {\n+      while (node != NULL)\n+\t{\n+\t  if (stack_ptr == stack_size)\n+\t    {\n+\t      stack_size *= 2;\n+\t      stack = XRESIZEVEC (splay_tree_node, stack, stack_size);\n+\t    }\n+\t  stack[stack_ptr++] = node;\n+\t  node = node->left;\n+\t}\n \n-  val = splay_tree_foreach_helper (sp, node->left, fn, data);\n-  if (val)\n-    return val;\n+      if (stack_ptr == 0)\n+\tbreak;\n \n-  val = (*fn)(node, data);\n-  if (val)\n-    return val;\n+      node = stack[--stack_ptr];\n \n-  return splay_tree_foreach_helper (sp, node->right, fn, data);\n-}\n+      val = (*fn) (node, data);\n+      if (val)\n+\tbreak;\n \n+      node = node->right;\n+    }\n+\n+  XDELETEVEC (stack);\n+  return val;\n+}\n \n /* An allocator and deallocator based on xmalloc.  */\n static void *\n@@ -537,7 +563,7 @@ splay_tree_successor (splay_tree sp, splay_tree_key key)\n int\n splay_tree_foreach (splay_tree sp, splay_tree_foreach_fn fn, void *data)\n {\n-  return splay_tree_foreach_helper (sp, sp->root, fn, data);\n+  return splay_tree_foreach_helper (sp->root, fn, data);\n }\n \n /* Splay-tree comparison function, treating the keys as ints.  */"}]}