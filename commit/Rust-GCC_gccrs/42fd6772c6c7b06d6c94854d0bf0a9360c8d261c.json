{"sha": "42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJmZDY3NzJjNmM3YjA2ZDZjOTQ4NTRkMGJmMGE5MzYwYzhkMjYxYw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-12-10T22:17:15Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-12-10T22:17:15Z"}, "message": "tree-vrp.c (adjust_range_with_scev): Use get_chrec_loop.\n\n\t* tree-vrp.c (adjust_range_with_scev): Use get_chrec_loop.\n\t* loop-unswitch.c (unswitch_loops): Use FOR_EACH_LOOP.\n\t* tree-loop-linear.c (linear_transform_loops): Ditto.\n\t* tree-ssa-loop-im.c (determine_lsm): Ditto.\n\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations,\n\tfree_numbers_of_iterations_estimates): Ditto.\n\t* tree_ssa_unswitch_loops (tree_ssa_unswitch_loops): Ditto.\n\t* tree-ssa-loop-ch.c (copy_loop_headers): Ditto.\n\t* tree-ssa-loop-ivopts.c (tree_ssa_iv_optimize): Ditto.\n\t* modulo-sched.c (sms_schedule): Ditto.\n\t* tree-ssa-loop-ivcanon.c (canonicalize_induction_variables,\n\ttree_unroll_loops_completely): Ditto.\n\t* predict.c (predict_loops): Ditto.\n\t* tree-if-conv.c (main_tree_if_conversion): Ditto.\n\t* loop-unroll.c (unroll_and_peel_loops, peel_loops_completely,\n\tdecide_unrolling_and_peeling): Ditto.\n\t* cfgloopmanip.c (unloop): Use delete_loop.\n\t(place_new_loop): Access larray vector instead of parray.\n\t(create_preheaders, force_single_succ_latches,\n\tfix_loop_structure): Use FOR_EACH_LOOP and delete_loop..\n\t* loop-doloop.c (doloop_optimize_loops): Ditto.\n\t* loop-invariant.c (move_loop_invariants): Ditto.\n\t* tree-cfg.c (replace_uses_by): Ditto.\n\t* tree-ssa-loop-prefetch.c (tree_ssa_prefetch_arrays): Ditto.\n\t* tree-chrec.h (CHREC_VAR, CHREC_LEFT, CHREC_RIGHT, CHREC_VARIABLE):\n\tMoved to ...\n\t* tree.h (CHREC_VAR, CHREC_LEFT, CHREC_RIGHT, CHREC_VARIABLE):\n\t... here.\n\t* tree-scalar-evolution.c (chrec_contains_symbols_defined_in_loop,\n\tcompute_overall_effect_of_inner_loop, chrec_is_positive): Use\n\tget_loop and get_chrec_loop.\n\t(number_of_iterations_for_all_loops): Use number_of_loops.\n\t(scev_initialize, scev_reset, scev_const_prop): Use FOR_EACH_LOOP.\n\t* tree-scalar-evolution.h (get_chrec_loop): New inline function.\n\t* cfgloopanal.c (mark_irreducible_loops): Use number_of_loops,\n\tand FOR_EACH_LOOP.\n\t* tree-chrec.c (evolution_function_is_invariant_rec_p,\n\tchrec_convert_1): Use get_loop and get_chrec_loop.\n\t* loop-init.c (loop_optimizer_init): Use number_of_loops.\n\t(loop_optimizer_init): Use FOR_EACH_LOOP.\n\t* tree-vectorizer.c (vect_loops_num): Removed.\n\t(vectorize_loops): Store number of loops locally.  Use\n\tFOR_EACH_LOOP and get_loop.\n\t* tree-vectorizer.h (vect_loops_num): Removed.\n\t* tree-data-ref.c (get_number_of_iters_for_loop): Use get_loop.\n\t(find_data_references_in_loop): Do not set parallel_p.\n\t* tree-data-ref.h: Do not declare VEC(loop_p).\n\t* cfgloop.c (flow_loops_dump, mark_single_exit_loops,\n\tverify_loop_structure): Use FOR_EACH_LOOP.\n\t(flow_loops_free): Use FOR_EACH_LOOP, free larray vector.\n\t(initialize_loops_parallel_p): Removed.\n\t(flow_loops_find): Push the loops into a vector.\n\t(delete_loop): New function.\n\t(cancel_loop): Use delete_loop.\n\t* cfgloop.h: Declare VEC(loop_p).\n\t(struct loop): Remove parallel_p field.\n\t(struct loops): Replace num and parray field by larray vector.\n\tRemove shared_headers field.\n\t(delete_loop): Declare.\n\t(get_loop, get_loops, number_of_loops, fel_next, fel_init,\n\tFOR_EACH_LOOP): New.\n\t* doc/loop.tex: Document new accessor functions.\n\nFrom-SVN: r119713", "tree": {"sha": "879533af06a5f9434bb047870e2878e104446c23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/879533af06a5f9434bb047870e2878e104446c23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/comments", "author": null, "committer": null, "parents": [{"sha": "7290d709efbec4d872160fa274bf2128b55432eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7290d709efbec4d872160fa274bf2128b55432eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7290d709efbec4d872160fa274bf2128b55432eb"}], "stats": {"total": 814, "additions": 396, "deletions": 418}, "files": [{"sha": "cabbcd17280614deee62ad22bb50753dd065f2c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -1,3 +1,68 @@\n+2006-12-10  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-vrp.c (adjust_range_with_scev): Use get_chrec_loop.\n+\t* loop-unswitch.c (unswitch_loops): Use FOR_EACH_LOOP.\n+\t* tree-loop-linear.c (linear_transform_loops): Ditto.\n+\t* tree-ssa-loop-im.c (determine_lsm): Ditto.\n+\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations,\n+\tfree_numbers_of_iterations_estimates): Ditto.\n+\t* tree_ssa_unswitch_loops (tree_ssa_unswitch_loops): Ditto.\n+\t* tree-ssa-loop-ch.c (copy_loop_headers): Ditto.\n+\t* tree-ssa-loop-ivopts.c (tree_ssa_iv_optimize): Ditto.\n+\t* modulo-sched.c (sms_schedule): Ditto.\n+\t* tree-ssa-loop-ivcanon.c (canonicalize_induction_variables,\n+\ttree_unroll_loops_completely): Ditto.\n+\t* predict.c (predict_loops): Ditto.\n+\t* tree-if-conv.c (main_tree_if_conversion): Ditto.\n+\t* loop-unroll.c (unroll_and_peel_loops, peel_loops_completely,\n+\tdecide_unrolling_and_peeling): Ditto.\n+\t* cfgloopmanip.c (unloop): Use delete_loop.\n+\t(place_new_loop): Access larray vector instead of parray.\n+\t(create_preheaders, force_single_succ_latches,\n+\tfix_loop_structure): Use FOR_EACH_LOOP and delete_loop..\n+\t* loop-doloop.c (doloop_optimize_loops): Ditto.\n+\t* loop-invariant.c (move_loop_invariants): Ditto.\n+\t* tree-cfg.c (replace_uses_by): Ditto.\n+\t* tree-ssa-loop-prefetch.c (tree_ssa_prefetch_arrays): Ditto.\n+\t* tree-chrec.h (CHREC_VAR, CHREC_LEFT, CHREC_RIGHT, CHREC_VARIABLE):\n+\tMoved to ...\n+\t* tree.h (CHREC_VAR, CHREC_LEFT, CHREC_RIGHT, CHREC_VARIABLE):\n+\t... here.\n+\t* tree-scalar-evolution.c (chrec_contains_symbols_defined_in_loop,\n+\tcompute_overall_effect_of_inner_loop, chrec_is_positive): Use\n+\tget_loop and get_chrec_loop.\n+\t(number_of_iterations_for_all_loops): Use number_of_loops.\n+\t(scev_initialize, scev_reset, scev_const_prop): Use FOR_EACH_LOOP.\n+\t* tree-scalar-evolution.h (get_chrec_loop): New inline function.\n+\t* cfgloopanal.c (mark_irreducible_loops): Use number_of_loops,\n+\tand FOR_EACH_LOOP.\n+\t* tree-chrec.c (evolution_function_is_invariant_rec_p,\n+\tchrec_convert_1): Use get_loop and get_chrec_loop.\n+\t* loop-init.c (loop_optimizer_init): Use number_of_loops.\n+\t(loop_optimizer_init): Use FOR_EACH_LOOP.\n+\t* tree-vectorizer.c (vect_loops_num): Removed.\n+\t(vectorize_loops): Store number of loops locally.  Use\n+\tFOR_EACH_LOOP and get_loop.\n+\t* tree-vectorizer.h (vect_loops_num): Removed.\n+\t* tree-data-ref.c (get_number_of_iters_for_loop): Use get_loop.\n+\t(find_data_references_in_loop): Do not set parallel_p.\n+\t* tree-data-ref.h: Do not declare VEC(loop_p).\n+\t* cfgloop.c (flow_loops_dump, mark_single_exit_loops,\n+\tverify_loop_structure): Use FOR_EACH_LOOP.\n+\t(flow_loops_free): Use FOR_EACH_LOOP, free larray vector.\n+\t(initialize_loops_parallel_p): Removed.\n+\t(flow_loops_find): Push the loops into a vector.\n+\t(delete_loop): New function.\n+\t(cancel_loop): Use delete_loop.\n+\t* cfgloop.h: Declare VEC(loop_p).\n+\t(struct loop): Remove parallel_p field.\n+\t(struct loops): Replace num and parray field by larray vector.\n+\tRemove shared_headers field.\n+\t(delete_loop): Declare.\n+\t(get_loop, get_loops, number_of_loops, fel_next, fel_init,\n+\tFOR_EACH_LOOP): New.\n+\t* doc/loop.tex: Document new accessor functions.\n+\n 2006-12-10  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* common.opt (-ftree-lrs): Remove live range splitting option."}, {"sha": "52e1ab0c6a2ce3d13448531980c219de18e30530", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 57, "deletions": 88, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -128,20 +128,16 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n void\n flow_loops_dump (FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *, int), int verbose)\n {\n-  unsigned i;\n+  loop_iterator li;\n+  struct loop *loop;\n \n   if (!current_loops || ! file)\n     return;\n \n-  fprintf (file, \";; %d loops found\\n\", current_loops->num);\n+  fprintf (file, \";; %d loops found\\n\", number_of_loops ());\n \n-  for (i = 0; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, LI_INCLUDE_ROOT)\n     {\n-      struct loop *loop = current_loops->parray[i];\n-\n-      if (!loop)\n-\tcontinue;\n-\n       flow_loop_dump (loop, file, loop_dump_aux, verbose);\n     }\n \n@@ -163,25 +159,22 @@ flow_loop_free (struct loop *loop)\n void\n flow_loops_free (struct loops *loops)\n {\n-  if (loops->parray)\n+  if (loops->larray)\n     {\n       unsigned i;\n-\n-      gcc_assert (loops->num);\n+      loop_p loop;\n \n       /* Free the loop descriptors.  */\n-      for (i = 0; i < loops->num; i++)\n+      for (i = 0; VEC_iterate (loop_p, loops->larray, i, loop); i++)\n \t{\n-\t  struct loop *loop = loops->parray[i];\n-\n \t  if (!loop)\n \t    continue;\n \n \t  flow_loop_free (loop);\n \t}\n \n-      free (loops->parray);\n-      loops->parray = NULL;\n+      VEC_free (loop_p, heap, loops->larray);\n+      loops->larray = NULL;\n     }\n }\n \n@@ -242,13 +235,11 @@ mark_single_exit_loops (void)\n   basic_block bb;\n   edge e;\n   struct loop *loop;\n-  unsigned i;\n+  loop_iterator li;\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (loop)\n-\tset_single_exit (loop, NULL);\n+      set_single_exit (loop, NULL);\n     }\n \n   FOR_EACH_BB (bb)\n@@ -278,12 +269,8 @@ mark_single_exit_loops (void)\n \t}\n     }\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n       if (single_exit (loop) == single_succ_edge (ENTRY_BLOCK_PTR))\n \tset_single_exit (loop, NULL);\n     }\n@@ -499,20 +486,6 @@ canonicalize_loop_headers (void)\n #endif\n }\n \n-/* Initialize all the parallel_p fields of the loops structure to true.  */\n-\n-static void\n-initialize_loops_parallel_p (struct loops *loops)\n-{\n-  unsigned int i;\n-\n-  for (i = 0; i < loops->num; i++)\n-    {\n-      struct loop *loop = loops->parray[i];\n-      loop->parallel_p = true;\n-    }\n-}\n-\n /* Find all the natural loops in the function and save in LOOPS structure and\n    recalculate loop_depth information in basic block structures.\n    Return the number of natural loops found.  */\n@@ -528,6 +501,7 @@ flow_loops_find (struct loops *loops)\n   int *rc_order;\n   basic_block header;\n   basic_block bb;\n+  struct loop *root;\n \n   memset (loops, 0, sizeof *loops);\n \n@@ -594,26 +568,21 @@ flow_loops_find (struct loops *loops)\n     }\n \n   /* Allocate loop structures.  */\n-  loops->parray = XCNEWVEC (struct loop *, num_loops + 1);\n+  loops->larray = VEC_alloc (loop_p, heap, num_loops + 1);\n \n   /* Dummy loop containing whole function.  */\n-  loops->parray[0] = XCNEW (struct loop);\n-  loops->parray[0]->next = NULL;\n-  loops->parray[0]->inner = NULL;\n-  loops->parray[0]->outer = NULL;\n-  loops->parray[0]->depth = 0;\n-  loops->parray[0]->pred = NULL;\n-  loops->parray[0]->num_nodes = n_basic_blocks;\n-  loops->parray[0]->latch = EXIT_BLOCK_PTR;\n-  loops->parray[0]->header = ENTRY_BLOCK_PTR;\n-  ENTRY_BLOCK_PTR->loop_father = loops->parray[0];\n-  EXIT_BLOCK_PTR->loop_father = loops->parray[0];\n-\n-  loops->tree_root = loops->parray[0];\n+  root = XCNEW (struct loop);\n+  root->num_nodes = n_basic_blocks;\n+  root->latch = EXIT_BLOCK_PTR;\n+  root->header = ENTRY_BLOCK_PTR;\n+  ENTRY_BLOCK_PTR->loop_father = root;\n+  EXIT_BLOCK_PTR->loop_father = root;\n+\n+  VEC_quick_push (loop_p, loops->larray, root);\n+  loops->tree_root = root;\n \n   /* Find and record information about all the natural loops\n      in the CFG.  */\n-  loops->num = 1;\n   FOR_EACH_BB (bb)\n     bb->loop_father = loops->tree_root;\n \n@@ -639,7 +608,8 @@ flow_loops_find (struct loops *loops)\n \n \t  header = BASIC_BLOCK (rc_order[b]);\n \n-\t  loop = loops->parray[num_loops] = XCNEW (struct loop);\n+\t  loop = XCNEW (struct loop);\n+\t  VEC_quick_push (loop_p, loops->larray, loop);\n \n \t  loop->header = header;\n \t  loop->num = num_loops;\n@@ -662,17 +632,14 @@ flow_loops_find (struct loops *loops)\n \t  loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n \t}\n \n-      loops->num = num_loops;\n-      initialize_loops_parallel_p (loops);\n-\n       free (dfs_order);\n       free (rc_order);\n     }\n \n   sbitmap_free (headers);\n \n   loops->state = 0;\n-  return loops->num;\n+  return VEC_length (loop_p, loops->larray);\n }\n \n /* Return nonzero if basic block BB belongs to LOOP.  */\n@@ -924,6 +891,21 @@ find_common_loop (struct loop *loop_s, struct loop *loop_d)\n   return loop_s;\n }\n \n+/* Removes LOOP from structures and frees its data.  */\n+\n+void\n+delete_loop (struct loop *loop)\n+{\n+  /* Remove the loop from structure.  */\n+  flow_loop_tree_node_remove (loop);\n+\n+  /* Remove loop from loops array.  */\n+  VEC_replace (loop_p, current_loops->larray, loop->num, NULL);\n+\n+  /* Free loop data.  */\n+  flow_loop_free (loop);\n+}\n+\n /* Cancels the LOOP; it must be innermost one.  */\n \n static void\n@@ -939,14 +921,7 @@ cancel_loop (struct loop *loop)\n   for (i = 0; i < loop->num_nodes; i++)\n     bbs[i]->loop_father = loop->outer;\n \n-  /* Remove the loop from structure.  */\n-  flow_loop_tree_node_remove (loop);\n-\n-  /* Remove loop from loops array.  */\n-  current_loops->parray[loop->num] = NULL;\n-\n-  /* Free loop data.  */\n-  flow_loop_free (loop);\n+  delete_loop (loop);\n }\n \n /* Cancels LOOP and all its subloops.  */\n@@ -974,52 +949,48 @@ verify_loop_structure (void)\n   struct loop *loop;\n   int err = 0;\n   edge e;\n+  unsigned num = number_of_loops ();\n+  loop_iterator li;\n \n   /* Check sizes.  */\n-  sizes = XCNEWVEC (unsigned, current_loops->num);\n+  sizes = XCNEWVEC (unsigned, num);\n   sizes[0] = 2;\n \n   FOR_EACH_BB (bb)\n     for (loop = bb->loop_father; loop; loop = loop->outer)\n       sizes[loop->num]++;\n \n-  for (i = 0; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, LI_INCLUDE_ROOT)\n     {\n-      if (!current_loops->parray[i])\n-\tcontinue;\n+      i = loop->num;\n \n-      if (current_loops->parray[i]->num_nodes != sizes[i])\n+      if (loop->num_nodes != sizes[i])\n \t{\n \t  error (\"size of loop %d should be %d, not %d\",\n-\t\t   i, sizes[i], current_loops->parray[i]->num_nodes);\n+\t\t   i, sizes[i], loop->num_nodes);\n \t  err = 1;\n \t}\n     }\n \n   /* Check get_loop_body.  */\n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n       bbs = get_loop_body (loop);\n \n       for (j = 0; j < loop->num_nodes; j++)\n \tif (!flow_bb_inside_loop_p (loop, bbs[j]))\n \t  {\n \t    error (\"bb %d do not belong to loop %d\",\n-\t\t    bbs[j]->index, i);\n+\t\t    bbs[j]->index, loop->num);\n \t    err = 1;\n \t  }\n       free (bbs);\n     }\n \n   /* Check headers and latches.  */\n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n+      i = loop->num;\n \n       if ((current_loops->state & LOOPS_HAVE_PREHEADERS)\n \t  && EDGE_COUNT (loop->header->preds) != 2)\n@@ -1120,7 +1091,7 @@ verify_loop_structure (void)\n   /* Check the single_exit.  */\n   if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n     {\n-      memset (sizes, 0, sizeof (unsigned) * current_loops->num);\n+      memset (sizes, 0, sizeof (unsigned) * num);\n       FOR_EACH_BB (bb)\n \t{\n \t  edge_iterator ei;\n@@ -1154,11 +1125,9 @@ verify_loop_structure (void)\n \t    }\n \t}\n \n-      for (i = 1; i < current_loops->num; i++)\n+      FOR_EACH_LOOP (li, loop, 0)\n \t{\n-\t  loop = current_loops->parray[i];\n-\t  if (!loop)\n-\t    continue;\n+\t  i = loop->num;\n \n \t  if (sizes[i] == 1\n \t      && !single_exit (loop))"}, {"sha": "d523acf001cc24ff91bba3f4221d736ba4492640", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 125, "deletions": 17, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -146,12 +146,6 @@ struct loop\n      EXIT_BLOCK_PTR do not count.  Do not use directly; this field should\n      only be accessed via single_exit/set_single_exit functions.  */\n   edge single_exit_;\n-\n-  /* True when the loop does not carry data dependences, and\n-     consequently the iterations can be executed in any order.  False\n-     when the loop carries data dependences, or when the property is\n-     not decidable.  */\n-  bool parallel_p;\n };\n \n /* Flags for state of loop structure.  */\n@@ -166,26 +160,21 @@ enum\n #define LOOPS_NORMAL (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES \\\n \t\t      | LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n \n+typedef struct loop *loop_p;\n+DEF_VEC_P (loop_p);\n+DEF_VEC_ALLOC_P (loop_p, heap);\n+\n /* Structure to hold CFG information about natural loops within a function.  */\n struct loops\n {\n-  /* Number of natural loops in the function.  */\n-  unsigned num;\n-\n   /* State of loops.  */\n   int state;\n \n-  /* We store just pointers to loops here.  \n-     Note that a loop in this array may actually be NULL, if the loop\n-     has been removed and the entire loops structure has not been\n-     recomputed since that time.  */\n-  struct loop **parray;\n+  /* Array of the loops.  */\n+  VEC (loop_p, heap) *larray;\n \n   /* Pointer to root of loop hierarchy tree.  */\n   struct loop *tree_root;\n-\n-  /* Headers shared by multiple loops that should be merged.  */\n-  sbitmap shared_headers;\n };\n \n /* Loop recognition.  */\n@@ -231,6 +220,7 @@ extern void add_bb_to_loop (basic_block, struct loop *);\n extern void remove_bb_from_loops (basic_block);\n \n extern void cancel_loop_tree (struct loop *);\n+extern void delete_loop (struct loop *);\n \n extern int fix_loop_placement (struct loop *);\n \n@@ -375,6 +365,124 @@ simple_loop_desc (struct loop *loop)\n   return (struct niter_desc *) loop->aux;\n }\n \n+/* Accessors for the loop structures.  */\n+\n+/* Returns the loop with index NUM from current_loops.  */\n+\n+static inline struct loop *\n+get_loop (unsigned num)\n+{\n+  return VEC_index (loop_p, current_loops->larray, num);\n+}\n+\n+/* Returns the list of loops in current_loops.  */\n+\n+static inline VEC (loop_p, heap) *\n+get_loops (void)\n+{\n+  if (!current_loops)\n+    return NULL;\n+\n+  return current_loops->larray;\n+}\n+\n+/* Returns the number of loops in current_loops (including the removed\n+   ones and the fake loop that forms the root of the loop tree).  */\n+\n+static inline unsigned\n+number_of_loops (void)\n+{\n+  if (!current_loops)\n+    return 0;\n+\n+  return VEC_length (loop_p, current_loops->larray);\n+}\n+\n+/* Loop iterators.  */\n+\n+/* Flags for loop iteration.  */\n+\n+enum li_flags\n+{\n+  LI_INCLUDE_ROOT,\t/* Include the fake root of the loop tree.  */\n+  LI_FROM_INNERMOST,\t/* Iterate over the loops in the reverse order,\n+\t\t\t   starting from innermost ones.  */\n+  LI_ONLY_INNERMOST,\t/* Iterate only over innermost loops.  */\n+  LI_ONLY_OLD\t\t/* Do not traverse the loops created during the\n+\t\t\t   traversal (this is the default behavior with\n+\t\t\t   LI_FROM_INNERMOST).  */\n+};\n+\n+/* The iterator for loops.  */\n+\n+typedef struct\n+{\n+  int idx;\t\t/* Index of the actual loop.  */\n+  int end;\t\t/* Only loops before end should be traversed.  */\n+} loop_iterator;\n+\n+static inline void\n+fel_next (loop_iterator *li, loop_p *loop, unsigned flags)\n+{\n+  if (flags & LI_FROM_INNERMOST)\n+    {\n+      li->idx--;\n+      for (; li->idx > li->end; li->idx--)\n+\t{\n+\t  *loop = VEC_index (loop_p, current_loops->larray, li->idx);\n+\t  if (*loop\n+\t      && (!(flags & LI_ONLY_INNERMOST)\n+\t\t  || (*loop)->inner == NULL))\n+\t    return;\n+\t}\n+    }\n+  else\n+    {\n+      if (!(flags & LI_ONLY_OLD))\n+\tli->end = number_of_loops ();\n+      li->idx++;\n+      for (; li->idx < li->end; li->idx++)\n+\t{\n+\t  *loop = VEC_index (loop_p, current_loops->larray, li->idx);\n+\t  if (*loop\n+\t      && (!(flags & LI_ONLY_INNERMOST)\n+\t\t  || (*loop)->inner == NULL))\n+\t    return;\n+\t}\n+    }\n+\n+  *loop = NULL;\n+}\n+\n+static inline void\n+fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n+{\n+  if (!current_loops)\n+    {\n+      li->idx = 0;\n+      li->end = 0;\n+      *loop = NULL;\n+      return;\n+    }\n+\n+  if (flags & LI_FROM_INNERMOST)\n+    {\n+      li->idx = number_of_loops ();\n+      li->end = (flags & LI_INCLUDE_ROOT) ? -1 : 0;\n+    }\n+  else\n+    {\n+      li->idx = (flags & LI_INCLUDE_ROOT) ? -1 : 0;\n+      li->end = number_of_loops ();\n+    }\n+  fel_next (li, loop, flags);\n+}\n+\n+#define FOR_EACH_LOOP(LI, LOOP, FLAGS) \\\n+  for (fel_init (&(LI), &(LOOP), FLAGS); \\\n+       (LOOP); \\\n+       fel_next (&(LI), &(LOOP), FLAGS))\n+\n /* The properties of the target.  */\n \n extern unsigned target_avail_regs;\t/* Number of available registers.  */"}, {"sha": "5a9189787eae1727a0eac86b7e49dc5a23cdeda0", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -273,11 +273,12 @@ mark_irreducible_loops (void)\n   edge_iterator ei;\n   int i, src, dest;\n   struct graph *g;\n-  int num = current_loops ? current_loops->num : 1;\n+  int num = current_loops ? number_of_loops () : 1;\n   int *queue1 = XNEWVEC (int, last_basic_block + num);\n   int *queue2 = XNEWVEC (int, last_basic_block + num);\n   int nq, depth;\n-  struct loop *cloop;\n+  struct loop *cloop, *loop;\n+  loop_iterator li;\n \n   /* Reset the flags.  */\n   FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n@@ -343,9 +344,14 @@ mark_irreducible_loops (void)\n     {\n       queue1[nq++] = BB_REPR (act);\n     }\n-  for (i = 1; i < num; i++)\n-    if (current_loops->parray[i])\n-      queue1[nq++] = LOOP_REPR (current_loops->parray[i]);\n+\n+  if (current_loops)\n+    {\n+      FOR_EACH_LOOP (li, loop, 0)\n+\t{\n+\t  queue1[nq++] = LOOP_REPR (loop);\n+\t}\n+    }\n   dfs (g, queue1, nq, queue2, false);\n   for (i = 0; i < nq; i++)\n     queue1[i] = queue2[nq - i - 1];"}, {"sha": "83d4e4c0e135e8df45a8f5c184535a80b132068e", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -552,9 +552,7 @@ unloop (struct loop *loop, bool *irred_invalidated)\n     }\n \n   /* Remove the loop and free its data.  */\n-  flow_loop_tree_node_remove (loop);\n-  current_loops->parray[loop->num] = NULL;\n-  flow_loop_free (loop);\n+  delete_loop (loop);\n \n   remove_edge (single_succ_edge (latch));\n \n@@ -634,11 +632,8 @@ fix_loop_placements (struct loop *loop, bool *irred_invalidated)\n static void\n place_new_loop (struct loop *loop)\n {\n-  current_loops->parray =\n-    xrealloc (current_loops->parray, (current_loops->num + 1) * sizeof (struct loop *));\n-  current_loops->parray[current_loops->num] = loop;\n-\n-  loop->num = current_loops->num++;\n+  loop->num = number_of_loops ();\n+  VEC_safe_push (loop_p, heap, current_loops->larray, loop);\n }\n \n /* Copies copy of LOOP as subloop of TARGET loop, placing newly\n@@ -1195,9 +1190,11 @@ create_preheader (struct loop *loop, int flags)\n void\n create_preheaders (int flags)\n {\n-  unsigned i;\n-  for (i = 1; i < current_loops->num; i++)\n-    create_preheader (current_loops->parray[i], flags);\n+  loop_iterator li;\n+  struct loop *loop;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    create_preheader (loop, flags);\n   current_loops->state |= LOOPS_HAVE_PREHEADERS;\n }\n \n@@ -1206,13 +1203,12 @@ create_preheaders (int flags)\n void\n force_single_succ_latches (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n   edge e;\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n       if (loop->latch != loop->header && single_succ_p (loop->latch))\n \tcontinue;\n \n@@ -1392,7 +1388,7 @@ fix_loop_structure (bitmap changed_bbs)\n {\n   basic_block bb;\n   struct loop *loop, *ploop;\n-  unsigned i;\n+  loop_iterator li;\n \n   /* Remove the old bb -> loop mapping.  */\n   FOR_EACH_BB (bb)\n@@ -1403,12 +1399,8 @@ fix_loop_structure (bitmap changed_bbs)\n \n   /* Remove the dead loops from structures.  */\n   current_loops->tree_root->num_nodes = n_basic_blocks;\n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n       loop->num_nodes = 0;\n       if (loop->header)\n \tcontinue;\n@@ -1421,38 +1413,18 @@ fix_loop_structure (bitmap changed_bbs)\n \t}\n \n       /* Remove the loop and free its data.  */\n-      flow_loop_tree_node_remove (loop);\n-      current_loops->parray[loop->num] = NULL;\n-      flow_loop_free (loop);\n+      delete_loop (loop);\n     }\n \n   /* Rescan the bodies of loops, starting from the outermost.  */\n-  loop = current_loops->tree_root;\n-  while (1)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      if (loop->inner)\n-\tloop = loop->inner;\n-      else\n-\t{\n-\t  while (!loop->next\n-\t\t && loop != current_loops->tree_root)\n-\t    loop = loop->outer;\n-\t  if (loop == current_loops->tree_root)\n-\t    break;\n-\n-\t  loop = loop->next;\n-\t}\n-\n       loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n     }\n \n   /* Now fix the loop nesting.  */\n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n       bb = loop_preheader_edge (loop)->src;\n       if (bb->loop_father != loop->outer)\n \t{"}, {"sha": "354241f14c70d220545cf0ec8e6489eec15382af", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -63,20 +63,25 @@ The root of this tree is a fake loop that contains all blocks in the\n function.  Each of the loops is represented in a @code{struct loop}\n structure.  Each loop is assigned an index (@code{num} field of the\n @code{struct loop} structure), and the pointer to the loop is stored in\n-the corresponding field of the @code{parray} field of the loops\n+the corresponding field of the @code{larray} vector in the loops\n structure.  Index of a sub-loop is always greater than the index of its\n super-loop.  The indices do not have to be continuous, there may be\n-empty (@code{NULL}) entries in the @code{parray} created by deleting\n-loops.  The index of a loop never changes.  The first unused index is\n-stored in the @code{num} field of the loops structure.\n+empty (@code{NULL}) entries in the @code{larray} created by deleting\n+loops.  The index of a loop never changes.\n+\n+The entries of the @code{larray} field should not be accessed directly.\n+The function @code{get_loop} returns the loop description for a loop with\n+the given index.  @code{number_of_loops} function returns number of\n+loops in the function.  To traverse all loops, use @code{FOR_EACH_LOOP}\n+macro.  The @code{flags} argument of the macro is used to determine\n+the direction of traversal and the set of loops visited.\n \n Each basic block contains the reference to the innermost loop it belongs\n to (@code{loop_father}).  For this reason, it is only possible to have\n one @code{struct loops} structure initialized at the same time for each\n-CFG.  It is recommended to use the global variable @code{current_loops}\n-to contain the @code{struct loops} structure, especially if the loop\n-structures are updated throughout several passes.  Many of the loop\n-manipulation functions assume that dominance information is up-to-date.\n+CFG.  The global variable @code{current_loops} contains the\n+@code{struct loops} structure.  Many of the loop manipulation functions\n+assume that dominance information is up-to-date.\n \n The loops are analyzed through @code{loop_optimizer_init} function.  The\n argument of this function is a set of flags represented in an integer"}, {"sha": "ef42c609198cabe29f76cc85d8f97ea0c6832916", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -621,15 +621,11 @@ doloop_optimize (struct loop *loop)\n void\n doloop_optimize_loops (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n       doloop_optimize (loop);\n     }\n "}, {"sha": "32e56b32a6ae69c26262ffd165a6e07d2f9df436", "filename": "gcc/loop-init.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -68,9 +68,10 @@ loop_optimizer_init (unsigned flags)\n   flow_loops_find (loops);\n   current_loops = loops;\n \n-  if (current_loops->num <= 1)\n+  if (number_of_loops () <= 1)\n     {\n-      /* No loops.  */\n+      /* No loops (the 1 returned by number_of_loops corresponds to the fake\n+\t loop that we put as a root of the loop tree).  */\n       loop_optimizer_finalize ();\n       return;\n     }\n@@ -104,15 +105,17 @@ loop_optimizer_init (unsigned flags)\n void\n loop_optimizer_finalize (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n+  struct loop *loop;\n   basic_block bb;\n \n   if (!current_loops)\n     return;\n \n-  for (i = 1; i < current_loops->num; i++)\n-    if (current_loops->parray[i])\n-      free_simple_loop_desc (current_loops->parray[i]);\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      free_simple_loop_desc (loop);\n+    }\n \n   /* Clean up.  */\n   flow_loops_free (current_loops);"}, {"sha": "4c6e8bc9f9c2d0ee87a17315e04053a142bd4930", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -1318,33 +1318,21 @@ void\n move_loop_invariants (void)\n {\n   struct loop *loop;\n-  unsigned i;\n+  loop_iterator li;\n \n   df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES);\n   df_chain_add_problem (df, DF_UD_CHAIN);\n  \n   /* Process the loops, innermost first.  */\n-  loop = current_loops->tree_root;\n-  while (loop->inner)\n-    loop = loop->inner;\n-\n-  while (loop != current_loops->tree_root)\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       move_single_loop_invariants (loop);\n-\n-      if (loop->next)\n-\t{\n-\t  loop = loop->next;\n-\t  while (loop->inner)\n-\t    loop = loop->inner;\n-\t}\n-      else\n-\tloop = loop->outer;\n     }\n \n-  for (i = 1; i < current_loops->num; i++)\n-    if (current_loops->parray[i])\n-      free_loop_data (current_loops->parray[i]);\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      free_loop_data (loop);\n+    }\n \n   df_finish (df);\n   df = NULL;"}, {"sha": "3a79dcca94337c52d916def2da02b77715c6b343", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -144,8 +144,9 @@ static rtx get_expansion (struct var_to_expand *);\n void\n unroll_and_peel_loops (int flags)\n {\n-  struct loop *loop, *next;\n+  struct loop *loop;\n   bool check;\n+  loop_iterator li;\n \n   /* First perform complete loop peeling (it is almost surely a win,\n      and affects parameters for further decision a lot).  */\n@@ -154,22 +155,9 @@ unroll_and_peel_loops (int flags)\n   /* Now decide rest of unrolling and peeling.  */\n   decide_unrolling_and_peeling (flags);\n \n-  loop = current_loops->tree_root;\n-  while (loop->inner)\n-    loop = loop->inner;\n-\n   /* Scan the loops, inner ones first.  */\n-  while (loop != current_loops->tree_root)\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n-      if (loop->next)\n-\t{\n-\t  next = loop->next;\n-\t  while (next->inner)\n-\t    next = next->inner;\n-\t}\n-      else\n-\tnext = loop->outer;\n-\n       check = true;\n       /* And perform the appropriate transformations.  */\n       switch (loop->lpt_decision.decision)\n@@ -202,7 +190,6 @@ unroll_and_peel_loops (int flags)\n \t  verify_loop_structure ();\n #endif\n \t}\n-      loop = next;\n     }\n \n   iv_analysis_done ();\n@@ -234,15 +221,11 @@ static void\n peel_loops_completely (int flags)\n {\n   struct loop *loop;\n-  unsigned i;\n+  loop_iterator li;\n \n   /* Scan the loops, the inner ones first.  */\n-  for (i = current_loops->num - 1; i > 0; i--)\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n       loop->lpt_decision.decision = LPT_NONE;\n \n       if (dump_file)\n@@ -271,23 +254,12 @@ peel_loops_completely (int flags)\n static void\n decide_unrolling_and_peeling (int flags)\n {\n-  struct loop *loop = current_loops->tree_root, *next;\n-\n-  while (loop->inner)\n-    loop = loop->inner;\n+  struct loop *loop;\n+  loop_iterator li;\n \n   /* Scan the loops, inner ones first.  */\n-  while (loop != current_loops->tree_root)\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n-      if (loop->next)\n-\t{\n-\t  next = loop->next;\n-\t  while (next->inner)\n-\t    next = next->inner;\n-\t}\n-      else\n-\tnext = loop->outer;\n-\n       loop->lpt_decision.decision = LPT_NONE;\n \n       if (dump_file)\n@@ -298,7 +270,6 @@ decide_unrolling_and_peeling (int flags)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \";; Not considering loop, cold area\\n\");\n-\t  loop = next;\n \t  continue;\n \t}\n \n@@ -308,7 +279,6 @@ decide_unrolling_and_peeling (int flags)\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \";; Not considering loop, cannot duplicate\\n\");\n-\t  loop = next;\n \t  continue;\n \t}\n \n@@ -317,7 +287,6 @@ decide_unrolling_and_peeling (int flags)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \";; Not considering loop, is not innermost\\n\");\n-\t  loop = next;\n \t  continue;\n \t}\n \n@@ -334,8 +303,6 @@ decide_unrolling_and_peeling (int flags)\n \tdecide_unroll_stupid (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n \tdecide_peel_simple (loop, flags);\n-\n-      loop = next;\n     }\n }\n "}, {"sha": "82cf1eaeeebebf1bd82a6c533db4166a1c4d2613", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -138,22 +138,13 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n void\n unswitch_loops (void)\n {\n-  int i, num;\n+  loop_iterator li;\n   struct loop *loop;\n \n   /* Go through inner loops (only original ones).  */\n-  num = current_loops->num;\n \n-  for (i = 1; i < num; i++)\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD | LI_ONLY_INNERMOST)\n     {\n-      /* Removed loop?  */\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n-      if (loop->inner)\n-\tcontinue;\n-\n       unswitch_single_loop (loop, NULL_RTX, 0);\n #ifdef ENABLE_CHECKING\n       verify_dominators (CDI_DOMINATORS);"}, {"sha": "3352e20adcdf852c5e9c92b3a8cd7780bc596579", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -878,12 +878,11 @@ sms_schedule (void)\n   ddg_ptr *g_arr, g;\n   int * node_order;\n   int maxii;\n-  unsigned i,num_loops;\n+  loop_iterator li;\n   partial_schedule_ptr ps;\n   struct df *df;\n   basic_block bb = NULL;\n-  /* vars to the versioning only if needed*/\n-  struct loop * nloop;\n+  struct loop *loop, *nloop;\n   basic_block condition_bb = NULL;\n   edge latch_edge;\n   gcov_type trip_count = 0;\n@@ -921,16 +920,14 @@ sms_schedule (void)\n \n   /* Allocate memory to hold the DDG array one entry for each loop.\n      We use loop->num as index into this array.  */\n-  g_arr = XCNEWVEC (ddg_ptr, current_loops->num);\n-\n+  g_arr = XCNEWVEC (ddg_ptr, number_of_loops ());\n \n   /* Build DDGs for all the relevant loops and hold them in G_ARR\n      indexed by the loop index.  */\n-  for (i = 0; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n       rtx head, tail;\n       rtx count_reg;\n-      struct loop *loop = current_loops->parray[i];\n \n       /* For debugging.  */\n       if ((passes++ > MAX_SMS_LOOP_NUMBER) && (MAX_SMS_LOOP_NUMBER != -1))\n@@ -1019,26 +1016,23 @@ sms_schedule (void)\n \t  continue;\n         }\n \n-      g_arr[i] = g;\n+      g_arr[loop->num] = g;\n     }\n \n   /* Release Data Flow analysis data structures.  */\n   df_finish (df);\n   df = NULL;\n \n   /* We don't want to perform SMS on new loops - created by versioning.  */\n-  num_loops = current_loops->num;\n-  /* Go over the built DDGs and perfrom SMS for each one of them.  */\n-  for (i = 0; i < num_loops; i++)\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD)\n     {\n       rtx head, tail;\n       rtx count_reg, count_init;\n       int mii, rec_mii;\n       unsigned stage_count = 0;\n       HOST_WIDEST_INT loop_count = 0;\n-      struct loop *loop = current_loops->parray[i];\n \n-      if (! (g = g_arr[i]))\n+      if (! (g = g_arr[loop->num]))\n         continue;\n \n       if (dump_file)"}, {"sha": "534258f39ce1cd25be87388eff1d22387e386c3e", "filename": "gcc/predict.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -630,17 +630,17 @@ combine_predictions_for_bb (basic_block bb)\n static void\n predict_loops (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n+  struct loop *loop;\n \n   scev_initialize ();\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n       basic_block bb, *bbs;\n       unsigned j, n_exits;\n-      struct loop *loop = current_loops->parray[i];\n       VEC (edge, heap) *exits;\n       struct tree_niter_desc niter_desc;\n       edge ex;"}, {"sha": "59a32ea6fff67d1bc7e61833e8a8b1c6de5bbf67", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -1245,7 +1245,6 @@ replace_uses_by (tree name, tree val)\n   use_operand_p use;\n   tree stmt;\n   edge e;\n-  unsigned i;\n \n   FOR_EACH_IMM_USE_STMT (stmt, imm_iter, name)\n     {\n@@ -1286,12 +1285,11 @@ replace_uses_by (tree name, tree val)\n   if (current_loops)\n     {\n       struct loop *loop;\n+      loop_iterator li;\n \n-      for (i = 0; i < current_loops->num; i++)\n+      FOR_EACH_LOOP (li, loop, 0)\n \t{\n-\t  loop = current_loops->parray[i];\n-\t  if (loop)\n-\t    substitute_in_loop_info (loop, name, val);\n+\t  substitute_in_loop_info (loop, name, val);\n \t}\n     }\n }"}, {"sha": "01d0bf9217ae3cd648fc94d6ff627f05c409a5b9", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -939,8 +939,7 @@ evolution_function_is_invariant_rec_p (tree chrec, int loopnum)\n     return true;\n \n   if (TREE_CODE (chrec) == SSA_NAME \n-      && expr_invariant_in_loop_p (current_loops->parray[loopnum],\n-\t\t\t\t   chrec))\n+      && expr_invariant_in_loop_p (get_loop (loopnum), chrec))\n     return true;\n \n   if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n@@ -1280,7 +1279,7 @@ chrec_convert_1 (tree type, tree chrec, tree at_stmt,\n   if (!evolution_function_is_affine_p (chrec))\n     goto keep_cast;\n \n-  loop = current_loops->parray[CHREC_VARIABLE (chrec)];\n+  loop = get_chrec_loop (chrec);\n   base = CHREC_LEFT (chrec);\n   step = CHREC_RIGHT (chrec);\n "}, {"sha": "c22867ba0d2c29c505e940994d00a928827f38c7", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -22,14 +22,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #ifndef GCC_TREE_CHREC_H\n #define GCC_TREE_CHREC_H\n \n-/* Accessors for the chains of recurrences.  */\n-#define CHREC_VAR(NODE)           TREE_OPERAND (NODE, 0)\n-#define CHREC_LEFT(NODE)          TREE_OPERAND (NODE, 1)\n-#define CHREC_RIGHT(NODE)         TREE_OPERAND (NODE, 2)\n-#define CHREC_VARIABLE(NODE)      TREE_INT_CST_LOW (CHREC_VAR (NODE))\n-\n-\f\n-\n /* The following trees are unique elements.  Thus the comparison of another \n    element to these elements should be done on the pointer to these trees, \n    and not on their value.  */"}, {"sha": "96d57a06e735450ca7fc272159e585dfee5ab8f9", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -2304,7 +2304,7 @@ analyze_ziv_subscript (tree chrec_a,\n static tree\n get_number_of_iters_for_loop (int loopnum)\n {\n-  struct loop *loop = current_loops->parray[loopnum];\n+  struct loop *loop = get_loop (loopnum);\n   tree numiter = number_of_iterations_in_loop (loop);\n \n   if (TREE_CODE (numiter) == INTEGER_CST)\n@@ -4109,7 +4109,6 @@ find_data_references_in_loop (struct loop *loop,\n   block_stmt_iterator bsi;\n \n   bbs = get_loop_body (loop);\n-  loop->parallel_p = true;\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -4137,16 +4136,11 @@ find_data_references_in_loop (struct loop *loop,\n \t      DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n \t      DR_MEMTAG (res) = NULL_TREE;\n \t      DR_PTR_INFO (res) = NULL;\n-\t      loop->parallel_p = false;\n \t      VEC_safe_push (data_reference_p, heap, *datarefs, res);\n \n \t      free (bbs);\n \t      return chrec_dont_know;\n \t    }\n-\n-\t  /* When there are no defs in the loop, the loop is parallel.  */\n-\t  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n-\t    loop->parallel_p = false;\n \t}\n     }\n   free (bbs);"}, {"sha": "8c6ee416d328c3891afabd3a3a75b5c04b901afc", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -224,10 +224,6 @@ DEF_VEC_ALLOC_P (subscript_p, heap);\n #define SUB_LAST_CONFLICT(SUB) SUB->last_conflict\n #define SUB_DISTANCE(SUB) SUB->distance\n \n-typedef struct loop *loop_p;\n-DEF_VEC_P(loop_p);\n-DEF_VEC_ALLOC_P (loop_p, heap);\n-\n /* A data_dependence_relation represents a relation between two\n    data_references A and B.  */\n "}, {"sha": "e97824f5185ceef5c51908241ad5cd63eccbe646", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -1092,19 +1092,14 @@ bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n static unsigned int\n main_tree_if_conversion (void)\n {\n-  unsigned i, loop_num;\n+  loop_iterator li;\n   struct loop *loop;\n \n   if (!current_loops)\n     return 0;\n \n-  loop_num = current_loops->num;\n-  for (i = 0; i < loop_num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop =  current_loops->parray[i];\n-      if (!loop)\n-      continue;\n-\n       tree_if_conversion (loop, true);\n     }\n   return 0;"}, {"sha": "61fdee3f0681f79a049b9c5825b18e726207efd3", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -242,16 +242,16 @@ void\n linear_transform_loops (void)\n {\n   bool modified = false;\n-  unsigned int i;\n+  loop_iterator li;\n   VEC(tree,heap) *oldivs = NULL;\n   VEC(tree,heap) *invariants = NULL;\n+  struct loop *loop_nest;\n   \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop_nest, 0)\n     {\n       unsigned int depth = 0;\n       VEC (ddr_p, heap) *dependence_relations;\n       VEC (data_reference_p, heap) *datarefs;\n-      struct loop *loop_nest = current_loops->parray[i];\n       struct loop *temp;\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n@@ -270,7 +270,7 @@ linear_transform_loops (void)\n                 ...\n                }\n            } */\n-      if (!loop_nest || !loop_nest->inner || !single_exit (loop_nest))\n+      if (!loop_nest->inner || !single_exit (loop_nest))\n \tcontinue;\n       VEC_truncate (tree, oldivs, 0);\n       VEC_truncate (tree, invariants, 0);"}, {"sha": "c668bf22ddfaf68c0146f6ade7340f287f8f015a", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -375,7 +375,7 @@ chrec_contains_symbols_defined_in_loop (tree chrec, unsigned loop_nb)\n     {\n       tree def = SSA_NAME_DEF_STMT (chrec);\n       struct loop *def_loop = loop_containing_stmt (def);\n-      struct loop *loop = current_loops->parray[loop_nb];\n+      struct loop *loop = get_loop (loop_nb);\n \n       if (def_loop == NULL)\n \treturn false;\n@@ -467,8 +467,7 @@ compute_overall_effect_of_inner_loop (struct loop *loop, tree evolution_fn)\n     {\n       if (CHREC_VARIABLE (evolution_fn) >= (unsigned) loop->num)\n \t{\n-\t  struct loop *inner_loop = \n-\t    current_loops->parray[CHREC_VARIABLE (evolution_fn)];\n+\t  struct loop *inner_loop = get_chrec_loop (evolution_fn);\n \t  tree nb_iter = number_of_iterations_in_loop (inner_loop);\n \n \t  if (nb_iter == chrec_dont_know)\n@@ -534,9 +533,7 @@ chrec_is_positive (tree chrec, bool *value)\n       if (!evolution_function_is_affine_p (chrec))\n \treturn false;\n \n-      nb_iter = number_of_iterations_in_loop\n-\t(current_loops->parray[CHREC_VARIABLE (chrec)]);\n-\n+      nb_iter = number_of_iterations_in_loop (get_chrec_loop (chrec));\n       if (chrec_contains_undetermined (nb_iter))\n \treturn false;\n \n@@ -2530,7 +2527,7 @@ number_of_iterations_for_all_loops (VEC(tree,heap) **exit_conditions)\n       fprintf (dump_file, \"-----------------------------------------\\n\");\n       fprintf (dump_file, \"%d\\tnb_chrec_dont_know_loops\\n\", nb_chrec_dont_know_loops);\n       fprintf (dump_file, \"%d\\tnb_static_loops\\n\", nb_static_loops);\n-      fprintf (dump_file, \"%d\\tnb_total_loops\\n\", current_loops->num);\n+      fprintf (dump_file, \"%d\\tnb_total_loops\\n\", number_of_loops ());\n       fprintf (dump_file, \"-----------------------------------------\\n\");\n       fprintf (dump_file, \")\\n\\n\");\n       \n@@ -2747,36 +2744,36 @@ initialize_scalar_evolutions_analyzer (void)\n void\n scev_initialize (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n+  struct loop *loop;\n \n   scalar_evolution_info = htab_create (100, hash_scev_info,\n \t\t\t\t       eq_scev_info, del_scev_info);\n   already_instantiated = BITMAP_ALLOC (NULL);\n   \n   initialize_scalar_evolutions_analyzer ();\n \n-  for (i = 1; i < current_loops->num; i++)\n-    if (current_loops->parray[i])\n-      current_loops->parray[i]->nb_iterations = NULL_TREE;\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      loop->nb_iterations = NULL_TREE;\n+    }\n }\n \n /* Cleans up the information cached by the scalar evolutions analysis.  */\n \n void\n scev_reset (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n \n   if (!scalar_evolution_info || !current_loops)\n     return;\n \n   htab_empty (scalar_evolution_info);\n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (loop)\n-\tloop->nb_iterations = NULL_TREE;\n+      loop->nb_iterations = NULL_TREE;\n     }\n }\n \n@@ -2890,6 +2887,7 @@ scev_const_prop (void)\n   struct loop *loop, *ex_loop;\n   bitmap ssa_names_to_remove = NULL;\n   unsigned i;\n+  loop_iterator li;\n \n   if (!current_loops)\n     return 0;\n@@ -2931,7 +2929,6 @@ scev_const_prop (void)\n   if (ssa_names_to_remove)\n     {\n       bitmap_iterator bi;\n-      unsigned i;\n \n       EXECUTE_IF_SET_IN_BITMAP (ssa_names_to_remove, 0, i, bi)\n \t{\n@@ -2947,16 +2944,12 @@ scev_const_prop (void)\n     }\n \n   /* Now the regular final value replacement.  */\n-  for (i = current_loops->num - 1; i > 0; i--)\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       edge exit;\n       tree def, rslt, ass, niter;\n       block_stmt_iterator bsi;\n \n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n       /* If we do not know exact number of iterations of the loop, we cannot\n \t replace the final value.  */\n       exit = single_exit (loop);"}, {"sha": "98855b93e260b7e65aa0e759129d016cafdcb56c", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -36,4 +36,12 @@ unsigned int scev_const_prop (void);\n \n extern bool simple_iv (struct loop *, tree, tree, affine_iv *, bool);\n \n+/* Returns the loop of the polynomial chrec CHREC.  */\n+\n+static inline struct loop *\n+get_chrec_loop (tree chrec)\n+{\n+  return get_loop (CHREC_VARIABLE (chrec));\n+}\n+\n #endif  /* GCC_TREE_SCALAR_EVOLUTION_H  */"}, {"sha": "e1d5af8a04cb7dfb6c1a06bfd32ca1b41bd9efa5", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -123,7 +123,7 @@ do_while_loop_p (struct loop *loop)\n static unsigned int\n copy_loop_headers (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n   basic_block header;\n   edge exit, entry;\n@@ -144,14 +144,11 @@ copy_loop_headers (void)\n   copied_bbs = XNEWVEC (basic_block, n_basic_blocks);\n   bbs_size = n_basic_blocks;\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n       /* Copy at most 20 insns.  */\n       int limit = 20;\n \n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n       header = loop->header;\n \n       /* If the loop is already a do-while style one (either because it was"}, {"sha": "9bdffa23ab1ac09fec280e4a729f036fb25804cc", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -1377,34 +1377,17 @@ static void\n determine_lsm (void)\n {\n   struct loop *loop;\n-\n-  if (!current_loops->tree_root->inner)\n-    return;\n+  loop_iterator li;\n \n   /* Pass the loops from the outermost and perform the store motion as\n      suitable.  */\n \n-  loop = current_loops->tree_root->inner;\n-  while (1)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n       determine_lsm_loop (loop);\n-\n-      if (loop->inner)\n-\t{\n-\t  loop = loop->inner;\n-\t  continue;\n-\t}\n-      while (!loop->next)\n-\t{\n-\t  loop = loop->outer;\n-\t  if (loop == current_loops->tree_root)\n-\t    {\n-\t      bsi_commit_edge_inserts ();\n-\t      return;\n-\t    }\n-\t}\n-      loop = loop->next;\n     }\n+\n+  bsi_commit_edge_inserts ();\n }\n \n /* Fills ALWAYS_EXECUTED_IN information for basic blocks of LOOP, i.e."}, {"sha": "6326801767095a00790af7a054296a9676a0e6ab", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -332,18 +332,15 @@ canonicalize_loop_induction_variables (struct loop *loop,\n unsigned int\n canonicalize_induction_variables (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n   \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-\n-      if (loop)\n-\tchanged |= canonicalize_loop_induction_variables (loop,\n-\t\t\t\t\t\t\t  true, UL_SINGLE_ITER,\n-\t\t\t\t\t\t\t  true);\n+      changed |= canonicalize_loop_induction_variables (loop,\n+\t\t\t\t\t\t\ttrue, UL_SINGLE_ITER,\n+\t\t\t\t\t\t\ttrue);\n     }\n \n   /* Clean up the information about numbers of iterations, since brute force\n@@ -362,18 +359,13 @@ canonicalize_induction_variables (void)\n unsigned int\n tree_unroll_loops_completely (bool may_increase_size)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n   enum unroll_level ul;\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-\n-      if (!loop)\n-\tcontinue;\n-\n       if (may_increase_size && maybe_hot_bb_p (loop->header))\n \tul = UL_ALL;\n       else"}, {"sha": "1aea162fe2c42643407dfd7f5da7c095b46d8236", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -5889,30 +5889,17 @@ tree_ssa_iv_optimize (void)\n {\n   struct loop *loop;\n   struct ivopts_data data;\n+  loop_iterator li;\n \n   tree_ssa_iv_optimize_init (&data);\n \n   /* Optimize the loops starting with the innermost ones.  */\n-  loop = current_loops->tree_root;\n-  while (loop->inner)\n-    loop = loop->inner;\n-\n-  /* Scan the loops, inner ones first.  */\n-  while (loop != current_loops->tree_root)\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tflow_loop_dump (loop, dump_file, NULL, 1);\n \n       tree_ssa_iv_optimize_loop (&data, loop);\n-\n-      if (loop->next)\n-\t{\n-\t  loop = loop->next;\n-\t  while (loop->inner)\n-\t    loop = loop->inner;\n-\t}\n-      else\n-\tloop = loop->outer;\n     }\n \n   tree_ssa_iv_optimize_finalize (&data);"}, {"sha": "bff08a0796b3cc0c64f01464c7b1ab955889fbdb", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -2024,14 +2024,12 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n void\n estimate_numbers_of_iterations (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (loop)\n-\testimate_numbers_of_iterations_loop (loop);\n+      estimate_numbers_of_iterations_loop (loop);\n     }\n }\n \n@@ -2246,14 +2244,12 @@ free_numbers_of_iterations_estimates_loop (struct loop *loop)\n void\n free_numbers_of_iterations_estimates (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n \n-  for (i = 1; i < current_loops->num; i++)\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n-      loop = current_loops->parray[i];\n-      if (loop)\n-\tfree_numbers_of_iterations_estimates_loop (loop);\n+      free_numbers_of_iterations_estimates_loop (loop);\n     }\n }\n "}, {"sha": "5f39b8d2bfd566d5afac6a3cf33639c49ba0784c", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -998,7 +998,7 @@ loop_prefetch_arrays (struct loop *loop)\n unsigned int\n tree_ssa_prefetch_arrays (void)\n {\n-  unsigned i;\n+  loop_iterator li;\n   struct loop *loop;\n   bool unrolled = false;\n   int todo_flags = 0;\n@@ -1043,12 +1043,8 @@ tree_ssa_prefetch_arrays (void)\n      here.  */\n   gcc_assert ((PREFETCH_BLOCK & (PREFETCH_BLOCK - 1)) == 0);\n \n-  for (i = current_loops->num - 1; i > 0; i--)\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Processing loop %d:\\n\", loop->num);\n "}, {"sha": "52465db8611378ddd47b4b99190f8535dfd01472", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -82,23 +82,13 @@ static tree tree_may_unswitch_on (basic_block, struct loop *);\n unsigned int\n tree_ssa_unswitch_loops (void)\n {\n-  int i, num;\n+  loop_iterator li;\n   struct loop *loop;\n   bool changed = false;\n \n   /* Go through inner loops (only original ones).  */\n-  num = current_loops->num;\n-\n-  for (i = 1; i < num; i++)\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD | LI_ONLY_INNERMOST)\n     {\n-      /* Removed loop?  */\n-      loop = current_loops->parray[i];\n-      if (!loop)\n-\tcontinue;\n-\n-      if (loop->inner)\n-\tcontinue;\n-\n       changed |= tree_unswitch_single_loop (loop, 0);\n     }\n "}, {"sha": "d948c99558a9d79577192016195cfa114a93c3ad", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -174,9 +174,6 @@ FILE *vect_dump;\n    to mark that it's uninitialized.  */\n enum verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n \n-/* Number of loops, at the beginning of vectorization.  */\n-unsigned int vect_loops_num;\n-\n /* Loop location.  */\n static LOC vect_loop_location;\n \n@@ -2157,6 +2154,9 @@ vectorize_loops (void)\n {\n   unsigned int i;\n   unsigned int num_vectorized_loops = 0;\n+  unsigned int vect_loops_num;\n+  loop_iterator li;\n+  struct loop *loop;\n \n   /* Fix the verbosity level if not defined explicitly by the user.  */\n   vect_set_dump_settings ();\n@@ -2170,14 +2170,10 @@ vectorize_loops (void)\n   /* If some loop was duplicated, it gets bigger number \n      than all previously defined loops. This fact allows us to run \n      only over initial loops skipping newly generated ones.  */\n-  vect_loops_num = current_loops->num;\n-  for (i = 1; i < vect_loops_num; i++)\n+  vect_loops_num = number_of_loops ();\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_OLD)\n     {\n       loop_vec_info loop_vinfo;\n-      struct loop *loop = current_loops->parray[i];\n-\n-      if (!loop)\n-        continue;\n \n       vect_loop_location = find_loop_location (loop);\n       loop_vinfo = vect_analyze_loop (loop);\n@@ -2201,9 +2197,9 @@ vectorize_loops (void)\n \n   for (i = 1; i < vect_loops_num; i++)\n     {\n-      struct loop *loop = current_loops->parray[i];\n       loop_vec_info loop_vinfo;\n \n+      loop = get_loop (i);\n       if (!loop)\n \tcontinue;\n       loop_vinfo = loop->aux;"}, {"sha": "325f4024d9f6f894d2e0362a24cf5b4f866d9b4e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -327,9 +327,6 @@ known_alignment_for_access_p (struct data_reference *data_ref_info)\n extern FILE *vect_dump;\n extern enum verbosity_levels vect_verbosity_level;\n \n-/* Number of loops, at the beginning of vectorization.  */\n-extern unsigned int vect_loops_num;\n-\n /* Bitmap of virtual variables to be renamed.  */\n extern bitmap vect_vnames_to_rename;\n "}, {"sha": "8e9d3cad7a593ae31e835badffdb2f101e3666bd", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -1998,8 +1998,7 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t or decreases,  ... */\n       dir == EV_DIR_UNKNOWN\n       /* ... or if it may wrap.  */\n-      || scev_probably_wraps_p (init, step, stmt,\n-\t\t\t\tcurrent_loops->parray[CHREC_VARIABLE (chrec)],\n+      || scev_probably_wraps_p (init, step, stmt, get_chrec_loop (chrec),\n \t\t\t\ttrue))\n     return;\n "}, {"sha": "4e42c9b1e20c364d3699097e0670ae87521578d3", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd6772c6c7b06d6c94854d0bf0a9360c8d261c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=42fd6772c6c7b06d6c94854d0bf0a9360c8d261c", "patch": "@@ -1587,6 +1587,12 @@ struct tree_constructor GTY(())\n #define COND_EXPR_THEN(NODE)\t(TREE_OPERAND (COND_EXPR_CHECK (NODE), 1))\n #define COND_EXPR_ELSE(NODE)\t(TREE_OPERAND (COND_EXPR_CHECK (NODE), 2))\n \n+/* Accessors for the chains of recurrences.  */\n+#define CHREC_VAR(NODE)           TREE_OPERAND (POLYNOMIAL_CHREC_CHECK (NODE), 0)\n+#define CHREC_LEFT(NODE)          TREE_OPERAND (POLYNOMIAL_CHREC_CHECK (NODE), 1)\n+#define CHREC_RIGHT(NODE)         TREE_OPERAND (POLYNOMIAL_CHREC_CHECK (NODE), 2)\n+#define CHREC_VARIABLE(NODE)      TREE_INT_CST_LOW (CHREC_VAR (NODE))\n+\n /* LABEL_EXPR accessor. This gives access to the label associated with\n    the given label expression.  */\n #define LABEL_EXPR_LABEL(NODE)  TREE_OPERAND (LABEL_EXPR_CHECK (NODE), 0)"}]}