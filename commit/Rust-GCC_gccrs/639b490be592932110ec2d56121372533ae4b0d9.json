{"sha": "639b490be592932110ec2d56121372533ae4b0d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM5YjQ5MGJlNTkyOTMyMTEwZWMyZDU2MTIxMzcyNTMzYWU0YjBkOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-11-26T10:04:25Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-11-26T10:04:25Z"}, "message": "PR libstdc++/29385 (2nd part, based on an idea by Ion Gaztanaga)\n\n2006-11-26  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/29385 (2nd part, based on an idea by Ion Gaztanaga)\n\t* include/bits/stl_tree.h (_Rb_tree<>::_M_equal_range): Add.\n\t(equal_range(const key_type&)): Use it.\n\n2006-11-26  Paolo Carlini  <pcarlini@suse.de>\n\n\t* testsuite/23_containers/multiset/operations/1.cc: New.\n\t* testsuite/23_containers/set/operations/1.cc: Likewise.\n\t* testsuite/23_containers/multimap/operations/1.cc: Likewise.\n\t* testsuite/23_containers/map/operations/1.cc: Likewise.\n\nFrom-SVN: r119221", "tree": {"sha": "40c6e179359ac85e912adbe01e17df5a777d4d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40c6e179359ac85e912adbe01e17df5a777d4d3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/639b490be592932110ec2d56121372533ae4b0d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/639b490be592932110ec2d56121372533ae4b0d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/639b490be592932110ec2d56121372533ae4b0d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/639b490be592932110ec2d56121372533ae4b0d9/comments", "author": null, "committer": null, "parents": [{"sha": "95c8e172964d91c605a4e134baab0b2f9497dd0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c8e172964d91c605a4e134baab0b2f9497dd0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c8e172964d91c605a4e134baab0b2f9497dd0e"}], "stats": {"total": 608, "additions": 585, "deletions": 23}, "files": [{"sha": "db38d1da9ec8750a28e25d46e66a0fc4ca6b8029", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=639b490be592932110ec2d56121372533ae4b0d9", "patch": "@@ -1,3 +1,16 @@\n+2006-11-26  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/29385 (2nd part, based on an idea by Ion Gaztanaga)\n+\t* include/bits/stl_tree.h (_Rb_tree<>::_M_equal_range): Add.\n+\t(equal_range(const key_type&)): Use it.\n+\n+2006-11-26  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* testsuite/23_containers/multiset/operations/1.cc: New.\n+\t* testsuite/23_containers/set/operations/1.cc: Likewise.\n+\t* testsuite/23_containers/multimap/operations/1.cc: Likewise.\n+\t* testsuite/23_containers/map/operations/1.cc: Likewise.\n+\n 2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/29385 (partial)"}, {"sha": "a4215af7b76a95363d141564dd00cb67778935ff", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=639b490be592932110ec2d56121372533ae4b0d9", "patch": "@@ -563,6 +563,9 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,\n \t\t     const _Key& __k) const;\n \n+      pair<iterator, iterator>\n+      _M_equal_range(const _Key& __k) const;\n+\n     public:\n       // allocation/deallocation\n       _Rb_tree()\n@@ -731,10 +734,12 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       { return const_iterator(_M_upper_bound(_M_begin(), _M_end(), __k)); }\n \n       pair<iterator, iterator>\n-      equal_range(const key_type& __k);\n+      equal_range(const key_type& __k)\n+      { return pair<iterator, iterator>(_M_equal_range(__k)); }\n \n       pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __k) const;\n+      equal_range(const key_type& __k) const\n+      { return pair<const_iterator, const_iterator>(_M_equal_range(__k)); }\n \n       // Debugging.\n       bool\n@@ -954,6 +959,35 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return iterator(const_cast<_Link_type>(__y));\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::iterator,\n+\t typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_equal_range(const _Key& __k) const\n+    {\n+      _Const_Link_type __x = _M_begin();\n+      _Const_Link_type __y = _M_end();\n+      while (__x != 0)\n+\t{\n+\t  if (_M_impl._M_key_compare(_S_key(__x), __k))\n+\t    __x = _S_right(__x);\n+\t  else if (_M_impl._M_key_compare(__k, _S_key(__x)))\n+\t    __y = __x, __x = _S_left(__x);\n+\t  else\n+\t    {\n+\t      _Const_Link_type __xu(__x), __yu(__y);\n+\t      __y = __x, __x = _S_left(__x);\n+\t      __xu = _S_right(__xu);\n+\t      return pair<iterator, iterator>(_M_lower_bound(__x, __y, __k),\n+\t\t\t\t\t      _M_upper_bound(__xu, __yu, __k));\t  \n+\t    }\n+\t}\n+      return pair<iterator, iterator>(iterator(const_cast<_Link_type>(__y)),\n+\t\t\t\t      iterator(const_cast<_Link_type>(__y)));\n+    }\n+\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n@@ -1295,27 +1329,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __n;\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    inline\n-    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n-\t\t\t   _Compare, _Alloc>::iterator,\n-\t typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    equal_range(const _Key& __k)\n-    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }\n-\n-  template<typename _Key, typename _Val, typename _KoV,\n-           typename _Compare, typename _Alloc>\n-    inline\n-    pair<typename _Rb_tree<_Key, _Val, _KoV,\n-\t\t\t   _Compare, _Alloc>::const_iterator,\n-\t typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>\n-    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n-    equal_range(const _Key& __k) const\n-    { return pair<const_iterator, const_iterator>(lower_bound(__k),\n-\t\t\t\t\t\t  upper_bound(__k)); }\n-\n   unsigned int\n   _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n                        const _Rb_tree_node_base* __root);"}, {"sha": "8f27ab4c06e8b211c8dc590fa455bb7570e55c3d", "filename": "libstdc++-v3/testsuite/23_containers/map/operations/1.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F1.cc?ref=639b490be592932110ec2d56121372533ae4b0d9", "patch": "@@ -0,0 +1,135 @@\n+// 2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+// A few tests for equal_range, in the occasion of libstdc++/29385.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  map<int, int> m0;\n+  typedef map<int, int>::iterator iterator;\n+  typedef pair<iterator, bool> insert_return_type;\n+  pair<iterator, iterator> pp0;\n+  typedef map<int, int>::value_type value_type;\n+\n+  pp0 = m0.equal_range(1);\n+  VERIFY( m0.count(1) == 0 );\n+  VERIFY( pp0.first == m0.end() );\n+  VERIFY( pp0.second == m0.end() );\n+\n+  insert_return_type irt0 = m0.insert(value_type(1, 1));\n+  insert_return_type irt1 = m0.insert(value_type(2, 2));\n+  insert_return_type irt2 = m0.insert(value_type(3, 3));\n+ \n+  pp0 = m0.equal_range(2);\n+  VERIFY( m0.count(2) == 1 );\n+  VERIFY( *pp0.first == value_type(2, 2) );\n+  VERIFY( *pp0.second == value_type(3, 3) );\n+  VERIFY( pp0.first == irt1.first );\n+  VERIFY( --pp0.first == irt0.first );  \n+  VERIFY( pp0.second == irt2.first );\n+\n+  m0.insert(value_type(3, 4));\n+  insert_return_type irt3 = m0.insert(value_type(3, 5));\n+  insert_return_type irt4 = m0.insert(value_type(4, 6));\n+\n+  pp0 = m0.equal_range(3);\n+  VERIFY( m0.count(3) == 1 );\n+  VERIFY( *pp0.first == value_type(3, 3) );\n+  VERIFY( *pp0.second == value_type(4, 6) );\n+  VERIFY( pp0.first == irt2.first );\n+  VERIFY( --pp0.first == irt1.first );  \n+  VERIFY( pp0.second == irt4.first );\n+\n+  insert_return_type irt5 = m0.insert(value_type(0, 7));\n+  m0.insert(value_type(1, 8));\n+  m0.insert(value_type(1, 9));\n+  m0.insert(value_type(1, 10));\n+\n+  pp0 = m0.equal_range(1);\n+  VERIFY( m0.count(1) == 1 );\n+  VERIFY( *pp0.first == value_type(1, 1) );\n+  VERIFY( *pp0.second == value_type(2, 2) );\n+  VERIFY( pp0.first == irt0.first );\n+  VERIFY( --pp0.first == irt5.first );  \n+  VERIFY( pp0.second == irt1.first );\n+\n+  insert_return_type irt6 = m0.insert(value_type(5, 11));\n+  m0.insert(value_type(5, 12));\n+  m0.insert(value_type(5, 13));\n+\n+  pp0 = m0.equal_range(5);\n+  VERIFY( m0.count(5) == 1 );\n+  VERIFY( *pp0.first == value_type(5, 11) );\n+  VERIFY( pp0.first == irt6.first );\n+  VERIFY( --pp0.first == irt4.first );  \n+  VERIFY( pp0.second == m0.end() );\n+\n+  m0.insert(value_type(4, 14));\n+  m0.insert(value_type(4, 15));\n+  m0.insert(value_type(4, 16));\n+\n+  pp0 = m0.equal_range(4);\n+  VERIFY( m0.count(4) == 1 );  \n+  VERIFY( *pp0.first == value_type(4, 6) );\n+  VERIFY( *pp0.second == value_type(5, 11) );  \n+  VERIFY( pp0.first == irt4.first );\n+  VERIFY( --pp0.first == irt3.first );  \n+  VERIFY( pp0.second == irt6.first );\n+\n+  m0.insert(value_type(0, 17));\n+  insert_return_type irt7 = m0.insert(value_type(0, 18));\n+  m0.insert(value_type(1, 19));\n+\n+  pp0 = m0.equal_range(0);\n+  VERIFY( m0.count(0) == 1 );  \n+  VERIFY( *pp0.first == value_type(0, 7) );\n+  VERIFY( *pp0.second == value_type(1, 1) );  \n+  VERIFY( pp0.first == irt5.first );\n+  VERIFY( pp0.first == m0.begin() );\n+  VERIFY( pp0.second == irt0.first );\n+\n+  pp0 = m0.equal_range(1);\n+  VERIFY( m0.count(1) == 1 );  \n+  VERIFY( *pp0.first == value_type(1, 1) );\n+  VERIFY( *pp0.second == value_type(2, 2) );  \n+  VERIFY( pp0.first == irt0.first );\n+  VERIFY( --pp0.first == irt7.first);\n+  VERIFY( pp0.second == irt1.first );\n+}\n+\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8ee2f2847d1478fd8412c1748260393376af6b7e", "filename": "libstdc++-v3/testsuite/23_containers/multimap/operations/1.cc", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperations%2F1.cc?ref=639b490be592932110ec2d56121372533ae4b0d9", "patch": "@@ -0,0 +1,134 @@\n+// 2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+// A few tests for equal_range, in the occasion of libstdc++/29385.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  multimap<int, int> mm0;\n+  typedef multimap<int, int>::iterator iterator;\n+  pair<iterator, iterator> pp0;\n+  typedef multimap<int, int>::value_type value_type;\n+\n+  pp0 = mm0.equal_range(1);\n+  VERIFY( mm0.count(1) == 0 );\n+  VERIFY( pp0.first == mm0.end() );\n+  VERIFY( pp0.second == mm0.end() );\n+\n+  iterator iter0 = mm0.insert(value_type(1, 1));\n+  iterator iter1 = mm0.insert(value_type(2, 2));\n+  iterator iter2 = mm0.insert(value_type(3, 3));\n+ \n+  pp0 = mm0.equal_range(2);\n+  VERIFY( mm0.count(2) == 1 );\n+  VERIFY( *pp0.first == value_type(2, 2) );\n+  VERIFY( *pp0.second == value_type(3, 3) );\n+  VERIFY( pp0.first == iter1 );\n+  VERIFY( --pp0.first == iter0 );  \n+  VERIFY( pp0.second == iter2 );\n+\n+  mm0.insert(value_type(3, 4));\n+  iterator iter3 = mm0.insert(value_type(3, 5));\n+  iterator iter4 = mm0.insert(value_type(4, 6));\n+\n+  pp0 = mm0.equal_range(3);\n+  VERIFY( mm0.count(3) == 3 );\n+  VERIFY( *pp0.first == value_type(3, 3) );\n+  VERIFY( *pp0.second == value_type(4, 6) );\n+  VERIFY( pp0.first == iter2 );\n+  VERIFY( --pp0.first == iter1 );  \n+  VERIFY( pp0.second == iter4 );\n+\n+  iterator iter5 = mm0.insert(value_type(0, 7));\n+  mm0.insert(value_type(1, 8));\n+  mm0.insert(value_type(1, 9));\n+  mm0.insert(value_type(1, 10));\n+\n+  pp0 = mm0.equal_range(1);\n+  VERIFY( mm0.count(1) == 4 );\n+  VERIFY( *pp0.first == value_type(1, 1) );\n+  VERIFY( *pp0.second == value_type(2, 2) );\n+  VERIFY( pp0.first == iter0 );\n+  VERIFY( --pp0.first == iter5 );  \n+  VERIFY( pp0.second == iter1 );\n+\n+  iterator iter6 = mm0.insert(value_type(5, 11));\n+  mm0.insert(value_type(5, 12));\n+  mm0.insert(value_type(5, 13));\n+\n+  pp0 = mm0.equal_range(5);\n+  VERIFY( mm0.count(5) == 3 );\n+  VERIFY( *pp0.first == value_type(5, 11) );\n+  VERIFY( pp0.first == iter6 );\n+  VERIFY( --pp0.first == iter4 );  \n+  VERIFY( pp0.second == mm0.end() );\n+\n+  mm0.insert(value_type(4, 14));\n+  mm0.insert(value_type(4, 15));\n+  mm0.insert(value_type(4, 16));\n+\n+  pp0 = mm0.equal_range(4);\n+  VERIFY( mm0.count(4) == 4 );  \n+  VERIFY( *pp0.first == value_type(4, 6) );\n+  VERIFY( *pp0.second == value_type(5, 11) );  \n+  VERIFY( pp0.first == iter4 );\n+  VERIFY( --pp0.first == iter3 );  \n+  VERIFY( pp0.second == iter6 );\n+\n+  mm0.insert(value_type(0, 17));\n+  iterator iter7 = mm0.insert(value_type(0, 18));\n+  mm0.insert(value_type(1, 19));\n+\n+  pp0 = mm0.equal_range(0);\n+  VERIFY( mm0.count(0) == 3 );  \n+  VERIFY( *pp0.first == value_type(0, 7) );\n+  VERIFY( *pp0.second == value_type(1, 1) );  \n+  VERIFY( pp0.first == iter5 );\n+  VERIFY( pp0.first == mm0.begin() );\n+  VERIFY( pp0.second == iter0 );\n+\n+  pp0 = mm0.equal_range(1);\n+  VERIFY( mm0.count(1) == 5 );  \n+  VERIFY( *pp0.first == value_type(1, 1) );\n+  VERIFY( *pp0.second == value_type(2, 2) );  \n+  VERIFY( pp0.first == iter0 );\n+  VERIFY( --pp0.first == iter7 );\n+  VERIFY( pp0.second == iter1 );\n+}\n+\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ffa386cfeb532f8a8c83121c551b09f473ddc869", "filename": "libstdc++-v3/testsuite/23_containers/multiset/operations/1.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperations%2F1.cc?ref=639b490be592932110ec2d56121372533ae4b0d9", "patch": "@@ -0,0 +1,133 @@\n+// 2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+// A few tests for equal_range, in the occasion of libstdc++/29385.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  multiset<int> ms0;\n+  typedef multiset<int>::iterator iterator;\n+  pair<iterator, iterator> pp0;\n+\n+  pp0 = ms0.equal_range(1);\n+  VERIFY( ms0.count(1) == 0 );\n+  VERIFY( pp0.first == ms0.end() );\n+  VERIFY( pp0.second == ms0.end() );\n+\n+  iterator iter0 = ms0.insert(1);\n+  iterator iter1 = ms0.insert(2);\n+  iterator iter2 = ms0.insert(3);\n+ \n+  pp0 = ms0.equal_range(2);\n+  VERIFY( ms0.count(2) == 1 );\n+  VERIFY( *pp0.first == 2 );\n+  VERIFY( *pp0.second == 3 );\n+  VERIFY( pp0.first == iter1 );\n+  VERIFY( --pp0.first == iter0 );  \n+  VERIFY( pp0.second == iter2 );\n+\n+  ms0.insert(3);\n+  iterator iter3 = ms0.insert(3);\n+  iterator iter4 = ms0.insert(4);\n+  \n+  pp0 = ms0.equal_range(3);\n+  VERIFY( ms0.count(3) == 3 );\n+  VERIFY( *pp0.first == 3 );\n+  VERIFY( *pp0.second == 4 );\n+  VERIFY( pp0.first == iter2 );\n+  VERIFY( --pp0.first == iter1 );  \n+  VERIFY( pp0.second == iter4 );\n+\n+  iterator iter5 = ms0.insert(0);\n+  ms0.insert(1);\n+  ms0.insert(1);\n+  ms0.insert(1);\n+\n+  pp0 = ms0.equal_range(1);\n+  VERIFY( ms0.count(1) == 4 );\n+  VERIFY( *pp0.first == 1 );\n+  VERIFY( *pp0.second == 2 );\n+  VERIFY( pp0.first == iter0 );\n+  VERIFY( --pp0.first == iter5 );  \n+  VERIFY( pp0.second == iter1 );\n+\n+  iterator iter6 = ms0.insert(5);\n+  ms0.insert(5);\n+  ms0.insert(5);\n+\n+  pp0 = ms0.equal_range(5);\n+  VERIFY( ms0.count(5) == 3 );\n+  VERIFY( *pp0.first == 5 );\n+  VERIFY( pp0.first == iter6 );\n+  VERIFY( --pp0.first == iter4 );  \n+  VERIFY( pp0.second == ms0.end() );\n+\n+  ms0.insert(4);\n+  ms0.insert(4);\n+  ms0.insert(4);\n+\n+  pp0 = ms0.equal_range(4);\n+  VERIFY( ms0.count(4) == 4 );  \n+  VERIFY( *pp0.first == 4 );\n+  VERIFY( *pp0.second == 5 );  \n+  VERIFY( pp0.first == iter4 );\n+  VERIFY( --pp0.first == iter3 );  \n+  VERIFY( pp0.second == iter6 );\n+  \n+  ms0.insert(0);\n+  iterator iter7 = ms0.insert(0);\n+  ms0.insert(1);\n+\n+  pp0 = ms0.equal_range(0);\n+  VERIFY( ms0.count(0) == 3 );  \n+  VERIFY( *pp0.first == 0 );\n+  VERIFY( *pp0.second == 1 );  \n+  VERIFY( pp0.first == iter5 );\n+  VERIFY( pp0.first == ms0.begin() );\n+  VERIFY( pp0.second == iter0 );\n+\n+  pp0 = ms0.equal_range(1);\n+  VERIFY( ms0.count(1) == 5 );  \n+  VERIFY( *pp0.first == 1 );\n+  VERIFY( *pp0.second == 2 );  \n+  VERIFY( pp0.first == iter0 );\n+  VERIFY( --pp0.first == iter7 );\n+  VERIFY( pp0.second == iter1 );\n+}\n+\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "fcc311381a149e2923c8af6565c07789fbeef784", "filename": "libstdc++-v3/testsuite/23_containers/set/operations/1.cc", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/639b490be592932110ec2d56121372533ae4b0d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperations%2F1.cc?ref=639b490be592932110ec2d56121372533ae4b0d9", "patch": "@@ -0,0 +1,134 @@\n+// 2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+// A few tests for equal_range, in the occasion of libstdc++/29385.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  set<int> s0;\n+  typedef set<int>::iterator iterator;\n+  typedef pair<iterator, bool> insert_return_type;\n+  pair<iterator, iterator> pp0;\n+\n+  pp0 = s0.equal_range(1);\n+  VERIFY( s0.count(1) == 0 );\n+  VERIFY( pp0.first == s0.end() );\n+  VERIFY( pp0.second == s0.end() );\n+\n+  insert_return_type irt0 = s0.insert(1);\n+  insert_return_type irt1 = s0.insert(2);\n+  insert_return_type irt2 = s0.insert(3);\n+ \n+  pp0 = s0.equal_range(2);\n+  VERIFY( s0.count(2) == 1 );\n+  VERIFY( *pp0.first == 2 );\n+  VERIFY( *pp0.second == 3 );\n+  VERIFY( pp0.first == irt1.first );\n+  VERIFY( --pp0.first == irt0.first );\n+  VERIFY( pp0.second == irt2.first );\n+\n+  s0.insert(3);\n+  insert_return_type irt3 = s0.insert(3);\n+  insert_return_type irt4 = s0.insert(4);\n+  \n+  pp0 = s0.equal_range(3);\n+  VERIFY( s0.count(3) == 1 );\n+  VERIFY( *pp0.first == 3 );\n+  VERIFY( *pp0.second == 4 );\n+  VERIFY( pp0.first == irt2.first );\n+  VERIFY( --pp0.first == irt1.first );  \n+  VERIFY( pp0.second == irt4.first );\n+\n+  insert_return_type irt5 = s0.insert(0);\n+  s0.insert(1);\n+  s0.insert(1);\n+  s0.insert(1);\n+\n+  pp0 = s0.equal_range(1);\n+  VERIFY( s0.count(1) == 1 );\n+  VERIFY( *pp0.first == 1 );\n+  VERIFY( *pp0.second == 2 );\n+  VERIFY( pp0.first == irt0.first );\n+  VERIFY( --pp0.first == irt5.first );  \n+  VERIFY( pp0.second == irt1.first );\n+\n+  insert_return_type irt6 = s0.insert(5);\n+  s0.insert(5);\n+  s0.insert(5);\n+\n+  pp0 = s0.equal_range(5);\n+  VERIFY( s0.count(5) == 1 );\n+  VERIFY( *pp0.first == 5 );\n+  VERIFY( pp0.first == irt6.first );\n+  VERIFY( --pp0.first == irt4.first );  \n+  VERIFY( pp0.second == s0.end() );\n+\n+  s0.insert(4);\n+  s0.insert(4);\n+  s0.insert(4);\n+\n+  pp0 = s0.equal_range(4);\n+  VERIFY( s0.count(4) == 1 );  \n+  VERIFY( *pp0.first == 4 );\n+  VERIFY( *pp0.second == 5 );  \n+  VERIFY( pp0.first == irt4.first );\n+  VERIFY( --pp0.first == irt3.first );  \n+  VERIFY( pp0.second == irt6.first );\n+  \n+  s0.insert(0);\n+  insert_return_type irt7 = s0.insert(0);\n+  s0.insert(1);\n+\n+  pp0 = s0.equal_range(0);\n+  VERIFY( s0.count(0) == 1 );  \n+  VERIFY( *pp0.first == 0 );\n+  VERIFY( *pp0.second == 1 );  \n+  VERIFY( pp0.first == irt5.first );\n+  VERIFY( pp0.first == s0.begin() );\n+  VERIFY( pp0.second == irt0.first );\n+\n+  pp0 = s0.equal_range(1);\n+  VERIFY( s0.count(1) == 1 );  \n+  VERIFY( *pp0.first == 1 );\n+  VERIFY( *pp0.second == 2 );  \n+  VERIFY( pp0.first == irt0.first );\n+  VERIFY( --pp0.first == irt7.first );\n+  VERIFY( pp0.second == irt1.first );\n+}\n+\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}