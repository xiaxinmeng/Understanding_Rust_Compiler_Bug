{"sha": "495ec0b2aa808a6463b8c24288a1730cbae1cfca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk1ZWMwYjJhYTgwOGE2NDYzYjhjMjQyODhhMTczMGNiYWUxY2ZjYQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-19T14:52:51Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-20T18:45:14Z"}, "message": "Convert -Walloca pass to ranger.\n\ngcc/ChangeLog:\n\n\t* gimple-ssa-warn-alloca.c (enum alloca_type): Remove\n\tALLOCA_BOUND_UNKNOWN and ALLOCA_CAST_FROM_SIGNED.\n\t(warn_limit_specified_p): New.\n\t(alloca_call_type_by_arg): Remove.\n\t(cast_from_signed_p): Remove.\n\t(is_max): Remove.\n\t(alloca_call_type): Remove heuristics and replace with call into\n\tranger.\n\t(pass_walloca::execute): Instantiate ranger.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/Walloca-1.c: Adjust for ranger.\n\t* gcc.dg/Walloca-12.c: Same.\n\t* gcc.dg/Walloca-13.c: Same.\n\t* gcc.dg/Walloca-2.c: Same.\n\t* gcc.dg/Walloca-3.c: Same.\n\t* gcc.dg/Walloca-6.c: Same.\n\t* gcc.dg/Wvla-larger-than-2.c: Same.", "tree": {"sha": "6483a62d876e9978edd7ffaff217f83a92b7a167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6483a62d876e9978edd7ffaff217f83a92b7a167"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/495ec0b2aa808a6463b8c24288a1730cbae1cfca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495ec0b2aa808a6463b8c24288a1730cbae1cfca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/495ec0b2aa808a6463b8c24288a1730cbae1cfca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495ec0b2aa808a6463b8c24288a1730cbae1cfca/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "522307281ce9042e0bb3044f4a162adcdee0f9f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/522307281ce9042e0bb3044f4a162adcdee0f9f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/522307281ce9042e0bb3044f4a162adcdee0f9f6"}], "stats": {"total": 370, "additions": 51, "deletions": 319}, "files": [{"sha": "33824a7a0915bbe1007668f90ac1cf95e6f9339e", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 44, "deletions": 307, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"cfgloop.h\"\n #include \"intl.h\"\n+#include \"gimple-range.h\"\n \n static unsigned HOST_WIDE_INT adjusted_warn_limit (bool);\n \n@@ -99,12 +100,6 @@ enum alloca_type {\n   // Alloca argument may be too large.\n   ALLOCA_BOUND_MAYBE_LARGE,\n \n-  // Alloca argument is bounded but of an indeterminate size.\n-  ALLOCA_BOUND_UNKNOWN,\n-\n-  // Alloca argument was casted from a signed integer.\n-  ALLOCA_CAST_FROM_SIGNED,\n-\n   // Alloca appears in a loop.\n   ALLOCA_IN_LOOP,\n \n@@ -135,6 +130,15 @@ class alloca_type_and_limit {\n   }\n };\n \n+/* Return TRUE if the user specified a limit for either VLAs or ALLOCAs.  */\n+\n+static bool\n+warn_limit_specified_p (bool is_vla)\n+{\n+  unsigned HOST_WIDE_INT max = is_vla ? warn_vla_limit : warn_alloca_limit;\n+  return max != HOST_WIDE_INT_MAX;\n+}\n+\n /* Return the value of the argument N to -Walloca-larger-than= or\n    -Wvla-larger-than= adjusted for the target data model so that\n    when N == HOST_WIDE_INT_MAX, the adjusted value is set to\n@@ -158,183 +162,15 @@ adjusted_warn_limit (bool idx)\n   return limits[idx];\n }\n \n-\n-// NOTE: When we get better range info, this entire function becomes\n-// irrelevant, as it should be possible to get range info for an SSA\n-// name at any point in the program.\n-//\n-// We have a few heuristics up our sleeve to determine if a call to\n-// alloca() is within bounds.  Try them out and return the type of\n-// alloca call with its assumed limit (if applicable).\n-//\n-// Given a known argument (ARG) to alloca() and an EDGE (E)\n-// calculating said argument, verify that the last statement in the BB\n-// in E->SRC is a gate comparing ARG to an acceptable bound for\n-// alloca().  See examples below.\n-//\n-// If set, ARG_CASTED is the possible unsigned argument to which ARG\n-// was casted to.  This is to handle cases where the controlling\n-// predicate is looking at a casted value, not the argument itself.\n-//    arg_casted = (size_t) arg;\n-//    if (arg_casted < N)\n-//      goto bb3;\n-//    else\n-//      goto bb5;\n-//\n-// MAX_SIZE is WARN_ALLOCA= adjusted for VLAs.  It is the maximum size\n-// in bytes we allow for arg.\n-\n-static class alloca_type_and_limit\n-alloca_call_type_by_arg (tree arg, tree arg_casted, edge e,\n-\t\t\t unsigned HOST_WIDE_INT max_size)\n-{\n-  basic_block bb = e->src;\n-  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  gimple *last = gsi_stmt (gsi);\n-\n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n-\n-  /* When MAX_SIZE is greater than or equal to PTRDIFF_MAX treat\n-     allocations that aren't visibly constrained as OK, otherwise\n-     report them as (potentially) unbounded.  */\n-  alloca_type unbounded_result = (max_size < maxobjsize.to_uhwi ()\n-\t\t\t\t  ? ALLOCA_UNBOUNDED : ALLOCA_OK);\n-\n-  if (!last || gimple_code (last) != GIMPLE_COND)\n-    {\n-      return alloca_type_and_limit (unbounded_result);\n-    }\n-\n-  enum tree_code cond_code = gimple_cond_code (last);\n-  if (e->flags & EDGE_TRUE_VALUE)\n-    ;\n-  else if (e->flags & EDGE_FALSE_VALUE)\n-    cond_code = invert_tree_comparison (cond_code, false);\n-  else\n-      return alloca_type_and_limit (unbounded_result);\n-\n-  // Check for:\n-  //   if (ARG .COND. N)\n-  //     goto <bb 3>;\n-  //   else\n-  //     goto <bb 4>;\n-  //   <bb 3>:\n-  //   alloca(ARG);\n-  if ((cond_code == LE_EXPR\n-       || cond_code == LT_EXPR\n-       || cond_code == GT_EXPR\n-       || cond_code == GE_EXPR)\n-      && (gimple_cond_lhs (last) == arg\n-\t  || gimple_cond_lhs (last) == arg_casted))\n-    {\n-      if (TREE_CODE (gimple_cond_rhs (last)) == INTEGER_CST)\n-\t{\n-\t  tree rhs = gimple_cond_rhs (last);\n-\t  int tst = wi::cmpu (wi::to_widest (rhs), max_size);\n-\t  if ((cond_code == LT_EXPR && tst == -1)\n-\t      || (cond_code == LE_EXPR && (tst == -1 || tst == 0)))\n-\t    return alloca_type_and_limit (ALLOCA_OK);\n-\t  else\n-\t    {\n-\t      // Let's not get too specific as to how large the limit\n-\t      // may be.  Someone's clearly an idiot when things\n-\t      // degrade into \"if (N > Y) alloca(N)\".\n-\t      if (cond_code == GT_EXPR || cond_code == GE_EXPR)\n-\t\trhs = integer_zero_node;\n-\t      return alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE,\n-\t\t\t\t\t    wi::to_wide (rhs));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Analogous to ALLOCA_UNBOUNDED, when MAX_SIZE is greater\n-\t     than or equal to PTRDIFF_MAX, treat allocations with\n-\t     an unknown bound as OK.  */\n-\t  alloca_type unknown_result\n-\t    = (max_size < maxobjsize.to_uhwi ()\n-\t       ? ALLOCA_BOUND_UNKNOWN : ALLOCA_OK);\n-\t  return alloca_type_and_limit (unknown_result);\n-\t}\n-    }\n-\n-  // Similarly, but check for a comparison with an unknown LIMIT.\n-  //   if (LIMIT .COND. ARG)\n-  //     alloca(arg);\n-  //\n-  //   Where LIMIT has a bound of unknown range.\n-  //\n-  // Note: All conditions of the form (ARG .COND. XXXX) where covered\n-  // by the previous check above, so we only need to look for (LIMIT\n-  // .COND. ARG) here.\n-  tree limit = gimple_cond_lhs (last);\n-  if ((gimple_cond_rhs (last) == arg\n-       || gimple_cond_rhs (last) == arg_casted)\n-      && TREE_CODE (limit) == SSA_NAME)\n-    {\n-      wide_int min, max;\n-      value_range_kind range_type = get_range_info (limit, &min, &max);\n-\n-      if (range_type == VR_UNDEFINED || range_type == VR_VARYING)\n-\treturn alloca_type_and_limit (ALLOCA_BOUND_UNKNOWN);\n-\n-      // ?? It looks like the above `if' is unnecessary, as we never\n-      // get any VR_RANGE or VR_ANTI_RANGE here.  If we had a range\n-      // for LIMIT, I suppose we would have taken care of it in\n-      // alloca_call_type(), or handled above where we handle (ARG .COND. N).\n-      //\n-      // If this ever triggers, we should probably figure out why and\n-      // handle it, though it is likely to be just an ALLOCA_UNBOUNDED.\n-      return alloca_type_and_limit (unbounded_result);\n-    }\n-\n-  return alloca_type_and_limit (unbounded_result);\n-}\n-\n-// Return TRUE if SSA's definition is a cast from a signed type.\n-// If so, set *INVALID_CASTED_TYPE to the signed type.\n-\n-static bool\n-cast_from_signed_p (tree ssa, tree *invalid_casted_type)\n-{\n-  gimple *def = SSA_NAME_DEF_STMT (ssa);\n-  if (def\n-      && !gimple_nop_p (def)\n-      && gimple_assign_cast_p (def)\n-      && !TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def))))\n-    {\n-      *invalid_casted_type = TREE_TYPE (gimple_assign_rhs1 (def));\n-      return true;\n-    }\n-  return false;\n-}\n-\n-// Return TRUE if X has a maximum range of MAX, basically covering the\n-// entire domain, in which case it's no range at all.\n-\n-static bool\n-is_max (tree x, wide_int max)\n-{\n-  return wi::max_value (TREE_TYPE (x)) == max;\n-}\n-\n // Analyze the alloca call in STMT and return the alloca type with its\n // corresponding limit (if applicable).  IS_VLA is set if the alloca\n // call was created by the gimplifier for a VLA.\n-//\n-// If the alloca call may be too large because of a cast from a signed\n-// type to an unsigned type, set *INVALID_CASTED_TYPE to the\n-// problematic signed type.\n \n static class alloca_type_and_limit\n-alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n+alloca_call_type (range_query &query, gimple *stmt, bool is_vla)\n {\n   gcc_assert (gimple_alloca_call_p (stmt));\n-  bool tentative_cast_from_signed = false;\n   tree len = gimple_call_arg (stmt, 0);\n-  tree len_casted = NULL;\n-  wide_int min, max;\n-  edge_iterator ei;\n-  edge e;\n \n   gcc_assert (!is_vla || warn_vla_limit >= 0);\n   gcc_assert (is_vla || warn_alloca_limit >= 0);\n@@ -361,118 +197,9 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n       return alloca_type_and_limit (ALLOCA_OK);\n     }\n \n-  // Check the range info if available.\n-  if (TREE_CODE (len) == SSA_NAME)\n-    {\n-      value_range_kind range_type = get_range_info (len, &min, &max);\n-      if (range_type == VR_RANGE)\n-\t{\n-\t  if (wi::leu_p (max, max_size))\n-\t    return alloca_type_and_limit (ALLOCA_OK);\n-\t  else\n-\t    {\n-\t      // A cast may have created a range we don't care\n-\t      // about.  For instance, a cast from 16-bit to\n-\t      // 32-bit creates a range of 0..65535, even if there\n-\t      // is not really a determinable range in the\n-\t      // underlying code.  In this case, look through the\n-\t      // cast at the original argument, and fall through\n-\t      // to look at other alternatives.\n-\t      //\n-\t      // We only look at through the cast when its from\n-\t      // unsigned to unsigned, otherwise we may risk\n-\t      // looking at SIGNED_INT < N, which is clearly not\n-\t      // what we want.  In this case, we'd be interested\n-\t      // in a VR_RANGE of [0..N].\n-\t      //\n-\t      // Note: None of this is perfect, and should all go\n-\t      // away with better range information.  But it gets\n-\t      // most of the cases.\n-\t      gimple *def = SSA_NAME_DEF_STMT (len);\n-\t      if (gimple_assign_cast_p (def))\n-\t\t{\n-\t\t  tree rhs1 = gimple_assign_rhs1 (def);\n-\t\t  tree rhs1type = TREE_TYPE (rhs1);\n-\n-\t\t  // Bail if the argument type is not valid.\n-\t\t  if (!INTEGRAL_TYPE_P (rhs1type))\n-\t\t    return alloca_type_and_limit (ALLOCA_OK);\n-\n-\t\t  if (TYPE_UNSIGNED (rhs1type))\n-\t\t    {\n-\t\t      len_casted = rhs1;\n-\t\t      range_type = get_range_info (len_casted, &min, &max);\n-\t\t    }\n-\t\t}\n-\t      // An unknown range or a range of the entire domain is\n-\t      // really no range at all.\n-\t      if (range_type == VR_VARYING\n-\t\t  || (!len_casted && is_max (len, max))\n-\t\t  || (len_casted && is_max (len_casted, max)))\n-\t\t{\n-\t\t  // Fall through.\n-\t\t}\n-\t      else if (range_type == VR_ANTI_RANGE)\n-\t\treturn alloca_type_and_limit (ALLOCA_UNBOUNDED);\n-\n-\t      if (range_type != VR_VARYING)\n-\t\t{\n-\t\t  const offset_int maxobjsize\n-\t\t    = wi::to_offset (max_object_size ());\n-\t\t  alloca_type result = (max_size < maxobjsize\n-\t\t\t\t\t? ALLOCA_BOUND_MAYBE_LARGE : ALLOCA_OK);\n-\t\t  return alloca_type_and_limit (result, max);\n-\t\t}\n-\t    }\n-\t}\n-      else if (range_type == VR_ANTI_RANGE)\n-\t{\n-\t  // There may be some wrapping around going on.  Catch it\n-\t  // with this heuristic.  Hopefully, this VR_ANTI_RANGE\n-\t  // nonsense will go away, and we won't have to catch the\n-\t  // sign conversion problems with this crap.\n-\t  //\n-\t  // This is here to catch things like:\n-\t  // void foo(signed int n) {\n-\t  //   if (n < 100)\n-\t  //     alloca(n);\n-\t  //   ...\n-\t  // }\n-\t  if (cast_from_signed_p (len, invalid_casted_type))\n-\t    {\n-\t      // Unfortunately this also triggers:\n-\t      //\n-\t      // __SIZE_TYPE__ n = (__SIZE_TYPE__)blah;\n-\t      // if (n < 100)\n-\t      //   alloca(n);\n-\t      //\n-\t      // ...which is clearly bounded.  So, double check that\n-\t      // the paths leading up to the size definitely don't\n-\t      // have a bound.\n-\t      tentative_cast_from_signed = true;\n-\t    }\n-\t}\n-      // No easily determined range and try other things.\n-    }\n-\n-  // If we couldn't find anything, try a few heuristics for things we\n-  // can easily determine.  Check these misc cases but only accept\n-  // them if all predecessors have a known bound.\n-  class alloca_type_and_limit ret = alloca_type_and_limit (ALLOCA_OK);\n-  FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->preds)\n-    {\n-      gcc_assert (!len_casted || TYPE_UNSIGNED (TREE_TYPE (len_casted)));\n-      ret = alloca_call_type_by_arg (len, len_casted, e, max_size);\n-      if (ret.type != ALLOCA_OK)\n-\tbreak;\n-    }\n-\n-  if (ret.type != ALLOCA_OK && tentative_cast_from_signed)\n-    ret = alloca_type_and_limit (ALLOCA_CAST_FROM_SIGNED);\n-\n+  struct alloca_type_and_limit ret = alloca_type_and_limit (ALLOCA_OK);\n   // If we have a declared maximum size, we can take it into account.\n-  if (ret.type != ALLOCA_OK\n-      && gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX))\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX))\n     {\n       tree arg = gimple_call_arg (stmt, 2);\n       if (compare_tree_int (arg, max_size) <= 0)\n@@ -485,9 +212,37 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n \t\t\t\t? ALLOCA_BOUND_MAYBE_LARGE : ALLOCA_OK);\n \t  ret = alloca_type_and_limit (result, wi::to_wide (arg));\n \t}\n+      return ret;\n+    }\n+\n+  // If the user specified a limit, use it.\n+  int_range_max r;\n+  if (warn_limit_specified_p (is_vla)\n+      && TREE_CODE (len) == SSA_NAME\n+      && query.range_of_expr (r, len, stmt)\n+      && !r.varying_p ())\n+    {\n+      // The invalid bits are anything outside of [0, MAX_SIZE].\n+      static int_range<2> invalid_range (build_int_cst (size_type_node, 0),\n+\t\t\t\t\t build_int_cst (size_type_node,\n+\t\t\t\t\t\t\tmax_size),\n+\t\t\t\t\t VR_ANTI_RANGE);\n+\n+      r.intersect (invalid_range);\n+      if (r.undefined_p ())\n+\treturn alloca_type_and_limit (ALLOCA_OK);\n+\n+      return alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE,\n+\t\t\t\t    wi::to_wide (integer_zero_node));\n     }\n \n-  return ret;\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  /* When MAX_SIZE is greater than or equal to PTRDIFF_MAX treat\n+     allocations that aren't visibly constrained as OK, otherwise\n+     report them as (potentially) unbounded.  */\n+  alloca_type unbounded_result = (max_size < maxobjsize.to_uhwi ()\n+\t\t\t\t  ? ALLOCA_UNBOUNDED : ALLOCA_OK);\n+  return alloca_type_and_limit (unbounded_result);\n }\n \n // Return TRUE if STMT is in a loop, otherwise return FALSE.\n@@ -503,6 +258,7 @@ in_loop_p (gimple *stmt)\n unsigned int\n pass_walloca::execute (function *fun)\n {\n+  gimple_ranger ranger;\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n@@ -535,9 +291,8 @@ pass_walloca::execute (function *fun)\n \t  else if (warn_alloca_limit < 0)\n \t    continue;\n \n-\t  tree invalid_casted_type = NULL;\n \t  class alloca_type_and_limit t\n-\t    = alloca_call_type (stmt, is_vla, &invalid_casted_type);\n+\t    = alloca_call_type (ranger, stmt, is_vla);\n \n \t  unsigned HOST_WIDE_INT adjusted_alloca_limit\n \t    = adjusted_warn_limit (false);\n@@ -599,13 +354,6 @@ pass_walloca::execute (function *fun)\n \t\t  }\n \t      }\n \t      break;\n-\t    case ALLOCA_BOUND_UNKNOWN:\n-\t      warning_at (loc, wcode,\n-\t\t\t  (is_vla\n-\t\t\t   ? G_(\"%Gvariable-length array bound is unknown\")\n-\t\t\t   : G_(\"%G%<alloca%> bound is unknown\")),\n-\t\t\t  stmt);\n-\t      break;\n \t    case ALLOCA_UNBOUNDED:\n \t      warning_at (loc, wcode,\n \t\t\t  (is_vla\n@@ -618,17 +366,6 @@ pass_walloca::execute (function *fun)\n \t      warning_at (loc, wcode,\n \t\t\t  \"%Guse of %<alloca%> within a loop\", stmt);\n \t      break;\n-\t    case ALLOCA_CAST_FROM_SIGNED:\n-\t      gcc_assert (invalid_casted_type != NULL_TREE);\n-\t      warning_at (loc, wcode,\n-\t\t\t  (is_vla\n-\t\t\t   ? G_(\"%Gargument to variable-length array \"\n-\t\t\t\t\"may be too large due to \"\n-\t\t\t\t\"conversion from %qT to %qT\")\n-\t\t\t   : G_(\"%Gargument to %<alloca%> may be too large \"\n-\t\t\t\t\"due to conversion from %qT to %qT\")),\n-\t\t\t  stmt, invalid_casted_type, size_type_node);\n-\t      break;\n \t    case ALLOCA_ARG_IS_ZERO:\n \t      warning_at (loc, wcode,\n \t\t\t  (is_vla"}, {"sha": "ed1fa929398c2682ac0b3599f5b4ba0a8423bd90", "filename": "gcc/testsuite/gcc.dg/Walloca-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -24,8 +24,7 @@ void foo1 (size_t len, size_t len2, size_t len3)\n   char *s = alloca (123);\n   useit (s);\t\t\t// OK, constant argument to alloca\n \n-  s = alloca (num);\t\t// { dg-warning \"large due to conversion\" \"\" { target lp64 } }\n-  // { dg-warning \"unbounded use of 'alloca'\" \"\" { target { ! lp64 } } .-1 }\n+  s = alloca (num);\t\t// { dg-warning \"may be too large\" }\n   useit (s);\n \n   s = alloca (30000);\t\t/* { dg-warning \"is too large\" } */"}, {"sha": "d2d9413ab1e9fe6d6f840a11601ccda689e7c568", "filename": "gcc/testsuite/gcc.dg/Walloca-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-12.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -8,5 +8,5 @@ void g (unsigned int n)\n {\n   if (n == 7)\n     n = 11;\n-  f (__builtin_alloca (n)); /* { dg-warning \"unbounded use of 'alloca'\" } */\n+  f (__builtin_alloca (n)); /* { dg-warning \"may be too large\" } */\n }"}, {"sha": "99d62065e2671d7c0409ced7caaacf33ba07219e", "filename": "gcc/testsuite/gcc.dg/Walloca-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-13.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -8,5 +8,5 @@ void g (int *p, int *q)\n {\n   __SIZE_TYPE__ n = (__SIZE_TYPE__)(p - q);\n   if (n < 100)\n-    f (__builtin_alloca (n)); // { dg-bogus \"may be too large due to conversion\" \"\" { xfail { *-*-* } } }\n+    f (__builtin_alloca (n)); // { dg-bogus \"may be too large\" \"\" { xfail { *-*-* } } }\n }"}, {"sha": "1cf9165c59f9e813e535d56d36e713884770a4ce", "filename": "gcc/testsuite/gcc.dg/Walloca-2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-2.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -24,7 +24,7 @@ g2 (int n)\n {\n   void *p;\n   if (n < 2000)\n-    p = __builtin_alloca (n); // { dg-warning \"large due to conversion\" }\n+    p = __builtin_alloca (n); // { dg-warning \"may be too large\" }\n   else\n     p = __builtin_malloc (n);\n   f (p);\n@@ -36,9 +36,7 @@ g3 (int n)\n   void *p;\n   if (n > 0 && n < 3000)\n     {\n-      p = __builtin_alloca (n); // { dg-warning \"'alloca' may be too large\" \"\" { target lp64} }\n-      // { dg-message \"note:.*argument may be as large as 2999\" \"note\" { target lp64 } .-1 }\n-      // { dg-warning \"unbounded use of 'alloca'\" \"\" { target { ! lp64 } } .-2 }\n+      p = __builtin_alloca (n); // { dg-warning \"may be too large\" }\n     }\n   else\n     p = __builtin_malloc (n);"}, {"sha": "b8000ff1249becc2c87506246963f60d502ba7fa", "filename": "gcc/testsuite/gcc.dg/Walloca-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-3.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -13,7 +13,7 @@ g1 (__SIZE_TYPE__ n)\n {\n   void *p;\n   if (n < LIMIT)\n-    p = __builtin_alloca (n); // { dg-warning \"'alloca' bound is unknown\" }\n+    p = __builtin_alloca (n); // { dg-warning \"may be too large\" }\n   else\n     p = __builtin_malloc (n);\n   f (p);\n@@ -27,7 +27,7 @@ g2 (unsigned short n)\n {\n   void *p;\n   if (n < SHORT_LIMIT)\n-    p = __builtin_alloca (n); // { dg-warning \"'alloca' bound is unknown\" }\n+    p = __builtin_alloca (n); // { dg-warning \"may be too large\" }\n   else\n     p = __builtin_malloc (n);\n   f (p);"}, {"sha": "ebe08aec838ba8cdc9cbd32961ffb8ffeeb2332c", "filename": "gcc/testsuite/gcc.dg/Walloca-6.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-6.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target alloca } */\n /* { dg-options \"-Walloca-larger-than=256 -O2\" } */\n-/* { dg-xfail-if \"Currently broken but Andrew's work should fix this\" { *-*-* } } */\n \n void f (void*);\n void g (__SIZE_TYPE__ n)"}, {"sha": "a3a053402f7f5307a2e395987b78d4e05c6e69c1", "filename": "gcc/testsuite/gcc.dg/Wvla-larger-than-2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-larger-than-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495ec0b2aa808a6463b8c24288a1730cbae1cfca/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-larger-than-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-larger-than-2.c?ref=495ec0b2aa808a6463b8c24288a1730cbae1cfca", "patch": "@@ -24,7 +24,6 @@ f2 (__SIZE_TYPE__ a)\n     {\n       // 11 * 4 bytes = 44: Not OK.\n       uint32_t x[a]; // { dg-warning \"array may be too large\" }\n-      // { dg-message \"note:.*argument may be as large as 44\" \"note\" { target *-*-* } .-1 }\n       f0 (x);\n     }\n }"}]}