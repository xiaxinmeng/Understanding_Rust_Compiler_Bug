{"sha": "a9de800a1d61a06926b273e73a596474242347e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlkZTgwMGExZDYxYTA2OTI2YjI3M2U3M2E1OTY0NzQyNDIzNDdlNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-02-12T16:25:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-02-12T16:25:47Z"}, "message": "re PR c++/34862 (operator new placement variant with reference arg not accepted by g++ 4.3)\n\n\tPR c++/34862\n\t* init.c (build_new_1): Don't create placement_expr before\n\tconstructing alloc_call.  Verify that the pointer is passed by\n\tvalue to operator new.\n\n\t* g++.dg/init/new27.C: New test.\n\nFrom-SVN: r132257", "tree": {"sha": "87d8c554fcf5359f810fbbee23dc77a8d2956de6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87d8c554fcf5359f810fbbee23dc77a8d2956de6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9de800a1d61a06926b273e73a596474242347e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9de800a1d61a06926b273e73a596474242347e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9de800a1d61a06926b273e73a596474242347e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9de800a1d61a06926b273e73a596474242347e6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02e52ae514072eb565ae9d7451ee00756c4f5121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e52ae514072eb565ae9d7451ee00756c4f5121", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e52ae514072eb565ae9d7451ee00756c4f5121"}], "stats": {"total": 89, "additions": 75, "deletions": 14}, "files": [{"sha": "943eef35de21a60877f1d6009179c22acf872fd7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a9de800a1d61a06926b273e73a596474242347e6", "patch": "@@ -1,3 +1,10 @@\n+2008-02-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/34862\n+\t* init.c (build_new_1): Don't create placement_expr before\n+\tconstructing alloc_call.  Verify that the pointer is passed by\n+\tvalue to operator new.\n+\n 2008-02-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/35097"}, {"sha": "040b335147259c877dcc36fc944f6804bca08cb3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a9de800a1d61a06926b273e73a596474242347e6", "patch": "@@ -1800,7 +1800,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n   tree cookie_size = NULL_TREE;\n-  tree placement_expr;\n+  tree placement_expr = NULL_TREE;\n   /* True if the function we are calling is a placement allocation\n      function.  */\n   bool placement_allocation_fn_p;\n@@ -1892,19 +1892,6 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n   alloc_fn = NULL_TREE;\n \n-  /* If PLACEMENT is a simple pointer type, then copy it into\n-     PLACEMENT_EXPR.  */\n-  if (processing_template_decl\n-      || placement == NULL_TREE\n-      || TREE_CHAIN (placement) != NULL_TREE\n-      || TREE_CODE (TREE_TYPE (TREE_VALUE (placement))) != POINTER_TYPE)\n-    placement_expr = NULL_TREE;\n-  else\n-    {\n-      placement_expr = get_target_expr (TREE_VALUE (placement));\n-      placement = tree_cons (NULL_TREE, placement_expr, NULL_TREE);\n-    }\n-\n   /* Allocate the object.  */\n   if (! placement && TYPE_FOR_JAVA (elt_type))\n     {\n@@ -1999,6 +1986,28 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n   gcc_assert (alloc_fn != NULL_TREE);\n \n+  /* If PLACEMENT is a simple pointer type and is not passed by reference,\n+     then copy it into PLACEMENT_EXPR.  */\n+  if (!processing_template_decl\n+      && placement != NULL_TREE\n+      && TREE_CHAIN (placement) == NULL_TREE\n+      && TREE_CODE (TREE_TYPE (TREE_VALUE (placement))) == POINTER_TYPE\n+      && TREE_CODE (alloc_call) == CALL_EXPR\n+      && call_expr_nargs (alloc_call) == 2\n+      && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 0))) == INTEGER_TYPE\n+      && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 1))) == POINTER_TYPE)\n+    {\n+      tree placement_arg = CALL_EXPR_ARG (alloc_call, 1);\n+\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg)))\n+\t  || VOID_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg))))\n+\t{\n+\t  placement_expr = get_target_expr (TREE_VALUE (placement));\n+\t  CALL_EXPR_ARG (alloc_call, 1)\n+\t    = convert (TREE_TYPE (placement_arg), placement_expr);\n+\t}\n+    }\n+\n   /* In the simple case, we can stop now.  */\n   pointer_type = build_pointer_type (type);\n   if (!cookie_size && !is_initialized)"}, {"sha": "091bb2897413a2b22401864abcc9e9d7570e9e36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9de800a1d61a06926b273e73a596474242347e6", "patch": "@@ -1,3 +1,8 @@\n+2008-02-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/34862\n+\t* g++.dg/init/new27.C: New test.\n+\n 2008-02-11  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/35077"}, {"sha": "a6271c930d92768b891852a74080d58f22c14183", "filename": "gcc/testsuite/g++.dg/init/new27.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9de800a1d61a06926b273e73a596474242347e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew27.C?ref=a9de800a1d61a06926b273e73a596474242347e6", "patch": "@@ -0,0 +1,40 @@\n+// PR c++/34862\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" void abort ();\n+\n+struct T\n+{\n+  void *operator new (size_t, char *&);\n+  T () { i[0] = 1; i[1] = 2; }\n+  int i[2];\n+};\n+\n+void *\n+T::operator new (size_t size, char *&p)\n+{\n+  void *o = (void *) p;\n+  p += size;\n+  return o;\n+}\n+\n+T *\n+f (char *&x)\n+{\n+  return new (x) T ();\n+}\n+\n+char buf[10 * sizeof (T)] __attribute__((aligned (__alignof (T))));\n+\n+int\n+main ()\n+{\n+  char *p = buf;\n+  T *t = f (p);\n+  if (p != buf + sizeof (T))\n+    abort ();\n+  if (t->i[0] != 1 || t->i[1] != 2)\n+    abort ();\n+}"}]}