{"sha": "03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiZTNjZmVlZjdiMzgxMWFjYjZjNGE4ZGEyZmM1YzFlMjVkM2U0Yw==", "commit": {"author": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2021-08-31T13:09:40Z"}, "committer": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2021-08-31T13:19:31Z"}, "message": "Add support for device-modifiers for 'omp target device'.\n\n'device_num' and 'ancestor' are now parsed on target device constructs for C,\nC++, and Fortran (see OpenMP specification 5.0, p. 170). When 'ancestor' is\n used, then 'sorry, not supported' is output. Moreover, the restrictions for\n'ancestor' are implemented (see OpenMP specification 5.0, p. 174f).\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_omp_clause_device): Parse device-modifiers 'device_num'\n\tand 'ancestor' in 'target device' clauses.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_omp_clause_device): Parse device-modifiers 'device_num'\n\tand 'ancestor' in 'target device' clauses.\n\t* semantics.c (finish_omp_clauses): Error handling. Constant device ids must\n\tevaluate to '1' if 'ancestor' is used.\n\ngcc/fortran/ChangeLog:\n\n\t* gfortran.h: Add variable for 'ancestor' in struct gfc_omp_clauses.\n\t* openmp.c (gfc_match_omp_clauses): Parse device-modifiers 'device_num'\n\tand 'ancestor' in 'target device' clauses.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Set OMP_CLAUSE_DEVICE_ANCESTOR.\n\ngcc/ChangeLog:\n\n\t* gimplify.c (gimplify_scan_omp_clauses): Error handling. 'ancestor' only\n\tallowed on target constructs and only with particular other clauses.\n\t* omp-expand.c (expand_omp_target): Output of 'sorry, not supported' if\n\t'ancestor' is used.\n\t* omp-low.c (check_omp_nesting_restrictions): Error handling. No nested OpenMP\n\tstructs when 'ancestor' is used.\n\t(scan_omp_1_stmt): No usage of OpenMP runtime routines in a target region when\n\t'ancestor' is used.\n\t* tree-pretty-print.c (dump_omp_clause): Append 'ancestor'.\n\t* tree.h (OMP_CLAUSE_DEVICE_ANCESTOR): Define macro.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/target-device-1.c: New test.\n\t* c-c++-common/gomp/target-device-2.c: New test.\n\t* c-c++-common/gomp/target-device-ancestor-1.c: New test.\n\t* c-c++-common/gomp/target-device-ancestor-2.c: New test.\n\t* c-c++-common/gomp/target-device-ancestor-3.c: New test.\n\t* c-c++-common/gomp/target-device-ancestor-4.c: New test.\n\t* gfortran.dg/gomp/target-device-1.f90: New test.\n\t* gfortran.dg/gomp/target-device-2.f90: New test.\n\t* gfortran.dg/gomp/target-device-ancestor-1.f90: New test.\n\t* gfortran.dg/gomp/target-device-ancestor-2.f90: New test.\n\t* gfortran.dg/gomp/target-device-ancestor-3.f90: New test.\n\t* gfortran.dg/gomp/target-device-ancestor-4.f90: New test.", "tree": {"sha": "6ccba78c726f6621e6851caf061f944bc7b5c9d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ccba78c726f6621e6851caf061f944bc7b5c9d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/comments", "author": null, "committer": null, "parents": [{"sha": "69b09c5599b201ac039db564c303f7b20d87e0df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b09c5599b201ac039db564c303f7b20d87e0df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b09c5599b201ac039db564c303f7b20d87e0df"}], "stats": {"total": 670, "additions": 650, "deletions": 20}, "files": [{"sha": "3b1d10f1a36760a64a7d580b79dffc733c1c5eef", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -15945,37 +15945,87 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n }\n \n /* OpenMP 4.0:\n-   device ( expression ) */\n+   device ( expression )\n+\n+   OpenMP 5.0:\n+   device ( [device-modifier :] integer-expression )\n+\n+   device-modifier:\n+     ancestor | device_num */\n \n static tree\n c_parser_omp_clause_device (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n-  matching_parens parens;\n-  if (parens.require_open (parser))\n-    {\n-      location_t expr_loc = c_parser_peek_token (parser)->location;\n-      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n-      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n-      tree c, t = expr.value;\n-      t = c_fully_fold (t, false, NULL);\n+  location_t expr_loc;\n+  c_expr expr;\n+  tree c, t;\n+  bool ancestor = false;\n \n-      parens.skip_until_found_close (parser);\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n \n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+  if (c_parser_next_token_is (parser, CPP_NAME)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+    {\n+      c_token *tok = c_parser_peek_token (parser);\n+      const char *p = IDENTIFIER_POINTER (tok->value);\n+      if (strcmp (\"ancestor\", p) == 0)\n \t{\n-\t  c_parser_error (parser, \"expected integer expression\");\n+\t  /* A requires directive with the reverse_offload clause must be\n+\t  specified.  */\n+\t  if ((omp_requires_mask & OMP_REQUIRES_REVERSE_OFFLOAD) == 0)\n+\t    {\n+\t      error_at (tok->location, \"%<ancestor%> device modifier not \"\n+\t\t\t\t       \"preceded by %<requires%> directive \"\n+\t\t\t\t       \"with %<reverse_offload%> clause\");\n+\t      parens.skip_until_found_close (parser);\n+\t      return list;\n+\t    }\n+\t  ancestor = true;\n+\t}\n+      else if (strcmp (\"device_num\", p) == 0)\n+\t;\n+      else\n+\t{\n+\t  error_at (tok->location, \"expected %<ancestor%> or %<device_num%>\");\n+\t  parens.skip_until_found_close (parser);\n \t  return list;\n \t}\n+      c_parser_consume_token (parser);\n+      c_parser_consume_token (parser);\n+    }\n \n-      check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE, \"device\");\n+  expr_loc = c_parser_peek_token (parser)->location;\n+  expr = c_parser_expr_no_commas (parser, NULL);\n+  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+  t = expr.value;\n+  t = c_fully_fold (t, false, NULL);\n \n-      c = build_omp_clause (clause_loc, OMP_CLAUSE_DEVICE);\n-      OMP_CLAUSE_DEVICE_ID (c) = t;\n-      OMP_CLAUSE_CHAIN (c) = list;\n-      list = c;\n+  parens.skip_until_found_close (parser);\n+\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+    {\n+      c_parser_error (parser, \"expected integer expression\");\n+      return list;\n     }\n+  if (ancestor && TREE_CODE (t) == INTEGER_CST && !integer_onep (t))\n+    {\n+      error_at (expr_loc, \"the %<device%> clause expression must evaluate to \"\n+\t\t\t  \"%<1%>\");\n+      return list;\n+    }\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE, \"device\");\n+\n+  c = build_omp_clause (clause_loc, OMP_CLAUSE_DEVICE);\n \n+  OMP_CLAUSE_DEVICE_ID (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  OMP_CLAUSE_DEVICE_ANCESTOR (c) = ancestor;\n+\n+  list = c;\n   return list;\n }\n "}, {"sha": "7dc4eae7102537fb614efba58b2d8d58a05f12cf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -39049,18 +39049,57 @@ cp_parser_omp_clause_map (cp_parser *parser, tree list)\n }\n \n /* OpenMP 4.0:\n-   device ( expression ) */\n+   device ( expression )\n+\n+   OpenMP 5.0:\n+   device ( [device-modifier :] integer-expression )\n+\n+   device-modifier:\n+     ancestor | device_num */\n \n static tree\n cp_parser_omp_clause_device (cp_parser *parser, tree list,\n \t\t\t     location_t location)\n {\n   tree t, c;\n+  bool ancestor = false;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n     return list;\n \n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_COLON))\n+    {\n+      cp_token *tok = cp_lexer_peek_token (parser->lexer);\n+      const char *p = IDENTIFIER_POINTER (tok->u.value);\n+      if (strcmp (\"ancestor\", p) == 0)\n+\t{\n+\t  ancestor = true;\n+\n+\t  /* A requires directive with the reverse_offload clause must be\n+\t  specified.  */\n+\t  if ((omp_requires_mask & OMP_REQUIRES_REVERSE_OFFLOAD) == 0)\n+\t    {\n+\t      error_at (tok->location, \"%<ancestor%> device modifier not \"\n+\t\t\t\t       \"preceded by %<requires%> directive \"\n+\t\t\t\t       \"with %<reverse_offload%> clause\");\n+\t      cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n+\t      return list;\n+\t    }\n+\t}\n+      else if (strcmp (\"device_num\", p) == 0)\n+\t;\n+      else\n+\t{\n+\t  error_at (tok->location, \"expected %<ancestor%> or %<device_num%>\");\n+\t  cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n+\t  return list;\n+\t}\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+\n   t = cp_parser_assignment_expression (parser);\n \n   if (t == error_mark_node\n@@ -39075,6 +39114,7 @@ cp_parser_omp_clause_device (cp_parser *parser, tree list,\n   c = build_omp_clause (location, OMP_CLAUSE_DEVICE);\n   OMP_CLAUSE_DEVICE_ID (c) = t;\n   OMP_CLAUSE_CHAIN (c) = list;\n+  OMP_CLAUSE_DEVICE_ANCESTOR (c) = ancestor;\n \n   return c;\n }"}, {"sha": "f4b042fb676bbd088b455e6d8774b05088170450", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -7334,6 +7334,15 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"%<device%> id must be integral\");\n \t      remove = true;\n \t    }\n+\t  else if (OMP_CLAUSE_DEVICE_ANCESTOR (c)\n+\t\t   && TREE_CODE (t) == INTEGER_CST\n+\t\t   && !integer_onep (t))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"the %<device%> clause expression must evaluate to \"\n+\t\t\t\"%<1%>\");\n+\t      remove = true;\n+\t    }\n \t  else\n \t    {\n \t      t = mark_rvalue_use (t);"}, {"sha": "fdf556eef3d1a24411d7a750ab522a1c2ec2cf78", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -1482,6 +1482,7 @@ typedef struct gfc_omp_clauses\n   struct gfc_expr *dist_chunk_size;\n   struct gfc_expr *message;\n   const char *critical_name;\n+  bool ancestor;\n   enum gfc_omp_default_sharing default_sharing;\n   enum gfc_omp_atomic_op atomic_op;\n   enum gfc_omp_defaultmap defaultmap[OMP_DEFAULTMAP_CAT_NUM];"}, {"sha": "64ecd547d267ffb8949c0d2c5063791db9c22931", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -1825,11 +1825,54 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_DEVICE)\n \t      && !openacc\n-\t      && (m = gfc_match_dupl_check (!c->device, \"device\", true,\n-\t\t\t\t\t    &c->device)) != MATCH_NO)\n+\t      && ((m = gfc_match_dupl_check (!c->device, \"device\", true))\n+\t\t  != MATCH_NO))\n \t    {\n \t      if (m == MATCH_ERROR)\n \t\tgoto error;\n+\t      c->ancestor = false;\n+\t      if (gfc_match (\"device_num : \") == MATCH_YES)\n+\t\t{\n+\t\t  if (gfc_match (\"%e )\", &c->device) != MATCH_YES)\n+\t\t    {\n+\t\t      gfc_error (\"Expected integer expression at %C\");\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else if (gfc_match (\"ancestor : \") == MATCH_YES)\n+\t\t{\n+\t\t  c->ancestor = true;\n+\t\t  if (!(gfc_current_ns->omp_requires & OMP_REQ_REVERSE_OFFLOAD))\n+\t\t    {\n+\t\t      gfc_error (\"%<ancestor%> device modifier not \"\n+\t\t\t\t \"preceded by %<requires%> directive \"\n+\t\t\t\t \"with %<reverse_offload%> clause at %C\");\n+\t\t      break;\n+\t\t    }\n+\t\t  locus old_loc2 = gfc_current_locus;\n+\t\t  if (gfc_match (\"%e )\", &c->device) == MATCH_YES)\n+\t\t    {\n+\t\t      int device = 0;\n+\t\t      if (!gfc_extract_int (c->device, &device) && device != 1)\n+\t\t      {\n+\t\t\tgfc_current_locus = old_loc2;\n+\t\t\tgfc_error (\"the %<device%> clause expression must \"\n+\t\t\t\t   \"evaluate to %<1%> at %C\");\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gfc_error (\"Expected integer expression at %C\");\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else if (gfc_match (\"%e )\", &c->device) != MATCH_YES)\n+\t\t{\n+\t\t  gfc_error (\"Expected integer expression or a single device-\"\n+\t\t\t      \"modifier %<device_num%> or %<ancestor%> at %C\");\n+\t\t  break;\n+\t\t}\n \t      continue;\n \t    }\n \t  if ((mask & OMP_CLAUSE_DEVICE)"}, {"sha": "6f9b0e390dea0eaec3f8c27bcee7f8dc8b26081e", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -3950,6 +3950,10 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n       c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_DEVICE);\n       OMP_CLAUSE_DEVICE_ID (c) = device;\n+\n+      if (clauses->ancestor)\n+\tOMP_CLAUSE_DEVICE_ANCESTOR (c) = 1;\n+\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n "}, {"sha": "400b6f0f4c186bae6df4bb250596375a12e02e0a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -10107,6 +10107,38 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_DEVICE:\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEVICE\n+\t      && OMP_CLAUSE_DEVICE_ANCESTOR (c))\n+\t    {\n+\t      if (code != OMP_TARGET)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<device%> clause with %<ancestor%> is only \"\n+\t\t\t    \"allowed on %<target%> construct\");\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\n+\t      tree clauses = *orig_list_p;\n+\t      for (; clauses ; clauses = OMP_CLAUSE_CHAIN (clauses))\n+\t\tif (OMP_CLAUSE_CODE (clauses) != OMP_CLAUSE_DEVICE\n+\t\t    && OMP_CLAUSE_CODE (clauses) != OMP_CLAUSE_FIRSTPRIVATE\n+\t\t    && OMP_CLAUSE_CODE (clauses) != OMP_CLAUSE_PRIVATE\n+\t\t    && OMP_CLAUSE_CODE (clauses) != OMP_CLAUSE_DEFAULTMAP\n+\t\t    && OMP_CLAUSE_CODE (clauses) != OMP_CLAUSE_MAP\n+\t\t   )\n+\t\t  {\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"with %<ancestor%>, only the %<device%>, \"\n+\t\t\t      \"%<firstprivate%>, %<private%>, %<defaultmap%>, \"\n+\t\t\t      \"and %<map%> clauses may appear on the \"\n+\t\t\t      \"construct\");\n+\t\t    remove = true;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t  /* Fall through.  */\n+\n \tcase OMP_CLAUSE_PRIORITY:\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:"}, {"sha": "ecb8ee517805a25d488e29a2ffecc972bab481c9", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -9613,6 +9613,8 @@ expand_omp_target (struct omp_region *region)\n \t{\n \t  device = OMP_CLAUSE_DEVICE_ID (c);\n \t  device_loc = OMP_CLAUSE_LOCATION (c);\n+\t  if (OMP_CLAUSE_DEVICE_ANCESTOR (c))\n+\t    sorry_at (device_loc, \"%<ancestor%> not yet supported\");\n \t}\n       else\n \t{"}, {"sha": "6686946e5a7b688e7aedfa61d953b1caf3f0b154", "filename": "gcc/omp-low.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -3114,6 +3114,16 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n       if (gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n \t  && gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_REGION)\n \t{\n+\t  c = omp_find_clause (gimple_omp_target_clauses (ctx->stmt),\n+\t\t\t       OMP_CLAUSE_DEVICE);\n+\t  if (c && OMP_CLAUSE_DEVICE_ANCESTOR (c))\n+\t    {\n+\t      error_at (gimple_location (stmt),\n+\t\t\t\"OpenMP constructs are not allowed in target region \"\n+\t\t\t\"with %<ancestor%>\");\n+\t      return false;\n+\t    }\n+\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TEAMS && !ctx->teams_nested_p)\n \t    ctx->teams_nested_p = true;\n \t  else\n@@ -4063,6 +4073,17 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t\t    \"OpenMP runtime API call %qD in a region with \"\n \t\t\t    \"%<order(concurrent)%> clause\", fndecl);\n \t\t}\n+\t      if (gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n+\t\t  && (gimple_omp_target_kind (ctx->stmt)\n+\t\t      == GF_OMP_TARGET_KIND_REGION))\n+\t\t{\n+\t\t  tree tgt_clauses = gimple_omp_target_clauses (ctx->stmt);\n+\t\t  tree c = omp_find_clause (tgt_clauses, OMP_CLAUSE_DEVICE);\n+\t\t  if (c && OMP_CLAUSE_DEVICE_ANCESTOR (c))\n+\t\t    error_at (gimple_location (stmt),\n+\t\t\t      \"OpenMP runtime API call %qD in a region with \"\n+\t\t\t      \"%<device(ancestor)%> clause\", fndecl);\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "98228626df9ca7e48d5081bf49398d5a28571ca7", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-1.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (int n)\n+{\n+  /* Test to ensure that 'device_num' is parsed correctly in device clauses. */\n+\n+  #pragma omp target device (1)\n+  ;\n+\n+  #pragma omp target device (n)\n+  ;\n+\n+  #pragma omp target device (n + 1)\n+  ;\n+\n+  #pragma omp target device (device_num : 1)\n+  ;\n+\n+  #pragma omp target device (device_num : n)\n+  ;\n+\n+  #pragma omp target device (device_num : n + 1)\n+  ;\n+\n+  #pragma omp target device (invalid : 1) /* { dg-error \"expected 'ancestor' or 'device_num'\" \"\" { target *-*-* } } */\n+  /* { dg-error \"expected '\\\\)' before 'invalid'\" \"\" { target c } .-1 } */\n+  ;\n+\n+  #pragma omp target device (device_num : n, n) /* { dg-error \"expected '\\\\)' before ','\" } */\n+  ;\n+}"}, {"sha": "b711ea15a24654a4d7c621bb9ec7c9ccd7dd3cfb", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-2.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+  /* Test to ensure that device-modifier 'device_num' is parsed correctly in\n+     device clauses. */\n+\n+void\n+foo (void)\n+{\n+  #pragma omp target device (device_num : 42)\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump \"pragma omp target \\[^\\n\\r)]*device\\\\(42\\\\)\" \"original\" } } */"}, {"sha": "b3c1ce89430606bfd8d3db74e43280cf82d86e95", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-1.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (void)\n+{\n+  /* Ensure that a 'requires' directive with the 'reverse_offload' clause was\n+     specified.  */\n+\n+  #pragma omp target device (ancestor : 1) /* { dg-error \"'ancestor' device modifier not preceded by 'requires' directive with 'reverse_offload' clause\" } */\n+    /* { dg-error \"expected '\\\\)' before 'ancestor'\" \"\" { target c } .-1 } */\n+\n+  ;\n+}"}, {"sha": "cf05c505004b3352d4562c6471376859c6957c34", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-2.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-2.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do compile } */\n+\n+#pragma omp requires reverse_offload /* { dg-message \"sorry, unimplemented: 'reverse_offload' clause on 'requires' directive not supported yet\" } */\n+\n+void\n+foo (int n)\n+{\n+  /* The following test is marked with 'xfail' because a previous 'sorry' from\n+     'reverse_offload' suppresses the 'sorry' for 'ancestor'.  */\n+  #pragma omp target device (ancestor: 1) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  ;\n+\n+\n+  /* Ensure that the integer expression in the 'device' clause for\n+     device-modifier 'ancestor' evaluates to '1' in case of a constant.  */\n+\n+  #pragma omp target device (ancestor : 1)\n+  ;\n+  #pragma omp target device (ancestor : 42) /* { dg-error \"the 'device' clause expression must evaluate to '1'\" } */\n+  ;\n+\n+  #pragma omp target device (ancestor : n) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  ;\n+  #pragma omp target device (ancestor : n + 1) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  ;\n+\n+\n+  /* Ensure that only one 'device' clause appears on the construct.  */\n+\n+  #pragma omp target device (17) device (42) /* { dg-error \"too many 'device' clauses\" } */\n+  ;\n+\n+\n+  /* Ensure that with 'ancestor' only the 'device', 'firstprivate', 'private',\n+     'defaultmap', and 'map' clauses appear on the construct.  */\n+\n+  #pragma omp target nowait device (ancestor: 1) /* { dg-error \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" } */\n+  ;\n+  #pragma omp target device (ancestor: 1) nowait /* { dg-error \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" } */\n+  ;\n+  #pragma omp target nowait device (42)\n+  ;\n+  #pragma omp target nowait device (device_num: 42)\n+  ;\n+\n+  int a = 0, b = 0, c = 0;\n+  #pragma omp target device (ancestor: 1) firstprivate (a) private (b) defaultmap (none) map (c)\n+  ;\n+\n+\n+  /* Ensure that 'ancestor' is only used with 'target' constructs (not with\n+     'target data', 'target update' etc.).  */\n+\n+  #pragma omp target data map (a) device (ancestor: 1) /* { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" } */\n+  ;\n+  #pragma omp target enter data map (to: a) device (ancestor: 1) /* { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" } */\n+  #pragma omp target exit data map (from: a) device (ancestor: 1) /* { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" } */\n+  #pragma omp target update to (a) device (ancestor: 1) /* { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" \"\" { target *-*-* } } */\n+\n+\n+  /* Ensure that no OpenMP constructs appear inside target regions with \n+     'ancestor'.  */\n+\n+  #pragma omp target device (ancestor: 1)\n+    {\n+      #pragma omp teams /* { dg-error \"OpenMP constructs are not allowed in target region with 'ancestor'\" } */\n+      ;\n+    }\n+\n+  #pragma omp target device (device_num: 1) \n+    {\n+      #pragma omp teams\n+      ;\n+    }\n+\n+  #pragma omp target device (1) \n+    {\n+      #pragma omp teams\n+      ;\n+    }\n+\n+}"}, {"sha": "5e3a478fd5b4d42bf63f71eedea32c4b546124e5", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-3.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-3.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,37 @@\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+int omp_get_num_teams (void);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+/* { dg-do compile } */\n+\n+#pragma omp requires reverse_offload /* { dg-message \"sorry, unimplemented: 'reverse_offload' clause on 'requires' directive not supported yet\" } */\n+\n+void\n+foo (void)\n+{\n+  /* Ensure that no calls to OpenMP API runtime routines are allowed inside the\n+     corresponding target region.  */\n+\n+  int a;\n+\n+  #pragma omp target device (ancestor: 1)\n+    {\n+      a = omp_get_num_teams (); /* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_teams\\[^\\n\\r]*' in a region with 'device\\\\(ancestor\\\\)' clause\" }  */\n+    }\n+\n+  #pragma omp target device (device_num: 1)\n+    {\n+      a = omp_get_num_teams ();\n+    }\n+\n+  #pragma omp target device (1)\n+    {\n+      a = omp_get_num_teams ();\n+    }\n+}"}, {"sha": "b4b5620bbc0f90ab93b33a1b9b10911492b2d541", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+  /* Test to ensure that device-modifier 'ancestor' is parsed correctly in\n+     device clauses. */\n+\n+#pragma omp requires reverse_offload /* { dg-message \"sorry, unimplemented: 'reverse_offload' clause on 'requires' directive not supported yet\" } */\n+\n+void\n+foo (void)\n+{\n+  #pragma omp target device (ancestor: 1) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  ;\n+\n+}\n+\n+/* { dg-final { scan-tree-dump \"pragma omp target \\[^\\n\\r)]*device\\\\(ancestor:1\\\\)\" \"original\" } } */"}, {"sha": "20b97559978e6a783f5e3bf8f8146e3a355cb92e", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-1.f90", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-1.f90?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,67 @@\n+! { dg-do compile }\n+\n+implicit none\n+\n+integer :: n\n+\n+!$omp target device (1)\n+!$omp end target\n+\n+!$omp target device (n)\n+!$omp end target\n+\n+!$omp target device (n + 1)\n+!$omp end target\n+\n+!$omp target device (device_num : 1)\n+!$omp end target\n+\n+!$omp target device (device_num : n)\n+!$omp end target\n+\n+!$omp target device (device_num : n + 1)\n+!$omp end target\n+\n+!$omp target device (invalid : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device ( : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device ( , : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (ancestor, device_num : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (ancestor, device_num, ancestor : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (device_num device_num : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (ancestor device_num : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (device_num, invalid : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (ancestor, invalid : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (ancestor, , , : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (invalid, ancestor : 1)  ! { dg-error \"xpected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (invalid, invalid, ancestor : 1)  ! { dg-error \"xpected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (device_num invalid : 1)  ! { dg-error \"Expected integer expression or a single device-modifier 'device_num' or 'ancestor' at\" }\n+! !$omp end target\n+\n+!$omp target device (device_num : n, n)  ! { dg-error \"Expected integer expression\" }\n+! !$omp end target\n+\n+end"}, {"sha": "133b805b8e1a07fb37212b5d4282d5f87e622ca0", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-2.f90?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+! Test to ensure that device-modifier 'device_num' is parsed correctly in\n+! device clauses.\n+\n+!$omp target device (device_num : 42)\n+!$omp end target\n+\n+end\n+\n+! { dg-final { scan-tree-dump \"pragma omp target \\[^\\n\\r)]*device\\\\(42\\\\)\" \"original\" } }"}, {"sha": "9a170dbee07dcda63313134ebc0901c22301af3d", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-1.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-1.f90?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+\n+! Ensure that a 'requires' directive with the 'reverse_offload' clause was\n+! specified.\n+\n+!$omp target device (ancestor:1)  ! { dg-error \"'ancestor' device modifier not preceded by 'requires' directive with 'reverse_offload' clause\" }\n+! !$omp end target\n+\n+end\n\\ No newline at end of file"}, {"sha": "117a1d000a5748fb6784168132ea6f9458bd1d4d", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-2.f90", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2.f90?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,92 @@\n+! { dg-do compile }\n+\n+implicit none\n+\n+integer :: a, b, c\n+\n+!$omp requires reverse_offload  ! { dg-error \"Sorry, 'reverse_offload' clause at \\\\(1\\\\) on REQUIRES directive is not yet supported\" }\n+\n+\n+! The following test case is marked with 'xfail' because a previous 'sorry' from\n+! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n+\n+!$omp target device (ancestor: 1)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp end target\n+\n+!$omp target device (ancestor : a)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp end target\n+\n+!$omp target device (ancestor : a + 1)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp end target\n+\n+\n+! Ensure that the integer expression in the 'device' clause for\n+! device-modifier 'ancestor' evaluates to '1' in case of a constant.\n+\n+!$omp target device (ancestor: 42)  ! { dg-error \"the 'device' clause expression must evaluate to '1'\" }\n+! !$omp end target\n+\n+!$omp target device (device_num:42)\n+!$omp end target\n+\n+!$omp target device (42)\n+!$omp end target\n+\n+\n+! Ensure that no OpenMP constructs appear inside target regions with 'ancestor'.\n+! The following test case is marked with 'xfail' because a previous 'sorry' from\n+! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n+\n+!$omp target device (ancestor: 1)\n+  !$omp teams  ! { dg-error \"\" \"OpenMP constructs are not allowed in target region with 'ancestor'\" { xfail *-*-* } }\n+  !$omp end teams\n+!$omp end target\n+\n+!$omp target device (device_num: 1)\n+  !$omp teams\n+  !$omp end teams\n+!$omp end target\n+\n+!$omp target device (1)\n+  !$omp teams\n+  !$omp end teams\n+!$omp end target\n+\n+\n+! Ensure that with 'ancestor' only the 'device', 'firstprivate', 'private',\n+! 'defaultmap', and 'map' clauses appear on the construct.\n+! The following test case is marked with 'xfail' because a previous 'sorry' from\n+! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n+\n+!$omp target nowait device (ancestor: 1)  ! { dg-error \"\" \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" { xfail *-*-* } }\n+!$omp end target\n+\n+!$omp target device (ancestor: 1) nowait  ! { dg-error \"\" \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" { xfail *-*-* } }\n+!$omp end target\n+\n+!$omp target nowait device (device_num: 1)\n+!$omp end target\n+\n+!$omp target nowait device (1)\n+!$omp end target\n+\n+!$omp target device (ancestor: 1) firstprivate (a) private (b) defaultmap (none) map (c)\n+!$omp end target\n+\n+\n+! Ensure that 'ancestor' is only used with 'target' constructs (not with\n+! 'target data', 'target update' etc.).\n+! The following test case is marked with 'xfail' because a previous 'sorry' from\n+! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n+\n+!$omp target data map (a) device (ancestor: 1)  ! { dg-error \"\" \"'device' clause with 'ancestor' is only allowed on 'target' construct\" { xfail *-*-* } }\n+!$omp end target data\n+\n+!$omp target enter data map (to: a) device (ancestor: 1)  ! { dg-error \"\" \"'device' clause with 'ancestor' is only allowed on 'target' construct\" { xfail *-*-* } }\n+!$omp target exit data map (from: a) device (ancestor: 1)  ! { dg-error \"\" \"'device' clause with 'ancestor' is only allowed on 'target' construct\" { xfail *-*-* } }\n+\n+!$omp target update to (a) device (ancestor: 1)  ! { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" \"\" { xfail *-*-* } }\n+! { dg-error \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" \"\" { xfail *-*-* } .-1 }\n+\n+\n+end\n\\ No newline at end of file"}, {"sha": "f1145bde2ece0bee085c97f68de4b64be032b984", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-3.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-3.f90?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+\n+! This testcase ensure that no calls to OpenMP API runtime routines are allowed\n+! inside the corresponding target region.\n+\n+module my_omp_mod\n+ use iso_c_binding\n+ interface\n+   integer function omp_get_thread_num ()\n+   end\n+ end interface\n+end\n+\n+subroutine f1 ()\n+  use my_omp_mod\n+  implicit none\n+  integer :: n\n+\n+  !$omp requires reverse_offload  ! { dg-error \"Sorry, 'reverse_offload' clause at \\\\(1\\\\) on REQUIRES directive is not yet supported\" }\n+\n+  !$omp target device (ancestor : 1)\n+    n = omp_get_thread_num ()  ! { dg-error \"\" \"OpenMP runtime API call 'omp_get_thread_num' in a region with 'device\\\\(ancestor\\\\)' clause\" { xfail *-*-* } }\n+  !$omp end target\n+\n+  !$omp target device (device_num : 1)\n+    n = omp_get_thread_num ()\n+  !$omp end target\n+\n+  !$omp target device (1)\n+    n = omp_get_thread_num ()\n+  !$omp end target\n+\n+end\n\\ No newline at end of file"}, {"sha": "540b3d0355c08d454fd7ffb82df9fe6129b3e1f1", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-4.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+! Test to ensure that device-modifier 'ancestor' is parsed correctly in\n+! device clauses.\n+\n+!$omp requires reverse_offload  ! { dg-error \"Sorry, 'reverse_offload' clause at \\\\(1\\\\) on REQUIRES directive is not yet supported\" }\n+\n+!$omp target device (ancestor : 1)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp end target\n+\n+end\n+\n+! { dg-final { scan-tree-dump \"pragma omp target \\[^\\n\\r)]*device\\\\(ancestor:1\\\\)\" \"original\" } }"}, {"sha": "5495942043883b15f30d1bec3470cd68ec73fdca", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -986,6 +986,8 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \n     case OMP_CLAUSE_DEVICE:\n       pp_string (pp, \"device(\");\n+      if (OMP_CLAUSE_DEVICE_ANCESTOR (clause))\n+\tpp_string (pp, \"ancestor:\");\n       dump_generic_node (pp, OMP_CLAUSE_DEVICE_ID (clause),\n \t\t\t spc, flags, false);\n       pp_right_paren (pp);"}, {"sha": "c32193219efce626fedbe9cc5b7860bc1c535d29", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=03be3cfeef7b3811acb6c4a8da2fc5c1e25d3e4c", "patch": "@@ -1691,6 +1691,10 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_DEVICE_TYPE_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEVICE_TYPE)->omp_clause.subcode.device_type_kind)\n \n+/* True if there is a device clause with a device-modifier 'ancestor'.  */\n+#define OMP_CLAUSE_DEVICE_ANCESTOR(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEVICE)->base.public_flag)\n+\n #define OMP_CLAUSE_COLLAPSE_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 0)\n #define OMP_CLAUSE_COLLAPSE_ITERVAR(NODE) \\"}]}