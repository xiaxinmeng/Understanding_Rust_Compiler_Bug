{"sha": "6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwNDJlZjRlMmI5NmMwN2NiMGY3YTk1NjM1MDI1YTMwN2E2ZjFiZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-30T00:32:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-30T00:32:04Z"}, "message": "alias.c (alias_set_entry_d): Add is_pointer and has_pointer.\n\n\t* alias.c (alias_set_entry_d): Add is_pointer and has_pointer.\n\t(alias_stats): Add num_universal.\n\t(alias_set_subset_of): Special case pointers; be ready for NULL\n\tchildren.\n\t(alias_sets_conflict_p): Special case pointers; be ready for NULL\n\tchildren.\n\t(init_alias_set_entry): Break out from ...\n\t(record_alias_subset): ... here; propagate new fields;\n\tallocate children only when really needed.\n\t(get_alias_set): Do less generous pointer globbing.\n\t(dump_alias_stats_in_alias_c): Update statistics.\n\t* gcc.dg/alias-8.c: Do not xfail.\n\t* gcc.dg/pr62167.c: Prevent FRE.\n\t* gcc.dg/alias-14.c: New testcase.\n\nFrom-SVN: r223883", "tree": {"sha": "3e1ec41db99dd8ff783e9dd8e15b253a16dc5db6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e1ec41db99dd8ff783e9dd8e15b253a16dc5db6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/comments", "author": null, "committer": null, "parents": [{"sha": "530141b637308c11f49f1b1c9079975f886b5ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/530141b637308c11f49f1b1c9079975f886b5ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/530141b637308c11f49f1b1c9079975f886b5ac1"}], "stats": {"total": 376, "additions": 314, "deletions": 62}, "files": [{"sha": "76992ee4a75cd107d9283c0583d3c4d89265ff33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "patch": "@@ -1,3 +1,17 @@\n+2015-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* alias.c (alias_set_entry_d): Add is_pointer and has_pointer.\n+\t(alias_stats): Add num_universal.\n+\t(alias_set_subset_of): Special case pointers; be ready for NULL\n+\tchildren.\n+\t(alias_sets_conflict_p): Special case pointers; be ready for NULL\n+\tchildren.\n+\t(init_alias_set_entry): Break out from ...\n+\t(record_alias_subset): ... here; propagate new fields;\n+\tallocate children only when really needed.\n+\t(get_alias_set): Do less generous pointer globbing.\n+\t(dump_alias_stats_in_alias_c): Update statistics.\n+\n 2015-05-30  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (split_stack_arg_pointer_used_p): Scan"}, {"sha": "68f71bf303017f2a6be14d377cc9ce18bd45732b", "filename": "gcc/alias.c", "status": "modified", "additions": 221, "deletions": 61, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "patch": "@@ -183,10 +183,6 @@ struct GTY(()) alias_set_entry_d {\n   /* The alias set number, as stored in MEM_ALIAS_SET.  */\n   alias_set_type alias_set;\n \n-  /* Nonzero if would have a child of zero: this effectively makes this\n-     alias set the same as alias set zero.  */\n-  int has_zero_child;\n-\n   /* The children of the alias set.  These are not just the immediate\n      children, but, in fact, all descendants.  So, if we have:\n \n@@ -195,6 +191,17 @@ struct GTY(()) alias_set_entry_d {\n      continuing our example above, the children here will be all of\n      `int', `double', `float', and `struct S'.  */\n   hash_map<int, int, alias_set_traits> *children;\n+\n+  /* Nonzero if would have a child of zero: this effectively makes this\n+     alias set the same as alias set zero.  */\n+  bool has_zero_child;\n+  /* Nonzero if alias set corresponds to pointer type itself (i.e. not to\n+     aggregate contaiing pointer.\n+     This is used for a special case where we need an universal pointer type\n+     compatible with all other pointer types.  */\n+  bool is_pointer;\n+  /* Nonzero if is_pointer or if one of childs have has_pointer set.  */\n+  bool has_pointer;\n };\n typedef struct alias_set_entry_d *alias_set_entry;\n \n@@ -222,6 +229,7 @@ static struct {\n   unsigned long long num_same_objects;\n   unsigned long long num_volatile;\n   unsigned long long num_dag;\n+  unsigned long long num_universal;\n   unsigned long long num_disambiguated;\n } alias_stats;\n \n@@ -454,18 +462,58 @@ mems_in_disjoint_alias_sets_p (const_rtx mem1, const_rtx mem2)\n bool\n alias_set_subset_of (alias_set_type set1, alias_set_type set2)\n {\n-  alias_set_entry ase;\n+  alias_set_entry ase2;\n \n   /* Everything is a subset of the \"aliases everything\" set.  */\n   if (set2 == 0)\n     return true;\n \n-  /* Otherwise, check if set1 is a subset of set2.  */\n-  ase = get_alias_set_entry (set2);\n-  if (ase != 0\n-      && (ase->has_zero_child\n-\t  || ase->children->get (set1)))\n+  /* Check if set1 is a subset of set2.  */\n+  ase2 = get_alias_set_entry (set2);\n+  if (ase2 != 0\n+      && (ase2->has_zero_child\n+\t  || (ase2->children && ase2->children->get (set1))))\n     return true;\n+\n+  /* As a special case we consider alias set of \"void *\" to be both subset\n+     and superset of every alias set of a pointer.  This extra symmetry does\n+     not matter for alias_sets_conflict_p but it makes aliasing_component_refs_p\n+     to return true on the following testcase:\n+\n+     void *ptr;\n+     char **ptr2=(char **)&ptr;\n+     *ptr2 = ...\n+\n+     Additionally if a set contains universal pointer, we consider every pointer\n+     to be a subset of it, but we do not represent this explicitely - doing so\n+     would require us to update transitive closure each time we introduce new\n+     pointer type.  This makes aliasing_component_refs_p to return true\n+     on the following testcase:\n+\n+     struct a {void *ptr;}\n+     char **ptr = (char **)&a.ptr;\n+     ptr = ...\n+\n+     This makes void * truly universal pointer type.  See pointer handling in\n+     get_alias_set for more details.  */\n+  if (ase2 && ase2->has_pointer)\n+    {\n+      alias_set_entry ase1 = get_alias_set_entry (set1);\n+\n+      if (ase1 && ase1->is_pointer)\n+\t{\n+          alias_set_type voidptr_set = TYPE_ALIAS_SET (ptr_type_node);\n+\t  /* If one is ptr_type_node and other is pointer, then we consider\n+ \t     them subset of each other.  */\n+\t  if (set1 == voidptr_set || set2 == voidptr_set)\n+\t    return true;\n+\t  /* If SET2 contains universal pointer's alias set, then we consdier\n+ \t     every (non-universal) pointer.  */\n+\t  if (ase2->children && set1 != voidptr_set\n+\t      && ase2->children->get (voidptr_set))\n+\t    return true;\n+\t}\n+    }\n   return false;\n }\n \n@@ -474,29 +522,68 @@ alias_set_subset_of (alias_set_type set1, alias_set_type set2)\n int\n alias_sets_conflict_p (alias_set_type set1, alias_set_type set2)\n {\n-  alias_set_entry ase;\n+  alias_set_entry ase1;\n+  alias_set_entry ase2;\n \n   /* The easy case.  */\n   if (alias_sets_must_conflict_p (set1, set2))\n     return 1;\n \n   /* See if the first alias set is a subset of the second.  */\n-  ase = get_alias_set_entry (set1);\n-  if (ase != 0\n-      && ase->children->get (set2))\n+  ase1 = get_alias_set_entry (set1);\n+  if (ase1 != 0\n+      && ase1->children && ase1->children->get (set2))\n     {\n       ++alias_stats.num_dag;\n       return 1;\n     }\n \n   /* Now do the same, but with the alias sets reversed.  */\n-  ase = get_alias_set_entry (set2);\n-  if (ase != 0\n-      && ase->children->get (set1))\n+  ase2 = get_alias_set_entry (set2);\n+  if (ase2 != 0\n+      && ase2->children && ase2->children->get (set1))\n     {\n       ++alias_stats.num_dag;\n       return 1;\n     }\n+\n+  /* We want void * to be compatible with any other pointer without\n+     really dropping it to alias set 0. Doing so would make it\n+     compatible with all non-pointer types too.\n+\n+     This is not strictly necessary by the C/C++ language\n+     standards, but avoids common type punning mistakes.  In\n+     addition to that, we need the existence of such universal\n+     pointer to implement Fortran's C_PTR type (which is defined as\n+     type compatible with all C pointers).  */\n+  if (ase1 && ase2 && ase1->has_pointer && ase2->has_pointer)\n+    {\n+      alias_set_type voidptr_set = TYPE_ALIAS_SET (ptr_type_node);\n+\n+      /* If one of the sets corresponds to universal pointer,\n+ \t we consider it to conflict with anything that is\n+\t or contains pointer.  */\n+      if (set1 == voidptr_set || set2 == voidptr_set)\n+\t{\n+\t  ++alias_stats.num_universal;\n+\t  return true;\n+\t}\n+     /* If one of sets is (non-universal) pointer and the other\n+ \tcontains universal pointer, we also get conflict.  */\n+     if (ase1->is_pointer && set2 != voidptr_set\n+\t && ase2->children && ase2->children->get (voidptr_set))\n+\t{\n+\t  ++alias_stats.num_universal;\n+\t  return true;\n+\t}\n+     if (ase2->is_pointer && set1 != voidptr_set\n+\t && ase1->children && ase1->children->get (voidptr_set))\n+\t{\n+\t  ++alias_stats.num_universal;\n+\t  return true;\n+\t}\n+    }\n+\n   ++alias_stats.num_disambiguated;\n \n   /* The two alias sets are distinct and neither one is the\n@@ -764,6 +851,22 @@ alias_ptr_types_compatible_p (tree t1, tree t2)\n \t  == TYPE_MAIN_VARIANT (TREE_TYPE (t2)));\n }\n \n+/* Create emptry alias set entry.  */\n+\n+alias_set_entry\n+init_alias_set_entry (alias_set_type set)\n+{\n+  alias_set_entry ase = ggc_alloc<alias_set_entry_d> ();\n+  ase->alias_set = set;\n+  ase->children = NULL;\n+  ase->has_zero_child = false;\n+  ase->is_pointer = false;\n+  ase->has_pointer = false;\n+  gcc_checking_assert (!get_alias_set_entry (set));\n+  (*alias_sets)[set] = ase;\n+  return ase;\n+}\n+\n /* Return the alias set for T, which may be either a type or an\n    expression.  Call language-specific routine for help, if needed.  */\n \n@@ -903,35 +1006,77 @@ get_alias_set (tree t)\n      the pointed-to types.  This issue has been reported to the\n      C++ committee.\n \n-     In addition to the above canonicalization issue, with LTO\n-     we should also canonicalize `T (*)[]' to `T *' avoiding\n-     alias issues with pointer-to element types and pointer-to\n-     array types.\n-\n-     Likewise we need to deal with the situation of incomplete\n-     pointed-to types and make `*(struct X **)&a' and\n-     `*(struct X {} **)&a' alias.  Otherwise we will have to\n-     guarantee that all pointer-to incomplete type variants\n-     will be replaced by pointer-to complete type variants if\n-     they are available.\n-\n-     With LTO the convenient situation of using `void *' to\n-     access and store any pointer type will also become\n-     more apparent (and `void *' is just another pointer-to\n-     incomplete type).  Assigning alias-set zero to `void *'\n-     and all pointer-to incomplete types is a not appealing\n-     solution.  Assigning an effective alias-set zero only\n-     affecting pointers might be - by recording proper subset\n-     relationships of all pointer alias-sets.\n-\n-     Pointer-to function types are another grey area which\n-     needs caution.  Globbing them all into one alias-set\n-     or the above effective zero set would work.\n-\n-     For now just assign the same alias-set to all pointers.\n-     That's simple and avoids all the above problems.  */\n-  else if (POINTER_TYPE_P (t)\n-\t   && t != ptr_type_node)\n+     For this reason go to canonical type of the unqalified pointer type.\n+     Until GCC 6 this code set all pointers sets to have alias set of\n+     ptr_type_node but that is a bad idea, because it prevents disabiguations\n+     in between pointers.  For Firefox this accounts about 20% of all\n+     disambiguations in the program.  */\n+  else if (POINTER_TYPE_P (t) && t != ptr_type_node && !in_lto_p)\n+    {\n+      tree p;\n+      auto_vec <bool, 8> reference;\n+\n+      /* Unnest all pointers and references.\n+         We also want to make pointer to array equivalent to pointer to its\n+         element. So skip all array types, too.  */\n+      for (p = t; POINTER_TYPE_P (p)\n+\t   || (TREE_CODE (p) == ARRAY_TYPE && !TYPE_NONALIASED_COMPONENT (p));\n+\t   p = TREE_TYPE (p))\n+\t{\n+\t  if (TREE_CODE (p) == REFERENCE_TYPE)\n+\t    reference.safe_push (true);\n+\t  if (TREE_CODE (p) == POINTER_TYPE)\n+\t    reference.safe_push (false);\n+\t}\n+      p = TYPE_MAIN_VARIANT (p);\n+\n+      /* Make void * compatible with char * and also void **.\n+\t Programs are commonly violating TBAA by this.\n+\n+\t We also make void * to conflict with every pointer\n+\t (see record_component_aliases) and thus it is safe it to use it for\n+\t pointers to types with TYPE_STRUCTURAL_EQUALITY_P.  */\n+      if (TREE_CODE (p) == VOID_TYPE || TYPE_STRUCTURAL_EQUALITY_P (p))\n+\tset = get_alias_set (ptr_type_node);\n+      else\n+\t{\n+\t  /* Rebuild pointer type from starting from canonical types using\n+\t     unqualified pointers and references only.  This way all such\n+\t     pointers will have the same alias set and will conflict with\n+\t     each other.\n+\n+\t     Most of time we already have pointers or references of a given type.\n+\t     If not we build new one just to be sure that if someone later\n+\t     (probably only middle-end can, as we should assign all alias\n+\t     classes only after finishing translation unit) builds the pointer\n+\t     type, the canonical type will match.  */\n+\t  p = TYPE_CANONICAL (p);\n+\t  while (!reference.is_empty ())\n+\t    {\n+\t      if (reference.pop ())\n+\t\tp = build_reference_type (p);\n+\t      else\n+\t\tp = build_pointer_type (p);\n+\t      p = TYPE_CANONICAL (TYPE_MAIN_VARIANT (p));\n+\t    }\n+          gcc_checking_assert (TYPE_CANONICAL (p) == p);\n+\n+\t  /* Assign the alias set to both p and t.\n+\t     We can not call get_alias_set (p) here as that would trigger\n+\t     infinite recursion when p == t.  In other cases it would just\n+\t     trigger unnecesary legwork of rebuilding the pointer again.  */\n+\t  if (TYPE_ALIAS_SET_KNOWN_P (p))\n+\t    set = TYPE_ALIAS_SET (p);\n+\t  else\n+\t    {\n+\t      set = new_alias_set ();\n+\t      TYPE_ALIAS_SET (p) = set;\n+\t    }\n+\t}\n+    }\n+  /* In LTO the rules above needs to be part of canonical type machinery.\n+     For now just punt.  */\n+  else if (POINTER_TYPE_P (t) && t != ptr_type_node && in_lto_p)\n     set = get_alias_set (ptr_type_node);\n \n   /* Otherwise make a new alias set for this type.  */\n@@ -953,6 +1098,16 @@ get_alias_set (tree t)\n   if (AGGREGATE_TYPE_P (t) || TREE_CODE (t) == COMPLEX_TYPE)\n     record_component_aliases (t);\n \n+  /* We treat pointer types specially in alias_set_subset_of.  */\n+  if (POINTER_TYPE_P (t) && set)\n+    {\n+      alias_set_entry ase = get_alias_set_entry (set);\n+      if (!ase)\n+\tase = init_alias_set_entry (set);\n+      ase->is_pointer = true;\n+      ase->has_pointer = true;\n+    }\n+\n   return set;\n }\n \n@@ -1003,30 +1158,33 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n     {\n       /* Create an entry for the SUPERSET, so that we have a place to\n \t attach the SUBSET.  */\n-      superset_entry = ggc_cleared_alloc<alias_set_entry_d> ();\n-      superset_entry->alias_set = superset;\n-      superset_entry->children\n-\t= hash_map<int, int, alias_set_traits>::create_ggc (64);\n-      superset_entry->has_zero_child = 0;\n-      (*alias_sets)[superset] = superset_entry;\n+      superset_entry = init_alias_set_entry (superset);\n     }\n \n   if (subset == 0)\n     superset_entry->has_zero_child = 1;\n   else\n     {\n       subset_entry = get_alias_set_entry (subset);\n+      if (!superset_entry->children)\n+\tsuperset_entry->children\n+\t  = hash_map<int, int, alias_set_traits>::create_ggc (64);\n       /* If there is an entry for the subset, enter all of its children\n \t (if they are not already present) as children of the SUPERSET.  */\n       if (subset_entry)\n \t{\n \t  if (subset_entry->has_zero_child)\n-\t    superset_entry->has_zero_child = 1;\n+\t    superset_entry->has_zero_child = true;\n+          if (subset_entry->has_pointer)\n+\t    superset_entry->has_pointer = true;\n \n-\t  hash_map<int, int, alias_set_traits>::iterator iter\n-\t    = subset_entry->children->begin ();\n-\t  for (; iter != subset_entry->children->end (); ++iter)\n-\t    superset_entry->children->put ((*iter).first, (*iter).second);\n+\t  if (subset_entry->children)\n+\t    {\n+\t      hash_map<int, int, alias_set_traits>::iterator iter\n+\t\t= subset_entry->children->begin ();\n+\t      for (; iter != subset_entry->children->end (); ++iter)\n+\t\tsuperset_entry->children->put ((*iter).first, (*iter).second);\n+\t    }\n \t}\n \n       /* Enter the SUBSET itself as a child of the SUPERSET.  */\n@@ -3086,13 +3244,15 @@ dump_alias_stats_in_alias_c (FILE *s)\n \t      \"               %llu queries asked about the same object\\n\"\n \t      \"               %llu queries asked about the same alias set\\n\"\n \t      \"               %llu access volatile\\n\"\n-\t      \"               %llu are dependent in the DAG\\n\",\n+\t      \"               %llu are dependent in the DAG\\n\"\n+\t      \"               %llu are aritificially in conflict with void *\\n\",\n \t   alias_stats.num_disambiguated,\n \t   alias_stats.num_alias_zero + alias_stats.num_same_alias_set\n \t   + alias_stats.num_same_objects + alias_stats.num_volatile\n-\t   + alias_stats.num_dag,\n+\t   + alias_stats.num_dag + alias_stats.num_disambiguated\n+\t   + alias_stats.num_universal,\n \t   alias_stats.num_alias_zero, alias_stats.num_same_alias_set,\n-\t   + alias_stats.num_same_objects, alias_stats.num_volatile,\n-\t   + alias_stats.num_dag);\n+\t   alias_stats.num_same_objects, alias_stats.num_volatile,\n+\t   alias_stats.num_dag, alias_stats.num_universal);\n }\n #include \"gt-alias.h\""}, {"sha": "9dea7c22d809cfd8af499811afceee02bcc97890", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "patch": "@@ -1,3 +1,9 @@\n+2015-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/alias-8.c: Do not xfail.\n+\t* gcc.dg/pr62167.c: Prevent FRE.\n+\t* gcc.dg/alias-14.c: New testcase.\n+\n 2015-05-29  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/arm/simd/vextp64_1.c: Close comment on final line."}, {"sha": "1ca1c09d5e35934aee5219bf9fc1e21a5fcaead0", "filename": "gcc/testsuite/gcc.dg/alias-14.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2Fgcc.dg%2Falias-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2Fgcc.dg%2Falias-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-14.c?ref=6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+#include <stddef.h>\n+void *a;\n+int *b;\n+struct c {void * a;} c;\n+struct d {short * a;} d;\n+\n+int *ip= (int *)(size_t)2;\n+int **ipp = &ip;\n+\n+int\n+main()\n+{\n+  float **ptr;\n+  void **uptr;\n+  int* const* cipp = (int* const*)ipp;\n+  /* as an extension we consider void * universal. Writes to it should alias.  */\n+  asm (\"\":\"=r\"(ptr):\"0\"(&a));\n+  a=NULL;\n+  *ptr=(float*)(size_t)1;\n+  if (!a)\n+    __builtin_abort ();\n+  a=NULL;\n+  if (*ptr)\n+    __builtin_abort ();\n+\n+  asm (\"\":\"=r\"(uptr):\"0\"(&b));\n+  b=NULL;\n+  *uptr=(void*)(size_t)1;\n+  if (!b)\n+    __builtin_abort ();\n+  b=NULL;\n+  if (*uptr)\n+    __builtin_abort ();\n+\n+  /* Check that we disambiguate int * and char *.  */\n+  asm (\"\":\"=r\"(ptr):\"0\"(&b));\n+  b=NULL;\n+  *ptr=(float*)(size_t)1;\n+  if (b)\n+    __builtin_abort ();\n+\n+  /* Again we should make void * in the structure conflict with any pointer.  */\n+  asm (\"\":\"=r\"(ptr):\"0\"(&c));\n+  c.a=NULL;\n+  *ptr=(float*)(size_t)1;\n+  if (!c.a)\n+    __builtin_abort ();\n+  c.a=NULL;\n+  if (*ptr)\n+    __builtin_abort ();\n+\n+  asm (\"\":\"=r\"(uptr):\"0\"(&d));\n+  d.a=NULL;\n+  *uptr=(void*)(size_t)1;\n+  if (!d.a)\n+    __builtin_abort ();\n+  d.a=NULL;\n+  if (*uptr)\n+    __builtin_abort ();\n+\n+  if ((void *)*cipp != (void*)(size_t)2)\n+    __builtin_abort ();\n+  *ipp = NULL;\n+  if (*cipp)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "b99873e213abde1b1b2f466f187a62fa4e289c54", "filename": "gcc/testsuite/gcc.dg/alias-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2Fgcc.dg%2Falias-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2Fgcc.dg%2Falias-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-8.c?ref=6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "patch": "@@ -8,5 +8,5 @@ struct s {\n void\n func(struct s *ptr)\n {\n-  *(void **)&ptr->p = 0; /* { dg-warning \"type-punned pointer\" \"\" { xfail *-*-* } } */\n+  *(void **)&ptr->p = 0; /* { dg-warning \"type-punned pointer\" \"\" { } } */\n }"}, {"sha": "7293d642d414e153a253cb1cfbced4bb4499a3cf", "filename": "gcc/testsuite/gcc.dg/pr62167.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62167.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e042ef4e2b96c07cb0f7a95635025a307a6f1be/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62167.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62167.c?ref=6e042ef4e2b96c07cb0f7a95635025a307a6f1be", "patch": "@@ -29,6 +29,8 @@ main ()\n \n   node.prev = (void *)head;\n \n+  asm(\"\":\"=m\"(node.prev));\n+\n   head->first = &node;\n \n   struct node *n = head->first;"}]}