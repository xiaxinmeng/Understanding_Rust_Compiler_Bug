{"sha": "730832cd7921eb240793634b86d3d026bba58117", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwODMyY2Q3OTIxZWIyNDA3OTM2MzRiODZkM2QwMjZiYmE1ODExNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-01-01T18:20:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-01-01T18:20:13Z"}, "message": "gimple-fold.c (get_range_strlen): Update prototype.\n\n\t* gimple-fold.c (get_range_strlen): Update prototype.\n\t(get_range_strlen_tree): Update prototype.  Drop minlen/maxlen\n\tlocal variables.  Use pdata to return information to caller.\n\tUpdate calls to get_range_strlen.  Update pdata->maxbound.\n\t(get_range_strlen -- static version): Similarly.\n\t(get_range_strlen -- extern version): Update for internal\n\tget_range_strlen API change.  Convert to external data format.\n\t(get_maxval_strlen): Similarly.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267498", "tree": {"sha": "e7ebb9ded38ac1ccf258c90a04b6b7d82a469a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7ebb9ded38ac1ccf258c90a04b6b7d82a469a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/730832cd7921eb240793634b86d3d026bba58117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/730832cd7921eb240793634b86d3d026bba58117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/730832cd7921eb240793634b86d3d026bba58117", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/730832cd7921eb240793634b86d3d026bba58117/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "976cbbe1ea4979ebada367a70a28fa7fc1bdef08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/976cbbe1ea4979ebada367a70a28fa7fc1bdef08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/976cbbe1ea4979ebada367a70a28fa7fc1bdef08"}], "stats": {"total": 137, "additions": 82, "deletions": 55}, "files": [{"sha": "29fe552f2c49ef079f6ae01ebbde410c81f28fb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730832cd7921eb240793634b86d3d026bba58117/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730832cd7921eb240793634b86d3d026bba58117/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=730832cd7921eb240793634b86d3d026bba58117", "patch": "@@ -1,3 +1,15 @@\n+2019-01-01  Martin Sebor  <msebor@redhat.com>\n+            Jeff Law  <law@redhat.com>\n+\n+\t* gimple-fold.c (get_range_strlen): Update prototype.\n+\t(get_range_strlen_tree): Update prototype.  Drop minlen/maxlen\n+\tlocal variables.  Use pdata to return information to caller.\n+\tUpdate calls to get_range_strlen.  Update pdata->maxbound.\n+\t(get_range_strlen -- static version): Similarly.\n+\t(get_range_strlen -- extern version): Update for internal\n+\tget_range_strlen API change.  Convert to external data format.\n+\t(get_maxval_strlen): Similarly.\n+\n 2019-01-01  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* coverage.c (get_coverage_counts): Use current_function_decl."}, {"sha": "5e29f79ee09d9988ef27f6ed250fcf41f121d78b", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 70, "deletions": 55, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730832cd7921eb240793634b86d3d026bba58117/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730832cd7921eb240793634b86d3d026bba58117/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=730832cd7921eb240793634b86d3d026bba58117", "patch": "@@ -83,8 +83,8 @@ enum strlen_range_kind {\n   SRK_INT_VALUE\n };\n \n-static bool get_range_strlen (tree, tree[2], bitmap *, strlen_range_kind,\n-\t\t  bool *, unsigned, tree *);\n+static bool get_range_strlen (tree, bitmap *, strlen_range_kind,\n+\t\t  c_strlen_data *, bool *, unsigned);\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -1281,16 +1281,13 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n /* Helper of get_range_strlen for ARG that is not an SSA_NAME.  */\n \n static bool\n-get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n+get_range_strlen_tree (tree arg, bitmap *visited,\n \t\t       strlen_range_kind rkind,\n-\t\t       bool *flexp, unsigned eltsize, tree *nonstr)\n+\t\t       c_strlen_data *pdata,\n+\t\t       bool *flexp, unsigned eltsize)\n {\n   gcc_assert (TREE_CODE (arg) != SSA_NAME);\n  \n-  /* The minimum and maximum length.  */\n-  tree *const minlen = length;\n-  tree *const maxlen = length + 1;\n-\n   /* The length computed by this invocation of the function.  */\n   tree val = NULL_TREE;\n \n@@ -1304,9 +1301,8 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n \t  tree aop0 = TREE_OPERAND (op, 0);\n \t  if (TREE_CODE (aop0) == INDIRECT_REF\n \t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n-\t    return get_range_strlen (TREE_OPERAND (aop0, 0), length,\n-\t\t\t\t     visited, rkind, flexp,\n-\t\t\t\t     eltsize, nonstr);\n+\t    return get_range_strlen (TREE_OPERAND (aop0, 0), visited,\n+\t\t\t\t     rkind, pdata, flexp, eltsize);\n \t}\n       else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF\n \t       && (rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2))\n@@ -1344,19 +1340,18 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n \t bubble that information up to the caller.  */\n       if (!val && lendata.decl)\n \t{\n-\t  *nonstr = lendata.decl;\n-\t  *minlen = lendata.minlen;\n-\t  *maxlen = lendata.minlen;\n+\t  pdata->decl = lendata.decl;\n+\t  pdata->minlen = lendata.minlen;\n+\t  pdata->maxlen = lendata.minlen;\n \t  return rkind == SRK_STRLEN ? false : true;\n \t}\n     }\n \n   if (!val && (rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2))\n     {\n       if (TREE_CODE (arg) == ADDR_EXPR)\n-\treturn get_range_strlen (TREE_OPERAND (arg, 0), length,\n-\t\t\t\t visited, rkind, flexp,\n-\t\t\t\t eltsize, nonstr);\n+\treturn get_range_strlen (TREE_OPERAND (arg, 0), visited, rkind,\n+\t\t\t\t pdata, flexp, eltsize);\n \n       if (TREE_CODE (arg) == ARRAY_REF)\n \t{\n@@ -1383,7 +1378,7 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n \n \t  /* Set the minimum size to zero since the string in\n \t     the array could have zero length.  */\n-\t  *minlen = ssize_int (0);\n+\t  pdata->minlen = ssize_int (0);\n \n \t  if (TREE_CODE (TREE_OPERAND (arg, 0)) == COMPONENT_REF\n \t      && optype == TREE_TYPE (TREE_OPERAND (arg, 0))\n@@ -1423,7 +1418,7 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n \n \t  /* Set the minimum size to zero since the string in\n \t     the array could have zero length.  */\n-\t  *minlen = ssize_int (0);\n+\t  pdata->minlen = ssize_int (0);\n \t}\n \n       if (VAR_P (arg))\n@@ -1444,7 +1439,7 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n \n \t      /* Set the minimum size to zero since the string in\n \t\t the array could have zero length.  */\n-\t      *minlen = ssize_int (0);\n+\t      pdata->minlen = ssize_int (0);\n \t    }\n \t}\n     }\n@@ -1453,36 +1448,57 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n     return false;\n \n   /* Adjust the lower bound on the string length as necessary.  */\n-  if (!*minlen\n+  if (!pdata->minlen\n       || (rkind != SRK_STRLEN\n-\t  && TREE_CODE (*minlen) == INTEGER_CST\n+\t  && TREE_CODE (pdata->minlen) == INTEGER_CST\n \t  && TREE_CODE (val) == INTEGER_CST\n-\t  && tree_int_cst_lt (val, *minlen)))\n-    *minlen = val;\n+\t  && tree_int_cst_lt (val, pdata->minlen)))\n+    pdata->minlen = val;\n \n-  if (*maxlen)\n+  if (pdata->maxbound)\n+    {\n+      /* Adjust the tighter (more optimistic) string length bound\n+\t if necessary and proceed to adjust the more conservative\n+\t bound.  */\n+      if (TREE_CODE (val) == INTEGER_CST)\n+\t{\n+\t  if (TREE_CODE (pdata->maxbound) == INTEGER_CST)\n+\t    {\n+\t      if (tree_int_cst_lt (pdata->maxbound, val))\n+\t\tpdata->maxbound = val;\n+\t    }\n+\t  else\n+\t    pdata->maxbound = build_all_ones_cst (size_type_node);\n+\t}\n+      else\n+\tpdata->maxbound = val;\n+    }\n+  else\n+    pdata->maxbound = val;\n+\n+  if (pdata->maxlen)\n     {\n       /* Adjust the more conservative bound if possible/necessary\n \t and fail otherwise.  */\n       if (rkind != SRK_STRLEN)\n \t{\n-\t  if (TREE_CODE (*maxlen) != INTEGER_CST\n+\t  if (TREE_CODE (pdata->maxlen) != INTEGER_CST\n \t      || TREE_CODE (val) != INTEGER_CST)\n \t    return false;\n \n-\t  if (tree_int_cst_lt (*maxlen, val))\n-\t    *maxlen = val;\n+\t  if (tree_int_cst_lt (pdata->maxlen, val))\n+\t    pdata->maxlen = val;\n \t  return true;\n \t}\n-      else if (simple_cst_equal (val, *maxlen) != 1)\n+      else if (simple_cst_equal (val, pdata->maxlen) != 1)\n \t{\n \t  /* Fail if the length of this ARG is different from that\n \t     previously determined from another ARG.  */\n \t  return false;\n \t}\n     }\n \n-  *maxlen = val;\n+  pdata->maxlen = val;\n   return true;\n }\n \n@@ -1500,14 +1516,13 @@ get_range_strlen_tree (tree arg, tree length[2], bitmap *visited,\n    Return true if *PDATA was successfully populated and false otherwise.  */\n \n static bool\n-get_range_strlen (tree arg, tree length[2], bitmap *visited,\n+get_range_strlen (tree arg, bitmap *visited,\n \t\t  strlen_range_kind rkind,\n-\t\t  bool *flexp, unsigned eltsize, tree *nonstr)\n+\t\t  c_strlen_data *pdata, bool *flexp, unsigned eltsize)\n {\n \n   if (TREE_CODE (arg) != SSA_NAME)\n-    return get_range_strlen_tree (arg, length, visited, rkind, flexp,\n-\t\t\t\t  eltsize, nonstr);\n+    return get_range_strlen_tree (arg, visited, rkind, pdata, flexp, eltsize);\n \n   /* If ARG is registered for SSA update we cannot look at its defining\n      statement.  */\n@@ -1523,9 +1538,6 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited,\n   tree var = arg;\n   gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n \n-  /* The minimum and maximum length.  */\n-  tree *const maxlen = length + 1;\n-\n   switch (gimple_code (def_stmt))\n     {\n       case GIMPLE_ASSIGN:\n@@ -1536,17 +1548,16 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited,\n             || gimple_assign_unary_nop_p (def_stmt))\n           {\n \t    tree rhs = gimple_assign_rhs1 (def_stmt);\n-\t    return get_range_strlen (rhs, length, visited, rkind, flexp,\n-\t\t\t\t     eltsize, nonstr);\n+\t    return get_range_strlen (rhs, visited, rkind, pdata, flexp, eltsize);\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n \t  {\n \t    tree ops[2] = { gimple_assign_rhs2 (def_stmt),\n \t\t\t    gimple_assign_rhs3 (def_stmt) };\n \n \t    for (unsigned int i = 0; i < 2; i++)\n-\t      if (!get_range_strlen (ops[i], length, visited, rkind,\n-\t\t\t\t     flexp, eltsize, nonstr))\n+\t      if (!get_range_strlen (ops[i], visited, rkind, pdata,\n+\t\t\t\t     flexp, eltsize))\n \t\t{\n \t\t  if (rkind != SRK_LENRANGE_2)\n \t\t    return false;\n@@ -1558,7 +1569,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited,\n \t\t     in fact zero can be determined from MAXLEN being\n \t\t     unbounded but the discovered minimum is used for\n \t\t     diagnostics.  */\n-\t\t  *maxlen = build_all_ones_cst (size_type_node);\n+\t\t  pdata->maxlen = build_all_ones_cst (size_type_node);\n \t\t}\n \t    return true;\n \t  }\n@@ -1580,8 +1591,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited,\n             if (arg == gimple_phi_result (def_stmt))\n               continue;\n \n-\t    if (!get_range_strlen (arg, length, visited, rkind, flexp,\n-\t\t\t\t   eltsize, nonstr))\n+\t    if (!get_range_strlen (arg, visited, rkind, pdata, flexp, eltsize))\n \t      {\n \t\tif (rkind != SRK_LENRANGE_2)\n \t\t  return false;\n@@ -1593,7 +1603,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited,\n \t\t   in fact zero can be determined from MAXLEN being\n \t\t   unbounded but the discovered minimum is used for\n \t\t   diagnostics.  */\n-\t\t*maxlen = build_all_ones_cst (size_type_node);\n+\t\tpdata->maxlen = build_all_ones_cst (size_type_node);\n \t      }\n           }\n         return true;\n@@ -1642,14 +1652,21 @@ get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize,\n   *nonstr = NULL_TREE;\n \n   bool flexarray = false;\n-  if (!get_range_strlen (arg, minmaxlen, &visited,\n+  c_strlen_data lendata = { };\n+  if (!get_range_strlen (arg, &visited,\n \t\t\t strict ? SRK_LENRANGE : SRK_LENRANGE_2,\n-\t\t\t &flexarray, eltsize, nonstr))\n+\t\t\t &lendata, &flexarray, eltsize))\n     {\n       minmaxlen[0] = NULL_TREE;\n       minmaxlen[1] = NULL_TREE;\n     }\n+  else\n+    {\n+      minmaxlen[0] = lendata.minlen;\n+      minmaxlen[1] = lendata.maxlen;\n+    }\n \n+  *nonstr = lendata.decl;\n   if (visited)\n     BITMAP_FREE (visited);\n \n@@ -1674,13 +1691,11 @@ get_maxval_strlen (tree arg, strlen_range_kind rkind, tree *nonstr = NULL)\n   gcc_assert (rkind != SRK_INT_VALUE || INTEGRAL_TYPE_P (TREE_TYPE (arg)));\n \n   bitmap visited = NULL;\n-  tree len[2] = { NULL_TREE, NULL_TREE };\n \n   bool dummy;\n-  /* Set to non-null if ARG refers to an untermianted array.  */\n-  tree mynonstr = NULL_TREE;\n-  if (!get_range_strlen (arg, len, &visited, rkind, &dummy, 1, &mynonstr))\n-    len[1] = NULL_TREE;\n+  c_strlen_data lendata = { };\n+  if (!get_range_strlen (arg, &visited, rkind, &lendata, &dummy, 1))\n+    lendata.maxlen = NULL_TREE;\n   if (visited)\n     BITMAP_FREE (visited);\n \n@@ -1689,12 +1704,12 @@ get_maxval_strlen (tree arg, strlen_range_kind rkind, tree *nonstr = NULL)\n       /* For callers prepared to handle unterminated arrays set\n \t *NONSTR to point to the declaration of the array and return\n \t the maximum length/size. */\n-      *nonstr = mynonstr;\n-      return len[1];\n+      *nonstr = lendata.decl;\n+      return lendata.maxlen;\n     }\n \n   /* Fail if the constant array isn't nul-terminated.  */\n-  return mynonstr ? NULL_TREE : len[1];\n+  return lendata.decl ? NULL_TREE : lendata.maxlen;\n }\n \n "}]}