{"sha": "cfbe3efe4518a3f9784fc350082561ba1882b422", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZiZTNlZmU0NTE4YTNmOTc4NGZjMzUwMDgyNTYxYmExODgyYjQyMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-02-13T11:19:09Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-02-13T11:19:09Z"}, "message": "cfgloopanal.c (mark_irreducible_loops): Rewriten.\n\n\t* cfgloopanal.c (mark_irreducible_loops): Rewriten.\n\t(struct edge, struct vertex, struct graph): New.\n\t(dump_graph, new_graph, add_edge, dfs, check_irred, for_each_edge,\n\tfree_graph): New functions.\n\nFrom-SVN: r77755", "tree": {"sha": "2b810f5e9aafc2e39d4f87e841719f3a73a35d39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b810f5e9aafc2e39d4f87e841719f3a73a35d39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfbe3efe4518a3f9784fc350082561ba1882b422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbe3efe4518a3f9784fc350082561ba1882b422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfbe3efe4518a3f9784fc350082561ba1882b422", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbe3efe4518a3f9784fc350082561ba1882b422/comments", "author": null, "committer": null, "parents": [{"sha": "5bd61841e40632387d9ec3ab809f6a0f715181bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bd61841e40632387d9ec3ab809f6a0f715181bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bd61841e40632387d9ec3ab809f6a0f715181bf"}], "stats": {"total": 412, "additions": 263, "deletions": 149}, "files": [{"sha": "6085a4245bf2b78574dba718fbcf6d648847ff90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbe3efe4518a3f9784fc350082561ba1882b422/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbe3efe4518a3f9784fc350082561ba1882b422/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfbe3efe4518a3f9784fc350082561ba1882b422", "patch": "@@ -1,3 +1,10 @@\n+2004-02-13  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloopanal.c (mark_irreducible_loops): Rewriten.\n+\t(struct edge, struct vertex, struct graph): New.\n+\t(dump_graph, new_graph, add_edge, dfs, check_irred, for_each_edge,\n+\tfree_graph): New functions.\n+\n 2004-02-12  Chris Demetriou  <cgd@broadcom.com>\n \n \t* config/mips/mips.md (casesi_internal, casesi_internal_di):"}, {"sha": "1ba2b07319c96a62b98d24aa6fdb0247e1ef1eca", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 256, "deletions": 149, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbe3efe4518a3f9784fc350082561ba1882b422/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbe3efe4518a3f9784fc350082561ba1882b422/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=cfbe3efe4518a3f9784fc350082561ba1882b422", "patch": "@@ -1111,21 +1111,230 @@ simple_loop_p (struct loop *loop, struct loop_desc *desc)\n   return any;\n }\n \n+/* Structure representing edge of a graph.  */\n+\n+struct edge\n+{\n+  int src, dest;\t/* Source and destination.  */\n+  struct edge *pred_next, *succ_next;\n+\t\t\t/* Next edge in predecessor and successor lists.  */\n+  void *data;\t\t/* Data attached to the edge.  */\n+};\n+\n+/* Structure representing vertex of a graph.  */\n+\n+struct vertex\n+{\n+  struct edge *pred, *succ;\n+\t\t\t/* Lists of predecessors and successors.  */\n+  int component;\t/* Number of dfs restarts before reaching the\n+\t\t\t   vertex.  */\n+  int post;\t\t/* Postorder number.  */\n+};\n+\n+/* Structure representing a graph.  */\n+\n+struct graph\n+{\n+  int n_vertices;\t/* Number of vertices.  */\n+  struct vertex *vertices;\n+\t\t\t/* The vertices.  */\n+};\n+\n+/* Dumps graph G into F.  */\n+\n+extern void dump_graph (FILE *, struct graph *);\n+void dump_graph (FILE *f, struct graph *g)\n+{\n+  int i;\n+  struct edge *e;\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      if (!g->vertices[i].pred\n+\t  && !g->vertices[i].succ)\n+\tcontinue;\n+\n+      fprintf (f, \"%d (%d)\\t<-\", i, g->vertices[i].component);\n+      for (e = g->vertices[i].pred; e; e = e->pred_next)\n+\tfprintf (f, \" %d\", e->src);\n+      fprintf (f, \"\\n\");\n+\n+      fprintf (f, \"\\t->\");\n+      for (e = g->vertices[i].succ; e; e = e->succ_next)\n+\tfprintf (f, \" %d\", e->dest);\n+      fprintf (f, \"\\n\");\n+    }\n+}\n+\n+/* Creates a new graph with N_VERTICES vertices.  */\n+\n+static struct graph *\n+new_graph (int n_vertices)\n+{\n+  struct graph *g = xmalloc (sizeof (struct graph));\n+\n+  g->n_vertices = n_vertices;\n+  g->vertices = xcalloc (n_vertices, sizeof (struct vertex));\n+\n+  return g;\n+}\n+\n+/* Adds an edge from F to T to graph G, with DATA attached.  */\n+\n+static void\n+add_edge (struct graph *g, int f, int t, void *data)\n+{\n+  struct edge *e = xmalloc (sizeof (struct edge));\n+\n+  e->src = f;\n+  e->dest = t;\n+  e->data = data;\n+\n+  e->pred_next = g->vertices[t].pred;\n+  g->vertices[t].pred = e;\n+\n+  e->succ_next = g->vertices[f].succ;\n+  g->vertices[f].succ = e;\n+}\n+\n+/* Runs dfs search over vertices of G, from NQ vertices in queue QS.\n+   The vertices in postorder are stored into QT.  If FORWARD is false,\n+   backward dfs is run.  */\n+\n+static void\n+dfs (struct graph *g, int *qs, int nq, int *qt, bool forward)\n+{\n+  int i, tick = 0, v, comp = 0, top;\n+  struct edge *e;\n+  struct edge **stack = xmalloc (sizeof (struct edge *) * g->n_vertices);\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      g->vertices[i].component = -1;\n+      g->vertices[i].post = -1;\n+    }\n+\n+#define FST_EDGE(V) (forward ? g->vertices[(V)].succ : g->vertices[(V)].pred)\n+#define NEXT_EDGE(E) (forward ? (E)->succ_next : (E)->pred_next)\n+#define EDGE_SRC(E) (forward ? (E)->src : (E)->dest)\n+#define EDGE_DEST(E) (forward ? (E)->dest : (E)->src)\n+\n+  for (i = 0; i < nq; i++)\n+    {\n+      v = qs[i];\n+      if (g->vertices[v].post != -1)\n+\tcontinue;\n+\n+      g->vertices[v].component = comp++;\n+      e = FST_EDGE (v);\n+      top = 0;\n+\n+      while (1)\n+\t{\n+\t  while (e && g->vertices[EDGE_DEST (e)].component != -1)\n+\t    e = NEXT_EDGE (e);\n+\n+\t  if (!e)\n+\t    {\n+\t      if (qt)\n+\t\tqt[tick] = v;\n+ \t      g->vertices[v].post = tick++;\n+\n+\t      if (!top)\n+\t\tbreak;\n+\n+\t      e = stack[--top];\n+\t      v = EDGE_SRC (e);\n+\t      e = NEXT_EDGE (e);\n+\t      continue;\n+\t    }\n+\n+\t  stack[top++] = e;\n+\t  v = EDGE_DEST (e);\n+\t  e = FST_EDGE (v);\n+\t  g->vertices[v].component = comp - 1;\n+\t}\n+    }\n+\n+  free (stack);\n+}\n+\n+/* Marks the edge E in graph G irreducible if it connects two vertices in the\n+   same scc.  */\n+\n+static void\n+check_irred (struct graph *g, struct edge *e)\n+{\n+  edge real = e->data;\n+\n+  /* All edges should lead from a component with higher number to the\n+     one with lower one.  */\n+  if (g->vertices[e->src].component < g->vertices[e->dest].component)\n+    abort ();\n+\n+  if (g->vertices[e->src].component != g->vertices[e->dest].component)\n+    return;\n+\n+  real->flags |= EDGE_IRREDUCIBLE_LOOP;\n+  if (flow_bb_inside_loop_p (real->src->loop_father, real->dest))\n+    real->src->flags |= BB_IRREDUCIBLE_LOOP;\n+}\n+\n+/* Runs CALLBACK for all edges in G.  */\n+\n+static void\n+for_each_edge (struct graph *g,\n+\t       void (callback) (struct graph *, struct edge *))\n+{\n+  struct edge *e;\n+  int i;\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    for (e = g->vertices[i].succ; e; e = e->succ_next)\n+      callback (g, e);\n+}\n+\n+/* Releases the memory occupied by G.  */\n+\n+static void\n+free_graph (struct graph *g)\n+{\n+  struct edge *e, *n;\n+  int i;\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    for (e = g->vertices[i].succ; e; e = n)\n+      {\n+\tn = e->succ_next;\n+\tfree (e);\n+      }\n+  free (g->vertices);\n+  free (g);\n+}\n+\n /* Marks blocks and edges that are part of non-recognized loops; i.e. we\n    throw away all latch edges and mark blocks inside any remaining cycle.\n    Everything is a bit complicated due to fact we do not want to do this\n    for parts of cycles that only \"pass\" through some loop -- i.e. for\n    each cycle, we want to mark blocks that belong directly to innermost\n-   loop containing the whole cycle.  */\n+   loop containing the whole cycle.\n+   \n+   LOOPS is the loop tree.  */\n+\n+#define LOOP_REPR(LOOP) ((LOOP)->num + last_basic_block)\n+#define BB_REPR(BB) ((BB)->index + 1)\n+\n void\n mark_irreducible_loops (struct loops *loops)\n {\n-  int *dfs_in, *closed, *mr, *mri, *n_edges, *stack;\n-  unsigned i;\n-  edge **edges, e;\n-  edge *estack;\n   basic_block act;\n-  int stack_top, tick, depth;\n+  edge e;\n+  int i, src, dest;\n+  struct graph *g;\n+  int *queue1 = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  int *queue2 = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n+  int nq, depth;\n   struct loop *cloop;\n \n   /* Reset the flags.  */\n@@ -1136,176 +1345,74 @@ mark_irreducible_loops (struct loops *loops)\n \te->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n     }\n \n-  /* The first last_basic_block + 1 entries are for real blocks (including\n-     entry); then we have loops->num - 1 fake blocks for loops to that we\n-     assign edges leading from loops (fake loop 0 is not interesting).  */\n-  dfs_in = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n-  closed = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n-  mr = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n-  mri = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n-  n_edges = xmalloc ((last_basic_block + loops->num) * sizeof (int));\n-  edges = xmalloc ((last_basic_block + loops->num) * sizeof (edge *));\n-  stack = xmalloc ((n_basic_blocks + loops->num) * sizeof (int));\n-  estack = xmalloc ((n_basic_blocks + loops->num) * sizeof (edge));\n-\n   /* Create the edge lists.  */\n-  for (i = 0; i < last_basic_block + loops->num; i++)\n-    n_edges[i] = 0;\n+  g = new_graph (last_basic_block + loops->num);\n+\n   FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     for (e = act->succ; e; e = e->succ_next)\n       {\n         /* Ignore edges to exit.  */\n         if (e->dest == EXIT_BLOCK_PTR)\n \t  continue;\n+\n \t/* And latch edges.  */\n \tif (e->dest->loop_father->header == e->dest\n \t    && e->dest->loop_father->latch == act)\n \t  continue;\n+\n \t/* Edges inside a single loop should be left where they are.  Edges\n \t   to subloop headers should lead to representative of the subloop,\n-\t   but from the same place.  */\n-\tif (act->loop_father == e->dest->loop_father\n-\t    || act->loop_father == e->dest->loop_father->outer)\n-\t  {\n-\t    n_edges[act->index + 1]++;\n-\t    continue;\n-\t  }\n-\t/* Edges exiting loops remain.  They should lead from representative\n+\t   but from the same place.\n+\n+\t   Edges exiting loops should lead from representative\n \t   of the son of nearest common ancestor of the loops in that\n \t   act lays.  */\n-\tdepth = find_common_loop (act->loop_father, e->dest->loop_father)->depth + 1;\n-\tif (depth == act->loop_father->depth)\n-\t  cloop = act->loop_father;\n-\telse\n-\t  cloop = act->loop_father->pred[depth];\n-\tn_edges[cloop->num + last_basic_block]++;\n-      }\n \n-  for (i = 0; i < last_basic_block + loops->num; i++)\n-    {\n-      edges[i] = xmalloc (n_edges[i] * sizeof (edge));\n-      n_edges[i] = 0;\n-    }\n+\tsrc = BB_REPR (act);\n+\tdest = BB_REPR (e->dest);\n \n-  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n-    for (e = act->succ; e; e = e->succ_next)\n-      {\n-        if (e->dest == EXIT_BLOCK_PTR)\n-\t  continue;\n-\tif (e->dest->loop_father->header == e->dest\n-\t    && e->dest->loop_father->latch == act)\n-\t  continue;\n-\tif (act->loop_father == e->dest->loop_father\n-\t    || act->loop_father == e->dest->loop_father->outer)\n+\tif (e->dest->loop_father->header == e->dest)\n+\t  dest = LOOP_REPR (e->dest->loop_father);\n+\n+\tif (!flow_bb_inside_loop_p (act->loop_father, e->dest))\n \t  {\n-\t    edges[act->index + 1][n_edges[act->index + 1]++] = e;\n-\t    continue;\n+\t    depth = find_common_loop (act->loop_father,\n+\t\t\t\t      e->dest->loop_father)->depth + 1;\n+\t    if (depth == act->loop_father->depth)\n+\t      cloop = act->loop_father;\n+\t    else\n+\t      cloop = act->loop_father->pred[depth];\n+\n+\t    src = LOOP_REPR (cloop);\n \t  }\n-\tdepth = find_common_loop (act->loop_father, e->dest->loop_father)->depth + 1;\n-\tif (depth == act->loop_father->depth)\n-\t  cloop = act->loop_father;\n-\telse\n-\t  cloop = act->loop_father->pred[depth];\n-\ti = cloop->num + last_basic_block;\n-\tedges[i][n_edges[i]++] = e;\n+\n+\tadd_edge (g, src, dest, e);\n       }\n \n-  /* Compute dfs numbering, starting from loop headers, and mark found\n-     loops.  */\n-  tick = 0;\n-  for (i = 0; i < last_basic_block + loops->num; i++)\n+  /* Find the strongly connected components.  Use the algorithm of Tarjan --\n+     first determine the postorder dfs numbering in reversed graph, then\n+     run the dfs on the original graph in the order given by decreasing\n+     numbers assigned by the previous pass.  */\n+  nq = 0;\n+  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      dfs_in[i] = -1;\n-      closed[i] = 0;\n-      mr[i] = last_basic_block + loops->num;\n-      mri[i] = -1;\n+      queue1[nq++] = BB_REPR (act);\n     }\n-\n-  stack_top = 0;\n-  for (i = 0; i < loops->num; i++)\n+  for (i = 1; i < (int) loops->num; i++)\n     if (loops->parray[i])\n-      {\n-\tstack[stack_top] = loops->parray[i]->header->index + 1;\n-\testack[stack_top] = NULL;\n-\tstack_top++;\n-      }\n+      queue1[nq++] = LOOP_REPR (loops->parray[i]);\n+  dfs (g, queue1, nq, queue2, false);\n+  for (i = 0; i < nq; i++)\n+    queue1[i] = queue2[nq - i - 1];\n+  dfs (g, queue1, nq, NULL, true);\n \n-  while (stack_top)\n-    {\n-      int idx, sidx;\n+  /* Mark the irreducible loops.  */\n+  for_each_edge (g, check_irred);\n \n-      idx = stack[stack_top - 1];\n-      if (dfs_in[idx] < 0)\n-\tdfs_in[idx] = tick++;\n+  free_graph (g);\n+  free (queue1);\n+  free (queue2);\n \n-      while (n_edges[idx])\n-\t{\n-\t  e = edges[idx][--n_edges[idx]];\n-\t  sidx = e->dest->loop_father->header == e->dest\n-\t           ? e->dest->loop_father->num + last_basic_block\n-\t           : e->dest->index + 1;\n-          if (closed[sidx])\n-\t    {\n-\t      if (mri[sidx] != -1 && !closed[mri[sidx]])\n-\t\t{\n-\t\t  if (mr[sidx] < mr[idx])\n-\t\t    {\n-\t\t      mr[idx] = mr[sidx];\n-\t\t      mri[idx] = mri[sidx];\n-\t\t    }\n-\n-\t\t  if (mr[sidx] <= dfs_in[idx])\n-\t\t    e->flags |= EDGE_IRREDUCIBLE_LOOP;\n-\t\t}\n-\t      continue;\n-\t    }\n-\t  if (dfs_in[sidx] < 0)\n-\t    {\n-\t      stack[stack_top] = sidx;\n-\t      estack[stack_top] = e;\n-\t      stack_top++;\n-\t      goto next;\n-\t    }\n-\t  if (dfs_in[sidx] < mr[idx])\n-\t    {\n-\t      mr[idx] = dfs_in[sidx];\n-\t      mri[idx] = sidx;\n-\t    }\n-\t  e->flags |= EDGE_IRREDUCIBLE_LOOP;\n-\t}\n-\n-      /* Return back.  */\n-      closed[idx] = 1;\n-      e = estack[stack_top - 1];\n-      stack_top--;\n-      if (e)\n-        {\n-\t  /* Propagate information back.  */\n-\t  sidx = stack[stack_top - 1];\n-\t  if (mr[sidx] > mr[idx])\n-\t    {\n-\t      mr[sidx] = mr[idx];\n-\t      mri[sidx] = mri[idx];\n-\t    }\n-\t  if (mr[idx] <= dfs_in[sidx])\n-\t    e->flags |= EDGE_IRREDUCIBLE_LOOP;\n-\t}\n-      /* Mark the block if relevant.  */\n-      if (idx && idx <= last_basic_block && mr[idx] <= dfs_in[idx])\n-        BASIC_BLOCK (idx - 1)->flags |= BB_IRREDUCIBLE_LOOP;\n-next:;\n-    }\n-\n-  free (stack);\n-  free (estack);\n-  free (dfs_in);\n-  free (closed);\n-  free (mr);\n-  free (mri);\n-  for (i = 0; i < last_basic_block + loops->num; i++)\n-    free (edges[i]);\n-  free (edges);\n-  free (n_edges);\n   loops->state |= LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n }\n "}]}