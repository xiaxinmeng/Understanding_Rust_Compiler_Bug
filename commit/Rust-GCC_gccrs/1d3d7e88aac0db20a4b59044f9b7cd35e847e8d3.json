{"sha": "1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "node_id": "C_kwDOANBUbNoAKDFkM2Q3ZTg4YWFjMGRiMjBhNGI1OTA0NGY5YjdjZDM1ZTg0N2U4ZDM", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-09T17:20:06Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-13T14:42:52Z"}, "message": "Add a return value to intersect and speed it up.\n\nReturn true if the intersection of ranges changed the original value.\nSpeed up the case when there is no change by calling an efficient\ncontains routine.\n\n\t* value-range.cc (irange::legacy_verbose_intersect): Add return value.\n\t(irange::irange_contains_p): New.\n\t(irange::irange_intersect): Add return value.\n\t* value-range.h (class irange): Adjust prototypes.", "tree": {"sha": "931a3a72b17c8f3e164180cee85c5c336c966604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/931a3a72b17c8f3e164180cee85c5c336c966604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3/comments", "author": null, "committer": null, "parents": [{"sha": "98e475a8f58ca3ba6e9bd5c9276efce4236f5d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e475a8f58ca3ba6e9bd5c9276efce4236f5d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e475a8f58ca3ba6e9bd5c9276efce4236f5d26"}], "stats": {"total": 108, "additions": 84, "deletions": 24}, "files": [{"sha": "190d7fb6f2246c587f7b23cd596d9ec05c3e45bf", "filename": "gcc/value-range.cc", "status": "modified", "additions": 76, "deletions": 18, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "patch": "@@ -1481,7 +1481,7 @@ irange::legacy_verbose_union_ (const irange *other)\n     irange_union (*other);\n }\n \n-void\n+bool\n irange::legacy_verbose_intersect (const irange *other)\n {\n   if (legacy_mode_p ())\n@@ -1490,7 +1490,7 @@ irange::legacy_verbose_intersect (const irange *other)\n \t{\n \t  int_range<1> tmp = *other;\n \t  legacy_intersect (this, &tmp);\n-\t  return;\n+\t  return true;\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1509,17 +1509,17 @@ irange::legacy_verbose_intersect (const irange *other)\n \t  dump_value_range (dump_file, this);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n-      return;\n+      return true;\n     }\n \n   if (other->legacy_mode_p ())\n     {\n       int_range<2> wider;\n       wider = *other;\n-      irange_intersect (wider);\n+      return irange_intersect (wider);\n     }\n   else\n-    irange_intersect (*other);\n+    return irange_intersect (*other);\n }\n \n // union_ for multi-ranges.\n@@ -1630,34 +1630,80 @@ irange::irange_union (const irange &r)\n     verify_range ();\n }\n \n-// intersect for multi-ranges.\n+// Return TRUE if THIS fully contains R.  No undefined or varying cases.\n \n-void\n+bool\n+irange::irange_contains_p (const irange &r) const\n+{\n+  gcc_checking_assert (!undefined_p () && !varying_p ());\n+  gcc_checking_assert (!r.undefined_p () && !varying_p ());\n+\n+  // In order for THIS to fully contain R, all of the pairs within R must\n+  // be fully contained by the pairs in this object.\n+  signop sign = TYPE_SIGN (TREE_TYPE(m_base[0]));\n+  unsigned ri = 0;\n+  unsigned i = 0;\n+  tree rl = r.m_base[0];\n+  tree ru = r.m_base[1];\n+  tree l = m_base[0];\n+  tree u = m_base[1];\n+  while (1)\n+    {\n+      // If r is contained within this range, move to the next R\n+      if (wi::ge_p (wi::to_wide (rl), wi::to_wide (l), sign)\n+\t  && wi::le_p (wi::to_wide (ru), wi::to_wide (u), sign))\n+\t{\n+\t  // This pair is OK, Either done, or bump to the next.\n+\t  if (++ri >= r.num_pairs ())\n+\t    return true;\n+\t  rl = r.m_base[ri * 2];\n+\t  ru = r.m_base[ri * 2 + 1];\n+\t  continue;\n+\t}\n+      // Otherwise, check if this's pair occurs before R's.\n+      if (wi::lt_p (wi::to_wide (u), wi::to_wide (rl), sign))\n+\t{\n+\t  // THere's still at leats one pair of R left.\n+\t  if (++i >= num_pairs ())\n+\t    return false;\n+\t  l = m_base[i * 2];\n+\t  u = m_base[i * 2 + 1];\n+\t  continue;\n+\t}\n+      return false;\n+    }\n+  return false;\n+}\n+\n+\n+// Intersect for multi-ranges.  Return TRUE if anything changes.\n+\n+bool\n irange::irange_intersect (const irange &r)\n {\n   gcc_checking_assert (!legacy_mode_p () && !r.legacy_mode_p ());\n   gcc_checking_assert (undefined_p () || r.undefined_p ()\n \t\t       || range_compatible_p (type (), r.type ()));\n \n   if (undefined_p () || r.varying_p ())\n-    return;\n+    return false;\n   if (r.undefined_p ())\n     {\n       set_undefined ();\n-      return;\n+      return true;\n     }\n   if (varying_p ())\n     {\n       operator= (r);\n-      return;\n+      return true;\n     }\n \n   if (r.num_pairs () == 1)\n-   {\n-     // R cannot be undefined, use more efficent pair routine.\n-     intersect (r.lower_bound(), r.upper_bound ());\n-     return;\n-   }\n+    return intersect (r.lower_bound (), r.upper_bound ());\n+\n+  // If R fully contains this, then intersection will change nothing.\n+  if (r.irange_contains_p (*this))\n+    return false;\n \n   signop sign = TYPE_SIGN (TREE_TYPE(m_base[0]));\n   unsigned bld_pair = 0;\n@@ -1732,21 +1778,25 @@ irange::irange_intersect (const irange &r)\n \n   if (flag_checking)\n     verify_range ();\n+\n+  return true;\n }\n \n+\n // Multirange intersect for a specified wide_int [lb, ub] range.\n+// Return TRUE if intersect changed anything.\n \n-void\n+bool\n irange::intersect (const wide_int& lb, const wide_int& ub)\n {\n   // Undefined remains undefined.\n   if (undefined_p ())\n-    return;\n+    return false;\n \n   if (legacy_mode_p ())\n     {\n       intersect (int_range<1> (type (), lb, ub));\n-      return;\n+      return true;\n     }\n \n   tree range_type = type();\n@@ -1755,6 +1805,11 @@ irange::intersect (const wide_int& lb, const wide_int& ub)\n   gcc_checking_assert (TYPE_PRECISION (range_type) == wi::get_precision (lb));\n   gcc_checking_assert (TYPE_PRECISION (range_type) == wi::get_precision (ub));\n \n+  // If this range is fuly contained, then intersection will do nothing.\n+  if (wi::ge_p (lower_bound (), lb, sign)\n+      && wi::le_p (upper_bound (), ub, sign))\n+    return false;\n+\n   unsigned bld_index = 0;\n   unsigned pair_lim = num_pairs ();\n   for (unsigned i = 0; i < pair_lim; i++)\n@@ -1793,7 +1848,10 @@ irange::intersect (const wide_int& lb, const wide_int& ub)\n \n   if (flag_checking)\n     verify_range ();\n+  return true;\n }\n+\n+\n // Signed 1-bits are strange.  You can't subtract 1, because you can't\n // represent the number 1.  This works around that for the invert routine.\n "}, {"sha": "419860247fcc9ff0551e315898885c7b0bd00bfe", "filename": "gcc/value-range.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "patch": "@@ -72,7 +72,7 @@ class GTY((user)) irange\n \n   // In-place operators.\n   void union_ (const irange &);\n-  void intersect (const irange &);\n+  bool intersect (const irange &);\n   void invert ();\n \n   // Operator overloads.\n@@ -97,7 +97,7 @@ class GTY((user)) irange\n   void set (tree);\t\t\t\t// DEPRECATED\n   bool equal_p (const irange &) const;\t\t// DEPRECATED\n   void legacy_verbose_union_ (const class irange *);\t// DEPRECATED\n-  void legacy_verbose_intersect (const irange *);\t// DEPRECATED\n+  bool legacy_verbose_intersect (const irange *);\t// DEPRECATED\n \n protected:\n   irange (tree *, unsigned);\n@@ -108,9 +108,10 @@ class GTY((user)) irange\n \n    // In-place operators.\n   void irange_union (const irange &);\n-  void irange_intersect (const irange &);\n+  bool irange_intersect (const irange &);\n   void irange_set (tree, tree);\n   void irange_set_anti_range (tree, tree);\n+  bool irange_contains_p (const irange &) const;\n \n   void normalize_kind ();\n \n@@ -134,7 +135,7 @@ class GTY((user)) irange\n   void irange_set_1bit_anti_range (tree, tree);\n   bool varying_compatible_p () const;\n \n-  void intersect (const wide_int& lb, const wide_int& ub);\n+  bool intersect (const wide_int& lb, const wide_int& ub);\n   unsigned char m_num_ranges;\n   unsigned char m_max_ranges;\n   ENUM_BITFIELD(value_range_kind) m_kind : 8;\n@@ -553,13 +554,14 @@ irange::union_ (const irange &r)\n   dump_flags = m_flags;\n }\n \n-inline void\n+inline bool\n irange::intersect (const irange &r)\n {\n   dump_flags_t m_flags = dump_flags;\n   dump_flags &= ~TDF_DETAILS;\n-  irange::legacy_verbose_intersect (&r);\n+  bool ret = irange::legacy_verbose_intersect (&r);\n   dump_flags = m_flags;\n+  return ret;\n }\n \n // Set value range VR to a nonzero range of type TYPE."}]}