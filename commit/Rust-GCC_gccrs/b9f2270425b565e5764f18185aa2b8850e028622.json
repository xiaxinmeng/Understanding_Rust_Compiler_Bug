{"sha": "b9f2270425b565e5764f18185aa2b8850e028622", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlmMjI3MDQyNWI1NjVlNTc2NGYxODE4NWFhMmI4ODUwZTAyODYyMg==", "commit": {"author": {"name": "Jan van Male", "email": "jan.vanmale@fenk.wau.nl", "date": "2001-08-08T20:32:31Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-08-08T20:32:31Z"}, "message": "emit-rtl.c (adjust_address, [...]): Cast offset to unsigned HOST_WIDE_INT to avoid warning.\n\n2001-08-08  Jan van Male <jan.vanmale@fenk.wau.nl>\n\n        * emit-rtl.c (adjust_address, adjust_address_nv): Cast offset to\n        unsigned HOST_WIDE_INT to avoid warning.\n        * final.c (final): Cast INSN_UID to unsigned to avoid warning.\n        * flow.c (set_block_for_new_insns): Likewise.\n\nFrom-SVN: r44724", "tree": {"sha": "14c8e489d6e8d46e8959175feeaa96a9151c0247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14c8e489d6e8d46e8959175feeaa96a9151c0247"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9f2270425b565e5764f18185aa2b8850e028622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f2270425b565e5764f18185aa2b8850e028622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f2270425b565e5764f18185aa2b8850e028622", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f2270425b565e5764f18185aa2b8850e028622/comments", "author": null, "committer": null, "parents": [{"sha": "a4b07e7ff898a61497d248c67d6540cd7067305b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b07e7ff898a61497d248c67d6540cd7067305b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4b07e7ff898a61497d248c67d6540cd7067305b"}], "stats": {"total": 75, "additions": 42, "deletions": 33}, "files": [{"sha": "75fc2fdd4b962547d1777cde70bff596b06256c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9f2270425b565e5764f18185aa2b8850e028622", "patch": "@@ -1,3 +1,10 @@\n+2001-08-08  Jan van Male <jan.vanmale@fenk.wau.nl>\n+\n+        * emit-rtl.c (adjust_address, adjust_address_nv): Cast offset to\n+\tunsigned HOST_WIDE_INT to avoid warning.\n+        * final.c (final): Cast INSN_UID to unsigned to avoid warning.\n+        * flow.c (set_block_for_new_insns): Likewise.\n+\n Wed Aug  8 21:08:14 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* sibcall.c (return_value_pseudo): New static variable.\n@@ -93,7 +100,7 @@ Wed Aug  8 18:01:58 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* config/ia64/ia64.md (cond_opsi2_internal, cond_opsi2_internal_b):\n \tTurn into define_insn_and_split.\n-\t\n+\n \t* sched-deps.c: Include \"cselib.h\".\n \t(add_insn_mem_dependence, sched_analyze_1, sched_analyze_2):\n \tUse cselib to turn memory addresses into VALUEs.\n@@ -107,7 +114,7 @@ Wed Aug  8 18:01:58 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t* cselib.c (cselib_subst_to_values): No longer static.  Allow MEMs\n \tthat have no value and autoincs to be handled by generating a new\n \tdummy value.\n-\t\n+\n 2001-08-08  Graham Stott  <grahams@redhat.com>\n \n \t* final.c (shorten_branches): Update the INSN_ADDRESSES of insns"}, {"sha": "755527fa3af04b1aeab0b2148338331202897201", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b9f2270425b565e5764f18185aa2b8850e028622", "patch": "@@ -1643,7 +1643,8 @@ adjust_address (memref, mode, offset)\n      object, we can merge it into the LO_SUM.  */\n   if (GET_MODE (memref) != BLKmode && GET_CODE (addr) == LO_SUM\n       && offset >= 0\n-      && offset < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n+      && (unsigned HOST_WIDE_INT) offset\n+         < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n     addr = gen_rtx_LO_SUM (mode, XEXP (addr, 0),\n \t\t\t   plus_constant (XEXP (addr, 1), offset));\n   else\n@@ -1668,7 +1669,8 @@ adjust_address_nv (memref, mode, offset)\n      object, we can merge it into the LO_SUM.  */\n   if (GET_MODE (memref) != BLKmode && GET_CODE (addr) == LO_SUM\n       && offset >= 0\n-      && offset < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n+      && (unsigned HOST_WIDE_INT) offset\n+         < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n     addr = gen_rtx_LO_SUM (mode, XEXP (addr, 0),\n \t\t\t   plus_constant (XEXP (addr, 1), offset));\n   else"}, {"sha": "d32248196a0066c1045a5b4e90766203d6c2e670", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b9f2270425b565e5764f18185aa2b8850e028622", "patch": "@@ -526,7 +526,7 @@ end_final (filename)\n }\n \n /* Default target function prologue and epilogue assembler output.\n-  \n+\n    If not overridden for epilogue code, then the function body itself\n    contains return instructions wherever needed.  */\n void\n@@ -918,7 +918,7 @@ insn_current_reference_address (branch)\n     return insn_current_address;\n   dest = JUMP_LABEL (branch);\n \n-  /* BRANCH has no proper alignment chain set, so use SEQ.  \n+  /* BRANCH has no proper alignment chain set, so use SEQ.\n      BRANCH also has no INSN_SHUID.  */\n   if (INSN_SHUID (seq) < INSN_SHUID (dest))\n     {\n@@ -1938,7 +1938,7 @@ final (first, file, optimize, prescan)\n   for (insn = NEXT_INSN (first); insn;)\n     {\n #ifdef HAVE_ATTR_length\n-      if (INSN_UID (insn) >= INSN_ADDRESSES_SIZE ())\n+      if ((unsigned) INSN_UID (insn) >= INSN_ADDRESSES_SIZE ())\n \t{\n #ifdef STACK_REGS\n \t  /* Irritatingly, the reg-stack pass is creating new instructions\n@@ -2057,12 +2057,12 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  break;\n \n \tcase NOTE_INSN_PROLOGUE_END:\n-\t  (*targetm.asm_out.function_end_prologue) (file);\t     \n+\t  (*targetm.asm_out.function_end_prologue) (file);\n \t  profile_after_prologue (file);\n \t  break;\n \n \tcase NOTE_INSN_EPILOGUE_BEG:\n-\t  (*targetm.asm_out.function_begin_epilogue) (file);\t     \n+\t  (*targetm.asm_out.function_begin_epilogue) (file);\n \t  break;\n \n \tcase NOTE_INSN_FUNCTION_BEG:\n@@ -2749,7 +2749,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n            print_rtl_single (asm_out_file, insn);\n            print_rtx_head = \"\";\n          }\n-       \n+\n \tif (! constrain_operands_cached (1))\n \t  fatal_insn_not_found (insn);\n "}, {"sha": "7fe007485c19056ec07d3151e18614de83b68018", "filename": "gcc/flow.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f2270425b565e5764f18185aa2b8850e028622/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b9f2270425b565e5764f18185aa2b8850e028622", "patch": "@@ -366,7 +366,7 @@ typedef struct depth_first_search_dsS *depth_first_search_ds;\n   print_rtl_and_abort_fcn (__FILE__, __LINE__, __FUNCTION__)\n \n /* Forward declarations */\n-static bool try_crossjump_to_edge \tPARAMS ((int, edge, edge));\n+static bool try_crossjump_to_edge\tPARAMS ((int, edge, edge));\n static bool try_crossjump_bb\t\tPARAMS ((int, basic_block));\n static bool outgoing_edges_match\tPARAMS ((basic_block, basic_block));\n static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n@@ -1783,7 +1783,7 @@ can_fallthru (src, target)\n \n /* Attempt to perform edge redirection by replacing possibly complex jump\n    instruction by unconditional jump or removing jump completely.\n-   This can apply only if all edges now point to the same block. \n+   This can apply only if all edges now point to the same block.\n \n    The parameters and return values are equivalent to redirect_edge_and_branch.\n  */\n@@ -2532,7 +2532,7 @@ need_fake_edge_p (insn)\n /* Add fake edges to the function exit for any non constant and non noreturn\n    calls, volatile inline assembly in the bitmap of blocks specified by\n    BLOCKS or to the whole CFG if BLOCKS is zero.  Return the nuber of blocks\n-   that were split. \n+   that were split.\n \n    The goal is to expose cases in which entering a basic block does not imply\n    that all subsequent instructions must be executed.  */\n@@ -2560,7 +2560,7 @@ flow_call_edges_add (blocks)\n     }\n   else\n     {\n-      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i, \n+      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n       {\n \tbbs[bb_num++] = BASIC_BLOCK (i);\n \tif (i == n_basic_blocks - 1)\n@@ -2572,7 +2572,7 @@ flow_call_edges_add (blocks)\n      a fallthru edge to EXIT.  Special care is required if the last insn\n      of the last basic block is a call because make_edge folds duplicate\n      edges, which would result in the fallthru edge also being marked\n-     fake, which would result in the fallthru edge being removed by \n+     fake, which would result in the fallthru edge being removed by\n      remove_fake_edges, which would result in an invalid CFG.\n \n      Moreover, we can't elide the outgoing fake edge, since the block\n@@ -3336,7 +3336,7 @@ try_simplify_condjump (cbranch_block)\n   redirect_edge_succ_nodup (cbranch_fallthru_edge, jump_dest_block);\n   cbranch_jump_edge->flags |= EDGE_FALLTHRU;\n   cbranch_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n-  \n+\n   /* Delete the block with the unconditional jump, and clean up the mess.  */\n   flow_delete_block (jump_block);\n   tidy_fallthru_edge (cbranch_jump_edge, cbranch_block, cbranch_dest_block);\n@@ -3363,7 +3363,7 @@ try_forward_edges (mode, b)\n       next = e->succ_next;\n \n       /* Skip complex edges because we don't know how to update them.\n-        \n+\n          Still handle fallthru edges, as we can suceed to forward fallthru\n          edge to the same place as the branch edge of conditional branch\n          and turn conditional branch to an unconditonal branch.  */\n@@ -3386,13 +3386,13 @@ try_forward_edges (mode, b)\n \n \t  /* Avoid killing of loop pre-headers, as it is the place loop\n \t     optimizer wants to hoist code to.\n-\t \n+\n \t     For fallthru forwarders, the LOOP_BEG note must appear between\n \t     the header of block and CODE_LABEL of the loop, for non forwarders\n \t     it must appear before the JUMP_INSN.  */\n \t  if (mode & CLEANUP_PRE_LOOP)\n \t    {\n-\t      rtx insn = (target->succ->flags & EDGE_FALLTHRU \n+\t      rtx insn = (target->succ->flags & EDGE_FALLTHRU\n \t\t          ? target->head : prev_nonnote_insn (target->end));\n \n \t      if (GET_CODE (insn) != NOTE)\n@@ -3630,7 +3630,7 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n \n /* Return true iff outgoing edges of BB1 and BB2 match, together with\n    the branch instruction.  This means that if we commonize the control\n-   flow before end of the basic block, the semantic remains unchanged.  \n+   flow before end of the basic block, the semantic remains unchanged.\n \n    We may assume that there exists one edge with a common destination.  */\n \n@@ -3971,7 +3971,7 @@ try_crossjump_bb (mode, bb)\n \t     If there is a match, we'll do it the other way around.  */\n \t  if (e == fallthru)\n \t    continue;\n-\t\n+\n \t  if (try_crossjump_to_edge (mode, e, fallthru))\n \t    {\n \t      changed = true;\n@@ -4013,7 +4013,7 @@ try_crossjump_bb (mode, bb)\n \n \t  /* The \"first successor\" check above only prevents multiple\n \t     checks of crossjump(A,B).  In order to prevent redundant\n-\t     checks of crossjump(B,A), require that A be the block \n+\t     checks of crossjump(B,A), require that A be the block\n \t     with the lowest index.  */\n \t  if (e->src->index > e2->src->index)\n \t    continue;\n@@ -4080,7 +4080,7 @@ try_optimize_cfg (mode)\n \t      && !(b->pred->flags & EDGE_COMPLEX)\n \t      && GET_CODE (b->head) == CODE_LABEL\n \t      && (!(mode & CLEANUP_PRE_SIBCALL)\n- \t\t  || !tail_recursion_label_p (b->head))\n+\t\t  || !tail_recursion_label_p (b->head))\n \t      /* If previous block ends with condjump jumping to next BB,\n \t         we can't delete the label.  */\n \t      && (b->pred->src == ENTRY_BLOCK_PTR\n@@ -6251,8 +6251,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t  if (regno_first < FIRST_PSEUDO_REGISTER)\n \t    {\n \t      regno_first += subreg_regno_offset (regno_first, inner_mode,\n-\t      \t\t\t\t\t  SUBREG_BYTE (reg),\n-\t      \t\t\t\t\t  outer_mode);\n+\t\t\t\t\t\t  SUBREG_BYTE (reg),\n+\t\t\t\t\t\t  outer_mode);\n \t      regno_last = (regno_first\n \t\t\t    + HARD_REGNO_NREGS (regno_first, outer_mode) - 1);\n \n@@ -8277,7 +8277,7 @@ set_block_for_insn (insn, bb)\n /* When a new insn has been inserted into an existing block, it will\n    sometimes emit more than a single insn. This routine will set the\n    block number for the specified insn, and look backwards in the insn\n-   chain to see if there are any other uninitialized insns immediately \n+   chain to see if there are any other uninitialized insns immediately\n    previous to this one, and set the block number for them too.  */\n \n void\n@@ -8287,14 +8287,14 @@ set_block_for_new_insns (insn, bb)\n {\n   set_block_for_insn (insn, bb);\n \n-  /* Scan the previous instructions setting the block number until we find \n-     an instruction that has the block number set, or we find a note \n+  /* Scan the previous instructions setting the block number until we find\n+     an instruction that has the block number set, or we find a note\n      of any kind.  */\n   for (insn = PREV_INSN (insn); insn != NULL_RTX; insn = PREV_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE)\n \tbreak;\n-      if (INSN_UID (insn) >= basic_block_for_insn->num_elements \n+      if ((unsigned) INSN_UID (insn) >= basic_block_for_insn->num_elements\n \t  || BLOCK_FOR_INSN (insn) == 0)\n \tset_block_for_insn (insn, bb);\n       else\n@@ -8556,7 +8556,7 @@ verify_flow_info ()\n \t  num_bb_notes++;\n \t  if (bb->index != last_bb_num_seen + 1)\n \t    internal_error (\"Basic blocks not numbered consecutively.\");\n-\t       \n+\n \t  last_bb_num_seen = bb->index;\n \t}\n \n@@ -9891,13 +9891,13 @@ flow_loop_scan (loops, loop, flags)\n       for (j = 0; j < loop->num_exits; j++)\n \tsbitmap_a_and_b (loop->exits_doms, loop->exits_doms,\n \t\t\t loops->cfg.dom[loop->exit_edges[j]->src->index]);\n-      \n+\n       /* The header of a natural loop must dominate\n \t all exits.  */\n       if (! TEST_BIT (loop->exits_doms, loop->header->index))\n \tabort ();\n     }\n-  \n+\n   if (flags & LOOP_PRE_HEADER)\n     {\n       /* Look to see if the loop has a pre-header node.  */\n@@ -10301,7 +10301,7 @@ purge_dead_edges (bb)\n }\n \n /* Search all basic blocks for potentionally dead edges and purge them.\n-  \n+\n    Return true ifif some edge has been elliminated.\n  */\n "}]}