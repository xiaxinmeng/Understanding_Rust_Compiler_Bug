{"sha": "732b08f1e9ed6a48f34d1d31562314d59f2d284e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMyYjA4ZjFlOWVkNmE0OGYzNGQxZDMxNTYyMzE0ZDU5ZjJkMjg0ZQ==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1997-04-18T00:47:55Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1997-04-18T00:47:55Z"}, "message": "automatically generated from GPLed version\n\nFrom-SVN: r13929", "tree": {"sha": "a85d5bcb1d538bdc6a8425e089dda7782c9d636a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a85d5bcb1d538bdc6a8425e089dda7782c9d636a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/732b08f1e9ed6a48f34d1d31562314d59f2d284e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732b08f1e9ed6a48f34d1d31562314d59f2d284e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/732b08f1e9ed6a48f34d1d31562314d59f2d284e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732b08f1e9ed6a48f34d1d31562314d59f2d284e/comments", "author": null, "committer": null, "parents": [{"sha": "d0c2f176681a3db8604b37764f5172781c25c21d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c2f176681a3db8604b37764f5172781c25c21d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c2f176681a3db8604b37764f5172781c25c21d"}], "stats": {"total": 1055, "additions": 1055, "deletions": 0}, "files": [{"sha": "19f3f0565921089c21c78ba2d26772a390b7d790", "filename": "gcc/getopt.c", "status": "added", "additions": 1055, "deletions": 0, "changes": 1055, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732b08f1e9ed6a48f34d1d31562314d59f2d284e/gcc%2Fgetopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732b08f1e9ed6a48f34d1d31562314d59f2d284e/gcc%2Fgetopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgetopt.c?ref=732b08f1e9ed6a48f34d1d31562314d59f2d284e", "patch": "@@ -0,0 +1,1055 @@\n+/* Getopt for GNU.\n+   NOTE: getopt is now part of the C library, so if you don't know what\n+   \"Keep this file name-space clean\" means, talk to roland@gnu.ai.mit.edu\n+   before changing it!\n+\n+   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97\n+   \tFree Software Foundation, Inc.\n+\n+   the C library, however.  The master source lives in /gd/gnu/lib.\n+\n+NOTE: The canonical source of this file is maintained with the GNU C Library.\n+Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+USA.  */\n+\f\n+/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.\n+   Ditto for AIX 3.2 and <stdlib.h>.  */\n+#ifndef _NO_PROTO\n+#define _NO_PROTO\n+#endif\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#if !defined (__STDC__) || !__STDC__\n+/* This is a separate conditional since some stdc systems\n+   reject `defined (const)'.  */\n+#ifndef const\n+#define const\n+#endif\n+#endif\n+\n+#include <stdio.h>\n+\n+/* Comment out all this code if we are using the GNU C Library, and are not\n+   actually compiling the library itself.  This code is part of the GNU C\n+   Library, but also included in many other GNU distributions.  Compiling\n+   and linking in this code is a waste when using the GNU C library\n+   (especially if it is a shared library).  Rather than having every GNU\n+   program understand `configure --with-gnu-libc' and omit the object files,\n+   it is simpler to just do this in the source for each such file.  */\n+\n+#define GETOPT_INTERFACE_VERSION 2\n+#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2\n+#include <gnu-versions.h>\n+#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION\n+#define ELIDE_CODE\n+#endif\n+#endif\n+\n+#ifndef ELIDE_CODE\n+\n+\n+/* This needs to come after some library #include\n+   to get __GNU_LIBRARY__ defined.  */\n+#ifdef\t__GNU_LIBRARY__\n+/* Don't include stdlib.h for non-GNU C libraries because some of them\n+   contain conflicting prototypes for getopt.  */\n+#include <stdlib.h>\n+#include <unistd.h>\n+#endif\t/* GNU C library.  */\n+\n+#ifdef VMS\n+#include <unixlib.h>\n+#if HAVE_STRING_H - 0\n+#include <string.h>\n+#endif\n+#endif\n+\n+#if defined (WIN32) && !defined (__CYGWIN32__)\n+/* It's not Unix, really.  See?  Capital letters.  */\n+#include <windows.h>\n+#define getpid() GetCurrentProcessId()\n+#endif\n+\n+#ifndef _\n+/* This is for other GNU distributions with internationalized messages.\n+   When compiling libc, the _ macro is predefined.  */\n+#ifdef HAVE_LIBINTL_H\n+# include <libintl.h>\n+# define _(msgid)\tgettext (msgid)\n+#else\n+# define _(msgid)\t(msgid)\n+#endif\n+#endif\n+\n+/* This version of `getopt' appears to the caller like standard Unix `getopt'\n+   but it behaves differently for the user, since it allows the user\n+   to intersperse the options with the other arguments.\n+\n+   As `getopt' works, it permutes the elements of ARGV so that,\n+   when it is done, all the options precede everything else.  Thus\n+   all application programs are extended to handle flexible argument order.\n+\n+   Setting the environment variable POSIXLY_CORRECT disables permutation.\n+   Then the behavior is completely standard.\n+\n+   GNU application programs can use a third alternative mode in which\n+   they can distinguish the relative order of options and other arguments.  */\n+\n+#include \"getopt.h\"\n+\n+/* For communication from `getopt' to the caller.\n+   When `getopt' finds an option that takes an argument,\n+   the argument value is returned here.\n+   Also, when `ordering' is RETURN_IN_ORDER,\n+   each non-option ARGV-element is returned here.  */\n+\n+char *optarg = NULL;\n+\n+/* Index in ARGV of the next element to be scanned.\n+   This is used for communication to and from the caller\n+   and for communication between successive calls to `getopt'.\n+\n+   On entry to `getopt', zero means this is the first call; initialize.\n+\n+   When `getopt' returns -1, this is the index of the first of the\n+   non-option elements that the caller should itself scan.\n+\n+   Otherwise, `optind' communicates from one call to the next\n+   how much of ARGV has been scanned so far.  */\n+\n+/* 1003.2 says this must be 1 before any call.  */\n+int optind = 1;\n+\n+/* Formerly, initialization of getopt depended on optind==0, which\n+   causes problems with re-calling getopt as programs generally don't\n+   know that. */\n+\n+int __getopt_initialized = 0;\n+\n+/* The next char to be scanned in the option-element\n+   in which the last option character we returned was found.\n+   This allows us to pick up the scan where we left off.\n+\n+   If this is zero, or a null string, it means resume the scan\n+   by advancing to the next ARGV-element.  */\n+\n+static char *nextchar;\n+\n+/* Callers store zero here to inhibit the error message\n+   for unrecognized options.  */\n+\n+int opterr = 1;\n+\n+/* Set to an option character which was unrecognized.\n+   This must be initialized on some systems to avoid linking in the\n+   system's own getopt implementation.  */\n+\n+int optopt = '?';\n+\n+/* Describe how to deal with options that follow non-option ARGV-elements.\n+\n+   If the caller did not specify anything,\n+   the default is REQUIRE_ORDER if the environment variable\n+   POSIXLY_CORRECT is defined, PERMUTE otherwise.\n+\n+   REQUIRE_ORDER means don't recognize them as options;\n+   stop option processing when the first non-option is seen.\n+   This is what Unix does.\n+   This mode of operation is selected by either setting the environment\n+   variable POSIXLY_CORRECT, or using `+' as the first character\n+   of the list of option characters.\n+\n+   PERMUTE is the default.  We permute the contents of ARGV as we scan,\n+   so that eventually all the non-options are at the end.  This allows options\n+   to be given in any order, even with programs that were not written to\n+   expect this.\n+\n+   RETURN_IN_ORDER is an option available to programs that were written\n+   to expect options and other ARGV-elements in any order and that care about\n+   the ordering of the two.  We describe each non-option ARGV-element\n+   as if it were the argument of an option with character code 1.\n+   Using `-' as the first character of the list of option characters\n+   selects this mode of operation.\n+\n+   The special argument `--' forces an end of option-scanning regardless\n+   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only\n+   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */\n+\n+static enum\n+{\n+  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER\n+} ordering;\n+\n+/* Value of POSIXLY_CORRECT environment variable.  */\n+static char *posixly_correct;\n+\f\n+#ifdef\t__GNU_LIBRARY__\n+/* We want to avoid inclusion of string.h with non-GNU libraries\n+   because there are many ways it can cause trouble.\n+   On some systems, it contains special magic macros that don't work\n+   in GCC.  */\n+#include <string.h>\n+#define\tmy_index\tstrchr\n+#else\n+\n+/* Avoid depending on library functions or files\n+   whose names are inconsistent.  */\n+\n+char *getenv ();\n+\n+static char *\n+my_index (str, chr)\n+     const char *str;\n+     int chr;\n+{\n+  while (*str)\n+    {\n+      if (*str == chr)\n+\treturn (char *) str;\n+      str++;\n+    }\n+  return 0;\n+}\n+\n+/* If using GCC, we can safely declare strlen this way.\n+   If not using GCC, it is ok not to declare it.  */\n+#ifdef __GNUC__\n+/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.\n+   That was relevant to code that was here before.  */\n+#if !defined (__STDC__) || !__STDC__\n+/* gcc with -traditional declares the built-in strlen to return int,\n+   and has done so at least since version 2.4.5. -- rms.  */\n+extern int strlen (const char *);\n+#endif /* not __STDC__ */\n+#endif /* __GNUC__ */\n+\n+#endif /* not __GNU_LIBRARY__ */\n+\f\n+/* Handle permutation of arguments.  */\n+\n+/* Describe the part of ARGV that contains non-options that have\n+   been skipped.  `first_nonopt' is the index in ARGV of the first of them;\n+   `last_nonopt' is the index after the last of them.  */\n+\n+static int first_nonopt;\n+static int last_nonopt;\n+\n+#ifdef _LIBC\n+/* Bash 2.0 gives us an environment variable containing flags\n+   indicating ARGV elements that should not be considered arguments.  */\n+\n+/* Defined in getopt_init.c  */\n+extern char *__getopt_nonoption_flags;\n+\n+static int nonoption_flags_max_len;\n+static int nonoption_flags_len;\n+\n+static int original_argc;\n+static char *const *original_argv;\n+\n+extern pid_t __libc_pid;\n+\n+/* Make sure the environment variable bash 2.0 puts in the environment\n+   is valid for the getopt call we must make sure that the ARGV passed\n+   to getopt is that one passed to the process.  */\n+static void\n+__attribute__ ((unused))\n+store_args_and_env (int argc, char *const *argv)\n+{\n+  /* XXX This is no good solution.  We should rather copy the args so\n+     that we can compare them later.  But we must not use malloc(3).  */\n+  original_argc = argc;\n+  original_argv = argv;\n+}\n+text_set_element (__libc_subinit, store_args_and_env);\n+\n+# define SWAP_FLAGS(ch1, ch2) \\\n+  if (nonoption_flags_len > 0)\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      char __tmp = __getopt_nonoption_flags[ch1];\t\t\t      \\\n+      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];\t      \\\n+      __getopt_nonoption_flags[ch2] = __tmp;\t\t\t\t      \\\n+    }\n+#else\t/* !_LIBC */\n+# define SWAP_FLAGS(ch1, ch2)\n+#endif\t/* _LIBC */\n+\n+/* Exchange two adjacent subsequences of ARGV.\n+   One subsequence is elements [first_nonopt,last_nonopt)\n+   which contains all the non-options that have been skipped so far.\n+   The other is elements [last_nonopt,optind), which contains all\n+   the options processed since those non-options were skipped.\n+\n+   `first_nonopt' and `last_nonopt' are relocated so that they describe\n+   the new indices of the non-options in ARGV after they are moved.  */\n+\n+#if defined (__STDC__) && __STDC__\n+static void exchange (char **);\n+#endif\n+\n+static void\n+exchange (argv)\n+     char **argv;\n+{\n+  int bottom = first_nonopt;\n+  int middle = last_nonopt;\n+  int top = optind;\n+  char *tem;\n+\n+  /* Exchange the shorter segment with the far end of the longer segment.\n+     That puts the shorter segment into the right place.\n+     It leaves the longer segment in the right place overall,\n+     but it consists of two parts that need to be swapped next.  */\n+\n+#ifdef _LIBC\n+  /* First make sure the handling of the `__getopt_nonoption_flags'\n+     string can work normally.  Our top argument must be in the range\n+     of the string.  */\n+  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)\n+    {\n+      /* We must extend the array.  The user plays games with us and\n+\t presents new arguments.  */\n+      char *new_str = malloc (top + 1);\n+      if (new_str == NULL)\n+\tnonoption_flags_len = nonoption_flags_max_len = 0;\n+      else\n+\t{\n+\t  memcpy (new_str, __getopt_nonoption_flags, nonoption_flags_max_len);\n+\t  memset (&new_str[nonoption_flags_max_len], '\\0',\n+\t\t  top + 1 - nonoption_flags_max_len);\n+\t  nonoption_flags_max_len = top + 1;\n+\t  __getopt_nonoption_flags = new_str;\n+\t}\n+    }\n+#endif\n+\n+  while (top > middle && middle > bottom)\n+    {\n+      if (top - middle > middle - bottom)\n+\t{\n+\t  /* Bottom segment is the short one.  */\n+\t  int len = middle - bottom;\n+\t  register int i;\n+\n+\t  /* Swap it with the top part of the top segment.  */\n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      tem = argv[bottom + i];\n+\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n+\t      argv[top - (middle - bottom) + i] = tem;\n+\t      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n+\t    }\n+\t  /* Exclude the moved bottom segment from further swapping.  */\n+\t  top -= len;\n+\t}\n+      else\n+\t{\n+\t  /* Top segment is the short one.  */\n+\t  int len = top - middle;\n+\t  register int i;\n+\n+\t  /* Swap it with the bottom part of the bottom segment.  */\n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      tem = argv[bottom + i];\n+\t      argv[bottom + i] = argv[middle + i];\n+\t      argv[middle + i] = tem;\n+\t      SWAP_FLAGS (bottom + i, middle + i);\n+\t    }\n+\t  /* Exclude the moved top segment from further swapping.  */\n+\t  bottom += len;\n+\t}\n+    }\n+\n+  /* Update records for the slots the non-options now occupy.  */\n+\n+  first_nonopt += (optind - last_nonopt);\n+  last_nonopt = optind;\n+}\n+\n+/* Initialize the internal data when the first call is made.  */\n+\n+#if defined (__STDC__) && __STDC__\n+static const char *_getopt_initialize (int, char *const *, const char *);\n+#endif\n+static const char *\n+_getopt_initialize (argc, argv, optstring)\n+     int argc;\n+     char *const *argv;\n+     const char *optstring;\n+{\n+  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n+     is the program name); the sequence of previously skipped\n+     non-option ARGV-elements is empty.  */\n+\n+  first_nonopt = last_nonopt = optind;\n+\n+  nextchar = NULL;\n+\n+  posixly_correct = getenv (\"POSIXLY_CORRECT\");\n+\n+  /* Determine how to handle the ordering of options and nonoptions.  */\n+\n+  if (optstring[0] == '-')\n+    {\n+      ordering = RETURN_IN_ORDER;\n+      ++optstring;\n+    }\n+  else if (optstring[0] == '+')\n+    {\n+      ordering = REQUIRE_ORDER;\n+      ++optstring;\n+    }\n+  else if (posixly_correct != NULL)\n+    ordering = REQUIRE_ORDER;\n+  else\n+    ordering = PERMUTE;\n+\n+#ifdef _LIBC\n+  if (posixly_correct == NULL\n+      && argc == original_argc && argv == original_argv)\n+    {\n+      if (nonoption_flags_max_len == 0)\n+\t{\n+\t  if (__getopt_nonoption_flags == NULL\n+\t      || __getopt_nonoption_flags[0] == '\\0')\n+\t    nonoption_flags_max_len = -1;\n+\t  else\n+\t    {\n+\t      const char *orig_str = __getopt_nonoption_flags;\n+\t      int len = nonoption_flags_max_len = strlen (orig_str);\n+\t      if (nonoption_flags_max_len < argc)\n+\t\tnonoption_flags_max_len = argc;\n+\t      __getopt_nonoption_flags =\n+\t\t(char *) malloc (nonoption_flags_max_len);\n+\t      if (__getopt_nonoption_flags == NULL)\n+\t\tnonoption_flags_max_len = -1;\n+\t      else\n+\t\t{\n+\t\t  memcpy (__getopt_nonoption_flags, orig_str, len);\n+\t\t  memset (&__getopt_nonoption_flags[len], '\\0',\n+\t\t\t  nonoption_flags_max_len - len);\n+\t\t}\n+\t    }\n+\t}\n+      nonoption_flags_len = nonoption_flags_max_len;\n+    }\n+  else\n+    nonoption_flags_len = 0;\n+#endif\n+\n+  return optstring;\n+}\n+\f\n+/* Scan elements of ARGV (whose length is ARGC) for option characters\n+   given in OPTSTRING.\n+\n+   If an element of ARGV starts with '-', and is not exactly \"-\" or \"--\",\n+   then it is an option element.  The characters of this element\n+   (aside from the initial '-') are option characters.  If `getopt'\n+   is called repeatedly, it returns successively each of the option characters\n+   from each of the option elements.\n+\n+   If `getopt' finds another option character, it returns that character,\n+   updating `optind' and `nextchar' so that the next call to `getopt' can\n+   resume the scan with the following option character or ARGV-element.\n+\n+   If there are no more option characters, `getopt' returns -1.\n+   Then `optind' is the index in ARGV of the first ARGV-element\n+   that is not an option.  (The ARGV-elements have been permuted\n+   so that those that are not options now come last.)\n+\n+   OPTSTRING is a string containing the legitimate option characters.\n+   If an option character is seen that is not listed in OPTSTRING,\n+   return '?' after printing an error message.  If you set `opterr' to\n+   zero, the error message is suppressed but we still return '?'.\n+\n+   If a char in OPTSTRING is followed by a colon, that means it wants an arg,\n+   so the following text in the same ARGV-element, or the text of the following\n+   ARGV-element, is returned in `optarg'.  Two colons mean an option that\n+   wants an optional arg; if there is text in the current ARGV-element,\n+   it is returned in `optarg', otherwise `optarg' is set to zero.\n+\n+   If OPTSTRING starts with `-' or `+', it requests different methods of\n+   handling the non-option ARGV-elements.\n+   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.\n+\n+   Long-named options begin with `--' instead of `-'.\n+   Their names may be abbreviated as long as the abbreviation is unique\n+   or is an exact match for some defined option.  If they have an\n+   argument, it follows the option name in the same ARGV-element, separated\n+   from the option name by a `=', or else the in next ARGV-element.\n+   When `getopt' finds a long-named option, it returns 0 if that option's\n+   `flag' field is nonzero, the value of the option's `val' field\n+   if the `flag' field is zero.\n+\n+   The elements of ARGV aren't really const, because we permute them.\n+   But we pretend they're const in the prototype to be compatible\n+   with other systems.\n+\n+   LONGOPTS is a vector of `struct option' terminated by an\n+   element containing a name which is zero.\n+\n+   LONGIND returns the index in LONGOPT of the long-named option found.\n+   It is only valid when a long-named option has been found by the most\n+   recent call.\n+\n+   If LONG_ONLY is nonzero, '-' as well as '--' can introduce\n+   long-named options.  */\n+\n+int\n+_getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n+     int argc;\n+     char *const *argv;\n+     const char *optstring;\n+     const struct option *longopts;\n+     int *longind;\n+     int long_only;\n+{\n+  optarg = NULL;\n+\n+  if (optind == 0 || !__getopt_initialized)\n+    {\n+      if (optind == 0)\n+\toptind = 1;\t/* Don't scan ARGV[0], the program name.  */\n+      optstring = _getopt_initialize (argc, argv, optstring);\n+      __getopt_initialized = 1;\n+    }\n+\n+  /* Test whether ARGV[optind] points to a non-option argument.\n+     Either it does not have option syntax, or there is an environment flag\n+     from the shell indicating it is not an option.  The later information\n+     is only used when the used in the GNU libc.  */\n+#ifdef _LIBC\n+#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\\0'\t      \\\n+\t\t     || (optind < nonoption_flags_len\t\t\t      \\\n+\t\t\t && __getopt_nonoption_flags[optind] == '1'))\n+#else\n+#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\\0')\n+#endif\n+\n+  if (nextchar == NULL || *nextchar == '\\0')\n+    {\n+      /* Advance to the next ARGV-element.  */\n+\n+      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n+\t moved back by the user (who may also have changed the arguments).  */\n+      if (last_nonopt > optind)\n+\tlast_nonopt = optind;\n+      if (first_nonopt > optind)\n+\tfirst_nonopt = optind;\n+\n+      if (ordering == PERMUTE)\n+\t{\n+\t  /* If we have just processed some options following some non-options,\n+\t     exchange them so that the options come first.  */\n+\n+\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n+\t    exchange ((char **) argv);\n+\t  else if (last_nonopt != optind)\n+\t    first_nonopt = optind;\n+\n+\t  /* Skip any additional non-options\n+\t     and extend the range of non-options previously skipped.  */\n+\n+\t  while (optind < argc && NONOPTION_P)\n+\t    optind++;\n+\t  last_nonopt = optind;\n+\t}\n+\n+      /* The special ARGV-element `--' means premature end of options.\n+\t Skip it like a null option,\n+\t then exchange with previous non-options as if it were an option,\n+\t then skip everything else like a non-option.  */\n+\n+      if (optind != argc && !strcmp (argv[optind], \"--\"))\n+\t{\n+\t  optind++;\n+\n+\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n+\t    exchange ((char **) argv);\n+\t  else if (first_nonopt == last_nonopt)\n+\t    first_nonopt = optind;\n+\t  last_nonopt = argc;\n+\n+\t  optind = argc;\n+\t}\n+\n+      /* If we have done all the ARGV-elements, stop the scan\n+\t and back over any non-options that we skipped and permuted.  */\n+\n+      if (optind == argc)\n+\t{\n+\t  /* Set the next-arg-index to point at the non-options\n+\t     that we previously skipped, so the caller will digest them.  */\n+\t  if (first_nonopt != last_nonopt)\n+\t    optind = first_nonopt;\n+\t  return -1;\n+\t}\n+\n+      /* If we have come to a non-option and did not permute it,\n+\t either stop the scan or describe it to the caller and pass it by.  */\n+\n+      if (NONOPTION_P)\n+\t{\n+\t  if (ordering == REQUIRE_ORDER)\n+\t    return -1;\n+\t  optarg = argv[optind++];\n+\t  return 1;\n+\t}\n+\n+      /* We have found another option-ARGV-element.\n+\t Skip the initial punctuation.  */\n+\n+      nextchar = (argv[optind] + 1\n+\t\t  + (longopts != NULL && argv[optind][1] == '-'));\n+    }\n+\n+  /* Decode the current option-ARGV-element.  */\n+\n+  /* Check whether the ARGV-element is a long option.\n+\n+     If long_only and the ARGV-element has the form \"-f\", where f is\n+     a valid short option, don't consider it an abbreviated form of\n+     a long option that starts with f.  Otherwise there would be no\n+     way to give the -f short option.\n+\n+     On the other hand, if there's a long option \"fubar\" and\n+     the ARGV-element is \"-fu\", do consider that an abbreviation of\n+     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n+\n+     This distinction seems to be the most useful approach.  */\n+\n+  if (longopts != NULL\n+      && (argv[optind][1] == '-'\n+\t  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))\n+    {\n+      char *nameend;\n+      const struct option *p;\n+      const struct option *pfound = NULL;\n+      int exact = 0;\n+      int ambig = 0;\n+      int indfound = -1;\n+      int option_index;\n+\n+      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)\n+\t/* Do nothing.  */ ;\n+\n+      /* Test all long options for either exact match\n+\t or abbreviated matches.  */\n+      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n+\tif (!strncmp (p->name, nextchar, nameend - nextchar))\n+\t  {\n+\t    if ((unsigned int) (nameend - nextchar)\n+\t\t== (unsigned int) strlen (p->name))\n+\t      {\n+\t\t/* Exact match found.  */\n+\t\tpfound = p;\n+\t\tindfound = option_index;\n+\t\texact = 1;\n+\t\tbreak;\n+\t      }\n+\t    else if (pfound == NULL)\n+\t      {\n+\t\t/* First nonexact match found.  */\n+\t\tpfound = p;\n+\t\tindfound = option_index;\n+\t      }\n+\t    else\n+\t      /* Second or later nonexact match found.  */\n+\t      ambig = 1;\n+\t  }\n+\n+      if (ambig && !exact)\n+\t{\n+\t  if (opterr)\n+\t    fprintf (stderr, _(\"%s: option `%s' is ambiguous\\n\"),\n+\t\t     argv[0], argv[optind]);\n+\t  nextchar += strlen (nextchar);\n+\t  optind++;\n+\t  optopt = 0;\n+\t  return '?';\n+\t}\n+\n+      if (pfound != NULL)\n+\t{\n+\t  option_index = indfound;\n+\t  optind++;\n+\t  if (*nameend)\n+\t    {\n+\t      /* Don't test has_arg with >, because some C compilers don't\n+\t\t allow it to be used on enums.  */\n+\t      if (pfound->has_arg)\n+\t\toptarg = nameend + 1;\n+\t      else\n+\t\t{\n+\t\t  if (opterr)\n+\t\t   if (argv[optind - 1][1] == '-')\n+\t\t    /* --option */\n+\t\t    fprintf (stderr,\n+\t\t     _(\"%s: option `--%s' doesn't allow an argument\\n\"),\n+\t\t     argv[0], pfound->name);\n+\t\t   else\n+\t\t    /* +option or -option */\n+\t\t    fprintf (stderr,\n+\t\t     _(\"%s: option `%c%s' doesn't allow an argument\\n\"),\n+\t\t     argv[0], argv[optind - 1][0], pfound->name);\n+\n+\t\t  nextchar += strlen (nextchar);\n+\n+\t\t  optopt = pfound->val;\n+\t\t  return '?';\n+\t\t}\n+\t    }\n+\t  else if (pfound->has_arg == 1)\n+\t    {\n+\t      if (optind < argc)\n+\t\toptarg = argv[optind++];\n+\t      else\n+\t\t{\n+\t\t  if (opterr)\n+\t\t    fprintf (stderr,\n+\t\t\t   _(\"%s: option `%s' requires an argument\\n\"),\n+\t\t\t   argv[0], argv[optind - 1]);\n+\t\t  nextchar += strlen (nextchar);\n+\t\t  optopt = pfound->val;\n+\t\t  return optstring[0] == ':' ? ':' : '?';\n+\t\t}\n+\t    }\n+\t  nextchar += strlen (nextchar);\n+\t  if (longind != NULL)\n+\t    *longind = option_index;\n+\t  if (pfound->flag)\n+\t    {\n+\t      *(pfound->flag) = pfound->val;\n+\t      return 0;\n+\t    }\n+\t  return pfound->val;\n+\t}\n+\n+      /* Can't find it as a long option.  If this is not getopt_long_only,\n+\t or the option starts with '--' or is not a valid short\n+\t option, then it's an error.\n+\t Otherwise interpret it as a short option.  */\n+      if (!long_only || argv[optind][1] == '-'\n+\t  || my_index (optstring, *nextchar) == NULL)\n+\t{\n+\t  if (opterr)\n+\t    {\n+\t      if (argv[optind][1] == '-')\n+\t\t/* --option */\n+\t\tfprintf (stderr, _(\"%s: unrecognized option `--%s'\\n\"),\n+\t\t\t argv[0], nextchar);\n+\t      else\n+\t\t/* +option or -option */\n+\t\tfprintf (stderr, _(\"%s: unrecognized option `%c%s'\\n\"),\n+\t\t\t argv[0], argv[optind][0], nextchar);\n+\t    }\n+\t  nextchar = (char *) \"\";\n+\t  optind++;\n+\t  optopt = 0;\n+\t  return '?';\n+\t}\n+    }\n+\n+  /* Look at and handle the next short option-character.  */\n+\n+  {\n+    char c = *nextchar++;\n+    char *temp = my_index (optstring, c);\n+\n+    /* Increment `optind' when we start to process its last character.  */\n+    if (*nextchar == '\\0')\n+      ++optind;\n+\n+    if (temp == NULL || c == ':')\n+      {\n+\tif (opterr)\n+\t  {\n+\t    if (posixly_correct)\n+\t      /* 1003.2 specifies the format of this message.  */\n+\t      fprintf (stderr, _(\"%s: illegal option -- %c\\n\"),\n+\t\t       argv[0], c);\n+\t    else\n+\t      fprintf (stderr, _(\"%s: invalid option -- %c\\n\"),\n+\t\t       argv[0], c);\n+\t  }\n+\toptopt = c;\n+\treturn '?';\n+      }\n+    /* Convenience. Treat POSIX -W foo same as long option --foo */\n+    if (temp[0] == 'W' && temp[1] == ';')\n+      {\n+\tchar *nameend;\n+\tconst struct option *p;\n+\tconst struct option *pfound = NULL;\n+\tint exact = 0;\n+\tint ambig = 0;\n+\tint indfound = 0;\n+\tint option_index;\n+\n+\t/* This is an option that requires an argument.  */\n+\tif (*nextchar != '\\0')\n+\t  {\n+\t    optarg = nextchar;\n+\t    /* If we end this ARGV-element by taking the rest as an arg,\n+\t       we must advance to the next element now.  */\n+\t    optind++;\n+\t  }\n+\telse if (optind == argc)\n+\t  {\n+\t    if (opterr)\n+\t      {\n+\t\t/* 1003.2 specifies the format of this message.  */\n+\t\tfprintf (stderr, _(\"%s: option requires an argument -- %c\\n\"),\n+\t\t\t argv[0], c);\n+\t      }\n+\t    optopt = c;\n+\t    if (optstring[0] == ':')\n+\t      c = ':';\n+\t    else\n+\t      c = '?';\n+\t    return c;\n+\t  }\n+\telse\n+\t  /* We already incremented `optind' once;\n+\t     increment it again when taking next ARGV-elt as argument.  */\n+\t  optarg = argv[optind++];\n+\n+\t/* optarg is now the argument, see if it's in the\n+\t   table of longopts.  */\n+\n+\tfor (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)\n+\t  /* Do nothing.  */ ;\n+\n+\t/* Test all long options for either exact match\n+\t   or abbreviated matches.  */\n+\tfor (p = longopts, option_index = 0; p->name; p++, option_index++)\n+\t  if (!strncmp (p->name, nextchar, nameend - nextchar))\n+\t    {\n+\t      if ((unsigned int) (nameend - nextchar) == strlen (p->name))\n+\t\t{\n+\t\t  /* Exact match found.  */\n+\t\t  pfound = p;\n+\t\t  indfound = option_index;\n+\t\t  exact = 1;\n+\t\t  break;\n+\t\t}\n+\t      else if (pfound == NULL)\n+\t\t{\n+\t\t  /* First nonexact match found.  */\n+\t\t  pfound = p;\n+\t\t  indfound = option_index;\n+\t\t}\n+\t      else\n+\t\t/* Second or later nonexact match found.  */\n+\t\tambig = 1;\n+\t    }\n+\tif (ambig && !exact)\n+\t  {\n+\t    if (opterr)\n+\t      fprintf (stderr, _(\"%s: option `-W %s' is ambiguous\\n\"),\n+\t\t       argv[0], argv[optind]);\n+\t    nextchar += strlen (nextchar);\n+\t    optind++;\n+\t    return '?';\n+\t  }\n+\tif (pfound != NULL)\n+\t  {\n+\t    option_index = indfound;\n+\t    if (*nameend)\n+\t      {\n+\t\t/* Don't test has_arg with >, because some C compilers don't\n+\t\t   allow it to be used on enums.  */\n+\t\tif (pfound->has_arg)\n+\t\t  optarg = nameend + 1;\n+\t\telse\n+\t\t  {\n+\t\t    if (opterr)\n+\t\t      fprintf (stderr, _(\"\\\n+%s: option `-W %s' doesn't allow an argument\\n\"),\n+\t\t\t       argv[0], pfound->name);\n+\n+\t\t    nextchar += strlen (nextchar);\n+\t\t    return '?';\n+\t\t  }\n+\t      }\n+\t    else if (pfound->has_arg == 1)\n+\t      {\n+\t\tif (optind < argc)\n+\t\t  optarg = argv[optind++];\n+\t\telse\n+\t\t  {\n+\t\t    if (opterr)\n+\t\t      fprintf (stderr,\n+\t\t\t       _(\"%s: option `%s' requires an argument\\n\"),\n+\t\t\t       argv[0], argv[optind - 1]);\n+\t\t    nextchar += strlen (nextchar);\n+\t\t    return optstring[0] == ':' ? ':' : '?';\n+\t\t  }\n+\t      }\n+\t    nextchar += strlen (nextchar);\n+\t    if (longind != NULL)\n+\t      *longind = option_index;\n+\t    if (pfound->flag)\n+\t      {\n+\t\t*(pfound->flag) = pfound->val;\n+\t\treturn 0;\n+\t      }\n+\t    return pfound->val;\n+\t  }\n+\t  nextchar = NULL;\n+\t  return 'W';\t/* Let the application handle it.   */\n+      }\n+    if (temp[1] == ':')\n+      {\n+\tif (temp[2] == ':')\n+\t  {\n+\t    /* This is an option that accepts an argument optionally.  */\n+\t    if (*nextchar != '\\0')\n+\t      {\n+\t\toptarg = nextchar;\n+\t\toptind++;\n+\t      }\n+\t    else\n+\t      optarg = NULL;\n+\t    nextchar = NULL;\n+\t  }\n+\telse\n+\t  {\n+\t    /* This is an option that requires an argument.  */\n+\t    if (*nextchar != '\\0')\n+\t      {\n+\t\toptarg = nextchar;\n+\t\t/* If we end this ARGV-element by taking the rest as an arg,\n+\t\t   we must advance to the next element now.  */\n+\t\toptind++;\n+\t      }\n+\t    else if (optind == argc)\n+\t      {\n+\t\tif (opterr)\n+\t\t  {\n+\t\t    /* 1003.2 specifies the format of this message.  */\n+\t\t    fprintf (stderr,\n+\t\t\t   _(\"%s: option requires an argument -- %c\\n\"),\n+\t\t\t   argv[0], c);\n+\t\t  }\n+\t\toptopt = c;\n+\t\tif (optstring[0] == ':')\n+\t\t  c = ':';\n+\t\telse\n+\t\t  c = '?';\n+\t      }\n+\t    else\n+\t      /* We already incremented `optind' once;\n+\t\t increment it again when taking next ARGV-elt as argument.  */\n+\t      optarg = argv[optind++];\n+\t    nextchar = NULL;\n+\t  }\n+      }\n+    return c;\n+  }\n+}\n+\n+int\n+getopt (argc, argv, optstring)\n+     int argc;\n+     char *const *argv;\n+     const char *optstring;\n+{\n+  return _getopt_internal (argc, argv, optstring,\n+\t\t\t   (const struct option *) 0,\n+\t\t\t   (int *) 0,\n+\t\t\t   0);\n+}\n+\n+#endif\t/* Not ELIDE_CODE.  */\n+\f\n+#ifdef TEST\n+\n+/* Compile with -DTEST to make an executable for use in testing\n+   the above definition of `getopt'.  */\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int c;\n+  int digit_optind = 0;\n+\n+  while (1)\n+    {\n+      int this_option_optind = optind ? optind : 1;\n+\n+      c = getopt (argc, argv, \"abc:d:0123456789\");\n+      if (c == -1)\n+\tbreak;\n+\n+      switch (c)\n+\t{\n+\tcase '0':\n+\tcase '1':\n+\tcase '2':\n+\tcase '3':\n+\tcase '4':\n+\tcase '5':\n+\tcase '6':\n+\tcase '7':\n+\tcase '8':\n+\tcase '9':\n+\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n+\t    printf (\"digits occur in two different argv-elements.\\n\");\n+\t  digit_optind = this_option_optind;\n+\t  printf (\"option %c\\n\", c);\n+\t  break;\n+\n+\tcase 'a':\n+\t  printf (\"option a\\n\");\n+\t  break;\n+\n+\tcase 'b':\n+\t  printf (\"option b\\n\");\n+\t  break;\n+\n+\tcase 'c':\n+\t  printf (\"option c with value `%s'\\n\", optarg);\n+\t  break;\n+\n+\tcase '?':\n+\t  break;\n+\n+\tdefault:\n+\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n+\t}\n+    }\n+\n+  if (optind < argc)\n+    {\n+      printf (\"non-option ARGV-elements: \");\n+      while (optind < argc)\n+\tprintf (\"%s \", argv[optind++]);\n+      printf (\"\\n\");\n+    }\n+\n+  exit (0);\n+}\n+\n+#endif /* TEST */"}]}