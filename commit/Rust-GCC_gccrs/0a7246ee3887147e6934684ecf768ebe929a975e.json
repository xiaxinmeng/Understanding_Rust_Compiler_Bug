{"sha": "0a7246ee3887147e6934684ecf768ebe929a975e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE3MjQ2ZWUzODg3MTQ3ZTY5MzQ2ODRlY2Y3NjhlYmU5MjlhOTc1ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-02-27T02:06:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-02-27T02:06:48Z"}, "message": "re PR bootstrap/65150 (r220875 causes bootstrap failure on x86_64 darwin)\n\n\tPR bootstrap/65150\n\t* ipa-icf.c (symbol_compare_collection::symbol_compare_colleciton):\n\tUse address_matters_p.\n\t(redirect_all_callers, set_addressable): New functions.\n\t(sem_function::merge): Reorganize and fix merging issues.\n\t(sem_variable::merge): Likewise.\n\t(sem_variable::compare_sections): Remove.\n\t* common.opt (fmerge-all-constants, fmerge-constants): Remove\n\tOptimization flag.\n\t* symtab.c (symtab_node::resolve_alias): When alias has aliases,\n\tredirect them.\n\t(symtab_node::make_decl_local): Set ADDRESSABLE bit when\n\tdecl is used.\n\t(address_matters_1): New function.\n\t(symtab_node::address_matters_p): New function.\n\t* cgraph.c (cgraph_edge::verify_corresponds_to_fndecl): Fix\n\tcheck for merged flag.\n\t* cgraph.h (address_matters_p): Declare.\n\t(symtab_node::address_taken_from_non_vtable_p): Remove.\n\t(symtab_node::address_can_be_compared_p): New method.\n\t(ipa_ref::address_matters_p): Move here from ipa-ref.c; simplify.\n\t* ipa-visibility.c (symtab_node::address_taken_from_non_vtable_p):\n\tRemove.\n\t(comdat_can_be_unshared_p_1) Use address_matters_p.\n\t(update_vtable_references): Fix formating.\n\t* ipa-ref.c (ipa_ref::address_matters_p): Move inline.\n\t* cgraphunit.c (cgraph_node::create_wrapper): Drop UNINLINABLE flag.\n\t* cgraphclones.c: Preserve merged and icf_merged flags.\n\nCo-Authored-By: Martin Liska <mliska@suse.cz>\n\nFrom-SVN: r221040", "tree": {"sha": "64340fdd45bcc8e11f6dbe5c80f68a86cce6c1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64340fdd45bcc8e11f6dbe5c80f68a86cce6c1fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a7246ee3887147e6934684ecf768ebe929a975e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7246ee3887147e6934684ecf768ebe929a975e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7246ee3887147e6934684ecf768ebe929a975e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7246ee3887147e6934684ecf768ebe929a975e/comments", "author": null, "committer": null, "parents": [{"sha": "f91f1c1312beaf16da0d12feea1696c91cb5f0a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91f1c1312beaf16da0d12feea1696c91cb5f0a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f91f1c1312beaf16da0d12feea1696c91cb5f0a7"}], "stats": {"total": 713, "additions": 490, "deletions": 223}, "files": [{"sha": "e4346a0ae9346af1262d7202917b358d26ad2bcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1,3 +1,35 @@\n+2015-02-26  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\tPR bootstrap/65150\n+\t* ipa-icf.c (symbol_compare_collection::symbol_compare_colleciton):\n+\tUse address_matters_p.\n+\t(redirect_all_callers, set_addressable): New functions.\n+\t(sem_function::merge): Reorganize and fix merging issues.\n+\t(sem_variable::merge): Likewise.\n+\t(sem_variable::compare_sections): Remove.\n+\t* common.opt (fmerge-all-constants, fmerge-constants): Remove\n+\tOptimization flag.\n+\t* symtab.c (symtab_node::resolve_alias): When alias has aliases,\n+\tredirect them.\n+\t(symtab_node::make_decl_local): Set ADDRESSABLE bit when\n+\tdecl is used.\n+\t(address_matters_1): New function.\n+\t(symtab_node::address_matters_p): New function.\n+\t* cgraph.c (cgraph_edge::verify_corresponds_to_fndecl): Fix\n+\tcheck for merged flag.\n+\t* cgraph.h (address_matters_p): Declare.\n+\t(symtab_node::address_taken_from_non_vtable_p): Remove.\n+\t(symtab_node::address_can_be_compared_p): New method.\n+\t(ipa_ref::address_matters_p): Move here from ipa-ref.c; simplify.\n+\t* ipa-visibility.c (symtab_node::address_taken_from_non_vtable_p):\n+\tRemove.\n+\t(comdat_can_be_unshared_p_1) Use address_matters_p.\n+\t(update_vtable_references): Fix formating.\n+\t* ipa-ref.c (ipa_ref::address_matters_p): Move inline.\n+\t* cgraphunit.c (cgraph_node::create_wrapper): Drop UNINLINABLE flag.\n+\t* cgraphclones.c: Preserve merged and icf_merged flags.\n+\n 2015-02-26  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/extend.texi (Function Attributes): Fix spelling and typos."}, {"sha": "5555439215ebada5213717adfbb84694f687aeca", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -2630,7 +2630,7 @@ cgraph_edge::verify_corresponds_to_fndecl (tree decl)\n   if (!node\n       || node->body_removed\n       || node->in_other_partition\n-      || node->icf_merged\n+      || callee->icf_merged\n       || callee->in_other_partition)\n     return false;\n "}, {"sha": "ff437cf18b82fe2015980a397acd528e3fff8f0e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -326,9 +326,6 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return true if ONE and TWO are part of the same COMDAT group.  */\n   inline bool in_same_comdat_group_p (symtab_node *target);\n \n-  /* Return true when there is a reference to node and it is not vtable.  */\n-  bool address_taken_from_non_vtable_p (void);\n-\n   /* Return true if symbol is known to be nonzero.  */\n   bool nonzero_address ();\n \n@@ -337,6 +334,15 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      return 2 otherwise.   */\n   int equal_address_to (symtab_node *s2);\n \n+  /* Return true if symbol's address may possibly be compared to other\n+     symbol's address.  */\n+  bool address_matters_p ();\n+\n+  /* Return true if NODE's address can be compared.  This use properties\n+     of NODE only and does not look if the address is actually taken in\n+     interesting way.  For that use ADDRESS_MATTERS_P instead.  */\n+  bool address_can_be_compared_p (void);\n+\n   /* Return symbol table node associated with DECL, if any,\n      and NULL otherwise.  */\n   static inline symtab_node *get (const_tree decl)\n@@ -3022,6 +3028,43 @@ varpool_node::call_for_symbol_and_aliases (bool (*callback) (varpool_node *,\n   return false;\n }\n \n+/* Return true if NODE's address can be compared.  */\n+\n+inline bool\n+symtab_node::address_can_be_compared_p ()\n+{\n+  /* Address of virtual tables and functions is never compared.  */\n+  if (DECL_VIRTUAL_P (decl))\n+    return false;\n+  /* Address of C++ cdtors is never compared.  */\n+  if (is_a <cgraph_node *> (this)\n+      && (DECL_CXX_CONSTRUCTOR_P (decl)\n+\t  || DECL_CXX_DESTRUCTOR_P (decl)))\n+    return false;\n+  /* Constant pool symbols addresses are never compared.\n+     flag_merge_constants permits us to assume the same on readonly vars.  */\n+  if (is_a <varpool_node *> (this)\n+      && (DECL_IN_CONSTANT_POOL (decl)\n+\t  || (flag_merge_constants >= 2\n+\t      && TREE_READONLY (decl) && !TREE_THIS_VOLATILE (decl))))\n+    return false;\n+  return true;\n+}\n+\n+/* Return true if refernece may be used in address compare.  */\n+\n+inline bool\n+ipa_ref::address_matters_p ()\n+{\n+  if (use != IPA_REF_ADDR)\n+    return false;\n+  /* Addresses taken from virtual tables are never compared.  */\n+  if (is_a <varpool_node *> (referring)\n+      && DECL_VIRTUAL_P (referring->decl))\n+    return false;\n+  return referred->address_can_be_compared_p ();\n+}\n+\n /* Build polymorphic call context for indirect call E.  */\n \n inline"}, {"sha": "c74017615fdf805062d5a9c89d287a99b4d8126b", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -471,6 +471,8 @@ cgraph_node::create_clone (tree decl, gcov_type gcov_count, int freq,\n   new_node->frequency = frequency;\n   new_node->tp_first_run = tp_first_run;\n   new_node->tm_clone = tm_clone;\n+  new_node->icf_merged = icf_merged;\n+  new_node->merged = merged;\n \n   new_node->clone.tree_map = NULL;\n   new_node->clone.args_to_skip = args_to_skip;"}, {"sha": "9f6878a19e3b41d4ebda30f29ee63401d8a8f750", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -2468,6 +2468,7 @@ cgraph_node::create_wrapper (cgraph_node *target)\n   release_body (true);\n   reset ();\n \n+  DECL_UNINLINABLE (decl) = false;\n   DECL_RESULT (decl) = decl_result;\n   DECL_INITIAL (decl) = NULL;\n   allocate_struct_function (decl, false);"}, {"sha": "b49ac46610c76ff9be7f593263df889f31a84589", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1644,11 +1644,11 @@ Report on permanent memory allocation in WPA only\n ; string constants and constants from constant pool, if 2 also constant\n ; variables.\n fmerge-all-constants\n-Common Report Var(flag_merge_constants,2) Init(1) Optimization\n+Common Report Var(flag_merge_constants,2) Init(1)\n Attempt to merge identical constants and constant variables\n \n fmerge-constants\n-Common Report Var(flag_merge_constants,1) Optimization\n+Common Report Var(flag_merge_constants,1)\n Attempt to merge identical constants across compilation units\n \n fmerge-debug-strings"}, {"sha": "5d50b6f639b2b24d80696b05a75978064ce26e93", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 290, "deletions": 159, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -147,7 +147,7 @@ symbol_compare_collection::symbol_compare_collection (symtab_node *node)\n \n       if (ref->referred->get_availability () <= AVAIL_INTERPOSABLE)\n         {\n-\t  if (ref->use == IPA_REF_ADDR)\n+\t  if (ref->address_matters_p ())\n \t    m_references.safe_push (ref->referred);\n \t  else\n \t    m_interposables.safe_push (ref->referred);\n@@ -632,8 +632,56 @@ set_local (cgraph_node *node, void *data)\n   return false;\n }\n \n+/* TREE_ADDRESSABLE of NODE to true if DATA is non-NULL.\n+   Helper for call_for_symbol_thunks_and_aliases.  */\n+\n+static bool\n+set_addressable (varpool_node *node, void *)\n+{\n+  TREE_ADDRESSABLE (node->decl) = 1;\n+  return false;\n+}\n+\n+/* Redirect all callers of N and its aliases to TO.  Remove aliases if\n+   possible.  Return number of redirections made.  */\n+\n+static int\n+redirect_all_callers (cgraph_node *n, cgraph_node *to)\n+{\n+  int nredirected = 0;\n+  ipa_ref *ref;\n+\n+  while (n->callers)\n+    {\n+      cgraph_edge *e = n->callers;\n+      e->redirect_callee (to);\n+      nredirected++;\n+    }\n+  for (unsigned i = 0; n->iterate_direct_aliases (i, ref);)\n+    {\n+      bool removed = false;\n+      cgraph_node *n_alias = dyn_cast <cgraph_node *> (ref->referring);\n+\n+      if ((DECL_COMDAT_GROUP (n->decl)\n+\t   && (DECL_COMDAT_GROUP (n->decl)\n+\t       == DECL_COMDAT_GROUP (n_alias->decl)))\n+\t  || (n_alias->get_availability () > AVAIL_INTERPOSABLE\n+\t      && n->get_availability () > AVAIL_INTERPOSABLE))\n+\t{\n+\t  nredirected += redirect_all_callers (n_alias, to);\n+\t  if (n_alias->can_remove_if_no_direct_calls_p ()\n+\t      && !n_alias->has_aliases_p ())\n+\t    n_alias->remove ();\n+\t}\n+      if (!removed)\n+\ti++;\n+    }\n+  return nredirected;\n+}\n+\n /* Merges instance with an ALIAS_ITEM, where alias, thunk or redirection can\n    be applied.  */\n+\n bool\n sem_function::merge (sem_item *alias_item)\n {\n@@ -642,16 +690,29 @@ sem_function::merge (sem_item *alias_item)\n   sem_function *alias_func = static_cast<sem_function *> (alias_item);\n \n   cgraph_node *original = get_node ();\n-  cgraph_node *local_original = original;\n+  cgraph_node *local_original = NULL;\n   cgraph_node *alias = alias_func->get_node ();\n-  bool original_address_matters;\n-  bool alias_address_matters;\n \n-  bool create_thunk = false;\n+  bool create_wrapper = false;\n   bool create_alias = false;\n   bool redirect_callers = false;\n+  bool remove = false;\n+\n   bool original_discardable = false;\n \n+  bool original_address_matters = original->address_matters_p ();\n+  bool alias_address_matters = alias->address_matters_p ();\n+\n+  if (DECL_NO_INLINE_WARNING_P (original->decl)\n+      != DECL_NO_INLINE_WARNING_P (alias->decl))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Not unifying; \"\n+\t\t \"DECL_NO_INLINE_WARNING mismatch.\\n\\n\");\n+      return false;\n+    }\n+\n   /* Do not attempt to mix functions from different user sections;\n      we do not know what user intends with those.  */\n   if (((DECL_SECTION_NAME (original->decl) && !original->implicit_section)\n@@ -660,123 +721,173 @@ sem_function::merge (sem_item *alias_item)\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n-\t\t \"Not unifying; original and alias are in different sections.\\n\\n\");\n+\t\t \"Not unifying; \"\n+\t\t \"original and alias are in different sections.\\n\\n\");\n       return false;\n     }\n \n   /* See if original is in a section that can be discarded if the main\n-     symbol is not used.  */\n-  if (DECL_EXTERNAL (original->decl))\n-    original_discardable = true;\n-  if (original->resolution == LDPR_PREEMPTED_REG\n-      || original->resolution == LDPR_PREEMPTED_IR)\n-    original_discardable = true;\n-  if (original->can_be_discarded_p ())\n+     symbol is not used.\n+\n+     Also consider case where we have resolution info and we know that\n+     original's definition is not going to be used.  In this case we can not\n+     create alias to original.  */\n+  if (original->can_be_discarded_p ()\n+      || (node->resolution != LDPR_UNKNOWN\n+\t  && !decl_binds_to_current_def_p (node->decl)))\n     original_discardable = true;\n \n-  /* See if original and/or alias address can be compared for equality.  */\n-  original_address_matters\n-    = (!DECL_VIRTUAL_P (original->decl)\n-       && (original->externally_visible\n-\t   || original->address_taken_from_non_vtable_p ()));\n-  alias_address_matters\n-    = (!DECL_VIRTUAL_P (alias->decl)\n-       && (alias->externally_visible\n-\t   || alias->address_taken_from_non_vtable_p ()));\n-\n-  /* If alias and original can be compared for address equality, we need\n-     to create a thunk.  Also we can not create extra aliases into discardable\n-     section (or we risk link failures when section is discarded).  */\n-  if ((original_address_matters\n-       && alias_address_matters)\n+  /* Creating a symtab alias is the optimal way to merge.\n+     It however can not be used in the following cases:\n+\n+     1) if ORIGINAL and ALIAS may be possibly compared for address equality.\n+     2) if ORIGINAL is in a section that may be discarded by linker or if\n+\tit is an external functions where we can not create an alias\n+\t(ORIGINAL_DISCARDABLE)\n+     3) if target do not support symbol aliases.\n+\n+     If we can not produce alias, we will turn ALIAS into WRAPPER of ORIGINAL\n+     and/or redirect all callers from ALIAS to ORIGINAL.  */\n+  if ((original_address_matters && alias_address_matters)\n       || original_discardable\n-      || DECL_COMDAT_GROUP (alias->decl)\n       || !sem_item::target_supports_symbol_aliases_p ())\n     {\n-      create_thunk = !stdarg_p (TREE_TYPE (alias->decl));\n-      create_alias = false;\n-      /* When both alias and original are not overwritable, we can save\n-         the extra thunk wrapper for direct calls.  */\n+      /* First see if we can produce wrapper.  */\n+\n+      /* Do not turn function in one comdat group into wrapper to another\n+\t comdat group. Other compiler producing the body of the\n+\t another comdat group may make opossite decision and with unfortunate\n+\t linker choices this may close a loop.  */\n+      if (DECL_COMDAT_GROUP (alias->decl)\n+\t  && (DECL_COMDAT_GROUP (alias->decl)\n+\t      != DECL_COMDAT_GROUP (original->decl)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Wrapper cannot be created because of COMDAT\\n\");\n+\t}\n+      else if (DECL_STATIC_CHAIN (alias->decl))\n+        {\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Can not create wrapper of nested functions.\\n\");\n+        }\n+      /* TODO: We can also deal with variadic functions never calling\n+\t VA_START.  */\n+      else if (stdarg_p (TREE_TYPE (alias->decl)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"can not create wrapper of stdarg function.\\n\");\n+\t}\n+      else if (inline_summaries\n+\t       && inline_summaries->get (alias)->self_size <= 2)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Wrapper creation is not \"\n+\t\t     \"profitable (function is too small).\\n\");\n+\t}\n+      /* If user paid attention to mark function noinline, assume it is\n+\t somewhat special and do not try to turn it into a wrapper that can\n+\t not be undone by inliner.  */\n+      else if (lookup_attribute (\"noinline\", DECL_ATTRIBUTES (alias->decl)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Wrappers are not created for noinline.\\n\");\n+\t}\n+      else\n+        create_wrapper = true;\n+\n+      /* We can redirect local calls in the case both alias and orignal\n+\t are not interposable.  */\n       redirect_callers\n-\t= (!original_discardable\n-\t   && !DECL_COMDAT_GROUP (alias->decl)\n-\t   && alias->get_availability () > AVAIL_INTERPOSABLE\n-\t   && original->get_availability () > AVAIL_INTERPOSABLE\n-\t   && !alias->instrumented_version);\n-    }\n-  else\n-    {\n-      create_alias = true;\n-      create_thunk = false;\n-      redirect_callers = false;\n-    }\n+\t= alias->get_availability () > AVAIL_INTERPOSABLE\n+\t  && original->get_availability () > AVAIL_INTERPOSABLE\n+\t  && !alias->instrumented_version;\n \n-  /* We want thunk to always jump to the local function body\n-     unless the body is comdat and may be optimized out.  */\n-  if ((create_thunk || redirect_callers)\n-      && (!original_discardable\n+      if (!redirect_callers && !create_wrapper)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not unifying; can not redirect callers nor \"\n+\t\t     \"produce wrapper\\n\\n\");\n+\t  return false;\n+\t}\n+\n+      /* Work out the symbol the wrapper should call.\n+\t If ORIGINAL is interposable, we need to call a local alias.\n+\t Also produce local alias (if possible) as an optimization.  */\n+      if (!original_discardable\n \t  || (DECL_COMDAT_GROUP (original->decl)\n \t      && (DECL_COMDAT_GROUP (original->decl)\n-\t\t  == DECL_COMDAT_GROUP (alias->decl)))))\n-    local_original\n-      = dyn_cast <cgraph_node *> (original->noninterposable_alias ());\n-\n-    if (!local_original)\n-      {\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Noninterposable alias cannot be created.\\n\\n\");\n-\n-\treturn false;\n-      }\n+\t\t  == DECL_COMDAT_GROUP (alias->decl))))\n+\t{\n+\t  local_original\n+\t    = dyn_cast <cgraph_node *> (original->noninterposable_alias ());\n+\t  if (!local_original\n+\t      && original->get_availability () > AVAIL_INTERPOSABLE)\n+\t    local_original = original;\n+\t  /* If original is COMDAT local, we can not really redirect external\n+\t     callers to it.  */\n+\t  if (original->comdat_local_p ())\n+\t    redirect_callers = false;\n+\t}\n+      /* If we can not use local alias, fallback to the original\n+\t when possible.  */\n+      else if (original->get_availability () > AVAIL_INTERPOSABLE)\n+\tlocal_original = original;\n+      if (!local_original)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not unifying; \"\n+\t\t     \"can not produce local alias.\\n\\n\");\n+\t  return false;\n+\t}\n \n-  if (!decl_binds_to_current_def_p (alias->decl))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Declaration does not bind to currect definition.\\n\\n\");\n-      return false;\n+      if (!redirect_callers && !create_wrapper)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not unifying; \"\n+\t\t     \"can not redirect callers nor produce a wrapper\\n\\n\");\n+\t  return false;\n+\t}\n+      if (!create_wrapper\n+\t  && !alias->can_remove_if_no_direct_calls_p ())\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not unifying; can not make wrapper and \"\n+\t\t     \"function has other uses than direct calls\\n\\n\");\n+\t  return false;\n+\t}\n     }\n+  else\n+    create_alias = true;\n \n   if (redirect_callers)\n     {\n-      /* If alias is non-overwritable then\n-         all direct calls are safe to be redirected to the original.  */\n-      bool redirected = false;\n-      while (alias->callers)\n-\t{\n-\t  cgraph_edge *e = alias->callers;\n-\t  e->redirect_callee (local_original);\n-\t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n+      int nredirected = redirect_all_callers (alias, local_original);\n \n-\t  if (e->call_stmt)\n-\t    e->redirect_call_stmt_to_callee ();\n+      if (nredirected)\n+\t{\n+\t  alias->icf_merged = true;\n+\t  local_original->icf_merged = true;\n \n-\t  pop_cfun ();\n-\t  redirected = true;\n+\t  if (dump_file && nredirected)\n+\t    fprintf (dump_file, \"%i local calls have been \"\n+\t\t     \"redirected.\\n\", nredirected);\n \t}\n \n-      alias->icf_merged = true;\n-      if (local_original->lto_file_data\n-\t  && alias->lto_file_data\n-\t  && local_original->lto_file_data != alias->lto_file_data)\n-      local_original->merged = true;\n-\n-      /* The alias function is removed if symbol address\n-         does not matter.  */\n-      if (!alias_address_matters)\n-\talias->remove ();\n-\n-      if (dump_file && redirected)\n-\tfprintf (dump_file, \"Callgraph local calls have been redirected.\\n\\n\");\n+      /* If all callers was redirected, do not produce wrapper.  */\n+      if (alias->can_remove_if_no_direct_calls_p ()\n+\t  && !alias->has_aliases_p ())\n+\t{\n+\t  create_wrapper = false;\n+\t  remove = true;\n+\t}\n+      gcc_assert (!create_alias);\n     }\n-  /* If the condtion above is not met, we are lucky and can turn the\n-     function into real alias.  */\n   else if (create_alias)\n     {\n       alias->icf_merged = true;\n-      if (local_original->lto_file_data\n-\t  && alias->lto_file_data\n-\t  && local_original->lto_file_data != alias->lto_file_data)\n-      local_original->merged = true;\n \n       /* Remove the function's body.  */\n       ipa_merge_profiles (original, alias);\n@@ -791,39 +902,38 @@ sem_function::merge (sem_item *alias_item)\n \t (set_local, (void *)(size_t) original->local_p (), true);\n \n       if (dump_file)\n-\tfprintf (dump_file, \"Callgraph alias has been created.\\n\\n\");\n+\tfprintf (dump_file, \"Unified; Function alias has been created.\\n\\n\");\n     }\n-  else if (create_thunk)\n+  if (create_wrapper)\n     {\n-      if (DECL_COMDAT_GROUP (alias->decl))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Callgraph thunk cannot be created because of COMDAT\\n\");\n+      gcc_assert (!create_alias);\n+      alias->icf_merged = true;\n+      local_original->icf_merged = true;\n \n-\t  return 0;\n-\t}\n+      ipa_merge_profiles (local_original, alias, true);\n+      alias->create_wrapper (local_original);\n \n-      if (DECL_STATIC_CHAIN (alias->decl))\n-        {\n-         if (dump_file)\n-           fprintf (dump_file, \"Thunk creation is risky for static-chain functions.\\n\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"Unified; Wrapper has been created.\\n\\n\");\n+    }\n+  gcc_assert (alias->icf_merged || remove);\n+  original->icf_merged = true;\n \n-         return 0;\n-        }\n+  /* Inform the inliner about cross-module merging.  */\n+  if ((original->lto_file_data || alias->lto_file_data)\n+      && original->lto_file_data != alias->lto_file_data)\n+    local_original->merged = original->merged = true;\n \n+  if (remove)\n+    {\n+      ipa_merge_profiles (original, alias);\n+      alias->release_body ();\n+      alias->reset ();\n+      alias->body_removed = true;\n       alias->icf_merged = true;\n-      if (local_original->lto_file_data\n-\t  && alias->lto_file_data\n-\t  && local_original->lto_file_data != alias->lto_file_data)\n-      local_original->merged = true;\n-      ipa_merge_profiles (local_original, alias, true);\n-      alias->create_wrapper (local_original);\n-\n       if (dump_file)\n-\tfprintf (dump_file, \"Callgraph thunk has been created.\\n\\n\");\n+\tfprintf (dump_file, \"Unified; Function body was removed.\\n\");\n     }\n-  else if (dump_file)\n-    fprintf (dump_file, \"Callgraph merge operation cannot be performed.\\n\\n\");\n \n   return true;\n }\n@@ -1319,7 +1429,8 @@ sem_variable::merge (sem_item *alias_item)\n   if (!sem_item::target_supports_symbol_aliases_p ())\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Symbol aliases are not supported by target\\n\\n\");\n+\tfprintf (dump_file, \"Not unifying; \"\n+\t\t \"Symbol aliases are not supported by target\\n\\n\");\n       return false;\n     }\n \n@@ -1329,73 +1440,93 @@ sem_variable::merge (sem_item *alias_item)\n   varpool_node *alias = alias_var->get_node ();\n   bool original_discardable = false;\n \n+  bool original_address_matters = original->address_matters_p ();\n+  bool alias_address_matters = alias->address_matters_p ();\n+\n   /* See if original is in a section that can be discarded if the main\n-     symbol is not used.  */\n-  if (DECL_EXTERNAL (original->decl))\n-    original_discardable = true;\n-  if (original->resolution == LDPR_PREEMPTED_REG\n-      || original->resolution == LDPR_PREEMPTED_IR)\n-    original_discardable = true;\n-  if (original->can_be_discarded_p ())\n+     symbol is not used.\n+     Also consider case where we have resolution info and we know that\n+     original's definition is not going to be used.  In this case we can not\n+     create alias to original.  */\n+  if (original->can_be_discarded_p ()\n+      || (node->resolution != LDPR_UNKNOWN\n+\t  && !decl_binds_to_current_def_p (node->decl)))\n     original_discardable = true;\n \n   gcc_assert (!TREE_ASM_WRITTEN (alias->decl));\n \n-  if (original_discardable || DECL_EXTERNAL (alias_var->decl) ||\n-      !compare_sections (alias_var))\n+  /* Constant pool machinery is not quite ready for aliases.\n+     TODO: varasm code contains logic for merging DECL_IN_CONSTANT_POOL.\n+     For LTO merging does not happen that is an important missing feature.\n+     We can enable merging with LTO if the DECL_IN_CONSTANT_POOL\n+     flag is dropped and non-local symbol name is assigned.  */\n+  if (DECL_IN_CONSTANT_POOL (alias->decl)\n+      || DECL_IN_CONSTANT_POOL (original->decl))\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Varpool alias cannot be created\\n\\n\");\n+\tfprintf (dump_file,\n+\t\t \"Not unifying; constant pool variables.\\n\\n\");\n+      return false;\n+    }\n \n+  /* Do not attempt to mix functions from different user sections;\n+     we do not know what user intends with those.  */\n+  if (((DECL_SECTION_NAME (original->decl) && !original->implicit_section)\n+       || (DECL_SECTION_NAME (alias->decl) && !alias->implicit_section))\n+      && DECL_SECTION_NAME (original->decl) != DECL_SECTION_NAME (alias->decl))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Not unifying; \"\n+\t\t \"original and alias are in different sections.\\n\\n\");\n       return false;\n     }\n-  else\n+\n+  /* We can not merge if address comparsion metters.  */\n+  if (original_address_matters && alias_address_matters\n+      && flag_merge_constants < 2)\n     {\n-      // alias cycle creation check\n-      varpool_node *n = original;\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Not unifying; \"\n+\t\t \"adress of original and alias may be compared.\\n\\n\");\n+      return false;\n+    }\n \n-      while (n->alias)\n-\t{\n-\t  n = n->get_alias_target ();\n-\t  if (n == alias)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"Varpool alias cannot be created (alias cycle).\\n\\n\");\n+  if (original_discardable\n+      && (!DECL_COMDAT_GROUP (original->decl)\n+\t  || (DECL_COMDAT_GROUP (original->decl)\n+\t      != DECL_COMDAT_GROUP (alias->decl))))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not unifying; alias cannot be created; \"\n+\t\t \"target is discardable\\n\\n\");\n \n-\t      return false;\n-\t    }\n-\t}\n+      return false;\n+    }\n+  else\n+    {\n+      gcc_assert (!original->alias);\n+      gcc_assert (!alias->alias);\n \n       alias->analyzed = false;\n \n       DECL_INITIAL (alias->decl) = NULL;\n       alias->need_bounds_init = false;\n       alias->remove_all_references ();\n+      if (TREE_ADDRESSABLE (alias->decl))\n+        original->call_for_symbol_and_aliases (set_addressable, NULL, true);\n \n       varpool_node::create_alias (alias_var->decl, decl);\n       alias->resolve_alias (original);\n \n       if (dump_file)\n-\tfprintf (dump_file, \"Varpool alias has been created.\\n\\n\");\n+\tfprintf (dump_file, \"Unified; Variable alias has been created.\\n\\n\");\n \n       return true;\n     }\n }\n \n-bool\n-sem_variable::compare_sections (sem_variable *alias)\n-{\n-  const char *source = node->get_section ();\n-  const char *target = alias->node->get_section();\n-\n-  if (source == NULL && target == NULL)\n-    return true;\n-  else if(!source || !target)\n-    return false;\n-  else\n-    return strcmp (source, target) == 0;\n-}\n-\n /* Dump symbol to FILE.  */\n \n void"}, {"sha": "91c2f89af25271ef94183d69f5b79224a393f88f", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -124,23 +124,3 @@ ipa_ref::referred_ref_list (void)\n {\n   return &referred->ref_list;\n }\n-\n-/* Return true if refernece may be used in address compare.  */\n-bool\n-ipa_ref::address_matters_p ()\n-{\n-  if (use != IPA_REF_ADDR)\n-    return false;\n-  /* Addresses taken from virtual tables are never compared.  */\n-  if (is_a <varpool_node *> (referring)\n-      && DECL_VIRTUAL_P (referring->decl))\n-    return false;\n-  /* Address of virtual tables and functions is never compared.  */\n-  if (DECL_VIRTUAL_P (referred->decl))\n-    return false;\n-  /* Address of C++ cdtors is never compared.  */\n-  if (is_a <cgraph_node *> (referred)\n-      && (DECL_CXX_CONSTRUCTOR_P (referred->decl) || DECL_CXX_DESTRUCTOR_P (referred->decl)))\n-    return false;\n-  return true;\n-}"}, {"sha": "7614cfbee4b4543b97c6b4f493d877181ac335c1", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 10, "deletions": 32, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -129,44 +129,21 @@ cgraph_node::local_p (void)\n \t\t\t\t\t\n }\n \n-/* Return true when there is a reference to node and it is not vtable.  */\n-\n-bool\n-symtab_node::address_taken_from_non_vtable_p (void)\n-{\n-  int i;\n-  struct ipa_ref *ref = NULL;\n-\n-  for (i = 0; iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ADDR)\n-      {\n-\tvarpool_node *node;\n-\tif (is_a <cgraph_node *> (ref->referring))\n-\t  return true;\n-\tnode = dyn_cast <varpool_node *> (ref->referring);\n-\tif (!DECL_VIRTUAL_P (node->decl))\n-\t  return true;\n-      }\n-  return false;\n-}\n-\n /* A helper for comdat_can_be_unshared_p.  */\n \n static bool\n comdat_can_be_unshared_p_1 (symtab_node *node)\n {\n   if (!node->externally_visible)\n     return true;\n-  /* When address is taken, we don't know if equality comparison won't\n-     break eventually. Exception are virutal functions, C++\n-     constructors/destructors and vtables, where this is not possible by\n-     language standard.  */\n-  if (!DECL_VIRTUAL_P (node->decl)\n-      && (TREE_CODE (node->decl) != FUNCTION_DECL\n-\t  || (!DECL_CXX_CONSTRUCTOR_P (node->decl)\n-\t      && !DECL_CXX_DESTRUCTOR_P (node->decl)))\n-      && node->address_taken_from_non_vtable_p ())\n-    return false;\n+  if (node->address_can_be_compared_p ())\n+    {\n+      struct ipa_ref *ref;\n+\n+      for (unsigned int i = 0; node->iterate_referring (i, ref); i++)\n+\tif (ref->address_matters_p ())\n+\t  return false;\n+    }\n \n   /* If the symbol is used in some weird way, better to not touch it.  */\n   if (node->force_output)\n@@ -387,7 +364,8 @@ can_replace_by_local_alias_in_vtable (symtab_node *node)\n /* walk_tree callback that rewrites initializer references.   */\n \n static tree\n-update_vtable_references (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+update_vtable_references (tree *tp, int *walk_subtrees,\n+\t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n   if (TREE_CODE (*tp) == VAR_DECL\n       || TREE_CODE (*tp) == FUNCTION_DECL)"}, {"sha": "a46ebd49efafd2b676f5d3ea042ce175d020d51e", "filename": "gcc/symtab.c", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1156,7 +1156,11 @@ symtab_node::make_decl_local (void)\n     return;\n \n   if (TREE_CODE (decl) == VAR_DECL)\n-    DECL_COMMON (decl) = 0;\n+    {\n+      DECL_COMMON (decl) = 0;\n+      /* ADDRESSABLE flag is not defined for public symbols.  */\n+      TREE_ADDRESSABLE (decl) = 1;\n+    }\n   else gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   DECL_COMDAT (decl) = 0;\n@@ -1513,6 +1517,19 @@ symtab_node::resolve_alias (symtab_node *target)\n   /* If alias has address taken, so does the target.  */\n   if (address_taken)\n     target->ultimate_alias_target ()->address_taken = true;\n+\n+  /* All non-weakref aliases of THIS are now in fact aliases of TARGET.  */\n+  ipa_ref *ref;\n+  for (unsigned i = 0; iterate_direct_aliases (i, ref);)\n+    {\n+      struct symtab_node *alias_alias = ref->referring;\n+      if (!alias_alias->weakref)\n+\t{\n+\t  alias_alias->remove_all_references ();\n+\t  alias_alias->create_reference (target, IPA_REF_ALIAS, NULL);\n+\t}\n+      else i++;\n+    }\n   return true;\n }\n \n@@ -1863,3 +1880,31 @@ symtab_node::call_for_symbol_and_aliases_1 (bool (*callback) (symtab_node *,\n     }\n   return false;\n }\n+\n+/* Return ture if address of N is possibly compared.  */\n+\n+static bool\n+address_matters_1 (symtab_node *n, void *)\n+{\n+  struct ipa_ref *ref;\n+\n+  if (!n->address_can_be_compared_p ())\n+    return false;\n+  if (n->externally_visible || n->force_output)\n+    return true;\n+\n+  for (unsigned int i = 0; n->iterate_referring (i, ref); i++)\n+    if (ref->address_matters_p ())\n+      return true;\n+  return false;\n+}\n+\n+/* Return true if symbol's address may possibly be compared to other\n+   symbol's address.  */\n+\n+bool\n+symtab_node::address_matters_p ()\n+{\n+  gcc_assert (!alias);\n+  return call_for_symbol_and_aliases (address_matters_1, NULL, true);\n+}"}, {"sha": "3566d03436568cbfaace9a7630d8da573fff9bc9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1,3 +1,13 @@\n+2015-02-26  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\tPR bootstrap/65150\n+\t* gcc.dg/pr64454.c: Disable ICF.\n+\t* gcc.dg/pr28685-1.c: Disable ICF\n+\t* gcc.dg/ipa/iinline-5.c: Disable ICF.\n+\t* g++.dg/warn/Wsuggest-final.C: Force methods to be different.\n+\t* g++.dg/ipa/ipa-icf-4.C: Update template.\n+\n 2015-02-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/65216"}, {"sha": "2cd7a2eed3a999b18fe95a51329d48a5c49b3e0c", "filename": "gcc/testsuite/g++.dg/ipa/ipa-icf-4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-icf-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-icf-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-icf-4.C?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -43,6 +43,6 @@ int main()\n   return 123;\n }\n \n-/* { dg-final { scan-ipa-dump \"\\(Varpool alias has been created\\)|\\(Symbol aliases are not supported by target\\)\" \"icf\"  } } */\n+/* { dg-final { scan-ipa-dump \"\\(Unified; Variable alias has been created\\)|\\(Symbol aliases are not supported by target\\)\" \"icf\"  } } */\n /* { dg-final { scan-ipa-dump \"Equal symbols: 6\" \"icf\"  } } */\n /* { dg-final { cleanup-ipa-dump \"icf\" } } */"}, {"sha": "f1d419e144acda2139be476fc6e3bfa35b8ce493", "filename": "gcc/testsuite/g++.dg/warn/Wsuggest-final.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsuggest-final.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsuggest-final.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsuggest-final.C?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1,8 +1,9 @@\n // { dg-do compile }\n // { dg-options \"-O2 -Wsuggest-final-types -Wsuggest-final-methods\" }\n+int c;\n struct A { // { dg-warning \"final would enable devirtualization of 4 calls\" }\n virtual void a() {} // { dg-warning \"final would enable devirtualization of 2 calls\" }\n- virtual void b() {} // { dg-warning \"final would enable devirtualization of 2 calls\"  }\n+ virtual void b() {c++;} // { dg-warning \"final would enable devirtualization of 2 calls\"  }\n };\n void\n t(struct A *a)"}, {"sha": "b83b8c25a92c1fa2c36ecd96e55196ef030e5010", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-5.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1,7 +1,7 @@\n /* Verify that simple indirect calls are inlined even without early\n    inlining..  */\n /* { dg-do run } */\n-/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining\"  } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-icf\"  } */\n \n extern void abort (void);\n "}, {"sha": "b1ec4d4bb66b059c7c1295142c254532a51bbd0a", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-cp-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-cp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-cp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-cp-1.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-cp\"  } */\n+int n;\n+\n+static void\n+__attribute__ ((noinline))\n+test(void *a)\n+{\n+  __builtin_memset (a,0,n);\n+}\n+\n+int\n+main()\n+{\n+  int aa;\n+  short bb;\n+  test (&aa);\n+  test (&bb);\n+  return 0;\n+}\n+/* { dg-final { scan-ipa-dump \"Alignment 2\"  \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "0dbbcf1c0e156dfe048f50be85dd064eabfce300", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-cp-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-cp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-cp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-cp-2.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-cp\"  } */\n+int n;\n+\n+static void\n+__attribute__ ((noinline))\n+test(void *a)\n+{\n+  __builtin_memset (a,0,n);\n+}\n+\n+static __attribute__ ((aligned(16))) int aa[10];\n+\n+int\n+main()\n+{\n+  test (&aa[1]);\n+  test (&aa[3]);\n+  return 0;\n+}\n+/* { dg-final { scan-ipa-dump \"Alignment 8, misalignment 4\"  \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "1eb8c2d457bc50328236b722e2971c6206c4558d", "filename": "gcc/testsuite/gcc.dg/pr28685-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28685-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28685-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28685-1.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" }  */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fno-ipa-icf\" }  */\n \n /* Should produce <=.  */\n int test1 (int a, int b)"}, {"sha": "35542349c707f788dc928145bb911d8ec6f9e837", "filename": "gcc/testsuite/gcc.dg/pr64454.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64454.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7246ee3887147e6934684ecf768ebe929a975e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64454.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64454.c?ref=0a7246ee3887147e6934684ecf768ebe929a975e", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/64454 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1 -fno-ipa-icf\" } */\n \n unsigned\n f1 (unsigned x)"}]}