{"sha": "ec2dd67a4e27946cb81f63bea02db355f30a36f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyZGQ2N2E0ZTI3OTQ2Y2I4MWY2M2JlYTAyZGIzNTVmMzBhMzZmOQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-05-20T12:44:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:44:23Z"}, "message": "checks.adb (Apply_Arithmetic_Overflow_Check): Avoid intermediate overflow if result converted to wider integer type.\n\n2008-05-20  Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* checks.adb (Apply_Arithmetic_Overflow_Check): Avoid intermediate\n\toverflow if result converted to wider integer type.\n\t(Apply_Type_Conversion_Checks): Don't emit checks on conversions to\n\tdiscriminated types when discriminant checks are suppressed.\n\nFrom-SVN: r135616", "tree": {"sha": "26b6bdd22686a877ec6acac6e34c19c2037b8bf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26b6bdd22686a877ec6acac6e34c19c2037b8bf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec2dd67a4e27946cb81f63bea02db355f30a36f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2dd67a4e27946cb81f63bea02db355f30a36f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec2dd67a4e27946cb81f63bea02db355f30a36f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2dd67a4e27946cb81f63bea02db355f30a36f9/comments", "author": null, "committer": null, "parents": [{"sha": "57f56c63cb82353c64404ccf3cfe338ed3ea61be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57f56c63cb82353c64404ccf3cfe338ed3ea61be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57f56c63cb82353c64404ccf3cfe338ed3ea61be"}], "stats": {"total": 313, "additions": 211, "deletions": 102}, "files": [{"sha": "aea61397dc98e24eefeec04537011859672a6fc0", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 211, "deletions": 102, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec2dd67a4e27946cb81f63bea02db355f30a36f9/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec2dd67a4e27946cb81f63bea02db355f30a36f9/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=ec2dd67a4e27946cb81f63bea02db355f30a36f9", "patch": "@@ -765,148 +765,256 @@ package body Checks is\n    -- Apply_Arithmetic_Overflow_Check --\n    -------------------------------------\n \n-   --  This routine is called only if the type is an integer type, and\n-   --  a software arithmetic overflow check must be performed for op\n-   --  (add, subtract, multiply). The check is performed only if\n-   --  Software_Overflow_Checking is enabled and Do_Overflow_Check\n-   --  is set. In this case we expand the operation into a more complex\n-   --  sequence of tests that ensures that overflow is properly caught.\n+   --  This routine is called only if the type is an integer type, and a\n+   --  software arithmetic overflow check may be needed for op (add, subtract,\n+   --  or multiply). This check is performed only if Software_Overflow_Checking\n+   --  is enabled and Do_Overflow_Check is set. In this case we expand the\n+   --  operation into a more complex sequence of tests that ensures that\n+   --  overflow is properly caught.\n \n    procedure Apply_Arithmetic_Overflow_Check (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n-      Typ   : constant Entity_Id  := Etype (N);\n-      Rtyp  : constant Entity_Id  := Root_Type (Typ);\n-      Siz   : constant Int        := UI_To_Int (Esize (Rtyp));\n-      Dsiz  : constant Int        := Siz * 2;\n-      Opnod : Node_Id;\n-      Ctyp  : Entity_Id;\n-      Opnd  : Node_Id;\n-      Cent  : RE_Id;\n+      Typ   : Entity_Id           := Etype (N);\n+      Rtyp  : Entity_Id           := Root_Type (Typ);\n \n    begin\n-      --  Skip this if overflow checks are done in back end, or the overflow\n-      --  flag is not set anyway, or we are not doing code expansion.\n-      --  Special case CLI target, where arithmetic overflow checks can be\n-      --  performed for integer and long_integer\n-\n-      if Backend_Overflow_Checks_On_Target\n-        or else (VM_Target = CLI_Target and then Siz >= Standard_Integer_Size)\n-        or else not Do_Overflow_Check (N)\n-        or else not Expander_Active\n+      --  An interesting special case. If the arithmetic operation appears as\n+      --  the operand of a type conversion:\n+\n+      --    type1 (x op y)\n+\n+      --  and all the following conditions apply:\n+\n+      --    arithmetic operation is for a signed integer type\n+      --    target type type1 is a static integer subtype\n+      --    range of x and y are both included in the range of type1\n+      --    range of x op y is included in the range of type1\n+      --    size of type1 is at least twice the result size of op\n+\n+      --  then we don't do an overflow check in any case, instead we transform\n+      --  the operation so that we end up with:\n+\n+      --    type1 (type1 (x) op type1 (y))\n+\n+      --  This avoids intermediate overflow before the conversion. It is\n+      --  explicitly permitted by RM 3.5.4(24):\n+\n+      --    For the execution of a predefined operation of a signed integer\n+      --    type, the implementation need not raise Constraint_Error if the\n+      --    result is outside the base range of the type, so long as the\n+      --    correct result is produced.\n+\n+      --  It's hard to imagine that any programmer counts on the exception\n+      --  being raised in this case, and in any case it's wrong coding to\n+      --  have this expectation, given the RM permission. Furthermore, other\n+      --  Ada compilers do allow such out of range results.\n+\n+      --  Note that we do this transformation even if overflow checking is\n+      --  off, since this is precisely about giving the \"right\" result and\n+      --  avoiding the need for an overflow check.\n+\n+      if Is_Signed_Integer_Type (Typ)\n+        and then Nkind (Parent (N)) = N_Type_Conversion\n       then\n-         return;\n+         declare\n+            Target_Type : constant Entity_Id :=\n+                            Base_Type (Entity (Subtype_Mark (Parent (N))));\n+\n+            Llo, Lhi : Uint;\n+            Rlo, Rhi : Uint;\n+            LOK, ROK : Boolean;\n+\n+            Vlo : Uint;\n+            Vhi : Uint;\n+            VOK : Boolean;\n+\n+            Tlo : Uint;\n+            Thi : Uint;\n+\n+         begin\n+            if Is_Integer_Type (Target_Type)\n+              and then RM_Size (Root_Type (Target_Type)) >= 2 * RM_Size (Rtyp)\n+            then\n+               Tlo := Expr_Value (Type_Low_Bound  (Target_Type));\n+               Thi := Expr_Value (Type_High_Bound (Target_Type));\n+\n+               Determine_Range (Left_Opnd  (N), LOK, Llo, Lhi);\n+               Determine_Range (Right_Opnd (N), ROK, Rlo, Rhi);\n+\n+               if (LOK and ROK)\n+                 and then Tlo <= Llo and then Lhi <= Thi\n+                 and then Tlo <= Rlo and then Rhi <= Thi\n+               then\n+                  Determine_Range (N, VOK, Vlo, Vhi);\n+\n+                  if VOK and then Tlo <= Vlo and then Vhi <= Thi then\n+                     Rewrite (Left_Opnd (N),\n+                       Make_Type_Conversion (Loc,\n+                         Subtype_Mark => New_Occurrence_Of (Target_Type, Loc),\n+                         Expression   => Relocate_Node (Left_Opnd (N))));\n+\n+                     Rewrite (Right_Opnd (N),\n+                       Make_Type_Conversion (Loc,\n+                        Subtype_Mark => New_Occurrence_Of (Target_Type, Loc),\n+                        Expression   => Relocate_Node (Right_Opnd (N))));\n+\n+                     Set_Etype (N, Target_Type);\n+                     Typ := Target_Type;\n+                     Rtyp := Root_Type (Typ);\n+                     Analyze_And_Resolve (Left_Opnd  (N), Target_Type);\n+                     Analyze_And_Resolve (Right_Opnd (N), Target_Type);\n+\n+                     --  Given that the target type is twice the size of the\n+                     --  source type, overflow is now impossible, so we can\n+                     --  safely kill the overflow check and return.\n+\n+                     Set_Do_Overflow_Check (N, False);\n+                     return;\n+                  end if;\n+               end if;\n+            end if;\n+         end;\n       end if;\n \n-      --  Otherwise, we generate the full general code for front end overflow\n-      --  detection, which works by doing arithmetic in a larger type:\n+      --  Now see if an overflow check is required\n+\n+      declare\n+         Siz   : constant Int := UI_To_Int (Esize (Rtyp));\n+         Dsiz  : constant Int := Siz * 2;\n+         Opnod : Node_Id;\n+         Ctyp  : Entity_Id;\n+         Opnd  : Node_Id;\n+         Cent  : RE_Id;\n+\n+      begin\n+         --  Skip check if back end does overflow checks, or the overflow flag\n+         --  is not set anyway, or we are not doing code expansion.\n+\n+         --  Special case CLI target, where arithmetic overflow checks can be\n+         --  performed for integer and long_integer\n \n-      --    x op y\n+         if Backend_Overflow_Checks_On_Target\n+           or else not Do_Overflow_Check (N)\n+           or else not Expander_Active\n+           or else\n+             (VM_Target = CLI_Target and then Siz >= Standard_Integer_Size)\n+         then\n+            return;\n+         end if;\n \n-      --  is expanded into\n+         --  Otherwise, generate the full general code for front end overflow\n+         --  detection, which works by doing arithmetic in a larger type:\n \n-      --    Typ (Checktyp (x) op Checktyp (y));\n+         --    x op y\n \n-      --  where Typ is the type of the original expression, and Checktyp is\n-      --  an integer type of sufficient length to hold the largest possible\n-      --  result.\n+         --  is expanded into\n \n-      --  In the case where check type exceeds the size of Long_Long_Integer,\n-      --  we use a different approach, expanding to:\n+         --    Typ (Checktyp (x) op Checktyp (y));\n \n-      --    typ (xxx_With_Ovflo_Check (Integer_64 (x), Integer (y)))\n+         --  where Typ is the type of the original expression, and Checktyp is\n+         --  an integer type of sufficient length to hold the largest possible\n+         --  result.\n \n-      --  where xxx is Add, Multiply or Subtract as appropriate\n+         --  If the size of check type exceeds the size of Long_Long_Integer,\n+         --  we use a different approach, expanding to:\n \n-      --  Find check type if one exists\n+         --    typ (xxx_With_Ovflo_Check (Integer_64 (x), Integer (y)))\n \n-      if Dsiz <= Standard_Integer_Size then\n-         Ctyp := Standard_Integer;\n+         --  where xxx is Add, Multiply or Subtract as appropriate\n \n-      elsif Dsiz <= Standard_Long_Long_Integer_Size then\n-         Ctyp := Standard_Long_Long_Integer;\n+         --  Find check type if one exists\n \n-      --  No check type exists, use runtime call\n+         if Dsiz <= Standard_Integer_Size then\n+            Ctyp := Standard_Integer;\n \n-      else\n-         if Nkind (N) = N_Op_Add then\n-            Cent := RE_Add_With_Ovflo_Check;\n+         elsif Dsiz <= Standard_Long_Long_Integer_Size then\n+            Ctyp := Standard_Long_Long_Integer;\n \n-         elsif Nkind (N) = N_Op_Multiply then\n-            Cent := RE_Multiply_With_Ovflo_Check;\n+            --  No check type exists, use runtime call\n \n          else\n-            pragma Assert (Nkind (N) = N_Op_Subtract);\n-            Cent := RE_Subtract_With_Ovflo_Check;\n-         end if;\n+            if Nkind (N) = N_Op_Add then\n+               Cent := RE_Add_With_Ovflo_Check;\n \n-         Rewrite (N,\n-           OK_Convert_To (Typ,\n-             Make_Function_Call (Loc,\n-               Name => New_Reference_To (RTE (Cent), Loc),\n-               Parameter_Associations => New_List (\n-                 OK_Convert_To (RTE (RE_Integer_64), Left_Opnd  (N)),\n-                 OK_Convert_To (RTE (RE_Integer_64), Right_Opnd (N))))));\n+            elsif Nkind (N) = N_Op_Multiply then\n+               Cent := RE_Multiply_With_Ovflo_Check;\n \n-         Analyze_And_Resolve (N, Typ);\n-         return;\n-      end if;\n+            else\n+               pragma Assert (Nkind (N) = N_Op_Subtract);\n+               Cent := RE_Subtract_With_Ovflo_Check;\n+            end if;\n+\n+            Rewrite (N,\n+              OK_Convert_To (Typ,\n+                Make_Function_Call (Loc,\n+                  Name => New_Reference_To (RTE (Cent), Loc),\n+                  Parameter_Associations => New_List (\n+                    OK_Convert_To (RTE (RE_Integer_64), Left_Opnd  (N)),\n+                    OK_Convert_To (RTE (RE_Integer_64), Right_Opnd (N))))));\n \n-      --  If we fall through, we have the case where we do the arithmetic in\n-      --  the next higher type and get the check by conversion. In these cases\n-      --  Ctyp is set to the type to be used as the check type.\n+            Analyze_And_Resolve (N, Typ);\n+            return;\n+         end if;\n \n-      Opnod := Relocate_Node (N);\n+         --  If we fall through, we have the case where we do the arithmetic\n+         --  in the next higher type and get the check by conversion. In these\n+         --  cases Ctyp is set to the type to be used as the check type.\n \n-      Opnd := OK_Convert_To (Ctyp, Left_Opnd (Opnod));\n+         Opnod := Relocate_Node (N);\n \n-      Analyze (Opnd);\n-      Set_Etype (Opnd, Ctyp);\n-      Set_Analyzed (Opnd, True);\n-      Set_Left_Opnd (Opnod, Opnd);\n+         Opnd := OK_Convert_To (Ctyp, Left_Opnd (Opnod));\n \n-      Opnd := OK_Convert_To (Ctyp, Right_Opnd (Opnod));\n+         Analyze (Opnd);\n+         Set_Etype (Opnd, Ctyp);\n+         Set_Analyzed (Opnd, True);\n+         Set_Left_Opnd (Opnod, Opnd);\n \n-      Analyze (Opnd);\n-      Set_Etype (Opnd, Ctyp);\n-      Set_Analyzed (Opnd, True);\n-      Set_Right_Opnd (Opnod, Opnd);\n+         Opnd := OK_Convert_To (Ctyp, Right_Opnd (Opnod));\n \n-      --  The type of the operation changes to the base type of the check type,\n-      --  and we reset the overflow check indication, since clearly no overflow\n-      --  is possible now that we are using a double length type. We also set\n-      --  the Analyzed flag to avoid a recursive attempt to expand the node.\n+         Analyze (Opnd);\n+         Set_Etype (Opnd, Ctyp);\n+         Set_Analyzed (Opnd, True);\n+         Set_Right_Opnd (Opnod, Opnd);\n \n-      Set_Etype             (Opnod, Base_Type (Ctyp));\n-      Set_Do_Overflow_Check (Opnod, False);\n-      Set_Analyzed          (Opnod, True);\n+         --  The type of the operation changes to the base type of the check\n+         --  type, and we reset the overflow check indication, since clearly no\n+         --  overflow is possible now that we are using a double length type.\n+         --  We also set the Analyzed flag to avoid a recursive attempt to\n+         --  expand the node.\n \n-      --  Now build the outer conversion\n+         Set_Etype             (Opnod, Base_Type (Ctyp));\n+         Set_Do_Overflow_Check (Opnod, False);\n+         Set_Analyzed          (Opnod, True);\n \n-      Opnd := OK_Convert_To (Typ, Opnod);\n-      Analyze (Opnd);\n-      Set_Etype (Opnd, Typ);\n+         --  Now build the outer conversion\n \n-      --  In the discrete type case, we directly generate the range check for\n-      --  the outer operand. This range check will implement the required\n-      --  overflow check.\n+         Opnd := OK_Convert_To (Typ, Opnod);\n+         Analyze (Opnd);\n+         Set_Etype (Opnd, Typ);\n \n-      if Is_Discrete_Type (Typ) then\n-         Rewrite (N, Opnd);\n-         Generate_Range_Check (Expression (N), Typ, CE_Overflow_Check_Failed);\n+         --  In the discrete type case, we directly generate the range check\n+         --  for the outer operand. This range check will implement the\n+         --  required overflow check.\n \n-      --  For other types, we enable overflow checking on the conversion,\n-      --  after setting the node as analyzed to prevent recursive attempts\n-      --  to expand the conversion node.\n+         if Is_Discrete_Type (Typ) then\n+            Rewrite (N, Opnd);\n+            Generate_Range_Check\n+              (Expression (N), Typ, CE_Overflow_Check_Failed);\n \n-      else\n-         Set_Analyzed (Opnd, True);\n-         Enable_Overflow_Check (Opnd);\n-         Rewrite (N, Opnd);\n-      end if;\n+         --  For other types, we enable overflow checking on the conversion,\n+         --  after setting the node as analyzed to prevent recursive attempts\n+         --  to expand the conversion node.\n \n-   exception\n-      when RE_Not_Available =>\n-         return;\n+         else\n+            Set_Analyzed (Opnd, True);\n+            Enable_Overflow_Check (Opnd);\n+            Rewrite (N, Opnd);\n+         end if;\n+\n+      exception\n+         when RE_Not_Available =>\n+            return;\n+      end;\n    end Apply_Arithmetic_Overflow_Check;\n \n    ----------------------------\n@@ -2231,6 +2339,7 @@ package body Checks is\n          end;\n \n       elsif Comes_From_Source (N)\n+        and then not Discriminant_Checks_Suppressed (Target_Type)\n         and then Is_Record_Type (Target_Type)\n         and then Is_Derived_Type (Target_Type)\n         and then not Is_Tagged_Type (Target_Type)"}]}