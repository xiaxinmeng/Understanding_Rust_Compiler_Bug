{"sha": "1634705dd6bf842b1dca21c690a38b3fdbef53a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYzNDcwNWRkNmJmODQyYjFkY2EyMWM2OTBhMzhiM2ZkYmVmNTNhNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-09-06T02:12:30Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-09-06T02:12:30Z"}, "message": "cp-tree.h, [...]: Fix comment typos.\n\n\t* cp-tree.h, decl.c, decl2.c, semantics.c: Fix comment typos.\n\tFollow spelling conventions.\n\nFrom-SVN: r103926", "tree": {"sha": "83dd791d18b8133d0e69edb0dec8d92f1dd2a805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83dd791d18b8133d0e69edb0dec8d92f1dd2a805"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1634705dd6bf842b1dca21c690a38b3fdbef53a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1634705dd6bf842b1dca21c690a38b3fdbef53a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1634705dd6bf842b1dca21c690a38b3fdbef53a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1634705dd6bf842b1dca21c690a38b3fdbef53a4/comments", "author": null, "committer": null, "parents": [{"sha": "57b51d4d635b49b94ace7d83ef0294f58dcb64f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57b51d4d635b49b94ace7d83ef0294f58dcb64f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57b51d4d635b49b94ace7d83ef0294f58dcb64f7"}], "stats": {"total": 19, "additions": 12, "deletions": 7}, "files": [{"sha": "4c73cfcb72d409646fe6fdfa8636e55e6a1d72d2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1634705dd6bf842b1dca21c690a38b3fdbef53a4", "patch": "@@ -1,3 +1,8 @@\n+2005-09-06  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* cp-tree.h, decl.c, decl2.c, semantics.c: Fix comment typos.\n+\tFollow spelling conventions.\n+\n 2005-09-05  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/23667"}, {"sha": "4d5d618950ec589847b28f8a75bb6b6e543446a8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1634705dd6bf842b1dca21c690a38b3fdbef53a4", "patch": "@@ -1177,12 +1177,12 @@ struct lang_type GTY(())\n /* Mark bits for repeated base checks.  */\n #define TYPE_MARKED_P(NODE) TREE_LANG_FLAG_6 (TYPE_CHECK (NODE))\n \n-/* Non-zero if the class NODE has multiple paths to the same (virtual)\n+/* Nonzero if the class NODE has multiple paths to the same (virtual)\n    base object.  */\n #define CLASSTYPE_DIAMOND_SHAPED_P(NODE) \\\n   (LANG_TYPE_CLASS_CHECK(NODE)->diamond_shaped)\n \n-/* Non-zero if the class NODE has multiple instances of the same base\n+/* Nonzero if the class NODE has multiple instances of the same base\n    type.  */\n #define CLASSTYPE_REPEATED_BASE_P(NODE) \\\n   (LANG_TYPE_CLASS_CHECK(NODE)->repeated_base)\n@@ -2065,7 +2065,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    template.  \n \n    In general, DECL_TEMPLATE_INFO is non-NULL only if\n-   DECL_USE_TEMPLATE is non-zero.  However, for friends, we sometimes\n+   DECL_USE_TEMPLATE is nonzero.  However, for friends, we sometimes\n    have DECL_TEMPLATE_INFO even when DECL_USE_TEMPLATE is zero.\n    Consider:\n \n@@ -2784,7 +2784,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n      2=explicit template specialization, e.g. int min<int> (int, int);\n      3=explicit template instantiation, e.g. template int min<int> (int, int);\n \n-   If DECL_USE_TEMPLATE is non-zero, then DECL_TEMPLATE_INFO will also\n+   If DECL_USE_TEMPLATE is nonzero, then DECL_TEMPLATE_INFO will also\n    be non-NULL.  */\n #define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.use_template)\n "}, {"sha": "1d887bf353d5e4c58c2784132c5f62043da88f8a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1634705dd6bf842b1dca21c690a38b3fdbef53a4", "patch": "@@ -4924,7 +4924,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t    }\n \n \t  /* Check that the initializer for a static data member was a\n-\t     constant.  Althouh we check in the parser that the\n+\t     constant.  Although we check in the parser that the\n \t     initializer is an integral constant expression, we do not\n \t     simplify division-by-zero at the point at which it\n \t     occurs.  Therefore, in:"}, {"sha": "87ef85885eeca70d37fc05f7a52ce9e9bf0699b4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1634705dd6bf842b1dca21c690a38b3fdbef53a4", "patch": "@@ -1790,7 +1790,7 @@ import_export_decl (tree decl)\n \t      /* The generic C++ ABI says that class data is always\n \t\t COMDAT, even if there is a key function.  Some\n \t\t variants (e.g., the ARM EABI) says that class data\n-\t\t only has COMDAT linkage if the the class data might\n+\t\t only has COMDAT linkage if the class data might\n \t\t be emitted in more than one translation unit.  */\n \t      if (!CLASSTYPE_KEY_METHOD (class_type)\n \t\t  || targetm.cxx.class_data_always_comdat ())"}, {"sha": "074a7fdf081bd8e0a95c7adb27b474c6f50d5148", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634705dd6bf842b1dca21c690a38b3fdbef53a4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1634705dd6bf842b1dca21c690a38b3fdbef53a4", "patch": "@@ -1567,7 +1567,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t expression.  */\n       TREE_TYPE (stmt_expr) = type;\n       /* We must take particular care if TYPE is a class type.  In\n-\t paticular if EXPR creates a temporary of class type, then it\n+\t particular if EXPR creates a temporary of class type, then it\n \t must be destroyed at the semicolon terminating the last\n \t statement -- but we must make a copy before that happens.\n "}]}