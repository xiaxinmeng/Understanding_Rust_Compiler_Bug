{"sha": "1d8eeb6305f34833ff3ca867ace263ac5a46645a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ4ZWViNjMwNWYzNDgzM2ZmM2NhODY3YWNlMjYzYWM1YTQ2NjQ1YQ==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@apple.com", "date": "2005-07-06T21:08:02Z"}, "committer": {"name": "Fariborz Jahanian", "email": "fjahanian@gcc.gnu.org", "date": "2005-07-06T21:08:02Z"}, "message": "Removal of -fforce-mem.\n\nOKed by Richard Henderson.\n\nFrom-SVN: r101666", "tree": {"sha": "72f0defa1895cf089d7787f10f4d92c5a40899b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72f0defa1895cf089d7787f10f4d92c5a40899b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d8eeb6305f34833ff3ca867ace263ac5a46645a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d8eeb6305f34833ff3ca867ace263ac5a46645a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d8eeb6305f34833ff3ca867ace263ac5a46645a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d8eeb6305f34833ff3ca867ace263ac5a46645a/comments", "author": null, "committer": null, "parents": [{"sha": "c42adccb1a99b85613384a3847264c3cc51a12d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42adccb1a99b85613384a3847264c3cc51a12d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42adccb1a99b85613384a3847264c3cc51a12d7"}], "stats": {"total": 147, "additions": 32, "deletions": 115}, "files": [{"sha": "a75e4d4f847f8fe5532a4302c53684a129e8ccd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -1,3 +1,17 @@\n+2005-07-06  Fariborz Jahanian <fjahanian@apple.com>\n+\n+        * doc/invoke.texi: Update -fforce-mem documentation.\n+        * dojump.c (compare_from_rtx,do_compare_rtx_and_jump): Remove \n+        code for -fforce-mem.\n+        * expmed.c: (store_bit_field,store_fixed_bit_field,\n+        extract_bit_field): Ditto.\n+        * expr.c: (convert_move): Ditto.\n+        * optabs.c: (expand_binop,expand_twoval_unop,expand_twoval_binop,\n+        expand_unop,emit_unop_insn,prepare_cmp_insn,emit_conditional_move,\n+        emit_conditional_add,expand_float,expand_fix): Ditto.\n+        * opts.c: (decode_options): Remove setting of flag_force_mem flag.\n+        (common_handle_option): Issue warning when -fforce-mem specified.\n+\n 2005-07-06  Paul Brook  <paul@codesourcery.com>\n \n \t* aclocal.m4: Work around a bug in AC_PATH_PROGS when its last"}, {"sha": "f1ce356d0d5f7a7df14af3cfe1d1c3c9df2ab5fb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -102,7 +102,7 @@ of the same kind; for example, if you specify @option{-L} more than once,\n the directories are searched in the order specified.\n \n Many options have long names starting with @samp{-f} or with\n-@samp{-W}---for example, @option{-fforce-mem},\n+@samp{-W}---for example, \n @option{-fstrength-reduce}, @option{-Wformat} and so on.  Most of\n these have both positive and negative forms; the negative form of\n @option{-ffoo} would be @option{-fno-foo}.  This manual documents\n@@ -302,7 +302,7 @@ Objective-C and Objective-C++ Dialects}.\n -fcse-skip-blocks  -fcx-limited-range  -fdata-sections @gol\n -fdelayed-branch  -fdelete-null-pointer-checks -fearly-inlining @gol\n -fexpensive-optimizations  -ffast-math  -ffloat-store @gol\n--fforce-addr  -fforce-mem  -ffunction-sections @gol\n+-fforce-addr  -ffunction-sections @gol\n -fgcse  -fgcse-lm  -fgcse-sm  -fgcse-las  -fgcse-after-reload @gol\n -floop-optimize -fcrossjumping  -fif-conversion  -fif-conversion2 @gol\n -finline-functions  -finline-limit=@var{n}  -fkeep-inline-functions @gol\n@@ -4322,7 +4322,6 @@ also turns on the following optimization flags:\n -fstrength-reduce @gol\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n -fcaller-saves @gol\n--fforce-mem @gol\n -fpeephole2 @gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fsched-interblock  -fsched-spec @gol\n@@ -4399,15 +4398,12 @@ Force memory operands to be copied into registers before doing\n arithmetic on them.  This produces better code by making all memory\n references potential common subexpressions.  When they are not common\n subexpressions, instruction combination should eliminate the separate\n-register-load.\n-\n-Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+register-load. This option is now a nop and will be removed in 4.2.\n \n @item -fforce-addr\n @opindex fforce-addr\n Force memory address constants to be copied into registers before\n-doing arithmetic on them.  This may produce better code just as\n-@option{-fforce-mem} may.\n+doing arithmetic on them.\n \n @item -fomit-frame-pointer\n @opindex fomit-frame-pointer"}, {"sha": "741c30a8dca7f7f797cd33ea9ffea90b64a2fe11", "filename": "gcc/dojump.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -761,12 +761,6 @@ compare_from_rtx (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n       code = swap_condition (code);\n     }\n \n-  if (flag_force_mem)\n-    {\n-      op0 = force_not_mem (op0);\n-      op1 = force_not_mem (op1);\n-    }\n-\n   do_pending_stack_adjust ();\n \n   code = unsignedp ? unsigned_condition (code) : code;\n@@ -830,12 +824,6 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n       code = swap_condition (code);\n     }\n \n-  if (flag_force_mem)\n-    {\n-      op0 = force_not_mem (op0);\n-      op1 = force_not_mem (op1);\n-    }\n-\n   do_pending_stack_adjust ();\n \n   code = unsignedp ? unsigned_condition (code) : code;"}, {"sha": "e54f0430cf578a73b6129a8abaf0464a76733c85", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -408,14 +408,6 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t}\n     }\n \n-  if (flag_force_mem)\n-    {\n-      int old_generating_concat_p = generating_concat_p;\n-      generating_concat_p = 0;\n-      value = force_not_mem (value);\n-      generating_concat_p = old_generating_concat_p;\n-    }\n-\n   /* If the target is a register, overwriting the entire object, or storing\n      a full-word or multi-word field can be done with just a SUBREG.\n \n@@ -633,8 +625,6 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       /* If this machine's insv can only insert into a register, copy OP0\n \t into a register and save it back later.  */\n-      /* This used to check flag_force_mem, but that was a serious\n-\t de-optimization now that flag_force_mem is enabled by -O2.  */\n       if (MEM_P (op0)\n \t  && ! ((*insn_data[(int) CODE_FOR_insv].operand[0].predicate)\n \t\t(op0, VOIDmode)))\n@@ -902,7 +892,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n   /* Now clear the chosen bits in OP0,\n      except that if VALUE is -1 we need not bother.  */\n \n-  subtarget = (REG_P (op0) || ! flag_force_mem) ? op0 : 0;\n+  subtarget = op0;\n \n   if (! all_one)\n     {\n@@ -1449,8 +1439,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n \t  unit = GET_MODE_BITSIZE (maxmode);\n \n-\t  if (xtarget == 0\n-\t      || (flag_force_mem && MEM_P (xtarget)))\n+\t  if (xtarget == 0)\n \t    xtarget = xspec_target = gen_reg_rtx (tmode);\n \n \t  if (GET_MODE (xtarget) != maxmode)\n@@ -1577,8 +1566,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n \t  unit = GET_MODE_BITSIZE (maxmode);\n \n-\t  if (xtarget == 0\n-\t      || (flag_force_mem && MEM_P (xtarget)))\n+\t  if (xtarget == 0)\n \t    xtarget = xspec_target = gen_reg_rtx (tmode);\n \n \t  if (GET_MODE (xtarget) != maxmode)"}, {"sha": "2a1ecab51e8612ba4b000361f023d11cba83cdee", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -642,9 +642,6 @@ convert_move (rtx to, rtx from, int unsignedp)\n       if ((code = can_extend_p (to_mode, from_mode, unsignedp))\n \t  != CODE_FOR_nothing)\n \t{\n-\t  if (flag_force_mem)\n-\t    from = force_not_mem (from);\n-\n \t  emit_unop_insn (code, to, from, equiv_code);\n \t  return;\n \t}"}, {"sha": "60c491870a88f9866098ee8a7279cdabcf426b43", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 74, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -1030,21 +1030,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   class = GET_MODE_CLASS (mode);\n \n-  if (flag_force_mem)\n-    {\n-      /* Load duplicate non-volatile operands once.  */\n-      if (rtx_equal_p (op0, op1) && ! volatile_refs_p (op0))\n-\t{\n-\t  op0 = force_not_mem (op0);\n-\t  op1 = op0;\n-\t}\n-      else\n-\t{\n-\t  op0 = force_not_mem (op0);\n-\t  op1 = force_not_mem (op1);\n-\t}\n-    }\n-\n   /* If subtracting an integer constant, convert this into an addition of\n      the negated constant.  */\n \n@@ -1871,9 +1856,6 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n   class = GET_MODE_CLASS (mode);\n \n-  if (flag_force_mem)\n-    op0 = force_not_mem (op0);\n-\n   if (!targ0)\n     targ0 = gen_reg_rtx (mode);\n   if (!targ1)\n@@ -1966,12 +1948,6 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   class = GET_MODE_CLASS (mode);\n \n-  if (flag_force_mem)\n-    {\n-      op0 = force_not_mem (op0);\n-      op1 = force_not_mem (op1);\n-    }\n-\n   /* If we are inside an appropriately-short loop and we are optimizing,\n      force expensive constants into a register.  */\n   if (CONSTANT_P (op0) && optimize\n@@ -2358,9 +2334,6 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   class = GET_MODE_CLASS (mode);\n \n-  if (flag_force_mem)\n-    op0 = force_not_mem (op0);\n-\n   if (unoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n       int icode = (int) unoptab->handlers[(int) mode].insn_code;\n@@ -2987,19 +2960,12 @@ emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n \n   temp = target;\n \n-  /* Sign and zero extension from memory is often done specially on\n-     RISC machines, so forcing into a register here can pessimize\n-     code.  */\n-  if (flag_force_mem && code != SIGN_EXTEND && code != ZERO_EXTEND)\n-    op0 = force_not_mem (op0);\n-\n   /* Now, if insn does not accept our operands, put them into pseudos.  */\n \n   if (!insn_data[icode].operand[1].predicate (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n \n-  if (!insn_data[icode].operand[0].predicate (temp, GET_MODE (temp))\n-      || (flag_force_mem && MEM_P (temp)))\n+  if (!insn_data[icode].operand[0].predicate (temp, GET_MODE (temp)))\n     temp = gen_reg_rtx (GET_MODE (temp));\n \n   pat = GEN_FCN (icode) (temp, op0);\n@@ -3415,21 +3381,6 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \n   class = GET_MODE_CLASS (mode);\n \n-  if (mode != BLKmode && flag_force_mem)\n-    {\n-      /* Load duplicate non-volatile operands once.  */\n-      if (rtx_equal_p (x, y) && ! volatile_refs_p (x))\n-\t{\n-\t  x = force_not_mem (x);\n-\t  y = x;\n-\t}\n-      else\n-\t{\n-\t  x = force_not_mem (x);\n-\t  y = force_not_mem (y);\n-\t}\n-    }\n-\n   /* If we are inside an appropriately-short loop and we are optimizing,\n      force expensive constants into a register.  */\n   if (CONSTANT_P (x) && optimize\n@@ -3916,12 +3867,6 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  if (flag_force_mem)\n-    {\n-      op2 = force_not_mem (op2);\n-      op3 = force_not_mem (op3);\n-    }\n-\n   if (!target)\n     target = gen_reg_rtx (mode);\n \n@@ -4050,12 +3995,6 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  if (flag_force_mem)\n-    {\n-      op2 = force_not_mem (op2);\n-      op3 = force_not_mem (op3);\n-    }\n-\n   if (!target)\n     target = gen_reg_rtx (mode);\n \n@@ -4379,9 +4318,6 @@ expand_float (rtx to, rtx from, int unsignedp)\n       rtx temp;\n       REAL_VALUE_TYPE offset;\n \n-      if (flag_force_mem)\n-\tfrom = force_not_mem (from);\n-\n       /* Look for a usable floating mode FMODE wider than the source and at\n \t least as wide as the target.  Using FMODE will avoid rounding woes\n \t with unsigned values greater than the signed maximum value.  */\n@@ -4489,9 +4425,6 @@ expand_float (rtx to, rtx from, int unsignedp)\n       if (GET_MODE_SIZE (GET_MODE (from)) < GET_MODE_SIZE (SImode))\n \tfrom = convert_to_mode (SImode, from, unsignedp);\n \n-      if (flag_force_mem)\n-\tfrom = force_not_mem (from);\n-\n       libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n       gcc_assert (libfunc);\n \n@@ -4609,9 +4542,6 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \t  lab1 = gen_label_rtx ();\n \t  lab2 = gen_label_rtx ();\n \n-\t  if (flag_force_mem)\n-\t    from = force_not_mem (from);\n-\n \t  if (fmode != GET_MODE (from))\n \t    from = convert_to_mode (fmode, from, 0);\n \n@@ -4678,9 +4608,6 @@ expand_fix (rtx to, rtx from, int unsignedp)\n       libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n       gcc_assert (libfunc);\n \n-      if (flag_force_mem)\n-\tfrom = force_not_mem (from);\n-\n       start_sequence ();\n \n       value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,"}, {"sha": "e5e490d16eb4dcb62fb809e35f10e78827ec8637", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -560,7 +560,6 @@ decode_options (unsigned int argc, const char **argv)\n       flag_rerun_cse_after_loop = 1;\n       flag_rerun_loop_opt = 1;\n       flag_caller_saves = 1;\n-      flag_force_mem = 1;\n       flag_peephole2 = 1;\n #ifdef INSN_SCHEDULING\n       flag_schedule_insns = 1;\n@@ -1042,6 +1041,10 @@ common_handle_option (size_t scode, const char *arg, int value)\n       flag_pedantic_errors = pedantic = 1;\n       break;\n \n+    case OPT_fforce_mem:\n+      warning (0, \"-f[no-]force-mem is nop and option will be removed in 4.2\");\n+      break;\n+\n     default:\n       /* If the flag was handled in a standard way, assume the lack of\n \t processing here is intentional.  */"}, {"sha": "445ac810b40194d3a6a74deb589f7c501a323e75", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -1,3 +1,8 @@\n+2005-07-06  Fariborz Jahanian <fjahanian@apple.com>\n+\n+\t* gcc.dg/20030324-1.c: Remove -fforce-mem option.\n+\t* gcc.dg/980816-1.c: Ditto.\n+\n 2005-07-06  Jeff Law  <law@redhat.com>\n \n \t* gcc.c-torture/compile/pr21356.c: New test."}, {"sha": "f141bafa927ea283aca89583597c3eeabf45e10c", "filename": "gcc/testsuite/gcc.dg/20030324-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Ftestsuite%2Fgcc.dg%2F20030324-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Ftestsuite%2Fgcc.dg%2F20030324-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030324-1.c?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O -fstrength-reduce -fstrict-aliasing -fforce-mem -fgcse\" } */\n+/* { dg-options \"-O -fstrength-reduce -fstrict-aliasing -fgcse\" } */\n \n /* PR optimization/10087 */\n /* Contributed by Peter van Hoof <p.van-hoof@qub.ac.uk> */"}, {"sha": "d4f59c40c538be32f4a5fb14c711effc9fbcf8a8", "filename": "gcc/testsuite/gcc.dg/980816-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Ftestsuite%2Fgcc.dg%2F980816-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d8eeb6305f34833ff3ca867ace263ac5a46645a/gcc%2Ftestsuite%2Fgcc.dg%2F980816-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F980816-1.c?ref=1d8eeb6305f34833ff3ca867ace263ac5a46645a", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do compile } */\n-/* { dg-options -fno-force-mem } */\n \n int\n div_and_round_double (lden_orig, hden_orig)"}]}