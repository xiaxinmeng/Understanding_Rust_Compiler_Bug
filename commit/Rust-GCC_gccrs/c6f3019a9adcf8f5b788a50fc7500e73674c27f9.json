{"sha": "c6f3019a9adcf8f5b788a50fc7500e73674c27f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZmMzAxOWE5YWRjZjhmNWI3ODhhNTBmYzc1MDBlNzM2NzRjMjdmOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-09-20T07:43:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-09-20T07:43:49Z"}, "message": "dse.c (find_shift_sequence): No-op rework of control flow.\n\ngcc/\n\t* dse.c (find_shift_sequence): No-op rework of control flow.\n\nFrom-SVN: r128614", "tree": {"sha": "4352dbe95763799c64b26388cdb830ead1b476da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4352dbe95763799c64b26388cdb830ead1b476da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6f3019a9adcf8f5b788a50fc7500e73674c27f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f3019a9adcf8f5b788a50fc7500e73674c27f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6f3019a9adcf8f5b788a50fc7500e73674c27f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f3019a9adcf8f5b788a50fc7500e73674c27f9/comments", "author": null, "committer": null, "parents": [{"sha": "6d3b5aea0bf4c92befdc226bc85e0445a7b50c59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3b5aea0bf4c92befdc226bc85e0445a7b50c59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d3b5aea0bf4c92befdc226bc85e0445a7b50c59"}], "stats": {"total": 108, "additions": 52, "deletions": 56}, "files": [{"sha": "5829711c123dedd082061e50b471f0f3c26ece0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f3019a9adcf8f5b788a50fc7500e73674c27f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f3019a9adcf8f5b788a50fc7500e73674c27f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6f3019a9adcf8f5b788a50fc7500e73674c27f9", "patch": "@@ -1,3 +1,7 @@\n+2007-09-20  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* dse.c (find_shift_sequence): No-op rework of control flow.\n+\n 2007-09-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.c (build_mips16_call_stub): Tidy.  Fix second"}, {"sha": "7bf759d45fc38f837d9a13d0f618cacaecab30c5", "filename": "gcc/dse.c", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f3019a9adcf8f5b788a50fc7500e73674c27f9/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f3019a9adcf8f5b788a50fc7500e73674c27f9/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=c6f3019a9adcf8f5b788a50fc7500e73674c27f9", "patch": "@@ -1399,6 +1399,7 @@ find_shift_sequence (rtx read_reg,\n {\n   enum machine_mode store_mode = GET_MODE (store_info->mem);\n   enum machine_mode read_mode = GET_MODE (read_info->mem);\n+  rtx chosen_seq = NULL;\n \n   /* Some machines like the x86 have shift insns for each size of\n      operand.  Other machines like the ppc or the ia-64 may only have\n@@ -1409,8 +1410,9 @@ find_shift_sequence (rtx read_reg,\n \n   for (; access_size < UNITS_PER_WORD; access_size *= 2)\n     {\n-      rtx target, new_reg;\n+      rtx target, new_reg, shift_seq, insn;\n       enum machine_mode new_mode;\n+      int cost;\n \n       /* Try a wider mode if truncating the store mode to ACCESS_SIZE\n \t bytes requires a real instruction.  */\n@@ -1431,67 +1433,57 @@ find_shift_sequence (rtx read_reg,\n       target = expand_binop (new_mode, lshr_optab, new_reg,\n \t\t\t     GEN_INT (shift), new_reg, 1, OPTAB_DIRECT);\n \n-      if (target == new_reg)\n-\t{\n-\t  rtx shift_seq = get_insns ();\n-\t  end_sequence ();\n+      shift_seq = get_insns ();\n+      end_sequence ();\n \n-\t  /* If cost is too great, set target to NULL and\n-\t     let the iteration happen. */\n-\t  if (shift_seq != NULL)\n-\t    {\n-\t      int cost = 0;\n-\t      rtx insn;\n-\n-\t      for (insn = shift_seq; insn != NULL_RTX; insn = NEXT_INSN (insn))\n-\t\tif (INSN_P (insn))\n-\t\t  cost += insn_rtx_cost (PATTERN (insn));\n-\n-\t      /* The computation up to here is essentially independent\n-\t\t of the arguments and could be precomputed.  It may\n-\t\t not be worth doing so.  We could precompute if\n-\t\t worthwhile or at least cache the results.  The result\n-\t\t technically depends on SHIFT, ACCESS_SIZE, and\n-\t\t GET_MODE_CLASS (READ_MODE).  But in practice the\n-\t\t answer will depend only on ACCESS_SIZE.  */\n-\n-\t      if (cost <= COSTS_N_INSNS (1))\n-\t\t{\n-\t\t  /* We found an acceptable shift.  Generate a move to\n-\t\t     take the value from the store and put it into the\n-\t\t     shift pseudo, then shift it, then generate another\n-\t\t     move to put in into the target of the read.  */\n-\t\t  start_sequence ();\n-\t\t  emit_move_insn (new_reg, gen_lowpart (new_mode, store_info->rhs));\n-\t\t  emit_insn (shift_seq);\n-\t\t  convert_move (read_reg, new_reg, 1);\n+      if (target != new_reg || shift_seq == NULL)\n+\tcontinue;\n+\n+      cost = 0;\n+      for (insn = shift_seq; insn != NULL_RTX; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn))\n+\t  cost += insn_rtx_cost (PATTERN (insn));\n+\n+      /* The computation up to here is essentially independent\n+\t of the arguments and could be precomputed.  It may\n+\t not be worth doing so.  We could precompute if\n+\t worthwhile or at least cache the results.  The result\n+\t technically depends on SHIFT, ACCESS_SIZE, and\n+\t GET_MODE_CLASS (READ_MODE).  But in practice the\n+\t answer will depend only on ACCESS_SIZE.  */\n+\n+      if (cost > COSTS_N_INSNS (1))\n+\tcontinue;\n+\n+      /* We found an acceptable shift.  Generate a move to\n+\t take the value from the store and put it into the\n+\t shift pseudo, then shift it, then generate another\n+\t move to put in into the target of the read.  */\n+      start_sequence ();\n+      emit_move_insn (new_reg, gen_lowpart (new_mode, store_info->rhs));\n+      emit_insn (shift_seq);\n+      convert_move (read_reg, new_reg, 1);\n \t\t  \n-\t\t  if (dump_file)\n-\t\t    {\n-\t\t      fprintf (dump_file, \" -- adding extract insn r%d:%s = r%d:%s\\n\",\n-\t\t\t       REGNO (new_reg), GET_MODE_NAME (new_mode),\n-\t\t\t       REGNO (store_info->rhs), GET_MODE_NAME (store_mode));\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \" -- adding extract insn r%d:%s = r%d:%s\\n\",\n+\t\t   REGNO (new_reg), GET_MODE_NAME (new_mode),\n+\t\t   REGNO (store_info->rhs), GET_MODE_NAME (store_mode));\n \t\t      \n-\t\t      fprintf (dump_file, \" -- with shift of r%d by %d\\n\",\n-\t\t\t       REGNO(new_reg), shift);\n-\t\t      fprintf (dump_file, \" -- and second extract insn r%d:%s = r%d:%s\\n\",\n-\t\t\t       REGNO (read_reg), GET_MODE_NAME (read_mode),\n-\t\t\t       REGNO (new_reg), GET_MODE_NAME (new_mode));\n-\t\t    }\n-\t\t  \n-\t\t  /* Get the three insn sequence and return it.  */\n-\t\t  shift_seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  return shift_seq;\n-\t\t}\n-\t    }\n+\t  fprintf (dump_file, \" -- with shift of r%d by %d\\n\",\n+\t\t   REGNO(new_reg), shift);\n+\t  fprintf (dump_file, \" -- and second extract insn r%d:%s = r%d:%s\\n\",\n+\t\t   REGNO (read_reg), GET_MODE_NAME (read_mode),\n+\t\t   REGNO (new_reg), GET_MODE_NAME (new_mode));\n \t}\n-      else\n-\t/* End the sequence.  */\n-\tend_sequence ();\n+\t\t  \n+      /* Get the three insn sequence and return it.  */\n+      chosen_seq = get_insns ();\n+      end_sequence ();\n+      break;\n     }\n \n-  return NULL;\n+  return chosen_seq;\n }\n \n "}]}