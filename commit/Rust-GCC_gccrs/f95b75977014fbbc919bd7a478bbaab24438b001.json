{"sha": "f95b75977014fbbc919bd7a478bbaab24438b001", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk1Yjc1OTc3MDE0ZmJiYzkxOWJkN2E0NzhiYmFhYjI0NDM4YjAwMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-04-10T11:25:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-04-10T11:25:10Z"}, "message": "tree-vectorizer.h (_stmt_vec_info): Remove same_dr_stmt member.\n\n2019-04-10  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_stmt_vec_info): Remove same_dr_stmt\n\tmember.\n\t(DR_GROUP_SAME_DR_STMT): Remove.\n\t* tree-vect-stmts.c (vectorizable_load): Remove unreachable code.\n\t* tree-vect-data-refs.c (vect_analyze_group_access_1): Likewise,\n\treplace with assert.\n\t(vect_analyze_data_ref_accesses): Fix INTEGER_CST comparison.\n\t(vect_record_grouped_load_vectors): Remove unreachable code.\n\nFrom-SVN: r270250", "tree": {"sha": "f4b9adc4685a10454e6dc661870bd75437ddcf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4b9adc4685a10454e6dc661870bd75437ddcf36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f95b75977014fbbc919bd7a478bbaab24438b001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95b75977014fbbc919bd7a478bbaab24438b001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95b75977014fbbc919bd7a478bbaab24438b001", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95b75977014fbbc919bd7a478bbaab24438b001/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a3f7992d2d9049eb80b30f93fb142b24dfe1685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a3f7992d2d9049eb80b30f93fb142b24dfe1685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a3f7992d2d9049eb80b30f93fb142b24dfe1685"}], "stats": {"total": 104, "additions": 33, "deletions": 71}, "files": [{"sha": "7dd43051607298a629d5ebc3e76a9d7973bda299", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f95b75977014fbbc919bd7a478bbaab24438b001", "patch": "@@ -1,3 +1,14 @@\n+2019-04-10  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info): Remove same_dr_stmt\n+\tmember.\n+\t(DR_GROUP_SAME_DR_STMT): Remove.\n+\t* tree-vect-stmts.c (vectorizable_load): Remove unreachable code.\n+\t* tree-vect-data-refs.c (vect_analyze_group_access_1): Likewise,\n+\treplace with assert.\n+\t(vect_analyze_data_ref_accesses): Fix INTEGER_CST comparison.\n+\t(vect_record_grouped_load_vectors): Remove unreachable code.\n+\n 2019-04-10  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/90016"}, {"sha": "85997cf9617bfa5dc6930b4415c2e11b109eb131", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 22, "deletions": 53, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f95b75977014fbbc919bd7a478bbaab24438b001", "patch": "@@ -2523,40 +2523,15 @@ vect_analyze_group_access_1 (dr_vec_info *dr_info)\n       struct data_reference *data_ref = dr;\n       unsigned int count = 1;\n       tree prev_init = DR_INIT (data_ref);\n-      stmt_vec_info prev = stmt_info;\n       HOST_WIDE_INT diff, gaps = 0;\n \n       /* By construction, all group members have INTEGER_CST DR_INITs.  */\n       while (next)\n         {\n-          /* Skip same data-refs.  In case that two or more stmts share\n-             data-ref (supported only for loads), we vectorize only the first\n-             stmt, and the rest get their vectorized loads from the first\n-             one.  */\n-          if (!tree_int_cst_compare (DR_INIT (data_ref),\n-\t\t\t\t     DR_INIT (STMT_VINFO_DATA_REF (next))))\n-            {\n-              if (DR_IS_WRITE (data_ref))\n-                {\n-                  if (dump_enabled_p ())\n-                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                     \"Two store stmts share the same dr.\\n\");\n-                  return false;\n-                }\n-\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"Two or more load stmts share the same dr.\\n\");\n-\n-\t      /* For load use the same data-ref load.  */\n-\t      DR_GROUP_SAME_DR_STMT (next) = prev;\n-\n-\t      prev = next;\n-\t      next = DR_GROUP_NEXT_ELEMENT (next);\n-\t      continue;\n-            }\n+          /* We never have the same DR multiple times.  */\n+          gcc_assert (tree_int_cst_compare (DR_INIT (data_ref),\n+\t\t\t\tDR_INIT (STMT_VINFO_DATA_REF (next))) != 0);\n \n-\t  prev = next;\n \t  data_ref = STMT_VINFO_DATA_REF (next);\n \n \t  /* All group members have the same STEP by construction.  */\n@@ -3072,8 +3047,8 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n       stmt_vec_info next, g = grp;\n       while ((next = DR_GROUP_NEXT_ELEMENT (g)))\n \t{\n-\t  if ((DR_INIT (STMT_VINFO_DR_INFO (next)->dr)\n-\t       == DR_INIT (STMT_VINFO_DR_INFO (g)->dr))\n+\t  if (tree_int_cst_equal (DR_INIT (STMT_VINFO_DR_INFO (next)->dr),\n+\t\t\t\t  DR_INIT (STMT_VINFO_DR_INFO (g)->dr))\n \t      && gimple_uid (STMT_VINFO_STMT (next)) < first_duplicate)\n \t    first_duplicate = gimple_uid (STMT_VINFO_STMT (next));\n \t  g = next;\n@@ -6329,12 +6304,14 @@ vect_record_grouped_load_vectors (stmt_vec_info stmt_info,\n        correspond to the gaps.  */\n       if (next_stmt_info != first_stmt_info\n \t  && gap_count < DR_GROUP_GAP (next_stmt_info))\n-      {\n-        gap_count++;\n-        continue;\n-      }\n+\t{\n+\t  gap_count++;\n+\t  continue;\n+\t}\n \n-      while (next_stmt_info)\n+      /* ???  The following needs cleanup after the removal of\n+         DR_GROUP_SAME_DR_STMT.  */\n+      if (next_stmt_info)\n         {\n \t  stmt_vec_info new_stmt_info = vinfo->lookup_def (tmp_data_ref);\n \t  /* We assume that if VEC_STMT is not NULL, this is a case of multiple\n@@ -6344,29 +6321,21 @@ vect_record_grouped_load_vectors (stmt_vec_info stmt_info,\n \t    STMT_VINFO_VEC_STMT (next_stmt_info) = new_stmt_info;\n \t  else\n             {\n-\t      if (!DR_GROUP_SAME_DR_STMT (next_stmt_info))\n-                {\n-\t\t  stmt_vec_info prev_stmt_info\n-\t\t    = STMT_VINFO_VEC_STMT (next_stmt_info);\n-\t\t  stmt_vec_info rel_stmt_info\n-\t\t    = STMT_VINFO_RELATED_STMT (prev_stmt_info);\n-\t\t  while (rel_stmt_info)\n-\t\t    {\n-\t\t      prev_stmt_info = rel_stmt_info;\n-\t\t      rel_stmt_info = STMT_VINFO_RELATED_STMT (rel_stmt_info);\n-\t\t    }\n+\t      stmt_vec_info prev_stmt_info\n+\t\t= STMT_VINFO_VEC_STMT (next_stmt_info);\n+\t      stmt_vec_info rel_stmt_info\n+\t\t= STMT_VINFO_RELATED_STMT (prev_stmt_info);\n+\t      while (rel_stmt_info)\n+\t\t{\n+\t\t  prev_stmt_info = rel_stmt_info;\n+\t\t  rel_stmt_info = STMT_VINFO_RELATED_STMT (rel_stmt_info);\n+\t\t}\n \n-\t\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n-                }\n+\t      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n             }\n \n \t  next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n \t  gap_count = 1;\n-\t  /* If NEXT_STMT_INFO accesses the same DR as the previous statement,\n-\t     put the same TMP_DATA_REF as its vectorized statement; otherwise\n-\t     get the next data-ref from RESULT_CHAIN.  */\n-\t  if (!next_stmt_info || !DR_GROUP_SAME_DR_STMT (next_stmt_info))\n-\t    break;\n         }\n     }\n }"}, {"sha": "41a7eb0b9a79ba14d000553476e4ef2a13840946", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f95b75977014fbbc919bd7a478bbaab24438b001", "patch": "@@ -7704,19 +7704,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t     \"group loads with negative dependence distance\\n\");\n \t  return false;\n \t}\n-\n-      /* Similarly when the stmt is a load that is both part of a SLP\n-         instance and a loop vectorized stmt via the same-dr mechanism\n-\t we have to give up.  */\n-      if (DR_GROUP_SAME_DR_STMT (stmt_info)\n-\t  && (STMT_SLP_TYPE (stmt_info)\n-\t      != STMT_SLP_TYPE (DR_GROUP_SAME_DR_STMT (stmt_info))))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"conflicting SLP types for CSEd load\\n\");\n-\t  return false;\n-\t}\n     }\n   else\n     group_size = 1;"}, {"sha": "6f59af64163540d9af4720bd928da9c3726229e5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95b75977014fbbc919bd7a478bbaab24438b001/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f95b75977014fbbc919bd7a478bbaab24438b001", "patch": "@@ -872,9 +872,6 @@ struct _stmt_vec_info {\n   stmt_vec_info first_element;\n   /* Pointer to the next element in the group.  */\n   stmt_vec_info next_element;\n-  /* For data-refs, in case that two or more stmts share data-ref, this is the\n-     pointer to the previously detected stmt with the same dr.  */\n-  stmt_vec_info same_dr_stmt;\n   /* The size of the group.  */\n   unsigned int size;\n   /* For stores, number of stores from this group seen. We vectorize the last\n@@ -1044,8 +1041,6 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n   (gcc_checking_assert ((S)->dr_aux.dr), (S)->store_count)\n #define DR_GROUP_GAP(S) \\\n   (gcc_checking_assert ((S)->dr_aux.dr), (S)->gap)\n-#define DR_GROUP_SAME_DR_STMT(S) \\\n-  (gcc_checking_assert ((S)->dr_aux.dr), (S)->same_dr_stmt)\n \n #define REDUC_GROUP_FIRST_ELEMENT(S) \\\n   (gcc_checking_assert (!(S)->dr_aux.dr), (S)->first_element)"}]}