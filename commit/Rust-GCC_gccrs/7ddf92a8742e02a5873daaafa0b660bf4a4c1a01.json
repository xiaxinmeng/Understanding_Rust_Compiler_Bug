{"sha": "7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RkZjkyYTg3NDJlMDJhNTg3M2RhYWFmYTBiNjYwYmY0YTRjMWEwMQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2006-08-21T22:07:30Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-08-21T22:07:30Z"}, "message": "re PR libgcj/13212 (JNI/CNI AttachCurrentThread does not register thread with garbage collector)\n\nboehm-gc\n\tPR libgcj/13212:\n\t* configure.ac: Check for pthread_getattr_np(). Remove\n\tGC_PTHREAD_SYM_VERSION detection.\n\t* include/gc.h (GC_register_my_thread, GC_unregister_my_thread,\n\tGC_get_thread_stack_base): New declarations.\n\t* pthread_support.c (GC_register_my_thread, GC_unregister_my_thread,\n\tGC_get_thread_stack_base): New functions.\n\t(GC_delete_thread): Don't try to free the first_thread.\n\t* misc.c (GC_init_inner): Use GC_get_thread_stack_base() if possible.\n\t(pthread_create_, constr): Removed.\n\t(pthread_create): Don't rename.\n\t* include/gc_ext_config.h.in: Rebuilt.\n\t* include/gc_pthread_redirects.h (pthread_create): Define \n\tunconditionally.\n\t* include/gc_config.h.in: Rebuilt.\n\t* configure: Rebuilt.\nlibjava\n\t* java/lang/natThread.cc (_Jv_AttachCurrentThread): Attach thread\n\tto GC.\n\t(_Jv_DetachCurrentThread): Detach thread from GC.\n\t* include/boehm-gc.h (_Jv_GCAttachThread, _Jv_GCDetachThread):\n\tDeclare.\n\t* boehm.cc (_Jv_GCAttachThread): New function.\n\t(_Jv_GCDetachThread): Likewise.\n\nFrom-SVN: r116313", "tree": {"sha": "4c9de9e1ba2a27a47f6d8da1bbd87446fe43e48f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c9de9e1ba2a27a47f6d8da1bbd87446fe43e48f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/comments", "author": null, "committer": null, "parents": [{"sha": "accabadcf398fb27c0e13154b7d2d1d52fc4fdef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/accabadcf398fb27c0e13154b7d2d1d52fc4fdef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/accabadcf398fb27c0e13154b7d2d1d52fc4fdef"}], "stats": {"total": 397, "additions": 313, "deletions": 84}, "files": [{"sha": "70dcfb0d9d4737aa631963fb08ff9ad1cbef6b81", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -1,3 +1,22 @@\n+2006-08-21  Bryce McKinlay  <mckinlay@redhat.com>\n+\t\n+\tPR libgcj/13212:\n+\t* configure.ac: Check for pthread_getattr_np(). Remove\n+\tGC_PTHREAD_SYM_VERSION detection.\n+\t* include/gc.h (GC_register_my_thread, GC_unregister_my_thread,\n+\tGC_get_thread_stack_base): New declarations.\n+\t* pthread_support.c (GC_register_my_thread, GC_unregister_my_thread,\n+\tGC_get_thread_stack_base): New functions.\n+\t(GC_delete_thread): Don't try to free the first_thread.\n+\t* misc.c (GC_init_inner): Use GC_get_thread_stack_base() if possible.\n+\t(pthread_create_, constr): Removed.\n+\t(pthread_create): Don't rename.\n+\t* include/gc_ext_config.h.in: Rebuilt.\n+\t* include/gc_pthread_redirects.h (pthread_create): Define \n+\tunconditionally.\n+\t* include/gc_config.h.in: Rebuilt.\n+\t* configure: Rebuilt.\n+\n 2006-06-21  Keith Seitz  <keiths@redhat.com>\n \n \t* pthread_stop_world.c (GC_suspend_handler): Redirect to suspension"}, {"sha": "3f2f5d835f54242c2e246967a041c77f0c00156b", "filename": "boehm-gc/configure", "status": "modified", "additions": 113, "deletions": 23, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -6445,6 +6445,119 @@ echo \"${ECHO_T}yes\" >&6\n      ;;\n esac\n \n+# Checks for pthreads functions\n+#\n+oldLIBS=\"$LIBS\"\n+LIBS=\"$LIBS $THREADLIBS\"\n+\n+for ac_func in pthread_getattr_np\n+do\n+as_ac_var=`echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n+echo \"$as_me:$LINENO: checking for $ac_func\" >&5\n+echo $ECHO_N \"checking for $ac_func... $ECHO_C\" >&6\n+if eval \"test \\\"\\${$as_ac_var+set}\\\" = set\"; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  if test x$gcc_no_link = xyes; then\n+  { { echo \"$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&5\n+echo \"$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.\n+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */\n+#define $ac_func innocuous_$ac_func\n+\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char $ac_func (); below.\n+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since\n+    <limits.h> exists even on freestanding compilers.  */\n+\n+#ifdef __STDC__\n+# include <limits.h>\n+#else\n+# include <assert.h>\n+#endif\n+\n+#undef $ac_func\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char $ac_func ();\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)\n+choke me\n+#else\n+char (*f) () = $ac_func;\n+#endif\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+int\n+main ()\n+{\n+return f != $ac_func;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  eval \"$as_ac_var=yes\"\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+eval \"$as_ac_var=no\"\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`\" >&5\n+echo \"${ECHO_T}`eval echo '${'$as_ac_var'}'`\" >&6\n+if test `eval echo '${'$as_ac_var'}'` = yes; then\n+  cat >>confdefs.h <<_ACEOF\n+#define `echo \"HAVE_$ac_func\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+done\n+\n+LIBS=\"$oldLIBS\"\n+\n # Configuration of machine-dependent code\n #\n # We don't set NO_EXECUTE_PERMISSION by default because gcj (and\n@@ -7313,29 +7426,6 @@ _ACEOF\n \n fi\n \n-symver=\n-case \"$target\" in\n-  *-*-linux* )\n-    cat > conftest.c <<EOF\n-#include <pthread.h>\n-void *tf (void *arg) { (void) arg; return NULL; }\n-int main (void) { pthread_t th; pthread_create (&th, NULL, tf, NULL); return 0; }\n-EOF\n-    if $CC $CFLAGS -pthread -o conftest conftest.c > /dev/null 2>&1; then\n-      symver=`readelf -s conftest 2> /dev/null | sed -n '/UND pthread_create@/{s/^.*@//;s/ .*$//;p;q}'`\n-    fi\n-    rm -f conftest conftest.c\n-    ;;\n-esac\n-if test -n \"$symver\"; then\n-\n-cat >>confdefs.h <<_ACEOF\n-#define GC_PTHREAD_SYM_VERSION \"$symver\"\n-_ACEOF\n-\n-fi\n-\n-\n if test -n \"$with_cross_host\" &&\n    test x\"$with_cross_host\" != x\"no\"; then\n   toolexecdir='$(exec_prefix)/$(target_noncanonical)'"}, {"sha": "807b7a1a758f56baf1528a104de9f0e6ca3b2943", "filename": "boehm-gc/configure.ac", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.ac?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -1,4 +1,4 @@\n-# Copyright (c) 1999, 2000, 2001, 2002, 2003 by Red Hat, Inc. All rights reserved.\n+# Copyright (c) 1999, 2000, 2001, 2002, 2003, 2006 by Red Hat, Inc. All rights reserved.\n # Copyright 2004 Nathanael Nerode\n # \n # THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n@@ -329,6 +329,13 @@ case \"$host\" in\n      ;;\n esac\n \n+# Checks for pthreads functions\n+#\n+oldLIBS=\"$LIBS\"\n+LIBS=\"$LIBS $THREADLIBS\"\n+AC_CHECK_FUNCS([pthread_getattr_np])\n+LIBS=\"$oldLIBS\"\n+\n # Configuration of machine-dependent code\n #\n # We don't set NO_EXECUTE_PERMISSION by default because gcj (and\n@@ -488,25 +495,6 @@ if test \"${gc_use_mmap}\" = \"yes\"; then\n   AC_DEFINE(USE_MMAP, 1, [use MMAP instead of sbrk to get new memory])\n fi\n \n-symver=\n-case \"$target\" in\n-  *-*-linux* )\n-    cat > conftest.c <<EOF\n-#include <pthread.h>\n-void *tf (void *arg) { (void) arg; return NULL; }\n-int main (void) { pthread_t th; pthread_create (&th, NULL, tf, NULL); return 0; }\n-EOF\n-    if $CC $CFLAGS -pthread -o conftest conftest.c > /dev/null 2>&1; then\n-      symver=`readelf -s conftest 2> /dev/null | sed -n '/UND pthread_create@/{s/^.*@//;s/ .*$//;p;q}'`\n-    fi\n-    rm -f conftest conftest.c\n-    ;;\n-esac\n-if test -n \"$symver\"; then\n-  AC_DEFINE_UNQUOTED(GC_PTHREAD_SYM_VERSION, \"$symver\", [symbol version of pthread_create])\n-fi\n-\n-\n if test -n \"$with_cross_host\" &&\n    test x\"$with_cross_host\" != x\"no\"; then\n   toolexecdir='$(exec_prefix)/$(target_noncanonical)'"}, {"sha": "5ba1f4becfee9ab284c07b68d90307e8c33a5cb9", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -69,7 +69,6 @@\n     extern \"C\" {\n # endif\n \n-\n /* Define word and signed_word to be unsigned and signed types of the \t*/\n /* size as char * or void *.  There seems to be no way to do this\t*/\n /* even semi-portably.  The following is probably no better/worse \t*/\n@@ -912,6 +911,25 @@ GC_API void (*GC_is_visible_print_proc)\n # if defined(PCR) || defined(GC_SOLARIS_THREADS) || \\\n      defined(GC_PTHREADS) || defined(GC_WIN32_THREADS)\n    \t/* Any flavor of threads except SRC_M3.\t*/\n+\n+/* Register the current thread as a new thread whose stack(s) should    */\n+/* be traced by the GC.  \t\t\t\t\t\t*/\n+/* If a platform does not implicitly do so, this must be called before  */\n+/* a thread can allocate garbage collected memory, or assign pointers\t*/\n+/* to the garbage collected heap.  Once registered, a thread will be\t*/\n+/* stopped during garbage collections.\t\t\t\t\t*/\n+GC_API void GC_register_my_thread GC_PROTO((void));\n+\n+/* Register the current thread, with the indicated stack base, as\t*/\n+/* a new thread whose stack(s) should be traced by the GC.  If a \t*/\n+/* platform does not implicitly do so, this must be called before a\t*/\n+/* thread can allocate garbage collected memory, or assign pointers\t*/\n+/* to the garbage collected heap.  Once registered, a thread will be\t*/\n+/* stopped during garbage collections.\t\t\t\t\t*/\n+GC_API void GC_unregister_my_thread GC_PROTO((void));\n+\n+GC_API GC_PTR GC_get_thread_stack_base GC_PROTO((void));\n+\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n /* the allocation lock can be acquired and released many fewer times.\t*/"}, {"sha": "5055b50245991e72ff9c82b08bc3a243275a3509", "filename": "boehm-gc/include/gc_config.h.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc_config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc_config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config.h.in?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -45,9 +45,6 @@\n /* support for Tru64 pthreads */\n #undef GC_OSF1_THREADS\n \n-/* symbol version of pthread_create */\n-#undef GC_PTHREAD_SYM_VERSION\n-\n /* support for Solaris pthreads */\n #undef GC_SOLARIS_PTHREADS\n \n@@ -81,6 +78,9 @@\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n+/* Define to 1 if you have the `pthread_getattr_np' function. */\n+#undef HAVE_PTHREAD_GETATTR_NP\n+\n /* Define to 1 if you have the <stdint.h> header file. */\n #undef HAVE_STDINT_H\n "}, {"sha": "219ba2fb8c8e9e2040ab5f3f8cd8f49daaf0116d", "filename": "boehm-gc/include/gc_ext_config.h.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc_ext_config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc_ext_config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_ext_config.h.in?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -4,4 +4,4 @@ is used by libjava/include/boehm-gc.h. */\n \n #undef THREAD_LOCAL_ALLOC\n \n-#undef GC_PTHREAD_SYM_VERSION\n+#undef HAVE_PTHREAD_GETATTR_NP"}, {"sha": "842518cfcc48c2a0657b1cc6581994abf5cd8a44", "filename": "boehm-gc/include/gc_pthread_redirects.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_pthread_redirects.h?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -68,9 +68,7 @@\n # undef pthread_detach\n #endif\n \n-#ifndef GC_PTHREAD_SYM_VERSION\n # define pthread_create GC_pthread_create\n-#endif\n # define pthread_join GC_pthread_join\n # define pthread_detach GC_pthread_detach\n "}, {"sha": "23e226df52ab60239a43fff5be9d67fa69e6a21d", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -674,7 +674,13 @@ void GC_init_inner()\n #   if !defined(THREADS) || defined(GC_PTHREADS) || defined(GC_WIN32_THREADS) \\\n \t|| defined(GC_SOLARIS_THREADS)\n       if (GC_stackbottom == 0) {\n-\tGC_stackbottom = GC_get_stack_base();\n+        # ifdef GC_PTHREADS\n+\t/* Use thread_stack_base if available, as GC could be initialized from\n+\t   a thread that is not the \"main\" thread.  */\n+\tGC_stackbottom = GC_get_thread_stack_base();\n+\t# endif\n+\tif (GC_stackbottom == 0)\n+\t  GC_stackbottom = GC_get_stack_base();\n #       if (defined(LINUX) || defined(HPUX)) && defined(IA64)\n \t  GC_register_stackbottom = GC_get_register_stack_base();\n #       endif"}, {"sha": "bbda8522c03072f4bc7a54d9c8fa517c95d1971a", "filename": "boehm-gc/pthread_support.c", "status": "modified", "additions": 106, "deletions": 32, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fpthread_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/boehm-gc%2Fpthread_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_support.c?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -602,7 +602,9 @@ void GC_delete_thread(pthread_t id)\n     } else {\n         prev -> next = p -> next;\n     }\n-    GC_INTERNAL_FREE(p);\n+\n+    if (p != &first_thread)\n+      GC_INTERNAL_FREE(p);\n }\n \n /* If a thread has been joined, but we have not yet\t\t*/\n@@ -1124,6 +1126,107 @@ WRAP_FUNC(pthread_detach)(pthread_t thread)\n \n GC_bool GC_in_thread_creation = FALSE;\n \n+GC_PTR GC_get_thread_stack_base()\n+{  \n+# ifdef HAVE_PTHREAD_GETATTR_NP\n+  pthread_t my_pthread;\n+  pthread_attr_t attr;\n+  ptr_t stack_addr;\n+  size_t stack_size;\n+  \n+  my_pthread = pthread_self();  \n+  pthread_getattr_np (my_pthread, &attr);\n+  pthread_attr_getstack (&attr, (void **) &stack_addr, &stack_size);\n+  pthread_attr_destroy (&attr);\n+  \n+#   ifdef DEBUG_THREADS\n+\tGC_printf1(\"attached thread stack address: 0x%x\\n\", stack_addr);\n+#   endif\n+\n+#   ifdef STACK_GROWS_DOWN\n+      return stack_addr + stack_size;\n+#   else\n+      return stack_addr - stack_size;\n+#   endif\n+\n+# else\n+#   ifdef DEBUG_THREADS\n+\tGC_printf1(\"Can not determine stack base for attached thread\");\n+#   endif\n+  return 0;\n+# endif\n+}\n+\n+void GC_register_my_thread()\n+{\n+  GC_thread me;\n+  pthread_t my_pthread;\n+\n+  my_pthread = pthread_self();\n+#   ifdef DEBUG_THREADS\n+      GC_printf1(\"Attaching thread 0x%lx\\n\", my_pthread);\n+      GC_printf1(\"pid = %ld\\n\", (long) getpid());\n+#   endif\n+  \n+  /* Check to ensure this thread isn't attached already. */\n+  LOCK();\n+  me = GC_lookup_thread (my_pthread);\n+  UNLOCK();\n+  if (me != 0)\n+    {\n+#   ifdef DEBUG_THREADS\n+      GC_printf1(\"Attempt to re-attach known thread 0x%lx\\n\", my_pthread);\n+#   endif\n+      return;\n+    }\n+\n+  LOCK();\n+  GC_in_thread_creation = TRUE;\n+  me = GC_new_thread(my_pthread);\n+  GC_in_thread_creation = FALSE;\n+\n+  me -> flags |= DETACHED;  \n+\n+#ifdef GC_DARWIN_THREADS\n+    me -> stop_info.mach_thread = mach_thread_self();\n+#else\n+    me -> stack_end = GC_get_thread_stack_base();    \n+    if (me -> stack_end == 0)\n+      GC_abort(\"Can not determine stack base for attached thread\");\n+    \n+#   ifdef STACK_GROWS_DOWN\n+      me -> stop_info.stack_ptr = me -> stack_end - 0x10;\n+#   else\n+      me -> stop_info.stack_ptr = me -> stack_end + 0x10;\n+#   endif\n+#endif\n+\n+#   ifdef IA64\n+      me -> backing_store_end = (ptr_t)\n+\t\t\t(GC_save_regs_in_stack() & ~(GC_page_size - 1));\n+      /* This is also < 100% convincing.  We should also read this \t*/\n+      /* from /proc, but the hook to do so isn't there yet.\t\t*/\n+#   endif /* IA64 */\n+\n+#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n+        GC_init_thread_local(me);\n+#   endif\n+  UNLOCK();\n+}\n+\n+void GC_unregister_my_thread()\n+{\n+  pthread_t my_pthread;\n+\n+  my_pthread = pthread_self();\n+\n+#   ifdef DEBUG_THREADS\n+      GC_printf1(\"Detaching thread 0x%lx\\n\", my_pthread);\n+#   endif\n+\n+  GC_thread_exit_proc (0);\n+}\n+\n void * GC_start_routine(void * arg)\n {\n     int dummy;\n@@ -1200,37 +1303,8 @@ void * GC_start_routine(void * arg)\n     return(result);\n }\n \n-#ifdef GC_PTHREAD_SYM_VERSION\n-\n-/* Force constr to execute prior to main().  */\n-static void constr (void) __attribute__ ((constructor));\n-\n-static int\n-(*pthread_create_)(pthread_t *new_thread,\n-\t\t   const pthread_attr_t *attr_in,\n-\t\t   void * (*thread_execp)(void *), void *arg);\n-\n-static void\n-constr (void)\n-{\n-  /* Get a pointer to the real pthread_create.  */\n-  pthread_create_ = dlvsym (RTLD_NEXT, \"pthread_create\",\n-\t\t\t    GC_PTHREAD_SYM_VERSION);\n-}\n-\n-#define GC_PTHREAD_CREATE_NAME pthread_create\n-#define GC_PTHREAD_REAL_NAME (*pthread_create_)\n-\n-#else\n-\n-#define GC_PTHREAD_CREATE_NAME WRAP_FUNC(pthread_create)\n-#define GC_PTHREAD_REAL_NAME REAL_FUNC(pthread_create)\n-\n-#endif\n-\n-\n int\n-GC_PTHREAD_CREATE_NAME(pthread_t *new_thread,\n+WRAP_FUNC(pthread_create)(pthread_t *new_thread,\n \t\t  const pthread_attr_t *attr,\n                   void *(*start_routine)(void *), void *arg)\n {\n@@ -1291,7 +1365,7 @@ GC_PTHREAD_CREATE_NAME(pthread_t *new_thread,\n \t\t   pthread_self());\n #   endif\n \n-    result = GC_PTHREAD_REAL_NAME(new_thread, attr, GC_start_routine, si);\n+    result = REAL_FUNC(pthread_create)(new_thread, attr, GC_start_routine, si);\n \n #   ifdef DEBUG_THREADS\n         GC_printf1(\"Started thread 0x%X\\n\", *new_thread);"}, {"sha": "8c20e8c3365388966a01fd5537e9cc7021f0b7e1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -1,3 +1,13 @@\n+2006-08-21  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* java/lang/natThread.cc (_Jv_AttachCurrentThread): Attach thread\n+\tto GC.\n+\t(_Jv_DetachCurrentThread): Detach thread from GC.\n+\t* include/boehm-gc.h (_Jv_GCAttachThread, _Jv_GCDetachThread):\n+\tDeclare.\n+\t* boehm.cc (_Jv_GCAttachThread): New function.\n+\t(_Jv_GCDetachThread): Likewise.\n+\n 2006-08-19  Ranjit Mathew  <rmathew@gcc.gnu.org>\n \n \t* sysdep/i386/backtrace.h (fallback_backtrace): Add \"0x55 0x8B 0xEC\""}, {"sha": "f96128e191d9823ec6c8e6c53c53be193b3d8064", "filename": "libjava/boehm.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -695,3 +695,21 @@ _Jv_ResumeThread (_Jv_Thread_t *thread)\n   GC_resume_thread (_Jv_GetPlatformThreadID (thread));\n #endif\n }\n+\n+void\n+_Jv_GCAttachThread ()\n+{\n+  // The registration interface is only defined on posixy systems and\n+  // only actually works if pthread_getattr_np is defined.\n+#ifdef HAVE_PTHREAD_GETATTR_NP\n+  GC_register_my_thread ();\n+#endif\n+}\n+\n+void\n+_Jv_GCDetachThread ()\n+{\n+#ifdef HAVE_PTHREAD_GETATTR_NP\n+  GC_unregister_my_thread ();\n+#endif\n+}"}, {"sha": "7e61b8e48fbbbfb8d95a6b3cc60379003ecd6117", "filename": "libjava/include/boehm-gc.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2Finclude%2Fboehm-gc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2Finclude%2Fboehm-gc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fboehm-gc.h?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -80,6 +80,10 @@ _Jv_AllocPtrFreeObj (jsize size, jclass klass);\n \n #endif /* LIBGCJ_GC_DEBUG */\n \n+void _Jv_GCAttachThread ();\n+\n+void _Jv_GCDetachThread ();\n+\n // _Jv_AllocBytes (jsize size) should go here, too.  But clients don't\n // usually include this header.\n "}, {"sha": "facce30fa2e259a177e065ee594180e8a3da05ae", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddf92a8742e02a5873daaafa0b660bf4a4c1a01/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=7ddf92a8742e02a5873daaafa0b660bf4a4c1a01", "patch": "@@ -410,7 +410,8 @@ _Jv_SetCurrentJNIEnv (JNIEnv *env)\n }\n \n // Attach the current native thread to an existing (but unstarted) Thread \n-// object. Returns -1 on failure, 0 upon success.\n+// object. Does not register thread with the garbage collector.\n+// Returns -1 on failure, 0 upon success.\n jint\n _Jv_AttachCurrentThread(java::lang::Thread* thread)\n {\n@@ -427,6 +428,8 @@ _Jv_AttachCurrentThread(java::lang::Thread* thread)\n java::lang::Thread*\n _Jv_AttachCurrentThread(jstring name, java::lang::ThreadGroup* group)\n {\n+  // Register thread with GC before attempting any allocations.\n+  _Jv_GCAttachThread ();\n   java::lang::Thread *thread = _Jv_ThreadCurrent ();\n   if (thread != NULL)\n     return thread;\n@@ -461,6 +464,7 @@ _Jv_DetachCurrentThread (void)\n     return -1;\n \n   _Jv_ThreadUnRegister ();\n+  _Jv_GCDetachThread ();\n   // Release the monitors.\n   t->finish_ ();\n "}]}