{"sha": "a3ff15afb4c697117aa8916c47b358045dbf0fe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNmZjE1YWZiNGM2OTcxMTdhYTg5MTZjNDdiMzU4MDQ1ZGJmMGZlOQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-03T08:09:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-03T15:19:53Z"}, "message": "Dump reason why threads are being cancelled and abstract code.\n\nWe are inconsistent on dumping out reasons why a thread was canceled.\nThis makes debugging jump threading problems harder because paths can be\ncanceled with no reason given.  This patch abstracts out the thread\ncanceling code and adds a reason for every cancellation.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadupdate.c (cancel_thread): New.\n\t(jump_thread_path_registry::thread_block_1): Use cancel_thread.\n\t(jump_thread_path_registry::mark_threaded_blocks): Same.\n\t(jump_thread_path_registry::register_jump_thread): Same.", "tree": {"sha": "bf74977c01c4b01fb072e34978d515c261730650", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf74977c01c4b01fb072e34978d515c261730650"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3ff15afb4c697117aa8916c47b358045dbf0fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ff15afb4c697117aa8916c47b358045dbf0fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3ff15afb4c697117aa8916c47b358045dbf0fe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ff15afb4c697117aa8916c47b358045dbf0fe9/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ec4990bc777dd191b86aee6156be3f60cf9de24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec4990bc777dd191b86aee6156be3f60cf9de24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ec4990bc777dd191b86aee6156be3f60cf9de24"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "18f16efbb7a92da165945e1d48ded0cb58c56d54", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ff15afb4c697117aa8916c47b358045dbf0fe9/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ff15afb4c697117aa8916c47b358045dbf0fe9/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=a3ff15afb4c697117aa8916c47b358045dbf0fe9", "patch": "@@ -245,6 +245,23 @@ debug (const vec<jump_thread_edge *> *path)\n   debug (*path);\n }\n \n+/* Release the memory associated with PATH, and if dumping is enabled,\n+   dump out the reason why the thread was canceled.  */\n+\n+static void\n+cancel_thread (vec<jump_thread_edge *> *path, const char *reason = NULL)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      if (reason)\n+\tfprintf (dump_file, \"%s:\\n\", reason);\n+\n+      dump_jump_thread_path (dump_file, *path, false);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  path->release ();\n+}\n+\n /* Simple hashing function.  For any given incoming edge E, we're going\n    to be most concerned with the final destination of its jump thread\n    path.  So hash on the block index of the final edge in the path.  */\n@@ -1449,7 +1466,7 @@ jump_thread_path_registry::thread_block_1 (basic_block bb,\n \t      /* Since this case is not handled by our special code\n \t\t to thread through a loop header, we must explicitly\n \t\t cancel the threading request here.  */\n-\t      path->release ();\n+\t      cancel_thread (path, \"Threading through unhandled loop header\");\n \t      e->aux = NULL;\n \t      continue;\n \t    }\n@@ -1488,7 +1505,7 @@ jump_thread_path_registry::thread_block_1 (basic_block bb,\n \n \t      if (i != path->length ())\n \t\t{\n-\t\t  path->release ();\n+\t\t  cancel_thread (path, \"Threading through loop exit\");\n \t\t  e->aux = NULL;\n \t\t  continue;\n \t\t}\n@@ -1847,7 +1864,7 @@ jump_thread_path_registry::thread_through_loop_header\n \n       if (path)\n \t{\n-\t  path->release ();\n+\t  cancel_thread (path, \"Failure in thread_through_loop_header\");\n \t  e->aux = NULL;\n \t}\n     }\n@@ -1975,9 +1992,7 @@ jump_thread_path_registry::mark_threaded_blocks (bitmap threaded_blocks)\n \t  else\n \t    {\n \t      m_paths.unordered_remove (i);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tdump_jump_thread_path (dump_file, *path, false);\n-\t      path->release ();\n+\t      cancel_thread (path);\n \t    }\n \t}\n       else\n@@ -2012,9 +2027,7 @@ jump_thread_path_registry::mark_threaded_blocks (bitmap threaded_blocks)\n \t    {\n \t      e->aux = NULL;\n \t      m_paths.unordered_remove (i);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tdump_jump_thread_path (dump_file, *path, false);\n-\t      path->release ();\n+\t      cancel_thread (path);\n \t    }\n \t}\n       else\n@@ -2060,9 +2073,7 @@ jump_thread_path_registry::mark_threaded_blocks (bitmap threaded_blocks)\n \n \t\tif (j != path->length ())\n \t\t  {\n-\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t      dump_jump_thread_path (dump_file, *path, false);\n-\t\t    path->release ();\n+\t\t    cancel_thread (path);\n \t\t    e->aux = NULL;\n \t\t  }\n \t\telse\n@@ -2109,7 +2120,7 @@ jump_thread_path_registry::mark_threaded_blocks (bitmap threaded_blocks)\n \n \t\t  if (e2 && !phi_args_equal_on_edges (e2, final_edge))\n \t\t    {\n-\t\t      path->release ();\n+\t\t      cancel_thread (path);\n \t\t      e->aux = NULL;\n \t\t    }\n \t\t}\n@@ -2332,9 +2343,7 @@ jump_thread_path_registry::adjust_paths_after_duplication\n \t  if (j == cand_path->length ())\n \t    {\n \t    remove_candidate_from_list:\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"adjusted candidate: [EMPTY]\\n\");\n-\t      cand_path->release ();\n+\t      cancel_thread (cand_path, \"Adjusted candidate is EMPTY\");\n \t      m_paths.unordered_remove (cand_path_num);\n \t      continue;\n \t    }\n@@ -2595,7 +2604,7 @@ jump_thread_path_registry::thread_through_all_blocks\n \n \tif (j != path->length ())\n \t  {\n-\t    path->release ();\n+\t    cancel_thread (path, \"Thread references removed edge\");\n \t    m_paths.unordered_remove (i);\n \t    continue;\n \t  }\n@@ -2629,7 +2638,7 @@ jump_thread_path_registry::thread_through_all_blocks\n \t  || !valid_jump_thread_path (path))\n \t{\n \t  /* Remove invalid FSM jump-thread paths.  */\n-\t  path->release ();\n+\t  cancel_thread (path, \"Invalid FSM jump-thread path\");\n \t  m_paths.unordered_remove (i);\n \t  continue;\n \t}\n@@ -2665,7 +2674,7 @@ jump_thread_path_registry::thread_through_all_blocks\n       /* Do not jump-thread twice from the same block.  */\n       if (visited_starting_edges.contains (entry))\n \t{\n-\t  path->release ();\n+\t  cancel_thread (path, \"Avoiding threading twice from same BB\");\n \t  m_paths.unordered_remove (i);\n \t}\n       else\n@@ -2766,14 +2775,7 @@ jump_thread_path_registry::register_jump_thread (vec<jump_thread_edge *> *path)\n     {\n       if ((*path)[i]->e == NULL)\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"Found NULL edge in jump threading path.  Cancelling jump thread:\\n\");\n-\t      dump_jump_thread_path (dump_file, *path, false);\n-\t    }\n-\n-\t  path->release ();\n+\t  cancel_thread (path, \"Found NULL edge in jump threading path\");\n \t  return false;\n \t}\n "}]}