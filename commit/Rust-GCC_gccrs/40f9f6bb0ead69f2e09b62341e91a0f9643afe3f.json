{"sha": "40f9f6bb0ead69f2e09b62341e91a0f9643afe3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmOWY2YmIwZWFkNjlmMmUwOWI2MjM0MWU5MWEwZjk2NDNhZmUzZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-05-30T18:37:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-05-30T18:37:05Z"}, "message": "sanitizer.def (BUILT_IN_ASAN_REPORT_LOAD_N, [...]): New.\n\n\t* sanitizer.def (BUILT_IN_ASAN_REPORT_LOAD_N,\n\tBUILT_IN_ASAN_REPORT_STORE_N): New.\n\t* asan.c (struct asan_mem_ref): Change access_size type to\n\tHOST_WIDE_INT.\n\t(asan_mem_ref_init, asan_mem_ref_new, get_mem_refs_of_builtin_call,\n\tupdate_mem_ref_hash_table): Likewise.\n\t(asan_mem_ref_hasher::hash): Hash in a HWI.\n\t(report_error_func): Change size_in_bytes argument to HWI.\n\tUse *_N builtins if size_in_bytes is larger than 16 or not power of\n\ttwo.\n\t(build_shadow_mem_access): New function.\n\t(build_check_stmt): Use it.  Change size_in_bytes argument to HWI.\n\tHandle size_in_bytes not power of two or larger than 16.\n\t(instrument_derefs): Don't give up if size_in_bytes is not\n\tpower of two or is larger than 16.\n\nFrom-SVN: r211091", "tree": {"sha": "3326b794ec3e297e31dd9c81d4f4177c48d5ae5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3326b794ec3e297e31dd9c81d4f4177c48d5ae5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8465be9f1d5755379686743fb33aafbbfd77dfb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8465be9f1d5755379686743fb33aafbbfd77dfb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8465be9f1d5755379686743fb33aafbbfd77dfb3"}], "stats": {"total": 190, "additions": 135, "deletions": 55}, "files": [{"sha": "3d20e13d14f0113ec61086321b71c32ec2dcf831", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40f9f6bb0ead69f2e09b62341e91a0f9643afe3f", "patch": "@@ -1,3 +1,21 @@\n+2014-05-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* sanitizer.def (BUILT_IN_ASAN_REPORT_LOAD_N,\n+\tBUILT_IN_ASAN_REPORT_STORE_N): New.\n+\t* asan.c (struct asan_mem_ref): Change access_size type to\n+\tHOST_WIDE_INT.\n+\t(asan_mem_ref_init, asan_mem_ref_new, get_mem_refs_of_builtin_call,\n+\tupdate_mem_ref_hash_table): Likewise.\n+\t(asan_mem_ref_hasher::hash): Hash in a HWI.\n+\t(report_error_func): Change size_in_bytes argument to HWI.\n+\tUse *_N builtins if size_in_bytes is larger than 16 or not power of\n+\ttwo.\n+\t(build_shadow_mem_access): New function.\n+\t(build_check_stmt): Use it.  Change size_in_bytes argument to HWI.\n+\tHandle size_in_bytes not power of two or larger than 16.\n+\t(instrument_derefs): Don't give up if size_in_bytes is not\n+\tpower of two or is larger than 16.\n+\n 2014-05-30  Kai Tietz  <ktietz@redhat.com>\n \n \tPR target/60104"}, {"sha": "beb002374a2a9f34c087e29eb1f94066ac1b9b45", "filename": "gcc/asan.c", "status": "modified", "additions": 111, "deletions": 55, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=40f9f6bb0ead69f2e09b62341e91a0f9643afe3f", "patch": "@@ -251,8 +251,8 @@ struct asan_mem_ref\n   /* The expression of the beginning of the memory region.  */\n   tree start;\n \n-  /* The size of the access (can be 1, 2, 4, 8, 16 for now).  */\n-  char access_size;\n+  /* The size of the access.  */\n+  HOST_WIDE_INT access_size;\n };\n \n static alloc_pool asan_mem_ref_alloc_pool;\n@@ -274,7 +274,7 @@ asan_mem_ref_get_alloc_pool ()\n /* Initializes an instance of asan_mem_ref.  */\n \n static void\n-asan_mem_ref_init (asan_mem_ref *ref, tree start, char access_size)\n+asan_mem_ref_init (asan_mem_ref *ref, tree start, HOST_WIDE_INT access_size)\n {\n   ref->start = start;\n   ref->access_size = access_size;\n@@ -287,7 +287,7 @@ asan_mem_ref_init (asan_mem_ref *ref, tree start, char access_size)\n    access to the referenced memory.  */\n \n static asan_mem_ref*\n-asan_mem_ref_new (tree start, char access_size)\n+asan_mem_ref_new (tree start, HOST_WIDE_INT access_size)\n {\n   asan_mem_ref *ref =\n     (asan_mem_ref *) pool_alloc (asan_mem_ref_get_alloc_pool ());\n@@ -334,7 +334,7 @@ inline hashval_t\n asan_mem_ref_hasher::hash (const asan_mem_ref *mem_ref)\n {\n   hashval_t h = iterative_hash_expr (mem_ref->start, 0);\n-  h = iterative_hash_hashval_t (h, mem_ref->access_size);\n+  h = iterative_hash_host_wide_int (mem_ref->access_size, h);\n   return h;\n }\n \n@@ -392,7 +392,7 @@ free_mem_ref_resources ()\n /* Return true iff the memory reference REF has been instrumented.  */\n \n static bool\n-has_mem_ref_been_instrumented (tree ref, char access_size)\n+has_mem_ref_been_instrumented (tree ref, HOST_WIDE_INT access_size)\n {\n   asan_mem_ref r;\n   asan_mem_ref_init (&r, ref, access_size);\n@@ -480,7 +480,7 @@ get_mem_refs_of_builtin_call (const gimple call,\n   tree source0 = NULL_TREE, source1 = NULL_TREE,\n     dest = NULL_TREE, len = NULL_TREE;\n   bool is_store = true, got_reference_p = false;\n-  char access_size = 1;\n+  HOST_WIDE_INT access_size = 1;\n \n   switch (DECL_FUNCTION_CODE (callee))\n     {\n@@ -842,7 +842,7 @@ has_stmt_been_instrumented_p (gimple stmt)\n /*  Insert a memory reference into the hash table.  */\n \n static void\n-update_mem_ref_hash_table (tree ref, char access_size)\n+update_mem_ref_hash_table (tree ref, HOST_WIDE_INT access_size)\n {\n   hash_table <asan_mem_ref_hasher> ht = get_mem_ref_hash_table ();\n \n@@ -1315,20 +1315,22 @@ asan_protect_global (tree decl)\n   return true;\n }\n \n-/* Construct a function tree for __asan_report_{load,store}{1,2,4,8,16}.\n-   IS_STORE is either 1 (for a store) or 0 (for a load).\n-   SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n+/* Construct a function tree for __asan_report_{load,store}{1,2,4,8,16,_n}.\n+   IS_STORE is either 1 (for a store) or 0 (for a load).  */\n \n static tree\n-report_error_func (bool is_store, int size_in_bytes)\n+report_error_func (bool is_store, HOST_WIDE_INT size_in_bytes)\n {\n-  static enum built_in_function report[2][5]\n+  static enum built_in_function report[2][6]\n     = { { BUILT_IN_ASAN_REPORT_LOAD1, BUILT_IN_ASAN_REPORT_LOAD2,\n \t  BUILT_IN_ASAN_REPORT_LOAD4, BUILT_IN_ASAN_REPORT_LOAD8,\n-\t  BUILT_IN_ASAN_REPORT_LOAD16 },\n+\t  BUILT_IN_ASAN_REPORT_LOAD16, BUILT_IN_ASAN_REPORT_LOAD_N },\n \t{ BUILT_IN_ASAN_REPORT_STORE1, BUILT_IN_ASAN_REPORT_STORE2,\n \t  BUILT_IN_ASAN_REPORT_STORE4, BUILT_IN_ASAN_REPORT_STORE8,\n-\t  BUILT_IN_ASAN_REPORT_STORE16 } };\n+\t  BUILT_IN_ASAN_REPORT_STORE16, BUILT_IN_ASAN_REPORT_STORE_N } };\n+  if ((size_in_bytes & (size_in_bytes - 1)) != 0\n+      || size_in_bytes > 16)\n+    return builtin_decl_implicit (report[is_store][5]);\n   return builtin_decl_implicit (report[is_store][exact_log2 (size_in_bytes)]);\n }\n \n@@ -1450,23 +1452,63 @@ insert_if_then_before_iter (gimple cond,\n   gsi_insert_after (&cond_insert_point, cond, GSI_NEW_STMT);\n }\n \n+/* Build\n+   (base_addr >> ASAN_SHADOW_SHIFT) + targetm.asan_shadow_offset ().  */\n+\n+static tree\n+build_shadow_mem_access (gimple_stmt_iterator *gsi, location_t location,\n+\t\t\t tree base_addr, tree shadow_ptr_type)\n+{\n+  tree t, uintptr_type = TREE_TYPE (base_addr);\n+  tree shadow_type = TREE_TYPE (shadow_ptr_type);\n+  gimple g;\n+\n+  t = build_int_cst (uintptr_type, ASAN_SHADOW_SHIFT);\n+  g = gimple_build_assign_with_ops (RSHIFT_EXPR,\n+\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t    base_addr, t);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+\n+  t = build_int_cst (uintptr_type, targetm.asan_shadow_offset ());\n+  g = gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t    gimple_assign_lhs (g), t);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+\n+  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t    make_ssa_name (shadow_ptr_type, NULL),\n+\t\t\t\t    gimple_assign_lhs (g), NULL_TREE);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+\n+  t = build2 (MEM_REF, shadow_type, gimple_assign_lhs (g),\n+\t      build_int_cst (shadow_ptr_type, 0));\n+  g = gimple_build_assign_with_ops (MEM_REF,\n+\t\t\t\t    make_ssa_name (shadow_type, NULL),\n+\t\t\t\t    t, NULL_TREE);\n+  gimple_set_location (g, location);\n+  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+  return gimple_assign_lhs (g);\n+}\n+\n /* Instrument the memory access instruction BASE.  Insert new\n    statements before or after ITER.\n \n    Note that the memory access represented by BASE can be either an\n    SSA_NAME, or a non-SSA expression.  LOCATION is the source code\n    location.  IS_STORE is TRUE for a store, FALSE for a load.\n    BEFORE_P is TRUE for inserting the instrumentation code before\n-   ITER, FALSE for inserting it after ITER.  SIZE_IN_BYTES is one of\n-   1, 2, 4, 8, 16.\n+   ITER, FALSE for inserting it after ITER.\n \n    If BEFORE_P is TRUE, *ITER is arranged to still point to the\n    statement it was pointing to prior to calling this function,\n    otherwise, it points to the statement logically following it.  */\n \n static void\n build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n-\t\t  bool before_p, bool is_store, int size_in_bytes)\n+\t\t  bool before_p, bool is_store, HOST_WIDE_INT size_in_bytes)\n {\n   gimple_stmt_iterator gsi;\n   basic_block then_bb, else_bb;\n@@ -1477,6 +1519,12 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n   tree uintptr_type\n     = build_nonstandard_integer_type (TYPE_PRECISION (TREE_TYPE (base)), 1);\n   tree base_ssa = base;\n+  HOST_WIDE_INT real_size_in_bytes = size_in_bytes;\n+  tree sz_arg = NULL_TREE;\n+\n+  if ((size_in_bytes & (size_in_bytes - 1)) != 0\n+      || size_in_bytes > 16)\n+    real_size_in_bytes = 1;\n \n   /* Get an iterator on the point where we can add the condition\n      statement for the instrumentation.  */\n@@ -1509,58 +1557,64 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n \n   /* Build\n      (base_addr >> ASAN_SHADOW_SHIFT) + targetm.asan_shadow_offset ().  */\n+  shadow = build_shadow_mem_access (&gsi, location, base_addr,\n+\t\t\t\t    shadow_ptr_type);\n \n-  t = build_int_cst (uintptr_type, ASAN_SHADOW_SHIFT);\n-  g = gimple_build_assign_with_ops (RSHIFT_EXPR,\n-\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n-\t\t\t\t    base_addr, t);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-  t = build_int_cst (uintptr_type, targetm.asan_shadow_offset ());\n-  g = gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n-\t\t\t\t    gimple_assign_lhs (g), t);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (shadow_ptr_type, NULL),\n-\t\t\t\t    gimple_assign_lhs (g), NULL_TREE);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-  t = build2 (MEM_REF, shadow_type, gimple_assign_lhs (g),\n-\t      build_int_cst (shadow_ptr_type, 0));\n-  g = gimple_build_assign_with_ops (MEM_REF,\n-\t\t\t\t    make_ssa_name (shadow_type, NULL),\n-\t\t\t\t    t, NULL_TREE);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-  shadow = gimple_assign_lhs (g);\n-\n-  if (size_in_bytes < 8)\n+  if (real_size_in_bytes < 8)\n     {\n       /* Slow path for 1, 2 and 4 byte accesses.\n \t Test (shadow != 0)\n-\t      & ((base_addr & 7) + (size_in_bytes - 1)) >= shadow).  */\n+\t      & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n       gimple_seq seq = NULL;\n       gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n       gimple_seq_add_stmt (&seq, shadow_test);\n       gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, base_addr, 7));\n       gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n                                                   gimple_seq_last (seq)));\n-      if (size_in_bytes > 1)\n+      if (real_size_in_bytes > 1)\n         gimple_seq_add_stmt (&seq,\n                              build_assign (PLUS_EXPR, gimple_seq_last (seq),\n-                                           size_in_bytes - 1));\n+\t\t\t\t\t   real_size_in_bytes - 1));\n       gimple_seq_add_stmt (&seq, build_assign (GE_EXPR, gimple_seq_last (seq),\n                                                shadow));\n       gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n                                                gimple_seq_last (seq)));\n       t = gimple_assign_lhs (gimple_seq_last (seq));\n       gimple_seq_set_location (seq, location);\n       gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+      /* For weird access sizes, check first and last byte.  */\n+      if (real_size_in_bytes != size_in_bytes)\n+\t{\n+\t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t\t    base_addr,\n+\t\t\t\t\t    build_int_cst (uintptr_type,\n+\t\t\t\t\t\t\t   size_in_bytes - 1));\n+\t  gimple_set_location (g, location);\n+\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t  tree base_end_addr = gimple_assign_lhs (g);\n+\n+\t  shadow = build_shadow_mem_access (&gsi, location, base_end_addr,\n+\t\t\t\t\t    shadow_ptr_type);\n+\t  seq = NULL;\n+\t  shadow_test = build_assign (NE_EXPR, shadow, 0);\n+\t  gimple_seq_add_stmt (&seq, shadow_test);\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR,\n+\t\t\t\t\t\t   base_end_addr, 7));\n+\t  gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n+\t\t\t\t\t\t      gimple_seq_last (seq)));\n+\t  gimple_seq_add_stmt (&seq, build_assign (GE_EXPR,\n+\t\t\t\t\t\t   gimple_seq_last (seq),\n+\t\t\t\t\t\t   shadow));\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n+\t\t\t\t\t\t   gimple_seq_last (seq)));\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_IOR_EXPR, t,\n+\t\t\t\t\t\t   gimple_seq_last (seq)));\n+\t  t = gimple_assign_lhs (gimple_seq_last (seq));\n+\t  gimple_seq_set_location (seq, location);\n+\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\t  sz_arg = build_int_cst (pointer_sized_int_node, size_in_bytes);\n+\t}\n     }\n   else\n     t = shadow;\n@@ -1573,7 +1627,7 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n   /* Generate call to the run-time library (e.g. __asan_report_load8).  */\n   gsi = gsi_start_bb (then_bb);\n   g = gimple_build_call (report_error_func (is_store, size_in_bytes),\n-\t\t\t 1, base_addr);\n+\t\t\t sz_arg ? 2 : 1, base_addr, sz_arg);\n   gimple_set_location (g, location);\n   gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n@@ -1611,8 +1665,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     }\n \n   size_in_bytes = int_size_in_bytes (type);\n-  if ((size_in_bytes & (size_in_bytes - 1)) != 0\n-      || (unsigned HOST_WIDE_INT) size_in_bytes - 1 >= 16)\n+  if (size_in_bytes <= 0)\n     return;\n \n   HOST_WIDE_INT bitsize, bitpos;\n@@ -1621,7 +1674,8 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n   int volatilep = 0, unsignedp = 0;\n   tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset,\n \t\t\t\t    &mode, &unsignedp, &volatilep, false);\n-  if (bitpos % (size_in_bytes * BITS_PER_UNIT)\n+  if (((size_in_bytes & (size_in_bytes - 1)) == 0\n+       && (bitpos % (size_in_bytes * BITS_PER_UNIT)))\n       || bitsize != size_in_bytes * BITS_PER_UNIT)\n     {\n       if (TREE_CODE (t) == COMPONENT_REF\n@@ -1634,6 +1688,8 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \t}\n       return;\n     }\n+  if (bitpos % BITS_PER_UNIT)\n+    return;\n \n   if (TREE_CODE (inner) == VAR_DECL\n       && offset == NULL_TREE"}, {"sha": "4016fc534cde8ffec35011ebdd1eeb82b9405d1f", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f9f6bb0ead69f2e09b62341e91a0f9643afe3f/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=40f9f6bb0ead69f2e09b62341e91a0f9643afe3f", "patch": "@@ -41,6 +41,9 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_LOAD8, \"__asan_report_load8\",\n \t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_LOAD16, \"__asan_report_load16\",\n \t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_LOAD_N, \"__asan_report_load_n\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE,\n+\t\t      ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_STORE1, \"__asan_report_store1\",\n \t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_STORE2, \"__asan_report_store2\",\n@@ -51,6 +54,9 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_STORE8, \"__asan_report_store8\",\n \t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_STORE16, \"__asan_report_store16\",\n \t\t      BT_FN_VOID_PTR, ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REPORT_STORE_N, \"__asan_report_store_n\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE,\n+\t\t      ATTR_TMPURE_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_REGISTER_GLOBALS,\n \t\t      \"__asan_register_globals\",\n \t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)"}]}