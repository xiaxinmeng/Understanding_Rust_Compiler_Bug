{"sha": "cd20e505e752c0434869baec3ac4fe7ac55a32b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QyMGU1MDVlNzUyYzA0MzQ4NjliYWVjM2FjNGZlN2FjNTVhMzJiOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:19:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:19:13Z"}, "message": "[multiple changes]\n\n2012-07-12  Robert Dewar  <dewar@adacore.com>\n\n\t* make.adb, sem_ch9.adb, prj.adb, s-rident.ads, snames.ads-tmpl: Minor\n\treformatting.\n\n2012-07-12  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Is_User_Defined_Equality): New subprogram.\n\t(Make_Neq_Body): New subprogram.\n\t(Make_Predefined_Primitive_Specs): Adding local variable\n\tHas_Predef_Eq_ Renaming to ensure that we enable the machinery\n\twhich handles renamings of predefined primitive operators.\n\nFrom-SVN: r189432", "tree": {"sha": "3f3cf576d4f28db8d3db474fab9bab784ed55f9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f3cf576d4f28db8d3db474fab9bab784ed55f9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd20e505e752c0434869baec3ac4fe7ac55a32b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd20e505e752c0434869baec3ac4fe7ac55a32b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd20e505e752c0434869baec3ac4fe7ac55a32b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd20e505e752c0434869baec3ac4fe7ac55a32b9/comments", "author": null, "committer": null, "parents": [{"sha": "381ec0f4cd325bdab94621649483c993f8f4139f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381ec0f4cd325bdab94621649483c993f8f4139f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/381ec0f4cd325bdab94621649483c993f8f4139f"}], "stats": {"total": 313, "additions": 273, "deletions": 40}, "files": [{"sha": "0e30e766c269727522645856a32d2f7e406cf805", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cd20e505e752c0434869baec3ac4fe7ac55a32b9", "patch": "@@ -1,3 +1,16 @@\n+2012-07-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* make.adb, sem_ch9.adb, prj.adb, s-rident.ads, snames.ads-tmpl: Minor\n+\treformatting.\n+\n+2012-07-12  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Is_User_Defined_Equality): New subprogram.\n+\t(Make_Neq_Body): New subprogram.\n+\t(Make_Predefined_Primitive_Specs): Adding local variable\n+\tHas_Predef_Eq_ Renaming to ensure that we enable the machinery\n+\twhich handles renamings of predefined primitive operators.\n+\n 2012-07-09  Pascal Obry  <obry@adacore.com>\n \n \t* prj.adb (For_Every_Project_Imported_Context): Make sure we"}, {"sha": "369d895906ba7b70dbc7069fd0b6db8996c82531", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 219, "deletions": 19, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=cd20e505e752c0434869baec3ac4fe7ac55a32b9", "patch": "@@ -202,6 +202,9 @@ package body Exp_Ch3 is\n    --  Check if E is defined in the RTL (in a child of Ada or System). Used\n    --  to avoid to bring in the overhead of _Input, _Output for tagged types.\n \n+   function Is_User_Defined_Equality (Prim : Node_Id) return Boolean;\n+   --  Returns true if Prim is a user defined equality function\n+\n    function Is_Variable_Size_Array (E : Entity_Id) return Boolean;\n    --  Returns true if E has variable size components\n \n@@ -237,6 +240,11 @@ package body Exp_Ch3 is\n    --  formals at some upper level). E provides the Sloc to be used for the\n    --  generated code.\n \n+   function Make_Neq_Body (Tag_Typ : Entity_Id) return Node_Id;\n+   --  Search for a renaming of the inequality dispatching primitive of\n+   --  this tagged type. If found then build and return the corresponding\n+   --  rename-as-body inequality subprogram; otherwise return Empty.\n+\n    procedure Make_Predefined_Primitive_Specs\n      (Tag_Typ     : Entity_Id;\n       Predef_List : out List_Id;\n@@ -7677,6 +7685,18 @@ package body Exp_Ch3 is\n       end loop;\n    end Init_Secondary_Tags;\n \n+   ------------------------\n+   -- Is_User_Defined_Eq --\n+   ------------------------\n+\n+   function Is_User_Defined_Equality (Prim : Node_Id) return Boolean is\n+   begin\n+      return Chars (Prim) = Name_Op_Eq\n+        and then Etype (First_Formal (Prim)) =\n+                 Etype (Next_Formal (First_Formal (Prim)))\n+        and then Base_Type (Etype (Prim)) = Standard_Boolean;\n+   end Is_User_Defined_Equality;\n+\n    ----------------------------\n    -- Is_Variable_Size_Array --\n    ----------------------------\n@@ -8140,6 +8160,175 @@ package body Exp_Ch3 is\n       end if;\n    end Make_Eq_If;\n \n+   --------------------\n+   --  Make_Neq_Body --\n+   --------------------\n+\n+   function Make_Neq_Body (Tag_Typ : Entity_Id) return Node_Id is\n+\n+      function Is_Predefined_Neq_Renaming (Prim : Node_Id) return Boolean;\n+      --  Returns true if Prim is a renaming of an unresolved predefined\n+      --  inequality operation.\n+\n+      --------------------------------\n+      -- Is_Predefined_Neq_Renaming --\n+      --------------------------------\n+\n+      function Is_Predefined_Neq_Renaming (Prim : Node_Id) return Boolean is\n+      begin\n+         return Chars (Prim) /= Name_Op_Ne\n+           and then Present (Alias (Prim))\n+           and then Comes_From_Source (Prim)\n+           and then Is_Intrinsic_Subprogram (Alias (Prim))\n+           and then Chars (Alias (Prim)) = Name_Op_Ne;\n+      end Is_Predefined_Neq_Renaming;\n+\n+      --  Local variables\n+\n+      Loc           : constant Source_Ptr := Sloc (Parent (Tag_Typ));\n+      Stmts         : constant List_Id    := New_List;\n+      Decl          : Node_Id;\n+      Eq_Prim       : Entity_Id;\n+      Left_Op       : Entity_Id;\n+      Renaming_Prim : Entity_Id;\n+      Right_Op      : Entity_Id;\n+      Target        : Entity_Id;\n+\n+   --  Start of processing for Make_Neq_Body\n+\n+   begin\n+      --  For a call on a renaming of a dispatching subprogram that is\n+      --  overridden, if the overriding occurred before the renaming, then\n+      --  the body executed is that of the overriding declaration, even if the\n+      --  overriding declaration is not visible at the place of the renaming;\n+      --  otherwise, the inherited or predefined subprogram is called, see\n+      --  (RM 8.5.4(8))\n+\n+      --  Stage 1: Search for a renaming of the unequality primitive and also\n+      --  search for an overriding of the equality primitive located before the\n+      --  renaming declaration.\n+\n+      declare\n+         Elmt : Elmt_Id;\n+         Prim : Node_Id;\n+\n+      begin\n+         Eq_Prim       := Empty;\n+         Renaming_Prim := Empty;\n+\n+         Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+         while Present (Elmt) loop\n+            Prim := Node (Elmt);\n+\n+            if Is_User_Defined_Equality (Prim)\n+              and then No (Alias (Prim))\n+            then\n+               if No (Renaming_Prim) then\n+                  pragma Assert (No (Eq_Prim));\n+                  Eq_Prim := Prim;\n+               end if;\n+\n+            elsif Is_Predefined_Neq_Renaming (Prim) then\n+               Renaming_Prim := Prim;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end;\n+\n+      --  No further action needed if no renaming was found\n+\n+      if No (Renaming_Prim) then\n+         return Empty;\n+      end if;\n+\n+      --  Stage 2: Replace the renaming declaration by a subprogram declaration\n+      --  (required to add its body)\n+\n+      Decl := Parent (Parent (Renaming_Prim));\n+      Rewrite (Decl,\n+        Make_Subprogram_Declaration (Loc,\n+          Specification => Specification (Decl)));\n+      Set_Analyzed (Decl);\n+\n+      --  Remove the decoration of intrinsic renaming subprogram\n+\n+      Set_Is_Intrinsic_Subprogram (Renaming_Prim, False);\n+      Set_Convention (Renaming_Prim, Convention_Ada);\n+      Set_Alias (Renaming_Prim, Empty);\n+      Set_Has_Completion (Renaming_Prim, False);\n+\n+      --  Stage 3: Build the corresponding body\n+\n+      Left_Op  := First_Formal (Renaming_Prim);\n+      Right_Op := Next_Formal (Left_Op);\n+\n+      Decl :=\n+        Predef_Spec_Or_Body (Loc,\n+          Tag_Typ => Tag_Typ,\n+          Name    => Chars (Renaming_Prim),\n+          Profile => New_List (\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier =>\n+                Make_Defining_Identifier (Loc, Chars (Left_Op)),\n+              Parameter_Type      => New_Reference_To (Tag_Typ, Loc)),\n+\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier =>\n+                Make_Defining_Identifier (Loc, Chars (Right_Op)),\n+              Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n+\n+          Ret_Type => Standard_Boolean,\n+          For_Body => True);\n+\n+      --  If the overriding of the equality primitive occurred before the\n+      --  renaming, then generate:\n+\n+      --    function <Neq_Name> (X : Y : Typ) return Boolean is\n+      --    begin\n+      --       return not Oeq (X, Y);\n+      --    end;\n+\n+      if Present (Eq_Prim) then\n+         Target := Eq_Prim;\n+\n+      --  Otherwise build a nested subprogram which performs the predefined\n+      --  evaluation of the equality operator. That is, generate:\n+\n+      --    function <Neq_Name> (X : Y : Typ) return Boolean is\n+      --       function Oeq (X : Y) return Boolean is\n+      --       begin\n+      --          <<body of default implementation>>\n+      --       end;\n+      --    begin\n+      --       return not Oeq (X, Y);\n+      --    end;\n+\n+      else\n+         declare\n+            Local_Subp : Node_Id;\n+         begin\n+            Local_Subp := Make_Eq_Body (Tag_Typ, Name_Op_Eq);\n+            Set_Declarations (Decl, New_List (Local_Subp));\n+            Target := Defining_Entity (Local_Subp);\n+         end;\n+      end if;\n+\n+      Append_To (Stmts,\n+        Make_Simple_Return_Statement (Loc,\n+          Expression =>\n+            Make_Op_Not (Loc,\n+              Make_Function_Call (Loc,\n+                Name => New_Reference_To (Target, Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Identifier (Loc, Chars (Left_Op)),\n+                  Make_Identifier (Loc, Chars (Right_Op)))))));\n+\n+      Set_Handled_Statement_Sequence\n+        (Decl, Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n+      return Decl;\n+   end Make_Neq_Body;\n+\n    -------------------------------\n    -- Make_Null_Procedure_Specs --\n    -------------------------------\n@@ -8238,13 +8427,6 @@ package body Exp_Ch3 is\n       Predef_List : out List_Id;\n       Renamed_Eq  : out Entity_Id)\n    is\n-      Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n-      Res       : constant List_Id    := New_List;\n-      Eq_Name   : Name_Id := Name_Op_Eq;\n-      Eq_Needed : Boolean;\n-      Eq_Spec   : Node_Id;\n-      Prim      : Elmt_Id;\n-\n       function Is_Predefined_Eq_Renaming (Prim : Node_Id) return Boolean;\n       --  Returns true if Prim is a renaming of an unresolved predefined\n       --  equality operation.\n@@ -8262,6 +8444,19 @@ package body Exp_Ch3 is\n            and then Chars (Alias (Prim)) = Name_Op_Eq;\n       end Is_Predefined_Eq_Renaming;\n \n+      --  Local variables\n+\n+      Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n+      Res       : constant List_Id    := New_List;\n+      Eq_Name   : Name_Id := Name_Op_Eq;\n+      Eq_Needed : Boolean;\n+      Eq_Spec   : Node_Id;\n+      Prim      : Elmt_Id;\n+\n+      Has_Predef_Eq_Renaming : Boolean := False;\n+      --  Set to True if Tag_Typ has a primitive that renames the predefined\n+      --  equality operator. Used to implement (RM 8-5-4(8)).\n+\n    --  Start of processing for Make_Predefined_Primitive_Specs\n \n    begin\n@@ -8299,9 +8494,9 @@ package body Exp_Ch3 is\n          end loop;\n       end;\n \n-      --  Spec of \"=\" is expanded if the type is not limited and if a\n-      --  user defined \"=\" was not already declared for the non-full\n-      --  view of a private extension\n+      --  Spec of \"=\" is expanded if the type is not limited and if a user\n+      --  defined \"=\" was not already declared for the non-full view of a\n+      --  private extension\n \n       if not Is_Limited_Type (Tag_Typ) then\n          Eq_Needed := True;\n@@ -8311,21 +8506,18 @@ package body Exp_Ch3 is\n             --  If a primitive is encountered that renames the predefined\n             --  equality operator before reaching any explicit equality\n             --  primitive, then we still need to create a predefined equality\n-            --  function, because calls to it can occur via the renaming. A new\n-            --  name is created for the equality to avoid conflicting with any\n-            --  user-defined equality. (Note that this doesn't account for\n+            --  function, because calls to it can occur via the renaming. A\n+            --  new name is created for the equality to avoid conflicting with\n+            --  any user-defined equality. (Note that this doesn't account for\n             --  renamings of equality nested within subpackages???)\n \n             if Is_Predefined_Eq_Renaming (Node (Prim)) then\n+               Has_Predef_Eq_Renaming := True;\n                Eq_Name := New_External_Name (Chars (Node (Prim)), 'E');\n \n             --  User-defined equality\n \n-            elsif Chars (Node (Prim)) = Name_Op_Eq\n-              and then Etype (First_Formal (Node (Prim))) =\n-                         Etype (Next_Formal (First_Formal (Node (Prim))))\n-              and then Base_Type (Etype (Node (Prim))) = Standard_Boolean\n-            then\n+            elsif Is_User_Defined_Equality (Node (Prim)) then\n                if No (Alias (Node (Prim)))\n                  or else Nkind (Unit_Declaration_Node (Node (Prim))) =\n                            N_Subprogram_Renaming_Declaration\n@@ -8394,7 +8586,7 @@ package body Exp_Ch3 is\n                 Ret_Type => Standard_Boolean);\n             Append_To (Res, Eq_Spec);\n \n-            if Eq_Name /= Name_Op_Eq then\n+            if Has_Predef_Eq_Renaming then\n                Renamed_Eq := Defining_Unit_Name (Specification (Eq_Spec));\n \n                Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n@@ -8966,6 +9158,14 @@ package body Exp_Ch3 is\n             Append_To (Res, Decl);\n          end if;\n \n+         --  Body for inequality (if required!)\n+\n+         Decl := Make_Neq_Body (Tag_Typ);\n+\n+         if Present (Decl) then\n+            Append_To (Res, Decl);\n+         end if;\n+\n          --  Body for dispatching assignment\n \n          Decl :="}, {"sha": "dca504d7919644a14e8f671009145f881136904c", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=cd20e505e752c0434869baec3ac4fe7ac55a32b9", "patch": "@@ -4807,8 +4807,10 @@ package body Make is\n          return;\n       end if;\n \n-      --  Regenerate libraries, if there are any and if object files\n-      --  have been regenerated.\n+      --  Regenerate libraries, if there are any and if object files have been\n+      --  regenerated. Note that we skip this in CodePeer mode because we don't\n+      --  need libraries in this case, and more importantly, the object files\n+      --  may not be present.\n \n       if Main_Project /= No_Project\n         and then not CodePeer_Mode"}, {"sha": "150d524d30f3a40231c0df4f589794ea1a902879", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=cd20e505e752c0434869baec3ac4fe7ac55a32b9", "patch": "@@ -599,12 +599,14 @@ package body Prj is\n \n             function Has_Sources (P : Project_Id) return Boolean is\n                Lang : Language_Ptr;\n+\n             begin\n                Lang := P.Languages;\n                while Lang /= No_Language_Index loop\n                   if Lang.First_Source /= No_Source then\n                      return True;\n                   end if;\n+\n                   Lang := Lang.Next;\n                end loop;\n \n@@ -617,6 +619,7 @@ package body Prj is\n \n             function Get_From_Tree (P : Project_Id) return Project_Id is\n                List : Project_List := Tree.Projects;\n+\n             begin\n                if not Has_Sources (P) then\n                   while List /= null loop\n@@ -625,15 +628,20 @@ package body Prj is\n                      then\n                         return List.Project;\n                      end if;\n+\n                      List := List.Next;\n                   end loop;\n                end if;\n \n                return P;\n             end Get_From_Tree;\n \n+            --  Local variables\n+\n             List : Project_List;\n \n+         --  Start of processing for Recursive_Check\n+\n          begin\n             if not Seen_Name.Contains (Project.Name) then\n "}, {"sha": "11943f074c3b8f564d84534e21d8eb5f004c304e", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=cd20e505e752c0434869baec3ac4fe7ac55a32b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,16 +30,17 @@\n ------------------------------------------------------------------------------\n \n --  This package defines the set of restriction identifiers. It is a generic\n---  package that is instantiated by the compiler/binder in package Rident, and\n---  is instantiated in package System.Restrictions for use at run-time.\n+--  package that is instantiated by the binder for output of the restrictions\n+--  structure, and is instantiated in package System.Restrictions for use at\n+--  run-time.\n \n --  The reason that we make this a generic package is so that in the case of\n---  the instantiation in Rident for use at compile time and bind time, we can\n---  generate normal image tables for the enumeration types, which are needed\n---  for diagnostic and informational messages. At run-time we really do not\n---  want to waste the space for these image tables, and they are not needed,\n---  so we can do the instantiation under control of Discard_Names to remove\n---  the tables.\n+--  the instantiation in the binder, we can generate normal image tables for\n+--  the enumeration types, which are needed for diagnostic and informational\n+--  messages as well as for identification of restrictions. At run-time we\n+--  really do not want to waste the space for these image tables, and they are\n+--  not needed, so we can do the instantiation under control of Discard_Names\n+--  to remove the tables.\n \n pragma Compiler_Unit;\n "}, {"sha": "d6141bc1e05c37638c45ae68e88342a19849614e", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=cd20e505e752c0434869baec3ac4fe7ac55a32b9", "patch": "@@ -244,6 +244,9 @@ package body Sem_Ch9 is\n                ----------------\n \n                function Check_Node (N : Node_Id) return Traverse_Result is\n+\n+                  --  The following function belongs in sem_eval ???\n+\n                   function Is_Static_Function (Attr : Node_Id) return Boolean;\n                   --  Given an attribute reference node Attr, return True if\n                   --  Attr denotes a static function according to the rules in"}, {"sha": "27ee72e2c89017db9e961e90310ffa4af9d7d713", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd20e505e752c0434869baec3ac4fe7ac55a32b9/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=cd20e505e752c0434869baec3ac4fe7ac55a32b9", "patch": "@@ -953,18 +953,24 @@ package Snames is\n    Last_Attribute_Name                 : constant Name_Id := N + $;\n \n    --  Names of internal attributes. They are not real attributes but special\n-   --  names used internally by GNAT in order to deal with certain delayed\n-   --  aspects (Aspect_CPU, Aspect_Dispatching_Domain,\n-   --  Aspect_Interrupt_Priority) that don't have corresponding pragmas or\n-   --  user-referencable attributes. It is convenient to have these internal\n-   --  attributes available in processing the aspects, since the normal\n-   --  approach is to convert an aspect into its corresponding pragma or\n-   --  attribute specification.\n+   --  names used internally by GNAT in order to deal with delayed aspects\n+   --  (Aspect_CPU, Aspect_Dispatching_Domain, Aspect_Interrupt_Priority) that\n+   --  don't have corresponding pragmas or user-referencable attributes.\n+\n+   --  It is convenient to have these internal attributes available for\n+   --  processing the aspects, since the normal approach is to convert an\n+   --  aspect into its corresponding pragma or attribute specification.\n+\n+   --  These attributes do have Attribute_Id values so that case statements\n+   --  on Attribute_Id include these cases, but they are NOT included in the\n+   --  Attribute_Name subtype defined above, which is typically used in the\n+   --  front end for checking syntax of submitted programs (where the use of\n+   --  internal attributes is not permitted).\n \n    First_Internal_Attribute_Name       : constant Name_Id := N + $;\n-   Name_CPU                            : constant Name_Id := N + $; -- INT\n-   Name_Dispatching_Domain             : constant Name_Id := N + $; -- INT\n-   Name_Interrupt_Priority             : constant Name_Id := N + $; -- INT\n+   Name_CPU                            : constant Name_Id := N + $;\n+   Name_Dispatching_Domain             : constant Name_Id := N + $;\n+   Name_Interrupt_Priority             : constant Name_Id := N + $;\n    Last_Internal_Attribute_Name        : constant Name_Id := N + $;\n \n    --  Names of recognized locking policy identifiers"}]}