{"sha": "bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4YjliMWVhZTQ4YWFhNDM1MGFiNTVlMzE3NWM0Mzk0YjllMzBjOQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:50:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:50:31Z"}, "message": "binde.adb (Better_Choice, [...]): Implement new preferences.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n\t* binde.adb (Better_Choice, Worse_Choice): Implement new preferences.\n\nFrom-SVN: r118245", "tree": {"sha": "50f8d6629ae5458408e64707b814202ea10dfdde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50f8d6629ae5458408e64707b814202ea10dfdde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9/comments", "author": null, "committer": null, "parents": [{"sha": "bfef8d0d62ede027e717a7ab1900bee71b54e708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfef8d0d62ede027e717a7ab1900bee71b54e708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfef8d0d62ede027e717a7ab1900bee71b54e708"}], "stats": {"total": 301, "additions": 213, "deletions": 88}, "files": [{"sha": "5bfccbfa300021766261c35248271ab785996a3e", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 213, "deletions": 88, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=bd8b9b1eae48aaa4350ab55e3175c4394b9e30c9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -271,6 +271,15 @@ package body Binde is\n    procedure Gather_Dependencies;\n    --  Compute dependencies, building the Succ and UNR tables\n \n+   function Is_Body_Unit (U : Unit_Id) return Boolean;\n+   pragma Inline (Is_Body_Unit);\n+   --  Determines if given unit is a body\n+\n+   function Is_Waiting_Body (U : Unit_Id) return Boolean;\n+   pragma Inline (Is_Waiting_Body);\n+   --  Determines if U is a waiting body, defined as a body which has\n+   --  not been elaborated, but whose spec has been elaborated.\n+\n    function Make_Elab_Entry\n      (Unam : Unit_Name_Type;\n       Link : Elab_All_Id) return Elab_All_Id;\n@@ -298,70 +307,82 @@ package body Binde is\n    -------------------\n \n    function Better_Choice (U1, U2 : Unit_Id) return Boolean is\n+      UT1 : Unit_Record renames Units.Table (U1);\n+      UT2 : Unit_Record renames Units.Table (U2);\n \n-      function Body_Unit (U : Unit_Id) return Boolean;\n-      --  Determines if given unit is a body\n-\n-      function Waiting_Body (U : Unit_Id) return Boolean;\n-      --  Determines if U is a waiting body, defined as a body which has\n-      --  not been elaborated, but whose spec has been elaborated.\n-\n-      function Body_Unit (U : Unit_Id) return Boolean is\n-      begin\n-         return Units.Table (U).Utype = Is_Body\n-           or else Units.Table (U).Utype = Is_Body_Only;\n-      end Body_Unit;\n-\n-      function Waiting_Body (U : Unit_Id) return Boolean is\n-      begin\n-         return Units.Table (U).Utype = Is_Body\n-           and then UNR.Table (Corresponding_Spec (U)).Elab_Position /= 0;\n-      end Waiting_Body;\n-\n-   --  Start of processing for Better_Choice\n+   begin\n+      if Debug_Flag_B then\n+         Write_Str (\"Better_Choice (\");\n+         Write_Unit_Name (UT1.Uname);\n+         Write_Str (\", \");\n+         Write_Unit_Name (UT2.Uname);\n+         Write_Line (\")\");\n+      end if;\n \n-   --  Note: the checks here are applied in sequence, and the ordering is\n-   --  significant (i.e. the more important criteria are applied first).\n+      --  Note: the checks here are applied in sequence, and the ordering is\n+      --  significant (i.e. the more important criteria are applied first).\n \n-   begin\n       --  Prefer a waiting body to any other case\n \n-      if Waiting_Body (U1) and not Waiting_Body (U2) then\n+      if Is_Waiting_Body (U1) and not Is_Waiting_Body (U2) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is waiting body, u2 is not\");\n+         end if;\n+\n          return True;\n \n-      elsif Waiting_Body (U2) and not Waiting_Body (U1) then\n+      elsif Is_Waiting_Body (U2) and not Is_Waiting_Body (U1) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is waiting body, u1 is not\");\n+         end if;\n+\n          return False;\n \n       --  Prefer a predefined unit to a non-predefined unit\n \n-      elsif Units.Table (U1).Predefined\n-        and not Units.Table (U2).Predefined\n-      then\n+      elsif UT1.Predefined and not UT2.Predefined then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is predefined, u2 is not\");\n+         end if;\n+\n          return True;\n \n-      elsif Units.Table (U2).Predefined\n-        and not Units.Table (U1).Predefined\n-      then\n+      elsif UT2.Predefined and not UT1.Predefined then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is predefined, u1 is not\");\n+         end if;\n+\n          return False;\n \n       --  Prefer an internal unit to a non-internal unit\n \n-      elsif Units.Table (U1).Internal\n-        and not Units.Table (U2).Internal\n-      then\n+      elsif UT1.Internal and not UT2.Internal then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is internal, u2 is not\");\n+         end if;\n          return True;\n \n-      elsif Units.Table (U2).Internal\n-        and not Units.Table (U1).Internal\n-      then\n+      elsif UT2.Internal and not UT1.Internal then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is internal, u1 is not\");\n+         end if;\n+\n          return False;\n \n       --  Prefer a body to a spec\n \n-      elsif Body_Unit (U1) and not Body_Unit (U2) then\n+      elsif Is_Body_Unit (U1) and not Is_Body_Unit (U2) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is body, u2 is not\");\n+         end if;\n+\n          return True;\n \n-      elsif Body_Unit (U2) and not Body_Unit (U1) then\n+      elsif Is_Body_Unit (U2) and not Is_Body_Unit (U1) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is body, u1 is not\");\n+         end if;\n+\n          return False;\n \n       --  If both are waiting bodies, then prefer the one whose spec is\n@@ -376,16 +397,89 @@ package body Binde is\n       --  must be the case that A depends on B. It is therefore a good idea\n       --  to put the body of B first.\n \n-      elsif Waiting_Body (U1) and then Waiting_Body (U2) then\n-         return\n-           UNR.Table (Corresponding_Spec (U1)).Elab_Position >\n-           UNR.Table (Corresponding_Spec (U2)).Elab_Position;\n+      elsif Is_Waiting_Body (U1) and then Is_Waiting_Body (U2) then\n+         declare\n+            Result : constant Boolean :=\n+                       UNR.Table (Corresponding_Spec (U1)).Elab_Position >\n+                       UNR.Table (Corresponding_Spec (U2)).Elab_Position;\n+         begin\n+            if Debug_Flag_B then\n+               if Result then\n+                  Write_Line (\"  True: based on waiting body elab positions\");\n+               else\n+                  Write_Line (\"  False: based on waiting body elab positions\");\n+               end if;\n+            end if;\n \n-      --  Otherwise decide on the basis of alphabetical order\n+            return Result;\n+         end;\n+      end if;\n \n-      else\n-         return Uname_Less (Units.Table (U1).Uname, Units.Table (U2).Uname);\n+      --  Remaining choice rules are disabled by Debug flag -do\n+\n+      if not Debug_Flag_O then\n+\n+         --  The following deal with the case of specs which have been marked\n+         --  as Elaborate_Body_Desirable. We generally want to delay these\n+         --  specs as long as possible, so that the bodies have a better chance\n+         --  of being elaborated closer to the specs.\n+\n+         --  If we have two units, one of which is a spec for which this flag\n+         --  is set, and the other is not, we prefer to delay the spec for\n+         --  which the flag is set.\n+\n+         if not UT1.Elaborate_Body_Desirable\n+           and then UT2.Elaborate_Body_Desirable\n+         then\n+            if Debug_Flag_B then\n+               Write_Line (\"  True: u1 is elab body desirable, u2 is not\");\n+            end if;\n+\n+            return True;\n+\n+         elsif not UT2.Elaborate_Body_Desirable\n+           and then UT1.Elaborate_Body_Desirable\n+         then\n+            if Debug_Flag_B then\n+               Write_Line (\"  False: u1 is elab body desirable, u2 is not\");\n+            end if;\n+\n+            return False;\n+\n+            --  If we have two specs that are both marked as Elaborate_Body\n+            --  desirable, we prefer the one whose body is nearer to being able\n+            --  to be elaborated, based on the Num_Pred count. This helps to\n+            --  ensure bodies are as close to specs as possible.\n+\n+         elsif UT1.Elaborate_Body_Desirable\n+           and then UT2.Elaborate_Body_Desirable\n+         then\n+            declare\n+               Result : constant Boolean :=\n+                          UNR.Table (Corresponding_Body (U1)).Num_Pred <\n+                          UNR.Table (Corresponding_Body (U2)).Num_Pred;\n+            begin\n+               if Debug_Flag_B then\n+                  if Result then\n+                     Write_Line (\"  True based on Num_Pred compare\");\n+                  else\n+                     Write_Line (\"  False based on Num_Pred compare\");\n+                  end if;\n+               end if;\n+\n+               return Result;\n+            end;\n+         end if;\n+      end if;\n+\n+      --  If we fall through, it means that no preference rule applies, so we\n+      --  use alphabetical order to at least give a deterministic result.\n+\n+      if Debug_Flag_B then\n+         Write_Line (\"  choose on alpha order\");\n       end if;\n+\n+      return Uname_Less (UT1.Uname, UT2.Uname);\n    end Better_Choice;\n \n    ----------------\n@@ -1018,7 +1112,6 @@ package body Binde is\n             Choose (Best_So_Far);\n          end if;\n       end loop Outer;\n-\n    end Find_Elab_Order;\n \n    -------------------------\n@@ -1156,6 +1249,26 @@ package body Binde is\n       end loop;\n    end Gather_Dependencies;\n \n+   ------------------\n+   -- Is_Body_Unit --\n+   ------------------\n+\n+   function Is_Body_Unit (U : Unit_Id) return Boolean is\n+   begin\n+      return Units.Table (U).Utype = Is_Body\n+        or else Units.Table (U).Utype = Is_Body_Only;\n+   end Is_Body_Unit;\n+\n+   ---------------------\n+   -- Is_Waiting_Body --\n+   ---------------------\n+\n+   function Is_Waiting_Body (U : Unit_Id) return Boolean is\n+   begin\n+      return Units.Table (U).Utype = Is_Body\n+        and then UNR.Table (Corresponding_Spec (U)).Elab_Position /= 0;\n+   end Is_Waiting_Body;\n+\n    ---------------------\n    -- Make_Elab_Entry --\n    ---------------------\n@@ -1187,35 +1300,8 @@ package body Binde is\n    ------------------\n \n    function Worse_Choice (U1, U2 : Unit_Id) return Boolean is\n-\n-      function Body_Unit (U : Unit_Id) return Boolean;\n-      --  Determines if given unit is a body\n-\n-      function Waiting_Body (U : Unit_Id) return Boolean;\n-      --  Determines if U is a waiting body, defined as a body which has\n-      --  not been elaborated, but whose spec has been elaborated.\n-\n-      ---------------\n-      -- Body_Unit --\n-      ---------------\n-\n-      function Body_Unit (U : Unit_Id) return Boolean is\n-      begin\n-         return Units.Table (U).Utype = Is_Body\n-           or else Units.Table (U).Utype = Is_Body_Only;\n-      end Body_Unit;\n-\n-      ------------------\n-      -- Waiting_Body --\n-      ------------------\n-\n-      function Waiting_Body (U : Unit_Id) return Boolean is\n-      begin\n-         return Units.Table (U).Utype = Is_Body and then\n-            UNR.Table (Corresponding_Spec (U)).Elab_Position /= 0;\n-      end Waiting_Body;\n-\n-   --  Start of processing for Worse_Choice\n+      UT1 : Unit_Record renames Units.Table (U1);\n+      UT2 : Unit_Record renames Units.Table (U2);\n \n    begin\n       --  Note: the checks here are applied in sequence, and the ordering is\n@@ -1226,23 +1312,23 @@ package body Binde is\n       --  of elaboration order, and for internal units, any problems are\n       --  ours and not the programmers.\n \n-      if Units.Table (U1).Internal or else Units.Table (U2).Internal then\n+      if UT1.Internal or else UT2.Internal then\n          return Better_Choice (U1, U2);\n \n       --  Prefer anything else to a waiting body (!)\n \n-      elsif Waiting_Body (U1) and not Waiting_Body (U2) then\n+      elsif Is_Waiting_Body (U1) and not Is_Waiting_Body (U2) then\n          return False;\n \n-      elsif Waiting_Body (U2) and not Waiting_Body (U1) then\n+      elsif Is_Waiting_Body (U2) and not Is_Waiting_Body (U1) then\n          return True;\n \n       --  Prefer a spec to a body (!)\n \n-      elsif Body_Unit (U1) and not Body_Unit (U2) then\n+      elsif Is_Body_Unit (U1) and not Is_Body_Unit (U2) then\n          return False;\n \n-      elsif Body_Unit (U2) and not Body_Unit (U1) then\n+      elsif Is_Body_Unit (U2) and not Is_Body_Unit (U1) then\n          return True;\n \n       --  If both are waiting bodies, then prefer the one whose spec is\n@@ -1258,18 +1344,57 @@ package body Binde is\n       --  to put the body of B last so that if there is an elaboration order\n       --  problem, we will find it (that's what horrible order is about)\n \n-      elsif Waiting_Body (U1) and then Waiting_Body (U2) then\n+      elsif Is_Waiting_Body (U1) and then Is_Waiting_Body (U2) then\n          return\n            UNR.Table (Corresponding_Spec (U1)).Elab_Position <\n            UNR.Table (Corresponding_Spec (U2)).Elab_Position;\n+      end if;\n \n-      --  Otherwise decide on the basis of alphabetical order. We do not try\n-      --  to reverse the usual choice here, since it can cause cancelling\n-      --  errors with the other inversions.\n+      --  Remaining choice rules are disabled by Debug flag -do\n \n-      else\n-         return Uname_Less (Units.Table (U1).Uname, Units.Table (U2).Uname);\n+      if not Debug_Flag_O then\n+\n+         --  The following deal with the case of specs which have been marked\n+         --  as Elaborate_Body_Desirable. In the normal case, we generally want\n+         --  to delay the elaboration of these specs as long as possible, so\n+         --  that bodies have better chance of being elaborated closer to the\n+         --  specs. Worse_Choice as usual wants to do the opposite and\n+         --  elaborate such specs as early as possible.\n+\n+         --  If we have two units, one of which is a spec for which this flag\n+         --  is set, and the other is not, we normally prefer to delay the spec\n+         --  for which the flag is set, and so Worse_Choice does the opposite.\n+\n+         if not UT1.Elaborate_Body_Desirable\n+           and then UT2.Elaborate_Body_Desirable\n+         then\n+            return False;\n+\n+         elsif not UT2.Elaborate_Body_Desirable\n+           and then UT1.Elaborate_Body_Desirable\n+         then\n+            return True;\n+\n+            --  If we have two specs that are both marked as Elaborate_Body\n+            --  desirable, we normally prefer the one whose body is nearer to\n+            --  being able to be elaborated, based on the Num_Pred count. This\n+            --  helps to ensure bodies are as close to specs as possible. As\n+            --  usual, Worse_Choice does the opposite.\n+\n+         elsif UT1.Elaborate_Body_Desirable\n+           and then UT2.Elaborate_Body_Desirable\n+         then\n+            return UNR.Table (Corresponding_Body (U1)).Num_Pred >=\n+              UNR.Table (Corresponding_Body (U2)).Num_Pred;\n+         end if;\n       end if;\n+\n+      --  If we fall through, it means that no preference rule applies, so we\n+      --  use alphabetical order to at least give a deterministic result. Since\n+      --  Worse_Choice is in the business of stirring up the order, we will\n+      --  use reverse alphabetical ordering.\n+\n+      return Uname_Less (UT2.Uname, UT1.Uname);\n    end Worse_Choice;\n \n    ------------------------"}]}