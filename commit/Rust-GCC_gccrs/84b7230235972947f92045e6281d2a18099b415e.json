{"sha": "84b7230235972947f92045e6281d2a18099b415e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRiNzIzMDIzNTk3Mjk0N2Y5MjA0NWU2MjgxZDJhMTgwOTliNDE1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-10-11T07:07:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-10-11T07:07:30Z"}, "message": "c-parse.in (asm_operand): Allow named operands.\n\n        * c-parse.in (asm_operand): Allow named operands.\n        * genconfig.c (max_recog_operands): Set to 29.\n        * local-alloc.c (requires_inout): Skip multiple digits.\n        * recog.c (asm_operand_ok): Likewise.\n        (preprocess_constraints): Use strtoul for matching constraints.\n        (constrain_operands): Likewise.\n        * regmove.c (find_matches): Likewise.\n        * reload.c (find_reloads): Likewise.\n        * stmt.c (parse_output_constraint): Don't reject in-out\n        constraint on operands > 9.  Reject '[' in constraint.\n        (expand_asm_operands): Handle named operands.  Use strtoul\n        for matching constraints.\n        (check_operand_nalternatives): Split out from expand_asm_operands.\n        (check_unique_operand_names): New.\n        (resolve_operand_names, resolve_operand_name_1): New.\n\n        * doc/extend.texi (Extended Asm): Document named operands.\n        * doc/md.texi (Simple Constraints): Document matching constraints\n        on operands > 9.\n\n        * parse.y (asm_operand): Allow named operands.\n        * semantics.c (finish_asm_stmt): Tweek for changed location\n        of the operand constrant.\n\nFrom-SVN: r46179", "tree": {"sha": "65279fa1cd98240f2ba4d2902ef69c88fa458bd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65279fa1cd98240f2ba4d2902ef69c88fa458bd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84b7230235972947f92045e6281d2a18099b415e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b7230235972947f92045e6281d2a18099b415e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b7230235972947f92045e6281d2a18099b415e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b7230235972947f92045e6281d2a18099b415e/comments", "author": null, "committer": null, "parents": [{"sha": "592188a538c1993640b27f0788f382e282dddbb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592188a538c1993640b27f0788f382e282dddbb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592188a538c1993640b27f0788f382e282dddbb6"}], "stats": {"total": 563, "additions": 414, "deletions": 149}, "files": [{"sha": "b322551d11a68ae92f4c43aa65a4420b608d35f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -1,3 +1,25 @@\n+2001-10-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-parse.in (asm_operand): Allow named operands.\n+\t* genconfig.c (max_recog_operands): Set to 29.\n+\t* local-alloc.c (requires_inout): Skip multiple digits.\n+\t* recog.c (asm_operand_ok): Likewise.\n+\t(preprocess_constraints): Use strtoul for matching constraints.\n+\t(constrain_operands): Likewise.\n+\t* regmove.c (find_matches): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* stmt.c (parse_output_constraint): Don't reject in-out\n+\tconstraint on operands > 9.  Reject '[' in constraint.\n+\t(expand_asm_operands): Handle named operands.  Use strtoul\n+\tfor matching constraints.\n+\t(check_operand_nalternatives): Split out from expand_asm_operands.\n+\t(check_unique_operand_names): New.\n+\t(resolve_operand_names, resolve_operand_name_1): New.\n+\n+\t* doc/extend.texi (Extended Asm): Document named operands.\n+\t* doc/md.texi (Simple Constraints): Document matching constraints\n+\ton operands > 9.\n+\n 2001-10-10  Richard Henderson  <rth@redhat.com>\n \n \t* combine.c (try_combine): Handle a SEQUENCE of one insn."}, {"sha": "8096d1cef27b4118e25215b838b5dab68feabbcc", "filename": "gcc/c-parse.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -2454,7 +2454,9 @@ nonnull_asm_operands:\n \n asm_operand:\n \t  STRING '(' expr ')'\n-\t\t{ $$ = build_tree_list ($1, $3); }\n+\t\t{ $$ = build_tree_list (build_tree_list (NULL_TREE, $1), $3); }\n+\t| '[' identifier ']' STRING '(' expr ')'\n+\t\t{ $$ = build_tree_list (build_tree_list ($2, $4), $6); }\n \t;\n \n asm_clobbers:"}, {"sha": "8d867bbd5791c894b3fe383fddd1ce9577394e3b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -1,3 +1,9 @@\n+2001-10-10  Richard Henderson  <rth@redhat.com>\n+\n+        * parse.y (asm_operand): Allow named operands.\n+\t* semantics.c (finish_asm_stmt): Tweek for changed location\n+\tof the operand constrant.\n+\n 2001-10-09  Jason Merrill  <jason_merrill@redhat.com>\n \n \t* call.c (standard_conversion): Add bad conversion between"}, {"sha": "f3e85ffe849e69089dbfdd182f945f4ff8ea1829", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -3607,7 +3607,9 @@ nonnull_asm_operands:\n \n asm_operand:\n \t  STRING '(' expr ')'\n-\t\t{ $$ = build_tree_list ($$, $3); }\n+\t\t{ $$ = build_tree_list (build_tree_list (NULL_TREE, $1), $3); }\n+\t| '[' identifier ']' STRING '(' expr ')'\n+\t\t{ $$ = build_tree_list (build_tree_list ($2, $4), $6); }\n \t;\n \n asm_clobbers:"}, {"sha": "41e3bcf4b462f242b9c7659693544f345bf8fb1c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -929,7 +929,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n \t  const char *constraint;\n \t  tree operand;\n \n-\t  constraint = TREE_STRING_POINTER (TREE_PURPOSE (t));\n+\t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n \t  operand = TREE_VALUE (output_operands);\n \n \t  if (!parse_output_constraint (&constraint,"}, {"sha": "132ccbad14fe1a02b480d5221fe69b5a107db6ed", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -3382,14 +3382,34 @@ Each operand is described by an operand-constraint string followed by\n the C expression in parentheses.  A colon separates the assembler\n template from the first output operand and another separates the last\n output operand from the first input, if any.  Commas separate the\n-operands within each group.  The total number of operands is limited to\n-ten or to the maximum number of operands in any instruction pattern in\n-the machine description, whichever is greater.\n+operands within each group.  The total number of operands is currently\n+limited to 30; this limitation may be lifted in some future version of\n+GCC.\n \n If there are no output operands but there are input operands, you must\n place two consecutive colons surrounding the place where the output\n operands would go.\n \n+As of GCC version 3.1, it is also possible to specify input and output\n+operands using symbolic names which can be referenced within the\n+assembler code.  These names are specified inside square brackets\n+preceding the constraint string, and can be referenced inside the\n+assembler code using @code{%[@var{name}]} instead of a percentage sign\n+followed by the operand number.  Using named operands the above example\n+could look like:\n+\n+@example\n+asm (\"fsinx %[angle],%[output]\"\n+     : [output] \"=f\" (result)\n+     : [angle] \"f\" (angle));\n+@end example\n+\n+@noindent\n+Note that the symbolic operand names have no relation whatsoever to\n+other C identifiers.  You may use any name you like, even those of\n+existing C symbols, but must ensure that no two operands within the same\n+assembler construct use the same symbolic name.\n+\n Output operand expressions must be lvalues; the compiler can check this.\n The input operands need not be lvalues.  The compiler cannot check\n whether the operands have data types that are reasonable for the\n@@ -3425,10 +3445,10 @@ asm (\"combine %2,%0\" : \"=r\" (foo) : \"0\" (foo), \"g\" (bar));\n \n @noindent\n The constraint @samp{\"0\"} for operand 1 says that it must occupy the\n-same location as operand 0.  A digit in constraint is allowed only in an\n-input operand and it must refer to an output operand.\n+same location as operand 0.  A number in constraint is allowed only in\n+an input operand and it must refer to an output operand.\n \n-Only a digit in the constraint can guarantee that one operand will be in\n+Only a number in the constraint can guarantee that one operand will be in\n the same place as another.  The mere fact that @code{foo} is the value\n of both operands is not enough to guarantee that they will be in the\n same place in the generated assembler code.  The following would not\n@@ -3446,6 +3466,15 @@ register (copying it afterward to @code{foo}'s own address).  Of course,\n since the register for operand 1 is not even mentioned in the assembler\n code, the result will not work, but GCC can't tell that.\n \n+As of GCC version 3.1, one may write @code{[@var{name}]} instead of\n+the operand number for a matching constraint.  For example:\n+\n+@example\n+asm (\"cmoveq %1,%2,%[result]\"\n+     : [result] \"=r\"(result)\n+     : \"r\" (test), \"r\"(new), \"[result]\"(old));\n+@end example\n+\n Some instructions clobber specific hard registers.  To describe this,\n write a third colon after the input operands, followed by the names of\n the clobbered hard registers (given as strings).  Here is a realistic"}, {"sha": "7a62eaf25c045dd3806392995b8a5a1c91631bbe", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -894,6 +894,13 @@ An operand that matches the specified operand number is allowed.  If a\n digit is used together with letters within the same alternative, the\n digit should come last.\n \n+This number is allowed to be more than a single digit.  If multiple\n+digits are encountered consecutavely, they are interpreted as a single\n+decimal integer.  There is scant chance for ambiguity, since to-date\n+it has never been desirable that @samp{10} be interpreted as matching\n+either operand 1 @emph{or} operand 0.  Should this be desired, one\n+can use multiple alternatives instead.\n+\n @cindex matching constraint\n @cindex constraint, matching\n This is called a @dfn{matching constraint} and what it really means is"}, {"sha": "27000be7d93f9eacf07216c72e48c0f6ae008465", "filename": "gcc/genconfig.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -285,8 +285,10 @@ main (argc, argv)\n   puts (\"#ifndef GCC_INSN_CONFIG_H\");\n   puts (\"#define GCC_INSN_CONFIG_H\\n\");\n \n-  /* Allow at least 10 operands for the sake of asm constructs.  */\n-  max_recog_operands = 9;  /* We will add 1 later.  */\n+  /* Allow at least 30 operands for the sake of asm constructs.  */\n+  /* ??? We *really* ought to reorganize things such that there\n+     is no fixed upper bound.  */\n+  max_recog_operands = 29;  /* We will add 1 later.  */\n   max_dup_operands = 1;\n \n   /* Read the machine description.  */"}, {"sha": "22d7d48b528ed4eb98334faf5ae8f68d5dd0826b", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -1302,7 +1302,7 @@ block_alloc (b)\n \t      for (i = 1; i < recog_data.n_operands; i++)\n \t\t{\n \t\t  const char *p = recog_data.constraints[i];\n-\t\t  int this_match = (requires_inout (p));\n+\t\t  int this_match = requires_inout (p);\n \n \t\t  n_matching_alts += this_match;\n \t\t  if (this_match == recog_data.n_alternatives)\n@@ -2409,8 +2409,6 @@ requires_inout (p)\n       case '=':  case '+':  case '?':\n       case '#':  case '&':  case '!':\n       case '*':  case '%':\n-      case '1':  case '2':  case '3':  case '4': case '5':\n-      case '6':  case '7':  case '8':  case '9':\n       case 'm':  case '<':  case '>':  case 'V':  case 'o':\n       case 'E':  case 'F':  case 'G':  case 'H':\n       case 's':  case 'i':  case 'n':\n@@ -2431,6 +2429,13 @@ requires_inout (p)\n \tfound_zero = 1;\n \tbreak;\n \n+      case '1':  case '2':  case '3':  case '4': case '5':\n+      case '6':  case '7':  case '8':  case '9':\n+\t/* Skip the balance of the matching constraint.  */\n+\twhile (*p >= '0' && *p <= '9')\n+\t  p++;\n+\tbreak;\n+\n       default:\n \tif (REG_CLASS_FROM_LETTER (c) == NO_REGS)\n \t  break;"}, {"sha": "150487057638ef5ff2bd8c31add0c7abad1893d0", "filename": "gcc/recog.c", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -1657,6 +1657,8 @@ asm_operand_ok (op, constraint)\n \t     proper matching constraint, but we can't actually fail\n \t     the check if they didn't.  Indicate that results are\n \t     inconclusive.  */\n+\t  while (*constraint >= '0' && *constraint <= '9')\n+\t    constraint++;\n \t  result = -1;\n \t  break;\n \n@@ -2211,8 +2213,12 @@ preprocess_constraints ()\n \n \t\tcase '0': case '1': case '2': case '3': case '4':\n \t\tcase '5': case '6': case '7': case '8': case '9':\n-\t\t  op_alt[j].matches = c - '0';\n-\t\t  recog_op_alt[op_alt[j].matches][j].matched = i;\n+\t\t  {\n+\t\t    char *end;\n+\t\t    op_alt[j].matches = strtoul (p - 1, &end, 10);\n+\t\t    recog_op_alt[op_alt[j].matches][j].matched = i;\n+\t\t    p = end;\n+\t\t  }\n \t\t  break;\n \n \t\tcase 'm':\n@@ -2364,45 +2370,54 @@ constrain_operands (strict)\n \n \t      case '0':  case '1':  case '2':  case '3':  case '4':\n \t      case '5':  case '6':  case '7':  case '8':  case '9':\n+\t\t{\n+\t\t  /* This operand must be the same as a previous one.\n+\t\t     This kind of constraint is used for instructions such\n+\t\t     as add when they take only two operands.\n \n-\t\t/* This operand must be the same as a previous one.\n-\t\t   This kind of constraint is used for instructions such\n-\t\t   as add when they take only two operands.\n+\t\t     Note that the lower-numbered operand is passed first.\n \n-\t\t   Note that the lower-numbered operand is passed first.\n+\t\t     If we are not testing strictly, assume that this\n+\t\t     constraint will be satisfied.  */\n \n-\t\t   If we are not testing strictly, assume that this constraint\n-\t\t   will be satisfied.  */\n-\t\tif (strict < 0)\n-\t\t  val = 1;\n-\t\telse\n-\t\t  {\n-\t\t    rtx op1 = recog_data.operand[c - '0'];\n-\t\t    rtx op2 = recog_data.operand[opno];\n+\t\t  char *end;\n+\t\t  int match;\n \n-\t            /* A unary operator may be accepted by the predicate,\n-\t\t       but it is irrelevant for matching constraints.  */\n-\t            if (GET_RTX_CLASS (GET_CODE (op1)) == '1')\n-\t              op1 = XEXP (op1, 0);\n-\t            if (GET_RTX_CLASS (GET_CODE (op2)) == '1')\n-\t              op2 = XEXP (op2, 0);\n+\t\t  match = strtoul (p - 1, &end, 10);\n+\t\t  p = end;\n \n-\t\t    val = operands_match_p (op1, op2);\n-\t\t  }\n+\t\t  if (strict < 0)\n+\t\t    val = 1;\n+\t\t  else\n+\t\t    {\n+\t\t      rtx op1 = recog_data.operand[match];\n+\t\t      rtx op2 = recog_data.operand[opno];\n \n-\t\tmatching_operands[opno] = c - '0';\n-\t\tmatching_operands[c - '0'] = opno;\n+\t\t      /* A unary operator may be accepted by the predicate,\n+\t\t\t but it is irrelevant for matching constraints.  */\n+\t\t      if (GET_RTX_CLASS (GET_CODE (op1)) == '1')\n+\t\t\top1 = XEXP (op1, 0);\n+\t\t      if (GET_RTX_CLASS (GET_CODE (op2)) == '1')\n+\t\t\top2 = XEXP (op2, 0);\n \n-\t\tif (val != 0)\n-\t\t  win = 1;\n-\t\t/* If output is *x and input is *--x,\n-\t\t   arrange later to change the output to *--x as well,\n-\t\t   since the output op is the one that will be printed.  */\n-\t\tif (val == 2 && strict > 0)\n-\t\t  {\n-\t\t    funny_match[funny_match_index].this = opno;\n-\t\t    funny_match[funny_match_index++].other = c - '0';\n-\t\t  }\n+\t\t      val = operands_match_p (op1, op2);\n+\t\t    }\n+\n+\t\t  matching_operands[opno] = match;\n+\t\t  matching_operands[match] = opno;\n+\n+\t\t  if (val != 0)\n+\t\t    win = 1;\n+\n+\t\t  /* If output is *x and input is *--x, arrange later\n+\t\t     to change the output to *--x as well, since the\n+\t\t     output op is the one that will be printed.  */\n+\t\t  if (val == 2 && strict > 0)\n+\t\t    {\n+\t\t      funny_match[funny_match_index].this = opno;\n+\t\t      funny_match[funny_match_index++].other = match;\n+\t\t    }\n+\t\t}\n \t\tbreak;\n \n \t      case 'p':"}, {"sha": "89a55ca44e17138eb084a91e089aff7b27cc51be", "filename": "gcc/regmove.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -1576,16 +1576,23 @@ find_matches (insn, matchp)\n \t    matchp->commutative[op_no] = op_no + 1;\n \t    matchp->commutative[op_no + 1] = op_no;\n \t    break;\n+\n \t  case '0': case '1': case '2': case '3': case '4':\n \t  case '5': case '6': case '7': case '8': case '9':\n-\t    c -= '0';\n-\t    if (c < op_no && likely_spilled[(unsigned char) c])\n-\t      break;\n-\t    matchp->with[op_no] = c;\n-\t    any_matches = 1;\n-\t    if (matchp->commutative[op_no] >= 0)\n-\t      matchp->with[matchp->commutative[op_no]] = c;\n+\t    {\n+\t      char *end;\n+\t      unsigned long match = strtoul (p - 1, &end, 10);\n+\t      p = end;\n+\n+\t      if (match < op_no && likely_spilled[match])\n+\t\tbreak;\n+\t      matchp->with[op_no] = match;\n+\t      any_matches = 1;\n+\t      if (matchp->commutative[op_no] >= 0)\n+\t\tmatchp->with[matchp->commutative[op_no]] = match;\n+\t    }\n \t    break;\n+\n \t  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'h':\n \t  case 'j': case 'k': case 'l': case 'p': case 'q': case 't': case 'u':\n \t  case 'v': case 'w': case 'x': case 'y': case 'z': case 'A': case 'B':"}, {"sha": "8b01ce25403a434cb58efc0e63860ee7f12c373c", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -2551,7 +2551,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    }\n \t  else if (c >= '0' && c <= '9')\n \t    {\n-\t      c -= '0';\n+\t      c = strtoul (p - 1, &p, 10);\n+\n \t      operands_match[c][i]\n \t\t= operands_match_p (recog_data.operand[c],\n \t\t\t\t    recog_data.operand[i]);\n@@ -2939,8 +2940,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t      case '0':  case '1':  case '2':  case '3':  case '4':\n \t      case '5':  case '6':  case '7':  case '8':  case '9':\n+\t\tc = strtoul (p - 1, &p, 10);\n \n-\t\tc -= '0';\n \t\tthis_alternative_matches[i] = c;\n \t\t/* We are supposed to match a previous operand.\n \t\t   If we do, we win if that one did."}, {"sha": "1f91823bdc8b224c1b86a295c3990fd297b97de7", "filename": "gcc/stmt.c", "status": "modified", "additions": 259, "deletions": 92, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b7230235972947f92045e6281d2a18099b415e/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=84b7230235972947f92045e6281d2a18099b415e", "patch": "@@ -404,6 +404,11 @@ static void expand_nl_goto_receiver\tPARAMS ((void));\n static void expand_nl_goto_receivers\tPARAMS ((struct nesting *));\n static void fixup_gotos\t\t\tPARAMS ((struct nesting *, rtx, tree,\n \t\t\t\t\t       rtx, int));\n+static bool check_operand_nalternatives\tPARAMS ((tree, tree));\n+static bool check_unique_operand_names\tPARAMS ((tree, tree));\n+static tree resolve_operand_names\tPARAMS ((tree, tree, tree,\n+\t\t\t\t\t\t const char **));\n+static char *resolve_operand_name_1\tPARAMS ((char *, tree, tree));\n static void expand_null_return_1\tPARAMS ((rtx));\n static void expand_value_return\t\tPARAMS ((rtx));\n static int tail_recursion_args\t\tPARAMS ((tree, tree));\n@@ -1355,14 +1360,6 @@ parse_output_constraint (constraint_p,\n      from and written to.  */\n   *is_inout = (*p == '+');\n \n-  /* Make sure we can specify the matching operand.  */\n-  if (*is_inout && operand_num > 9)\n-    {\n-      error (\"output operand constraint %d contains `+'\", \n-\t     operand_num);\n-      return false;\n-    }\n-\n   /* Canonicalize the output constraint so that it begins with `='.  */\n   if (p != constraint || is_inout)\n     {\n@@ -1416,6 +1413,7 @@ parse_output_constraint (constraint_p,\n \n       case '0':  case '1':  case '2':  case '3':  case '4':\n       case '5':  case '6':  case '7':  case '8':  case '9':\n+      case '[':\n \terror (\"matching constraint not valid in output operand\");\n \treturn false;\n \n@@ -1478,7 +1476,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n      const char *filename;\n      int line;\n {\n-  rtvec argvec, constraints;\n+  rtvec argvec, constraintvec;\n   rtx body;\n   int ninputs = list_length (inputs);\n   int noutputs = list_length (outputs);\n@@ -1492,8 +1490,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   rtx *real_output_rtx = (rtx *) alloca (noutputs * sizeof (rtx));\n   enum machine_mode *inout_mode\n     = (enum machine_mode *) alloca (noutputs * sizeof (enum machine_mode));\n-  const char **output_constraints\n-    = alloca (noutputs * sizeof (const char *));\n+  const char **constraints\n+    = (const char **) alloca ((noutputs + ninputs) * sizeof (const char *));\n   /* The insn we have emitted.  */\n   rtx insn;\n   int old_generating_concat_p = generating_concat_p;\n@@ -1504,10 +1502,18 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   if (current_function_check_memory_usage)\n     {\n-      error (\"`asm' cannot be used with `-fcheck-memory-usage'\");\n+      error (\"`asm' cannot be used in function where memory usage is checked\");\n       return;\n     }\n \n+  if (! check_operand_nalternatives (outputs, inputs))\n+    return;\n+\n+  if (! check_unique_operand_names (outputs, inputs))\n+    return;\n+\n+  string = resolve_operand_names (string, outputs, inputs, constraints);\n+\n #ifdef MD_ASM_CLOBBERS\n   /* Sometimes we wish to automatically clobber registers across an asm.\n      Case in point is when the i386 backend moved from cc0 to a hard reg --\n@@ -1516,12 +1522,6 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   MD_ASM_CLOBBERS (clobbers);\n #endif\n \n-  if (current_function_check_memory_usage)\n-    {\n-      error (\"`asm' cannot be used in function where memory usage is checked\");\n-      return;\n-    }\n-\n   /* Count the number of meaningful clobbered registers, ignoring what\n      we would ignore later.  */\n   nclobbers = 0;\n@@ -1538,43 +1538,10 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   last_expr_type = 0;\n \n-  /* Check that the number of alternatives is constant across all\n-     operands.  */\n-  if (outputs || inputs)\n-    {\n-      tree tmp = TREE_PURPOSE (outputs ? outputs : inputs);\n-      int nalternatives = n_occurrences (',', TREE_STRING_POINTER (tmp));\n-      tree next = inputs;\n-\n-      if (nalternatives + 1 > MAX_RECOG_ALTERNATIVES)\n-\t{\n-\t  error (\"too many alternatives in `asm'\");\n-\t  return;\n-\t}\n-\n-      tmp = outputs;\n-      while (tmp)\n-\t{\n-\t  const char *constraint = TREE_STRING_POINTER (TREE_PURPOSE (tmp));\n-\n-\t  if (n_occurrences (',', constraint) != nalternatives)\n-\t    {\n-\t      error (\"operand constraints for `asm' differ in number of alternatives\");\n-\t      return;\n-\t    }\n-\n-\t  if (TREE_CHAIN (tmp))\n-\t    tmp = TREE_CHAIN (tmp);\n-\t  else\n-\t    tmp = next, next = 0;\n-\t}\n-    }\n-\n   for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n     {\n       tree val = TREE_VALUE (tail);\n       tree type = TREE_TYPE (val);\n-      const char *constraint;\n       bool is_inout;\n       bool allows_reg;\n       bool allows_mem;\n@@ -1588,12 +1555,9 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t the worst that happens if we get it wrong is we issue an error\n \t message.  */\n \n-      constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n-      output_constraints[i] = constraint;\n-\n       /* Try to parse the output constraint.  If that fails, there's\n \t no point in going further.  */\n-      if (!parse_output_constraint (&output_constraints[i],\n+      if (!parse_output_constraint (&constraints[i],\n \t\t\t\t    i,\n \t\t\t\t    ninputs,\n \t\t\t\t    noutputs,\n@@ -1659,24 +1623,24 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       return;\n     }\n \n-  /* Make vectors for the expression-rtx and constraint strings.  */\n+  /* Make vectors for the expression-rtx, constraint strings,\n+     and named operands.  */\n \n   argvec = rtvec_alloc (ninputs);\n-  constraints = rtvec_alloc (ninputs);\n+  constraintvec = rtvec_alloc (ninputs);\n \n   body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode\n \t\t\t\t: GET_MODE (output_rtx[0])),\n \t\t\t       TREE_STRING_POINTER (string), \n-\t\t\t       empty_string, 0, argvec, constraints,\n+\t\t\t       empty_string, 0, argvec, constraintvec,\n \t\t\t       filename, line);\n \n   MEM_VOLATILE_P (body) = vol;\n \n   /* Eval the inputs and put them into ARGVEC.\n      Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */\n \n-  i = 0;\n-  for (tail = inputs; tail; tail = TREE_CHAIN (tail))\n+  for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), ++i)\n     {\n       int j;\n       int allows_reg = 0, allows_mem = 0;\n@@ -1698,9 +1662,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  return;\n \t}\n \n-      constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n+      orig_constraint = constraint = constraints[i + noutputs];\n       c_len = strlen (constraint);\n-      orig_constraint = constraint;\n \n       /* Make sure constraint has neither `=', `+', nor '&'.  */\n \n@@ -1744,28 +1707,30 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t       operands to memory.  */\n \t  case '0':  case '1':  case '2':  case '3':  case '4':\n \t  case '5':  case '6':  case '7':  case '8':  case '9':\n-\t    if (constraint[j] >= '0' + noutputs)\n-\t      {\n-\t\terror\n-\t\t  (\"matching constraint references invalid operand number\");\n-\t\treturn;\n-\t      }\n-\n-\t    /* Try and find the real constraint for this dup.  */\n-\t    if ((j == 0 && c_len == 1)\n-\t\t|| (j == 1 && c_len == 2 && constraint[0] == '%'))\n-\t      {\n-\t\ttree o = outputs;\n-\n-\t\tfor (j = constraint[j] - '0'; j > 0; --j)\n-\t\t  o = TREE_CHAIN (o);\n+\t    {\n+\t      char *end;\n+\t      unsigned long match;\n \n-\t\tconstraint = TREE_STRING_POINTER (TREE_PURPOSE (o));\n-\t\tc_len = strlen (constraint);\n-\t\tj = 0;\n-\t\tbreak;\n-\t      }\n+\t      match = strtoul (constraint + j, &end, 10);\n+\t      if (match >= (unsigned long) noutputs)\n+\t\t{\n+\t\t  error (\"matching constraint references invalid operand number\");\n+\t\t  return;\n+\t\t}\n \n+\t      /* Try and find the real constraint for this dup.  Only do\n+\t         this if the matching constraint is the only alternative.  */\n+\t      if (*end == '\\0'\n+\t\t  && (j == 0 || (j == 1 && constraint[0] == '%')))\n+\t\t{\n+\t\t  constraint = constraints[match];\n+\t\t  c_len = strlen (constraint);\n+\t\t  j = 0;\n+\t          break;\n+\t\t}\n+\t      else\n+\t\tj = end - constraint;\n+\t    }\n \t    /* Fall through.  */\n \n \t  case 'p':  case 'r':\n@@ -1814,7 +1779,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  if (allows_reg)\n \t    op = force_reg (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))), op);\n \t  else if (!allows_mem)\n-\t    warning (\"asm operand %d probably doesn't match constraints\", i);\n+\t    warning (\"asm operand %d probably doesn't match constraints\",\n+\t\t     i + noutputs);\n \t  else if (CONSTANT_P (op))\n \t    op = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n \t\t\t\t  op);\n@@ -1843,15 +1809,15 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    /* ??? Leave this only until we have experience with what\n \t       happens in combine and elsewhere when constraints are\n \t       not satisfied.  */\n-\t    warning (\"asm operand %d probably doesn't match constraints\", i);\n+\t    warning (\"asm operand %d probably doesn't match constraints\",\n+\t\t     i + noutputs);\n \t}\n       generating_concat_p = old_generating_concat_p;\n       ASM_OPERANDS_INPUT (body, i) = op;\n \n       ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, i)\n \t= gen_rtx_ASM_INPUT (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n \t\t\t     orig_constraint);\n-      i++;\n     }\n \n   /* Protect all the operands from the queue now that they have all been\n@@ -1870,24 +1836,26 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   for (i = 0; i < ninout; i++)\n     {\n       int j = inout_opnum[i];\n+      char buffer[16];\n \n       ASM_OPERANDS_INPUT (body, ninputs - ninout + i)\n \t= output_rtx[j];\n+\n+      sprintf (buffer, \"%d\", j);\n       ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, ninputs - ninout + i)\n-\t= gen_rtx_ASM_INPUT (inout_mode[i], digit_string (j));\n+\t= gen_rtx_ASM_INPUT (inout_mode[i], ggc_alloc_string (buffer, -1));\n     }\n \n   generating_concat_p = old_generating_concat_p;\n \n   /* Now, for each output, construct an rtx\n-     (set OUTPUT (asm_operands INSN OUTPUTNUMBER OUTPUTCONSTRAINT\n-\t\t\t       ARGVEC CONSTRAINTS))\n+     (set OUTPUT (asm_operands INSN OUTPUTCONSTRAINT OUTPUTNUMBER\n+\t\t\t       ARGVEC CONSTRAINTS OPNAMES))\n      If there is more than one, put them inside a PARALLEL.  */\n \n   if (noutputs == 1 && nclobbers == 0)\n     {\n-      ASM_OPERANDS_OUTPUT_CONSTRAINT (body)\n-\t= output_constraints[0];\n+      ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = constraints[0];\n       insn = emit_insn (gen_rtx_SET (VOIDmode, output_rtx[0], body));\n     }\n \n@@ -1916,8 +1884,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t\t\t   gen_rtx_ASM_OPERANDS\n \t\t\t   (GET_MODE (output_rtx[i]),\n \t\t\t    TREE_STRING_POINTER (string),\n-\t\t\t    output_constraints[i],\n-\t\t\t    i, argvec, constraints,\n+\t\t\t    constraints[i], i, argvec, constraintvec,\n \t\t\t    filename, line));\n \n \t  MEM_VOLATILE_P (SET_SRC (XVECEXP (body, 0, i))) = vol;\n@@ -1971,6 +1938,206 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   free_temp_slots ();\n }\n+\n+/* A subroutine of expand_asm_operands.  Check that all operands have\n+   the same number of alternatives.  Return true if so.  */\n+\n+static bool\n+check_operand_nalternatives (outputs, inputs)\n+     tree outputs, inputs;\n+{\n+  if (outputs || inputs)\n+    {\n+      tree tmp = TREE_PURPOSE (outputs ? outputs : inputs);\n+      int nalternatives\n+\t= n_occurrences (',', TREE_STRING_POINTER (TREE_VALUE (tmp)));\n+      tree next = inputs;\n+\n+      if (nalternatives + 1 > MAX_RECOG_ALTERNATIVES)\n+\t{\n+\t  error (\"too many alternatives in `asm'\");\n+\t  return false;\n+\t}\n+\n+      tmp = outputs;\n+      while (tmp)\n+\t{\n+\t  const char *constraint\n+\t    = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tmp)));\n+\n+\t  if (n_occurrences (',', constraint) != nalternatives)\n+\t    {\n+\t      error (\"operand constraints for `asm' differ in number of alternatives\");\n+\t      return false;\n+\t    }\n+\n+\t  if (TREE_CHAIN (tmp))\n+\t    tmp = TREE_CHAIN (tmp);\n+\t  else\n+\t    tmp = next, next = 0;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* A subroutine of expand_asm_operands.  Check that all operand names\n+   are unique.  Return true if so.  We rely on the fact that these names\n+   are identifiers, and so have been canonicalized by get_identifier,\n+   so all we need are pointer comparisons.  */\n+\n+static bool\n+check_unique_operand_names (outputs, inputs)\n+     tree outputs, inputs;\n+{\n+  tree i, j;\n+\n+  for (i = outputs; i ; i = TREE_CHAIN (i))\n+    {\n+      tree i_name = TREE_PURPOSE (TREE_PURPOSE (i));\n+      if (! i_name)\n+\tcontinue;\n+\n+      for (j = TREE_CHAIN (i); j ; j = TREE_CHAIN (j))\n+\tif (i_name == TREE_PURPOSE (TREE_PURPOSE (j)))\n+\t  goto failure;\n+    }\n+\n+  for (i = inputs; i ; i = TREE_CHAIN (i))\n+    {\n+      tree i_name = TREE_PURPOSE (TREE_PURPOSE (i));\n+      if (! i_name)\n+\tcontinue;\n+\n+      for (j = TREE_CHAIN (i); j ; j = TREE_CHAIN (j))\n+\tif (i_name == TREE_PURPOSE (TREE_PURPOSE (j)))\n+\t  goto failure;\n+      for (j = outputs; j ; j = TREE_CHAIN (j))\n+\tif (i_name == TREE_PURPOSE (TREE_PURPOSE (j)))\n+\t  goto failure;\n+    }\n+\n+  return true;\n+\n+ failure:\n+  error (\"duplicate asm operand name '%s'\",\n+\t IDENTIFIER_POINTER (TREE_PURPOSE (TREE_PURPOSE (i))));\n+  return false;\n+}\n+\n+/* A subroutine of expand_asm_operands.  Resolve the names of the operands\n+   in *POUTPUTS and *PINPUTS to numbers, and replace the name expansions in\n+   STRING and in the constraints to those numbers.  */\n+\n+static tree\n+resolve_operand_names (string, outputs, inputs, pconstraints)\n+     tree string;\n+     tree outputs, inputs;\n+     const char **pconstraints;\n+{\n+  char *buffer = xstrdup (TREE_STRING_POINTER (string));\n+  char *p;\n+  tree t;\n+\n+  /* Assume that we will not need extra space to perform the substitution.\n+     This because we get to remove '[' and ']', which means we cannot have\n+     a problem until we have more than 999 operands.  */\n+\n+  p = buffer;\n+  while ((p = strchr (p, '%')) != NULL)\n+    {\n+      if (*++p != '[')\n+\tcontinue;\n+      p = resolve_operand_name_1 (p, outputs, inputs);\n+    }\n+\n+  string = build_string (strlen (buffer), buffer);\n+  free (buffer);\n+\n+  /* Collect output constraints here because it's convenient.\n+     There should be no named operands here; this is verified\n+     in expand_asm_operand.  */\n+  for (t = outputs; t ; t = TREE_CHAIN (t), pconstraints++)\n+    *pconstraints = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+\n+  /* Substitute [<name>] in input constraint strings.  */\n+  for (t = inputs; t ; t = TREE_CHAIN (t), pconstraints++)\n+    {\n+      const char *c = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+      if (strchr (c, '[') == NULL)\n+\t*pconstraints = c;\n+      else\n+\t{\n+\t  p = buffer = xstrdup (c);\n+\t  while ((p = strchr (p, '[')) != NULL)\n+\t    p = resolve_operand_name_1 (p, outputs, inputs);\n+\n+\t  *pconstraints = ggc_alloc_string (buffer, -1);\n+\t  free (buffer);\n+\t}\n+    }\n+\n+  return string;\n+}\n+\n+/* A subroutine of resolve_operand_names.  P points to the '[' for a\n+   potential named operand of the form [<name>].  In place, replace\n+   the name and brackets with a number.  Return a pointer to the \n+   balance of the string after substitution.  */\n+\n+static char *\n+resolve_operand_name_1 (p, outputs, inputs)\n+     char *p;\n+     tree outputs, inputs;\n+{\n+  char *q;\n+  int op;\n+  tree t;\n+  size_t len;\n+\n+  /* Collect the operand name.  */\n+  q = strchr (p, ']');\n+  if (!q)\n+    {\n+      error (\"missing close brace for named operand\");\n+      return strchr (p, '\\0');\n+    }\n+  len = q - p - 1;\n+\n+  /* Resolve the name to a number.  */\n+  for (op = 0, t = outputs; t ; t = TREE_CHAIN (t), op++)\n+    {\n+      const char *c = IDENTIFIER_POINTER (TREE_PURPOSE (TREE_PURPOSE (t)));\n+      if (strncmp (c, p + 1, len) == 0 && c[len] == '\\0')\n+\tgoto found;\n+    }\n+  for (t = inputs; t ; t = TREE_CHAIN (t), op++)\n+    {\n+      const char *c = IDENTIFIER_POINTER (TREE_PURPOSE (TREE_PURPOSE (t)));\n+      if (strncmp (c, p + 1, len) == 0 && c[len] == '\\0')\n+\tgoto found;\n+    }\n+\n+  *q = '\\0';\n+  error (\"undefined named operand '%s'\", p + 1);\n+  op = 0;\n+ found:\n+\n+  /* Replace the name with the number.  Unfortunately, not all libraries\n+     get the return value of sprintf correct, so search for the end of the\n+     generated string by hand.  */\n+  sprintf (p, \"%d\", op);\n+  p = strchr (p, '\\0');\n+\n+  /* Verify the no extra buffer space assumption.  */\n+  if (p > q)\n+    abort ();\n+\n+  /* Shift the rest of the buffer down to fill the gap.  */\n+  memmove (p, q + 1, strlen (q + 1) + 1);\n+\n+  return p;\n+}\n \f\n /* Generate RTL to evaluate the expression EXP\n    and remember it in case this is the VALUE in a ({... VALUE; }) constr.  */"}]}