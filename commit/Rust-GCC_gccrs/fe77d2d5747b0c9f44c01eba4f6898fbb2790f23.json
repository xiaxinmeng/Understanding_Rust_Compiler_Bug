{"sha": "fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "node_id": "C_kwDOANBUbNoAKGZlNzdkMmQ1NzQ3YjBjOWY0NGMwMWViYTRmNjg5OGZiYjI3OTBmMjM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-20T16:47:17Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-22T10:48:42Z"}, "message": "Fix ICE when trying to resolve associated type from type bounds\n\nWhen we have a generic function with specified type bounds this allows rust\ncode to actually then look up the relevant bounds for associated types,\nfunctions or constants. This means at code generation the relevant\nassociated mappings msut be setup such that we compile to the\nimplementaiton if available or the default implementation if possible.\n\nThe bug here was that the resolution for associated types were auto setting\nup the associated type mappings even when the receiver was generic. So for\nexample:\n\n```rust\npub trait Foo {\n    type A;\n\n    fn bar(self) -> Self::A;\n}\n\nstruct S(i32);\nimpl Foo for S {\n    type A = i32;\n\n    fn bar(self) -> Self::A {\n        self.0\n    }\n}\n\nfn test_bar<T: Foo>(x: T) -> T::A {\n    x.bar()\n}\n```\n\nThe generic function of test_bar was auto resolving the T::A to A=i32 since\nit found the type-bound Foo was specified and the only implementation of\nFoo is on S. This is usually the correct flow to auto setup these mappings\nbut in the conjtext of a generic receiver this needs to still result in\na Placeholder type of the bound Foo to type check correctly.\n\nFixes: #744 #741", "tree": {"sha": "be68921b507eb448d0573d9071e1daf628653214", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be68921b507eb448d0573d9071e1daf628653214"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86ec0383d45b3339edd0583452d8bc3a0a3cddca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ec0383d45b3339edd0583452d8bc3a0a3cddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ec0383d45b3339edd0583452d8bc3a0a3cddca"}], "stats": {"total": 151, "additions": 145, "deletions": 6}, "files": [{"sha": "d2b5f5b5c78ad492b16d773206cfa2508202fa8e", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "patch": "@@ -276,7 +276,16 @@ class PathProbeType : public TypeCheckBase\n \n \tTyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n \n-\tif (impl != nullptr)\n+\t// we cannot auto setup associated type mappings when our receiver is a\n+\t// generic type bound\n+\tconst TyTy::BaseType *root = receiver->get_root ();\n+\tbool receiver_is_type_param\n+\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n+\n+\tif (impl != nullptr && !receiver_is_generic)\n+\n \t  {\n \t    HirId impl_block_id = impl->get_mappings ().get_hirid ();\n \t    AssociatedImplTrait *lookup_associated = nullptr;"}, {"sha": "ed21d5391bb074d13f15cfa89b0b95808ce94b02", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "patch": "@@ -445,7 +445,7 @@ TypeCheckType::resolve_segments (\n \n \t  // lookup the associated-impl-trait\n \t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n-\t  if (impl != nullptr)\n+\t  if (impl != nullptr && !reciever_is_generic)\n \t    {\n \t      AssociatedImplTrait *lookup_associated = nullptr;\n \t      bool found_impl_trait = context->lookup_associated_trait_impl ("}, {"sha": "1e7c87e0beb0ecfe1cb9822fbf89224fd5daff47", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "patch": "@@ -331,17 +331,19 @@ StructFieldType::clone () const\n \t\t\t      get_field_type ()->clone ());\n }\n \n-void\n+bool\n SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n {\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n   if (type.get_kind () == TyTy::TypeKind::INFER)\n     {\n       type.inherit_bounds (*param);\n     }\n   else\n     {\n       if (!param->bounds_compatible (type, locus, true))\n-\treturn;\n+\treturn false;\n     }\n \n   if (type.get_kind () == TypeKind::PARAM)\n@@ -351,8 +353,52 @@ SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n     }\n   else\n     {\n+      // check the substitution is compatible with bounds\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+\n+      // setup any associated type mappings for the specified bonds and this\n+      // type\n+      auto candidates = Resolver::TypeBoundsProbe::Probe (&type);\n+      for (auto &specified_bound : param->get_specified_bounds ())\n+\t{\n+\t  const Resolver::TraitReference *specified_bound_ref\n+\t    = specified_bound.get ();\n+\n+\t  // since the bounds_compatible check has occurred we should be able to\n+\t  // assert on finding the trait references\n+\t  HirId associated_impl_block_id = UNKNOWN_HIRID;\n+\t  bool found = false;\n+\t  for (auto &bound : candidates)\n+\t    {\n+\t      const Resolver::TraitReference *bound_trait_ref = bound.first;\n+\t      const HIR::ImplBlock *associated_impl = bound.second;\n+\n+\t      found = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t      if (found)\n+\t\t{\n+\t\t  rust_assert (associated_impl != nullptr);\n+\t\t  associated_impl_block_id\n+\t\t    = associated_impl->get_mappings ().get_hirid ();\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (found && associated_impl_block_id != UNKNOWN_HIRID)\n+\t    {\n+\t      Resolver::AssociatedImplTrait *lookup_associated = nullptr;\n+\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\tassociated_impl_block_id, &lookup_associated);\n+\n+\t      if (found_impl_trait)\n+\t\tlookup_associated->setup_associated_types ();\n+\t    }\n+\t}\n+\n       param->set_ty_ref (type.get_ref ());\n     }\n+\n+  return true;\n }\n \n void"}, {"sha": "f6a279737d1cb29c6c90fc3b2d0de81e4610af1f", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "patch": "@@ -626,7 +626,7 @@ class SubstitutionParamMapping\n \n   std::string as_string () const { return param->as_string (); }\n \n-  void fill_param_ty (BaseType &type, Location locus);\n+  bool fill_param_ty (BaseType &type, Location locus);\n \n   SubstitutionParamMapping clone () const\n   {\n@@ -1812,7 +1812,9 @@ class PlaceholderType : public BaseType\n \n   bool contains_type_parameters () const override\n   {\n-    rust_assert (can_resolve ());\n+    if (!can_resolve ())\n+      return false;\n+\n     return resolve ()->contains_type_parameters ();\n   }\n "}, {"sha": "54023d291febc1023b9ed84fd7ea27291b95fbe5", "filename": "gcc/testsuite/rust/execute/torture/trait6.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait6.rs?ref=fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+pub trait Foo {\n+    type A;\n+\n+    fn bar(self) -> Self::A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct S(i32);\n+impl Foo for S {\n+    type A = i32;\n+\n+    fn bar(self) -> Self::A {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn test_bar<T: Foo>(x: T) -> T::A {\n+    x.bar()\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = S(123);\n+\n+    let bar: i32 = test_bar::<S>(a);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, bar);\n+    }\n+\n+    0\n+}"}, {"sha": "059ba15b69d621f42796eb5651b96dee5aa09483", "filename": "gcc/testsuite/rust/execute/torture/trait7.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77d2d5747b0c9f44c01eba4f6898fbb2790f23/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait7.rs?ref=fe77d2d5747b0c9f44c01eba4f6898fbb2790f23", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+pub trait Foo {\n+    type A;\n+\n+    fn bar(self) -> Self::A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct S(i32);\n+impl Foo for S {\n+    type A = i32;\n+\n+    fn bar(self) -> Self::A {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn test_bar<T: Foo>(x: T) -> T::A {\n+    x.bar()\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = S(123);\n+\n+    let bar: i32 = test_bar(a);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, bar);\n+    }\n+\n+    0\n+}"}]}