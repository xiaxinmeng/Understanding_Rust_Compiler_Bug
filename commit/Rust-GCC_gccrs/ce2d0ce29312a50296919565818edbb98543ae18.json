{"sha": "ce2d0ce29312a50296919565818edbb98543ae18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UyZDBjZTI5MzEyYTUwMjk2OTE5NTY1ODE4ZWRiYjk4NTQzYWUxOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-11T14:24:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-11T14:24:28Z"}, "message": "Remove superfluous call to Base_Type\n\ngcc/ada/ChangeLog:\n\t* gcc-interface/gigi.h: Remove ^L characters throughout.\n\t* gcc-interface/decl.c: Likewise.\n\t* gcc-interface/utils.c: Likewise.\n\t* gcc-interface/utils2.c: Likewise.\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Allocator>: Do not explicitly\n\tgo to the base type for the Has_Constrained_Partial_View flag.", "tree": {"sha": "ef5dc21faa268e8f472fa3ee601c4ba2ddd7f316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef5dc21faa268e8f472fa3ee601c4ba2ddd7f316"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce2d0ce29312a50296919565818edbb98543ae18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2d0ce29312a50296919565818edbb98543ae18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce2d0ce29312a50296919565818edbb98543ae18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2d0ce29312a50296919565818edbb98543ae18/comments", "author": null, "committer": null, "parents": [{"sha": "4e1a215870a4194c9ca884ef838103c094aa38c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e1a215870a4194c9ca884ef838103c094aa38c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e1a215870a4194c9ca884ef838103c094aa38c8"}], "stats": {"total": 204, "additions": 101, "deletions": 103}, "files": [{"sha": "fa17ad9453f3524142028fa90f3d93f3618d1aeb", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ce2d0ce29312a50296919565818edbb98543ae18", "patch": "@@ -261,7 +261,7 @@ typedef struct {\n } intrin_binding_t;\n \n static bool intrin_profiles_compatible_p (intrin_binding_t *);\n-\f\n+\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, return the equivalent GCC tree for that entity (a ..._DECL node)\n    and associate the ..._DECL node with the input GNAT defining identifier.\n@@ -6578,7 +6578,7 @@ update_n_elem (tree n_elem, tree min, tree max)\n \n   return n_elem;\n }\n-\f\n+\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n \n@@ -6635,7 +6635,7 @@ elaborate_entity (Entity_Id gnat_entity)\n \n     }\n }\n-\f\n+\n /* Prepend to ATTR_LIST an entry for an attribute with provided TYPE,\n    NAME, ARGS and ERROR_POINT.  */\n \n@@ -6750,7 +6750,7 @@ prepend_attributes (struct attrib **attr_list, Entity_Id gnat_entity)\n     if (Nkind (gnat_temp) == N_Pragma)\n       prepend_one_attribute_pragma (attr_list, gnat_temp);\n }\n-\f\n+\n /* Given a GNAT tree GNAT_EXPR, for an expression which is a value within a\n    type definition (either a bound or a discriminant value) for GNAT_ENTITY,\n    return the GCC tree to use for that expression.  S is the suffix to use\n@@ -6957,7 +6957,7 @@ elaborate_reference (tree ref, Entity_Id gnat_entity, bool definition,\n   struct er_data er = { gnat_entity, definition, 0 };\n   return gnat_rewrite_reference (ref, elaborate_reference_1, &er, init);\n }\n-\f\n+\n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */\n \n@@ -7054,7 +7054,7 @@ choices_to_gnu (tree gnu_operand, Node_Id gnat_choices)\n \n   return gnu_result;\n }\n-\f\n+\n /* Adjust PACKED setting as passed to gnat_to_gnu_field for a field of\n    type FIELD_TYPE to be placed in RECORD_TYPE.  Return the result.  */\n \n@@ -7467,7 +7467,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \n   return gnu_field;\n }\n-\f\n+\n /* Return true if at least one member of COMPONENT_LIST needs strict\n    alignment.  */\n \n@@ -8433,7 +8433,7 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \n   return (gnu_rep_list && !p_gnu_rep_list) || variants_have_rep;\n }\n-\f\n+\n /* Given GNU_SIZE, a GCC tree representing a size, return a Uint to be\n    placed into an Esize, Component_Bit_Offset, or Component_Size value\n    in the GNAT tree.  */\n@@ -8801,7 +8801,7 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \t  }\n       }\n }\n-\f\n+\n /* Scan all fields in GNU_TYPE and return a TREE_LIST where TREE_PURPOSE is\n    the FIELD_DECL and TREE_VALUE a TREE_VEC containing the byte position, the\n    value to be placed into DECL_OFFSET_ALIGN and the bit position.  The list\n@@ -8959,7 +8959,7 @@ build_variant_list (tree gnu_qual_union_type, Node_Id gnat_variant_part,\n \n   return gnu_list;\n }\n-\f\n+\n /* If SIZE has overflowed, return the maximum valid size, which is the upper\n    bound of the signed sizetype in bits, rounded down to ALIGN.  Otherwise\n    return SIZE unmodified.  */\n@@ -9103,7 +9103,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n \n   return size;\n }\n-\f\n+\n /* Similarly, but both validate and process a value of RM size.  This routine\n    is only called for types.  */\n \n@@ -9180,7 +9180,7 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n \t   && !TYPE_FAT_POINTER_P (gnu_type))\n     SET_TYPE_ADA_SIZE (gnu_type, size);\n }\n-\f\n+\n /* ALIGNMENT is a Uint giving the alignment specified for GNAT_ENTITY,\n    a type or object whose present alignment is ALIGN.  If this alignment is\n    valid, return it.  Otherwise, give an error and return ALIGN.  */\n@@ -9273,7 +9273,7 @@ validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n \n   return align;\n }\n-\f\n+\n /* Promote the alignment of GNU_TYPE corresponding to GNAT_ENTITY.  Return\n    a positive value on success or zero on failure.  */\n \n@@ -9320,7 +9320,7 @@ promote_object_alignment (tree gnu_type, Entity_Id gnat_entity)\n \n   return align;\n }\n-\f\n+\n /* Verify that TYPE is something we can implement atomically.  If not, issue\n    an error for GNAT_ENTITY.  COMPONENT_P is true if we are being called to\n    process a component type.  */\n@@ -9388,7 +9388,7 @@ check_ok_for_atomic_type (tree type, Entity_Id gnat_entity, bool component_p)\n     post_error_ne (\"atomic access to & cannot be guaranteed\",\n \t\t   gnat_error_point, gnat_entity);\n }\n-\f\n+\n \n /* Helper for the intrin compatibility checks family.  Evaluate whether\n    two types are definitely incompatible.  */\n@@ -9543,7 +9543,7 @@ intrin_profiles_compatible_p (intrin_binding_t * inb)\n \n   return return_compatible_p && arglists_compatible_p;\n }\n-\f\n+\n /* Return a FIELD_DECL node modeled on OLD_FIELD.  FIELD_TYPE is its type\n    and RECORD_TYPE is the type of the parent.  If SIZE is nonzero, it is the\n    specified size for this field.  POS_LIST is a position list describing\n@@ -10157,7 +10157,7 @@ associate_original_type_to_packed_array (tree gnu_type, Entity_Id gnat_entity)\n       return NULL_TREE;\n     }\n }\n-\f\n+\n /* Given a type T, a FIELD_DECL F, and a replacement value R, return an\n    equivalent type with adjusted size expressions where all occurrences\n    of references to F in a PLACEHOLDER_EXPR have been replaced by R.\n@@ -10318,7 +10318,7 @@ substitute_in_type (tree t, tree f, tree r)\n       return t;\n     }\n }\n-\f\n+\n /* Return the RM size of GNU_TYPE.  This is the actual number of bits\n    needed to represent the object.  */\n \n@@ -10347,7 +10347,7 @@ rm_size (tree gnu_type)\n   /* For other types, this is just the size.  */\n   return TYPE_SIZE (gnu_type);\n }\n-\f\n+\n /* Return the name to be used for GNAT_ENTITY.  If a type, create a\n    fully-qualified name, possibly with type information encoding.\n    Otherwise, return the name.  */"}, {"sha": "328e5f3a119ac42c7a20b16b07580b516d5157bc", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=ce2d0ce29312a50296919565818edbb98543ae18", "patch": "@@ -325,7 +325,7 @@ extern int double_scalar_alignment;\n \n /* True if floating-point arithmetics may use wider intermediate results.  */\n extern bool fp_arith_may_widen;\n-\f\n+\n /* Data structures used to represent attributes.  */\n \n enum attrib_type"}, {"sha": "4bd9c8dafcaf5d63a898d85c938bab902310737f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ce2d0ce29312a50296919565818edbb98543ae18", "patch": "@@ -255,7 +255,7 @@ static bool maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk);\n    of configurations.  */\n static const char *extract_encoding (const char *) ATTRIBUTE_UNUSED;\n static const char *decode_name (const char *) ATTRIBUTE_UNUSED;\n-\f\n+\n /* This makes gigi's file_info_ptr visible in this translation unit,\n    so that Sloc_to_locus can look it up when deciding whether to map\n    decls to instances.  */\n@@ -735,7 +735,7 @@ gigi (Node_Id gnat_root,\n   /* We cannot track the location of errors past this point.  */\n   Current_Error_Node = Empty;\n }\n-\f\n+\n /* Return a subprogram decl corresponding to __gnat_rcheck_xx for the given\n    CHECK if KIND is EXCEPTION_SIMPLE, or else to __gnat_rcheck_xx_ext.  */\n \n@@ -779,7 +779,7 @@ build_raise_check (int check, enum exception_info_kind kind)\n \n   return result;\n }\n-\f\n+\n /* Return a positive value if an lvalue is required for GNAT_NODE, which is\n    an N_Attribute_Reference.  */\n \n@@ -1599,7 +1599,7 @@ Pragma_to_gnu (Node_Id gnat_node)\n \n   return gnu_result;\n }\n-\f\n+\n /* Check the inline status of nested function FNDECL wrt its parent function.\n \n    If a non-inline nested function is referenced from an inline external\n@@ -1645,7 +1645,7 @@ check_inlining_for_nested_subprog (tree fndecl)\n       DECL_UNINLINABLE (parent_decl) = 1;\n     }\n }\n-\f\n+\n /* Return an expression for the length of TYPE, an integral type, computed in\n    RESULT_TYPE, another integral type.\n \n@@ -2590,7 +2590,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n   *gnu_result_type_p = gnu_result_type;\n   return gnu_result;\n }\n-\f\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Case_Statement,\n    to a GCC tree, which is returned.  */\n \n@@ -2715,7 +2715,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \n   return gnu_result;\n }\n-\f\n+\n /* Return true if we are in the body of a loop.  */\n \n static inline bool\n@@ -3328,7 +3328,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n   return gnu_result;\n }\n-\f\n+\n /* This page implements a form of Named Return Value optimization modeled\n    on the C++ optimization of the same name.  The main difference is that\n    we disregard any semantical considerations when applying it here, the\n@@ -3820,7 +3820,7 @@ build_return_expr (tree ret_obj, tree ret_val)\n \n   return build1 (RETURN_EXPR, void_type_node, result_expr);\n }\n-\f\n+\n /* Subroutine of gnat_to_gnu to process gnat_node, an N_Subprogram_Body.  We\n    don't return anything.  */\n \n@@ -4144,7 +4144,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   else\n     rest_of_subprog_body_compilation (gnu_subprog_decl);\n }\n-\f\n+\n /* The type of an atomic access.  */\n \n typedef enum { NOT_ATOMIC, SIMPLE_ATOMIC, OUTER_ATOMIC } atomic_acces_t;\n@@ -4334,8 +4334,8 @@ get_atomic_access (Node_Id gnat_node, atomic_acces_t *type, bool *sync)\n   *type = NOT_ATOMIC;\n   *sync = false;\n }\n-\f\n-\f/* Return true if GNAT_NODE requires simple atomic access and, if so, set SYNC\n+\n+/* Return true if GNAT_NODE requires simple atomic access and, if so, set SYNC\n    according to the associated synchronization setting.  */\n \n static inline bool\n@@ -5205,7 +5205,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \n   return gnu_result;\n }\n-\f\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an\n    N_Handled_Sequence_Of_Statements, to a GCC tree, which is returned.  */\n \n@@ -5444,7 +5444,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \n   return gnu_result;\n }\n-\f\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Exception_Handler,\n    to a GCC tree, which is returned.  This is the variant for front-end sjlj\n    exception handling.  */\n@@ -5513,7 +5513,7 @@ Exception_Handler_to_gnu_fe_sjlj (Node_Id gnat_node)\n \n   return build3 (COND_EXPR, void_type_node, gnu_choice, gnu_body, NULL_TREE);\n }\n-\f\n+\n /* Return true if no statement in GNAT_LIST can alter the control flow.  */\n \n static bool\n@@ -5720,7 +5720,7 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n   return\n     build2 (CATCH_EXPR, void_type_node, gnu_etypes_list, end_stmt_group ());\n }\n-\f\n+\n /* Subroutine of gnat_to_gnu to generate code for an N_Compilation unit.  */\n \n static void\n@@ -5850,7 +5850,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   /* Force the processing for all nodes that remain in the queue.  */\n   process_deferred_decl_context (true);\n }\n-\f\n+\n /* Mark COND, a boolean expression, as predicating a call to a noreturn\n    function, i.e. predict that it is very likely false, and return it.\n \n@@ -6064,7 +6064,7 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \n   return gnu_result;\n }\n-\f\n+\n /* Return true if GNAT_NODE is on the LHS of an assignment or an actual\n    parameter of a call.  */\n \n@@ -7159,9 +7159,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    const Entity_Id gnat_desig_type\n \t      = Designated_Type (Underlying_Type (Etype (gnat_node)));\n \n-\t    /* The flag is effectively only set on the base types.  */\n-\t    ignore_init_type\n-\t      = Has_Constrained_Partial_View (Base_Type (gnat_desig_type));\n+\t    ignore_init_type = Has_Constrained_Partial_View (gnat_desig_type);\n \n \t    gnu_init = gnat_to_gnu (Expression (gnat_temp));\n \t    gnu_init = maybe_unconstrained_array (gnu_init);\n@@ -8331,7 +8329,7 @@ gnat_to_gnu_external (Node_Id gnat_node)\n \n   return gnu_result;\n }\n-\f\n+\n /* Return true if the statement list STMT_LIST is empty.  */\n \n static bool\n@@ -8375,7 +8373,7 @@ insert_code_for (Node_Id gnat_node)\n \n   save_gnu_tree (gnat_node, NULL_TREE, true);\n }\n-\f\n+\n /* Start a new statement group chained to the previous group.  */\n \n void\n@@ -8647,7 +8645,7 @@ build_stmt_group (List_Id gnat_list, bool binding_p)\n \n   return end_stmt_group ();\n }\n-\f\n+\n /* Generate GIMPLE in place for the expression at *EXPR_P.  */\n \n int\n@@ -8896,7 +8894,7 @@ gnat_gimplify_stmt (tree *stmt_p)\n       gcc_unreachable ();\n     }\n }\n-\f\n+\n /* Force a reference to each of the entities in GNAT_PACKAGE recursively.\n \n    This routine is exclusively called in type_annotate mode, to compute DDA\n@@ -9022,7 +9020,7 @@ elaborate_all_entities (Node_Id gnat_node)\n   if (Nkind (Unit (gnat_node)) == N_Package_Body)\n     elaborate_all_entities (Library_Unit (gnat_node));\n }\n-\f\n+\n /* Do the processing of GNAT_NODE, an N_Freeze_Entity.  */\n \n static void\n@@ -9162,7 +9160,7 @@ process_freeze_entity (Node_Id gnat_node)\n \tused_types_insert (TREE_TYPE (gnu_new));\n     }\n }\n-\f\n+\n /* Elaborate decls in the lists GNAT_DECLS and GNAT_DECLS2, if present.\n    We make two passes, one to elaborate anything other than bodies (but\n    we declare a function if there was no spec).  The second pass\n@@ -9297,7 +9295,7 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t      add_stmt (gnat_to_gnu (gnat_decl));\n \t  }\n }\n-\f\n+\n /* Make a unary operation of kind CODE using build_unary_op, but guard\n    the operation by an overflow check.  CODE can be one of NEGATE_EXPR\n    or ABS_EXPR.  GNU_TYPE is the type desired for the result.  Usually\n@@ -9545,7 +9543,7 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason, Node_Id gnat_node)\n \t\t\t : build_int_cst (TREE_TYPE (gnu_expr), 0)),\n \t\t gnu_expr);\n }\n-\f\n+\n /* Return an expression that converts GNU_EXPR to GNAT_TYPE, doing overflow\n    checks if OVERFLOW_P is true.  If TRUNCATE_P is true, do a fp-to-integer\n    conversion with truncation, otherwise round.  GNAT_NODE is the GNAT node\n@@ -9730,7 +9728,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflow_p,\n \n   return convert (gnu_type, gnu_result);\n }\n-\f\n+\n /* Return true if GNU_EXPR can be directly addressed.  This is the case\n    unless it is an expression involving computation or if it involves a\n    reference to a bitfield or to an object not sufficiently aligned for\n@@ -9908,7 +9906,7 @@ addressable_p (tree gnu_expr, tree gnu_type)\n       return false;\n     }\n }\n-\f\n+\n /* Do the processing for the declaration of a GNAT_ENTITY, a type or subtype.\n    If a Freeze node exists for the entity, delay the bulk of the processing.\n    Otherwise make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n@@ -9992,7 +9990,7 @@ process_type (Entity_Id gnat_entity)\n \t\t\t TREE_TYPE (gnu_new));\n     }\n }\n-\f\n+\n /* Subroutine of assoc_to_constructor: VALUES is a list of field associations,\n    some of which are from RECORD_TYPE.  Return a CONSTRUCTOR consisting of the\n    associations that are from RECORD_TYPE.  If we see an internal record, make\n@@ -10146,7 +10144,7 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type)\n \n   return gnat_build_constructor (gnu_array_type, gnu_expr_vec);\n }\n-\f\n+\n /* Process a N_Validate_Unchecked_Conversion node.  */\n \n static void\n@@ -10205,7 +10203,7 @@ validate_unchecked_conversion (Node_Id gnat_node)\n \t}\n     }\n }\n-\f\n+\n /* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a\n    source code location and false if it doesn't.  If CLEAR_COLUMN is\n    true, set the column information to 0.  If DECL is given and SLOC\n@@ -10387,7 +10385,7 @@ set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)\n       return false;\n     }\n }\n-\f\n+\n /* Return a colon-separated list of encodings contained in encoded Ada\n    name.  */\n \n@@ -10408,7 +10406,7 @@ decode_name (const char *name)\n   __gnat_decode (name, decoded, 0);\n   return decoded;\n }\n-\f\n+\n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n    '&' substitution.  */"}, {"sha": "013fccdd65793776e48df6fb48a5003c86c6b6cf", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ce2d0ce29312a50296919565818edbb98543ae18", "patch": "@@ -357,7 +357,7 @@ add_deferred_decl_context (tree decl, Entity_Id gnat_scope, int force_global);\n    computed.  */\n static void add_deferred_type_context (struct deferred_decl_context_node *n,\n \t\t\t\t       tree type);\n-\f\n+\n /* Initialize data structures of the utils.c module.  */\n \n void\n@@ -397,7 +397,7 @@ destroy_gnat_utils (void)\n   pad_type_hash_table->empty ();\n   pad_type_hash_table = NULL;\n }\n-\f\n+\n /* GNAT_ENTITY is a GNAT tree node for an entity.  Associate GNU_DECL, a GCC\n    tree node, with GNAT_ENTITY.  If GNU_DECL is not a ..._DECL node, abort.\n    If NO_CHECK is true, the latter check is suppressed.\n@@ -438,7 +438,7 @@ present_gnu_tree (Entity_Id gnat_entity)\n {\n   return PRESENT_GNU_TREE (gnat_entity);\n }\n-\f\n+\n /* Make a dummy type corresponding to GNAT_TYPE.  */\n \n tree\n@@ -533,7 +533,7 @@ build_dummy_unc_pointer_types (Entity_Id gnat_desig_type, tree gnu_desig_type)\n   TYPE_REFERENCE_TO (gnu_desig_type) = gnu_fat_type;\n   TYPE_OBJECT_RECORD_TYPE (gnu_desig_type) = gnu_object_type;\n }\n-\f\n+\n /* Return true if we are in the global binding level.  */\n \n bool\n@@ -663,7 +663,7 @@ gnat_zaplevel (void)\n   level->chain = free_binding_level;\n   free_binding_level = level;\n }\n-\f\n+\n /* Set the context of TYPE and its parallel types (if any) to CONTEXT.  */\n \n static void\n@@ -935,7 +935,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t    }\n     }\n }\n-\f\n+\n /* Create a record type that contains a SIZE bytes long field of TYPE with a\n    starting bit position so that it is aligned to ALIGN bits, and leaving at\n    least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n@@ -1772,7 +1772,7 @@ set_reverse_storage_order_on_pad_type (tree type)\n   TYPE_REVERSE_STORAGE_ORDER (type) = 1;\n   return canonicalize_pad_type (type);\n }\n-\f\n+\n /* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP.\n    If this is a multi-dimensional array type, do this recursively.\n \n@@ -1847,7 +1847,7 @@ relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n \n   record_component_aliases (gnu_new_type);\n }\n-\f\n+\n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.\n    ARTIFICIAL_P is true if the type was generated by the compiler.  */\n \n@@ -1863,7 +1863,7 @@ record_builtin_type (const char *name, tree type, bool artificial_p)\n   if (debug_hooks->type_decl)\n     debug_hooks->type_decl (type_decl, false);\n }\n-\f\n+\n /* Finish constructing the character type CHAR_TYPE.\n \n   In Ada character types are enumeration types and, as a consequence, are\n@@ -2558,7 +2558,7 @@ split_plus (tree in, tree *pvar)\n   else\n     return bitsize_zero_node;\n }\n-\f\n+\n /* Return a copy of TYPE but safe to modify in any way.  */\n \n tree\n@@ -2595,7 +2595,7 @@ copy_type (tree type)\n \n   return new_type;\n }\n-\f\n+\n /* Return a subtype of sizetype with range MIN to MAX and whose\n    TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position\n    of the associated TYPE_DECL.  */\n@@ -2634,8 +2634,8 @@ create_range_type (tree type, tree min, tree max)\n \n   return range_type;\n }\n-\f\n-\f/* Return an extra subtype of TYPE with range MIN to MAX.  */\n+\n+/* Return an extra subtype of TYPE with range MIN to MAX.  */\n \n tree\n create_extra_subtype (tree type, tree min, tree max)\n@@ -2652,7 +2652,7 @@ create_extra_subtype (tree type, tree min, tree max)\n \n   return subtype;\n }\n-\f\n+\n /* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of TYPE.\n    NAME gives the name of the type to be used in the declaration.  */\n \n@@ -2718,7 +2718,7 @@ create_type_decl (tree name, tree type, bool artificial_p, bool debug_info_p,\n \n   return type_decl;\n }\n-\f\n+\n /* Return a VAR_DECL or CONST_DECL node.\n \n    NAME gives the name of the variable.  ASM_NAME is its assembler name\n@@ -2886,7 +2886,7 @@ create_var_decl (tree name, tree asm_name, tree type, tree init,\n \n   return var_decl;\n }\n-\f\n+\n /* Return true if TYPE, an aggregate type, contains (or is) an array.\n    If SELF_REFERENTIAL is true, then an additional requirement on the\n    array is that it be self-referential.  */\n@@ -3097,7 +3097,7 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n \n   return field_decl;\n }\n-\f\n+\n /* Return a PARM_DECL node with NAME and TYPE.  */\n \n tree\n@@ -3131,7 +3131,7 @@ create_param_decl (tree name, tree type)\n   DECL_ARG_TYPE (param_decl) = type;\n   return param_decl;\n }\n-\f\n+\n /* Process the attributes in ATTR_LIST for NODE, which is either a DECL or\n    a TYPE.  If IN_PLACE is true, the tree pointed to by NODE should not be\n    changed.  GNAT_NODE is used for the position of error messages.  */\n@@ -3420,7 +3420,7 @@ create_label_decl (tree name, Node_Id gnat_node)\n \n   return label_decl;\n }\n-\f\n+\n /* Return a FUNCTION_DECL node.  NAME is the name of the subprogram, ASM_NAME\n    its assembler name, TYPE its type (a FUNCTION_TYPE or METHOD_TYPE node),\n    PARAM_DECL_LIST the list of its parameters (a list of PARM_DECL nodes\n@@ -3558,7 +3558,7 @@ finish_subprog_decl (tree decl, tree asm_name, tree type)\n \tDECL_NAME (decl) = main_identifier_node;\n     }\n }\n-\f\n+\n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n    body.  This routine needs to be invoked before processing the declarations\n    appearing in the subprogram.  */\n@@ -3830,7 +3830,7 @@ fntype_same_flags_p (const_tree t, tree cico_list, bool return_unconstrained_p,\n \t && TYPE_RETURN_BY_DIRECT_REF_P (t) == return_by_direct_ref_p\n \t && TREE_ADDRESSABLE (t) == return_by_invisi_ref_p;\n }\n-\f\n+\n /* EXP is an expression for the size of an object.  If this size contains\n    discriminant references, replace them with the maximum (if MAX_P) or\n    minimum (if !MAX_P) possible value of the discriminant.\n@@ -4042,7 +4042,7 @@ max_size (tree exp, bool max_p)\n \n   gcc_unreachable ();\n }\n-\f\n+\n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n    EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs.\n    Return a constructor for the template.  */\n@@ -4108,7 +4108,7 @@ build_template (tree template_type, tree array_type, tree expr)\n \n   return gnat_build_constructor (template_type, template_elts);\n }\n-\f\n+\n /* Return true if TYPE is suitable for the element type of a vector.  */\n \n static bool\n@@ -4198,7 +4198,7 @@ build_vector_type_for_array (tree array_type, tree attribute)\n   TYPE_REPRESENTATIVE_ARRAY (vector_type) = array_type;\n   return vector_type;\n }\n-\f\n+\n /* Build a type to be used to represent an aliased object whose nominal type\n    is an unconstrained array.  This consists of a RECORD_TYPE containing a\n    field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an ARRAY_TYPE.\n@@ -4248,7 +4248,7 @@ build_unc_object_type_from_ptr (tree thin_fat_ptr_type, tree object_type,\n   return\n     build_unc_object_type (template_type, object_type, name, debug_info_p);\n }\n-\f\n+\n /* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.\n    In the normal case this is just two adjustments, but we have more to\n    do if NEW_TYPE is an UNCONSTRAINED_ARRAY_TYPE.  */\n@@ -4379,7 +4379,7 @@ update_pointer_to (tree old_type, tree new_type)\n       TYPE_REFERENCE_TO (old_type) = NULL_TREE;\n     }\n }\n-\f\n+\n /* Convert EXPR, a pointer to a constrained array, into a pointer to an\n    unconstrained one.  This involves making or finding a template.  */\n \n@@ -4483,7 +4483,7 @@ convert_to_fat_pointer (tree type, tree expr)\n   CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)), template_addr);\n   return gnat_build_constructor (type, v);\n }\n-\f\n+\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n@@ -5170,7 +5170,7 @@ convert_to_index_type (tree expr)\n \n   return convert (sizetype, expr);\n }\n-\f\n+\n /* Remove all conversions that are done in EXP.  This includes converting\n    from a padded type or to a justified modular type.  If TRUE_ADDRESS\n    is true, always return the address of the containing object even if\n@@ -5205,7 +5205,7 @@ remove_conversions (tree exp, bool true_address)\n \n   return exp;\n }\n-\f\n+\n /* If EXP's type is an UNCONSTRAINED_ARRAY_TYPE, return an expression that\n    refers to the underlying array.  If it has TYPE_CONTAINS_TEMPLATE_P,\n    likewise return an expression pointing to the underlying array.  */\n@@ -5293,7 +5293,7 @@ maybe_unconstrained_array (tree exp)\n \n   return exp;\n }\n-\f\n+\n /* Return true if EXPR is an expression that can be folded as an operand\n    of a VIEW_CONVERT_EXPR.  See ada-tree.h for a complete rationale.  */\n \n@@ -5687,7 +5687,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \n   return expr;\n }\n-\f\n+\n /* Return the appropriate GCC tree code for the specified GNAT_TYPE,\n    the latter being a record type as predicated by Is_Record_Type.  */\n "}, {"sha": "316033bdf60edfa1cb09fcf99dff235ffd50e109", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2d0ce29312a50296919565818edbb98543ae18/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ce2d0ce29312a50296919565818edbb98543ae18", "patch": "@@ -73,7 +73,7 @@ get_base_type (tree type)\n \n   return type;\n }\n-\f\n+\n /* EXP is a GCC tree representing an address.  See if we can find how strictly\n    the object at this address is aligned and, if so, return the alignment of\n    the object in bits.  Otherwise return 0.  */\n@@ -203,7 +203,7 @@ known_alignment (tree exp)\n \n   return this_alignment;\n }\n-\f\n+\n /* We have a comparison or assignment operation on two types, T1 and T2, which\n    are either both array types or both record types.  T1 is assumed to be for\n    the left hand side operand, and T2 for the right hand side.  Return the\n@@ -271,7 +271,7 @@ find_common_type (tree t1, tree t2)\n      could cause a bad self-referential reference.  */\n   return NULL_TREE;\n }\n-\f\n+\n /* Return an expression tree representing an equality comparison of A1 and A2,\n    two objects of type ARRAY_TYPE.  The result should be of type RESULT_TYPE.\n \n@@ -533,7 +533,7 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n \t\t\t  build_binary_op (TRUTH_ORIF_EXPR, result_type,\n \t\t\t\t\t   p1_array_is_null, same_bounds));\n }\n-\f\n+\n /* Compute the result of applying OP_CODE to LHS and RHS, where both are of\n    type TYPE.  We know that TYPE is a modular type with a nonbinary\n    modulus.  */\n@@ -629,7 +629,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n \n   return convert (type, result);\n }\n-\f\n+\n /* This page contains routines that implement the Ada semantics with regard\n    to atomic objects.  They are fully piggybacked on the middle-end support\n    for atomic loads and stores.\n@@ -828,7 +828,7 @@ build_load_modify_store (tree dest, tree src, Node_Id gnat_node)\n   /* Something went wrong earlier if we have not found the atomic load.  */\n   gcc_unreachable ();\n }\n-\f\n+\n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n    in that type.  For INIT_EXPR and MODIFY_EXPR, RESULT_TYPE must be\n@@ -1323,7 +1323,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n   return result;\n }\n-\f\n+\n /* Similar, but for unary operations.  */\n \n tree\n@@ -1683,7 +1683,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n   return result;\n }\n-\f\n+\n /* Similar, but for COND_EXPR.  */\n \n tree\n@@ -1758,7 +1758,7 @@ build_compound_expr (tree result_type, tree stmt_operand, tree expr_operand)\n \n   return result;\n }\n-\f\n+\n /* Conveniently construct a function call expression.  FNDECL names the\n    function to be called, N is the number of arguments, and the \"...\"\n    parameters are the argument expressions.  Unlike build_call_expr\n@@ -1776,7 +1776,7 @@ build_call_n_expr (tree fndecl, int n, ...)\n   va_end (ap);\n   return fn;\n }\n-\f\n+\n /* Build a goto to LABEL for a raise, with an optional call to Local_Raise.\n    MSG gives the exception's identity for the call to Local_Raise, if any.  */\n \n@@ -1924,7 +1924,7 @@ build_call_raise_range (int msg, Node_Id gnat_node, char kind,\n \t\t       convert (integer_type_node, first),\n \t\t       convert (integer_type_node, last));\n }\n-\f\n+\n /* qsort comparer for the bit positions of two constructor elements\n    for record components.  */\n \n@@ -1987,7 +1987,7 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n   TREE_READONLY (result) = TYPE_READONLY (type) || read_only || allconstant;\n   return result;\n }\n-\f\n+\n /* Return a COMPONENT_REF to access FIELD in RECORD, or NULL_TREE if the field\n    is not found in the record.  Don't fold the result if NO_FOLD is true.  */\n \n@@ -2113,7 +2113,7 @@ build_component_ref (tree record, tree field, bool no_fold)\n \t\t build_call_raise (CE_Discriminant_Check_Failed, Empty,\n \t\t\t\t   N_Raise_Constraint_Error));\n }\n-\f\n+\n /* Helper for build_call_alloc_dealloc, with arguments to be interpreted\n    identically.  Process the case where a GNAT_PROC to call is provided.  */\n \n@@ -2326,7 +2326,7 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, tree gnu_type,\n       return maybe_wrap_malloc (gnu_size, gnu_type, gnat_node);\n     }\n }\n-\f\n+\n /* Build a GCC tree that corresponds to allocating an object of TYPE whose\n    initial value is INIT, if INIT is nonzero.  Convert the expression to\n    RESULT_TYPE, which must be some pointer type, and return the result.\n@@ -2457,7 +2457,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n   return storage;\n }\n-\f\n+\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Return true if successful.  */\n \n@@ -2505,7 +2505,7 @@ gnat_mark_addressable (tree t)\n \treturn true;\n     }\n }\n-\f\n+\n /* Return true if EXP is a stable expression for the purpose of the functions\n    below and, therefore, can be returned unmodified by them.  We accept things\n    that are actual constants or that have already been handled.  */"}]}