{"sha": "5bb650ec1bfb9da5eef4e2da6348c42d916d247b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJiNjUwZWMxYmZiOWRhNWVlZjRlMmRhNjM0OGM0MmQ5MTZkMjQ3Yg==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-16T02:36:48Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-16T02:36:48Z"}, "message": "builtins.c (fold_builtin_memcpy, [...]): New functions.\n\n\n\t* builtins.c (fold_builtin_memcpy, fold_builtin_mempcpy,\n\tfold_builtin_memmove, fold_builtin_strcpy, fold_builtin_strncpy,\n\tfold_builtin_memcmp, fold_builtin_strcmp, fold_builtin_strncmp):\n\tNew functions.\n\t(expand_builtin_memcpy): Use integer_zerop instead of testing\n\thost_integerp and tree_low_cst directly.  Move misapplied hunk\n\tfor optimization wher SRC and DEST point to the same location.\n\t(expand_builtin_mempcpy): From here.\n\t(expand_builtin_memmove): Use integer_zerop instead of testing\n\thost_integerp and tree_low_cst_directly.\n\t(expand_builtin_memset): Likewise.\n\t(expand_builtin_memcmp): Likewise (and for integer_onep).\n\t(expand_builtin_strncmp): Likewise.\n\t(fold_builtin): Call the appropriate fold_builtin_foo functions\n\tto optimize memcpy, mempcpy, memmove, strcpy, strncpy, memcmp,\n\tstrcmp and strncmp.\n\nFrom-SVN: r72547", "tree": {"sha": "aca9996b3b9dc6d84bc947bea56b72d53bfd3e27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aca9996b3b9dc6d84bc947bea56b72d53bfd3e27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bb650ec1bfb9da5eef4e2da6348c42d916d247b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb650ec1bfb9da5eef4e2da6348c42d916d247b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb650ec1bfb9da5eef4e2da6348c42d916d247b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb650ec1bfb9da5eef4e2da6348c42d916d247b/comments", "author": null, "committer": null, "parents": [{"sha": "8725a9b49935c912618060e0762e2ff534973fc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8725a9b49935c912618060e0762e2ff534973fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8725a9b49935c912618060e0762e2ff534973fc8"}], "stats": {"total": 337, "additions": 321, "deletions": 16}, "files": [{"sha": "ba69f6518e5fc8397d5624ff9dbb3acdd28f01b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb650ec1bfb9da5eef4e2da6348c42d916d247b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb650ec1bfb9da5eef4e2da6348c42d916d247b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5bb650ec1bfb9da5eef4e2da6348c42d916d247b", "patch": "@@ -1,3 +1,22 @@\n+2003-10-15  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (fold_builtin_memcpy, fold_builtin_mempcpy,\n+\tfold_builtin_memmove, fold_builtin_strcpy, fold_builtin_strncpy,\n+\tfold_builtin_memcmp, fold_builtin_strcmp, fold_builtin_strncmp):\n+\tNew functions.\n+\t(expand_builtin_memcpy): Use integer_zerop instead of testing\n+\thost_integerp and tree_low_cst directly.  Move misapplied hunk\n+\tfor optimization wher SRC and DEST point to the same location.\n+\t(expand_builtin_mempcpy): From here.\n+\t(expand_builtin_memmove): Use integer_zerop instead of testing\n+\thost_integerp and tree_low_cst_directly.\n+\t(expand_builtin_memset): Likewise.\n+\t(expand_builtin_memcmp): Likewise (and for integer_onep).\n+\t(expand_builtin_strncmp): Likewise.\n+\t(fold_builtin): Call the appropriate fold_builtin_foo functions\n+\tto optimize memcpy, mempcpy, memmove, strcpy, strncpy, memcmp,\n+\tstrcmp and strncmp.\n+\n 2003-10-15  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/darwin-protos.h (machopic_non_lazy_ptr_name): Delete\n@@ -11,8 +30,8 @@\n \t\n 2003-10-15  G\ufffdbor L\ufffdki  <alga@rgai.hu>\n \n-\t* fold-const.c (tree_swap_operands_p): disables\n-\tsome features when optimizing for size.\n+\t* fold-const.c (tree_swap_operands_p): Disable some features\n+\twhen optimizing for size.\n \n 2003-10-15  David Daney  <ddaney@avtrex.com>\n "}, {"sha": "39156ebb62e70cbed462bff0dc813c116a35e7f1", "filename": "gcc/builtins.c", "status": "modified", "additions": 300, "deletions": 14, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb650ec1bfb9da5eef4e2da6348c42d916d247b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb650ec1bfb9da5eef4e2da6348c42d916d247b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5bb650ec1bfb9da5eef4e2da6348c42d916d247b", "patch": "@@ -157,6 +157,14 @@ static tree fold_builtin_trunc (tree);\n static tree fold_builtin_floor (tree);\n static tree fold_builtin_ceil (tree);\n static tree fold_builtin_bitop (tree);\n+static tree fold_builtin_memcpy (tree);\n+static tree fold_builtin_mempcpy (tree);\n+static tree fold_builtin_memmove (tree);\n+static tree fold_builtin_strcpy (tree);\n+static tree fold_builtin_strncpy (tree);\n+static tree fold_builtin_memcmp (tree);\n+static tree fold_builtin_strcmp (tree);\n+static tree fold_builtin_strncmp (tree);\n \n /* Return the alignment in bits of EXP, a pointer valued expression.\n    But don't return more than MAX_ALIGN no matter what.\n@@ -2474,13 +2482,21 @@ expand_builtin_memcpy (tree arglist, rtx target, enum machine_mode mode)\n \treturn 0;\n \n       /* If the LEN parameter is zero, return DEST.  */\n-      if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+      if (integer_zerop (len))\n \t{\n \t  /* Evaluate and ignore SRC in case it has side-effects.  */\n \t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n \t}\n \n+      /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+      if (operand_equal_p (src, dest, 0))\n+\t{\n+\t  /* Evaluate and ignore LEN in case it has side-effects.  */\n+\t  expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t}\n+\n       /* If either SRC is not a pointer type, don't do this\n          operation in-line.  */\n       if (src_align == 0)\n@@ -2597,14 +2613,6 @@ expand_builtin_mempcpy (tree arglist, rtx target, enum machine_mode mode,\n \t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n \t}\n \n-      /* If SRC and DEST are the same (and not volatile), return DEST.  */\n-      if (operand_equal_p (src, dest, 0))\n-\t{\n-\t  /* Evaluate and ignore LEN in case it has side-effects.  */\n-\t  expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n-\t}\n-\n       /* If either SRC is not a pointer type, don't do this\n          operation in-line.  */\n       if (src_align == 0)\n@@ -2675,7 +2683,7 @@ expand_builtin_memmove (tree arglist, rtx target, enum machine_mode mode)\n \treturn 0;\n \n       /* If the LEN parameter is zero, return DEST.  */\n-      if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+      if (integer_zerop (len))\n \t{\n \t  /* Evaluate and ignore SRC in case it has side-effects.  */\n \t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -2975,7 +2983,7 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode)\n \treturn 0;\n \n       /* If the LEN parameter is zero, return DEST.  */\n-      if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+      if (integer_zerop (len))\n \t{\n \t  /* Evaluate and ignore VAL in case it has side-effects.  */\n \t  expand_expr (val, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -3098,7 +3106,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n   len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n \n   /* If the len parameter is zero, return zero.  */\n-  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+  if (integer_zerop (len))\n     {\n       /* Evaluate and ignore arg1 and arg2 in case they have\n          side-effects.  */\n@@ -3131,7 +3139,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n \n   /* If len parameter is one, return an expression corresponding to\n      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n-  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 1)\n+  if (integer_onep (len))\n     {\n       tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n       tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n@@ -3392,7 +3400,7 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n   arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n \n   /* If the len parameter is zero, return zero.  */\n-  if (host_integerp (arg3, 1) && tree_low_cst (arg3, 1) == 0)\n+  if (integer_zerop (arg3))\n     {\n       /* Evaluate and ignore arg1 and arg2 in case they have\n \t side-effects.  */\n@@ -6190,6 +6198,260 @@ fold_builtin_exponent (tree exp, const REAL_VALUE_TYPE *value)\n   return 0;\n }\n \n+/* Fold function call to builtin memcpy.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_memcpy (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree dest, src, len;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the LEN parameter is zero, return DEST.  */\n+  if (integer_zerop (len))\n+    return omit_one_operand (TREE_TYPE (exp), dest, src);\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+  if (operand_equal_p (src, dest, 0))\n+    return omit_one_operand (TREE_TYPE (exp), dest, len);\n+\n+  return 0;\n+}\n+\n+/* Fold function call to builtin mempcpy.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_mempcpy (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree dest, src, len;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the LEN parameter is zero, return DEST.  */\n+  if (integer_zerop (len))\n+    return omit_one_operand (TREE_TYPE (exp), dest, src);\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST+LEN.  */\n+  if (operand_equal_p (src, dest, 0))\n+    {\n+      tree temp = convert (TREE_TYPE (dest), len);\n+      temp = fold (build (PLUS_EXPR, TREE_TYPE (dest), dest, len));\n+      return convert (TREE_TYPE (exp), temp);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Fold function call to builtin memmove.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_memmove (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree dest, src, len;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the LEN parameter is zero, return DEST.  */\n+  if (integer_zerop (len))\n+    return omit_one_operand (TREE_TYPE (exp), dest, src);\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+  if (operand_equal_p (src, dest, 0))\n+    return omit_one_operand (TREE_TYPE (exp), dest, len);\n+\n+  return 0;\n+}\n+\n+/* Fold function call to builtin strcpy.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_strcpy (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree dest, src;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+  if (operand_equal_p (src, dest, 0))\n+    return convert (TREE_TYPE (exp), dest);\n+\n+  return 0;\n+}\n+\n+/* Fold function call to builtin strncpy.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_strncpy (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree dest, src, len;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the LEN parameter is zero, return DEST.  */\n+  if (integer_zerop (len))\n+    return omit_one_operand (TREE_TYPE (exp), dest, src);\n+\n+  return 0;\n+}\n+\n+/* Fold function call to builtin memcmp.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_memcmp (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg1, arg2, len;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the LEN parameter is zero, return zero.  */\n+  if (integer_zerop (len))\n+    {\n+      tree temp = omit_one_operand (TREE_TYPE (exp), integer_zero_node, arg2);\n+      return omit_one_operand (TREE_TYPE (exp), temp, arg1);\n+    }\n+\n+  /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    return omit_one_operand (TREE_TYPE (exp), integer_zero_node, len);\n+\n+  return 0;\n+}\n+\n+/* Fold function call to builtin strcmp.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_strcmp (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg1, arg2;\n+  const char *p1, *p2;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    return convert (TREE_TYPE (exp), integer_zero_node);\n+\n+  p1 = c_getstr (arg1);\n+  p2 = c_getstr (arg2);\n+\n+  if (p1 && p2)\n+    {\n+      tree temp;\n+      const int i = strcmp (p1, p2);\n+      if (i < 0)\n+\ttemp = integer_minus_one_node;\n+      else if (i > 0)\n+\ttemp = integer_one_node;\n+      else\n+\ttemp = integer_zero_node;\n+      return convert (TREE_TYPE (exp), temp);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Fold function call to builtin strncmp.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_strncmp (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg1, arg2, len;\n+  const char *p1, *p2;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the LEN parameter is zero, return zero.  */\n+  if (integer_zerop (len))\n+    {\n+      tree temp = omit_one_operand (TREE_TYPE (exp), integer_zero_node, arg2);\n+      return omit_one_operand (TREE_TYPE (exp), temp, arg1);\n+    }\n+\n+  /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    return omit_one_operand (TREE_TYPE (exp), integer_zero_node, len);\n+\n+  p1 = c_getstr (arg1);\n+  p2 = c_getstr (arg2);\n+\n+  if (host_integerp (len, 1) && p1 && p2)\n+    {\n+      tree temp;\n+      const int i = strncmp (p1, p2, tree_low_cst (len, 1));\n+      if (i < 0)\n+\ttemp = integer_minus_one_node;\n+      else if (i > 0)\n+\ttemp = integer_one_node;\n+      else\n+\ttemp = integer_zero_node;\n+      return convert (TREE_TYPE (exp), temp);\n+    }\n+\n+  return 0;\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -6585,6 +6847,30 @@ fold_builtin (tree exp)\n     case BUILT_IN_PARITYLL:\n       return fold_builtin_bitop (exp);\n \n+    case BUILT_IN_MEMCPY:\n+      return fold_builtin_memcpy (exp);\n+\n+    case BUILT_IN_MEMPCPY:\n+      return fold_builtin_mempcpy (exp);\n+\n+    case BUILT_IN_MEMMOVE:\n+      return fold_builtin_memmove (exp);\n+\n+    case BUILT_IN_STRCPY:\n+      return fold_builtin_strcpy (exp);\n+\n+    case BUILT_IN_STRNCPY:\n+      return fold_builtin_strncpy (exp);\n+\n+    case BUILT_IN_MEMCMP:\n+      return fold_builtin_memcmp (exp);\n+\n+    case BUILT_IN_STRCMP:\n+      return fold_builtin_strcmp (exp);\n+\n+    case BUILT_IN_STRNCMP:\n+      return fold_builtin_strncmp (exp);\n+\n     default:\n       break;\n     }"}]}