{"sha": "eb471ba379597d73fcd79986cca5b8351a32770a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI0NzFiYTM3OTU5N2Q3M2ZjZDc5OTg2Y2NhNWI4MzUxYTMyNzcwYQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2018-10-01T12:56:40Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2018-10-01T12:56:40Z"}, "message": "Add support for SVE stack clash probing.\n\nThis patch adds basic support for SVE stack clash protection.\nIt is a first implementation and will use a loop to do the\nprobing and stack adjustments.\n\nAn example sequence is:\n\n        .cfi_startproc\n        mov     x15, sp\n        cntb    x16, all, mul #11\n        add     x16, x16, 304\n        .cfi_def_cfa_register 15\n.SVLPSPL0:\n        cmp     x16, 61440\n        b.lt    .SVLPEND0\n        sub     sp, sp, 61440\n        str     xzr, [sp, 0]\n        sub     x16, x16, 61440\n        b      .SVLPSPL0\n.SVLPEND0:\n        sub     sp, sp, x16\n        .cfi_escape 0xf,0xc,0x8f,0,0x92,0x2e,0,0x8,0x58,0x1e,0x23,0xb0,0x2,0x22\n\nfor a 64KB guard size, and for a 4KB guard size\n\n        .cfi_startproc\n        mov     x15, sp\n        cntb    x16, all, mul #11\n        add     x16, x16, 304\n        .cfi_def_cfa_register 15\n.SVLPSPL0:\n        cmp     x16, 3072\n        b.lt    .SVLPEND0\n        sub     sp, sp, 3072\n        str     xzr, [sp, 0]\n        sub     x16, x16, 3072\n        b       .SVLPSPL0\n.SVLPEND0:\n        sub     sp, sp, x16\n        .cfi_escape 0xf,0xc,0x8f,0,0x92,0x2e,0,0x8,0x58,0x1e,0x23,0xb0,0x2,0x22\n\nThis has about the same semantics as alloca, except we prioritize the common case\nwhere no probe is required.  We also change the amount we adjust the stack and\nthe probing interval to be the nearest value to `guard size - abi buffer` that\nfits in the 12-bit shifted immediate used by cmp.\n\nWhile this would mean we probe a bit more often than we require, in practice the\namount of SVE vectors you'd need to spill is significant. Even more so to enter the\nloop more than once.\n\n\ngcc/\n\n\tPR target/86486\n\t* config/aarch64/aarch64-protos.h (aarch64_output_probe_sve_stack_clash): New.\n\t* config/aarch64/aarch64.c (aarch64_output_probe_sve_stack_clash,\n\taarch64_clamp_to_uimm12_shift): New.\n\t(aarch64_allocate_and_probe_stack_space): Add SVE specific section.\n\t* config/aarch64/aarch64.md (probe_sve_stack_clash): New.\n\ngcc/testsuite/\n\n\tPR target/86486\n\t* gcc.target/aarch64/stack-check-prologue-16.c: New test\n\t* gcc.target/aarch64/stack-check-cfa-3.c: New test.\n\t* gcc.target/aarch64/sve/struct_vect_24.c: New test.\n\t* gcc.target/aarch64/sve/struct_vect_24_run.c: New test.\n\nFrom-SVN: r264749", "tree": {"sha": "5da852b0b47fb40568a4116f3ab83b5db8162726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5da852b0b47fb40568a4116f3ab83b5db8162726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb471ba379597d73fcd79986cca5b8351a32770a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb471ba379597d73fcd79986cca5b8351a32770a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb471ba379597d73fcd79986cca5b8351a32770a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb471ba379597d73fcd79986cca5b8351a32770a/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "db6b62a858e578fdb7f9f754f2c4bf868d951fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db6b62a858e578fdb7f9f754f2c4bf868d951fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db6b62a858e578fdb7f9f754f2c4bf868d951fcb"}], "stats": {"total": 322, "additions": 317, "deletions": 5}, "files": [{"sha": "4da1c622752099faa3fda34e65a3373b0b067c5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -1,3 +1,12 @@\n+2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/86486\n+\t* config/aarch64/aarch64-protos.h (aarch64_output_probe_sve_stack_clash): New.\n+\t* config/aarch64/aarch64.c (aarch64_output_probe_sve_stack_clash,\n+\taarch64_clamp_to_uimm12_shift): New.\n+\t(aarch64_allocate_and_probe_stack_space): Add SVE specific section.\n+\t* config/aarch64/aarch64.md (probe_sve_stack_clash): New.\n+\n 2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/86486"}, {"sha": "5f18837418e1c7950ccf74af0be7e3ae7763ee28", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -497,6 +497,7 @@ void aarch64_asm_output_labelref (FILE *, const char *);\n void aarch64_cpu_cpp_builtins (cpp_reader *);\n const char * aarch64_gen_far_branch (rtx *, int, const char *, const char *);\n const char * aarch64_output_probe_stack_range (rtx, rtx);\n+const char * aarch64_output_probe_sve_stack_clash (rtx, rtx, rtx, rtx);\n void aarch64_err_no_fpadvsimd (machine_mode);\n void aarch64_expand_epilogue (bool);\n void aarch64_expand_mov_immediate (rtx, rtx, rtx (*) (rtx, rtx) = 0);"}, {"sha": "1351caa61415918e1fd704dc541dd8489723d7bb", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 150, "deletions": 5, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -166,6 +166,7 @@ static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,\n static machine_mode aarch64_simd_container_mode (scalar_mode, poly_int64);\n static bool aarch64_print_address_internal (FILE*, machine_mode, rtx,\n \t\t\t\t\t    aarch64_addr_query_type);\n+static HOST_WIDE_INT aarch64_clamp_to_uimm12_shift (HOST_WIDE_INT val);\n \n /* Major revision number of the ARM Architecture implemented by the target.  */\n unsigned aarch64_architecture_version;\n@@ -4020,6 +4021,84 @@ aarch64_output_probe_stack_range (rtx reg1, rtx reg2)\n   return \"\";\n }\n \n+/* Emit the probe loop for doing stack clash probes and stack adjustments for\n+   SVE.  This emits probes from BASE to BASE - ADJUSTMENT based on a guard size\n+   of GUARD_SIZE.  When a probe is emitted it is done at most\n+   MIN_PROBE_THRESHOLD bytes from the current BASE at an interval of\n+   at most MIN_PROBE_THRESHOLD.  By the end of this function\n+   BASE = BASE - ADJUSTMENT.  */\n+\n+const char *\n+aarch64_output_probe_sve_stack_clash (rtx base, rtx adjustment,\n+\t\t\t\t      rtx min_probe_threshold, rtx guard_size)\n+{\n+  /* This function is not allowed to use any instruction generation function\n+     like gen_ and friends.  If you do you'll likely ICE during CFG validation,\n+     so instead emit the code you want using output_asm_insn.  */\n+  gcc_assert (flag_stack_clash_protection);\n+  gcc_assert (CONST_INT_P (min_probe_threshold) && CONST_INT_P (guard_size));\n+  gcc_assert (INTVAL (guard_size) > INTVAL (min_probe_threshold));\n+\n+  /* The minimum required allocation before the residual requires probing.  */\n+  HOST_WIDE_INT residual_probe_guard = INTVAL (min_probe_threshold);\n+\n+  /* Clamp the value down to the nearest value that can be used with a cmp.  */\n+  residual_probe_guard = aarch64_clamp_to_uimm12_shift (residual_probe_guard);\n+  rtx probe_offset_value_rtx = gen_int_mode (residual_probe_guard, Pmode);\n+\n+  gcc_assert (INTVAL (min_probe_threshold) >= residual_probe_guard);\n+  gcc_assert (aarch64_uimm12_shift (residual_probe_guard));\n+\n+  static int labelno = 0;\n+  char loop_start_lab[32];\n+  char loop_end_lab[32];\n+  rtx xops[2];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_start_lab, \"SVLPSPL\", labelno);\n+  ASM_GENERATE_INTERNAL_LABEL (loop_end_lab, \"SVLPEND\", labelno++);\n+\n+  /* Emit loop start label.  */\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_start_lab);\n+\n+  /* ADJUSTMENT < RESIDUAL_PROBE_GUARD.  */\n+  xops[0] = adjustment;\n+  xops[1] = probe_offset_value_rtx;\n+  output_asm_insn (\"cmp\\t%0, %1\", xops);\n+\n+  /* Branch to end if not enough adjustment to probe.  */\n+  fputs (\"\\tb.lt\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, loop_end_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  /* BASE = BASE - RESIDUAL_PROBE_GUARD.  */\n+  xops[0] = base;\n+  xops[1] = probe_offset_value_rtx;\n+  output_asm_insn (\"sub\\t%0, %0, %1\", xops);\n+\n+  /* Probe at BASE.  */\n+  xops[1] = const0_rtx;\n+  output_asm_insn (\"str\\txzr, [%0, %1]\", xops);\n+\n+  /* ADJUSTMENT = ADJUSTMENT - RESIDUAL_PROBE_GUARD.  */\n+  xops[0] = adjustment;\n+  xops[1] = probe_offset_value_rtx;\n+  output_asm_insn (\"sub\\t%0, %0, %1\", xops);\n+\n+  /* Branch to start if still more bytes to allocate.  */\n+  fputs (\"\\tb\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, loop_start_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  /* No probe leave.  */\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_end_lab);\n+\n+  /* BASE = BASE - ADJUSTMENT.  */\n+  xops[0] = base;\n+  xops[1] = adjustment;\n+  output_asm_insn (\"sub\\t%0, %0, %1\", xops);\n+  return \"\";\n+}\n+\n /* Determine whether a frame chain needs to be generated.  */\n static bool\n aarch64_needs_frame_chain (void)\n@@ -4877,21 +4956,73 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,\n \t}\n     }\n \n-  HOST_WIDE_INT size;\n   /* If SIZE is not large enough to require probing, just adjust the stack and\n      exit.  */\n-  if (!poly_size.is_constant (&size)\n-      || known_lt (poly_size, min_probe_threshold)\n+  if (known_lt (poly_size, min_probe_threshold)\n       || !flag_stack_clash_protection)\n     {\n       aarch64_sub_sp (temp1, temp2, poly_size, frame_related_p);\n       return;\n     }\n \n+  HOST_WIDE_INT size;\n+  /* Handle the SVE non-constant case first.  */\n+  if (!poly_size.is_constant (&size))\n+    {\n+     if (dump_file)\n+      {\n+\tfprintf (dump_file, \"Stack clash SVE prologue: \");\n+\tprint_dec (poly_size, dump_file);\n+\tfprintf (dump_file, \" bytes, dynamic probing will be required.\\n\");\n+      }\n+\n+      /* First calculate the amount of bytes we're actually spilling.  */\n+      aarch64_add_offset (Pmode, temp1, CONST0_RTX (Pmode),\n+\t\t\t  poly_size, temp1, temp2, false, true);\n+\n+      rtx_insn *insn = get_last_insn ();\n+\n+      if (frame_related_p)\n+\t{\n+\t  /* This is done to provide unwinding information for the stack\n+\t     adjustments we're about to do, however to prevent the optimizers\n+\t     from removing the R15 move and leaving the CFA note (which would be\n+\t     very wrong) we tie the old and new stack pointer together.\n+\t     The tie will expand to nothing but the optimizers will not touch\n+\t     the instruction.  */\n+\t  rtx stack_ptr_copy = gen_rtx_REG (Pmode, R15_REGNUM);\n+\t  emit_move_insn (stack_ptr_copy, stack_pointer_rtx);\n+\t  emit_insn (gen_stack_tie (stack_ptr_copy, stack_pointer_rtx));\n+\n+\t  /* We want the CFA independent of the stack pointer for the\n+\t     duration of the loop.  */\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA, stack_ptr_copy);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      rtx probe_const = gen_int_mode (min_probe_threshold, Pmode);\n+      rtx guard_const = gen_int_mode (guard_size, Pmode);\n+\n+      insn = emit_insn (gen_probe_sve_stack_clash (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t   stack_pointer_rtx, temp1,\n+\t\t\t\t\t\t   probe_const, guard_const));\n+\n+      /* Now reset the CFA register if needed.  */\n+      if (frame_related_p)\n+\t{\n+\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t\tgen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t      gen_int_mode (poly_size, Pmode)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      return;\n+    }\n+\n   if (dump_file)\n     fprintf (dump_file,\n-\t     \"Stack clash AArch64 prologue: \" HOST_WIDE_INT_PRINT_DEC \" bytes\"\n-\t     \", probing will be required.\\n\", size);\n+\t     \"Stack clash AArch64 prologue: \" HOST_WIDE_INT_PRINT_DEC\n+\t     \" bytes, probing will be required.\\n\", size);\n \n   /* Round size to the nearest multiple of guard_size, and calculate the\n      residual as the difference between the original size and the rounded\n@@ -5494,6 +5625,20 @@ aarch64_uimm12_shift (HOST_WIDE_INT val)\n \t  );\n }\n \n+/* Returns the nearest value to VAL that will fit as a 12-bit unsigned immediate\n+   that can be created with a left shift of 0 or 12.  */\n+static HOST_WIDE_INT\n+aarch64_clamp_to_uimm12_shift (HOST_WIDE_INT val)\n+{\n+  /* Check to see if the value fits in 24 bits, as that is the maximum we can\n+     handle correctly.  */\n+  gcc_assert ((val & 0xffffff) == val);\n+\n+  if (((val & 0xfff) << 0) == val)\n+    return val;\n+\n+  return val & (0xfff << 12);\n+}\n \n /* Return true if val is an immediate that can be loaded into a\n    register by a MOVZ instruction.  */"}, {"sha": "b4a4315ff4b3b603299a5718ad5a489a75a8c5c9", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -6514,6 +6514,25 @@\n   [(set_attr \"length\" \"32\")]\n )\n \n+;; This instruction is used to generate the stack clash stack adjustment and\n+;; probing loop.  We can't change the control flow during prologue and epilogue\n+;; code generation.  So we must emit a volatile unspec and expand it later on.\n+\n+(define_insn \"@probe_sve_stack_clash_<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=rk\")\n+\t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"0\")\n+\t\t\t    (match_operand:P 2 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:P 3 \"const_int_operand\" \"n\")\n+\t\t\t    (match_operand:P 4 \"aarch64_plus_immediate\" \"L\")]\n+\t\t\t     UNSPECV_PROBE_STACK_RANGE))]\n+  \"TARGET_SVE\"\n+{\n+  return aarch64_output_probe_sve_stack_clash (operands[0], operands[2],\n+\t\t\t\t\t       operands[3], operands[4]);\n+}\n+  [(set_attr \"length\" \"28\")]\n+)\n+\n ;; Named pattern for expanding thread pointer reference.\n (define_expand \"get_thread_pointerdi\"\n   [(match_operand:DI 0 \"register_operand\" \"=r\")]"}, {"sha": "84c4fa9524572315f58f708a9a2e67cc6352d202", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -1,3 +1,11 @@\n+2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/86486\n+\t* gcc.target/aarch64/stack-check-prologue-16.c: New test\n+\t* gcc.target/aarch64/stack-check-cfa-3.c: New test.\n+\t* gcc.target/aarch64/sve/struct_vect_24.c: New test.\n+\t* gcc.target/aarch64/sve/struct_vect_24_run.c: New test.\n+\n 2018-10-01  Jeff Law  <law@redhat.com>\n \t    Richard Sandiford <richard.sandiford@linaro.org>\n \t    Tamar Christina  <tamar.christina@arm.com>"}, {"sha": "41579f26ba9156f3e500f090d132ba9cf28364d3", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-cfa-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-cfa-3.c?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fopenmp-simd -march=armv8-a+sve -fstack-clash-protection --param stack-clash-protection-guard-size=16 -funwind-tables\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#include \"stack-check-prologue-16.c\"\n+\n+/* Checks that the CFA notes are correct for every sp adjustment, but we also\n+   need to make sure we can unwind correctly before the frame is set up.  So\n+   check that we're emitting r15 with a copy of sp an setting the CFA there.  */\n+\n+/* { dg-final { scan-assembler-times {mov\\tx15, sp} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_register 15} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_escape 0xf,0xc,0x8f,0,0x92,0x2e,0,.*} 1 } } */"}, {"sha": "d92ef47a57ddda556c563e36ad8aaf4acdeabc57", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-prologue-16.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-prologue-16.c?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-options \"-O3 -fopenmp-simd -march=armv8-a+sve -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+\n+/* Invoke X (P##n) for n in [0, 7].  */\n+#define REPEAT8(X, P) \\\n+  X (P##0) X (P##1) X (P##2) X (P##3) X (P##4) X (P##5) X (P##6) X (P##7)\n+\n+/* Invoke X (n) for all octal n in [0, 39].  */\n+#define REPEAT40(X) \\\n+  REPEAT8 (X, 0) REPEAT8 (X, 1)  REPEAT8 (X, 2) REPEAT8 (X, 3) REPEAT8 (X, 4)\n+\n+/* Expect vector work to be done, with spilling of vector registers.  */\n+void\n+f2 (int x[40][100], int *y)\n+{\n+  /* Try to force some spilling.  */\n+#define DECLARE(N) int y##N = y[N];\n+  REPEAT40 (DECLARE);\n+#pragma omp simd\n+  for (int i = 0; i < 100; ++i)\n+    {\n+#define INC(N) x[N][i] += y##N;\n+      REPEAT40 (INC);\n+    }\n+}\n+\n+/* SVE spill, requires probing as vector size is unknown at compile time.  */\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 0\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {cmp\\s+x[0-9]+, 61440} 1 } } */\n+/* { dg-final { scan-assembler-times {sub\\s+x[0-9]+, x[0-9]+, 61440} 1 } } */"}, {"sha": "68a9d5e3d2e74cb331dff0ef3bcd612f8bb0d0f2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_24.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_24.c?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-options \"-O3 -fopenmp-simd -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+\n+#include <stdint.h>\n+\n+#define N 50\n+#define S 2 * 64 * 1024\n+\n+/* Invoke X (P##n) for n in [0, 9].  */\n+#define REPEAT8(X, P) \\\n+  X (P##0) X (P##1) X (P##2) X (P##3) X (P##4) X (P##5) X (P##6) X (P##7) \\\n+  X (P##8)  X (P##9)\n+\n+/* Invoke X (n) for all n in [0, 49].  */\n+#define REPEAT50(X) \\\n+  REPEAT8 (X, ) REPEAT8 (X, 1)  REPEAT8 (X, 2) REPEAT8 (X, 3) REPEAT8 (X, 4)\n+\n+  /* Try to force some spilling.  */\n+#define DECLARE(N) int src##N = src[N * 4];\n+#define INC(N) dest[i] += src##N;\n+\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone, simd))\t\\\n+  NAME (TYPE *restrict dest, TYPE *restrict src)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    REPEAT50 (DECLARE);\t\t\t\t\t\\\n+    volatile char foo[S];\t\t\t\t\\\n+    foo[S-1]=1;\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; i++)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tREPEAT50 (INC);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST(NAME) \\\n+  TEST_LOOP (NAME##_i32, int32_t) \\\n+  TEST_LOOP (NAME##_i64, int64_t) \\\n+  TEST_LOOP (NAME##_f32, float) \\\n+  TEST_LOOP (NAME##_f64, double)\n+\n+TEST (test)\n+\n+/* Check the vectorized loop for stack clash probing.  */\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 0\\]} 4 } } */\n+/* { dg-final { scan-assembler-times {cmp\\s+x[0-9]+, 61440} 4 } } */\n+/* { dg-final { scan-assembler-times {sub\\s+x[0-9]+, x[0-9]+, 61440} 4 } } */"}, {"sha": "e764476faccded380102dfbc759be7cf6be88345", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_24_run.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_24_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb471ba379597d73fcd79986cca5b8351a32770a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_24_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_24_run.c?ref=eb471ba379597d73fcd79986cca5b8351a32770a", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-options \"-O3 -fopenmp-simd -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+\n+#include \"struct_vect_24.c\"\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE out[N];\t\t\t\t\t\\\n+    TYPE in[N * 4];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tout[i] = i * 7 / 2;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 4; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tin[i] = i * 9 / 2;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    NAME (out, in);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tTYPE expected = i * 7 / 2;\t\t\t\\\n+\tif (out[i] != out[0] + expected)\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (0)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}]}