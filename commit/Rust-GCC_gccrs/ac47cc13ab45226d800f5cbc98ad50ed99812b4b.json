{"sha": "ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM0N2NjMTNhYjQ1MjI2ZDgwMGY1Y2JjOThhZDUwZWQ5OTgxMmI0Yg==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2003-11-08T19:03:58Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2003-11-08T19:03:58Z"}, "message": "cls_9byte2.c: New test case.\n\n2003-11-08  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* testsuite/libffi.call/cls_9byte2.c: New test case.\n\t* testsuite/libffi.call/cls_9byte1.c: Likewise.\n\t* testsuite/libffi.call/cls_64byte.c: Likewise.\n\t* testsuite/libffi.call/cls_20byte1.c: Likewise.\n\t* testsuite/libffi.call/cls_19byte.c: Likewise.\n\t* testsuite/libffi.call/cls_18byte.c: Likewise.\n\t* testsuite/libffi.call/closure_fn4.c: Likewise.\n\t* testsuite/libffi.call/closure_fn5.c: Likewise.\n\t* testsuite/libffi.call/cls_schar.c: Likewise.\n\t* testsuite/libffi.call/cls_sint.c: Likewise.\n\t* testsuite/libffi.call/cls_sshort.c: Likewise.\n\t* testsuite/libffi.call/nested_struct2.c: Likewise.\n\t* testsuite/libffi.call/nested_struct3.c: Likewise.\n\nFrom-SVN: r73372", "tree": {"sha": "682efdfedf3163883402516b7bc9d057148191e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/682efdfedf3163883402516b7bc9d057148191e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/comments", "author": null, "committer": null, "parents": [{"sha": "49b8ea5ab0a9cd911a47674f53e81af8ac676b72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b8ea5ab0a9cd911a47674f53e81af8ac676b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49b8ea5ab0a9cd911a47674f53e81af8ac676b72"}], "stats": {"total": 1154, "additions": 1154, "deletions": 0}, "files": [{"sha": "004625db9b93beb0276461ae8e645daa5cab55d8", "filename": "libffi/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -1,3 +1,19 @@\n+2003-11-08  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* testsuite/libffi.call/cls_9byte2.c: New test case.\n+\t* testsuite/libffi.call/cls_9byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_64byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_20byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_19byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_18byte.c: Likewise.\n+\t* testsuite/libffi.call/closure_fn4.c: Likewise.\n+\t* testsuite/libffi.call/closure_fn5.c: Likewise.\n+\t* testsuite/libffi.call/cls_schar.c: Likewise.\n+\t* testsuite/libffi.call/cls_sint.c: Likewise.\n+\t* testsuite/libffi.call/cls_sshort.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct2.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct3.c: Likewise.\n+\n 2003-11-08  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* testsuite/libffi.call/cls_double.c: Do a check on the result."}, {"sha": "2085020b4577f6f151403f2c9d72671212069230", "filename": "libffi/testsuite/libffi.call/closure_fn4.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,87 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck multiple long long values passing.\n+\t\tAlso, exceed the limit of gpr and fpr registers on PowerPC\n+\t\tDarwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20031026\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+\n+#include \"ffitest.h\"\n+\n+static void\n+closure_test_fn0(ffi_cif* cif,void* resp,void** args, void* userdata)\n+{\n+  *(ffi_arg*)resp =\n+    (int)*(unsigned long long *)args[0] + (int)*(unsigned long long *)args[1] +\n+    (int)*(unsigned long long *)args[2] + (int)*(unsigned long long *)args[3] +\n+    (int)*(unsigned long long *)args[4] + (int)*(unsigned long long *)args[5] +\n+    (int)*(unsigned long long *)args[6] + (int)*(unsigned long long *)args[7] +\n+    (int)*(unsigned long long *)args[8] + (int)*(unsigned long long *)args[9] +\n+    (int)*(unsigned long long *)args[10] +\n+    (int)*(unsigned long long *)args[11] +\n+    (int)*(unsigned long long *)args[12] +\n+    (int)*(unsigned long long *)args[13] +\n+    (int)*(unsigned long long *)args[14] +\n+    *(int *)args[15] + (int)(long)userdata;\n+  \n+  printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t (int)*(unsigned long long *)args[0],\n+\t (int)*(unsigned long long *)args[1],\n+\t (int)*(unsigned long long *)args[2],\n+\t (int)*(unsigned long long *)args[3],\n+\t (int)*(unsigned long long *)args[4],\n+\t (int)*(unsigned long long *)args[5],\n+\t (int)*(unsigned long long *)args[6],\n+\t (int)*(unsigned long long *)args[7],\n+\t (int)*(unsigned long long *)args[8],\n+\t (int)*(unsigned long long *)args[9],\n+\t (int)*(unsigned long long *)args[10],\n+\t (int)*(unsigned long long *)args[11],\n+\t (int)*(unsigned long long *)args[12],\n+\t (int)*(unsigned long long *)args[13],\n+\t (int)*(unsigned long long *)args[14],\n+\t *(int *)args[15],\n+\t (int)(long)userdata, (int)*(ffi_arg *)resp);\n+  \n+}\n+\n+typedef int (*closure_test_type0)(unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, int);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[17];\n+  int i, res;\n+  \n+  for (i = 0; i < 15; i++) {\n+    cl_arg_types[i] = &ffi_type_uint64;\n+  }\n+  cl_arg_types[15] = &ffi_type_uint;\n+  cl_arg_types[16] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,\n+\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  \n+  res = (*((closure_test_type0)pcl))\n+    (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11LL, 12LL,\n+     13LL, 19LL, 21LL, 1);\n+  /* { dg-output \"1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680\" } */\n+  CHECK(res == 680);\n+  \n+  exit(0);\n+}"}, {"sha": "c99dc81c17eb2064c12b5260e241a27a70de549b", "filename": "libffi/testsuite/libffi.call/closure_fn5.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,90 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck multiple long long values passing.\n+\t\tExceed the limit of gpr registers on PowerPC\n+\t\tDarwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20031026\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+\n+#include \"ffitest.h\"\n+\n+static void\n+closure_test_fn5(ffi_cif* cif,void* resp,void** args, void* userdata)\n+{\n+  *(ffi_arg*)resp =\n+    (int)*(unsigned long long *)args[0] + (int)*(unsigned long long *)args[1] +\n+    (int)*(unsigned long long *)args[2] + (int)*(unsigned long long *)args[3] +\n+    (int)*(unsigned long long *)args[4] + (int)*(unsigned long long *)args[5] +\n+    (int)*(unsigned long long *)args[6] + (int)*(unsigned long long *)args[7] +\n+    (int)*(unsigned long long *)args[8] + (int)*(unsigned long long *)args[9] +\n+    (int)*(int *)args[10] +\n+    (int)*(unsigned long long *)args[11] +\n+    (int)*(unsigned long long *)args[12] +\n+    (int)*(unsigned long long *)args[13] +\n+    (int)*(unsigned long long *)args[14] +\n+    *(int *)args[15] + (int)(long)userdata;\n+  \n+  printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t (int)*(unsigned long long *)args[0],\n+\t (int)*(unsigned long long *)args[1],\n+\t (int)*(unsigned long long *)args[2],\n+\t (int)*(unsigned long long *)args[3],\n+\t (int)*(unsigned long long *)args[4],\n+\t (int)*(unsigned long long *)args[5],\n+\t (int)*(unsigned long long *)args[6],\n+\t (int)*(unsigned long long *)args[7],\n+\t (int)*(unsigned long long *)args[8],\n+\t (int)*(unsigned long long *)args[9],\n+\t (int)*(int *)args[10],\n+\t (int)*(unsigned long long *)args[11],\n+\t (int)*(unsigned long long *)args[12],\n+\t (int)*(unsigned long long *)args[13],\n+\t (int)*(unsigned long long *)args[14],\n+\t *(int *)args[15],\n+\t (int)(long)userdata, (int)*(ffi_arg *)resp);\n+  \n+}\n+\n+typedef int (*closure_test_type0)(unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  int, unsigned long long,\n+\t\t\t\t  unsigned long long, unsigned long long,\n+\t\t\t\t  unsigned long long, int);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[17];\n+  int i, res;\n+\n+  for (i = 0; i < 10; i++) {\n+    cl_arg_types[i] = &ffi_type_uint64;\n+  }\n+  cl_arg_types[10] = &ffi_type_uint;\n+  for (i = 11; i < 15; i++) {\n+    cl_arg_types[i] = &ffi_type_uint64;\n+  }\n+  cl_arg_types[15] = &ffi_type_uint;\n+  cl_arg_types[16] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn5,\n+\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  \n+  res = (*((closure_test_type0)pcl))\n+    (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11, 12LL,\n+     13LL, 19LL, 21LL, 1);\n+  /* { dg-output \"1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680\" } */\n+  CHECK(res == 680);\n+  exit(0);\n+}"}, {"sha": "3e4ae5a86c92ce4345f29c07e254a2e6407a76a0", "filename": "libffi/testsuite/libffi.call/cls_18byte.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,99 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Double alignment check on darwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030915\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_18byte {\n+  double a;\n+  unsigned char b;\n+  unsigned char c;\n+  double d;\n+} cls_struct_18byte;\n+\n+cls_struct_18byte cls_struct_18byte_fn(struct cls_struct_18byte a1,\n+\t\t\t    struct cls_struct_18byte a2)\n+{\n+  struct cls_struct_18byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+\n+\n+  printf(\"%g %d %d %g %g %d %d %g: %g %d %d %g\\n\", a1.a, a1.b, a1.c, a1.d,\n+\t a2.a, a2.b, a2.c, a2.d,\n+\t result.a, result.b, result.c, result.d);\n+  return result;\n+}\n+\n+static void\n+cls_struct_18byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+  struct cls_struct_18byte a1, a2;\n+\n+  a1 = *(struct cls_struct_18byte*)(args[0]);\n+  a2 = *(struct cls_struct_18byte*)(args[1]);\n+\n+  *(cls_struct_18byte*)resp = cls_struct_18byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[5];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[3];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_18byte g_dbl = { 1.0, 127, 126, 3.0 };\n+  struct cls_struct_18byte f_dbl = { 4.0, 125, 124, 5.0 };\n+  struct cls_struct_18byte res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_double;\n+  cls_struct_fields[4] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_18byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 127 126 3 4 125 124 5: 5 252 250 8\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_18byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_18byte(*)(cls_struct_18byte, cls_struct_18byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n1 127 126 3 4 125 124 5: 5 252 250 8\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  exit(0);\n+}"}, {"sha": "fafaad031e183ed663a976ea87e95f9a7fdec378", "filename": "libffi/testsuite/libffi.call/cls_19byte.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,105 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Double alignment check on darwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030915\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_19byte {\n+  double a;\n+  unsigned char b;\n+  unsigned char c;\n+  double d;\n+  unsigned char e;\n+} cls_struct_19byte;\n+\n+cls_struct_19byte cls_struct_19byte_fn(struct cls_struct_19byte a1,\n+\t\t\t    struct cls_struct_19byte a2)\n+{\n+  struct cls_struct_19byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+  result.e = a1.e + a2.e;\n+\n+\n+  printf(\"%g %d %d %g %d %g %d %d %g %d: %g %d %d %g %d\\n\",\n+\t a1.a, a1.b, a1.c, a1.d, a1.e,\n+\t a2.a, a2.b, a2.c, a2.d, a2.e,\n+\t result.a, result.b, result.c, result.d, result.e);\n+  return result;\n+}\n+\n+static void\n+cls_struct_19byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+  struct cls_struct_19byte a1, a2;\n+\n+  a1 = *(struct cls_struct_19byte*)(args[0]);\n+  a2 = *(struct cls_struct_19byte*)(args[1]);\n+\n+  *(cls_struct_19byte*)resp = cls_struct_19byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[6];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[3];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_19byte g_dbl = { 1.0, 127, 126, 3.0, 120 };\n+  struct cls_struct_19byte f_dbl = { 4.0, 125, 124, 5.0, 119 };\n+  struct cls_struct_19byte res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_double;\n+  cls_struct_fields[4] = &ffi_type_uchar;\n+  cls_struct_fields[5] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_19byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 127 126 3 120 4 125 124 5 119: 5 252 250 8 239\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+  CHECK( res_dbl.e == (g_dbl.e + f_dbl.e));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_19byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_19byte(*)(cls_struct_19byte, cls_struct_19byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n1 127 126 3 120 4 125 124 5 119: 5 252 250 8 239\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+  CHECK( res_dbl.e == (g_dbl.e + f_dbl.e));\n+\n+  exit(0);\n+}"}, {"sha": "1f70313c8c54d6efa083abf70b597a64a863dfbc", "filename": "libffi/testsuite/libffi.call/cls_20byte1.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,92 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_20byte {\n+  int a;\n+  double b;\n+  double c;\n+} cls_struct_20byte;\n+\n+cls_struct_20byte cls_struct_20byte_fn(struct cls_struct_20byte a1,\n+\t\t\t    struct cls_struct_20byte a2)\n+{\n+  struct cls_struct_20byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+\n+  printf(\"%d %g %g %d %g %g: %d %g %g\\n\", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c,\n+\t result.a, result.b, result.c);\n+  return result;\n+}\n+\n+static void\n+cls_struct_20byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+  struct cls_struct_20byte a1, a2;\n+\n+  a1 = *(struct cls_struct_20byte*)(args[0]);\n+  a2 = *(struct cls_struct_20byte*)(args[1]);\n+\n+  *(cls_struct_20byte*)resp = cls_struct_20byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[3];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_20byte g_dbl = { 1, 2.0, 3.0 };\n+  struct cls_struct_20byte f_dbl = { 4, 5.0, 7.0 };\n+  struct cls_struct_20byte res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_uint32;\n+  cls_struct_fields[1] = &ffi_type_double;\n+  cls_struct_fields[2] = &ffi_type_double;\n+  cls_struct_fields[3] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_20byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 2 3 4 5 7: 5 7 10\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_20byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n1 2 3 4 5 7: 5 7 10\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+  exit(0);\n+}"}, {"sha": "69281af1e190ad157dba960c7e063218f11f6124", "filename": "libffi/testsuite/libffi.call/cls_64byte.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,133 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check bigger struct which overlaps\n+\t\tthe gp and fp register count on Darwin/AIX/ppc64.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_64byte {\n+  double a;\n+  double b;\n+  double c;\n+  double d;\n+  double e;\n+  double f;\n+  double g;\n+  double h;\n+} cls_struct_64byte;\n+\n+cls_struct_64byte cls_struct_64byte_fn(struct cls_struct_64byte b0,\n+\t\t\t    struct cls_struct_64byte b1,\n+\t\t\t    struct cls_struct_64byte b2,\n+\t\t\t    struct cls_struct_64byte b3)\n+{\n+  struct cls_struct_64byte result;\n+\n+  result.a = b0.a + b1.a + b2.a + b3.a;\n+  result.b = b0.b + b1.b + b2.b + b3.b;\n+  result.c = b0.c + b1.c + b2.c + b3.c;\n+  result.d = b0.d + b1.d + b2.d + b3.d;\n+  result.e = b0.e + b1.e + b2.e + b3.e;\n+  result.f = b0.f + b1.f + b2.f + b3.f;\n+  result.g = b0.g + b1.g + b2.g + b3.g;\n+  result.h = b0.h + b1.h + b2.h + b3.h;\n+\n+  printf(\"%g %g %g %g %g %g %g %g\\n\", result.a, result.b, result.c,\n+\t result.d, result.e, result.f, result.g, result.h);\n+\n+  return result;\n+}\n+\n+static void\n+cls_struct_64byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+  struct cls_struct_64byte b0, b1, b2, b3;\n+\n+  b0 = *(struct cls_struct_64byte*)(args[0]);\n+  b1 = *(struct cls_struct_64byte*)(args[1]);\n+  b2 = *(struct cls_struct_64byte*)(args[2]);\n+  b3 = *(struct cls_struct_64byte*)(args[3]);\n+\n+  *(cls_struct_64byte*)resp = cls_struct_64byte_fn(b0, b1, b2, b3);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[9];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_64byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0 };\n+  struct cls_struct_64byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0 };\n+  struct cls_struct_64byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0 };\n+  struct cls_struct_64byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0 };\n+  struct cls_struct_64byte res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_double;\n+  cls_struct_fields[2] = &ffi_type_double;\n+  cls_struct_fields[3] = &ffi_type_double;\n+  cls_struct_fields[4] = &ffi_type_double;\n+  cls_struct_fields[5] = &ffi_type_double;\n+  cls_struct_fields[6] = &ffi_type_double;\n+  cls_struct_fields[7] = &ffi_type_double;\n+  cls_struct_fields[8] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = &cls_struct_type;\n+  dbl_arg_types[3] = &cls_struct_type;\n+  dbl_arg_types[4] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = &h_dbl;\n+  args_dbl[4] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_64byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"22 15 17 25 6 13 19 18\" } */\n+  CHECK( res_dbl.a == (e_dbl.a + f_dbl.a + g_dbl.a + h_dbl.a));\n+  CHECK( res_dbl.b == (e_dbl.b + f_dbl.b + g_dbl.b + h_dbl.b));\n+  CHECK( res_dbl.c == (e_dbl.c + f_dbl.c + g_dbl.c + h_dbl.c));\n+  CHECK( res_dbl.d == (e_dbl.d + f_dbl.d + g_dbl.d + h_dbl.d));\n+  CHECK( res_dbl.e == (e_dbl.e + f_dbl.e + g_dbl.e + h_dbl.e));\n+  CHECK( res_dbl.f == (e_dbl.f + f_dbl.f + g_dbl.f + h_dbl.f));\n+  CHECK( res_dbl.g == (e_dbl.g + f_dbl.g + g_dbl.g + h_dbl.g));\n+  CHECK( res_dbl.h == (e_dbl.h + f_dbl.h + g_dbl.h + h_dbl.h));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_64byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_64byte(*)(cls_struct_64byte,\n+\t\t\t\t     cls_struct_64byte,\n+\t\t\t\t     cls_struct_64byte,\n+\t\t\t\t     cls_struct_64byte))\n+\t     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+  /* { dg-output \"\\n22 15 17 25 6 13 19 18\" } */\n+  CHECK( res_dbl.a == (e_dbl.a + f_dbl.a + g_dbl.a + h_dbl.a));\n+  CHECK( res_dbl.b == (e_dbl.b + f_dbl.b + g_dbl.b + h_dbl.b));\n+  CHECK( res_dbl.c == (e_dbl.c + f_dbl.c + g_dbl.c + h_dbl.c));\n+  CHECK( res_dbl.d == (e_dbl.d + f_dbl.d + g_dbl.d + h_dbl.d));\n+  CHECK( res_dbl.e == (e_dbl.e + f_dbl.e + g_dbl.e + h_dbl.e));\n+  CHECK( res_dbl.f == (e_dbl.f + f_dbl.f + g_dbl.f + h_dbl.f));\n+  CHECK( res_dbl.g == (e_dbl.g + f_dbl.g + g_dbl.g + h_dbl.g));\n+  CHECK( res_dbl.h == (e_dbl.h + f_dbl.h + g_dbl.h + h_dbl.h));\n+\n+  exit(0);\n+}"}, {"sha": "8369a06f8f346bec2d64a1d42e527396f335debe", "filename": "libffi/testsuite/libffi.call/cls_9byte1.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,90 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Darwin/AIX do double-word\n+\t\talignment of the struct if the first element is a double.\n+\t\tCheck that it does not here.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030914\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_9byte {\n+  int a;\n+  double b;\n+} cls_struct_9byte;\n+\n+cls_struct_9byte cls_struct_9byte_fn(struct cls_struct_9byte b1,\n+\t\t\t    struct cls_struct_9byte b2)\n+{\n+  struct cls_struct_9byte result;\n+\n+  result.a = b1.a + b2.a;\n+  result.b = b1.b + b2.b;\n+\n+  printf(\"%d %g %d %g: %d %g\\n\", b1.a, b1.b,  b2.a, b2.b,\n+\t result.a, result.b);\n+\n+  return result;\n+}\n+\n+static void cls_struct_9byte_gn(ffi_cif* cif, void* resp, void** args,\n+\t\t\t\tvoid* userdata)\n+{\n+  struct cls_struct_9byte b1, b2;\n+\n+  b1 = *(struct cls_struct_9byte*)(args[0]);\n+  b2 = *(struct cls_struct_9byte*)(args[1]);\n+\n+  *(cls_struct_9byte*)resp = cls_struct_9byte_fn(b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[3];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_9byte h_dbl = { 7, 8.0};\n+  struct cls_struct_9byte j_dbl = { 1, 9.0};\n+  struct cls_struct_9byte res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_uint32;\n+  cls_struct_fields[1] = &ffi_type_double;\n+  cls_struct_fields[2] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &h_dbl;\n+  args_dbl[1] = &j_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_9byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"7 8 1 9: 8 17\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_9byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(pcl))(h_dbl, j_dbl);\n+  /* { dg-output \"\\n7 8 1 9: 8 17\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+\n+  exit(0);\n+}"}, {"sha": "2fc234e0025150971ab07fce1af5dbdbe1a1502e", "filename": "libffi/testsuite/libffi.call/cls_9byte2.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,90 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Darwin/AIX do double-word\n+\t\talignment of the struct if the first element is a double.\n+\t\tCheck that it does here.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030914\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_9byte {\n+  double a;\n+  int b;\n+} cls_struct_9byte;\n+\n+cls_struct_9byte cls_struct_9byte_fn(struct cls_struct_9byte b1,\n+\t\t\t    struct cls_struct_9byte b2)\n+{\n+  struct cls_struct_9byte result;\n+\n+  result.a = b1.a + b2.a;\n+  result.b = b1.b + b2.b;\n+\n+  printf(\"%g %d %g %d: %g %d\\n\", b1.a, b1.b,  b2.a, b2.b,\n+\t result.a, result.b);\n+\n+  return result;\n+}\n+\n+static void cls_struct_9byte_gn(ffi_cif* cif, void* resp, void** args,\n+\t\t\t\tvoid* userdata)\n+{\n+  struct cls_struct_9byte b1, b2;\n+\n+  b1 = *(struct cls_struct_9byte*)(args[0]);\n+  b2 = *(struct cls_struct_9byte*)(args[1]);\n+\n+  *(cls_struct_9byte*)resp = cls_struct_9byte_fn(b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[3];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_9byte h_dbl = { 7.0, 8};\n+  struct cls_struct_9byte j_dbl = { 1.0, 9};\n+  struct cls_struct_9byte res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_uint32;\n+  cls_struct_fields[2] = NULL;\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &h_dbl;\n+  args_dbl[1] = &j_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_9byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"7 8 1 9: 8 17\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_9byte_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(pcl))(h_dbl, j_dbl);\n+  /* { dg-output \"\\n7 8 1 9: 8 17\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+\n+  exit(0);\n+}"}, {"sha": "a704c9d18acfb259fc421d06ee9f82dd959f00dd", "filename": "libffi/testsuite/libffi.call/cls_schar.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,41 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value schar.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20031108\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_schar_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+{\n+  *(ffi_arg*)resp = *(signed char *)args[0];\n+  printf(\"%d: %d\\n\",*(signed char *)args[0],\n+\t *(ffi_arg*)resp);\n+}\n+typedef signed char (*cls_ret_schar)(signed char);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  signed char res;\n+\n+  cl_arg_types[0] = &ffi_type_schar;\n+  cl_arg_types[1] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_schar, cl_arg_types) == FFI_OK);\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_schar_fn, NULL)  == FFI_OK);\n+\n+  res = (*((cls_ret_schar)pcl))(127);\n+  /* { dg-output \"127: 127\" } */\n+  CHECK(res == 127);\n+\n+  exit(0);\n+}"}, {"sha": "839045f673dc6d3372cb62d9a9e87cb15b44a0c5", "filename": "libffi/testsuite/libffi.call/cls_sint.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,41 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value sint32.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20031108\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_sint_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+{\n+  *(ffi_arg*)resp = *(signed int *)args[0];\n+  printf(\"%d: %d\\n\",*(signed int *)args[0],\n+\t *(ffi_arg*)resp);\n+}\n+typedef signed int (*cls_ret_sint)(signed int);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  signed int res;\n+\n+  cl_arg_types[0] = &ffi_type_sint32;\n+  cl_arg_types[1] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_sint32, cl_arg_types) == FFI_OK);\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_sint_fn, NULL)  == FFI_OK);\n+\n+  res = (*((cls_ret_sint)pcl))(65534);\n+  /* { dg-output \"65534: 65534\" } */\n+  CHECK(res == 65534);\n+\n+  exit(0);\n+}"}, {"sha": "9cfe767871730f947e25b39f643d5ff642686dac", "filename": "libffi/testsuite/libffi.call/cls_sshort.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,41 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value sshort.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20031108\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_sshort_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+{\n+  *(ffi_arg*)resp = *(signed short *)args[0];\n+  printf(\"%d: %d\\n\",*(signed short *)args[0],\n+\t *(ffi_arg*)resp);\n+}\n+typedef signed short (*cls_ret_sshort)(signed short);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  signed short res;\n+\n+  cl_arg_types[0] = &ffi_type_sint16;\n+  cl_arg_types[1] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_sint16, cl_arg_types) == FFI_OK);\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_sshort_fn, NULL)  == FFI_OK);\n+\n+  res = (*((cls_ret_sshort)pcl))(255);\n+  /* { dg-output \"255: 255\" } */\n+  CHECK(res == 255);\n+\n+  exit(0);\n+}"}, {"sha": "7c06685b11fe936fd6cff4453f4fb8b3d74cd5e6", "filename": "libffi/testsuite/libffi.call/nested_struct2.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,119 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030911\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+#if LONG_MAX == 2147483647\n+#define ffi_type_mylong ffi_type_uint32\n+#else\n+#if LONG_MAX == 9223372036854775807\n+#define ffi_type_mylong ffi_type_uint64\n+#else\n+#error \"Error, size LONG not defined as expected\"\n+#endif\n+#endif\n+\n+typedef struct A {\n+  unsigned long a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+B B_fn(struct A b0, struct B b1)\n+{\n+  struct B result;\n+\n+  result.x.a = b0.a + b1.x.a;\n+  result.x.b = b0.b + b1.x.b + b1.y;\n+  result.y = b0.b + b1.x.b;\n+\n+  printf(\"%d %d %d %d %d: %d %d %d\\n\", b0.a, b0.b, b1.x.a, b1.x.b, b1.y,\n+\t result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+  struct A b0;\n+  struct B b1;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+\n+  *(B*)resp = B_fn(b0, b1);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type cls_struct_type, cls_struct_type1;\n+  ffi_type* dbl_arg_types[3];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  struct A e_dbl = { 1, 7};\n+  struct B f_dbl = {{12 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_mylong;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+  exit(0);\n+}"}, {"sha": "0f578b222bc8f0c0cab8f05c66e6a76e92763a22", "filename": "libffi/testsuite/libffi.call/nested_struct3.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47cc13ab45226d800f5cbc98ad50ed99812b4b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c?ref=ac47cc13ab45226d800f5cbc98ad50ed99812b4b", "patch": "@@ -0,0 +1,110 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030911\t */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  unsigned long long a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+B B_fn(struct A b0, struct B b1)\n+{\n+  struct B result;\n+\n+  result.x.a = b0.a + b1.x.a;\n+  result.x.b = b0.b + b1.x.b + b1.y;\n+  result.y = b0.b + b1.x.b;\n+\n+  printf(\"%d %d %d %d %d: %d %d %d\\n\", (int)b0.a, b0.b,\n+\t (int)b1.x.a, b1.x.b, b1.y,\n+\t (int)result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+  struct A b0;\n+  struct B b1;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+\n+  *(B*)resp = B_fn(b0, b1);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type cls_struct_type, cls_struct_type1;\n+  ffi_type* dbl_arg_types[3];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = {{12LL , 127}, 99};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_uint64;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+  exit(0);\n+}"}]}