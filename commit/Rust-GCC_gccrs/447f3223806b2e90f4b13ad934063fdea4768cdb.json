{"sha": "447f3223806b2e90f4b13ad934063fdea4768cdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3ZjMyMjM4MDZiMmU5MGY0YjEzYWQ5MzQwNjNmZGVhNDc2OGNkYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-10-25T11:51:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-10-25T11:51:11Z"}, "message": "re PR tree-optimization/58626 (possible array wrong code bug)\n\n2013-10-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/58626\n\t* tree-loop-distribution.c (enum rdg_dep_type): Remove\n\tanti_dd, output_dd and input_dd.\n\t(struct rdg_edge): Remove level and relation members.\n\t(RDGE_LEVEL, RDGE_RELATION): Remove.\n\t(dot_rdg_1): Adjust.\n\t(create_rdg_edge_for_ddr): Remove.\n\t(create_rdg_edges_for_scalar): Adjust.\n\t(create_edge_for_control_dependence): Likewise.\n\t(create_rdg_edges): Split into ...\n\t(create_rdg_flow_edges): ... this\n\t(create_rdg_cd_edges): ... and this.\n\t(free_rdg): Adjust.\n\t(build_rdg): Likewise, do not compute data dependences or\n\tadd edges for them.\n\t(pg_add_dependence_edges): New function.\n\t(pgcmp): Likewise.\n\t(distribute_loop): First apply all non-dependence based\n\tpartition mergings.  Then compute dependences between partitions\n\tand merge and order partitions according to them.\n\n\t* gcc.dg/torture/pr58626.c: New testcase.\n\nFrom-SVN: r204062", "tree": {"sha": "92a4f2d75d7f8468ac5e0aa42e73009a8b78c97c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92a4f2d75d7f8468ac5e0aa42e73009a8b78c97c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/447f3223806b2e90f4b13ad934063fdea4768cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447f3223806b2e90f4b13ad934063fdea4768cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447f3223806b2e90f4b13ad934063fdea4768cdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447f3223806b2e90f4b13ad934063fdea4768cdb/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5970573cc103b6745b760478b2f3f628d607edd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5970573cc103b6745b760478b2f3f628d607edd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5970573cc103b6745b760478b2f3f628d607edd2"}], "stats": {"total": 447, "additions": 287, "deletions": 160}, "files": [{"sha": "98286d132f3bcefd7a3755f0810dbfd781e3f316", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=447f3223806b2e90f4b13ad934063fdea4768cdb", "patch": "@@ -1,3 +1,26 @@\n+2013-10-25  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/58626\n+\t* tree-loop-distribution.c (enum rdg_dep_type): Remove\n+\tanti_dd, output_dd and input_dd.\n+\t(struct rdg_edge): Remove level and relation members.\n+\t(RDGE_LEVEL, RDGE_RELATION): Remove.\n+\t(dot_rdg_1): Adjust.\n+\t(create_rdg_edge_for_ddr): Remove.\n+\t(create_rdg_edges_for_scalar): Adjust.\n+\t(create_edge_for_control_dependence): Likewise.\n+\t(create_rdg_edges): Split into ...\n+\t(create_rdg_flow_edges): ... this\n+\t(create_rdg_cd_edges): ... and this.\n+\t(free_rdg): Adjust.\n+\t(build_rdg): Likewise, do not compute data dependences or\n+\tadd edges for them.\n+\t(pg_add_dependence_edges): New function.\n+\t(pgcmp): Likewise.\n+\t(distribute_loop): First apply all non-dependence based\n+\tpartition mergings.  Then compute dependences between partitions\n+\tand merge and order partitions according to them.\n+\n 2013-10-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR rtl-optimization/58831"}, {"sha": "1134e3ba28a375b6f01472b36dc3e6cf25496fd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=447f3223806b2e90f4b13ad934063fdea4768cdb", "patch": "@@ -1,3 +1,8 @@\n+2013-10-25  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/58626\n+\t* gcc.dg/torture/pr58626.c: New testcase.\n+\n 2013-10-25  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/54812"}, {"sha": "1416384b7a6f7e511a150370dd722512c6ed3e46", "filename": "gcc/testsuite/gcc.dg/torture/pr58626.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr58626.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr58626.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr58626.c?ref=447f3223806b2e90f4b13ad934063fdea4768cdb", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int a[8][6] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };\n+int b;\n+\n+int main(void)\n+{\n+  for (b = 0; b <= 1; b++) {\n+      a[1][3] = 0;\n+      int c;\n+      for (c = 0; c <= 1; c++) {\n+\t  a[c + 1][b] = a[c + 2][b];\n+      }\n+  }\n+  if (a[1][1] != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "353ce247de0550fe44e15fad44986e44e261e11b", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 239, "deletions": 160, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447f3223806b2e90f4b13ad934063fdea4768cdb/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=447f3223806b2e90f4b13ad934063fdea4768cdb", "patch": "@@ -96,15 +96,6 @@ enum rdg_dep_type\n   /* Read After Write (RAW).  */\n   flow_dd = 'f',\n \n-  /* Write After Read (WAR).  */\n-  anti_dd = 'a',\n-\n-  /* Write After Write (WAW).  */\n-  output_dd = 'o',\n-\n-  /* Read After Read (RAR).  */\n-  input_dd = 'i',\n-\n   /* Control dependence (execute conditional on).  */\n   control_dd = 'c'\n };\n@@ -115,19 +106,9 @@ typedef struct rdg_edge\n {\n   /* Type of the dependence.  */\n   enum rdg_dep_type type;\n-\n-  /* Levels of the dependence: the depth of the loops that carry the\n-     dependence.  */\n-  unsigned level;\n-\n-  /* Dependence relation between data dependences, NULL when one of\n-     the vertices is a scalar.  */\n-  ddr_p relation;\n } *rdg_edge_p;\n \n #define RDGE_TYPE(E)        ((struct rdg_edge *) ((E)->data))->type\n-#define RDGE_LEVEL(E)       ((struct rdg_edge *) ((E)->data))->level\n-#define RDGE_RELATION(E)    ((struct rdg_edge *) ((E)->data))->relation\n \n /* Dump vertex I in RDG to FILE.  */\n \n@@ -215,23 +196,11 @@ dot_rdg_1 (FILE *file, struct graph *rdg)\n        for (e = v->succ; e; e = e->succ_next)\n          switch (RDGE_TYPE (e))\n            {\n-           case input_dd:\n-             fprintf (file, \"%d -> %d [label=input] \\n\", i, e->dest);\n-             break;\n-\n-           case output_dd:\n-             fprintf (file, \"%d -> %d [label=output] \\n\", i, e->dest);\n-             break;\n-\n            case flow_dd:\n              /* These are the most common dependences: don't print these. */\n              fprintf (file, \"%d -> %d \\n\", i, e->dest);\n              break;\n \n-           case anti_dd:\n-             fprintf (file, \"%d -> %d [label=anti] \\n\", i, e->dest);\n-             break;\n-\n \t   case control_dd:\n              fprintf (file, \"%d -> %d [label=control] \\n\", i, e->dest);\n              break;\n@@ -273,52 +242,6 @@ rdg_vertex_for_stmt (struct graph *rdg ATTRIBUTE_UNUSED, gimple stmt)\n   return index;\n }\n \n-/* Creates an edge in RDG for each distance vector from DDR.  The\n-   order that we keep track of in the RDG is the order in which\n-   statements have to be executed.  */\n-\n-static void\n-create_rdg_edge_for_ddr (struct graph *rdg, ddr_p ddr)\n-{\n-  struct graph_edge *e;\n-  int va, vb;\n-  data_reference_p dra = DDR_A (ddr);\n-  data_reference_p drb = DDR_B (ddr);\n-  unsigned level = ddr_dependence_level (ddr);\n-\n-  /* For non scalar dependences, when the dependence is REVERSED,\n-     statement B has to be executed before statement A.  */\n-  if (level > 0\n-      && !DDR_REVERSED_P (ddr))\n-    {\n-      data_reference_p tmp = dra;\n-      dra = drb;\n-      drb = tmp;\n-    }\n-\n-  va = rdg_vertex_for_stmt (rdg, DR_STMT (dra));\n-  vb = rdg_vertex_for_stmt (rdg, DR_STMT (drb));\n-\n-  if (va < 0 || vb < 0)\n-    return;\n-\n-  e = add_edge (rdg, va, vb);\n-  e->data = XNEW (struct rdg_edge);\n-\n-  RDGE_LEVEL (e) = level;\n-  RDGE_RELATION (e) = ddr;\n-\n-  /* Determines the type of the data dependence.  */\n-  if (DR_IS_READ (dra) && DR_IS_READ (drb))\n-    RDGE_TYPE (e) = input_dd;\n-  else if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n-    RDGE_TYPE (e) = output_dd;\n-  else if (DR_IS_WRITE (dra) && DR_IS_READ (drb))\n-    RDGE_TYPE (e) = flow_dd;\n-  else if (DR_IS_READ (dra) && DR_IS_WRITE (drb))\n-    RDGE_TYPE (e) = anti_dd;\n-}\n-\n /* Creates dependence edges in RDG for all the uses of DEF.  IDEF is\n    the index of DEF in RDG.  */\n \n@@ -339,7 +262,6 @@ create_rdg_edges_for_scalar (struct graph *rdg, tree def, int idef)\n       e = add_edge (rdg, idef, use);\n       e->data = XNEW (struct rdg_edge);\n       RDGE_TYPE (e) = flow_dd;\n-      RDGE_RELATION (e) = NULL;\n     }\n }\n \n@@ -366,46 +288,45 @@ create_edge_for_control_dependence (struct graph *rdg, basic_block bb,\n \t  e = add_edge (rdg, c, v);\n \t  e->data = XNEW (struct rdg_edge);\n \t  RDGE_TYPE (e) = control_dd;\n-\t  RDGE_RELATION (e) = NULL;\n \t}\n     }\n }\n \n /* Creates the edges of the reduced dependence graph RDG.  */\n \n static void\n-create_rdg_edges (struct graph *rdg, vec<ddr_p> ddrs, control_dependences *cd)\n+create_rdg_flow_edges (struct graph *rdg)\n {\n   int i;\n-  struct data_dependence_relation *ddr;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n \n-  FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-    if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n-      create_rdg_edge_for_ddr (rdg, ddr);\n-    else\n-      free_dependence_relation (ddr);\n-\n   for (i = 0; i < rdg->n_vertices; i++)\n     FOR_EACH_PHI_OR_STMT_DEF (def_p, RDG_STMT (rdg, i),\n \t\t\t      iter, SSA_OP_DEF)\n       create_rdg_edges_for_scalar (rdg, DEF_FROM_PTR (def_p), i);\n+}\n \n-  if (cd)\n-    for (i = 0; i < rdg->n_vertices; i++)\n-      {\n-\tgimple stmt = RDG_STMT (rdg, i);\n-\tif (gimple_code (stmt) == GIMPLE_PHI)\n-\t  {\n-\t    edge_iterator ei;\n-\t    edge e;\n-\t    FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->preds)\n+/* Creates the edges of the reduced dependence graph RDG.  */\n+\n+static void\n+create_rdg_cd_edges (struct graph *rdg, control_dependences *cd)\n+{\n+  int i;\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    {\n+      gimple stmt = RDG_STMT (rdg, i);\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\t{\n+\t  edge_iterator ei;\n+\t  edge e;\n+\t  FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->preds)\n \t      create_edge_for_control_dependence (rdg, e->src, i, cd);\n-\t  }\n-\telse\n-\t  create_edge_for_control_dependence (rdg, gimple_bb (stmt), i, cd);\n-      }\n+\t}\n+      else\n+\tcreate_edge_for_control_dependence (rdg, gimple_bb (stmt), i, cd);\n+    }\n }\n \n /* Build the vertices of the reduced dependence graph RDG.  Return false\n@@ -494,10 +415,7 @@ free_rdg (struct graph *rdg)\n       struct graph_edge *e;\n \n       for (e = v->succ; e; e = e->succ_next)\n-\t{\n-\t  free_dependence_relation (RDGE_RELATION (e));\n-\t  free (e->data);\n-\t}\n+\tfree (e->data);\n \n       if (v->data)\n \t{\n@@ -520,7 +438,6 @@ build_rdg (vec<loop_p> loop_nest, control_dependences *cd)\n   struct graph *rdg;\n   vec<gimple> stmts;\n   vec<data_reference_p> datarefs;\n-  vec<ddr_p> dependence_relations;\n \n   /* Create the RDG vertices from the stmts of the loop nest.  */\n   stmts.create (10);\n@@ -536,19 +453,10 @@ build_rdg (vec<loop_p> loop_nest, control_dependences *cd)\n     }\n   stmts.release ();\n \n-  /* Create the RDG edges from the data dependences in the loop nest.  */\n-  dependence_relations.create (100);\n-  if (!compute_all_dependences (datarefs, &dependence_relations, loop_nest,\n-\t\t\t\tfalse)\n-      || !known_dependences_p (dependence_relations))\n-    {\n-      free_dependence_relations (dependence_relations);\n-      datarefs.release ();\n-      free_rdg (rdg);\n-      return NULL;\n-    }\n-  create_rdg_edges (rdg, dependence_relations, cd);\n-  dependence_relations.release ();\n+  create_rdg_flow_edges (rdg);\n+  if (cd)\n+    create_rdg_cd_edges (rdg, cd);\n+\n   datarefs.release ();\n \n   return rdg;\n@@ -1405,6 +1313,70 @@ partition_contains_all_rw (struct graph *rdg,\n   return false;\n }\n \n+/* Compute partition dependence created by the data references in DRS1\n+   and DRS2 and modify and return DIR according to that.  */\n+\n+static int\n+pg_add_dependence_edges (struct graph *rdg, vec<loop_p> loops, int dir,\n+\t\t\t vec<data_reference_p> drs1,\n+\t\t\t vec<data_reference_p> drs2)\n+{\n+  data_reference_p dr1, dr2;\n+\n+  /* dependence direction - 0 is no dependence, -1 is back,\n+     1 is forth, 2 is both (we can stop then, merging will occur).  */\n+  for (int ii = 0; drs1.iterate (ii, &dr1); ++ii)\n+    for (int jj = 0; drs2.iterate (jj, &dr2); ++jj)\n+      {\n+\tint this_dir = 1;\n+\tddr_p ddr;\n+\t/* Re-shuffle data-refs to be in dominator order.  */\n+\tif (rdg_vertex_for_stmt (rdg, DR_STMT (dr1))\n+\t    > rdg_vertex_for_stmt (rdg, DR_STMT (dr2)))\n+\t  {\n+\t    data_reference_p tem = dr1;\n+\t    dr1 = dr2;\n+\t    dr2 = tem;\n+\t    this_dir = -this_dir;\n+\t  }\n+\tddr = initialize_data_dependence_relation (dr1, dr2, loops);\n+\tcompute_affine_dependence (ddr, loops[0]);\n+\tif (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+\t  this_dir = 2;\n+\telse if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+\t  {\n+\t    if (DDR_REVERSED_P (ddr))\n+\t      {\n+\t\tdata_reference_p tem = dr1;\n+\t\tdr1 = dr2;\n+\t\tdr2 = tem;\n+\t\tthis_dir = -this_dir;\n+\t      }\n+\t    /* Known dependences can still be unordered througout the\n+\t       iteration space, see gcc.dg/tree-ssa/ldist-16.c.  */\n+\t    if (DDR_NUM_DIST_VECTS (ddr) == 0)\n+\t      this_dir = 2;\n+\t  }\n+\telse\n+\t  this_dir = 0;\n+\tfree_dependence_relation (ddr);\n+\tif (dir == 0)\n+\t  dir = this_dir;\n+\telse if (dir != this_dir)\n+\t  return 2;\n+      }\n+  return dir;\n+}\n+\n+/* Compare postorder number of the partition graph vertices V1 and V2.  */\n+\n+static int\n+pgcmp (const void *v1_, const void *v2_)\n+{\n+  const vertex *v1 = (const vertex *)v1_;\n+  const vertex *v2 = (const vertex *)v2_;\n+  return v2->post - v1->post;\n+}\n \n /* Distributes the code from LOOP in such a way that producer\n    statements are placed before consumer statements.  Tries to separate\n@@ -1421,6 +1393,8 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n   partition_t partition;\n   bool any_builtin;\n   int i, nbp;\n+  graph *pg = NULL;\n+  int num_sccs = 1;\n \n   *nb_calls = 0;\n   loop_nest.create (3);\n@@ -1455,18 +1429,65 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n       any_builtin |= partition_builtin_p (partition);\n     }\n \n-  /* If we did not detect any builtin but are not asked to apply\n-     regular loop distribution simply bail out.  */\n+  /* If we are only distributing patterns but did not detect any,\n+     simply bail out.  */\n   if (!flag_tree_loop_distribution\n       && !any_builtin)\n     {\n       nbp = 0;\n       goto ldist_done;\n     }\n \n+  /* If we are only distributing patterns fuse all partitions that\n+     were not classified as builtins.  This also avoids chopping\n+     a loop into pieces, separated by builtin calls.  That is, we\n+     only want no or a single loop body remaining.  */\n+  partition_t into;\n+  if (!flag_tree_loop_distribution)\n+    {\n+      for (i = 0; partitions.iterate (i, &into); ++i)\n+\tif (!partition_builtin_p (into))\n+\t  break;\n+      for (++i; partitions.iterate (i, &partition); ++i)\n+\tif (!partition_builtin_p (partition))\n+\t  {\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      {\n+\t\tfprintf (dump_file, \"fusing non-builtin partitions\\n\");\n+\t\tdump_bitmap (dump_file, into->stmts);\n+\t\tdump_bitmap (dump_file, partition->stmts);\n+\t      }\n+\t    partition_merge_into (into, partition);\n+\t    partitions.unordered_remove (i);\n+\t    partition_free (partition);\n+\t    i--;\n+\t  }\n+    }\n+\n+  /* Due to limitations in the transform phase we have to fuse all\n+     reduction partitions into the last partition so the existing\n+     loop will contain all loop-closed PHI nodes.  */\n+  for (i = 0; partitions.iterate (i, &into); ++i)\n+    if (partition_reduction_p (into))\n+      break;\n+  for (i = i + 1; partitions.iterate (i, &partition); ++i)\n+    if (partition_reduction_p (partition))\n+      {\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  {\n+\t    fprintf (dump_file, \"fusing partitions\\n\");\n+\t    dump_bitmap (dump_file, into->stmts);\n+\t    dump_bitmap (dump_file, partition->stmts);\n+\t    fprintf (dump_file, \"because they have reductions\\n\");\n+\t  }\n+\tpartition_merge_into (into, partition);\n+\tpartitions.unordered_remove (i);\n+\tpartition_free (partition);\n+\ti--;\n+      }\n+\n   /* Apply our simple cost model - fuse partitions with similar\n      memory accesses.  */\n-  partition_t into;\n   for (i = 0; partitions.iterate (i, &into); ++i)\n     {\n       if (partition_builtin_p (into))\n@@ -1486,61 +1507,119 @@ distribute_loop (struct loop *loop, vec<gimple> stmts,\n \t\t\t   \"memory accesses\\n\");\n \t\t}\n \t      partition_merge_into (into, partition);\n-\t      partitions.ordered_remove (j);\n+\t      partitions.unordered_remove (j);\n \t      partition_free (partition);\n \t      j--;\n \t    }\n \t}\n     }\n \n-  /* If we are only distributing patterns fuse all partitions that\n-     were not properly classified as builtins.  */\n-  if (!flag_tree_loop_distribution)\n+  /* Build the partition dependency graph.  */\n+  if (partitions.length () > 1)\n     {\n-      partition_t into;\n-      /* Only fuse adjacent non-builtin partitions, see PR53616.\n-         ???  Use dependence information to improve partition ordering.  */\n-      i = 0;\n-      do\n+      pg = new_graph (partitions.length ());\n+      struct pgdata {\n+\t  partition_t partition;\n+\t  vec<data_reference_p> writes;\n+\t  vec<data_reference_p> reads;\n+      };\n+#define PGDATA(i) ((pgdata *)(pg->vertices[i].data))\n+      for (i = 0; partitions.iterate (i, &partition); ++i)\n+\t{\n+\t  vertex *v = &pg->vertices[i];\n+\t  pgdata *data = new pgdata;\n+\t  data_reference_p dr;\n+\t  /* FIXME - leaks.  */\n+\t  v->data = data;\n+\t  bitmap_iterator bi;\n+\t  unsigned j;\n+\t  data->partition = partition;\n+\t  data->reads = vNULL;\n+\t  data->writes = vNULL;\n+\t  EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, j, bi)\n+\t    for (int k = 0; RDG_DATAREFS (rdg, j).iterate (k, &dr); ++k)\n+\t      if (DR_IS_READ (dr))\n+\t\tdata->reads.safe_push (dr);\n+\t      else\n+\t\tdata->writes.safe_push (dr);\n+\t}\n+      partition_t partition1, partition2;\n+      for (i = 0; partitions.iterate (i, &partition1); ++i)\n+\tfor (int j = i + 1; partitions.iterate (j, &partition2); ++j)\n+\t  {\n+\t    /* dependence direction - 0 is no dependence, -1 is back,\n+\t       1 is forth, 2 is both (we can stop then, merging will occur).  */\n+\t    int dir = 0;\n+\t    dir = pg_add_dependence_edges (rdg, loop_nest, dir,\n+\t\t\t\t\t   PGDATA(i)->writes,\n+\t\t\t\t\t   PGDATA(j)->reads);\n+\t    if (dir != 2)\n+\t      dir = pg_add_dependence_edges (rdg, loop_nest, dir,\n+\t\t\t\t\t     PGDATA(i)->reads,\n+\t\t\t\t\t     PGDATA(j)->writes);\n+\t    if (dir != 2)\n+\t      dir = pg_add_dependence_edges (rdg, loop_nest, dir,\n+\t\t\t\t\t     PGDATA(i)->writes,\n+\t\t\t\t\t     PGDATA(j)->writes);\n+\t    if (dir == 1 || dir == 2)\n+\t      add_edge (pg, i, j);\n+\t    if (dir == -1 || dir == 2)\n+\t      add_edge (pg, j, i);\n+\t  }\n+\n+      /* Add edges to the reduction partition (if any) to force it last.  */\n+      unsigned j;\n+      for (j = 0; partitions.iterate (j, &partition); ++j)\n+\tif (partition_reduction_p (partition))\n+\t  break;\n+      if (j < partitions.length ())\n \t{\n-\t  for (; partitions.iterate (i, &into); ++i)\n-\t    if (!partition_builtin_p (into))\n+\t  for (unsigned i = 0; partitions.iterate (i, &partition); ++i)\n+\t    if (i != j)\n+\t      add_edge (pg, i, j);\n+\t}\n+\n+      /* Compute partitions we cannot separate and fuse them.  */\n+      num_sccs = graphds_scc (pg, NULL);\n+      for (i = 0; i < num_sccs; ++i)\n+\t{\n+\t  partition_t first;\n+\t  int j;\n+\t  for (j = 0; partitions.iterate (j, &first); ++j)\n+\t    if (pg->vertices[j].component == i)\n \t      break;\n-\t  for (++i; partitions.iterate (i, &partition); ++i)\n-\t    if (!partition_builtin_p (partition))\n+\t  for (j = j + 1; partitions.iterate (j, &partition); ++j)\n+\t    if (pg->vertices[j].component == i)\n \t      {\n-\t\tpartition_merge_into (into, partition);\n-\t\tpartitions.ordered_remove (i);\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t  {\n+\t\t    fprintf (dump_file, \"fusing partitions\\n\");\n+\t\t    dump_bitmap (dump_file, first->stmts);\n+\t\t    dump_bitmap (dump_file, partition->stmts);\n+\t\t    fprintf (dump_file, \"because they are in the same \"\n+\t\t\t     \"dependence SCC\\n\");\n+\t\t  }\n+\t\tpartition_merge_into (first, partition);\n+\t\tpartitions[j] = NULL;\n \t\tpartition_free (partition);\n-\t\ti--;\n+\t\tPGDATA (j)->partition = NULL;\n \t      }\n-\t    else\n-\t      break;\n \t}\n-      while ((unsigned) i < partitions.length ());\n-    }\n \n-  /* Fuse all reduction partitions into the last.  */\n-  if (partitions.length () > 1)\n-    {\n-      partition_t into = partitions.last ();\n-      for (i = partitions.length () - 2; i >= 0; --i)\n+      /* Now order the remaining nodes in postorder.  */\n+      qsort (pg->vertices, pg->n_vertices, sizeof (vertex), pgcmp);\n+      partitions.truncate (0);\n+      for (i = 0; i < pg->n_vertices; ++i)\n \t{\n-\t  partition_t what = partitions[i];\n-\t  if (partition_reduction_p (what))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"fusing partitions\\n\");\n-\t\t  dump_bitmap (dump_file, into->stmts);\n-\t\t  dump_bitmap (dump_file, what->stmts);\n-\t\t  fprintf (dump_file, \"because the latter has reductions\\n\");\n-\t\t}\n-\t      partition_merge_into (into, what);\n-\t      partitions.ordered_remove (i);\n-\t      partition_free (what);\n-\t    }\n+\t  pgdata *data = PGDATA (i);\n+\t  if (data->partition)\n+\t    partitions.safe_push (data->partition);\n+\t  data->reads.release ();\n+\t  data->writes.release ();\n+\t  delete data;\n \t}\n+      gcc_assert (partitions.length () == (unsigned)num_sccs);\n+      free_graph (pg);\n     }\n \n   nbp = partitions.length ();"}]}