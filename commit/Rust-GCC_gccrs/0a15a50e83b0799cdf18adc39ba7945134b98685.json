{"sha": "0a15a50e83b0799cdf18adc39ba7945134b98685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGExNWE1MGU4M2IwNzk5Y2RmMThhZGMzOWJhNzk0NTEzNGI5ODY4NQ==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2014-01-06T14:14:21Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2014-01-06T14:14:21Z"}, "message": "cp-demangle.c (struct d_print_info): New fields next_saved_scope...\n\nlibiberty/\n2014-01-06  Gary Benson  <gbenson@redhat.com>\n\n\t* cp-demangle.c (struct d_print_info): New fields\n\tnext_saved_scope, copy_templates, next_copy_template and\n\tnum_copy_templates.\n\t(d_count_templates): New function.\n\t(d_print_init): New parameter \"dc\".\n\tEstimate numbers of templates and scopes required.\n\t(d_print_free): Removed function.\n\t(cplus_demangle_print_callback): Allocate stack for\n\ttemplates and scopes.  Removed call to d_print_free.\n\t(d_copy_templates): Removed function.\n\t(d_save_scope): New function.\n\t(d_get_saved_scope): Likewise.\n\t(d_print_comp): Replace state saving/restoring code with\n\tcalls to d_save_scope and d_get_saved_scope.\n\nFrom-SVN: r206362", "tree": {"sha": "91ad70d43240c61f727c41e1a180f23a036cb090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91ad70d43240c61f727c41e1a180f23a036cb090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a15a50e83b0799cdf18adc39ba7945134b98685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a15a50e83b0799cdf18adc39ba7945134b98685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a15a50e83b0799cdf18adc39ba7945134b98685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a15a50e83b0799cdf18adc39ba7945134b98685/comments", "author": null, "committer": null, "parents": [{"sha": "a4e33812b0fe66f2d868d299b9b1fff0f0e84905", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4e33812b0fe66f2d868d299b9b1fff0f0e84905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4e33812b0fe66f2d868d299b9b1fff0f0e84905"}], "stats": {"total": 284, "additions": 223, "deletions": 61}, "files": [{"sha": "9a5ace1a2b68ec3cbcfb0f0ab7761c94426f28fc", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a15a50e83b0799cdf18adc39ba7945134b98685/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a15a50e83b0799cdf18adc39ba7945134b98685/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=0a15a50e83b0799cdf18adc39ba7945134b98685", "patch": "@@ -1,3 +1,20 @@\n+2014-01-06  Gary Benson  <gbenson@redhat.com>\n+\n+\t* cp-demangle.c (struct d_print_info): New fields\n+\tnext_saved_scope, copy_templates, next_copy_template and\n+\tnum_copy_templates.\n+\t(d_count_templates): New function.\n+\t(d_print_init): New parameter \"dc\".\n+\tEstimate numbers of templates and scopes required.\n+\t(d_print_free): Removed function.\n+\t(cplus_demangle_print_callback): Allocate stack for\n+\ttemplates and scopes.  Removed call to d_print_free.\n+\t(d_copy_templates): Removed function.\n+\t(d_save_scope): New function.\n+\t(d_get_saved_scope): Likewise.\n+\t(d_print_comp): Replace state saving/restoring code with\n+\tcalls to d_save_scope and d_get_saved_scope.\n+\n 2013-12-23  Bill Maddox  <maddox@google.com>\n \n \t* cp-demangle.c (cplus_demangle_fill_ctor,cplus_demangle_fill_dtor):"}, {"sha": "bf2ffa95a8df7566d06fbea44654f1523eee0eeb", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 206, "deletions": 61, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a15a50e83b0799cdf18adc39ba7945134b98685/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a15a50e83b0799cdf18adc39ba7945134b98685/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=0a15a50e83b0799cdf18adc39ba7945134b98685", "patch": "@@ -329,8 +329,16 @@ struct d_print_info\n   unsigned long int flush_count;\n   /* Array of saved scopes for evaluating substitutions.  */\n   struct d_saved_scope *saved_scopes;\n+  /* Index of the next unused saved scope in the above array.  */\n+  int next_saved_scope;\n   /* Number of saved scopes in the above array.  */\n   int num_saved_scopes;\n+  /* Array of templates for saving into scopes.  */\n+  struct d_print_template *copy_templates;\n+  /* Index of the next unused copy template in the above array.  */\n+  int next_copy_template;\n+  /* Number of copy templates in the above array.  */\n+  int num_copy_templates;\n   /* The nearest enclosing template, if any.  */\n   const struct demangle_component *current_template;\n };\n@@ -475,7 +483,8 @@ static void\n d_growable_string_callback_adapter (const char *, size_t, void *);\n \n static void\n-d_print_init (struct d_print_info *, demangle_callbackref, void *);\n+d_print_init (struct d_print_info *, demangle_callbackref, void *,\n+\t      const struct demangle_component *);\n \n static inline void d_print_error (struct d_print_info *);\n \n@@ -3777,11 +3786,141 @@ d_growable_string_callback_adapter (const char *s, size_t l, void *opaque)\n   d_growable_string_append_buffer (dgs, s, l);\n }\n \n+/* Walk the tree, counting the number of templates encountered, and\n+   the number of times a scope might be saved.  These counts will be\n+   used to allocate data structures for d_print_comp, so the logic\n+   here must mirror the logic d_print_comp will use.  It is not\n+   important that the resulting numbers are exact, so long as they\n+   are larger than the actual numbers encountered.  */\n+\n+static void\n+d_count_templates_scopes (int *num_templates, int *num_scopes,\n+\t\t\t  const struct demangle_component *dc)\n+{\n+  if (dc == NULL)\n+    return;\n+\n+  switch (dc->type)\n+    {\n+    case DEMANGLE_COMPONENT_NAME:\n+    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n+    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n+    case DEMANGLE_COMPONENT_SUB_STD:\n+    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n+    case DEMANGLE_COMPONENT_OPERATOR:\n+    case DEMANGLE_COMPONENT_CHARACTER:\n+    case DEMANGLE_COMPONENT_NUMBER:\n+    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n+      break;\n+\n+    case DEMANGLE_COMPONENT_TEMPLATE:\n+      (*num_templates)++;\n+      goto recurse_left_right;\n+\n+    case DEMANGLE_COMPONENT_REFERENCE:\n+    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n+      if (d_left (dc)->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n+\t(*num_scopes)++;\n+      goto recurse_left_right;\n+\n+    case DEMANGLE_COMPONENT_QUAL_NAME:\n+    case DEMANGLE_COMPONENT_LOCAL_NAME:\n+    case DEMANGLE_COMPONENT_TYPED_NAME:\n+    case DEMANGLE_COMPONENT_VTABLE:\n+    case DEMANGLE_COMPONENT_VTT:\n+    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n+    case DEMANGLE_COMPONENT_TYPEINFO:\n+    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n+    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n+    case DEMANGLE_COMPONENT_THUNK:\n+    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n+    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n+    case DEMANGLE_COMPONENT_JAVA_CLASS:\n+    case DEMANGLE_COMPONENT_GUARD:\n+    case DEMANGLE_COMPONENT_TLS_INIT:\n+    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n+    case DEMANGLE_COMPONENT_REFTEMP:\n+    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n+    case DEMANGLE_COMPONENT_RESTRICT:\n+    case DEMANGLE_COMPONENT_VOLATILE:\n+    case DEMANGLE_COMPONENT_CONST:\n+    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n+    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n+    case DEMANGLE_COMPONENT_CONST_THIS:\n+    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n+    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n+    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n+    case DEMANGLE_COMPONENT_POINTER:\n+    case DEMANGLE_COMPONENT_COMPLEX:\n+    case DEMANGLE_COMPONENT_IMAGINARY:\n+    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n+    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n+    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n+    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n+    case DEMANGLE_COMPONENT_FIXED_TYPE:\n+    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n+    case DEMANGLE_COMPONENT_ARGLIST:\n+    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n+    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n+    case DEMANGLE_COMPONENT_CAST:\n+    case DEMANGLE_COMPONENT_NULLARY:\n+    case DEMANGLE_COMPONENT_UNARY:\n+    case DEMANGLE_COMPONENT_BINARY:\n+    case DEMANGLE_COMPONENT_BINARY_ARGS:\n+    case DEMANGLE_COMPONENT_TRINARY:\n+    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n+    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n+    case DEMANGLE_COMPONENT_LITERAL:\n+    case DEMANGLE_COMPONENT_LITERAL_NEG:\n+    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n+    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n+    case DEMANGLE_COMPONENT_DECLTYPE:\n+    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n+    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n+    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n+    case DEMANGLE_COMPONENT_TAGGED_NAME:\n+    case DEMANGLE_COMPONENT_CLONE:\n+    recurse_left_right:\n+      d_count_templates_scopes (num_templates, num_scopes,\n+\t\t\t\td_left (dc));\n+      d_count_templates_scopes (num_templates, num_scopes,\n+\t\t\t\td_right (dc));\n+      break;\n+\n+    case DEMANGLE_COMPONENT_CTOR:\n+      d_count_templates_scopes (num_templates, num_scopes,\n+\t\t\t\tdc->u.s_ctor.name);\n+      break;\n+\n+    case DEMANGLE_COMPONENT_DTOR:\n+      d_count_templates_scopes (num_templates, num_scopes,\n+\t\t\t\tdc->u.s_dtor.name);\n+      break;\n+\n+    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n+      d_count_templates_scopes (num_templates, num_scopes,\n+\t\t\t\tdc->u.s_extended_operator.name);\n+      break;\n+\n+    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n+    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n+      d_count_templates_scopes (num_templates, num_scopes,\n+\t\t\t\td_left (dc));\n+      break;\n+\n+    case DEMANGLE_COMPONENT_LAMBDA:\n+    case DEMANGLE_COMPONENT_DEFAULT_ARG:\n+      d_count_templates_scopes (num_templates, num_scopes,\n+\t\t\t\tdc->u.s_unary_num.sub);\n+      break;\n+    }\n+}\n+\n /* Initialize a print information structure.  */\n \n static void\n d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n-\t      void *opaque)\n+\t      void *opaque, const struct demangle_component *dc)\n {\n   dpi->len = 0;\n   dpi->last_char = '\\0';\n@@ -3796,29 +3935,18 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n   dpi->demangle_failure = 0;\n \n   dpi->saved_scopes = NULL;\n+  dpi->next_saved_scope = 0;\n   dpi->num_saved_scopes = 0;\n-  dpi->current_template = NULL;\n-}\n-\n-/* Free a print information structure.  */\n-\n-static void\n-d_print_free (struct d_print_info *dpi)\n-{\n-  int i;\n \n-  for (i = 0; i < dpi->num_saved_scopes; i++)\n-    {\n-      struct d_print_template *ts, *tn;\n+  dpi->copy_templates = NULL;\n+  dpi->next_copy_template = 0;\n+  dpi->num_copy_templates = 0;\n \n-      for (ts = dpi->saved_scopes[i].templates; ts != NULL; ts = tn)\n-\t{\n-\t  tn = ts->next;\n-\t  free (ts);\n-\t}\n-    }\n+  d_count_templates_scopes (&dpi->num_copy_templates,\n+\t\t\t    &dpi->num_saved_scopes, dc);\n+  dpi->num_copy_templates *= dpi->num_saved_scopes;\n \n-  free (dpi->saved_scopes);\n+  dpi->current_template = NULL;\n }\n \n /* Indicate that an error occurred during printing, and test for error.  */\n@@ -3903,17 +4031,29 @@ cplus_demangle_print_callback (int options,\n                                demangle_callbackref callback, void *opaque)\n {\n   struct d_print_info dpi;\n-  int success;\n \n-  d_print_init (&dpi, callback, opaque);\n+  d_print_init (&dpi, callback, opaque, dc);\n+\n+  {\n+#ifdef CP_DYNAMIC_ARRAYS\n+    __extension__ struct d_saved_scope scopes[dpi.num_saved_scopes];\n+    __extension__ struct d_print_template temps[dpi.num_copy_templates];\n+\n+    dpi.saved_scopes = scopes;\n+    dpi.copy_templates = temps;\n+#else\n+    dpi.saved_scopes = alloca (dpi.num_saved_scopes\n+\t\t\t       * sizeof (*dpi.saved_scopes));\n+    dpi.copy_templates = alloca (dpi.num_copy_templates\n+\t\t\t\t * sizeof (*dpi.copy_templates));\n+#endif\n \n-  d_print_comp (&dpi, options, dc);\n+    d_print_comp (&dpi, options, dc);\n+  }\n \n   d_print_flush (&dpi);\n \n-  success = ! d_print_saw_error (&dpi);\n-  d_print_free (&dpi);\n-  return success;\n+  return ! d_print_saw_error (&dpi);\n }\n \n /* Turn components into a human readable string.  OPTIONS is the\n@@ -4070,34 +4210,60 @@ d_print_subexpr (struct d_print_info *dpi, int options,\n     d_append_char (dpi, ')');\n }\n \n-/* Return a shallow copy of the current list of templates.\n-   On error d_print_error is called and a partial list may\n-   be returned.  Whatever is returned must be freed.  */\n+/* Save the current scope.  */\n \n-static struct d_print_template *\n-d_copy_templates (struct d_print_info *dpi)\n+static void\n+d_save_scope (struct d_print_info *dpi,\n+\t      const struct demangle_component *container)\n {\n-  struct d_print_template *src, *result, **link = &result;\n+  struct d_saved_scope *scope;\n+  struct d_print_template *src, **link;\n+\n+  if (dpi->next_saved_scope >= dpi->num_saved_scopes)\n+    {\n+      d_print_error (dpi);\n+      return;\n+    }\n+  scope = &dpi->saved_scopes[dpi->next_saved_scope];\n+  dpi->next_saved_scope++;\n+\n+  scope->container = container;\n+  link = &scope->templates;\n \n   for (src = dpi->templates; src != NULL; src = src->next)\n     {\n-      struct d_print_template *dst =\n-\t(struct d_print_template *) malloc (sizeof (struct d_print_template));\n+      struct d_print_template *dst;\n \n-      if (dst == NULL)\n+      if (dpi->next_copy_template >= dpi->num_copy_templates)\n \t{\n \t  d_print_error (dpi);\n-\t  break;\n+\t  return;\n \t}\n+      dst = &dpi->copy_templates[dpi->next_copy_template];\n+      dpi->next_copy_template++;\n \n       dst->template_decl = src->template_decl;\n       *link = dst;\n       link = &dst->next;\n     }\n \n   *link = NULL;\n+}\n+\n+/* Attempt to locate a previously saved scope.  Returns NULL if no\n+   corresponding saved scope was found.  */\n+\n+static struct d_saved_scope *\n+d_get_saved_scope (struct d_print_info *dpi,\n+\t\t   const struct demangle_component *container)\n+{\n+  int i;\n \n-  return result;\n+  for (i = 0; i < dpi->next_saved_scope; i++)\n+    if (dpi->saved_scopes[i].container == container)\n+      return &dpi->saved_scopes[i];\n+\n+  return NULL;\n }\n \n /* Subroutine to handle components.  */\n@@ -4492,37 +4658,16 @@ d_print_comp (struct d_print_info *dpi, int options,\n \tconst struct demangle_component *sub = d_left (dc);\n \tif (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n \t  {\n+\t    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);\n \t    struct demangle_component *a;\n-\t    struct d_saved_scope *scope = NULL, *scopes;\n-\t    int i;\n-\n-\t    for (i = 0; i < dpi->num_saved_scopes; i++)\n-\t      if (dpi->saved_scopes[i].container == sub)\n-\t\tscope = &dpi->saved_scopes[i];\n \n \t    if (scope == NULL)\n \t      {\n-\t\tsize_t size;\n-\n \t\t/* This is the first time SUB has been traversed.\n \t\t   We need to capture the current templates so\n \t\t   they can be restored if SUB is reentered as a\n \t\t   substitution.  */\n-\t\t++dpi->num_saved_scopes;\n-\t\tsize = sizeof (struct d_saved_scope) * dpi->num_saved_scopes;\n-\t\tscopes = (struct d_saved_scope *) realloc (dpi->saved_scopes,\n-\t\t\t\t\t\t\t   size);\n-\t\tif (scopes == NULL)\n-\t\t  {\n-\t\t    d_print_error (dpi);\n-\t\t    return;\n-\t\t  }\n-\n-\t\tdpi->saved_scopes = scopes;\n-\t\tscope = dpi->saved_scopes + (dpi->num_saved_scopes - 1);\n-\n-\t\tscope->container = sub;\n-\t\tscope->templates = d_copy_templates (dpi);\n+\t\td_save_scope (dpi, sub);\n \t\tif (d_print_saw_error (dpi))\n \t\t  return;\n \t      }"}]}