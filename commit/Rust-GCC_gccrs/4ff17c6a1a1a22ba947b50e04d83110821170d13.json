{"sha": "4ff17c6a1a1a22ba947b50e04d83110821170d13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZmMTdjNmExYTFhMjJiYTk0N2I1MGUwNGQ4MzExMDgyMTE3MGQxMw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2001-03-23T14:16:33Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2001-03-23T14:16:33Z"}, "message": "gcj.texi (Configure-time Options): Add -fcheck-references.\n\n2001-02-07  Andrew Haley  <aph@redhat.com>\n\n        * gcj.texi (Configure-time Options): Add -fcheck-references.\n        * expr.c (build_java_indirect_ref): New function.\n        (build_java_array_length_access): Use build_java_indirect_ref to\n        check for null references.\n        (build_java_arrayaccess): Likewise.\n        (build_get_class): Likewise.\n        (build_field_ref): Likewise.\n        (invoke_build_dtable): Likewise.\n        (build_invokeinterface): Likewise.\n        * lang.c (lang_f_options): Add flag_check_references.\n        * jvspec.c (jvgenmain_spec): Add flag_check_references.\n        * java-tree.h (flag_check_references): New variable.\n        * lang.c (flag_check_references): Likewise.\n\nFrom-SVN: r40780", "tree": {"sha": "08a50666c0e7391b2df66372456f9a01f3b4e195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08a50666c0e7391b2df66372456f9a01f3b4e195"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ff17c6a1a1a22ba947b50e04d83110821170d13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ff17c6a1a1a22ba947b50e04d83110821170d13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ff17c6a1a1a22ba947b50e04d83110821170d13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ff17c6a1a1a22ba947b50e04d83110821170d13/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e4ce833ab3f109b5d344a84d0659a895aa8c603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4ce833ab3f109b5d344a84d0659a895aa8c603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e4ce833ab3f109b5d344a84d0659a895aa8c603"}], "stats": {"total": 138, "additions": 86, "deletions": 52}, "files": [{"sha": "5ad64eed6096df2f622d02edb9ef07a0be849eae", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4ff17c6a1a1a22ba947b50e04d83110821170d13", "patch": "@@ -1,3 +1,19 @@\n+2001-02-07  Andrew Haley  <aph@redhat.com>\n+\n+\t* gcj.texi (Configure-time Options): Add -fcheck-references.\n+\t* expr.c (build_java_indirect_ref): New function.\n+\t(build_java_array_length_access): Use build_java_indirect_ref to\n+\tcheck for null references.\n+\t(build_java_arrayaccess): Likewise.\n+\t(build_get_class): Likewise.\n+\t(build_field_ref): Likewise.\n+\t(invoke_build_dtable): Likewise.\n+\t(build_invokeinterface): Likewise.\n+\t* lang.c (lang_f_options): Add flag_check_references.\n+\t* jvspec.c (jvgenmain_spec): Add flag_check_references.\n+\t* java-tree.h (flag_check_references): New variable.\n+\t* lang.c (flag_check_references): Likewise.\n+\n 2001-03-23  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* gjavah.c (cxx_keywords): Update from the definitive list in cp/lex.c."}, {"sha": "8be7f7d8cc1c27fe115b79bcd1e6dd8ccb37a21f", "filename": "gcc/java/expr.c", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=4ff17c6a1a1a22ba947b50e04d83110821170d13", "patch": "@@ -710,36 +710,46 @@ build_java_array_length_access (node)\n   length = java_array_type_length (type);\n   if (length >= 0)\n     return build_int_2 (length, 0);\n-\n-  return fold (build1 (INDIRECT_REF,\n-\t\t       int_type_node,\n+  return fold (build1 (INDIRECT_REF, int_type_node,\n \t\t       fold (build (PLUS_EXPR, ptr_type_node,\n-\t\t\t\t    node, \n+\t\t\t\t    java_check_reference (node, 1), \n \t\t\t\t    JAVA_ARRAY_LENGTH_OFFSET(node)))));\n }\n \n-/* Optionally checks an array against the NULL pointer, eventually throwing a\n-   NullPointerException. It could replace signal handling, but tied to NULL.\n-   ARG1: the pointer to check, ARG2: the expression to use if\n-   the pointer is non-null and ARG3 the type that should be returned.   */\n+/* Optionally checks a reference against the NULL pointer.  ARG1: the\n+   expr, ARG2: we should check the reference.  Don't generate extra\n+   checks if we're not generating code.  */\n+\n+tree \n+java_check_reference (expr, check)\n+     tree expr;\n+     int check;\n+{\n+  if (!flag_syntax_only && check)\n+    {\n+      tree cond;\n+      expr = save_expr (expr);\n+      cond = build (COND_EXPR, void_type_node,\n+\t\t    build (EQ_EXPR, boolean_type_node, expr, null_pointer_node),\n+\t\t    build (CALL_EXPR, void_type_node, \n+\t\t\t   build_address_of (soft_nullpointer_node),\n+\t\t\t   NULL_TREE, NULL_TREE),\n+\t\t    empty_stmt_node);\n+      expr = build (COMPOUND_EXPR, TREE_TYPE (expr), cond, expr);\n+    }\n+\n+  return expr;\n+}\n+\n+/* Reference an object: just like an INDIRECT_REF, but with checking.  */\n \n tree\n-build_java_arraynull_check (node, expr, type)\n-    tree node ATTRIBUTE_UNUSED;\n-    tree expr;\n-    tree type ATTRIBUTE_UNUSED;\n+build_java_indirect_ref (type, expr, check)\n+     tree type;\n+     tree expr;\n+     int check;\n {\n-#if 0\n-  static int java_array_access_throws_null_exception = 0;\n-  node = ???;\n-  if (java_array_access_throws_null_exception)\n-      return (build (COND_EXPR, \n-\t\t     type,\n-\t\t     build (EQ_EXPR, int_type_node, node, null_pointer_node),\n-\t\t     build_java_athrow (node), expr ));\n-  else\n-#endif\n-      return (expr);\n+  return build1 (INDIRECT_REF, type, java_check_reference (expr, check));\n }\n \n static tree\n@@ -792,15 +802,15 @@ build_java_arrayaccess (array, type, index)\n \t  TREE_SIDE_EFFECTS( throw ) = 1;\n \t}\n     }\n-\n+  \n   node = build1 (INDIRECT_REF, type, \n \t\t fold (build (PLUS_EXPR, ptr_type_node, \n-\t\t\t      array, \n+\t\t\t      java_check_reference (array, flag_check_references), \n \t\t\t      (throw ? build (COMPOUND_EXPR, int_type_node, \n \t\t\t\t\t      throw, arith )\n \t\t\t             : arith))));\n-\n-  return (fold (build_java_arraynull_check (array, node, type)));\n+  \n+  return node;\n }\n \n /* Makes sure that INDEXED_TYPE is appropriate. If not, make it from\n@@ -1008,7 +1018,7 @@ expand_java_array_length ()\n   tree array  = pop_value (ptr_type_node);\n   tree length = build_java_array_length_access (array);\n \n-  push_value (build_java_arraynull_check (array, length, int_type_node));\n+  push_value (length);\n }\n \n /* Emit code for the call to _Jv_Monitor{Enter,Exit}. CALL can be\n@@ -1118,7 +1128,8 @@ build_get_class (value)\n   return build (COMPONENT_REF, class_ptr_type,\n \t\tbuild1 (INDIRECT_REF, dtable_type,\n \t\t\tbuild (COMPONENT_REF, dtable_ptr_type,\n-\t\t\t       build1 (INDIRECT_REF, object_type_node, value),\n+\t\t\t       build_java_indirect_ref (object_type_node, value,\n+\t\t\t\t\t\t\tflag_check_references),\n \t\t\t       vtable_field)),\n \t\tclass_field);\n }\n@@ -1485,8 +1496,8 @@ build_field_ref (self_value, self_class, name)\n #ifdef JAVA_USE_HANDLES\n       self_value = unhand_expr (self_value);\n #endif\n-      self_value = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (self_value)),\n-\t\t\t   self_value);\n+      self_value = build_java_indirect_ref (TREE_TYPE (TREE_TYPE (self_value)),\n+\t\t\t\t\t    self_value, flag_check_references);\n       return fold (build (COMPONENT_REF, TREE_TYPE (field_decl),\n \t\t\t  self_value, field_decl));\n     }\n@@ -1780,7 +1791,8 @@ invoke_build_dtable (is_invoke_interface, arg_list)\n   \n   if (dtable_ident == NULL_TREE)\n     dtable_ident = get_identifier (\"vtable\");\n-  dtable = build1 (INDIRECT_REF, object_type_node, objectref );\n+  dtable = build_java_indirect_ref (object_type_node, objectref, \n+\t\t\t\t    flag_check_references);\n   dtable = build (COMPONENT_REF, dtable_ptr_type, dtable,\n \t\t  lookup_field (&object_type_node, dtable_ident));\n \n@@ -1829,7 +1841,7 @@ build_invokeinterface (dtable, method)\n       ggc_add_tree_root (&class_ident, 1);\n     }\n \n-  dtable = build1 (INDIRECT_REF, dtable_type, dtable);\n+  dtable = build_java_indirect_ref (dtable_type, dtable, flag_check_references);\n   dtable = build (COMPONENT_REF, class_ptr_type, dtable,\n \t\t  lookup_field (&dtable_type, class_ident));\n \n@@ -1875,7 +1887,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n   const char *self_name\n     = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n   tree call, func, method, arg_list, method_type;\n-  tree cond = NULL_TREE;\n+  tree check = NULL_TREE;\n \n   if (! CLASS_LOADED_P (self_type))\n     {\n@@ -1957,7 +1969,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n \t the new `self' expression once.  */\n       tree save_arg = save_expr (TREE_VALUE (arg_list));\n       TREE_VALUE (arg_list) = save_arg;\n-      cond = build (EQ_EXPR, boolean_type_node, save_arg, null_pointer_node);\n+      check = java_check_reference (save_arg, 1);\n       func = build_known_method_ref (method, method_type, self_type,\n \t\t\t\t     method_signature, arg_list);\n     }\n@@ -1974,20 +1986,9 @@ expand_invoke (opcode, method_ref_index, nargs)\n   call = build (CALL_EXPR, TREE_TYPE (method_type), func, arg_list, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n \n-  if (cond != NULL_TREE)\n-    {\n-      /* We have to make the `then' branch a compound expression to\n-\t make the types turn out right.  This seems bizarre.  */\n-      call = build (COND_EXPR, TREE_TYPE (call), cond,\n-\t\t    build (COMPOUND_EXPR, TREE_TYPE (call),\n-\t\t\t   build (CALL_EXPR, void_type_node,\n-\t\t\t\t  build_address_of (soft_nullpointer_node),\n-\t\t\t\t  NULL_TREE, NULL_TREE),\n-\t\t\t   (FLOAT_TYPE_P (TREE_TYPE (call))\n-\t\t\t    ? build_real (TREE_TYPE (call), dconst0)\n-\t\t\t    : build1 (CONVERT_EXPR, TREE_TYPE (call),\n-\t\t\t\t      integer_zero_node))),\n-\t\t    call);\n+  if (check != NULL_TREE)\n+    {\n+      call = build (COMPOUND_EXPR, TREE_TYPE (call), check, call);\n       TREE_SIDE_EFFECTS (call) = 1;\n     }\n \n@@ -2428,8 +2429,9 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t    init = init_decl;\n \t  }\n \texpand_assignment (build (COMPONENT_REF, TREE_TYPE (data_fld),\n-\t\t\t\t  build1 (INDIRECT_REF, array_type, \n-\t\t\t\t\t  array_decl), data_fld), init, 0, 0);\n+\t\t\t\t  build_java_indirect_ref (array_type, \n+\t\t\t\t\t  array_decl, flag_check_references), \n+\t\t\t\t  data_fld), init, 0, 0);\n \treturn tmp;\n       }\n     case BLOCK:"}, {"sha": "c31a92339a1c9f7afaed35116c245a1866ef1c75", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=4ff17c6a1a1a22ba947b50e04d83110821170d13", "patch": "@@ -758,6 +758,12 @@ hash table and not in the object itself.\n On some systems, a library routine is called to perform integer\n division.  This is required to get exception handling correct when\n dividing by zero.\n+\n+@item -fcheck-references\n+On some systems it's necessary to insert inline checks whenever\n+accessing an object via a reference.  On other systems you won't need\n+this because null pointer accesses are caught automatically by the\n+processor.\n @end table\n \n "}, {"sha": "6e3c979d23e3d4ad3dcb8911c1d27448e1e61576", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=4ff17c6a1a1a22ba947b50e04d83110821170d13", "patch": "@@ -181,6 +181,9 @@ extern int flag_use_boehm_gc;\n    object to its synchronization structure.  */\n extern int flag_hash_synchronization;\n \n+/* When non zero, generate checks for references to NULL.  */\n+extern int flag_check_references;\n+\n /* Encoding used for source files.  */\n extern const char *current_encoding;\n \n@@ -1010,6 +1013,8 @@ extern tree build_anewarray PARAMS ((tree, tree));\n extern tree build_new_array PARAMS ((tree, tree));\n extern tree build_java_array_length_access PARAMS ((tree));\n extern tree build_java_arraynull_check PARAMS ((tree, tree, tree));\n+extern tree build_java_indirect_ref PARAMS ((tree, tree, int));\n+extern tree java_check_reference PARAMS ((tree, int));\n extern tree build_get_class PARAMS ((tree));\n extern tree build_instanceof PARAMS ((tree, tree));\n extern tree create_label_decl PARAMS ((tree));"}, {"sha": "105f8133c56f8c530633f7262ac789455ec0c995", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=4ff17c6a1a1a22ba947b50e04d83110821170d13", "patch": "@@ -63,6 +63,7 @@ const char jvgenmain_spec[] =\n \t\t   %{<fuse-boehm-gc} %{<fhash-synchronization} %{<fjni}\\\n \t\t   %{<fclasspath*} %{<fCLASSPATH*} %{<foutput-class-dir}\\\n \t\t   %{<fuse-divide-subroutine} %{<fno-use-divide-subroutine}\\\n+\t\t   %{<fcheck-references} %{<fno-check-references}\\\n \t\t   %{f*} -fdollars-in-identifiers\\\n \t\t   %{aux-info*}\\\n \t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\"}, {"sha": "38aedc74d28ed7c6d9c1fe4bc59b7b833ee0158e", "filename": "gcc/java/lang.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff17c6a1a1a22ba947b50e04d83110821170d13/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=4ff17c6a1a1a22ba947b50e04d83110821170d13", "patch": "@@ -138,6 +138,9 @@ int flag_jni = 0;\n    file.  */\n int flag_newer = 1;\n \n+/* When non zero, generate checks for references to NULL.  */\n+int flag_check_references = 0;\n+\n /* The encoding of the source file.  */\n const char *current_encoding = NULL;\n \n@@ -164,7 +167,8 @@ lang_f_options[] =\n   {\"use-divide-subroutine\", &flag_use_divide_subroutine, 1},\n   {\"use-boehm-gc\", &flag_use_boehm_gc, 1},\n   {\"hash-synchronization\", &flag_hash_synchronization, 1},\n-  {\"jni\", &flag_jni, 1}\n+  {\"jni\", &flag_jni, 1},\n+  {\"check-references\", &flag_check_references, 1},\n };\n \n static struct string_option"}]}