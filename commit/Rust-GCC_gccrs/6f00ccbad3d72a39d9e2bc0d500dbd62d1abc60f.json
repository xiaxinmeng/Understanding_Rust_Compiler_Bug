{"sha": "6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYwMGNjYmFkM2Q3MmEzOWQ5ZTJiYzBkNTAwZGJkNjJkMWFiYzYwZg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-21T06:18:08Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-07-31T21:18:51Z"}, "message": "libstdc++: Fix and improve std::vector<bool> implementation.\n\nDo not consider allocator noexcept qualification for vector<bool> move\nconstructor.\nImprove swap performance using TBAA like in main vector implementation. Bypass\n_M_initialize_dispatch/_M_assign_dispatch in post-c++11 modes.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/stl_bvector.h\n\t[_GLIBCXX_INLINE_VERSION](_Bvector_impl_data::_M_start): Define as\n\t_Bit_type*.\n\t(_Bvector_impl_data(const _Bvector_impl_data&)): Default.\n\t(_Bvector_impl_data(_Bvector_impl_data&&)): Delegate to latter.\n\t(_Bvector_impl_data::operator=(const _Bvector_impl_data&)): Default.\n\t(_Bvector_impl_data::_M_move_data(_Bvector_impl_data&&)): Use latter.\n\t(_Bvector_impl_data::_M_reset()): Likewise.\n\t(_Bvector_impl_data::_M_swap_data): New.\n\t(_Bvector_impl::_Bvector_impl(_Bvector_impl&&)): Implement explicitely.\n\t(_Bvector_impl::_Bvector_impl(_Bit_alloc_type&&, _Bvector_impl&&)): New.\n\t(_Bvector_base::_Bvector_base(_Bvector_base&&, const allocator_type&)):\n\tNew, use latter.\n\t(vector::vector(vector&&, const allocator_type&, true_type)): New, use\n\tlatter.\n\t(vector::vector(vector&&, const allocator_type&, false_type)): New.\n\t(vector::vector(vector&&, const allocator_type&)): Use latters.\n\t(vector::vector(const vector&, const allocator_type&)): Adapt.\n\t[__cplusplus >= 201103](vector::vector(_InputIt, _InputIt,\n\tconst allocator_type&)): Use _M_initialize_range.\n\t(vector::operator[](size_type)): Use iterator operator[].\n\t(vector::operator[](size_type) const): Use const_iterator operator[].\n\t(vector::swap(vector&)): Add assertions on allocators. Use _M_swap_data.\n\t[__cplusplus >= 201103](vector::insert(const_iterator, _InputIt,\n\t_InputIt)): Use _M_insert_range.\n\t(vector::_M_initialize(size_type)): Adapt.\n\t[__cplusplus >= 201103](vector::_M_initialize_dispatch): Remove.\n\t[__cplusplus >= 201103](vector::_M_insert_dispatch): Remove.\n\t* python/libstdcxx/v6/printers.py (StdVectorPrinter._iterator): Stop\n\tusing start _M_offset.\n\t(StdVectorPrinter.to_string): Likewise.\n\t* testsuite/23_containers/vector/bool/allocator/swap.cc: Adapt.\n\t* testsuite/23_containers/vector/bool/cons/noexcept_move_construct.cc:\n\tAdd check.", "tree": {"sha": "b2a62ce2dc25793f4794a971c1073f6ae9eabd6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2a62ce2dc25793f4794a971c1073f6ae9eabd6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/comments", "author": null, "committer": null, "parents": [{"sha": "5f9669d9e23a1116e040c80e0f3d4f43639bda52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9669d9e23a1116e040c80e0f3d4f43639bda52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f9669d9e23a1116e040c80e0f3d4f43639bda52"}], "stats": {"total": 199, "additions": 130, "deletions": 69}, "files": [{"sha": "d6f5435bdfb7c0eed7673beffdef37c7ba1c7d50", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 87, "deletions": 53, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "patch": "@@ -427,53 +427,75 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       struct _Bvector_impl_data\n       {\n-\t_Bit_iterator \t_M_start;\n-\t_Bit_iterator \t_M_finish;\n-\t_Bit_pointer \t_M_end_of_storage;\n+#if !_GLIBCXX_INLINE_VERSION\n+\t_Bit_iterator\t_M_start;\n+#else\n+\t// We don't need the offset field for the start, it's always zero.\n+\tstruct {\n+\t  _Bit_type* _M_p;\n+\t  // Allow assignment from iterators (assume offset is zero):\n+\t  void operator=(_Bit_iterator __it) { _M_p = __it._M_p; }\n+\t} _M_start;\n+#endif\n+\t_Bit_iterator\t_M_finish;\n+\t_Bit_pointer\t_M_end_of_storage;\n \n \t_Bvector_impl_data() _GLIBCXX_NOEXCEPT\n \t: _M_start(), _M_finish(), _M_end_of_storage()\n \t{ }\n \n #if __cplusplus >= 201103L\n+\t_Bvector_impl_data(const _Bvector_impl_data&) = default;\n+\t_Bvector_impl_data&\n+\toperator=(const _Bvector_impl_data&) = default;\n+\n \t_Bvector_impl_data(_Bvector_impl_data&& __x) noexcept\n-\t: _M_start(__x._M_start), _M_finish(__x._M_finish)\n-\t, _M_end_of_storage(__x._M_end_of_storage)\n+\t: _Bvector_impl_data(__x)\n \t{ __x._M_reset(); }\n \n \tvoid\n \t_M_move_data(_Bvector_impl_data&& __x) noexcept\n \t{\n-\t  this->_M_start = __x._M_start;\n-\t  this->_M_finish = __x._M_finish;\n-\t  this->_M_end_of_storage = __x._M_end_of_storage;\n+\t  *this = __x;\n \t  __x._M_reset();\n \t}\n #endif\n \n \tvoid\n \t_M_reset() _GLIBCXX_NOEXCEPT\n+\t{ *this = _Bvector_impl_data(); }\n+\n+\tvoid\n+\t_M_swap_data(_Bvector_impl_data& __x) _GLIBCXX_NOEXCEPT\n \t{\n-\t  _M_start = _M_finish = _Bit_iterator();\n-\t  _M_end_of_storage = _Bit_pointer();\n+\t  // Do not use std::swap(_M_start, __x._M_start), etc as it loses\n+\t  // information used by TBAA.\n+\t  std::swap(*this, __x);\n \t}\n       };\n \n       struct _Bvector_impl\n \t: public _Bit_alloc_type, public _Bvector_impl_data\n-\t{\n-\tpublic:\n-\t  _Bvector_impl() _GLIBCXX_NOEXCEPT_IF(\n-\t\tis_nothrow_default_constructible<_Bit_alloc_type>::value)\n-\t  : _Bit_alloc_type()\n-\t  { }\n+      {\n+\t_Bvector_impl() _GLIBCXX_NOEXCEPT_IF(\n+\t  is_nothrow_default_constructible<_Bit_alloc_type>::value)\n+\t: _Bit_alloc_type()\n+\t{ }\n \n-\t  _Bvector_impl(const _Bit_alloc_type& __a) _GLIBCXX_NOEXCEPT\n-\t  : _Bit_alloc_type(__a)\n-\t  { }\n+\t_Bvector_impl(const _Bit_alloc_type& __a) _GLIBCXX_NOEXCEPT\n+\t: _Bit_alloc_type(__a)\n+\t{ }\n \n #if __cplusplus >= 201103L\n-\t_Bvector_impl(_Bvector_impl&&) = default;\n+\t// Not defaulted, to enforce noexcept(true) even when\n+\t// !is_nothrow_move_constructible<_Bit_alloc_type>.\n+\t_Bvector_impl(_Bvector_impl&& __x) noexcept\n+\t: _Bit_alloc_type(std::move(__x)), _Bvector_impl_data(std::move(__x))\n+\t{ }\n+\n+\t_Bvector_impl(_Bit_alloc_type&& __a, _Bvector_impl&& __x) noexcept\n+\t: _Bit_alloc_type(std::move(__a)), _Bvector_impl_data(std::move(__x))\n+\t{ }\n #endif\n \n \t_Bit_type*\n@@ -511,6 +533,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n #if __cplusplus >= 201103L\n       _Bvector_base(_Bvector_base&&) = default;\n+\n+      _Bvector_base(_Bvector_base&& __x, const allocator_type& __a) noexcept\n+      : _M_impl(_Bit_alloc_type(__a), std::move(__x._M_impl))\n+      { }\n #endif\n \n       ~_Bvector_base()\n@@ -647,14 +673,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))\n       {\n \t_M_initialize(__x.size());\n-\t_M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n+\t_M_copy_aligned(__x.begin(), __x.end(), begin());\n       }\n \n #if __cplusplus >= 201103L\n       vector(vector&&) = default;\n \n-      vector(vector&& __x, const allocator_type& __a)\n-      noexcept(_Bit_alloc_traits::_S_always_equal())\n+    private:\n+      vector(vector&& __x, const allocator_type& __a, true_type) noexcept\n+      : _Base(std::move(__x), __a)\n+      { }\n+\n+      vector(vector&& __x, const allocator_type& __a, false_type)\n       : _Base(__a)\n       {\n \tif (__x.get_allocator() == __a)\n@@ -667,11 +697,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  }\n       }\n \n+    public:\n+      vector(vector&& __x, const allocator_type& __a)\n+      noexcept(_Bit_alloc_traits::_S_always_equal())\n+      : vector(std::move(__x), __a,\n+\t       typename _Bit_alloc_traits::is_always_equal{})\n+      { }\n+\n       vector(const vector& __x, const allocator_type& __a)\n       : _Base(__a)\n       {\n \t_M_initialize(__x.size());\n-\t_M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n+\t_M_copy_aligned(__x.begin(), __x.end(), begin());\n       }\n \n       vector(initializer_list<bool> __l,\n@@ -689,13 +726,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tvector(_InputIterator __first, _InputIterator __last,\n \t       const allocator_type& __a = allocator_type())\n \t: _Base(__a)\n-\t{ _M_initialize_dispatch(__first, __last, __false_type()); }\n+\t{\n+\t  _M_initialize_range(__first, __last,\n+\t\t\t      std::__iterator_category(__first));\n+\t}\n #else\n       template<typename _InputIterator>\n \tvector(_InputIterator __first, _InputIterator __last,\n \t       const allocator_type& __a = allocator_type())\n \t: _Base(__a)\n \t{\n+\t  // Check whether it's an integral type. If so, it's not an iterator.\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_initialize_dispatch(__first, __last, _Integral());\n \t}\n@@ -762,7 +803,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       vector&\n       operator=(initializer_list<bool> __l)\n       {\n-\tthis->assign (__l.begin(), __l.end());\n+\tthis->assign(__l.begin(), __l.end());\n \treturn *this;\n       }\n #endif\n@@ -786,6 +827,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tvoid\n \tassign(_InputIterator __first, _InputIterator __last)\n \t{\n+\t  // Check whether it's an integral type. If so, it's not an iterator.\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_assign_dispatch(__first, __last, _Integral());\n \t}\n@@ -874,17 +916,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       reference\n       operator[](size_type __n)\n-      {\n-\treturn *iterator(this->_M_impl._M_start._M_p\n-\t\t\t + __n / int(_S_word_bit), __n % int(_S_word_bit));\n-      }\n+      { return begin()[__n]; }\n \n       const_reference\n       operator[](size_type __n) const\n-      {\n-\treturn *const_iterator(this->_M_impl._M_start._M_p\n-\t\t\t     + __n / int(_S_word_bit), __n % int(_S_word_bit));\n-      }\n+      { return begin()[__n]; }\n \n     protected:\n       void\n@@ -951,10 +987,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       void\n       swap(vector& __x) _GLIBCXX_NOEXCEPT\n       {\n-\tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n-\tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n-\tstd::swap(this->_M_impl._M_end_of_storage,\n-\t\t  __x._M_impl._M_end_of_storage);\n+#if __cplusplus >= 201103L\n+\t__glibcxx_assert(_Bit_alloc_traits::propagate_on_container_swap::value\n+\t\t\t || _M_get_Bit_allocator() == __x._M_get_Bit_allocator());\n+#endif\n+\tthis->_M_impl._M_swap_data(__x._M_impl);\n \t_Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),\n \t\t\t\t      __x._M_get_Bit_allocator());\n       }\n@@ -992,8 +1029,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t       _InputIterator __first, _InputIterator __last)\n \t{\n \t  difference_type __offset = __position - cbegin();\n-\t  _M_insert_dispatch(__position._M_const_cast(),\n-\t\t\t     __first, __last, __false_type());\n+\t  _M_insert_range(__position._M_const_cast(),\n+\t\t\t  __first, __last,\n+\t\t\t  std::__iterator_category(__first));\n \t  return begin() + __offset;\n \t}\n #else\n@@ -1002,6 +1040,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tinsert(iterator __position,\n \t       _InputIterator __first, _InputIterator __last)\n \t{\n+\t  // Check whether it's an integral type. If so, it's not an iterator.\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_insert_dispatch(__position, __first, __last, _Integral());\n \t}\n@@ -1113,15 +1152,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  {\n \t    _Bit_pointer __q = this->_M_allocate(__n);\n \t    this->_M_impl._M_end_of_storage = __q + _S_nword(__n);\n-\t    this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);\n+\t    iterator __start = iterator(std::__addressof(*__q), 0);\n+\t    this->_M_impl._M_start = __start;\n+\t    this->_M_impl._M_finish = __start + difference_type(__n);\n \t  }\n-\telse\n-\t  {\n-\t    this->_M_impl._M_end_of_storage = _Bit_pointer();\n-\t    this->_M_impl._M_start = iterator(0, 0);\n-\t  }\n-\tthis->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);\n-\n       }\n \n       void\n@@ -1141,8 +1175,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_shrink_to_fit();\n #endif\n \n-      // Check whether it's an integral type.  If so, it's not an iterator.\n-\n+#if __cplusplus < 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n@@ -1159,6 +1192,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t       __false_type)\n \t{ _M_initialize_range(__first, __last,\n \t\t\t      std::__iterator_category(__first)); }\n+#endif\n \n       template<typename _InputIterator>\n \tvoid\n@@ -1176,7 +1210,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t{\n \t  const size_type __n = std::distance(__first, __last);\n \t  _M_initialize(__n);\n-\t  std::copy(__first, __last, this->_M_impl._M_start);\n+\t  std::copy(__first, __last, begin());\n \t}\n \n #if __cplusplus < 201103L\n@@ -1240,8 +1274,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    }\n \t}\n \n-      // Check whether it's an integral type.  If so, it's not an iterator.\n-\n+#if __cplusplus < 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n@@ -1257,6 +1290,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t   __false_type)\n \t{ _M_insert_range(__pos, __first, __last,\n \t\t\t  std::__iterator_category(__first)); }\n+#endif\n \n       void\n       _M_fill_insert(iterator __position, size_type __n, bool __x);"}, {"sha": "0bf307b8e5f78c29feb028cc96f0c45bdbe9c0b5", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "patch": "@@ -405,7 +405,7 @@ def __init__ (self, start, finish, bitvec):\n             self.bitvec = bitvec\n             if bitvec:\n                 self.item   = start['_M_p']\n-                self.so     = start['_M_offset']\n+                self.so     = 0\n                 self.finish = finish['_M_p']\n                 self.fo     = finish['_M_offset']\n                 itype = self.item.dereference().type\n@@ -453,12 +453,11 @@ def to_string(self):\n         end = self.val['_M_impl']['_M_end_of_storage']\n         if self.is_bool:\n             start = self.val['_M_impl']['_M_start']['_M_p']\n-            so    = self.val['_M_impl']['_M_start']['_M_offset']\n             finish = self.val['_M_impl']['_M_finish']['_M_p']\n             fo     = self.val['_M_impl']['_M_finish']['_M_offset']\n             itype = start.dereference().type\n             bl = 8 * itype.sizeof\n-            length   = (bl - so) + bl * ((finish - start) - 1) + fo\n+            length   = bl * (finish - start) + fo\n             capacity = bl * (end - start)\n             return ('%s<bool> of length %d, capacity %d'\n                     % (self.typename, int (length), int (capacity)))"}, {"sha": "793115b473ee1b51b07c88b4d3512be77995c4c8", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/swap.cc", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fswap.cc?ref=6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "patch": "@@ -28,19 +28,17 @@ namespace __gnu_test\n   // It is undefined behaviour to swap() containers with unequal allocators\n   // if the allocator doesn't propagate, so ensure the allocators compare\n   // equal, while still being able to test propagation via get_personality().\n-  bool\n-  operator==(const propagating_allocator<T, false>&,\n-\t     const propagating_allocator<T, false>&)\n-  {\n-    return true;\n-  }\n+  template<typename Type>\n+    bool\n+    operator==(const propagating_allocator<Type, false>&,\n+\t       const propagating_allocator<Type, false>&)\n+    { return true; }\n \n-  bool\n-  operator!=(const propagating_allocator<T, false>&,\n-\t     const propagating_allocator<T, false>&)\n-  {\n-    return false;\n-  }\n+  template<typename Type>\n+    bool\n+    operator!=(const propagating_allocator<Type, false>&,\n+\t       const propagating_allocator<Type, false>&)\n+    { return false; }\n }\n \n using __gnu_test::propagating_allocator;"}, {"sha": "296ba33bba843af0b09e6940d66512db20e2fff1", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/cons/noexcept_move_construct.cc", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcons%2Fnoexcept_move_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcons%2Fnoexcept_move_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcons%2Fnoexcept_move_construct.cc?ref=6f00ccbad3d72a39d9e2bc0d500dbd62d1abc60f", "patch": "@@ -23,4 +23,34 @@\n \n typedef std::vector<bool> vbtype;\n \n-static_assert(std::is_nothrow_move_constructible<vbtype>::value, \"Error\");\n+static_assert( std::is_nothrow_move_constructible<vbtype>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( std::is_nothrow_constructible<vbtype,\n+\t       vbtype&&, const typename vbtype::allocator_type&>::value,\n+\t       \"noexcept move constructor with allocator\" );\n+\n+template<typename Type>\n+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>\n+  {\n+  public:\n+    not_noexcept_move_constructor_alloc() noexcept { }\n+\n+    not_noexcept_move_constructor_alloc(\n+\tconst not_noexcept_move_constructor_alloc& x) noexcept\n+    : std::allocator<Type>(x)\n+    { }\n+\n+    not_noexcept_move_constructor_alloc(\n+\tnot_noexcept_move_constructor_alloc&& x) noexcept(false)\n+    : std::allocator<Type>(std::move(x))\n+    { }\n+\n+    template<typename _Tp1>\n+      struct rebind\n+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };\n+  };\n+\n+typedef std::vector<bool, not_noexcept_move_constructor_alloc<bool>> vbtype2;\n+\n+static_assert( std::is_nothrow_move_constructible<vbtype2>::value,\n+\t       \"noexcept move constructor with not noexcept alloc\" );"}]}