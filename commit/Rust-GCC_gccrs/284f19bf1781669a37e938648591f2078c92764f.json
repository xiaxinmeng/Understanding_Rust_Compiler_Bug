{"sha": "284f19bf1781669a37e938648591f2078c92764f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg0ZjE5YmYxNzgxNjY5YTM3ZTkzODY0ODU5MWYyMDc4YzkyNzY0Zg==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2003-07-15T07:02:40Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2003-07-15T07:02:40Z"}, "message": "basic_string.h: Document public functions.\n\n2003-07-15  Jerry Quinn  <jlquinn@optonline.net>\n\n        * include/bits/basic_string.h:  Document public functions.\n\t* docs/doxygen/TODO:  Update c21 todo.\n\nFrom-SVN: r69386", "tree": {"sha": "ffd25be7044595818035b6a8df5f2d3b06ce8fc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffd25be7044595818035b6a8df5f2d3b06ce8fc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/284f19bf1781669a37e938648591f2078c92764f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284f19bf1781669a37e938648591f2078c92764f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284f19bf1781669a37e938648591f2078c92764f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284f19bf1781669a37e938648591f2078c92764f/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "709e7c9f87f9d58c77f2b9595234e56b3ae9c965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/709e7c9f87f9d58c77f2b9595234e56b3ae9c965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/709e7c9f87f9d58c77f2b9595234e56b3ae9c965"}], "stats": {"total": 1194, "additions": 1191, "deletions": 3}, "files": [{"sha": "adc76a678b937f7de8bcb899e6eee784847c9f22", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284f19bf1781669a37e938648591f2078c92764f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284f19bf1781669a37e938648591f2078c92764f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=284f19bf1781669a37e938648591f2078c92764f", "patch": "@@ -1,3 +1,8 @@\n+2003-07-15  Jerry Quinn  <jlquinn@optonline.net>\n+\n+        * include/bits/basic_string.h:  Document public functions.\n+\t* docs/doxygen/TODO:  Update c21 todo.\n+\n 2003-07-15  Jerry Quinn  <jlquinn@optonline.net>\n \n \t* include/bits/stl_list.h:  Document more functions."}, {"sha": "b32b2b1a0fe44b6eb0ed86efa175417b9c19f98a", "filename": "libstdc++-v3/docs/doxygen/TODO", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284f19bf1781669a37e938648591f2078c92764f/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284f19bf1781669a37e938648591f2078c92764f/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO?ref=284f19bf1781669a37e938648591f2078c92764f", "patch": "@@ -22,8 +22,7 @@ c17             FINISHED (Nothing in Clause 17 \"exists\" in terms of code.)\n c18             FINISHED, Note A\n c19             Note A\n c20             Note A\n-c21             Untouched (top-level class note for basic_string done),\n-                Note B\n+c21             Public functions basic_string done, Note B\n c22             Untouched; see docs/html/22_locale/*\n c23             See doxygroups.cc and Note B.  Notes on what invalidates\n                 iterators need to be added."}, {"sha": "1a534a15b6506c57eeb9cdb1466e12a51da42048", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 1185, "deletions": 1, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284f19bf1781669a37e938648591f2078c92764f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284f19bf1781669a37e938648591f2078c92764f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=284f19bf1781669a37e938648591f2078c92764f", "patch": "@@ -248,6 +248,8 @@ namespace std\n       // Data Members (public):\n       // NB: This is an unsigned type, and thus represents the maximum\n       // size that the allocator can hold.\n+      /// @var\n+      /// Value returned by various member functions when they fail.\n       static const size_type \tnpos = static_cast<size_type>(-1);\n \n     private:\n@@ -339,120 +341,302 @@ namespace std\n       // NB: We overload ctors in some cases instead of using default\n       // arguments, per 17.4.4.4 para. 2 item 2.\n \n+      /**\n+       *  @brief  Default constructor creates an empty string.\n+       */\n       inline\n       basic_string();\n \n+      /**\n+       *  @brief  Construct an empty string using allocator a.\n+       */\n       explicit\n       basic_string(const _Alloc& __a);\n \n       // NB: per LWG issue 42, semantics different from IS:\n+      /**\n+       *  @brief  Construct string with copy of value of @a str.\n+       *  @param  str  Source string.\n+       */\n       basic_string(const basic_string& __str);\n+      /**\n+       *  @brief  Construct string as copy of a substring.\n+       *  @param  str  Source string.\n+       *  @param  pos  Index of first character to copy from.\n+       *  @param  n  Number of characters to copy (default remainder).\n+       */\n       basic_string(const basic_string& __str, size_type __pos,\n \t\t   size_type __n = npos);\n+      /**\n+       *  @brief  Construct string as copy of a substring.\n+       *  @param  str  Source string.\n+       *  @param  pos  Index of first character to copy from.\n+       *  @param  n  Number of characters to copy.\n+       *  @param  a  Allocator to use.\n+       */\n       basic_string(const basic_string& __str, size_type __pos,\n \t\t   size_type __n, const _Alloc& __a);\n \n+      /**\n+       *  @brief  Construct string as copy of a C substring.\n+       *  @param  s  Source C string.\n+       *  @param  n  Number of characters to copy.\n+       *  @param  a  Allocator to use (default is default allocator).\n+       */\n       basic_string(const _CharT* __s, size_type __n,\n \t\t   const _Alloc& __a = _Alloc());\n+      /**\n+       *  @brief  Construct string as copy of a C string.\n+       *  @param  s  Source C string.\n+       *  @param  a  Allocator to use (default is default allocator).\n+       */\n       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());\n+      /**\n+       *  @brief  Construct string as multiple characters.\n+       *  @param  n  Number of characters.\n+       *  @param  c  Character to use.\n+       *  @param  a  Allocator to use (default is default allocator).\n+       */\n       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());\n \n+      /**\n+       *  @brief  Construct string as copy of a range.\n+       *  @param  beg  Start of range.\n+       *  @param  end  End of range.\n+       *  @param  a  Allocator to use (default is default allocator).\n+       */\n       template<class _InputIterator>\n         basic_string(_InputIterator __beg, _InputIterator __end,\n \t\t     const _Alloc& __a = _Alloc());\n \n+      /**\n+       *  @brief  Destroy the string instance.\n+       */\n       ~basic_string()\n       { _M_rep()->_M_dispose(this->get_allocator()); }\n \n+      /**\n+       *  @brief  Assign the value of @a str to this string.\n+       *  @param  str  Source string.\n+       */\n       basic_string&\n       operator=(const basic_string& __str) { return this->assign(__str); }\n \n+      /**\n+       *  @brief  Copy contents of @a s into this string.\n+       *  @param  s  Source null-terminated string.\n+       */\n       basic_string&\n       operator=(const _CharT* __s) { return this->assign(__s); }\n \n+      /**\n+       *  @brief  Set value to string of length 1.\n+       *  @param  c  Source character.\n+       *\n+       *  Assigning to a character makes this string length 1 and\n+       *  (*this)[0] == @a c.\n+       */\n       basic_string&\n       operator=(_CharT __c) { return this->assign(1, __c); }\n \n       // Iterators:\n+      /**\n+       *  Returns a read/write iterator that points to the first character in\n+       *  the %string.  Unshares the string.\n+       */\n       iterator\n       begin()\n       {\n \t_M_leak();\n \treturn iterator(_M_data());\n       }\n \n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  character in the %string.\n+       */\n       const_iterator\n       begin() const\n       { return const_iterator(_M_data()); }\n \n+      /**\n+       *  Returns a read/write iterator that points one past the last\n+       *  character in the %string.  Unshares the string.\n+       */\n       iterator\n       end()\n       {\n \t_M_leak();\n \treturn iterator(_M_data() + this->size());\n       }\n \n+      /**\n+       *  Returns a read-only (constant) iterator that points one past the\n+       *  last character in the %string.\n+       */\n       const_iterator\n       end() const\n       { return const_iterator(_M_data() + this->size()); }\n \n+      /**\n+       *  Returns a read/write reverse iterator that points to the last\n+       *  character in the %string.  Iteration is done in reverse element\n+       *  order.  Unshares the string.\n+       */\n       reverse_iterator\n       rbegin()\n       { return reverse_iterator(this->end()); }\n \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points\n+       *  to the last character in the %string.  Iteration is done in\n+       *  reverse element order.\n+       */\n       const_reverse_iterator\n       rbegin() const\n       { return const_reverse_iterator(this->end()); }\n \n+      /**\n+       *  Returns a read/write reverse iterator that points to one before the\n+       *  first character in the %string.  Iteration is done in reverse\n+       *  element order.  Unshares the string.\n+       */\n       reverse_iterator\n       rend()\n       { return reverse_iterator(this->begin()); }\n \n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points\n+       *  to one before the first character in the %string.  Iteration\n+       *  is done in reverse element order.\n+       */\n       const_reverse_iterator\n       rend() const\n       { return const_reverse_iterator(this->begin()); }\n \n     public:\n       // Capacity:\n+      ///  Returns the number of characters in the string, not including any\n+      ///  null-termination.\n       size_type\n       size() const { return _M_rep()->_M_length; }\n \n+      ///  Returns the number of characters in the string, not including any\n+      ///  null-termination.\n       size_type\n       length() const { return _M_rep()->_M_length; }\n \n+      /// Returns the size() of the largest possible %string.\n       size_type\n       max_size() const { return _Rep::_S_max_size; }\n \n+      /**\n+       *  @brief  Resizes the %string to the specified number of characters.\n+       *  @param  n  Number of characters the %string should contain.\n+       *  @param  c  Character to fill any new elements.\n+       *\n+       *  This function will %resize the %string to the specified\n+       *  number of characters.  If the number is smaller than the\n+       *  %string's current size the %string is truncated, otherwise\n+       *  the %string is extended and new elements are set to @a c.\n+       */\n       void\n       resize(size_type __n, _CharT __c);\n \n+      /**\n+       *  @brief  Resizes the %string to the specified number of characters.\n+       *  @param  n  Number of characters the %string should contain.\n+       *\n+       *  This function will resize the %string to the specified length.  If\n+       *  the new size is smaller than the %string's current size the %string\n+       *  is truncated, otherwise the %string is extended and new characters\n+       *  are default-constructed.  For basic types such as char, this means\n+       *  setting them to 0.\n+       */\n       void\n       resize(size_type __n) { this->resize(__n, _CharT()); }\n \n+      /**\n+       *  Returns the total number of characters that the %string can hold\n+       *  before needing to allocate more memory.\n+       */\n       size_type\n       capacity() const { return _M_rep()->_M_capacity; }\n \n+      /**\n+       *  @brief  Attempt to preallocate enough memory for specified number of\n+       *          characters.\n+       *  @param  n  Number of characters required.\n+       *  @throw  std::length_error  If @a n exceeds @c max_size().\n+       *\n+       *  This function attempts to reserve enough memory for the\n+       *  %string to hold the specified number of characters.  If the\n+       *  number requested is more than max_size(), length_error is\n+       *  thrown.\n+       *\n+       *  The advantage of this function is that if optimal code is a\n+       *  necessity and the user can determine the string length that will be\n+       *  required, the user can reserve the memory in %advance, and thus\n+       *  prevent a possible reallocation of memory and copying of %string\n+       *  data.\n+       */\n       void\n       reserve(size_type __res_arg = 0);\n \n+      /**\n+       *  Erases the string, making it empty.\n+       */\n       void\n       clear() { _M_mutate(0, this->size(), 0); }\n \n+      /**\n+       *  Returns true if the %string is empty.  Equivalent to *this == \"\".\n+       */\n       bool\n       empty() const { return this->size() == 0; }\n \n       // Element access:\n+      /**\n+       *  @brief  Subscript access to the data contained in the %string.\n+       *  @param  n  The index of the character to access.\n+       *  @return  Read-only (constant) reference to the character.\n+       *\n+       *  This operator allows for easy, array-style, data access.\n+       *  Note that data access with this operator is unchecked and\n+       *  out_of_range lookups are not defined. (For checked lookups\n+       *  see at().)\n+       */\n       const_reference\n       operator[] (size_type __pos) const\n       { return _M_data()[__pos]; }\n \n+      /**\n+       *  @brief  Subscript access to the data contained in the %string.\n+       *  @param  n  The index of the character to access.\n+       *  @return  Read/write reference to the character.\n+       *\n+       *  This operator allows for easy, array-style, data access.\n+       *  Note that data access with this operator is unchecked and\n+       *  out_of_range lookups are not defined. (For checked lookups\n+       *  see at().)  Unshares the string.\n+       */\n       reference\n       operator[](size_type __pos)\n       {\n \t_M_leak();\n \treturn _M_data()[__pos];\n       }\n \n+      /**\n+       *  @brief  Provides access to the data contained in the %string.\n+       *  @param n The index of the character to access.\n+       *  @return  Read-only (const) reference to the character.\n+       *  @throw  std::out_of_range  If @a n is an invalid index.\n+       *\n+       *  This function provides for safer data access.  The parameter is\n+       *  first checked that it is in the range of the string.  The function\n+       *  throws out_of_range if the check fails.\n+       */\n       const_reference\n       at(size_type __n) const\n       {\n@@ -461,6 +645,17 @@ namespace std\n \treturn _M_data()[__n];\n       }\n \n+      /**\n+       *  @brief  Provides access to the data contained in the %string.\n+       *  @param n The index of the character to access.\n+       *  @return  Read/write reference to the character.\n+       *  @throw  std::out_of_range  If @a n is an invalid index.\n+       *\n+       *  This function provides for safer data access.  The parameter is\n+       *  first checked that it is in the range of the string.  The function\n+       *  throws out_of_range if the check fails.  Success results in\n+       *  unsharing the string.\n+       */\n       reference\n       at(size_type __n)\n       {\n@@ -471,92 +666,320 @@ namespace std\n       }\n \n       // Modifiers:\n+      /**\n+       *  @brief  Append a string to this string.\n+       *  @param str  The string to append.\n+       *  @return  Reference to this string.\n+       */\n       basic_string&\n       operator+=(const basic_string& __str) { return this->append(__str); }\n \n+      /**\n+       *  @brief  Append a C string.\n+       *  @param s  The C string to append.\n+       *  @return  Reference to this string.\n+       */\n       basic_string&\n       operator+=(const _CharT* __s) { return this->append(__s); }\n \n+      /**\n+       *  @brief  Append a character.\n+       *  @param s  The character to append.\n+       *  @return  Reference to this string.\n+       */\n       basic_string&\n       operator+=(_CharT __c) { return this->append(size_type(1), __c); }\n \n+      /**\n+       *  @brief  Append a string to this string.\n+       *  @param str  The string to append.\n+       *  @return  Reference to this string.\n+       */\n       basic_string&\n       append(const basic_string& __str);\n \n+      /**\n+       *  @brief  Append a substring.\n+       *  @param str  The string to append.\n+       *  @param pos  Index of the first character of str to append.\n+       *  @param n  The number of characters to append.\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range if @a pos is not a valid index.\n+       *\n+       *  This function appends @a n characters from @a str starting at @a pos\n+       *  to this string.  If @a n is is larger than the number of available\n+       *  characters in @a str, the remainder of @a str is appended.\n+       */\n       basic_string&\n       append(const basic_string& __str, size_type __pos, size_type __n);\n \n+      /**\n+       *  @brief  Append a C substring.\n+       *  @param s  The C string to append.\n+       *  @param n  The number of characters to append.\n+       *  @return  Reference to this string.\n+       */\n       basic_string&\n       append(const _CharT* __s, size_type __n);\n \n+      /**\n+       *  @brief  Append a C string.\n+       *  @param s  The C string to append.\n+       *  @return  Reference to this string.\n+       */\n       basic_string&\n       append(const _CharT* __s)\n       { return this->append(__s, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Append multiple characters.\n+       *  @param n  The number of characters to append.\n+       *  @param c  The character to use.\n+       *  @return  Reference to this string.\n+       *\n+       *  Appends n copies of c to this string.\n+       */\n       basic_string&\n       append(size_type __n, _CharT __c);\n \n+      /**\n+       *  @brief  Append a range of characters.\n+       *  @param first  Iterator referencing the first character to append.\n+       *  @param last  Iterator marking the end of the range.\n+       *  @return  Reference to this string.\n+       *\n+       *  Appends characters in the range [first,last) to this string.\n+       */\n       template<class _InputIterator>\n         basic_string&\n         append(_InputIterator __first, _InputIterator __last)\n         { return this->replace(_M_iend(), _M_iend(), __first, __last); }\n \n+      /**\n+       *  @brief  Append a single character.\n+       *  @param c  Character to append.\n+       */\n       void\n       push_back(_CharT __c)\n       { this->replace(_M_iend(), _M_iend(), 1, __c); }\n \n+      /**\n+       *  @brief  Set value to contents of another string.\n+       *  @param  str  Source string to use.\n+       *  @return  Reference to this string.\n+       */\n       basic_string&\n       assign(const basic_string& __str);\n \n+      /**\n+       *  @brief  Set value to a substring of a string.\n+       *  @param str  The string to use.\n+       *  @param pos  Index of the first character of str.\n+       *  @param n  Number of characters to use.\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range if @a pos is not a valid index.\n+       *\n+       *  This function sets this string to the substring of @a str consisting\n+       *  of @a n characters at @a pos.  If @a n is is larger than the number\n+       *  of available characters in @a str, the remainder of @a str is used.\n+       */\n       basic_string&\n       assign(const basic_string& __str, size_type __pos, size_type __n);\n \n+      /**\n+       *  @brief  Set value to a C substring.\n+       *  @param s  The C string to use.\n+       *  @param n  Number of characters to use.\n+       *  @return  Reference to this string.\n+       *\n+       *  This function sets the value of this string to the first @a n\n+       *  characters of @a s.  If @a n is is larger than the number of\n+       *  available characters in @a s, the remainder of @a s is used.\n+       */\n       basic_string&\n       assign(const _CharT* __s, size_type __n);\n \n+      /**\n+       *  @brief  Set value to contents of a C string.\n+       *  @param s  The C string to use.\n+       *  @return  Reference to this string.\n+       *\n+       *  This function sets the value of this string to the value of @a s.\n+       *  The data is copied, so there is no dependence on @a s once the\n+       *  function returns.\n+       */\n       basic_string&\n       assign(const _CharT* __s)\n       { return this->assign(__s, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Set value to multiple characters.\n+       *  @param n  Length of the resulting string.\n+       *  @param c  The character to use.\n+       *  @return  Reference to this string.\n+       *\n+       *  This function sets the value of this string to @a n copies of\n+       *  character @a c.\n+       */\n       basic_string&\n       assign(size_type __n, _CharT __c)\n       { return this->replace(_M_ibegin(), _M_iend(), __n, __c); }\n \n+      /**\n+       *  @brief  Set value to a range of characters.\n+       *  @param first  Iterator referencing the first character to append.\n+       *  @param last  Iterator marking the end of the range.\n+       *  @return  Reference to this string.\n+       *\n+       *  Sets value of string to characters in the range [first,last).\n+      */\n       template<class _InputIterator>\n         basic_string&\n         assign(_InputIterator __first, _InputIterator __last)\n         { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\n \n+      /**\n+       *  @brief  Insert multiple characters.\n+       *  @param p  Iterator referencing location in string to insert at.\n+       *  @param n  Number of characters to insert\n+       *  @param c  The character to insert.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Inserts @a n copies of character @a c starting at the position\n+       *  referenced by iterator @a p.  If adding characters causes the length\n+       *  to exceed max_size(), length_error is thrown.  The value of the\n+       *  string doesn't change if an error is thrown.\n+      */\n       void\n       insert(iterator __p, size_type __n, _CharT __c)\n       {\tthis->replace(__p, __p, __n, __c);  }\n \n+      /**\n+       *  @brief  Insert a range of characters.\n+       *  @param p  Iterator referencing location in string to insert at.\n+       *  @param beg  Start of range.\n+       *  @param end  End of range. \n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Inserts characters in range [beg,end).  If adding characters causes\n+       *  the length to exceed max_size(), length_error is thrown.  The value\n+       *  of the string doesn't change if an error is thrown.\n+      */\n       template<class _InputIterator>\n         void insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n         { this->replace(__p, __p, __beg, __end); }\n \n+      /**\n+       *  @brief  Insert value of a string.\n+       *  @param pos1  Iterator referencing location in string to insert at.\n+       *  @param str  The string to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Inserts value of @a str starting at @a pos1.  If adding characters\n+       *  causes the length to exceed max_size(), length_error is thrown.  The\n+       *  value of the string doesn't change if an error is thrown.\n+      */\n       basic_string&\n       insert(size_type __pos1, const basic_string& __str)\n       { return this->insert(__pos1, __str, 0, __str.size()); }\n \n+      /**\n+       *  @brief  Insert a substring.\n+       *  @param pos1  Iterator referencing location in string to insert at.\n+       *  @param str  The string to insert.\n+       *  @param pos2  Start of characters in str to insert.\n+       *  @param n  Number of characters to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *  @throw  std::out_of_range  If @a pos1 > size() or\n+       *  @a pos2 > @a str.size().\n+       *\n+       *  Starting at @a pos1, insert @a n character of @a str beginning with\n+       *  @a pos2.  If adding characters causes the length to exceed\n+       *  max_size(), length_error is thrown.  If @a pos1 is beyond the end of\n+       *  this string or @a pos2 is beyond the end of @a str, out_of_range is\n+       *  thrown.  The value of the string doesn't change if an error is\n+       *  thrown.\n+      */\n       basic_string&\n       insert(size_type __pos1, const basic_string& __str,\n \t     size_type __pos2, size_type __n);\n \n+      /**\n+       *  @brief  Insert a C substring.\n+       *  @param pos  Iterator referencing location in string to insert at.\n+       *  @param s  The C string to insert.\n+       *  @param n  The number of characters to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n+       *  string. \n+       *\n+       *  Inserts the first @a n characters of @a s starting at @a pos.  If\n+       *  adding characters causes the length to exceed max_size(),\n+       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is\n+       *  thrown.  The value of the string doesn't change if an error is\n+       *  thrown.\n+      */\n       basic_string&\n       insert(size_type __pos, const _CharT* __s, size_type __n);\n \n+      /**\n+       *  @brief  Insert a C string.\n+       *  @param pos  Iterator referencing location in string to insert at.\n+       *  @param s  The C string to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n+       *  string.\n+       *\n+       *  Inserts the first @a n characters of @a s starting at @a pos.  If\n+       *  adding characters causes the length to exceed max_size(),\n+       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is\n+       *  thrown.  The value of the string doesn't change if an error is\n+       *  thrown.\n+      */\n       basic_string&\n       insert(size_type __pos, const _CharT* __s)\n       { return this->insert(__pos, __s, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Insert multiple characters.\n+       *  @param pos  Index in string to insert at.\n+       *  @param n  Number of characters to insert\n+       *  @param c  The character to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n+       *  string.\n+       *\n+       *  Inserts @a n copies of character @a c starting at index @a pos.  If\n+       *  adding characters causes the length to exceed max_size(),\n+       *  length_error is thrown.  If @a pos > length(), out_of_range is\n+       *  thrown.  The value of the string doesn't change if an error is\n+       *  thrown.\n+      */\n       basic_string&\n       insert(size_type __pos, size_type __n, _CharT __c)\n       {\n \tthis->insert(_M_check(__pos), __n, __c);\n \treturn *this;\n       }\n \n+      /**\n+       *  @brief  Insert one character.\n+       *  @param p  Iterator referencing position in string to insert at.\n+       *  @param c  The character to insert.\n+       *  @return  Iterator referencing newly inserted char.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *  @throw  std::out_of_range  If @a p is beyond the end of this string.\n+       *\n+       *  Inserts character @a c at position referenced by @a p.  If adding\n+       *  character causes the length to exceed max_size(), length_error is\n+       *  thrown.  If @a p is beyond end of string, out_of_range is thrown.\n+       *  The value of the string doesn't change if an error is thrown.\n+      */\n       iterator\n       insert(iterator __p, _CharT __c = _CharT())\n       {\n@@ -566,13 +989,38 @@ namespace std\n  \treturn this->_M_ibegin() + __pos;\n       }\n \n+      /**\n+       *  @brief  Remove characters.\n+       *  @param pos  Index of first character to remove (default 0).\n+       *  @param n  Number of characters to remove (default remainder).\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n+       *  string.\n+       *\n+       *  Removes @a n characters from this string starting at @a pos.  The\n+       *  length of the string is reduced by @a n.  If there are < @a n\n+       *  characters to remove, the remainder of the string is truncated.  If\n+       *  @a p is beyond end of string, out_of_range is thrown.  The value of\n+       *  the string doesn't change if an error is thrown.\n+      */\n       basic_string&\n       erase(size_type __pos = 0, size_type __n = npos)\n       {\n \treturn this->replace(_M_check(__pos), _M_fold(__pos, __n),\n \t\t\t     _M_data(), _M_data());\n       }\n \n+      /**\n+       *  @brief  Remove one character.\n+       *  @param position  Iterator referencing the character to remove.\n+       *  @return  iterator referencing same location after removal.\n+       *  @throw  std::out_of_range  If @a position is beyond the end of this\n+       *  string. \n+       *\n+       *  Removes the character at @a position from this string.  If @a\n+       *  position is beyond end of string, out_of_range is thrown.  The value\n+       *  of the string doesn't change if an error is thrown.\n+      */\n       iterator\n       erase(iterator __position)\n       {\n@@ -582,6 +1030,18 @@ namespace std\n \treturn _M_ibegin() + __i;\n       }\n \n+      /**\n+       *  @brief  Remove a range of characters.\n+       *  @param first  Iterator referencing the first character to remove.\n+       *  @param last  Iterator referencing the end of the range.\n+       *  @return  Iterator referencing location of first after removal.\n+       *  @throw  std::out_of_range  If @a first is beyond the end of this\n+       *  string. \n+       *\n+       *  Removes the characters in the range [first,last) from this string.\n+       *  If @a first is beyond end of string, out_of_range is thrown.  The\n+       *  value of the string doesn't change if an error is thrown.\n+      */\n       iterator\n       erase(iterator __first, iterator __last)\n       {\n@@ -591,43 +1051,193 @@ namespace std\n \treturn _M_ibegin() + __i;\n       }\n \n+      /**\n+       *  @brief  Replace characters with value from another string.\n+       *  @param pos  Index of first character to replace.\n+       *  @param n  Number of characters to be replaced.\n+       *  @param str  String to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n+       *  string. \n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [pos,pos+n) from this string.\n+       *  In place, the value of @a str is inserted.  If @a pos is beyond end\n+       *  of string, out_of_range is thrown.  If the length of the result\n+       *  exceeds max_size(), length_error is thrown.  The value of the string\n+       *  doesn't change if an error is thrown.\n+      */\n       basic_string&\n       replace(size_type __pos, size_type __n, const basic_string& __str)\n       { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n \n+      /**\n+       *  @brief  Replace characters with value from another string.\n+       *  @param pos1  Index of first character to replace.\n+       *  @param n1  Number of characters to be replaced.\n+       *  @param str  String to insert.\n+       *  @param pos2  Index of first character of str to use.\n+       *  @param n2  Number of characters from str to use.\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range  If @a pos1 > size() or @a pos2 >\n+       *  str.size(). \n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [pos1,pos1 + n) from this\n+       *  string.  In place, the value of @a str is inserted.  If @a pos is\n+       *  beyond end of string, out_of_range is thrown.  If the length of the\n+       *  result exceeds max_size(), length_error is thrown.  The value of the\n+       *  string doesn't change if an error is thrown.\n+      */\n       basic_string&\n       replace(size_type __pos1, size_type __n1, const basic_string& __str,\n \t      size_type __pos2, size_type __n2);\n \n+      /**\n+       *  @brief  Replace characters with value of a C substring.\n+       *  @param pos  Index of first character to replace.\n+       *  @param n1  Number of characters to be replaced.\n+       *  @param str  C string to insert.\n+       *  @param n2  Number of characters from str to use.\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range  If @a pos1 > size().\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [pos,pos + n1) from this string.\n+       *  In place, the first @a n2 characters of @a str are inserted, or all\n+       *  of @a str if @a n2 is too large.  If @a pos is beyond end of string,\n+       *  out_of_range is thrown.  If the length of result exceeds max_size(),\n+       *  length_error is thrown.  The value of the string doesn't change if\n+       *  an error is thrown.\n+      */\n       basic_string&\n       replace(size_type __pos, size_type __n1, const _CharT* __s,\n \t      size_type __n2);\n \n+      /**\n+       *  @brief  Replace characters with value of a C string.\n+       *  @param pos  Index of first character to replace.\n+       *  @param n1  Number of characters to be replaced.\n+       *  @param str  C string to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range  If @a pos > size().\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [pos,pos + n1) from this string.\n+       *  In place, the first @a n characters of @a str are inserted.  If @a\n+       *  pos is beyond end of string, out_of_range is thrown.  If the length\n+       *  of result exceeds max_size(), length_error is thrown.  The value of\n+       *  the string doesn't change if an error is thrown.\n+      */\n       basic_string&\n       replace(size_type __pos, size_type __n1, const _CharT* __s)\n       { return this->replace(__pos, __n1, __s, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Replace characters with multiple characters.\n+       *  @param pos  Index of first character to replace.\n+       *  @param n1  Number of characters to be replaced.\n+       *  @param n2  Number of characters to insert.\n+       *  @param c  Character to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::out_of_range  If @a pos > size().\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [pos,pos + n1) from this string.\n+       *  In place, @a n2 copies of @a c are inserted.  If @a pos is beyond\n+       *  end of string, out_of_range is thrown.  If the length of result\n+       *  exceeds max_size(), length_error is thrown.  The value of the string\n+       *  doesn't change if an error is thrown.\n+      */\n       basic_string&\n       replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n       { return this->replace(_M_check(__pos), _M_fold(__pos, __n1), __n2, __c); }\n \n+      /**\n+       *  @brief  Replace range of characters with string.\n+       *  @param i1  Iterator referencing start of range to replace.\n+       *  @param i2  Iterator referencing end of range to replace.\n+       *  @param str  String value to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [i1,i2).  In place, the value of\n+       *  @a str is inserted.  If the length of result exceeds max_size(),\n+       *  length_error is thrown.  The value of the string doesn't change if\n+       *  an error is thrown.\n+      */\n       basic_string&\n       replace(iterator __i1, iterator __i2, const basic_string& __str)\n       { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n \n+      /**\n+       *  @brief  Replace range of characters with C substring.\n+       *  @param i1  Iterator referencing start of range to replace.\n+       *  @param i2  Iterator referencing end of range to replace.\n+       *  @param s  C string value to insert.\n+       *  @param n  Number of characters from s to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [i1,i2).  In place, the first @a\n+       *  n characters of @a s are inserted.  If the length of result exceeds\n+       *  max_size(), length_error is thrown.  The value of the string doesn't\n+       *  change if an error is thrown.\n+      */\n       basic_string&\n       replace(iterator __i1, iterator __i2,\n                            const _CharT* __s, size_type __n)\n       { return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n); }\n \n+      /**\n+       *  @brief  Replace range of characters with C string.\n+       *  @param i1  Iterator referencing start of range to replace.\n+       *  @param i2  Iterator referencing end of range to replace.\n+       *  @param s  C string value to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [i1,i2).  In place, the\n+       *  characters of @a s are inserted.  If the length of result exceeds\n+       *  max_size(), length_error is thrown.  The value of the string doesn't\n+       *  change if an error is thrown.\n+      */\n       basic_string&\n       replace(iterator __i1, iterator __i2, const _CharT* __s)\n       { return this->replace(__i1, __i2, __s, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Replace range of characters with multiple characters\n+       *  @param i1  Iterator referencing start of range to replace.\n+       *  @param i2  Iterator referencing end of range to replace.\n+       *  @param n  Number of characters to insert.\n+       *  @param c  Character to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [i1,i2).  In place, @a n copies\n+       *  of @a c are inserted.  If the length of result exceeds max_size(),\n+       *  length_error is thrown.  The value of the string doesn't change if\n+       *  an error is thrown.\n+      */\n       basic_string&\n       replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n       { return _M_replace_aux(__i1, __i2, __n, __c); }\n \n+      /**\n+       *  @brief  Replace range of characters with range.\n+       *  @param i1  Iterator referencing start of range to replace.\n+       *  @param i2  Iterator referencing end of range to replace.\n+       *  @param k1  Iterator referencing start of range to insert.\n+       *  @param k2  Iterator referencing end of range to insert.\n+       *  @return  Reference to this string.\n+       *  @throw  std::length_error  If new length exceeds @c max_size().\n+       *\n+       *  Removes the characters in the range [i1,i2).  In place, characters\n+       *  in the range [k1,k2) are inserted.  If the length of result exceeds\n+       *  max_size(), length_error is thrown.  The value of the string doesn't\n+       *  change if an error is thrown.\n+      */\n       template<class _InputIterator>\n         basic_string&\n         replace(iterator __i1, iterator __i2,\n@@ -735,13 +1345,37 @@ namespace std\n \n     public:\n \n+      /**\n+       *  @brief  Copy substring into C string.\n+       *  @param s  C string to copy value into.\n+       *  @param n  Number of characters to copy.\n+       *  @param pos  Index of first character to copy.\n+       *  @return  Number of characters actually copied\n+       *  @throw  std::out_of_range  If pos > size().\n+       *\n+       *  Copies up to @a n characters starting at @a pos into the C string @a\n+       *  s.  If @a pos is greater than size(), out_of_range is thrown.\n+      */\n       size_type\n       copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n \n+      /**\n+       *  @brief  Swap contents with another string.\n+       *  @param s  String to swap with.\n+       *\n+       *  Exchanges the contents of this string with that of @a s in constant\n+       *  time.\n+      */\n       void\n       swap(basic_string& __s);\n \n       // String operations:\n+      /**\n+       *  @brief  Return const pointer to null-terminated contents.\n+       *\n+       *  This is a handle to internal data.  Do not modify or dire things may\n+       *  happen.\n+      */\n       const _CharT*\n       c_str() const\n       {\n@@ -751,99 +1385,371 @@ namespace std\n         return _M_data();\n       }\n \n+      /**\n+       *  @brief  Return const pointer to contents.\n+       *\n+       *  This is a handle to internal data.  It may not be null-terminated.\n+       *  Do not modify or dire things may happen.\n+      */\n       const _CharT*\n       data() const { return _M_data(); }\n \n+      /**\n+       *  @brief  Return copy of allocator used to construct this string.\n+      */\n       allocator_type\n       get_allocator() const { return _M_dataplus; }\n \n+      /**\n+       *  @brief  Find position of a C substring.\n+       *  @param s  C string to locate.\n+       *  @param pos  Index of character to search from.\n+       *  @param n  Number of characters from @a s to search for.\n+       *  @return  Index of start of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for the first @a n characters\n+       *  in @a s within this string.  If found, returns the index where it\n+       *  begins.  If not found, returns npos.\n+      */\n       size_type\n       find(const _CharT* __s, size_type __pos, size_type __n) const;\n \n+      /**\n+       *  @brief  Find position of a string.\n+       *  @param str  String to locate.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of start of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for value of @a str within\n+       *  this string.  If found, returns the index where it begins.  If not\n+       *  found, returns npos.\n+      */\n       size_type\n       find(const basic_string& __str, size_type __pos = 0) const\n       { return this->find(__str.data(), __pos, __str.size()); }\n \n+      /**\n+       *  @brief  Find position of a C string.\n+       *  @param s  C string to locate.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of start of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for the value of @a s within\n+       *  this string.  If found, returns the index where it begins.  If not\n+       *  found, returns npos.\n+      */\n       size_type\n       find(const _CharT* __s, size_type __pos = 0) const\n       { return this->find(__s, __pos, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Find position of a character.\n+       *  @param c  Character to locate.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for @a c within this string.\n+       *  If found, returns the index where it was found.  If not found,\n+       *  returns npos.\n+      */\n       size_type\n       find(_CharT __c, size_type __pos = 0) const;\n \n+      /**\n+       *  @brief  Find last position of a string.\n+       *  @param str  String to locate.\n+       *  @param pos  Index of character to search back from (default end).\n+       *  @return  Index of start of last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for value of @a str within\n+       *  this string.  If found, returns the index where it begins.  If not\n+       *  found, returns npos.\n+      */\n       size_type\n       rfind(const basic_string& __str, size_type __pos = npos) const\n       { return this->rfind(__str.data(), __pos, __str.size()); }\n \n+      /**\n+       *  @brief  Find last position of a C substring.\n+       *  @param s  C string to locate.\n+       *  @param pos  Index of character to search back from.\n+       *  @param n  Number of characters from s to search for.\n+       *  @return  Index of start of last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for the first @a n\n+       *  characters in @a s within this string.  If found, returns the index\n+       *  where it begins.  If not found, returns npos.\n+      */\n       size_type\n       rfind(const _CharT* __s, size_type __pos, size_type __n) const;\n \n+      /**\n+       *  @brief  Find last position of a C string.\n+       *  @param s  C string to locate.\n+       *  @param pos  Index of character to start search at (default 0).\n+       *  @return  Index of start of  last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for the value of @a s within\n+       *  this string.  If found, returns the index where it begins.  If not\n+       *  found, returns npos.\n+      */\n       size_type\n       rfind(const _CharT* __s, size_type __pos = npos) const\n       { return this->rfind(__s, __pos, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Find last position of a character.\n+       *  @param c  Character to locate.\n+       *  @param pos  Index of character to search back from (default 0).\n+       *  @return  Index of last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for @a c within this string.\n+       *  If found, returns the index where it was found.  If not found,\n+       *  returns npos.\n+      */\n       size_type\n       rfind(_CharT __c, size_type __pos = npos) const;\n \n+      /**\n+       *  @brief  Find position of a character of string.\n+       *  @param str  String containing characters to locate.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for one of the characters of\n+       *  @a str within this string.  If found, returns the index where it was\n+       *  found.  If not found, returns npos.\n+      */\n       size_type\n       find_first_of(const basic_string& __str, size_type __pos = 0) const\n       { return this->find_first_of(__str.data(), __pos, __str.size()); }\n \n+      /**\n+       *  @brief  Find position of a character of C substring.\n+       *  @param s  String containing characters to locate.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @param n  Number of characters from s to search for.\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for one of the first @a n\n+       *  characters of @a s within this string.  If found, returns the index\n+       *  where it was found.  If not found, returns npos.\n+      */\n       size_type\n       find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;\n \n+      /**\n+       *  @brief  Find position of a character of C string.\n+       *  @param s  String containing characters to locate.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for one of the characters of\n+       *  @a s within this string.  If found, returns the index where it was\n+       *  found.  If not found, returns npos.\n+      */\n       size_type\n       find_first_of(const _CharT* __s, size_type __pos = 0) const\n       { return this->find_first_of(__s, __pos, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Find position of a character.\n+       *  @param c  Character to locate.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for the character @a c within\n+       *  this string.  If found, returns the index where it was found.  If\n+       *  not found, returns npos.\n+       *\n+       *  Note: equivalent to find(c, pos).\n+      */\n       size_type\n       find_first_of(_CharT __c, size_type __pos = 0) const\n       { return this->find(__c, __pos); }\n \n+      /**\n+       *  @brief  Find last position of a character of string.\n+       *  @param str  String containing characters to locate.\n+       *  @param pos  Index of character to search back from (default end).\n+       *  @return  Index of last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for one of the characters of\n+       *  @a str within this string.  If found, returns the index where it was\n+       *  found.  If not found, returns npos.\n+      */\n       size_type\n       find_last_of(const basic_string& __str, size_type __pos = npos) const\n       { return this->find_last_of(__str.data(), __pos, __str.size()); }\n \n+      /**\n+       *  @brief  Find last position of a character of C substring.\n+       *  @param s  C string containing characters to locate.\n+       *  @param pos  Index of character to search back from (default end).\n+       *  @param n  Number of characters from s to search for.\n+       *  @return  Index of last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for one of the first @a n\n+       *  characters of @a s within this string.  If found, returns the index\n+       *  where it was found.  If not found, returns npos.\n+      */\n       size_type\n       find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;\n \n+      /**\n+       *  @brief  Find last position of a character of C string.\n+       *  @param s  C string containing characters to locate.\n+       *  @param pos  Index of character to search back from (default end).\n+       *  @return  Index of last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for one of the characters of\n+       *  @a s within this string.  If found, returns the index where it was\n+       *  found.  If not found, returns npos.\n+      */\n       size_type\n       find_last_of(const _CharT* __s, size_type __pos = npos) const\n       { return this->find_last_of(__s, __pos, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Find last position of a character.\n+       *  @param c  Character to locate.\n+       *  @param pos  Index of character to search back from (default 0).\n+       *  @return  Index of last occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for @a c within this string.\n+       *  If found, returns the index where it was found.  If not found,\n+       *  returns npos.\n+       *\n+       *  Note: equivalent to rfind(c, pos).\n+      */\n       size_type\n       find_last_of(_CharT __c, size_type __pos = npos) const\n       { return this->rfind(__c, __pos); }\n \n+      /**\n+       *  @brief  Find position of a character not in string.\n+       *  @param str  String containing characters to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for a character not contained\n+       *  in @a str within this string.  If found, returns the index where it\n+       *  was found.  If not found, returns npos.\n+      */\n       size_type\n       find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n       { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n \n+      /**\n+       *  @brief  Find position of a character not in C substring.\n+       *  @param s  C string containing characters to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @param n  Number of characters from s to consider.\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for a character not contained\n+       *  in the first @a n characters of @a s within this string.  If found,\n+       *  returns the index where it was found.  If not found, returns npos.\n+      */\n       size_type\n       find_first_not_of(const _CharT* __s, size_type __pos,\n \t\t\tsize_type __n) const;\n \n+      /**\n+       *  @brief  Find position of a character not in C string.\n+       *  @param s  C string containing characters to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for a character not contained\n+       *  in @a s within this string.  If found, returns the index where it\n+       *  was found.  If not found, returns npos.\n+      */\n       size_type\n       find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n       { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Find position of a different character.\n+       *  @param c  Character to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches forward for a character other than @a c\n+       *  within this string.  If found, returns the index where it was found.\n+       *  If not found, returns npos.\n+      */\n       size_type\n       find_first_not_of(_CharT __c, size_type __pos = 0) const;\n \n+      /**\n+       *  @brief  Find last position of a character not in string.\n+       *  @param str  String containing characters to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for a character not\n+       *  contained in @a str within this string.  If found, returns the index\n+       *  where it was found.  If not found, returns npos.\n+      */\n       size_type\n       find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n       { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n \n+      /**\n+       *  @brief  Find last position of a character not in C substring.\n+       *  @param s  C string containing characters to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @param n  Number of characters from s to consider.\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for a character not\n+       *  contained in the first @a n characters of @a s within this string.\n+       *  If found, returns the index where it was found.  If not found,\n+       *  returns npos.\n+      */\n       size_type\n       find_last_not_of(const _CharT* __s, size_type __pos,\n \t\t       size_type __n) const;\n+      /**\n+       *  @brief  Find position of a character not in C string.\n+       *  @param s  C string containing characters to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for a character not\n+       *  contained in @a s within this string.  If found, returns the index\n+       *  where it was found.  If not found, returns npos.\n+      */\n       size_type\n       find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n       { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }\n \n+      /**\n+       *  @brief  Find last position of a different character.\n+       *  @param c  Character to avoid.\n+       *  @param pos  Index of character to search from (default 0).\n+       *  @return  Index of first occurrence.\n+       *\n+       *  Starting from @a pos, searches backward for a character other than\n+       *  @a c within this string.  If found, returns the index where it was\n+       *  found.  If not found, returns npos.\n+      */\n       size_type\n       find_last_not_of(_CharT __c, size_type __pos = npos) const;\n \n+      /**\n+       *  @brief  Get a substring.\n+       *  @param pos  Index of first character (default 0).\n+       *  @param n  Number of characters in substring (default remainder).\n+       *  @return  The new string.\n+       *  @throw  std::out_of_range  If pos > size().\n+       *\n+       *  Construct and return a new string using the @a n characters starting\n+       *  at @a pos.  If the string is too short, use the remainder of the\n+       *  characters.  If @a pos is beyond the end of the string, out_of_range\n+       *  is thrown.\n+      */\n       basic_string\n       substr(size_type __pos = 0, size_type __n = npos) const\n       {\n@@ -852,6 +1758,17 @@ namespace std\n \treturn basic_string(*this, __pos, __n);\n       }\n \n+      /**\n+       *  @brief  Compare to a string.\n+       *  @param str  String to compare against.\n+       *  @return  Integer < 0, 0, or > 0.\n+       *\n+       *  Returns an integer < 0 if this string is ordered before @a str, 0 if\n+       *  their values are equivalent, or > 0 if this string is ordered after\n+       *  @a str.  If the lengths of @a str and this string are different, the\n+       *  shorter one is ordered first.  If they are the same, returns the\n+       *  result of traits::compare(data(),str.data(),size());\n+      */\n       int\n       compare(const basic_string& __str) const\n       {\n@@ -865,21 +1782,98 @@ namespace std\n \treturn __r;\n       }\n \n+      /**\n+       *  @brief  Compare substring to a string.\n+       *  @param pos  Index of first character of substring.\n+       *  @param n  Number of characters in substring.\n+       *  @param str  String to compare against.\n+       *  @return  Integer < 0, 0, or > 0.\n+       *\n+       *  Form the substring of this string from the @a n characters starting\n+       *  at @a pos.  Returns an integer < 0 if the substring is ordered\n+       *  before @a str, 0 if their values are equivalent, or > 0 if the\n+       *  substring is ordered after @a str.  If the lengths @a of str and the\n+       *  substring are different, the shorter one is ordered first.  If they\n+       *  are the same, returns the result of\n+       *  traits::compare(substring.data(),str.data(),size());\n+      */\n       int\n       compare(size_type __pos, size_type __n, const basic_string& __str) const;\n \n+      /**\n+       *  @brief  Compare substring to a substring.\n+       *  @param pos1  Index of first character of substring.\n+       *  @param n1  Number of characters in substring.\n+       *  @param str  String to compare against.\n+       *  @param pos2  Index of first character of substring of str.\n+       *  @param n2  Number of characters in substring of str.\n+       *  @return  Integer < 0, 0, or > 0.\n+       *\n+       *  Form the substring of this string from the @a n1 characters starting\n+       *  at @a pos1.  Form the substring of @a str from the @a n2 characters\n+       *  starting at @a pos2.  Returns an integer < 0 if this substring is\n+       *  ordered before the substring of @a str, 0 if their values are\n+       *  equivalent, or > 0 if this substring is ordered after the substring\n+       *  of @a str.  If the lengths of the substring of @a str and this\n+       *  substring are different, the shorter one is ordered first.  If they\n+       *  are the same, returns the result of\n+       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),size());\n+      */\n       int\n       compare(size_type __pos1, size_type __n1, const basic_string& __str,\n \t      size_type __pos2, size_type __n2) const;\n \n+      /**\n+       *  @brief  Compare to a C string.\n+       *  @param s  C string to compare against.\n+       *  @return  Integer < 0, 0, or > 0.\n+       *\n+       *  Returns an integer < 0 if this string is ordered before @a s, 0 if\n+       *  their values are equivalent, or > 0 if this string is ordered after\n+       *  @a s.  If the lengths of @a s and this string are different, the\n+       *  shorter one is ordered first.  If they are the same, returns the\n+       *  result of traits::compare(data(),s,size());\n+      */\n       int\n       compare(const _CharT* __s) const;\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 5 String::compare specification questionable\n+      /**\n+       *  @brief  Compare substring to a C string.\n+       *  @param pos  Index of first character of substring.\n+       *  @param n1  Number of characters in substring.\n+       *  @param s  C string to compare against.\n+       *  @return  Integer < 0, 0, or > 0.\n+       *\n+       *  Form the substring of this string from the @a n1 characters starting\n+       *  at @a pos.  Returns an integer < 0 if the substring is ordered\n+       *  before @a s, 0 if their values are equivalent, or > 0 if the\n+       *  substring is ordered after @a s.  If the lengths of @a s and the\n+       *  substring are different, the shorter one is ordered first.  If they\n+       *  are the same, returns the result of\n+       *  traits::compare(substring.data(),s,size());\n+      */\n       int\n       compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n \n+      /**\n+       *  @brief  Compare substring against a C substring.\n+       *  @param pos1  Index of first character of substring.\n+       *  @param n1  Number of characters in substring.\n+       *  @param s  C string to compare against.\n+       *  @param n2  Number of characters in substring of s.\n+       *  @return  Integer < 0, 0, or > 0.\n+       *\n+       *  Form the substring of this string from the @a n1 characters starting\n+       *  at @a pos1.  Form the substring of @a s from the first @a n\n+       *  characters of @a s.  Returns an integer < 0 if this substring is\n+       *  ordered before the substring of @a s, 0 if their values are\n+       *  equivalent, or > 0 if this substring is ordered after the substring\n+       *  of @a s.  If the lengths of this substring and @a n are different,\n+       *  the shorter one is ordered first.  If they are the same, returns the\n+       *  result of traits::compare(substring.data(),s,size());\n+      */\n       int\n       compare(size_type __pos, size_type __n1, const _CharT* __s,\n \t      size_type __n2) const;\n@@ -892,7 +1886,13 @@ namespace std\n     : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }\n \n   // operator+\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n+  /**\n+   *  @brief  Concatenate two strings.\n+   *  @param lhs  First string.\n+   *  @param rhs  Last string.\n+   *  @return  New string with value of @a lhs followed by @a rhs.\n+   */ \n+ template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n@@ -902,15 +1902,33 @@ namespace std\n       return __str;\n     }\n \n+  /**\n+   *  @brief  Concatenate C string and string.\n+   *  @param lhs  First string.\n+   *  @param rhs  Last string.\n+   *  @return  New string with value of @a lhs followed by @a rhs.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT,_Traits,_Alloc>\n     operator+(const _CharT* __lhs,\n \t      const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n \n+  /**\n+   *  @brief  Concatenate character and string.\n+   *  @param lhs  First string.\n+   *  @param rhs  Last string.\n+   *  @return  New string with @a lhs followed by @a rhs.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT,_Traits,_Alloc>\n     operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n \n+  /**\n+   *  @brief  Concatenate string and C string.\n+   *  @param lhs  First string.\n+   *  @param rhs  Last string.\n+   *  @return  New string with @a lhs followed by @a rhs.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline basic_string<_CharT, _Traits, _Alloc>\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -921,6 +1939,12 @@ namespace std\n       return __str;\n     }\n \n+  /**\n+   *  @brief  Concatenate string and character.\n+   *  @param lhs  First string.\n+   *  @param rhs  Last string.\n+   *  @return  New string with @a lhs followed by @a rhs.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline basic_string<_CharT, _Traits, _Alloc>\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n@@ -933,141 +1957,301 @@ namespace std\n     }\n \n   // operator ==\n+  /**\n+   *  @brief  Test equivalence of two strings.\n+   *  @param lhs  First string.\n+   *  @param rhs  Second string.\n+   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __lhs.compare(__rhs) == 0; }\n \n+  /**\n+   *  @brief  Test equivalence of C string and string.\n+   *  @param lhs  C string.\n+   *  @param rhs  String.\n+   *  @return  True if @a rhs.compare(@a lhs) == 0.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator==(const _CharT* __lhs,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) == 0; }\n \n+  /**\n+   *  @brief  Test equivalence of string and C string.\n+   *  @param lhs  String.\n+   *  @param rhs  C string.\n+   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const _CharT* __rhs)\n     { return __lhs.compare(__rhs) == 0; }\n \n   // operator !=\n+  /**\n+   *  @brief  Test difference of two strings.\n+   *  @param lhs  First string.\n+   *  @param rhs  Second string.\n+   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) != 0; }\n \n+  /**\n+   *  @brief  Test difference of C string and string.\n+   *  @param lhs  C string.\n+   *  @param rhs  String.\n+   *  @return  True if @a rhs.compare(@a lhs) != 0.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator!=(const _CharT* __lhs,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) != 0; }\n \n+  /**\n+   *  @brief  Test difference of string and C string.\n+   *  @param lhs  String.\n+   *  @param rhs  C string.\n+   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const _CharT* __rhs)\n     { return __lhs.compare(__rhs) != 0; }\n \n   // operator <\n+  /**\n+   *  @brief  Test if string precedes string.\n+   *  @param lhs  First string.\n+   *  @param rhs  Second string.\n+   *  @return  True if @a lhs precedes @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __lhs.compare(__rhs) < 0; }\n \n+  /**\n+   *  @brief  Test if string precedes C string.\n+   *  @param lhs  String.\n+   *  @param rhs  C string.\n+   *  @return  True if @a lhs precedes @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t      const _CharT* __rhs)\n     { return __lhs.compare(__rhs) < 0; }\n \n+  /**\n+   *  @brief  Test if C string precedes string.\n+   *  @param lhs  C string.\n+   *  @param rhs  String.\n+   *  @return  True if @a lhs precedes @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<(const _CharT* __lhs,\n \t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) > 0; }\n \n   // operator >\n+  /**\n+   *  @brief  Test if string follows string.\n+   *  @param lhs  First string.\n+   *  @param rhs  Second string.\n+   *  @return  True if @a lhs follows @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __lhs.compare(__rhs) > 0; }\n \n+  /**\n+   *  @brief  Test if string follows C string.\n+   *  @param lhs  String.\n+   *  @param rhs  C string.\n+   *  @return  True if @a lhs follows @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t      const _CharT* __rhs)\n     { return __lhs.compare(__rhs) > 0; }\n \n+  /**\n+   *  @brief  Test if C string follows string.\n+   *  @param lhs  C string.\n+   *  @param rhs  String.\n+   *  @return  True if @a lhs follows @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>(const _CharT* __lhs,\n \t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) < 0; }\n \n   // operator <=\n+  /**\n+   *  @brief  Test if string doesn't follow string.\n+   *  @param lhs  First string.\n+   *  @param rhs  Second string.\n+   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __lhs.compare(__rhs) <= 0; }\n \n+  /**\n+   *  @brief  Test if string doesn't follow C string.\n+   *  @param lhs  String.\n+   *  @param rhs  C string.\n+   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const _CharT* __rhs)\n     { return __lhs.compare(__rhs) <= 0; }\n \n+  /**\n+   *  @brief  Test if C string doesn't follow string.\n+   *  @param lhs  C string.\n+   *  @param rhs  String.\n+   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<=(const _CharT* __lhs,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n   { return __rhs.compare(__lhs) >= 0; }\n \n   // operator >=\n+  /**\n+   *  @brief  Test if string doesn't precede string.\n+   *  @param lhs  First string.\n+   *  @param rhs  Second string.\n+   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __lhs.compare(__rhs) >= 0; }\n \n+  /**\n+   *  @brief  Test if string doesn't precede C string.\n+   *  @param lhs  String.\n+   *  @param rhs  C string.\n+   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t       const _CharT* __rhs)\n     { return __lhs.compare(__rhs) >= 0; }\n \n+  /**\n+   *  @brief  Test if C string doesn't precede string.\n+   *  @param lhs  C string.\n+   *  @param rhs  String.\n+   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\n+   */ \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>=(const _CharT* __lhs,\n \t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) <= 0; }\n \n \n+  /**\n+   *  @brief  Swap contents of two strings.\n+   *  @param lhs  First string.\n+   *  @param rhs  Second string.\n+   *\n+   *  Exchanges the contents of @a lhs and @a rhs in constant time. \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline void\n     swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\n \t basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { __lhs.swap(__rhs); }\n \n+  /**\n+   *  @brief  Read stream into a string.\n+   *  @param is  Input stream.\n+   *  @param str  Buffer to store into.\n+   *  @return  Reference to the input stream.\n+   *\n+   *  Stores characters from @a is into @a str until whitespace is found, the\n+   *  end of the stream is encountered, or str.max_size() is reached.  If\n+   *  is.width() is non-zero, that is the limit on the number of characters\n+   *  stored into @a str.  Any previous contents of @a str are erased.\n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __is,\n \t       basic_string<_CharT, _Traits, _Alloc>& __str);\n \n+  /**\n+   *  @brief  Write string to a stream.\n+   *  @param os  Output stream.\n+   *  @param str  String to write out.\n+   *  @return  Reference to the output stream.\n+   *\n+   *  Output characters of @a str into os following the same rules as for\n+   *  writing a C string.\n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>& __os,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __str);\n \n+  /**\n+   *  @brief  Read a line from stream into a string.\n+   *  @param is  Input stream.\n+   *  @param str  Buffer to store into.\n+   *  @param delim  Character marking end of line.\n+   *  @return  Reference to the input stream.\n+   *\n+   *  Stores characters from @a is into @a str until @a delim is found, the\n+   *  end of the stream is encountered, or str.max_size() is reached.  If\n+   *  is.width() is non-zero, that is the limit on the number of characters\n+   *  stored into @a str.  Any previous contents of @a str are erased.  If @a\n+   *  delim was encountered, it is extracted but not stored into @a str.\n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_istream<_CharT,_Traits>&\n     getline(basic_istream<_CharT, _Traits>& __is,\n \t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\n \n+  /**\n+   *  @brief  Read a line from stream into a string.\n+   *  @param is  Input stream.\n+   *  @param str  Buffer to store into.\n+   *  @return  Reference to the input stream.\n+   *\n+   *  Stores characters from is into @a str until '\\n' is found, the end of\n+   *  the stream is encountered, or str.max_size() is reached.  If is.width()\n+   *  is non-zero, that is the limit on the number of characters stored into\n+   *  @a str.  Any previous contents of @a str are erased.  If end of line was\n+   *  encountered, it is extracted but not stored into @a str.\n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline basic_istream<_CharT,_Traits>&\n     getline(basic_istream<_CharT, _Traits>& __is,"}]}