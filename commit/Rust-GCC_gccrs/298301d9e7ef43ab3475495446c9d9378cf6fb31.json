{"sha": "298301d9e7ef43ab3475495446c9d9378cf6fb31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk4MzAxZDllN2VmNDNhYjM0NzU0OTU0NDZjOWQ5Mzc4Y2Y2ZmIzMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-06-27T03:19:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-06-27T03:19:51Z"}, "message": "i386: Expand mul<VI8_AVX2> earlier\n\nMove the expansion code to i386.c next to mulv4si3.  Eliminate\none shift by adding the highparts before shifting.  Correct costs.\n\n        * config/i386/sse.md (mul<VI8_AVX2>3): Change from insn_and_split\n        to expander; move guts to ...\n        * config/i386/i386.c (ix86_expand_sse2_mulvxdi3): ... here.  Add\n        highparts before shifting up.\n        * config/i386/i386-protos.h: Update.\n\nFrom-SVN: r189005", "tree": {"sha": "2f0f80a671b4ba2cbfaee3a36e454d7c3465a624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f0f80a671b4ba2cbfaee3a36e454d7c3465a624"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/298301d9e7ef43ab3475495446c9d9378cf6fb31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298301d9e7ef43ab3475495446c9d9378cf6fb31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/298301d9e7ef43ab3475495446c9d9378cf6fb31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298301d9e7ef43ab3475495446c9d9378cf6fb31/comments", "author": null, "committer": null, "parents": [{"sha": "e2a3a0987fdacf48defcc6f89a92197026d2bde4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a3a0987fdacf48defcc6f89a92197026d2bde4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a3a0987fdacf48defcc6f89a92197026d2bde4"}], "stats": {"total": 183, "additions": 102, "deletions": 81}, "files": [{"sha": "3719552dec84bb768838dce2235f04bc97912128", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=298301d9e7ef43ab3475495446c9d9378cf6fb31", "patch": "@@ -1,3 +1,11 @@\n+2012-06-26  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/sse.md (mul<VI8_AVX2>3): Change from insn_and_split\n+\tto expander; move guts to ...\n+\t* config/i386/i386.c (ix86_expand_sse2_mulvxdi3): ... here.  Add\n+\thighparts before shifting up.\n+\t* config/i386/i386-protos.h: Update.\n+\n 2012-06-26  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* system.h (USE_COMMON_FOR_ONE_ONLY): Poison."}, {"sha": "581b25c519985f92bc49d0332175589ff4dfabdc", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=298301d9e7ef43ab3475495446c9d9378cf6fb31", "patch": "@@ -227,6 +227,7 @@ extern bool ix86_expand_pinsr (rtx *);\n extern void ix86_expand_mul_widen_evenodd (rtx, rtx, rtx, bool, bool);\n extern void ix86_expand_mul_widen_hilo (rtx, rtx, rtx, bool, bool);\n extern void ix86_expand_sse2_mulv4si3 (rtx, rtx, rtx);\n+extern void ix86_expand_sse2_mulvxdi3 (rtx, rtx, rtx);\n \n /* In i386-c.c  */\n extern void ix86_target_macros (void);"}, {"sha": "5cf230f5d25517bb6f5e099c528409f06a1e5b70", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=298301d9e7ef43ab3475495446c9d9378cf6fb31", "patch": "@@ -32293,6 +32293,14 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t\textra = 6;\n \t      *total = cost->fmul * 2 + cost->fabs * extra;\n \t    }\n+\t  /* V*DImode is emulated with 5-8 insns.  */\n+\t  else if (mode == V2DImode || mode == V4DImode)\n+\t    {\n+\t      if (TARGET_XOP && mode == V2DImode)\n+\t\t*total = cost->fmul * 2 + cost->fabs * 3;\n+\t      else\n+\t\t*total = cost->fmul * 3 + cost->fabs * 5;\n+\t    }\n \t  /* Without sse4.1, we don't have PMULLD; it's emulated with 7\n \t     insns, including two PMULUDQ.  */\n \t  else if (mode == V4SImode && !(TARGET_SSE4_1 || TARGET_AVX))\n@@ -38915,6 +38923,88 @@ ix86_expand_sse2_mulv4si3 (rtx op0, rtx op1, rtx op2)\n   set_unique_reg_note (res_1, REG_EQUAL, gen_rtx_MULT (V4SImode, op1, op2));\n }\n \n+void\n+ix86_expand_sse2_mulvxdi3 (rtx op0, rtx op1, rtx op2)\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+  rtx t1, t2, t3, t4, t5, t6;\n+\n+  if (TARGET_XOP && mode == V2DImode)\n+    {\n+      /* op1: A,B,C,D, op2: E,F,G,H */\n+      op1 = gen_lowpart (V4SImode, op1);\n+      op2 = gen_lowpart (V4SImode, op2);\n+\n+      t1 = gen_reg_rtx (V4SImode);\n+      t2 = gen_reg_rtx (V4SImode);\n+      t3 = gen_reg_rtx (V2DImode);\n+      t4 = gen_reg_rtx (V2DImode);\n+\n+      /* t1: B,A,D,C */\n+      emit_insn (gen_sse2_pshufd_1 (t1, op1,\n+\t\t\t\t    GEN_INT (1),\n+\t\t\t\t    GEN_INT (0),\n+\t\t\t\t    GEN_INT (3),\n+\t\t\t\t    GEN_INT (2)));\n+\n+      /* t2: (B*E),(A*F),(D*G),(C*H) */\n+      emit_insn (gen_mulv4si3 (t2, t1, op2));\n+\n+      /* t3: (B*E)+(A*F), (D*G)+(C*H) */\n+      emit_insn (gen_xop_phadddq (t3, t2));\n+\n+      /* t4: ((B*E)+(A*F))<<32, ((D*G)+(C*H))<<32 */\n+      emit_insn (gen_ashlv2di3 (t4, t3, GEN_INT (32)));\n+\n+      /* op0: (((B*E)+(A*F))<<32)+(B*F), (((D*G)+(C*H))<<32)+(D*H) */\n+      emit_insn (gen_xop_pmacsdql (op0, op1, op2, t4));\n+    }\n+  else\n+    {\n+      enum machine_mode nmode;\n+      rtx (*umul) (rtx, rtx, rtx);\n+\n+      if (mode == V2DImode)\n+\t{\n+\t  umul = gen_sse2_umulv2siv2di3;\n+\t  nmode = V4SImode;\n+\t}\n+      else if (mode == V4DImode)\n+\t{\n+\t  umul = gen_avx2_umulv4siv4di3;\n+\t  nmode = V8SImode;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+\n+\n+      /* Multiply low parts.  */\n+      t1 = gen_reg_rtx (mode);\n+      emit_insn (umul (t1, gen_lowpart (nmode, op1), gen_lowpart (nmode, op2)));\n+\n+      /* Shift input vectors right 32 bits so we can multiply high parts.  */\n+      t6 = GEN_INT (32);\n+      t2 = expand_binop (mode, lshr_optab, op1, t6, NULL, 1, OPTAB_DIRECT);\n+      t3 = expand_binop (mode, lshr_optab, op2, t6, NULL, 1, OPTAB_DIRECT);\n+\n+      /* Multiply high parts by low parts.  */\n+      t4 = gen_reg_rtx (mode);\n+      t5 = gen_reg_rtx (mode);\n+      emit_insn (umul (t4, gen_lowpart (nmode, t2), gen_lowpart (nmode, op2)));\n+      emit_insn (umul (t5, gen_lowpart (nmode, t3), gen_lowpart (nmode, op1)));\n+\n+      /* Combine and shift the highparts back.  */\n+      t4 = expand_binop (mode, add_optab, t4, t5, t4, 1, OPTAB_DIRECT);\n+      t4 = expand_binop (mode, ashl_optab, t4, t6, t4, 1, OPTAB_DIRECT);\n+\n+      /* Combine high and low parts.  */\n+      force_expand_binop (mode, add_optab, t1, t4, op0, 1, OPTAB_DIRECT);\n+    }\n+\n+  set_unique_reg_note (get_last_insn (), REG_EQUAL,\n+\t\t       gen_rtx_MULT (mode, op1, op2));\n+}\n+\n /* Expand an insert into a vector register through pinsr insn.\n    Return true if successful.  */\n "}, {"sha": "81e7dc08745b100e9ebc7199f27d2962a3629d3c", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 3, "deletions": 81, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298301d9e7ef43ab3475495446c9d9378cf6fb31/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=298301d9e7ef43ab3475495446c9d9378cf6fb31", "patch": "@@ -5592,91 +5592,13 @@\n    (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn_and_split \"mul<mode>3\"\n+(define_expand \"mul<mode>3\"\n   [(set (match_operand:VI8_AVX2 0 \"register_operand\")\n \t(mult:VI8_AVX2 (match_operand:VI8_AVX2 1 \"register_operand\")\n \t\t       (match_operand:VI8_AVX2 2 \"register_operand\")))]\n-  \"TARGET_SSE2\n-   && can_create_pseudo_p ()\"\n-  \"#\"\n-  \"&& 1\"\n-  [(const_int 0)]\n+  \"TARGET_SSE2\"\n {\n-  rtx t1, t2, t3, t4, t5, t6, thirtytwo;\n-  rtx op0, op1, op2;\n-\n-  op0 = operands[0];\n-  op1 = operands[1];\n-  op2 = operands[2];\n-\n-  if (TARGET_XOP && <MODE>mode == V2DImode)\n-    {\n-      /* op1: A,B,C,D, op2: E,F,G,H */\n-      op1 = gen_lowpart (V4SImode, op1);\n-      op2 = gen_lowpart (V4SImode, op2);\n-\n-      t1 = gen_reg_rtx (V4SImode);\n-      t2 = gen_reg_rtx (V4SImode);\n-      t3 = gen_reg_rtx (V2DImode);\n-      t4 = gen_reg_rtx (V2DImode);\n-\n-      /* t1: B,A,D,C */\n-      emit_insn (gen_sse2_pshufd_1 (t1, op1,\n-\t\t\t\t    GEN_INT (1),\n-\t\t\t\t    GEN_INT (0),\n-\t\t\t\t    GEN_INT (3),\n-\t\t\t\t    GEN_INT (2)));\n-\n-      /* t2: (B*E),(A*F),(D*G),(C*H) */\n-      emit_insn (gen_mulv4si3 (t2, t1, op2));\n-\n-      /* t4: (B*E)+(A*F), (D*G)+(C*H) */\n-      emit_insn (gen_xop_phadddq (t3, t2));\n-\n-      /* t5: ((B*E)+(A*F))<<32, ((D*G)+(C*H))<<32 */\n-      emit_insn (gen_ashlv2di3 (t4, t3, GEN_INT (32)));\n-\n-      /* op0: (((B*E)+(A*F))<<32)+(B*F), (((D*G)+(C*H))<<32)+(D*H) */\n-      emit_insn (gen_xop_pmacsdql (op0, op1, op2, t4));\n-    }\n-  else\n-    {\n-      t1 = gen_reg_rtx (<MODE>mode);\n-      t2 = gen_reg_rtx (<MODE>mode);\n-      t3 = gen_reg_rtx (<MODE>mode);\n-      t4 = gen_reg_rtx (<MODE>mode);\n-      t5 = gen_reg_rtx (<MODE>mode);\n-      t6 = gen_reg_rtx (<MODE>mode);\n-      thirtytwo = GEN_INT (32);\n-\n-      /* Multiply low parts.  */\n-      emit_insn (gen_<sse2_avx2>_umulv<ssescalarnum>si<mode>3\n-\t\t  (t1, gen_lowpart (<ssepackmode>mode, op1),\n-\t\t   gen_lowpart (<ssepackmode>mode, op2)));\n-\n-      /* Shift input vectors right 32 bits so we can multiply high parts.  */\n-      emit_insn (gen_lshr<mode>3 (t2, op1, thirtytwo));\n-      emit_insn (gen_lshr<mode>3 (t3, op2, thirtytwo));\n-\n-      /* Multiply high parts by low parts.  */\n-      emit_insn (gen_<sse2_avx2>_umulv<ssescalarnum>si<mode>3\n-\t\t  (t4, gen_lowpart (<ssepackmode>mode, op1),\n-\t\t   gen_lowpart (<ssepackmode>mode, t3)));\n-      emit_insn (gen_<sse2_avx2>_umulv<ssescalarnum>si<mode>3\n-\t\t  (t5, gen_lowpart (<ssepackmode>mode, op2),\n-\t\t   gen_lowpart (<ssepackmode>mode, t2)));\n-\n-      /* Shift them back.  */\n-      emit_insn (gen_ashl<mode>3 (t4, t4, thirtytwo));\n-      emit_insn (gen_ashl<mode>3 (t5, t5, thirtytwo));\n-\n-      /* Add the three parts together.  */\n-      emit_insn (gen_add<mode>3 (t6, t1, t4));\n-      emit_insn (gen_add<mode>3 (op0, t6, t5));\n-    }\n-\n-  set_unique_reg_note (get_last_insn (), REG_EQUAL,\n-\t\t       gen_rtx_MULT (<MODE>mode, operands[1], operands[2]));\n+  ix86_expand_sse2_mulvxdi3 (operands[0], operands[1], operands[2]);\n   DONE;\n })\n "}]}