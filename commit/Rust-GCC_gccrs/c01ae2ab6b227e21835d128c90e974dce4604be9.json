{"sha": "c01ae2ab6b227e21835d128c90e974dce4604be9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxYWUyYWI2YjIyN2UyMTgzNWQxMjhjOTBlOTc0ZGNlNDYwNGJlOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-07T11:17:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-07T11:25:06Z"}, "message": "tree-optimization/99954 - fix loop distribution memcpy classification\n\nThis fixes bogus classification of a copy as memcpy.  We cannot use\nplain dependence analysis to decide between memcpy and memmove when\nit computes no dependence.  Instead we have to try harder later which\nthe patch does for the gcc.dg/tree-ssa/ldist-24.c testcase by resorting\nto tree-affine to compute the difference between src and dest and\ncompare against the copy size.\n\n2021-04-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/99954\n\t* tree-loop-distribution.c: Include tree-affine.h.\n\t(generate_memcpy_builtin): Try using tree-affine to prove\n\tnon-overlap.\n\t(loop_distribution::classify_builtin_ldst): Always classify\n\tas PKIND_MEMMOVE.\n\n\t* gcc.dg/torture/pr99954.c: New testcase.", "tree": {"sha": "27b82badec76eac80372b97548289cf35fb33a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27b82badec76eac80372b97548289cf35fb33a92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01ae2ab6b227e21835d128c90e974dce4604be9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01ae2ab6b227e21835d128c90e974dce4604be9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01ae2ab6b227e21835d128c90e974dce4604be9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01ae2ab6b227e21835d128c90e974dce4604be9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d6ad10c170e3670f0b5e3709e0fa6e76b7065b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d6ad10c170e3670f0b5e3709e0fa6e76b7065b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d6ad10c170e3670f0b5e3709e0fa6e76b7065b3"}], "stats": {"total": 47, "additions": 45, "deletions": 2}, "files": [{"sha": "7d4470359125d61f99f9dc5af2c17372c68430d8", "filename": "gcc/testsuite/gcc.dg/torture/pr99954.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01ae2ab6b227e21835d128c90e974dce4604be9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr99954.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01ae2ab6b227e21835d128c90e974dce4604be9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr99954.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr99954.c?ref=c01ae2ab6b227e21835d128c90e974dce4604be9", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+\n+#include <assert.h>\n+\n+#define CONTAINER_KIND union\n+\n+typedef CONTAINER_KIND container { int value; } container;\n+\n+void move(container* end, container* start) {\n+    container* p;\n+    for (p = end; p > start; p--) {\n+\t(p)->value = (p-1)->value;\n+    }\n+}\n+\n+#define N 100\n+\n+int main(int argc, char* argv[]) {\n+    container vals[N];\n+    int i;\n+    for (i=0; i<N; i++) {\n+        vals[i].value = argc + i;\n+    }\n+    move(&vals[N-1], &vals[0]);\n+    assert(vals[0].value == argc + 0);\n+    for (i=1; i<N; i++) {\n+        assert(vals[i].value == argc + i - 1);\n+    }\n+    return 0;\n+}"}, {"sha": "8b91a30d1c62d74908fd9f0f7dc675c837b60395", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01ae2ab6b227e21835d128c90e974dce4604be9/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01ae2ab6b227e21835d128c90e974dce4604be9/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=c01ae2ab6b227e21835d128c90e974dce4604be9", "patch": "@@ -115,6 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"tree-eh.h\"\n #include \"gimple-fold.h\"\n+#include \"tree-affine.h\"\n \n \n #define MAX_DATAREFS_NUM \\\n@@ -1212,6 +1213,18 @@ generate_memcpy_builtin (class loop *loop, partition *partition)\n     kind = BUILT_IN_MEMCPY;\n   else\n     kind = BUILT_IN_MEMMOVE;\n+  /* Try harder if we're copying a constant size.  */\n+  if (kind == BUILT_IN_MEMMOVE && poly_int_tree_p (nb_bytes))\n+    {\n+      aff_tree asrc, adest;\n+      tree_to_aff_combination (src, ptr_type_node, &asrc);\n+      tree_to_aff_combination (dest, ptr_type_node, &adest);\n+      aff_combination_scale (&adest, -1);\n+      aff_combination_add (&asrc, &adest);\n+      if (aff_comb_cannot_overlap_p (&asrc, wi::to_poly_widest (nb_bytes),\n+\t\t\t\t     wi::to_poly_widest (nb_bytes)))\n+\tkind = BUILT_IN_MEMCPY;\n+    }\n \n   dest = force_gimple_operand_gsi (&gsi, dest, true, NULL_TREE,\n \t\t\t\t   false, GSI_CONTINUE_LINKING);\n@@ -1759,11 +1772,11 @@ loop_distribution::classify_builtin_ldst (loop_p loop, struct graph *rdg,\n   /* Now check that if there is a dependence.  */\n   ddr_p ddr = get_data_dependence (rdg, src_dr, dst_dr);\n \n-  /* Classify as memcpy if no dependence between load and store.  */\n+  /* Classify as memmove if no dependence between load and store.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     {\n       partition->builtin = alloc_builtin (dst_dr, src_dr, base, src_base, size);\n-      partition->kind = PKIND_MEMCPY;\n+      partition->kind = PKIND_MEMMOVE;\n       return;\n     }\n "}]}