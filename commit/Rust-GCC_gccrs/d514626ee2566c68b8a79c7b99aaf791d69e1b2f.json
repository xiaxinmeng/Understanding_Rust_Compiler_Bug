{"sha": "d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUxNDYyNmVlMjU2NmM2OGI4YTc5YzdiOTlhYWY3OTFkNjllMWIyZg==", "commit": {"author": {"name": "Jos\u00e9 Rui Faustino de Sousa", "email": "jrfsousa@gmail.com", "date": "2021-06-05T11:12:50Z"}, "committer": {"name": "Jos\u00e9 Rui Faustino de Sousa", "email": "jrfsousa@gmail.com", "date": "2021-06-05T11:12:50Z"}, "message": "Fortran: Fix some issues with pointers to character.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/100120\n\tPR fortran/100816\n\tPR fortran/100818\n\tPR fortran/100819\n\tPR fortran/100821\n\t* trans-array.c (gfc_get_array_span): rework the way character\n\tarray \"span\" was calculated.\n\t(gfc_conv_expr_descriptor): improve handling of character sections\n\tand unlimited polymorphic objects.\n\t* trans-expr.c (gfc_get_character_len): new function to calculate\n\tcharacter string length.\n\t(gfc_get_character_len_in_bytes): new function to calculate\n\tcharacter string length in bytes.\n\t(gfc_conv_scalar_to_descriptor): add call to set the \"span\".\n\t(gfc_trans_pointer_assignment): set \"_len\" and antecipate the\n\tinitialization of the deferred character length hidden argument.\n\t* trans-intrinsic.c (gfc_conv_associated): set \"force_no_tmp\" to\n\tavoid the creation of a temporary.\n\t* trans-types.c (gfc_get_dtype_rank_type): rework type detection\n\tso that unlimited polymorphic objects get proper type infomation,\n\talso important for bind(c).\n\t(gfc_get_dtype): add argument to pass the rank if necessary.\n\t(gfc_get_array_type_bounds): cosmetic change to have character\n\tarrays called character instead of unknown.\n\t* trans-types.h (gfc_get_dtype): modify prototype.\n\t* trans.c (get_array_span): rework the way character array \"span\"\n\twas calculated.\n\t* trans.h (gfc_get_character_len): new prototype.\n\t(gfc_get_character_len_in_bytes): new prototype.\n\tAdd \"unlimited_polymorphic\" flag to \"gfc_se\" type to signal when\n\texpression carries an unlimited polymorphic object.\n\nlibgfortran/ChangeLog:\n\n\tPR fortran/100120\n\t* intrinsics/associated.c (associated): have associated verify if\n\tthe \"span\" matches insted of the \"elem_len\".\n\t* libgfortran.h (GFC_DESCRIPTOR_SPAN): add macro to retrive the\n\tdescriptor \"span\".\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/100120\n\t* gfortran.dg/PR100120.f90: New test.\n\tPR fortran/100816\n\tPR fortran/100818\n\tPR fortran/100819\n\tPR fortran/100821\n\t* gfortran.dg/character_workout_1.f90: New test.\n\t* gfortran.dg/character_workout_4.f90: New test.", "tree": {"sha": "b33c075825af5105b83798f664f0314cfed294d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b33c075825af5105b83798f664f0314cfed294d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/comments", "author": {"login": "jrfsousa", "id": 56982651, "node_id": "MDQ6VXNlcjU2OTgyNjUx", "avatar_url": "https://avatars.githubusercontent.com/u/56982651?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jrfsousa", "html_url": "https://github.com/jrfsousa", "followers_url": "https://api.github.com/users/jrfsousa/followers", "following_url": "https://api.github.com/users/jrfsousa/following{/other_user}", "gists_url": "https://api.github.com/users/jrfsousa/gists{/gist_id}", "starred_url": "https://api.github.com/users/jrfsousa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrfsousa/subscriptions", "organizations_url": "https://api.github.com/users/jrfsousa/orgs", "repos_url": "https://api.github.com/users/jrfsousa/repos", "events_url": "https://api.github.com/users/jrfsousa/events{/privacy}", "received_events_url": "https://api.github.com/users/jrfsousa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jrfsousa", "id": 56982651, "node_id": "MDQ6VXNlcjU2OTgyNjUx", "avatar_url": "https://avatars.githubusercontent.com/u/56982651?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jrfsousa", "html_url": "https://github.com/jrfsousa", "followers_url": "https://api.github.com/users/jrfsousa/followers", "following_url": "https://api.github.com/users/jrfsousa/following{/other_user}", "gists_url": "https://api.github.com/users/jrfsousa/gists{/gist_id}", "starred_url": "https://api.github.com/users/jrfsousa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrfsousa/subscriptions", "organizations_url": "https://api.github.com/users/jrfsousa/orgs", "repos_url": "https://api.github.com/users/jrfsousa/repos", "events_url": "https://api.github.com/users/jrfsousa/events{/privacy}", "received_events_url": "https://api.github.com/users/jrfsousa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96963713f6a648a0ed890450e02ebdd8ff583b14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96963713f6a648a0ed890450e02ebdd8ff583b14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96963713f6a648a0ed890450e02ebdd8ff583b14"}], "stats": {"total": 1812, "additions": 1732, "deletions": 80}, "files": [{"sha": "a6bcd2b5ab75504bacc32b4b4077e9b3f244a332", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -860,16 +860,25 @@ gfc_get_array_span (tree desc, gfc_expr *expr)\n \t size of the array. Attempt to deal with unbounded character\n \t types if possible. Otherwise, return NULL_TREE.  */\n       tmp = gfc_get_element_type (TREE_TYPE (desc));\n-      if (tmp && TREE_CODE (tmp) == ARRAY_TYPE\n-\t  && (TYPE_MAX_VALUE (TYPE_DOMAIN (tmp)) == NULL_TREE\n-\t      || integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (tmp)))))\n-\t{\n-\t  if (expr->expr_type == EXPR_VARIABLE\n-\t      && expr->ts.type == BT_CHARACTER)\n-\t    tmp = fold_convert (gfc_array_index_type,\n-\t\t\t\tgfc_get_expr_charlen (expr));\n-\t  else\n-\t    tmp = NULL_TREE;\n+      if (tmp && TREE_CODE (tmp) == ARRAY_TYPE && TYPE_STRING_FLAG (tmp))\n+\t{\n+\t  gcc_assert (expr->ts.type == BT_CHARACTER);\n+\t  \n+\t  tmp = gfc_get_character_len_in_bytes (tmp);\n+\t  \n+\t  if (tmp == NULL_TREE || integer_zerop (tmp))\n+\t    {\n+\t      tree bs;\n+\n+\t      tmp = gfc_get_expr_charlen (expr);\n+\t      tmp = fold_convert (gfc_array_index_type, tmp);\n+\t      bs = build_int_cst (gfc_array_index_type, expr->ts.kind);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp, bs);\n+\t    }\n+\t  \n+\t  tmp = (tmp && !integer_zerop (tmp))\n+\t    ? (fold_convert (gfc_array_index_type, tmp)) : (NULL_TREE);\n \t}\n       else\n \ttmp = fold_convert (gfc_array_index_type,\n@@ -7328,6 +7337,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       expr = expr->value.function.actual->expr;\n     }\n \n+  if (!se->direct_byref)\n+    se->unlimited_polymorphic = UNLIMITED_POLY (expr);\n+  \n   /* Special case things we know we can pass easily.  */\n   switch (expr->expr_type)\n     {\n@@ -7351,9 +7363,11 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  && TREE_CODE (desc) == COMPONENT_REF)\n \tdeferred_array_component = true;\n \n-      subref_array_target = se->direct_byref && is_subref_array (expr);\n-      need_tmp = gfc_ref_needs_temporary_p (expr->ref)\n-\t\t\t&& !subref_array_target;\n+      subref_array_target = (is_subref_array (expr)\n+\t\t\t     && (se->direct_byref\n+\t\t\t\t || expr->ts.type == BT_CHARACTER));\n+      need_tmp = (gfc_ref_needs_temporary_p (expr->ref)\n+\t\t  && !subref_array_target);\n \n       if (se->force_tmp)\n \tneed_tmp = 1;\n@@ -7390,9 +7404,8 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t      subref_array_target, expr);\n \n \t      /* ....and set the span field.  */\n-\t      tmp = gfc_get_array_span (desc, expr);\n-\t      if (tmp != NULL_TREE && !integer_zerop (tmp))\n-\t\tgfc_conv_descriptor_span_set (&se->pre, se->expr, tmp);\n+\t      tmp = gfc_conv_descriptor_span_get (desc);\n+\t      gfc_conv_descriptor_span_set (&se->pre, se->expr, tmp);\n \t    }\n \t  else if (se->want_pointer)\n \t    {\n@@ -7607,6 +7620,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       int dim, ndim, codim;\n       tree parm;\n       tree parmtype;\n+      tree dtype;\n       tree stride;\n       tree from;\n       tree to;\n@@ -7689,7 +7703,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       else\n \t{\n \t  /* Otherwise make a new one.  */\n-\t  if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)\n+\t  if (expr->ts.type == BT_CHARACTER)\n \t    parmtype = gfc_typenode_for_spec (&expr->ts);\n \t  else\n \t    parmtype = gfc_get_element_type (TREE_TYPE (desc));\n@@ -7723,11 +7737,8 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t}\n \n       /* Set the span field.  */\n-      if (expr->ts.type == BT_CHARACTER && ss_info->string_length)\n-\ttmp = ss_info->string_length;\n-      else\n-\ttmp = gfc_get_array_span (desc, expr);\n-      if (tmp != NULL_TREE)\n+      tmp = gfc_get_array_span (desc, expr);\n+      if (tmp)\n \tgfc_conv_descriptor_span_set (&loop.pre, parm, tmp);\n \n       /* The following can be somewhat confusing.  We have two\n@@ -7741,7 +7752,11 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n       /* Set the dtype.  */\n       tmp = gfc_conv_descriptor_dtype (parm);\n-      gfc_add_modify (&loop.pre, tmp, gfc_get_dtype (parmtype));\n+      if (se->unlimited_polymorphic)\n+\tdtype = gfc_get_dtype (TREE_TYPE (desc), &loop.dimen);\n+      else\n+\tdtype = gfc_get_dtype (parmtype);\n+      gfc_add_modify (&loop.pre, tmp, dtype);\n \n       /* The 1st element in the section.  */\n       base = gfc_index_zero_node;"}, {"sha": "e3bc8863f1b3bcdbe7d67506b8659acc30f89f10", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -42,6 +42,45 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dependency.h\"\n #include \"gimplify.h\"\n \n+\n+/* Calculate the number of characters in a string.  */\n+\n+tree\n+gfc_get_character_len (tree type)\n+{\n+  tree len;\n+  \n+  gcc_assert (type && TREE_CODE (type) == ARRAY_TYPE\n+\t      && TYPE_STRING_FLAG (type));\n+  \n+  len = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+  len = (len) ? (len) : (integer_zero_node);\n+  return fold_convert (gfc_charlen_type_node, len);\n+}\n+\n+\n+\n+/* Calculate the number of bytes in a string.  */\n+\n+tree\n+gfc_get_character_len_in_bytes (tree type)\n+{\n+  tree tmp, len;\n+  \n+  gcc_assert (type && TREE_CODE (type) == ARRAY_TYPE\n+\t      && TYPE_STRING_FLAG (type));\n+  \n+  tmp = TYPE_SIZE_UNIT (TREE_TYPE (type));\n+  tmp = (tmp && !integer_zerop (tmp))\n+    ? (fold_convert (gfc_charlen_type_node, tmp)) : (NULL_TREE);\n+  len = gfc_get_character_len (type);\n+  if (tmp && len && !integer_zerop (len))\n+    len = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t   gfc_charlen_type_node, len, tmp);\n+  return len;\n+}\n+\n+\n /* Convert a scalar to an array descriptor. To be used for assumed-rank\n    arrays.  */\n \n@@ -87,6 +126,8 @@ gfc_conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n   gfc_add_modify (&se->pre, gfc_conv_descriptor_dtype (desc),\n \t\t  gfc_get_dtype_rank_type (0, etype));\n   gfc_conv_descriptor_data_set (&se->pre, desc, scalar);\n+  gfc_conv_descriptor_span_set (&se->pre, desc,\n+\t\t\t\tgfc_conv_descriptor_elem_len (desc));\n \n   /* Copy pointer address back - but only if it could have changed and\n      if the actual argument is a pointer and not, e.g., NULL().  */\n@@ -9630,11 +9671,12 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  lse.direct_byref = 1;\n \t  gfc_conv_expr_descriptor (&lse, expr2);\n \t  strlen_rhs = lse.string_length;\n+\t  gfc_init_se (&rse, NULL);\n \n \t  if (expr1->ts.type == BT_CLASS)\n \t    {\n \t      rse.expr = NULL_TREE;\n-\t      rse.string_length = NULL_TREE;\n+\t      rse.string_length = strlen_rhs;\n \t      trans_class_vptr_len_assignment (&block, expr1, expr2, &rse,\n \t\t\t\t\t       NULL, NULL);\n \t    }\n@@ -9694,6 +9736,19 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  gfc_add_modify (&lse.pre, desc, tmp);\n \t}\n \n+      if (expr1->ts.type == BT_CHARACTER\n+\t  && expr1->symtree->n.sym->ts.deferred\n+\t  && expr1->symtree->n.sym->ts.u.cl->backend_decl\n+\t  && VAR_P (expr1->symtree->n.sym->ts.u.cl->backend_decl))\n+\t{\n+\t  tmp = expr1->symtree->n.sym->ts.u.cl->backend_decl;\n+\t  if (expr2->expr_type != EXPR_NULL)\n+\t    gfc_add_modify (&block, tmp,\n+\t\t\t    fold_convert (TREE_TYPE (tmp), strlen_rhs));\n+\t  else\n+\t    gfc_add_modify (&block, tmp, build_zero_cst (TREE_TYPE (tmp)));\n+\t}\n+\n       gfc_add_block_to_block (&block, &lse.pre);\n       if (rank_remap)\n \tgfc_add_block_to_block (&block, &rse.pre);\n@@ -9856,19 +9911,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\t\t\t   msg, rsize, lsize);\n \t}\n \n-      if (expr1->ts.type == BT_CHARACTER\n-\t  && expr1->symtree->n.sym->ts.deferred\n-\t  && expr1->symtree->n.sym->ts.u.cl->backend_decl\n-\t  && VAR_P (expr1->symtree->n.sym->ts.u.cl->backend_decl))\n-\t{\n-\t  tmp = expr1->symtree->n.sym->ts.u.cl->backend_decl;\n-\t  if (expr2->expr_type != EXPR_NULL)\n-\t    gfc_add_modify (&block, tmp,\n-\t\t\t    fold_convert (TREE_TYPE (tmp), strlen_rhs));\n-\t  else\n-\t    gfc_add_modify (&block, tmp, build_zero_cst (TREE_TYPE (tmp)));\n-\t}\n-\n       /* Check string lengths if applicable.  The check is only really added\n \t to the output code if -fbounds-check is enabled.  */\n       if (expr1->ts.type == BT_CHARACTER && expr2->expr_type != EXPR_NULL)"}, {"sha": "73b0bcc9deab15d3aa8772bf70a68c932f23b20c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -9080,6 +9080,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t  gfc_add_block_to_block (&se->post, &arg1se.post);\n \n \t  arg2se.want_pointer = 1;\n+\t  arg2se.force_no_tmp = 1;\n \t  gfc_conv_expr_descriptor (&arg2se, arg2->expr);\n \t  gfc_add_block_to_block (&se->pre, &arg2se.pre);\n \t  gfc_add_block_to_block (&se->post, &arg2se.post);"}, {"sha": "5582e404df9d99daf5790b171a37b1963bd89f94", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -1482,19 +1482,32 @@ gfc_get_desc_dim_type (void)\n tree\n gfc_get_dtype_rank_type (int rank, tree etype)\n {\n+  tree ptype;\n   tree size;\n   int n;\n   tree tmp;\n   tree dtype;\n   tree field;\n   vec<constructor_elt, va_gc> *v = NULL;\n \n-  size = TYPE_SIZE_UNIT (etype);\n+  ptype = etype;\n+  while (TREE_CODE (etype) == POINTER_TYPE\n+\t || TREE_CODE (etype) == ARRAY_TYPE)\n+    {\n+      ptype = etype;\n+      etype = TREE_TYPE (etype);\n+    }\n+\n+  gcc_assert (etype);\n \n   switch (TREE_CODE (etype))\n     {\n     case INTEGER_TYPE:\n-      n = BT_INTEGER;\n+      if (TREE_CODE (ptype) == ARRAY_TYPE\n+\t  && TYPE_STRING_FLAG (ptype))\n+\tn = BT_CHARACTER;\n+      else\n+\tn = BT_INTEGER;\n       break;\n \n     case BOOLEAN_TYPE:\n@@ -1516,27 +1529,36 @@ gfc_get_dtype_rank_type (int rank, tree etype)\n \tn = BT_DERIVED;\n       break;\n \n-    /* We will never have arrays of arrays.  */\n-    case ARRAY_TYPE:\n-      n = BT_CHARACTER;\n-      if (size == NULL_TREE)\n-\tsize = TYPE_SIZE_UNIT (TREE_TYPE (etype));\n+    case FUNCTION_TYPE:\n+    case VOID_TYPE:\n+      n = BT_VOID;\n       break;\n \n-    case POINTER_TYPE:\n-      n = BT_ASSUMED;\n-      if (TREE_CODE (TREE_TYPE (etype)) != VOID_TYPE)\n-\tsize = TYPE_SIZE_UNIT (TREE_TYPE (etype));\n-      else\n-\tsize = build_int_cst (size_type_node, 0);\n-    break;\n-\n     default:\n       /* TODO: Don't do dtype for temporary descriptorless arrays.  */\n       /* We can encounter strange array types for temporary arrays.  */\n-      return gfc_index_zero_node;\n+      gcc_unreachable ();\n     }\n \n+  switch (n)\n+    {\n+    case BT_CHARACTER:\n+      gcc_assert (TREE_CODE (ptype) == ARRAY_TYPE);\n+      size = gfc_get_character_len_in_bytes (ptype);\n+      break;\n+    case BT_VOID:\n+      gcc_assert (TREE_CODE (ptype) == POINTER_TYPE);\n+      size = size_in_bytes (ptype);\n+      break;\n+    default:\n+      size = size_in_bytes (etype);\n+      break;\n+    }\n+      \n+  gcc_assert (size);\n+\n+  STRIP_NOPS (size);\n+  size = fold_convert (size_type_node, size);\n   tmp = get_dtype_type_node ();\n   field = gfc_advance_chain (TYPE_FIELDS (tmp),\n \t\t\t     GFC_DTYPE_ELEM_LEN);\n@@ -1560,17 +1582,17 @@ gfc_get_dtype_rank_type (int rank, tree etype)\n \n \n tree\n-gfc_get_dtype (tree type)\n+gfc_get_dtype (tree type, int * rank)\n {\n   tree dtype;\n   tree etype;\n-  int rank;\n+  int irnk;\n \n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type) || GFC_ARRAY_TYPE_P (type));\n \n-  rank = GFC_TYPE_ARRAY_RANK (type);\n+  irnk = (rank) ? (*rank) : (GFC_TYPE_ARRAY_RANK (type));\n   etype = gfc_get_element_type (type);\n-  dtype = gfc_get_dtype_rank_type (rank, etype);\n+  dtype = gfc_get_dtype_rank_type (irnk, etype);\n \n   GFC_TYPE_ARRAY_DTYPE (type) = dtype;\n   return dtype;\n@@ -1912,7 +1934,11 @@ gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n   TYPE_TYPELESS_STORAGE (fat_type) = 1;\n   gcc_checking_assert (!get_alias_set (base_type) && !get_alias_set (fat_type));\n \n-  tmp = TYPE_NAME (etype);\n+  tmp = etype;\n+  if (TREE_CODE (tmp) == ARRAY_TYPE\n+      && TYPE_STRING_FLAG (tmp))\n+    tmp = TREE_TYPE (etype);\n+  tmp = TYPE_NAME (tmp);\n   if (tmp && TREE_CODE (tmp) == TYPE_DECL)\n     tmp = DECL_NAME (tmp);\n   if (tmp)"}, {"sha": "3b45ce25666e82302e8f8d674b0c4198451edd25", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -114,7 +114,7 @@ int gfc_is_nodesc_array (gfc_symbol *);\n \n /* Return the DTYPE for an array.  */\n tree gfc_get_dtype_rank_type (int, tree);\n-tree gfc_get_dtype (tree);\n+tree gfc_get_dtype (tree, int *rank = NULL);\n \n tree gfc_get_ppc_type (gfc_component *);\n tree gfc_get_caf_vector_type (int dim);"}, {"sha": "f26e91b29e20690165481496272408866492b7b5", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -371,30 +371,16 @@ get_array_span (tree type, tree decl)\n     return gfc_conv_descriptor_span_get (decl);\n \n   /* Return the span for deferred character length array references.  */\n-  if (type && TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n-      && (VAR_P (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t  || TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INDIRECT_REF)\n-      && (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INDIRECT_REF\n-\t  || TREE_CODE (decl) == FUNCTION_DECL\n-\t  || DECL_CONTEXT (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t\t\t\t\t== DECL_CONTEXT (decl)))\n-    {\n-      span = fold_convert (gfc_array_index_type,\n-\t\t\t   TYPE_MAX_VALUE (TYPE_DOMAIN (type)));\n-      span = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t  fold_convert (gfc_array_index_type,\n-\t\t\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (type))),\n-\t\t\t  span);\n-    }\n-  else if (type && TREE_CODE (type) == ARRAY_TYPE\n-\t   && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n-\t   && integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+  if (type && TREE_CODE (type) == ARRAY_TYPE && TYPE_STRING_FLAG (type))\n     {\n+      if (TREE_CODE (decl) == PARM_DECL)\n+\tdecl = build_fold_indirect_ref_loc (input_location, decl);\n       if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n \tspan = gfc_conv_descriptor_span_get (decl);\n       else\n-\tspan = NULL_TREE;\n+\tspan = gfc_get_character_len_in_bytes (type);\n+      span = (span && !integer_zerop (span))\n+\t? (fold_convert (gfc_array_index_type, span)) : (NULL_TREE);\n     }\n   /* Likewise for class array or pointer array references.  */\n   else if (TREE_CODE (decl) == FIELD_DECL"}, {"sha": "d1d4a1d6a921dbf00e30aa50d5700ca019f0fc49", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -53,6 +53,9 @@ typedef struct gfc_se\n      here.  */\n   tree class_vptr;\n \n+  /* Whether expr is a reference to an unlimited polymorphic object.  */\n+  unsigned unlimited_polymorphic:1;\n+  \n   /* If set gfc_conv_variable will return an expression for the array\n      descriptor. When set, want_pointer should also be set.\n      If not set scalarizing variables will be substituted.  */\n@@ -506,6 +509,8 @@ void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);\n \n \n /* trans-expr.c */\n+tree gfc_get_character_len (tree);\n+tree gfc_get_character_len_in_bytes (tree);\n tree gfc_conv_scalar_to_descriptor (gfc_se *, tree, symbol_attribute);\n tree gfc_get_ultimate_alloc_ptr_comps_caf_token (gfc_se *, gfc_expr *);\n void gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr);"}, {"sha": "c1e6c9996394d86218466977cde95fbb67d6c2b0", "filename": "gcc/testsuite/gfortran.dg/PR100120.f90", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100120.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100120.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR100120.f90?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -0,0 +1,198 @@\n+! { dg-do run }\n+!\n+! Tests fix for PR100120\n+!\n+\n+program main_p\n+\n+  implicit none\n+\n+  integer, parameter :: n = 11\n+  integer, parameter :: m = 7\n+  integer, parameter :: c = 63\n+\n+  type :: foo_t\n+    integer :: i\n+  end type foo_t\n+\n+  type, extends(foo_t) :: bar_t\n+    integer :: j(n)\n+  end type bar_t\n+\n+  integer,          target :: ain(n)\n+  character,        target :: ac1(n)\n+  character(len=m), target :: acn(n)\n+  type(foo_t),      target :: afd(n)\n+  type(bar_t),      target :: abd(n)\n+  !\n+  class(foo_t),    pointer :: spf\n+  class(foo_t),    pointer :: apf(:)\n+  class(bar_t),    pointer :: spb\n+  class(bar_t),    pointer :: apb(:)\n+  class(*),        pointer :: spu\n+  class(*),        pointer :: apu(:)\n+  integer                  :: i, j\n+\n+  ain = [(i, i=1,n)]\n+  ac1 = [(achar(i+c), i=1,n)]\n+  do i = 1, n\n+    do j = 1, m\n+      acn(i)(j:j) = achar(i*m+j+c-m)\n+    end do\n+  end do\n+  afd%i = ain\n+  abd%i = ain\n+  do i = 1, n\n+    abd(i)%j = 2*i*ain\n+  end do\n+  !\n+  spf => afd(n)\n+  if(.not.associated(spf))         stop 1\n+  if(.not.associated(spf, afd(n))) stop 2\n+  if(spf%i/=n)                     stop 3\n+  apf => afd\n+  if(.not.associated(apf))         stop 4\n+  if(.not.associated(apf, afd))    stop 5\n+  if(any(apf%i/=afd%i))            stop 6\n+  !\n+  spf => abd(n)\n+  if(.not.associated(spf))         stop 7\n+  if(.not.associated(spf, abd(n))) stop 8\n+  if(spf%i/=n)                     stop 9\n+  select type(spf)\n+  type is(bar_t)\n+    if(any(spf%j/=2*n*ain))        stop 10\n+  class default\n+    stop 11\n+  end select\n+  apf => abd\n+  if(.not.associated(apf))         stop 12\n+  if(.not.associated(apf, abd))    stop 13\n+  if(any(apf%i/=abd%i))            stop 14\n+  select type(apf)\n+  type is(bar_t)\n+    do i = 1, n\n+      if(any(apf(i)%j/=2*i*ain))   stop 15\n+    end do\n+  class default\n+    stop 16\n+  end select\n+  !\n+  spb => abd(n)\n+  if(.not.associated(spb))         stop 17\n+  if(.not.associated(spb, abd(n))) stop 18\n+  if(spb%i/=n)                     stop 19\n+  if(any(spb%j/=2*n*ain))          stop 20\n+  apb => abd\n+  if(.not.associated(apb))         stop 21\n+  if(.not.associated(apb, abd))    stop 22\n+  if(any(apb%i/=abd%i))            stop 23\n+  do i = 1, n\n+    if(any(apb(i)%j/=2*i*ain))     stop 24\n+  end do\n+  !\n+  spu => ain(n)\n+  if(.not.associated(spu))         stop 25\n+  if(.not.associated(spu, ain(n))) stop 26\n+  select type(spu)\n+  type is(integer)\n+    if(spu/=n)                     stop 27\n+  class default\n+    stop 28\n+  end select\n+  apu => ain\n+  if(.not.associated(apu))         stop 29\n+  if(.not.associated(apu, ain))    stop 30\n+  select type(apu)\n+  type is(integer)\n+    if(any(apu/=ain))              stop 31\n+  class default\n+    stop 32\n+  end select\n+  !\n+  spu => ac1(n)\n+  if(.not.associated(spu))         stop 33\n+  if(.not.associated(spu, ac1(n))) stop 34\n+  select type(spu)\n+  type is(character(len=*))\n+    if(len(spu)/=1)                stop 35\n+    if(spu/=ac1(n))                stop 36\n+  class default\n+    stop 37\n+  end select\n+  apu => ac1\n+  if(.not.associated(apu))         stop 38\n+  if(.not.associated(apu, ac1))    stop 39\n+  select type(apu)\n+  type is(character(len=*))\n+    if(len(apu)/=1)                stop 40\n+    if(any(apu/=ac1))              stop 41\n+  class default\n+    stop 42\n+  end select\n+  !\n+  spu => acn(n)\n+  if(.not.associated(spu))         stop 43\n+  if(.not.associated(spu, acn(n))) stop 44\n+  select type(spu)\n+  type is(character(len=*))\n+    if(len(spu)/=m)                stop 45\n+    if(spu/=acn(n))                stop 46\n+  class default\n+    stop 47\n+  end select\n+  apu => acn\n+  if(.not.associated(apu))         stop 48\n+  if(.not.associated(apu, acn))    stop 49\n+  select type(apu)\n+  type is(character(len=*))\n+    if(len(apu)/=m)                stop 50\n+    if(any(apu/=acn))              stop 51\n+  class default\n+    stop 52\n+  end select\n+  !\n+  spu => afd(n)\n+  if(.not.associated(spu))         stop 53\n+  if(.not.associated(spu, afd(n))) stop 54\n+  select type(spu)\n+  type is(foo_t)\n+    if(spu%i/=n)                   stop 55\n+  class default\n+    stop 56\n+  end select\n+  apu => afd\n+  if(.not.associated(apu))         stop 57\n+  if(.not.associated(apu, afd))    stop 58\n+  select type(apu)\n+  type is(foo_t)\n+    if(any(apu%i/=afd%i))          stop 59\n+  class default\n+    stop 60\n+  end select\n+  !\n+  spu => abd(n)\n+  if(.not.associated(spu))         stop 61\n+  if(.not.associated(spu, abd(n))) stop 62\n+  select type(spu)\n+  type is(bar_t)\n+    if(spu%i/=n)                   stop 63\n+    if(any(spu%j/=2*n*ain))        stop 64\n+  class default\n+    stop 65\n+  end select\n+  apu => abd\n+  if(.not.associated(apu))         stop 66\n+  if(.not.associated(apu, abd))    stop 67\n+  select type(apu)\n+  type is(bar_t)\n+    if(any(apu%i/=abd%i))          stop 68\n+    do i = 1, n\n+      if(any(apu(i)%j/=2*i*ain))   stop 69\n+    end do\n+  class default\n+    stop 70\n+  end select\n+  stop\n+\n+end program main_p"}, {"sha": "98133b48960a7accf0a53dcd1174f13e196ebb2d", "filename": "gcc/testsuite/gfortran.dg/character_workout_1.f90", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_workout_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_workout_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_workout_1.f90?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -0,0 +1,689 @@\n+! { dg-do run }\n+!\n+! Tests fix for PR100120/100816/100818/100819/100821\n+! \n+\n+program main_p\n+\n+  implicit none\n+\n+  integer, parameter :: k = 1\n+  integer, parameter :: n = 11\n+  integer, parameter :: m = 7\n+  integer, parameter :: l = 3\n+  integer, parameter :: u = 5\n+  integer, parameter :: e = u-l+1\n+  integer, parameter :: c = 61\n+\n+  character(kind=k),         target :: c1(n)\n+  character(len=m, kind=k),  target :: cm(n)\n+  !\n+  character(kind=k),        pointer :: s1\n+  character(len=m, kind=k), pointer :: sm\n+  character(len=e, kind=k), pointer :: se\n+  character(len=:, kind=k), pointer :: sd\n+  !\n+  character(kind=k),        pointer :: p1(:)\n+  character(len=m, kind=k), pointer :: pm(:)\n+  character(len=e, kind=k), pointer :: pe(:)\n+  character(len=:, kind=k), pointer :: pd(:)\n+  \n+  class(*),                 pointer :: su\n+  class(*),                 pointer :: pu(:)\n+  \n+  integer :: i, j\n+\n+  nullify(s1, sm, se, sd, su)\n+  nullify(p1, pm, pe, pd, pu)\n+  c1 = [(char(i+c, kind=k), i=1,n)]\n+  do i = 1, n\n+    do j = 1, m\n+      cm(i)(j:j) = char(i*m+j+c-m, kind=k)\n+    end do\n+  end do\n+  \n+  s1 => c1(n)\n+  if(.not.associated(s1))              stop 1\n+  if(.not.associated(s1, c1(n)))       stop 2\n+  if(len(s1)/=1)                       stop 3\n+  if(s1/=c1(n))                        stop 4\n+  call schar_c1(s1)\n+  call schar_a1(s1)\n+  p1 => c1\n+  if(.not.associated(p1))              stop 5\n+  if(.not.associated(p1, c1))          stop 6\n+  if(len(p1)/=1)                       stop 7\n+  if(any(p1/=c1))                      stop 8\n+  call achar_c1(p1)\n+  call achar_a1(p1)\n+  !\n+  sm => cm(n)\n+  if(.not.associated(sm))              stop 9\n+  if(.not.associated(sm, cm(n)))       stop 10\n+  if(len(sm)/=m)                       stop 11\n+  if(sm/=cm(n))                        stop 12\n+  call schar_cm(sm)\n+  call schar_am(sm)\n+  pm => cm\n+  if(.not.associated(pm))              stop 13\n+  if(.not.associated(pm, cm))          stop 14\n+  if(len(pm)/=m)                       stop 15\n+  if(any(pm/=cm))                      stop 16\n+  call achar_cm(pm)\n+  call achar_am(pm)\n+  !\n+  se => cm(n)(l:u)\n+  if(.not.associated(se))              stop 17\n+  if(.not.associated(se, cm(n)(l:u)))  stop 18\n+  if(len(se)/=e)                       stop 19\n+  if(se/=cm(n)(l:u))                   stop 20\n+  call schar_ce(se)\n+  call schar_ae(se)\n+  pe => cm(:)(l:u)\n+  if(.not.associated(pe))              stop 21\n+  if(.not.associated(pe, cm(:)(l:u)))  stop 22\n+  if(len(pe)/=e)                       stop 23\n+  if(any(pe/=cm(:)(l:u)))              stop 24\n+  call achar_ce(pe)\n+  call achar_ae(pe)\n+  !\n+  sd => c1(n)\n+  if(.not.associated(sd))              stop 25\n+  if(.not.associated(sd, c1(n)))       stop 26\n+  if(len(sd)/=1)                       stop 27\n+  if(sd/=c1(n))                        stop 28\n+  call schar_d1(sd)\n+  pd => c1\n+  if(.not.associated(pd))              stop 29\n+  if(.not.associated(pd, c1))          stop 30\n+  if(len(pd)/=1)                       stop 31\n+  if(any(pd/=c1))                      stop 32\n+  call achar_d1(pd)\n+  !\n+  sd => cm(n)\n+  if(.not.associated(sd))              stop 33\n+  if(.not.associated(sd, cm(n)))       stop 34\n+  if(len(sd)/=m)                       stop 35\n+  if(sd/=cm(n))                        stop 36\n+  call schar_dm(sd)\n+  pd => cm\n+  if(.not.associated(pd))              stop 37\n+  if(.not.associated(pd, cm))          stop 38\n+  if(len(pd)/=m)                       stop 39\n+  if(any(pd/=cm))                      stop 40\n+  call achar_dm(pd)\n+  !\n+  sd => cm(n)(l:u)\n+  if(.not.associated(sd))              stop 41\n+  if(.not.associated(sd, cm(n)(l:u)))  stop 42\n+  if(len(sd)/=e)                       stop 43\n+  if(sd/=cm(n)(l:u))                   stop 44\n+  call schar_de(sd)\n+  pd => cm(:)(l:u)\n+  if(.not.associated(pd))              stop 45\n+  if(.not.associated(pd, cm(:)(l:u)))  stop 46\n+  if(len(pd)/=e)                       stop 47\n+  if(any(pd/=cm(:)(l:u)))              stop 48\n+  call achar_de(pd)\n+  !\n+  sd => c1(n)\n+  s1 => sd\n+  if(.not.associated(s1))              stop 49\n+  if(.not.associated(s1, c1(n)))       stop 50\n+  if(len(s1)/=1)                       stop 51\n+  if(s1/=c1(n))                        stop 52\n+  call schar_c1(s1)\n+  call schar_a1(s1)\n+  pd => c1\n+  s1 => pd(n)\n+  if(.not.associated(s1))              stop 53\n+  if(.not.associated(s1, c1(n)))       stop 54\n+  if(len(s1)/=1)                       stop 55\n+  if(s1/=c1(n))                        stop 56\n+  call schar_c1(s1)\n+  call schar_a1(s1)\n+  pd => c1\n+  p1 => pd\n+  if(.not.associated(p1))              stop 57\n+  if(.not.associated(p1, c1))          stop 58\n+  if(len(p1)/=1)                       stop 59\n+  if(any(p1/=c1))                      stop 60\n+  call achar_c1(p1)\n+  call achar_a1(p1)\n+  !\n+  sd => cm(n)\n+  sm => sd\n+  if(.not.associated(sm))              stop 61\n+  if(.not.associated(sm, cm(n)))       stop 62\n+  if(len(sm)/=m)                       stop 63\n+  if(sm/=cm(n))                        stop 64\n+  call schar_cm(sm)\n+  call schar_am(sm)\n+  pd => cm\n+  sm => pd(n)\n+  if(.not.associated(sm))              stop 65\n+  if(.not.associated(sm, cm(n)))       stop 66\n+  if(len(sm)/=m)                       stop 67\n+  if(sm/=cm(n))                        stop 68\n+  call schar_cm(sm)\n+  call schar_am(sm)\n+  pd => cm\n+  pm => pd\n+  if(.not.associated(pm))              stop 69\n+  if(.not.associated(pm, cm))          stop 70\n+  if(len(pm)/=m)                       stop 71\n+  if(any(pm/=cm))                      stop 72\n+  call achar_cm(pm)\n+  call achar_am(pm)\n+  !\n+  sd => cm(n)(l:u)\n+  se => sd\n+  if(.not.associated(se))              stop 73\n+  if(.not.associated(se, cm(n)(l:u)))  stop 74\n+  if(len(se)/=e)                       stop 75\n+  if(se/=cm(n)(l:u))                   stop 76\n+  call schar_ce(se)\n+  call schar_ae(se)\n+  pd => cm(:)(l:u)\n+  pe => pd\n+  if(.not.associated(pe))              stop 77\n+  if(.not.associated(pe, cm(:)(l:u)))  stop 78\n+  if(len(pe)/=e)                       stop 79\n+  if(any(pe/=cm(:)(l:u)))              stop 80\n+  call achar_ce(pe)\n+  call achar_ae(pe)\n+  !\n+  su => c1(n)\n+  if(.not.associated(su))              stop 81\n+  if(.not.associated(su, c1(n)))       stop 82\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=1)                     stop 83\n+    if(su/=c1(n))                      stop 84\n+  class default\n+    stop 85\n+  end select\n+  call schar_u1(su)\n+  pu => c1\n+  if(.not.associated(pu))              stop 86\n+  if(.not.associated(pu, c1))          stop 87\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=1)                     stop 88\n+    if(any(pu/=c1))                    stop 89\n+  class default\n+    stop 90\n+  end select\n+  call achar_u1(pu)\n+  !\n+  su => cm(n)\n+  if(.not.associated(su))              stop 91\n+  if(.not.associated(su))              stop 92\n+  if(.not.associated(su, cm(n)))       stop 93\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=m)                     stop 94\n+    if(su/=cm(n))                      stop 95\n+  class default\n+    stop 96\n+  end select\n+  call schar_um(su)\n+  pu => cm\n+  if(.not.associated(pu))              stop 97\n+  if(.not.associated(pu, cm))          stop 98\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=m)                     stop 99\n+    if(any(pu/=cm))                    stop 100\n+  class default\n+    stop 101\n+  end select\n+  call achar_um(pu)\n+  !\n+  su => cm(n)(l:u)\n+  if(.not.associated(su))              stop 102\n+  if(.not.associated(su, cm(n)(l:u)))  stop 103\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 104\n+    if(su/=cm(n)(l:u))                 stop 105\n+  class default\n+    stop 106\n+  end select\n+  call schar_ue(su)\n+  pu => cm(:)(l:u)\n+  if(.not.associated(pu))              stop 107\n+  if(.not.associated(pu, cm(:)(l:u)))  stop 108\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=e)                     stop 109\n+    if(any(pu/=cm(:)(l:u)))            stop 110\n+  class default\n+    stop 111\n+  end select\n+  call achar_ue(pu)\n+  !\n+  sd => c1(n)\n+  su => sd\n+  if(.not.associated(su))              stop 112\n+  if(.not.associated(su, c1(n)))       stop 113\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=1)                     stop 114\n+    if(su/=c1(n))                      stop 115\n+  class default\n+    stop 116\n+  end select\n+  call schar_u1(su)\n+  pd => c1\n+  su => pd(n)\n+  if(.not.associated(su))              stop 117\n+  if(.not.associated(su, c1(n)))       stop 118\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=1)                     stop 119\n+    if(su/=c1(n))                      stop 120\n+  class default\n+    stop 121\n+  end select\n+  call schar_u1(su)\n+  pd => c1\n+  pu => pd\n+  if(.not.associated(pu))              stop 122\n+  if(.not.associated(pu, c1))          stop 123\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=1)                     stop 124\n+    if(any(pu/=c1))                    stop 125\n+  class default\n+    stop 126\n+  end select\n+  call achar_u1(pu)\n+  !\n+  sd => cm(n)\n+  su => sd\n+  if(.not.associated(su))              stop 127\n+  if(.not.associated(su, cm(n)))       stop 128\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=m)                     stop 129\n+    if(su/=cm(n))                      stop 130\n+  class default\n+    stop 131\n+  end select\n+  call schar_um(su)\n+  pd => cm\n+  su => pd(n)\n+  if(.not.associated(su))              stop 132\n+  if(.not.associated(su, cm(n)))       stop 133\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=m)                     stop 134\n+    if(su/=cm(n))                      stop 135\n+  class default\n+    stop 136\n+  end select\n+  call schar_um(su)\n+  pd => cm\n+  pu => pd\n+  if(.not.associated(pu))              stop 137\n+  if(.not.associated(pu, cm))          stop 138\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=m)                     stop 139\n+    if(any(pu/=cm))                    stop 140\n+  class default\n+    stop 141\n+  end select\n+  call achar_um(pu)\n+  !\n+  sd => cm(n)(l:u)\n+  su => sd\n+  if(.not.associated(su))              stop 142\n+  if(.not.associated(su, cm(n)(l:u)))  stop 143\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 144\n+    if(su/=cm(n)(l:u))                 stop 145\n+  class default\n+    stop 146\n+  end select\n+  call schar_ue(su)\n+  pd => cm(:)(l:u)\n+  su => pd(n)\n+  if(.not.associated(su))              stop 147\n+  if(.not.associated(su, cm(n)(l:u)))  stop 148\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 149\n+    if(su/=cm(n)(l:u))                 stop 150\n+  class default\n+    stop 151\n+  end select\n+  call schar_ue(su)\n+  pd => cm(:)(l:u)\n+  pu => pd\n+  if(.not.associated(pu))              stop 152\n+  if(.not.associated(pu, cm(:)(l:u)))  stop 153\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=e)                     stop 154\n+    if(any(pu/=cm(:)(l:u)))            stop 155\n+  class default\n+    stop 156\n+  end select\n+  call achar_ue(pu)\n+  !\n+  sd => cm(n)\n+  su => sd(l:u)\n+  if(.not.associated(su))              stop 157\n+  if(.not.associated(su, cm(n)(l:u)))  stop 158\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 159\n+    if(su/=cm(n)(l:u))                 stop 160\n+  class default\n+    stop 161\n+  end select\n+  call schar_ue(su)\n+  pd => cm(:)\n+  su => pd(n)(l:u)\n+  if(.not.associated(su))              stop 162\n+  if(.not.associated(su, cm(n)(l:u)))  stop 163\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 164\n+    if(su/=cm(n)(l:u))                 stop 165\n+  class default\n+    stop 166\n+  end select\n+  call schar_ue(su)\n+  pd => cm\n+  pu => pd(:)(l:u)\n+  if(.not.associated(pu))              stop 167\n+  if(.not.associated(pu, cm(:)(l:u)))  stop 168\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=e)                     stop 169\n+    if(any(pu/=cm(:)(l:u)))            stop 170\n+  class default\n+    stop 171\n+  end select\n+  call achar_ue(pu)\n+  !\n+  stop\n+\n+contains\n+\n+  subroutine schar_c1(a)\n+    character(kind=k), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 172\n+    if(.not.associated(a, c1(n)))      stop 173\n+    if(len(a)/=1)                      stop 174\n+    if(a/=c1(n))                       stop 175\n+    return\n+  end subroutine schar_c1\n+\n+  subroutine achar_c1(a)\n+    character(kind=k), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 176\n+    if(.not.associated(a, c1))         stop 177\n+    if(len(a)/=1)                      stop 178\n+    if(any(a/=c1))                     stop 179\n+    return\n+  end subroutine achar_c1\n+\n+  subroutine schar_cm(a)\n+    character(kind=k, len=m), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 180\n+    if(.not.associated(a, cm(n)))      stop 181\n+    if(len(a)/=m)                      stop 182\n+    if(a/=cm(n))                       stop 183\n+    return\n+  end subroutine schar_cm\n+\n+  subroutine achar_cm(a)\n+    character(kind=k, len=m), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 184\n+    if(.not.associated(a, cm))         stop 185\n+    if(len(a)/=m)                      stop 186\n+    if(any(a/=cm))                     stop 187\n+    return\n+  end subroutine achar_cm\n+\n+  subroutine schar_ce(a)\n+    character(kind=k, len=e), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 188\n+    if(.not.associated(a, cm(n)(l:u))) stop 189\n+    if(len(a)/=e)                      stop 190\n+    if(a/=cm(n)(l:u))                  stop 191\n+    return\n+  end subroutine schar_ce\n+\n+  subroutine achar_ce(a)\n+    character(kind=k, len=e), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 192\n+    if(.not.associated(a, cm(:)(l:u))) stop 193\n+    if(len(a)/=e)                      stop 194\n+    if(any(a/=cm(:)(l:u)))             stop 195\n+    return\n+  end subroutine achar_ce\n+\n+  subroutine schar_a1(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 196\n+    if(.not.associated(a, c1(n)))      stop 197\n+    if(len(a)/=1)                      stop 198\n+    if(a/=c1(n))                       stop 199\n+    return\n+  end subroutine schar_a1\n+\n+  subroutine achar_a1(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 200\n+    if(.not.associated(a, c1))         stop 201\n+    if(len(a)/=1)                      stop 202\n+    if(any(a/=c1))                     stop 203\n+    return\n+  end subroutine achar_a1\n+\n+  subroutine schar_am(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 204\n+    if(.not.associated(a, cm(n)))      stop 205\n+    if(len(a)/=m)                      stop 206\n+    if(a/=cm(n))                       stop 207\n+    return\n+  end subroutine schar_am\n+\n+  subroutine achar_am(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 208\n+    if(.not.associated(a, cm))         stop 209\n+    if(len(a)/=m)                      stop 210\n+    if(any(a/=cm))                     stop 211\n+    return\n+  end subroutine achar_am\n+\n+  subroutine schar_ae(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 212\n+    if(.not.associated(a, cm(n)(l:u))) stop 213\n+    if(len(a)/=e)                      stop 214\n+    if(a/=cm(n)(l:u))                  stop 215\n+    return\n+  end subroutine schar_ae\n+\n+  subroutine achar_ae(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 216\n+    if(.not.associated(a, cm(:)(l:u))) stop 217\n+    if(len(a)/=e)                      stop 218\n+    if(any(a/=cm(:)(l:u)))             stop 219\n+    return\n+  end subroutine achar_ae\n+\n+  subroutine schar_d1(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 220\n+    if(.not.associated(a, c1(n)))      stop 221\n+    if(len(a)/=1)                      stop 222\n+    if(a/=c1(n))                       stop 223\n+    return\n+  end subroutine schar_d1\n+\n+  subroutine achar_d1(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 224\n+    if(.not.associated(a, c1))         stop 225\n+    if(len(a)/=1)                      stop 226\n+    if(any(a/=c1))                     stop 227\n+    return\n+  end subroutine achar_d1\n+\n+  subroutine schar_dm(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 228\n+    if(.not.associated(a, cm(n)))      stop 229\n+    if(len(a)/=m)                      stop 230\n+    if(a/=cm(n))                       stop 231\n+    return\n+  end subroutine schar_dm\n+\n+  subroutine achar_dm(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 232\n+    if(.not.associated(a, cm))         stop 233\n+    if(len(a)/=m)                      stop 234\n+    if(any(a/=cm))                     stop 235\n+    return\n+  end subroutine achar_dm\n+\n+  subroutine schar_de(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 236\n+    if(.not.associated(a, cm(n)(l:u))) stop 237\n+    if(len(a)/=e)                      stop 238\n+    if(a/=cm(n)(l:u))                  stop 239\n+    return\n+  end subroutine schar_de\n+\n+  subroutine achar_de(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 240\n+    if(.not.associated(a, cm(:)(l:u))) stop 241\n+    if(len(a)/=e)                      stop 242\n+    if(any(a/=cm(:)(l:u)))             stop 243\n+    return\n+  end subroutine achar_de\n+\n+  subroutine schar_u1(a)\n+    class(*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 244\n+    if(.not.associated(a, c1(n)))      stop 245\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=1)                    stop 246\n+      if(a/=c1(n))                     stop 247\n+    class default\n+      stop 248\n+    end select\n+    return\n+  end subroutine schar_u1\n+\n+  subroutine achar_u1(a)\n+    class(*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 249\n+    if(.not.associated(a, c1))         stop 250\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=1)                    stop 251\n+      if(any(a/=c1))                   stop 252\n+    class default\n+      stop 253\n+    end select\n+    return\n+  end subroutine achar_u1\n+\n+  subroutine schar_um(a)\n+    class(*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 254\n+    if(.not.associated(a))             stop 255\n+    if(.not.associated(a, cm(n)))      stop 256\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=m)                    stop 257\n+      if(a/=cm(n))                     stop 258\n+    class default\n+      stop 259\n+    end select\n+    return\n+  end subroutine schar_um\n+\n+  subroutine achar_um(a)\n+    class(*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 260\n+    if(.not.associated(a, cm))         stop 261\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=m)                    stop 262\n+      if(any(a/=cm))                   stop 263\n+    class default\n+      stop 264\n+    end select\n+    return\n+  end subroutine achar_um\n+\n+  subroutine schar_ue(a)\n+    class(*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 265\n+    if(.not.associated(a, cm(n)(l:u))) stop 266\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=e)                    stop 267\n+      if(a/=cm(n)(l:u))                stop 268\n+    class default\n+      stop 269\n+    end select\n+    return\n+  end subroutine schar_ue\n+\n+  subroutine achar_ue(a)\n+    class(*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 270\n+    if(.not.associated(a, cm(:)(l:u))) stop 271\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=e)                    stop 272\n+      if(any(a/=cm(:)(l:u)))           stop 273\n+    class default\n+      stop 274\n+    end select\n+    return\n+  end subroutine achar_ue\n+\n+end program main_p"}, {"sha": "993c742c76c86445a62c504e75e05e6bbf144864", "filename": "gcc/testsuite/gfortran.dg/character_workout_4.f90", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_workout_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_workout_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_workout_4.f90?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -0,0 +1,689 @@\n+! { dg-do run }\n+!\n+! Tests fix for PR100120/100816/100818/100819/100821\n+! \n+\n+program main_p\n+\n+  implicit none\n+\n+  integer, parameter :: k = 4\n+  integer, parameter :: n = 11\n+  integer, parameter :: m = 7\n+  integer, parameter :: l = 3\n+  integer, parameter :: u = 5\n+  integer, parameter :: e = u-l+1\n+  integer, parameter :: c = int(z\"FF00\")\n+\n+  character(kind=k),         target :: c1(n)\n+  character(len=m, kind=k),  target :: cm(n)\n+  !\n+  character(kind=k),        pointer :: s1\n+  character(len=m, kind=k), pointer :: sm\n+  character(len=e, kind=k), pointer :: se\n+  character(len=:, kind=k), pointer :: sd\n+  !\n+  character(kind=k),        pointer :: p1(:)\n+  character(len=m, kind=k), pointer :: pm(:)\n+  character(len=e, kind=k), pointer :: pe(:)\n+  character(len=:, kind=k), pointer :: pd(:)\n+  \n+  class(*),                 pointer :: su\n+  class(*),                 pointer :: pu(:)\n+  \n+  integer :: i, j\n+\n+  nullify(s1, sm, se, sd, su)\n+  nullify(p1, pm, pe, pd, pu)\n+  c1 = [(char(i+c, kind=k), i=1,n)]\n+  do i = 1, n\n+    do j = 1, m\n+      cm(i)(j:j) = char(i*m+j+c-m, kind=k)\n+    end do\n+  end do\n+  \n+  s1 => c1(n)\n+  if(.not.associated(s1))              stop 1\n+  if(.not.associated(s1, c1(n)))       stop 2\n+  if(len(s1)/=1)                       stop 3\n+  if(s1/=c1(n))                        stop 4\n+  call schar_c1(s1)\n+  call schar_a1(s1)\n+  p1 => c1\n+  if(.not.associated(p1))              stop 5\n+  if(.not.associated(p1, c1))          stop 6\n+  if(len(p1)/=1)                       stop 7\n+  if(any(p1/=c1))                      stop 8\n+  call achar_c1(p1)\n+  call achar_a1(p1)\n+  !\n+  sm => cm(n)\n+  if(.not.associated(sm))              stop 9\n+  if(.not.associated(sm, cm(n)))       stop 10\n+  if(len(sm)/=m)                       stop 11\n+  if(sm/=cm(n))                        stop 12\n+  call schar_cm(sm)\n+  call schar_am(sm)\n+  pm => cm\n+  if(.not.associated(pm))              stop 13\n+  if(.not.associated(pm, cm))          stop 14\n+  if(len(pm)/=m)                       stop 15\n+  if(any(pm/=cm))                      stop 16\n+  call achar_cm(pm)\n+  call achar_am(pm)\n+  !\n+  se => cm(n)(l:u)\n+  if(.not.associated(se))              stop 17\n+  if(.not.associated(se, cm(n)(l:u)))  stop 18\n+  if(len(se)/=e)                       stop 19\n+  if(se/=cm(n)(l:u))                   stop 20\n+  call schar_ce(se)\n+  call schar_ae(se)\n+  pe => cm(:)(l:u)\n+  if(.not.associated(pe))              stop 21\n+  if(.not.associated(pe, cm(:)(l:u)))  stop 22\n+  if(len(pe)/=e)                       stop 23\n+  if(any(pe/=cm(:)(l:u)))              stop 24\n+  call achar_ce(pe)\n+  call achar_ae(pe)\n+  !\n+  sd => c1(n)\n+  if(.not.associated(sd))              stop 25\n+  if(.not.associated(sd, c1(n)))       stop 26\n+  if(len(sd)/=1)                       stop 27\n+  if(sd/=c1(n))                        stop 28\n+  call schar_d1(sd)\n+  pd => c1\n+  if(.not.associated(pd))              stop 29\n+  if(.not.associated(pd, c1))          stop 30\n+  if(len(pd)/=1)                       stop 31\n+  if(any(pd/=c1))                      stop 32\n+  call achar_d1(pd)\n+  !\n+  sd => cm(n)\n+  if(.not.associated(sd))              stop 33\n+  if(.not.associated(sd, cm(n)))       stop 34\n+  if(len(sd)/=m)                       stop 35\n+  if(sd/=cm(n))                        stop 36\n+  call schar_dm(sd)\n+  pd => cm\n+  if(.not.associated(pd))              stop 37\n+  if(.not.associated(pd, cm))          stop 38\n+  if(len(pd)/=m)                       stop 39\n+  if(any(pd/=cm))                      stop 40\n+  call achar_dm(pd)\n+  !\n+  sd => cm(n)(l:u)\n+  if(.not.associated(sd))              stop 41\n+  if(.not.associated(sd, cm(n)(l:u)))  stop 42\n+  if(len(sd)/=e)                       stop 43\n+  if(sd/=cm(n)(l:u))                   stop 44\n+  call schar_de(sd)\n+  pd => cm(:)(l:u)\n+  if(.not.associated(pd))              stop 45\n+  if(.not.associated(pd, cm(:)(l:u)))  stop 46\n+  if(len(pd)/=e)                       stop 47\n+  if(any(pd/=cm(:)(l:u)))              stop 48\n+  call achar_de(pd)\n+  !\n+  sd => c1(n)\n+  s1 => sd\n+  if(.not.associated(s1))              stop 49\n+  if(.not.associated(s1, c1(n)))       stop 50\n+  if(len(s1)/=1)                       stop 51\n+  if(s1/=c1(n))                        stop 52\n+  call schar_c1(s1)\n+  call schar_a1(s1)\n+  pd => c1\n+  s1 => pd(n)\n+  if(.not.associated(s1))              stop 53\n+  if(.not.associated(s1, c1(n)))       stop 54\n+  if(len(s1)/=1)                       stop 55\n+  if(s1/=c1(n))                        stop 56\n+  call schar_c1(s1)\n+  call schar_a1(s1)\n+  pd => c1\n+  p1 => pd\n+  if(.not.associated(p1))              stop 57\n+  if(.not.associated(p1, c1))          stop 58\n+  if(len(p1)/=1)                       stop 59\n+  if(any(p1/=c1))                      stop 60\n+  call achar_c1(p1)\n+  call achar_a1(p1)\n+  !\n+  sd => cm(n)\n+  sm => sd\n+  if(.not.associated(sm))              stop 61\n+  if(.not.associated(sm, cm(n)))       stop 62\n+  if(len(sm)/=m)                       stop 63\n+  if(sm/=cm(n))                        stop 64\n+  call schar_cm(sm)\n+  call schar_am(sm)\n+  pd => cm\n+  sm => pd(n)\n+  if(.not.associated(sm))              stop 65\n+  if(.not.associated(sm, cm(n)))       stop 66\n+  if(len(sm)/=m)                       stop 67\n+  if(sm/=cm(n))                        stop 68\n+  call schar_cm(sm)\n+  call schar_am(sm)\n+  pd => cm\n+  pm => pd\n+  if(.not.associated(pm))              stop 69\n+  if(.not.associated(pm, cm))          stop 70\n+  if(len(pm)/=m)                       stop 71\n+  if(any(pm/=cm))                      stop 72\n+  call achar_cm(pm)\n+  call achar_am(pm)\n+  !\n+  sd => cm(n)(l:u)\n+  se => sd\n+  if(.not.associated(se))              stop 73\n+  if(.not.associated(se, cm(n)(l:u)))  stop 74\n+  if(len(se)/=e)                       stop 75\n+  if(se/=cm(n)(l:u))                   stop 76\n+  call schar_ce(se)\n+  call schar_ae(se)\n+  pd => cm(:)(l:u)\n+  pe => pd\n+  if(.not.associated(pe))              stop 77\n+  if(.not.associated(pe, cm(:)(l:u)))  stop 78\n+  if(len(pe)/=e)                       stop 79\n+  if(any(pe/=cm(:)(l:u)))              stop 80\n+  call achar_ce(pe)\n+  call achar_ae(pe)\n+  !\n+  su => c1(n)\n+  if(.not.associated(su))              stop 81\n+  if(.not.associated(su, c1(n)))       stop 82\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=1)                     stop 83\n+    if(su/=c1(n))                      stop 84\n+  class default\n+    stop 85\n+  end select\n+  call schar_u1(su)\n+  pu => c1\n+  if(.not.associated(pu))              stop 86\n+  if(.not.associated(pu, c1))          stop 87\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=1)                     stop 88\n+    if(any(pu/=c1))                    stop 89\n+  class default\n+    stop 90\n+  end select\n+  call achar_u1(pu)\n+  !\n+  su => cm(n)\n+  if(.not.associated(su))              stop 91\n+  if(.not.associated(su))              stop 92\n+  if(.not.associated(su, cm(n)))       stop 93\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=m)                     stop 94\n+    if(su/=cm(n))                      stop 95\n+  class default\n+    stop 96\n+  end select\n+  call schar_um(su)\n+  pu => cm\n+  if(.not.associated(pu))              stop 97\n+  if(.not.associated(pu, cm))          stop 98\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=m)                     stop 99\n+    if(any(pu/=cm))                    stop 100\n+  class default\n+    stop 101\n+  end select\n+  call achar_um(pu)\n+  !\n+  su => cm(n)(l:u)\n+  if(.not.associated(su))              stop 102\n+  if(.not.associated(su, cm(n)(l:u)))  stop 103\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 104\n+    if(su/=cm(n)(l:u))                 stop 105\n+  class default\n+    stop 106\n+  end select\n+  call schar_ue(su)\n+  pu => cm(:)(l:u)\n+  if(.not.associated(pu))              stop 107\n+  if(.not.associated(pu, cm(:)(l:u)))  stop 108\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=e)                     stop 109\n+    if(any(pu/=cm(:)(l:u)))            stop 110\n+  class default\n+    stop 111\n+  end select\n+  call achar_ue(pu)\n+  !\n+  sd => c1(n)\n+  su => sd\n+  if(.not.associated(su))              stop 112\n+  if(.not.associated(su, c1(n)))       stop 113\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=1)                     stop 114\n+    if(su/=c1(n))                      stop 115\n+  class default\n+    stop 116\n+  end select\n+  call schar_u1(su)\n+  pd => c1\n+  su => pd(n)\n+  if(.not.associated(su))              stop 117\n+  if(.not.associated(su, c1(n)))       stop 118\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=1)                     stop 119\n+    if(su/=c1(n))                      stop 120\n+  class default\n+    stop 121\n+  end select\n+  call schar_u1(su)\n+  pd => c1\n+  pu => pd\n+  if(.not.associated(pu))              stop 122\n+  if(.not.associated(pu, c1))          stop 123\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=1)                     stop 124\n+    if(any(pu/=c1))                    stop 125\n+  class default\n+    stop 126\n+  end select\n+  call achar_u1(pu)\n+  !\n+  sd => cm(n)\n+  su => sd\n+  if(.not.associated(su))              stop 127\n+  if(.not.associated(su, cm(n)))       stop 128\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=m)                     stop 129\n+    if(su/=cm(n))                      stop 130\n+  class default\n+    stop 131\n+  end select\n+  call schar_um(su)\n+  pd => cm\n+  su => pd(n)\n+  if(.not.associated(su))              stop 132\n+  if(.not.associated(su, cm(n)))       stop 133\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=m)                     stop 134\n+    if(su/=cm(n))                      stop 135\n+  class default\n+    stop 136\n+  end select\n+  call schar_um(su)\n+  pd => cm\n+  pu => pd\n+  if(.not.associated(pu))              stop 137\n+  if(.not.associated(pu, cm))          stop 138\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=m)                     stop 139\n+    if(any(pu/=cm))                    stop 140\n+  class default\n+    stop 141\n+  end select\n+  call achar_um(pu)\n+  !\n+  sd => cm(n)(l:u)\n+  su => sd\n+  if(.not.associated(su))              stop 142\n+  if(.not.associated(su, cm(n)(l:u)))  stop 143\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 144\n+    if(su/=cm(n)(l:u))                 stop 145\n+  class default\n+    stop 146\n+  end select\n+  call schar_ue(su)\n+  pd => cm(:)(l:u)\n+  su => pd(n)\n+  if(.not.associated(su))              stop 147\n+  if(.not.associated(su, cm(n)(l:u)))  stop 148\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 149\n+    if(su/=cm(n)(l:u))                 stop 150\n+  class default\n+    stop 151\n+  end select\n+  call schar_ue(su)\n+  pd => cm(:)(l:u)\n+  pu => pd\n+  if(.not.associated(pu))              stop 152\n+  if(.not.associated(pu, cm(:)(l:u)))  stop 153\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=e)                     stop 154\n+    if(any(pu/=cm(:)(l:u)))            stop 155\n+  class default\n+    stop 156\n+  end select\n+  call achar_ue(pu)\n+  !\n+  sd => cm(n)\n+  su => sd(l:u)\n+  if(.not.associated(su))              stop 157\n+  if(.not.associated(su, cm(n)(l:u)))  stop 158\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 159\n+    if(su/=cm(n)(l:u))                 stop 160\n+  class default\n+    stop 161\n+  end select\n+  call schar_ue(su)\n+  pd => cm(:)\n+  su => pd(n)(l:u)\n+  if(.not.associated(su))              stop 162\n+  if(.not.associated(su, cm(n)(l:u)))  stop 163\n+  select type(su)\n+  type is(character(len=*, kind=k))\n+    if(len(su)/=e)                     stop 164\n+    if(su/=cm(n)(l:u))                 stop 165\n+  class default\n+    stop 166\n+  end select\n+  call schar_ue(su)\n+  pd => cm\n+  pu => pd(:)(l:u)\n+  if(.not.associated(pu))              stop 167\n+  if(.not.associated(pu, cm(:)(l:u)))  stop 168\n+  select type(pu)\n+  type is(character(len=*, kind=k))\n+    if(len(pu)/=e)                     stop 169\n+    if(any(pu/=cm(:)(l:u)))            stop 170\n+  class default\n+    stop 171\n+  end select\n+  call achar_ue(pu)\n+  !\n+  stop\n+\n+contains\n+\n+  subroutine schar_c1(a)\n+    character(kind=k), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 172\n+    if(.not.associated(a, c1(n)))      stop 173\n+    if(len(a)/=1)                      stop 174\n+    if(a/=c1(n))                       stop 175\n+    return\n+  end subroutine schar_c1\n+\n+  subroutine achar_c1(a)\n+    character(kind=k), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 176\n+    if(.not.associated(a, c1))         stop 177\n+    if(len(a)/=1)                      stop 178\n+    if(any(a/=c1))                     stop 179\n+    return\n+  end subroutine achar_c1\n+\n+  subroutine schar_cm(a)\n+    character(kind=k, len=m), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 180\n+    if(.not.associated(a, cm(n)))      stop 181\n+    if(len(a)/=m)                      stop 182\n+    if(a/=cm(n))                       stop 183\n+    return\n+  end subroutine schar_cm\n+\n+  subroutine achar_cm(a)\n+    character(kind=k, len=m), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 184\n+    if(.not.associated(a, cm))         stop 185\n+    if(len(a)/=m)                      stop 186\n+    if(any(a/=cm))                     stop 187\n+    return\n+  end subroutine achar_cm\n+\n+  subroutine schar_ce(a)\n+    character(kind=k, len=e), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 188\n+    if(.not.associated(a, cm(n)(l:u))) stop 189\n+    if(len(a)/=e)                      stop 190\n+    if(a/=cm(n)(l:u))                  stop 191\n+    return\n+  end subroutine schar_ce\n+\n+  subroutine achar_ce(a)\n+    character(kind=k, len=e), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 192\n+    if(.not.associated(a, cm(:)(l:u))) stop 193\n+    if(len(a)/=e)                      stop 194\n+    if(any(a/=cm(:)(l:u)))             stop 195\n+    return\n+  end subroutine achar_ce\n+\n+  subroutine schar_a1(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 196\n+    if(.not.associated(a, c1(n)))      stop 197\n+    if(len(a)/=1)                      stop 198\n+    if(a/=c1(n))                       stop 199\n+    return\n+  end subroutine schar_a1\n+\n+  subroutine achar_a1(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 200\n+    if(.not.associated(a, c1))         stop 201\n+    if(len(a)/=1)                      stop 202\n+    if(any(a/=c1))                     stop 203\n+    return\n+  end subroutine achar_a1\n+\n+  subroutine schar_am(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 204\n+    if(.not.associated(a, cm(n)))      stop 205\n+    if(len(a)/=m)                      stop 206\n+    if(a/=cm(n))                       stop 207\n+    return\n+  end subroutine schar_am\n+\n+  subroutine achar_am(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 208\n+    if(.not.associated(a, cm))         stop 209\n+    if(len(a)/=m)                      stop 210\n+    if(any(a/=cm))                     stop 211\n+    return\n+  end subroutine achar_am\n+\n+  subroutine schar_ae(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 212\n+    if(.not.associated(a, cm(n)(l:u))) stop 213\n+    if(len(a)/=e)                      stop 214\n+    if(a/=cm(n)(l:u))                  stop 215\n+    return\n+  end subroutine schar_ae\n+\n+  subroutine achar_ae(a)\n+    character(kind=k, len=*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 216\n+    if(.not.associated(a, cm(:)(l:u))) stop 217\n+    if(len(a)/=e)                      stop 218\n+    if(any(a/=cm(:)(l:u)))             stop 219\n+    return\n+  end subroutine achar_ae\n+\n+  subroutine schar_d1(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 220\n+    if(.not.associated(a, c1(n)))      stop 221\n+    if(len(a)/=1)                      stop 222\n+    if(a/=c1(n))                       stop 223\n+    return\n+  end subroutine schar_d1\n+\n+  subroutine achar_d1(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 224\n+    if(.not.associated(a, c1))         stop 225\n+    if(len(a)/=1)                      stop 226\n+    if(any(a/=c1))                     stop 227\n+    return\n+  end subroutine achar_d1\n+\n+  subroutine schar_dm(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 228\n+    if(.not.associated(a, cm(n)))      stop 229\n+    if(len(a)/=m)                      stop 230\n+    if(a/=cm(n))                       stop 231\n+    return\n+  end subroutine schar_dm\n+\n+  subroutine achar_dm(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 232\n+    if(.not.associated(a, cm))         stop 233\n+    if(len(a)/=m)                      stop 234\n+    if(any(a/=cm))                     stop 235\n+    return\n+  end subroutine achar_dm\n+\n+  subroutine schar_de(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 236\n+    if(.not.associated(a, cm(n)(l:u))) stop 237\n+    if(len(a)/=e)                      stop 238\n+    if(a/=cm(n)(l:u))                  stop 239\n+    return\n+  end subroutine schar_de\n+\n+  subroutine achar_de(a)\n+    character(kind=k, len=:), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 240\n+    if(.not.associated(a, cm(:)(l:u))) stop 241\n+    if(len(a)/=e)                      stop 242\n+    if(any(a/=cm(:)(l:u)))             stop 243\n+    return\n+  end subroutine achar_de\n+\n+  subroutine schar_u1(a)\n+    class(*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 244\n+    if(.not.associated(a, c1(n)))      stop 245\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=1)                    stop 246\n+      if(a/=c1(n))                     stop 247\n+    class default\n+      stop 248\n+    end select\n+    return\n+  end subroutine schar_u1\n+\n+  subroutine achar_u1(a)\n+    class(*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 249\n+    if(.not.associated(a, c1))         stop 250\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=1)                    stop 251\n+      if(any(a/=c1))                   stop 252\n+    class default\n+      stop 253\n+    end select\n+    return\n+  end subroutine achar_u1\n+\n+  subroutine schar_um(a)\n+    class(*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 254\n+    if(.not.associated(a))             stop 255\n+    if(.not.associated(a, cm(n)))      stop 256\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=m)                    stop 257\n+      if(a/=cm(n))                     stop 258\n+    class default\n+      stop 259\n+    end select\n+    return\n+  end subroutine schar_um\n+\n+  subroutine achar_um(a)\n+    class(*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 260\n+    if(.not.associated(a, cm))         stop 261\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=m)                    stop 262\n+      if(any(a/=cm))                   stop 263\n+    class default\n+      stop 264\n+    end select\n+    return\n+  end subroutine achar_um\n+\n+  subroutine schar_ue(a)\n+    class(*), pointer, intent(in) :: a\n+\n+    if(.not.associated(a))             stop 265\n+    if(.not.associated(a, cm(n)(l:u))) stop 266\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=e)                    stop 267\n+      if(a/=cm(n)(l:u))                stop 268\n+    class default\n+      stop 269\n+    end select\n+    return\n+  end subroutine schar_ue\n+\n+  subroutine achar_ue(a)\n+    class(*), pointer, intent(in) :: a(:)\n+\n+    if(.not.associated(a))             stop 270\n+    if(.not.associated(a, cm(:)(l:u))) stop 271\n+    select type(a)\n+    type is(character(len=*, kind=k))\n+      if(len(a)/=e)                    stop 272\n+      if(any(a/=cm(:)(l:u)))           stop 273\n+    class default\n+      stop 274\n+    end select\n+    return\n+  end subroutine achar_ue\n+\n+end program main_p"}, {"sha": "943fc69ed47732363d684bf365e2dcbef0825ff5", "filename": "libgfortran/intrinsics/associated.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/libgfortran%2Fintrinsics%2Fassociated.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/libgfortran%2Fintrinsics%2Fassociated.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fassociated.c?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -37,7 +37,7 @@ associated (const gfc_array_void *pointer, const gfc_array_void *target)\n     return 0;\n   if (GFC_DESCRIPTOR_DATA (pointer) != GFC_DESCRIPTOR_DATA (target))\n     return 0;\n-  if (GFC_DESCRIPTOR_DTYPE (pointer).elem_len != GFC_DESCRIPTOR_DTYPE (target).elem_len)\n+  if (GFC_DESCRIPTOR_SPAN (pointer) != GFC_DESCRIPTOR_SPAN (target))\n     return 0;\n   if (GFC_DESCRIPTOR_DTYPE (pointer).type != GFC_DESCRIPTOR_DTYPE (target).type)\n     return 0;"}, {"sha": "285c36a00b54c61067a614a9e45d501e122edd95", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d514626ee2566c68b8a79c7b99aaf791d69e1b2f/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=d514626ee2566c68b8a79c7b99aaf791d69e1b2f", "patch": "@@ -409,6 +409,7 @@ typedef GFC_FULL_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_INTEGER_4) gfc_full_a\n #define GFC_DESCRIPTOR_SIZE(desc) ((desc)->dtype.elem_len)\n #define GFC_DESCRIPTOR_DATA(desc) ((desc)->base_addr)\n #define GFC_DESCRIPTOR_DTYPE(desc) ((desc)->dtype)\n+#define GFC_DESCRIPTOR_SPAN(desc) ((desc)->span)\n \n #define GFC_DIMENSION_LBOUND(dim) ((dim).lower_bound)\n #define GFC_DIMENSION_UBOUND(dim) ((dim)._ubound)"}]}