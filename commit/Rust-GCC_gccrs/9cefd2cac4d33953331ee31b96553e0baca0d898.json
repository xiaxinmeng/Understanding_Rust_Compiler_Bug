{"sha": "9cefd2cac4d33953331ee31b96553e0baca0d898", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNlZmQyY2FjNGQzMzk1MzMzMWVlMzFiOTY1NTNlMGJhY2EwZDg5OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-05-15T22:25:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-05-15T22:25:51Z"}, "message": "re PR c++/5388 (Incorrect message \"operands to ?: have different types\")\n\n        PR c++/5388\n        * call.c (conditional_conversion): Don't consider implicit\n        conversions if T2 is a base of T1.\n        * cp-tree.h (DERIVED_FROM_P, UNIQUELY_DERIVED_FROM_P): Make boolean.\n        (ACCESSIBLY_UNIQUELY_DERIVED_P, PUBLICLY_UNIQUELY_DERIVED_P): Likewise.\n\n        * parser.c (cp_parser_primary_expression): Convert a static data\n        member from reference.\n\nFrom-SVN: r66844", "tree": {"sha": "97560f63f2cfb583065bc62291c070d43909a908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97560f63f2cfb583065bc62291c070d43909a908"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cefd2cac4d33953331ee31b96553e0baca0d898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cefd2cac4d33953331ee31b96553e0baca0d898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cefd2cac4d33953331ee31b96553e0baca0d898", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cefd2cac4d33953331ee31b96553e0baca0d898/comments", "author": null, "committer": null, "parents": [{"sha": "8f4b394d0259cb330bf8a67f0e4b974a6070def7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4b394d0259cb330bf8a67f0e4b974a6070def7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4b394d0259cb330bf8a67f0e4b974a6070def7"}], "stats": {"total": 50, "additions": 32, "deletions": 18}, "files": [{"sha": "403c7fede1dcdd36ac2dfaa161d4ad4f674563c0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9cefd2cac4d33953331ee31b96553e0baca0d898", "patch": "@@ -1,3 +1,14 @@\n+2003-05-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/5388\n+\t* call.c (conditional_conversion): Don't consider implicit\n+\tconversions if T2 is a base of T1. \n+\t* cp-tree.h (DERIVED_FROM_P, UNIQUELY_DERIVED_FROM_P): Make boolean.\n+\t(ACCESSIBLY_UNIQUELY_DERIVED_P, PUBLICLY_UNIQUELY_DERIVED_P): Likewise.\n+\n+\t* parser.c (cp_parser_primary_expression): Convert a static data\n+\tmember from reference.\n+\n 2003-05-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (build_op_delete_call): Avoid creating unnecessary types.\n@@ -98,10 +109,10 @@\n \n 2003-05-07  Richard Henderson  <rth@redhat.com>\n \n-        PR c++/10570\n-        * cfns.gperf: Comment out POSIX thread cancellation points,\n-        plus abort and raise.\n-        * cfns.h: Regenerate.\n+\tPR c++/10570\n+\t* cfns.gperf: Comment out POSIX thread cancellation points,\n+\tplus abort and raise.\n+\t* cfns.h: Regenerate.\n \n 2003-05-07  Jason Merrill  <jason@redhat.com>\n "}, {"sha": "d40a60cc7a1cd35b86f76eb7257400c155490e21", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9cefd2cac4d33953331ee31b96553e0baca0d898", "patch": "@@ -3161,6 +3161,7 @@ conditional_conversion (tree e1, tree e2)\n   tree t1 = non_reference (TREE_TYPE (e1));\n   tree t2 = non_reference (TREE_TYPE (e2));\n   tree conv;\n+  bool good_base;\n \n   /* [expr.cond]\n \n@@ -3192,10 +3193,9 @@ conditional_conversion (tree e1, tree e2)\n      FIXME we can't express an rvalue that refers to the original object;\n      we have to create a new one.  */\n   if (CLASS_TYPE_P (t1) && CLASS_TYPE_P (t2)\n-      && same_or_base_type_p (TYPE_MAIN_VARIANT (t2), \n-\t\t\t      TYPE_MAIN_VARIANT (t1)))\n+      && ((good_base = DERIVED_FROM_P (t2, t1)) || DERIVED_FROM_P (t1, t2)))\n     {\n-      if (at_least_as_qualified_p (t2, t1))\n+      if (good_base && at_least_as_qualified_p (t2, t1))\n \t{\n \t  conv = build1 (IDENTITY_CONV, t1, e1);\n \t  if (!same_type_p (TYPE_MAIN_VARIANT (t1), \n@@ -3211,13 +3211,13 @@ conditional_conversion (tree e1, tree e2)\n       else\n \treturn NULL_TREE;\n     }\n+  else\n+    /* [expr.cond]\n \n-  /* [expr.cond]\n-\n-     E1 can be converted to match E2 if E1 can be implicitly converted\n-     to the type that expression E2 would have if E2 were converted to\n-     an rvalue (or the type it has, if E2 is an rvalue).  */\n-  return implicit_conversion (t2, t1, e1, LOOKUP_NORMAL);\n+       Otherwise: E1 can be converted to match E2 if E1 can be implicitly\n+       converted to the type that expression E2 would have if E2 were\n+       converted to an rvalue (or the type it has, if E2 is an rvalue).  */\n+    return implicit_conversion (t2, t1, e1, LOOKUP_NORMAL);\n }\n \n /* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three"}, {"sha": "6bb2e0ddc51fd6ec2b4b8c8aa1b216a102157216", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9cefd2cac4d33953331ee31b96553e0baca0d898", "patch": "@@ -992,18 +992,19 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* Nonzero iff TYPE is derived from PARENT. Ignores accessibility and\n    ambiguity issues.  */\n #define DERIVED_FROM_P(PARENT, TYPE) \\\n-  lookup_base ((TYPE), PARENT, ba_any, NULL)\n+  (lookup_base ((TYPE), PARENT, ba_any, NULL) != NULL_TREE)\n /* Nonzero iff TYPE is uniquely derived from PARENT. Ignores\n    accessibility.  */\n #define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) \\\n-  lookup_base ((TYPE), (PARENT), ba_ignore | ba_quiet, NULL)\n+  (lookup_base ((TYPE), (PARENT), ba_ignore | ba_quiet, NULL) != NULL_TREE)\n /* Nonzero iff TYPE is accessible in the current scope and uniquely\n    derived from PARENT.  */\n #define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n-  lookup_base ((TYPE), (PARENT), ba_check | ba_quiet, NULL)\n+  (lookup_base ((TYPE), (PARENT), ba_check | ba_quiet, NULL) != NULL_TREE)\n /* Nonzero iff TYPE is publicly & uniquely derived from PARENT.  */\n #define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n-  lookup_base ((TYPE), (PARENT),  ba_not_special | ba_quiet, NULL)\n+  (lookup_base ((TYPE), (PARENT),  ba_not_special | ba_quiet, NULL) \\\n+   != NULL_TREE)\n \f\n /* This is a few header flags for 'struct lang_type'.  Actually,\n    all but the first are used only for lang_type_class; they\n@@ -3364,7 +3365,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \t\t\t\t   type is derived from the pointed to\n \t\t\t\t   by the first.  */\n #define COMPARE_RELAXED       2 /* Like COMPARE_DERIVED, but in\n-\t\t\t\t   reverse.  Also treat enmeration\n+\t\t\t\t   reverse.  Also treat enumeration\n \t\t\t\t   types as the same as integer types\n \t\t\t\t   of the same width.  */\n #define COMPARE_REDECLARATION 4 /* The comparsion is being done when"}, {"sha": "cf768e0ac8db68ba99a5edaa9850e1a7c202b4ba", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cefd2cac4d33953331ee31b96553e0baca0d898/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9cefd2cac4d33953331ee31b96553e0baca0d898", "patch": "@@ -2800,6 +2800,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t(decl, parser->scope, current_class_type));\n \t\tif (TREE_CODE (decl) == FIELD_DECL || BASELINK_P (decl))\n \t\t  *qualifying_class = parser->scope;\n+\t\telse if (!processing_template_decl)\n+\t\t  decl = convert_from_reference (decl);\n \t      }\n \t    else\n \t      /* Transform references to non-static data members into"}]}