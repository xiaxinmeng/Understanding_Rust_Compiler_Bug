{"sha": "f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk2OGVmOWI4ZGYyYmMyMjg3ZTVlN2U4NzI5OWU1YTJhNDRlOGM5NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-01T23:28:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-01T23:28:20Z"}, "message": "PR c++/88335 - Implement P1073R3: Immediate functions\n\n\tPR c++/88335 - Implement P1073R3: Immediate functions\nc-family/\n\t* c-common.h (enum rid): Add RID_CONSTEVAL.\n\t* c-common.c (c_common_reswords): Add consteval.\ncp/\n\t* cp-tree.h (struct lang_decl_fn): Add immediate_fn_p bit.\n\t(DECL_IMMEDIATE_FUNCTION_P, SET_DECL_IMMEDIATE_FUNCTION_P): Define.\n\t(enum cp_decl_spec): Add ds_consteval.\n\t(fold_non_dependent_expr): Add another tree argument defaulted to\n\tNULL_TREE.\n\t* name-lookup.h (struct cp_binding_level): Add immediate_fn_ctx_p\n\tmember.\n\t* parser.c (cp_keyword_starts_decl_specifier_p): Adjust comments\n\tfor C++11 and C++20 specifiers.  Handle RID_CONSTEVAL.\n\t(CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR): Adjust comment.\n\t(CP_PARSER_FLAGS_CONSTEVAL): New.\n\t(cp_parser_skip_balanced_tokens): New forward declaration.\n\t(cp_parser_lambda_declarator_opt): Handle ds_consteval.  Set\n\tcurrent_binding_level->immediate_fn_ctx_p before parsing parameter\n\tlist if decl-specifier-seq contains consteval specifier.\n\t(cp_parser_decl_specifier_seq): Handle RID_CONSTEVAL.\n\t(cp_parser_explicit_instantiation): Diagnose explicit instantiation\n\twith consteval specifier.\n\t(cp_parser_init_declarator): For consteval or into flags\n\tCP_PARSER_FLAGS_CONSTEVAL.\n\t(cp_parser_direct_declarator): If CP_PARSER_FLAGS_CONSTEVAL, set\n\tcurrent_binding_level->immediate_fn_ctx_p in the sk_function_parms\n\tscope.\n\t(set_and_check_decl_spec_loc): Add consteval entry, formatting fix.\n\t* call.c (build_addr_func): For direct calls to immediate functions\n\tuse build_address rather than decay_conversion.\n\t(build_over_call): Evaluate immediate function invocations.\n\t* error.c (dump_function_decl): Handle DECL_IMMEDIATE_FUNCTION_P.\n\t* semantics.c (expand_or_defer_fn_1): Use tentative linkage and don't\n\tcall mark_needed for immediate functions.\n\t* typeck.c (cxx_sizeof_or_alignof_expr): Likewise.  Formatting fix.\n\t(cp_build_addr_expr_1): Reject taking address of immediate function\n\toutside of immediate function.\n\t* decl.c (validate_constexpr_redeclaration): Diagnose consteval\n\tvs. non-consteval or vice versa redeclaration.  Use\n\tSET_DECL_IMMEDIATE_FUNCTION_P if new_decl is immediate function.\n\t(check_tag_decl): Use %qs with keyword string to simplify translation.\n\tHandle ds_consteval.\n\t(start_decl): Adjust diagnostics for static or thread_local variables\n\tin immediate functions.\n\t(grokfndecl): Call sorry_at on virtual consteval.  Use %qs with keyword\n\tto string to simplify translation.  Diagnose consteval main.  Use\n\tSET_DECL_IMMEDIATE_FUNCTION_P for consteval.\n\t(grokdeclarator): Handle consteval.  Use %qs with keyword strings to\n\tsimplify translation.  Use separate ifs instead of chained else if\n\tfor invalid specifiers.  For constinit clear constinit_p rather than\n\tconstexpr_p.\n\t* constexpr.c (find_immediate_fndecl): New function.\n\t(cxx_eval_outermost_constant_expr): Allow consteval calls returning\n\tvoid.  Diagnose returning address of immediate function from consteval\n\tevaluation.\n\t(fold_non_dependent_expr_template): Add OBJECT argument, pass it\n\tthrough to cxx_eval_outermost_constant_expr.\n\t(fold_non_dependent_expr): Add OBJECT argument, pass it through to\n\tfold_non_dependent_expr_template.\n\t(fold_non_dependent_init): Adjust fold_non_dependent_expr_template\n\tcaller.\n\t* method.c (defaulted_late_check): Adjust diagnostics for consteval.\n\t* lambda.c (maybe_add_lambda_conv_op): Copy over\n\tDECL_DECLARED_CONSTEXPR_P and DECL_IMMEDIATE_FUNCTION_P bits from\n\tcallop to both artificial functions.\n\t* init.c (build_value_init): Don't do further processing if\n\tbuild_special_member_call returned a TREE_CONSTANT.  Formatting fix.\ntestsuite/\n\t* g++.dg/cpp2a/consteval1.C: New test.\n\t* g++.dg/cpp2a/consteval2.C: New test.\n\t* g++.dg/cpp2a/consteval3.C: New test.\n\t* g++.dg/cpp2a/consteval4.C: New test.\n\t* g++.dg/cpp2a/consteval5.C: New test.\n\t* g++.dg/cpp2a/consteval6.C: New test.\n\t* g++.dg/cpp2a/consteval7.C: New test.\n\t* g++.dg/cpp2a/consteval8.C: New test.\n\t* g++.dg/cpp2a/consteval9.C: New test.\n\t* g++.dg/cpp2a/consteval10.C: New test.\n\t* g++.dg/cpp2a/consteval11.C: New test.\n\t* g++.dg/cpp2a/consteval12.C: New test.\n\t* g++.dg/cpp2a/consteval13.C: New test.\n\t* g++.dg/cpp2a/consteval14.C: New test.\n\t* g++.dg/ext/consteval1.C: New test.\n\nFrom-SVN: r277733", "tree": {"sha": "6aba8238b5260a14347acaa810dbae9579df6f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6aba8238b5260a14347acaa810dbae9579df6f8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8412b939d1cf375c8e478e39a5ac9d7260e4c23c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8412b939d1cf375c8e478e39a5ac9d7260e4c23c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8412b939d1cf375c8e478e39a5ac9d7260e4c23c"}], "stats": {"total": 1031, "additions": 967, "deletions": 64}, "files": [{"sha": "9bc219049a383cb785cc8f8ae2b9fdaa2b027240", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -1,3 +1,9 @@\n+2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/88335 - Implement P1073R3: Immediate functions\n+\t* c-common.h (enum rid): Add RID_CONSTEVAL.\n+\t* c-common.c (c_common_reswords): Add consteval.\n+\n 2019-10-30  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): Add 'L' suffix to feature"}, {"sha": "743ef04918df718d17b17feb7addca73d6c9da0e", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -459,6 +459,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"char32_t\",\t\tRID_CHAR32,\tD_CXXONLY | D_CXX11 | D_CXXWARN },\n   { \"class\",\t\tRID_CLASS,\tD_CXX_OBJC | D_CXXWARN },\n   { \"const\",\t\tRID_CONST,\t0 },\n+  { \"consteval\",\tRID_CONSTEVAL,\tD_CXXONLY | D_CXX20 | D_CXXWARN },\n   { \"constexpr\",\tRID_CONSTEXPR,\tD_CXXONLY | D_CXX11 | D_CXXWARN },\n   { \"constinit\",\tRID_CONSTINIT,\tD_CXXONLY | D_CXX20 | D_CXXWARN },\n   { \"const_cast\",\tRID_CONSTCAST,\tD_CXXONLY | D_CXXWARN },"}, {"sha": "5a24a7eb2f76afcee8f8cce2d9c6c6edc09a2434", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -181,7 +181,7 @@ enum rid\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,\n \n   /* C++20 */\n-  RID_CONSTINIT,\n+  RID_CONSTINIT, RID_CONSTEVAL,\n \n   /* char8_t */\n   RID_CHAR8,"}, {"sha": "06a4e31578f8cc4bfd661021df2bed3b829b8181", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -1,5 +1,70 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/88335 - Implement P1073R3: Immediate functions\n+\t* cp-tree.h (struct lang_decl_fn): Add immediate_fn_p bit.\n+\t(DECL_IMMEDIATE_FUNCTION_P, SET_DECL_IMMEDIATE_FUNCTION_P): Define.\n+\t(enum cp_decl_spec): Add ds_consteval.\n+\t(fold_non_dependent_expr): Add another tree argument defaulted to\n+\tNULL_TREE.\n+\t* name-lookup.h (struct cp_binding_level): Add immediate_fn_ctx_p\n+\tmember.\n+\t* parser.c (cp_keyword_starts_decl_specifier_p): Adjust comments\n+\tfor C++11 and C++20 specifiers.  Handle RID_CONSTEVAL.\n+\t(CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR): Adjust comment.\n+\t(CP_PARSER_FLAGS_CONSTEVAL): New.\n+\t(cp_parser_skip_balanced_tokens): New forward declaration.\n+\t(cp_parser_lambda_declarator_opt): Handle ds_consteval.  Set\n+\tcurrent_binding_level->immediate_fn_ctx_p before parsing parameter\n+\tlist if decl-specifier-seq contains consteval specifier.\n+\t(cp_parser_decl_specifier_seq): Handle RID_CONSTEVAL.\n+\t(cp_parser_explicit_instantiation): Diagnose explicit instantiation\n+\twith consteval specifier.\n+\t(cp_parser_init_declarator): For consteval or into flags\n+\tCP_PARSER_FLAGS_CONSTEVAL.\n+\t(cp_parser_direct_declarator): If CP_PARSER_FLAGS_CONSTEVAL, set\n+\tcurrent_binding_level->immediate_fn_ctx_p in the sk_function_parms\n+\tscope.\n+\t(set_and_check_decl_spec_loc): Add consteval entry, formatting fix.\n+\t* call.c (build_addr_func): For direct calls to immediate functions\n+\tuse build_address rather than decay_conversion.\n+\t(build_over_call): Evaluate immediate function invocations.\n+\t* error.c (dump_function_decl): Handle DECL_IMMEDIATE_FUNCTION_P.\n+\t* semantics.c (expand_or_defer_fn_1): Use tentative linkage and don't\n+\tcall mark_needed for immediate functions.\n+\t* typeck.c (cxx_sizeof_or_alignof_expr): Likewise.  Formatting fix.\n+\t(cp_build_addr_expr_1): Reject taking address of immediate function\n+\toutside of immediate function.\n+\t* decl.c (validate_constexpr_redeclaration): Diagnose consteval\n+\tvs. non-consteval or vice versa redeclaration.  Use\n+\tSET_DECL_IMMEDIATE_FUNCTION_P if new_decl is immediate function.\n+\t(check_tag_decl): Use %qs with keyword string to simplify translation.\n+\tHandle ds_consteval.\n+\t(start_decl): Adjust diagnostics for static or thread_local variables\n+\tin immediate functions.\n+\t(grokfndecl): Call sorry_at on virtual consteval.  Use %qs with keyword\n+\tto string to simplify translation.  Diagnose consteval main.  Use\n+\tSET_DECL_IMMEDIATE_FUNCTION_P for consteval.\n+\t(grokdeclarator): Handle consteval.  Use %qs with keyword strings to\n+\tsimplify translation.  Use separate ifs instead of chained else if\n+\tfor invalid specifiers.  For constinit clear constinit_p rather than\n+\tconstexpr_p.\n+\t* constexpr.c (find_immediate_fndecl): New function.\n+\t(cxx_eval_outermost_constant_expr): Allow consteval calls returning\n+\tvoid.  Diagnose returning address of immediate function from consteval\n+\tevaluation.\n+\t(fold_non_dependent_expr_template): Add OBJECT argument, pass it\n+\tthrough to cxx_eval_outermost_constant_expr.\n+\t(fold_non_dependent_expr): Add OBJECT argument, pass it through to\n+\tfold_non_dependent_expr_template.\n+\t(fold_non_dependent_init): Adjust fold_non_dependent_expr_template\n+\tcaller.\n+\t* method.c (defaulted_late_check): Adjust diagnostics for consteval.\n+\t* lambda.c (maybe_add_lambda_conv_op): Copy over\n+\tDECL_DECLARED_CONSTEXPR_P and DECL_IMMEDIATE_FUNCTION_P bits from\n+\tcallop to both artificial functions.\n+\t* init.c (build_value_init): Don't do further processing if\n+\tbuild_special_member_call returned a TREE_CONSTANT.  Formatting fix.\n+\n \tPR c++/91369 - Implement P0784R7: constexpr new\n \t* cp-tree.h (CALL_FROM_NEW_OR_DELETE_P): Define.\n \t* init.c (build_new_1, build_vec_delete_1, build_delete): Set"}, {"sha": "3dac31a37b989e654b616a4ee3fdd2239dc7104c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -289,6 +289,9 @@ build_addr_func (tree function, tsubst_flags_t complain)\n \t}\n       function = build_address (function);\n     }\n+  else if (TREE_CODE (function) == FUNCTION_DECL\n+\t   && DECL_IMMEDIATE_FUNCTION_P (function))\n+    function = build_address (function);\n   else\n     function = decay_conversion (function, complain, /*reject_builtin=*/false);\n \n@@ -8145,6 +8148,40 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t\t\t   addr, nargs, argarray);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n+      if (TREE_CODE (fn) == FUNCTION_DECL\n+\t  && DECL_IMMEDIATE_FUNCTION_P (fn)\n+\t  && (current_function_decl == NULL_TREE\n+\t      || !DECL_IMMEDIATE_FUNCTION_P (current_function_decl))\n+\t  && (current_binding_level->kind != sk_function_parms\n+\t      || !current_binding_level->immediate_fn_ctx_p))\n+\t{\n+\t  tree obj_arg = NULL_TREE, exprimm = expr;\n+\t  if (DECL_CONSTRUCTOR_P (fn))\n+\t    obj_arg = first_arg;\n+\t  if (obj_arg\n+\t      && is_dummy_object (obj_arg)\n+\t      && !type_dependent_expression_p (obj_arg))\n+\t    {\n+\t      exprimm = build_cplus_new (DECL_CONTEXT (fn), expr, complain);\n+\t      obj_arg = NULL_TREE;\n+\t    }\n+\t  /* Look through *(const T *)&obj.  */\n+\t  else if (obj_arg && TREE_CODE (obj_arg) == INDIRECT_REF)\n+\t    {\n+\t      tree addr = TREE_OPERAND (obj_arg, 0);\n+\t      STRIP_NOPS (addr);\n+\t      if (TREE_CODE (addr) == ADDR_EXPR)\n+\t\t{\n+\t\t  tree typeo = TREE_TYPE (obj_arg);\n+\t\t  tree typei = TREE_TYPE (TREE_OPERAND (addr, 0));\n+\t\t  if (same_type_ignoring_top_level_qualifiers_p (typeo, typei))\n+\t\t    obj_arg = TREE_OPERAND (addr, 0);\n+\t\t}\n+\t    }\n+\t  fold_non_dependent_expr (exprimm, complain,\n+\t\t\t\t   /*manifestly_const_eval=*/true,\n+\t\t\t\t   obj_arg);\n+\t}\n       return convert_from_reference (expr);\n     }\n \n@@ -8744,6 +8781,40 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (TREE_CODE (c) == CALL_EXPR)\n \tTREE_NO_WARNING (c) = 1;\n     }\n+  if (TREE_CODE (fn) == ADDR_EXPR)\n+    {\n+      tree fndecl = STRIP_TEMPLATE (TREE_OPERAND (fn, 0));\n+      if (TREE_CODE (fndecl) == FUNCTION_DECL\n+\t  && DECL_IMMEDIATE_FUNCTION_P (fndecl)\n+\t  && (current_function_decl == NULL_TREE\n+\t      || !DECL_IMMEDIATE_FUNCTION_P (current_function_decl))\n+\t  && (current_binding_level->kind != sk_function_parms\n+\t      || !current_binding_level->immediate_fn_ctx_p))\n+\t{\n+\t  tree obj_arg = NULL_TREE;\n+\t  if (DECL_CONSTRUCTOR_P (fndecl))\n+\t    obj_arg = cand->first_arg ? cand->first_arg : (*args)[0];\n+\t  if (obj_arg && is_dummy_object (obj_arg))\n+\t    {\n+\t      call = build_cplus_new (DECL_CONTEXT (fndecl), call, complain);\n+\t      obj_arg = NULL_TREE;\n+\t    }\n+\t  /* Look through *(const T *)&obj.  */\n+\t  else if (obj_arg && TREE_CODE (obj_arg) == INDIRECT_REF)\n+\t    {\n+\t      tree addr = TREE_OPERAND (obj_arg, 0);\n+\t      STRIP_NOPS (addr);\n+\t      if (TREE_CODE (addr) == ADDR_EXPR)\n+\t\t{\n+\t\t  tree typeo = TREE_TYPE (obj_arg);\n+\t\t  tree typei = TREE_TYPE (TREE_OPERAND (addr, 0));\n+\t\t  if (same_type_ignoring_top_level_qualifiers_p (typeo, typei))\n+\t\t    obj_arg = TREE_OPERAND (addr, 0);\n+\t\t}\n+\t    }\n+\t  call = cxx_constant_value (call, obj_arg);\n+\t}\n+    }\n   return call;\n }\n "}, {"sha": "84ed7accd7d4717231fdacbb1bfdbfe735166797", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -5739,6 +5739,16 @@ find_heap_var_refs (tree *tp, int *walk_subtrees, void */*data*/)\n   return NULL_TREE;\n }\n \n+/* Find immediate function decls in *TP if any.  */\n+\n+static tree\n+find_immediate_fndecl (tree *tp, int */*walk_subtrees*/, void */*data*/)\n+{\n+  if (TREE_CODE (*tp) == FUNCTION_DECL && DECL_IMMEDIATE_FUNCTION_P (*tp))\n+    return *tp;\n+  return NULL_TREE;\n+}\n+\n /* ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n    STRICT has the same sense as for constant_value_1: true if we only allow\n    conforming C++ constant expressions, or false if we want a constant value\n@@ -5767,13 +5777,38 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \n   tree type = initialized_type (t);\n   tree r = t;\n+  bool is_consteval = false;\n   if (VOID_TYPE_P (type))\n     {\n       if (constexpr_dtor)\n \t/* Used for destructors of array elements.  */\n \ttype = TREE_TYPE (object);\n       else\n-\treturn t;\n+\t{\n+\t  if (cxx_dialect < cxx2a)\n+\t    return t;\n+\t  if (TREE_CODE (t) != CALL_EXPR && TREE_CODE (t) != AGGR_INIT_EXPR)\n+\t    return t;\n+\t  /* Calls to immediate functions returning void need to be\n+\t     evaluated.  */\n+\t  tree fndecl = cp_get_callee_fndecl_nofold (t);\n+\t  if (fndecl == NULL_TREE || !DECL_IMMEDIATE_FUNCTION_P (fndecl))\n+\t    return t;\n+\t  else\n+\t    is_consteval = true;\n+\t}\n+    }\n+  else if (cxx_dialect >= cxx2a\n+\t   && (TREE_CODE (t) == CALL_EXPR\n+\t       || TREE_CODE (t) == AGGR_INIT_EXPR\n+\t       || TREE_CODE (t) == TARGET_EXPR))\n+    {\n+      tree x = t;\n+      if (TREE_CODE (x) == TARGET_EXPR)\n+\tx = TARGET_EXPR_INITIAL (x);\n+      tree fndecl = cp_get_callee_fndecl_nofold (x);\n+      if (fndecl && DECL_IMMEDIATE_FUNCTION_P (fndecl))\n+\tis_consteval = true;\n     }\n   if (AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n     {\n@@ -5874,6 +5909,25 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t  }\n     }\n \n+  /* Check that immediate invocation does not return an expression referencing\n+     any immediate function decls.  They need to be allowed while parsing\n+     immediate functions, but can't leak outside of them.  */\n+  if (is_consteval\n+      && t != r\n+      && (current_function_decl == NULL_TREE\n+\t  || !DECL_IMMEDIATE_FUNCTION_P (current_function_decl)))\n+    if (tree immediate_fndecl\n+\t= cp_walk_tree_without_duplicates (&r, find_immediate_fndecl,\n+\t\t\t\t\t   NULL))\n+    {\n+      if (!allow_non_constant && !non_constant_p)\n+\terror_at (cp_expr_loc_or_input_loc (t),\n+\t\t  \"immediate evaluation returns address of immediate \"\n+\t\t  \"function %qD\", immediate_fndecl);\n+      r = t;\n+      non_constant_p = true;\n+    }\n+\n   /* Technically we should check this for all subexpressions, but that\n      runs into problems with our internal representation of pointer\n      subtraction and the 5.19 rules are still in flux.  */\n@@ -6114,7 +6168,8 @@ clear_cv_and_fold_caches (bool sat /*= true*/)\n \n static tree\n fold_non_dependent_expr_template (tree t, tsubst_flags_t complain,\n-\t\t\t\t  bool manifestly_const_eval)\n+\t\t\t\t  bool manifestly_const_eval,\n+\t\t\t\t  tree object)\n {\n   gcc_assert (processing_template_decl);\n \n@@ -6135,7 +6190,7 @@ fold_non_dependent_expr_template (tree t, tsubst_flags_t complain,\n \n       tree r = cxx_eval_outermost_constant_expr (t, true, true,\n \t\t\t\t\t\t manifestly_const_eval,\n-\t\t\t\t\t\t false, NULL_TREE);\n+\t\t\t\t\t\t false, object);\n       /* cp_tree_equal looks through NOPs, so allow them.  */\n       gcc_checking_assert (r == t\n \t\t\t   || CONVERT_EXPR_P (t)\n@@ -6171,16 +6226,17 @@ fold_non_dependent_expr_template (tree t, tsubst_flags_t complain,\n tree\n fold_non_dependent_expr (tree t,\n \t\t\t tsubst_flags_t complain /* = tf_warning_or_error */,\n-\t\t\t bool manifestly_const_eval /* = false */)\n+\t\t\t bool manifestly_const_eval /* = false */,\n+\t\t\t tree object /* = NULL_TREE */)\n {\n   if (t == NULL_TREE)\n     return NULL_TREE;\n \n   if (processing_template_decl)\n     return fold_non_dependent_expr_template (t, complain,\n-\t\t\t\t\t     manifestly_const_eval);\n+\t\t\t\t\t     manifestly_const_eval, object);\n \n-  return maybe_constant_value (t, NULL_TREE, manifestly_const_eval);\n+  return maybe_constant_value (t, object, manifestly_const_eval);\n }\n \n \n@@ -6197,7 +6253,7 @@ fold_non_dependent_init (tree t,\n   if (processing_template_decl)\n     {\n       t = fold_non_dependent_expr_template (t, complain,\n-\t\t\t\t\t    manifestly_const_eval);\n+\t\t\t\t\t    manifestly_const_eval, NULL_TREE);\n       /* maybe_constant_init does this stripping, so do it here too.  */\n       if (TREE_CODE (t) == TARGET_EXPR)\n \t{"}, {"sha": "eb8563943773b20210e5285735fc66a44ae3c6d6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -2697,7 +2697,8 @@ struct GTY(()) lang_decl_fn {\n   unsigned hidden_friend_p : 1;\n   unsigned omp_declare_reduction_p : 1;\n   unsigned has_dependent_explicit_spec_p : 1;\n-  unsigned spare : 12;\n+  unsigned immediate_fn_p : 1;\n+  unsigned spare : 11;\n \n   /* 32-bits padding on 64-bit host.  */\n \n@@ -3211,6 +3212,15 @@ struct GTY(()) lang_decl {\n #define DECL_DECLARED_CONSTEXPR_P(DECL) \\\n   DECL_LANG_FLAG_8 (VAR_OR_FUNCTION_DECL_CHECK (STRIP_TEMPLATE (DECL)))\n \n+/* True if FNDECL is an immediate function.  */\n+#define DECL_IMMEDIATE_FUNCTION_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (STRIP_TEMPLATE (NODE)))\t\\\n+   ? LANG_DECL_FN_CHECK (NODE)->immediate_fn_p\t\t\t\t\\\n+   : false)\n+#define SET_DECL_IMMEDIATE_FUNCTION_P(NODE) \\\n+  (retrofit_lang_decl (FUNCTION_DECL_CHECK (NODE)),\t\t\t\\\n+   LANG_DECL_FN_CHECK (NODE)->immediate_fn_p = true)\n+\n // True if NODE was declared as 'concept'.  The flag implies that the\n // declaration is constexpr, that the declaration cannot be specialized or\n // refined, and that the result type must be convertible to bool.\n@@ -5879,6 +5889,7 @@ enum cp_decl_spec {\n   ds_constexpr,\n   ds_complex,\n   ds_constinit,\n+  ds_consteval,\n   ds_thread,\n   ds_type_spec,\n   ds_redefined_builtin_type_spec,\n@@ -7824,7 +7835,7 @@ extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,\n-\t\t\t\t\t\t bool = false);\n+\t\t\t\t\t\t bool = false, tree = NULL_TREE);\n extern tree fold_non_dependent_init\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,\n \t\t\t\t\t\t bool = false);"}, {"sha": "8f22f230954aeef4d26ce3ff42aadfbd585543d2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 146, "deletions": 36, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -1225,14 +1225,22 @@ validate_constexpr_redeclaration (tree old_decl, tree new_decl)\n     return true;\n   if (DECL_DECLARED_CONSTEXPR_P (old_decl)\n       == DECL_DECLARED_CONSTEXPR_P (new_decl))\n-    return true;\n+    {\n+      if (TREE_CODE (old_decl) != FUNCTION_DECL)\n+\treturn true;\n+      if (DECL_IMMEDIATE_FUNCTION_P (old_decl)\n+\t  == DECL_IMMEDIATE_FUNCTION_P (new_decl))\n+\treturn true;\n+    }\n   if (TREE_CODE (old_decl) == FUNCTION_DECL)\n     {\n       if (fndecl_built_in_p (old_decl))\n \t{\n \t  /* Hide a built-in declaration.  */\n \t  DECL_DECLARED_CONSTEXPR_P (old_decl)\n \t    = DECL_DECLARED_CONSTEXPR_P (new_decl);\n+\t  if (DECL_IMMEDIATE_FUNCTION_P (new_decl))\n+\t    SET_DECL_IMMEDIATE_FUNCTION_P (old_decl);\n \t  return true;\n \t}\n       /* 7.1.5 [dcl.constexpr]\n@@ -1242,9 +1250,14 @@ validate_constexpr_redeclaration (tree old_decl, tree new_decl)\n \t  && DECL_TEMPLATE_SPECIALIZATION (new_decl))\n \treturn true;\n \n+      const char *kind = \"constexpr\";\n+      if (DECL_IMMEDIATE_FUNCTION_P (old_decl)\n+\t  || DECL_IMMEDIATE_FUNCTION_P (new_decl))\n+\tkind = \"consteval\";\n       error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t\"redeclaration %qD differs in %<constexpr%> \"\n-\t\t\"from previous declaration\", new_decl);\n+\t\t\"redeclaration %qD differs in %qs \"\n+\t\t\"from previous declaration\", new_decl,\n+\t\tkind);\n       inform (DECL_SOURCE_LOCATION (old_decl),\n \t      \"previous declaration %qD\", old_decl);\n       return false;\n@@ -5024,12 +5037,15 @@ check_tag_decl (cp_decl_specifier_seq *declspecs,\n       else if (saw_typedef)\n \twarning_at (declspecs->locations[ds_typedef], 0,\n \t\t    \"%<typedef%> was ignored in this declaration\");\n-      else if (decl_spec_seq_has_spec_p (declspecs,  ds_constexpr))\n+      else if (decl_spec_seq_has_spec_p (declspecs, ds_constexpr))\n         error_at (declspecs->locations[ds_constexpr],\n-\t\t  \"%<constexpr%> cannot be used for type declarations\");\n-      else if (decl_spec_seq_has_spec_p (declspecs,  ds_constinit))\n+\t\t  \"%qs cannot be used for type declarations\", \"constexpr\");\n+      else if (decl_spec_seq_has_spec_p (declspecs, ds_constinit))\n \terror_at (declspecs->locations[ds_constinit],\n-\t\t  \"%<constinit%> cannot be used for type declarations\");\n+\t\t  \"%qs cannot be used for type declarations\", \"constinit\");\n+      else if (decl_spec_seq_has_spec_p (declspecs, ds_consteval))\n+\terror_at (declspecs->locations[ds_consteval],\n+\t\t  \"%qs cannot be used for type declarations\", \"consteval\");\n     }\n \n   if (declspecs->attributes && warn_attributes && declared_type)\n@@ -5387,11 +5403,14 @@ start_decl (const cp_declarator *declarator,\n       bool ok = false;\n       if (CP_DECL_THREAD_LOCAL_P (decl))\n \terror_at (DECL_SOURCE_LOCATION (decl),\n-\t\t  \"%qD declared %<thread_local%> in %<constexpr%> function\",\n-\t\t  decl);\n+\t\t  \"%qD declared %<thread_local%> in %qs function\", decl,\n+\t\t  DECL_IMMEDIATE_FUNCTION_P (current_function_decl)\n+\t\t  ? \"consteval\" : \"constexpr\");\n       else if (TREE_STATIC (decl))\n \terror_at (DECL_SOURCE_LOCATION (decl),\n-\t\t  \"%qD declared %<static%> in %<constexpr%> function\", decl);\n+\t\t  \"%qD declared %<static%> in %qs function\", decl,\n+\t\t  DECL_IMMEDIATE_FUNCTION_P (current_function_decl)\n+\t\t  ? \"consteval\" : \"constexpr\");\n       else\n \tok = true;\n       if (!ok)\n@@ -9342,6 +9361,15 @@ grokfndecl (tree ctype,\n \t  }\n     }\n \n+  /* FIXME: For now.  */\n+  if (virtualp && (inlinep & 8) != 0)\n+    {\n+      sorry_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%<virtual%> %<consteval%> method %qD not supported yet\",\n+\t\tdecl);\n+      inlinep &= ~8;\n+    }\n+\n   /* If this decl has namespace scope, set that up.  */\n   if (in_namespace)\n     set_decl_namespace (decl, in_namespace, friendp);\n@@ -9389,7 +9417,10 @@ grokfndecl (tree ctype,\n \t\t  \"cannot declare %<::main%> to be inline\");\n       if (inlinep & 2)\n \terror_at (declspecs->locations[ds_constexpr],\n-\t\t  \"cannot declare %<::main%> to be %<constexpr%>\");\n+\t\t  \"cannot declare %<::main%> to be %qs\", \"constexpr\");\n+      if (inlinep & 8)\n+\terror_at (declspecs->locations[ds_consteval],\n+\t\t  \"cannot declare %<::main%> to be %qs\", \"consteval\");\n       if (!publicp)\n \terror_at (location, \"cannot declare %<::main%> to be static\");\n       inlinep = 0;\n@@ -9428,6 +9459,11 @@ grokfndecl (tree ctype,\n     }\n   if (inlinep & 2)\n     DECL_DECLARED_CONSTEXPR_P (decl) = true;\n+  else if (inlinep & 8)\n+    {\n+      DECL_DECLARED_CONSTEXPR_P (decl) = true;\n+      SET_DECL_IMMEDIATE_FUNCTION_P (decl);\n+    }\n \n   // If the concept declaration specifier was found, check\n   // that the declaration satisfies the necessary requirements.\n@@ -10786,6 +10822,7 @@ grokdeclarator (const cp_declarator *declarator,\n   bool typedef_p = decl_spec_seq_has_spec_p (declspecs, ds_typedef);\n   bool constexpr_p = decl_spec_seq_has_spec_p (declspecs, ds_constexpr);\n   bool constinit_p = decl_spec_seq_has_spec_p (declspecs, ds_constinit);\n+  bool consteval_p = decl_spec_seq_has_spec_p (declspecs, ds_consteval);\n   bool late_return_type_p = false;\n   bool array_parameter_p = false;\n   tree reqs = NULL_TREE;\n@@ -11058,17 +11095,31 @@ grokdeclarator (const cp_declarator *declarator,\n   if (name == NULL)\n     name = decl_context == PARM ? \"parameter\" : \"type name\";\n \n+  if (consteval_p && constexpr_p)\n+    {\n+      error_at (declspecs->locations[ds_consteval],\n+\t\t\"both %qs and %qs specified\", \"constexpr\", \"consteval\");\n+      return error_mark_node;\n+    }\n+\n   if (concept_p && typedef_p)\n     {\n       error_at (declspecs->locations[ds_concept],\n-\t\t\"%<concept%> cannot appear in a typedef declaration\");\n+\t\t\"%qs cannot appear in a typedef declaration\", \"concept\");\n       return error_mark_node;\n     }\n \n   if (constexpr_p && typedef_p)\n     {\n       error_at (declspecs->locations[ds_constexpr],\n-\t\t\"%<constexpr%> cannot appear in a typedef declaration\");\n+\t\t\"%qs cannot appear in a typedef declaration\", \"constexpr\");\n+      return error_mark_node;\n+    }\n+\n+  if (consteval_p && typedef_p)\n+    {\n+      error_at (declspecs->locations[ds_consteval],\n+\t\t\"%qs cannot appear in a typedef declaration\", \"consteval\");\n       return error_mark_node;\n     }\n \n@@ -11474,21 +11525,31 @@ grokdeclarator (const cp_declarator *declarator,\n \n       /* Function parameters cannot be concept. */\n       if (concept_p)\n-\terror_at (declspecs->locations[ds_concept],\n-\t\t  \"a parameter cannot be declared %<concept%>\");\n+\t{\n+\t  error_at (declspecs->locations[ds_concept],\n+\t\t    \"a parameter cannot be declared %qs\", \"concept\");\n+\t  concept_p = 0;\n+\t  constexpr_p = 0;\n+\t}\n       /* Function parameters cannot be constexpr.  If we saw one, moan\n          and pretend it wasn't there.  */\n       else if (constexpr_p)\n         {\n           error_at (declspecs->locations[ds_constexpr],\n-\t\t    \"a parameter cannot be declared %<constexpr%>\");\n+\t\t    \"a parameter cannot be declared %qs\", \"constexpr\");\n           constexpr_p = 0;\n         }\n-      else if (constinit_p)\n+      if (constinit_p)\n \t{\n \t  error_at (declspecs->locations[ds_constinit],\n-\t\t    \"a parameter cannot be declared %<constinit%>\");\n-\t  constexpr_p = 0;\n+\t\t    \"a parameter cannot be declared %qs\", \"constinit\");\n+\t  constinit_p = 0;\n+\t}\n+      if (consteval_p)\n+\t{\n+\t  error_at (declspecs->locations[ds_consteval],\n+\t\t    \"a parameter cannot be declared %qs\", \"consteval\");\n+\t  consteval_p = 0;\n \t}\n     }\n \n@@ -11511,9 +11572,12 @@ grokdeclarator (const cp_declarator *declarator,\n       if (typedef_p)\n \terror_at (declspecs->locations[ds_typedef],\n \t\t  \"structured binding declaration cannot be %qs\", \"typedef\");\n-      if (constexpr_p)\n+      if (constexpr_p && !concept_p)\n \terror_at (declspecs->locations[ds_constexpr], \"structured \"\n \t\t  \"binding declaration cannot be %qs\", \"constexpr\");\n+      if (consteval_p)\n+\terror_at (declspecs->locations[ds_consteval], \"structured \"\n+\t\t  \"binding declaration cannot be %qs\", \"consteval\");\n       if (thread_p && cxx_dialect < cxx2a)\n \tpedwarn (declspecs->locations[ds_thread], 0,\n \t\t \"structured binding declaration can be %qs only in \"\n@@ -11573,6 +11637,7 @@ grokdeclarator (const cp_declarator *declarator,\n       inlinep = 0;\n       typedef_p = 0;\n       constexpr_p = 0;\n+      consteval_p = 0;\n       concept_p = 0;\n       if (storage_class != sc_static)\n \t{\n@@ -12967,7 +13032,7 @@ grokdeclarator (const cp_declarator *declarator,\n                 if (concept_p)\n                   {\n                     error_at (declspecs->locations[ds_concept],\n-\t\t\t      \"a destructor cannot be %<concept%>\");\n+\t\t\t      \"a destructor cannot be %qs\", \"concept\");\n                     return error_mark_node;\n                   }\n \t\tif (constexpr_p && cxx_dialect < cxx2a)\n@@ -12977,6 +13042,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t      \" with %<-std=c++2a%> or %<-std=gnu++2a%>\");\n \t\t    return error_mark_node;\n \t\t  }\n+\t\tif (consteval_p)\n+\t\t  {\n+\t\t    error_at (declspecs->locations[ds_consteval],\n+\t\t\t      \"a destructor cannot be %qs\", \"consteval\");\n+\t\t    return error_mark_node;\n+\t\t  }\n \t      }\n \t    else if (sfk == sfk_constructor && friendp && !ctype)\n \t      {\n@@ -12998,6 +13069,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t  \"a concept cannot be a member function\");\n \t\tconcept_p = false;\n \t      }\n+\t    else if (consteval_p\n+\t\t     && identifier_p (unqualified_id)\n+\t\t     && IDENTIFIER_NEWDEL_OP_P (unqualified_id))\n+\t      {\n+\t\terror_at (declspecs->locations[ds_consteval],\n+\t\t\t  \"%qD cannot be %qs\", unqualified_id, \"consteval\");\n+\t\tconsteval_p = false;\n+\t      }\n \n \t    if (TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR)\n \t      {\n@@ -13028,7 +13107,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       reqs,\n \t\t\t       virtualp, flags, memfn_quals, rqual, raises,\n \t\t\t       friendp ? -1 : 0, friendp, publicp,\n-                               inlinep | (2 * constexpr_p) | (4 * concept_p),\n+\t\t\t       inlinep | (2 * constexpr_p) | (4 * concept_p)\n+\t\t\t\t       | (8 * consteval_p),\n \t\t\t       initialized == SD_DELETED, sfk,\n \t\t\t       funcdef_flag, late_return_type_p,\n \t\t\t       template_count, in_namespace,\n@@ -13130,15 +13210,19 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tset_linkage_for_static_data_member (decl);\n \t\tif (concept_p)\n \t\t  error_at (declspecs->locations[ds_concept],\n-\t\t\t    \"static data member %qE declared %<concept%>\",\n-\t\t\t    unqualified_id);\n+\t\t\t    \"static data member %qE declared %qs\",\n+\t\t\t    unqualified_id, \"concept\");\n \t\telse if (constexpr_p && !initialized)\n \t\t  {\n \t\t    error_at (DECL_SOURCE_LOCATION (decl),\n \t\t\t      \"%<constexpr%> static data member %qD must \"\n \t\t\t      \"have an initializer\", decl);\n \t\t    constexpr_p = false;\n \t\t  }\n+\t\tif (consteval_p)\n+\t\t  error_at (declspecs->locations[ds_consteval],\n+\t\t\t    \"static data member %qE declared %qs\",\n+\t\t\t    unqualified_id, \"consteval\");\n \n \t\tif (inlinep)\n \t\t  mark_inline_variable (decl, declspecs->locations[ds_inline]);\n@@ -13163,23 +13247,34 @@ grokdeclarator (const cp_declarator *declarator,\n \t    else\n \t      {\n \t\tif (concept_p)\n-\t\t  error_at (declspecs->locations[ds_concept],\n-\t\t\t    \"non-static data member %qE declared %<concept%>\",\n-\t\t\t    unqualified_id);\n-                else if (constexpr_p)\n+\t\t  {\n+\t\t    error_at (declspecs->locations[ds_concept],\n+\t\t\t      \"non-static data member %qE declared %qs\",\n+\t\t\t      unqualified_id, \"concept\");\n+\t\t    concept_p = false;\n+\t\t    constexpr_p = false;\n+\t\t  }\n+\t\telse if (constexpr_p)\n \t\t  {\n \t\t    error_at (declspecs->locations[ds_constexpr],\n-\t\t\t      \"non-static data member %qE declared \"\n-\t\t\t      \"%<constexpr%>\", unqualified_id);\n+\t\t\t      \"non-static data member %qE declared %qs\",\n+\t\t\t      unqualified_id, \"constexpr\");\n \t\t    constexpr_p = false;\n \t\t  }\n-\t\telse if (constinit_p)\n+\t\tif (constinit_p)\n \t\t  {\n \t\t    error_at (declspecs->locations[ds_constinit],\n-\t\t\t      \"non-static data member %qE declared \"\n-\t\t\t      \"%<constinit%>\", unqualified_id);\n+\t\t\t      \"non-static data member %qE declared %qs\",\n+\t\t\t      unqualified_id, \"constinit\");\n \t\t    constinit_p = false;\n \t\t  }\n+\t\tif (consteval_p)\n+\t\t  {\n+\t\t    error_at (declspecs->locations[ds_consteval],\n+\t\t\t      \"non-static data member %qE declared %qs\",\n+\t\t\t      unqualified_id, \"consteval\");\n+\t\t    consteval_p = false;\n+\t\t  }\n \t\tdecl = build_decl (id_loc, FIELD_DECL, unqualified_id, type);\n \t\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \t\tif (bitfield && !unqualified_id)\n@@ -13285,6 +13380,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tsfk = sfk_none;\n \t      }\n \t  }\n+\tif (consteval_p\n+\t    && identifier_p (unqualified_id)\n+\t    && IDENTIFIER_NEWDEL_OP_P (unqualified_id))\n+\t  {\n+\t    error_at (declspecs->locations[ds_consteval],\n+\t\t      \"%qD cannot be %qs\", unqualified_id, \"consteval\");\n+\t    consteval_p = false;\n+\t  }\n \n \t/* Record whether the function is public.  */\n \tpublicp = (ctype != NULL_TREE\n@@ -13295,7 +13398,8 @@ grokdeclarator (const cp_declarator *declarator,\n                            reqs, virtualp, flags, memfn_quals, rqual, raises,\n \t\t\t   1, friendp,\n \t\t\t   publicp,\n-                           inlinep | (2 * constexpr_p) | (4 * concept_p),\n+\t\t\t   inlinep | (2 * constexpr_p) | (4 * concept_p)\n+\t\t\t\t   | (8 * consteval_p),\n \t\t\t   initialized == SD_DELETED,\n                            sfk,\n                            funcdef_flag,\n@@ -13388,6 +13492,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      \"is not a definition\", decl);\n \t    constexpr_p = false;\n \t  }\n+\tif (consteval_p)\n+\t  {\n+\t    error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t      \"a variable cannot be declared %<consteval%>\");\n+\t    consteval_p = false;\n+\t  }\n \n \tif (inlinep)\n \t  mark_inline_variable (decl, declspecs->locations[ds_inline]);\n@@ -16696,7 +16806,7 @@ finish_function (bool inline_p)\n     invoke_plugin_callbacks (PLUGIN_PRE_GENERICIZE, fndecl);\n \n   /* Perform delayed folding before NRV transformation.  */\n-  if (!processing_template_decl)\n+  if (!processing_template_decl && !DECL_IMMEDIATE_FUNCTION_P (fndecl))\n     cp_fold_function (fndecl);\n \n   /* Set up the named return value optimization, if we can.  Candidate\n@@ -16813,7 +16923,7 @@ finish_function (bool inline_p)\n     do_warn_unused_parameter (fndecl);\n \n   /* Genericize before inlining.  */\n-  if (!processing_template_decl)\n+  if (!processing_template_decl && !DECL_IMMEDIATE_FUNCTION_P (fndecl))\n     cp_genericize (fndecl);\n \n   /* We're leaving the context of this function, so zap cfun.  It's still in"}, {"sha": "d104a4d574c40e5ff04b0be3e898970900536b4d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -1652,7 +1652,9 @@ dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n         {\n           if (DECL_DECLARED_CONCEPT_P (t))\n             pp_cxx_ws_string (pp, \"concept\");\n-          else\n+\t  else if (DECL_IMMEDIATE_FUNCTION_P (t))\n+\t    pp_cxx_ws_string (pp, \"consteval\");\n+\t  else\n \t    pp_cxx_ws_string (pp, \"constexpr\");\n \t}\n     }"}, {"sha": "eda827250dab82fa9d0b6ba11a2f42f0f3198f99", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -348,14 +348,12 @@ build_value_init (tree type, tsubst_flags_t complain)\n   gcc_assert (!processing_template_decl\n \t      || (SCALAR_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE));\n \n-  if (CLASS_TYPE_P (type)\n-      && type_build_ctor_call (type))\n+  if (CLASS_TYPE_P (type) && type_build_ctor_call (type))\n     {\n-      tree ctor =\n-\t build_special_member_call (NULL_TREE, complete_ctor_identifier,\n-\t\t\t\t    NULL, type, LOOKUP_NORMAL,\n-\t\t\t\t    complain);\n-      if (ctor == error_mark_node)\n+      tree ctor\n+\t= build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t     NULL, type, LOOKUP_NORMAL, complain);\n+      if (ctor == error_mark_node || TREE_CONSTANT (ctor))\n \treturn ctor;\n       tree fn = NULL_TREE;\n       if (TREE_CODE (ctor) == CALL_EXPR)"}, {"sha": "c582aa5b10573f9e7a6b9ac696f4d2c4193bda31", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -1194,6 +1194,9 @@ maybe_add_lambda_conv_op (tree type)\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n+  DECL_DECLARED_CONSTEXPR_P (fn) = DECL_DECLARED_CONSTEXPR_P (callop);\n+  if (DECL_IMMEDIATE_FUNCTION_P (callop))\n+    SET_DECL_IMMEDIATE_FUNCTION_P (fn);\n   DECL_ARGUMENTS (fn) = build_this_parm (fn, fntype, TYPE_QUAL_CONST);\n \n   if (nested_def)\n@@ -1226,6 +1229,9 @@ maybe_add_lambda_conv_op (tree type)\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_STATIC_FUNCTION_P (fn) = 1;\n+  DECL_DECLARED_CONSTEXPR_P (fn) = DECL_DECLARED_CONSTEXPR_P (callop);\n+  if (DECL_IMMEDIATE_FUNCTION_P (callop))\n+    SET_DECL_IMMEDIATE_FUNCTION_P (fn);\n   DECL_ARGUMENTS (fn) = fn_args;\n   for (tree arg = fn_args; arg; arg = DECL_CHAIN (arg))\n     {"}, {"sha": "09e9c73cda59c7cb03cc6c6b1640a6168473dd9a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -2228,8 +2228,9 @@ defaulted_late_check (tree fn)\n       if (!CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n \t{\n \t  error (\"explicitly defaulted function %q+D cannot be declared \"\n-\t\t \"%qs because the implicit declaration is not %qs:\",\n-\t\t fn, \"constexpr\", \"constexpr\");\n+\t\t \"%qs because the implicit declaration is not %qs:\", fn,\n+\t\t DECL_IMMEDIATE_FUNCTION_P (fn) ? \"consteval\" : \"constexpr\",\n+\t\t \"constexpr\");\n \t  explain_implicit_non_constexpr (fn);\n \t}\n       DECL_DECLARED_CONSTEXPR_P (fn) = false;"}, {"sha": "0b7bf83c4f436722eaa1007356984c1b2069b151", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -233,7 +233,10 @@ struct GTY(()) cp_binding_level {\n      'this_entity'.  */\n   unsigned defining_class_p : 1;\n \n-  /* 23 bits left to fill a 32-bit word.  */\n+  /* true for SK_FUNCTION_PARMS of immediate functions.  */\n+  unsigned immediate_fn_ctx_p : 1;\n+\n+  /* 22 bits left to fill a 32-bit word.  */\n };\n \n /* The binding level currently in effect.  */"}, {"sha": "516c14b5610decd7b9c27d73ebc1a885a0c4f519", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -998,11 +998,13 @@ cp_keyword_starts_decl_specifier_p (enum rid keyword)\n       /* GNU extensions.  */\n     case RID_ATTRIBUTE:\n     case RID_TYPEOF:\n-      /* C++0x extensions.  */\n+      /* C++11 extensions.  */\n     case RID_DECLTYPE:\n     case RID_UNDERLYING_TYPE:\n     case RID_CONSTEXPR:\n+      /* C++20 extensions.  */\n     case RID_CONSTINIT:\n+    case RID_CONSTEVAL:\n       return true;\n \n     default:\n@@ -1807,12 +1809,15 @@ enum\n   /* When parsing a decl-specifier-seq, only allow type-specifier or\n      constexpr.  */\n   CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR = 0x8,\n-  /* When parsing a decl-specifier-seq, only allow mutable or constexpr.  */\n+  /* When parsing a decl-specifier-seq, only allow mutable, constexpr or\n+     for C++2A consteval.  */\n   CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR = 0x10,\n   /* When parsing a decl-specifier-seq, allow missing typename.  */\n   CP_PARSER_FLAGS_TYPENAME_OPTIONAL = 0x20,\n   /* When parsing of the noexcept-specifier should be delayed.  */\n-  CP_PARSER_FLAGS_DELAY_NOEXCEPT = 0x40\n+  CP_PARSER_FLAGS_DELAY_NOEXCEPT = 0x40,\n+  /* When parsing a consteval declarator.  */\n+  CP_PARSER_FLAGS_CONSTEVAL = 0x80\n };\n \n /* This type is used for parameters and variables which hold\n@@ -2671,6 +2676,7 @@ static bool cp_parser_init_statement_p\n   (cp_parser *);\n static bool cp_parser_skip_to_closing_square_bracket\n   (cp_parser *);\n+static size_t cp_parser_skip_balanced_tokens (cp_parser *, size_t);\n \n // -------------------------------------------------------------------------- //\n // Unevaluated Operand Guard\n@@ -10903,11 +10909,31 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n      opening parenthesis if present.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n+      bool is_consteval = false;\n+      /* For C++20, before parsing the parameter list check if there is\n+\t a consteval specifier in the corresponding decl-specifier-seq.  */\n+      if (cxx_dialect >= cxx2a)\n+\t{\n+\t  for (size_t n = cp_parser_skip_balanced_tokens (parser, 1);\n+\t       cp_lexer_nth_token_is (parser->lexer, n, CPP_KEYWORD); n++)\n+\t    {\n+\t      if (cp_lexer_peek_nth_token (parser->lexer, n)->keyword\n+\t\t  == RID_CONSTEVAL)\n+\t\t{\n+\t\t  is_consteval = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n       matching_parens parens;\n       parens.consume_open (parser);\n \n       begin_scope (sk_function_parms, /*entity=*/NULL_TREE);\n \n+      if (is_consteval)\n+\tcurrent_binding_level->immediate_fn_ctx_p = true;\n+\n       /* Parse parameters.  */\n       param_list\n \t= cp_parser_parameter_declaration_clause\n@@ -10992,6 +11018,9 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t\t    \"lambda only available with %<-std=c++17%> or \"\n \t\t    \"%<-std=gnu++17%>\");\n       }\n+    if (lambda_specs.locations[ds_consteval])\n+      return_type_specs.locations[ds_consteval]\n+\t= lambda_specs.locations[ds_consteval];\n \n     p = obstack_alloc (&declarator_obstack, 0);\n \n@@ -14052,6 +14081,11 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  break;\n \n+\tcase RID_CONSTEVAL:\n+\t  ds = ds_consteval;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  break;\n+\n         case RID_CONCEPT:\n           ds = ds_concept;\n           cp_lexer_consume_token (parser->lexer);\n@@ -14169,7 +14203,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       if (found_decl_spec\n \t  && (flags & CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR)\n \t  && token->keyword != RID_MUTABLE\n-\t  && token->keyword != RID_CONSTEXPR)\n+\t  && token->keyword != RID_CONSTEXPR\n+\t  && token->keyword != RID_CONSTEVAL)\n \terror_at (token->location, \"%qD invalid in lambda\",\n \t\t  ridpointers[token->keyword]);\n \n@@ -17310,6 +17345,10 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t    permerror (decl_specifiers.locations[ds_constexpr],\n \t\t       \"explicit instantiation shall not use\"\n \t\t       \" %<constexpr%> specifier\");\n+\t  if (decl_spec_seq_has_spec_p (&decl_specifiers, ds_consteval))\n+\t    permerror (decl_specifiers.locations[ds_consteval],\n+\t\t       \"explicit instantiation shall not use\"\n+\t\t       \" %<consteval%> specifier\");\n \n \t  decl = grokdeclarator (declarator, &decl_specifiers,\n \t\t\t\t NORMAL, 0, &decl_specifiers.attributes);\n@@ -20295,6 +20334,9 @@ cp_parser_init_declarator (cp_parser* parser,\n   bool saved_default_arg_ok_p = parser->default_arg_ok_p;\n   location_t tmp_init_loc = UNKNOWN_LOCATION;\n \n+  if (decl_spec_seq_has_spec_p (decl_specifiers, ds_consteval))\n+    flags |= CP_PARSER_FLAGS_CONSTEVAL;\n+\n   /* Gather the attributes that were provided with the\n      decl-specifiers.  */\n   prefix_attributes = decl_specifiers->attributes;\n@@ -20939,6 +20981,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t      begin_scope (sk_function_parms, NULL_TREE);\n \n+\t      /* Signal we are in the immediate function context.  */\n+\t      if (flags & CP_PARSER_FLAGS_CONSTEVAL)\n+\t\tcurrent_binding_level->immediate_fn_ctx_p = true;\n+\n \t      /* Parse the parameter-declaration-clause.  */\n \t      params\n \t\t= cp_parser_parameter_declaration_clause (parser, flags);\n@@ -29960,9 +30006,10 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,\n \t    \"friend\",\n \t    \"typedef\",\n \t    \"using\",\n-            \"constexpr\",\n+\t    \"constexpr\",\n \t    \"__complex\",\n-\t    \"constinit\"\n+\t    \"constinit\",\n+\t    \"consteval\"\n \t  };\n \t  gcc_rich_location richloc (location);\n \t  richloc.add_fixit_remove ();"}, {"sha": "8293c0721bd5d295de894bfc43e62c962bbfe057", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -4428,7 +4428,7 @@ expand_or_defer_fn_1 (tree fn)\n       if (DECL_INTERFACE_KNOWN (fn))\n \t/* We've already made a decision as to how this function will\n \t   be handled.  */;\n-      else if (!at_eof)\n+      else if (!at_eof || DECL_IMMEDIATE_FUNCTION_P (fn))\n \ttentative_decl_linkage (fn);\n       else\n \timport_export_decl (fn);\n@@ -4439,6 +4439,7 @@ expand_or_defer_fn_1 (tree fn)\n \t be emitted; there may be callers in other DLLs.  */\n       if (DECL_DECLARED_INLINE_P (fn)\n \t  && !DECL_REALLY_EXTERN (fn)\n+\t  && !DECL_IMMEDIATE_FUNCTION_P (fn)\n \t  && (flag_keep_inline_functions\n \t      || (flag_keep_inline_dllexport\n \t\t  && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (fn)))))"}, {"sha": "15529c66b1efa62b2021b7b459e0082ce7b927dc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -6176,6 +6176,16 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n   if (processing_template_decl || TREE_CODE (arg) != COMPONENT_REF)\n     {\n       tree stripped_arg = tree_strip_any_location_wrapper (arg);\n+      if (TREE_CODE (stripped_arg) == FUNCTION_DECL\n+\t  && DECL_IMMEDIATE_FUNCTION_P (stripped_arg)\n+\t  && (current_function_decl == NULL_TREE\n+\t      || !DECL_IMMEDIATE_FUNCTION_P (current_function_decl)))\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"taking address of an immediate function %qD\",\n+\t\t   stripped_arg);\n+\t  return error_mark_node;\n+\t}\n       if (TREE_CODE (stripped_arg) == FUNCTION_DECL\n \t  && !mark_used (stripped_arg, complain) && !(complain & tf_error))\n \treturn error_mark_node;"}, {"sha": "5473b252e731a7ab9136fed99ae039512563f848", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -1,5 +1,22 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/88335 - Implement P1073R3: Immediate functions\n+\t* g++.dg/cpp2a/consteval1.C: New test.\n+\t* g++.dg/cpp2a/consteval2.C: New test.\n+\t* g++.dg/cpp2a/consteval3.C: New test.\n+\t* g++.dg/cpp2a/consteval4.C: New test.\n+\t* g++.dg/cpp2a/consteval5.C: New test.\n+\t* g++.dg/cpp2a/consteval6.C: New test.\n+\t* g++.dg/cpp2a/consteval7.C: New test.\n+\t* g++.dg/cpp2a/consteval8.C: New test.\n+\t* g++.dg/cpp2a/consteval9.C: New test.\n+\t* g++.dg/cpp2a/consteval10.C: New test.\n+\t* g++.dg/cpp2a/consteval11.C: New test.\n+\t* g++.dg/cpp2a/consteval12.C: New test.\n+\t* g++.dg/cpp2a/consteval13.C: New test.\n+\t* g++.dg/cpp2a/consteval14.C: New test.\n+\t* g++.dg/ext/consteval1.C: New test.\n+\n \tPR c++/91369 - Implement P0784R7: constexpr new\n \t* g++.dg/cpp2a/constexpr-new6.C: New test.\n \t* g++.dg/cpp2a/constexpr-new7.C: New test."}, {"sha": "fa00b07e272a9af9df72112908f3c1efd53b2f5c", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval1.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a\" }\n+\n+namespace std {\n+  constexpr inline bool\n+  is_constant_evaluated () noexcept\n+  {\n+    return __builtin_is_constant_evaluated ();\n+  }\n+}\n+\n+extern \"C\" void abort ();\n+constexpr int f0 (int n) { return n; }\n+consteval int f1 (int n) { return f0 (n) * n; }\n+consteval int f2 (int n) { return f1 (n); }\n+consteval bool f3 () { return std::is_constant_evaluated (); }\n+struct S { constexpr S (int x) : s (x) {} consteval int m1 (int n) const; int s; };\n+consteval int\n+S::m1 (int n) const\n+{\n+  n += s;\n+  return n;\n+}\n+\n+constexpr int a = 2;\n+int b = f1 (a);\n+int c = f2 (f1 (a));\n+bool d = f3 ();\n+constexpr S e = 41;\n+int f = e.m1 (1);\n+\n+int\n+main ()\n+{\n+  if (b != 4 || c != 16 || !d || f != 42)\n+    abort ();\n+}"}, {"sha": "6785f60df58cee73fbf723c6256a5e0af74492d0", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval10.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval10.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do compile }\n+\n+consteval int bar (void) { return 0; }\t// { dg-error \"'consteval' does not name a type\" \"\" { target c++17_down } }"}, {"sha": "2f68ec0f8928602641afa751d168a689f5ddf09b", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval11.C", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval11.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,140 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+consteval int bar (int i) { if (i != 1) throw 1; return 0; }\t// { dg-error \"is not a constant expression\" }\n+\n+constexpr int a = bar (1);\n+constexpr int b = bar (2);\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+constexpr int c = 0 ? bar (3) : 1;\t// { dg-message \"in 'constexpr' expansion of\" }\n+const int d = bar (4);\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+const int e = 0 ? bar (5) : 1;\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+int f = bar (1);\n+int g = bar (6);\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+int h = 0 ? bar (7) : 1;\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+\n+void\n+foo ()\n+{\n+  constexpr int a = bar (1);\n+  constexpr int b = bar (2);\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  constexpr int c = 0 ? bar (3) : 1;\t// { dg-message \"in 'constexpr' expansion of\" }\n+  const int d = bar (4);\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  const int e = 0 ? bar (5) : 1;\t// { dg-message \"in 'constexpr' expansion of\" }\n+  int f = bar (1);\n+  int g = bar (6);\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  int h = 0 ? bar (7) : 1;\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  h += 0 ? bar (8) : 1;\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if (0)\n+    bar (9);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (10);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if (1)\n+    bar (11);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (12);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if constexpr (0)\n+    bar (13);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (14);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if constexpr (1)\n+    bar (15);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (16);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+}\n+\n+consteval int\n+baz ()\n+{\n+  constexpr int a = bar (1);\n+  constexpr int b = bar (2);\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  constexpr int c = 0 ? bar (3) : 1;\n+  const int d = bar (4);\n+  const int e = 0 ? bar (5) : 1;\n+  int f = bar (1);\n+  int g = bar (6);\n+  int h = 0 ? bar (7) : 1;\n+  h += 0 ? bar (8) : 1;\n+  if (0)\n+    bar (9);\n+  else\n+    bar (10);\n+  if (1)\n+    bar (11);\n+  else\n+    bar (12);\n+  if constexpr (0)\n+    bar (13);\n+  else\n+    bar (14);\n+  if constexpr (1)\n+    bar (15);\n+  else\n+    bar (16);\n+  return 0;\n+}\n+\n+template <typename T>\n+void\n+qux ()\n+{\n+  if (0)\n+    bar (2);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (3);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if (1)\n+    bar (4);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (5);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if constexpr (0)\n+    bar (6);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (7);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if constexpr (1)\n+    bar (8);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar (9);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if (0)\n+    bar ((T) 2);\n+  else\n+    bar ((T) 3);\n+  if (1)\n+    bar ((T) 4);\n+  else\n+    bar ((T) 5);\n+  if constexpr (0)\n+    bar ((T) 6);\n+  else\n+    bar ((T) 7);\n+  if constexpr (1)\n+    bar ((T) 8);\n+  else\n+    bar ((T) 9);\n+}\n+\n+template <typename T>\n+void\n+quux ()\n+{\n+  if (0)\n+    bar ((T) 2);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar ((T) 3);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if (1)\n+    bar ((T) 4);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar ((T) 5);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if constexpr (0)\n+    bar ((T) 6);\n+  else\n+    bar ((T) 7);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  if constexpr (1)\n+    bar ((T) 8);\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" }\n+  else\n+    bar ((T) 9);\n+}\n+\n+void\n+corge ()\n+{\n+  quux <int> ();\n+}"}, {"sha": "0e97cf2136a1df0700e7a1266cec5a9230d8ae7c", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval12.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval12.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+consteval int bar () { return 42; }\n+consteval int baz () { return 1; }\n+typedef int (*fnptr) ();\n+consteval fnptr quux () { return bar; }\n+\n+void\n+foo ()\n+{\n+   auto qux = [] (fnptr a = quux ()) consteval { return a (); };\n+   constexpr auto e = qux ();\n+   static_assert (e == 42);\n+}"}, {"sha": "8db7e6611c01cc6a01eb31240606fe5cb27d4245", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval13.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval13.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+consteval int bar () { return 42; }\n+consteval int baz () { return 1; }\n+typedef int (*fnptr) ();\n+consteval fnptr quux () { return bar; }\n+\n+void\n+foo ()\n+{\n+   auto qux = [] (fnptr a = quux ()) consteval { return a (); };\n+   constexpr auto c = qux (baz);\t// { dg-error \"taking address of an immediate function\" }\n+   constexpr auto d = qux (bar);\t// { dg-error \"taking address of an immediate function\" }\n+   static_assert (c == 1);\n+   static_assert (d == 42);\n+}"}, {"sha": "54ab927705ca2aaebfbad6d13cca7b0503243634", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval14.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval14.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+struct S { consteval S () : a (1), b (2) { a++; b++; } consteval S (int x) : a (x), b (x) { a++; b--; } int a, b; };\n+S c;\n+\n+template <int N>\n+int\n+foo ()\n+{\n+  S a;\n+  a.b++;\n+  c = a;\n+  S b = 12;\n+  c.a += b.a;\n+  c.b += b.b;\n+  S e[2];\n+  S f[2] = { 1, 2 };\n+  const S g;\n+  c.a += g.a;\n+  c.b += g.b;\n+  const S h = 12;\n+  c.a += h.a;\n+  c.b += h.b;\n+  const S i[2];\n+  const S j[2] = { 1, 2 };\n+  return S ().a + e[1].a + f[0].b + i[0].a + j[1].b;\n+}\n+\n+int x = foo <2> ();"}, {"sha": "8975002ad13365e952127a912186ced1df511e66", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval2.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a\" }\n+\n+extern \"C\" void abort ();\n+consteval int foo () { return 42; }\n+consteval auto bar () { return foo; }\n+consteval int baz (int (*fn) () = bar ()) { return fn (); }\n+constexpr int a = baz ();\n+static_assert (a == 42);\n+int b = baz ();\n+\n+int\n+main ()\n+{\n+  if (b != 42)\n+    abort ();\n+}"}, {"sha": "4214092131fd470fa13320c0e6faae62836f4586", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval3.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval3.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+struct S { S () : a (0), b (1) {} int a, b; };\n+int f1 ();\t\t// { dg-message \"previous declaration 'int f1\\\\(\\\\)'\" }\n+consteval int f1 ();\t// { dg-error \"redeclaration 'consteval int f1\\\\(\\\\)' differs in 'consteval' from previous declaration\" }\n+consteval int f2 ();\t// { dg-message \"previous declaration 'consteval int f2\\\\(\\\\)'\" }\n+int f2 ();\t\t// { dg-error \"redeclaration 'int f2\\\\(\\\\)' differs in 'consteval' from previous declaration\" }\n+constexpr int f3 ();\t// { dg-message \"previous declaration 'constexpr int f3\\\\(\\\\)'\" }\n+consteval int f3 ();\t// { dg-error \"redeclaration 'consteval int f3\\\\(\\\\)' differs in 'consteval' from previous declaration\" }\n+consteval int f4 ();\t// { dg-message \"previous declaration 'consteval int f4\\\\(\\\\)'\" }\n+constexpr int f4 ();\t// { dg-error \"redeclaration 'constexpr int f4\\\\(\\\\)' differs in 'consteval' from previous declaration\" }\n+typedef consteval int cint;\t// { dg-error \"'consteval' cannot appear in a typedef declaration\" }\n+consteval struct T { int i; };\t// { dg-error \"'consteval' cannot be used for type declarations\" }\n+consteval int a = 5;\t// { dg-error \"a variable cannot be declared 'consteval'\" }\n+consteval auto [ b, c ] = S ();\t\t// { dg-error \"structured binding declaration cannot be 'consteval'\" }\n+int f5 (consteval int x) { return x; }\t// { dg-error \"a parameter cannot be declared 'consteval'\" }\n+consteval int f6 (int x) { return x; }\n+int d = 6;\t\t// { dg-message \"'int d' is not const\" }\n+int e = f6 (d);\t\t// { dg-error \"the value of 'd' is not usable in a constant expression\" }\n+constexpr int f7 (int x) { return f6 (x); }\t// { dg-error \"'x' is not a constant expression\" }\n+constexpr int f = f7 (5);\t// { dg-error \"\" }\n+\t\t\t\t// { dg-message \"in 'constexpr' expansion of\" \"\" { target *-*-* } .-1 }\n+using fnptr = int (int);\n+fnptr *g = f6;\t\t// { dg-error \"taking address of an immediate function 'consteval int f6\\\\(int\\\\)'\" }\n+int f8 (fnptr *);\n+int h = f8 (f6);\t// { dg-error \"taking address of an immediate function 'consteval int f6\\\\(int\\\\)'\" }\n+consteval constexpr int f9 () { return 0; }\t// { dg-error \"both 'constexpr' and 'consteval' specified\" }\n+constexpr consteval int f10 () { return 0; }\t// { dg-error \"both 'constexpr' and 'consteval' specified\" }\n+consteval consteval int f11 () { return 0; }\t// { dg-error \"duplicate 'consteval'\" }\n+struct U { consteval ~U () {} };\t// { dg-error \"a destructor cannot be 'consteval'\" }\n+struct V { consteval int v = 5; };\t// { dg-error \"non-static data member 'v' declared 'consteval'\" }\n+struct W { consteval static int w; };\t// { dg-error \"static data member 'w' declared 'consteval'\" }\n+int i = sizeof (&f6);\t\t\t// { dg-error \"taking address of an immediate function 'consteval int f6\\\\(int\\\\)'\" }\n+using j = decltype (&f6);\t\t// { dg-error \"taking address of an immediate function 'consteval int f6\\\\(int\\\\)'\" }\n+int k = sizeof (f6 (d));\t\t// { dg-error \"the value of 'd' is not usable in a constant expression\" }\n+using l = decltype (f6 (d));\t\t// { dg-error \"the value of 'd' is not usable in a constant expression\" }\n+bool m = noexcept (f6 (d));\t\t// { dg-error \"the value of 'd' is not usable in a constant expression\" }\n+namespace std {\n+using size_t = decltype (sizeof (0));\n+}\n+consteval void* operator new (std::size_t);\t// { dg-error \"'operator new' cannot be 'consteval'\" }\n+consteval void operator delete (void *, std::size_t) noexcept;\t// { dg-error \"'operator delete' cannot be 'consteval'\" }\n+consteval void operator delete[] (void *) noexcept;\t// { dg-error \"'operator delete \\\\\\[\\\\\\]' cannot be 'consteval'\" }\n+struct X {\n+  static consteval void* operator new (std::size_t);\t// { dg-error \"'operator new' cannot be 'consteval'\" }\n+  static consteval void operator delete (void *, std::size_t) noexcept;\t// { dg-error \"'operator delete' cannot be 'consteval'\" }\n+  consteval static void operator delete[] (void *) noexcept;\t// { dg-error \"'operator delete \\\\\\[\\\\\\]' cannot be 'consteval'\" }\n+};\n+consteval int main () { return 0; }\t// { dg-error \"cannot declare '::main' to be 'consteval'\" }\n+struct A { A (); int a; };\t\t// { dg-message \"defaulted constructor calls non-'constexpr' 'A::A\\\\(\\\\)'\" }\n+struct B { constexpr B () : b (0) {} int b; };\n+struct C { A a; consteval C () = default; };\t// { dg-error \"explicitly defaulted function 'consteval C::C\\\\(\\\\)' cannot be declared 'consteval' because the implicit declaration is not 'constexpr'\" }\n+struct D { B b; consteval D () = default; };\n+template <class T> consteval T f12 (T x) { return x; }\n+template consteval float f12 (float x); // { dg-error \"explicit instantiation shall not use 'consteval' specifier\" }\n+consteval int\n+f13 (int x)\n+{\n+  static int a = 5;\t\t// { dg-error \"'a' declared 'static' in 'consteval' function\" }\n+  thread_local int b = 6;\t// { dg-error \"'b' declared 'thread_local' in 'consteval' function\" }\n+  return x;\n+}"}, {"sha": "3e55c2b5c83e2076c05d1154dbbaf247f5a04f8a", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval4.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval4.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a\" }\n+\n+extern \"C\" void abort ();\n+namespace std {\n+  constexpr inline bool\n+  is_constant_evaluated () noexcept\n+  {\n+    return __builtin_is_constant_evaluated ();\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  constexpr int a = 5;\n+  auto b = [] (int n) consteval { return n + a + std::is_constant_evaluated (); };\n+  int c = b (4);\n+  if (c != 10)\n+    abort ();\n+  auto d = [] () consteval { return a + std::is_constant_evaluated (); };\n+  int e = d ();\n+  if (e != 6)\n+    abort ();\n+  constexpr int f = d ();\n+  if (f != 6)\n+    abort ();\n+  static_assert (d () == 6);\n+}"}, {"sha": "600ce40149b29e1811c907ed0aabd7dfee88dd0a", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval5.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval5.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a\" }\n+\n+namespace std {\n+  constexpr inline bool\n+  is_constant_evaluated () noexcept\n+  {\n+    return __builtin_is_constant_evaluated ();\n+  }\n+}\n+\n+extern \"C\" void abort ();\n+template <int N>\n+constexpr int f0 (int n) { return n + N; }\n+template <int N>\n+consteval int f1 (int n) { return f0<N> (n) * n + N; }\n+template <int N>\n+consteval int f2 (int n) { return f1<N> (n); }\n+template <int N>\n+consteval bool f3 () { return std::is_constant_evaluated () + N; }\n+struct S { constexpr S (int x) : s (x) {} template <int N> consteval int m1 (int n) const; int s; };\n+template <int N>\n+consteval int\n+S::m1 (int n) const\n+{\n+  n += s + N;\n+  return n;\n+}\n+\n+constexpr int a = 2;\n+int b = f1<0> (a);\n+int c = f2<0> (f1<0> (a));\n+bool d = f3<0> ();\n+constexpr S e = 41;\n+int f = e.m1<0> (1);\n+\n+int\n+main ()\n+{\n+  if (b != 4 || c != 16 || !d || f != 42)\n+    abort ();\n+}"}, {"sha": "72d5f79762e64b33202619d7e3bdebc8d2c19c39", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval6.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval6.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+struct A {\n+  constexpr A () {}\n+  A (A const&) = delete;\t// { dg-message \"declared here\" }\n+};\n+\n+template<typename T>\n+constexpr void\n+foo ()\n+{\n+  T t;\n+  T u = t;\n+}\n+\n+template<typename T>\n+consteval void\n+bar ()\n+{\n+  T t;\n+  T u = t;\t// { dg-error \"use of deleted function\" }\n+}\n+\n+using B = decltype (foo<A> ());\n+using C = decltype (bar<A> ());\t// { dg-message \"required from here\" }"}, {"sha": "10e4ea41c9b53e255eb48a998edbfe0166dae87f", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval7.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval7.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+consteval int foo () { return 42; }\n+consteval auto bar () { return foo; }\n+constexpr auto a = bar ();\t// { dg-error \"immediate evaluation returns address of immediate function 'consteval int foo\\\\(\\\\)'\" }\n+struct S { int b; int (*c) (); };\n+consteval S baz () { return { 5, foo }; }\n+consteval int qux () { S s = baz (); return s.b + s.c (); }\n+consteval int quux () { constexpr S s = baz (); return s.b + s.c (); }\n+constexpr auto d = baz ();\t// { dg-error \"immediate evaluation returns address of immediate function 'consteval int foo\\\\(\\\\)'\" }\n+constexpr auto e = qux ();\n+constexpr auto f = quux ();"}, {"sha": "105737d8f764ffd0e882417fd3ed072d6229d595", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval8.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval8.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+struct S { consteval S () : a (1), b (2) { a++; b++; } consteval S (int x) : a (x), b (x) { a++; b--; } int a, b; };\n+S c;\n+S d = 25;\n+\n+int\n+foo ()\n+{\n+  S a;\n+  a.b++;\n+  c = a;\n+  S b = 12;\n+  c.a += b.a;\n+  c.b += b.b;\n+  S e[2];\n+  S f[2] = { 1, 2 };\n+  return S ().a + e[1].a + f[0].b;\n+}\n+\n+constexpr S g;\n+constexpr S h = 42;\n+constexpr S i[2];\n+constexpr S j[2] = { 3, 4 };\n+static_assert (g.a == 2 && g.b == 3);\n+static_assert (h.a == 43 && h.b == 41);\n+static_assert (i[0].a == 2 && i[0].b == 3 && i[1].a == 2 && i[1].b == 3);\n+static_assert (j[0].a == 4 && j[0].b == 2 && j[1].a == 5 && j[1].b == 3);"}, {"sha": "489286a12d2a592707233965bd6d914b1e77cb59", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval9.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval9.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+consteval int bar (int i) { if (i != 1) throw 1; return 0; }\t// { dg-error \"is not a constant expression\" }\n+\n+template <int N>\n+void foo ()\n+{\n+  int a = bar (N);\n+}\n+\n+template <int N>\n+void qux ()\n+{\n+  int a = bar (N);\t// { dg-message \"in 'constexpr' expansion of 'bar\\\\(2\\\\)'\" }\n+}\n+\n+template <int N>\n+void quux ()\n+{\n+  int a = bar (5);\t// { dg-message \"in 'constexpr' expansion of 'bar\\\\(5\\\\)'\" }\n+}\n+\n+void\n+baz ()\n+{\n+  foo<1> ();\n+  qux<2> ();\n+}\n+\n+int a = bar (2);\t// { dg-message \"in 'constexpr' expansion of 'bar\\\\(2\\\\)'\" }"}, {"sha": "928e0f8ab174cf4f1b15f0c7e7b08f4b0cb1bc58", "filename": "gcc/testsuite/g++.dg/ext/consteval1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconsteval1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconsteval1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconsteval1.C?ref=f968ef9b8df2bc2287e5e7e87299e5a2a44e8c94", "patch": "@@ -0,0 +1,6 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+consteval int foo (int x) { return x; }\n+int d = 6;\t\t\t// { dg-message \"'int d' is not const\" }\n+bool e = __builtin_has_attribute (foo (d), packed);\t// { dg-error \"the value of 'd' is not usable in a constant expression\" }"}]}