{"sha": "9eab67850ba2faf07c1bb3e4f12b4754003066cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVhYjY3ODUwYmEyZmFmMDdjMWJiM2U0ZjEyYjQ3NTQwMDMwNjZjYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-01-27T14:48:02Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-01-27T14:48:02Z"}, "message": "tracer.c (rest_of_handle_tracer): We already cleaned up the CFG in tracer() so don't do it here again.\n\n\t* tracer.c (rest_of_handle_tracer): We already cleaned\n\tup the CFG in tracer() so don't do it here again.\n\t* cfgcleanup.c (rest_of_handle_jump2): Don't repeat\n\tcleanup_cfg here, either.  And don't call renumber_insns.\n\n\t* cfgrtl.c (rtl_verify_flow_info_1): Don't verify that BB_END\n\tand BB_HEAD are in the insn stream here.  Instead make sure\n\tthat BB_INSN is valid on all insns.  Also, do check here that\n\tthere are no pending branch predictions...\n\t(rtl_verify_flow_info): ...instead of doing it here.  Checks\n\tfor BB_END and BB_HEAD moved from rtl_verify_flow_info_1 to\n\there.\n\nFrom-SVN: r121231", "tree": {"sha": "c09108de229652b098e73519159d1d90297a51d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09108de229652b098e73519159d1d90297a51d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eab67850ba2faf07c1bb3e4f12b4754003066cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eab67850ba2faf07c1bb3e4f12b4754003066cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eab67850ba2faf07c1bb3e4f12b4754003066cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eab67850ba2faf07c1bb3e4f12b4754003066cc/comments", "author": null, "committer": null, "parents": [{"sha": "90e7f69de54c68a7de7966158428bfb4232fc07e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e7f69de54c68a7de7966158428bfb4232fc07e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e7f69de54c68a7de7966158428bfb4232fc07e"}], "stats": {"total": 133, "additions": 76, "deletions": 57}, "files": [{"sha": "99fcc33ed8c469c19c55dae9d82ae1f037a863a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9eab67850ba2faf07c1bb3e4f12b4754003066cc", "patch": "@@ -1,3 +1,18 @@\n+2007-01-27  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tracer.c (rest_of_handle_tracer): We already cleaned\n+\tup the CFG in tracer() so don't do it here again.\n+\t* cfgcleanup.c (rest_of_handle_jump2): Don't repeat\n+\tcleanup_cfg here, either.  And don't call renumber_insns.\n+\n+\t* cfgrtl.c (rtl_verify_flow_info_1): Don't verify that BB_END\n+\tand BB_HEAD are in the insn stream here.  Instead make sure\n+\tthat BB_INSN is valid on all insns.  Also, do check here that\n+\tthere are no pending branch predictions...\n+\t(rtl_verify_flow_info): ...instead of doing it here.  Checks\n+\tfor BB_END and BB_HEAD moved from rtl_verify_flow_info_1 to\n+\there.\n+\n 2007-01-26  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.c (ix86_swap_binary_operands_p): New helper"}, {"sha": "d7c29b7ba53ae6473a62288de894da2bcab1c9e9", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=9eab67850ba2faf07c1bb3e4f12b4754003066cc", "patch": "@@ -2318,16 +2318,6 @@ rest_of_handle_jump2 (void)\n     dump_flow_info (dump_file, dump_flags);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)\n \t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  /* Jump optimization, and the removal of NULL pointer checks, may\n-     have reduced the number of instructions substantially.  CSE, and\n-     future passes, allocate arrays whose dimensions involve the\n-     maximum instruction UID, so if we can reduce the maximum UID\n-     we'll save big on memory.  */\n-  renumber_insns ();\n   return 0;\n }\n "}, {"sha": "4aaedbe472435cdc28a83bc940d32ae97557fe1f", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 61, "deletions": 46, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9eab67850ba2faf07c1bb3e4f12b4754003066cc", "patch": "@@ -1676,79 +1676,51 @@ get_last_bb_insn (basic_block bb)\n \n    Currently it does following checks:\n \n-   - test head/end pointers\n    - overlapping of basic blocks\n+   - insns with wrong BLOCK_FOR_INSN pointers\n    - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n    - tails of basic blocks (ensure that boundary is necessary)\n    - scans body of the basic block for JUMP_INSN, CODE_LABEL\n      and NOTE_INSN_BASIC_BLOCK\n    - verify that no fall_thru edge crosses hot/cold partition boundaries\n+   - verify that there are no pending RTL branch predictions\n \n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n \n static int\n rtl_verify_flow_info_1 (void)\n {\n-  const int max_uid = get_max_uid ();\n-  rtx last_head = get_last_insn ();\n-  basic_block *bb_info;\n   rtx x;\n   int err = 0;\n   basic_block bb;\n \n-  bb_info = XCNEWVEC (basic_block, max_uid);\n-\n+  /* Check the general integrity of the basic blocks.  */\n   FOR_EACH_BB_REVERSE (bb)\n     {\n-      rtx head = BB_HEAD (bb);\n-      rtx end = BB_END (bb);\n-\n-      /* Verify the end of the basic block is in the INSN chain.  */\n-      for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n-\tif (x == end)\n-\t  break;\n+      rtx insn;\n \n       if (!(bb->flags & BB_RTL))\n \t{\n \t  error (\"BB_RTL flag not set for block %d\", bb->index);\n \t  err = 1;\n \t}\n \n-      if (!x)\n-\t{\n-\t  error (\"end insn %d for block %d not found in the insn stream\",\n-\t\t INSN_UID (end), bb->index);\n-\t  err = 1;\n-\t}\n-\n-      /* Work backwards from the end to the head of the basic block\n-\t to verify the head is in the RTL chain.  */\n-      for (; x != NULL_RTX; x = PREV_INSN (x))\n-\t{\n-\t  /* While walking over the insn chain, verify insns appear\n-\t     in only one basic block and initialize the BB_INFO array\n-\t     used by other passes.  */\n-\t  if (bb_info[INSN_UID (x)] != NULL)\n-\t    {\n-\t      error (\"insn %d is in multiple basic blocks (%d and %d)\",\n-\t\t     INSN_UID (x), bb->index, bb_info[INSN_UID (x)]->index);\n-\t      err = 1;\n-\t    }\n-\n-\t  bb_info[INSN_UID (x)] = bb;\n+      FOR_BB_INSNS (bb, insn)\n+\tif (BLOCK_FOR_INSN (insn) != bb)\n+\t  {\n+\t    error (\"insn %d basic block pointer is %d, should be %d\",\n+\t\t   INSN_UID (insn),\n+\t\t   BLOCK_FOR_INSN (insn) ? BLOCK_FOR_INSN (insn)->index : 0,\n+\t\t   bb->index);\n+\t    err = 1;\n+\t  }\n \n-\t  if (x == head)\n-\t    break;\n-\t}\n-      if (!x)\n+      if (bb->predictions)\n \t{\n-\t  error (\"head insn %d for block %d not found in the insn stream\",\n-\t\t INSN_UID (head), bb->index);\n+\t  error (\"bb prediction set for block %d, but it is not used in RTL land\", bb->index);\n \t  err = 1;\n \t}\n-\n-      last_head = x;\n     }\n \n   /* Now check the basic blocks (boundaries etc.) */\n@@ -1916,7 +1888,6 @@ rtl_verify_flow_info_1 (void)\n     }\n \n   /* Clean up.  */\n-  free (bb_info);\n   return err;\n }\n \n@@ -1925,31 +1896,73 @@ rtl_verify_flow_info_1 (void)\n \n    Currently it does following checks:\n    - all checks of rtl_verify_flow_info_1\n+   - test head/end pointers\n    - check that all insns are in the basic blocks\n      (except the switch handling code, barriers and notes)\n    - check that all returns are followed by barriers\n    - check that all fallthru edge points to the adjacent blocks.  */\n+\n static int\n rtl_verify_flow_info (void)\n {\n   basic_block bb;\n   int err = rtl_verify_flow_info_1 ();\n   rtx x;\n+  rtx last_head = get_last_insn ();\n+  basic_block *bb_info;\n   int num_bb_notes;\n   const rtx rtx_first = get_insns ();\n   basic_block last_bb_seen = ENTRY_BLOCK_PTR, curr_bb = NULL;\n+  const int max_uid = get_max_uid ();\n+\n+  bb_info = XCNEWVEC (basic_block, max_uid);\n \n   FOR_EACH_BB_REVERSE (bb)\n     {\n       edge e;\n       edge_iterator ei;\n+      rtx head = BB_HEAD (bb);\n+      rtx end = BB_END (bb);\n \n-      if (bb->predictions)\n+      /* Verify the end of the basic block is in the INSN chain.  */\n+      for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n+\tif (x == end)\n+\t  break;\n+\n+      if (!x)\n+\t{\n+\t  error (\"end insn %d for block %d not found in the insn stream\",\n+\t\t INSN_UID (end), bb->index);\n+\t  err = 1;\n+\t}\n+\n+      /* Work backwards from the end to the head of the basic block\n+\t to verify the head is in the RTL chain.  */\n+      for (; x != NULL_RTX; x = PREV_INSN (x))\n \t{\n-\t  error (\"bb prediction set for block %i, but it is not used in RTL land\", bb->index);\n+\t  /* While walking over the insn chain, verify insns appear\n+\t     in only one basic block.  */\n+\t  if (bb_info[INSN_UID (x)] != NULL)\n+\t    {\n+\t      error (\"insn %d is in multiple basic blocks (%d and %d)\",\n+\t\t     INSN_UID (x), bb->index, bb_info[INSN_UID (x)]->index);\n+\t      err = 1;\n+\t    }\n+\n+\t  bb_info[INSN_UID (x)] = bb;\n+\n+\t  if (x == head)\n+\t    break;\n+\t}\n+      if (!x)\n+\t{\n+\t  error (\"head insn %d for block %d not found in the insn stream\",\n+\t\t INSN_UID (head), bb->index);\n \t  err = 1;\n \t}\n \n+      last_head = x;\n+\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n@@ -1994,6 +2007,8 @@ rtl_verify_flow_info (void)\n \t}\n     }\n \n+  free (bb_info);\n+\n   num_bb_notes = 0;\n   last_bb_seen = ENTRY_BLOCK_PTR;\n "}, {"sha": "4c8d06374d9f34215079f4016fa4df8e4c79c879", "filename": "gcc/tracer.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eab67850ba2faf07c1bb3e4f12b4754003066cc/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=9eab67850ba2faf07c1bb3e4f12b4754003066cc", "patch": "@@ -393,7 +393,6 @@ rest_of_handle_tracer (void)\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n   tracer (0);\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n   reg_scan (get_insns (), max_reg_num ());\n   return 0;\n }"}]}