{"sha": "a469a4f2410b8e85bb7cdd6ea9ea07320491ceee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ2OWE0ZjI0MTBiOGU4NWJiN2NkZDZlYTllYTA3MzIwNDkxY2VlZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-06-26T10:32:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-06-26T10:32:26Z"}, "message": "ggc-page.c (init_ggc): Add missing element to size_lookup table.\n\n2006-06-26  Richard Guenther  <rguenther@suse.de>\n\n        * ggc-page.c (init_ggc): Add missing element to size_lookup\n        table.\n\n        Revert\n        2006-06-23  Richard Guenther  <rguenther@suse.de>\n\n        * ggc-page.c (init_ggc): Do not round up the extra_order_size_table\n        sizes to MAX_ALIGNMENT.  Fix the size_lookup table to honour\n        alignment requests instead.  Add verification code.\n        Add struct tree_function_decl and struct tree_binfo size to\n        extra_order_size_table.  Add missing element to size_lookup\n        table.\n\nFrom-SVN: r115007", "tree": {"sha": "eec0b22f697a163169cadc5e54ada18542cd8723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec0b22f697a163169cadc5e54ada18542cd8723"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bfe3e83159fa545f90a81e81321a77ca9f6fd6c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe3e83159fa545f90a81e81321a77ca9f6fd6c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe3e83159fa545f90a81e81321a77ca9f6fd6c0"}], "stats": {"total": 75, "additions": 26, "deletions": 49}, "files": [{"sha": "ea09b8d830389a72331d301bc0a2b8e1d51aa9b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a469a4f2410b8e85bb7cdd6ea9ea07320491ceee", "patch": "@@ -1,3 +1,18 @@\n+2006-06-26  Richard Guenther  <rguenther@suse.de>\n+\n+\t* ggc-page.c (init_ggc): Add missing element to size_lookup\n+\ttable.\n+\n+\tRevert\n+\t2006-06-23  Richard Guenther  <rguenther@suse.de>\n+\n+\t* ggc-page.c (init_ggc): Do not round up the extra_order_size_table\n+\tsizes to MAX_ALIGNMENT.  Fix the size_lookup table to honour\n+\talignment requests instead.  Add verification code.\n+\tAdd struct tree_function_decl and struct tree_binfo size to\n+\textra_order_size_table.  Add missing element to size_lookup\n+\ttable.\n+\n 2006-06-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/28151"}, {"sha": "751a0d184a67b1104c1fb2ceee7c1e1a6451ba3f", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 11, "deletions": 49, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a469a4f2410b8e85bb7cdd6ea9ea07320491ceee/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=a469a4f2410b8e85bb7cdd6ea9ea07320491ceee", "patch": "@@ -193,8 +193,6 @@ static const size_t extra_order_size_table[] = {\n   sizeof (struct tree_var_decl),\n   sizeof (struct tree_list),\n   sizeof (struct tree_ssa_name),\n-  sizeof (struct tree_function_decl),\n-  sizeof (struct tree_binfo),\n   sizeof (struct function),\n   sizeof (struct basic_block_def),\n   sizeof (bitmap_element),\n@@ -1511,6 +1509,10 @@ init_ggc (void)\n   for (order = HOST_BITS_PER_PTR; order < NUM_ORDERS; ++order)\n     {\n       size_t s = extra_order_size_table[order - HOST_BITS_PER_PTR];\n+\n+      /* If S is not a multiple of the MAX_ALIGNMENT, then round it up\n+\t so that we're sure of getting aligned memory.  */\n+      s = ROUND_UP (s, MAX_ALIGNMENT);\n       object_size_table[order] = s;\n     }\n \n@@ -1526,56 +1528,16 @@ init_ggc (void)\n   /* Reset the size_lookup array to put appropriately sized objects in\n      the special orders.  All objects bigger than the previous power\n      of two, but no greater than the special size, should go in the\n-     new order.\n-     Enforce alignment during lookup.  The resulting bin size must\n-     have the same or bigger alignment than the apparent alignment\n-     requirement from the size request (but not bigger alignment\n-     than MAX_ALIGNMENT).  Consider an extra bin of size 76 (in\n-     addition to the 64 and 128 byte sized bins).  A request of\n-     allocation size of 72 bytes must be served from the 128 bytes\n-     bin, because 72 bytes looks like a request for 8 byte aligned\n-     memory, while the 76 byte bin can only serve chunks with a\n-     guaranteed alignment of 4 bytes.  */\n+     new order.  */\n   for (order = HOST_BITS_PER_PTR; order < NUM_ORDERS; ++order)\n     {\n-      int i, mask;\n-\n-      /* Build an alignment mask that can be used for testing\n-         size % 2*align.  If (size | MAX_ALIGNMENT) & mask is non-zero\n-\t then the requested size apparent alignment requirement \n-\t (which is at most MAX_ALIGNMENT) is less or equal than what\n-\t the OBJECT_SIZE bin can guarantee.  */\n-      mask = ~(((unsigned)-1) << ffs (OBJECT_SIZE (order)));\n-      mask &= 2 * MAX_ALIGNMENT - 1;\n-\n-      /* All objects smaller than the OBJECT_SIZE for this ORDER could go\n-\t into ORDER.  Determine the cases for which that is profitable\n-\t and fulfilling the alignment requirements.  Stop searching\n-\t once a smaller bin with same or better alignment guarantee is\n-\t found.  */\n-      for (i = OBJECT_SIZE (order); ; --i)\n-\t{\n-\t  unsigned int old_sz = OBJECT_SIZE (size_lookup [i]);\n-\t  if (!(old_sz & (mask >> 1))\n-\t      && old_sz < OBJECT_SIZE (order))\n-\t    break;\n-\n-\t  /* If object of size I are presently using a larger bin, we would\n-\t     like to move them to ORDER.  However, we can only do that if we\n-\t     can be sure they will be properly aligned.  They will be properly\n-\t     aligned if either the ORDER bin is maximally aligned, or if\n-\t     objects of size I cannot be more strictly aligned than the\n-\t     alignment of this order.  */\n-\t  if ((i | MAX_ALIGNMENT) & mask\n-\t      && old_sz > OBJECT_SIZE (order))\n-\t    size_lookup[i] = order;\n-\t}\n-    }\n+      int o;\n+      int i;\n \n-  /* Verify we got everything right with respect to alignment requests.  */\n-  for (order = 1; order < 512; ++order)\n-    gcc_assert (ffs (OBJECT_SIZE (size_lookup [order]))\n-\t\t>= ffs (order | MAX_ALIGNMENT));\n+      o = size_lookup[OBJECT_SIZE (order)];\n+      for (i = OBJECT_SIZE (order); size_lookup [i] == o; --i)\n+\tsize_lookup[i] = order;\n+    }\n \n   G.depth_in_use = 0;\n   G.depth_max = 10;"}]}