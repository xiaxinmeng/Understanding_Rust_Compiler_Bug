{"sha": "8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYxYjg4ZjgyYjljYmZkMTM0NTQ0ZmQyMjMwYTZmM2U1YzgyYWNjZQ==", "commit": {"author": {"name": "Raphael Amiard", "email": "amiard@adacore.com", "date": "2018-05-24T13:05:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-24T13:05:38Z"}, "message": "[Ada] Add documentation from the Ada RM to Ada.Containers.Vector\n\n2018-05-24  Raphael Amiard  <amiard@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-convec.ads: Add documentation.\n\nFrom-SVN: r260655", "tree": {"sha": "263d507f01dd01c7441c8c88c33a865454e169d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/263d507f01dd01c7441c8c88c33a865454e169d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce/comments", "author": {"login": "raph-amiard", "id": 478727, "node_id": "MDQ6VXNlcjQ3ODcyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/478727?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raph-amiard", "html_url": "https://github.com/raph-amiard", "followers_url": "https://api.github.com/users/raph-amiard/followers", "following_url": "https://api.github.com/users/raph-amiard/following{/other_user}", "gists_url": "https://api.github.com/users/raph-amiard/gists{/gist_id}", "starred_url": "https://api.github.com/users/raph-amiard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raph-amiard/subscriptions", "organizations_url": "https://api.github.com/users/raph-amiard/orgs", "repos_url": "https://api.github.com/users/raph-amiard/repos", "events_url": "https://api.github.com/users/raph-amiard/events{/privacy}", "received_events_url": "https://api.github.com/users/raph-amiard/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c06a59be1990743d1520b89016a532572a9256ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c06a59be1990743d1520b89016a532572a9256ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c06a59be1990743d1520b89016a532572a9256ab"}], "stats": {"total": 310, "additions": 310, "deletions": 0}, "files": [{"sha": "31365684547425fa43d5baaaa21c4dcccc134f7e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "patch": "@@ -1,3 +1,7 @@\n+2018-05-24  Raphael Amiard  <amiard@adacore.com>\n+\n+\t* libgnat/a-convec.ads: Add documentation.\n+\n 2018-05-24  Justin Squirek  <squirek@adacore.com>\n \n \t* exp_ch3.adb (Expand_N_Object_Declaration): Ignore raising an error in"}, {"sha": "803fcfc439f6f4b85652e82bc905c4ef1d14d0a3", "filename": "gcc/ada/libgnat/a-convec.ads", "status": "modified", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce/gcc%2Fada%2Flibgnat%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1b88f82b9cbfd134544fd2230a6f3e5c82acce/gcc%2Fada%2Flibgnat%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-convec.ads?ref=8f1b88f82b9cbfd134544fd2230a6f3e5c82acce", "patch": "@@ -37,11 +37,38 @@ with Ada.Containers.Helpers;\n private with Ada.Finalization;\n private with Ada.Streams;\n \n+--  The language-defined generic package Containers.Vectors provides private\n+--  types Vector and Cursor, and a set of operations for each type. A vector\n+--  container allows insertion and deletion at any position, but it is\n+--  specifically optimized for insertion and deletion at the high end (the end\n+--  with the higher index) of the container. A vector container also provides\n+--  random access to its elements.\n+--\n+--  A vector container behaves conceptually as an array that expands as\n+--  necessary as items are inserted. The length of a vector is the number of\n+--  elements that the vector contains. The capacity of a vector is the maximum\n+--  number of elements that can be inserted into the vector prior to it being\n+--  automatically expanded.\n+--\n+--  Elements in a vector container can be referred to by an index value of a\n+--  generic formal type. The first element of a vector always has its index\n+--  value equal to the lower bound of the formal type.\n+--\n+--  A vector container may contain empty elements. Empty elements do not have a\n+--  specified value.\n+\n generic\n    type Index_Type is range <>;\n    type Element_Type is private;\n \n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+   --  The actual function for the generic formal function \"=\" on Element_Type\n+   --  values is expected to define a reflexive and symmetric relationship and\n+   --  return the same result value each time it is called with a particular\n+   --  pair of values. If it behaves in some other manner, the functions\n+   --  defined to use it return an unspecified value. The exact arguments and\n+   --  number of calls of this generic formal function by the functions defined\n+   --  to use it are unspecified.\n \n package Ada.Containers.Vectors is\n    pragma Annotate (CodePeer, Skip_Analysis);\n@@ -51,8 +78,12 @@ package Ada.Containers.Vectors is\n    subtype Extended_Index is Index_Type'Base\n      range Index_Type'First - 1 ..\n            Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n+   --  The subtype Extended_Index includes the indices covered by Index_Type\n+   --  plus the value No_Index and, if it exists, the successor to the\n+   --  Index_Type'Last.\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n+   --  No_Index represents a position that does not correspond to any element.\n \n    type Vector is tagged private\n    with\n@@ -61,91 +92,193 @@ package Ada.Containers.Vectors is\n       Default_Iterator  => Iterate,\n       Iterator_Element  => Element_Type;\n    pragma Preelaborable_Initialization (Vector);\n+   --  Vector type, to be instantiated by users of this package. If an object\n+   --  of type Vector is not otherwise initialized, it is initialized to\n+   --  Empty_Vector.\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n+   --  Cursor pointing into an instance of vector. If an object of type Cursor\n+   --  is not otherwise initialized, it is initialized to No_Element\n \n    No_Element : constant Cursor;\n+   --  No_Element represents a cursor that designates no element.\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Returns True if Position designates an element, and returns False\n+   --  otherwise.\n \n    package Vector_Iterator_Interfaces is new\n       Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    Empty_Vector : constant Vector;\n+   --  Empty_Vector represents the empty vector object. It has a length of 0.\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean;\n+   --  If Left and Right denote the same vector object, then the function\n+   --  returns True. If Left and Right have different lengths, then the\n+   --  function returns False. Otherwise, it compares each element in Left to\n+   --  the corresponding element in Right using the generic formal equality\n+   --  operator. If any such comparison returns False, the function returns\n+   --  False; otherwise it returns True. Any exception raised during evaluation\n+   --  of element equality is propagated.\n \n    function To_Vector (Length : Count_Type) return Vector;\n+   --  Returns a vector with a length of Length, filled with empty elements.\n \n    function To_Vector\n      (New_Item : Element_Type;\n       Length   : Count_Type) return Vector;\n+   --  Returns a vector with a length of Length, filled with elements\n+   --  initialized to the value New_Item.\n \n    function \"&\" (Left, Right : Vector) return Vector;\n+   --  Returns a vector comprising the elements of Left followed by the\n+   --  elements of Right.\n \n    function \"&\" (Left : Vector; Right : Element_Type) return Vector;\n+   --  Returns a vector comprising the elements of Left followed by the element\n+   --  Right.\n \n    function \"&\" (Left : Element_Type; Right : Vector) return Vector;\n+   --  Returns a vector comprising the element Left followed by the elements of\n+   --  Right.\n \n    function \"&\" (Left, Right : Element_Type) return Vector;\n+   --  Returns a vector comprising the element Left followed by the element\n+   --  Right.\n \n    function Capacity (Container : Vector) return Count_Type;\n+   --  Returns the capacity of Container.\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n       Capacity  : Count_Type);\n+   --  Reserve_Capacity allocates new internal data structures such that the\n+   --  length of the resulting vector can become at least the value Capacity\n+   --  without requiring an additional call to Reserve_Capacity, and is large\n+   --  enough to hold the current length of Container. Reserve_Capacity then\n+   --  copies the elements into the new data structures and deallocates the old\n+   --  data structures. Any exception raised during allocation is propagated\n+   --  and Container is not modified.\n \n    function Length (Container : Vector) return Count_Type;\n+   --  Returns the number of elements in Container.\n \n    procedure Set_Length\n      (Container : in out Vector;\n       Length    : Count_Type);\n+   --  If Length is larger than the capacity of Container, Set_Length calls\n+   --  Reserve_Capacity (Container, Length), then sets the length of the\n+   --  Container to Length. If Length is greater than the original length of\n+   --  Container, empty elements are added to Container; otherwise elements are\n+   --  removed from Container.\n \n    function Is_Empty (Container : Vector) return Boolean;\n+   --  Equivalent to Length (Container) = 0.\n \n    procedure Clear (Container : in out Vector);\n+   --  Removes all the elements from Container. The capacity of Container does\n+   --  not change.\n \n    function To_Cursor\n      (Container : Vector;\n       Index     : Extended_Index) return Cursor;\n+   --  If Index is not in the range First_Index (Container) .. Last_Index\n+   --  (Container), then No_Element is returned. Otherwise, a cursor\n+   --  designating the element at position Index in Container is returned.\n \n    function To_Index (Position : Cursor) return Extended_Index;\n+   --  If Position is No_Element, No_Index is returned. Otherwise, the index\n+   --  (within its containing vector) of the element designated by Position is\n+   --  returned.\n \n    function Element\n      (Container : Vector;\n       Index     : Index_Type) return Element_Type;\n+   --  If Index is not in the range First_Index (Container) .. Last_Index\n+   --  (Container), then Constraint_Error is propagated. Otherwise, Element\n+   --  returns the element at position Index.\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  If Position equals No_Element, then Constraint_Error is propagated.\n+   --  Otherwise, Element returns the element designated by Position.\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Index     : Index_Type;\n       New_Item  : Element_Type);\n+   --  If Index is not in the range First_Index (Container) .. Last_Index\n+   --  (Container), then Constraint_Error is propagated. Otherwise\n+   --  Replace_Element assigns the value New_Item to the element at position\n+   --  Index. Any exception raised during the assignment is propagated. The\n+   --  element at position Index is not an empty element after successful call\n+   --  to Replace_Element.\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  If Position equals No_Element, then Constraint_Error is propagated; if\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated. Otherwise Replace_Element assigns New_Item to the element\n+   --  designated by Position. Any exception raised during the assignment is\n+   --  propagated. The element at Position is not an empty element after\n+   --  successful call to Replace_Element.\n \n    procedure Query_Element\n      (Container : Vector;\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : Element_Type));\n+   --  If Index is not in the range First_Index (Container) .. Last_Index\n+   --  (Container), then Constraint_Error is propagated. Otherwise,\n+   --  Query_Element calls Process.all with the element at position Index as\n+   --  the argument. Program_Error is propagated if Process.all tampers with\n+   --  the elements of Container. Any exception raised by Process.all is\n+   --  propagated.\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n+   --  If Position equals No_Element, then Constraint_Error is propagated.\n+   --  Otherwise, Query_Element calls Process.all with the element designated\n+   --  by Position as the argument. Program_Error is propagated if Process.all\n+   --  tampers with the elements of Container. Any exception raised by\n+   --  Process.all is propagated.\n \n    procedure Update_Element\n      (Container : in out Vector;\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type));\n+   --  If Index is not in the range First_Index (Container) .. Last_Index\n+   --  (Container), then Constraint_Error is propagated. Otherwise,\n+   --  Update_Element calls Process.all with the element at position Index as\n+   --  the argument. Program_Error is propagated if Process.all tampers with\n+   --  the elements of Container. Any exception raised by Process.all is\n+   --  propagated.\n+   --\n+   --  If Element_Type is unconstrained and definite, then the actual Element\n+   --  parameter of Process.all shall be unconstrained.\n+   --\n+   --  The element at position Index is not an empty element after successful\n+   --  completion of this operation.\n \n    procedure Update_Element\n      (Container : in out Vector;\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n+   --  If Position equals No_Element, then Constraint_Error is propagated; if\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated. Otherwise Update_Element calls Process.all with the\n+   --  element designated by Position as the argument. Program_Error is\n+   --  propagated if Process.all tampers with the elements of Container. Any\n+   --  exception raised by Process.all is propagated.\n+   --\n+   --  If Element_Type is unconstrained and definite, then the actual Element\n+   --  parameter of Process.all shall be unconstrained.\n+   --\n+   --  The element designated by Position is not an empty element after\n+   --  successful completion of this operation.\n \n    type Constant_Reference_Type\n       (Element : not null access constant Element_Type) is\n@@ -182,157 +315,308 @@ package Ada.Containers.Vectors is\n    function Copy (Source : Vector; Capacity : Count_Type := 0) return Vector;\n \n    procedure Move (Target : in out Vector; Source : in out Vector);\n+   --  If Target denotes the same object as Source, then Move has no effect.\n+   --  Otherwise, Move first calls Clear (Target); then, each element from\n+   --  Source is removed from Source and inserted into Target in the original\n+   --  order. The length of Source is 0 after a successful call to Move.\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n       New_Item  : Vector);\n+   --  If Before is not in the range First_Index (Container) .. Last_Index\n+   --  (Container) + 1, then Constraint_Error is propagated. If\n+   --  Length(New_Item) is 0, then Insert does nothing. Otherwise, it computes\n+   --  the new length NL as the sum of the current length and Length\n+   --  (New_Item); if the value of Last appropriate for length NL would be\n+   --  greater than Index_Type'Last then Constraint_Error is propagated.\n+   --\n+   --  If the current vector capacity is less than NL, Reserve_Capacity\n+   --  (Container, NL) is called to increase the vector capacity. Then Insert\n+   --  slides the elements in the range Before .. Last_Index (Container) up by\n+   --  Length(New_Item) positions, and then copies the elements of New_Item to\n+   --  the positions starting at Before. Any exception raised during the\n+   --  copying is propagated.\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Vector);\n+   --  If Before is not No_Element, and does not designate an element in\n+   --  Container, then Program_Error is propagated. Otherwise, if\n+   --  Length(New_Item) is 0, then Insert does nothing. If Before is\n+   --  No_Element, then the call is equivalent to Insert (Container, Last_Index\n+   --  (Container) + 1, New_Item); otherwise the call is equivalent to Insert\n+   --  (Container, To_Index (Before), New_Item);\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Vector;\n       Position  : out Cursor);\n+   --  If Before is not No_Element, and does not designate an element in\n+   --  Container, then Program_Error is propagated. If Before equals\n+   --  No_Element, then let T be Last_Index (Container) + 1; otherwise, let T\n+   --  be To_Index (Before). Insert (Container, T, New_Item) is called, and\n+   --  then Position is set to To_Cursor (Container, T).\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n+   --  Equivalent to Insert (Container, Before, To_Vector (New_Item, Count));\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n+   --  Equivalent to Insert (Container, Before, To_Vector (New_Item, Count));\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n+   --  Equivalent to\n+   --  Insert (Container, Before, To_Vector (New_Item, Count), Position);\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n       Count     : Count_Type := 1);\n+   --  If Before is not in the range First_Index (Container) .. Last_Index\n+   --  (Container) + 1, then Constraint_Error is propagated. If Count is 0,\n+   --  then Insert does nothing. Otherwise, it computes the new length NL as\n+   --  the sum of the current length and Count; if the value of Last\n+   --  appropriate for length NL would be greater than Index_Type'Last then\n+   --  Constraint_Error is propagated.\n+   --\n+   --  If the current vector capacity is less than NL, Reserve_Capacity\n+   --  (Container, NL) is called to increase the vector capacity. Then Insert\n+   --  slides the elements in the range Before .. Last_Index (Container) up by\n+   --  Count positions, and then inserts elements that are initialized by\n+   --  default (see 3.3.1) in the positions starting at Before.\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n+   --  If Before is not No_Element, and does not designate an element in\n+   --  Container, then Program_Error is propagated. If Before equals\n+   --  No_Element, then let T be Last_Index (Container) + 1; otherwise, let T\n+   --  be To_Index (Before). Insert (Container, T, Count) is called, and then\n+   --  Position is set to To_Cursor (Container, T).\n \n    procedure Prepend\n      (Container : in out Vector;\n       New_Item  : Vector);\n+   --  Equivalent to Insert (Container, First_Index (Container), New_Item).\n \n    procedure Prepend\n      (Container : in out Vector;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n+   --  Equivalent to Insert (Container, First_Index (Container), New_Item,\n+   --  Count).\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Vector);\n+   --  Equivalent to Insert (Container, Last_Index (Container) + 1, New_Item).\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n+   --  Equivalent to Insert (Container, Last_Index (Container) + 1, New_Item,\n+   --  Count).\n \n    procedure Insert_Space\n      (Container : in out Vector;\n       Before    : Extended_Index;\n       Count     : Count_Type := 1);\n+   --  If Before is not in the range First_Index (Container) .. Last_Index\n+   --  (Container) + 1, then Constraint_Error is propagated. If Count is 0,\n+   --  then Insert_Space does nothing. Otherwise, it computes the new length NL\n+   --  as the sum of the current length and Count; if the value of Last\n+   --  appropriate for length NL would be greater than Index_Type'Last then\n+   --  Constraint_Error is propagated.\n+   --\n+   --  If the current vector capacity is less than NL, Reserve_Capacity\n+   --  (Container, NL) is called to increase the vector capacity. Then\n+   --  Insert_Space slides the elements in the range Before .. Last_Index\n+   --  (Container) up by Count positions, and then inserts empty elements in\n+   --  the positions starting at Before.\n \n    procedure Insert_Space\n      (Container : in out Vector;\n       Before    : Cursor;\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n+   --  If Before is not No_Element, and does not designate an element in\n+   --  Container, then Program_Error is propagated. If Before equals\n+   --  No_Element, then let T be Last_Index (Container) + 1; otherwise, let T\n+   --  be To_Index (Before). Insert_Space (Container, T, Count) is called, and\n+   --  then Position is set to To_Cursor (Container, T).\n \n    procedure Delete\n      (Container : in out Vector;\n       Index     : Extended_Index;\n       Count     : Count_Type := 1);\n+   --  If Index is not in the range First_Index (Container) .. Last_Index\n+   --  (Container) + 1, then Constraint_Error is propagated. If Count is 0,\n+   --  Delete has no effect. Otherwise Delete slides the elements (if any)\n+   --  starting at position Index + Count down to Index. Any exception raised\n+   --  during element assignment is propagated.\n \n    procedure Delete\n      (Container : in out Vector;\n       Position  : in out Cursor;\n       Count     : Count_Type := 1);\n+   --  If Position equals No_Element, then Constraint_Error is propagated. If\n+   --  Position does not designate an element in Container, then Program_Error\n+   --  is propagated. Otherwise, Delete (Container, To_Index (Position), Count)\n+   --  is called, and then Position is set to No_Element.\n \n    procedure Delete_First\n      (Container : in out Vector;\n       Count     : Count_Type := 1);\n+   --  Equivalent to Delete (Container, First_Index (Container), Count).\n \n    procedure Delete_Last\n      (Container : in out Vector;\n       Count     : Count_Type := 1);\n+   --  If Length (Container) <= Count then Delete_Last is equivalent to Clear\n+   --  (Container). Otherwise it is equivalent to Delete (Container,\n+   --  Index_Type'Val(Index_Type'Pos(Last_Index (Container)) - Count + 1),\n+   --  Count).\n \n    procedure Reverse_Elements (Container : in out Vector);\n+   --  Reorders the elements of Container in reverse order.\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type);\n+   --  If either I or J is not in the range First_Index (Container) ..\n+   --  Last_Index (Container), then Constraint_Error is propagated. Otherwise,\n+   --  Swap exchanges the values of the elements at positions I and J.\n \n    procedure Swap (Container : in out Vector; I, J : Cursor);\n+   --  If either I or J is No_Element, then Constraint_Error is propagated. If\n+   --  either I or J do not designate an element in Container, then\n+   --  Program_Error is propagated. Otherwise, Swap exchanges the values of the\n+   --  elements designated by I and J.\n \n    function First_Index (Container : Vector) return Index_Type;\n+   --  Returns the value Index_Type'First.\n \n    function First (Container : Vector) return Cursor;\n+   --  If Container is empty, First returns No_Element. Otherwise, it returns a\n+   --  cursor that designates the first element in Container.\n \n    function First_Element (Container : Vector) return Element_Type;\n+   --  Equivalent to Element (Container, First_Index (Container)).\n \n    function Last_Index (Container : Vector) return Extended_Index;\n+   --  If Container is empty, Last_Index returns No_Index. Otherwise, it\n+   --  returns the position of the last element in Container.\n \n    function Last (Container : Vector) return Cursor;\n+   --  If Container is empty, Last returns No_Element. Otherwise, it returns a\n+   --  cursor that designates the last element in Container.\n \n    function Last_Element (Container : Vector) return Element_Type;\n+   --  Equivalent to Element (Container, Last_Index (Container)).\n \n    function Next (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or designates the last element of the\n+   --  container, then Next returns the value No_Element. Otherwise, it returns\n+   --  a cursor that designates the element with index To_Index (Position) + 1\n+   --  in the same vector as Position.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position).\n \n    function Previous (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or designates the first element of the\n+   --  container, then Previous returns the value No_Element. Otherwise, it\n+   --  returns a cursor that designates the element with index To_Index\n+   --  (Position) - 1 in the same vector as Position.\n \n    procedure Previous (Position : in out Cursor);\n+   --  Equivalent to Position := Previous (Position).\n \n    function Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index;\n+   --  Searches the elements of Container for an element equal to Item (using\n+   --  the generic formal equality operator). The search starts at position\n+   --  Index and proceeds towards Last_Index (Container). If no equal\n+   --  element is found, then Find_Index returns No_Index. Otherwise, it\n+   --  returns the index of the first equal element encountered.\n \n    function Find\n      (Container : Vector;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor;\n+   --  If Position is not No_Element, and does not designate an element in\n+   --  Container, then Program_Error is propagated. Otherwise Find searches\n+   --  the elements of Container for an element equal to Item (using the\n+   --  generic formal equality operator). The search starts at the first\n+   --  element if Position equals No_Element, and at the element designated\n+   --  by Position otherwise. It proceeds towards the last element of\n+   --  Container. If no equal element is found, then Find returns\n+   --  No_Element. Otherwise, it returns a cursor designating the first\n+   --  equal element encountered.\n \n    function Reverse_Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index;\n+   --  Searches the elements of Container for an element equal to Item (using\n+   --  the generic formal equality operator). The search starts at position\n+   --  Index or, if Index is greater than Last_Index (Container), at\n+   --  position Last_Index (Container). It proceeds towards First_Index\n+   --  (Container). If no equal element is found, then Reverse_Find_Index\n+   --  returns No_Index. Otherwise, it returns the index of the first equal\n+   --  element encountered.\n \n    function Reverse_Find\n      (Container : Vector;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor;\n+   --  If Position is not No_Element, and does not designate an element in\n+   --  Container, then Program_Error is propagated. Otherwise Reverse_Find\n+   --  searches the elements of Container for an element equal to Item\n+   --  (using the generic formal equality operator). The search starts at\n+   --  the last element if Position equals No_Element, and at the element\n+   --  designated by Position otherwise. It proceeds towards the first\n+   --  element of Container. If no equal element is found, then Reverse_Find\n+   --  returns No_Element. Otherwise, it returns a cursor designating the\n+   --  first equal element encountered.\n \n    function Contains\n      (Container : Vector;\n       Item      : Element_Type) return Boolean;\n+   --  Equivalent to Has_Element (Find (Container, Item)).\n \n    procedure Iterate\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Invokes Process.all with a cursor that designates each element in\n+   --  Container, in index order. Program_Error is propagated if Process.all\n+   --  tampers with the cursors of Container. Any exception raised by Process\n+   --  is propagated.\n \n    procedure Reverse_Iterate\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Iterates over the elements in Container as per Iterate, except that\n+   --  elements are traversed in reverse index order.\n+   --\n \n    function Iterate (Container : Vector)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class;\n@@ -342,13 +626,35 @@ package Ada.Containers.Vectors is\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+      --  The actual function for the generic formal function \"<\" of\n+      --  Generic_Sorting is expected to return the same value each time it is\n+      --  called with a particular pair of element values. It should define a\n+      --  strict ordering relationship, that is, be irreflexive, asymmetric,\n+      --  and transitive; it should not modify Container. If the actual for \"<\"\n+      --  behaves in some other manner, the behavior of the subprograms of\n+      --  Generic_Sorting are unspecified. How many times the subprograms of\n+      --  Generic_Sorting call \"<\" is unspecified.\n    package Generic_Sorting is\n \n       function Is_Sorted (Container : Vector) return Boolean;\n+      --  Returns True if the elements are sorted smallest first as determined\n+      --  by the generic formal \"<\" operator; otherwise, Is_Sorted returns\n+      --  False. Any exception raised during evaluation of \"<\" is propagated.\n \n       procedure Sort (Container : in out Vector);\n+      --  Reorders the elements of Container such that the elements are sorted\n+      --  smallest first as determined by the generic formal \"<\" operator\n+      --  provided. Any exception raised during evaluation of \"<\" is\n+      --  propagated.\n \n       procedure Merge (Target : in out Vector; Source : in out Vector);\n+      --  Merge removes elements from Source and inserts them into Target;\n+      --  afterwards, Target contains the union of the elements that were\n+      --  initially in Source and Target; Source is left empty. If Target and\n+      --  Source are initially sorted smallest first, then Target is ordered\n+      --  smallest first as determined by the generic formal \"<\" operator;\n+      --  otherwise, the order of elements in Target is unspecified. Any\n+      --  exception raised during evaluation of \"<\" is propagated.\n \n    end Generic_Sorting;\n "}]}