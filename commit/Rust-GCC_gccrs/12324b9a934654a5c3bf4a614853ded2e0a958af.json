{"sha": "12324b9a934654a5c3bf4a614853ded2e0a958af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIzMjRiOWE5MzQ2NTRhNWMzYmY0YTYxNDg1M2RlZDJlMGE5NThhZg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-20T18:15:43Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-07-29T09:26:42Z"}, "message": "libstdc++: Fix unordered containers move constructors noexcept qualification\n\n_Hashtable move constructor is wrongly qualified as noexcept(true) regardless of\n_Equal and _H1 copy constructor qualifications.\n_Hashtable allocator-aware move constructor is missing its noexcept\nqualification like the depending unordered containers ones.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/hashtable.h\n\t(_Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a, true_type)):\n\tAdd noexcept qualification.\n\t(_Hashtable(_Hashtable&&)): Fix noexcept qualification.\n\t(_Hashtable(_Hashtable&&, const allocator_type&)): Add noexcept\n\tqualification.\n\t* include/bits/unordered_map.h\n\t(unordered_map(unordered_map&&, const allocator_type&)): Add noexcept\n\tqualification.\n\t(unordered_multimap(unordered_multimap&&, const allocator_type&)):\n\tLikewise.\n\t* include/bits/unordered_set.h\n\t(unordered_set(unordered_set&&, const allocator_type&)): Likewise.\n\t(unordered_multiset(unordered_multiset&&, const allocator_type&)):\n\tLikewise.\n\t* include/debug/unordered_map\n\t(unordered_map(unordered_map&&, const allocator_type&)): Likewise.\n\t(unordered_multimap(unordered_multimap&&, const allocator_type&)):\n\tLikewise.\n\t* include/debug/unordered_set\n\t(unordered_set(unordered_set&&, const allocator_type&)): Likewise.\n\t(unordered_multiset(unordered_multiset&&, const allocator_type&)):\n\tLikewise.\n\t* testsuite/23_containers/unordered_map/allocator/default_init.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_map/modifiers/move_assign.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_set/allocator/default_init.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc:\n\tNew test.\n\t* testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc:\n\tNew test.", "tree": {"sha": "a66b4107aabc48b6e6275686505f7af2c3187b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a66b4107aabc48b6e6275686505f7af2c3187b54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12324b9a934654a5c3bf4a614853ded2e0a958af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12324b9a934654a5c3bf4a614853ded2e0a958af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12324b9a934654a5c3bf4a614853ded2e0a958af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12324b9a934654a5c3bf4a614853ded2e0a958af/comments", "author": null, "committer": null, "parents": [{"sha": "f1660ceb0d3b0076555058087307f88b80619a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1660ceb0d3b0076555058087307f88b80619a6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1660ceb0d3b0076555058087307f88b80619a6f"}], "stats": {"total": 839, "additions": 812, "deletions": 27}, "files": [{"sha": "dc8ed2ee18c42e0db16a332a50890727dc907a18", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -460,6 +460,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__hashtable_alloc(__node_alloc_type(__a))\n       { }\n \n+      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,\n+\t\t true_type /* alloc always equal */)\n+\tnoexcept(std::is_nothrow_copy_constructible<_H1>::value &&\n+\t\t std::is_nothrow_copy_constructible<_Equal>::value);\n+\n+      _Hashtable(_Hashtable&&, __node_alloc_type&&,\n+\t\t false_type /* alloc always equal */);\n+\n       template<typename _InputIterator>\n \t_Hashtable(_InputIterator __first, _InputIterator __last,\n \t\t   size_type __bkt_count_hint,\n@@ -486,11 +494,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Hashtable(const _Hashtable&);\n \n-      _Hashtable(_Hashtable&&) noexcept;\n+      _Hashtable(_Hashtable&& __ht)\n+\tnoexcept( noexcept(\n+\t  _Hashtable(std::declval<_Hashtable>(),\n+\t\t     std::declval<__node_alloc_type>(),\n+\t\t     true_type{})) )\n+      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),\n+\t\t   true_type{})\n+      { }\n \n       _Hashtable(const _Hashtable&, const allocator_type&);\n \n-      _Hashtable(_Hashtable&&, const allocator_type&);\n+      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)\n+\tnoexcept( noexcept(\n+\t  _Hashtable(std::declval<_Hashtable>(),\n+\t\t     std::declval<__node_alloc_type>(),\n+\t\t     typename __node_alloc_traits::is_always_equal{})) )\n+      : _Hashtable(std::move(__ht), __node_alloc_type(__a),\n+\t\t   typename __node_alloc_traits::is_always_equal{})\n+      { }\n \n       // Use delegating constructors.\n       template<typename _InputIterator>\n@@ -1342,18 +1364,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _Hashtable(_Hashtable&& __ht) noexcept\n+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,\n+\t       true_type /* alloc always equal */)\n+    noexcept(std::is_nothrow_copy_constructible<_H1>::value &&\n+\t     std::is_nothrow_copy_constructible<_Equal>::value)\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n-      __hashtable_alloc(std::move(__ht._M_base_alloc())),\n+      __hashtable_alloc(std::move(__a)),\n       _M_buckets(__ht._M_buckets),\n       _M_bucket_count(__ht._M_bucket_count),\n       _M_before_begin(__ht._M_before_begin._M_nxt),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      // Update, if necessary, buckets if __ht is using its single bucket.\n+      // Update buckets if __ht is using its single bucket.\n       if (__ht._M_uses_single_bucket())\n \t{\n \t  _M_buckets = &_M_single_bucket;\n@@ -1392,11 +1417,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)\n+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,\n+\t       false_type /* alloc always equal */)\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n-      __hashtable_alloc(__node_alloc_type(__a)),\n+      __hashtable_alloc(std::move(__a)),\n       _M_buckets(nullptr),\n       _M_bucket_count(__ht._M_bucket_count),\n       _M_element_count(__ht._M_element_count),"}, {"sha": "1aaa1a1a6ee0f459eead2d592bd9f9997bbb943d", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -209,6 +209,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       unordered_map(unordered_map&& __umap,\n \t\t    const allocator_type& __a)\n+\tnoexcept( noexcept(_Hashtable(std::move(__umap._M_h), __a)) )\n       : _M_h(std::move(__umap._M_h), __a)\n       { }\n \n@@ -1303,6 +1304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       unordered_multimap(unordered_multimap&& __ummap,\n \t\t\t const allocator_type& __a)\n+\tnoexcept( noexcept(_Hashtable(std::move(__ummap._M_h), __a)) )\n       : _M_h(std::move(__ummap._M_h), __a)\n       { }\n "}, {"sha": "6cbfcb1f0b6c05109cd26dca6d4c8012dc68583e", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -203,6 +203,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       unordered_set(unordered_set&& __uset,\n \t\t    const allocator_type& __a)\n+\tnoexcept( noexcept(_Hashtable(std::move(__uset._M_h), __a)) )\n       : _M_h(std::move(__uset._M_h), __a)\n       { }\n \n@@ -1044,6 +1045,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       unordered_multiset(unordered_multiset&& __umset,\n \t\t\t const allocator_type& __a)\n+\tnoexcept( noexcept(_Hashtable(std::move(__umset._M_h), __a)) )\n       : _M_h(std::move(__umset._M_h), __a)\n       { }\n "}, {"sha": "4fa5c124d5a73ac2f4e8da177fd3d66615a7c993", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -144,6 +144,7 @@ namespace __debug\n \n       unordered_map(unordered_map&& __umap,\n \t\t    const allocator_type& __a)\n+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )\n       : _Safe(std::move(__umap._M_safe()), __a),\n \t_Base(std::move(__umap._M_base()), __a) { }\n \n@@ -168,28 +169,28 @@ namespace __debug\n \tunordered_map(_InputIterator __first, _InputIterator __last,\n \t\t      size_type __n,\n \t\t      const allocator_type& __a)\n-\t  : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)\n+\t: unordered_map(__first, __last, __n, hasher(), key_equal(), __a)\n \t{ }\n \n       template<typename _InputIterator>\n \tunordered_map(_InputIterator __first, _InputIterator __last,\n \t\t      size_type __n,\n \t\t      const hasher& __hf,\n \t\t      const allocator_type& __a)\n-\t  : unordered_map(__first, __last, __n, __hf, key_equal(), __a)\n+\t: unordered_map(__first, __last, __n, __hf, key_equal(), __a)\n \t{ }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n,\n \t\t    const allocator_type& __a)\n-\t: unordered_map(__l, __n, hasher(), key_equal(), __a)\n+      : unordered_map(__l, __n, hasher(), key_equal(), __a)\n       { }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n,\n \t\t    const hasher& __hf,\n \t\t    const allocator_type& __a)\n-\t: unordered_map(__l, __n, __hf, key_equal(), __a)\n+      : unordered_map(__l, __n, __hf, key_equal(), __a)\n       { }\n \n       ~unordered_map() = default;\n@@ -847,6 +848,7 @@ namespace __debug\n \n       unordered_multimap(unordered_multimap&& __umap,\n \t\t\t const allocator_type& __a)\n+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )\n       : _Safe(std::move(__umap._M_safe()), __a),\n \t_Base(std::move(__umap._M_base()), __a) { }\n \n@@ -870,26 +872,26 @@ namespace __debug\n \tunordered_multimap(_InputIterator __first, _InputIterator __last,\n \t\t\t   size_type __n,\n \t\t\t   const allocator_type& __a)\n-\t  : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)\n+\t: unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)\n \t{ }\n \n       template<typename _InputIterator>\n \tunordered_multimap(_InputIterator __first, _InputIterator __last,\n \t\t\t   size_type __n, const hasher& __hf,\n \t\t\t   const allocator_type& __a)\n-\t  : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)\n+\t: unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)\n \t{ }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n,\n \t\t\t const allocator_type& __a)\n-\t: unordered_multimap(__l, __n, hasher(), key_equal(), __a)\n+      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)\n       { }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n, const hasher& __hf,\n \t\t\t const allocator_type& __a)\n-\t: unordered_multimap(__l, __n, __hf, key_equal(), __a)\n+      : unordered_multimap(__l, __n, __hf, key_equal(), __a)\n       { }\n \n       ~unordered_multimap() = default;"}, {"sha": "94dde0d0ded67dab904340f49b77ec12578d3289", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -141,6 +141,7 @@ namespace __debug\n \n       unordered_set(unordered_set&& __uset,\n \t\t    const allocator_type& __a)\n+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )\n       : _Safe(std::move(__uset._M_safe()), __a),\n \t_Base(std::move(__uset._M_base()), __a) { }\n \n@@ -152,38 +153,38 @@ namespace __debug\n       : _Base(__l, __n, __hf, __eql, __a) { }\n \n       unordered_set(size_type __n, const allocator_type& __a)\n-\t: unordered_set(__n, hasher(), key_equal(), __a)\n+      : unordered_set(__n, hasher(), key_equal(), __a)\n       { }\n \n       unordered_set(size_type __n, const hasher& __hf,\n \t\t    const allocator_type& __a)\n-\t: unordered_set(__n, __hf, key_equal(), __a)\n+      : unordered_set(__n, __hf, key_equal(), __a)\n       { }\n \n       template<typename _InputIterator>\n \tunordered_set(_InputIterator __first, _InputIterator __last,\n \t\t      size_type __n,\n \t\t      const allocator_type& __a)\n-\t  : unordered_set(__first, __last, __n, hasher(), key_equal(), __a)\n+\t: unordered_set(__first, __last, __n, hasher(), key_equal(), __a)\n \t{ }\n \n       template<typename _InputIterator>\n \tunordered_set(_InputIterator __first, _InputIterator __last,\n \t\t      size_type __n, const hasher& __hf,\n \t\t      const allocator_type& __a)\n-\t  : unordered_set(__first, __last, __n, __hf, key_equal(), __a)\n+\t: unordered_set(__first, __last, __n, __hf, key_equal(), __a)\n \t{ }\n \n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n,\n \t\t    const allocator_type& __a)\n-\t: unordered_set(__l, __n, hasher(), key_equal(), __a)\n+      : unordered_set(__l, __n, hasher(), key_equal(), __a)\n       { }\n \n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n, const hasher& __hf,\n \t\t    const allocator_type& __a)\n-\t: unordered_set(__l, __n, __hf, key_equal(), __a)\n+      : unordered_set(__l, __n, __hf, key_equal(), __a)\n       { }\n \n       ~unordered_set() = default;\n@@ -717,6 +718,7 @@ namespace __debug\n \n       unordered_multiset(unordered_multiset&& __uset,\n \t\t\t const allocator_type& __a)\n+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )\n       : _Safe(std::move(__uset._M_safe()), __a),\n \t_Base(std::move(__uset._M_base()), __a) { }\n \n@@ -728,38 +730,38 @@ namespace __debug\n       : _Base(__l, __n, __hf, __eql, __a) { }\n \n       unordered_multiset(size_type __n, const allocator_type& __a)\n-\t: unordered_multiset(__n, hasher(), key_equal(), __a)\n+      : unordered_multiset(__n, hasher(), key_equal(), __a)\n       { }\n \n       unordered_multiset(size_type __n, const hasher& __hf,\n \t\t\t const allocator_type& __a)\n-\t: unordered_multiset(__n, __hf, key_equal(), __a)\n+      : unordered_multiset(__n, __hf, key_equal(), __a)\n       { }\n \n       template<typename _InputIterator>\n \tunordered_multiset(_InputIterator __first, _InputIterator __last,\n \t\t\t   size_type __n,\n \t\t\t   const allocator_type& __a)\n-\t  : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)\n+\t: unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)\n \t{ }\n \n       template<typename _InputIterator>\n \tunordered_multiset(_InputIterator __first, _InputIterator __last,\n \t\t\t   size_type __n, const hasher& __hf,\n \t\t\t   const allocator_type& __a)\n-\t  : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)\n+\t: unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)\n \t{ }\n \n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n,\n \t\t\t const allocator_type& __a)\n-\t: unordered_multiset(__l, __n, hasher(), key_equal(), __a)\n+      : unordered_multiset(__l, __n, hasher(), key_equal(), __a)\n       { }\n \n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n, const hasher& __hf,\n \t\t\t const allocator_type& __a)\n-\t: unordered_multiset(__l, __n, __hf, key_equal(), __a)\n+      : unordered_multiset(__l, __n, __hf, key_equal(), __a)\n       { }\n \n       ~unordered_multiset() = default;"}, {"sha": "473a5f1ce47279feec404972de14031e3a855c30", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fdefault_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fdefault_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fdefault_init.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O0\" }\n+// { dg-xfail-run-if \"PR c++/65816\" { *-*-* } }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+#include <ext/aligned_buffer.h>\n+\n+using T = int;\n+\n+using __gnu_test::default_init_allocator;\n+\n+void test01()\n+{\n+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;\n+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,\n+\t\t\t     alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type;\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+void test02()\n+{\n+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;\n+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,\n+\t\t\t     alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type();\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "f859ec939d04fdd6000e239f43e0572f94b7af18", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fnoexcept_default_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fnoexcept_default_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fnoexcept_default_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <unordered_map>\n+\n+using type1 = std::unordered_map<int, int>;\n+\n+static_assert(std::is_nothrow_default_constructible<type1>::value,\n+\t      \"noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_hash\n+{\n+  not_noexcept_dflt_cons_hash() /* noexcept */;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_map<int, int, not_noexcept_dflt_cons_hash>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type2>::value,\n+\t       \"not noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_equal_to\n+{\n+  not_noexcept_dflt_cons_equal_to() /* noexcept */;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_map<int, int, std::hash<int>,\n+\t\t\t\t  not_noexcept_dflt_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type3>::value,\n+\t       \"not noexcept default constructible\");\n+\n+template<typename _Tp>\n+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>\n+  {\n+    not_noexcept_dflt_cons_alloc() /* noexcept */;\n+\n+    template<typename _Tp1>\n+      struct rebind\n+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };\n+  };\n+\n+using type4 = std::unordered_map<int, int, std::hash<int>, std::equal_to<int>,\n+\t\t\tnot_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;\n+\n+static_assert(!std::is_nothrow_default_constructible<type4>::value,\n+\t      \"not noexcept default constructible\");"}, {"sha": "99852b248d06b767f3248709322e611851bc0b2d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fnoexcept_move_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fnoexcept_move_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fnoexcept_move_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+\n+using type1 = std::unordered_map<int, int>;\n+\n+static_assert( std::is_nothrow_move_constructible<type1>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( std::is_nothrow_constructible<type1,\n+\t       type1&&, const typename type1::allocator_type&>::value,\n+\t       \"noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_hash\n+{\n+  not_noexcept_copy_cons_hash() noexcept;\n+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;\n+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_map<int, int, not_noexcept_copy_cons_hash>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type2>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type2, type2&&,\n+\t       const typename type2::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_equal_to\n+{\n+  not_noexcept_copy_cons_equal_to() noexcept;\n+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;\n+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_map<int, int, std::hash<int>,\n+\t\t\t\t  not_noexcept_copy_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type3>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type3, type3&&,\n+\t       const typename type3::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );"}, {"sha": "0a5ef1113d9c7d4183f02859a7515821af6d4bae", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fmove_assign.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,81 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_counter_type.h>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  using __gnu_test::counter_type;\n+\n+  std::vector<pair<int, counter_type>> insts { { 0, 0 }, { 1, 1 }, { 2, 2 } };\n+  typedef unordered_map<int, counter_type> Map;\n+  Map m;\n+\n+  counter_type::reset();\n+\n+  m.insert(make_move_iterator(insts.begin()), make_move_iterator(insts.end()));\n+\n+  VERIFY( m.size() == 3 );\n+  VERIFY( counter_type::default_count == 0 );\n+  VERIFY( counter_type::copy_count == 0 );\n+  VERIFY( counter_type::move_count == 3 );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+  using __gnu_test::counter_type;\n+  using __gnu_test::propagating_allocator;\n+\n+  typedef propagating_allocator<pair<const int, counter_type>, false> Alloc;\n+  typedef unordered_map<int, counter_type,\n+\t\t\thash<int>, equal_to<int>,\n+\t\t\tAlloc> Map;\n+\n+  Alloc a1(1);\n+  Map m1(3, a1);\n+  m1 = { { 0, 0 }, { 1, 1 }, { 2, 2 } };\n+  Alloc a2(2);\n+  Map m2(3, a2);\n+  m2 = { { 3, 0 }, { 4, 1 }, { 5, 2 } };\n+\n+  counter_type::reset();\n+\n+  m2 = move(m1);\n+\n+  VERIFY( m1.empty() );\n+  VERIFY( m2.size() == 3 );\n+  VERIFY( counter_type::default_count == 0 );\n+  VERIFY( counter_type::copy_count == 0 );\n+  VERIFY( counter_type::move_count == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "98e2b017ca99f4680f516301a0a3593226190864", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fnoexcept_default_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fnoexcept_default_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fnoexcept_default_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <unordered_map>\n+\n+using type1 = std::unordered_multimap<int, int>;\n+\n+static_assert(std::is_nothrow_default_constructible<type1>::value,\n+\t      \"noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_hash\n+{\n+  not_noexcept_dflt_cons_hash() /* noexcept */;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_multimap<int, int, not_noexcept_dflt_cons_hash>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type2>::value,\n+\t       \"not noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_equal_to\n+{\n+  not_noexcept_dflt_cons_equal_to() /* noexcept */;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_multimap<int, int, std::hash<int>,\n+\t\t\t\t       not_noexcept_dflt_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type3>::value,\n+\t       \"not noexcept default constructible\");\n+\n+template<typename _Tp>\n+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>\n+  {\n+    not_noexcept_dflt_cons_alloc() /* noexcept */;\n+\n+    template<typename _Tp1>\n+      struct rebind\n+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };\n+  };\n+\n+using type4 = std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>,\n+\t\t\t\t       not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;\n+\n+static_assert(!std::is_nothrow_default_constructible<type4>::value,\n+\t      \"not noexcept default constructible\");"}, {"sha": "1d60c0184ebaaef8c015b766fb078619b2feca4d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fnoexcept_move_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fnoexcept_move_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fnoexcept_move_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+\n+using type1 = std::unordered_multimap<int, int>;\n+\n+static_assert( std::is_nothrow_move_constructible<type1>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( std::is_nothrow_constructible<type1,\n+\t       type1&&, const typename type1::allocator_type&>::value,\n+\t       \"noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_hash\n+{\n+  not_noexcept_copy_cons_hash() noexcept;\n+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;\n+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_multimap<int, int, not_noexcept_copy_cons_hash>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type2>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type2, type2&&,\n+\t       const typename type2::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_equal_to\n+{\n+  not_noexcept_copy_cons_equal_to() noexcept;\n+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;\n+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_multimap<int, int, std::hash<int>,\n+\t\t\t\t       not_noexcept_copy_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type3>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type3, type3&&,\n+\t       const typename type3::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );"}, {"sha": "b7c0d80212599e01c04e0da8895b4362e6a82fa9", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fnoexcept_default_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fnoexcept_default_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fnoexcept_default_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <unordered_set>\n+\n+using type1 = std::unordered_multiset<int>;\n+\n+static_assert(std::is_nothrow_default_constructible<type1>::value,\n+\t      \"noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_hash\n+{\n+  not_noexcept_dflt_cons_hash() /* noexcept */;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_multiset<int, not_noexcept_dflt_cons_hash>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type2>::value,\n+\t       \"not noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_equal_to\n+{\n+  not_noexcept_dflt_cons_equal_to() /* noexcept */;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_multiset<int, std::hash<int>,\n+\t\t\t\t      not_noexcept_dflt_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type3>::value,\n+\t       \"not noexcept default constructible\");\n+\n+template<typename _Tp>\n+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>\n+  {\n+    not_noexcept_dflt_cons_alloc() /* noexcept */;\n+\n+    template<typename _Tp1>\n+      struct rebind\n+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };\n+  };\n+\n+using type4 = std::unordered_multiset<int, std::hash<int>, std::equal_to<int>,\n+\t\t\t\t      not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;\n+\n+static_assert(!std::is_nothrow_default_constructible<type4>::value,\n+\t      \"not noexcept default constructible\");"}, {"sha": "dd0e4ca920b45dec2d800d878d03536b2f2d3a8d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fnoexcept_move_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fnoexcept_move_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fnoexcept_move_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+\n+using type1 = std::unordered_multiset<int>;\n+\n+static_assert( std::is_nothrow_move_constructible<type1>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( std::is_nothrow_constructible<type1,\n+\t       type1&&, const typename type1::allocator_type&>::value,\n+\t       \"noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_hash\n+{\n+  not_noexcept_copy_cons_hash() noexcept;\n+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;\n+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_multiset<int, not_noexcept_copy_cons_hash>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type2>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type2, type2&&,\n+\t       const typename type2::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_equal_to\n+{\n+  not_noexcept_copy_cons_equal_to() noexcept;\n+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;\n+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_multiset<int, std::hash<int>,\n+\t\t\t\t      not_noexcept_copy_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type3>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type3, type3&&,\n+\t       const typename type3::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );"}, {"sha": "37110dd6eb0eb27c093b01b1fb61701609b2b535", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fdefault_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fdefault_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fdefault_init.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O0\" }\n+// { dg-xfail-run-if \"PR c++/65816\" { *-*-* } }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+#include <ext/aligned_buffer.h>\n+\n+using T = int;\n+\n+using __gnu_test::default_init_allocator;\n+\n+void test01()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,\n+\t\t\t     alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type;\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+void test02()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,\n+\t\t\t     alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type();\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "d60a81ffb7ce3cfe6249758625b858b7de00b875", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fnoexcept_default_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fnoexcept_default_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fnoexcept_default_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <unordered_set>\n+\n+using type1 = std::unordered_set<int>;\n+\n+static_assert(std::is_nothrow_default_constructible<type1>::value,\n+\t      \"noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_hash\n+{\n+  not_noexcept_dflt_cons_hash() /* noexcept */;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_set<int, not_noexcept_dflt_cons_hash>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type2>::value,\n+\t       \"not noexcept default constructible\");\n+\n+struct not_noexcept_dflt_cons_equal_to\n+{\n+  not_noexcept_dflt_cons_equal_to() /* noexcept */;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_set<int, std::hash<int>,\n+\t\t\t\t  not_noexcept_dflt_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_default_constructible<type3>::value,\n+\t       \"not noexcept default constructible\");\n+\n+template<typename _Tp>\n+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>\n+  {\n+    not_noexcept_dflt_cons_alloc() /* noexcept */;\n+\n+    template<typename _Tp1>\n+      struct rebind\n+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };\n+  };\n+\n+using type4 = std::unordered_set<int, std::hash<int>, std::equal_to<int>,\n+\t\t\t\t  not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;\n+\n+static_assert(!std::is_nothrow_default_constructible<type4>::value,\n+\t      \"not noexcept default constructible\");"}, {"sha": "9be5ed07a33c094d16a7e40fd51d16278b3a6a83", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fnoexcept_move_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12324b9a934654a5c3bf4a614853ded2e0a958af/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fnoexcept_move_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fnoexcept_move_construct.cc?ref=12324b9a934654a5c3bf4a614853ded2e0a958af", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+\n+using type1 = std::unordered_set<int>;\n+\n+static_assert( std::is_nothrow_move_constructible<type1>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( std::is_nothrow_constructible<type1,\n+\t       type1&&, const typename type1::allocator_type&>::value,\n+\t       \"noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_hash\n+{\n+  not_noexcept_copy_cons_hash() noexcept;\n+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;\n+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;\n+\n+  std::size_t\n+  operator()(int) const noexcept;\n+};\n+\n+using type2 = std::unordered_set<int, not_noexcept_copy_cons_hash>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type2>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type2, type2&&,\n+\t       const typename type2::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );\n+\n+struct not_noexcept_copy_cons_equal_to\n+{\n+  not_noexcept_copy_cons_equal_to() noexcept;\n+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;\n+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;\n+\n+  bool\n+  operator()(int, int) const noexcept;\n+};\n+\n+using type3 = std::unordered_set<int, std::hash<int>,\n+\t\t\t\t  not_noexcept_copy_cons_equal_to>;\n+\n+static_assert( !std::is_nothrow_move_constructible<type3>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( !std::is_nothrow_constructible<type3, type3&&,\n+\t       const typename type3::allocator_type&>::value,\n+\t       \"not noexcept move constructor with allocator\" );"}]}