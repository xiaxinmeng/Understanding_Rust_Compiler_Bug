{"sha": "85363ca0942f5f45334b2b2ee56dad289f0ebd27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUzNjNjYTA5NDJmNWY0NTMzNGIyYjJlZTU2ZGFkMjg5ZjBlYmQyNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-07T02:23:42Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-07T02:23:42Z"}, "message": "* libfuncs.h (LTI_extendsfdf2, LTI_extendsfxf2, LTI_extendsftf2)\n\t(LTI_extenddfxf2, LTI_extenddftf2, LTI_truncdfsf2, LTI_truncxfsf2)\n\t(LTI_trunctfsf2, LTI_truncxfdf2, LTI_trunctfdf2, LTI_floatsisf)\n\t(LTI_floatdisf, LTI_floattisf, LTI_floatsidf, LTI_floatdidf)\n\t(LTI_floattidf, LTI_floatsixf, LTI_floatdixf, LTI_floattixf)\n\t(LTI_floatsitf, LTI_floatditf, LTI_floattitf, LTI_fixsfsi, LTI_fixsfdi)\n\t(LTI_fixsfti, LTI_fixdfsi, LTI_fixdfdi, LTI_fixdfti, LTI_fixxfsi)\n\t(LTI_fixxfdi, LTI_fixxfti, LTI_fixtfsi, LTI_fixtfdi, LTI_fixtfti)\n\t(LTI_fixunssfsi, LTI_fixunssfdi, LTI_fixunssfti, LTI_fixunsdfsi)\n\t(LTI_fixunsdfdi, LTI_fixunsdfti, LTI_fixunsxfsi, LTI_fixunsxfdi)\n\t(LTI_fixunsxfti, LTI_fixunstfsi, LTI_fixunstfdi, LTI_fixunstfti)\n\t(extendsfdf2_libfunc, extendsfxf2_libfunc, extendsftf2_libfunc)\n\t(extenddfxf2_libfunc, extenddftf2_libfunc, truncdfsf2_libfunc)\n\t(truncxfsf2_libfunc, trunctfsf2_libfunc, truncxfdf2_libfunc)\n\t(trunctfdf2_libfunc, floatsisf_libfunc, floatdisf_libfunc)\n\t(floattisf_libfunc, floatsidf_libfunc, floatdidf_libfunc)\n\t(floattidf_libfunc, floatsixf_libfunc, floatdixf_libfunc)\n\t(floattixf_libfunc, floatsitf_libfunc, floatditf_libfunc)\n\t(floattitf_libfunc, fixsfsi_libfunc, fixsfdi_libfunc, fixsfti_libfunc)\n\t(fixdfsi_libfunc, fixdfdi_libfunc, fixdfti_libfunc, fixxfsi_libfunc)\n\t(fixxfdi_libfunc, fixxfti_libfunc, fixtfsi_libfunc, fixtfdi_libfunc)\n\t(fixtfti_libfunc, fixunssfsi_libfunc, fixunssfdi_libfunc)\n\t(fixunssfti_libfunc, fixunsdfsi_libfunc, fixunsdfdi_libfunc)\n\t(fixunsdfti_libfunc, fixunsxfsi_libfunc, fixunsxfdi_libfunc)\n\t(fixunsxfti_libfunc, fixunstfsi_libfunc, fixunstfdi_libfunc)\n\t(fixunstfti_libfunc): Delete.\n\t* optabs.h (struct optab_handlers): Break out of struct optab.\n\t(struct convert_optab, convert_optab, enum convert_optab_index,\n\tconvert_optab_table, sext_optab, zext_optab, trunc_optab,\n\tsfix_optab, ufix_optab, sfixtrunc_optab, ufixtrunc_optab,\n\tsfloat_optab, ufloat_optab): New.\n\t(set_conv_libfunc): Prototype.\n\t(GEN_FCN): Use C90 indirect call syntax, remove unnecessary cast.\n\t(trunc_optab): Renamed btrunc_optab.\n\t* builtins.c (expand_builtin_mathfn): Update to match.\n\t* optabs.c (extendtab, fixtab, fixtrunctab, floattab): Delete.\n\t(convert_optab_table, new_convert_optab, init_convert_optab)\n\t(init_interclass_conv_libfuncs, init_intraclass_conv_libfuncs)\n\t(set_conv_libfunc): New.\n\t(can_extend_p, gen_extend_insn, can_fix_p, can_float_p)\n\t(expand_float, expand_fix): Use new conversion optabs,\n\tnot old insn code tables or long chains of ifs.\n\t(init_optabs): No need to clear old insn code tables.\n\tInitialize the new optabs, not the old libfunc array entries.\n\tDon't handle FIXUNS_TRUNC_LIKE_FIX_TRUNC here.\n\t* genopinit.c: Initialize conversion optabs, not the\n\tformer insn code tables.  Remove unnecessary casts.\n\tHandle FIXUNS_TRUNC_LIKE_FIX_TRUNC here.\n\t* expr.c (convert_move): Remove redundant check that\n\tto_real==from_real.  Use the conversion optabs instead\n\tof long chains of tests of modes.  Move partial-integer-mode\n\tinterconversion above all integer conversion.  Do not recurse\n\ton a value forced into a register in the original mode.\n\n\t* config/gofast.h, config/frv/frv.c, config/ia64/ia64.c\n\t* config/mips/mips.c, config/pa/pa.c, config/rs6000/rs6000.c\n\t* config/sparc/sparc.c: Use set_conv_libfunc to adjust entries\n\tin new conversion optabs; do not reference the old libfunc\n\tarray entries.  No need to include libfuncs.h.\n\nFrom-SVN: r72178", "tree": {"sha": "272ff451c0f5e3b65cd727409933c9d1f5119570", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/272ff451c0f5e3b65cd727409933c9d1f5119570"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85363ca0942f5f45334b2b2ee56dad289f0ebd27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85363ca0942f5f45334b2b2ee56dad289f0ebd27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85363ca0942f5f45334b2b2ee56dad289f0ebd27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85363ca0942f5f45334b2b2ee56dad289f0ebd27/comments", "author": null, "committer": null, "parents": [{"sha": "1f1dc5bb85d601f26249deecb9bf77390d674f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f1dc5bb85d601f26249deecb9bf77390d674f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f1dc5bb85d601f26249deecb9bf77390d674f3d"}], "stats": {"total": 1448, "additions": 521, "deletions": 927}, "files": [{"sha": "a7a3b0c1a89876914c3d43630ddba8159e3b525d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -1,3 +1,65 @@\n+2003-10-06  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* libfuncs.h (LTI_extendsfdf2, LTI_extendsfxf2, LTI_extendsftf2)\n+\t(LTI_extenddfxf2, LTI_extenddftf2, LTI_truncdfsf2, LTI_truncxfsf2)\n+\t(LTI_trunctfsf2, LTI_truncxfdf2, LTI_trunctfdf2, LTI_floatsisf)\n+\t(LTI_floatdisf, LTI_floattisf, LTI_floatsidf, LTI_floatdidf)\n+\t(LTI_floattidf, LTI_floatsixf, LTI_floatdixf, LTI_floattixf)\n+\t(LTI_floatsitf, LTI_floatditf, LTI_floattitf, LTI_fixsfsi, LTI_fixsfdi)\n+\t(LTI_fixsfti, LTI_fixdfsi, LTI_fixdfdi, LTI_fixdfti, LTI_fixxfsi)\n+\t(LTI_fixxfdi, LTI_fixxfti, LTI_fixtfsi, LTI_fixtfdi, LTI_fixtfti)\n+\t(LTI_fixunssfsi, LTI_fixunssfdi, LTI_fixunssfti, LTI_fixunsdfsi)\n+\t(LTI_fixunsdfdi, LTI_fixunsdfti, LTI_fixunsxfsi, LTI_fixunsxfdi)\n+\t(LTI_fixunsxfti, LTI_fixunstfsi, LTI_fixunstfdi, LTI_fixunstfti)\n+\t(extendsfdf2_libfunc, extendsfxf2_libfunc, extendsftf2_libfunc)\n+\t(extenddfxf2_libfunc, extenddftf2_libfunc, truncdfsf2_libfunc)\n+\t(truncxfsf2_libfunc, trunctfsf2_libfunc, truncxfdf2_libfunc)\n+\t(trunctfdf2_libfunc, floatsisf_libfunc, floatdisf_libfunc)\n+\t(floattisf_libfunc, floatsidf_libfunc, floatdidf_libfunc)\n+\t(floattidf_libfunc, floatsixf_libfunc, floatdixf_libfunc)\n+\t(floattixf_libfunc, floatsitf_libfunc, floatditf_libfunc)\n+\t(floattitf_libfunc, fixsfsi_libfunc, fixsfdi_libfunc, fixsfti_libfunc)\n+\t(fixdfsi_libfunc, fixdfdi_libfunc, fixdfti_libfunc, fixxfsi_libfunc)\n+\t(fixxfdi_libfunc, fixxfti_libfunc, fixtfsi_libfunc, fixtfdi_libfunc)\n+\t(fixtfti_libfunc, fixunssfsi_libfunc, fixunssfdi_libfunc)\n+\t(fixunssfti_libfunc, fixunsdfsi_libfunc, fixunsdfdi_libfunc)\n+\t(fixunsdfti_libfunc, fixunsxfsi_libfunc, fixunsxfdi_libfunc)\n+\t(fixunsxfti_libfunc, fixunstfsi_libfunc, fixunstfdi_libfunc)\n+\t(fixunstfti_libfunc): Delete.\n+\t* optabs.h (struct optab_handlers): Break out of struct optab.\n+\t(struct convert_optab, convert_optab, enum convert_optab_index,\n+\tconvert_optab_table, sext_optab, zext_optab, trunc_optab,\n+\tsfix_optab, ufix_optab, sfixtrunc_optab, ufixtrunc_optab,\n+\tsfloat_optab, ufloat_optab): New.\n+\t(set_conv_libfunc): Prototype.\n+\t(GEN_FCN): Use C90 indirect call syntax, remove unnecessary cast.\n+\t(trunc_optab): Renamed btrunc_optab.\n+\t* builtins.c (expand_builtin_mathfn): Update to match.\n+\t* optabs.c (extendtab, fixtab, fixtrunctab, floattab): Delete.\n+\t(convert_optab_table, new_convert_optab, init_convert_optab)\n+\t(init_interclass_conv_libfuncs, init_intraclass_conv_libfuncs)\n+\t(set_conv_libfunc): New.\n+\t(can_extend_p, gen_extend_insn, can_fix_p, can_float_p)\n+\t(expand_float, expand_fix): Use new conversion optabs,\n+\tnot old insn code tables or long chains of ifs.\n+\t(init_optabs): No need to clear old insn code tables.\n+\tInitialize the new optabs, not the old libfunc array entries.\n+\tDon't handle FIXUNS_TRUNC_LIKE_FIX_TRUNC here.\n+\t* genopinit.c: Initialize conversion optabs, not the\n+\tformer insn code tables.  Remove unnecessary casts.\n+\tHandle FIXUNS_TRUNC_LIKE_FIX_TRUNC here.\n+\t* expr.c (convert_move): Remove redundant check that\n+\tto_real==from_real.  Use the conversion optabs instead\n+\tof long chains of tests of modes.  Move partial-integer-mode\n+\tinterconversion above all integer conversion.  Do not recurse\n+\ton a value forced into a register in the original mode.\n+\n+\t* config/gofast.h, config/frv/frv.c, config/ia64/ia64.c\n+\t* config/mips/mips.c, config/pa/pa.c, config/rs6000/rs6000.c\n+\t* config/sparc/sparc.c: Use set_conv_libfunc to adjust entries\n+\tin new conversion optabs; do not reference the old libfunc\n+\tarray entries.  No need to include libfuncs.h.\n+\n 2003-10-06  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.c (ix86_expand_setcc): Annotate the floating\n@@ -18,9 +80,9 @@\n \n 2003-10-06  Falk Hueffner  <falk.hueffner@student.uni-tuebingen.de>\n \n-        PR optimization/11974\n-        * optabs.c (expand_unop): Promote libcall outmode according to\n-        hard_libcall_value.\n+\tPR optimization/11974\n+\t* optabs.c (expand_unop): Promote libcall outmode according to\n+\thard_libcall_value.\n \n 2003-10-06  Zack Weinberg  <zack@codesourcery.com>\n "}, {"sha": "8aabaa7754a03917fc9485bd77a0db3f01bcc891", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -1652,7 +1652,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n     case BUILT_IN_TRUNC:\n     case BUILT_IN_TRUNCF:\n     case BUILT_IN_TRUNCL:\n-      builtin_optab = trunc_optab; break;\n+      builtin_optab = btrunc_optab; break;\n     case BUILT_IN_ROUND:\n     case BUILT_IN_ROUNDF:\n     case BUILT_IN_ROUNDL:"}, {"sha": "c9eab11bd3135282cb88c3919027fd79debaaff6", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -40,7 +40,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"function.h\"\n #include \"optabs.h\"\n-#include \"libfuncs.h\"\n #include \"toplev.h\"\n #include \"basic-block.h\"\n #include \"tm_p.h\"\n@@ -9145,20 +9144,23 @@ frv_init_libfuncs (void)\n   set_optab_libfunc (smul_optab,     DFmode, \"__muld\");\n   set_optab_libfunc (sdiv_optab,     DFmode, \"__divd\");\n \n-  fixsfsi_libfunc     = init_one_libfunc (\"__ftoi\");\n-  fixunssfsi_libfunc  = init_one_libfunc (\"__ftoui\");\n-  fixsfdi_libfunc     = init_one_libfunc (\"__ftoll\");\n-  fixunssfdi_libfunc  = init_one_libfunc (\"__ftoull\");\n-  fixdfsi_libfunc     = init_one_libfunc (\"__dtoi\");\n-  fixunsdfsi_libfunc  = init_one_libfunc (\"__dtoui\");\n-  fixdfdi_libfunc     = init_one_libfunc (\"__dtoll\");\n-  fixunsdfdi_libfunc  = init_one_libfunc (\"__dtoull\");\n-  floatsisf_libfunc   = init_one_libfunc (\"__itof\");\n-  floatdisf_libfunc   = init_one_libfunc (\"__lltof\");\n-  floatsidf_libfunc   = init_one_libfunc (\"__itod\");\n-  floatdidf_libfunc   = init_one_libfunc (\"__lltod\");\n-  extendsfdf2_libfunc = init_one_libfunc (\"__ftod\");\n-  truncdfsf2_libfunc  = init_one_libfunc (\"__dtof\");\n+  set_conv_libfunc (sext_optab,   DFmode, SFmode, \"__ftod\");\n+  set_conv_libfunc (trunc_optab,  SFmode, DFmode, \"__dtof\");\n+\n+  set_conv_libfunc (sfix_optab,   SImode, SFmode, \"__ftoi\");\n+  set_conv_libfunc (sfix_optab,   DImode, SFmode, \"__ftoll\");\n+  set_conv_libfunc (sfix_optab,   SImode, DFmode, \"__dtoi\");\n+  set_conv_libfunc (sfix_optab,   DImode, DFmode, \"__dtoll\");\n+\n+  set_conv_libfunc (ufix_optab,   SImode, SFmode, \"__ftoui\");\n+  set_conv_libfunc (ufix_optab,   SImode, SFmode, \"__ftoull\");\n+  set_conv_libfunc (ufix_optab,   SImode, SFmode, \"__dtoui\");\n+  set_conv_libfunc (ufix_optab,   SImode, SFmode, \"__dtoull\");\n+\n+  set_conv_libfunc (sfloat_optab, SFmode, SImode, \"__itof\");\n+  set_conv_libfunc (sfloat_optab, SFmode, DImode, \"__lltof\");\n+  set_conv_libfunc (sfloat_optab, DFmode, SImode, \"__itod\");\n+  set_conv_libfunc (sfloat_optab, DFmode, DImode, \"__lltod\");\n }\n \n /* Convert an integer constant to an accumulator register.  ICODE is the"}, {"sha": "91b0a651566e4ce9fdc2ede76f70e8ce28275963", "filename": "gcc/config/gofast.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fgofast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fgofast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgofast.h?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -66,14 +66,15 @@ gofast_maybe_init_libfuncs (void)\n   set_optab_libfunc (lt_optab, DFmode, \"dpcmp\");\n   set_optab_libfunc (le_optab, DFmode, \"dpcmp\");\n \n-  extendsfdf2_libfunc = init_one_libfunc (\"fptodp\");\n-  truncdfsf2_libfunc = init_one_libfunc (\"dptofp\");\n+  set_conv_libfunc (sext_optab,   DFmode, SFmode, \"fptodp\");\n+  set_conv_libfunc (trunc_optab,  SFmode, DFmode, \"dptofp\");\n \n-  floatsisf_libfunc = init_one_libfunc (\"sitofp\");\n-  floatsidf_libfunc = init_one_libfunc (\"litodp\");\n-  fixsfsi_libfunc = init_one_libfunc (\"fptosi\");\n-  fixdfsi_libfunc = init_one_libfunc (\"dptoli\");\n-  fixunssfsi_libfunc = init_one_libfunc (\"fptoui\");\n-  fixunsdfsi_libfunc = init_one_libfunc (\"dptoul\");\n+  set_conv_libfunc (sfix_optab,   SImode, SFmode, \"fptosi\");\n+  set_conv_libfunc (sfix_optab,   SImode, DFmode, \"dptoli\");\n+  set_conv_libfunc (ufix_optab,   SImode, SFmode, \"fptoui\");\n+  set_conv_libfunc (ufix_optab,   SImode, DFmode, \"dptoul\");\n+\n+  set_conv_libfunc (sfloat_optab, SFmode, SImode, \"sitofp\");\n+  set_conv_libfunc (sfloat_optab, DFmode, DImode, \"litodp\");\n #endif\n }"}, {"sha": "75a2cb6b5d4de89b5bc372e6cdec050cc5e5b4e9", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -37,7 +37,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n-#include \"libfuncs.h\"\n #include \"except.h\"\n #include \"function.h\"\n #include \"ggc.h\"\n@@ -8327,16 +8326,18 @@ ia64_hpux_init_libfuncs (void)\n   set_optab_libfunc (lt_optab, TFmode, \"_U_Qflt\");\n   set_optab_libfunc (le_optab, TFmode, \"_U_Qfle\");\n \n-  extendsftf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_sgl_to_quad\");\n-  extenddftf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_dbl_to_quad\");\n-  trunctfsf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_quad_to_sgl\");\n-  trunctfdf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_quad_to_dbl\");\n-  floatsitf_libfunc = init_one_libfunc (\"_U_Qfcnvxf_sgl_to_quad\");\n-  floatditf_libfunc = init_one_libfunc (\"_U_Qfcnvxf_dbl_to_quad\");\n-  fixtfsi_libfunc = init_one_libfunc (\"_U_Qfcnvfxt_quad_to_sgl\");\n-  fixtfdi_libfunc = init_one_libfunc (\"_U_Qfcnvfxt_quad_to_dbl\");\n-  fixunstfsi_libfunc = init_one_libfunc (\"_U_Qfcnvfxut_quad_to_sgl\");\n-  fixunstfdi_libfunc = init_one_libfunc (\"_U_Qfcnvfxut_quad_to_dbl\");\n+  set_conv_libfunc (sext_optab,   TFmode, SFmode, \"_U_Qfcnvff_sgl_to_quad\");\n+  set_conv_libfunc (sext_optab,   TFmode, DFmode, \"_U_Qfcnvff_dbl_to_quad\");\n+  set_conv_libfunc (trunc_optab,  SFmode, TFmode, \"_U_Qfcnvff_quad_to_sgl\");\n+  set_conv_libfunc (trunc_optab,  DFmode, TFmode, \"_U_Qfcnvff_quad_to_dbl\");\n+\n+  set_conv_libfunc (sfix_optab,   SImode, TFmode, \"_U_Qfcnvfxt_quad_to_sgl\");\n+  set_conv_libfunc (sfix_optab,   DImode, TFmode, \"_U_Qfcnvfxt_quad_to_dbl\");\n+  set_conv_libfunc (ufix_optab,   SImode, TFmode, \"_U_Qfcnvfxut_quad_to_sgl\");\n+  set_conv_libfunc (ufix_optab,   DImode, TFmode, \"_U_Qfcnvfxut_quad_to_dbl\");\n+\n+  set_conv_libfunc (sfloat_optab, TFmode, SImode, \"_U_Qfcnvxf_sgl_to_quad\");\n+  set_conv_libfunc (sfloat_optab, TFmode, DImode, \"_U_Qfcnvxf_dbl_to_quad\");\n }\n \f\n /* Switch to the section to which we should output X.  The only thing"}, {"sha": "773d6a1a99d78e8aca6aad98dddf37a821c1960b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -42,7 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n-#include \"libfuncs.h\"\n #include \"flags.h\"\n #include \"reload.h\"\n #include \"tm_p.h\"\n@@ -9043,8 +9042,8 @@ mips_init_libfuncs (void)\n       set_optab_libfunc (lt_optab, SFmode, \"__mips16_ltsf2\");\n       set_optab_libfunc (le_optab, SFmode, \"__mips16_lesf2\");\n \n-      floatsisf_libfunc = init_one_libfunc (\"__mips16_floatsisf\");\n-      fixsfsi_libfunc   = init_one_libfunc (\"__mips16_fixsfsi\");\n+      set_conv_libfunc (sfix_optab, SImode, SFmode, \"__mips16_fixsfsi\");\n+      set_conv_libfunc (sfloat_optab, SFmode, SImode, \"__mips16_floatsisf\");\n \n       if (TARGET_DOUBLE_FLOAT)\n \t{\n@@ -9060,11 +9059,11 @@ mips_init_libfuncs (void)\n \t  set_optab_libfunc (lt_optab, DFmode, \"__mips16_ltdf2\");\n \t  set_optab_libfunc (le_optab, DFmode, \"__mips16_ledf2\");\n \n-\t  floatsidf_libfunc   = init_one_libfunc (\"__mips16_floatsidf\");\n-\t  fixdfsi_libfunc     = init_one_libfunc (\"__mips16_fixdfsi\");\n+\t  set_conv_libfunc (sext_optab, DFmode, SFmode, \"__mips16_extendsfdf2\");\n+\t  set_conv_libfunc (trunc_optab, SFmode, DFmode, \"__mips16_truncdfsf2\");\n \n-\t  extendsfdf2_libfunc =\tinit_one_libfunc (\"__mips16_extendsfdf2\");\n-\t  truncdfsf2_libfunc  =\tinit_one_libfunc (\"__mips16_truncdfsf2\");\n+\t  set_conv_libfunc (sfix_optab, SImode, DFmode, \"__mips16_fixdfsi\");\n+\t  set_conv_libfunc (sfloat_optab, DFmode, SImode, \"__mips16_floatsidf\");\n \t}\n     }\n   else"}, {"sha": "a438ac4a413539440e29f3a10786b67814283312", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -37,7 +37,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n-#include \"libfuncs.h\"\n #include \"reload.h\"\n #include \"integrate.h\"\n #include \"function.h\"\n@@ -4980,18 +4979,20 @@ pa_hpux_init_libfuncs (void)\n   set_optab_libfunc (lt_optab, TFmode, \"_U_Qflt\");\n   set_optab_libfunc (le_optab, TFmode, \"_U_Qfle\");\n \n-  extendsftf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_sgl_to_quad\");\n-  extenddftf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_dbl_to_quad\");\n-  trunctfsf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_quad_to_sgl\");\n-  trunctfdf2_libfunc = init_one_libfunc (\"_U_Qfcnvff_quad_to_dbl\");\n-  floatsitf_libfunc = init_one_libfunc (\"_U_Qfcnvxf_sgl_to_quad\");\n-  floatditf_libfunc = init_one_libfunc (\"_U_Qfcnvxf_dbl_to_quad\");\n-  fixtfsi_libfunc = init_one_libfunc (TARGET_64BIT\n-\t\t\t\t      ? \"__U_Qfcnvfxt_quad_to_sgl\"\n-\t\t\t\t      : \"_U_Qfcnvfxt_quad_to_sgl\");\n-  fixtfdi_libfunc = init_one_libfunc (\"_U_Qfcnvfxt_quad_to_dbl\");\n-  fixunstfsi_libfunc = init_one_libfunc (\"_U_Qfcnvfxt_quad_to_usgl\");\n-  fixunstfdi_libfunc = init_one_libfunc (\"_U_Qfcnvfxt_quad_to_udbl\");\n+  set_conv_libfunc (sext_optab,   TFmode, SFmode, \"_U_Qfcnvff_sgl_to_quad\");\n+  set_conv_libfunc (sext_optab,   TFmode, DFmode, \"_U_Qfcnvff_dbl_to_quad\");\n+  set_conv_libfunc (trunc_optab,  SFmode, TFmode, \"_U_Qfcnvff_quad_to_sgl\");\n+  set_conv_libfunc (trunc_optab,  DFmode, TFmode, \"_U_Qfcnvff_quad_to_dbl\");\n+\n+  set_conv_libfunc (sfix_optab,   SImode, TFmode, TARGET_64BIT\n+\t\t\t\t\t\t  ? \"__U_Qfcnvfxt_quad_to_sgl\"\n+\t\t\t\t\t\t  : \"_U_Qfcnvfxt_quad_to_sgl\");\n+  set_conv_libfunc (sfix_optab,   DImode, TFmode, \"_U_Qfcnvfxt_quad_to_dbl\");\n+  set_conv_libfunc (ufix_optab,   SImode, TFmode, \"_U_Qfcnvfxt_quad_to_usgl\");\n+  set_conv_libfunc (ufix_optab,   DImode, TFmode, \"_U_Qfcnvfxt_quad_to_udbl\");\n+\n+  set_conv_libfunc (sfloat_optab, TFmode, SImode, \"_U_Qfcnvxf_sgl_to_quad\");\n+  set_conv_libfunc (sfloat_optab, TFmode, DImode, \"_U_Qfcnvxf_dbl_to_quad\");\n }\n #endif\n "}, {"sha": "be79acc3f686d86ce3468793f8c8612725d953c9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -37,7 +37,6 @@\n #include \"tree.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n-#include \"libfuncs.h\"\n #include \"except.h\"\n #include \"function.h\"\n #include \"output.h\"\n@@ -6784,8 +6783,8 @@ rs6000_init_libfuncs (void)\n       if (TARGET_XCOFF && ! TARGET_POWER2 && ! TARGET_POWERPC)\n \t{\n \t  /* AIX library routines for float->int conversion.  */\n-\t  fixdfsi_libfunc = init_one_libfunc (\"__itrunc\");\n-\t  fixunsdfsi_libfunc = init_one_libfunc (\"__uitrunc\");\n+\t  set_conv_libfunc (sfix_optab, SImode, DFmode, \"__itrunc\");\n+\t  set_conv_libfunc (ufix_optab, SImode, DFmode, \"__uitrunc\");\n \t}\n \n       /* Standard AIX/Darwin/64-bit SVR4 quad floating point routines.  */\n@@ -6813,17 +6812,15 @@ rs6000_init_libfuncs (void)\n       set_optab_libfunc (lt_optab, TFmode, \"_q_flt\");\n       set_optab_libfunc (le_optab, TFmode, \"_q_fle\");\n \n-      trunctfsf2_libfunc = init_one_libfunc (\"_q_qtos\");\n-      trunctfdf2_libfunc = init_one_libfunc (\"_q_qtod\");\n-      extendsftf2_libfunc = init_one_libfunc (\"_q_stoq\");\n-      extenddftf2_libfunc = init_one_libfunc (\"_q_dtoq\");\n-      floatsitf_libfunc = init_one_libfunc (\"_q_itoq\");\n-      fixtfsi_libfunc = init_one_libfunc (\"_q_qtoi\");\n-      fixunstfsi_libfunc = init_one_libfunc (\"_q_qtou\");\n+      set_conv_libfunc (sext_optab, TFmode, SFmode, \"_q_stoq\");\n+      set_conv_libfunc (sext_optab, TFmode, DFmode, \"_q_dtoq\");\n+      set_conv_libfunc (trunc_optab, SFmode, TFmode, \"_q_qtos\");\n+      set_conv_libfunc (trunc_optab, DFmode, TFmode, \"_q_qtod\");\n+      set_conv_libfunc (sfix_optab, SImode, TFmode, \"_q_qtoi\");\n+      set_conv_libfunc (ufix_optab, SImode, TFmode, \"_q_qtou\");\n+      set_conv_libfunc (sfloat_optab, TFmode, SImode, \"_q_itoq\");\n     }\n }\n-\n-\n \f\n /* Expand a block move operation, and return 1 if successful.  Return 0\n    if we should let the compiler generate normal code."}, {"sha": "96335c9d96cb0cbefd9b8f7bc34ee6b3d3075b06", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -39,7 +39,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n-#include \"libfuncs.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n@@ -8431,20 +8430,21 @@ sparc_init_libfuncs (void)\n       set_optab_libfunc (lt_optab, TFmode, \"_Q_flt\");\n       set_optab_libfunc (le_optab, TFmode, \"_Q_fle\");\n \n-      trunctfsf2_libfunc = init_one_libfunc (\"_Q_qtos\");\n-      trunctfdf2_libfunc = init_one_libfunc (\"_Q_qtod\");\n-      extendsftf2_libfunc = init_one_libfunc (\"_Q_stoq\");\n-      extenddftf2_libfunc = init_one_libfunc (\"_Q_dtoq\");\n-      floatsitf_libfunc = init_one_libfunc (\"_Q_itoq\");\n-      fixtfsi_libfunc = init_one_libfunc (\"_Q_qtoi\");\n-      fixunstfsi_libfunc = init_one_libfunc (\"_Q_qtou\");\n+      set_conv_libfunc (sext_optab,   TFmode, SFmode, \"_Q_stoq\");\n+      set_conv_libfunc (sext_optab,   TFmode, DFmode, \"_Q_dtoq\");\n+      set_conv_libfunc (trunc_optab,  SFmode, TFmode, \"_Q_qtos\");\n+      set_conv_libfunc (trunc_optab,  DFmode, TFmode, \"_Q_qtod\");\n+\n+      set_conv_libfunc (sfix_optab,   SImode, TFmode, \"_Q_qtoi\");\n+      set_conv_libfunc (ufix_optab,   SImode, TFmode, \"_Q_qtou\");\n+      set_conv_libfunc (sfloat_optab, TFmode, SImode, \"_Q_itoq\");\n \n       if (SUN_CONVERSION_LIBFUNCS)\n \t{\n-\t  fixsfdi_libfunc = init_one_libfunc (\"__ftoll\");\n-\t  fixunssfdi_libfunc = init_one_libfunc (\"__ftoull\");\n-\t  fixdfdi_libfunc = init_one_libfunc (\"__dtoll\");\n-\t  fixunsdfdi_libfunc = init_one_libfunc (\"__dtoull\");\n+\t  set_conv_libfunc (sfix_optab, DImode, SFmode, \"__ftoll\");\n+\t  set_conv_libfunc (ufix_optab, DImode, SFmode, \"__ftoull\");\n+\t  set_conv_libfunc (sfix_optab, DImode, DFmode, \"__dtoll\");\n+\t  set_conv_libfunc (ufix_optab, DImode, DFmode, \"__dtoull\");\n \t}\n     }\n   if (TARGET_ARCH64)\n@@ -8470,10 +8470,10 @@ sparc_init_libfuncs (void)\n \n       if (SUN_CONVERSION_LIBFUNCS)\n \t{\n-\t  fixsfdi_libfunc = init_one_libfunc (\"__ftol\");\n-\t  fixunssfdi_libfunc = init_one_libfunc (\"__ftoul\");\n-\t  fixdfdi_libfunc = init_one_libfunc (\"__dtol\");\n-\t  fixunsdfdi_libfunc = init_one_libfunc (\"__dtoul\");\n+\t  set_conv_libfunc (sfix_optab, DImode, SFmode, \"__ftol\");\n+\t  set_conv_libfunc (ufix_optab, DImode, SFmode, \"__ftoul\");\n+\t  set_conv_libfunc (sfix_optab, DImode, DFmode, \"__dtol\");\n+\t  set_conv_libfunc (ufix_optab, DImode, DFmode, \"__dtoul\");\n \t}\n     }\n "}, {"sha": "015faaf37980081d61d2d3768416a6cc8c85a556", "filename": "gcc/expr.c", "status": "modified", "additions": 58, "deletions": 471, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -595,248 +595,32 @@ convert_move (rtx to, rtx from, int unsignedp)\n       return;\n     }\n \n-  if (to_real != from_real)\n-    abort ();\n-\n   if (to_real)\n     {\n       rtx value, insns;\n+      convert_optab tab;\n \n       if (GET_MODE_BITSIZE (from_mode) < GET_MODE_BITSIZE (to_mode))\n-\t{\n-\t  /* Try converting directly if the insn is supported.  */\n-\t  if ((code = can_extend_p (to_mode, from_mode, 0))\n-\t      != CODE_FOR_nothing)\n-\t    {\n-\t      emit_unop_insn (code, to, from, UNKNOWN);\n-\t      return;\n-\t    }\n-\t}\n+\ttab = sext_optab;\n+      else if (GET_MODE_BITSIZE (from_mode) > GET_MODE_BITSIZE (to_mode))\n+\ttab = trunc_optab;\n+      else\n+\tabort ();\n \n-#ifdef HAVE_trunchfqf2\n-      if (HAVE_trunchfqf2 && from_mode == HFmode && to_mode == QFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunchfqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_trunctqfqf2\n-      if (HAVE_trunctqfqf2 && from_mode == TQFmode && to_mode == QFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctqfqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncsfqf2\n-      if (HAVE_truncsfqf2 && from_mode == SFmode && to_mode == QFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncsfqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncdfqf2\n-      if (HAVE_truncdfqf2 && from_mode == DFmode && to_mode == QFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdfqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncxfqf2\n-      if (HAVE_truncxfqf2 && from_mode == XFmode && to_mode == QFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncxfqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_trunctfqf2\n-      if (HAVE_trunctfqf2 && from_mode == TFmode && to_mode == QFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctfqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n+      /* Try converting directly if the insn is supported.  */\n \n-#ifdef HAVE_trunctqfhf2\n-      if (HAVE_trunctqfhf2 && from_mode == TQFmode && to_mode == HFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctqfhf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncsfhf2\n-      if (HAVE_truncsfhf2 && from_mode == SFmode && to_mode == HFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncsfhf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncdfhf2\n-      if (HAVE_truncdfhf2 && from_mode == DFmode && to_mode == HFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdfhf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncxfhf2\n-      if (HAVE_truncxfhf2 && from_mode == XFmode && to_mode == HFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncxfhf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_trunctfhf2\n-      if (HAVE_trunctfhf2 && from_mode == TFmode && to_mode == HFmode)\n+      code = tab->handlers[to_mode][from_mode].insn_code;\n+      if (code != CODE_FOR_nothing)\n \t{\n-\t  emit_unop_insn (CODE_FOR_trunctfhf2, to, from, UNKNOWN);\n+\t  emit_unop_insn (code, to, from,\n+\t\t\t  tab == sext_optab ? FLOAT_EXTEND : FLOAT_TRUNCATE);\n \t  return;\n \t}\n-#endif\n \n-#ifdef HAVE_truncsftqf2\n-      if (HAVE_truncsftqf2 && from_mode == SFmode && to_mode == TQFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncsftqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncdftqf2\n-      if (HAVE_truncdftqf2 && from_mode == DFmode && to_mode == TQFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdftqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncxftqf2\n-      if (HAVE_truncxftqf2 && from_mode == XFmode && to_mode == TQFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncxftqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_trunctftqf2\n-      if (HAVE_trunctftqf2 && from_mode == TFmode && to_mode == TQFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctftqf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n+      /* Otherwise use a libcall.  */\n+      libcall = tab->handlers[to_mode][from_mode].libfunc;\n \n-#ifdef HAVE_truncdfsf2\n-      if (HAVE_truncdfsf2 && from_mode == DFmode && to_mode == SFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdfsf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncxfsf2\n-      if (HAVE_truncxfsf2 && from_mode == XFmode && to_mode == SFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncxfsf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_trunctfsf2\n-      if (HAVE_trunctfsf2 && from_mode == TFmode && to_mode == SFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctfsf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_truncxfdf2\n-      if (HAVE_truncxfdf2 && from_mode == XFmode && to_mode == DFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncxfdf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-#ifdef HAVE_trunctfdf2\n-      if (HAVE_trunctfdf2 && from_mode == TFmode && to_mode == DFmode)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctfdf2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-\n-      libcall = (rtx) 0;\n-      switch (from_mode)\n-\t{\n-\tcase SFmode:\n-\t  switch (to_mode)\n-\t    {\n-\t    case DFmode:\n-\t      libcall = extendsfdf2_libfunc;\n-\t      break;\n-\n-\t    case XFmode:\n-\t      libcall = extendsfxf2_libfunc;\n-\t      break;\n-\n-\t    case TFmode:\n-\t      libcall = extendsftf2_libfunc;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase DFmode:\n-\t  switch (to_mode)\n-\t    {\n-\t    case SFmode:\n-\t      libcall = truncdfsf2_libfunc;\n-\t      break;\n-\n-\t    case XFmode:\n-\t      libcall = extenddfxf2_libfunc;\n-\t      break;\n-\n-\t    case TFmode:\n-\t      libcall = extenddftf2_libfunc;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase XFmode:\n-\t  switch (to_mode)\n-\t    {\n-\t    case SFmode:\n-\t      libcall = truncxfsf2_libfunc;\n-\t      break;\n-\n-\t    case DFmode:\n-\t      libcall = truncxfdf2_libfunc;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase TFmode:\n-\t  switch (to_mode)\n-\t    {\n-\t    case SFmode:\n-\t      libcall = trunctfsf2_libfunc;\n-\t      break;\n-\n-\t    case DFmode:\n-\t      libcall = trunctfdf2_libfunc;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      if (libcall == (rtx) 0)\n+      if (!libcall)\n \t/* This conversion is not implemented yet.  */\n \tabort ();\n \n@@ -850,6 +634,42 @@ convert_move (rtx to, rtx from, int unsignedp)\n       return;\n     }\n \n+  /* Handle pointer conversion.  */\t\t\t/* SPEE 900220.  */\n+  /* Targets are expected to provide conversion insns between PxImode and\n+     xImode for all MODE_PARTIAL_INT modes they use, but no others.  */\n+  if (GET_MODE_CLASS (to_mode) == MODE_PARTIAL_INT)\n+    {\n+      enum machine_mode full_mode\n+\t= smallest_mode_for_size (GET_MODE_BITSIZE (to_mode), MODE_INT);\n+\n+      if (trunc_optab->handlers[to_mode][full_mode].insn_code\n+\t  == CODE_FOR_nothing)\n+\tabort ();\n+\n+      if (full_mode != from_mode)\n+\tfrom = convert_to_mode (full_mode, from, unsignedp);\n+      emit_unop_insn (trunc_optab->handlers[to_mode][full_mode].insn_code,\n+\t\t      to, from, UNKNOWN);\n+      return;\n+    }\n+  if (GET_MODE_CLASS (from_mode) == MODE_PARTIAL_INT)\n+    {\n+      enum machine_mode full_mode\n+\t= smallest_mode_for_size (GET_MODE_BITSIZE (from_mode), MODE_INT);\n+\n+      if (sext_optab->handlers[full_mode][from_mode].insn_code\n+\t  == CODE_FOR_nothing)\n+\tabort ();\n+\n+      emit_unop_insn (sext_optab->handlers[full_mode][from_mode].insn_code,\n+\t\t      to, from, UNKNOWN);\n+      if (to_mode == full_mode)\n+\treturn;\n+\n+      /* else proceed to integer conversions below */\n+      from_mode = full_mode;\n+    }\n+\n   /* Now both modes are integers.  */\n \n   /* Handle expanding beyond a word.  */\n@@ -972,119 +792,6 @@ convert_move (rtx to, rtx from, int unsignedp)\n       return;\n     }\n \n-  /* Handle pointer conversion.  */\t\t\t/* SPEE 900220.  */\n-  if (to_mode == PQImode)\n-    {\n-      if (from_mode != QImode)\n-\tfrom = convert_to_mode (QImode, from, unsignedp);\n-\n-#ifdef HAVE_truncqipqi2\n-      if (HAVE_truncqipqi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncqipqi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif /* HAVE_truncqipqi2 */\n-      abort ();\n-    }\n-\n-  if (from_mode == PQImode)\n-    {\n-      if (to_mode != QImode)\n-\t{\n-\t  from = convert_to_mode (QImode, from, unsignedp);\n-\t  from_mode = QImode;\n-\t}\n-      else\n-\t{\n-#ifdef HAVE_extendpqiqi2\n-\t  if (HAVE_extendpqiqi2)\n-\t    {\n-\t      emit_unop_insn (CODE_FOR_extendpqiqi2, to, from, UNKNOWN);\n-\t      return;\n-\t    }\n-#endif /* HAVE_extendpqiqi2 */\n-\t  abort ();\n-\t}\n-    }\n-\n-  if (to_mode == PSImode)\n-    {\n-      if (from_mode != SImode)\n-\tfrom = convert_to_mode (SImode, from, unsignedp);\n-\n-#ifdef HAVE_truncsipsi2\n-      if (HAVE_truncsipsi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncsipsi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif /* HAVE_truncsipsi2 */\n-      abort ();\n-    }\n-\n-  if (from_mode == PSImode)\n-    {\n-      if (to_mode != SImode)\n-\t{\n-\t  from = convert_to_mode (SImode, from, unsignedp);\n-\t  from_mode = SImode;\n-\t}\n-      else\n-\t{\n-#ifdef HAVE_extendpsisi2\n-\t  if (! unsignedp && HAVE_extendpsisi2)\n-\t    {\n-\t      emit_unop_insn (CODE_FOR_extendpsisi2, to, from, UNKNOWN);\n-\t      return;\n-\t    }\n-#endif /* HAVE_extendpsisi2 */\n-#ifdef HAVE_zero_extendpsisi2\n-\t  if (unsignedp && HAVE_zero_extendpsisi2)\n-\t    {\n-\t      emit_unop_insn (CODE_FOR_zero_extendpsisi2, to, from, UNKNOWN);\n-\t      return;\n-\t    }\n-#endif /* HAVE_zero_extendpsisi2 */\n-\t  abort ();\n-\t}\n-    }\n-\n-  if (to_mode == PDImode)\n-    {\n-      if (from_mode != DImode)\n-\tfrom = convert_to_mode (DImode, from, unsignedp);\n-\n-#ifdef HAVE_truncdipdi2\n-      if (HAVE_truncdipdi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdipdi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif /* HAVE_truncdipdi2 */\n-      abort ();\n-    }\n-\n-  if (from_mode == PDImode)\n-    {\n-      if (to_mode != DImode)\n-\t{\n-\t  from = convert_to_mode (DImode, from, unsignedp);\n-\t  from_mode = DImode;\n-\t}\n-      else\n-\t{\n-#ifdef HAVE_extendpdidi2\n-\t  if (HAVE_extendpdidi2)\n-\t    {\n-\t      emit_unop_insn (CODE_FOR_extendpdidi2, to, from, UNKNOWN);\n-\t      return;\n-\t    }\n-#endif /* HAVE_extendpdidi2 */\n-\t  abort ();\n-\t}\n-    }\n-\n   /* Now follow all the conversions between integers\n      no more than a word long.  */\n \n@@ -1158,140 +865,20 @@ convert_move (rtx to, rtx from, int unsignedp)\n     }\n \n   /* Support special truncate insns for certain modes.  */\n-\n-  if (from_mode == DImode && to_mode == SImode)\n+  if (trunc_optab->handlers[to_mode][from_mode].insn_code != CODE_FOR_nothing)\n     {\n-#ifdef HAVE_truncdisi2\n-      if (HAVE_truncdisi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdisi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == DImode && to_mode == HImode)\n-    {\n-#ifdef HAVE_truncdihi2\n-      if (HAVE_truncdihi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdihi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == DImode && to_mode == QImode)\n-    {\n-#ifdef HAVE_truncdiqi2\n-      if (HAVE_truncdiqi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncdiqi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == SImode && to_mode == HImode)\n-    {\n-#ifdef HAVE_truncsihi2\n-      if (HAVE_truncsihi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncsihi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == SImode && to_mode == QImode)\n-    {\n-#ifdef HAVE_truncsiqi2\n-      if (HAVE_truncsiqi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_truncsiqi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == HImode && to_mode == QImode)\n-    {\n-#ifdef HAVE_trunchiqi2\n-      if (HAVE_trunchiqi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunchiqi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == TImode && to_mode == DImode)\n-    {\n-#ifdef HAVE_trunctidi2\n-      if (HAVE_trunctidi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctidi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == TImode && to_mode == SImode)\n-    {\n-#ifdef HAVE_trunctisi2\n-      if (HAVE_trunctisi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctisi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == TImode && to_mode == HImode)\n-    {\n-#ifdef HAVE_trunctihi2\n-      if (HAVE_trunctihi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctihi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n-      return;\n-    }\n-\n-  if (from_mode == TImode && to_mode == QImode)\n-    {\n-#ifdef HAVE_trunctiqi2\n-      if (HAVE_trunctiqi2)\n-\t{\n-\t  emit_unop_insn (CODE_FOR_trunctiqi2, to, from, UNKNOWN);\n-\t  return;\n-\t}\n-#endif\n-      convert_move (to, force_reg (from_mode, from), unsignedp);\n+      emit_unop_insn (trunc_optab->handlers[to_mode][from_mode].insn_code,\n+\t\t      to, from, UNKNOWN);\n       return;\n     }\n \n   /* Handle truncation of volatile memrefs, and so on;\n      the things that couldn't be truncated directly,\n-     and for which there was no special instruction.  */\n+     and for which there was no special instruction.\n+\n+     ??? Code above formerly short-circuited this, for most integer\n+     mode pairs, with a force_reg in from_mode followed by a recursive\n+     call to this routine.  Appears always to have been wrong.  */\n   if (GET_MODE_BITSIZE (to_mode) < GET_MODE_BITSIZE (from_mode))\n     {\n       rtx temp = force_reg (to_mode, gen_lowpart (to_mode, from));"}, {"sha": "cded6e3e0a3f12b36e83966ae7fbf32a0a46cab9", "filename": "gcc/genopinit.c", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -59,32 +59,33 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    upper-case forms of the comparison, respectively.  */\n \n static const char * const optabs[] =\n-{ \"extendtab[$B][$A][0] = CODE_FOR_$(extend$a$b2$)\",\n-  \"extendtab[$B][$A][1] = CODE_FOR_$(zero_extend$a$b2$)\",\n-  \"fixtab[$A][$B][0] = CODE_FOR_$(fix$F$a$I$b2$)\",\n-  \"fixtab[$A][$B][1] = CODE_FOR_$(fixuns$F$a$b2$)\",\n-  \"fixtrunctab[$A][$B][0] = CODE_FOR_$(fix_trunc$F$a$I$b2$)\",\n-  \"fixtrunctab[$A][$B][1] = CODE_FOR_$(fixuns_trunc$F$a$I$b2$)\",\n-  \"floattab[$B][$A][0] = CODE_FOR_$(float$I$a$F$b2$)\",\n-  \"floattab[$B][$A][1] = CODE_FOR_$(floatuns$I$a$F$b2$)\",\n+{ \"sext_optab->handlers[$B][$A].insn_code = CODE_FOR_$(extend$a$b2$)\",\n+  \"zext_optab->handlers[$B][$A].insn_code = CODE_FOR_$(zero_extend$a$b2$)\",\n+  \"sfix_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fix$F$a$I$b2$)\",\n+  \"ufix_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fixuns$F$a$b2$)\",\n+  \"sfixtrunc_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fix_trunc$F$a$I$b2$)\",\n+  \"ufixtrunc_optab->handlers[$B][$A].insn_code = CODE_FOR_$(fixuns_trunc$F$a$I$b2$)\",\n+  \"sfloat_optab->handlers[$B][$A].insn_code = CODE_FOR_$(float$I$a$F$b2$)\",\n+  \"ufloat_optab->handlers[$B][$A].insn_code = CODE_FOR_$(floatuns$I$a$F$b2$)\",\n+  \"trunc_optab->handlers[$B][$A].insn_code = CODE_FOR_$(trunc$a$b2$)\",\n   \"add_optab->handlers[$A].insn_code = CODE_FOR_$(add$P$a3$)\",\n-  \"addv_optab->handlers[(int) $A].insn_code =\\n\\\n-    add_optab->handlers[(int) $A].insn_code = CODE_FOR_$(add$F$a3$)\",\n-  \"addv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(addv$I$a3$)\",\n+  \"addv_optab->handlers[$A].insn_code =\\n\\\n+    add_optab->handlers[$A].insn_code = CODE_FOR_$(add$F$a3$)\",\n+  \"addv_optab->handlers[$A].insn_code = CODE_FOR_$(addv$I$a3$)\",\n   \"sub_optab->handlers[$A].insn_code = CODE_FOR_$(sub$P$a3$)\",\n-  \"subv_optab->handlers[(int) $A].insn_code =\\n\\\n-    sub_optab->handlers[(int) $A].insn_code = CODE_FOR_$(sub$F$a3$)\",\n-  \"subv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(subv$I$a3$)\",\n+  \"subv_optab->handlers[$A].insn_code =\\n\\\n+    sub_optab->handlers[$A].insn_code = CODE_FOR_$(sub$F$a3$)\",\n+  \"subv_optab->handlers[$A].insn_code = CODE_FOR_$(subv$I$a3$)\",\n   \"smul_optab->handlers[$A].insn_code = CODE_FOR_$(mul$P$a3$)\",\n-  \"smulv_optab->handlers[(int) $A].insn_code =\\n\\\n-    smul_optab->handlers[(int) $A].insn_code = CODE_FOR_$(mul$F$a3$)\",\n-  \"smulv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(mulv$I$a3$)\",\n+  \"smulv_optab->handlers[$A].insn_code =\\n\\\n+    smul_optab->handlers[$A].insn_code = CODE_FOR_$(mul$F$a3$)\",\n+  \"smulv_optab->handlers[$A].insn_code = CODE_FOR_$(mulv$I$a3$)\",\n   \"umul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(umul$a3_highpart$)\",\n   \"smul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(smul$a3_highpart$)\",\n   \"smul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(mul$a$b3$)$N\",\n   \"umul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(umul$a$b3$)$N\",\n   \"sdiv_optab->handlers[$A].insn_code = CODE_FOR_$(div$a3$)\",\n-  \"sdivv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(div$V$I$a3$)\",\n+  \"sdivv_optab->handlers[$A].insn_code = CODE_FOR_$(div$V$I$a3$)\",\n   \"udiv_optab->handlers[$A].insn_code = CODE_FOR_$(udiv$I$a3$)\",\n   \"sdivmod_optab->handlers[$A].insn_code = CODE_FOR_$(divmod$a4$)\",\n   \"udivmod_optab->handlers[$A].insn_code = CODE_FOR_$(udivmod$a4$)\",\n@@ -108,13 +109,13 @@ static const char * const optabs[] =\n   \"pow_optab->handlers[$A].insn_code = CODE_FOR_$(pow$a3$)\",\n   \"atan2_optab->handlers[$A].insn_code = CODE_FOR_$(atan2$a3$)\",\n   \"neg_optab->handlers[$A].insn_code = CODE_FOR_$(neg$P$a2$)\",\n-  \"negv_optab->handlers[(int) $A].insn_code =\\n\\\n-    neg_optab->handlers[(int) $A].insn_code = CODE_FOR_$(neg$F$a2$)\",\n-  \"negv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(negv$I$a2$)\",\n+  \"negv_optab->handlers[$A].insn_code =\\n\\\n+    neg_optab->handlers[$A].insn_code = CODE_FOR_$(neg$F$a2$)\",\n+  \"negv_optab->handlers[$A].insn_code = CODE_FOR_$(negv$I$a2$)\",\n   \"abs_optab->handlers[$A].insn_code = CODE_FOR_$(abs$P$a2$)\",\n-  \"absv_optab->handlers[(int) $A].insn_code =\\n\\\n-    abs_optab->handlers[(int) $A].insn_code = CODE_FOR_$(abs$F$a2$)\",\n-  \"absv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(absv$I$a2$)\",\n+  \"absv_optab->handlers[$A].insn_code =\\n\\\n+    abs_optab->handlers[$A].insn_code = CODE_FOR_$(abs$F$a2$)\",\n+  \"absv_optab->handlers[$A].insn_code = CODE_FOR_$(absv$I$a2$)\",\n   \"sqrt_optab->handlers[$A].insn_code = CODE_FOR_$(sqrt$a2$)\",\n   \"floor_optab->handlers[$A].insn_code = CODE_FOR_$(floor$a2$)\",\n   \"ceil_optab->handlers[$A].insn_code = CODE_FOR_$(ceil$a2$)\",\n@@ -229,7 +230,7 @@ gen_insn (rtx insn)\n                    look through the modes in reverse order, in case\n                    EXTRA_CC_MODES was used and CC is a prefix of the\n                    CC modes (as it should be).  */\n-\t\tfor (i = ((int) MAX_MACHINE_MODE) - 1; i >= 0; i--)\n+\t\tfor (i = (MAX_MACHINE_MODE) - 1; i >= 0; i--)\n \t\t  {\n \t\t    for (p = GET_MODE_NAME(i), q = np; *p; p++, q++)\n \t\t      if (TOLOWER (*p) != *q)\n@@ -303,16 +304,15 @@ gen_insn (rtx insn)\n \t      putchar (TOLOWER (*np));\n \t    break;\n \t  case 'A':\n-\t    printf (\"(int) %smode\", GET_MODE_NAME(m1));\n+\t    printf (\"%smode\", GET_MODE_NAME(m1));\n \t    break;\n \t  case 'B':\n-\t    printf (\"(int) %smode\", GET_MODE_NAME(m2));\n+\t    printf (\"%smode\", GET_MODE_NAME(m2));\n \t    break;\n \t  case 'c':\n \t    printf (\"%s\", GET_RTX_NAME(op));\n \t    break;\n \t  case 'C':\n-\t    printf (\"(int) \");\n \t    for (np = GET_RTX_NAME(op); *np; np++)\n \t      putchar (TOUPPER (*np));\n \t    break;\n@@ -368,7 +368,17 @@ from the machine description file `md'.  */\\n\\n\");\n \tgen_insn (desc);\n     }\n \n-  printf (\"}\\n\");\n+  puts (\"\\\n+\\n\\\n+#ifdef FIXUNS_TRUNC_LIKE_FIX_TRUNC\\n\\\n+  /* This flag says the same insns that convert to a signed fixnum\\n\\\n+     also convert validly to an unsigned one.  */\\n\\\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\\n\\\n+    for (j = 0; j < NUM_MACHINE_MODES; j++)\\n\\\n+      ufixtrunc_optab->handlers[i][j].insn_code\\n\\\n+      = sfixtrunc_optab->handlers[i][j].insn_code;\\n\\\n+#endif\\n\\\n+}\");\n \n   fflush (stdout);\n   return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);"}, {"sha": "d4bd644f108d7a82eced5fb4a16bc7479a918ae8", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -24,18 +24,6 @@ Boston, MA 02111-1307, USA.  */\n /* Enumeration of indexes into libfunc_table.  */\n enum libfunc_index\n {\n-  LTI_extendsfdf2,\n-  LTI_extendsfxf2,\n-  LTI_extendsftf2,\n-  LTI_extenddfxf2,\n-  LTI_extenddftf2,\n-\n-  LTI_truncdfsf2,\n-  LTI_truncxfsf2,\n-  LTI_trunctfsf2,\n-  LTI_truncxfdf2,\n-  LTI_trunctfdf2,\n-\n   LTI_abort,\n   LTI_memcpy,\n   LTI_memmove,\n@@ -53,54 +41,6 @@ enum libfunc_index\n   LTI_unwind_sjlj_register,\n   LTI_unwind_sjlj_unregister,\n \n-  LTI_floatsisf,\n-  LTI_floatdisf,\n-  LTI_floattisf,\n-\n-  LTI_floatsidf,\n-  LTI_floatdidf,\n-  LTI_floattidf,\n-\n-  LTI_floatsixf,\n-  LTI_floatdixf,\n-  LTI_floattixf,\n-\n-  LTI_floatsitf,\n-  LTI_floatditf,\n-  LTI_floattitf,\n-\n-  LTI_fixsfsi,\n-  LTI_fixsfdi,\n-  LTI_fixsfti,\n-\n-  LTI_fixdfsi,\n-  LTI_fixdfdi,\n-  LTI_fixdfti,\n-\n-  LTI_fixxfsi,\n-  LTI_fixxfdi,\n-  LTI_fixxfti,\n-\n-  LTI_fixtfsi,\n-  LTI_fixtfdi,\n-  LTI_fixtfti,\n-\n-  LTI_fixunssfsi,\n-  LTI_fixunssfdi,\n-  LTI_fixunssfti,\n-\n-  LTI_fixunsdfsi,\n-  LTI_fixunsdfdi,\n-  LTI_fixunsdfti,\n-\n-  LTI_fixunsxfsi,\n-  LTI_fixunsxfdi,\n-  LTI_fixunsxfti,\n-\n-  LTI_fixunstfsi,\n-  LTI_fixunstfdi,\n-  LTI_fixunstfti,\n-\n   LTI_profile_function_entry,\n   LTI_profile_function_exit,\n \n@@ -115,17 +55,6 @@ enum libfunc_index\n extern GTY(()) rtx libfunc_table[LTI_MAX];\n \n /* Accessor macros for libfunc_table.  */\n-#define extendsfdf2_libfunc\t(libfunc_table[LTI_extendsfdf2])\n-#define extendsfxf2_libfunc\t(libfunc_table[LTI_extendsfxf2])\n-#define extendsftf2_libfunc\t(libfunc_table[LTI_extendsftf2])\n-#define extenddfxf2_libfunc\t(libfunc_table[LTI_extenddfxf2])\n-#define extenddftf2_libfunc\t(libfunc_table[LTI_extenddftf2])\n-\n-#define truncdfsf2_libfunc\t(libfunc_table[LTI_truncdfsf2])\n-#define truncxfsf2_libfunc\t(libfunc_table[LTI_truncxfsf2])\n-#define trunctfsf2_libfunc\t(libfunc_table[LTI_trunctfsf2])\n-#define truncxfdf2_libfunc\t(libfunc_table[LTI_truncxfdf2])\n-#define trunctfdf2_libfunc\t(libfunc_table[LTI_trunctfdf2])\n \n #define abort_libfunc\t(libfunc_table[LTI_abort])\n #define memcpy_libfunc\t(libfunc_table[LTI_memcpy])\n@@ -145,54 +74,6 @@ extern GTY(()) rtx libfunc_table[LTI_MAX];\n #define unwind_sjlj_unregister_libfunc \\\n   (libfunc_table[LTI_unwind_sjlj_unregister])\n \n-#define floatsisf_libfunc\t(libfunc_table[LTI_floatsisf])\n-#define floatdisf_libfunc\t(libfunc_table[LTI_floatdisf])\n-#define floattisf_libfunc\t(libfunc_table[LTI_floattisf])\n-\n-#define floatsidf_libfunc\t(libfunc_table[LTI_floatsidf])\n-#define floatdidf_libfunc\t(libfunc_table[LTI_floatdidf])\n-#define floattidf_libfunc\t(libfunc_table[LTI_floattidf])\n-\n-#define floatsixf_libfunc\t(libfunc_table[LTI_floatsixf])\n-#define floatdixf_libfunc\t(libfunc_table[LTI_floatdixf])\n-#define floattixf_libfunc\t(libfunc_table[LTI_floattixf])\n-\n-#define floatsitf_libfunc\t(libfunc_table[LTI_floatsitf])\n-#define floatditf_libfunc\t(libfunc_table[LTI_floatditf])\n-#define floattitf_libfunc\t(libfunc_table[LTI_floattitf])\n-\n-#define fixsfsi_libfunc\t(libfunc_table[LTI_fixsfsi])\n-#define fixsfdi_libfunc\t(libfunc_table[LTI_fixsfdi])\n-#define fixsfti_libfunc\t(libfunc_table[LTI_fixsfti])\n-\n-#define fixdfsi_libfunc\t(libfunc_table[LTI_fixdfsi])\n-#define fixdfdi_libfunc\t(libfunc_table[LTI_fixdfdi])\n-#define fixdfti_libfunc\t(libfunc_table[LTI_fixdfti])\n-\n-#define fixxfsi_libfunc\t(libfunc_table[LTI_fixxfsi])\n-#define fixxfdi_libfunc\t(libfunc_table[LTI_fixxfdi])\n-#define fixxfti_libfunc\t(libfunc_table[LTI_fixxfti])\n-\n-#define fixtfsi_libfunc\t(libfunc_table[LTI_fixtfsi])\n-#define fixtfdi_libfunc\t(libfunc_table[LTI_fixtfdi])\n-#define fixtfti_libfunc\t(libfunc_table[LTI_fixtfti])\n-\n-#define fixunssfsi_libfunc\t(libfunc_table[LTI_fixunssfsi])\n-#define fixunssfdi_libfunc\t(libfunc_table[LTI_fixunssfdi])\n-#define fixunssfti_libfunc\t(libfunc_table[LTI_fixunssfti])\n-\n-#define fixunsdfsi_libfunc\t(libfunc_table[LTI_fixunsdfsi])\n-#define fixunsdfdi_libfunc\t(libfunc_table[LTI_fixunsdfdi])\n-#define fixunsdfti_libfunc\t(libfunc_table[LTI_fixunsdfti])\n-\n-#define fixunsxfsi_libfunc\t(libfunc_table[LTI_fixunsxfsi])\n-#define fixunsxfdi_libfunc\t(libfunc_table[LTI_fixunsxfdi])\n-#define fixunsxfti_libfunc\t(libfunc_table[LTI_fixunsxfti])\n-\n-#define fixunstfsi_libfunc\t(libfunc_table[LTI_fixunstfsi])\n-#define fixunstfdi_libfunc\t(libfunc_table[LTI_fixunstfdi])\n-#define fixunstfti_libfunc\t(libfunc_table[LTI_fixunstfti])\n-\n #define profile_function_entry_libfunc\t(libfunc_table[LTI_profile_function_entry])\n #define profile_function_exit_libfunc\t(libfunc_table[LTI_profile_function_exit])\n "}, {"sha": "bd1bf39637fca80746dd16849dd697234a3996d0", "filename": "gcc/optabs.c", "status": "modified", "additions": 225, "deletions": 210, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -58,13 +58,8 @@ optab optab_table[OTI_MAX];\n \n rtx libfunc_table[LTI_MAX];\n \n-/* Tables of patterns for extending one integer mode to another.  */\n-enum insn_code extendtab[MAX_MACHINE_MODE][MAX_MACHINE_MODE][2];\n-\n-/* Tables of patterns for converting between fixed and floating point.  */\n-enum insn_code fixtab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n-enum insn_code fixtrunctab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n-enum insn_code floattab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n+/* Tables of patterns for converting one mode to another.  */\n+convert_optab convert_optab_table[CTI_MAX];\n \n /* Contains the optab used for each rtx code.  */\n optab code_to_optab[NUM_RTX_CODE + 1];\n@@ -112,11 +107,17 @@ static enum insn_code can_fix_p (enum machine_mode, enum machine_mode, int,\n static enum insn_code can_float_p (enum machine_mode, enum machine_mode, int);\n static rtx ftruncify (rtx);\n static optab new_optab (void);\n+static convert_optab new_convert_optab (void);\n static inline optab init_optab (enum rtx_code);\n static inline optab init_optabv (enum rtx_code);\n+static inline convert_optab init_convert_optab (enum rtx_code);\n static void init_libfuncs (optab, int, int, const char *, int);\n static void init_integral_libfuncs (optab, const char *, int);\n static void init_floating_libfuncs (optab, const char *, int);\n+static void init_interclass_conv_libfuncs (convert_optab, const char *,\n+\t\t\t\t\t   enum mode_class, enum mode_class);\n+static void init_intraclass_conv_libfuncs (convert_optab, const char *,\n+\t\t\t\t\t   enum mode_class, bool);\n static void emit_cmp_and_jump_insn_1 (rtx, rtx, enum machine_mode,\n \t\t\t\t      enum rtx_code, int, rtx);\n static void prepare_float_lib_cmp (rtx *, rtx *, enum rtx_code *,\n@@ -4421,12 +4422,14 @@ enum insn_code\n can_extend_p (enum machine_mode to_mode, enum machine_mode from_mode,\n \t      int unsignedp)\n {\n+  convert_optab tab;\n #ifdef HAVE_ptr_extend\n   if (unsignedp < 0)\n     return CODE_FOR_ptr_extend;\n-  else\n #endif\n-    return extendtab[(int) to_mode][(int) from_mode][unsignedp != 0];\n+\n+  tab = unsignedp ? zext_optab : sext_optab;\n+  return tab->handlers[to_mode][from_mode].insn_code;\n }\n \n /* Generate the body of an insn to extend Y (with mode MFROM)\n@@ -4436,7 +4439,8 @@ rtx\n gen_extend_insn (rtx x, rtx y, enum machine_mode mto,\n \t\t enum machine_mode mfrom, int unsignedp)\n {\n-  return (GEN_FCN (extendtab[(int) mto][(int) mfrom][unsignedp != 0]) (x, y));\n+  enum insn_code icode = can_extend_p (mto, mfrom, unsignedp);\n+  return GEN_FCN (icode) (x, y);\n }\n \f\n /* can_fix_p and can_float_p say whether the target machine\n@@ -4452,24 +4456,38 @@ static enum insn_code\n can_fix_p (enum machine_mode fixmode, enum machine_mode fltmode,\n \t   int unsignedp, int *truncp_ptr)\n {\n-  *truncp_ptr = 0;\n-  if (fixtrunctab[(int) fltmode][(int) fixmode][unsignedp != 0]\n-      != CODE_FOR_nothing)\n-    return fixtrunctab[(int) fltmode][(int) fixmode][unsignedp != 0];\n+  convert_optab tab;\n+  enum insn_code icode;\n+\n+  tab = unsignedp ? ufixtrunc_optab : sfixtrunc_optab;\n+  icode = tab->handlers[fixmode][fltmode].insn_code;\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      *truncp_ptr = 0;\n+      return icode;\n+    }\n \n-  if (ftrunc_optab->handlers[(int) fltmode].insn_code != CODE_FOR_nothing)\n+  tab = unsignedp ? ufix_optab : sfix_optab;\n+  icode = tab->handlers[fixmode][fltmode].insn_code;\n+  if (icode != CODE_FOR_nothing\n+      && ftrunc_optab->handlers[fltmode].insn_code != CODE_FOR_nothing)\n     {\n       *truncp_ptr = 1;\n-      return fixtab[(int) fltmode][(int) fixmode][unsignedp != 0];\n+      return icode;\n     }\n+\n+  *truncp_ptr = 0;\n   return CODE_FOR_nothing;\n }\n \n static enum insn_code\n can_float_p (enum machine_mode fltmode, enum machine_mode fixmode,\n \t     int unsignedp)\n {\n-  return floattab[(int) fltmode][(int) fixmode][unsignedp != 0];\n+  convert_optab tab;\n+\n+  tab = unsignedp ? ufloat_optab : sfloat_optab;\n+  return tab->handlers[fltmode][fixmode].insn_code;\n }\n \f\n /* Generate code to convert FROM to floating point\n@@ -4642,12 +4660,12 @@ expand_float (rtx to, rtx from, int unsignedp)\n       goto done;\n     }\n \n-  /* No hardware instruction available; call a library routine to convert from\n-     SImode, DImode, or TImode into SFmode, DFmode, XFmode, or TFmode.  */\n+  /* No hardware instruction available; call a library routine.  */\n     {\n-      rtx libfcn;\n+      rtx libfunc;\n       rtx insns;\n       rtx value;\n+      convert_optab tab = unsignedp ? ufloat_optab : sfloat_optab;\n \n       to = protect_from_queue (to, 1);\n       from = protect_from_queue (from, 0);\n@@ -4658,56 +4676,13 @@ expand_float (rtx to, rtx from, int unsignedp)\n       if (flag_force_mem)\n \tfrom = force_not_mem (from);\n \n-      if (GET_MODE (to) == SFmode)\n-\t{\n-\t  if (GET_MODE (from) == SImode)\n-\t    libfcn = floatsisf_libfunc;\n-\t  else if (GET_MODE (from) == DImode)\n-\t    libfcn = floatdisf_libfunc;\n-\t  else if (GET_MODE (from) == TImode)\n-\t    libfcn = floattisf_libfunc;\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_MODE (to) == DFmode)\n-\t{\n-\t  if (GET_MODE (from) == SImode)\n-\t    libfcn = floatsidf_libfunc;\n-\t  else if (GET_MODE (from) == DImode)\n-\t    libfcn = floatdidf_libfunc;\n-\t  else if (GET_MODE (from) == TImode)\n-\t    libfcn = floattidf_libfunc;\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_MODE (to) == XFmode)\n-\t{\n-\t  if (GET_MODE (from) == SImode)\n-\t    libfcn = floatsixf_libfunc;\n-\t  else if (GET_MODE (from) == DImode)\n-\t    libfcn = floatdixf_libfunc;\n-\t  else if (GET_MODE (from) == TImode)\n-\t    libfcn = floattixf_libfunc;\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_MODE (to) == TFmode)\n-\t{\n-\t  if (GET_MODE (from) == SImode)\n-\t    libfcn = floatsitf_libfunc;\n-\t  else if (GET_MODE (from) == DImode)\n-\t    libfcn = floatditf_libfunc;\n-\t  else if (GET_MODE (from) == TImode)\n-\t    libfcn = floattitf_libfunc;\n-\t  else\n-\t    abort ();\n-\t}\n-      else\n+      libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n+      if (!libfunc)\n \tabort ();\n \n       start_sequence ();\n \n-      value = emit_library_call_value (libfcn, NULL_RTX, LCT_CONST,\n+      value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n \t\t\t\t       GET_MODE (to), 1, from,\n \t\t\t\t       GET_MODE (from));\n       insns = get_insns ();\n@@ -4748,7 +4723,6 @@ expand_fix (rtx to, rtx from, int unsignedp)\n   rtx target = to;\n   enum machine_mode fmode, imode;\n   int must_trunc = 0;\n-  rtx libfcn = 0;\n \n   /* We first try to find a pair of modes, one real and one integer, at\n      least as wide as FROM and TO, respectively, in which we can open-code\n@@ -4889,57 +4863,16 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n       expand_fix (target, from, unsignedp);\n     }\n-  else if (GET_MODE (from) == SFmode)\n-    {\n-      if (GET_MODE (to) == SImode)\n-\tlibfcn = unsignedp ? fixunssfsi_libfunc : fixsfsi_libfunc;\n-      else if (GET_MODE (to) == DImode)\n-\tlibfcn = unsignedp ? fixunssfdi_libfunc : fixsfdi_libfunc;\n-      else if (GET_MODE (to) == TImode)\n-\tlibfcn = unsignedp ? fixunssfti_libfunc : fixsfti_libfunc;\n-      else\n-\tabort ();\n-    }\n-  else if (GET_MODE (from) == DFmode)\n-    {\n-      if (GET_MODE (to) == SImode)\n-\tlibfcn = unsignedp ? fixunsdfsi_libfunc : fixdfsi_libfunc;\n-      else if (GET_MODE (to) == DImode)\n-\tlibfcn = unsignedp ? fixunsdfdi_libfunc : fixdfdi_libfunc;\n-      else if (GET_MODE (to) == TImode)\n-\tlibfcn = unsignedp ? fixunsdfti_libfunc : fixdfti_libfunc;\n-      else\n-\tabort ();\n-    }\n-  else if (GET_MODE (from) == XFmode)\n-    {\n-      if (GET_MODE (to) == SImode)\n-\tlibfcn = unsignedp ? fixunsxfsi_libfunc : fixxfsi_libfunc;\n-      else if (GET_MODE (to) == DImode)\n-\tlibfcn = unsignedp ? fixunsxfdi_libfunc : fixxfdi_libfunc;\n-      else if (GET_MODE (to) == TImode)\n-\tlibfcn = unsignedp ? fixunsxfti_libfunc : fixxfti_libfunc;\n-      else\n-\tabort ();\n-    }\n-  else if (GET_MODE (from) == TFmode)\n-    {\n-      if (GET_MODE (to) == SImode)\n-\tlibfcn = unsignedp ? fixunstfsi_libfunc : fixtfsi_libfunc;\n-      else if (GET_MODE (to) == DImode)\n-\tlibfcn = unsignedp ? fixunstfdi_libfunc : fixtfdi_libfunc;\n-      else if (GET_MODE (to) == TImode)\n-\tlibfcn = unsignedp ? fixunstfti_libfunc : fixtfti_libfunc;\n-      else\n-\tabort ();\n-    }\n   else\n-    abort ();\n-\n-  if (libfcn)\n     {\n       rtx insns;\n       rtx value;\n+      rtx libfunc;\n+      \n+      convert_optab tab = unsignedp ? ufix_optab : sfix_optab;\n+      libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n+      if (!libfunc)\n+\tabort ();\n \n       to = protect_from_queue (to, 1);\n       from = protect_from_queue (from, 0);\n@@ -4949,7 +4882,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n       start_sequence ();\n \n-      value = emit_library_call_value (libfcn, NULL_RTX, LCT_CONST,\n+      value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n \t\t\t\t       GET_MODE (to), 1, from,\n \t\t\t\t       GET_MODE (from));\n       insns = get_insns ();\n@@ -4994,6 +4927,20 @@ new_optab (void)\n   return op;\n }\n \n+static convert_optab\n+new_convert_optab (void)\n+{\n+  int i, j;\n+  convert_optab op = ggc_alloc (sizeof (struct convert_optab));\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    for (j = 0; j < NUM_MACHINE_MODES; j++)\n+      {\n+\top->handlers[i][j].insn_code = CODE_FOR_nothing;\n+\top->handlers[i][j].libfunc = 0;\n+      }\n+  return op;\n+}\n+\n /* Same, but fill in its code as CODE, and write it into the\n    code_to_optab table.  */\n static inline optab\n@@ -5015,6 +4962,15 @@ init_optabv (enum rtx_code code)\n   return op;\n }\n \n+/* Conversion optabs never go in the code_to_optab table.  */\n+static inline convert_optab\n+init_convert_optab (enum rtx_code code)\n+{\n+  convert_optab op = new_convert_optab ();\n+  op->code = code;\n+  return op;\n+}\n+\n /* Initialize the libfunc fields of an entire group of entries in some\n    optab.  Each entry is set equal to a string consisting of a leading\n    pair of underscores followed by a generic operation name followed by\n@@ -5101,6 +5057,119 @@ init_floating_libfuncs (optab optable, const char *opname, int suffix)\n     init_libfuncs (optable, lmode, lmode, opname, suffix);\n }\n \n+/* Initialize the libfunc fields of an entire group of entries of an\n+   inter-mode-class conversion optab.  The string formation rules are\n+   similar to the ones for init_libfuncs, above, but instead of having\n+   a mode name and an operand count these functions have two mode names\n+   and no operand count.  */\n+static void\n+init_interclass_conv_libfuncs (convert_optab tab, const char *opname,\n+\t\t\t       enum mode_class from_class,\n+\t\t\t       enum mode_class to_class)\n+{\n+  enum machine_mode first_from_mode = GET_CLASS_NARROWEST_MODE (from_class);\n+  enum machine_mode first_to_mode = GET_CLASS_NARROWEST_MODE (to_class);\n+  size_t opname_len = strlen (opname);\n+  size_t max_mname_len = 0;\n+\n+  enum machine_mode fmode, tmode;\n+  const char *fname, *tname;\n+  const char *q;\n+  char *libfunc_name, *suffix;\n+  char *p;\n+\n+  for (fmode = first_from_mode;\n+       fmode != VOIDmode;\n+       fmode = GET_MODE_WIDER_MODE (fmode))\n+    max_mname_len = MAX (max_mname_len, strlen (GET_MODE_NAME (fmode)));\n+\n+  for (tmode = first_to_mode;\n+       tmode != VOIDmode;\n+       tmode = GET_MODE_WIDER_MODE (tmode))\n+    max_mname_len = MAX (max_mname_len, strlen (GET_MODE_NAME (tmode)));\n+\n+  libfunc_name = alloca (2 + opname_len + 2*max_mname_len + 1 + 1);\n+  libfunc_name[0] = '_';\n+  libfunc_name[1] = '_';\n+  memcpy (&libfunc_name[2], opname, opname_len);\n+  suffix = libfunc_name + opname_len + 2;\n+\n+  for (fmode = first_from_mode; fmode != VOIDmode;\n+       fmode = GET_MODE_WIDER_MODE (fmode))\n+    for (tmode = first_to_mode; tmode != VOIDmode;\n+\t tmode = GET_MODE_WIDER_MODE (tmode))\n+      {\n+\tfname = GET_MODE_NAME (fmode);\n+\ttname = GET_MODE_NAME (tmode);\n+\n+\tp = suffix;\n+\tfor (q = fname; *q; p++, q++)\n+\t  *p = TOLOWER (*q);\n+\tfor (q = tname; *q; p++, q++)\n+\t  *p = TOLOWER (*q);\n+\n+\t*p = '\\0';\n+\n+\ttab->handlers[tmode][fmode].libfunc\n+\t  = init_one_libfunc (ggc_alloc_string (libfunc_name,\n+\t\t\t\t\t\tp - libfunc_name));\n+      }\n+}\n+\n+/* Initialize the libfunc fields of an entire group of entries of an\n+   intra-mode-class conversion optab.  The string formation rules are\n+   similar to the ones for init_libfunc, above.  WIDENING says whether\n+   the optab goes from narrow to wide modes or vice versa.  These functions\n+   have two mode names _and_ an operand count.  */\n+static void\n+init_intraclass_conv_libfuncs (convert_optab tab, const char *opname,\n+\t\t\t       enum mode_class class, bool widening)\n+{\n+  enum machine_mode first_mode = GET_CLASS_NARROWEST_MODE (class);\n+  size_t opname_len = strlen (opname);\n+  size_t max_mname_len = 0;\n+\n+  enum machine_mode nmode, wmode;\n+  const char *nname, *wname;\n+  const char *q;\n+  char *libfunc_name, *suffix;\n+  char *p;\n+\n+  for (nmode = first_mode; nmode != VOIDmode;\n+       nmode = GET_MODE_WIDER_MODE (nmode))\n+    max_mname_len = MAX (max_mname_len, strlen (GET_MODE_NAME (nmode)));\n+\n+  libfunc_name = alloca (2 + opname_len + 2*max_mname_len + 1 + 1);\n+  libfunc_name[0] = '_';\n+  libfunc_name[1] = '_';\n+  memcpy (&libfunc_name[2], opname, opname_len);\n+  suffix = libfunc_name + opname_len + 2;\n+\n+  for (nmode = first_mode; nmode != VOIDmode;\n+       nmode = GET_MODE_WIDER_MODE (nmode))\n+    for (wmode = GET_MODE_WIDER_MODE (nmode); wmode != VOIDmode;\n+\t wmode = GET_MODE_WIDER_MODE (wmode))\n+      {\n+\tnname = GET_MODE_NAME (nmode);\n+\twname = GET_MODE_NAME (wmode);\n+\n+\tp = suffix;\n+\tfor (q = widening ? nname : wname; *q; p++, q++)\n+\t  *p = TOLOWER (*q);\n+\tfor (q = widening ? wname : nname; *q; p++, q++)\n+\t  *p = TOLOWER (*q);\n+\n+\t*p++ = '2';\n+\t*p = '\\0';\n+\n+\ttab->handlers[widening ? nmode : wmode]\n+\t             [widening ? wmode : nmode].libfunc\n+\t  = init_one_libfunc (ggc_alloc_string (libfunc_name,\n+\t\t\t\t\t\tp - libfunc_name));\n+      }\n+}\n+\n+\n rtx\n init_one_libfunc (const char *name)\n {\n@@ -5136,36 +5205,29 @@ set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n     optable->handlers[mode].libfunc = 0;\n }\n \n+/* Call this to reset the function entry for one conversion optab\n+   (OPTABLE) from mode FMODE to mode TMODE to NAME, which should be\n+   either 0 or a string constant.  */\n+void\n+set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n+\t\t  enum machine_mode fmode, const char *name)\n+{\n+  if (name)\n+    optable->handlers[tmode][fmode].libfunc = init_one_libfunc (name);\n+  else\n+    optable->handlers[tmode][fmode].libfunc = 0;\n+}\n+\n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n \n void\n init_optabs (void)\n {\n-  unsigned int i, j, k;\n+  unsigned int i;\n \n   /* Start by initializing all tables to contain CODE_FOR_nothing.  */\n \n-  for (i = 0; i < ARRAY_SIZE (fixtab); i++)\n-    for (j = 0; j < ARRAY_SIZE (fixtab[0]); j++)\n-      for (k = 0; k < ARRAY_SIZE (fixtab[0][0]); k++)\n-\tfixtab[i][j][k] = CODE_FOR_nothing;\n-\n-  for (i = 0; i < ARRAY_SIZE (fixtrunctab); i++)\n-    for (j = 0; j < ARRAY_SIZE (fixtrunctab[0]); j++)\n-      for (k = 0; k < ARRAY_SIZE (fixtrunctab[0][0]); k++)\n-\tfixtrunctab[i][j][k] = CODE_FOR_nothing;\n-\n-  for (i = 0; i < ARRAY_SIZE (floattab); i++)\n-    for (j = 0; j < ARRAY_SIZE (floattab[0]); j++)\n-      for (k = 0; k < ARRAY_SIZE (floattab[0][0]); k++)\n-\tfloattab[i][j][k] = CODE_FOR_nothing;\n-\n-  for (i = 0; i < ARRAY_SIZE (extendtab); i++)\n-    for (j = 0; j < ARRAY_SIZE (extendtab[0]); j++)\n-      for (k = 0; k < ARRAY_SIZE (extendtab[0][0]); k++)\n-\textendtab[i][j][k] = CODE_FOR_nothing;\n-\n   for (i = 0; i < NUM_RTX_CODE; i++)\n     setcc_gen_code[i] = CODE_FOR_nothing;\n \n@@ -5239,7 +5301,7 @@ init_optabs (void)\n   floor_optab = init_optab (UNKNOWN);\n   ceil_optab = init_optab (UNKNOWN);\n   round_optab = init_optab (UNKNOWN);\n-  trunc_optab = init_optab (UNKNOWN);\n+  btrunc_optab = init_optab (UNKNOWN);\n   nearbyint_optab = init_optab (UNKNOWN);\n   sin_optab = init_optab (UNKNOWN);\n   cos_optab = init_optab (UNKNOWN);\n@@ -5253,6 +5315,17 @@ init_optabs (void)\n   cstore_optab = init_optab (UNKNOWN);\n   push_optab = init_optab (UNKNOWN);\n \n+  /* Conversions.  */\n+  sext_optab = init_convert_optab (SIGN_EXTEND);\n+  zext_optab = init_convert_optab (ZERO_EXTEND);\n+  trunc_optab = init_convert_optab (TRUNCATE);\n+  sfix_optab = init_convert_optab (FIX);\n+  ufix_optab = init_convert_optab (UNSIGNED_FIX);\n+  sfixtrunc_optab = init_convert_optab (UNKNOWN);\n+  ufixtrunc_optab = init_convert_optab (UNKNOWN);\n+  sfloat_optab = init_convert_optab (FLOAT);\n+  ufloat_optab = init_convert_optab (UNSIGNED_FLOAT);\n+\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       movstr_optab[i] = CODE_FOR_nothing;\n@@ -5266,14 +5339,6 @@ init_optabs (void)\n   /* Fill in the optabs with the insns we support.  */\n   init_all_optabs ();\n \n-#ifdef FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-  /* This flag says the same insns that convert to a signed fixnum\n-     also convert validly to an unsigned one.  */\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    for (j = 0; j < NUM_MACHINE_MODES; j++)\n-      fixtrunctab[i][j][1] = fixtrunctab[i][j][0];\n-#endif\n-\n   /* Initialize the optabs with the names of the library functions.  */\n   init_integral_libfuncs (add_optab, \"add\", '3');\n   init_floating_libfuncs (add_optab, \"add\", '3');\n@@ -5333,26 +5398,24 @@ init_optabs (void)\n   init_floating_libfuncs (le_optab, \"le\", '2');\n   init_floating_libfuncs (unord_optab, \"unord\", '2');\n \n-  /* Use cabs for DC complex abs, since systems generally have cabs.\n-     Don't define any libcall for SCmode, so that cabs will be used.  */\n-  abs_optab->handlers[(int) DCmode].libfunc\n-    = init_one_libfunc (\"cabs\");\n+  /* Conversions.  */\n+  init_interclass_conv_libfuncs (sfloat_optab, \"float\", MODE_INT, MODE_FLOAT);\n+  init_interclass_conv_libfuncs (sfix_optab, \"fix\",     MODE_FLOAT, MODE_INT);\n+  init_interclass_conv_libfuncs (ufix_optab, \"fixuns\",  MODE_FLOAT, MODE_INT);\n \n-  /* The ffs function operates on `int'.  */\n-  ffs_optab->handlers[(int) mode_for_size (INT_TYPE_SIZE, MODE_INT, 0)].libfunc\n-    = init_one_libfunc (\"ffs\");\n+  /* sext_optab is also used for FLOAT_EXTEND.  */\n+  init_intraclass_conv_libfuncs (sext_optab, \"extend\", MODE_FLOAT, true);\n+  init_intraclass_conv_libfuncs (trunc_optab, \"trunc\", MODE_FLOAT, false);\n \n-  extendsfdf2_libfunc = init_one_libfunc (\"__extendsfdf2\");\n-  extendsfxf2_libfunc = init_one_libfunc (\"__extendsfxf2\");\n-  extendsftf2_libfunc = init_one_libfunc (\"__extendsftf2\");\n-  extenddfxf2_libfunc = init_one_libfunc (\"__extenddfxf2\");\n-  extenddftf2_libfunc = init_one_libfunc (\"__extenddftf2\");\n+  /* Use cabs for double complex abs, since systems generally have cabs.\n+     Don't define any libcall for float complex, so that cabs will be used.  */\n+  if (complex_double_type_node)\n+    abs_optab->handlers[TYPE_MODE (complex_double_type_node)].libfunc\n+      = init_one_libfunc (\"cabs\");\n \n-  truncdfsf2_libfunc = init_one_libfunc (\"__truncdfsf2\");\n-  truncxfsf2_libfunc = init_one_libfunc (\"__truncxfsf2\");\n-  trunctfsf2_libfunc = init_one_libfunc (\"__trunctfsf2\");\n-  truncxfdf2_libfunc = init_one_libfunc (\"__truncxfdf2\");\n-  trunctfdf2_libfunc = init_one_libfunc (\"__trunctfdf2\");\n+  /* The ffs function op[1erates on `int'.  */\n+  ffs_optab->handlers[(int) mode_for_size (INT_TYPE_SIZE, MODE_INT, 0)].libfunc\n+    = init_one_libfunc (\"ffs\");\n \n   abort_libfunc = init_one_libfunc (\"abort\");\n   memcpy_libfunc = init_one_libfunc (\"memcpy\");\n@@ -5378,54 +5441,6 @@ init_optabs (void)\n   unwind_sjlj_unregister_libfunc\n     = init_one_libfunc (\"_Unwind_SjLj_Unregister\");\n \n-  floatsisf_libfunc = init_one_libfunc (\"__floatsisf\");\n-  floatdisf_libfunc = init_one_libfunc (\"__floatdisf\");\n-  floattisf_libfunc = init_one_libfunc (\"__floattisf\");\n-\n-  floatsidf_libfunc = init_one_libfunc (\"__floatsidf\");\n-  floatdidf_libfunc = init_one_libfunc (\"__floatdidf\");\n-  floattidf_libfunc = init_one_libfunc (\"__floattidf\");\n-\n-  floatsixf_libfunc = init_one_libfunc (\"__floatsixf\");\n-  floatdixf_libfunc = init_one_libfunc (\"__floatdixf\");\n-  floattixf_libfunc = init_one_libfunc (\"__floattixf\");\n-\n-  floatsitf_libfunc = init_one_libfunc (\"__floatsitf\");\n-  floatditf_libfunc = init_one_libfunc (\"__floatditf\");\n-  floattitf_libfunc = init_one_libfunc (\"__floattitf\");\n-\n-  fixsfsi_libfunc = init_one_libfunc (\"__fixsfsi\");\n-  fixsfdi_libfunc = init_one_libfunc (\"__fixsfdi\");\n-  fixsfti_libfunc = init_one_libfunc (\"__fixsfti\");\n-\n-  fixdfsi_libfunc = init_one_libfunc (\"__fixdfsi\");\n-  fixdfdi_libfunc = init_one_libfunc (\"__fixdfdi\");\n-  fixdfti_libfunc = init_one_libfunc (\"__fixdfti\");\n-\n-  fixxfsi_libfunc = init_one_libfunc (\"__fixxfsi\");\n-  fixxfdi_libfunc = init_one_libfunc (\"__fixxfdi\");\n-  fixxfti_libfunc = init_one_libfunc (\"__fixxfti\");\n-\n-  fixtfsi_libfunc = init_one_libfunc (\"__fixtfsi\");\n-  fixtfdi_libfunc = init_one_libfunc (\"__fixtfdi\");\n-  fixtfti_libfunc = init_one_libfunc (\"__fixtfti\");\n-\n-  fixunssfsi_libfunc = init_one_libfunc (\"__fixunssfsi\");\n-  fixunssfdi_libfunc = init_one_libfunc (\"__fixunssfdi\");\n-  fixunssfti_libfunc = init_one_libfunc (\"__fixunssfti\");\n-\n-  fixunsdfsi_libfunc = init_one_libfunc (\"__fixunsdfsi\");\n-  fixunsdfdi_libfunc = init_one_libfunc (\"__fixunsdfdi\");\n-  fixunsdfti_libfunc = init_one_libfunc (\"__fixunsdfti\");\n-\n-  fixunsxfsi_libfunc = init_one_libfunc (\"__fixunsxfsi\");\n-  fixunsxfdi_libfunc = init_one_libfunc (\"__fixunsxfdi\");\n-  fixunsxfti_libfunc = init_one_libfunc (\"__fixunsxfti\");\n-\n-  fixunstfsi_libfunc = init_one_libfunc (\"__fixunstfsi\");\n-  fixunstfdi_libfunc = init_one_libfunc (\"__fixunstfdi\");\n-  fixunstfti_libfunc = init_one_libfunc (\"__fixunstfti\");\n-\n   /* For function entry/exit instrumentation.  */\n   profile_function_entry_libfunc\n     = init_one_libfunc (\"__cyg_profile_func_enter\");"}, {"sha": "d8448afb03455222381815bcc2bd6bf6e7044e23", "filename": "gcc/optabs.h", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85363ca0942f5f45334b2b2ee56dad289f0ebd27/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=85363ca0942f5f45334b2b2ee56dad289f0ebd27", "patch": "@@ -38,19 +38,32 @@ Boston, MA 02111-1307, USA.  */\n    A few optabs, such as move_optab and cmp_optab, are used\n    by special code.  */\n \n+struct optab_handlers GTY(())\n+{\n+  enum insn_code insn_code;\n+  rtx libfunc;\n+};\n+\n struct optab GTY(())\n {\n   enum rtx_code code;\n-  struct optab_handlers {\n-    enum insn_code insn_code;\n-    rtx libfunc;\n-  } handlers [NUM_MACHINE_MODES];\n+  struct optab_handlers handlers[NUM_MACHINE_MODES];\n };\n typedef struct optab * optab;\n \n+/* A convert_optab is for some sort of conversion operation between\n+   modes.  The first array index is the destination mode, the second\n+   is the source mode.  */\n+struct convert_optab GTY(())\n+{\n+  enum rtx_code code;\n+  struct optab_handlers handlers[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n+};\n+typedef struct convert_optab *convert_optab;\n+\n /* Given an enum insn_code, access the function to construct\n    the body of that kind of insn.  */\n-#define GEN_FCN(CODE) (*insn_data[(int) (CODE)].genfun)\n+#define GEN_FCN(CODE) (insn_data[CODE].genfun)\n \n /* Enumeration of valid indexes into optab_table.  */\n enum optab_index\n@@ -242,7 +255,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define log_optab (optab_table[OTI_log])\n #define floor_optab (optab_table[OTI_floor])\n #define ceil_optab (optab_table[OTI_ceil])\n-#define trunc_optab (optab_table[OTI_trunc])\n+#define btrunc_optab (optab_table[OTI_trunc])\n #define round_optab (optab_table[OTI_round])\n #define nearbyint_optab (optab_table[OTI_nearbyint])\n #define tan_optab (optab_table[OTI_tan])\n@@ -268,13 +281,36 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define push_optab (optab_table[OTI_push])\n #define addcc_optab (optab_table[OTI_addcc])\n \n-/* Tables of patterns for extending one integer mode to another.  */\n-extern enum insn_code extendtab[MAX_MACHINE_MODE][MAX_MACHINE_MODE][2];\n+/* Conversion optabs have their own table and indexes.  */\n+enum convert_optab_index\n+{\n+  CTI_sext,\n+  CTI_zext,\n+  CTI_trunc,\n+\n+  CTI_sfix,\n+  CTI_ufix,\n+\n+  CTI_sfixtrunc,\n+  CTI_ufixtrunc,\n+\n+  CTI_sfloat,\n+  CTI_ufloat,\n+\n+  CTI_MAX\n+};\n+\n+extern GTY(()) convert_optab convert_optab_table[CTI_MAX];\n \n-/* Tables of patterns for converting between fixed and floating point.  */\n-extern enum insn_code fixtab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n-extern enum insn_code fixtrunctab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n-extern enum insn_code floattab[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n+#define sext_optab (convert_optab_table[CTI_sext])\n+#define zext_optab (convert_optab_table[CTI_zext])\n+#define trunc_optab (convert_optab_table[CTI_trunc])\n+#define sfix_optab (convert_optab_table[CTI_sfix])\n+#define ufix_optab (convert_optab_table[CTI_ufix])\n+#define sfixtrunc_optab (convert_optab_table[CTI_sfixtrunc])\n+#define ufixtrunc_optab (convert_optab_table[CTI_ufixtrunc])\n+#define sfloat_optab (convert_optab_table[CTI_sfloat])\n+#define ufloat_optab (convert_optab_table[CTI_ufloat])\n \n /* These arrays record the insn_code of insns that may be needed to\n    perform input and output reloads of special objects.  They provide a\n@@ -385,6 +421,8 @@ extern void init_floattab (void);\n \n /* Call this to reset the function entry for one optab.  */\n extern void set_optab_libfunc (optab, enum machine_mode, const char *);\n+extern void set_conv_libfunc (convert_optab, enum machine_mode,\n+\t\t\t      enum machine_mode, const char *);\n \n /* Generate code for a FLOAT_EXPR.  */\n extern void expand_float (rtx, rtx, int);"}]}