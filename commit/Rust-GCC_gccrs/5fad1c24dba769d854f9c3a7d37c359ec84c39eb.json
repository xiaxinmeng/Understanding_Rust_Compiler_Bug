{"sha": "5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZhZDFjMjRkYmE3NjlkODU0ZjljM2E3ZDM3YzM1OWVjODRjMzllYg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-06-29T18:21:57Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-06-29T18:21:57Z"}, "message": "pa.c (update_total_code_bytes): New function.\n\n        * pa.c (update_total_code_bytes): New function.\n\t(last_address): Number of bytes output for a function and its\n\tassociated thunks.\n\t(compute_frame_size): Use BITS_PER_UNIT.\n\t(pa_output_function_epilogue): Compute last_address.  Use\n\tupdate_total_code_bytes.\n\t(output_lbranch): Handle long branch on portable runtime.\n\t(attr_length_millicode_call, attr_length_call,\n\tattr_length_indirect_call): Only use total_code_bytes for calls in\n\tthe text section.\n\t(output_call): Only use an indirect call sequence when the target is\n\tnot local.\n\t(pa_asm_output_mi_thunk): Handle updating of total_code_bytes.  Improve\n\ttest to determine when an IA-relative branch can be used.  Add various\n\tlong branch sequences.  Avoid using an indirect branch on all ports\n\texcept SOM.\n\nFrom-SVN: r68677", "tree": {"sha": "4530b135c43f906ef7b411175cd7fc7732dcb684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4530b135c43f906ef7b411175cd7fc7732dcb684"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fad1c24dba769d854f9c3a7d37c359ec84c39eb/comments", "author": null, "committer": null, "parents": [{"sha": "342e2b749d651b51cee1f484966e260c33915575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/342e2b749d651b51cee1f484966e260c33915575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/342e2b749d651b51cee1f484966e260c33915575"}], "stats": {"total": 395, "additions": 303, "deletions": 92}, "files": [{"sha": "b3570e3a2fa89eddba95df70cd9ecafa45c02330", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fad1c24dba769d854f9c3a7d37c359ec84c39eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fad1c24dba769d854f9c3a7d37c359ec84c39eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "patch": "@@ -1,3 +1,23 @@\n+\n+2003-06-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+        * pa.c (update_total_code_bytes): New function.\n+\t(last_address): Number of bytes output for a function and its\n+\tassociated thunks.\n+\t(compute_frame_size): Use BITS_PER_UNIT.\n+\t(pa_output_function_epilogue): Compute last_address.  Use\n+\tupdate_total_code_bytes.\n+\t(output_lbranch): Handle long branch on portable runtime.\n+\t(attr_length_millicode_call, attr_length_call,\n+\tattr_length_indirect_call): Only use total_code_bytes for calls in\n+\tthe text section.\n+\t(output_call): Only use an indirect call sequence when the target is\n+\tnot local.\n+\t(pa_asm_output_mi_thunk): Handle updating of total_code_bytes.  Improve\n+\ttest to determine when an IA-relative branch can be used.  Add various\n+\tlong branch sequences.  Avoid using an indirect branch on all ports\n+\texcept SOM.\n+\n 2003-06-29  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* expr.c (clear_by_pieces): Fix prototype."}, {"sha": "e7b0b8abbe2745f7546435681935adf3c7ac34a4", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 283, "deletions": 92, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fad1c24dba769d854f9c3a7d37c359ec84c39eb/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fad1c24dba769d854f9c3a7d37c359ec84c39eb/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5fad1c24dba769d854f9c3a7d37c359ec84c39eb", "patch": "@@ -113,6 +113,7 @@ static void store_reg_modify PARAMS ((int, int, int));\n static void load_reg PARAMS ((int, int, int));\n static void set_reg_plus_d PARAMS ((int, int, int, int));\n static void pa_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void update_total_code_bytes PARAMS ((int));\n static void pa_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static int pa_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int pa_adjust_priority PARAMS ((rtx, int));\n@@ -169,10 +170,15 @@ static int gr_saved, fr_saved;\n \n static rtx find_addr_reg PARAMS ((rtx));\n \n-/* Keep track of the number of bytes we have output in the CODE subspaces\n+/* Keep track of the number of bytes we have output in the CODE subspace\n    during this compilation so we'll know when to emit inline long-calls.  */\n unsigned long total_code_bytes;\n \n+/* The last address of the previous function plus the number of bytes in\n+   associated thunks that have been output.  This is used to determine if\n+   a thunk can use an IA-relative branch to reach its target function.  */\n+static int last_address;\n+\n /* Variables to handle plabels that we discover are necessary at assembly\n    output time.  They are output after the current function.  */\n struct deferred_plabel GTY(())\n@@ -3292,8 +3298,8 @@ compute_frame_size (size, fregs_live)\n     size += TARGET_64BIT ? 48 : 32;\n \n   /* Finally, round to the preferred stack boundary.  */\n-  return ((size + PREFERRED_STACK_BOUNDARY / 8 - 1)\n-\t  & ~(PREFERRED_STACK_BOUNDARY / 8 - 1));\n+  return ((size + PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1)\n+\t  & ~(PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1));\n }\n \n /* Generate the assembly code for function entry.  FILE is a stdio\n@@ -3681,6 +3687,30 @@ load_reg (reg, disp, base)\n     }\n }\n \n+/* Update the total code bytes output to the text section.  */\n+\n+static void\n+update_total_code_bytes (nbytes)\n+     int nbytes;\n+{\n+  if ((TARGET_PORTABLE_RUNTIME || !TARGET_GAS || !TARGET_SOM)\n+      && in_text_section ())\n+    {\n+      if (INSN_ADDRESSES_SET_P ())\n+\t{\n+\t  unsigned long old_total = total_code_bytes;\n+\n+\t  total_code_bytes += nbytes;\n+\n+\t  /* Be prepared to handle overflows.  */\n+\t  if (old_total > total_code_bytes)\n+\t    total_code_bytes = -1;\n+\t}\n+      else\n+\ttotal_code_bytes = -1;\n+    }\n+}\n+\n /* This function generates the assembly code for function exit.\n    Args are as for output_function_prologue ().\n \n@@ -3694,9 +3724,10 @@ pa_output_function_epilogue (file, size)\n      FILE *file;\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n-  int last_address = 0;\n   rtx insn = get_last_insn ();\n \n+  last_address = 0;\n+\n   /* hppa_expand_epilogue does the dirty work now.  We just need\n      to output the assembler directives which denote the end\n      of a function.\n@@ -3724,29 +3755,18 @@ pa_output_function_epilogue (file, size)\n \n   fputs (\"\\t.EXIT\\n\\t.PROCEND\\n\", file);\n \n-  /* Finally, update the total number of code bytes output so far.  */\n-  if ((TARGET_PORTABLE_RUNTIME || !TARGET_GAS || !TARGET_SOM)\n-      && !flag_function_sections)\n+  if (INSN_ADDRESSES_SET_P ())\n     {\n-      if (INSN_ADDRESSES_SET_P ())\n-\t{\n-\t  unsigned long old_total = total_code_bytes;\n-\n-\t  insn = get_last_nonnote_insn ();\n-\t  last_address += INSN_ADDRESSES (INSN_UID (insn));\n-\t  if (INSN_P (insn))\n-\t    last_address += insn_default_length (insn);\n-\n-\t  total_code_bytes += last_address;\n-\t  total_code_bytes += FUNCTION_BOUNDARY / BITS_PER_UNIT;\n-\n-\t  /* Be prepared to handle overflows.  */\n-\t  if (old_total > total_code_bytes)\n-\t    total_code_bytes = -1;\n-\t}\n-      else\n-\ttotal_code_bytes = -1;\n+      insn = get_last_nonnote_insn ();\n+      last_address += INSN_ADDRESSES (INSN_UID (insn));\n+      if (INSN_P (insn))\n+\tlast_address += insn_default_length (insn);\n+      last_address = ((last_address + FUNCTION_BOUNDARY / BITS_PER_UNIT - 1)\n+\t\t      & ~(FUNCTION_BOUNDARY / BITS_PER_UNIT - 1));\n     }\n+\n+  /* Finally, update the total number of code bytes output so far.  */\n+  update_total_code_bytes (last_address);\n }\n \n void\n@@ -5904,7 +5924,13 @@ output_lbranch (dest, insn)\n \toutput_asm_insn (\"stw %%r1,-12(%%r30)\", xoperands);\n     }\n \n-  if (flag_pic)\n+  if (TARGET_PORTABLE_RUNTIME)\n+    {\n+      output_asm_insn (\"ldil L'%0,%%r1\", xoperands);\n+      output_asm_insn (\"ldo R'%0(%%r1),%%r1\", xoperands);\n+      output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n+    }\n+  else if (flag_pic)\n     {\n       output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n       if (TARGET_SOM || !TARGET_GAS)\n@@ -6545,11 +6571,12 @@ attr_length_millicode_call (insn)\n      rtx insn;\n {\n   unsigned long distance = -1;\n+  unsigned long total = in_text_section () ? total_code_bytes : 0;\n \n   if (INSN_ADDRESSES_SET_P ())\n     {\n-      distance = (total_code_bytes + insn_current_reference_address (insn));\n-      if (distance < total_code_bytes)\n+      distance = (total + insn_current_reference_address (insn));\n+      if (distance < total)\n \tdistance = -1;\n     }\n \n@@ -6741,11 +6768,12 @@ attr_length_call (insn, sibcall)\n      int sibcall;\n {\n   unsigned long distance = -1;\n+  unsigned long total = in_text_section ()? total_code_bytes : 0;\n \n   if (INSN_ADDRESSES_SET_P ())\n     {\n-      distance = (total_code_bytes + insn_current_reference_address (insn));\n-      if (distance < total_code_bytes)\n+      distance = (total + insn_current_reference_address (insn));\n+      if (distance < total)\n \tdistance = -1;\n     }\n \n@@ -6813,20 +6841,23 @@ output_call (insn, call_dest, sibcall)\n   int delay_insn_deleted = 0;\n   int delay_slot_filled = 0;\n   int seq_length = dbr_sequence_length ();\n+  tree call_decl = SYMBOL_REF_DECL (call_dest);\n+  int local_call = call_decl && !TREE_PUBLIC (call_decl);\n   rtx xoperands[2];\n \n   xoperands[0] = call_dest;\n \n   /* Handle the common case where we're sure that the branch will reach\n-     the beginning of the $CODE$ subspace.  */\n+     the beginning of the \"$CODE$\" subspace.  This is the beginning of\n+     the current function if we are in a named section.  */\n   if (!TARGET_LONG_CALLS && attr_length_call (insn, sibcall) == 8)\n     {\n       xoperands[1] = gen_rtx_REG (word_mode, sibcall ? 0 : 2);\n       output_asm_insn (\"{bl|b,l} %0,%1\", xoperands);\n     }\n   else\n     {\n-      if (TARGET_64BIT)\n+      if (TARGET_64BIT && !local_call)\n \t{\n \t  /* ??? As far as I can tell, the HP linker doesn't support the\n \t     long pc-relative sequence described in the 64-bit runtime\n@@ -6878,9 +6909,10 @@ output_call (insn, call_dest, sibcall)\n \t  /* Emit a long call.  There are several different sequences\n \t     of increasing length and complexity.  In most cases,\n              they don't allow an instruction in the delay slot.  */\n-\t  if (!(TARGET_LONG_ABS_CALL && !flag_pic)\n+\t  if (!((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)\n \t      && !(TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)\n-\t      && !(TARGET_GAS && TARGET_LONG_PIC_PCREL_CALL))\n+\t      && !(TARGET_GAS && (TARGET_LONG_PIC_PCREL_CALL || local_call))\n+\t      && !TARGET_64BIT)\n \t    indirect_call = 1;\n \n \t  if (seq_length != 0\n@@ -6900,12 +6932,13 @@ output_call (insn, call_dest, sibcall)\n \t      delay_insn_deleted = 1;\n \t    }\n \n-\t  if (TARGET_LONG_ABS_CALL && !flag_pic)\n+\t  if ((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)\n \t    {\n \t      /* This is the best sequence for making long calls in\n \t\t non-pic code.  Unfortunately, GNU ld doesn't provide\n \t\t the stub needed for external calls, and GAS's support\n-\t\t for this with the SOM linker is buggy.  */\n+\t\t for this with the SOM linker is buggy.  It is safe\n+\t\t to use this for local calls.  */\n \t      output_asm_insn (\"ldil L'%0,%%r1\", xoperands);\n \t      if (sibcall)\n \t\toutput_asm_insn (\"be R'%0(%%sr4,%%r1)\", xoperands);\n@@ -6923,7 +6956,8 @@ output_call (insn, call_dest, sibcall)\n \t    }\n \t  else\n \t    {\n-\t      if (TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)\n+\t      if ((TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)\n+\t\t  || (TARGET_64BIT && !TARGET_GAS))\n \t\t{\n \t\t  /* The HP assembler and linker can handle relocations\n \t\t     for the difference of two symbols.  GAS and the HP\n@@ -6936,7 +6970,7 @@ output_call (insn, call_dest, sibcall)\n \t\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n \t\t  output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n \t\t}\n-\t      else if (TARGET_GAS && TARGET_LONG_PIC_PCREL_CALL)\n+\t      else if (TARGET_GAS && (TARGET_LONG_PIC_PCREL_CALL || local_call))\n \t\t{\n \t\t  /*  GAS currently can't generate the relocations that\n \t\t      are needed for the SOM linker under HP-UX using this\n@@ -7075,11 +7109,9 @@ output_call (insn, call_dest, sibcall)\n \t\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n \t}\n       else\n-\t/* ??? This branch may not reach its target.  */\n \toutput_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n     }\n   else\n-    /* ??? This branch may not reach its target.  */\n     output_asm_insn (\"b,n %0\", xoperands);\n \n   /* Delete the jump.  */\n@@ -7101,11 +7133,12 @@ attr_length_indirect_call (insn)\n      rtx insn;\n {\n   unsigned long distance = -1;\n+  unsigned long total = in_text_section () ? total_code_bytes : 0;\n \n   if (INSN_ADDRESSES_SET_P ())\n     {\n-      distance = (total_code_bytes + insn_current_reference_address (insn));\n-      if (distance < total_code_bytes)\n+      distance = (total + insn_current_reference_address (insn));\n+      if (distance < total)\n \tdistance = -1;\n     }\n \n@@ -7280,81 +7313,239 @@ pa_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n      HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n      tree function;\n {\n-  const char *target_name = XSTR (XEXP (DECL_RTL (function), 0), 0);\n+  const char *fname = XSTR (XEXP (DECL_RTL (function), 0), 0);\n+  const char *tname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n+  int val_14 = VAL_14_BITS_P (delta);\n+  int nbytes = 0;\n   static unsigned int current_thunk_number;\n   char label[16];\n-  const char *lab;\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"LTHN\", current_thunk_number);\n-  lab = (*targetm.strip_name_encoding) (label);\n-  target_name = (*targetm.strip_name_encoding) (target_name);\n-  /* FIXME: total_code_bytes is not handled correctly in files with\n-     mi thunks.  */\n-  pa_output_function_prologue (file, 0);\n-  if (VAL_14_BITS_P (delta))\n-    {\n-      if (!TARGET_64BIT && !TARGET_PORTABLE_RUNTIME && flag_pic)\n-\t{\n-\t  fprintf (file, \"\\taddil LT'%s,%%r19\\n\", lab);\n-\t  fprintf (file, \"\\tldw RT'%s(%%r1),%%r22\\n\", lab);\n-\t  fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n-\t  fprintf (file, \"\\tbb,>=,n %%r22,30,.+16\\n\");\n-\t  fprintf (file, \"\\tdepi 0,31,2,%%r22\\n\");\n-\t  fprintf (file, \"\\tldw 4(%%sr0,%%r22),%%r19\\n\");\n-\t  fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n+\n+  ASM_OUTPUT_LABEL (file, tname);\n+  fprintf (file, \"\\t.PROC\\n\\t.CALLINFO FRAME=0,NO_CALLS\\n\\t.ENTRY\\n\");\n+\n+  fname = (*targetm.strip_name_encoding) (fname);\n+  tname = (*targetm.strip_name_encoding) (tname);\n+\n+  /* Output the thunk.  We know that the function is in the same\n+     translation unit (i.e., the same space) as the thunk, and that\n+     thunks are output after their method.  Thus, we don't need an\n+     external branch to reach the function.  With SOM and GAS,\n+     functions and thunks are effectively in different sections.\n+     Thus, we can always use a IA-relative branch and the linker\n+     will add a long branch stub if necessary.\n+\n+     However, we have to be careful when generating PIC code on the\n+     SOM port to ensure that the sequence does not transfer to an\n+     import stub for the target function as this could clobber the\n+     return value saved at SP-24.  This would also apply to the\n+     32-bit linux port if the multi-space model is implemented.  */\n+  if ((!TARGET_LONG_CALLS && TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n+       && !(flag_pic && TREE_PUBLIC (function))\n+       && (TARGET_GAS || last_address < 262132))\n+      || (!TARGET_LONG_CALLS && !TARGET_SOM && !TARGET_PORTABLE_RUNTIME\n+\t  && ((targetm.have_named_sections\n+\t       && DECL_SECTION_NAME (thunk_fndecl) != NULL\n+\t       /* The GNU 64-bit linker has rather poor stub management.\n+\t\t  So, we use a long branch from thunks that aren't in\n+\t\t  the same section as the target function.  */\n+\t       && ((!TARGET_64BIT\n+\t\t    && (DECL_SECTION_NAME (thunk_fndecl)\n+\t\t\t!= DECL_SECTION_NAME (function)))\n+\t\t   || ((DECL_SECTION_NAME (thunk_fndecl)\n+\t\t\t== DECL_SECTION_NAME (function))\n+\t\t       && last_address < 262132)))\n+\t      || (!targetm.have_named_sections && last_address < 262132))))\n+    {\n+      if (val_14)\n+\t{\n+\t  fprintf (file, \"\\tb %s\\n\\tldo \" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t \"(%%r26),%%r26\\n\", fname, delta);\n+\t  nbytes += 8;\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t \",%%r26\\n\", delta);\n+\t  fprintf (file, \"\\tb %s\\n\\tldo R'\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t \"(%%r1),%%r26\\n\", fname, delta);\n+\t  nbytes += 12;\n+\t}\n+    }\n+  else if (TARGET_64BIT)\n+    {\n+      /* We only have one call-clobbered scratch register, so we can't\n+         make use of the delay slot if delta doesn't fit in 14 bits.  */\n+      if (!val_14)\n+\tfprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC\n+\t\t       \",%%r26\\n\\tldo R'\" HOST_WIDE_INT_PRINT_DEC\n+\t\t       \"(%%r1),%%r26\\n\", delta, delta);\n+\n+      fprintf (file, \"\\tb,l .+8,%%r1\\n\");\n+\n+      if (TARGET_GAS)\n+\t{\n+\t  fprintf (file, \"\\taddil L'%s-$PIC_pcrel$0+4,%%r1\\n\", fname);\n+\t  fprintf (file, \"\\tldo R'%s-$PIC_pcrel$0+8(%%r1),%%r1\\n\", fname);\n+\t}\n+      else\n+\t{\n+\t  int off = val_14 ? 8 : 16;\n+\t  fprintf (file, \"\\taddil L'%s-%s-%d,%%r1\\n\", fname, tname, off);\n+\t  fprintf (file, \"\\tldo R'%s-%s-%d(%%r1),%%r1\\n\", fname, tname, off);\n+\t}\n+\n+      if (val_14)\n+\t{\n+\t  fprintf (file, \"\\tbv %%r0(%%r1)\\n\\tldo \");\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%%r26),%%r26\\n\", delta);\n+\t  nbytes += 20;\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tbv,n %%r0(%%r1)\\n\");\n+\t  nbytes += 24;\n+\t}\n+    }\n+  else if (TARGET_PORTABLE_RUNTIME)\n+    {\n+      fprintf (file, \"\\tldil L'%s,%%r1\\n\", fname);\n+      fprintf (file, \"\\tldo R'%s(%%r1),%%r22\\n\", fname);\n+\n+      if (val_14)\n+\t{\n+\t  fprintf (file, \"\\tbv %%r0(%%r22)\\n\\tldo \");\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%%r26),%%r26\\n\", delta);\n+\t  nbytes += 16;\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t \",%%r26\\n\", delta);\n+\t  fprintf (file, \"\\tbv %%r0(%%r22)\\n\\tldo \");\n+\t  fprintf (file, \"R'\" HOST_WIDE_INT_PRINT_DEC \"(%%r1),%%r26\\n\", delta);\n+\t  nbytes += 20;\n+\t}\n+    }\n+  else if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))\n+    {\n+      /* The function is accessible from outside this module.  The only\n+\t way to avoid an import stub between the thunk and function is to\n+\t call the function directly with an indirect sequence similar to\n+\t that used by $$dyncall.  This is possible because $$dyncall acts\n+\t as the import stub in an indirect call.  */\n+      const char *lab;\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LTHN\", current_thunk_number);\n+      lab = (*targetm.strip_name_encoding) (label);\n+\n+      fprintf (file, \"\\taddil LT'%s,%%r19\\n\", lab);\n+      fprintf (file, \"\\tldw RT'%s(%%r1),%%r22\\n\", lab);\n+      fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n+      fprintf (file, \"\\tbb,>=,n %%r22,30,.+16\\n\");\n+      fprintf (file, \"\\tdepi 0,31,2,%%r22\\n\");\n+      fprintf (file, \"\\tldw 4(%%sr0,%%r22),%%r19\\n\");\n+      fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n+      if (!val_14)\n+\t{\n+\t  fprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t \",%%r26\\n\", delta);\n+\t  nbytes += 4;\n+\t}\n+      if (TARGET_PA_20)\n+\t{\n+          fprintf (file, \"\\tbve (%%r22)\\n\\tldo \");\n+\t  nbytes += 36;\n+\t}\n+      else\n+\t{\n \t  if (TARGET_NO_SPACE_REGS)\n-\t    fprintf (file, \"\\tbe 0(%%sr4,%%r22)\\n\\tldo \");\n+\t    {\n+\t      fprintf (file, \"\\tbe 0(%%sr4,%%r22)\\n\\tldo \");\n+\t      nbytes += 36;\n+\t    }\n \t  else\n \t    {\n \t      fprintf (file, \"\\tldsid (%%sr0,%%r22),%%r1\\n\");\n-\t      fprintf (file, \"\\tmtsp %%r1,%%sr0\\n\");\n+\t      fprintf (file, \"\\tmtsp %%r21,%%sr0\\n\");\n \t      fprintf (file, \"\\tbe 0(%%sr0,%%r22)\\n\\tldo \");\n+\t      nbytes += 44;\n \t    }\n+\t}\n+\n+      if (val_14)\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%%r26),%%r26\\n\", delta);\n+      else\n+\tfprintf (file, \"R'\" HOST_WIDE_INT_PRINT_DEC \"(%%r1),%%r26\\n\", delta);\n+    }\n+  else if (flag_pic)\n+    {\n+      if (TARGET_PA_20)\n+\tfprintf (file, \"\\tb,l .+8,%%r1\\n\");\n+      else\n+\tfprintf (file, \"\\tbl .+8,%%r1\\n\");\n+\n+      if (TARGET_SOM || !TARGET_GAS)\n+\t{\n+\t  fprintf (file, \"\\taddil L'%s-%s-8,%%r1\\n\", fname, tname);\n+\t  fprintf (file, \"\\tldo R'%s-%s-8(%%r1),%%r22\\n\", fname, tname);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\taddil L'%s-$PIC_pcrel$0+4,%%r1\\n\", fname);\n+\t  fprintf (file, \"\\tldo R'%s-$PIC_pcrel$0+8(%%r1),%%r22\\n\", fname);\n+\t}\n+\n+      if (val_14)\n+\t{\n+\t  fprintf (file, \"\\tbv %%r0(%%r22)\\n\\tldo \");\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%%r26),%%r26\\n\", delta);\n+\t  nbytes += 20;\n \t}\n       else\n-\tfprintf (file, \"\\tb %s\\n\\tldo \" HOST_WIDE_INT_PRINT_DEC\n-\t\t \"(%%r26),%%r26\\n\",\n-\t\t target_name, delta);\n+\t{\n+\t  fprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t \",%%r26\\n\", delta);\n+\t  fprintf (file, \"\\tbv %%r0(%%r22)\\n\\tldo \");\n+\t  fprintf (file, \"R'\" HOST_WIDE_INT_PRINT_DEC \"(%%r1),%%r26\\n\", delta);\n+\t  nbytes += 24;\n+\t}\n     }\n   else\n     {\n-      if (!TARGET_64BIT && !TARGET_PORTABLE_RUNTIME && flag_pic)\n+      if (!val_14)\n+\tfprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC \",%%r26\\n\", delta);\n+\n+      fprintf (file, \"\\tldil L'%s,%%r22\\n\", fname);\n+      fprintf (file, \"\\tbe R'%s(%%sr4,%%r22)\\n\\tldo \", fname);\n+\n+      if (val_14)\n \t{\n-\t  fprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC\n-\t\t   \",%%r26\\n\\tldo R'\" HOST_WIDE_INT_PRINT_DEC \"(%%r1),%%r26\\n\",\n-\t\t   delta, delta);\n-\t  fprintf (file, \"\\taddil LT'%s,%%r19\\n\", lab);\n-\t  fprintf (file, \"\\tldw RT'%s(%%r1),%%r22\\n\", lab);\n-\t  fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n-\t  fprintf (file, \"\\tbb,>=,n %%r22,30,.+16\\n\");\n-\t  fprintf (file, \"\\tdepi 0,31,2,%%r22\\n\");\n-\t  fprintf (file, \"\\tldw 4(%%sr0,%%r22),%%r19\\n\");\n-\t  fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n-\t  if (TARGET_NO_SPACE_REGS)\n-\t    fprintf (file, \"\\tbe 0(%%sr4,%%r22)\");\n-\t  else\n-\t    {\n-\t      fprintf (file, \"\\tldsid (%%sr0,%%r22),%%r1\\n\");\n-\t      fprintf (file, \"\\tmtsp %%r1,%%sr0\\n\");\n-\t      fprintf (file, \"\\tbe,n 0(%%sr0,%%r22)\\n\");\n-\t    }\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%%r26),%%r26\\n\", delta);\n+\t  nbytes += 12;\n \t}\n       else\n-\tfprintf (file, \"\\taddil L'\" HOST_WIDE_INT_PRINT_DEC\n-\t\t \",%%r26\\n\\tb %s\\n\\tldo R'\" HOST_WIDE_INT_PRINT_DEC\n-\t\t \"(%%r1),%%r26\\n\", delta, target_name, delta);\n+\t{\n+\t  fprintf (file, \"R'\" HOST_WIDE_INT_PRINT_DEC \"(%%r1),%%r26\\n\", delta);\n+\t  nbytes += 16;\n+\t}\n     }\n-    \n+\n   fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n-  if (! TARGET_64BIT && ! TARGET_PORTABLE_RUNTIME && flag_pic)\n+\n+  if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))\n     {\n       data_section ();\n       fprintf (file, \"\\t.align 4\\n\");\n-      (*targetm.asm_out.internal_label) (file, \"LTHN\", current_thunk_number);\n-      fprintf (file, \"\\t.word P'%s\\n\", target_name);\n+      ASM_OUTPUT_LABEL (file, label);\n+      fprintf (file, \"\\t.word P'%s\\n\", fname);\n       function_section (thunk_fndecl);\n     }\n+\n   current_thunk_number++;\n+  nbytes = ((nbytes + FUNCTION_BOUNDARY / BITS_PER_UNIT - 1)\n+\t    & ~(FUNCTION_BOUNDARY / BITS_PER_UNIT - 1));\n+  last_address += nbytes;\n+  update_total_code_bytes (nbytes);\n }\n \n /* Only direct calls to static functions are allowed to be sibling (tail)"}]}