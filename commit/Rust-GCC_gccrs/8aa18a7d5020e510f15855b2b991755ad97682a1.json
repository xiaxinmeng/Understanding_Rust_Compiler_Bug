{"sha": "8aa18a7d5020e510f15855b2b991755ad97682a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFhMThhN2Q1MDIwZTUxMGYxNTg1NWIyYjk5MTc1NWFkOTc2ODJhMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-04-29T10:19:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-04-29T10:19:56Z"}, "message": "predict.c (real_zero, [...]): New static variables.\n\n\t* predict.c (real_zero, real_one, real_almost_one, real_br_prob_base,\n\treal_one_half, real_bb_freq_max): New static variables.\n\t(debug_profile_bbauxs): Kill.\n\t(process_note_predictions): Kill unused variable.\n\t(block_info_def, edge_info_def): Use REAL_VALUE_TYPE instead of\n\tvolatile double.\n\t(propagate_freq): Use REAL_ARITHMETICS.\n\t(estimate_bb_frequencies): Likevise; init new static variables.\n\t* Makefile.in (predict.o): Add dependency on real.h\n\nFrom-SVN: r52889", "tree": {"sha": "f8fb242fe0937dbc976df57425b7422b078b4eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8fb242fe0937dbc976df57425b7422b078b4eea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aa18a7d5020e510f15855b2b991755ad97682a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa18a7d5020e510f15855b2b991755ad97682a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aa18a7d5020e510f15855b2b991755ad97682a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa18a7d5020e510f15855b2b991755ad97682a1/comments", "author": null, "committer": null, "parents": [{"sha": "4bd7c27025afa9f79d44b053a84ca96f110787b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd7c27025afa9f79d44b053a84ca96f110787b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bd7c27025afa9f79d44b053a84ca96f110787b7"}], "stats": {"total": 127, "additions": 97, "deletions": 30}, "files": [{"sha": "d59171b7beccc128464e5ceb37ff21904a0a39c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa18a7d5020e510f15855b2b991755ad97682a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa18a7d5020e510f15855b2b991755ad97682a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8aa18a7d5020e510f15855b2b991755ad97682a1", "patch": "@@ -1,3 +1,15 @@\n+Mon Apr 29 12:18:35 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (real_zero, real_one, real_almost_one, real_br_prob_base,\n+\treal_one_half, real_bb_freq_max): New static variables.\n+\t(debug_profile_bbauxs): Kill.\n+\t(process_note_predictions): Kill unused variable.\n+\t(block_info_def, edge_info_def): Use REAL_VALUE_TYPE instead of\n+\tvolatile double.\n+\t(propagate_freq): Use REAL_ARITHMETICS.\n+\t(estimate_bb_frequencies): Likevise; init new static variables.\n+\t* Makefile.in (predict.o): Add dependency on real.h\n+\n 2002-04-28  David S. Miller  <davem@redhat.com>\n \n \tPR target/6500"}, {"sha": "f7ebd99919978e7a9c5ebff0de7a96d555c4a449", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa18a7d5020e510f15855b2b991755ad97682a1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa18a7d5020e510f15855b2b991755ad97682a1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8aa18a7d5020e510f15855b2b991755ad97682a1", "patch": "@@ -1576,7 +1576,7 @@ reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(RECOG_H)\n    varray.h function.h $(TM_P_H)\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n-   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H)\n+   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) real.h\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n    flags.h $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h $(TARGET_H)"}, {"sha": "3eece3503b4e5a4e4b01c94319eab7dae18767f9", "filename": "gcc/predict.c", "status": "modified", "additions": 84, "deletions": 29, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa18a7d5020e510f15855b2b991755ad97682a1/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa18a7d5020e510f15855b2b991755ad97682a1/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=8aa18a7d5020e510f15855b2b991755ad97682a1", "patch": "@@ -45,6 +45,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"expr.h\"\n #include \"predict.h\"\n+#include \"real.h\"\n+\n+/* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE, 0.5,\n+                   REAL_BB_FREQ_MAX.  */\n+static REAL_VALUE_TYPE real_zero, real_one, real_almost_one, real_br_prob_base,\n+\t\t       real_one_half, real_bb_freq_max;\n \n /* Random guesstimation given names.  */\n #define PROB_NEVER\t\t(0)\n@@ -620,7 +626,7 @@ expected_value_to_br_prob ()\n typedef struct block_info_def\n {\n   /* Estimated frequency of execution of basic_block.  */\n-  volatile double frequency;\n+  REAL_VALUE_TYPE frequency;\n \n   /* To keep queue of basic blocks to process.  */\n   basic_block next;\n@@ -637,11 +643,8 @@ typedef struct edge_info_def\n {\n   /* In case edge is an loopback edge, the probability edge will be reached\n      in case header is.  Estimated number of iterations of the loop can be\n-     then computed as 1 / (1 - back_edge_prob).\n-\n-     Volatile is needed to avoid differences in the optimized and unoptimized\n-     builds on machines where FP registers are wider than double.  */\n-  volatile double back_edge_prob;\n+     then computed as 1 / (1 - back_edge_prob).  */\n+  REAL_VALUE_TYPE back_edge_prob;\n   /* True if the edge is an loopback edge in the natural loop.  */\n   int back_edge:1;\n } *edge_info;\n@@ -683,10 +686,13 @@ propagate_freq (head)\n \t}\n     }\n \n-  BLOCK_INFO (head)->frequency = 1;\n+  memcpy (&BLOCK_INFO (head)->frequency, &real_one, sizeof (real_one));\n   for (; bb; bb = nextbb)\n     {\n-      double cyclic_probability = 0, frequency = 0;\n+      REAL_VALUE_TYPE cyclic_probability, frequency;\n+\n+      memcpy (&cyclic_probability, &real_zero, sizeof (real_zero));\n+      memcpy (&frequency, &real_zero, sizeof (real_zero));\n \n       nextbb = BLOCK_INFO (bb)->next;\n       BLOCK_INFO (bb)->next = NULL;\n@@ -702,26 +708,56 @@ propagate_freq (head)\n \n \t  for (e = bb->pred; e; e = e->pred_next)\n \t    if (EDGE_INFO (e)->back_edge)\n-\t      cyclic_probability += EDGE_INFO (e)->back_edge_prob;\n+\t      {\n+\t\tREAL_ARITHMETIC (cyclic_probability, PLUS_EXPR,\n+\t\t\t\t cyclic_probability,\n+\t\t\t\t EDGE_INFO (e)->back_edge_prob);\n+\t      }\n \t    else if (!(e->flags & EDGE_DFS_BACK))\n-\t      frequency += (e->probability\n-\t\t\t    * BLOCK_INFO (e->src)->frequency /\n-\t\t\t    REG_BR_PROB_BASE);\n+\t      {\n+\t\tREAL_VALUE_TYPE tmp;\n+\n+\t\t/*  frequency += (e->probability\n+\t\t\t\t  * BLOCK_INFO (e->src)->frequency /\n+\t\t\t\t  REG_BR_PROB_BASE);  */\n+\n+\t\tREAL_VALUE_FROM_INT (tmp, e->probability, 0, DFmode);\n+\t\tREAL_ARITHMETIC (tmp, MULT_EXPR, tmp,\n+\t\t\t\t BLOCK_INFO (e->src)->frequency);\n+\t\tREAL_ARITHMETIC (tmp, RDIV_EXPR, tmp, real_br_prob_base);\n+\t\tREAL_ARITHMETIC (frequency, PLUS_EXPR, frequency, tmp);\n+\t      }\n+\n+\t  if (REAL_VALUES_LESS (real_almost_one, cyclic_probability))\n+\t    memcpy (&cyclic_probability, &real_almost_one, sizeof (real_zero));\n \n-\t  if (cyclic_probability > 1.0 - 1.0 / REG_BR_PROB_BASE)\n-\t    cyclic_probability = 1.0 - 1.0 / REG_BR_PROB_BASE;\n+\t  /* BLOCK_INFO (bb)->frequency = frequency / (1 - cyclic_probability)\n+\t   */\n \n-\t  BLOCK_INFO (bb)->frequency = frequency / (1 - cyclic_probability);\n+\t  REAL_ARITHMETIC (cyclic_probability, MINUS_EXPR, real_one,\n+\t\t\t   cyclic_probability);\n+\t  REAL_ARITHMETIC (BLOCK_INFO (bb)->frequency,\n+\t\t\t   RDIV_EXPR, frequency, cyclic_probability);\n \t}\n \n       BLOCK_INFO (bb)->tovisit = 0;\n \n       /* Compute back edge frequencies.  */\n       for (e = bb->succ; e; e = e->succ_next)\n \tif (e->dest == head)\n-\t  EDGE_INFO (e)->back_edge_prob\n-\t    = ((e->probability * BLOCK_INFO (bb)->frequency)\n-\t       / REG_BR_PROB_BASE);\n+\t  {\n+\t    REAL_VALUE_TYPE tmp;\n+\n+\t    /* EDGE_INFO (e)->back_edge_prob\n+\t\t  = ((e->probability * BLOCK_INFO (bb)->frequency)\n+\t\t     / REG_BR_PROB_BASE); */\n+\t    REAL_VALUE_FROM_INT (tmp, e->probability, 0, DFmode);\n+\t    REAL_ARITHMETIC (tmp, MULT_EXPR, tmp,\n+\t\t\t     BLOCK_INFO (bb)->frequency);\n+\t    REAL_ARITHMETIC (EDGE_INFO (e)->back_edge_prob,\n+\t\t\t     RDIV_EXPR, tmp, real_br_prob_base);\n+\n+\t  }\n \n       /* Propagate to successor blocks.  */\n       for (e = bb->succ; e; e = e->succ_next)\n@@ -863,7 +899,18 @@ estimate_bb_frequencies (loops)\n      struct loops *loops;\n {\n   int i;\n-  double freq_max = 0;\n+  REAL_VALUE_TYPE freq_max;\n+\n+  REAL_VALUE_FROM_INT (real_zero, 0, 0, DFmode);\n+  REAL_VALUE_FROM_INT (real_one, 1, 0, DFmode);\n+  REAL_VALUE_FROM_INT (real_br_prob_base, REG_BR_PROB_BASE, 0, DFmode);\n+  REAL_VALUE_FROM_INT (real_bb_freq_max, BB_FREQ_MAX, 0, DFmode);\n+  REAL_VALUE_FROM_INT (real_one_half, 2, 0, DFmode);\n+\n+  REAL_ARITHMETIC (real_one_half, RDIV_EXPR, real_one, real_one_half);\n+\n+  REAL_ARITHMETIC (real_almost_one, RDIV_EXPR, real_one, real_br_prob_base);\n+  REAL_ARITHMETIC (real_almost_one, MINUS_EXPR, real_one, real_almost_one);\n \n   mark_dfs_back_edges ();\n   if (flag_branch_probabilities)\n@@ -919,8 +966,14 @@ estimate_bb_frequencies (loops)\n \n       BLOCK_INFO (bb)->tovisit = 0;\n       for (e = bb->succ; e; e = e->succ_next)\n-\tEDGE_INFO (e)->back_edge_prob = ((double) e->probability\n-\t\t\t\t\t / REG_BR_PROB_BASE);\n+\t{\n+\t\n+\t  REAL_VALUE_FROM_INT (EDGE_INFO (e)->back_edge_prob,\n+\t\t\t       e->probability, 0, DFmode);\n+\t  REAL_ARITHMETIC (EDGE_INFO (e)->back_edge_prob,\n+\t\t\t   RDIV_EXPR, EDGE_INFO (e)->back_edge_prob,\n+\t\t\t   real_br_prob_base);\n+\t}\n     }\n \n   /* First compute probabilities locally for each loop from innermost\n@@ -935,14 +988,16 @@ estimate_bb_frequencies (loops)\n   BLOCK_INFO (EXIT_BLOCK_PTR)->tovisit = 1;\n   propagate_freq (ENTRY_BLOCK_PTR);\n \n+  memcpy (&freq_max, &real_zero, sizeof (real_zero));\n   for (i = 0; i < n_basic_blocks; i++)\n-    if (BLOCK_INFO (BASIC_BLOCK (i))->frequency > freq_max)\n-      freq_max = BLOCK_INFO (BASIC_BLOCK (i))->frequency;\n+    if (REAL_VALUES_LESS (freq_max, BLOCK_INFO (BASIC_BLOCK (i))->frequency))\n+      memcpy (&freq_max, &BLOCK_INFO (BASIC_BLOCK (i))->frequency,\n+\t      sizeof (freq_max));\n \n   for (i = -2; i < n_basic_blocks; i++)\n     {\n       basic_block bb;\n-      volatile double tmp;\n+      REAL_VALUE_TYPE tmp;\n \n       if (i == -2)\n \tbb = ENTRY_BLOCK_PTR;\n@@ -951,11 +1006,11 @@ estimate_bb_frequencies (loops)\n       else\n \tbb = BASIC_BLOCK (i);\n \n-      /* ??? Prevent rounding differences due to optimization on x86.  */\n-      tmp = BLOCK_INFO (bb)->frequency * BB_FREQ_MAX;\n-      tmp /= freq_max;\n-      tmp += 0.5;\n-      bb->frequency = tmp;\n+      REAL_ARITHMETIC (tmp, MULT_EXPR, BLOCK_INFO (bb)->frequency,\n+\t\t       real_bb_freq_max);\n+      REAL_ARITHMETIC (tmp, RDIV_EXPR, tmp, freq_max);\n+      REAL_ARITHMETIC (tmp, PLUS_EXPR, tmp, real_one_half);\n+      bb->frequency = REAL_VALUE_UNSIGNED_FIX (tmp);\n     }\n \n   free_aux_for_blocks ();"}]}