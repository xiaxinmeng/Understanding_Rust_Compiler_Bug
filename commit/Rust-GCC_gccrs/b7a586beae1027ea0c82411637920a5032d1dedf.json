{"sha": "b7a586beae1027ea0c82411637920a5032d1dedf", "node_id": "C_kwDOANBUbNoAKGI3YTU4NmJlYWUxMDI3ZWEwYzgyNDExNjM3OTIwYTUwMzJkMWRlZGY", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-08-25T17:04:50Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-08-27T22:16:34Z"}, "message": "d: Merge upstream dmd 817610b16d, phobos b578dfad9\n\nD front-end changes:\n\n    - Import latest bug fixes to mainline.\n\nPhobos changes:\n\n    - Import latest bug fixes to mainline.\n    - std.logger module has been moved out of experimental.\n    - Removed std.experimental.typecons module.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 817610b16d.\n\t* d-ctfloat.cc (CTFloat::parse): Update for new front-end interface.\n\t* d-lang.cc (d_parse_file): Likewise.\n\t* expr.cc (ExprVisitor::visit (AssignExp *)): Remove handling of array\n\tassignments to non-trivial static and dynamic arrays.\n\t* runtime.def (ARRAYASSIGN): Remove.\n\t(ARRAYASSIGN_L): Remove.\n\t(ARRAYASSIGN_R): Remove.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 817610b16d.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Add\n\tcore/internal/array/arrayassign.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos b578dfad9.\n\t* src/Makefile.am (PHOBOS_DSOURCES): Remove\n\tstd/experimental/typecons.d. Add std/logger package.\n\t* src/Makefile.in: Regenerate.", "tree": {"sha": "4c41a84c4113e90cd0caaa7aa9925f4232dc22d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c41a84c4113e90cd0caaa7aa9925f4232dc22d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7a586beae1027ea0c82411637920a5032d1dedf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7a586beae1027ea0c82411637920a5032d1dedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7a586beae1027ea0c82411637920a5032d1dedf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7a586beae1027ea0c82411637920a5032d1dedf/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cace77f4fb8df18c01dfdf9040cc944eedef1147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cace77f4fb8df18c01dfdf9040cc944eedef1147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cace77f4fb8df18c01dfdf9040cc944eedef1147"}], "stats": {"total": 11486, "additions": 5812, "deletions": 5674}, "files": [{"sha": "a434af95528304555140d6278c7daca45d860812", "filename": "gcc/d/d-ctfloat.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fd-ctfloat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fd-ctfloat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-ctfloat.cc?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -85,14 +85,13 @@ CTFloat::isInfinity (real_t r)\n /* Return a real_t value from string BUFFER rounded to long double mode.  */\n \n real_t\n-CTFloat::parse (const char *buffer, bool *overflow)\n+CTFloat::parse (const char *buffer, bool &overflow)\n {\n   real_t r;\n   real_from_string3 (&r.rv (), buffer, TYPE_MODE (long_double_type_node));\n \n   /* Front-end checks overflow to see if the value is representable.  */\n-  if (overflow && r == target.RealProperties.infinity)\n-    *overflow = true;\n+  overflow = (r == target.RealProperties.infinity) ? true : false;\n \n   return r;\n }"}, {"sha": "dcc465f299bbed6603c8e8846ef612bc1663ddbb", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1191,7 +1191,6 @@ d_parse_file (void)\n     }\n \n   /* Do deferred semantic analysis.  */\n-  Module::dprogress = 1;\n   Module::runDeferredSemantic ();\n \n   if (Module::deferred.length)"}, {"sha": "85fc49d3d0a2e8f62f298079c618beec2a09b803", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,4 +1,4 @@\n-d7772a236983ec37b92d21b28bad3cd2de57b945\n+817610b16d0f0f469b9fbb28c000956fb910c43f\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "1c7e1dd027d8a9251956b86bba43f1b4cd66ace2", "filename": "gcc/d/dmd/README.md", "status": "modified", "additions": 141, "deletions": 141, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FREADME.md?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -18,10 +18,10 @@ this license for that file.\n \n | Folder                                                                   | Purpose                                                                                                                                                                                                       |\n |--------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| [dmd/](https://github.com/dlang/dmd/tree/master/src/dmd)                 | The dmd driver and front-end                                                                                                                                                                                  |\n-| [dmd/backend/](https://github.com/dlang/dmd/tree/master/src/dmd/backend) | Code generation for x86 or x86-64. Shared by the [Digital Mars C compiler](https://github.com/DigitalMars/Compiler/), but not [LDC](https://github.com/ldc-developers/ldc) or [GDC](https://gdcproject.org/). |\n-| [dmd/common/](https://github.com/dlang/dmd/tree/master/src/dmd/common)   | Code shared by the front-end and back-end                                                                                                                                                                     |\n-| [dmd/root/](https://github.com/dlang/dmd/tree/master/src/dmd/root)       | Meant as a portable utility library, but [\"it wasn't very good and the only project left using it is dmd\"](https://github.com/dlang/dmd/pull/9844#issuecomment-498479516).                                    |\n+| [dmd/](https://github.com/dlang/dmd/tree/master/compiler/src/dmd)                 | The dmd driver and front-end                                                                                                                                                                                  |\n+| [dmd/backend/](https://github.com/dlang/dmd/tree/master/compiler/src/dmd/backend) | Code generation for x86 or x86-64. Shared by the [Digital Mars C compiler](https://github.com/DigitalMars/Compiler/), but not [LDC](https://github.com/ldc-developers/ldc) or [GDC](https://gdcproject.org/). |\n+| [dmd/common/](https://github.com/dlang/dmd/tree/master/compiler/src/dmd/common)   | Code shared by the front-end and back-end                                                                                                                                                                     |\n+| [dmd/root/](https://github.com/dlang/dmd/tree/master/compiler/src/dmd/root)       | Meant as a portable utility library, but [\"it wasn't very good and the only project left using it is dmd\"](https://github.com/dlang/dmd/pull/9844#issuecomment-498479516).                                    |\n \n DMD has a mostly flat directory structure, so this section aims to divide all source files into logical groups for easier navigation.\n The groups are roughly ordered by how late they appear in the compilation process.\n@@ -31,232 +31,232 @@ Note that these groups have no strict meaning, the category assignments are a bi\n \n | File                                                                        | Purpose                                                               |\n |-----------------------------------------------------------------------------|-----------------------------------------------------------------------|\n-| [mars.d](https://github.com/dlang/dmd/blob/master/src/dmd/mars.d)           | The entry point. Contains `main`.                                     |\n-| [cli.d](https://github.com/dlang/dmd/blob/master/src/dmd/cli.d)             | Define the command line interface                                     |\n-| [dmdparams.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmdparams.d) | DMD-specific parameters                                               |\n-| [globals.d](https://github.com/dlang/dmd/blob/master/src/dmd/globals.d)     | Define a structure storing command line options                       |\n-| [dinifile.d](https://github.com/dlang/dmd/blob/master/src/dmd/dinifile.d)   | Parse settings from .ini file (`sc.ini` / `dmd.conf`)                 |\n-| [vsoptions.d](https://github.com/dlang/dmd/blob/master/src/dmd/vsoptions.d) | Detect the Microsoft Visual Studio toolchain for linking              |\n-| [frontend.d](https://github.com/dlang/dmd/blob/master/src/dmd/frontend.d)   | An interface for using DMD as a library                               |\n-| [errors.d](https://github.com/dlang/dmd/blob/master/src/dmd/errors.d)       | Error reporting functionality                                         |\n-| [target.d](https://github.com/dlang/dmd/blob/master/src/dmd/target.d)       | Manage target-specific parameters for cross-compiling (for LDC/GDC)   |\n-| [compiler.d](https://github.com/dlang/dmd/blob/master/src/dmd/compiler.d)   | Describe a back-end compiler and implements compiler-specific actions |\n+| [mars.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/mars.d)           | The entry point. Contains `main`.                                     |\n+| [cli.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/cli.d)             | Define the command line interface                                     |\n+| [dmdparams.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dmdparams.d) | DMD-specific parameters                                               |\n+| [globals.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/globals.d)     | Define a structure storing command line options                       |\n+| [dinifile.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dinifile.d)   | Parse settings from .ini file (`sc.ini` / `dmd.conf`)                 |\n+| [vsoptions.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/vsoptions.d) | Detect the Microsoft Visual Studio toolchain for linking              |\n+| [frontend.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/frontend.d)   | An interface for using DMD as a library                               |\n+| [errors.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/errors.d)       | Error reporting functionality                                         |\n+| [target.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/target.d)       | Manage target-specific parameters for cross-compiling (for LDC/GDC)   |\n+| [compiler.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/compiler.d)   | Describe a back-end compiler and implements compiler-specific actions |\n \n ### Lexing / parsing\n \n | File                                                                  | Purpose                                                              |\n |-----------------------------------------------------------------------|----------------------------------------------------------------------|\n-| [lexer.d](https://github.com/dlang/dmd/blob/master/src/dmd/lexer.d)   | Convert source code into tokens for the D and ImportC parsers        |\n-| [entity.d](https://github.com/dlang/dmd/blob/master/src/dmd/entity.d) | Define \"\\\\&Entity;\" escape sequence for strings / character literals |\n-| [tokens.d](https://github.com/dlang/dmd/blob/master/src/dmd/tokens.d) | Define lexical tokens.                                               |\n-| [parse.d](https://github.com/dlang/dmd/blob/master/src/dmd/parse.d)   | D parser, converting tokens into an Abstract Syntax Tree (AST)       |\n-| [cparse.d](https://github.com/dlang/dmd/blob/master/src/dmd/cparse.d) | ImportC parser, converting tokens into an Abstract Syntax Tree (AST) |\n+| [lexer.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/lexer.d)   | Convert source code into tokens for the D and ImportC parsers        |\n+| [entity.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/entity.d) | Define \"\\\\&Entity;\" escape sequence for strings / character literals |\n+| [tokens.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/tokens.d) | Define lexical tokens.                                               |\n+| [parse.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/parse.d)   | D parser, converting tokens into an Abstract Syntax Tree (AST)       |\n+| [cparse.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/cparse.d) | ImportC parser, converting tokens into an Abstract Syntax Tree (AST) |\n \n ### Semantic analysis\n \n **Symbols and declarations**\n \n | File                                                                            | Purpose                                                                                                          |\n |---------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|\n-| [dsymbol.d](https://github.com/dlang/dmd/blob/master/src/dmd/dsymbol.d)         | Base class for a D symbol, e.g. a variable, function, module, enum etc.                                          |\n-| [identifier.d](https://github.com/dlang/dmd/blob/master/src/dmd/identifier.d)   | Represents the name of a `Dsymbol`                                                                               |\n-| [id.d](https://github.com/dlang/dmd/blob/master/src/dmd/id.d)                   | Define strings for pre-defined identifiers (e.g. `sizeof`, `string`)                                             |\n-| [dscope.d](https://github.com/dlang/dmd/blob/master/src/dmd/dscope.d)           | Define a 'scope' on which symbol lookup can be performed                                                         |\n-| [dtemplate.d](https://github.com/dlang/dmd/blob/master/src/dmd/dtemplate.d)     | A template declaration or instance                                                                               |\n-| [dmodule.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmodule.d)         | Define a package and module                                                                                      |\n-| [mtype.d](https://github.com/dlang/dmd/blob/master/src/dmd/mtype.d)             | Define expression types such as `int`, `char[]`, `void function()`                                               |\n-| [arraytypes.d](https://github.com/dlang/dmd/blob/master/src/dmd/arraytypes.d)   | For certain Declaration nodes of type `T`, provides aliases for `Array!T`                                        |\n-| [declaration.d](https://github.com/dlang/dmd/blob/master/src/dmd/declaration.d) | Misc. declarations of `alias`, variables, type tuples, `ClassInfo` etc.                                          |\n-| [denum.d](https://github.com/dlang/dmd/blob/master/src/dmd/denum.d)             | Defines `enum` declarations and enum members                                                                     |\n-| [attrib.d](https://github.com/dlang/dmd/blob/master/src/dmd/nogc.d)             | Declarations of 'attributes' such as `private`, `pragma()`, `immutable`, `@UDA`, `align`, `extern(C++)` and more |\n-| [func.d](https://github.com/dlang/dmd/blob/master/src/dmd/func.d)               | Define a function declaration (includes function literals, `invariant`, `unittest`)                              |\n-| [dversion.d](https://github.com/dlang/dmd/blob/master/src/dmd/dversion.d)       | Defines a version symbol, e.g. `version = ident`, `debug = ident`                                                |\n+| [dsymbol.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dsymbol.d)         | Base class for a D symbol, e.g. a variable, function, module, enum etc.                                          |\n+| [identifier.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/identifier.d)   | Represents the name of a `Dsymbol`                                                                               |\n+| [id.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/id.d)                   | Define strings for pre-defined identifiers (e.g. `sizeof`, `string`)                                             |\n+| [dscope.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dscope.d)           | Define a 'scope' on which symbol lookup can be performed                                                         |\n+| [dtemplate.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dtemplate.d)     | A template declaration or instance                                                                               |\n+| [dmodule.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dmodule.d)         | Define a package and module                                                                                      |\n+| [mtype.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/mtype.d)             | Define expression types such as `int`, `char[]`, `void function()`                                               |\n+| [arraytypes.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/arraytypes.d)   | For certain Declaration nodes of type `T`, provides aliases for `Array!T`                                        |\n+| [declaration.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/declaration.d) | Misc. declarations of `alias`, variables, type tuples, `ClassInfo` etc.                                          |\n+| [denum.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/denum.d)             | Defines `enum` declarations and enum members                                                                     |\n+| [attrib.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/nogc.d)             | Declarations of 'attributes' such as `private`, `pragma()`, `immutable`, `@UDA`, `align`, `extern(C++)` and more |\n+| [func.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/func.d)               | Define a function declaration (includes function literals, `invariant`, `unittest`)                              |\n+| [dversion.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dversion.d)       | Defines a version symbol, e.g. `version = ident`, `debug = ident`                                                |\n \n **AST nodes**\n \n | File                                                                              | Purpose                                                     |\n |-----------------------------------------------------------------------------------|-------------------------------------------------------------|\n-| [ast_node.d](https://github.com/dlang/dmd/blob/master/src/dmd/ast_node.d)         | Define an abstract AST node class                           |\n-| [astbase.d](https://github.com/dlang/dmd/blob/master/src/dmd/astbase.d)           | Namespace of AST nodes that can be produced by the parser   |\n-| [astcodegen.d](https://github.com/dlang/dmd/blob/master/src/dmd/astcodegen.d)     | Namespace of AST nodes of a AST ready for code generation   |\n-| [astenums.d](https://github.com/dlang/dmd/blob/master/src/dmd/astenums.d)         | Enums common to DMD and AST                                 |\n-| [expression.d](https://github.com/dlang/dmd/blob/master/src/dmd/expression.d)     | Define expression AST nodes                                 |\n-| [statement.d](https://github.com/dlang/dmd/blob/master/src/dmd/statement.d)       | Define statement AST nodes                                  |\n-| [staticassert.d](https://github.com/dlang/dmd/blob/master/src/dmd/staticassert.d) | Define a `static assert` AST node                           |\n-| [aggregate.d](https://github.com/dlang/dmd/blob/master/src/dmd/aggregate.d)       | Define an aggregate (`struct`, `union` or `class`) AST node |\n-| [dclass.d](https://github.com/dlang/dmd/blob/master/src/dmd/dclass.d)             | Define a `class` AST node                                   |\n-| [dstruct.d](https://github.com/dlang/dmd/blob/master/src/dmd/dstruct.d)           | Define a `struct` or `union` AST node                       |\n-| [init.d](https://github.com/dlang/dmd/blob/master/src/dmd/init.d)                 | Define variable initializers                                |\n+| [ast_node.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/ast_node.d)         | Define an abstract AST node class                           |\n+| [astbase.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/astbase.d)           | Namespace of AST nodes that can be produced by the parser   |\n+| [astcodegen.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/astcodegen.d)     | Namespace of AST nodes of a AST ready for code generation   |\n+| [astenums.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/astenums.d)         | Enums common to DMD and AST                                 |\n+| [expression.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/expression.d)     | Define expression AST nodes                                 |\n+| [statement.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/statement.d)       | Define statement AST nodes                                  |\n+| [staticassert.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/staticassert.d) | Define a `static assert` AST node                           |\n+| [aggregate.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/aggregate.d)       | Define an aggregate (`struct`, `union` or `class`) AST node |\n+| [dclass.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dclass.d)             | Define a `class` AST node                                   |\n+| [dstruct.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dstruct.d)           | Define a `struct` or `union` AST node                       |\n+| [init.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/init.d)                 | Define variable initializers                                |\n \n **AST visitors**\n \n | File                                                                                                      | Purpose                                                                          |\n |-----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|\n-| [parsetimevisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/parsetimevisitor.d)                 | General [visitor](https://en.wikipedia.org/wiki/Visitor_pattern) for AST nodes   |\n-| [permissivevisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/permissivevisitor.d)               | Subclass of ParseTimeVisitor that does not `assert(0)` on unimplemented nodes    |\n-| [strictvisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/strictvisitor.d)                       | Visitor that forces derived classes to implement `visit` for every possible node |\n-| [visitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/visitor.d)                                   | A visitor implementing `visit` for all nodes present in the compiler             |\n-| [transitivevisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/transitivevisitor.d)               | Provide a mixin template with visit methods for the parse time AST               |\n-| [apply.d](https://github.com/dlang/dmd/blob/master/src/dmd/apply.d)                                       | Depth-first expression visitor                                                   |\n-| [sapply.d](https://github.com/dlang/dmd/blob/master/src/dmd/sapply.d)                                     | Depth-first statement visitor                                                    |\n-| [statement_rewrite_walker.d](https://github.com/dlang/dmd/blob/master/src/dmd/statement_rewrite_walker.d) | Statement visitor that allows replacing the currently visited node               |\n+| [parsetimevisitor.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/parsetimevisitor.d)                 | General [visitor](https://en.wikipedia.org/wiki/Visitor_pattern) for AST nodes   |\n+| [permissivevisitor.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/permissivevisitor.d)               | Subclass of ParseTimeVisitor that does not `assert(0)` on unimplemented nodes    |\n+| [strictvisitor.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/strictvisitor.d)                       | Visitor that forces derived classes to implement `visit` for every possible node |\n+| [visitor.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/visitor.d)                                   | A visitor implementing `visit` for all nodes present in the compiler             |\n+| [transitivevisitor.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/transitivevisitor.d)               | Provide a mixin template with visit methods for the parse time AST               |\n+| [apply.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/apply.d)                                       | Depth-first expression visitor                                                   |\n+| [sapply.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/sapply.d)                                     | Depth-first statement visitor                                                    |\n+| [statement_rewrite_walker.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/statement_rewrite_walker.d) | Statement visitor that allows replacing the currently visited node               |\n \n **Semantic passes**\n \n | File                                                                                      | Purpose                                                           |\n |-------------------------------------------------------------------------------------------|-------------------------------------------------------------------|\n-| [dsymbolsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/dsymbolsem.d)             | Do semantic 1 pass (symbol identifiers/types)                     |\n-| [semantic2.d](https://github.com/dlang/dmd/blob/master/src/dmd/semantic2.d)               | Do semantic 2 pass (symbol initializers)                          |\n-| [semantic3.d](https://github.com/dlang/dmd/blob/master/src/dmd/semantic3.d)               | Do semantic 3 pass (function bodies)                              |\n-| [inline.d](https://github.com/dlang/dmd/blob/master/src/dmd/inline.d)                     | Do inline pass (optimization pass that dmd does in the front-end) |\n-| [inlinecost.d](https://github.com/dlang/dmd/blob/master/src/dmd/inlinecost.d)             | Compute the cost of inlining a function call.                     |\n-| [expressionsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/expressionsem.d)       | Do semantic analysis for expressions                              |\n-| [statementsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/statementsem.d)         | Do semantic analysis for statements                               |\n-| [initsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/initsem.d)                   | Do semantic analysis for initializers                             |\n-| [templateparamsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/templateparamsem.d) | Do semantic analysis for template parameters                      |\n-| [typesem.d](https://github.com/dlang/dmd/blob/master/src/dmd/typesem.d)                   | Do semantic analysis for types                                    |\n+| [dsymbolsem.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dsymbolsem.d)             | Do semantic 1 pass (symbol identifiers/types)                     |\n+| [semantic2.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/semantic2.d)               | Do semantic 2 pass (symbol initializers)                          |\n+| [semantic3.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/semantic3.d)               | Do semantic 3 pass (function bodies)                              |\n+| [inline.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/inline.d)                     | Do inline pass (optimization pass that dmd does in the front-end) |\n+| [inlinecost.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/inlinecost.d)             | Compute the cost of inlining a function call.                     |\n+| [expressionsem.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/expressionsem.d)       | Do semantic analysis for expressions                              |\n+| [statementsem.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/statementsem.d)         | Do semantic analysis for statements                               |\n+| [initsem.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/initsem.d)                   | Do semantic analysis for initializers                             |\n+| [templateparamsem.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/templateparamsem.d) | Do semantic analysis for template parameters                      |\n+| [typesem.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/typesem.d)                   | Do semantic analysis for types                                    |\n \n **Semantic helpers**\n \n | File                                                                          | Purpose                                                                                    |\n |-------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|\n-| [opover.d](https://github.com/dlang/dmd/blob/master/src/dmd/opover.d)         | Operator overloading                                                                       |\n-| [clone.d](https://github.com/dlang/dmd/blob/master/src/dmd/dsymbolsem.d)      | Generate automatic `opEquals`, `opAssign` and constructors for structs                     |\n-| [blockexit.d](https://github.com/dlang/dmd/blob/master/src/dmd/blockexit.d)   | Find out in what ways control flow can exit a block                                        |\n-| [ctorflow.d](https://github.com/dlang/dmd/blob/master/src/dmd/ctorflow.d)     | Control flow in constructors                                                               |\n-| [constfold.d](https://github.com/dlang/dmd/blob/master/src/dmd/constfold.d)   | Do constant folding of arithmetic expressions                                              |\n-| [optimize.d](https://github.com/dlang/dmd/blob/master/src/dmd/optimize.d)     | Do constant folding more generally                                                         |\n-| [dcast.d](https://github.com/dlang/dmd/blob/master/src/dmd/dcast.d)           | Implicit or explicit cast(), finding common types e.g. in `x ? a : b`, integral promotions |\n-| [impcnvtab.d](https://github.com/dlang/dmd/blob/master/src/dmd/impcnvtab.d)   | Define an implicit conversion table for basic types                                        |\n-| [importc.d](https://github.com/dlang/dmd/blob/master/src/dmd/importc.d)       | Helpers specific to ImportC                                                                |\n-| [sideeffect.d](https://github.com/dlang/dmd/blob/master/src/dmd/sideeffect.d) | Extract side-effects of expressions for certain lowerings.                                 |\n-| [mustuse.d](https://github.com/dlang/dmd/blob/master/src/dmd/mustuse.d)       | Helpers related to the `@mustuse` attribute                                                |\n+| [opover.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/opover.d)         | Operator overloading                                                                       |\n+| [clone.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dsymbolsem.d)      | Generate automatic `opEquals`, `opAssign` and constructors for structs                     |\n+| [blockexit.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/blockexit.d)   | Find out in what ways control flow can exit a block                                        |\n+| [ctorflow.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/ctorflow.d)     | Control flow in constructors                                                               |\n+| [constfold.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/constfold.d)   | Do constant folding of arithmetic expressions                                              |\n+| [optimize.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/optimize.d)     | Do constant folding more generally                                                         |\n+| [dcast.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dcast.d)           | Implicit or explicit cast(), finding common types e.g. in `x ? a : b`, integral promotions |\n+| [impcnvtab.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/impcnvtab.d)   | Define an implicit conversion table for basic types                                        |\n+| [importc.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/importc.d)       | Helpers specific to ImportC                                                                |\n+| [sideeffect.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/sideeffect.d) | Extract side-effects of expressions for certain lowerings.                                 |\n+| [mustuse.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/mustuse.d)       | Helpers related to the `@mustuse` attribute                                                |\n \n \n **Compile Time Function Execution (CTFE)**\n \n | File                                                                          | Purpose                                                                             |\n |-------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|\n-| [dinterpret.d](https://github.com/dlang/dmd/blob/master/src/dmd/dinterpret.d) | CTFE entry point                                                                    |\n-| [ctfeexpr.d](https://github.com/dlang/dmd/blob/master/src/dmd/ctfeexpr.d)     | CTFE for expressions involving pointers, slices, array concatenation etc.           |\n-| [builtin.d](https://github.com/dlang/dmd/blob/master/src/dmd/builtin.d)       | Allow CTFE of certain external functions (`core.math`, `std.math` and `core.bitop`) |\n+| [dinterpret.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dinterpret.d) | CTFE entry point                                                                    |\n+| [ctfeexpr.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/ctfeexpr.d)     | CTFE for expressions involving pointers, slices, array concatenation etc.           |\n+| [builtin.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/builtin.d)       | Allow CTFE of certain external functions (`core.math`, `std.math` and `core.bitop`) |\n \n ### Specific language features\n \n **Attribute checks**\n \n | File                                                                      | Purpose                                |\n |---------------------------------------------------------------------------|----------------------------------------|\n-| [nogc.d](https://github.com/dlang/dmd/blob/master/src/dmd/nogc.d)         | `@nogc` checks                         |\n-| [safe.d](https://github.com/dlang/dmd/blob/master/src/dmd/safe.d)         | `@safe` checks                         |\n-| [canthrow.d](https://github.com/dlang/dmd/blob/master/src/dmd/canthrow.d) | `nothrow` checks                       |\n-| [escape.d](https://github.com/dlang/dmd/blob/master/src/dmd/escape.d)     | `scope` checks                         |\n-| [access.d](https://github.com/dlang/dmd/blob/master/src/dmd/access.d)     | `public` / `private` checks            |\n-| [ob.d](https://github.com/dlang/dmd/blob/master/src/dmd/ob.d)             | Ownership / borrowing (`@live`) checks |\n+| [nogc.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/nogc.d)         | `@nogc` checks                         |\n+| [safe.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/safe.d)         | `@safe` checks                         |\n+| [canthrow.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/canthrow.d) | `nothrow` checks                       |\n+| [escape.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/escape.d)     | `scope` checks                         |\n+| [access.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/access.d)     | `public` / `private` checks            |\n+| [ob.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/ob.d)             | Ownership / borrowing (`@live`) checks |\n \n **Inline Assembly**\n \n | File                                                                    | Purpose                                   |\n |-------------------------------------------------------------------------|-------------------------------------------|\n-| [iasm.d](https://github.com/dlang/dmd/blob/master/src/dmd/iasm.d)       | Inline assembly depending on the compiler |\n-| [iasmdmd.d](https://github.com/dlang/dmd/blob/master/src/dmd/iasmdmd.d) | Inline assembly for DMD                   |\n-| [iasmgcc.d](https://github.com/dlang/dmd/blob/master/src/dmd/iasmgcc.d) | Inline assembly for GDC                   |\n+| [iasm.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/iasm.d)       | Inline assembly depending on the compiler |\n+| [iasmdmd.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/iasmdmd.d) | Inline assembly for DMD                   |\n+| [iasmgcc.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/iasmgcc.d) | Inline assembly for GDC                   |\n \n **Other**\n \n | File                                                                           | Purpose                                                                                     |\n |--------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|\n-| [aliasthis.d](https://github.com/dlang/dmd/blob/master/src/dmd/aliasthis.d)    | Resolve implicit conversions for `alias X this`                                             |\n-| [traits.d](https://github.com/dlang/dmd/blob/master/src/dmd/traits.d)          | `__traits()`                                                                                |\n-| [lambdacomp.d](https://github.com/dlang/dmd/blob/master/src/dmd/lambdacomp.d)  | `__traits(isSame, x => y, z => w)`                                                          |\n-| [cond.d](https://github.com/dlang/dmd/blob/master/src/dmd/cond.d)              | Evaluate `static if`, `version` `debug `                                                    |\n-| [staticcond.d](https://github.com/dlang/dmd/blob/master/src/dmd/staticcond.d)  | Lazily evaluate static conditions for `static if`, `static assert` and template constraints |\n-| [delegatize.d](https://github.com/dlang/dmd/blob/master/src/dmd/delegatize.d)  | Converts expression to delegates for `lazy` parameters                                      |\n-| [eh.d](https://github.com/dlang/dmd/blob/master/src/dmd/eh.d)                  | Generate tables for exception handling                                                      |\n-| [nspace.d](https://github.com/dlang/dmd/blob/master/src/dmd/nspace.d)          | Namespace for `extern (C++, Module)`                                                        |\n-| [intrange.d](https://github.com/dlang/dmd/blob/master/src/dmd/intrange.d)      | [Value range propagation](https://digitalmars.com/articles/b62.html)                        |\n-| [dimport.d](https://github.com/dlang/dmd/blob/master/src/dmd/dimport.d)        | Renamed imports (`import aliasSymbol = pkg1.pkg2.symbol`)                                   |\n-| [arrayop.d](https://github.com/dlang/dmd/blob/master/src/dmd/arrayop.d)        | Array operations (`a[] = b[] + c[]`)                                                        |\n-| [cpreprocess.d](https://github.com/dlang/dmd/blob/master/src/dmd/cpreprocess.d)| Run the C preprocessor on C source files                                                   |\n-| [typinf.d](https://github.com/dlang/dmd/blob/master/src/dmd/typinf.d)          | Generate typeinfo for `typeid()` (as well as internals)                                     |\n+| [aliasthis.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/aliasthis.d)    | Resolve implicit conversions for `alias X this`                                             |\n+| [traits.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/traits.d)          | `__traits()`                                                                                |\n+| [lambdacomp.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/lambdacomp.d)  | `__traits(isSame, x => y, z => w)`                                                          |\n+| [cond.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/cond.d)              | Evaluate `static if`, `version` `debug `                                                    |\n+| [staticcond.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/staticcond.d)  | Lazily evaluate static conditions for `static if`, `static assert` and template constraints |\n+| [delegatize.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/delegatize.d)  | Converts expression to delegates for `lazy` parameters                                      |\n+| [eh.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/eh.d)                  | Generate tables for exception handling                                                      |\n+| [nspace.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/nspace.d)          | Namespace for `extern (C++, Module)`                                                        |\n+| [intrange.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/intrange.d)      | [Value range propagation](https://digitalmars.com/articles/b62.html)                        |\n+| [dimport.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dimport.d)        | Renamed imports (`import aliasSymbol = pkg1.pkg2.symbol`)                                   |\n+| [arrayop.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/arrayop.d)        | Array operations (`a[] = b[] + c[]`)                                                        |\n+| [cpreprocess.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/cpreprocess.d)| Run the C preprocessor on C source files                                                   |\n+| [typinf.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/typinf.d)          | Generate typeinfo for `typeid()` (as well as internals)                                     |\n \n | File                                                                        | Purpose                                                                            |\n |-----------------------------------------------------------------------------|------------------------------------------------------------------------------------|\n-| [chkformat.d](https://github.com/dlang/dmd/blob/master/src/dmd/chkformat.d) | Validate arguments with format specifiers for `printf` / `scanf` etc.              |\n-| [imphint.d](https://github.com/dlang/dmd/blob/master/src/dmd/imphint.d)     | Give a suggestion to e.g. `import std.stdio` when `writeln` could not be resolved. |\n+| [chkformat.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/chkformat.d) | Validate arguments with format specifiers for `printf` / `scanf` etc.              |\n+| [imphint.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/imphint.d)     | Give a suggestion to e.g. `import std.stdio` when `writeln` could not be resolved. |\n \n ### Library files\n \n | File                                                                          | Purpose                                              |\n |-------------------------------------------------------------------------------|------------------------------------------------------|\n-| [lib.d](https://github.com/dlang/dmd/blob/master/src/dmd/lib.d)               | Abstract library class                               |\n-| [libelf.d](https://github.com/dlang/dmd/blob/master/src/dmd/libelf.d)         | Library in ELF format (Unix)                         |\n-| [libmach.d](https://github.com/dlang/dmd/blob/master/src/dmd/libmach.d)       | Library in Mach-O format (macOS)                     |\n-| [libmscoff.d](https://github.com/dlang/dmd/blob/master/src/dmd/libmscoff.d)   | Library in COFF format (32/64-bit Windows)           |\n-| [libomf.d](https://github.com/dlang/dmd/blob/master/src/dmd/libomf.d)         | Library in OMF format (legacy 32-bit Windows)        |\n-| [scanelf.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanelf.d)       | Extract symbol names from a library in ELF format    |\n-| [scanmach.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanmach.d)     | Extract symbol names from a library in Mach-O format |\n-| [scanmscoff.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanmscoff.d) | Extract symbol names from a library in COFF format   |\n-| [scanomf.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanomf.d)       | Extract symbol names from a library in OMF format    |\n+| [lib.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/lib.d)               | Abstract library class                               |\n+| [libelf.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/libelf.d)         | Library in ELF format (Unix)                         |\n+| [libmach.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/libmach.d)       | Library in Mach-O format (macOS)                     |\n+| [libmscoff.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/libmscoff.d)   | Library in COFF format (32/64-bit Windows)           |\n+| [libomf.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/libomf.d)         | Library in OMF format (legacy 32-bit Windows)        |\n+| [scanelf.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/scanelf.d)       | Extract symbol names from a library in ELF format    |\n+| [scanmach.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/scanmach.d)     | Extract symbol names from a library in Mach-O format |\n+| [scanmscoff.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/scanmscoff.d) | Extract symbol names from a library in COFF format   |\n+| [scanomf.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/scanomf.d)       | Extract symbol names from a library in OMF format    |\n \n ### Code generation / back-end interfacing\n \n | File                                                                                        | Purpose                                                                             |\n |---------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|\n-| [dmsc.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmsc.d)                           | Configures and initializes the back-end                                             |\n-| [toobj.d](https://github.com/dlang/dmd/blob/master/src/dmd/toobj.d)                         | Convert an AST that went through all semantic phases into an object file            |\n-| [toir.d](https://github.com/dlang/dmd/blob/master/src/dmd/toir.d)                           | Convert Dsymbols intermediate representation                                        |\n-| [e2ir.d](https://github.com/dlang/dmd/blob/master/src/dmd/e2ir.d)                           | Convert Expressions to intermediate representation                                  |\n-| [s2ir.d](https://github.com/dlang/dmd/blob/master/src/dmd/s2ir.d)                           | Convert Statements to intermediate representation                                   |\n-| [stmtstate.d](https://github.com/dlang/dmd/blob/master/src/dmd/stmtstate.d)                 | Used to help transform statement AST into flow graph                                |\n-| [toctype.d](https://github.com/dlang/dmd/blob/master/src/dmd/toctype.d)                     | Convert a D type to a type the back-end understands                                 |\n-| [tocsym.d](https://github.com/dlang/dmd/blob/master/src/dmd/tocsym.d)                       | Convert a D symbol to a symbol the linker understands (with mangled name)           |\n-| [argtypes_x86.d](https://github.com/dlang/dmd/blob/master/src/dmd/argtypes_x86.d)           | Convert a D type into simple (register) types for the 32-bit x86 ABI                |\n-| [argtypes_sysv_x64.d](https://github.com/dlang/dmd/blob/master/src/dmd/argtypes_sysv_x64.d) | 'argtypes' for the x86_64 System V ABI                                              |\n-| [argtypes_aarch64.d](https://github.com/dlang/dmd/blob/master/src/dmd/argtypes_aarch64.d)   | 'argtypes' for the AArch64 ABI                                                      |\n-| [glue.d](https://github.com/dlang/dmd/blob/master/src/dmd/glue.d)                           | Generate the object file for function declarations                                  |\n-| [gluelayer.d](https://github.com/dlang/dmd/blob/master/src/dmd/gluelayer.d)                 | Declarations for back-end functions that the front-end invokes                      |\n-| [todt.d](https://github.com/dlang/dmd/blob/master/src/dmd/todt.d)                           | Convert initializers into structures that the back-end will add to the data segment |\n-| [tocvdebug.d](https://github.com/dlang/dmd/blob/master/src/dmd/tovcdebug.d)                 | Generate debug info in the CV4 debug format.                                        |\n-| [objc.d](https://github.com/dlang/dmd/blob/master/src/dmd/objc.d)                           | Objective-C interfacing                                                             |\n-| [objc_glue.d](https://github.com/dlang/dmd/blob/master/src/dmd/objc_glue.d)                 | Glue code for Objective-C interop.                                                  |\n+| [dmsc.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dmsc.d)                           | Configures and initializes the back-end                                             |\n+| [toobj.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/toobj.d)                         | Convert an AST that went through all semantic phases into an object file            |\n+| [toir.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/toir.d)                           | Convert Dsymbols intermediate representation                                        |\n+| [e2ir.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/e2ir.d)                           | Convert Expressions to intermediate representation                                  |\n+| [s2ir.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/s2ir.d)                           | Convert Statements to intermediate representation                                   |\n+| [stmtstate.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/stmtstate.d)                 | Used to help transform statement AST into flow graph                                |\n+| [toctype.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/toctype.d)                     | Convert a D type to a type the back-end understands                                 |\n+| [tocsym.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/tocsym.d)                       | Convert a D symbol to a symbol the linker understands (with mangled name)           |\n+| [argtypes_x86.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/argtypes_x86.d)           | Convert a D type into simple (register) types for the 32-bit x86 ABI                |\n+| [argtypes_sysv_x64.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/argtypes_sysv_x64.d) | 'argtypes' for the x86_64 System V ABI                                              |\n+| [argtypes_aarch64.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/argtypes_aarch64.d)   | 'argtypes' for the AArch64 ABI                                                      |\n+| [glue.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/glue.d)                           | Generate the object file for function declarations                                  |\n+| [gluelayer.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/gluelayer.d)                 | Declarations for back-end functions that the front-end invokes                      |\n+| [todt.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/todt.d)                           | Convert initializers into structures that the back-end will add to the data segment |\n+| [tocvdebug.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/tovcdebug.d)                 | Generate debug info in the CV4 debug format.                                        |\n+| [objc.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/objc.d)                           | Objective-C interfacing                                                             |\n+| [objc_glue.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/objc_glue.d)                 | Glue code for Objective-C interop.                                                  |\n \n **Name mangling**\n \n | File                                                                              | Purpose                                                          |\n |-----------------------------------------------------------------------------------|------------------------------------------------------------------|\n-| [cppmangle.d](https://github.com/dlang/dmd/blob/master/src/dmd/cppmangle.d)       | C++ name mangling                                                |\n-| [cppmanglewin.d](https://github.com/dlang/dmd/blob/master/src/dmd/cppmanglewin.d) | C++ name mangling for Windows                                    |\n-| [dmangle.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmangle.d)           | D [name mangling](https://dlang.org/spec/abi.html#name_mangling) |\n+| [cppmangle.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/cppmangle.d)       | C++ name mangling                                                |\n+| [cppmanglewin.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/cppmanglewin.d) | C++ name mangling for Windows                                    |\n+| [dmangle.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dmangle.d)           | D [name mangling](https://dlang.org/spec/abi.html#name_mangling) |\n \n ### Linking\n \n | File                                                              | Purpose                                 |\n |-------------------------------------------------------------------|-----------------------------------------|\n-| [link.d](https://github.com/dlang/dmd/blob/master/src/dmd/link.d) | Invoke the linker as a separate process |\n+| [link.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/link.d) | Invoke the linker as a separate process |\n \n ### Special output\n \n | File                                                                  | Purpose                                                                                                 |\n |-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|\n-| [doc.d](https://github.com/dlang/dmd/blob/master/src/dmd/doc.d)       | [Documentation generation](https://dlang.org/spec/ddoc.html)                                            |\n-| [dmacro.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmacro.d) | DDoc macro processing                                                                                   |\n-| [hdrgen.d](https://github.com/dlang/dmd/blob/master/src/dmd/hdrgen.d) | Convert an AST into D source code for `.di` header generation, as well as `-vcg-ast` and error messages |\n-| [json.d](https://github.com/dlang/dmd/blob/master/src/dmd/json.d)     | Describe the module in a `.json` file for the `-X` flag                                                 |\n-| [dtoh.d](https://github.com/dlang/dmd/blob/master/src/dmd/dtoh.d)     | C++ header generation from D source files                                                               |\n+| [doc.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/doc.d)       | [Documentation generation](https://dlang.org/spec/ddoc.html)                                            |\n+| [dmacro.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dmacro.d) | DDoc macro processing                                                                                   |\n+| [hdrgen.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/hdrgen.d) | Convert an AST into D source code for `.di` header generation, as well as `-vcg-ast` and error messages |\n+| [json.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/json.d)     | Describe the module in a `.json` file for the `-X` flag                                                 |\n+| [dtoh.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/dtoh.d)     | C++ header generation from D source files                                                               |\n \n ### Utility\n \n-Note: many other utilities are in [dmd/root](https://github.com/dlang/dmd/tree/master/src/dmd/root).\n+Note: many other utilities are in [dmd/root](https://github.com/dlang/dmd/tree/master/compiler/src/dmd/root).\n \n | File                                                                              | Purpose                                           |\n |-----------------------------------------------------------------------------------|---------------------------------------------------|\n-| [console.d](https://github.com/dlang/dmd/blob/master/src/dmd/console.d)           | Print error messages in color                     |\n-| [file_manager.d](https://github.com/dlang/dmd/blob/master/src/dmd/file_manager.d) | Keep file contents in memory                      |\n-| [utils.d](https://github.com/dlang/dmd/blob/master/src/dmd/utils.d)               | Utility functions related to files and file paths |\n+| [console.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/console.d)           | Print error messages in color                     |\n+| [file_manager.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/file_manager.d) | Keep file contents in memory                      |\n+| [utils.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/utils.d)               | Utility functions related to files and file paths |\n \n | File                                                                            | Purpose                                                       |\n |---------------------------------------------------------------------------------|---------------------------------------------------------------|\n-| [asttypename.d](https://github.com/dlang/dmd/blob/master/src/dmd/asttypename.d) | Print the internal name of an AST node (for debugging only)   |\n-| [printast.d](https://github.com/dlang/dmd/blob/master/src/dmd/printast.d)       | Print the AST data structure                                  |\n-| [foreachvar.d](https://github.com/dlang/dmd/blob/master/src/dmd/foreachvar.d)   | Used in `ob.d` to iterate over all variables in an expression |\n+| [asttypename.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/asttypename.d) | Print the internal name of an AST node (for debugging only)   |\n+| [printast.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/printast.d)       | Print the AST data structure                                  |\n+| [foreachvar.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/foreachvar.d)   | Used in `ob.d` to iterate over all variables in an expression |"}, {"sha": "091e96a82c132121f4e6b21c10e1da0d0b57776c", "filename": "gcc/d/dmd/astenums.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fastenums.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fastenums.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fastenums.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -68,7 +68,6 @@ enum STC : ulong  // transfer changes to declaration.h\n     ref_                = 0x4_0000,   /// `ref`\n     scope_              = 0x8_0000,   /// `scope`\n \n-    maybescope          = 0x10_0000,   /// parameter might be `scope`\n     scopeinferred       = 0x20_0000,   /// `scope` has been inferred and should not be part of mangling, `scope_` must also be set\n     return_             = 0x40_0000,   /// 'return ref' or 'return scope' for function parameters\n     returnScope         = 0x80_0000,   /// if `ref return scope` then resolve to `ref` and `return scope`"}, {"sha": "088ca61537e9a4373750653418b81d3bbc4e589c", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -114,8 +114,10 @@ extern (C++) /* CT */ BE canThrow(Expression e, FuncDeclaration func, bool mustN\n                         import dmd.id : Id;\n \n                         auto sd = ts.sym;\n+                        const id = ce.f.ident;\n                         if (sd.postblit &&\n-                            (ce.f.ident == Id._d_arrayctor || ce.f.ident == Id._d_arraysetctor))\n+                            (id == Id._d_arrayctor || id == Id._d_arraysetctor ||\n+                            id == Id._d_arrayassign_l || id == Id._d_arrayassign_r))\n                         {\n                             checkFuncThrows(ce, sd.postblit);\n                             return;"}, {"sha": "853fd4ff502a9f736ce13a2f1c776002f417e7e8", "filename": "gcc/d/dmd/common/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2,7 +2,7 @@\n \n | File                                                                               | Purpose                                                         |\n |------------------------------------------------------------------------------------|-----------------------------------------------------------------|\n-| [bitfields.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/bitfields.d) | Pack multiple boolean fields into bit fields                    |\n-| [file.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/file.d)           | Functions and objects dedicated to file I/O and management      |\n-| [outbuffer.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/outbuffer.d) | An expandable buffer in which you can write text or binary data |\n-| [string.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/string.d)       | Common string functions including filename manipulation         |\n+| [bitfields.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/common/bitfields.d) | Pack multiple boolean fields into bit fields                    |\n+| [file.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/common/file.d)           | Functions and objects dedicated to file I/O and management      |\n+| [outbuffer.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/common/outbuffer.d) | An expandable buffer in which you can write text or binary data |\n+| [string.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/common/string.d)       | Common string functions including filename manipulation         |"}, {"sha": "9d544a400fed17cc964d492996d0d6bb9794dadd", "filename": "gcc/d/dmd/common/outbuffer.d", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -109,12 +109,12 @@ struct OutBuffer\n     }\n \n     /// For porting with ease from dmd.backend.outbuf.Outbuffer\n-    ubyte* buf() nothrow {\n+    ubyte* buf() nothrow @system {\n         return data.ptr;\n     }\n \n     /// For porting with ease from dmd.backend.outbuf.Outbuffer\n-    ubyte** bufptr() nothrow {\n+    ubyte** bufptr() nothrow @system {\n         static struct Array { size_t length; ubyte* ptr; }\n         auto a = cast(Array*) &data;\n         assert(a.length == data.length && a.ptr == data.ptr);\n@@ -156,7 +156,7 @@ struct OutBuffer\n     Params:\n     nbytes = the number of additional bytes to reserve\n     */\n-    extern (C++) void reserve(size_t nbytes) pure nothrow\n+    extern (C++) void reserve(size_t nbytes) pure nothrow @trusted\n     {\n         //debug (stomp) printf(\"OutBuffer::reserve: size = %lld, offset = %lld, nbytes = %lld\\n\", data.length, offset, nbytes);\n         const minSize = offset + nbytes;\n@@ -210,7 +210,7 @@ struct OutBuffer\n         offset = 0;\n     }\n \n-    private void indent() pure nothrow\n+    private void indent() pure nothrow @safe\n     {\n         if (level)\n         {\n@@ -223,19 +223,19 @@ struct OutBuffer\n     }\n \n     // Write an array to the buffer, no reserve check\n-    @trusted nothrow\n+    @system nothrow\n     void writen(const void *b, size_t len)\n     {\n         memcpy(data.ptr + offset, b, len);\n         offset += len;\n     }\n \n-    extern (C++) void write(const(void)* data, size_t nbytes) pure nothrow\n+    extern (C++) void write(const(void)* data, size_t nbytes) pure nothrow @system\n     {\n         write(data[0 .. nbytes]);\n     }\n \n-    void write(const(void)[] buf) pure nothrow\n+    void write(scope const(void)[] buf) pure nothrow @trusted\n     {\n         if (doindent && !notlinehead)\n             indent();\n@@ -282,7 +282,7 @@ struct OutBuffer\n     }\n \n     /// NOT zero-terminated\n-    extern (C++) void writestring(const(char)* s) pure nothrow\n+    extern (C++) void writestring(const(char)* s) pure nothrow @system\n     {\n         if (!s)\n             return;\n@@ -291,45 +291,45 @@ struct OutBuffer\n     }\n \n     /// ditto\n-    void writestring(const(char)[] s) pure nothrow\n+    void writestring(scope const(char)[] s) pure nothrow @safe\n     {\n         write(s);\n     }\n \n     /// ditto\n-    void writestring(string s) pure nothrow\n+    void writestring(scope string s) pure nothrow @safe\n     {\n         write(s);\n     }\n \n     /// NOT zero-terminated, followed by newline\n-    void writestringln(const(char)[] s) pure nothrow\n+    void writestringln(const(char)[] s) pure nothrow @safe\n     {\n         writestring(s);\n         writenl();\n     }\n \n     /** Write string to buffer, ensure it is zero terminated\n      */\n-    void writeStringz(const(char)* s) pure nothrow @trusted\n+    void writeStringz(const(char)* s) pure nothrow @system\n     {\n         write(s[0 .. strlen(s)+1]);\n     }\n \n     /// ditto\n-    void writeStringz(const(char)[] s) pure nothrow\n+    void writeStringz(const(char)[] s) pure nothrow @safe\n     {\n         write(s);\n         writeByte(0);\n     }\n \n     /// ditto\n-    void writeStringz(string s) pure nothrow\n+    void writeStringz(string s) pure nothrow @safe\n     {\n         writeStringz(cast(const(char)[])(s));\n     }\n \n-    extern (C++) void prependstring(const(char)* string) pure nothrow\n+    extern (C++) void prependstring(const(char)* string) pure nothrow @system\n     {\n         size_t len = strlen(string);\n         reserve(len);\n@@ -339,7 +339,7 @@ struct OutBuffer\n     }\n \n     /// write newline\n-    extern (C++) void writenl() pure nothrow\n+    extern (C++) void writenl() pure nothrow @safe\n     {\n         version (Windows)\n         {\n@@ -385,7 +385,7 @@ struct OutBuffer\n         this.data[offset++] = cast(ubyte) b;\n     }\n \n-    extern (C++) void writeByte(uint b) pure nothrow\n+    extern (C++) void writeByte(uint b) pure nothrow @safe\n     {\n         if (doindent && !notlinehead && b != '\\n')\n             indent();\n@@ -394,7 +394,7 @@ struct OutBuffer\n         offset++;\n     }\n \n-    extern (C++) void writeUTF8(uint b) pure nothrow\n+    extern (C++) void writeUTF8(uint b) pure nothrow @safe\n     {\n         reserve(6);\n         if (b <= 0x7F)\n@@ -427,15 +427,15 @@ struct OutBuffer\n             assert(0);\n     }\n \n-    extern (C++) void prependbyte(uint b) pure nothrow\n+    extern (C++) void prependbyte(uint b) pure nothrow @trusted\n     {\n         reserve(1);\n         memmove(data.ptr + 1, data.ptr, offset);\n         data[0] = cast(ubyte)b;\n         offset++;\n     }\n \n-    extern (C++) void writewchar(uint w) pure nothrow\n+    extern (C++) void writewchar(uint w) pure nothrow @safe\n     {\n         version (Windows)\n         {\n@@ -447,7 +447,7 @@ struct OutBuffer\n         }\n     }\n \n-    extern (C++) void writeword(uint w) pure nothrow\n+    extern (C++) void writeword(uint w) pure nothrow @trusted\n     {\n         version (Windows)\n         {\n@@ -465,7 +465,7 @@ struct OutBuffer\n         offset += 2;\n     }\n \n-    extern (C++) void writeUTF16(uint w) pure nothrow\n+    extern (C++) void writeUTF16(uint w) pure nothrow @trusted\n     {\n         reserve(4);\n         if (w <= 0xFFFF)\n@@ -483,7 +483,7 @@ struct OutBuffer\n             assert(0);\n     }\n \n-    extern (C++) void write4(uint w) pure nothrow\n+    extern (C++) void write4(uint w) pure nothrow @trusted\n     {\n         version (Windows)\n         {\n@@ -500,7 +500,7 @@ struct OutBuffer\n         offset += 4;\n     }\n \n-    extern (C++) void write(const OutBuffer* buf) pure nothrow\n+    extern (C++) void write(const OutBuffer* buf) pure nothrow @trusted\n     {\n         if (buf)\n         {\n@@ -510,7 +510,7 @@ struct OutBuffer\n         }\n     }\n \n-    extern (C++) void fill0(size_t nbytes) pure nothrow\n+    extern (C++) void fill0(size_t nbytes) pure nothrow @trusted\n     {\n         reserve(nbytes);\n         memset(data.ptr + offset, 0, nbytes);\n@@ -531,7 +531,7 @@ struct OutBuffer\n         return cast(char[])data[offset - nbytes .. offset];\n     }\n \n-    extern (C++) void vprintf(const(char)* format, va_list args) nothrow\n+    extern (C++) void vprintf(const(char)* format, va_list args) nothrow @system\n     {\n         int count;\n         if (doindent && !notlinehead)\n@@ -567,7 +567,7 @@ struct OutBuffer\n \n     static if (__VERSION__ < 2092)\n     {\n-        extern (C++) void printf(const(char)* format, ...) nothrow\n+        extern (C++) void printf(const(char)* format, ...) nothrow @system\n         {\n             va_list ap;\n             va_start(ap, format);\n@@ -577,7 +577,7 @@ struct OutBuffer\n     }\n     else\n     {\n-        pragma(printf) extern (C++) void printf(const(char)* format, ...) nothrow\n+        pragma(printf) extern (C++) void printf(const(char)* format, ...) nothrow @system\n         {\n             va_list ap;\n             va_start(ap, format);\n@@ -591,13 +591,13 @@ struct OutBuffer\n      * Params:\n      *  u = integral value to append\n      */\n-    extern (C++) void print(ulong u) pure nothrow\n+    extern (C++) void print(ulong u) pure nothrow @safe\n     {\n         UnsignedStringBuf buf = void;\n         writestring(unsignedToTempString(u, buf));\n     }\n \n-    extern (C++) void bracket(char left, char right) pure nothrow\n+    extern (C++) void bracket(char left, char right) pure nothrow @trusted\n     {\n         reserve(2);\n         memmove(data.ptr + 1, data.ptr, offset);\n@@ -610,7 +610,7 @@ struct OutBuffer\n      * Insert left at i, and right at j.\n      * Return index just past right.\n      */\n-    extern (C++) size_t bracket(size_t i, const(char)* left, size_t j, const(char)* right) pure nothrow\n+    extern (C++) size_t bracket(size_t i, const(char)* left, size_t j, const(char)* right) pure nothrow @system\n     {\n         size_t leftlen = strlen(left);\n         size_t rightlen = strlen(right);\n@@ -620,7 +620,7 @@ struct OutBuffer\n         return j + leftlen + rightlen;\n     }\n \n-    extern (C++) void spread(size_t offset, size_t nbytes) pure nothrow\n+    extern (C++) void spread(size_t offset, size_t nbytes) pure nothrow @system\n     {\n         reserve(nbytes);\n         memmove(data.ptr + offset + nbytes, data.ptr + offset, this.offset - offset);\n@@ -630,19 +630,19 @@ struct OutBuffer\n     /****************************************\n      * Returns: offset + nbytes\n      */\n-    extern (C++) size_t insert(size_t offset, const(void)* p, size_t nbytes) pure nothrow\n+    extern (C++) size_t insert(size_t offset, const(void)* p, size_t nbytes) pure nothrow @system\n     {\n         spread(offset, nbytes);\n         memmove(data.ptr + offset, p, nbytes);\n         return offset + nbytes;\n     }\n \n-    size_t insert(size_t offset, const(char)[] s) pure nothrow\n+    size_t insert(size_t offset, const(char)[] s) pure nothrow @system\n     {\n         return insert(offset, s.ptr, s.length);\n     }\n \n-    extern (C++) void remove(size_t offset, size_t nbytes) pure nothrow @nogc\n+    extern (C++) void remove(size_t offset, size_t nbytes) pure nothrow @nogc @system\n     {\n         memmove(data.ptr + offset, data.ptr + offset + nbytes, this.offset - (offset + nbytes));\n         this.offset -= nbytes;\n@@ -716,7 +716,7 @@ struct OutBuffer\n         return extractData();\n     }\n \n-    void writesLEB128(int value) pure nothrow\n+    void writesLEB128(int value) pure nothrow @safe\n     {\n         while (1)\n         {\n@@ -733,7 +733,7 @@ struct OutBuffer\n         }\n     }\n \n-    void writeuLEB128(uint value) pure nothrow\n+    void writeuLEB128(uint value) pure nothrow @safe\n     {\n         do\n         {\n@@ -758,7 +758,7 @@ struct OutBuffer\n \n     Returns: `true` iff the operation succeeded.\n     */\n-    extern(D) bool moveToFile(const char* filename)\n+    extern(D) bool moveToFile(const char* filename) @system\n     {\n         bool result = true;\n         const bool identical = this[] == FileMapping!(const ubyte)(filename)[];\n@@ -799,7 +799,7 @@ private:\n \n alias UnsignedStringBuf = char[20];\n \n-char[] unsignedToTempString(ulong value, char[] buf, uint radix = 10) @safe pure nothrow @nogc\n+char[] unsignedToTempString(ulong value, return scope char[] buf, uint radix = 10) @safe pure nothrow @nogc\n {\n     size_t i = buf.length;\n     do"}, {"sha": "6243e74410cff9b860a440e8a93a1393b9558470", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -357,15 +357,31 @@ UnionExp copyLiteral(Expression e)\n         r.origin = sle.origin;\n         return ue;\n     }\n-    if (e.op == EXP.function_ || e.op == EXP.delegate_ || e.op == EXP.symbolOffset || e.op == EXP.null_ || e.op == EXP.variable || e.op == EXP.dotVariable || e.op == EXP.int64 || e.op == EXP.float64 || e.op == EXP.char_ || e.op == EXP.complex80 || e.op == EXP.void_ || e.op == EXP.vector || e.op == EXP.typeid_)\n-    {\n+\n+    switch(e.op)\n+    {\n+    case EXP.function_:\n+    case EXP.delegate_:\n+    case EXP.symbolOffset:\n+    case EXP.null_:\n+    case EXP.variable:\n+    case EXP.dotVariable:\n+    case EXP.int64:\n+    case EXP.float64:\n+    case EXP.char_:\n+    case EXP.complex80:\n+    case EXP.void_:\n+    case EXP.vector:\n+    case EXP.typeid_:\n         // Simple value types\n         // Keep e1 for DelegateExp and DotVarExp\n         emplaceExp!(UnionExp)(&ue, e);\n         Expression r = ue.exp();\n         r.type = e.type;\n         return ue;\n+    default: break;\n     }\n+\n     if (auto se = e.isSliceExp())\n     {\n         if (se.type.toBasetype().ty == Tsarray)"}, {"sha": "ff27e37c7dc364bcd3cb283e86685f7fe043748d", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -563,8 +563,9 @@ extern (C++) abstract class Declaration : Dsymbol\n extern (C++) final class TupleDeclaration : Declaration\n {\n     Objects* objects;\n-    bool isexp;             // true: expression tuple\n     TypeTuple tupletype;    // !=null if this is a type tuple\n+    bool isexp;             // true: expression tuple\n+    bool building;          // it's growing in AliasAssign semantic\n \n     extern (D) this(const ref Loc loc, Identifier ident, Objects* objects)\n     {\n@@ -588,7 +589,7 @@ extern (C++) final class TupleDeclaration : Declaration\n          */\n \n         //printf(\"TupleDeclaration::getType() %s\\n\", toChars());\n-        if (isexp)\n+        if (isexp || building)\n             return null;\n         if (!tupletype)\n         {\n@@ -931,6 +932,19 @@ extern (C++) final class AliasDeclaration : Declaration\n         }\n         else\n         {\n+            // stop AliasAssign tuple building\n+            if (aliassym)\n+            {\n+                if (auto td = aliassym.isTupleDeclaration())\n+                {\n+                    if (td.building)\n+                    {\n+                        td.building = false;\n+                        semanticRun = PASS.semanticdone;\n+                        return td;\n+                    }\n+                }\n+            }\n             if (_import && _import._scope)\n             {\n                 /* If this is an internal alias for selective/renamed import,\n@@ -1076,7 +1090,7 @@ extern (C++) class VarDeclaration : Declaration\n     VarDeclaration lastVar;         // Linked list of variables for goto-skips-init detection\n     Expression edtor;               // if !=null, does the destruction of the variable\n     IntRange* range;                // if !=null, the variable is known to be within the range\n-    VarDeclarations* maybes;        // STC.maybescope variables that are assigned to this STC.maybescope variable\n+    VarDeclarations* maybes;        // maybeScope variables that are assigned to this maybeScope variable\n \n     uint endlinnum;                 // line number of end of scope that this var lives in\n     uint offset;\n@@ -1105,7 +1119,7 @@ extern (C++) class VarDeclaration : Declaration\n \n         bool overlapped;        /// if it is a field and has overlapping\n         bool overlapUnsafe;     /// if it is an overlapping field and the overlaps are unsafe\n-        bool doNotInferScope;   /// do not infer 'scope' for this variable\n+        bool maybeScope;        /// allow inferring 'scope' for this variable\n         bool doNotInferReturn;  /// do not infer 'return' for this variable\n \n         bool isArgDtorVar;      /// temporary created to handle scope destruction of a function argument"}, {"sha": "bc8db441e60d007ec702c08d1349d28827823d0a", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -59,7 +59,6 @@ struct AttributeViolation;\n     #define STCref                0x40000ULL    /// `ref`\n     #define STCscope              0x80000ULL    /// `scope`\n \n-    #define STCmaybescope         0x100000ULL    /// parameter might be `scope`\n     #define STCscopeinferred      0x200000ULL    /// `scope` has been inferred and should not be part of mangling, `scope` must also be set\n     #define STCreturn             0x400000ULL    /// 'return ref' or 'return scope' for function parameters\n     #define STCreturnScope        0x800000ULL    /// if `ref return scope` then resolve to `ref` and `return scope`\n@@ -166,9 +165,9 @@ class TupleDeclaration final : public Declaration\n {\n public:\n     Objects *objects;\n-    bool isexp;                 // true: expression tuple\n-\n     TypeTuple *tupletype;       // !=NULL if this is a type tuple\n+    bool isexp;                 // true: expression tuple\n+    bool building;              // it's growing in AliasAssign semantic\n \n     TupleDeclaration *syntaxCopy(Dsymbol *) override;\n     const char *kind() const override;\n@@ -264,8 +263,8 @@ class VarDeclaration : public Declaration\n     bool overlapped(bool v);\n     bool overlapUnsafe() const; // if it is an overlapping field and the overlaps are unsafe\n     bool overlapUnsafe(bool v);\n-    bool doNotInferScope() const; // do not infer 'scope' for this variable\n-    bool doNotInferScope(bool v);\n+    bool maybeScope() const; // allow inferring 'scope' for this variable\n+    bool maybeScope(bool v);\n     bool doNotInferReturn() const; // do not infer 'return' for this variable\n     bool doNotInferReturn(bool v);\n     bool isArgDtorVar() const; // temporary created to handle scope destruction of a function argument"}, {"sha": "5cc3772d0526f93052fe698a35a5598502626acf", "filename": "gcc/d/dmd/dimport.d", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdimport.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdimport.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -223,7 +223,16 @@ extern (C++) final class Import : Dsymbol\n     override void importAll(Scope* sc)\n     {\n         if (mod) return; // Already done\n-        load(sc);\n+\n+        /*\n+         * https://issues.dlang.org/show_bug.cgi?id=15525\n+         *\n+         * Loading the import has failed,\n+         * most likely because of parsing errors.\n+         * Therefore we cannot trust the resulting AST.\n+         */\n+        if (load(sc)) return;\n+\n         if (!mod) return; // Failed\n \n         if (sc.stc & STC.static_)"}, {"sha": "a9fd0f56bc034295dede8d0f6cce5629169b7702", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -4778,6 +4778,12 @@ public:\n             // If `_d_HookTraceImpl` is found, resolve the underlying hook and replace `e` and `fd` with it.\n             removeHookTraceImpl(e, fd);\n \n+            bool isArrayConstructionOrAssign(FuncDeclaration fd)\n+            {\n+                return fd.ident == Id._d_arrayctor || fd.ident == Id._d_arraysetctor ||\n+                fd.ident == Id._d_arrayassign_l || fd.ident == Id._d_arrayassign_r;\n+            }\n+\n             if (fd.ident == Id.__ArrayPostblit || fd.ident == Id.__ArrayDtor)\n             {\n                 assert(e.arguments.dim == 1);\n@@ -4831,27 +4837,36 @@ public:\n                 result = interpretRegion(ae, istate);\n                 return;\n             }\n-            else if (fd.ident == Id._d_arrayctor || fd.ident == Id._d_arraysetctor)\n+            else if (isArrayConstructionOrAssign(fd))\n             {\n-                // In expressionsem.d `T[x] ea = eb;` was lowered to `_d_array{,set}ctor(ea[], eb[]);`.\n-                // The following code will rewrite it back to `ea = eb` and then interpret that expression.\n-                if (fd.ident == Id._d_arraysetctor)\n-                    assert(e.arguments.dim == 2);\n-                else\n+                // In expressionsem.d, the following lowerings were performed:\n+                // * `T[x] ea = eb;` to `_d_array{,set}ctor(ea[], eb[]);`.\n+                // * `ea = eb` (ea and eb are arrays) to `_d_arrayassign_{l,r}(ea[], eb[])`.\n+                // The following code will rewrite them back to `ea = eb` and\n+                // then interpret that expression.\n+\n+                if (fd.ident == Id._d_arrayctor)\n                     assert(e.arguments.dim == 3);\n+                else\n+                    assert(e.arguments.dim == 2);\n \n                 Expression ea = (*e.arguments)[0];\n                 if (ea.isCastExp)\n                     ea = ea.isCastExp.e1;\n \n                 Expression eb = (*e.arguments)[1];\n-                if (eb.isCastExp && fd.ident == Id._d_arrayctor)\n+                if (eb.isCastExp() && fd.ident != Id._d_arraysetctor)\n                     eb = eb.isCastExp.e1;\n \n-                ConstructExp ce = new ConstructExp(e.loc, ea, eb);\n-                ce.type = ea.type;\n+                Expression rewrittenExp;\n+                if (fd.ident == Id._d_arrayctor || fd.ident == Id._d_arraysetctor)\n+                    rewrittenExp = new ConstructExp(e.loc, ea, eb);\n+                else\n+                    rewrittenExp = new AssignExp(e.loc, ea, eb);\n+\n+                rewrittenExp.type = ea.type;\n+                result = interpret(rewrittenExp, istate);\n \n-                result = interpret(ce, istate);\n                 return;\n             }\n             else if (fd.ident == Id._d_arrayappendT || fd.ident == Id._d_arrayappendTTrace)"}, {"sha": "358712b884c0fb2aa94d6714d27993d66e89b1ec", "filename": "gcc/d/dmd/dmacro.d", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdmacro.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdmacro.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -14,8 +14,6 @@ module dmd.dmacro;\n import core.stdc.ctype;\n import core.stdc.string;\n import dmd.doc;\n-import dmd.errors;\n-import dmd.globals;\n import dmd.common.outbuffer;\n import dmd.root.rmem;\n \n@@ -28,7 +26,7 @@ extern (C++) struct MacroTable\n      *  name = name of macro\n      *  text = text of macro\n      */\n-    extern (D) void define(const(char)[] name, const(char)[] text)\n+    extern (D) void define(const(char)[] name, const(char)[] text) nothrow pure @safe\n     {\n         //printf(\"MacroTable::define('%.*s' = '%.*s')\\n\", cast(int)name.length, name.ptr, text.length, text.ptr);\n         if (auto table = name in mactab)\n@@ -42,23 +40,21 @@ extern (C++) struct MacroTable\n     /*****************************************************\n      * Look for macros in buf and expand them in place.\n      * Only look at the text in buf from start to pend.\n+     *\n+     * Returns: `true` on success, `false` when the recursion limit was reached\n      */\n-    extern (D) void expand(ref OutBuffer buf, size_t start, ref size_t pend, const(char)[] arg)\n+    extern (D) bool expand(ref OutBuffer buf, size_t start, ref size_t pend, const(char)[] arg, int recursionLimit) nothrow pure\n     {\n         version (none)\n         {\n             printf(\"Macro::expand(buf[%d..%d], arg = '%.*s')\\n\", start, pend, cast(int)arg.length, arg.ptr);\n             printf(\"Buf is: '%.*s'\\n\", cast(int)(pend - start), buf.data + start);\n         }\n         // limit recursive expansion\n-        __gshared int nest;\n-        if (nest > global.recursionLimit)\n-        {\n-            error(Loc.initial, \"DDoc macro expansion limit exceeded; more than %d expansions.\",\n-                  global.recursionLimit);\n-            return;\n-        }\n-        nest++;\n+        recursionLimit--;\n+        if (recursionLimit < 0)\n+            return false;\n+\n         size_t end = pend;\n         assert(start <= end);\n         assert(end <= buf.length);\n@@ -105,7 +101,9 @@ extern (C++) struct MacroTable\n                     end += marg.length - 2;\n                     // Scan replaced text for further expansion\n                     size_t mend = u + marg.length;\n-                    expand(buf, u, mend, null);\n+                    const success = expand(buf, u, mend, null, recursionLimit);\n+                    if (!success)\n+                        return false;\n                     end += mend - (u + marg.length);\n                     u = mend;\n                 }\n@@ -121,7 +119,9 @@ extern (C++) struct MacroTable\n                     end += -2 + 2 + marg.length + 2;\n                     // Scan replaced text for further expansion\n                     size_t mend = u + 2 + marg.length;\n-                    expand(buf, u + 2, mend, null);\n+                    const success = expand(buf, u + 2, mend, null, recursionLimit);\n+                    if (!success)\n+                        return false;\n                     end += mend - (u + 2 + marg.length);\n                     u = mend;\n                 }\n@@ -228,7 +228,9 @@ extern (C++) struct MacroTable\n                             // Scan replaced text for further expansion\n                             m.inuse++;\n                             size_t mend = v + 1 + 2 + m.text.length + 2;\n-                            expand(buf, v + 1, mend, marg);\n+                            const success = expand(buf, v + 1, mend, marg, recursionLimit);\n+                            if (!success)\n+                                return false;\n                             end += mend - (v + 1 + 2 + m.text.length + 2);\n                             m.inuse--;\n                             buf.remove(u, v + 1 - u);\n@@ -253,12 +255,12 @@ extern (C++) struct MacroTable\n         }\n         mem.xfree(cast(char*)arg);\n         pend = end;\n-        nest--;\n+        return true;\n     }\n \n   private:\n \n-    extern (D) Macro* search(const(char)[] name)\n+    extern (D) Macro* search(const(char)[] name) @nogc nothrow pure @safe\n     {\n         //printf(\"Macro::search(%.*s)\\n\", cast(int)name.length, name.ptr);\n         if (auto table = name in mactab)\n@@ -282,7 +284,7 @@ struct Macro\n     const(char)[] text;     // macro replacement text\n     int inuse;              // macro is in use (don't expand)\n \n-    this(const(char)[] name, const(char)[] text)\n+    this(const(char)[] name, const(char)[] text) @nogc nothrow pure @safe\n     {\n         this.name = name;\n         this.text = text;\n@@ -297,7 +299,7 @@ struct Macro\n  *      copy allocated with mem.xmalloc()\n  */\n \n-char[] memdup(const(char)[] p)\n+char[] memdup(const(char)[] p) nothrow pure @trusted\n {\n     size_t len = p.length;\n     return (cast(char*)memcpy(mem.xmalloc(len), p.ptr, len))[0 .. len];\n@@ -312,7 +314,7 @@ char[] memdup(const(char)[] p)\n  *              1..9:   get nth argument\n  *              -1:     get 2nd through end\n  */\n-size_t extractArgN(const(char)[] buf, out const(char)[] marg, int n)\n+size_t extractArgN(const(char)[] buf, out const(char)[] marg, int n) @nogc nothrow pure\n {\n     /* Scan forward for matching right parenthesis.\n      * Nest parentheses."}, {"sha": "2cb1cc7482e2a1e5e1664dde341ef040e1627169", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -325,7 +325,6 @@ extern (C++) final class Module : Package\n     extern (C++) __gshared Dsymbols deferred;    // deferred Dsymbol's needing semantic() run on them\n     extern (C++) __gshared Dsymbols deferred2;   // deferred Dsymbol's needing semantic2() run on them\n     extern (C++) __gshared Dsymbols deferred3;   // deferred Dsymbol's needing semantic3() run on them\n-    extern (C++) __gshared uint dprogress;       // progress resolving the deferred list\n \n     static void _init()\n     {\n@@ -1300,39 +1299,38 @@ extern (C++) final class Module : Package\n     extern (D) static void addDeferredSemantic(Dsymbol s)\n     {\n         //printf(\"Module::addDeferredSemantic('%s')\\n\", s.toChars());\n-        deferred.push(s);\n+        if (!deferred.contains(s))\n+            deferred.push(s);\n     }\n \n     extern (D) static void addDeferredSemantic2(Dsymbol s)\n     {\n         //printf(\"Module::addDeferredSemantic2('%s')\\n\", s.toChars());\n-        deferred2.push(s);\n+        if (!deferred2.contains(s))\n+            deferred2.push(s);\n     }\n \n     extern (D) static void addDeferredSemantic3(Dsymbol s)\n     {\n         //printf(\"Module::addDeferredSemantic3('%s')\\n\", s.toChars());\n-        deferred3.push(s);\n+        if (!deferred.contains(s))\n+            deferred3.push(s);\n     }\n \n     /******************************************\n      * Run semantic() on deferred symbols.\n      */\n     static void runDeferredSemantic()\n     {\n-        if (dprogress == 0)\n-            return;\n-\n         __gshared int nested;\n         if (nested)\n             return;\n-        //if (deferred.dim) printf(\"+Module::runDeferredSemantic(), len = %d\\n\", deferred.dim);\n+        //if (deferred.dim) printf(\"+Module::runDeferredSemantic(), len = %ld\\n\", deferred.dim);\n         nested++;\n \n         size_t len;\n         do\n         {\n-            dprogress = 0;\n             len = deferred.dim;\n             if (!len)\n                 break;\n@@ -1358,13 +1356,13 @@ extern (C++) final class Module : Package\n                 s.dsymbolSemantic(null);\n                 //printf(\"deferred: %s, parent = %s\\n\", s.toChars(), s.parent.toChars());\n             }\n-            //printf(\"\\tdeferred.dim = %d, len = %d, dprogress = %d\\n\", deferred.dim, len, dprogress);\n+            //printf(\"\\tdeferred.dim = %ld, len = %ld\\n\", deferred.dim, len);\n             if (todoalloc)\n                 free(todoalloc);\n         }\n-        while (deferred.dim < len || dprogress); // while making progress\n+        while (deferred.dim != len); // while making progress\n         nested--;\n-        //printf(\"-Module::runDeferredSemantic(), len = %d\\n\", deferred.dim);\n+        //printf(\"-Module::runDeferredSemantic(), len = %ld\\n\", deferred.dim);\n     }\n \n     static void runDeferredSemantic2()"}, {"sha": "ba83649da63ee95e39e74be742cec692c7b04e25", "filename": "gcc/d/dmd/doc.d", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -226,12 +226,12 @@ private final class ParamSection : Section\n                     buf.writestring(\"$(DDOC_PARAM_ID \");\n                     {\n                         size_t o = buf.length;\n-                        Parameter fparam = isFunctionParameter(a, namestart, namelen);\n+                        Parameter fparam = isFunctionParameter(a, namestart[0 .. namelen]);\n                         if (!fparam)\n                         {\n                             // Comments on a template might refer to function parameters within.\n                             // Search the parameters of nested eponymous functions (with the same name.)\n-                            fparam = isEponymousFunctionParameter(a, namestart, namelen);\n+                            fparam = isEponymousFunctionParameter(a, namestart[0 ..  namelen]);\n                         }\n                         bool isCVariadic = isCVariadicParameter(a, namestart[0 .. namelen]);\n                         if (isCVariadic)\n@@ -328,7 +328,7 @@ private final class MacroSection : Section\n private alias Sections = Array!(Section);\n \n // Workaround for missing Parameter instance for variadic params. (it's unnecessary to instantiate one).\n-private bool isCVariadicParameter(Dsymbols* a, const(char)[] p)\n+private bool isCVariadicParameter(Dsymbols* a, const(char)[] p) @safe\n {\n     foreach (member; *a)\n     {\n@@ -339,7 +339,7 @@ private bool isCVariadicParameter(Dsymbols* a, const(char)[] p)\n     return false;\n }\n \n-private Dsymbol getEponymousMember(TemplateDeclaration td)\n+private Dsymbol getEponymousMember(TemplateDeclaration td) @safe\n {\n     if (!td.onemember)\n         return null;\n@@ -456,7 +456,11 @@ extern(C++) void gendocfile(Module m)\n     OutBuffer buf2;\n     buf2.writestring(\"$(DDOC)\");\n     size_t end = buf2.length;\n-    m.macrotable.expand(buf2, 0, end, null);\n+\n+    const success = m.macrotable.expand(buf2, 0, end, null, global.recursionLimit);\n+    if (!success)\n+        error(Loc.initial, \"DDoc macro expansion limit exceeded; more than %d expansions.\", global.recursionLimit);\n+\n     version (all)\n     {\n         /* Remove all the escape sequences from buf2,\n@@ -2561,17 +2565,17 @@ private size_t replaceMarkdownEmphasis(ref OutBuffer buf, const ref Loc loc, ref\n \n /****************************************************\n  */\n-private bool isIdentifier(Dsymbols* a, const(char)* p, size_t len)\n+private bool isIdentifier(Dsymbols* a, const(char)[] s)\n {\n     foreach (member; *a)\n     {\n         if (auto imp = member.isImport())\n         {\n             // For example: `public import str = core.stdc.string;`\n-            // This checks if `p` is equal to `str`\n+            // This checks if `s` is equal to `str`\n             if (imp.aliasId)\n             {\n-                if (p[0 .. len] == imp.aliasId.toString())\n+                if (s == imp.aliasId.toString())\n                     return true;\n             }\n             else\n@@ -2586,14 +2590,14 @@ private bool isIdentifier(Dsymbols* a, const(char)* p, size_t len)\n                 }\n                 fullyQualifiedImport ~= imp.id.toString();\n \n-                // Check if `p` == `core.stdc.string`\n-                if (p[0 .. len] == fullyQualifiedImport)\n+                // Check if `s` == `core.stdc.string`\n+                if (s == fullyQualifiedImport)\n                     return true;\n             }\n         }\n         else if (member.ident)\n         {\n-            if (p[0 .. len] == member.ident.toString())\n+            if (s == member.ident.toString())\n                 return true;\n         }\n \n@@ -2603,20 +2607,20 @@ private bool isIdentifier(Dsymbols* a, const(char)* p, size_t len)\n \n /****************************************************\n  */\n-private bool isKeyword(const(char)* p, size_t len)\n+private bool isKeyword(const(char)[] str) @safe\n {\n     immutable string[3] table = [\"true\", \"false\", \"null\"];\n     foreach (s; table)\n     {\n-        if (p[0 .. len] == s)\n+        if (str == s)\n             return true;\n     }\n     return false;\n }\n \n /****************************************************\n  */\n-private TypeFunction isTypeFunction(Dsymbol s)\n+private TypeFunction isTypeFunction(Dsymbol s) @safe\n {\n     FuncDeclaration f = s.isFuncDeclaration();\n     /* f.type may be NULL for template members.\n@@ -2632,14 +2636,14 @@ private TypeFunction isTypeFunction(Dsymbol s)\n \n /****************************************************\n  */\n-private Parameter isFunctionParameter(Dsymbol s, const(char)* p, size_t len)\n+private Parameter isFunctionParameter(Dsymbol s, const(char)[] str) @safe\n {\n     TypeFunction tf = isTypeFunction(s);\n     if (tf && tf.parameterList.parameters)\n     {\n         foreach (fparam; *tf.parameterList.parameters)\n         {\n-            if (fparam.ident && p[0 .. len] == fparam.ident.toString())\n+            if (fparam.ident && str == fparam.ident.toString())\n             {\n                 return fparam;\n             }\n@@ -2650,11 +2654,11 @@ private Parameter isFunctionParameter(Dsymbol s, const(char)* p, size_t len)\n \n /****************************************************\n  */\n-private Parameter isFunctionParameter(Dsymbols* a, const(char)* p, size_t len)\n+private Parameter isFunctionParameter(Dsymbols* a, const(char)[] p) @safe\n {\n-    for (size_t i = 0; i < a.dim; i++)\n+    foreach (Dsymbol sym; *a)\n     {\n-        Parameter fparam = isFunctionParameter((*a)[i], p, len);\n+        Parameter fparam = isFunctionParameter(sym, p);\n         if (fparam)\n         {\n             return fparam;\n@@ -2665,11 +2669,11 @@ private Parameter isFunctionParameter(Dsymbols* a, const(char)* p, size_t len)\n \n /****************************************************\n  */\n-private Parameter isEponymousFunctionParameter(Dsymbols *a, const(char) *p, size_t len)\n+private Parameter isEponymousFunctionParameter(Dsymbols *a, const(char)[] p) @safe\n {\n-    for (size_t i = 0; i < a.dim; i++)\n+    foreach (Dsymbol dsym; *a)\n     {\n-        TemplateDeclaration td = (*a)[i].isTemplateDeclaration();\n+        TemplateDeclaration td = dsym.isTemplateDeclaration();\n         if (td && td.onemember)\n         {\n             /* Case 1: we refer to a template declaration inside the template\n@@ -2688,7 +2692,7 @@ private Parameter isEponymousFunctionParameter(Dsymbols *a, const(char) *p, size\n                /// ...ddoc...\n                alias case2 = case1!int;\n              */\n-            AliasDeclaration ad = (*a)[i].isAliasDeclaration();\n+            AliasDeclaration ad = dsym.isAliasDeclaration();\n             if (ad && ad.aliassym)\n             {\n                 td = ad.aliassym.isTemplateDeclaration();\n@@ -2699,7 +2703,7 @@ private Parameter isEponymousFunctionParameter(Dsymbols *a, const(char) *p, size\n             Dsymbol sym = getEponymousMember(td);\n             if (sym)\n             {\n-                Parameter fparam = isFunctionParameter(sym, p, len);\n+                Parameter fparam = isFunctionParameter(sym, p);\n                 if (fparam)\n                 {\n                     return fparam;\n@@ -4956,17 +4960,17 @@ private void highlightText(Scope* sc, Dsymbols* a, Loc loc, ref OutBuffer buf, s\n                     i = buf.bracket(i, \"$(DDOC_AUTO_PSYMBOL_SUPPRESS \", j - 1, \")\") - 1;\n                     break;\n                 }\n-                if (isIdentifier(a, start, len))\n+                if (isIdentifier(a, start[0 .. len]))\n                 {\n                     i = buf.bracket(i, \"$(DDOC_AUTO_PSYMBOL \", j, \")\") - 1;\n                     break;\n                 }\n-                if (isKeyword(start, len))\n+                if (isKeyword(start[0 .. len]))\n                 {\n                     i = buf.bracket(i, \"$(DDOC_AUTO_KEYWORD \", j, \")\") - 1;\n                     break;\n                 }\n-                if (isFunctionParameter(a, start, len))\n+                if (isFunctionParameter(a, start[0 .. len]))\n                 {\n                     //printf(\"highlighting arg '%s', i = %d, j = %d\\n\", arg.ident.toChars(), i, j);\n                     i = buf.bracket(i, \"$(DDOC_AUTO_PARAM \", j, \")\") - 1;\n@@ -5055,7 +5059,7 @@ private void highlightCode(Scope* sc, Dsymbols* a, ref OutBuffer buf, size_t off\n             if (i < j)\n             {\n                 size_t len = j - i;\n-                if (isIdentifier(a, start, len))\n+                if (isIdentifier(a, start[0 .. len]))\n                 {\n                     i = buf.bracket(i, \"$(DDOC_PSYMBOL \", j, \")\") - 1;\n                     continue;\n@@ -5066,12 +5070,12 @@ private void highlightCode(Scope* sc, Dsymbols* a, ref OutBuffer buf, size_t off\n             if (i < j)\n             {\n                 size_t len = j - i;\n-                if (isIdentifier(a, start, len))\n+                if (isIdentifier(a, start[0 .. len]))\n                 {\n                     i = buf.bracket(i, \"$(DDOC_PSYMBOL \", j, \")\") - 1;\n                     continue;\n                 }\n-                if (isFunctionParameter(a, start, len))\n+                if (isFunctionParameter(a, start[0 .. len]))\n                 {\n                     //printf(\"highlighting arg '%s', i = %d, j = %d\\n\", arg.ident.toChars(), i, j);\n                     i = buf.bracket(i, \"$(DDOC_PARAM \", j, \")\") - 1;\n@@ -5195,12 +5199,12 @@ private void highlightCode2(Scope* sc, Dsymbols* a, ref OutBuffer buf, size_t of\n                 if (!sc)\n                     break;\n                 size_t len = lex.p - tok.ptr;\n-                if (isIdentifier(a, tok.ptr, len))\n+                if (isIdentifier(a, tok.ptr[0 .. len]))\n                 {\n                     highlight = \"$(D_PSYMBOL \";\n                     break;\n                 }\n-                if (isFunctionParameter(a, tok.ptr, len))\n+                if (isFunctionParameter(a, tok.ptr[0 .. len]))\n                 {\n                     //printf(\"highlighting arg '%s', i = %d, j = %d\\n\", arg.ident.toChars(), i, j);\n                     highlight = \"$(D_PARAM \";\n@@ -5246,15 +5250,15 @@ private void highlightCode2(Scope* sc, Dsymbols* a, ref OutBuffer buf, size_t of\n /****************************************\n  * Determine if p points to the start of a \"...\" parameter identifier.\n  */\n-private bool isCVariadicArg(const(char)[] p)\n+private bool isCVariadicArg(const(char)[] p) @nogc nothrow pure @safe\n {\n     return p.length >= 3 && p[0 .. 3] == \"...\";\n }\n \n /****************************************\n  * Determine if p points to the start of an identifier.\n  */\n-bool isIdStart(const(char)* p)\n+bool isIdStart(const(char)* p) @nogc nothrow pure\n {\n     dchar c = *p;\n     if (isalpha(c) || c == '_')\n@@ -5273,7 +5277,7 @@ bool isIdStart(const(char)* p)\n /****************************************\n  * Determine if p points to the rest of an identifier.\n  */\n-bool isIdTail(const(char)* p)\n+bool isIdTail(const(char)* p) @nogc nothrow pure\n {\n     dchar c = *p;\n     if (isalnum(c) || c == '_')\n@@ -5292,15 +5296,15 @@ bool isIdTail(const(char)* p)\n /****************************************\n  * Determine if p points to the indentation space.\n  */\n-private bool isIndentWS(const(char)* p)\n+private bool isIndentWS(const(char)* p) @nogc nothrow pure @safe\n {\n     return (*p == ' ') || (*p == '\\t');\n }\n \n /*****************************************\n  * Return number of bytes in UTF character.\n  */\n-int utfStride(const(char)* p)\n+int utfStride(const(char)* p) @nogc nothrow pure\n {\n     dchar c = *p;\n     if (c < 0x80)\n@@ -5310,7 +5314,7 @@ int utfStride(const(char)* p)\n     return cast(int)i;\n }\n \n-private inout(char)* stripLeadingNewlines(inout(char)* s)\n+private inout(char)* stripLeadingNewlines(inout(char)* s) @nogc nothrow pure\n {\n     while (s && *s == '\\n' || *s == '\\r')\n         s++;"}, {"sha": "c3424dc5dfa70770fe8d18a56a6f4e4fe4ebdbff", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 152, "deletions": 10, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -359,6 +359,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             dsym.overlapped = true;\n \n         dsym.sequenceNumber = global.varSequenceNumber++;\n+        if (!dsym.isScope())\n+            dsym.maybeScope = true;\n \n         Scope* scx = null;\n         if (dsym._scope)\n@@ -2034,8 +2036,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             ed.semanticRun = PASS.semanticdone;\n             return;\n         }\n-        uint dprogress_save = Module.dprogress;\n-\n         Scope* scx = null;\n         if (ed._scope)\n         {\n@@ -2093,7 +2093,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 {\n                     // memtype is forward referenced, so try again later\n                     deferDsymbolSemantic(ed, scx);\n-                    Module.dprogress = dprogress_save;\n                     //printf(\"\\tdeferring %s\\n\", toChars());\n                     ed.semanticRun = PASS.initial;\n                     return;\n@@ -2134,8 +2133,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (!(sc.flags & SCOPE.Cfile))  // C enum remains incomplete until members are done\n             ed.semanticRun = PASS.semanticdone;\n \n-        Module.dprogress++;\n-\n         // @@@DEPRECATED_2.110@@@ https://dlang.org/deprecate.html#scope%20as%20a%20type%20constraint\n         // Deprecated in 2.100\n         // Make an error in 2.110\n@@ -3945,7 +3942,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (funcdecl.canInferAttributes(sc))\n             funcdecl.initInferAttributes();\n \n-        Module.dprogress++;\n         funcdecl.semanticRun = PASS.semanticdone;\n \n         /* Save scope for possible later use (if we need the\n@@ -4669,7 +4665,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         sd.inv = buildInv(sd, sc2);\n \n-        Module.dprogress++;\n         sd.semanticRun = PASS.semanticdone;\n         //printf(\"-StructDeclaration::semantic(this=%p, '%s')\\n\", sd, sd.toChars());\n \n@@ -5329,7 +5324,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         cldec.inv = buildInv(cldec, sc2);\n \n-        Module.dprogress++;\n         cldec.semanticRun = PASS.semanticdone;\n         //printf(\"-ClassDeclaration.dsymbolSemantic(%s), type = %p\\n\", toChars(), type);\n \n@@ -5676,7 +5670,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         idec.members.foreachDsymbol( s => s.dsymbolSemantic(sc2) );\n \n-        Module.dprogress++;\n         idec.semanticRun = PASS.semanticdone;\n         //printf(\"-InterfaceDeclaration.dsymbolSemantic(%s), type = %p\\n\", toChars(), type);\n \n@@ -6332,6 +6325,10 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n          * resolve the alias of eponymous member.\n          */\n         tempinst.aliasdecl = tempinst.aliasdecl.toAlias2();\n+\n+        // stop AliasAssign tuple building\n+        if (auto td = tempinst.aliasdecl.isTupleDeclaration())\n+            td.building = false;\n     }\n \n Laftersemantic:\n@@ -6726,13 +6723,28 @@ private void aliasAssignSemantic(AliasAssign ds, Scope* sc)\n      */\n \n     const errors = global.errors;\n+    Dsymbol s;\n+\n+    // Try AliasSeq optimization\n+    if (auto ti = ds.type.isTypeInstance())\n+    {\n+        if (!ti.tempinst.findTempDecl(sc, null))\n+            return errorRet();\n+        if (auto tempinst = isAliasSeq(sc, ti))\n+        {\n+            s = aliasAssignInPlace(sc, tempinst, aliassym);\n+            if (!s)\n+                return errorRet();\n+            goto Lsymdone;\n+        }\n+    }\n \n     /* This section is needed because Type.resolve() will:\n      *   const x = 3;\n      *   alias y = x;\n      * try to convert identifier x to 3.\n      */\n-    auto s = ds.type.toDsymbol(sc);\n+    s = ds.type.toDsymbol(sc);\n     if (errors != global.errors)\n         return errorRet();\n     if (s == aliassym)\n@@ -6784,6 +6796,7 @@ private void aliasAssignSemantic(AliasAssign ds, Scope* sc)\n \n     if (s) // it's a symbolic alias\n     {\n+    Lsymdone:\n         //printf(\"alias %s resolved to %s %s\\n\", toChars(), s.kind(), s.toChars());\n         aliassym.type = null;\n         aliassym.aliassym = s;\n@@ -6812,6 +6825,135 @@ private void aliasAssignSemantic(AliasAssign ds, Scope* sc)\n     ds.semanticRun = PASS.semanticdone;\n }\n \n+/***************************************\n+ * Expands template instance arguments inside 'alias assign' target declaration (aliassym),\n+ * instead of inside 'tempinst.tiargs' every time.\n+ * Params:\n+ *      tempinst = AliasSeq instance\n+ *      aliassym = the AliasDeclaration corresponding to AliasAssign\n+ * Returns:\n+ *       null.\n+ */\n+private TupleDeclaration aliasAssignInPlace(Scope* sc, TemplateInstance tempinst,\n+                                            AliasDeclaration aliassym)\n+{\n+    // Mark instance with semantic done, not needed but just in case.\n+    tempinst.inst = tempinst;\n+    tempinst.semanticRun = PASS.semanticdone;\n+    TupleDeclaration td;\n+    if (aliassym.type)\n+    {\n+        // Convert TypeTuple to TupleDeclaration to avoid back and forth allocations\n+        // in the assignment process\n+        if (auto tt = aliassym.type.isTypeTuple())\n+        {\n+            auto objs = new Objects(tt.arguments.length);\n+            foreach (i, p; *tt.arguments)\n+                (*objs)[i] = p.type;\n+            td = new TupleDeclaration(tempinst.loc, aliassym.ident, objs);\n+            td.storage_class |= STC.templateparameter;\n+            td.building = true;\n+            aliassym.type = null;\n+        }\n+        else if (aliassym.type.isTypeError())\n+            return null;\n+\n+    }\n+    else if (auto otd = aliassym.aliassym.isTupleDeclaration())\n+    {\n+        if (otd.building)\n+            td = otd;\n+        else\n+        {\n+            td = new TupleDeclaration(tempinst.loc, aliassym.ident, otd.objects.copy());\n+            td.storage_class |= STC.templateparameter;\n+            td.building = true;\n+        }\n+    }\n+    // If starting from single element in aliassym (td == null) we need to build the tuple\n+    // after semanticTiargs to keep same semantics (for example a FuncLiteraldeclaration\n+    // template argument is converted to FuncExp)\n+    if (td)\n+        aliassym.aliassym = td;\n+    aliassym.semanticRun = PASS.semanticdone;\n+    if (!TemplateInstance.semanticTiargs(tempinst.loc, sc, tempinst.tiargs, 0, td))\n+    {\n+        tempinst.errors = true;\n+        return null;\n+    }\n+    // The alias will stop tuple 'building' mode when used (in AliasDeclaration.toAlias(),\n+    // then TupleDeclaration.getType() will work again)\n+    aliassym.semanticRun = PASS.initial;\n+    if (!td)\n+    {\n+        td = new TupleDeclaration(tempinst.loc, aliassym.ident, tempinst.tiargs);\n+        td.storage_class |= STC.templateparameter;\n+        td.building = true;\n+        return td;\n+    }\n+\n+    auto tiargs = tempinst.tiargs;\n+    size_t oldlen = td.objects.length;\n+    size_t origstart;\n+    size_t insertidx;\n+    size_t insertlen;\n+    foreach (i, o; *tiargs)\n+    {\n+        if (o !is td)\n+        {\n+            ++insertlen;\n+            continue;\n+        }\n+        // tuple contains itself (tuple = AliasSeq!(..., tuple, ...))\n+        if (insertlen) // insert any left element before\n+        {\n+            td.objects.insert(insertidx, (*tiargs)[i - insertlen .. i]);\n+            if (insertidx == 0) // reset original tuple start point\n+                origstart = insertlen;\n+            insertlen = 0;\n+        }\n+        if (insertidx) // insert tuple if found more than one time\n+        {\n+            td.objects.reserve(oldlen); // reserve first to assert a valid slice\n+            td.objects.pushSlice((*td.objects)[origstart .. origstart + oldlen]);\n+        }\n+        insertidx = td.objects.length;\n+    }\n+    if (insertlen)\n+    {\n+        if (insertlen != tiargs.length) // insert any left element\n+            td.objects.pushSlice((*tiargs)[$ - insertlen .. $]);\n+        else\n+            // just assign tiargs if tuple = AliasSeq!(nottuple, nottuple...)\n+            td.objects = tempinst.tiargs;\n+    }\n+    return td;\n+}\n+\n+/***************************************\n+ * Check if a template instance is a trivial AliasSeq but without other overloads.\n+ * We can only be 100% sure of being AliasSeq after running semanticTiargs()\n+ * and findBestMatch() but this optimization must happen before that.\n+ */\n+private TemplateInstance isAliasSeq(Scope* sc, TypeInstance ti)\n+{\n+    auto tovers = ti.tempinst.tempdecl.isOverloadSet();\n+    foreach (size_t oi; 0 .. tovers ? tovers.a.dim : 1)\n+    {\n+        Dsymbol dstart = tovers ? tovers.a[oi] : ti.tempinst.tempdecl;\n+        int r = overloadApply(dstart, (Dsymbol s)\n+        {\n+            auto td = s.isTemplateDeclaration();\n+            if (!td || !td.isTrivialAliasSeq)\n+                return 1;\n+            return 0;\n+        });\n+        if (r)\n+            return null;\n+    }\n+    return ti.tempinst;\n+}\n+\n /***************************************\n  * Find all instance fields in `ad`, then push them into `fields`.\n  *"}, {"sha": "34cae1d14f1f08a48032f6ac3730b6ae7a9274c0", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -6564,10 +6564,12 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n      *      tiargs  array of template arguments\n      *      flags   1: replace const variables with their initializers\n      *              2: don't devolve Parameter to Type\n+     *      atd     tuple being optimized. If found, it's not expanded here\n+     *              but in AliasAssign semantic.\n      * Returns:\n      *      false if one or more arguments have errors.\n      */\n-    extern (D) static bool semanticTiargs(const ref Loc loc, Scope* sc, Objects* tiargs, int flags)\n+    extern (D) static bool semanticTiargs(const ref Loc loc, Scope* sc, Objects* tiargs, int flags, TupleDeclaration atd = null)\n     {\n         // Run semantic on each argument, place results in tiargs[]\n         //printf(\"+TemplateInstance.semanticTiargs()\\n\");\n@@ -6767,6 +6769,11 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 TupleDeclaration d = sa.toAlias().isTupleDeclaration();\n                 if (d)\n                 {\n+                    if (d is atd)\n+                    {\n+                        (*tiargs)[j] = d;\n+                        continue;\n+                    }\n                     // Expand tuple\n                     tiargs.remove(j);\n                     tiargs.insert(j, d.objects);"}, {"sha": "4f06bac6593d54e66c28daa4423e79f314ebd697", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 134, "deletions": 51, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -36,6 +36,21 @@ import dmd.tokens;\n import dmd.visitor;\n import dmd.arraytypes;\n \n+/// Groups global state for escape checking together\n+package(dmd) struct EscapeState\n+{\n+    // Maps `sequenceNumber` of a `VarDeclaration` to an object that contains the\n+    // reason it failed to infer `scope`\n+    // https://issues.dlang.org/show_bug.cgi?id=23295\n+    private __gshared RootObject[int] scopeInferFailure;\n+\n+    /// Called by `initDMD` / `deinitializeDMD` to reset global state\n+    static void reset()\n+    {\n+        scopeInferFailure = null;\n+    }\n+}\n+\n /******************************************************\n  * Checks memory objects passed to a function.\n  * Checks that if a memory object is passed by ref or by pointer,\n@@ -271,6 +286,40 @@ bool checkAssocArrayLiteralEscape(Scope *sc, AssocArrayLiteralExp ae, bool gag)\n     return errors;\n }\n \n+/**\n+ * A `scope` variable was assigned to non-scope parameter `v`.\n+ * If applicable, print why the parameter was not inferred `scope`.\n+ *\n+ * Params:\n+ *    printFunc = error/deprecation print function to use\n+ *    v = parameter that was not inferred\n+ *    recursionLimit = recursion limit for printing the reason\n+ */\n+void printScopeFailure(E)(E printFunc, VarDeclaration v, int recursionLimit)\n+{\n+    recursionLimit--;\n+    if (recursionLimit < 0 || !v)\n+        return;\n+\n+    if (RootObject* o = v.sequenceNumber in EscapeState.scopeInferFailure)\n+    {\n+        switch ((*o).dyncast())\n+        {\n+            case DYNCAST.expression:\n+                Expression e = cast(Expression) *o;\n+                printFunc(e.loc, \"which is not `scope` because of `%s`\", e.toChars());\n+                break;\n+            case DYNCAST.dsymbol:\n+                VarDeclaration v1 = cast(VarDeclaration) *o;\n+                printFunc(v1.loc, \"which is assigned to non-scope parameter `%s`\", v1.toChars());\n+                printScopeFailure(printFunc, v1, recursionLimit);\n+                break;\n+            default:\n+                assert(0);\n+        }\n+    }\n+}\n+\n /****************************************\n  * Function parameter `par` is being initialized to `arg`,\n  * and `par` may escape.\n@@ -280,14 +329,15 @@ bool checkAssocArrayLiteralEscape(Scope *sc, AssocArrayLiteralExp ae, bool gag)\n  *      sc = used to determine current function and module\n  *      fdc = function being called, `null` if called indirectly\n  *      par = function parameter (`this` if null)\n+ *      vPar = `VarDeclaration` corresponding to `par`\n  *      parStc = storage classes of function parameter (may have added `scope` from `pure`)\n  *      arg = initializer for param\n  *      assertmsg = true if the parameter is the msg argument to assert(bool, msg).\n  *      gag = do not print error messages\n  * Returns:\n  *      `true` if pointers to the stack can escape via assignment\n  */\n-bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, STC parStc, Expression arg, bool assertmsg, bool gag)\n+bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, VarDeclaration vPar, STC parStc, Expression arg, bool assertmsg, bool gag)\n {\n     enum log = false;\n     if (log) printf(\"checkParamArgumentEscape(arg: %s par: %s)\\n\",\n@@ -327,13 +377,21 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, STC\n         }\n         else if (par)\n         {\n-            result |= sc.setUnsafeDIP1000(gag, arg.loc,\n-                desc ~ \" `%s` assigned to non-scope parameter `%s` calling `%s`\", v, par, fdc);\n+            if (sc.setUnsafeDIP1000(gag, arg.loc,\n+                desc ~ \" `%s` assigned to non-scope parameter `%s` calling `%s`\", v, par, fdc))\n+            {\n+                result = true;\n+                printScopeFailure(previewSupplementalFunc(sc.isDeprecated(), global.params.useDIP1000), vPar, 10);\n+            }\n         }\n         else\n         {\n-            result |= sc.setUnsafeDIP1000(gag, arg.loc,\n-                desc ~ \" `%s` assigned to non-scope parameter `this` calling `%s`\", v, fdc);\n+            if (sc.setUnsafeDIP1000(gag, arg.loc,\n+                desc ~ \" `%s` assigned to non-scope parameter `this` calling `%s`\", v, fdc))\n+            {\n+                result = true;\n+                printScopeFailure(previewSupplementalFunc(sc.isDeprecated(), global.params.useDIP1000), fdc.vthis, 10);\n+            }\n         }\n     }\n \n@@ -345,7 +403,7 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, STC\n \n         Dsymbol p = v.toParent2();\n \n-        notMaybeScope(v);\n+        notMaybeScope(v, vPar);\n \n         if (v.isScope())\n         {\n@@ -366,7 +424,8 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, STC\n              */\n             if (log) printf(\"no infer for %s in %s loc %s, fdc %s, %d\\n\",\n                 v.toChars(), sc.func.ident.toChars(), sc.func.loc.toChars(), fdc.ident.toChars(),  __LINE__);\n-            v.doNotInferScope = true;\n+\n+            doNotInferScope(v, vPar);\n         }\n     }\n \n@@ -378,7 +437,7 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, STC\n \n         Dsymbol p = v.toParent2();\n \n-        notMaybeScope(v);\n+        notMaybeScope(v, arg);\n         if (checkScopeVarAddr(v, arg, sc, gag))\n         {\n             result = true;\n@@ -405,7 +464,7 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, STC\n \n             Dsymbol p = v.toParent2();\n \n-            notMaybeScope(v);\n+            notMaybeScope(v, arg);\n \n             if ((v.isReference() || v.isScope()) && p == sc.func)\n             {\n@@ -553,7 +612,16 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n         return false;\n \n     if (e1.isSliceExp())\n-        return false;\n+    {\n+        if (VarDeclaration va = expToVariable(e1))\n+        {\n+            if (!va.type.toBasetype().isTypeSArray() || // treat static array slice same as a variable\n+                !va.type.hasPointers())\n+                return false;\n+        }\n+        else\n+            return false;\n+    }\n \n     /* The struct literal case can arise from the S(e2) constructor call:\n      *    return S(e2);\n@@ -650,7 +718,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n \n         if (va && !vaIsRef && !va.isScope() && !v.isScope() &&\n             !v.isTypesafeVariadicParameter && !va.isTypesafeVariadicParameter &&\n-            (va.storage_class & v.storage_class & STC.maybescope) &&\n+            (va.isParameter() && va.maybeScope && v.isParameter() && v.maybeScope) &&\n             p == fd)\n         {\n             /* Add v to va's list of dependencies\n@@ -660,7 +728,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n         }\n \n         if (vaIsFirstRef &&\n-            (v.isScope() || (v.storage_class & STC.maybescope)) &&\n+            (v.isScope() || v.maybeScope) &&\n             !(v.storage_class & STC.return_) &&\n             v.isParameter() &&\n             fd.flags & FUNCFLAG.returnInprocess &&\n@@ -672,7 +740,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n         }\n \n         if (!(va && va.isScope()) || vaIsRef)\n-            notMaybeScope(v);\n+            notMaybeScope(v, e);\n \n         if (v.isScope())\n         {\n@@ -682,7 +750,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n                 if (va.isScope())\n                     continue;\n \n-                if (!va.doNotInferScope)\n+                if (va.maybeScope)\n                 {\n                     if (log) printf(\"inferring scope for lvalue %s\\n\", va.toChars());\n                     va.storage_class |= STC.scope_ | STC.scopeinferred;\n@@ -711,7 +779,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n                 }\n             }\n \n-            if (va && !va.isDataseg() && !va.doNotInferScope)\n+            if (va && !va.isDataseg() && (va.isScope() || va.maybeScope))\n             {\n                 if (!va.isScope())\n                 {   /* v is scope, and va is not scope, so va needs to\n@@ -742,7 +810,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n             Type tb = v.type.toBasetype();\n             if (tb.ty == Tarray || tb.ty == Tsarray)\n             {\n-                if (va && !va.isDataseg() && !va.doNotInferScope)\n+                if (va && !va.isDataseg() && (va.isScope() || va.maybeScope))\n                 {\n                     if (!va.isScope())\n                     {   //printf(\"inferring scope for %s\\n\", va.toChars());\n@@ -759,7 +827,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n              * It may escape via that assignment, therefore, v can never be 'scope'.\n              */\n             //printf(\"no infer for %s in %s, %d\\n\", v.toChars(), fd.ident.toChars(), __LINE__);\n-            v.doNotInferScope = true;\n+            doNotInferScope(v, e);\n         }\n     }\n \n@@ -812,12 +880,12 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n         }\n \n         if (!(va && va.isScope()))\n-            notMaybeScope(v);\n+            notMaybeScope(v, e);\n \n         if (p != sc.func)\n             continue;\n \n-        if (va && !va.isDataseg() && !va.doNotInferScope)\n+        if (va && !va.isDataseg() && (va.isScope() || va.maybeScope))\n         {\n             if (!va.isScope())\n             {   //printf(\"inferring scope for %s\\n\", va.toChars());\n@@ -855,12 +923,12 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n             Dsymbol p = v.toParent2();\n \n             if (!(va && va.isScope()))\n-                notMaybeScope(v);\n+                notMaybeScope(v, e);\n \n             if (!(v.isReference() || v.isScope()) || p != fd)\n                 continue;\n \n-            if (va && !va.isDataseg() && !va.doNotInferScope)\n+            if (va && !va.isDataseg() && (va.isScope() || va.maybeScope))\n             {\n                 /* Don't infer STC.scope_ for va, because then a closure\n                  * won't be generated for fd.\n@@ -891,7 +959,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n         }\n \n         if (ee.op == EXP.call && ee.type.toBasetype().isTypeStruct() &&\n-            (!va || !(va.storage_class & STC.temp)))\n+            (!va || !(va.storage_class & STC.temp) && !va.isScope()))\n         {\n             if (sc.setUnsafeDIP1000(gag, ee.loc, \"address of struct temporary returned by `%s` assigned to longer lived variable `%s`\", ee, e1))\n             {\n@@ -910,7 +978,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n             }\n         }\n \n-        if (va && !va.isDataseg() && !va.doNotInferScope)\n+        if (va && !va.isDataseg() && (va.isScope() || va.maybeScope))\n         {\n             if (!va.isScope())\n             {   //printf(\"inferring scope for %s\\n\", va.toChars());\n@@ -963,8 +1031,7 @@ bool checkThrowEscape(Scope* sc, Expression e, bool gag)\n         }\n         else\n         {\n-            //printf(\"no infer for %s in %s, %d\\n\", v.toChars(), sc.func.ident.toChars(), __LINE__);\n-            v.doNotInferScope = true;\n+            notMaybeScope(v, new ThrowExp(e.loc, e));\n         }\n     }\n     return result;\n@@ -1036,7 +1103,7 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n         else\n         {\n             //printf(\"no infer for %s in %s, %d\\n\", v.toChars(), sc.func.ident.toChars(), __LINE__);\n-            v.doNotInferScope = true;\n+            notMaybeScope(v, e);\n         }\n     }\n \n@@ -1191,7 +1258,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n \n         Dsymbol p = v.toParent2();\n \n-        if ((v.isScope() || (v.storage_class & STC.maybescope)) &&\n+        if ((v.isScope() || v.maybeScope) &&\n             !(v.storage_class & STC.return_) &&\n             v.isParameter() &&\n             !v.doNotInferReturn &&\n@@ -1266,7 +1333,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n         else\n         {\n             //printf(\"no infer for %s in %s, %d\\n\", v.toChars(), sc.func.ident.toChars(), __LINE__);\n-            v.doNotInferScope = true;\n+            doNotInferScope(v, e);\n         }\n     }\n \n@@ -1330,7 +1397,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n         if (!refs)\n         {\n             if (sc.func.vthis == v)\n-                notMaybeScope(v);\n+                notMaybeScope(v, e);\n \n             if (checkScopeVarAddr(v, e, sc, gag))\n             {\n@@ -2226,26 +2293,41 @@ public void findAllOuterAccessedVariables(FuncDeclaration fd, VarDeclarations* v\n }\n \n /***********************************\n- * Turn off `STC.maybescope` for variable `v`.\n+ * Turn off `maybeScope` for variable `v`.\n  *\n- * This exists in order to find where `STC.maybescope` is getting turned off.\n+ * This exists in order to find where `maybeScope` is getting turned off.\n  * Params:\n  *      v = variable\n+ *      o = reason for it being turned off:\n+ *          - `Expression` such as `throw e` or `&e`\n+ *          - `VarDeclaration` of a non-scope parameter it was assigned to\n+ *          - `null` for no reason\n  */\n-version (none)\n+private void notMaybeScope(VarDeclaration v, RootObject o)\n {\n-    private void notMaybeScope(string file = __FILE__, int line = __LINE__)(VarDeclaration v)\n+    if (v.maybeScope)\n     {\n-        printf(\"%.*s(%d): notMaybeScope('%s')\\n\", cast(int)file.length, file.ptr, line, v.toChars());\n-        v.storage_class &= ~STC.maybescope;\n+        v.maybeScope = false;\n+        if (o && v.isParameter())\n+            EscapeState.scopeInferFailure[v.sequenceNumber] = o;\n     }\n }\n-else\n+\n+/***********************************\n+ * Turn off `maybeScope` for variable `v` if it's not a parameter.\n+ *\n+ * This is for compatibility with the old system with both `STC.maybescope` and `VarDeclaration.doNotInferScope`,\n+ * which is now just `VarDeclaration.maybeScope`.\n+ * This function should probably be removed in future refactors.\n+ *\n+ * Params:\n+ *      v = variable\n+ *      o = reason for it being turned off\n+ */\n+private void doNotInferScope(VarDeclaration v, RootObject o)\n {\n-    private void notMaybeScope(VarDeclaration v)\n-    {\n-        v.storage_class &= ~STC.maybescope;\n-    }\n+    if (!v.isParameter)\n+        notMaybeScope(v, o);\n }\n \n /***********************************\n@@ -2259,6 +2341,7 @@ else\n  */\n void finishScopeParamInference(FuncDeclaration funcdecl, ref TypeFunction f)\n {\n+\n     if (funcdecl.flags & FUNCFLAG.returnInprocess)\n     {\n         funcdecl.flags &= ~FUNCFLAG.returnInprocess;\n@@ -2273,6 +2356,8 @@ void finishScopeParamInference(FuncDeclaration funcdecl, ref TypeFunction f)\n         }\n     }\n \n+    if (!(funcdecl.flags & FUNCFLAG.inferScope))\n+        return;\n     funcdecl.flags &= ~FUNCFLAG.inferScope;\n \n     // Eliminate maybescope's\n@@ -2305,20 +2390,19 @@ void finishScopeParamInference(FuncDeclaration funcdecl, ref TypeFunction f)\n         foreach (u, p; f.parameterList)\n         {\n             auto v = (*funcdecl.parameters)[u];\n-            if (v.storage_class & STC.maybescope)\n+            if (v.maybeScope)\n             {\n                 //printf(\"Inferring scope for %s\\n\", v.toChars());\n-                notMaybeScope(v);\n+                notMaybeScope(v, null);\n                 v.storage_class |= STC.scope_ | STC.scopeinferred;\n                 p.storageClass |= STC.scope_ | STC.scopeinferred;\n-                assert(!(p.storageClass & STC.maybescope));\n             }\n         }\n     }\n \n-    if (funcdecl.vthis && funcdecl.vthis.storage_class & STC.maybescope)\n+    if (funcdecl.vthis && funcdecl.vthis.maybeScope)\n     {\n-        notMaybeScope(funcdecl.vthis);\n+        notMaybeScope(funcdecl.vthis, null);\n         funcdecl.vthis.storage_class |= STC.scope_ | STC.scopeinferred;\n         f.isScopeQual = true;\n         f.isscopeinferred = true;\n@@ -2358,17 +2442,17 @@ private void eliminateMaybeScopes(VarDeclaration[] array)\n         foreach (va; array)\n         {\n             if (log) printf(\"  va = %s\\n\", va.toChars());\n-            if (!(va.storage_class & (STC.maybescope | STC.scope_)))\n+            if (!(va.maybeScope || va.isScope()))\n             {\n                 if (va.maybes)\n                 {\n                     foreach (v; *va.maybes)\n                     {\n                         if (log) printf(\"    v = %s\\n\", v.toChars());\n-                        if (v.storage_class & STC.maybescope)\n+                        if (v.maybeScope)\n                         {\n                             // v cannot be scope since it is assigned to a non-scope va\n-                            notMaybeScope(v);\n+                            notMaybeScope(v, va);\n                             if (!v.isReference())\n                                 v.storage_class &= ~(STC.return_ | STC.returninferred);\n                             changes = true;\n@@ -2485,7 +2569,7 @@ private bool enclosesLifetimeOf(const VarDeclaration va, const VarDeclaration v)\n  * analysis for the function is completed. Thus, we save the data\n  * until then.\n  * Params:\n- *     v = an `STC.maybescope` variable that was assigned to `this`\n+ *     v = a variable with `maybeScope == true` that was assigned to `this`\n  */\n private void addMaybe(VarDeclaration va, VarDeclaration v)\n {\n@@ -2570,8 +2654,7 @@ private bool checkScopeVarAddr(VarDeclaration v, Expression e, Scope* sc, bool g\n \n     if (!v.isScope())\n     {\n-        v.storage_class &= ~STC.maybescope;\n-        v.doNotInferScope = true;\n+        notMaybeScope(v, e);\n         return false;\n     }\n "}, {"sha": "f871fadead4c4a6ec187a831f64e4813277167f0", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -5153,7 +5153,7 @@ extern (C++) final class CallExp : UnaExp\n                 /* Type needs destruction, so declare a tmp\n                  * which the back end will recognize and call dtor on\n                  */\n-                auto tmp = copyToTemp(0, \"__tmpfordtor\", this);\n+                auto tmp = copyToTemp(0, Id.__tmpfordtor.toString(), this);\n                 auto de = new DeclarationExp(loc, tmp);\n                 auto ve = new VarExp(loc, tmp);\n                 Expression e = new CommaExp(loc, de, ve);"}, {"sha": "31141005a6d4a61c434051a792323515d6ac60c4", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 88, "deletions": 7, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2044,7 +2044,8 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n                 /* Argument value can escape from the called function.\n                  * Check arg to see if it matters.\n                  */\n-                err |= checkParamArgumentEscape(sc, fd, p, cast(STC) pStc, arg, false, false);\n+                VarDeclaration vPar = fd ? (fd.parameters ? (*fd.parameters)[i] : null) : null;\n+                err |= checkParamArgumentEscape(sc, fd, p, vPar, cast(STC) pStc, arg, false, false);\n             }\n \n             // Turning heap allocations into stack allocations is dangerous without dip1000, since `scope` inference\n@@ -4726,7 +4727,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 tthis = ue.e1.type;\n                 if (!(exp.f.type.ty == Tfunction && (cast(TypeFunction)exp.f.type).isScopeQual))\n                 {\n-                    if (checkParamArgumentEscape(sc, exp.f, null, STC.undefined_, ethis, false, false))\n+                    if (checkParamArgumentEscape(sc, exp.f, null, null, STC.undefined_, ethis, false, false))\n                         return setError();\n                 }\n             }\n@@ -6388,7 +6389,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             exp.msg = resolveProperties(sc, exp.msg);\n             exp.msg = exp.msg.implicitCastTo(sc, Type.tchar.constOf().arrayOf());\n             exp.msg = exp.msg.optimize(WANTvalue);\n-            checkParamArgumentEscape(sc, null, null, STC.undefined_, exp.msg, true, false);\n+            checkParamArgumentEscape(sc, null, null, null, STC.undefined_, exp.msg, true, false);\n         }\n \n         if (exp.msg && exp.msg.op == EXP.error)\n@@ -9934,7 +9935,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             if (isArrayCtor || isArraySetCtor)\n             {\n                 const ts = t1b.nextOf().baseElemOf().isTypeStruct();\n-                if (!ts || (!ts.sym.postblit && !ts.sym.dtor))\n+                if (!ts || (!ts.sym.postblit && !ts.sym.hasCopyCtor && !ts.sym.dtor))\n                     return setResult(res);\n \n                 auto func = isArrayCtor ? Id._d_arrayctor : Id._d_arraysetctor;\n@@ -9976,10 +9977,89 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     message(\"lowered   %s =>\\n          %s\", exp.toChars(), res.toChars());\n             }\n         }\n+        else if (auto ae = res.isAssignExp())\n+            res = lowerArrayAssign(ae);\n+        else if (auto ce = res.isCommaExp())\n+        {\n+            if (auto ae1 = ce.e1.isAssignExp())\n+                ce.e1 = lowerArrayAssign(ae1, true);\n+            if (auto ae2 = ce.e2.isAssignExp())\n+                ce.e2 = lowerArrayAssign(ae2, true);\n+        }\n \n         return setResult(res);\n     }\n \n+    /***************************************\n+     * Lower AssignExp to `_d_arrayassign_{l,r}` if needed.\n+     *\n+     * Params:\n+     *      ae = the AssignExp to be lowered\n+     *      fromCommaExp = indicates whether `ae` is part of a CommaExp or not,\n+     *                     so no unnecessary temporay variable is created.\n+     * Returns:\n+     *      a CommaExp contiaining call a to `_d_arrayassign_{l,r}` if needed or\n+     *      `ae` otherwise\n+     */\n+    private Expression lowerArrayAssign(AssignExp ae, bool fromCommaExp = false)\n+    {\n+        Type t1b = ae.e1.type.toBasetype();\n+        if (t1b.ty != Tsarray && t1b.ty != Tarray)\n+            return ae;\n+\n+        const isArrayAssign =\n+            (ae.e1.isSliceExp || ae.e1.type.ty == Tsarray) &&\n+            (ae.e2.type.ty == Tsarray || ae.e2.type.ty == Tarray) &&\n+            (ae.e1.type.nextOf && ae.e2.type.nextOf && ae.e1.type.nextOf.mutableOf.equals(ae.e2.type.nextOf.mutableOf));\n+\n+        if (!isArrayAssign)\n+            return ae;\n+\n+        const ts = t1b.nextOf().baseElemOf().isTypeStruct();\n+        if (!ts || (!ts.sym.postblit && !ts.sym.dtor))\n+            return ae;\n+\n+        Expression res;\n+        auto func = ae.e2.isLvalue || ae.e2.isSliceExp ? Id._d_arrayassign_l : Id._d_arrayassign_r;\n+\n+        // Lower to `.object._d_arrayassign_l{r}(e1, e2)``\n+        Expression id = new IdentifierExp(ae.loc, Id.empty);\n+        id = new DotIdExp(ae.loc, id, Id.object);\n+        id = new DotIdExp(ae.loc, id, func);\n+\n+        auto arguments = new Expressions();\n+        arguments.push(new CastExp(ae.loc, ae.e1, ae.e1.type.nextOf.arrayOf)\n+            .expressionSemantic(sc));\n+\n+        Expression eValue2, value2 = ae.e2;\n+        if (ae.e2.isLvalue)\n+            value2 = new CastExp(ae.loc, ae.e2, ae.e2.type.nextOf.arrayOf)\n+                .expressionSemantic(sc);\n+        else if (!fromCommaExp)\n+        {\n+            // Rvalues from CommaExps were introduced in `visit(AssignExp)`\n+            // and are temporary variables themselves. Rvalues from trivial\n+            // SliceExps are simply passed by reference without any copying.\n+\n+            // `__assigntmp` will be destroyed together with the array `ae.e1`.\n+            // When `ae.e2` is a variadic arg array, it is also `scope`, so\n+            // `__assigntmp` may also be scope.\n+            auto vd = copyToTemp(STC.rvalue | STC.nodtor | STC.scope_, \"__assigntmp\", ae.e2);\n+            eValue2 = new DeclarationExp(vd.loc, vd).expressionSemantic(sc);\n+            value2 = new VarExp(vd.loc, vd).expressionSemantic(sc);\n+        }\n+        arguments.push(value2);\n+\n+        Expression ce = new CallExp(ae.loc, id, arguments);\n+        res = Expression.combine(eValue2, ce).expressionSemantic(sc);\n+        res = Expression.combine(res, ae.e1).expressionSemantic(sc);\n+\n+        if (global.params.verbose)\n+            message(\"lowered   %s =>\\n          %s\", ae.toChars(), res.toChars());\n+\n+        return res;\n+    }\n+\n     override void visit(PowAssignExp exp)\n     {\n         if (exp.type)\n@@ -13092,7 +13172,10 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n             if (sc.func && sc.func.isSynchronized())\n                 return false;\n \n-            return sharedError(e);\n+            if (!allowRef && e.type.isShared())\n+                return sharedError(e);\n+\n+            return false;\n         }\n \n         bool visitDotVar(DotVarExp e)\n@@ -13182,8 +13265,6 @@ bool checkAddressVar(Scope* sc, Expression exp, VarDeclaration v)\n     }\n     if (sc.func && !sc.intypeof && !v.isDataseg())\n     {\n-        v.storage_class &= ~STC.maybescope;\n-        v.doNotInferScope = true;\n         if (global.params.useDIP1000 != FeatureState.enabled &&\n             !(v.storage_class & STC.temp) &&\n             sc.setUnsafe(false, exp.loc, \"cannot take address of local `%s` in `@safe` function `%s`\", v, sc.func))"}, {"sha": "4c0947415cd17d02996b9975990f1d6214626b3e", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -568,8 +568,6 @@ extern (C++) class FuncDeclaration : Declaration\n             if (tf.isreturnscope)\n                 vthis.storage_class |= STC.returnScope;\n         }\n-        if (flags & FUNCFLAG.inferScope && !(vthis.storage_class & STC.scope_))\n-            vthis.storage_class |= STC.maybescope;\n \n         vthis.dsymbolSemantic(sc);\n         if (!sc.insert(vthis))"}, {"sha": "745d5eb067ce428d789cf626df6fabd5515930be", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -116,10 +116,6 @@ extern (C++) struct Param\n     DiagnosticReporting useDeprecated = DiagnosticReporting.inform;  // how use of deprecated features are handled\n     bool useUnitTests;          // generate unittest code\n     bool useInline = false;     // inline expand functions\n-    FeatureState useDIP25;  // implement https://wiki.dlang.org/DIP25\n-    FeatureState useDIP1000; // implement https://dlang.org/spec/memory-safe-d.html#scope-return-params\n-    bool fixImmutableConv;  // error on unsound immutable conversion - https://github.com/dlang/dmd/pull/14070\n-    bool useDIP1021;        // implement https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1021.md\n     bool release;           // build release version\n     bool preservePaths;     // true means don't strip path from source file\n     DiagnosticReporting warnings = DiagnosticReporting.off;  // how compiler warnings are handled\n@@ -131,31 +127,10 @@ extern (C++) struct Param\n     bool useModuleInfo = true;   // generate runtime module information\n     bool useTypeInfo = true;     // generate runtime type information\n     bool useExceptions = true;   // support exception handling\n-    bool noSharedAccess;         // read/write access to shared memory objects\n-    bool previewIn;         // `in` means `[ref] scope const`, accepts rvalues\n-    bool shortenedMethods; // allow => in normal function declarations\n     bool betterC;           // be a \"better C\" compiler; no dependency on D runtime\n     bool addMain;           // add a default main() function\n     bool allInst;           // generate code for all template instantiations\n-    bool fix16997 = true;   // fix integral promotions for unary + - ~ operators\n-                            // https://issues.dlang.org/show_bug.cgi?id=16997\n-    bool fixAliasThis;      // if the current scope has an alias this, check it before searching upper scopes\n-    bool inclusiveInContracts;   // 'in' contracts of overridden methods must be a superset of parent contract\n-    /** The --transition=safe switch should only be used to show code with\n-     * silent semantics changes related to @safe improvements.  It should not be\n-     * used to hide a feature that will have to go through deprecate-then-error\n-     * before becoming default.\n-     */\n-    bool ehnogc;            // use @nogc exception handling\n-    FeatureState dtorFields; // destruct fields of partially constructed objects\n-                            // https://issues.dlang.org/show_bug.cgi?id=14246\n-    bool fieldwise;         // do struct equality testing field-wise rather than by memcmp()\n     bool bitfields;         // support C style bit fields\n-    FeatureState rvalueRefParam; // allow rvalues to be arguments to ref parameters\n-                                 // https://dconf.org/2019/talks/alexandrescu.html\n-                                 // https://gist.github.com/andralex/e5405a5d773f07f73196c05f8339435a\n-                                 // https://digitalmars.com/d/archives/digitalmars/D/Binding_rvalues_to_ref_parameters_redux_325087.html\n-                                 // Implementation: https://github.com/dlang/dmd/pull/9817\n \n     CppStdRevision cplusplus = CppStdRevision.cpp11;    // version of C++ standard to support\n \n@@ -173,6 +148,28 @@ extern (C++) struct Param\n     bool hcUsage;           // print help on -HC switch\n     bool logo;              // print compiler logo\n \n+    // Options for `-preview=/-revert=`\n+    FeatureState useDIP25;       // implement https://wiki.dlang.org/DIP25\n+    FeatureState useDIP1000;     // implement https://dlang.org/spec/memory-safe-d.html#scope-return-params\n+    bool ehnogc;                 // use @nogc exception handling\n+    bool useDIP1021;             // implement https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1021.md\n+    bool fieldwise;              // do struct equality testing field-wise rather than by memcmp()\n+    bool fixAliasThis;           // if the current scope has an alias this, check it before searching upper scopes\n+    FeatureState rvalueRefParam; // allow rvalues to be arguments to ref parameters\n+                                 // https://dconf.org/2019/talks/alexandrescu.html\n+                                 // https://gist.github.com/andralex/e5405a5d773f07f73196c05f8339435a\n+                                 // https://digitalmars.com/d/archives/digitalmars/D/Binding_rvalues_to_ref_parameters_redux_325087.html\n+                                 // Implementation: https://github.com/dlang/dmd/pull/9817\n+    bool noSharedAccess;         // read/write access to shared memory objects\n+    bool previewIn;              // `in` means `[ref] scope const`, accepts rvalues\n+    bool inclusiveInContracts;   // 'in' contracts of overridden methods must be a superset of parent contract\n+    bool shortenedMethods;       // allow => in normal function declarations\n+    bool fixImmutableConv;       // error on unsound immutable conversion - https://github.com/dlang/dmd/pull/14070\n+    bool fix16997 = true;        // fix integral promotions for unary + - ~ operators\n+                                 // https://issues.dlang.org/show_bug.cgi?id=16997\n+    FeatureState dtorFields;     // destruct fields of partially constructed objects\n+                                 // https://issues.dlang.org/show_bug.cgi?id=14246\n+\n     CHECKENABLE useInvariants  = CHECKENABLE._default;  // generate class invariant checks\n     CHECKENABLE useIn          = CHECKENABLE._default;  // generate precondition checks\n     CHECKENABLE useOut         = CHECKENABLE._default;  // generate postcondition checks"}, {"sha": "a6b1c90bb6c1a4ecce7515494c25604fe1703247", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -116,10 +116,6 @@ struct Param\n     Diagnostic useDeprecated;\n     bool useUnitTests;  // generate unittest code\n     bool useInline;     // inline expand functions\n-    FeatureState useDIP25;      // implement https://wiki.dlang.org/DIP25\n-    FeatureState useDIP1000; // implement https://dlang.org/spec/memory-safe-d.html#scope-return-params\n-    bool fixImmutableConv;\n-    bool useDIP1021;    // implement https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1021.md\n     bool release;       // build release version\n     bool preservePaths; // true means don't strip path from source file\n     Diagnostic warnings;\n@@ -131,22 +127,10 @@ struct Param\n     bool useModuleInfo; // generate runtime module information\n     bool useTypeInfo;   // generate runtime type information\n     bool useExceptions; // support exception handling\n-    bool noSharedAccess; // read/write access to shared memory objects\n-    bool previewIn;     // `in` means `scope const`, perhaps `ref`, accepts rvalues\n-    bool shortenedMethods; // allow => in normal function declarations\n     bool betterC;       // be a \"better C\" compiler; no dependency on D runtime\n     bool addMain;       // add a default main() function\n     bool allInst;       // generate code for all template instantiations\n-    bool fix16997;      // fix integral promotions for unary + - ~ operators\n-                        // https://issues.dlang.org/show_bug.cgi?id=16997\n-    bool fixAliasThis;  // if the current scope has an alias this, check it before searching upper scopes\n-    bool inclusiveInContracts;   // 'in' contracts of overridden methods must be a superset of parent contract\n-    bool ehnogc;        // use @nogc exception handling\n-    FeatureState dtorFields;  // destruct fields of partially constructed objects\n-                              // https://issues.dlang.org/show_bug.cgi?id=14246\n-    bool fieldwise;         // do struct equality testing field-wise rather than by memcmp()\n     bool bitfields;         // support C style bit fields\n-    FeatureState rvalueRefParam;    // allow rvalues to be arguments to ref parameters\n     CppStdRevision cplusplus;  // version of C++ name mangling to support\n     bool showGaggedErrors;  // print gagged errors anyway\n     bool printErrorContext;  // print errors with the error context (the error line in the source file)\n@@ -162,6 +146,27 @@ struct Param\n     bool hcUsage;           // print help on -HC switch\n     bool logo;              // print logo;\n \n+    // Options for `-preview=/-revert=`\n+    FeatureState useDIP25;       // implement https://wiki.dlang.org/DIP25\n+    FeatureState useDIP1000;     // implement https://dlang.org/spec/memory-safe-d.html#scope-return-params\n+    bool ehnogc;                 // use @nogc exception handling\n+    bool useDIP1021;             // implement https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1021.md\n+    bool fieldwise;              // do struct equality testing field-wise rather than by memcmp()\n+    bool fixAliasThis;           // if the current scope has an alias this, check it before searching upper scopes\n+    FeatureState rvalueRefParam; // allow rvalues to be arguments to ref parameters\n+                                 // https://dconf.org/2019/talks/alexandrescu.html\n+                                 // https://gist.github.com/andralex/e5405a5d773f07f73196c05f8339435a\n+                                 // https://digitalmars.com/d/archives/digitalmars/D/Binding_rvalues_to_ref_parameters_redux_325087.html\n+                                 // Implementation: https://github.com/dlang/dmd/pull/9817\n+    bool noSharedAccess;         // read/write access to shared memory objects\n+    bool previewIn;              // `in` means `[ref] scope const`, accepts rvalues\n+    bool inclusiveInContracts;   // 'in' contracts of overridden methods must be a superset of parent contract\n+    bool shortenedMethods;       // allow => in normal function declarations\n+    bool fixImmutableConv;       // error on unsound immutable conversion - https://github.com/dlang/dmd/pull/14070\n+    bool fix16997;               // fix integral promotions for unary + - ~ operators\n+                                 // https://issues.dlang.org/show_bug.cgi?id=16997\n+    FeatureState dtorFields;     // destruct fields of partially constructed objects\n+                                     // https://issues.dlang.org/show_bug.cgi?id=14246\n     CHECKENABLE useInvariants;     // generate class invariant checks\n     CHECKENABLE useIn;             // generate precondition checks\n     CHECKENABLE useOut;            // generate postcondition checks"}, {"sha": "48995db89f6c1274cf4b8dde2588cfa0801e78cc", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1890,7 +1890,17 @@ private void expressionPrettyPrint(Expression e, OutBuffer* buf, HdrGenState* hg\n                 buf.printf(\"%uu\", cast(uint)v);\n                 break;\n             case Tint64:\n-                buf.printf(\"%lldL\", v);\n+                if (v == long.min)\n+                {\n+                    // https://issues.dlang.org/show_bug.cgi?id=23173\n+                    // This is a special case because - is not part of the\n+                    // integer literal and 9223372036854775808L overflows a long\n+                    buf.writestring(\"cast(long)-9223372036854775808\");\n+                }\n+                else\n+                {\n+                    buf.printf(\"%lldL\", v);\n+                }\n                 break;\n             case Tuns64:\n                 buf.printf(\"%lluLU\", v);\n@@ -2651,7 +2661,9 @@ void floatToBuffer(Type type, const real_t value, OutBuffer* buf, const bool all\n     assert(strlen(buffer.ptr) < BUFFER_LEN);\n     if (allowHex)\n     {\n-        real_t r = CTFloat.parse(buffer.ptr);\n+        bool isOutOfRange;\n+        real_t r = CTFloat.parse(buffer.ptr, isOutOfRange);\n+        //assert(!isOutOfRange); // test/compilable/test22725.c asserts here\n         if (r != value) // if exact duplication\n             CTFloat.sprint(buffer.ptr, 'a', value);\n     }"}, {"sha": "6695faa5754c2fec766fa6947745b56116d8615d", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -160,6 +160,7 @@ immutable Msgtable[] msgtable =\n     { \"xopEquals\", \"__xopEquals\" },\n     { \"xopCmp\", \"__xopCmp\" },\n     { \"xtoHash\", \"__xtoHash\" },\n+    { \"__tmpfordtor\" },\n \n     { \"LINE\", \"__LINE__\" },\n     { \"FILE\", \"__FILE__\" },\n@@ -318,6 +319,8 @@ immutable Msgtable[] msgtable =\n     { \"_aaApply2\" },\n     { \"_d_arrayctor\" },\n     { \"_d_arraysetctor\" },\n+    { \"_d_arrayassign_l\" },\n+    { \"_d_arrayassign_r\" },\n \n     // For pragma's\n     { \"Pinline\", \"inline\" },"}, {"sha": "7f922981181138e9dcd1cbf973b92e3a67bada4a", "filename": "gcc/d/dmd/identifier.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fidentifier.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fidentifier.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -88,7 +88,7 @@ nothrow:\n         return name.ptr;\n     }\n \n-    extern (D) override const(char)[] toString() const pure\n+    extern (D) override const(char)[] toString() const pure @safe\n     {\n         return name;\n     }"}, {"sha": "21bbde8227fa1f17248813672af975b0171516f9", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2531,7 +2531,7 @@ class Lexer\n         auto sbufptr = cast(const(char)*)stringbuffer[].ptr;\n         TOK result;\n         bool isOutOfRange = false;\n-        t.floatvalue = (isWellformedString ? CTFloat.parse(sbufptr, &isOutOfRange) : CTFloat.zero);\n+        t.floatvalue = (isWellformedString ? CTFloat.parse(sbufptr, isOutOfRange) : CTFloat.zero);\n         switch (*p)\n         {\n         case 'F':"}, {"sha": "6bfb729170c97ee95bfbbd6c2174420be39386b1", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -58,7 +58,6 @@ class Module final : public Package\n     static Dsymbols deferred;   // deferred Dsymbol's needing semantic() run on them\n     static Dsymbols deferred2;  // deferred Dsymbol's needing semantic2() run on them\n     static Dsymbols deferred3;  // deferred Dsymbol's needing semantic3() run on them\n-    static unsigned dprogress;  // progress resolving the deferred list\n \n     static void _init();\n "}, {"sha": "f2da41b6ff7b97df7f41bfce6ee25d6d20aee202", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -4407,30 +4407,46 @@ extern (C++) final class TypeFunction : TypeNext\n \n         purityLevel();\n \n+        static bool mayHavePointers(Type t)\n+        {\n+            if (auto ts = t.isTypeStruct())\n+            {\n+                auto sym = ts.sym;\n+                if (sym.members && !sym.determineFields() && sym.type != Type.terror)\n+                    // struct is forward referenced, so \"may have\" pointers\n+                    return true;\n+            }\n+            return t.hasPointers();\n+        }\n+\n         // See if p can escape via any of the other parameters\n         if (purity == PURE.weak)\n         {\n             // Check escaping through parameters\n             foreach (i, fparam; parameterList)\n             {\n-                if (fparam == p)\n-                    continue;\n                 Type t = fparam.type;\n                 if (!t)\n                     continue;\n-                t = t.baseElemOf();\n+                t = t.baseElemOf();     // punch thru static arrays\n                 if (t.isMutable() && t.hasPointers())\n                 {\n-                    if (fparam.isReference())\n-                    {\n-                    }\n-                    else if (t.ty == Tarray || t.ty == Tpointer)\n+                    if (fparam.isReference() && fparam != p)\n+                        return stc;\n+\n+                    if (t.ty == Tdelegate)\n+                        return stc;     // could escape thru delegate\n+\n+                    if (t.ty == Tclass)\n+                        return stc;\n+\n+                    /* if t is a pointer to mutable pointer\n+                     */\n+                    if (auto tn = t.nextOf())\n                     {\n-                        Type tn = t.nextOf().toBasetype();\n-                        if (!(tn.isMutable() && tn.hasPointers()))\n-                            continue;\n+                        if (tn.isMutable() && mayHavePointers(tn))\n+                            return stc;   // escape through pointers\n                     }\n-                    return stc;\n                 }\n             }\n "}, {"sha": "ce2769d38490441d04249beabd936d8ed486e0bc", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1999,7 +1999,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             }\n         }\n         check(TOK.rightParenthesis);\n-        check(TOK.semicolon);\n+        check(TOK.semicolon, \"static assert\");\n         return new AST.StaticAssert(loc, exp, msg);\n     }\n \n@@ -2648,7 +2648,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     }\n                 }\n                 check(TOK.rightParenthesis);\n-                check(TOK.semicolon);\n+                check(TOK.semicolon, \"invariant\");\n                 e = new AST.AssertExp(loc, e, msg);\n                 auto fbody = new AST.ExpStatement(loc, e);\n                 auto f = new AST.InvariantDeclaration(loc, token.loc, stc, null, fbody);\n@@ -4738,7 +4738,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         nextToken();        // advance past =\n         auto t = parseType();\n         AST.Dsymbol s = new AST.AliasAssign(loc, ident, t, null);\n-        check(TOK.semicolon);\n+        check(TOK.semicolon, \"alias reassignment\");\n         addComment(s, comment);\n         auto a = new AST.Dsymbols();\n         a.push(s);\n@@ -4774,7 +4774,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             auto s = new AST.AliasThis(loc, token.ident);\n             nextToken();\n             check(TOK.this_);\n-            check(TOK.semicolon);\n+            check(TOK.semicolon, \"`alias Identifier this`\");\n             auto a = new AST.Dsymbols();\n             a.push(s);\n             addComment(s, comment);\n@@ -4791,7 +4791,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 check(TOK.assign);\n                 auto s = new AliasThis(loc, token.ident);\n                 nextToken();\n-                check(TOK.semicolon);\n+                check(TOK.semicolon, \"`alias this = Identifier`\");\n                 auto a = new Dsymbols();\n                 a.push(s);\n                 addComment(s, comment);\n@@ -5331,6 +5331,33 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         error(loc, \"instead of C-style syntax, use D-style `%s%s%s`\", t.toChars(), sp, s);\n     }\n \n+    /*****************************\n+     * Ad-hoc error message for missing or extra parens that close a condition.\n+     * Params:\n+     *  start = \"if\", \"while\", etc. Must be 0 terminated.\n+     *  param = if the condition is a declaration, this will be non-null\n+     *  condition = if param is null, then this is the conditional Expression. If condition is null,\n+     *      then an error in the condition was already reported.\n+     */\n+    private void closeCondition(string start, AST.Parameter param, AST.Expression condition)\n+    {\n+        string format;\n+        if (token.value != TOK.rightParenthesis && condition)\n+        {\n+            format = \"missing closing `)` after `%s (%s`\";\n+        }\n+        else\n+            check(TOK.rightParenthesis);\n+        if (token.value == TOK.rightParenthesis)\n+        {\n+            if (condition) // if not an error in condition\n+                format = \"extra `)` after `%s (%s)`\";\n+            nextToken();\n+        }\n+        if (format)\n+            error(format.ptr, start.ptr, param ? \"declaration\".ptr : condition.toChars());\n+    }\n+\n     /*****************************************\n      * Parses `foreach` statements, `static foreach` statements and\n      * `static foreach` declarations.\n@@ -5905,7 +5932,7 @@ LagainStc:\n                 {\n                     // mixin(string)\n                     AST.Expression e = parseAssignExp();\n-                    check(TOK.semicolon);\n+                    check(TOK.semicolon, \"mixin\");\n                     if (e.op == EXP.mixin_)\n                     {\n                         AST.MixinExp cpe = cast(AST.MixinExp)e;\n@@ -5961,12 +5988,12 @@ LagainStc:\n             }\n         case TOK.while_:\n             {\n-                AST.Parameter param = null;\n                 nextToken();\n                 check(TOK.leftParenthesis);\n-                param = parseAssignCondition();\n-                AST.Expression condition = parseExpression();\n-                check(TOK.rightParenthesis);\n+                auto param = parseAssignCondition();\n+                auto condition = parseExpression();\n+                closeCondition(\"while\", param, condition);\n+\n                 Loc endloc;\n                 AST.Statement _body = parseStatement(ParseStatementFlags.scope_, null, &endloc);\n                 s = new AST.WhileStatement(loc, condition, _body, endloc, param);\n@@ -5987,7 +6014,6 @@ LagainStc:\n         case TOK.do_:\n             {\n                 AST.Statement _body;\n-                AST.Expression condition;\n \n                 nextToken();\n                 const lookingForElseSave = lookingForElse;\n@@ -5996,8 +6022,8 @@ LagainStc:\n                 lookingForElse = lookingForElseSave;\n                 check(TOK.while_);\n                 check(TOK.leftParenthesis);\n-                condition = parseExpression();\n-                check(TOK.rightParenthesis);\n+                auto condition = parseExpression();\n+                closeCondition(\"do .. while\", null, condition);\n                 if (token.value == TOK.semicolon)\n                     nextToken();\n                 else\n@@ -6058,25 +6084,11 @@ LagainStc:\n             }\n         case TOK.if_:\n             {\n-                AST.Parameter param = null;\n-                AST.Expression condition;\n-\n                 nextToken();\n                 check(TOK.leftParenthesis);\n-                param = parseAssignCondition();\n-                condition = parseExpression();\n-                if (token.value != TOK.rightParenthesis && condition)\n-                {\n-                    error(\"missing closing `)` after `if (%s`\", param ? \"declaration\".ptr : condition.toChars());\n-                }\n-                else\n-                    check(TOK.rightParenthesis);\n-                if (token.value == TOK.rightParenthesis)\n-                {\n-                    if (condition) // if not an error in condition\n-                        error(\"extra `)` after `if (%s)`\", param ? \"declaration\".ptr : condition.toChars());\n-                    nextToken();\n-                }\n+                auto param = parseAssignCondition();\n+                auto condition = parseExpression();\n+                closeCondition(\"if\", param, condition);\n \n                 {\n                     const lookingForElseSave = lookingForElse;\n@@ -6223,7 +6235,7 @@ LagainStc:\n                 nextToken();\n                 check(TOK.leftParenthesis);\n                 AST.Expression condition = parseExpression();\n-                check(TOK.rightParenthesis);\n+                closeCondition(\"switch\", null, condition);\n                 AST.Statement _body = parseStatement(ParseStatementFlags.scope_);\n                 s = new AST.SwitchStatement(loc, condition, _body, isfinal);\n                 break;\n@@ -6402,7 +6414,7 @@ LagainStc:\n                 {\n                     nextToken();\n                     exp = parseExpression();\n-                    check(TOK.rightParenthesis);\n+                    closeCondition(\"synchronized\", null, exp);\n                 }\n                 else\n                     exp = null;\n@@ -6419,7 +6431,7 @@ LagainStc:\n                 nextToken();\n                 check(TOK.leftParenthesis);\n                 exp = parseExpression();\n-                check(TOK.rightParenthesis);\n+                closeCondition(\"with\", null, exp);\n                 _body = parseStatement(ParseStatementFlags.scope_, null, &endloc);\n                 s = new AST.WithStatement(loc, exp, _body, endloc);\n                 break;\n@@ -6511,7 +6523,7 @@ LagainStc:\n                 if (peekNext() == TOK.leftParenthesis)\n                 {\n                     AST.Expression e = parseExpression();\n-                    check(TOK.semicolon);\n+                    check(TOK.semicolon, \"`import` Expression\");\n                     s = new AST.ExpStatement(loc, e);\n                 }\n                 else"}, {"sha": "121d37cad9745a39010a2c0ae2eac64b3bee3f61", "filename": "gcc/d/dmd/root/README.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2FREADME.md?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2,25 +2,25 @@\n \n | File                                                                                 | Purpose                                                                                    |\n |--------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|\n-| [aav.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/aav.d)                 | An associative array implementation                                                        |\n-| [array.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/array.d)             | A dynamic array implementation                                                             |\n-| [bitarray.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/bitarray.d)       | A compact array of bits                                                                    |\n-| [complex.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/complex.d)         | A complex number type                                                                      |\n-| [ctfloat.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/ctfloat.d)         | A floating point type for compile-time calculations                                        |\n-| [env.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/env.d)                 | Modify environment variables                                                               |\n-| [file.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/file.d)               | Read a file from disk and store it in memory                                               |\n-| [filename.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/filename.d)       | Encapsulate path and file names                                                            |\n-| [hash.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/hash.d)               | Calculate a hash for a byte array                                                          |\n-| [longdouble.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/longdouble.d)   | 80-bit floating point number implementation in case they are not natively supported        |\n-| [man.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/man.d)                 | Opens an online manual page                                                                |\n-| [optional.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/optional.d)       | Implementation of an 'Optional' type                                                       |\n-| [port.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/port.d)               | Portable routines for functions that have different implementations on different platforms |\n-| [region.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/region.d)           | A region allocator                                                                         |\n-| [response.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/response.d)       | Parse command line arguments from response files                                           |\n-| [rmem.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/rmem.d)               | Allocate memory using `malloc` or the GC depending on the configuration                    |\n-| [rootobject.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/rootobject.d)   | A root object that classes in dmd inherit from                                             |\n-| [speller.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/speller.d)         | Try to detect typos in identifiers                                                         |\n-| [string.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/string.d)           | Various string related functions                                                           |\n-| [stringtable.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/stringtable.d) | Specialized associative array with string keys stored in a variable length structure       |\n-| [strtold.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/strtold.d)         | D implementation of the standard C function `strtold` (String to long double)              |\n-| [utf.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/utf.d)                 | Encoding/decoding Unicode text                                                             |\n+| [aav.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/aav.d)                 | An associative array implementation                                                        |\n+| [array.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/array.d)             | A dynamic array implementation                                                             |\n+| [bitarray.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/bitarray.d)       | A compact array of bits                                                                    |\n+| [complex.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/complex.d)         | A complex number type                                                                      |\n+| [ctfloat.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/ctfloat.d)         | A floating point type for compile-time calculations                                        |\n+| [env.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/env.d)                 | Modify environment variables                                                               |\n+| [file.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/file.d)               | Read a file from disk and store it in memory                                               |\n+| [filename.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/filename.d)       | Encapsulate path and file names                                                            |\n+| [hash.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/hash.d)               | Calculate a hash for a byte array                                                          |\n+| [longdouble.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/longdouble.d)   | 80-bit floating point number implementation in case they are not natively supported        |\n+| [man.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/man.d)                 | Opens an online manual page                                                                |\n+| [optional.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/optional.d)       | Implementation of an 'Optional' type                                                       |\n+| [port.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/port.d)               | Portable routines for functions that have different implementations on different platforms |\n+| [region.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/region.d)           | A region allocator                                                                         |\n+| [response.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/response.d)       | Parse command line arguments from response files                                           |\n+| [rmem.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/rmem.d)               | Allocate memory using `malloc` or the GC depending on the configuration                    |\n+| [rootobject.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/rootobject.d)   | A root object that classes in dmd inherit from                                             |\n+| [speller.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/speller.d)         | Try to detect typos in identifiers                                                         |\n+| [string.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/string.d)           | Various string related functions                                                           |\n+| [stringtable.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/stringtable.d) | Specialized associative array with string keys stored in a variable length structure       |\n+| [strtold.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/strtold.d)         | D implementation of the standard C function `strtold` (String to long double)              |\n+| [utf.d](https://github.com/dlang/dmd/blob/master/compiler/src/dmd/root/utf.d)                 | Encoding/decoding Unicode text                                                             |"}, {"sha": "212fe96f4dc8ea54b22fe4543201b9eba39334c1", "filename": "gcc/d/dmd/root/array.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -222,6 +222,16 @@ public:\n         }\n     }\n \n+    extern (D) void insert(size_t index, T[] a) pure nothrow\n+    {\n+        size_t d = a.length;\n+        reserve(d);\n+        if (length != index)\n+            memmove(data.ptr + index + d, data.ptr + index, (length - index) * T.sizeof);\n+        memcpy(data.ptr + index, a.ptr, d * T.sizeof);\n+        length += d;\n+    }\n+\n     void insert(size_t index, T ptr) pure nothrow\n     {\n         reserve(1);\n@@ -414,6 +424,14 @@ unittest\n     arrayA.zero();\n     foreach(e; arrayA)\n         assert(e == 0);\n+\n+    arrayA.setDim(0);\n+    arrayA.pushSlice([5, 6]);\n+    arrayA.insert(1, [1, 2]);\n+    assert(arrayA[] == [5, 1, 2, 6]);\n+    arrayA.insert(0, [7, 8]);\n+    arrayA.insert(arrayA.length, [0, 9]);\n+    assert(arrayA[] == [7, 8, 5, 1, 2, 6, 0, 9]);\n }\n \n /**"}, {"sha": "8c2fe46eebe140d61f8da78134d455e55de37c86", "filename": "gcc/d/dmd/root/ctfloat.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -47,7 +47,7 @@ extern (C++) struct CTFloat\n     static bool isInfinity(real_t r) pure;\n \n     @system\n-    static real_t parse(const(char)* literal, bool* isOutOfRange = null);\n+    static real_t parse(const(char)* literal, out bool isOutOfRange);\n \n     @system\n     static int sprint(char* str, char fmt, real_t x);"}, {"sha": "5a6cf258ed8d207fd55225301c381f51abae2d12", "filename": "gcc/d/dmd/root/ctfloat.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -50,7 +50,7 @@ struct CTFloat\n     static bool isSNaN(real_t r);\n     static bool isInfinity(real_t r);\n \n-    static real_t parse(const char *literal, bool *isOutOfRange = NULL);\n+    static real_t parse(const char *literal, bool& isOutOfRange);\n     static int sprint(char *str, char fmt, real_t x);\n \n     static size_t hash(real_t a);"}, {"sha": "ad4487f55dcc2517e99ae6219537b631f601d3a5", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -472,9 +472,6 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                         stc |= STC.variadic;\n                     }\n \n-                    if ((funcdecl.flags & FUNCFLAG.inferScope) && !(fparam.storageClass & STC.scope_))\n-                        stc |= STC.maybescope;\n-\n                     stc |= fparam.storageClass & (STC.IOR | STC.return_ | STC.scope_ | STC.lazy_ | STC.final_ | STC.TYPECTOR | STC.nodtor | STC.returnScope | STC.register);\n                     v.storage_class = stc;\n                     v.dsymbolSemantic(sc2);"}, {"sha": "367c56b7918df0efc5478d7be5809362e96d2a76", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1268,6 +1268,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         auto o = (*e.args)[0];\n         auto po = isParameter(o);\n         auto s = getDsymbolWithoutExpCtx(o);\n+        auto typeOfArg = isType(o);\n         UserAttributeDeclaration udad = null;\n         if (po)\n         {\n@@ -1282,6 +1283,10 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             //printf(\"getAttributes %s, attrs = %p, scope = %p\\n\", s.toChars(), s.userAttribDecl, s._scope);\n             udad = s.userAttribDecl;\n         }\n+        else if (typeOfArg)\n+        {\n+            // If there is a type but no symbol, do nothing rather than erroring.\n+        }\n         else\n         {\n             version (none)"}, {"sha": "b21ff7904ac18ec4364b38e022917e208696b311", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1447,6 +1447,11 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                         eparam.storageClass &= ~STC.auto_;\n                         eparam.storageClass |= STC.autoref;\n                     }\n+                    else if (eparam.storageClass & STC.ref_)\n+                    {\n+                        .error(loc, \"cannot explicitly instantiate template function with `auto ref` parameter\");\n+                        errors = true;\n+                    }\n                     else\n                     {\n                         .error(loc, \"`auto` can only be used as part of `auto ref` for template function parameters\");"}, {"sha": "b0ce87019f09d090e1982e6e28041c9bdb7c84b8", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -986,11 +986,9 @@ class ExprVisitor : public Visitor\n \t    else if ((postblit || destructor)\n \t\t     && e->op != EXP::blit && e->op != EXP::construct)\n \t      {\n-\t\t/* Generate: _d_arrayassign(ti, from, to);  */\n-\t\tthis->result_ = build_libcall (LIBCALL_ARRAYASSIGN, e->type, 3,\n-\t\t\t\t\t       build_typeinfo (e, etype),\n-\t\t\t\t\t       d_array_convert (e->e2),\n-\t\t\t\t\t       d_array_convert (e->e1));\n+\t\t/* Assigning to a non-trivially copyable array has already been\n+\t\t   handled by the front-end.  */\n+\t\tgcc_unreachable ();\n \t      }\n \t    else\n \t      {\n@@ -1124,27 +1122,7 @@ class ExprVisitor : public Visitor\n \t/* All other kinds of lvalue or rvalue static array assignment.\n \t   Array construction has already been handled by the front-end.  */\n \tgcc_assert (e->op != EXP::construct);\n-\n-\t/* Generate: _d_arrayassign_l()\n-\t\t or: _d_arrayassign_r()  */\n-\tlibcall_fn libcall = (lvalue)\n-\t  ? LIBCALL_ARRAYASSIGN_L : LIBCALL_ARRAYASSIGN_R;\n-\ttree elembuf = build_local_temp (build_ctype (etype));\n-\tType *arrtype = (e->type->ty == TY::Tsarray)\n-\t  ? etype->arrayOf () : e->type;\n-\ttree result = build_libcall (libcall, arrtype, 4,\n-\t\t\t\t     build_typeinfo (e, etype),\n-\t\t\t\t     d_array_convert (e->e2),\n-\t\t\t\t     d_array_convert (e->e1),\n-\t\t\t\t     build_address (elembuf));\n-\n-\t/* Cast the libcall result back to a static array.  */\n-\tif (e->type->ty == TY::Tsarray)\n-\t  result = indirect_ref (build_ctype (e->type),\n-\t\t\t\t d_array_ptr (result));\n-\n-\tthis->result_ = result;\n-\treturn;\n+\tgcc_unreachable ();\n       }\n \n     /* Simple assignment.  */"}, {"sha": "282f22c50730b39200c077c7fc435d83b0d504f5", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -115,14 +115,7 @@ DEF_D_RUNTIME (ALLOCMEMORY, \"_d_allocmemory\", RT(VOIDPTR), P1(SIZE_T),\n DEF_D_RUNTIME (ARRAYCOPY, \"_d_arraycopy\", RT(ARRAY_VOID),\n \t       P3(SIZE_T, ARRAY_VOID, ARRAY_VOID), 0)\n \n-/* Used for array assignments from an existing array.  The `set' variant is for\n-   when the assignment value is a single element.  */\n-DEF_D_RUNTIME (ARRAYASSIGN, \"_d_arrayassign\", RT(ARRAY_VOID),\n-\t       P3(CONST_TYPEINFO, ARRAY_VOID, ARRAY_VOID), 0)\n-DEF_D_RUNTIME (ARRAYASSIGN_L, \"_d_arrayassign_l\", RT(ARRAY_VOID),\n-\t       P4(CONST_TYPEINFO, ARRAY_VOID, ARRAY_VOID, VOIDPTR), 0)\n-DEF_D_RUNTIME (ARRAYASSIGN_R, \"_d_arrayassign_r\", RT(ARRAY_VOID),\n-\t       P4(CONST_TYPEINFO, ARRAY_VOID, ARRAY_VOID, VOIDPTR), 0)\n+/* Used for array assignments from a single element.  */\n DEF_D_RUNTIME (ARRAYSETASSIGN, \"_d_arraysetassign\", RT(VOIDPTR),\n \t       P4(VOIDPTR, VOIDPTR, SIZE_T, CONST_TYPEINFO), 0)\n "}, {"sha": "8643f5dc6852b7f281ea28b79d5d9396e673ecc4", "filename": "gcc/testsuite/gdc.test/compilable/aliasassign.d", "status": "modified", "additions": 100, "deletions": 5, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Faliasassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Faliasassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Faliasassign.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -3,18 +3,18 @@ template AliasSeq(T...) { alias AliasSeq = T; }\n template Unqual(T)\n {\n     static if (is(T U == const U))\n-\talias Unqual = U;\n+        alias Unqual = U;\n     else static if (is(T U == immutable U))\n-\talias Unqual = U;\n+        alias Unqual = U;\n     else\n-\talias Unqual = T;\n+        alias Unqual = T;\n }\n \n template staticMap(alias F, T...)\n {\n     alias A = AliasSeq!();\n     static foreach (t; T)\n-\tA = AliasSeq!(A, F!t); // what's tested\n+        A = AliasSeq!(A, F!t); // what's tested\n     alias staticMap = A;\n }\n \n@@ -28,7 +28,7 @@ template reverse(T...)\n {\n     alias A = AliasSeq!();\n     static foreach (t; T)\n-\tA = AliasSeq!(t, A); // what's tested\n+        A = AliasSeq!(t, A); // what's tested\n     alias reverse = A;\n }\n \n@@ -38,3 +38,98 @@ alias TK2 = reverse!(int, const uint, X2);\n static assert(TK2[0] == 3);\n static assert(is(TK2[1] == const(uint)));\n static assert(is(TK2[2] == int));\n+\n+/**************************************************/\n+\n+template Tp(Args...)\n+{\n+    alias Tp = AliasSeq!(int, 1, \"asd\", Args);\n+    static foreach (arg; Args)\n+    {\n+        Tp = AliasSeq!(4, Tp, \"zxc\", arg, Tp, 5, 4, int, Tp[0..2]);\n+    }\n+}\n+\n+void fun(){}\n+\n+alias a1 = Tp!(char[], fun, x => x);\n+static assert(\n+        __traits(isSame, a1, AliasSeq!(4, 4, 4, int, 1, \"asd\", char[], fun,\n+                x => x, \"zxc\", char[], int, 1, \"asd\", char[], fun, x => x,\n+                5, 4, int, int, 1, \"zxc\", fun, 4, int, 1, \"asd\", char[],\n+                fun, x => x, \"zxc\", char[], int, 1, \"asd\", char[], fun,\n+                x => x, 5, 4, int, int, 1, 5, 4, int, 4, int, \"zxc\", x => x,\n+                4, 4, int, 1, \"asd\", char[], fun, x => x, \"zxc\", char[],\n+                int, 1, \"asd\", char[], fun, x => x, 5, 4, int, int, 1,\n+                \"zxc\", fun, 4, int, 1, \"asd\", char[], fun, x => x, \"zxc\",\n+                char[], int, 1, \"asd\", char[], fun, x => x, 5, 4, int, int,\n+                1, 5, 4, int, 4, int, 5, 4, int, 4, 4)));\n+\n+template Tp2(Args...)\n+{\n+    alias Tp2 = () => 1;\n+    static foreach (i; 0..Args.length)\n+        Tp2 = AliasSeq!(Tp2, Args[i]);\n+}\n+\n+const x = 8;\n+static assert(\n+        __traits(isSame, Tp2!(2, float, x), AliasSeq!(() => 1, 2, float, x)));\n+\n+\n+enum F(int i) = i * i;\n+\n+template staticMap2(alias fun, args...)\n+{\n+    alias staticMap2 = AliasSeq!();\n+    static foreach (i; 0 .. args.length)\n+        staticMap2 = AliasSeq!(fun!(args[i]), staticMap2, fun!(args[i]));\n+}\n+\n+enum a2 = staticMap2!(F, 0, 1, 2, 3, 4);\n+\n+struct Cmp(T...){}\n+// isSame sucks\n+static assert(is(Cmp!a2 == Cmp!(16, 9, 4, 1, 0, 0, 1, 4, 9, 16)));\n+\n+template Tp3()\n+{\n+    alias aa1 = int;\n+    static foreach (t; AliasSeq!(float, char[]))\n+        aa1 = AliasSeq!(aa1, t);\n+    static assert(is(aa1 == AliasSeq!(int, float, char[])));\n+\n+    alias aa2 = AliasSeq!int;\n+    static foreach (t; AliasSeq!(float, char[]))\n+        aa2 = AliasSeq!(aa2, t);\n+    static assert(is(aa2 == AliasSeq!(int, float, char[])));\n+\n+    alias aa3 = AliasSeq!int;\n+    aa3 = AliasSeq!(float, char);\n+    static assert(is(aa3 == AliasSeq!(float, char)));\n+}\n+alias a3 = Tp3!();\n+\n+template Tp4() // Uses slow path because overload\n+{\n+    alias AliasSeq(T...) = T;\n+    alias AliasSeq(alias f, T...) = T;\n+\n+    alias aa4 = int;\n+    aa4 = AliasSeq!(aa4, float);\n+    static assert(is(aa4 == AliasSeq!(int, float)));\n+\n+}\n+alias a4 = Tp4!();\n+\n+template Tp5() // same tp overloaded, still uses fast path\n+{\n+    alias AliasSeq2(T...) = T;\n+    alias AliasSeq = AliasSeq2;\n+    alias AliasSeq = AliasSeq2;\n+\n+    alias aa5 = int;\n+    aa5 = AliasSeq!(aa5, float);\n+    static assert(is(aa5 == AliasSeq!(int, float)));\n+}\n+alias a5 = Tp5!();"}, {"sha": "8ef54a14be21fd81b07c88fdbe977c14ffa06dc2", "filename": "gcc/testsuite/gdc.test/compilable/scope_infer_array_assign.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope_infer_array_assign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope_infer_array_assign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope_infer_array_assign.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,28 @@\n+// REQUIRED_ARGS: -preview=dip1000\n+\n+// Test that scope inference works even with non POD array assignment\n+// This is tricky because it gets lowered to something like:\n+// (S[] __assigntmp0 = e[]) , _d_arrayassign_l(this.e[], __assigntmp0) , this.e[];\n+\n+@safe:\n+\n+struct File\n+{\n+    void* f;\n+    ~this() scope { }\n+}\n+\n+struct Vector\n+{\n+    File[] e;\n+\n+    auto assign(File[] e)\n+    {\n+        this.e[] = e[]; // slice copy\n+    }\n+}\n+\n+void test(scope File[] arr, Vector v)\n+{\n+    v.assign(arr);\n+}"}, {"sha": "01ee66e4c05df4c59087fdd4025cc6ece6822281", "filename": "gcc/testsuite/gdc.test/compilable/test21197.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21197.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21197.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21197.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,25 @@\n+/* REQUIRED_ARGS: -preview=dip1000\n+ */\n+// https://issues.dlang.org/show_bug.cgi?id=21197\n+\n+@safe void check2()\n+{\n+    int random;\n+\n+    S create1() return scope {\n+        return S();\n+    }\n+\n+    scope S gen1 = create1;\n+\n+    S create2() {\n+        return S(&random);\n+    }\n+\n+    scope S gen2 = create2;\n+}\n+\n+struct S\n+{\n+    int* r;\n+}"}, {"sha": "aa6277b021b07721bc66370fd1aa8bd7e37f0ddb", "filename": "gcc/testsuite/gdc.test/compilable/uda.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fuda.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fuda.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fuda.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -6,3 +6,9 @@ struct foo { }\n @foo bar () { }\n \n /************************************************/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23241\n+\n+alias feynman = int;\n+enum get = __traits(getAttributes, feynman);\n+static assert(get.length == 0);"}, {"sha": "dd421c90eeefb1f8edc3cf84f93dd1dbaf159d53", "filename": "gcc/testsuite/gdc.test/fail_compilation/aliasassign2.d", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Faliasassign2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Faliasassign2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Faliasassign2.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,33 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/aliasassign2.d(16): Error: `alias aa1 = aa1;` cannot alias itself, use a qualified name to create an overload set\n+fail_compilation/aliasassign2.d(19): Error: template instance `aliasassign2.Tp1!()` error instantiating\n+fail_compilation/aliasassign2.d(24): Error: undefined identifier `unknown`\n+fail_compilation/aliasassign2.d(26): Error: template instance `aliasassign2.Tp2!()` error instantiating\n+fail_compilation/aliasassign2.d(31): Error: template instance `AliasSeqX!(aa3, 1)` template `AliasSeqX` is not defined, did you mean AliasSeq(T...)?\n+fail_compilation/aliasassign2.d(33): Error: template instance `aliasassign2.Tp3!()` error instantiating\n+---\n+*/\n+\n+alias AliasSeq(T...) = T;\n+\n+template Tp1()\n+{\n+    alias aa1 = aa1;\n+    aa1 = AliasSeq!(aa1, float);\n+}\n+alias a1 = Tp1!();\n+\n+template Tp2()\n+{\n+    alias aa2 = AliasSeq!();\n+    aa2 = AliasSeq!(aa2, unknown);\n+}\n+alias a2 = Tp2!();\n+\n+template Tp3()\n+{\n+    alias aa3 = AliasSeq!();\n+    aa3 = AliasSeqX!(aa3, 1);\n+}\n+alias a3 = Tp3!();"}, {"sha": "a0bfe883966f965b175b70bda742144382e3ca76", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag23295.d", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23295.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23295.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23295.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,40 @@\n+/*\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/diag23295.d(21): Error: scope variable `x` assigned to non-scope parameter `y` calling `foo`\n+fail_compilation/diag23295.d(32):        which is assigned to non-scope parameter `z`\n+fail_compilation/diag23295.d(34):        which is not `scope` because of `f = & z`\n+fail_compilation/diag23295.d(24): Error: scope variable `ex` assigned to non-scope parameter `e` calling `thro`\n+fail_compilation/diag23295.d(39):        which is not `scope` because of `throw e`\n+---\n+*/\n+\n+// explain why scope inference failed\n+// https://issues.dlang.org/show_bug.cgi?id=23295\n+\n+@safe:\n+\n+void main()\n+{\n+    scope int* x;\n+    foo(x, null);\n+\n+    scope Exception ex;\n+    thro(ex);\n+}\n+\n+auto foo(int* y, int** w)\n+{\n+    fooImpl(y, null);\n+}\n+\n+auto fooImpl(int* z, int** w)\n+{\n+    auto f = &z;\n+}\n+\n+auto thro(Exception e)\n+{\n+    throw e;\n+}"}, {"sha": "e969b2493f73962970c088d5e9d2b76368d19bb0", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10968.d", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,26 +1,27 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(41): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(41): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(42): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(42): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(43): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(43): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(46): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(46): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(44): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.arrayassign._d_arrayassign_l!(SA[], SA)._d_arrayassign_l`\n fail_compilation/fail10968.d(47): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(47): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(47): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arraysetctor!(SA[], SA)._d_arraysetctor`\n+fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(48): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arrayctor!(SA[], SA)._d_arrayctor`\n+fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arraysetctor!(SA[], SA)._d_arraysetctor`\n+fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(49): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arrayctor!(SA[], SA)._d_arrayctor`\n ---\n */\n \n@@ -51,12 +52,12 @@ void bar() pure @safe\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(74): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(75): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(76): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n-fail_compilation/fail10968.d(79): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(77): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(80): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(81): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(82): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n ---\n */\n "}, {"sha": "5621ecceda8c11c5c0881ffc8e2f041e064f0cea", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail14669.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14669.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14669.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14669.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -20,9 +20,9 @@ void test1()\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail14669.d(29): Error: `auto` can only be used as part of `auto ref` for template function parameters\n+fail_compilation/fail14669.d(29): Error: cannot explicitly instantiate template function with `auto ref` parameter\n fail_compilation/fail14669.d(38): Error: template instance `fail14669.bar1!int` error instantiating\n-fail_compilation/fail14669.d(30): Error: `auto` can only be used as part of `auto ref` for template function parameters\n+fail_compilation/fail14669.d(30): Error: cannot explicitly instantiate template function with `auto ref` parameter\n fail_compilation/fail14669.d(40): Error: template instance `fail14669.bar2!int` error instantiating\n ---\n */"}, {"sha": "a30a65b200b75ca1b296fee469d8a7c5486d16ab", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice8795.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice8795.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice8795.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice8795.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -3,7 +3,7 @@ TEST_OUTPUT:\n ---\n fail_compilation/ice8795.d-mixin-14(14): Error: found `End of File` when expecting `(`\n fail_compilation/ice8795.d-mixin-14(14): Error: expression expected, not `End of File`\n-fail_compilation/ice8795.d-mixin-14(14): Error: found `End of File` when expecting `)`\n+fail_compilation/ice8795.d-mixin-14(14): Error: missing closing `)` after `switch (0`\n fail_compilation/ice8795.d-mixin-14(14): Error: found `End of File` instead of statement\n fail_compilation/ice8795.d-mixin-15(15): Error: { } expected following `interface` declaration\n fail_compilation/ice8795.d-mixin-15(15): Error: anonymous interfaces not allowed"}, {"sha": "9c05e7c3d0328a5773a50cdad801429076300054", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/import15525.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimport15525.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimport15525.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimport15525.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,3 @@\n+module imports.import15525;\n+\n+template Tuple{ static if }"}, {"sha": "0ddd6b48b534b297808015d6abfbd7cdce360897", "filename": "gcc/testsuite/gdc.test/fail_compilation/issue12652.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue12652.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue12652.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue12652.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,24 @@\n+/*\n+TEST_OUTPUT:\n+----\n+fail_compilation/issue12652.d(18): Error: static initializations of associative arrays is not allowed.\n+fail_compilation/issue12652.d(18):        associative arrays must be initialized at runtime: https://dlang.org/spec/hash-map.html#runtime_initialization\n+---\n+*/\n+\n+enum A\n+{\n+    x,\n+    y,\n+    z\n+}\n+\n+struct S\n+{\n+    string[A] t = [A.x : \"aaa\", A.y : \"bbb\"];\n+}\n+\n+void main ()\n+{\n+    S s;\n+}"}, {"sha": "95d5dbe5507ddbe4aa759acc44bfa9551a0a36f3", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope6.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -78,6 +78,7 @@ void foo() @safe\n fail_compilation/retscope6.d(8016): Error: address of variable `i` assigned to `p` with longer lifetime\n fail_compilation/retscope6.d(8031): Error: reference to local variable `i` assigned to non-scope parameter `p` calling `betty`\n fail_compilation/retscope6.d(8031): Error: reference to local variable `j` assigned to non-scope parameter `q` calling `betty`\n+fail_compilation/retscope6.d(8021):        which is assigned to non-scope parameter `p`\n fail_compilation/retscope6.d(8048): Error: reference to local variable `j` assigned to non-scope parameter `q` calling `archie`\n ---\n */\n@@ -255,6 +256,7 @@ void escape_throw_20150() @safe\n /* TEST_OUTPUT:\n ---\n fail_compilation/retscope6.d(14019): Error: scope variable `scopePtr` assigned to non-scope parameter `x` calling `noInfer23021`\n+fail_compilation/retscope6.d(14009):        which is not `scope` because of `*escapeHole = cast(const(int)*)x`\n fail_compilation/retscope6.d(14022): Error: scope variable `scopePtr` may not be returned\n ---\n */"}, {"sha": "7d15b16bdc1f787b00068d653a8d140a2884b07b", "filename": "gcc/testsuite/gdc.test/fail_compilation/shared.d", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fshared.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fshared.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fshared.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -225,3 +225,14 @@ auto ref Object test_inference_4(const return shared ref Object a)\n {\n     return a;\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23226\n+// Allow accessing non-shared `this`\n+struct BitRange\n+{\n+    int bits;\n+    void f()\n+    {\n+        this.bits++;\n+    }\n+}"}, {"sha": "cd35f3046f2750a9c47f80e4d0666b0aa578605a", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15525.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15525.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15525.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15525.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,17 @@\n+// https://issues.dlang.org/show_bug.cgi?id=15525\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/imports/import15525.d(3): Error: parenthesized template parameter list expected following template identifier\n+fail_compilation/imports/import15525.d(3): Error: (expression) expected following `static if`\n+fail_compilation/imports/import15525.d(3): Error: declaration expected, not `}`\n+fail_compilation/test15525.d(16): Error: template instance `Tuple!()` template `Tuple` is not defined\n+---\n+*/\n+\n+struct CrashMe\n+{\n+    import imports.import15525;\n+    Tuple!() crash;\n+}"}, {"sha": "faa98063e65f12c597f340d47a0a433547cb999b", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17423.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17423.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17423.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17423.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,7 +1,8 @@\n /* REQUIRED_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n-fail_compilation/test17423.d(26): Error: reference to local `this` assigned to non-scope parameter `dlg` calling `opApply`\n+fail_compilation/test17423.d(27): Error: reference to local `this` assigned to non-scope parameter `dlg` calling `opApply`\n+fail_compilation/test17423.d(16):        which is not `scope` because of `this.myDlg = dlg`\n ---\n */\n "}, {"sha": "6ee988a5dbb646a25ccb47c680635a29c1f5631a", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17764.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17764.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17764.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17764.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,21 @@\n+/* REQUIRED_ARGS: -preview=dip1000\n+ * TEST_OUTPUT:\n+---\n+fail_compilation/test17764.d(109): Error: scope variable `c` assigned to non-scope `global`\n+---\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=17764\n+\n+#line 100\n+\n+int** global;\n+\n+struct S { int** str; }\n+\n+void f() @safe\n+{\n+    int* buf;\n+    S[1] c = S(&buf);\n+    global = c[0].str; /* This should be rejected. */\n+}"}, {"sha": "98caa03b2f52dba94778d82854d92596adc0de44", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20245.d", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20245.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20245.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20245.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2,15 +2,16 @@\n REQUIRED_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n-fail_compilation/test20245.d(20): Error: reference to local variable `x` assigned to non-scope parameter `ptr` calling `escape`\n-fail_compilation/test20245.d(21): Error: copying `&x` into allocated memory escapes a reference to parameter `x`\n-fail_compilation/test20245.d(22): Error: scope variable `a` may not be returned\n-fail_compilation/test20245.d(26): Error: cannot take address of `scope` variable `x` since `scope` applies to first indirection only\n-fail_compilation/test20245.d(32): Error: reference to local variable `x` assigned to non-scope parameter `ptr` calling `escape`\n-fail_compilation/test20245.d(33): Error: copying `&x` into allocated memory escapes a reference to parameter `x`\n-fail_compilation/test20245.d(49): Error: reference to local variable `price` assigned to non-scope `this.minPrice`\n-fail_compilation/test20245.d(68): Error: reference to local variable `this` assigned to non-scope parameter `msg` calling `this`\n-fail_compilation/test20245.d(88): Error: reference to local variable `this` assigned to non-scope parameter `content` calling `listUp`\n+fail_compilation/test20245.d(21): Error: reference to local variable `x` assigned to non-scope parameter `ptr` calling `escape`\n+fail_compilation/test20245.d(22): Error: copying `&x` into allocated memory escapes a reference to parameter `x`\n+fail_compilation/test20245.d(23): Error: scope variable `a` may not be returned\n+fail_compilation/test20245.d(27): Error: cannot take address of `scope` variable `x` since `scope` applies to first indirection only\n+fail_compilation/test20245.d(33): Error: reference to local variable `x` assigned to non-scope parameter `ptr` calling `escape`\n+fail_compilation/test20245.d(34): Error: copying `&x` into allocated memory escapes a reference to parameter `x`\n+fail_compilation/test20245.d(50): Error: reference to local variable `price` assigned to non-scope `this.minPrice`\n+fail_compilation/test20245.d(69): Error: reference to local variable `this` assigned to non-scope parameter `msg` calling `this`\n+fail_compilation/test20245.d(89): Error: reference to local variable `this` assigned to non-scope parameter `content` calling `listUp`\n+fail_compilation/test20245.d(82):        which is not `scope` because of `charPtr = content`\n ---\n */\n "}, {"sha": "44728c5c2ff83aa38d2718fd7a06c4ade5ab2623", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20809.d", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20809.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20809.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20809.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,44 @@\n+/*\n+REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+fail_compilation/test20809.d(114): Deprecation: returning `this.a` escapes a reference to parameter `this`\n+fail_compilation/test20809.d(112):        perhaps annotate the function with `return`\n+---\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=20809\n+\n+#line 100\n+\n+@safe:\n+\n+struct S\n+{\n+    @safe:\n+    int a;\n+    ~this()\n+    {\n+        a = 0;\n+    }\n+\n+    ref int val()\n+    {\n+        return a;\n+    }\n+}\n+\n+S bar()\n+{\n+    return S(2);\n+}\n+\n+int foo()\n+{\n+    return bar.val;\n+}\n+\n+void test()\n+{\n+    assert(foo() == 2);\n+}"}, {"sha": "39106ba572e38ac13d98717307cbaeb660a952f1", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23073.d", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23073.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23073.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23073.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,35 @@\n+/*\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23073.d(28): Error: scope variable `c` assigned to non-scope parameter `c` calling `assignNext`\n+fail_compilation/test23073.d(22):        which is not `scope` because of `c.next = c`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23073\n+// scope inference from pure doesn't consider self-assignment\n+\n+@safe:\n+\n+class C\n+{\n+    C next;\n+}\n+\n+void assignNext(C c) pure nothrow @nogc\n+{\n+    c.next = c;\n+}\n+\n+C escape() @nogc\n+{\n+    scope C c = new C();\n+    assignNext(c);\n+    return c.next;\n+}\n+\n+void main()\n+{\n+    C dangling = escape();\n+}"}, {"sha": "fc9bc65107006205cebd78ebf90ce3887c97c607", "filename": "gcc/testsuite/gdc.test/fail_compilation/testsemi.d", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestsemi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestsemi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftestsemi.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,46 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/testsemi.d(102): Error: found `int` when expecting `;` following static assert\n+fail_compilation/testsemi.d(102): Error: no identifier for declarator `x`\n+fail_compilation/testsemi.d(109): Error: found `alias` when expecting `;` following alias reassignment\n+fail_compilation/testsemi.d(112): Error: found `}` when expecting `;` following invariant\n+fail_compilation/testsemi.d(117): Error: found `int` when expecting `;` following `alias Identifier this`\n+fail_compilation/testsemi.d(117): Error: no identifier for declarator `x`\n+fail_compilation/testsemi.d(123): Error: found `int` when expecting `;` following mixin\n+fail_compilation/testsemi.d(129): Error: found `int` when expecting `;` following `import` Expression\n+fail_compilation/testsemi.d(131): Error: `}` expected following members in `class` declaration at fail_compilation/testsemi.d(112)\n+---\n+ */\n+\n+#line 100\n+\n+static assert(1)\n+int x;\n+\n+template map(alias F, Args...)\n+{\n+    alias A = AliasSeq!();\n+    static foreach (Arg; Args)\n+        A = AliasSeq!(A, F!Arg)\n+    alias staticMap = A;\n+}\n+\n+class C { invariant(3) }\n+\n+class D\n+{\n+    alias x this\n+    int x;\n+}\n+\n+void test1()\n+{\n+    mixin(\"int x;\")\n+    int y;\n+}\n+\n+void test2()\n+{\n+    import(1)\n+    int z;\n+}"}, {"sha": "71865a5a04702fc34c2a347b1c2c8aa211f40602", "filename": "gcc/testsuite/gdc.test/runnable/test20365.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20365.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20365.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20365.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20365\n+\n+string result = \"\";\n+\n+struct S\n+{\n+    long[3] a;\n+    this(ref typeof(this)) { result ~= \"C\"; }\n+}\n+\n+void fun()\n+{\n+    S[4] a;\n+    auto b = a;\n+}\n+\n+void main()\n+{\n+    fun();\n+    assert(result == \"CCCC\");\n+}"}, {"sha": "6d6191e7d1442a86975d6829c2bc226ead26b9f6", "filename": "gcc/testsuite/gdc.test/runnable/test20809.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20809.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20809.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20809.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,14 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20809\n+\n+\n+@safe:\n+struct S{\n+    @safe:\n+    int[8] a;\n+    ~this(){ a[] = 0; }\n+    ref val(){ return a; }\n+}\n+S bar(){ return S([2,2,2,2,2,2,2,2]); }\n+int[8] foo(){ return bar.val; }\n+\n+void main(){ assert(foo() == [2,2,2,2,2,2,2,2]); } // error"}, {"sha": "85fc49d3d0a2e8f62f298079c618beec2a09b803", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,4 +1,4 @@\n-d7772a236983ec37b92d21b28bad3cd2de57b945\n+817610b16d0f0f469b9fbb28c000956fb910c43f\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "d828749837ad89e1d0866638ed92652e6de87474", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -171,17 +171,18 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/builtins.d core/checkedint.d core/cpuid.d core/demangle.d \\\n \tcore/exception.d core/gc/config.d core/gc/gcinterface.d \\\n \tcore/gc/registry.d core/int128.d core/internal/abort.d \\\n-\tcore/internal/array/appending.d core/internal/array/capacity.d \\\n-\tcore/internal/array/casting.d core/internal/array/comparison.d \\\n-\tcore/internal/array/concatenation.d core/internal/array/construction.d \\\n-\tcore/internal/array/duplication.d core/internal/array/equality.d \\\n-\tcore/internal/array/operations.d core/internal/array/utils.d \\\n-\tcore/internal/atomic.d core/internal/attributes.d \\\n-\tcore/internal/container/array.d core/internal/container/common.d \\\n-\tcore/internal/container/hashtab.d core/internal/container/treap.d \\\n-\tcore/internal/convert.d core/internal/dassert.d \\\n-\tcore/internal/destruction.d core/internal/entrypoint.d \\\n-\tcore/internal/gc/bits.d core/internal/gc/impl/conservative/gc.d \\\n+\tcore/internal/array/appending.d core/internal/array/arrayassign.d \\\n+\tcore/internal/array/capacity.d core/internal/array/casting.d \\\n+\tcore/internal/array/comparison.d core/internal/array/concatenation.d \\\n+\tcore/internal/array/construction.d core/internal/array/duplication.d \\\n+\tcore/internal/array/equality.d core/internal/array/operations.d \\\n+\tcore/internal/array/utils.d core/internal/atomic.d \\\n+\tcore/internal/attributes.d core/internal/container/array.d \\\n+\tcore/internal/container/common.d core/internal/container/hashtab.d \\\n+\tcore/internal/container/treap.d core/internal/convert.d \\\n+\tcore/internal/dassert.d core/internal/destruction.d \\\n+\tcore/internal/entrypoint.d core/internal/gc/bits.d \\\n+\tcore/internal/gc/impl/conservative/gc.d \\\n \tcore/internal/gc/impl/manual/gc.d core/internal/gc/impl/proto/gc.d \\\n \tcore/internal/gc/os.d core/internal/gc/pooltable.d \\\n \tcore/internal/gc/proxy.d core/internal/hash.d core/internal/lifetime.d \\"}, {"sha": "57660eeed1a4e2e2bae9fbbf0356d4a34ea7f00c", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -192,6 +192,7 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/demangle.lo core/exception.lo core/gc/config.lo \\\n \tcore/gc/gcinterface.lo core/gc/registry.lo core/int128.lo \\\n \tcore/internal/abort.lo core/internal/array/appending.lo \\\n+\tcore/internal/array/arrayassign.lo \\\n \tcore/internal/array/capacity.lo core/internal/array/casting.lo \\\n \tcore/internal/array/comparison.lo \\\n \tcore/internal/array/concatenation.lo \\\n@@ -839,17 +840,18 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/builtins.d core/checkedint.d core/cpuid.d core/demangle.d \\\n \tcore/exception.d core/gc/config.d core/gc/gcinterface.d \\\n \tcore/gc/registry.d core/int128.d core/internal/abort.d \\\n-\tcore/internal/array/appending.d core/internal/array/capacity.d \\\n-\tcore/internal/array/casting.d core/internal/array/comparison.d \\\n-\tcore/internal/array/concatenation.d core/internal/array/construction.d \\\n-\tcore/internal/array/duplication.d core/internal/array/equality.d \\\n-\tcore/internal/array/operations.d core/internal/array/utils.d \\\n-\tcore/internal/atomic.d core/internal/attributes.d \\\n-\tcore/internal/container/array.d core/internal/container/common.d \\\n-\tcore/internal/container/hashtab.d core/internal/container/treap.d \\\n-\tcore/internal/convert.d core/internal/dassert.d \\\n-\tcore/internal/destruction.d core/internal/entrypoint.d \\\n-\tcore/internal/gc/bits.d core/internal/gc/impl/conservative/gc.d \\\n+\tcore/internal/array/appending.d core/internal/array/arrayassign.d \\\n+\tcore/internal/array/capacity.d core/internal/array/casting.d \\\n+\tcore/internal/array/comparison.d core/internal/array/concatenation.d \\\n+\tcore/internal/array/construction.d core/internal/array/duplication.d \\\n+\tcore/internal/array/equality.d core/internal/array/operations.d \\\n+\tcore/internal/array/utils.d core/internal/atomic.d \\\n+\tcore/internal/attributes.d core/internal/container/array.d \\\n+\tcore/internal/container/common.d core/internal/container/hashtab.d \\\n+\tcore/internal/container/treap.d core/internal/convert.d \\\n+\tcore/internal/dassert.d core/internal/destruction.d \\\n+\tcore/internal/entrypoint.d core/internal/gc/bits.d \\\n+\tcore/internal/gc/impl/conservative/gc.d \\\n \tcore/internal/gc/impl/manual/gc.d core/internal/gc/impl/proto/gc.d \\\n \tcore/internal/gc/os.d core/internal/gc/pooltable.d \\\n \tcore/internal/gc/proxy.d core/internal/hash.d core/internal/lifetime.d \\\n@@ -1201,6 +1203,8 @@ core/internal/array/$(am__dirstamp):\n \t@$(MKDIR_P) core/internal/array\n \t@: > core/internal/array/$(am__dirstamp)\n core/internal/array/appending.lo: core/internal/array/$(am__dirstamp)\n+core/internal/array/arrayassign.lo:  \\\n+\tcore/internal/array/$(am__dirstamp)\n core/internal/array/capacity.lo: core/internal/array/$(am__dirstamp)\n core/internal/array/casting.lo: core/internal/array/$(am__dirstamp)\n core/internal/array/comparison.lo:  \\"}, {"sha": "ca87f902909e7eaca98d92a09792891491dd9ad7", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2328,7 +2328,7 @@ char[] mangle(T)(return scope const(char)[] fqn, return scope char[] dst = null)\n \n         @property bool empty() const { return !s.length; }\n \n-        @property const(char)[] front() const return\n+        @property const(char)[] front() const return scope\n         {\n             immutable i = indexOfDot();\n             return i == -1 ? s[0 .. $] : s[0 .. i];"}, {"sha": "a05a24cd19f49cdd86b500e9adcf945c8eb11bc9", "filename": "libphobos/libdruntime/core/exception.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fexception.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -14,7 +14,7 @@ void __switch_errorT()(string file = __FILE__, size_t line = __LINE__) @trusted\n {\n     // Consider making this a compile time check.\n     version (D_Exceptions)\n-        throw staticError!SwitchError(file, line, null);\n+        throw staticError!SwitchError(\"No appropriate switch clause found\", file, line, null);\n     else\n         assert(0, \"No appropriate switch clause found\");\n }\n@@ -446,24 +446,24 @@ class ForkError : Error\n  */\n class SwitchError : Error\n {\n-    @safe pure nothrow @nogc this( string file = __FILE__, size_t line = __LINE__, Throwable next = null )\n+    @safe pure nothrow @nogc this( string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null )\n     {\n-        super( \"No appropriate switch clause found\", file, line, next );\n+        super( msg, file, line, next );\n     }\n }\n \n unittest\n {\n     {\n-        auto se = new SwitchError();\n+        auto se = new SwitchError(\"No appropriate switch clause found\");\n         assert(se.file == __FILE__);\n         assert(se.line == __LINE__ - 2);\n         assert(se.next is null);\n         assert(se.msg == \"No appropriate switch clause found\");\n     }\n \n     {\n-        auto se = new SwitchError(\"hello\", 42, new Exception(\"It's an Exception!\"));\n+        auto se = new SwitchError(\"No appropriate switch clause found\", \"hello\", 42, new Exception(\"It's an Exception!\"));\n         assert(se.file == \"hello\");\n         assert(se.line == 42);\n         assert(se.next !is null);"}, {"sha": "6132e68db1a965c4bb80c60943587c0f3224f67c", "filename": "libphobos/libdruntime/core/internal/array/arrayassign.d", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,304 @@\n+module core.internal.array.arrayassign;\n+\n+// Force `enforceRawArraysConformable` to remain `pure` `@nogc`\n+private void enforceRawArraysConformable(const char[] action, const size_t elementSize,\n+    const void[] a1, const void[] a2, const bool allowOverlap) @trusted @nogc pure nothrow\n+{\n+    import core.internal.util.array : enforceRawArraysConformable;\n+\n+    alias Type = void function(const char[] action, const size_t elementSize,\n+        const void[] a1, const void[] a2, in bool allowOverlap = false) @nogc pure nothrow;\n+    (cast(Type)&enforceRawArraysConformable)(action, elementSize, a1, a2, allowOverlap);\n+}\n+\n+private template CopyElem(string CopyAction)\n+{\n+    const char[] CopyElem = \"{\\n\" ~ q{\n+            memcpy(&tmp, cast(void*) &dst, elemSize);\n+            } ~ CopyAction ~ q{\n+            auto elem = cast(Unqual!T*) &tmp;\n+            destroy(*elem);\n+        } ~ \"}\\n\";\n+}\n+\n+private template CopyArray(bool CanOverlap, string CopyAction)\n+{\n+    const char[] CopyArray = CanOverlap ? q{\n+        if (vFrom.ptr < vTo.ptr && vTo.ptr < vFrom.ptr + elemSize * vFrom.length)\n+            foreach_reverse (i, ref dst; to)\n+            } ~ CopyElem!(CopyAction) ~ q{\n+        else\n+            foreach (i, ref dst; to)\n+            } ~ CopyElem!(CopyAction)\n+        : q{\n+            foreach (i, ref dst; to)\n+            } ~ CopyElem!(CopyAction);\n+}\n+\n+private template ArrayAssign(string CopyLogic, string AllowOverLap)\n+{\n+    const char[] ArrayAssign = q{\n+        import core.internal.traits : hasElaborateCopyConstructor, Unqual;\n+        import core.lifetime : copyEmplace;\n+        import core.stdc.string : memcpy;\n+\n+        void[] vFrom = (cast(void*) from.ptr)[0 .. from.length];\n+        void[] vTo = (cast(void*) to.ptr)[0 .. to.length];\n+        enum elemSize = T.sizeof;\n+\n+        enforceRawArraysConformable(\"copy\", elemSize, vFrom, vTo, } ~ AllowOverLap ~ q{);\n+\n+        void[elemSize] tmp = void;\n+\n+        } ~ CopyLogic ~ q{\n+\n+        return to;\n+    };\n+}\n+\n+/**\n+ * Does array assignment (not construction) from another array of the same\n+ * element type. Handles overlapping copies. Assumes the right hand side is an\n+ * lvalue,\n+ *\n+ * Used for static array assignment with non-POD element types:\n+ * ---\n+ * struct S\n+ * {\n+ *     ~this() {} // destructor, so not Plain Old Data\n+ * }\n+ *\n+ * void main()\n+ * {\n+ *   S[3] arr;\n+ *   S[3] lvalue;\n+ *\n+ *   arr = lvalue;\n+ *   // Generates:\n+ *   // _d_arrayassign_l(arr[], lvalue[]), arr;\n+ * }\n+ * ---\n+ *\n+ * Params:\n+ *     to = destination array\n+ *     from = source array\n+ * Returns:\n+ *     `to`\n+ */\n+Tarr _d_arrayassign_l(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n+{\n+    mixin(ArrayAssign!(q{\n+        static if (hasElaborateCopyConstructor!T)\n+            } ~ CopyArray!(true, \"copyEmplace(from[i], dst);\") ~ q{\n+        else\n+            } ~ CopyArray!(true, \"memcpy(cast(void*) &dst, cast(void*) &from[i], elemSize);\"),\n+        \"true\"));\n+}\n+\n+@safe unittest\n+{\n+    int counter;\n+    struct S\n+    {\n+        int val;\n+        this(int val) { this.val = val; }\n+        this(const scope ref S rhs)\n+        {\n+            val = rhs.val;\n+            counter++;\n+        }\n+    }\n+\n+    S[4] arr1;\n+    S[4] arr2 = [S(0), S(1), S(2), S(3)];\n+    _d_arrayassign_l(arr1[], arr2[]);\n+\n+    assert(counter == 4);\n+    assert(arr1 == arr2);\n+}\n+\n+// copy constructor\n+@safe unittest\n+{\n+    int counter;\n+    struct S\n+    {\n+        int val;\n+        this(int val) { this.val = val; }\n+        this(const scope ref S rhs)\n+        {\n+            val = rhs.val;\n+            counter++;\n+        }\n+    }\n+\n+    S[4] arr1;\n+    S[4] arr2 = [S(0), S(1), S(2), S(3)];\n+    _d_arrayassign_l(arr1[], arr2[]);\n+\n+    assert(counter == 4);\n+    assert(arr1 == arr2);\n+}\n+\n+@safe nothrow unittest\n+{\n+    // Test that throwing works\n+    int counter;\n+    bool didThrow;\n+\n+    struct Throw\n+    {\n+        int val;\n+        this(this)\n+        {\n+            counter++;\n+            if (counter == 2)\n+                throw new Exception(\"\");\n+        }\n+    }\n+    try\n+    {\n+        Throw[4] a;\n+        Throw[4] b = [Throw(1), Throw(2), Throw(3), Throw(4)];\n+        _d_arrayassign_l(a[], b[]);\n+    }\n+    catch (Exception)\n+    {\n+        didThrow = true;\n+    }\n+    assert(didThrow);\n+    assert(counter == 2);\n+\n+\n+    // Test that `nothrow` works\n+    didThrow = false;\n+    counter = 0;\n+    struct NoThrow\n+    {\n+        int val;\n+        this(this)\n+        {\n+            counter++;\n+        }\n+    }\n+    try\n+    {\n+        NoThrow[4] a;\n+        NoThrow[4] b = [NoThrow(1), NoThrow(2), NoThrow(3), NoThrow(4)];\n+        _d_arrayassign_l(a[], b[]);\n+    }\n+    catch (Exception)\n+    {\n+        didThrow = false;\n+    }\n+    assert(!didThrow);\n+    assert(counter == 4);\n+}\n+\n+/**\n+ * Does array assignment (not construction) from another array of the same\n+ * element type. Does not support overlapping copies. Assumes the right hand\n+ * side is an rvalue,\n+ *\n+ * Used for static array assignment with non-POD element types:\n+ * ---\n+ * struct S\n+ * {\n+ *     ~this() {} // destructor, so not Plain Old Data\n+ * }\n+ *\n+ * void main()\n+ * {\n+ *   S[3] arr;\n+ *   S[3] getRvalue() {return lvalue;}\n+ *\n+ *   arr = getRvalue();\n+ *   // Generates:\n+ *   // (__appendtmp = getRvalue), _d_arrayassign_l(arr[], __appendtmp), arr;\n+ * }\n+ * ---\n+ *\n+ * Params:\n+ *     to = destination array\n+ *     from = source array\n+ * Returns:\n+ *     `to`\n+ */\n+Tarr _d_arrayassign_r(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n+{\n+    mixin(ArrayAssign!(\n+        CopyArray!(false, \"memcpy(cast(void*) &dst, cast(void*) &from[i], elemSize);\"),\n+        \"false\"));\n+}\n+\n+@safe unittest\n+{\n+    int counter;\n+    struct S\n+    {\n+        int val;\n+        this(int val) { this.val = val; }\n+        this(const scope ref S rhs)\n+        {\n+            val = rhs.val;\n+            counter++;\n+        }\n+    }\n+\n+    S[4] arr1;\n+    S[4] arr2 = [S(0), S(1), S(2), S(3)];\n+    _d_arrayassign_r(arr1[], arr2[]);\n+\n+    assert(counter == 0);\n+    assert(arr1 == arr2);\n+}\n+\n+// copy constructor\n+@safe unittest\n+{\n+    int counter;\n+    struct S\n+    {\n+        int val;\n+        this(int val) { this.val = val; }\n+        this(const scope ref S rhs)\n+        {\n+            val = rhs.val;\n+            counter++;\n+        }\n+    }\n+\n+    S[4] arr1;\n+    S[4] arr2 = [S(0), S(1), S(2), S(3)];\n+    _d_arrayassign_r(arr1[], arr2[]);\n+\n+    assert(counter == 0);\n+    assert(arr1 == arr2);\n+}\n+\n+@safe nothrow unittest\n+{\n+    // Test that `nothrow` works\n+    bool didThrow = false;\n+    int counter = 0;\n+    struct NoThrow\n+    {\n+        int val;\n+        this(this)\n+        {\n+            counter++;\n+        }\n+    }\n+    try\n+    {\n+        NoThrow[4] a;\n+        NoThrow[4] b = [NoThrow(1), NoThrow(2), NoThrow(3), NoThrow(4)];\n+        _d_arrayassign_r(a[], b[]);\n+    }\n+    catch (Exception)\n+    {\n+        didThrow = false;\n+    }\n+    assert(!didThrow);\n+    assert(counter == 0);\n+}"}, {"sha": "c110d64069f2122f50b33aedf5888d2a13055752", "filename": "libphobos/libdruntime/core/internal/array/equality.d", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fequality.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fequality.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fequality.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -236,6 +236,33 @@ unittest\n     static assert(!useMemcmp!(int[], int[]));\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=21094\n+unittest\n+{\n+    static class C\n+    {\n+        int a;\n+    }\n+    static struct S\n+    {\n+        bool isValid;\n+        C fib;\n+\n+        inout(C) get() pure @safe @nogc nothrow inout\n+        {\n+            return isValid ? fib : C.init;\n+        }\n+        T opCast(T : C)() const { return null; }\n+\n+        alias get this;\n+    }\n+\n+    auto foo(S[] lhs, S[] rhs)\n+    {\n+        return lhs == rhs;\n+    }\n+}\n+\n // Returns a reference to an array element, eliding bounds check and\n // casting void to ubyte.\n pragma(inline, true)"}, {"sha": "fc5dc5d1684136eb415b0429bd3ce0c7d66ce96a", "filename": "libphobos/libdruntime/core/sys/posix/sys/socket.d", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -188,10 +188,40 @@ version (linux)\n \n     extern (D) inout(ubyte)*   CMSG_DATA( return scope inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }\n \n-    private inout(cmsghdr)* __cmsg_nxthdr(inout(msghdr)*, inout(cmsghdr)*) pure nothrow @nogc;\n-    extern (D)  inout(cmsghdr)* CMSG_NXTHDR(inout(msghdr)* msg, inout(cmsghdr)* cmsg) pure nothrow @nogc\n+    version (CRuntime_Musl)\n     {\n-        return __cmsg_nxthdr(msg, cmsg);\n+        extern (D)\n+        {\n+            private size_t __CMSG_LEN(inout(cmsghdr)* cmsg) pure nothrow @nogc\n+            {\n+                return (cmsg.cmsg_len + size_t.sizeof -1) & cast(size_t)(~(size_t.sizeof - 1));\n+            }\n+\n+            private inout(cmsghdr)* __CMSG_NEXT(inout(cmsghdr)* cmsg) pure nothrow @nogc\n+            {\n+                return cmsg + __CMSG_LEN(cmsg);\n+            }\n+\n+            private inout(msghdr)* __MHDR_END(inout(msghdr)* mhdr) pure nothrow @nogc\n+            {\n+                return cast(inout(msghdr)*)(mhdr.msg_control + mhdr.msg_controllen);\n+            }\n+\n+            inout(cmsghdr)* CMSG_NXTHDR(inout(msghdr)* msg, inout(cmsghdr)* cmsg) pure nothrow @nogc\n+            {\n+                return cmsg.cmsg_len < cmsghdr.sizeof ||\n+                    __CMSG_LEN(cmsg) + cmsghdr.sizeof >= __MHDR_END(msg) - cast(inout(msghdr)*)(cmsg)\n+                        ? cast(inout(cmsghdr)*) null : cast(inout(cmsghdr)*) __CMSG_NEXT(cmsg);\n+            }\n+        }\n+    }\n+    else\n+    {\n+        private inout(cmsghdr)* __cmsg_nxthdr(inout(msghdr)*, inout(cmsghdr)*) pure nothrow @nogc;\n+        extern (D)  inout(cmsghdr)* CMSG_NXTHDR(inout(msghdr)* msg, inout(cmsghdr)* cmsg) pure nothrow @nogc\n+        {\n+            return __cmsg_nxthdr(msg, cmsg);\n+        }\n     }\n \n     extern (D) inout(cmsghdr)* CMSG_FIRSTHDR( inout(msghdr)* mhdr ) pure nothrow @nogc"}, {"sha": "d842499b8db34f85d3732bb486a043cf5310996b", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 66, "deletions": 25, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -6,6 +6,7 @@\n  * $(TR $(TD Arrays) $(TD\n  *     $(MYREF assumeSafeAppend)\n  *     $(MYREF capacity)\n+ *     $(A #.dup.2, $(TT dup))\n  *     $(MYREF idup)\n  *     $(MYREF reserve)\n  * ))\n@@ -14,6 +15,7 @@\n  *     $(MYREF byKeyValue)\n  *     $(MYREF byValue)\n  *     $(MYREF clear)\n+ *     $(MYREF dup)\n  *     $(MYREF get)\n  *     $(MYREF keys)\n  *     $(MYREF rehash)\n@@ -23,15 +25,15 @@\n  * ))\n  * $(TR $(TD General) $(TD\n  *     $(MYREF destroy)\n- *     $(MYREF dup)\n  *     $(MYREF hashOf)\n- *     $(MYREF opEquals)\n+ *     $(MYREF imported)\n+ *     $(MYREF noreturn)\n  * ))\n- * $(TR $(TD Types) $(TD\n+ * $(TR $(TD Classes) $(TD\n  *     $(MYREF Error)\n  *     $(MYREF Exception)\n- *     $(MYREF noreturn)\n  *     $(MYREF Object)\n+ *     $(MYREF opEquals)\n  *     $(MYREF Throwable)\n  * ))\n  * $(TR $(TD Type info) $(TD\n@@ -61,7 +63,11 @@ alias size_t = typeof(int.sizeof);\n alias ptrdiff_t = typeof(cast(void*)0 - cast(void*)0);\n \n alias sizediff_t = ptrdiff_t; // For backwards compatibility only.\n-alias noreturn = typeof(*null);  /// bottom type\n+/**\n+ * Bottom type.\n+ * See $(DDSUBLINK spec/type, noreturn).\n+ */\n+alias noreturn = typeof(*null);\n \n alias hash_t = size_t; // For backwards compatibility only.\n alias equals_t = bool; // For backwards compatibility only.\n@@ -266,7 +272,9 @@ class Object\n     the typeinfo name string compare. This is because of dmd's dll implementation. However,\n     it can infer to @safe if your class' opEquals is.\n +/\n-bool opEquals(LHS, RHS)(LHS lhs, RHS rhs) if (is(LHS : const Object) && is(RHS : const Object))\n+bool opEquals(LHS, RHS)(LHS lhs, RHS rhs)\n+if ((is(LHS : const Object) || is(LHS : const shared Object)) &&\n+    (is(RHS : const Object) || is(RHS : const shared Object)))\n {\n     static if (__traits(compiles, lhs.opEquals(rhs)) && __traits(compiles, rhs.opEquals(lhs)))\n     {\n@@ -505,6 +513,16 @@ unittest\n     assert(obj1 != obj2);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23291\n+@system unittest\n+{\n+    static shared class C { bool opEquals(const(shared(C)) rhs) const shared  { return true;}}\n+    const(C) c = new C();\n+    const(C)[] a = [c];\n+    const(C)[] b = [c];\n+    assert(a[0] == b[0]);\n+}\n+\n private extern(C) void _d_setSameMutex(shared Object ownee, shared Object owner) nothrow;\n \n void setSameMutex(shared Object ownee, shared Object owner)\n@@ -3473,13 +3491,18 @@ ref V require(K, V)(ref V[K] aa, K key, lazy V value = V.init)\n private enum bool isSafeCopyable(T) = is(typeof(() @safe { union U { T x; } T *x; auto u = U(*x); }));\n \n /***********************************\n- * Looks up key; if it exists applies the update callable else evaluates the\n- * create callable and adds it to the associative array\n+ * Calls `create` if `key` doesn't exist in the associative array,\n+ * otherwise calls `update`.\n+ * `create` returns a corresponding value for `key`.\n+ * `update` accepts a key parameter. If it returns a value, the value is\n+ * set for `key`.\n  * Params:\n  *      aa =     The associative array.\n  *      key =    The key.\n- *      create = The callable to apply on create.\n- *      update = The callable to apply on update.\n+ *      create = The callable to create a value for `key`.\n+ *               Must return V.\n+ *      update = The callable to call if `key` exists.\n+ *               Takes a K argument, returns a V or void.\n  */\n void update(K, V, C, U)(ref V[K] aa, K key, scope C create, scope U update)\n if (is(typeof(create()) : V) && (is(typeof(update(aa[K.init])) : V) || is(typeof(update(aa[K.init])) == void)))\n@@ -3509,23 +3532,39 @@ if (is(typeof(create()) : V) && (is(typeof(update(aa[K.init])) : V) || is(typeof\n }\n \n ///\n-@system unittest\n+@safe unittest\n {\n-    auto aa = [\"k1\": 1];\n+    int[string] aa;\n \n-    aa.update(\"k1\", {\n-        return -1; // create (won't be executed)\n-    }, (ref int v) {\n-        v += 1; // update\n-    });\n-    assert(aa[\"k1\"] == 2);\n-\n-    aa.update(\"k2\", {\n-        return 0; // create\n-    }, (ref int v) {\n-        v = -1; // update (won't be executed)\n-    });\n-    assert(aa[\"k2\"] == 0);\n+    // create\n+    aa.update(\"key\",\n+        () => 1,\n+        (int) {} // not executed\n+        );\n+    assert(aa[\"key\"] == 1);\n+\n+    // update value by ref\n+    aa.update(\"key\",\n+        () => 0, // not executed\n+        (ref int v) {\n+            v += 1;\n+        });\n+    assert(aa[\"key\"] == 2);\n+\n+    // update from return value\n+    aa.update(\"key\",\n+        () => 0, // not executed\n+        (int v) => v * 2\n+        );\n+    assert(aa[\"key\"] == 4);\n+\n+    // 'update' without changing value\n+    aa.update(\"key\",\n+        () => 0, // not executed\n+        (int) {\n+            // do something else\n+        });\n+    assert(aa[\"key\"] == 4);\n }\n \n @safe unittest\n@@ -4576,6 +4615,8 @@ public import core.internal.array.casting: __ArrayCast;\n public import core.internal.array.concatenation : _d_arraycatnTXImpl;\n public import core.internal.array.construction : _d_arrayctor;\n public import core.internal.array.construction : _d_arraysetctor;\n+public import core.internal.array.arrayassign : _d_arrayassign_l;\n+public import core.internal.array.arrayassign : _d_arrayassign_r;\n public import core.internal.array.capacity: _d_arraysetlengthTImpl;\n \n public import core.internal.dassert: _d_assert_fail;"}, {"sha": "c9e2b15025f7f07f97d036629790ecae0020adb3", "filename": "libphobos/libdruntime/rt/arrayassign.d", "status": "modified", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Farrayassign.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -19,171 +19,6 @@ private\n     debug(PRINTF) import core.stdc.stdio;\n }\n \n-/*\n- * Superseded array assignment hook. Does not take into account destructors:\n- * https://issues.dlang.org/show_bug.cgi?id=13661\n- * Kept for backward binary compatibility. This function can be removed in the future.\n- */\n-extern (C) void[] _d_arrayassign(TypeInfo ti, void[] from, void[] to)\n-{\n-    debug(PRINTF) printf(\"_d_arrayassign(from = %p,%d, to = %p,%d) size = %d\\n\", from.ptr, from.length, to.ptr, to.length, ti.tsize);\n-\n-    immutable elementSize = ti.tsize;\n-\n-    // Need a temporary buffer tmp[] big enough to hold one element\n-    void[16] buf = void;\n-    void* ptmp = (elementSize > buf.sizeof) ? malloc(elementSize) : buf.ptr;\n-    scope (exit)\n-    {\n-        if (ptmp != buf.ptr)\n-            free(ptmp);\n-    }\n-    return _d_arrayassign_l(ti, from, to, ptmp);\n-}\n-\n-/**\n-Does array assignment (not construction) from another array of the same\n-element type.\n-\n-Handles overlapping copies.\n-\n-The `_d_arrayassign_l` variant assumes the right hand side is an lvalue,\n-while `_d_arrayassign_r` assumes it's an rvalue, which means it doesn't have to call copy constructors.\n-\n-Used for static array assignment with non-POD element types:\n----\n-struct S\n-{\n-    ~this() {} // destructor, so not Plain Old Data\n-}\n-\n-void main()\n-{\n-    S[3] arr;\n-    S[3] lvalue;\n-\n-    arr = lvalue;\n-    // Generates:\n-    // S _tmp;\n-    // _d_arrayassign_l(typeid(S), (cast(void*) lvalue.ptr)[0..lvalue.length], (cast(void*) arr.ptr)[0..arr.length], &_tmp);\n-\n-    S[3] getRvalue() {return lvalue;}\n-    arr = getRvalue();\n-    // Similar, but `_d_arrayassign_r`\n-}\n----\n-\n-Params:\n-    ti = `TypeInfo` of the array element type.\n-    dst = target memory. Its `.length` is equal to the element count, not byte length.\n-    src = source memory. Its `.length` is equal to the element count, not byte length.\n-    ptmp =  Temporary memory for element swapping, must have capacity of `ti.tsize` bytes.\n-Returns: `dst`\n-*/\n-extern (C) void[] _d_arrayassign_l(TypeInfo ti, void[] src, void[] dst, void* ptmp)\n-{\n-    debug(PRINTF) printf(\"_d_arrayassign_l(src = %p,%d, dst = %p,%d) size = %d\\n\", src.ptr, src.length, dst.ptr, dst.length, ti.tsize);\n-\n-    immutable elementSize = ti.tsize;\n-\n-    enforceRawArraysConformable(\"copy\", elementSize, src, dst, true);\n-\n-    if (src.ptr < dst.ptr && dst.ptr < src.ptr + elementSize * src.length)\n-    {\n-        // If dst is in the middle of src memory, use reverse order.\n-        for (auto i = dst.length; i--; )\n-        {\n-            void* pdst = dst.ptr + i * elementSize;\n-            void* psrc = src.ptr + i * elementSize;\n-            memcpy(ptmp, pdst, elementSize);\n-            memcpy(pdst, psrc, elementSize);\n-            ti.postblit(pdst);\n-            ti.destroy(ptmp);\n-        }\n-    }\n-    else\n-    {\n-        // Otherwise, use normal order.\n-        foreach (i; 0 .. dst.length)\n-        {\n-            void* pdst = dst.ptr + i * elementSize;\n-            void* psrc = src.ptr + i * elementSize;\n-            memcpy(ptmp, pdst, elementSize);\n-            memcpy(pdst, psrc, elementSize);\n-            ti.postblit(pdst);\n-            ti.destroy(ptmp);\n-        }\n-    }\n-    return dst;\n-}\n-\n-unittest    // Bugzilla 14024\n-{\n-    string op;\n-\n-    struct S\n-    {\n-        char x = 'x';\n-        this(this) { op ~= x-0x20; }    // upper case\n-        ~this()    { op ~= x; }         // lower case\n-    }\n-\n-    S[4] mem;\n-    ref S[2] slice(int a, int b) { return mem[a .. b][0 .. 2]; }\n-\n-    op = null;\n-    mem[0].x = 'a';\n-    mem[1].x = 'b';\n-    mem[2].x = 'x';\n-    mem[3].x = 'y';\n-    slice(0, 2) = slice(2, 4);  // [ab] = [xy]\n-    assert(op == \"XaYb\", op);\n-\n-    op = null;\n-    mem[0].x = 'x';\n-    mem[1].x = 'y';\n-    mem[2].x = 'a';\n-    mem[3].x = 'b';\n-    slice(2, 4) = slice(0, 2);  // [ab] = [xy]\n-    assert(op == \"XaYb\", op);\n-\n-    op = null;\n-    mem[0].x = 'a';\n-    mem[1].x = 'b';\n-    mem[2].x = 'c';\n-    slice(0, 2) = slice(1, 3);  // [ab] = [bc]\n-    assert(op == \"BaCb\", op);\n-\n-    op = null;\n-    mem[0].x = 'x';\n-    mem[1].x = 'y';\n-    mem[2].x = 'z';\n-    slice(1, 3) = slice(0, 2);  // [yz] = [xy]\n-    assert(op == \"YzXy\", op);\n-}\n-\n-/// ditto\n-extern (C) void[] _d_arrayassign_r(TypeInfo ti, void[] src, void[] dst, void* ptmp)\n-{\n-    debug(PRINTF) printf(\"_d_arrayassign_r(src = %p,%d, dst = %p,%d) size = %d\\n\", src.ptr, src.length, dst.ptr, dst.length, ti.tsize);\n-\n-    immutable elementSize = ti.tsize;\n-\n-    enforceRawArraysConformable(\"copy\", elementSize, src, dst, false);\n-\n-    // Always use normal order, because we can assume that\n-    // the rvalue src has no overlapping with dst.\n-    foreach (i; 0 .. dst.length)\n-    {\n-        void* pdst = dst.ptr + i * elementSize;\n-        void* psrc = src.ptr + i * elementSize;\n-        memcpy(ptmp, pdst, elementSize);\n-        memcpy(pdst, psrc, elementSize);\n-        ti.destroy(ptmp);\n-    }\n-    return dst;\n-}\n-\n /**\n Set all elements of an array to a single value.\n "}, {"sha": "c8a377143033379fb1250322f9118eb3a0878418", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,4 +1,4 @@\n-5748ca43fd5c3e31ce7a8511f542b67e5d5a3dc6\n+b578dfad94770574d7e522557a77276c35943daa\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "2413024e162486159a6762dc80de3a07850da95b", "filename": "libphobos/src/Makefile.am", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.am?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -127,19 +127,20 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/zlib.d std/algorithm/comparison.d \\\n \tstd/experimental/logger/core.d std/experimental/logger/filelogger.d \\\n \tstd/experimental/logger/multilogger.d \\\n \tstd/experimental/logger/nulllogger.d std/experimental/logger/package.d \\\n-\tstd/experimental/typecons.d std/file.d std/format/internal/floats.d \\\n-\tstd/format/internal/read.d std/format/internal/write.d \\\n-\tstd/format/package.d std/format/read.d std/format/spec.d \\\n-\tstd/format/write.d std/functional.d std/getopt.d std/int128.d \\\n-\tstd/internal/attributes.d std/internal/cstring.d \\\n+\tstd/file.d std/format/internal/floats.d std/format/internal/read.d \\\n+\tstd/format/internal/write.d std/format/package.d std/format/read.d \\\n+\tstd/format/spec.d std/format/write.d std/functional.d std/getopt.d \\\n+\tstd/int128.d std/internal/attributes.d std/internal/cstring.d \\\n \tstd/internal/math/biguintcore.d std/internal/math/biguintnoasm.d \\\n \tstd/internal/math/errorfunction.d std/internal/math/gammafunction.d \\\n \tstd/internal/memory.d std/internal/scopebuffer.d \\\n \tstd/internal/test/dummyrange.d std/internal/test/range.d \\\n \tstd/internal/test/uda.d std/internal/unicode_comp.d \\\n \tstd/internal/unicode_decomp.d std/internal/unicode_grapheme.d \\\n \tstd/internal/unicode_norm.d std/internal/unicode_tables.d \\\n-\tstd/internal/windows/advapi32.d std/json.d std/math/algebraic.d \\\n+\tstd/internal/windows/advapi32.d std/json.d std/logger/core.d \\\n+\tstd/logger/filelogger.d std/logger/multilogger.d \\\n+\tstd/logger/nulllogger.d std/logger/package.d std/math/algebraic.d \\\n \tstd/math/constants.d std/math/exponential.d std/math/hardware.d \\\n \tstd/math/operations.d std/math/package.d std/math/remainder.d \\\n \tstd/math/rounding.d std/math/traits.d std/math/trigonometry.d \\"}, {"sha": "562a428412f06fdea9741688f54e09df0e1fe36b", "filename": "libphobos/src/Makefile.in", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.in?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -218,7 +218,6 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/logger/multilogger.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/logger/nulllogger.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/logger/package.lo \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/typecons.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/file.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/internal/floats.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/internal/read.lo \\\n@@ -246,7 +245,11 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/unicode_norm.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/unicode_tables.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/windows/advapi32.lo \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/json.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/json.lo std/logger/core.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/logger/filelogger.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/logger/multilogger.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/logger/nulllogger.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/logger/package.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/math/algebraic.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/math/constants.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/math/exponential.lo \\\n@@ -589,19 +592,20 @@ libgphobos_la_LINK = $(LIBTOOL) --tag=D $(libgphobos_la_LIBTOOLFLAGS) \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/logger/core.d std/experimental/logger/filelogger.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/logger/multilogger.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/logger/nulllogger.d std/experimental/logger/package.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/typecons.d std/file.d std/format/internal/floats.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/internal/read.d std/format/internal/write.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/package.d std/format/read.d std/format/spec.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/write.d std/functional.d std/getopt.d std/int128.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/attributes.d std/internal/cstring.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/file.d std/format/internal/floats.d std/format/internal/read.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/internal/write.d std/format/package.d std/format/read.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/spec.d std/format/write.d std/functional.d std/getopt.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/int128.d std/internal/attributes.d std/internal/cstring.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/math/biguintcore.d std/internal/math/biguintnoasm.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/math/errorfunction.d std/internal/math/gammafunction.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/memory.d std/internal/scopebuffer.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/test/dummyrange.d std/internal/test/range.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/test/uda.d std/internal/unicode_comp.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/unicode_decomp.d std/internal/unicode_grapheme.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/unicode_norm.d std/internal/unicode_tables.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/windows/advapi32.d std/json.d std/math/algebraic.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/windows/advapi32.d std/json.d std/logger/core.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/logger/filelogger.d std/logger/multilogger.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/logger/nulllogger.d std/logger/package.d std/math/algebraic.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/math/constants.d std/math/exponential.d std/math/hardware.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/math/operations.d std/math/package.d std/math/remainder.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/math/rounding.d std/math/traits.d std/math/trigonometry.d \\\n@@ -830,7 +834,6 @@ std/experimental/logger/nulllogger.lo:  \\\n \tstd/experimental/logger/$(am__dirstamp)\n std/experimental/logger/package.lo:  \\\n \tstd/experimental/logger/$(am__dirstamp)\n-std/experimental/typecons.lo: std/experimental/$(am__dirstamp)\n std/file.lo: std/$(am__dirstamp)\n std/format/internal/$(am__dirstamp):\n \t@$(MKDIR_P) std/format/internal\n@@ -879,6 +882,14 @@ std/internal/windows/$(am__dirstamp):\n std/internal/windows/advapi32.lo:  \\\n \tstd/internal/windows/$(am__dirstamp)\n std/json.lo: std/$(am__dirstamp)\n+std/logger/$(am__dirstamp):\n+\t@$(MKDIR_P) std/logger\n+\t@: > std/logger/$(am__dirstamp)\n+std/logger/core.lo: std/logger/$(am__dirstamp)\n+std/logger/filelogger.lo: std/logger/$(am__dirstamp)\n+std/logger/multilogger.lo: std/logger/$(am__dirstamp)\n+std/logger/nulllogger.lo: std/logger/$(am__dirstamp)\n+std/logger/package.lo: std/logger/$(am__dirstamp)\n std/math/$(am__dirstamp):\n \t@$(MKDIR_P) std/math\n \t@: > std/math/$(am__dirstamp)\n@@ -994,6 +1005,8 @@ mostlyclean-compile:\n \t-rm -f std/internal/test/*.lo\n \t-rm -f std/internal/windows/*.$(OBJEXT)\n \t-rm -f std/internal/windows/*.lo\n+\t-rm -f std/logger/*.$(OBJEXT)\n+\t-rm -f std/logger/*.lo\n \t-rm -f std/math/*.$(OBJEXT)\n \t-rm -f std/math/*.lo\n \t-rm -f std/net/*.$(OBJEXT)\n@@ -1033,6 +1046,7 @@ clean-libtool:\n \t-rm -rf std/internal/math/.libs std/internal/math/_libs\n \t-rm -rf std/internal/test/.libs std/internal/test/_libs\n \t-rm -rf std/internal/windows/.libs std/internal/windows/_libs\n+\t-rm -rf std/logger/.libs std/logger/_libs\n \t-rm -rf std/math/.libs std/math/_libs\n \t-rm -rf std/net/.libs std/net/_libs\n \t-rm -rf std/range/.libs std/range/_libs\n@@ -1162,6 +1176,7 @@ distclean-generic:\n \t-rm -f std/internal/math/$(am__dirstamp)\n \t-rm -f std/internal/test/$(am__dirstamp)\n \t-rm -f std/internal/windows/$(am__dirstamp)\n+\t-rm -f std/logger/$(am__dirstamp)\n \t-rm -f std/math/$(am__dirstamp)\n \t-rm -f std/net/$(am__dirstamp)\n \t-rm -f std/range/$(am__dirstamp)"}, {"sha": "45c248e117866643294f6c9d4b16a691f7ec5059", "filename": "libphobos/src/index.dd", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Findex.dd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Findex.dd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Findex.dd?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -459,6 +459,19 @@ $(BOOKTABLE ,\n         $(TDNW $(MREF core,simd))\n         $(TD SIMD intrinsics)\n     )\n+    $(LEADINGROW Logging)\n+    $(TR\n+        $(TDNW\n+            $(MREF std,logger)$(BR)\n+            $(MREF std,logger,core)$(BR)\n+            $(MREF std,logger,filelogger)$(BR)\n+            $(MREF std,logger,multilogger)$(BR)\n+            $(MREF std,logger,nulllogger)$(BR)\n+        )\n+        $(TD\n+             Logging.\n+        )\n+    )\n \n $(COMMENT\n     $(LEADINGROW Undocumented modules (intentionally omitted).)\n@@ -509,18 +522,6 @@ $(COMMENT\n              Deprecated modules.\n         )\n     )\n-    $(TR\n-        $(TDNW\n-            $(MREF std,experimental,logger)$(BR)\n-            $(MREF std,experimental,logger,core)$(BR)\n-            $(MREF std,experimental,logger,filelogger)$(BR)\n-            $(MREF std,experimental,logger,multilogger)$(BR)\n-            $(MREF std,experimental,logger,nulllogger)$(BR)\n-        )\n-        $(TD\n-             Experimental modules.\n-        )\n-    )\n )\n )\n "}, {"sha": "3e828cee9bbb8d7b4b72422e6493591f7d0d52bd", "filename": "libphobos/src/std/algorithm/iteration.d", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1798,7 +1798,7 @@ if (isInputRange!R)\n     assert(equal(g3, [ tuple(1, 2u), tuple(2, 2u) ]));\n \n     interface I {}\n-    class C : I { override size_t toHash() const nothrow @safe { return 0; } }\n+    static class C : I { override size_t toHash() const nothrow @safe { return 0; } }\n     const C[] a4 = [new const C()];\n     auto g4 = a4.group!\"a is b\";\n     assert(g4.front[1] == 1);\n@@ -2255,25 +2255,26 @@ if (isForwardRange!Range)\n     import std.algorithm.comparison : equal;\n \n     size_t popCount = 0;\n-    class RefFwdRange\n+    static class RefFwdRange\n     {\n         int[]  impl;\n+        size_t* pcount;\n \n         @safe nothrow:\n \n-        this(int[] data) { impl = data; }\n+        this(int[] data, size_t* pcount) { impl = data; this.pcount = pcount; }\n         @property bool empty() { return impl.empty; }\n         @property auto ref front() { return impl.front; }\n         void popFront()\n         {\n             impl.popFront();\n-            popCount++;\n+            (*pcount)++;\n         }\n-        @property auto save() { return new RefFwdRange(impl); }\n+        @property auto save() { return new RefFwdRange(impl, pcount); }\n     }\n     static assert(isForwardRange!RefFwdRange);\n \n-    auto testdata = new RefFwdRange([1, 3, 5, 2, 4, 7, 6, 8, 9]);\n+    auto testdata = new RefFwdRange([1, 3, 5, 2, 4, 7, 6, 8, 9], &popCount);\n     auto groups = testdata.chunkBy!((a,b) => (a % 2) == (b % 2));\n     auto outerSave1 = groups.save;\n \n@@ -6058,7 +6059,7 @@ if (is(typeof(binaryFun!pred(r.front, s.front)) : bool)\n     import std.algorithm.comparison : equal;\n \n     // Test by-reference separator\n-    class RefSep {\n+    static class RefSep {\n     @safe:\n         string _impl;\n         this(string s) { _impl = s; }"}, {"sha": "870b1b4021991a0140cc81185eb56d4b1589f97f", "filename": "libphobos/src/std/algorithm/searching.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -13,7 +13,7 @@ $(T2 any,\n         `any!\"a > 0\"([1, 2, -3, -4])` returns `true` because at least one\n         element is positive)\n $(T2 balancedParens,\n-        `balancedParens(\"((1 + 1) / 2)\")` returns `true` because the\n+        `balancedParens(\"((1 + 1) / 2)\", '(', ')')` returns `true` because the\n         string has balanced parentheses.)\n $(T2 boyerMooreFinder,\n         `find(\"hello world\", boyerMooreFinder(\"or\"))` returns `\"orld\"`"}, {"sha": "f48602e4cd6977f3fe1bebab448e3fd37ade6838", "filename": "libphobos/src/std/array.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Farray.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2297,7 +2297,7 @@ if (isInputRange!RoR &&\n // https://issues.dlang.org/show_bug.cgi?id=10895\n @safe unittest\n {\n-    class A\n+    static class A\n     {\n         string name;\n         alias name this;\n@@ -4376,8 +4376,8 @@ unittest\n             return app[];\n     }\n \n-    class C {}\n-    struct S { const(C) c; }\n+    static class C {}\n+    static struct S { const(C) c; }\n     S[] s = [ S(new C) ];\n \n     auto t = fastCopy(s); // Does not compile"}, {"sha": "33d0eae7ceda2c0b64e9d45a2cc5da4763cc797a", "filename": "libphobos/src/std/bigint.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fbigint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fbigint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fbigint.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1541,7 +1541,7 @@ Returns:\n     number in upper case.\n \n */\n-string toHex(const(BigInt) x) @safe\n+string toHex(const(BigInt) x) pure @safe\n {\n     import std.array : appender;\n     auto outbuff = appender!string();"}, {"sha": "3b860fe476b5b9c79bcbecf9b2ed7f932bf4d702", "filename": "libphobos/src/std/complex.d", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcomplex.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -478,6 +478,20 @@ if (isFloatingPoint!T)\n         }\n         return this;\n     }\n+\n+    /** Returns a complex number instance that correponds in size and in ABI\n+        to the associated C compiler's `_Complex` type.\n+     */\n+    auto toNative()\n+    {\n+        import core.stdc.config : c_complex_float, c_complex_double, c_complex_real;\n+        static if (is(T == float))\n+            return c_complex_float(re, im);\n+        else static if (is(T == double))\n+            return c_complex_double(re, im);\n+        else\n+            return c_complex_real(re, im);\n+    }\n }\n \n @safe pure nothrow unittest\n@@ -1910,3 +1924,14 @@ Complex!T pow(T)(const T x, Complex!T n) @trusted pure nothrow @nogc\n          }\n     }}\n }\n+\n+@safe pure nothrow @nogc unittest\n+{\n+    import std.meta : AliasSeq;\n+    static foreach (T; AliasSeq!(float, double, real))\n+    {{\n+         auto c = Complex!T(123, 456);\n+         auto n = c.toNative();\n+         assert(c.re == n.re && c.im == n.im);\n+    }}\n+}"}, {"sha": "9bd8d27c0656b0a36e1697db32f47286dcc87eeb", "filename": "libphobos/src/std/container/rbtree.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2055,7 +2055,7 @@ if ( is(typeof(binaryFun!less((ElementType!Stuff).init, (ElementType!Stuff).init\n }\n \n //Combinations not in examples.\n-@safe pure unittest\n+@system pure unittest\n {\n     auto rbt1 = redBlackTree!(true, string)(\"hello\", \"hello\");\n     auto rbt2 = redBlackTree!((a, b){return a < b;}, double)(5.1, 2.3);"}, {"sha": "a30ae5808818dc6cec7fe965d9b781e8628bcc8d", "filename": "libphobos/src/std/experimental/logger/core.d", "status": "modified", "additions": 11, "deletions": 3047, "changes": 3058, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf"}, {"sha": "3205a253b937a4f0d7262adfee57034f4e4fbe55", "filename": "libphobos/src/std/experimental/logger/filelogger.d", "status": "modified", "additions": 11, "deletions": 270, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,272 +1,13 @@\n-// Written in the D programming language.\n /**\n-Source: $(PHOBOSSRC std/experimental/logger/filelogger.d)\n-*/\n+ * This module is now deprecated, use $(MREF std, logger, filelogger)\n+ * instead.\n+ *\n+ * Copyright: Copyright The D Language Foundation 2005 - 2015.\n+ * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n+ * Authors:\n+ * Source:    $(PHOBOSSRC std/experimental/logger/filelogger.d)\n+ *\n+ * $(SCRIPT inhibitQuickIndex = 1;)\n+ */\n module std.experimental.logger.filelogger;\n-\n-import std.experimental.logger.core;\n-import std.stdio;\n-\n-import std.typecons : Flag;\n-\n-/** An option to create $(LREF FileLogger) directory if it is non-existent.\n-*/\n-alias CreateFolder = Flag!\"CreateFolder\";\n-\n-/** This `Logger` implementation writes log messages to the associated\n-file. The name of the file has to be passed on construction time. If the file\n-is already present new log messages will be append at its end.\n-*/\n-class FileLogger : Logger\n-{\n-    import std.concurrency : Tid;\n-    import std.datetime.systime : SysTime;\n-    import std.format.write : formattedWrite;\n-\n-    /** A constructor for the `FileLogger` Logger.\n-\n-    Params:\n-      fn = The filename of the output file of the `FileLogger`. If that\n-      file can not be opened for writting an exception will be thrown.\n-      lv = The `LogLevel` for the `FileLogger`. By default the\n-\n-    Example:\n-    -------------\n-    auto l1 = new FileLogger(\"logFile\");\n-    auto l2 = new FileLogger(\"logFile\", LogLevel.fatal);\n-    auto l3 = new FileLogger(\"logFile\", LogLevel.fatal, CreateFolder.yes);\n-    -------------\n-    */\n-    this(const string fn, const LogLevel lv = LogLevel.all) @safe\n-    {\n-         this(fn, lv, CreateFolder.yes);\n-    }\n-\n-    /** A constructor for the `FileLogger` Logger that takes a reference to\n-    a `File`.\n-\n-    The `File` passed must be open for all the log call to the\n-    `FileLogger`. If the `File` gets closed, using the `FileLogger`\n-    for logging will result in undefined behaviour.\n-\n-    Params:\n-      fn = The file used for logging.\n-      lv = The `LogLevel` for the `FileLogger`. By default the\n-      `LogLevel` for `FileLogger` is `LogLevel.all`.\n-      createFileNameFolder = if yes and fn contains a folder name, this\n-      folder will be created.\n-\n-    Example:\n-    -------------\n-    auto file = File(\"logFile.log\", \"w\");\n-    auto l1 = new FileLogger(file);\n-    auto l2 = new FileLogger(file, LogLevel.fatal);\n-    -------------\n-    */\n-    this(const string fn, const LogLevel lv, CreateFolder createFileNameFolder) @safe\n-    {\n-        import std.file : exists, mkdirRecurse;\n-        import std.path : dirName;\n-        import std.conv : text;\n-\n-        super(lv);\n-        this.filename = fn;\n-\n-        if (createFileNameFolder)\n-        {\n-            auto d = dirName(this.filename);\n-            mkdirRecurse(d);\n-            assert(exists(d), text(\"The folder the FileLogger should have\",\n-                                   \" created in '\", d,\"' could not be created.\"));\n-        }\n-\n-        this.file_.open(this.filename, \"a\");\n-    }\n-\n-    /** A constructor for the `FileLogger` Logger that takes a reference to\n-    a `File`.\n-\n-    The `File` passed must be open for all the log call to the\n-    `FileLogger`. If the `File` gets closed, using the `FileLogger`\n-    for logging will result in undefined behaviour.\n-\n-    Params:\n-      file = The file used for logging.\n-      lv = The `LogLevel` for the `FileLogger`. By default the\n-      `LogLevel` for `FileLogger` is `LogLevel.all`.\n-\n-    Example:\n-    -------------\n-    auto file = File(\"logFile.log\", \"w\");\n-    auto l1 = new FileLogger(file);\n-    auto l2 = new FileLogger(file, LogLevel.fatal);\n-    -------------\n-    */\n-    this(File file, const LogLevel lv = LogLevel.all) @safe\n-    {\n-        super(lv);\n-        this.file_ = file;\n-    }\n-\n-    /** If the `FileLogger` is managing the `File` it logs to, this\n-    method will return a reference to this File.\n-    */\n-    @property File file() @safe\n-    {\n-        return this.file_;\n-    }\n-\n-    /* This method overrides the base class method in order to log to a file\n-    without requiring heap allocated memory. Additionally, the `FileLogger`\n-    local mutex is logged to serialize the log calls.\n-    */\n-    override protected void beginLogMsg(string file, int line, string funcName,\n-        string prettyFuncName, string moduleName, LogLevel logLevel,\n-        Tid threadId, SysTime timestamp, Logger logger)\n-        @safe\n-    {\n-        import std.string : lastIndexOf;\n-        ptrdiff_t fnIdx = file.lastIndexOf('/') + 1;\n-        ptrdiff_t funIdx = funcName.lastIndexOf('.') + 1;\n-\n-        auto lt = this.file_.lockingTextWriter();\n-        systimeToISOString(lt, timestamp);\n-        import std.conv : to;\n-        formattedWrite(lt, \" [%s] %s:%u:%s \", logLevel.to!string,\n-                file[fnIdx .. $], line, funcName[funIdx .. $]);\n-    }\n-\n-    /* This methods overrides the base class method and writes the parts of\n-    the log call directly to the file.\n-    */\n-    override protected void logMsgPart(scope const(char)[] msg)\n-    {\n-        formattedWrite(this.file_.lockingTextWriter(), \"%s\", msg);\n-    }\n-\n-    /* This methods overrides the base class method and finalizes the active\n-    log call. This requires flushing the `File` and releasing the\n-    `FileLogger` local mutex.\n-    */\n-    override protected void finishLogMsg()\n-    {\n-        this.file_.lockingTextWriter().put(\"\\n\");\n-        this.file_.flush();\n-    }\n-\n-    /* This methods overrides the base class method and delegates the\n-    `LogEntry` data to the actual implementation.\n-    */\n-    override protected void writeLogMsg(ref LogEntry payload)\n-    {\n-        this.beginLogMsg(payload.file, payload.line, payload.funcName,\n-            payload.prettyFuncName, payload.moduleName, payload.logLevel,\n-            payload.threadId, payload.timestamp, payload.logger);\n-        this.logMsgPart(payload.msg);\n-        this.finishLogMsg();\n-    }\n-\n-    /** If the `FileLogger` was constructed with a filename, this method\n-    returns this filename. Otherwise an empty `string` is returned.\n-    */\n-    string getFilename()\n-    {\n-        return this.filename;\n-    }\n-\n-    /** The `File` log messages are written to. */\n-    protected File file_;\n-\n-    /** The filename of the `File` log messages are written to. */\n-    protected string filename;\n-}\n-\n-@system unittest\n-{\n-    import std.array : empty;\n-    import std.file : deleteme, remove;\n-    import std.string : indexOf;\n-\n-    string filename = deleteme ~ __FUNCTION__ ~ \".tempLogFile\";\n-    auto l = new FileLogger(filename);\n-\n-    scope(exit)\n-    {\n-        remove(filename);\n-    }\n-\n-    string notWritten = \"this should not be written to file\";\n-    string written = \"this should be written to file\";\n-\n-    l.logLevel = LogLevel.critical;\n-    l.log(LogLevel.warning, notWritten);\n-    l.log(LogLevel.critical, written);\n-    destroy(l);\n-\n-    auto file = File(filename, \"r\");\n-    string readLine = file.readln();\n-    assert(readLine.indexOf(written) != -1, readLine);\n-    readLine = file.readln();\n-    assert(readLine.indexOf(notWritten) == -1, readLine);\n-}\n-\n-@safe unittest\n-{\n-    import std.file : rmdirRecurse, exists, deleteme;\n-    import std.path : dirName;\n-\n-    const string tmpFolder = dirName(deleteme);\n-    const string filepath = tmpFolder ~ \"/bug15771/minas/oops/\";\n-    const string filename = filepath ~ \"output.txt\";\n-    assert(!exists(filepath));\n-\n-    auto f = new FileLogger(filename, LogLevel.all, CreateFolder.yes);\n-    scope(exit) () @trusted { rmdirRecurse(tmpFolder ~ \"/bug15771\"); }();\n-\n-    f.log(\"Hello World!\");\n-    assert(exists(filepath));\n-    f.file.close();\n-}\n-\n-@system unittest\n-{\n-    import std.array : empty;\n-    import std.file : deleteme, remove;\n-    import std.string : indexOf;\n-\n-    string filename = deleteme ~ __FUNCTION__ ~ \".tempLogFile\";\n-    auto file = File(filename, \"w\");\n-    auto l = new FileLogger(file);\n-\n-    scope(exit)\n-    {\n-        remove(filename);\n-    }\n-\n-    string notWritten = \"this should not be written to file\";\n-    string written = \"this should be written to file\";\n-\n-    l.logLevel = LogLevel.critical;\n-    l.log(LogLevel.warning, notWritten);\n-    l.log(LogLevel.critical, written);\n-    file.close();\n-\n-    file = File(filename, \"r\");\n-    string readLine = file.readln();\n-    assert(readLine.indexOf(written) != -1, readLine);\n-    readLine = file.readln();\n-    assert(readLine.indexOf(notWritten) == -1, readLine);\n-    file.close();\n-}\n-\n-@system unittest\n-{\n-    auto dl = cast(FileLogger) sharedLog;\n-    assert(dl !is null);\n-    assert(dl.logLevel == LogLevel.info);\n-    assert(globalLogLevel == LogLevel.all);\n-\n-    auto tl = cast(StdForwardLogger) stdThreadLocalLog;\n-    assert(tl !is null);\n-    stdThreadLocalLog.logLevel = LogLevel.all;\n-}\n+public import std.logger.filelogger;"}, {"sha": "ae00b251d9b48e9a28c1e7e7afb585b304f28cfe", "filename": "libphobos/src/std/experimental/logger/multilogger.d", "status": "modified", "additions": 11, "deletions": 198, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,200 +1,13 @@\n-// Written in the D programming language.\n /**\n-Source: $(PHOBOSSRC std/experimental/logger/multilogger.d)\n-*/\n+ * This module is now deprecated, use $(MREF std, logger, multilogger)\n+ * instead.\n+ *\n+ * Copyright: Copyright The D Language Foundation 2005 - 2015.\n+ * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n+ * Authors:\n+ * Source:    $(PHOBOSSRC std/experimental/logger/multilogger.d)\n+ *\n+ * $(SCRIPT inhibitQuickIndex = 1;)\n+ */\n module std.experimental.logger.multilogger;\n-\n-import std.experimental.logger.core;\n-import std.experimental.logger.filelogger;\n-\n-/** This Element is stored inside the `MultiLogger` and associates a\n-`Logger` to a `string`.\n-*/\n-struct MultiLoggerEntry\n-{\n-    string name; /// The name if the `Logger`\n-    Logger logger; /// The stored `Logger`\n-}\n-\n-/** MultiLogger logs to multiple `Logger`. The `Logger`s are stored in an\n-`Logger[]` in their order of insertion.\n-\n-Every data logged to this `MultiLogger` will be distributed to all the $(D\n-Logger)s inserted into it. This `MultiLogger` implementation can\n-hold multiple `Logger`s with the same name. If the method `removeLogger`\n-is used to remove a `Logger` only the first occurrence with that name will\n-be removed.\n-*/\n-class MultiLogger : Logger\n-{\n-    /** A constructor for the `MultiLogger` Logger.\n-\n-    Params:\n-      lv = The `LogLevel` for the `MultiLogger`. By default the\n-      `LogLevel` for `MultiLogger` is `LogLevel.all`.\n-\n-    Example:\n-    -------------\n-    auto l1 = new MultiLogger(LogLevel.trace);\n-    -------------\n-    */\n-    this(const LogLevel lv = LogLevel.all) @safe\n-    {\n-        super(lv);\n-    }\n-\n-    /** This member holds all `Logger`s stored in the `MultiLogger`.\n-\n-    When inheriting from `MultiLogger` this member can be used to gain\n-    access to the stored `Logger`.\n-    */\n-    protected MultiLoggerEntry[] logger;\n-\n-    /** This method inserts a new Logger into the `MultiLogger`.\n-\n-    Params:\n-      name = The name of the `Logger` to insert.\n-      newLogger = The `Logger` to insert.\n-    */\n-    void insertLogger(string name, Logger newLogger) @safe\n-    {\n-        this.logger ~= MultiLoggerEntry(name, newLogger);\n-    }\n-\n-    /** This method removes a Logger from the `MultiLogger`.\n-\n-    Params:\n-      toRemove = The name of the `Logger` to remove. If the `Logger`\n-        is not found `null` will be returned. Only the first occurrence of\n-        a `Logger` with the given name will be removed.\n-\n-    Returns: The removed `Logger`.\n-    */\n-    Logger removeLogger(in char[] toRemove) @safe\n-    {\n-        import std.algorithm.mutation : copy;\n-        import std.range.primitives : back, popBack;\n-        for (size_t i = 0; i < this.logger.length; ++i)\n-        {\n-            if (this.logger[i].name == toRemove)\n-            {\n-                Logger ret = this.logger[i].logger;\n-                this.logger[i] = this.logger.back;\n-                this.logger.popBack();\n-\n-                return ret;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /* The override to pass the payload to all children of the\n-    `MultiLoggerBase`.\n-    */\n-    override protected void writeLogMsg(ref LogEntry payload) @safe\n-    {\n-        foreach (it; this.logger)\n-        {\n-            /* We don't perform any checks here to avoid race conditions.\n-            Instead the child will check on its own if its log level matches\n-            and assume LogLevel.all for the globalLogLevel (since we already\n-            know the message passes this test).\n-            */\n-            it.logger.forwardMsg(payload);\n-        }\n-    }\n-}\n-\n-@safe unittest\n-{\n-    import std.exception : assertThrown;\n-    import std.experimental.logger.nulllogger;\n-    auto a = new MultiLogger;\n-    auto n0 = new NullLogger();\n-    auto n1 = new NullLogger();\n-    a.insertLogger(\"zero\", n0);\n-    a.insertLogger(\"one\", n1);\n-\n-    auto n0_1 = a.removeLogger(\"zero\");\n-    assert(n0_1 is n0);\n-    auto n = a.removeLogger(\"zero\");\n-    assert(n is null);\n-\n-    auto n1_1 = a.removeLogger(\"one\");\n-    assert(n1_1 is n1);\n-    n = a.removeLogger(\"one\");\n-    assert(n is null);\n-}\n-\n-@safe unittest\n-{\n-    auto a = new MultiLogger;\n-    auto n0 = new TestLogger;\n-    auto n1 = new TestLogger;\n-    a.insertLogger(\"zero\", n0);\n-    a.insertLogger(\"one\", n1);\n-\n-    a.log(\"Hello TestLogger\"); int line = __LINE__;\n-    assert(n0.msg == \"Hello TestLogger\");\n-    assert(n0.line == line);\n-    assert(n1.msg == \"Hello TestLogger\");\n-    assert(n1.line == line);\n-}\n-\n-// Issue #16\n-@system unittest\n-{\n-    import std.file : deleteme;\n-    import std.stdio : File;\n-    import std.string : indexOf;\n-    string logName = deleteme ~ __FUNCTION__ ~ \".log\";\n-    auto logFileOutput = File(logName, \"w\");\n-    scope(exit)\n-    {\n-        import std.file : remove;\n-        logFileOutput.close();\n-        remove(logName);\n-    }\n-    auto traceLog = new FileLogger(logFileOutput, LogLevel.all);\n-    auto infoLog  = new TestLogger(LogLevel.info);\n-\n-    auto root = new MultiLogger(LogLevel.all);\n-    root.insertLogger(\"fileLogger\", traceLog);\n-    root.insertLogger(\"stdoutLogger\", infoLog);\n-\n-    string tMsg = \"A trace message\";\n-    root.trace(tMsg); int line1 = __LINE__;\n-\n-    assert(infoLog.line != line1);\n-    assert(infoLog.msg != tMsg);\n-\n-    string iMsg = \"A info message\";\n-    root.info(iMsg); int line2 = __LINE__;\n-\n-    assert(infoLog.line == line2);\n-    assert(infoLog.msg == iMsg, infoLog.msg ~ \":\" ~ iMsg);\n-\n-    logFileOutput.close();\n-    logFileOutput = File(logName, \"r\");\n-    assert(logFileOutput.isOpen);\n-    assert(!logFileOutput.eof);\n-\n-    auto line = logFileOutput.readln();\n-    assert(line.indexOf(tMsg) != -1, line ~ \":\" ~ tMsg);\n-    assert(!logFileOutput.eof);\n-    line = logFileOutput.readln();\n-    assert(line.indexOf(iMsg) != -1, line ~ \":\" ~ tMsg);\n-}\n-\n-@system unittest\n-{\n-    auto dl = cast(FileLogger) sharedLog;\n-    assert(dl !is null);\n-    assert(dl.logLevel == LogLevel.info);\n-    assert(globalLogLevel == LogLevel.all);\n-\n-    auto tl = cast(StdForwardLogger) stdThreadLocalLog;\n-    assert(tl !is null);\n-    stdThreadLocalLog.logLevel = LogLevel.all;\n-}\n+public import std.logger.multilogger;"}, {"sha": "2c1f0ba9db52ca9ecf3c0fc39f635c072e926247", "filename": "libphobos/src/std/experimental/logger/nulllogger.d", "status": "modified", "additions": 11, "deletions": 39, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fnulllogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fnulllogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fnulllogger.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,41 +1,13 @@\n-// Written in the D programming language.\n /**\n-Source: $(PHOBOSSRC std/experimental/logger/nulllogger.d)\n-*/\n+ * This module is now deprecated, use $(MREF std, logger, nulllogger)\n+ * instead.\n+ *\n+ * Copyright: Copyright The D Language Foundation 2005 - 2015.\n+ * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n+ * Authors:\n+ * Source:    $(PHOBOSSRC std/experimental/logger/nulllogger.d)\n+ *\n+ * $(SCRIPT inhibitQuickIndex = 1;)\n+ */\n module std.experimental.logger.nulllogger;\n-\n-import std.experimental.logger.core;\n-\n-/** The `NullLogger` will not process any log messages.\n-\n-In case of a log message with `LogLevel.fatal` nothing will happen.\n-*/\n-class NullLogger : Logger\n-{\n-    /** The default constructor for the `NullLogger`.\n-\n-    Independent of the parameter this Logger will never log a message.\n-\n-    Params:\n-      lv = The `LogLevel` for the `NullLogger`. By default the `LogLevel`\n-      for `NullLogger` is `LogLevel.all`.\n-    */\n-    this(const LogLevel lv = LogLevel.all) @safe\n-    {\n-        super(lv);\n-        this.fatalHandler = delegate() {};\n-    }\n-\n-    override protected void writeLogMsg(ref LogEntry payload) @safe @nogc\n-    {\n-    }\n-}\n-\n-///\n-@safe unittest\n-{\n-    import std.experimental.logger.core : LogLevel;\n-    auto nl1 = new NullLogger(LogLevel.all);\n-    nl1.info(\"You will never read this.\");\n-    nl1.fatal(\"You will never read this, either and it will not throw\");\n-}\n+public import std.logger.nulllogger;"}, {"sha": "4d19ea9c03bc39adb59c1b92235793a7411c184d", "filename": "libphobos/src/std/experimental/logger/package.d", "status": "modified", "additions": 14, "deletions": 165, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fpackage.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1,168 +1,17 @@\n-// Written in the D programming language.\n /**\n-Implements logging facilities.\n-\n-Copyright: Copyright Robert \"burner\" Schadek 2013 --\n-License: <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n-Authors: $(HTTP www.svs.informatik.uni-oldenburg.de/60865.html, Robert burner Schadek)\n-\n-$(H3 Basic Logging)\n-\n-Message logging is a common approach to expose runtime information of a\n-program. Logging should be easy, but also flexible and powerful, therefore\n-`D` provides a standard interface for logging.\n-\n-The easiest way to create a log message is to write:\n--------------\n-import std.experimental.logger;\n-\n-void main() {\n-    log(\"Hello World\");\n-}\n--------------\n-This will print a message to the `stderr` device. The message will contain\n-the filename, the line number, the name of the surrounding function, the time\n-and the message.\n-\n-More complex log call can go along the lines like:\n--------------\n-log(\"Logging to the sharedLog with its default LogLevel\");\n-logf(LogLevel.info, 5 < 6, \"%s to the sharedLog with its LogLevel.info\", \"Logging\");\n-info(\"Logging to the sharedLog with its info LogLevel\");\n-warning(5 < 6, \"Logging to the sharedLog with its LogLevel.warning if 5 is less than 6\");\n-error(\"Logging to the sharedLog with its error LogLevel\");\n-errorf(\"Logging %s the sharedLog %s its error LogLevel\", \"to\", \"with\");\n-critical(\"Logging to the\",\" sharedLog with its error LogLevel\");\n-fatal(\"Logging to the sharedLog with its fatal LogLevel\");\n-\n-auto fLogger = new FileLogger(\"NameOfTheLogFile\");\n-fLogger.log(\"Logging to the fileLogger with its default LogLevel\");\n-fLogger.info(\"Logging to the fileLogger with its default LogLevel\");\n-fLogger.warning(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if 5 is less than 6\");\n-fLogger.warningf(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if %s is %s than 6\", 5, \"less\");\n-fLogger.critical(\"Logging to the fileLogger with its info LogLevel\");\n-fLogger.log(LogLevel.trace, 5 < 6, \"Logging to the fileLogger\",\" with its default LogLevel if 5 is less than 6\");\n-fLogger.fatal(\"Logging to the fileLogger with its warning LogLevel\");\n--------------\n-Additionally, this example shows how a new `FileLogger` is created.\n-Individual `Logger` and the global log functions share commonly named\n-functions to log data.\n-\n-The names of the functions are as follows:\n-$(UL\n-    $(LI `log`)\n-    $(LI `trace`)\n-    $(LI `info`)\n-    $(LI `warning`)\n-    $(LI `critical`)\n-    $(LI `fatal`)\n-)\n-The default `Logger` will by default log to `stderr` and has a default\n-`LogLevel` of `LogLevel.all`. The default Logger can be accessed by\n-using the property called `sharedLog`. This property is a reference to the\n-current default `Logger`. This reference can be used to assign a new\n-default `Logger`.\n--------------\n-sharedLog = new FileLogger(\"New_Default_Log_File.log\");\n--------------\n-\n-Additional `Logger` can be created by creating a new instance of the\n-required `Logger`.\n-\n-$(H3 Logging Fundamentals)\n-$(H4 LogLevel)\n-The `LogLevel` of a log call can be defined in two ways. The first is by\n-calling `log` and passing the `LogLevel` explicitly as the first argument.\n-The second way of setting the `LogLevel` of a\n-log call, is by calling either `trace`, `info`, `warning`,\n-`critical`, or `fatal`. The log call will then have the respective\n-`LogLevel`. If no `LogLevel` is defined the log call will use the\n-current `LogLevel` of the used `Logger`. If data is logged with\n-`LogLevel` `fatal` by default an `Error` will be thrown.\n-This behaviour can be modified by using the member `fatalHandler` to\n-assign a custom delegate to handle log call with `LogLevel` `fatal`.\n-\n-$(H4 Conditional Logging)\n-Conditional logging can be achieved be passing a `bool` as first\n-argument to a log function. If conditional logging is used the condition must\n-be `true` in order to have the log message logged.\n-\n-In order to combine an explicit `LogLevel` passing with conditional\n-logging, the `LogLevel` has to be passed as first argument followed by the\n-`bool`.\n-\n-$(H4 Filtering Log Messages)\n-Messages are logged if the `LogLevel` of the log message is greater than or\n-equal to the `LogLevel` of the used `Logger` and additionally if the\n-`LogLevel` of the log message is greater than or equal to the global `LogLevel`.\n-If a condition is passed into the log call, this condition must be true.\n-\n-The global `LogLevel` is accessible by using `globalLogLevel`.\n-To assign a `LogLevel` of a `Logger` use the `logLevel` property of\n-the logger.\n-\n-$(H4 Printf Style Logging)\n-If `printf`-style logging is needed add a $(B f) to the logging call, such as\n-$(D myLogger.infof(\"Hello %s\", \"world\");) or $(D fatalf(\"errno %d\", 1337)).\n-The additional $(B f) appended to the function name enables `printf`-style\n-logging for all combinations of explicit `LogLevel` and conditional\n-logging functions and methods.\n-\n-$(H4 Thread Local Redirection)\n-Calls to the free standing log functions are not directly forwarded to the\n-global `Logger` `sharedLog`. Actually, a thread local `Logger` of\n-type `StdForwardLogger` processes the log call and then, by default, forwards\n-the created `Logger.LogEntry` to the `sharedLog` `Logger`.\n-The thread local `Logger` is accessible by the `stdThreadLocalLog`\n-property. This property allows to assign user defined `Logger`. The default\n-`LogLevel` of the `stdThreadLocalLog` `Logger` is `LogLevel.all`\n-and it will therefore forward all messages to the `sharedLog` `Logger`.\n-The `LogLevel` of the `stdThreadLocalLog` can be used to filter log\n-calls before they reach the `sharedLog` `Logger`.\n-\n-$(H3 User Defined Logger)\n-To customize the `Logger` behavior, create a new `class` that inherits from\n-the abstract `Logger` `class`, and implements the `writeLogMsg`\n-method.\n--------------\n-class MyCustomLogger : Logger\n-{\n-    this(LogLevel lv) @safe\n-    {\n-        super(lv);\n-    }\n-\n-    override void writeLogMsg(ref LogEntry payload)\n-    {\n-        // log message in my custom way\n-    }\n-}\n-\n-auto logger = new MyCustomLogger(LogLevel.info);\n-logger.log(\"Awesome log message with LogLevel.info\");\n--------------\n-\n-To gain more precise control over the logging process, additionally to\n-overriding the `writeLogMsg` method the methods `beginLogMsg`,\n-`logMsgPart` and `finishLogMsg` can be overridden.\n-\n-$(H3 Provided Logger)\n-By default four `Logger` implementations are given. The `FileLogger`\n-logs data to files. It can also be used to log to `stdout` and `stderr`\n-as these devices are files as well. A `Logger` that logs to `stdout` can\n-therefore be created by $(D new FileLogger(stdout)).\n-The `MultiLogger` is basically an associative array of `string`s to\n-`Logger`. It propagates log calls to its stored `Logger`. The\n-`ArrayLogger` contains an array of `Logger` and also propagates log\n-calls to its stored `Logger`. The `NullLogger` does not do anything. It\n-will never log a message and will never throw on a log call with `LogLevel`\n-`error`.\n-\n-Source: $(PHOBOSSRC std/experimental/logger/package.d)\n-*/\n+ * This module is now deprecated, use $(MREF std, logger)\n+ * instead.\n+ *\n+ * Copyright: Copyright The D Language Foundation 2005 - 2015.\n+ * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n+ * Authors:\n+ * Source:    $(PHOBOSSRC std/experimental/logger/package.d)\n+ *\n+ * $(SCRIPT inhibitQuickIndex = 1;)\n+ */\n module std.experimental.logger;\n \n-public import std.experimental.logger.core;\n-public import std.experimental.logger.filelogger;\n-public import std.experimental.logger.multilogger;\n-public import std.experimental.logger.nulllogger;\n+public import std.logger.core;\n+public import std.logger.filelogger;\n+public import std.logger.multilogger;\n+public import std.logger.nulllogger;"}, {"sha": "46e21e77e7a4ed35a33dd6f6b763bc8ae1444b16", "filename": "libphobos/src/std/experimental/typecons.d", "status": "removed", "additions": 0, "deletions": 1083, "changes": 1083, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cace77f4fb8df18c01dfdf9040cc944eedef1147/libphobos%2Fsrc%2Fstd%2Fexperimental%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cace77f4fb8df18c01dfdf9040cc944eedef1147/libphobos%2Fsrc%2Fstd%2Fexperimental%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Ftypecons.d?ref=cace77f4fb8df18c01dfdf9040cc944eedef1147", "patch": "@@ -1,1083 +0,0 @@\n-// Written in the D programming language.\n-\n-/**\n-This module implements experimental additions/modifications to $(MREF std, typecons).\n-\n-Use this module to test out new functionality for $(REF wrap, std, typecons)\n-which allows for a struct to be wrapped against an interface; the\n-implementation in $(MREF std, typecons) only allows for classes to use the wrap\n-functionality.\n-\n-Source:    $(PHOBOSSRC std/experimental/typecons.d)\n-\n-Copyright: Copyright the respective authors, 2008-\n-License:   $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n-Authors:   $(HTTP erdani.org, Andrei Alexandrescu),\n-           $(HTTP bartoszmilewski.wordpress.com, Bartosz Milewski),\n-           Don Clugston,\n-           Shin Fujishiro,\n-           Kenji Hara\n- */\n-module std.experimental.typecons;\n-\n-import std.meta; // : AliasSeq, allSatisfy;\n-import std.traits;\n-\n-import std.typecons : Tuple, tuple, Bind, DerivedFunctionType, GetOverloadedMethods;\n-\n-private\n-{\n-    pragma(mangle, \"_d_toObject\")\n-    extern(C) pure nothrow Object typecons_d_toObject(void* p);\n-}\n-\n-/*\n- * Avoids opCast operator overloading.\n- */\n-private template dynamicCast(T)\n-if (is(T == class) || is(T == interface))\n-{\n-    @trusted\n-    T dynamicCast(S)(inout S source)\n-    if (is(S == class) || is(S == interface))\n-    {\n-        static if (is(Unqual!S : Unqual!T))\n-        {\n-            import std.traits : QualifierOf;\n-            alias Qual = QualifierOf!S; // SharedOf or MutableOf\n-            alias TmpT = Qual!(Unqual!T);\n-            inout(TmpT) tmp = source;   // bypass opCast by implicit conversion\n-            return *cast(T*)(&tmp);     // + variable pointer cast + dereference\n-        }\n-        else\n-        {\n-            return cast(T) typecons_d_toObject(*cast(void**)(&source));\n-        }\n-    }\n-}\n-\n-@system unittest\n-{\n-    class C { @disable void opCast(T)(); }\n-    auto c = new C;\n-    static assert(!__traits(compiles, cast(Object) c));\n-    auto o = dynamicCast!Object(c);\n-    assert(c is o);\n-\n-    interface I { @disable void opCast(T)(); Object instance(); }\n-    interface J { @disable void opCast(T)(); Object instance(); }\n-    class D : I, J { Object instance() { return this; } }\n-    I i = new D();\n-    static assert(!__traits(compiles, cast(J) i));\n-    J j = dynamicCast!J(i);\n-    assert(i.instance() is j.instance());\n-}\n-\n-/*\n- * Determines if the `Source` type satisfies all interface requirements of\n- * `Targets`.\n- */\n-private template implementsInterface(Source, Targets...)\n-if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))\n-{\n-    import std.meta : staticMap;\n-\n-    // strict upcast\n-    bool implementsInterface()()\n-    if (Targets.length == 1 && is(Source : Targets[0]))\n-    {\n-        return true;\n-    }\n-    // structural upcast\n-    template implementsInterface()\n-    if (!allSatisfy!(Bind!(isImplicitlyConvertible, Source), Targets))\n-    {\n-        auto implementsInterface()\n-        {\n-            return hasRequiredMethods!();\n-        }\n-\n-        // list of FuncInfo\n-        alias TargetMembers = UniqMembers!(ConcatInterfaceMembers!Targets);\n-        // list of function symbols\n-        alias SourceMembers = GetOverloadedMethods!Source;\n-\n-        // Check whether all of SourceMembers satisfy covariance target in\n-        // TargetMembers\n-        template hasRequiredMethods(size_t i = 0)\n-        {\n-            static if (i >= TargetMembers.length)\n-                enum hasRequiredMethods = true;\n-            else\n-            {\n-                enum foundFunc = findCovariantFunction!(TargetMembers[i], Source, SourceMembers);\n-\n-                version (StdUnittest) {}\n-                else debug\n-                {\n-                    static if (foundFunc == -1)\n-                        pragma(msg, \"Could not locate matching function for: \",\n-                               TargetMembers[i].stringof);\n-                }\n-\n-                enum hasRequiredMethods =\n-                    foundFunc != -1 &&\n-                    hasRequiredMethods!(i + 1);\n-            }\n-        }\n-    }\n-}\n-// ditto\n-private template implementsInterface(Source, Targets...)\n-if (Targets.length >= 1 && !allSatisfy!(isMutable, Targets))\n-{\n-    import std.meta : staticMap;\n-\n-    alias implementsInterface = .implementsInterface!(Source, staticMap!(Unqual, Targets));\n-}\n-\n-@safe unittest\n-{\n-    interface Foo {\n-        void foo();\n-    }\n-    interface Bar {\n-        void bar();\n-    }\n-    interface FooBar : Foo, Bar {\n-        void foobar();\n-    }\n-\n-    struct A {\n-        void foo() {}\n-    }\n-    struct B {\n-        void bar() {}\n-        void foobar() {}\n-    }\n-    class C {\n-        void foo() {}\n-        void bar() {}\n-    }\n-    struct D {\n-        void foo() {}\n-        void bar() {}\n-        void foobar() {}\n-    }\n-    // Implements interface\n-    static assert(implementsInterface!(A, Foo));\n-    static assert(implementsInterface!(A, const(Foo)));\n-    static assert(implementsInterface!(A, immutable(Foo)));\n-    // Doesn't implement interface\n-    static assert(!implementsInterface!(B, Foo));\n-    static assert(implementsInterface!(B, Bar));\n-    // Implements both interfaces\n-    static assert(implementsInterface!(C, Foo));\n-    static assert(implementsInterface!(C, Bar));\n-    static assert(implementsInterface!(C, Foo, Bar));\n-    static assert(implementsInterface!(C, Foo, const(Bar)));\n-    static assert(!implementsInterface!(A, Foo, Bar));\n-    static assert(!implementsInterface!(A, Foo, immutable(Bar)));\n-    // Implements inherited\n-    static assert(implementsInterface!(D, FooBar));\n-    static assert(!implementsInterface!(B, FooBar));\n-}\n-\n-private enum isInterface(ConceptType) = is(ConceptType == interface);\n-\n-///\n-template wrap(Targets...)\n-if (Targets.length >= 1 && allSatisfy!(isInterface, Targets))\n-{\n-    import std.meta : ApplyLeft, staticMap;\n-\n-    version (StdDdoc)\n-    {\n-        /**\n-         * Wrap src in an anonymous class implementing $(D_PARAM Targets).\n-         *\n-         * wrap creates an internal wrapper class which implements the\n-         * interfaces in `Targets` using the methods of `src`, then returns a\n-         * GC-allocated instance of it.\n-         *\n-         * $(D_PARAM Source) can be either a `class` or a `struct`, but it must\n-         * $(I structurally conform) with all the $(D_PARAM Targets)\n-         * interfaces; i.e. it must provide concrete methods with compatible\n-         * signatures of those in $(D_PARAM Targets).\n-         *\n-         * If $(D_PARAM Source) is a `struct` then wrapping/unwrapping will\n-         * create a copy; it is not possible to affect the original `struct`\n-         * through the wrapper.\n-         *\n-         * The returned object additionally supports $(LREF unwrap).\n-         *\n-         * Note:\n-         * If $(D_PARAM Targets) has only one entry and $(D_PARAM Source) is a\n-         * class which explicitly implements it, wrap simply returns src\n-         * upcasted to `Targets[0]`.\n-         *\n-         * Bugs:\n-         * wrap does not support interfaces which take their own type as either\n-         * a parameter type or return type in any of its methods.\n-         *\n-         * See_Also: $(LREF unwrap) for examples\n-         */\n-        auto wrap(Source)(inout Source src)\n-            if (implementsInterface!(Source, Targets));\n-    }\n-\n-    static if (!allSatisfy!(isMutable, Targets))\n-        alias wrap = .wrap!(staticMap!(Unqual, Targets));\n-    else\n-    {\n-        // strict upcast\n-        auto wrap(Source)(inout Source src)\n-        if (Targets.length == 1 && is(Source : Targets[0]))\n-        {\n-            alias T = Select!(is(Source == shared), shared Targets[0], Targets[0]);\n-            return dynamicCast!(inout T)(src);\n-        }\n-\n-        // structural upcast\n-        template wrap(Source)\n-        if (!allSatisfy!(ApplyLeft!(isImplicitlyConvertible, Source), Targets))\n-        {\n-            auto wrap(inout Source src)\n-            {\n-                static assert(implementsInterface!(Source, Targets),\n-                              \"Source \"~Source.stringof~\n-                              \" does not have structural conformance to \"~\n-                              Targets.stringof);\n-\n-                alias T = Select!(is(Source == shared), shared Impl, Impl);\n-                return new inout T(src);\n-            }\n-\n-            // list of FuncInfo\n-            alias TargetMembers = UniqMembers!(ConcatInterfaceMembers!(Targets));\n-            // list of function symbols\n-            alias SourceMembers = GetOverloadedMethods!Source;\n-\n-            static if (is(Source == class) || is(Source == interface))\n-                alias StructuralType = Object;\n-            else static if (is(Source == struct))\n-                alias StructuralType = Source;\n-\n-            // Check whether all of SourceMembers satisfy covariance target in TargetMembers\n-            // Internal wrapper class\n-            final class Impl : Structural!StructuralType, Targets\n-            {\n-            private:\n-                Source _wrap_source;\n-\n-                this(       inout Source s)        inout @safe pure nothrow { _wrap_source = s; }\n-                this(shared inout Source s) shared inout @safe pure nothrow { _wrap_source = s; }\n-\n-                static if (is(Source == class) || is(Source == interface))\n-                {\n-                    // BUG: making private should work with NVI.\n-                    protected inout(Object) _wrap_getSource() inout @safe\n-                    {\n-                        return dynamicCast!(inout Object)(_wrap_source);\n-                    }\n-                }\n-                else\n-                {\n-                    // BUG: making private should work with NVI.\n-                    protected inout(Source) _wrap_getSource() inout @safe\n-                    {\n-                        return _wrap_source;\n-                    }\n-                }\n-\n-                import std.conv : to;\n-                import core.lifetime : forward;\n-                template generateFun(size_t i)\n-                {\n-                    enum name = TargetMembers[i].name;\n-                    enum fa = functionAttributes!(TargetMembers[i].type);\n-                    static args(int num)()\n-                    {\n-                        string r;\n-                        bool first = true;\n-                        foreach (i; 0 .. num)\n-                        {\n-                            import std.conv : to;\n-                            r ~= (first ? \"\" : \", \") ~ \" a\" ~ (i+1).to!string;\n-                            first = false;\n-                        }\n-                        return r;\n-                    }\n-                    static if (fa & FunctionAttribute.property)\n-                    {\n-                        static if (Parameters!(TargetMembers[i].type).length == 0)\n-                            enum fbody = \"_wrap_source.\"~name;\n-                        else\n-                            enum fbody = \"_wrap_source.\"~name~\" = a1\";\n-                    }\n-                    else\n-                    {\n-                            enum fbody = \"_wrap_source.\"~name~\"(\"~args!(Parameters!(TargetMembers[i].type).length)~\")\";\n-                    }\n-                    enum generateFun =\n-                        \"override \"~wrapperSignature!(TargetMembers[i]) ~\n-                        \"{ return \"~fbody~\"; }\";\n-                }\n-\n-            public:\n-                static foreach (i; 0 .. TargetMembers.length)\n-                    mixin(generateFun!i);\n-            }\n-        }\n-    }\n-}\n-\n-// Build a signature that matches the provided function\n-// Each argument will be provided a name in the form a#\n-private template wrapperSignature(alias fun)\n-{\n-    enum name = fun.name;\n-    enum fa = functionAttributes!(fun.type);\n-    static @property stc()\n-    {\n-        string r;\n-        if (fa & FunctionAttribute.property)    r ~= \"@property \";\n-        if (fa & FunctionAttribute.ref_)        r ~= \"ref \";\n-        if (fa & FunctionAttribute.pure_)       r ~= \"pure \";\n-        if (fa & FunctionAttribute.nothrow_)    r ~= \"nothrow \";\n-        if (fa & FunctionAttribute.trusted)     r ~= \"@trusted \";\n-        if (fa & FunctionAttribute.safe)        r ~= \"@safe \";\n-        return r;\n-    }\n-    static @property mod()\n-    {\n-        alias type = AliasSeq!(fun.type)[0];\n-        string r;\n-        static if (is(type == immutable))       r ~= \" immutable\";\n-        else\n-        {\n-            static if (is(type == shared))      r ~= \" shared\";\n-            static if (is(type == const))       r ~= \" const\";\n-            else static if (is(type == inout))  r ~= \" inout\";\n-            //else  --> mutable\n-        }\n-        return r;\n-    }\n-    alias param = Parameters!(fun.type);\n-    static @property wrapperParameters()\n-    {\n-        string r;\n-        bool first = true;\n-        foreach (i, p; param)\n-        {\n-            import std.conv : to;\n-            r ~= (first ? \"\" : \", \") ~ p.stringof ~ \" a\" ~ (i+1).to!string;\n-            first = false;\n-        }\n-        return r;\n-    }\n-\n-    enum wrapperSignature =\n-        stc~ReturnType!(fun.type).stringof ~ \" \"\n-        ~ name~\"(\"~wrapperParameters~\")\"~mod;\n-}\n-\n-@safe unittest\n-{\n-    interface M\n-    {\n-        void f1();\n-        void f2(string[] args, int count);\n-        void f3(string[] args, int count) pure const;\n-    }\n-\n-    alias TargetMembers = UniqMembers!(ConcatInterfaceMembers!M);\n-    static assert(wrapperSignature!(TargetMembers[0]) == \"void f1()\"\n-                  , wrapperSignature!(TargetMembers[0]));\n-\n-    static assert(wrapperSignature!(TargetMembers[1]) == \"void f2(string[] a1, int a2)\"\n-                  , wrapperSignature!(TargetMembers[1]));\n-\n-    static assert(wrapperSignature!(TargetMembers[2]) == \"pure void f3(string[] a1, int a2) const\"\n-                  , wrapperSignature!(TargetMembers[2]));\n-}\n-\n-// Internal class to support dynamic cross-casting\n-private interface Structural(T)\n-{\n-    inout(T) _wrap_getSource() inout @safe pure nothrow;\n-}\n-\n-private string unwrapExceptionText(Source, Target)()\n-{\n-    return Target.stringof~ \" not wrapped into \"~ Source.stringof;\n-}\n-\n-version (StdDdoc)\n-{\n-    /**\n-     * Extract object previously wrapped by $(LREF wrap).\n-     *\n-     * Params:\n-     *     Target = type of wrapped object\n-     *     src = wrapper object returned by $(LREF wrap)\n-     *\n-     * Returns: the wrapped object, or null if src is not a wrapper created\n-     * by $(LREF wrap) and $(D_PARAM Target) is a class\n-     *\n-     * Throws: $(REF ConvException, std, conv) when attempting to extract a\n-     * struct which is not the wrapped type\n-     *\n-     * See_also: $(LREF wrap)\n-     */\n-    public inout(Target) unwrap(Target, Source)(inout Source src);\n-}\n-\n-///\n-@system unittest\n-{\n-    interface Quack\n-    {\n-        int quack();\n-        @property int height();\n-    }\n-    interface Flyer\n-    {\n-        @property int height();\n-    }\n-    class Duck : Quack\n-    {\n-        int quack() { return 1; }\n-        @property int height() { return 10; }\n-    }\n-    class Human\n-    {\n-        int quack() { return 2; }\n-        @property int height() { return 20; }\n-    }\n-    struct HumanStructure\n-    {\n-        int quack() { return 3; }\n-        @property int height() { return 30; }\n-    }\n-\n-    Duck d1 = new Duck();\n-    Human h1 = new Human();\n-    HumanStructure hs1;\n-\n-    interface Refreshable\n-    {\n-        int refresh();\n-    }\n-    // does not have structural conformance\n-    static assert(!__traits(compiles, d1.wrap!Refreshable));\n-    static assert(!__traits(compiles, h1.wrap!Refreshable));\n-    static assert(!__traits(compiles, hs1.wrap!Refreshable));\n-\n-    // strict upcast\n-    Quack qd = d1.wrap!Quack;\n-    assert(qd is d1);\n-    assert(qd.quack() == 1);    // calls Duck.quack\n-    // strict downcast\n-    Duck d2 = qd.unwrap!Duck;\n-    assert(d2 is d1);\n-\n-    // structural upcast\n-    Quack qh = h1.wrap!Quack;\n-    Quack qhs = hs1.wrap!Quack;\n-    assert(qh.quack() == 2);    // calls Human.quack\n-    assert(qhs.quack() == 3);    // calls HumanStructure.quack\n-    // structural downcast\n-    Human h2 = qh.unwrap!Human;\n-    HumanStructure hs2 = qhs.unwrap!HumanStructure;\n-    assert(h2 is h1);\n-    assert(hs2 is hs1);\n-\n-    // structural upcast (two steps)\n-    Quack qx = h1.wrap!Quack;   // Human -> Quack\n-    Quack qxs = hs1.wrap!Quack;   // HumanStructure -> Quack\n-    Flyer fx = qx.wrap!Flyer;   // Quack -> Flyer\n-    Flyer fxs = qxs.wrap!Flyer;   // Quack -> Flyer\n-    assert(fx.height == 20);    // calls Human.height\n-    assert(fxs.height == 30);    // calls HumanStructure.height\n-    // strucural downcast (two steps)\n-    Quack qy = fx.unwrap!Quack; // Flyer -> Quack\n-    Quack qys = fxs.unwrap!Quack; // Flyer -> Quack\n-    Human hy = qy.unwrap!Human; // Quack -> Human\n-    HumanStructure hys = qys.unwrap!HumanStructure; // Quack -> HumanStructure\n-    assert(hy is h1);\n-    assert(hys is hs1);\n-    // strucural downcast (one step)\n-    Human hz = fx.unwrap!Human; // Flyer -> Human\n-    HumanStructure hzs = fxs.unwrap!HumanStructure; // Flyer -> HumanStructure\n-    assert(hz is h1);\n-    assert(hzs is hs1);\n-}\n-\n-///\n-@system unittest\n-{\n-    import std.traits : functionAttributes, FunctionAttribute;\n-    interface A { int run(); }\n-    interface B { int stop(); @property int status(); }\n-    class X\n-    {\n-        int run() { return 1; }\n-        int stop() { return 2; }\n-        @property int status() { return 3; }\n-    }\n-\n-    auto x = new X();\n-    auto ab = x.wrap!(A, B);\n-    A a = ab;\n-    B b = ab;\n-    assert(a.run() == 1);\n-    assert(b.stop() == 2);\n-    assert(b.status == 3);\n-    static assert(functionAttributes!(typeof(ab).status) & FunctionAttribute.property);\n-}\n-\n-template unwrap(Target)\n-{\n-    static if (!isMutable!Target)\n-        alias unwrap = .unwrap!(Unqual!Target);\n-    else\n-    {\n-        // strict downcast\n-        auto unwrap(Source)(inout Source src)\n-        if (is(Target : Source))\n-        {\n-            alias T = Select!(is(Source == shared), shared Target, Target);\n-            return dynamicCast!(inout T)(src);\n-        }\n-\n-        // structural downcast for struct target\n-        auto unwrap(Source)(inout Source src)\n-        if (is(Target == struct))\n-        {\n-            alias T = Select!(is(Source == shared), shared Target, Target);\n-            auto upCastSource = dynamicCast!Object(src);   // remove qualifier\n-            do\n-            {\n-                if (auto a = dynamicCast!(Structural!Object)(upCastSource))\n-                {\n-                    upCastSource = a._wrap_getSource();\n-                }\n-                else if (auto a = dynamicCast!(Structural!T)(upCastSource))\n-                {\n-                    return a._wrap_getSource();\n-                }\n-                else\n-                {\n-                    static if (hasMember!(Source, \"_wrap_getSource\"))\n-                        return unwrap!Target(src._wrap_getSource());\n-                    else\n-                        break;\n-                }\n-            } while (upCastSource);\n-            import std.conv : ConvException;\n-            throw new ConvException(unwrapExceptionText!(Source,Target));\n-        }\n-        // structural downcast for class target\n-        auto unwrap(Source)(inout Source src)\n-        if (!is(Target : Source) && !is(Target == struct))\n-        {\n-            alias T = Select!(is(Source == shared), shared Target, Target);\n-            Object upCastSource = dynamicCast!(Object)(src);   // remove qualifier\n-            do\n-            {\n-                // Unwrap classes\n-                if (auto a = dynamicCast!(Structural!Object)(upCastSource))\n-                {\n-                    if (auto d = dynamicCast!(inout T)(upCastSource = a._wrap_getSource()))\n-                        return d;\n-                }\n-                // Unwrap a structure of type T\n-                else if (auto a = dynamicCast!(Structural!T)(upCastSource))\n-                {\n-                    return a._wrap_getSource();\n-                }\n-                // Unwrap class that already inherited from interface\n-                else if (auto d = dynamicCast!(inout T)(upCastSource))\n-                {\n-                    return d;\n-                }\n-                // Recurse to find the struct Target within a wrapped tree\n-                else\n-                {\n-                    static if (hasMember!(Source, \"_wrap_getSource\"))\n-                        return unwrap!Target(src._wrap_getSource());\n-                    else\n-                        break;\n-                }\n-            } while (upCastSource);\n-            return null;\n-        }\n-    }\n-}\n-\n-@system unittest\n-{\n-    // Validate const/immutable\n-    class A\n-    {\n-        int draw()              { return 1; }\n-        int draw(int v)         { return v; }\n-\n-        int draw() const        { return 2; }\n-        int draw() shared       { return 3; }\n-        int draw() shared const { return 4; }\n-        int draw() immutable    { return 5; }\n-    }\n-    interface Drawable\n-    {\n-        int draw();\n-        int draw() const;\n-        int draw() shared;\n-        int draw() shared const;\n-        int draw() immutable;\n-    }\n-    interface Drawable2\n-    {\n-        int draw(int v);\n-    }\n-\n-    auto ma = new A();\n-    auto sa = new shared A();\n-    auto ia = new immutable A();\n-    {\n-                     Drawable  md = ma.wrap!Drawable;\n-               const Drawable  cd = ma.wrap!Drawable;\n-              shared Drawable  sd = sa.wrap!Drawable;\n-        shared const Drawable scd = sa.wrap!Drawable;\n-           immutable Drawable  id = ia.wrap!Drawable;\n-        assert( md.draw() == 1);\n-        assert( cd.draw() == 2);\n-        assert( sd.draw() == 3);\n-        assert(scd.draw() == 4);\n-        assert( id.draw() == 5);\n-    }\n-    {\n-        Drawable2 d = ma.wrap!Drawable2;\n-        static assert(!__traits(compiles, d.draw()));\n-        assert(d.draw(10) == 10);\n-    }\n-}\n-\n-// https://issues.dlang.org/show_bug.cgi?id=10377\n-@system unittest\n-{\n-    import std.algorithm, std.range;\n-\n-    interface MyInputRange(T)\n-    {\n-        @property T front();\n-        void popFront();\n-        @property bool empty();\n-    }\n-\n-    //auto o = iota(0,10,1).inputRangeObject();\n-    //pragma(msg, __traits(allMembers, typeof(o)));\n-    auto r = iota(0,10,1).inputRangeObject().wrap!(MyInputRange!int)();\n-    assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));\n-}\n-\n-// https://issues.dlang.org/show_bug.cgi?id=10536\n-@system unittest\n-{\n-    interface Interface\n-    {\n-        int foo();\n-    }\n-    class Pluggable\n-    {\n-        int foo() { return 1; }\n-        @disable void opCast(T, this X)();  // !\n-    }\n-\n-    Interface i = new Pluggable().wrap!Interface;\n-    assert(i.foo() == 1);\n-}\n-\n-// https://issues.dlang.org/show_bug.cgi?id=10538\n-@system unittest\n-{\n-    interface Interface\n-    {\n-        int foo();\n-        int bar(int);\n-    }\n-    class Pluggable\n-    {\n-        int opDispatch(string name, A...)(A args) { return 100; }\n-    }\n-\n-    Interface i = wrap!Interface(new Pluggable());\n-    assert(i.foo() == 100);\n-    assert(i.bar(10) == 100);\n-}\n-\n-// Concat all Targets function members into one tuple\n-private template ConcatInterfaceMembers(Targets...)\n-{\n-    static if (Targets.length == 0)\n-        alias ConcatInterfaceMembers = AliasSeq!();\n-    else static if (Targets.length == 1)\n-        alias ConcatInterfaceMembers\n-          = AliasSeq!(GetOverloadedMethods!(Targets[0]));\n-    else\n-        alias ConcatInterfaceMembers = AliasSeq!(\n-                GetOverloadedMethods!(Targets[0]),\n-                ConcatInterfaceMembers!(Targets[1..$]));\n-}\n-// Remove duplicated functions based on the identifier name and function type covariance\n-private template UniqMembers(members...)\n-{\n-    template FuncInfo(string s, F)\n-    {\n-        enum name = s;\n-        alias type = F;\n-    }\n-\n-    static if (members.length == 0)\n-        alias UniqMembers = AliasSeq!();\n-    else\n-    {\n-        alias func = members[0];\n-        enum  name = __traits(identifier, func);\n-        alias type = FunctionTypeOf!func;\n-        template check(size_t i, mem...)\n-        {\n-            static if (i >= mem.length)\n-                enum ptrdiff_t check = -1;\n-            else static if\n-              (__traits(identifier, func) == __traits(identifier, mem[i]) &&\n-              !is(DerivedFunctionType!(type, FunctionTypeOf!(mem[i])) == void))\n-            {\n-                enum ptrdiff_t check = i;\n-            }\n-            else\n-                enum ptrdiff_t check = check!(i + 1, mem);\n-        }\n-        enum ptrdiff_t x = 1 + check!(0, members[1 .. $]);\n-        static if (x >= 1)\n-        {\n-            alias typex = DerivedFunctionType!(type, FunctionTypeOf!(members[x]));\n-            alias remain = UniqMembers!(members[1 .. x], members[x + 1 .. $]);\n-\n-            static if (remain.length >= 1 && remain[0].name == name &&\n-                       !is(DerivedFunctionType!(typex, remain[0].type) == void))\n-            {\n-                alias F = DerivedFunctionType!(typex, remain[0].type);\n-                alias UniqMembers = AliasSeq!(FuncInfo!(name, F), remain[1 .. $]);\n-            }\n-            else\n-                alias UniqMembers = AliasSeq!(FuncInfo!(name, typex), remain);\n-        }\n-        else\n-        {\n-            alias UniqMembers = AliasSeq!(FuncInfo!(name, type), UniqMembers!(members[1 .. $]));\n-        }\n-    }\n-}\n-\n-// find a function from Fs that has same identifier and covariant type with f\n-private template findCovariantFunction(alias finfo, Source, Fs...)\n-{\n-    template check(size_t i = 0)\n-    {\n-        static if (i >= Fs.length)\n-            enum ptrdiff_t check = -1;\n-        else\n-        {\n-            enum ptrdiff_t check =\n-                (finfo.name == __traits(identifier, Fs[i])) &&\n-                isCovariantWith!(FunctionTypeOf!(Fs[i]), finfo.type)\n-              ? i : check!(i + 1);\n-        }\n-    }\n-    enum x = check!();\n-    static if (x == -1 && is(typeof(Source.opDispatch)))\n-    {\n-        alias Params = Parameters!(finfo.type);\n-        enum ptrdiff_t findCovariantFunction =\n-            is(typeof((             Source).init.opDispatch!(finfo.name)(Params.init))) ||\n-            is(typeof((       const Source).init.opDispatch!(finfo.name)(Params.init))) ||\n-            is(typeof((   immutable Source).init.opDispatch!(finfo.name)(Params.init))) ||\n-            is(typeof((      shared Source).init.opDispatch!(finfo.name)(Params.init))) ||\n-            is(typeof((shared const Source).init.opDispatch!(finfo.name)(Params.init)))\n-          ? ptrdiff_t.max : -1;\n-    }\n-    else\n-        enum ptrdiff_t findCovariantFunction = x;\n-}\n-\n-/**\n-Type constructor for final (aka head-const) variables.\n-\n-Final variables cannot be directly mutated or rebound, but references\n-reached through the variable are typed with their original mutability.\n-It is equivalent to `final` variables in D1 and Java, as well as\n-`readonly` variables in C#.\n-\n-When `T` is a `const` or `immutable` type, `Final` aliases\n-to `T`.\n-*/\n-template Final(T)\n-{\n-static if (is(T == const) || is(T == immutable))\n-    alias Final = T;\n-else\n-{\n-    struct Final\n-    {\n-        import std.typecons : Proxy;\n-\n-        private T final_value;\n-        mixin Proxy!final_value;\n-\n-        /**\n-         * Construction is forwarded to the underlying type.\n-         */\n-        this(T other)\n-        {\n-            this.final_value = other;\n-        }\n-\n-        /// Ditto\n-        this(Args...)(auto ref Args args)\n-            if (__traits(compiles, T(args)))\n-        {\n-            static assert((!is(T == struct) && !is(T == union)) || !isNested!T,\n-                \"Non-static nested type \" ~ fullyQualifiedName!T ~ \" must be \" ~\n-                \"constructed explicitly at the call-site (e.g. auto s = \" ~\n-                \"makeFinal(\" ~ T.stringof ~ \"(...));)\");\n-            this.final_value = T(args);\n-        }\n-\n-        // Attaching function attributes gives less noisy error messages\n-        pure nothrow @safe @nogc\n-        {\n-            /++\n-             + All operators, including member access, are forwarded to the\n-             + underlying value of type `T` except for these mutating operators,\n-             + which are disabled.\n-             +/\n-            void opAssign(Other)(Other other)\n-            {\n-                static assert(0, typeof(this).stringof ~\n-                                 \" cannot be reassigned.\");\n-            }\n-\n-            /// Ditto\n-            void opOpAssign(string op, Other)(Other other)\n-            {\n-                static assert(0, typeof(this).stringof ~\n-                                 \" cannot be reassigned.\");\n-            }\n-\n-            /// Ditto\n-            void opUnary(string op : \"--\")()\n-            {\n-                static assert(0, typeof(this).stringof ~\n-                                 \" cannot be mutated.\");\n-            }\n-\n-            /// Ditto\n-            void opUnary(string op : \"++\")()\n-            {\n-                static assert(0, typeof(this).stringof ~\n-                                 \" cannot be mutated.\");\n-            }\n-        }\n-\n-        /**\n-         *\n-         * `Final!T` implicitly converts to an rvalue of type `T` through\n-         * `AliasThis`.\n-         */\n-        inout(T) final_get() inout\n-        {\n-            return final_value;\n-        }\n-\n-        /// Ditto\n-        alias final_get this;\n-\n-        /// Ditto\n-        auto ref opUnary(string op)()\n-            if (__traits(compiles, mixin(op ~ \"T.init\")))\n-        {\n-            return mixin(op ~ \"this.final_value\");\n-        }\n-    }\n-}\n-}\n-\n-/// Ditto\n-Final!T makeFinal(T)(T t)\n-{\n-    return Final!T(t);\n-}\n-\n-/// `Final` can be used to create class references which cannot be rebound:\n-pure nothrow @safe unittest\n-{\n-    static class A\n-    {\n-        int i;\n-\n-        this(int i) pure nothrow @nogc @safe\n-        {\n-            this.i = i;\n-        }\n-    }\n-\n-    auto a = makeFinal(new A(42));\n-    assert(a.i == 42);\n-\n-    //a = new A(24); // Reassignment is illegal,\n-    a.i = 24; // But fields are still mutable.\n-\n-    assert(a.i == 24);\n-}\n-\n-/// `Final` can also be used to create read-only data fields without using transitive immutability:\n-pure nothrow @safe unittest\n-{\n-    static class A\n-    {\n-        int i;\n-\n-        this(int i) pure nothrow @nogc @safe\n-        {\n-            this.i = i;\n-        }\n-    }\n-\n-    static class B\n-    {\n-        Final!A a;\n-\n-        this(A a) pure nothrow @nogc @safe\n-        {\n-            this.a = a; // Construction, thus allowed.\n-        }\n-    }\n-\n-    auto b = new B(new A(42));\n-    assert(b.a.i == 42);\n-\n-    // b.a = new A(24); // Reassignment is illegal,\n-    b.a.i = 24; // but `a` is still mutable.\n-\n-    assert(b.a.i == 24);\n-}\n-\n-pure nothrow @safe unittest\n-{\n-    static class A { int i; }\n-    static assert(!is(Final!A == A));\n-    static assert(is(Final!(const A) == const A));\n-    static assert(is(Final!(immutable A) == immutable A));\n-\n-    Final!A a = new A;\n-    static assert(!__traits(compiles, a = new A));\n-\n-    assert(a.i == 0);\n-    a.i = 42;\n-    assert(a.i == 42);\n-\n-    Final!int i = 42;\n-    static assert(!__traits(compiles, i = 24));\n-    static assert(!__traits(compiles, --i));\n-    static assert(!__traits(compiles, ++i));\n-    assert(i == 42);\n-    int iCopy = i;\n-    assert(iCopy == 42);\n-    iCopy = -i; // non-mutating unary operators must work\n-    assert(iCopy == -42);\n-\n-    static struct S\n-    {\n-        int i;\n-\n-        pure nothrow @safe @nogc:\n-        this(int i){}\n-        this(string s){}\n-        this(int i, string s, float f){ this.i = i; }\n-    }\n-\n-    Final!S sint = 42;\n-    Final!S sstr = \"foo\";\n-    static assert(!__traits(compiles, sint = sstr));\n-\n-    auto sboth = Final!S(42, \"foo\", 3.14);\n-    assert(sboth.i == 42);\n-\n-    sboth.i = 24;\n-    assert(sboth.i == 24);\n-\n-    struct NestedS\n-    {\n-        int i;\n-        int get() pure nothrow @safe @nogc { return sboth.i + i; }\n-    }\n-\n-    // Nested structs must be constructed at the call-site\n-    static assert(!__traits(compiles, Final!NestedS(6)));\n-    auto s = makeFinal(NestedS(6));\n-    assert(s.i == 6);\n-    assert(s.get == 30);\n-\n-    class NestedC\n-    {\n-        int i;\n-\n-        pure nothrow @safe @nogc:\n-        this(int i) { this.i = i; }\n-        int get() { return sboth.i + i; }\n-    }\n-\n-    auto c = makeFinal(new NestedC(6));\n-    assert(c.i == 6);\n-    assert(c.get == 30);\n-}\n-\n-pure nothrow @safe unittest\n-{\n-    auto arr = makeFinal([1, 2, 3]);\n-    static assert(!__traits(compiles, arr = null));\n-    static assert(!__traits(compiles, arr ~= 4));\n-    assert((arr ~ 4) == [1, 2, 3, 4]);\n-}\n-\n-// https://issues.dlang.org/show_bug.cgi?id=17270\n-pure nothrow @nogc @system unittest\n-{\n-    int i = 1;\n-    Final!(int*) fp = &i;\n-    assert(*fp == 1);\n-    static assert(!__traits(compiles,\n-        fp = &i // direct assignment\n-    ));\n-    static assert(is(typeof(*fp) == int));\n-    *fp = 2; // indirect assignment\n-    assert(*fp == 2);\n-    int* p = fp;\n-    assert(*p == 2);\n-}\n-\n-pure nothrow @system unittest\n-{\n-    Final!(int[]) arr;\n-    // static assert(!__traits(compiles,\n-        // arr.length = 10; // bug!\n-    // ));\n-    static assert(!__traits(compiles,\n-        arr.ptr = null\n-    ));\n-    static assert(!__traits(compiles,\n-        arr.ptr++\n-    ));\n-}"}, {"sha": "b2399013b452bcdf974e8fc3383dc2b621cc77e2", "filename": "libphobos/src/std/getopt.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fgetopt.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1835,7 +1835,7 @@ void defaultGetoptFormatter(Output)(Output output, string text, Option[] opt, st\n     assert(flag);\n }\n \n-@safe unittest  // Delegates as callbacks\n+@system unittest  // Delegates as callbacks\n {\n     alias TwoArgOptionHandler = void delegate(string option, string value) @safe;\n "}, {"sha": "ac397e5f973e08d27dcfea9a6febaabd8e0d5ff9", "filename": "libphobos/src/std/json.d", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fjson.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1537,19 +1537,15 @@ if (isOutputRange!(Out,char))\n             toStringImpl!char(str);\n     }\n \n-    // recursive @safe inference is broken here\n-    // workaround: if json.put is @safe, we should be too,\n-    // so annotate the recursion as @safe manually\n-    static if (isSafe!({ json.put(\"\"); }))\n-    {\n-        void delegate(ref const JSONValue, ulong) @safe toValue;\n-    }\n-    else\n-    {\n-        void delegate(ref const JSONValue, ulong) @system toValue;\n-    }\n+    /* make the function infer @system when json.put() is @system\n+     */\n+    if (0)\n+        json.put(' ');\n \n-    void toValueImpl(ref const JSONValue value, ulong indentLevel)\n+    /* Mark as @trusted because json.put() may be @system. This has difficulty\n+     * inferring @safe because it is recursive.\n+     */\n+    void toValueImpl(ref const JSONValue value, ulong indentLevel) @trusted\n     {\n         void putTabs(ulong additionalIndent = 0)\n         {\n@@ -1594,7 +1590,7 @@ if (isOutputRange!(Out,char))\n                             json.put(':');\n                             if (pretty)\n                                 json.put(' ');\n-                            toValue(member, indentLevel + 1);\n+                            toValueImpl(member, indentLevel + 1);\n                         }\n                     }\n \n@@ -1631,7 +1627,7 @@ if (isOutputRange!(Out,char))\n                         if (i)\n                             putCharAndEOL(',');\n                         putTabs(1);\n-                        toValue(el, indentLevel + 1);\n+                        toValueImpl(el, indentLevel + 1);\n                     }\n                     putEOL();\n                     putTabs();\n@@ -1710,9 +1706,7 @@ if (isOutputRange!(Out,char))\n         }\n     }\n \n-    toValue = &toValueImpl;\n-\n-    toValue(root, 0);\n+    toValueImpl(root, 0);\n }\n \n  // https://issues.dlang.org/show_bug.cgi?id=12897"}, {"sha": "be2bd8d175e56a7bb6e0a9fbc7d3966135ce5db8", "filename": "libphobos/src/std/logger/core.d", "status": "added", "additions": 3049, "deletions": 0, "changes": 3049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Flogger%2Fcore.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf"}, {"sha": "c662ca74e30059fa8fee82b14070ca729d826c4b", "filename": "libphobos/src/std/logger/filelogger.d", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Ffilelogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Ffilelogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Flogger%2Ffilelogger.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,272 @@\n+// Written in the D programming language.\n+/**\n+Source: $(PHOBOSSRC std/logger/filelogger.d)\n+*/\n+module std.logger.filelogger;\n+\n+import std.logger.core;\n+import std.stdio;\n+\n+import std.typecons : Flag;\n+\n+/** An option to create $(LREF FileLogger) directory if it is non-existent.\n+*/\n+alias CreateFolder = Flag!\"CreateFolder\";\n+\n+/** This `Logger` implementation writes log messages to the associated\n+file. The name of the file has to be passed on construction time. If the file\n+is already present new log messages will be append at its end.\n+*/\n+class FileLogger : Logger\n+{\n+    import std.concurrency : Tid;\n+    import std.datetime.systime : SysTime;\n+    import std.format.write : formattedWrite;\n+\n+    /** A constructor for the `FileLogger` Logger.\n+\n+    Params:\n+      fn = The filename of the output file of the `FileLogger`. If that\n+      file can not be opened for writting an exception will be thrown.\n+      lv = The `LogLevel` for the `FileLogger`. By default the\n+\n+    Example:\n+    -------------\n+    auto l1 = new FileLogger(\"logFile\");\n+    auto l2 = new FileLogger(\"logFile\", LogLevel.fatal);\n+    auto l3 = new FileLogger(\"logFile\", LogLevel.fatal, CreateFolder.yes);\n+    -------------\n+    */\n+    this(const string fn, const LogLevel lv = LogLevel.all) @safe\n+    {\n+         this(fn, lv, CreateFolder.yes);\n+    }\n+\n+    /** A constructor for the `FileLogger` Logger that takes a reference to\n+    a `File`.\n+\n+    The `File` passed must be open for all the log call to the\n+    `FileLogger`. If the `File` gets closed, using the `FileLogger`\n+    for logging will result in undefined behaviour.\n+\n+    Params:\n+      fn = The file used for logging.\n+      lv = The `LogLevel` for the `FileLogger`. By default the\n+      `LogLevel` for `FileLogger` is `LogLevel.all`.\n+      createFileNameFolder = if yes and fn contains a folder name, this\n+      folder will be created.\n+\n+    Example:\n+    -------------\n+    auto file = File(\"logFile.log\", \"w\");\n+    auto l1 = new FileLogger(file);\n+    auto l2 = new FileLogger(file, LogLevel.fatal);\n+    -------------\n+    */\n+    this(const string fn, const LogLevel lv, CreateFolder createFileNameFolder) @safe\n+    {\n+        import std.file : exists, mkdirRecurse;\n+        import std.path : dirName;\n+        import std.conv : text;\n+\n+        super(lv);\n+        this.filename = fn;\n+\n+        if (createFileNameFolder)\n+        {\n+            auto d = dirName(this.filename);\n+            mkdirRecurse(d);\n+            assert(exists(d), text(\"The folder the FileLogger should have\",\n+                                   \" created in '\", d,\"' could not be created.\"));\n+        }\n+\n+        this.file_.open(this.filename, \"a\");\n+    }\n+\n+    /** A constructor for the `FileLogger` Logger that takes a reference to\n+    a `File`.\n+\n+    The `File` passed must be open for all the log call to the\n+    `FileLogger`. If the `File` gets closed, using the `FileLogger`\n+    for logging will result in undefined behaviour.\n+\n+    Params:\n+      file = The file used for logging.\n+      lv = The `LogLevel` for the `FileLogger`. By default the\n+      `LogLevel` for `FileLogger` is `LogLevel.all`.\n+\n+    Example:\n+    -------------\n+    auto file = File(\"logFile.log\", \"w\");\n+    auto l1 = new FileLogger(file);\n+    auto l2 = new FileLogger(file, LogLevel.fatal);\n+    -------------\n+    */\n+    this(File file, const LogLevel lv = LogLevel.all) @safe\n+    {\n+        super(lv);\n+        this.file_ = file;\n+    }\n+\n+    /** If the `FileLogger` is managing the `File` it logs to, this\n+    method will return a reference to this File.\n+    */\n+    @property File file() @safe\n+    {\n+        return this.file_;\n+    }\n+\n+    /* This method overrides the base class method in order to log to a file\n+    without requiring heap allocated memory. Additionally, the `FileLogger`\n+    local mutex is logged to serialize the log calls.\n+    */\n+    override protected void beginLogMsg(string file, int line, string funcName,\n+        string prettyFuncName, string moduleName, LogLevel logLevel,\n+        Tid threadId, SysTime timestamp, Logger logger)\n+        @safe\n+    {\n+        import std.string : lastIndexOf;\n+        ptrdiff_t fnIdx = file.lastIndexOf('/') + 1;\n+        ptrdiff_t funIdx = funcName.lastIndexOf('.') + 1;\n+\n+        auto lt = this.file_.lockingTextWriter();\n+        systimeToISOString(lt, timestamp);\n+        import std.conv : to;\n+        formattedWrite(lt, \" [%s] %s:%u:%s \", logLevel.to!string,\n+                file[fnIdx .. $], line, funcName[funIdx .. $]);\n+    }\n+\n+    /* This methods overrides the base class method and writes the parts of\n+    the log call directly to the file.\n+    */\n+    override protected void logMsgPart(scope const(char)[] msg)\n+    {\n+        formattedWrite(this.file_.lockingTextWriter(), \"%s\", msg);\n+    }\n+\n+    /* This methods overrides the base class method and finalizes the active\n+    log call. This requires flushing the `File` and releasing the\n+    `FileLogger` local mutex.\n+    */\n+    override protected void finishLogMsg()\n+    {\n+        this.file_.lockingTextWriter().put(\"\\n\");\n+        this.file_.flush();\n+    }\n+\n+    /* This methods overrides the base class method and delegates the\n+    `LogEntry` data to the actual implementation.\n+    */\n+    override protected void writeLogMsg(ref LogEntry payload)\n+    {\n+        this.beginLogMsg(payload.file, payload.line, payload.funcName,\n+            payload.prettyFuncName, payload.moduleName, payload.logLevel,\n+            payload.threadId, payload.timestamp, payload.logger);\n+        this.logMsgPart(payload.msg);\n+        this.finishLogMsg();\n+    }\n+\n+    /** If the `FileLogger` was constructed with a filename, this method\n+    returns this filename. Otherwise an empty `string` is returned.\n+    */\n+    string getFilename()\n+    {\n+        return this.filename;\n+    }\n+\n+    /** The `File` log messages are written to. */\n+    protected File file_;\n+\n+    /** The filename of the `File` log messages are written to. */\n+    protected string filename;\n+}\n+\n+@system unittest\n+{\n+    import std.array : empty;\n+    import std.file : deleteme, remove;\n+    import std.string : indexOf;\n+\n+    string filename = deleteme ~ __FUNCTION__ ~ \".tempLogFile\";\n+    auto l = new FileLogger(filename);\n+\n+    scope(exit)\n+    {\n+        remove(filename);\n+    }\n+\n+    string notWritten = \"this should not be written to file\";\n+    string written = \"this should be written to file\";\n+\n+    l.logLevel = LogLevel.critical;\n+    l.log(LogLevel.warning, notWritten);\n+    l.log(LogLevel.critical, written);\n+    destroy(l);\n+\n+    auto file = File(filename, \"r\");\n+    string readLine = file.readln();\n+    assert(readLine.indexOf(written) != -1, readLine);\n+    readLine = file.readln();\n+    assert(readLine.indexOf(notWritten) == -1, readLine);\n+}\n+\n+@safe unittest\n+{\n+    import std.file : rmdirRecurse, exists, deleteme;\n+    import std.path : dirName;\n+\n+    const string tmpFolder = dirName(deleteme);\n+    const string filepath = tmpFolder ~ \"/bug15771/minas/oops/\";\n+    const string filename = filepath ~ \"output.txt\";\n+    assert(!exists(filepath));\n+\n+    auto f = new FileLogger(filename, LogLevel.all, CreateFolder.yes);\n+    scope(exit) () @trusted { rmdirRecurse(tmpFolder ~ \"/bug15771\"); }();\n+\n+    f.log(\"Hello World!\");\n+    assert(exists(filepath));\n+    f.file.close();\n+}\n+\n+@system unittest\n+{\n+    import std.array : empty;\n+    import std.file : deleteme, remove;\n+    import std.string : indexOf;\n+\n+    string filename = deleteme ~ __FUNCTION__ ~ \".tempLogFile\";\n+    auto file = File(filename, \"w\");\n+    auto l = new FileLogger(file);\n+\n+    scope(exit)\n+    {\n+        remove(filename);\n+    }\n+\n+    string notWritten = \"this should not be written to file\";\n+    string written = \"this should be written to file\";\n+\n+    l.logLevel = LogLevel.critical;\n+    l.log(LogLevel.warning, notWritten);\n+    l.log(LogLevel.critical, written);\n+    file.close();\n+\n+    file = File(filename, \"r\");\n+    string readLine = file.readln();\n+    assert(readLine.indexOf(written) != -1, readLine);\n+    readLine = file.readln();\n+    assert(readLine.indexOf(notWritten) == -1, readLine);\n+    file.close();\n+}\n+\n+@system unittest\n+{\n+    auto dl = cast(FileLogger) sharedLog;\n+    assert(dl !is null);\n+    assert(dl.logLevel == LogLevel.info);\n+    assert(globalLogLevel == LogLevel.all);\n+\n+    auto tl = cast(StdForwardLogger) stdThreadLocalLog;\n+    assert(tl !is null);\n+    stdThreadLocalLog.logLevel = LogLevel.all;\n+}"}, {"sha": "eda922dee6caabf520e313dcdbdcd5a0b08de1e5", "filename": "libphobos/src/std/logger/multilogger.d", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fmultilogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fmultilogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Flogger%2Fmultilogger.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,200 @@\n+// Written in the D programming language.\n+/**\n+Source: $(PHOBOSSRC std/logger/multilogger.d)\n+*/\n+module std.logger.multilogger;\n+\n+import std.logger.core;\n+import std.logger.filelogger;\n+\n+/** This Element is stored inside the `MultiLogger` and associates a\n+`Logger` to a `string`.\n+*/\n+struct MultiLoggerEntry\n+{\n+    string name; /// The name if the `Logger`\n+    Logger logger; /// The stored `Logger`\n+}\n+\n+/** MultiLogger logs to multiple `Logger`. The `Logger`s are stored in an\n+`Logger[]` in their order of insertion.\n+\n+Every data logged to this `MultiLogger` will be distributed to all the $(D\n+Logger)s inserted into it. This `MultiLogger` implementation can\n+hold multiple `Logger`s with the same name. If the method `removeLogger`\n+is used to remove a `Logger` only the first occurrence with that name will\n+be removed.\n+*/\n+class MultiLogger : Logger\n+{\n+    /** A constructor for the `MultiLogger` Logger.\n+\n+    Params:\n+      lv = The `LogLevel` for the `MultiLogger`. By default the\n+      `LogLevel` for `MultiLogger` is `LogLevel.all`.\n+\n+    Example:\n+    -------------\n+    auto l1 = new MultiLogger(LogLevel.trace);\n+    -------------\n+    */\n+    this(const LogLevel lv = LogLevel.all) @safe\n+    {\n+        super(lv);\n+    }\n+\n+    /** This member holds all `Logger`s stored in the `MultiLogger`.\n+\n+    When inheriting from `MultiLogger` this member can be used to gain\n+    access to the stored `Logger`.\n+    */\n+    protected MultiLoggerEntry[] logger;\n+\n+    /** This method inserts a new Logger into the `MultiLogger`.\n+\n+    Params:\n+      name = The name of the `Logger` to insert.\n+      newLogger = The `Logger` to insert.\n+    */\n+    void insertLogger(string name, Logger newLogger) @safe\n+    {\n+        this.logger ~= MultiLoggerEntry(name, newLogger);\n+    }\n+\n+    /** This method removes a Logger from the `MultiLogger`.\n+\n+    Params:\n+      toRemove = The name of the `Logger` to remove. If the `Logger`\n+        is not found `null` will be returned. Only the first occurrence of\n+        a `Logger` with the given name will be removed.\n+\n+    Returns: The removed `Logger`.\n+    */\n+    Logger removeLogger(in char[] toRemove) @safe\n+    {\n+        import std.algorithm.mutation : copy;\n+        import std.range.primitives : back, popBack;\n+        for (size_t i = 0; i < this.logger.length; ++i)\n+        {\n+            if (this.logger[i].name == toRemove)\n+            {\n+                Logger ret = this.logger[i].logger;\n+                this.logger[i] = this.logger.back;\n+                this.logger.popBack();\n+\n+                return ret;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /* The override to pass the payload to all children of the\n+    `MultiLoggerBase`.\n+    */\n+    override protected void writeLogMsg(ref LogEntry payload) @safe\n+    {\n+        foreach (it; this.logger)\n+        {\n+            /* We don't perform any checks here to avoid race conditions.\n+            Instead the child will check on its own if its log level matches\n+            and assume LogLevel.all for the globalLogLevel (since we already\n+            know the message passes this test).\n+            */\n+            it.logger.forwardMsg(payload);\n+        }\n+    }\n+}\n+\n+@safe unittest\n+{\n+    import std.exception : assertThrown;\n+    import std.logger.nulllogger;\n+    auto a = new MultiLogger;\n+    auto n0 = new NullLogger();\n+    auto n1 = new NullLogger();\n+    a.insertLogger(\"zero\", n0);\n+    a.insertLogger(\"one\", n1);\n+\n+    auto n0_1 = a.removeLogger(\"zero\");\n+    assert(n0_1 is n0);\n+    auto n = a.removeLogger(\"zero\");\n+    assert(n is null);\n+\n+    auto n1_1 = a.removeLogger(\"one\");\n+    assert(n1_1 is n1);\n+    n = a.removeLogger(\"one\");\n+    assert(n is null);\n+}\n+\n+@safe unittest\n+{\n+    auto a = new MultiLogger;\n+    auto n0 = new TestLogger;\n+    auto n1 = new TestLogger;\n+    a.insertLogger(\"zero\", n0);\n+    a.insertLogger(\"one\", n1);\n+\n+    a.log(\"Hello TestLogger\"); int line = __LINE__;\n+    assert(n0.msg == \"Hello TestLogger\");\n+    assert(n0.line == line);\n+    assert(n1.msg == \"Hello TestLogger\");\n+    assert(n1.line == line);\n+}\n+\n+// Issue #16\n+@system unittest\n+{\n+    import std.file : deleteme;\n+    import std.stdio : File;\n+    import std.string : indexOf;\n+    string logName = deleteme ~ __FUNCTION__ ~ \".log\";\n+    auto logFileOutput = File(logName, \"w\");\n+    scope(exit)\n+    {\n+        import std.file : remove;\n+        logFileOutput.close();\n+        remove(logName);\n+    }\n+    auto traceLog = new FileLogger(logFileOutput, LogLevel.all);\n+    auto infoLog  = new TestLogger(LogLevel.info);\n+\n+    auto root = new MultiLogger(LogLevel.all);\n+    root.insertLogger(\"fileLogger\", traceLog);\n+    root.insertLogger(\"stdoutLogger\", infoLog);\n+\n+    string tMsg = \"A trace message\";\n+    root.trace(tMsg); int line1 = __LINE__;\n+\n+    assert(infoLog.line != line1);\n+    assert(infoLog.msg != tMsg);\n+\n+    string iMsg = \"A info message\";\n+    root.info(iMsg); int line2 = __LINE__;\n+\n+    assert(infoLog.line == line2);\n+    assert(infoLog.msg == iMsg, infoLog.msg ~ \":\" ~ iMsg);\n+\n+    logFileOutput.close();\n+    logFileOutput = File(logName, \"r\");\n+    assert(logFileOutput.isOpen);\n+    assert(!logFileOutput.eof);\n+\n+    auto line = logFileOutput.readln();\n+    assert(line.indexOf(tMsg) != -1, line ~ \":\" ~ tMsg);\n+    assert(!logFileOutput.eof);\n+    line = logFileOutput.readln();\n+    assert(line.indexOf(iMsg) != -1, line ~ \":\" ~ tMsg);\n+}\n+\n+@system unittest\n+{\n+    auto dl = cast(FileLogger) sharedLog;\n+    assert(dl !is null);\n+    assert(dl.logLevel == LogLevel.info);\n+    assert(globalLogLevel == LogLevel.all);\n+\n+    auto tl = cast(StdForwardLogger) stdThreadLocalLog;\n+    assert(tl !is null);\n+    stdThreadLocalLog.logLevel = LogLevel.all;\n+}"}, {"sha": "fd48b8529bb00c5f172d6b4aaf8a561d4d6e8021", "filename": "libphobos/src/std/logger/nulllogger.d", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fnulllogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fnulllogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Flogger%2Fnulllogger.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,41 @@\n+// Written in the D programming language.\n+/**\n+Source: $(PHOBOSSRC std/logger/nulllogger.d)\n+*/\n+module std.logger.nulllogger;\n+\n+import std.logger.core;\n+\n+/** The `NullLogger` will not process any log messages.\n+\n+In case of a log message with `LogLevel.fatal` nothing will happen.\n+*/\n+class NullLogger : Logger\n+{\n+    /** The default constructor for the `NullLogger`.\n+\n+    Independent of the parameter this Logger will never log a message.\n+\n+    Params:\n+      lv = The `LogLevel` for the `NullLogger`. By default the `LogLevel`\n+      for `NullLogger` is `LogLevel.all`.\n+    */\n+    this(const LogLevel lv = LogLevel.all) @safe\n+    {\n+        super(lv);\n+        this.fatalHandler = delegate() {};\n+    }\n+\n+    override protected void writeLogMsg(ref LogEntry payload) @safe @nogc\n+    {\n+    }\n+}\n+\n+///\n+@safe unittest\n+{\n+    import std.logger.core : LogLevel;\n+    auto nl1 = new NullLogger(LogLevel.all);\n+    nl1.info(\"You will never read this.\");\n+    nl1.fatal(\"You will never read this, either and it will not throw\");\n+}"}, {"sha": "4f4183c4cec7c34a6e8a25633e01bb835d7b7d82", "filename": "libphobos/src/std/logger/package.d", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Flogger%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Flogger%2Fpackage.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -0,0 +1,168 @@\n+// Written in the D programming language.\n+/**\n+Implements logging facilities.\n+\n+Copyright: Copyright Robert \"burner\" Schadek 2013 --\n+License: <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n+Authors: $(HTTP www.svs.informatik.uni-oldenburg.de/60865.html, Robert burner Schadek)\n+\n+$(H3 Basic Logging)\n+\n+Message logging is a common approach to expose runtime information of a\n+program. Logging should be easy, but also flexible and powerful, therefore\n+`D` provides a standard interface for logging.\n+\n+The easiest way to create a log message is to write:\n+-------------\n+import std.logger;\n+\n+void main() {\n+    log(\"Hello World\");\n+}\n+-------------\n+This will print a message to the `stderr` device. The message will contain\n+the filename, the line number, the name of the surrounding function, the time\n+and the message.\n+\n+More complex log call can go along the lines like:\n+-------------\n+log(\"Logging to the sharedLog with its default LogLevel\");\n+logf(LogLevel.info, 5 < 6, \"%s to the sharedLog with its LogLevel.info\", \"Logging\");\n+info(\"Logging to the sharedLog with its info LogLevel\");\n+warning(5 < 6, \"Logging to the sharedLog with its LogLevel.warning if 5 is less than 6\");\n+error(\"Logging to the sharedLog with its error LogLevel\");\n+errorf(\"Logging %s the sharedLog %s its error LogLevel\", \"to\", \"with\");\n+critical(\"Logging to the\",\" sharedLog with its error LogLevel\");\n+fatal(\"Logging to the sharedLog with its fatal LogLevel\");\n+\n+auto fLogger = new FileLogger(\"NameOfTheLogFile\");\n+fLogger.log(\"Logging to the fileLogger with its default LogLevel\");\n+fLogger.info(\"Logging to the fileLogger with its default LogLevel\");\n+fLogger.warning(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if 5 is less than 6\");\n+fLogger.warningf(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if %s is %s than 6\", 5, \"less\");\n+fLogger.critical(\"Logging to the fileLogger with its info LogLevel\");\n+fLogger.log(LogLevel.trace, 5 < 6, \"Logging to the fileLogger\",\" with its default LogLevel if 5 is less than 6\");\n+fLogger.fatal(\"Logging to the fileLogger with its warning LogLevel\");\n+-------------\n+Additionally, this example shows how a new `FileLogger` is created.\n+Individual `Logger` and the global log functions share commonly named\n+functions to log data.\n+\n+The names of the functions are as follows:\n+$(UL\n+    $(LI `log`)\n+    $(LI `trace`)\n+    $(LI `info`)\n+    $(LI `warning`)\n+    $(LI `critical`)\n+    $(LI `fatal`)\n+)\n+The default `Logger` will by default log to `stderr` and has a default\n+`LogLevel` of `LogLevel.all`. The default Logger can be accessed by\n+using the property called `sharedLog`. This property is a reference to the\n+current default `Logger`. This reference can be used to assign a new\n+default `Logger`.\n+-------------\n+sharedLog = new FileLogger(\"New_Default_Log_File.log\");\n+-------------\n+\n+Additional `Logger` can be created by creating a new instance of the\n+required `Logger`.\n+\n+$(H3 Logging Fundamentals)\n+$(H4 LogLevel)\n+The `LogLevel` of a log call can be defined in two ways. The first is by\n+calling `log` and passing the `LogLevel` explicitly as the first argument.\n+The second way of setting the `LogLevel` of a\n+log call, is by calling either `trace`, `info`, `warning`,\n+`critical`, or `fatal`. The log call will then have the respective\n+`LogLevel`. If no `LogLevel` is defined the log call will use the\n+current `LogLevel` of the used `Logger`. If data is logged with\n+`LogLevel` `fatal` by default an `Error` will be thrown.\n+This behaviour can be modified by using the member `fatalHandler` to\n+assign a custom delegate to handle log call with `LogLevel` `fatal`.\n+\n+$(H4 Conditional Logging)\n+Conditional logging can be achieved be passing a `bool` as first\n+argument to a log function. If conditional logging is used the condition must\n+be `true` in order to have the log message logged.\n+\n+In order to combine an explicit `LogLevel` passing with conditional\n+logging, the `LogLevel` has to be passed as first argument followed by the\n+`bool`.\n+\n+$(H4 Filtering Log Messages)\n+Messages are logged if the `LogLevel` of the log message is greater than or\n+equal to the `LogLevel` of the used `Logger` and additionally if the\n+`LogLevel` of the log message is greater than or equal to the global `LogLevel`.\n+If a condition is passed into the log call, this condition must be true.\n+\n+The global `LogLevel` is accessible by using `globalLogLevel`.\n+To assign a `LogLevel` of a `Logger` use the `logLevel` property of\n+the logger.\n+\n+$(H4 Printf Style Logging)\n+If `printf`-style logging is needed add a $(B f) to the logging call, such as\n+$(D myLogger.infof(\"Hello %s\", \"world\");) or $(D fatalf(\"errno %d\", 1337)).\n+The additional $(B f) appended to the function name enables `printf`-style\n+logging for all combinations of explicit `LogLevel` and conditional\n+logging functions and methods.\n+\n+$(H4 Thread Local Redirection)\n+Calls to the free standing log functions are not directly forwarded to the\n+global `Logger` `sharedLog`. Actually, a thread local `Logger` of\n+type `StdForwardLogger` processes the log call and then, by default, forwards\n+the created `Logger.LogEntry` to the `sharedLog` `Logger`.\n+The thread local `Logger` is accessible by the `stdThreadLocalLog`\n+property. This property allows to assign user defined `Logger`. The default\n+`LogLevel` of the `stdThreadLocalLog` `Logger` is `LogLevel.all`\n+and it will therefore forward all messages to the `sharedLog` `Logger`.\n+The `LogLevel` of the `stdThreadLocalLog` can be used to filter log\n+calls before they reach the `sharedLog` `Logger`.\n+\n+$(H3 User Defined Logger)\n+To customize the `Logger` behavior, create a new `class` that inherits from\n+the abstract `Logger` `class`, and implements the `writeLogMsg`\n+method.\n+-------------\n+class MyCustomLogger : Logger\n+{\n+    this(LogLevel lv) @safe\n+    {\n+        super(lv);\n+    }\n+\n+    override void writeLogMsg(ref LogEntry payload)\n+    {\n+        // log message in my custom way\n+    }\n+}\n+\n+auto logger = new MyCustomLogger(LogLevel.info);\n+logger.log(\"Awesome log message with LogLevel.info\");\n+-------------\n+\n+To gain more precise control over the logging process, additionally to\n+overriding the `writeLogMsg` method the methods `beginLogMsg`,\n+`logMsgPart` and `finishLogMsg` can be overridden.\n+\n+$(H3 Provided Logger)\n+By default four `Logger` implementations are given. The `FileLogger`\n+logs data to files. It can also be used to log to `stdout` and `stderr`\n+as these devices are files as well. A `Logger` that logs to `stdout` can\n+therefore be created by $(D new FileLogger(stdout)).\n+The `MultiLogger` is basically an associative array of `string`s to\n+`Logger`. It propagates log calls to its stored `Logger`. The\n+`ArrayLogger` contains an array of `Logger` and also propagates log\n+calls to its stored `Logger`. The `NullLogger` does not do anything. It\n+will never log a message and will never throw on a log call with `LogLevel`\n+`error`.\n+\n+Source: $(PHOBOSSRC std/logger/package.d)\n+*/\n+module std.logger;\n+\n+public import std.logger.core;\n+public import std.logger.filelogger;\n+public import std.logger.multilogger;\n+public import std.logger.nulllogger;"}, {"sha": "2db341da85e11bcd093faf842626bc15294e5fad", "filename": "libphobos/src/std/meta.d", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fmeta.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fmeta.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmeta.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -627,35 +627,9 @@ Evaluates to `AliasSeq!(fun!(args[0]), fun!(args[1]), ..., fun!(args[$ - 1]))`.\n  */\n template staticMap(alias fun, args...)\n {\n-    version (__staticMap_simplest_but_buggy)\n-    {\n-        // @@@ BUG @@@\n-        // The following straightforward implementation exposes a bug.\n-        // See issue https://issues.dlang.org/show_bug.cgi?id=22421 and unittest below.\n-        alias staticMap = AliasSeq!();\n-        static foreach (arg; args)\n-             staticMap = AliasSeq!(staticMap, fun!arg);\n-    }\n-    else version (__staticMap_simple_but_slow)\n-    {\n-        // This has a performance bug. Appending to the staticMap seems to be quadratic.\n-        alias staticMap = AliasSeq!();\n-        static foreach (i; 0 .. args.length)\n-            staticMap = AliasSeq!(staticMap, fun!(args[i]));\n-    }\n-    else // Current best-of-breed implementation imitates quicksort\n-    {\n-        static if (args.length <= 8)\n-        {\n-            alias staticMap = AliasSeq!();\n-            static foreach (i; 0 .. args.length)\n-                staticMap = AliasSeq!(staticMap, fun!(args[i]));\n-        }\n-        else\n-        {\n-            alias staticMap = AliasSeq!(staticMap!(fun, args[0 .. $ / 2]), staticMap!(fun, args[$ / 2 .. $]));\n-        }\n-    }\n+    alias staticMap = AliasSeq!();\n+    static foreach (arg; args)\n+        staticMap = AliasSeq!(staticMap, fun!arg);\n }\n \n ///"}, {"sha": "e2eca7bc4896052a8222df99a5b26372327895f6", "filename": "libphobos/src/std/package.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fpackage.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -53,6 +53,7 @@ public import\n  std.getopt,\n  std.int128,\n  std.json,\n+ std.logger,\n  std.math,\n  std.mathspecial,\n  std.meta,"}, {"sha": "70b87ddd59e1afdd8e2433fb679ef984e5fdcb8c", "filename": "libphobos/src/std/random.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Frandom.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Frandom.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frandom.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -2806,7 +2806,7 @@ auto ref choice(Range)(ref Range range)\n {\n     import std.algorithm.searching : canFind;\n \n-    class MyTestClass\n+    static class MyTestClass\n     {\n         int x;\n "}, {"sha": "1562d797e8856ef900b04eecc80754394326532e", "filename": "libphobos/src/std/regex/package.d", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -43,11 +43,16 @@ $(TR $(TD Objects) $(TD\n ))\n \n   $(SECTION Synopsis)\n-  ---\n-  import std.regex;\n-  import std.stdio;\n-  void main()\n-  {\n+\n+  Create a regex at runtime:\n+  $(RUNNABLE_EXAMPLE\n+  $(RUNNABLE_EXAMPLE_STDIN\n+They met on 24/01/1970.\n+7/8/99 wasn't as hot as 7/8/2022.\n+)\n+      ---\n+      import std.regex;\n+      import std.stdio;\n       // Print out all possible dd/mm/yy(yy) dates found in user input.\n       auto r = regex(r\"\\b[0-9][0-9]?/[0-9][0-9]?/[0-9][0-9](?:[0-9][0-9])?\\b\");\n       foreach (line; stdin.byLine)\n@@ -57,41 +62,52 @@ $(TR $(TD Objects) $(TD\n         foreach (c; matchAll(line, r))\n             writeln(c.hit);\n       }\n-  }\n-  ...\n-\n-  // Create a static regex at compile-time, which contains fast native code.\n+      ---\n+  )\n+  Create a static regex at compile-time, which contains fast native code:\n+  $(RUNNABLE_EXAMPLE\n+  ---\n+  import std.regex;\n   auto ctr = ctRegex!(`^.*/([^/]+)/?$`);\n \n   // It works just like a normal regex:\n   auto c2 = matchFirst(\"foo/bar\", ctr);   // First match found here, if any\n   assert(!c2.empty);   // Be sure to check if there is a match before examining contents!\n   assert(c2[1] == \"bar\");   // Captures is a range of submatches: 0 = full match.\n-\n-  ...\n-  // multi-pattern regex\n+  ---\n+  )\n+  Multi-pattern regex:\n+  $(RUNNABLE_EXAMPLE\n+  ---\n+  import std.regex;\n   auto multi = regex([`\\d+,\\d+`, `([a-z]+):(\\d+)`]);\n   auto m = \"abc:43 12,34\".matchAll(multi);\n   assert(m.front.whichPattern == 2);\n   assert(m.front[1] == \"abc\");\n   assert(m.front[2] == \"43\");\n   m.popFront();\n   assert(m.front.whichPattern == 1);\n-  assert(m.front[1] == \"12\");\n-  ...\n-\n+  assert(m.front[0] == \"12,34\");\n+  ---\n+  )\n+  $(LREF Captures) and `opCast!bool`:\n+  $(RUNNABLE_EXAMPLE\n+  ---\n+  import std.regex;\n   // The result of `matchAll/matchFirst` is directly testable with `if/assert/while`,\n   // e.g. test if a string consists of letters only:\n   assert(matchFirst(\"LettersOnly\", `^\\p{L}+$`));\n \n-  // And we can take advantage of the ability to define a variable in the $(LINK2 https://dlang.org/spec/statement.html#IfCondition `IfCondition`):\n-  if (const auto captures = matchFirst(\"At l34st one digit, but maybe more...\", `((\\d)(\\d*))`))\n+  // And we can take advantage of the ability to define a variable in the IfCondition:\n+  if (const captures = matchFirst(\"At l34st one digit, but maybe more...\", `((\\d)(\\d*))`))\n   {\n       assert(captures[2] == \"3\");\n       assert(captures[3] == \"4\");\n       assert(captures[1] == \"34\");\n   }\n   ---\n+  )\n+  See_Also: $(LINK2 https://dlang.org/spec/statement.html#IfCondition, `IfCondition`).\n \n   $(SECTION Syntax and general information)\n   The general usage guideline is to keep regex complexity on the side of simplicity,\n@@ -470,7 +486,7 @@ private struct CTRegexWrapper(Char)\n     alias getRe this;\n }\n \n-template ctRegexImpl(alias pattern, string flags=[])\n+template ctRegexImpl(alias pattern, string flags=\"\")\n {\n     import std.regex.internal.backtracking, std.regex.internal.parser;\n     static immutable r = cast(immutable) regex(pattern, flags);\n@@ -518,7 +534,7 @@ template ctRegexImpl(alias pattern, string flags=[])\n     pattern = Regular expression\n     flags = The _attributes (g, i, m, s and x accepted)\n +/\n-public enum ctRegex(alias pattern, alias flags=[]) = ctRegexImpl!(pattern, flags).wrapper;\n+public enum ctRegex(alias pattern, string flags=\"\") = ctRegexImpl!(pattern, flags).wrapper;\n \n enum isRegexFor(RegEx, R) = is(immutable RegEx == immutable Regex!(BasicElementOf!R))\n      || is(RegEx : const(Regex!(BasicElementOf!R)))"}, {"sha": "7ed24f7f98d90d290a66d3a4967cd1dd5518fa57", "filename": "libphobos/src/std/string.d", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fstring.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -6884,7 +6884,7 @@ if (isSomeString!S)\n \n     if (inword)\n     {\n-        if (col + 1 + (s.length - wordstart) >= columns)\n+        if (col + 1 + (s.length - wordstart) > columns)\n         {\n             result ~= '\\n';\n             result ~= indent;\n@@ -6929,6 +6929,13 @@ if (isSomeString!S)\n     });\n }\n \n+@safe pure unittest // https://issues.dlang.org/show_bug.cgi?id=23298\n+{\n+    assert(\"1 2 3 4 5 6 7 8 9\".wrap(17) == \"1 2 3 4 5 6 7 8 9\\n\");\n+    assert(\"1 2 3 4 5 6 7 8 9 \".wrap(17) == \"1 2 3 4 5 6 7 8 9\\n\");\n+    assert(\"1 2 3 4 5 6 7 8 99\".wrap(17) == \"1 2 3 4 5 6 7 8\\n99\\n\");\n+}\n+\n /******************************************\n  * Removes one level of indentation from a multi-line string.\n  *"}, {"sha": "c7cdc24e4d59275ac114b6b768214d036135a89c", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a586beae1027ea0c82411637920a5032d1dedf/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=b7a586beae1027ea0c82411637920a5032d1dedf", "patch": "@@ -1146,7 +1146,7 @@ if (distinctFieldNames!(Specs))\n         }\n \n         ///\n-        static if (Specs.length == 0) @safe unittest\n+        static if (Specs.length == 0) @system unittest\n         {\n             //replace names by their position\n \n@@ -1166,7 +1166,7 @@ if (distinctFieldNames!(Specs))\n             assert(t2Named.c == 3);\n         }\n \n-        static if (Specs.length == 0) @safe unittest\n+        static if (Specs.length == 0) @system unittest\n         {\n             //check that empty translations work fine\n             enum string[string] a0 = null;"}]}