{"sha": "05486daafd85d56f457ab6808a02de02d53d60b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU0ODZkYWFmZDg1ZDU2ZjQ1N2FiNjgwOGEwMmRlMDJkNTNkNjBiMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-10-10T19:37:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-10-10T19:37:47Z"}, "message": "fold-const.c (operand_equal_p): Document OEP_ADDRESS_OF and OEP_CONSTANT_ADDRESS_OF...\n\n\t* fold-const.c (operand_equal_p): Document OEP_ADDRESS_OF\n\tand OEP_CONSTANT_ADDRESS_OF; skip type compatibility checks\n\twhen OEP_ADDRESS_OF is se.\n\nFrom-SVN: r228679", "tree": {"sha": "5450cb9c06657b0b025e9638dba976f0921562ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5450cb9c06657b0b025e9638dba976f0921562ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05486daafd85d56f457ab6808a02de02d53d60b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05486daafd85d56f457ab6808a02de02d53d60b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05486daafd85d56f457ab6808a02de02d53d60b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05486daafd85d56f457ab6808a02de02d53d60b3/comments", "author": null, "committer": null, "parents": [{"sha": "ea17c0fef46752dbad162c0d9882570876a4ff6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea17c0fef46752dbad162c0d9882570876a4ff6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea17c0fef46752dbad162c0d9882570876a4ff6c"}], "stats": {"total": 139, "additions": 92, "deletions": 47}, "files": [{"sha": "c92e7444b1f39a6599cbd378ed6439ac77d724b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05486daafd85d56f457ab6808a02de02d53d60b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05486daafd85d56f457ab6808a02de02d53d60b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05486daafd85d56f457ab6808a02de02d53d60b3", "patch": "@@ -1,3 +1,9 @@\n+2015-10-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* fold-const.c (operand_equal_p): Document OEP_ADDRESS_OF\n+\tand OEP_CONSTANT_ADDRESS_OF; skip type compatibility checks\n+\twhen OEP_ADDRESS_OF is se.\n+\n 2015-10-10  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "bdfda9a3cdc129d19aec1457062aa52c6fa9a6d5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 86, "deletions": 47, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05486daafd85d56f457ab6808a02de02d53d60b3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05486daafd85d56f457ab6808a02de02d53d60b3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=05486daafd85d56f457ab6808a02de02d53d60b3", "patch": "@@ -2693,7 +2693,12 @@ combine_comparisons (location_t loc,\n \n    If OEP_PURE_SAME is set, then pure functions with identical arguments\n    are considered the same.  It is used when the caller has other ways\n-   to ensure that global memory is unchanged in between.  */\n+   to ensure that global memory is unchanged in between.\n+\n+   If OEP_ADDRESS_OF is set, we are actually comparing addresses of objects,\n+   not values of expressions.  OEP_CONSTANT_ADDRESS_OF in addition to\n+   OEP_ADDRESS_OF is used for ADDR_EXPR with TREE_CONSTANT flag set and we\n+   further ignore any side effects on SAVE_EXPRs then.  */\n \n int\n operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n@@ -2712,31 +2717,52 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n   /* Check equality of integer constants before bailing out due to\n      precision differences.  */\n   if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n-    return tree_int_cst_equal (arg0, arg1);\n-\n-  /* If both types don't have the same signedness, then we can't consider\n-     them equal.  We must check this before the STRIP_NOPS calls\n-     because they may change the signedness of the arguments.  As pointers\n-     strictly don't have a signedness, require either two pointers or\n-     two non-pointers as well.  */\n-  if (TYPE_UNSIGNED (TREE_TYPE (arg0)) != TYPE_UNSIGNED (TREE_TYPE (arg1))\n-      || POINTER_TYPE_P (TREE_TYPE (arg0)) != POINTER_TYPE_P (TREE_TYPE (arg1)))\n-    return 0;\n+    {\n+      /* Address of INTEGER_CST is not defined; check that we did not forget\n+\t to drop the OEP_ADDRESS_OF/OEP_CONSTANT_ADDRESS_OF flags.  */\n+      gcc_checking_assert (!(flags\n+\t\t\t     & (OEP_ADDRESS_OF | OEP_CONSTANT_ADDRESS_OF)));\n+      return tree_int_cst_equal (arg0, arg1);\n+    }\n \n-  /* We cannot consider pointers to different address space equal.  */\n-  if (POINTER_TYPE_P (TREE_TYPE (arg0)) && POINTER_TYPE_P (TREE_TYPE (arg1))\n-      && (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg0)))\n-\t  != TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg1)))))\n-    return 0;\n+  if (!(flags & OEP_ADDRESS_OF))\n+    {\n+      /* If both types don't have the same signedness, then we can't consider\n+\t them equal.  We must check this before the STRIP_NOPS calls\n+\t because they may change the signedness of the arguments.  As pointers\n+\t strictly don't have a signedness, require either two pointers or\n+\t two non-pointers as well.  */\n+      if (TYPE_UNSIGNED (TREE_TYPE (arg0)) != TYPE_UNSIGNED (TREE_TYPE (arg1))\n+\t  || POINTER_TYPE_P (TREE_TYPE (arg0))\n+\t\t\t     != POINTER_TYPE_P (TREE_TYPE (arg1)))\n+\treturn 0;\n \n-  /* If both types don't have the same precision, then it is not safe\n-     to strip NOPs.  */\n-  if (element_precision (TREE_TYPE (arg0))\n-      != element_precision (TREE_TYPE (arg1)))\n-    return 0;\n+      /* We cannot consider pointers to different address space equal.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (arg0))\n+\t\t\t  && POINTER_TYPE_P (TREE_TYPE (arg1))\n+\t  && (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg0)))\n+\t      != TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg1)))))\n+\treturn 0;\n \n-  STRIP_NOPS (arg0);\n-  STRIP_NOPS (arg1);\n+      /* If both types don't have the same precision, then it is not safe\n+\t to strip NOPs.  */\n+      if (element_precision (TREE_TYPE (arg0))\n+\t  != element_precision (TREE_TYPE (arg1)))\n+\treturn 0;\n+\n+      STRIP_NOPS (arg0);\n+      STRIP_NOPS (arg1);\n+    }\n+#if 0\n+  /* FIXME: Fortran FE currently produce ADDR_EXPR of NOP_EXPR. Enable the\n+     sanity check once the issue is solved.  */\n+  else\n+    /* Addresses of conversions and SSA_NAMEs (and many other things)\n+       are not defined.  Check that we did not forget to drop the\n+       OEP_ADDRESS_OF/OEP_CONSTANT_ADDRESS_OF flags.  */\n+    gcc_checking_assert (!CONVERT_EXPR_P (arg0) && !CONVERT_EXPR_P (arg1)\n+\t\t\t && TREE_CODE (arg0) != SSA_NAME);\n+#endif\n \n   /* In case both args are comparisons but with different comparison\n      code, try to swap the comparison operands of one arg to produce\n@@ -2859,9 +2885,11 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t\t      TREE_STRING_LENGTH (arg0)));\n \n       case ADDR_EXPR:\n+\tgcc_checking_assert (!(flags\n+\t\t\t       & (OEP_ADDRESS_OF | OEP_CONSTANT_ADDRESS_OF)));\n \treturn operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1, 0),\n-\t\t\t\tTREE_CONSTANT (arg0) && TREE_CONSTANT (arg1)\n-\t\t\t\t? OEP_CONSTANT_ADDRESS_OF | OEP_ADDRESS_OF : 0);\n+\t\t\t\tflags | OEP_ADDRESS_OF\n+\t\t\t\t| OEP_CONSTANT_ADDRESS_OF);\n       default:\n \tbreak;\n       }\n@@ -2923,7 +2951,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       switch (TREE_CODE (arg0))\n \t{\n \tcase INDIRECT_REF:\n-\t  if (!(flags & OEP_ADDRESS_OF)\n+\t  if (!(flags & (OEP_ADDRESS_OF | OEP_CONSTANT_ADDRESS_OF))\n \t      && (TYPE_ALIGN (TREE_TYPE (arg0))\n \t\t  != TYPE_ALIGN (TREE_TYPE (arg1))))\n \t    return 0;\n@@ -2936,27 +2964,34 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n \tcase TARGET_MEM_REF:\n \tcase MEM_REF:\n-\t  /* Require equal access sizes, and similar pointer types.\n-\t     We can have incomplete types for array references of\n-\t     variable-sized arrays from the Fortran frontend\n-\t     though.  Also verify the types are compatible.  */\n-\t  if (!((TYPE_SIZE (TREE_TYPE (arg0)) == TYPE_SIZE (TREE_TYPE (arg1))\n-\t\t   || (TYPE_SIZE (TREE_TYPE (arg0))\n-\t\t       && TYPE_SIZE (TREE_TYPE (arg1))\n-\t\t       && operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),\n-\t\t\t\t\t   TYPE_SIZE (TREE_TYPE (arg1)), flags)))\n-\t\t  && types_compatible_p (TREE_TYPE (arg0), TREE_TYPE (arg1))\n-\t\t  && ((flags & OEP_ADDRESS_OF)\n-\t\t      || (alias_ptr_types_compatible_p\n-\t\t\t    (TREE_TYPE (TREE_OPERAND (arg0, 1)),\n-\t\t\t     TREE_TYPE (TREE_OPERAND (arg1, 1)))\n-\t\t\t  && (MR_DEPENDENCE_CLIQUE (arg0)\n-\t\t\t      == MR_DEPENDENCE_CLIQUE (arg1))\n-\t\t\t  && (MR_DEPENDENCE_BASE (arg0)\n-\t\t\t      == MR_DEPENDENCE_BASE (arg1))\n-\t\t\t  && (TYPE_ALIGN (TREE_TYPE (arg0))\n-\t\t\t    == TYPE_ALIGN (TREE_TYPE (arg1)))))))\n-\t    return 0;\n+\t  if (!(flags & (OEP_ADDRESS_OF | OEP_CONSTANT_ADDRESS_OF)))\n+\t    {\n+\t      /* Require equal access sizes */\n+\t      if (TYPE_SIZE (TREE_TYPE (arg0)) != TYPE_SIZE (TREE_TYPE (arg1))\n+\t\t  && (!TYPE_SIZE (TREE_TYPE (arg0))\n+\t\t      || !TYPE_SIZE (TREE_TYPE (arg1))\n+\t\t      || !operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),\n+\t\t\t\t\t   TYPE_SIZE (TREE_TYPE (arg1)),\n+\t\t\t\t\t   flags)))\n+\t\treturn 0;\n+\t      /* Verify that access happens in similar types.  */\n+\t      if (!types_compatible_p (TREE_TYPE (arg0), TREE_TYPE (arg1)))\n+\t\treturn 0;\n+\t      /* Verify that accesses are TBAA compatible.  */\n+\t      if (flag_strict_aliasing\n+\t\t  && (!alias_ptr_types_compatible_p\n+\t\t        (TREE_TYPE (TREE_OPERAND (arg0, 1)),\n+\t\t         TREE_TYPE (TREE_OPERAND (arg1, 1)))\n+\t\t      || (MR_DEPENDENCE_CLIQUE (arg0)\n+\t\t\t  != MR_DEPENDENCE_CLIQUE (arg1))\n+\t\t      || (MR_DEPENDENCE_BASE (arg0)\n+\t\t\t  != MR_DEPENDENCE_BASE (arg1))))\n+\t\treturn 0;\n+\t     /* Verify that alignment is compatible.  */\n+\t     if (TYPE_ALIGN (TREE_TYPE (arg0))\n+\t\t != TYPE_ALIGN (TREE_TYPE (arg1)))\n+\t\treturn 0;\n+\t    }\n \t  flags &= ~(OEP_CONSTANT_ADDRESS_OF|OEP_ADDRESS_OF);\n \t  return (OP_SAME (0) && OP_SAME (1)\n \t\t  /* TARGET_MEM_REF require equal extra operands.  */\n@@ -3002,6 +3037,10 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       switch (TREE_CODE (arg0))\n \t{\n \tcase ADDR_EXPR:\n+\t  /* Be sure we pass right ADDRESS_OF flag.  */\n+\t  gcc_checking_assert (!(flags\n+\t\t\t\t & (OEP_ADDRESS_OF\n+\t\t\t\t    | OEP_CONSTANT_ADDRESS_OF)));\n \t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t  TREE_OPERAND (arg1, 0),\n \t\t\t\t  flags | OEP_ADDRESS_OF);"}]}