{"sha": "ed3479983db246f3126c12c441659ef6b8ed027e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzNDc5OTgzZGIyNDZmMzEyNmMxMmM0NDE2NTllZjZiOGVkMDI3ZQ==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2004-08-28T00:45:56Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2004-08-28T00:45:56Z"}, "message": "configure.ac: Handle --enable-gc-debug.\n\n\t* configure.ac: Handle --enable-gc-debug.\n\t* configure: Regenerate.\n\t* include/config.h.in (LIBGCJ_GC_DEBUG): Add.\n\t* boehm.cc: Include gc_mark.h, javaxfc.h, but no GC private files.\n\tRearrange include file order.\n\t(GC_DEBUG): Set if LIBGCJ_GC_DEBUG is set.\n\t(GC_finalize_all, GC_debug_generic_malloc): Don't declare.\n\t(disable_gc_mutex): Delete along with all references.\n\t(_Jv_MarkObj, _Jv_MarkArray): Use public types,\n\tadjust for debug header size.\n\t(_Jv_AllocObj, _Jv_allocPtrFreeObj): Define out of line for\n\tdebug case.\n\t(_Jv_AllocArray): Declare min_heap_addr only if needed.\n\t(gcj_describe_type_fn): New.\n\t(_Jv_InitGC): Use GC_new_free_list, GC_new_proc, and GC_new_kind.\n\tRegister gcj_describe_type_fn.\n\t* include/boehm-gc.h:\n\t(_Jv_AllocObj, _Jv_allocPtrFreeObj):\n\tDon't define, but declare, for debug case.\n\t* java/lang/natObject.cc:\n\t(GC_DEBUG): Define if LIBGCJ_GC_DEBUG is set.\n\nFrom-SVN: r86686", "tree": {"sha": "3ffbf3d3e391be4b78a46bc6acfcb0fbb12af641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ffbf3d3e391be4b78a46bc6acfcb0fbb12af641"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed3479983db246f3126c12c441659ef6b8ed027e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3479983db246f3126c12c441659ef6b8ed027e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3479983db246f3126c12c441659ef6b8ed027e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3479983db246f3126c12c441659ef6b8ed027e/comments", "author": null, "committer": null, "parents": [{"sha": "3c1cbf58a609a29362ed15c322d588797f3f4cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c1cbf58a609a29362ed15c322d588797f3f4cc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c1cbf58a609a29362ed15c322d588797f3f4cc5"}], "stats": {"total": 296, "additions": 197, "deletions": 99}, "files": [{"sha": "fb67852b28ae18bec08cdd754fcd673aae1f1d90", "filename": "libjava/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ed3479983db246f3126c12c441659ef6b8ed027e", "patch": "@@ -1,3 +1,27 @@\n+2004-08-27  Hans Boehm  <Hans.Boehm@hp.com>\n+\n+\t* configure.ac: Handle --enable-gc-debug.\n+\t* configure: Regenerate.\n+\t* include/config.h.in (LIBGCJ_GC_DEBUG): Add.\n+\t* boehm.cc: Include gc_mark.h, javaxfc.h, but no GC private files.\n+\tRearrange include file order.\n+\t(GC_DEBUG): Set if LIBGCJ_GC_DEBUG is set.\n+\t(GC_finalize_all, GC_debug_generic_malloc): Don't declare.\n+\t(disable_gc_mutex): Delete along with all references.\n+\t(_Jv_MarkObj, _Jv_MarkArray): Use public types,\n+\tadjust for debug header size.\n+\t(_Jv_AllocObj, _Jv_allocPtrFreeObj): Define out of line for\n+\tdebug case.\n+\t(_Jv_AllocArray): Declare min_heap_addr only if needed.\n+\t(gcj_describe_type_fn): New.\n+\t(_Jv_InitGC): Use GC_new_free_list, GC_new_proc, and GC_new_kind.\n+\tRegister gcj_describe_type_fn.\n+\t* include/boehm-gc.h:\n+\t(_Jv_AllocObj, _Jv_allocPtrFreeObj):\n+\tDon't define, but declare, for debug case.\n+\t* java/lang/natObject.cc:\n+\t(GC_DEBUG): Define if LIBGCJ_GC_DEBUG is set.\n+\n 2004-08-26  Mark Wielaard  <mark@klomp.org>\n \n \tFixes PR libgcj/17002:"}, {"sha": "c2a93a57b047dfef3e8134468bb4af438ab02378", "filename": "libjava/boehm.cc", "status": "modified", "additions": 133, "deletions": 97, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=ed3479983db246f3126c12c441659ef6b8ed027e", "patch": "@@ -10,63 +10,58 @@ details.  */\n \n #include <config.h>\n \n-#include <stdio.h>\n-#include <limits.h>\n-\n-#include <jvm.h>\n-#include <gcj/cni.h>\n-\n-#include <java/lang/Class.h>\n-#include <java/lang/reflect/Modifier.h>\n-#include <java-interp.h>\n-\n-// More nastiness: the GC wants to define TRUE and FALSE.  We don't\n-// need the Java definitions (themselves a hack), so we undefine them.\n-#undef TRUE\n-#undef FALSE\n-\n extern \"C\"\n {\n-#include <private/gc_pmark.h>\n+#include <gc_config.h>\n+\n+// Set GC_DEBUG before including gc.h!\n+#ifdef LIBGCJ_GC_DEBUG\n+# define GC_DEBUG\n+#endif\n+\n+#include <gc_mark.h>\n #include <gc_gcj.h>\n+#include <javaxfc.h>  // GC_finalize_all declaration.  \n \n #ifdef THREAD_LOCAL_ALLOC\n # define GC_REDIRECT_TO_LOCAL\n # include <gc_local_alloc.h>\n #endif\n-\n-  // These aren't declared in any Boehm GC header.\n-  void GC_finalize_all (void);\n-  ptr_t GC_debug_generic_malloc (size_t size, int k, GC_EXTRA_PARAMS);\n };\n \n+#include <stdio.h>\n+#include <limits.h>\n+\n+#include <jvm.h>\n+#include <gcj/cni.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/reflect/Modifier.h>\n+#include <java-interp.h>\n+\n #define MAYBE_MARK(Obj, Top, Limit, Source, Exit)  \\\n \tTop=GC_MARK_AND_PUSH((GC_PTR)Obj, Top, Limit, (GC_PTR *)Source)\n \n // `kind' index used when allocating Java arrays.\n static int array_kind_x;\n \n // Freelist used for Java arrays.\n-static ptr_t *array_free_list;\n-\n-// Lock used to protect access to Boehm's GC_enable/GC_disable functions.\n-static _Jv_Mutex_t disable_gc_mutex;\n+static void * *array_free_list;\n \n \f\n \n // This is called by the GC during the mark phase.  It marks a Java\n // object.  We use `void *' arguments and return, and not what the\n // Boehm GC wants, to avoid pollution in our headers.\n void *\n-_Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n+_Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n {\n-  mse *mark_stack_ptr = (mse *) msp;\n-  mse *mark_stack_limit = (mse *) msl;\n-  jobject obj = (jobject) addr;\n+  struct GC_ms_entry *mark_stack_ptr = (struct GC_ms_entry *)msp;\n+  struct GC_ms_entry *mark_stack_limit = (struct GC_ms_entry *)msl;\n \n-  // FIXME: if env is 1, this object was allocated through the debug\n-  // interface, and addr points to the beginning of the debug header.\n-  // In that case, we should really add the size of the header to addr.\n+  if (env == (void *)1) /* Object allocated with debug allocator.\t*/\n+    addr = (GC_PTR)GC_USR_PTR_FROM_BASE(addr);\n+  jobject obj = (jobject) addr;\n \n   _Jv_VTable *dt = *(_Jv_VTable **) addr;\n   // The object might not yet have its vtable set, or it might\n@@ -78,15 +73,15 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n   if (__builtin_expect (! dt || !(dt -> get_finalizer()), false))\n     return mark_stack_ptr;\n   jclass klass = dt->clas;\n-  ptr_t p;\n+  GC_PTR p;\n \n # ifndef JV_HASH_SYNCHRONIZATION\n     // Every object has a sync_info pointer.\n-    p = (ptr_t) obj->sync_info;\n+    p = (GC_PTR) obj->sync_info;\n     MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj, o1label);\n # endif\n   // Mark the object's class.\n-  p = (ptr_t) klass;\n+  p = (GC_PTR) klass;\n   MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj, o2label);\n \n   if (__builtin_expect (klass == &java::lang::Class::class$, false))\n@@ -105,33 +100,33 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n       // of our root set.\t\t- HB\n       jclass c = (jclass) addr;\n \n-      p = (ptr_t) c->name;\n+      p = (GC_PTR) c->name;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c3label);\n-      p = (ptr_t) c->superclass;\n+      p = (GC_PTR) c->superclass;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c4label);\n       for (int i = 0; i < c->constants.size; ++i)\n \t{\n \t  /* FIXME: We could make this more precise by using the tags -KKT */\n-\t  p = (ptr_t) c->constants.data[i].p;\n+\t  p = (GC_PTR) c->constants.data[i].p;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5label);\n \t}\n \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))\n \t{\n-\t  p = (ptr_t) c->constants.tags;\n+\t  p = (GC_PTR) c->constants.tags;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5alabel);\n-\t  p = (ptr_t) c->constants.data;\n+\t  p = (GC_PTR) c->constants.data;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5blabel);\n-\t  p = (ptr_t) c->vtable;\n+\t  p = (GC_PTR) c->vtable;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5clabel);\n \t}\n #endif\n \n       // If the class is an array, then the methods field holds a\n       // pointer to the element class.  If the class is primitive,\n       // then the methods field holds a pointer to the array class.\n-      p = (ptr_t) c->methods;\n+      p = (GC_PTR) c->methods;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c6label);\n \n       // The vtable might have been set, but the rest of the class\n@@ -147,34 +142,34 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n \t  // points to a methods structure.\n \t  for (int i = 0; i < c->method_count; ++i)\n \t    {\n-\t      p = (ptr_t) c->methods[i].name;\n+\t      p = (GC_PTR) c->methods[i].name;\n \t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t     cm1label);\n-\t      p = (ptr_t) c->methods[i].signature;\n+\t      p = (GC_PTR) c->methods[i].signature;\n \t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t     cm2label);\n \t    }\n \t}\n \n       // Mark all the fields.\n-      p = (ptr_t) c->fields;\n+      p = (GC_PTR) c->fields;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8label);\n       for (int i = 0; i < c->field_count; ++i)\n \t{\n \t  _Jv_Field* field = &c->fields[i];\n \n #ifndef COMPACT_FIELDS\n-\t  p = (ptr_t) field->name;\n+\t  p = (GC_PTR) field->name;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8alabel);\n #endif\n-\t  p = (ptr_t) field->type;\n+\t  p = (GC_PTR) field->type;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8blabel);\n \n \t  // For the interpreter, we also need to mark the memory\n \t  // containing static members\n \t  if ((field->flags & java::lang::reflect::Modifier::STATIC))\n \t    {\n-\t      p = (ptr_t) field->u.addr;\n+\t      p = (GC_PTR) field->u.addr;\n \t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8clabel);\n \n \t      // also, if the static member is a reference,\n@@ -184,44 +179,44 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n \t      if (JvFieldIsRef (field) && field->isResolved()) \n \t\t{\n \t\t  jobject val = *(jobject*) field->u.addr;\n-\t\t  p = (ptr_t) val;\n+\t\t  p = (GC_PTR) val;\n \t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit,\n \t\t\t      c, c8elabel);\n \t\t}\n \t    }\n \t}\n \n-      p = (ptr_t) c->vtable;\n+      p = (GC_PTR) c->vtable;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c9label);\n-      p = (ptr_t) c->interfaces;\n+      p = (GC_PTR) c->interfaces;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cAlabel);\n       for (int i = 0; i < c->interface_count; ++i)\n \t{\n-\t  p = (ptr_t) c->interfaces[i];\n+\t  p = (GC_PTR) c->interfaces[i];\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cClabel);\n \t}\n-      p = (ptr_t) c->loader;\n+      p = (GC_PTR) c->loader;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cBlabel);\n-      p = (ptr_t) c->arrayclass;\n+      p = (GC_PTR) c->arrayclass;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cDlabel);\n-      p = (ptr_t) c->protectionDomain;\n+      p = (GC_PTR) c->protectionDomain;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cPlabel);\n-      p = (ptr_t) c->hack_signers;\n+      p = (GC_PTR) c->hack_signers;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cSlabel);\n-      p = (ptr_t) c->aux_info;\n+      p = (GC_PTR) c->aux_info;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cTlabel);\n \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))\n \t{\n \t  _Jv_InterpClass* ic = (_Jv_InterpClass*) c->aux_info;\n \n-\t  p = (ptr_t) ic->interpreted_methods;\n+\t  p = (GC_PTR) ic->interpreted_methods;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cElabel);\n \n \t  for (int i = 0; i < c->method_count; i++)\n \t    {\n-\t      p = (ptr_t) ic->interpreted_methods[i];\n+\t      p = (GC_PTR) ic->interpreted_methods[i];\n \t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, \\\n \t\t\t  cFlabel);\n \n@@ -233,20 +228,20 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n \t\t    = (_Jv_InterpMethod *) ic->interpreted_methods[i];\n \t\t  if (im)\n \t\t    {\n-\t\t      p = (ptr_t) im->prepared;\n+\t\t      p = (GC_PTR) im->prepared;\n \t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, \\\n \t\t\t\t  cFlabel);\n \t\t    }\n \t\t}\n \n \t      // The interpreter installs a heap-allocated trampoline\n \t      // here, so we'll mark it.\n-\t      p = (ptr_t) c->methods[i].ncode;\n+\t      p = (GC_PTR) c->methods[i].ncode;\n \t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t  cm3label);\n \t    }\n \n-\t  p = (ptr_t) ic->field_initializers;\n+\t  p = (GC_PTR) ic->field_initializers;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cGlabel);\n \t  \n \t}\n@@ -273,7 +268,7 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n \t      if (JvFieldIsRef (field))\n \t\t{\n \t\t  jobject val = JvGetObjectField (obj, field);\n-\t\t  p = (ptr_t) val;\n+\t\t  p = (GC_PTR) val;\n \t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit,\n \t\t\t      obj, elabel);\n \t\t}\n@@ -290,10 +285,13 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n // array (of objects).  We use `void *' arguments and return, and not\n // what the Boehm GC wants, to avoid pollution in our headers.\n void *\n-_Jv_MarkArray (void *addr, void *msp, void *msl, void * /*env*/)\n+_Jv_MarkArray (void *addr, void *msp, void *msl, void * env)\n {\n-  mse *mark_stack_ptr = (mse *) msp;\n-  mse *mark_stack_limit = (mse *) msl;\n+  struct GC_ms_entry *mark_stack_ptr = (struct GC_ms_entry *)msp;\n+  struct GC_ms_entry *mark_stack_limit = (struct GC_ms_entry *)msl;\n+\n+  if (env == (void *)1) /* Object allocated with debug allocator.\t*/\n+    addr = (void *)GC_USR_PTR_FROM_BASE(addr);\n   jobjectArray array = (jobjectArray) addr;\n \n   _Jv_VTable *dt = *(_Jv_VTable **) addr;\n@@ -303,21 +301,21 @@ _Jv_MarkArray (void *addr, void *msp, void *msl, void * /*env*/)\n   if (__builtin_expect (! dt || !(dt -> get_finalizer()), false))\n     return mark_stack_ptr;\n   jclass klass = dt->clas;\n-  ptr_t p;\n+  GC_PTR p;\n \n # ifndef JV_HASH_SYNCHRONIZATION\n     // Every object has a sync_info pointer.\n-    p = (ptr_t) array->sync_info;\n+    p = (GC_PTR) array->sync_info;\n     MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array, e1label);\n # endif\n   // Mark the object's class.\n-  p = (ptr_t) klass;\n+  p = (GC_PTR) klass;\n   MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, &(dt -> clas), o2label);\n \n   for (int i = 0; i < JvGetArrayLength (array); ++i)\n     {\n       jobject obj = elements (array)[i];\n-      p = (ptr_t) obj;\n+      p = (GC_PTR) obj;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array, e2label);\n     }\n \n@@ -366,7 +364,7 @@ _Jv_BuildGCDescr(jclass self)\n \t      // If we find a field outside the range of our bitmap,\n \t      // fall back to procedure marker. The bottom 2 bits are\n \t      // reserved.\n-\t      if (off >= bits_per_word - 2)\n+\t      if (off >= (unsigned)bits_per_word - 2)\n \t\treturn (void *) (GCJ_DEFAULT_DESCR);\n \t      desc |= 1ULL << (bits_per_word - off - 1);\n \t    }\n@@ -394,25 +392,51 @@ _Jv_AllocBytes (jsize size)\n   return r;\n }\n \n+#ifdef LIBGCJ_GC_DEBUG\n+\n+void *\n+_Jv_AllocObj (jsize size, jclass klass)\n+{\n+  return GC_GCJ_MALLOC (size, klass->vtable);\n+}\n+\n+void *\n+_Jv_AllocPtrFreeObj (jsize size, jclass klass)\n+{\n+#ifdef JV_HASH_SYNCHRONIZATION\n+  void * obj = GC_MALLOC_ATOMIC(size);\n+  *((_Jv_VTable **) obj) = klass->vtable;\n+#else\n+  void * obj = GC_GCJ_MALLOC(size, klass->vtable);\n+#endif\n+  return obj;\n+}\n+\n+#endif /* LIBGCJ_GC_DEBUG */\n+// In the non-debug case, the above two functions are defined\n+// as inline functions in boehm-gc.h.  In the debug case we\n+// really want to take advantage of the definitions in gc_gcj.h.\n+\n // Allocate space for a new Java array.\n // Used only for arrays of objects.\n void *\n _Jv_AllocArray (jsize size, jclass klass)\n {\n   void *obj;\n+\n+#ifdef LIBGCJ_GC_DEBUG\n+  // There isn't much to lose by scanning this conservatively.\n+  // If we didn't, the mark proc would have to understand that\n+  // it needed to skip the header.\n+  obj = GC_MALLOC(size);\n+#else\n   const jsize min_heap_addr = 16*1024;\n   // A heuristic.  If size is less than this value, the size\n   // stored in the array can't possibly be misinterpreted as\n   // a pointer.   Thus we lose nothing by scanning the object\n   // completely conservatively, since no misidentification can\n   // take place.\n   \n-#ifdef GC_DEBUG\n-  // There isn't much to lose by scanning this conservatively.\n-  // If we didn't, the mark proc would have to understand that\n-  // it needed to skip the header.\n-  obj = GC_MALLOC(size);\n-#else\n   if (size < min_heap_addr) \n     obj = GC_MALLOC(size);\n   else \n@@ -497,24 +521,43 @@ extern \"C\" void GC_disable();\n void\n _Jv_DisableGC (void)\n {\n-  _Jv_MutexLock (&disable_gc_mutex); \n   GC_disable();\n-  _Jv_MutexUnlock (&disable_gc_mutex); \n }\n \n void\n _Jv_EnableGC (void)\n {\n-  _Jv_MutexLock (&disable_gc_mutex); \n   GC_enable();\n-  _Jv_MutexUnlock (&disable_gc_mutex); \n }\n \n static void * handle_out_of_memory(size_t)\n {\n   _Jv_ThrowNoMemory();\n }\n \n+static void\n+gcj_describe_type_fn(void *obj, char *out_buf)\n+{\n+  _Jv_VTable *dt = *(_Jv_VTable **) obj;\n+\n+  if (! dt /* Shouldn't happen */)\n+    {\n+      strcpy(out_buf, \"GCJ (bad)\");\n+      return;\n+    }\n+  jclass klass = dt->clas;\n+  if (!klass /* shouldn't happen */)\n+    {\n+      strcpy(out_buf, \"GCJ (bad)\");\n+      return;\n+    }\n+  jstring name = klass -> getName();\n+  size_t len = name -> length();\n+  if (len >= GC_TYPE_DESCR_LEN) len = GC_TYPE_DESCR_LEN - 1;\n+  JvGetStringUTFRegion (name, 0, len, out_buf);\n+  out_buf[len] = '\\0';\n+}\n+\n void\n _Jv_InitGC (void)\n {\n@@ -525,6 +568,8 @@ _Jv_InitGC (void)\n \n   // Configure the collector to use the bitmap marking descriptors that we\n   // stash in the class vtable.\n+  // We always use mark proc descriptor 0, since the compiler knows\n+  // about it.\n   GC_init_gcj_malloc (0, (void *) _Jv_MarkObj);  \n \n   // Cause an out of memory error to be thrown from the allocators,\n@@ -535,23 +580,14 @@ _Jv_InitGC (void)\n \n   // We use a different mark procedure for object arrays. This code \n   // configures a different object `kind' for object array allocation and\n-  // marking. FIXME: see above.\n-  array_free_list = (ptr_t *) GC_generic_malloc_inner ((MAXOBJSZ + 1)\n-\t\t\t\t\t\t       * sizeof (ptr_t),\n-\t\t\t\t\t\t       PTRFREE);\n-  memset (array_free_list, 0, (MAXOBJSZ + 1) * sizeof (ptr_t));\n-\n-  proc = GC_n_mark_procs++;\n-  GC_mark_procs[proc] = (GC_mark_proc) _Jv_MarkArray;\n-\n-  array_kind_x = GC_n_kinds++;\n-  GC_obj_kinds[array_kind_x].ok_freelist = array_free_list;\n-  GC_obj_kinds[array_kind_x].ok_reclaim_list = 0;\n-  GC_obj_kinds[array_kind_x].ok_descriptor = GC_MAKE_PROC (proc, 0);\n-  GC_obj_kinds[array_kind_x].ok_relocate_descr = FALSE;\n-  GC_obj_kinds[array_kind_x].ok_init = TRUE;\n-\n-  _Jv_MutexInit (&disable_gc_mutex);\n+  // marking.\n+  array_free_list = GC_new_free_list();\n+  proc = GC_new_proc((GC_mark_proc)_Jv_MarkArray);\n+  array_kind_x = GC_new_kind(array_free_list, GC_MAKE_PROC (proc, 0), 0, 1);\n+\n+  /* Arrange to have the GC print Java class names in backtraces, etc. \t*/\n+  GC_register_describe_type_fn(GC_gcj_kind, gcj_describe_type_fn);\n+  GC_register_describe_type_fn(GC_gcj_debug_kind, gcj_describe_type_fn);\n }\n \n #ifdef JV_HASH_SYNCHRONIZATION"}, {"sha": "cd6dc283b84217b8c36aef1e7156889ab6a79b96", "filename": "libjava/configure", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=ed3479983db246f3126c12c441659ef6b8ed027e", "patch": "@@ -869,6 +869,7 @@ Optional Features:\n                  allow compilation of several files at once\n \n   --enable-libgcj-debug   enable runtime debugging code\n+  --enable-gc-debug\tinclude full support for pointer backtracing etc.\n   --enable-interpreter    enable interpreter\n   --enable-sjlj-exceptions\n                           force use of builtin_setjmp for exceptions\n@@ -4735,7 +4736,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 4738 \"configure\"' > conftest.$ac_ext\n+  echo '#line 4739 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -5716,6 +5717,18 @@ _ACEOF\n   fi\n fi;\n \n+# Check for gc debugging.  This option is handled both here and in the GC.\n+# Check whether --enable-gc-debug or --disable-gc-debug was given.\n+if test \"${enable_gc_debug+set}\" = set; then\n+  enableval=\"$enable_gc_debug\"\n+   if test \"$enable_gc_debug\" = \"yes\"; then\n+    cat >>confdefs.h <<\\_ACEOF\n+#define LIBGCJ_GC_DEBUG 1\n+_ACEOF\n+\n+  fi\n+fi;\n+\n # See if the user has the interpreter included.\n # Check whether --enable-interpreter or --disable-interpreter was given.\n if test \"${enable_interpreter+set}\" = set; then\n@@ -5752,7 +5765,7 @@ if test \"${enable_sjlj_exceptions+set}\" = set; then\n   :\n else\n   cat > conftest.$ac_ext << EOF\n-#line 5755 \"configure\"\n+#line 5768 \"configure\"\n struct S { ~S(); };\n void bar();\n void foo()"}, {"sha": "72f254997bc0d091a0e197da2de7aca0e97b85e2", "filename": "libjava/configure.ac", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=ed3479983db246f3126c12c441659ef6b8ed027e", "patch": "@@ -253,6 +253,13 @@ AC_ARG_ENABLE(libgcj-debug,\n     LIBGCJDEBUG=\"true\"\n   fi])\n \n+# Check for gc debugging.  This option is handled both here and in the GC.\n+AC_ARG_ENABLE(gc-debug,\n+[  --enable-gc-debug\tinclude full support for pointer backtracing etc.],\n+[ if test \"$enable_gc_debug\" = \"yes\"; then\n+    AC_DEFINE(LIBGCJ_GC_DEBUG)\n+  fi])\n+\n # See if the user has the interpreter included.\n AC_ARG_ENABLE(interpreter,\n   AS_HELP_STRING([--enable-interpreter],"}, {"sha": "fa2623b37e17d17424c6733256bb765bd118e31c", "filename": "libjava/include/boehm-gc.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Finclude%2Fboehm-gc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Finclude%2Fboehm-gc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fboehm-gc.h?ref=ed3479983db246f3126c12c441659ef6b8ed027e", "patch": "@@ -35,6 +35,8 @@ extern \"C\" void * GC_local_gcj_malloc(size_t, void *);\n extern \"C\" void * GC_local_malloc_atomic(size_t);\n #endif\n \n+#ifndef LIBGCJ_GC_DEBUG\n+\n inline void *\n _Jv_AllocObj (jsize size, jclass klass)\n {\n@@ -67,6 +69,16 @@ _Jv_AllocPtrFreeObj (jsize size, jclass klass)\n   return obj;\n }\n \n+#else /* LIBGCJ_GC_DEBUG */\n+\n+void *\n+_Jv_AllocObj (jsize size, jclass klass);\n+\n+void *\n+_Jv_AllocPtrFreeObj (jsize size, jclass klass);\n+\n+#endif /* LIBGCJ_GC_DEBUG */\n+\n // _Jv_AllocBytes (jsize size) should go here, too.  But clients don't\n // usually include this header.\n "}, {"sha": "0429517ac1eb72ad66f7c6f2e44192cdb518d0a0", "filename": "libjava/include/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=ed3479983db246f3126c12c441659ef6b8ed027e", "patch": "@@ -366,6 +366,9 @@\n /* Indicate that linker is not able to 8-byte align static data */\n #undef JV_LINKER_CANNOT_8BYTE_ALIGN_STATICS\n \n+/* Define if we want to use debug calls into the garbage collector. */\n+#undef LIBGCJ_GC_DEBUG\n+\n /* Define if using POSIX threads on Linux. */\n #undef LINUX_THREADS\n "}, {"sha": "7dff626cd8510402709172faa190039c2e07cdbf", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3479983db246f3126c12c441659ef6b8ed027e/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=ed3479983db246f3126c12c441659ef6b8ed027e", "patch": "@@ -286,6 +286,9 @@ _Jv_ObjectCheckMonitor (jobject obj)\n // operations is already ridiculous, and would become worse if we\n // went through the proper intermediaries.\n #else\n+# ifdef LIBGCJ_GC_DEBUG\n+#   define GC_DEBUG\n+# endif\n # include \"gc.h\"\n #endif\n "}]}