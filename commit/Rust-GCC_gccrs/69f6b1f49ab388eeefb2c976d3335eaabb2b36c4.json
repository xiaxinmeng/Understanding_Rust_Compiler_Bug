{"sha": "69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlmNmIxZjQ5YWIzODhlZWVmYjJjOTc2ZDMzMzVlYWFiYjJiMzZjNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-24T21:51:08Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-03-24T21:51:08Z"}, "message": "IPA ICF: enhance hash value calculated in TU\n\n\t* ipa-icf-gimple.h (return_with_result): Add missing colon to dump.\n\t* ipa-icf.c (sem_function::get_hash): Hash new declaration properties.\n\t(sem_item::add_type): New function.\n\t(sem_function::hash_stmt): Add TREE_TYPE of gimple_op.\n\t(sem_function::compare_polymorphic_p): Do not consider indirect calls.\n\t(sem_item_optimizer::update_hash_by_addr_refs): Add ODR type to hash.\n\t(sem_function::equals_wpa): Fix typo.\n\t* ipa-icf.h (sem_item::add_type): New function.\n\t(symbol_compare_hashmap_traits): Replace hashing of pointer with symbol\n\torder.\n\n\nCo-Authored-By: Martin Liska <mliska@suse.cz>\n\nFrom-SVN: r221645", "tree": {"sha": "606cbcfb4ebd88b0c41d37f545be4e2790c50e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/606cbcfb4ebd88b0c41d37f545be4e2790c50e36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/comments", "author": null, "committer": null, "parents": [{"sha": "e93870c12bbd5843b93447646c631eb8d6d99a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93870c12bbd5843b93447646c631eb8d6d99a9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93870c12bbd5843b93447646c631eb8d6d99a9a"}], "stats": {"total": 186, "additions": 168, "deletions": 18}, "files": [{"sha": "538931eb9adc45df8540c804329567c6ec52b547", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "patch": "@@ -1,3 +1,17 @@\n+2015-03-24  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf-gimple.h (return_with_result): Add missing colon to dump.\n+\t* ipa-icf.c (sem_function::get_hash): Hash new declaration properties.\n+\t(sem_item::add_type): New function.\n+\t(sem_function::hash_stmt): Add TREE_TYPE of gimple_op.\n+\t(sem_function::compare_polymorphic_p): Do not consider indirect calls.\n+\t(sem_item_optimizer::update_hash_by_addr_refs): Add ODR type to hash.\n+\t(sem_function::equals_wpa): Fix typo.\n+\t* ipa-icf.h (sem_item::add_type): New function.\n+\t(symbol_compare_hashmap_traits): Replace hashing of pointer with symbol\n+\torder.\n+\n 2015-03-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/65533"}, {"sha": "6a9cbed5ff49475543ecdafe0dcc1a6399188c58", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "patch": "@@ -75,7 +75,7 @@ static inline bool\n return_with_result (bool result, const char *func, unsigned int line)\n {\n   if (!result && dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"  false returned (%s:%u)\\n\", func, line);\n+    fprintf (dump_file, \"  false returned: (%s:%u)\\n\", func, line);\n \n   return result;\n }"}, {"sha": "ad868e10c0487a84daba607da7932b1f93886bce", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 146, "deletions": 14, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "patch": "@@ -128,6 +128,11 @@ using namespace ipa_icf_gimple;\n \n namespace ipa_icf {\n \n+/* Initialization and computation of symtab node hash, there data\n+   are propagated later on.  */\n+\n+static sem_item_optimizer *optimizer = NULL;\n+\n /* Constructor.  */\n \n symbol_compare_collection::symbol_compare_collection (symtab_node *node)\n@@ -328,6 +333,21 @@ sem_function::get_hash (void)\n       for (unsigned i = 0; i < bb_sizes.length (); i++)\n \thstate.add_int (bb_sizes[i]);\n \n+\n+      /* Add common features of declaration itself.  */\n+      if (DECL_FUNCTION_SPECIFIC_TARGET (decl))\n+        hstate.add_wide_int\n+\t (cl_target_option_hash\n+\t   (TREE_TARGET_OPTION (DECL_FUNCTION_SPECIFIC_TARGET (decl))));\n+      if (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl))\n+\t (cl_optimization_hash\n+\t   (TREE_OPTIMIZATION (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl))));\n+      hstate.add_flag (DECL_DISREGARD_INLINE_LIMITS (decl));\n+      hstate.add_flag (DECL_DECLARED_INLINE_P (decl));\n+      hstate.add_flag (DECL_IS_OPERATOR_NEW (decl));\n+      hstate.add_flag (DECL_CXX_CONSTRUCTOR_P (decl));\n+      hstate.add_flag (DECL_CXX_DESTRUCTOR_P (decl));\n+\n       hash = hstate.end ();\n     }\n \n@@ -430,10 +450,10 @@ sem_function::equals_wpa (sem_item *item,\n     return return_false_with_msg (\"no stack limit attributes are different\");\n \n   if (DECL_CXX_CONSTRUCTOR_P (decl) != DECL_CXX_CONSTRUCTOR_P (item->decl))\n-    return return_false_with_msg (\"DELC_CXX_CONSTRUCTOR mismatch\");\n+    return return_false_with_msg (\"DECL_CXX_CONSTRUCTOR mismatch\");\n \n   if (DECL_CXX_DESTRUCTOR_P (decl) != DECL_CXX_DESTRUCTOR_P (item->decl))\n-    return return_false_with_msg (\"DELC_CXX_DESTRUCTOR mismatch\");\n+    return return_false_with_msg (\"DECL_CXX_DESTRUCTOR mismatch\");\n \n   if (flags_from_decl_or_type (decl) != flags_from_decl_or_type (item->decl))\n     return return_false_with_msg (\"decl_or_type flags are different\");\n@@ -1283,6 +1303,80 @@ sem_item::add_expr (const_tree exp, inchash::hash &hstate)\n     }\n }\n \n+/* Accumulate to HSTATE a hash of type t.\n+   TYpes that may end up being compatible after LTO type merging needs to have\n+   the same hash.  */\n+\n+void\n+sem_item::add_type (const_tree type, inchash::hash &hstate)\n+{\n+  if (type == NULL_TREE)\n+    {\n+      hstate.merge_hash (0);\n+      return;\n+    }\n+\n+  type = TYPE_MAIN_VARIANT (type);\n+  if (TYPE_CANONICAL (type))\n+    type = TYPE_CANONICAL (type);\n+\n+  if (!AGGREGATE_TYPE_P (type))\n+    hstate.add_int (TYPE_MODE (type));\n+\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      hstate.add_int (COMPLEX_TYPE);\n+      sem_item::add_type (TREE_TYPE (type), hstate);\n+    }\n+  else if (INTEGRAL_TYPE_P (type))\n+    {\n+      hstate.add_int (INTEGER_TYPE);\n+      hstate.add_flag (TYPE_UNSIGNED (type));\n+      hstate.add_int (TYPE_PRECISION (type));\n+    }\n+  else if (VECTOR_TYPE_P (type))\n+    {\n+      hstate.add_int (VECTOR_TYPE);\n+      hstate.add_int (TYPE_PRECISION (type));\n+      sem_item::add_type (TREE_TYPE (type), hstate);\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      hstate.add_int (ARRAY_TYPE);\n+      /* Do not hash size, so complete and incomplete types can match.  */\n+      sem_item::add_type (TREE_TYPE (type), hstate);\n+    }\n+  else if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      hashval_t *val = optimizer->m_type_hash_cache.get (type);\n+\n+      if (!val)\n+\t{\n+\t  inchash::hash hstate2;\n+\t  unsigned nf;\n+\t  tree f;\n+\t  hashval_t hash;\n+\n+\t  hstate2.add_int (RECORD_TYPE);\n+\t  gcc_assert (COMPLETE_TYPE_P (type));\n+\n+\t  for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n+\t    if (TREE_CODE (f) == FIELD_DECL)\n+\t      {\n+\t\tadd_type (TREE_TYPE (f), hstate2);\n+\t\tnf++;\n+\t      }\n+\n+\t  hstate2.add_int (nf);\n+\t  hash = hstate2.end ();\n+\t  hstate.add_wide_int (hash);\n+\t  optimizer->m_type_hash_cache.put (type, hash);\n+\t}\n+      else\n+        hstate.add_wide_int (*val);\n+    }\n+}\n+\n /* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n \n void\n@@ -1294,16 +1388,27 @@ sem_function::hash_stmt (gimple stmt, inchash::hash &hstate)\n \n   switch (code)\n     {\n+    case GIMPLE_SWITCH:\n+      add_expr (gimple_switch_index (as_a <gswitch *> (stmt)), hstate);\n+      break;\n     case GIMPLE_ASSIGN:\n+      hstate.add_int (gimple_assign_rhs_code (stmt));\n       if (commutative_tree_code (gimple_assign_rhs_code (stmt))\n \t  || commutative_ternary_tree_code (gimple_assign_rhs_code (stmt)))\n \t{\n \t  inchash::hash one, two;\n \n \t  add_expr (gimple_assign_rhs1 (stmt), one);\n+\t  add_type (TREE_TYPE (gimple_assign_rhs1 (stmt)), one);\n \t  add_expr (gimple_assign_rhs2 (stmt), two);\n \t  hstate.add_commutative (one, two);\n+\t  if (commutative_ternary_tree_code (gimple_assign_rhs_code (stmt)))\n+\t    {\n+\t      add_expr (gimple_assign_rhs3 (stmt), hstate);\n+\t      add_type (TREE_TYPE (gimple_assign_rhs3 (stmt)), hstate);\n+\t    }\n \t  add_expr (gimple_assign_lhs (stmt), hstate);\n+\t  add_type (TREE_TYPE (gimple_assign_lhs (stmt)), two);\n \t  break;\n \t}\n       /* ... fall through ... */\n@@ -1314,7 +1419,11 @@ sem_function::hash_stmt (gimple stmt, inchash::hash &hstate)\n     case GIMPLE_RETURN:\n       /* All these statements are equivalent if their operands are.  */\n       for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n-\tadd_expr (gimple_op (stmt, i), hstate);\n+\t{\n+\t  add_expr (gimple_op (stmt, i), hstate);\n+\t  if (gimple_op (stmt, i))\n+\t    add_type (TREE_TYPE (gimple_op (stmt, i)), hstate);\n+\t}\n     default:\n       break;\n     }\n@@ -1328,14 +1437,13 @@ sem_function::compare_polymorphic_p (void)\n {\n   struct cgraph_edge *e;\n \n-  if (!opt_for_fn (decl, flag_devirtualize))\n+  if (!opt_for_fn (get_node ()->decl, flag_devirtualize))\n     return false;\n-  if (get_node ()->indirect_calls != NULL\n-      || m_compared_func->get_node ()->indirect_calls != NULL)\n+  if (get_node ()->indirect_calls != NULL)\n     return true;\n   /* TODO: We can do simple propagation determining what calls may lead to\n      a polymorphic call.  */\n-  for (e = m_compared_func->get_node ()->callees; e; e = e->next_callee)\n+  for (e = get_node ()->callees; e; e = e->next_callee)\n     if (e->callee->definition\n \t&& opt_for_fn (e->callee->decl, flag_devirtualize))\n       return true;\n@@ -2386,9 +2494,38 @@ sem_item_optimizer::add_item_to_class (congruence_class *cls, sem_item *item)\n void\n sem_item_optimizer::update_hash_by_addr_refs ()\n {\n-  /* First, append to hash sensitive references.  */\n+  /* First, append to hash sensitive references and class type if it need to\n+     be matched for ODR.  */\n   for (unsigned i = 0; i < m_items.length (); i++)\n-    m_items[i]->update_hash_by_addr_refs (m_symtab_node_map);\n+    {\n+      m_items[i]->update_hash_by_addr_refs (m_symtab_node_map);\n+      if (m_items[i]->type == FUNC)\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (m_items[i]->decl)) == METHOD_TYPE\n+\t      && contains_polymorphic_type_p\n+\t\t   (method_class_type (TREE_TYPE (m_items[i]->decl)))\n+\t      && (DECL_CXX_CONSTRUCTOR_P (m_items[i]->decl)\n+\t\t  || ((!flag_ipa_cp\n+\t\t       || ipa_is_param_used (\n+\t\t\t    IPA_NODE_REF\n+\t\t\t      (dyn_cast <cgraph_node *>(m_items[i]->node)), 0))\n+\t\t      && static_cast<sem_function *> (m_items[i])\n+\t\t\t   ->compare_polymorphic_p ())))\n+\t     {\n+\t        tree class_type\n+\t\t  = method_class_type (TREE_TYPE (m_items[i]->decl));\n+\t\tinchash::hash hstate (m_items[i]->hash);\n+\n+\t\tif (TYPE_NAME (class_type)\n+\t\t     && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (class_type)))\n+\t\t  hstate.add_wide_int\n+\t\t    (IDENTIFIER_HASH_VALUE\n+\t\t       (DECL_ASSEMBLER_NAME (TYPE_NAME (class_type))));\n+\n+\t\tm_items[i]->hash = hstate.end ();\n+\t     }\n+\t}\n+    }\n \n   /* Once all symbols have enhanced hash value, we can append\n      hash values of symbols that are seen by IPA ICF and are\n@@ -3123,11 +3260,6 @@ congruence_class::is_class_used (void)\n   return false;\n }\n \n-/* Initialization and computation of symtab node hash, there data\n-   are propagated later on.  */\n-\n-static sem_item_optimizer *optimizer = NULL;\n-\n /* Generate pass summary for IPA ICF pass.  */\n \n static void"}, {"sha": "7eb9f27cb2f462b0a5aa81b293ecc6f22aaa1a65", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f6b1f49ab388eeefb2c976d3335eaabb2b36c4/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=69f6b1f49ab388eeefb2c976d3335eaabb2b36c4", "patch": "@@ -96,12 +96,12 @@ struct symbol_compare_hashmap_traits: default_hashmap_traits\n     hstate.add_int (v->m_references.length ());\n \n     for (unsigned i = 0; i < v->m_references.length (); i++)\n-      hstate.add_ptr (v->m_references[i]->ultimate_alias_target ());\n+      hstate.add_int (v->m_references[i]->ultimate_alias_target ()->order);\n \n     hstate.add_int (v->m_interposables.length ());\n \n     for (unsigned i = 0; i < v->m_interposables.length (); i++)\n-      hstate.add_ptr (v->m_interposables[i]->ultimate_alias_target ());\n+      hstate.add_int (v->m_interposables[i]->ultimate_alias_target ()->order);\n \n     return hstate.end ();\n   }\n@@ -243,8 +243,10 @@ class sem_item\n protected:\n   /* Cached, once calculated hash for the item.  */\n \n-  /* Accumulate to HSTATE a hash of constructor expression EXP.  */\n+  /* Accumulate to HSTATE a hash of expression EXP.  */\n   static void add_expr (const_tree exp, inchash::hash &hstate);\n+  /* Accumulate to HSTATE a hash of type T.  */\n+  static void add_type (const_tree t, inchash::hash &hstate);\n \n   /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n      point to a same function. Comparison can be skipped if IGNORED_NODES\n@@ -505,6 +507,8 @@ class sem_item_optimizer\n   congruence_class_group *get_group_by_hash (hashval_t hash,\n       sem_item_type type);\n \n+  /* Because types can be arbitrarily large, avoid quadratic bottleneck.  */\n+  hash_map<const_tree, hashval_t> m_type_hash_cache;\n private:\n \n   /* For each semantic item, append hash values of references.  */"}]}