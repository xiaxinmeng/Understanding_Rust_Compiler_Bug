{"sha": "6300156042c8ea54f146abe9a7deb9c7ebdef655", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwMDE1NjA0MmM4ZWE1NGYxNDZhYmU5YTdkZWI5YzdlYmRlZjY1NQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-09-27T06:25:55Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-27T06:25:55Z"}, "message": "i386.h (CLASS_MAX_NREGS): Also handle XCmode.\n\n\t* config/i386/i386.h (CLASS_MAX_NREGS): Also handle XCmode.\n\t(UNITS_PER_WORD): Define only when IN_LIBGCC2 is undefined.\n\t(MOVE_MAX_PIECES): Redefine using UNITS_PER_WORD.\n\t(ASM_OUTPUT_AVX_PREFIX): Simplify pointer addition.\n\nFrom-SVN: r164644", "tree": {"sha": "aa6b55c28bbddcb1095807cb64a078ee08bd4e53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa6b55c28bbddcb1095807cb64a078ee08bd4e53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6300156042c8ea54f146abe9a7deb9c7ebdef655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6300156042c8ea54f146abe9a7deb9c7ebdef655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6300156042c8ea54f146abe9a7deb9c7ebdef655", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6300156042c8ea54f146abe9a7deb9c7ebdef655/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2acaab23d31c9e7fdfe1da06adcc5b8654a624bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2acaab23d31c9e7fdfe1da06adcc5b8654a624bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2acaab23d31c9e7fdfe1da06adcc5b8654a624bf"}], "stats": {"total": 55, "additions": 29, "deletions": 26}, "files": [{"sha": "3128865f72f744656f286ed15cc925115f9986ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6300156042c8ea54f146abe9a7deb9c7ebdef655/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6300156042c8ea54f146abe9a7deb9c7ebdef655/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6300156042c8ea54f146abe9a7deb9c7ebdef655", "patch": "@@ -1,3 +1,10 @@\n+2010-09-27  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (CLASS_MAX_NREGS): Also handle XCmode.\n+\t(UNITS_PER_WORD): Define only when IN_LIBGCC2 is undefined.\n+\t(MOVE_MAX_PIECES): Redefine using UNITS_PER_WORD.\n+\t(ASM_OUTPUT_AVX_PREFIX): Simplify pointer addition.\n+\n 2010-09-26  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (pro_epilogue_adjust_stack_<mode>_add): Merge"}, {"sha": "627d8d20ea09f9075d5b9deed137dc8b31c64745", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6300156042c8ea54f146abe9a7deb9c7ebdef655/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6300156042c8ea54f146abe9a7deb9c7ebdef655/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6300156042c8ea54f146abe9a7deb9c7ebdef655", "patch": "@@ -8777,11 +8777,9 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n   rtx insn;\n \n   if (! TARGET_64BIT)\n-    insn = emit_insn (gen_pro_epilogue_adjust_stack_si_add (dest,\n-\t\t\t\t\t\t\t    src, offset));\n+    insn = gen_pro_epilogue_adjust_stack_si_add (dest, src, offset);\n   else if (x86_64_immediate_operand (offset, DImode))\n-    insn = emit_insn (gen_pro_epilogue_adjust_stack_di_add (dest,\n-\t\t\t\t\t\t\t    src, offset));\n+    insn = gen_pro_epilogue_adjust_stack_di_add (dest, src, offset);\n   else\n     {\n       rtx tmp;\n@@ -8798,9 +8796,11 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n       insn = emit_insn (gen_rtx_SET (DImode, tmp, offset));\n       if (style < 0)\n \tRTX_FRAME_RELATED_P (insn) = 1;\n-      insn = emit_insn (gen_pro_epilogue_adjust_stack_di_add (dest, src, tmp));\n+\n+      insn = gen_pro_epilogue_adjust_stack_di_add (dest, src, tmp);\n     }\n \n+  insn = emit_insn (insn);\n   if (style >= 0)\n     ix86_add_queued_cfa_restore_notes (insn);\n "}, {"sha": "b3439bc9f0c47384cd3d11af3b105c135f7c0abf", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6300156042c8ea54f146abe9a7deb9c7ebdef655/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6300156042c8ea54f146abe9a7deb9c7ebdef655/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6300156042c8ea54f146abe9a7deb9c7ebdef655", "patch": "@@ -674,9 +674,8 @@ enum target_cpu_default\n \n /* Width of a word, in units (bytes).  */\n #define UNITS_PER_WORD\t\t(TARGET_64BIT ? 8 : 4)\n-#ifdef IN_LIBGCC2\n-#define MIN_UNITS_PER_WORD\t(TARGET_64BIT ? 8 : 4)\n-#else\n+\n+#ifndef IN_LIBGCC2\n #define MIN_UNITS_PER_WORD\t4\n #endif\n \n@@ -863,8 +862,8 @@ enum target_cpu_default\n #define STACK_REGS\n \n #define IS_STACK_MODE(MODE)\t\t\t\t\t\\\n-  (((MODE) == SFmode && (!TARGET_SSE || !TARGET_SSE_MATH))\t\\\n-   || ((MODE) == DFmode && (!TARGET_SSE2 || !TARGET_SSE_MATH))  \\\n+  (((MODE) == SFmode && !(TARGET_SSE && TARGET_SSE_MATH))\t\\\n+   || ((MODE) == DFmode && !(TARGET_SSE2 && TARGET_SSE_MATH))\t\\\n    || (MODE) == XFmode)\n \n /* Cover class containing the stack registers.  */\n@@ -979,8 +978,7 @@ enum target_cpu_default\n \n    Actually there are no two word move instructions for consecutive\n    registers.  And only registers 0-3 may have mov byte instructions\n-   applied to them.\n-   */\n+   applied to them.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n@@ -1187,7 +1185,8 @@ enum reg_class\n   NON_Q_REGS,\t\t\t/* %esi %edi %ebp %esp */\n   INDEX_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp */\n   LEGACY_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n-  GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp %r8 - %r15*/\n+  GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp\n+\t\t\t\t   %r8 %r9 %r10 %r11 %r12 %r13 %r14 %r15 */\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n   FLOAT_REGS,\n   SSE_FIRST_REG,\n@@ -1416,10 +1415,13 @@ enum reg_class\n /* On the 80386, this is the size of MODE in words,\n    except in the FP regs, where a single reg is always enough.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n- (!MAYBE_INTEGER_CLASS_P (CLASS)\t\t\t\t\t\\\n-  ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n-  : (((((MODE) == XFmode ? 12 : GET_MODE_SIZE (MODE)))\t\t\t\\\n-      + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+  (MAYBE_INTEGER_CLASS_P (CLASS)\t\t\t\t\t\\\n+   ? ((MODE) == XFmode\t\t\t\t\t\t\t\\\n+      ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n+      : (MODE) == XCmode\t\t\t\t\t\t\\\n+      ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\t\\\n+      : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\t\\\n+   : (COMPLEX_MODE_P (MODE) ? 2 : 1))\n \n /* Return a class of registers that cannot change FROM mode to TO mode.  */\n \n@@ -1753,7 +1755,7 @@ typedef struct ix86_args {\n /* MOVE_MAX_PIECES is the number of bytes at a time which we can\n    move efficiently, as opposed to  MOVE_MAX which is the maximum\n    number of bytes we can move with a single instruction.  */\n-#define MOVE_MAX_PIECES (TARGET_64BIT ? 8 : 4)\n+#define MOVE_MAX_PIECES UNITS_PER_WORD\n \n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n    move-instruction pairs, we will do a movmem or libcall instead.\n@@ -1998,18 +2000,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   ix86_output_addr_diff_elt ((FILE), (VALUE), (REL))\n \n-/* When we see %v, we will print the 'v' prefix if TARGET_AVX is\n-   true.  */\n+/* When we see %v, we will print the 'v' prefix if TARGET_AVX is true.  */\n \n #define ASM_OUTPUT_AVX_PREFIX(STREAM, PTR)\t\\\n {\t\t\t\t\t\t\\\n   if ((PTR)[0] == '%' && (PTR)[1] == 'v')\t\\\n-    {\t\t\t\t\t\t\\\n-      if (TARGET_AVX)\t\t\t\t\\\n-\t(PTR) += 1;\t\t\t\t\\\n-      else\t\t\t\t\t\\\n-\t(PTR) += 2;\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n+    (PTR) += TARGET_AVX ? 1 : 2;\t\t\\\n }\n \n /* A C statement or statements which output an assembler instruction"}]}