{"sha": "b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4MzhkNzcwMTRhNGJiNmU5ZDNjZDRhMWUzMWFiMzAzZGUyNjhiOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-27T09:30:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-27T09:30:32Z"}, "message": "Move pow folds to match.pd\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* builtins.c (fold_builtin_pow): Delete in favor of...\n\t(fold_const_builtin_pow): ...this new function.  Only handle constant\n\targuments.\n\t(fold_builtin_2): Update accordingly.\n\t* match.pd: Add rules previously handled by fold_builtin_pow.\n\ngcc/testsuite/\n\t* gcc.dg/torture/builtin-math-1.c: Skip at -O0.\n\nFrom-SVN: r229408", "tree": {"sha": "e461030724a5d900e04e8f664d357d95208b1169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e461030724a5d900e04e8f664d357d95208b1169"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d7836c4361c5ae2f703c03e789ac0c533dd80be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d7836c4361c5ae2f703c03e789ac0c533dd80be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d7836c4361c5ae2f703c03e789ac0c533dd80be"}], "stats": {"total": 211, "additions": 88, "deletions": 123}, "files": [{"sha": "f26ea3de501e7de8b4fa43f29f1683a5bc55fe92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "patch": "@@ -1,3 +1,11 @@\n+2015-10-27  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* builtins.c (fold_builtin_pow): Delete in favor of...\n+\t(fold_const_builtin_pow): ...this new function.  Only handle constant\n+\targuments.\n+\t(fold_builtin_2): Update accordingly.\n+\t* match.pd: Add rules previously handled by fold_builtin_pow.\n+\n 2015-10-27  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* builtins.c (fold_builtin_hypot): Delete."}, {"sha": "88c0576edac6a0b9904c0d6c342d6cbf49899c66", "filename": "gcc/builtins.c", "status": "modified", "additions": 21, "deletions": 121, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "patch": "@@ -156,7 +156,6 @@ static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n static bool validate_arg (const_tree, enum tree_code code);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n-static tree fold_builtin_pow (location_t, tree, tree, tree, tree);\n static tree fold_builtin_powi (location_t, tree, tree, tree, tree);\n static tree fold_builtin_bitop (tree, tree);\n static tree fold_builtin_strchr (location_t, tree, tree, tree);\n@@ -7478,7 +7477,7 @@ fold_builtin_bswap (tree fndecl, tree arg)\n /* Fold a builtin function call to pow, powf, or powl.  Return\n    NULL_TREE if no simplification can be made.  */\n static tree\n-fold_builtin_pow (location_t loc, tree fndecl, tree arg0, tree arg1, tree type)\n+fold_const_builtin_pow (tree arg0, tree arg1, tree type)\n {\n   tree res;\n \n@@ -7490,127 +7489,28 @@ fold_builtin_pow (location_t loc, tree fndecl, tree arg0, tree arg1, tree type)\n   if ((res = do_mpfr_arg2 (arg0, arg1, type, mpfr_pow)))\n     return res;\n \n-  /* Optimize pow(1.0,y) = 1.0.  */\n-  if (real_onep (arg0))\n-    return omit_one_operand_loc (loc, type, build_real (type, dconst1), arg1);\n-\n-  if (TREE_CODE (arg1) == REAL_CST\n+  /* Check for an integer exponent.  */\n+  if (TREE_CODE (arg0) == REAL_CST\n+      && !TREE_OVERFLOW (arg0)\n+      && TREE_CODE (arg1) == REAL_CST\n       && !TREE_OVERFLOW (arg1))\n     {\n-      REAL_VALUE_TYPE cint;\n-      REAL_VALUE_TYPE c;\n-      HOST_WIDE_INT n;\n-\n-      c = TREE_REAL_CST (arg1);\n-\n-      /* Optimize pow(x,0.0) = 1.0.  */\n-      if (real_equal (&c, &dconst0))\n-\treturn omit_one_operand_loc (loc, type, build_real (type, dconst1),\n-\t\t\t\t arg0);\n-\n-      /* Optimize pow(x,1.0) = x.  */\n-      if (real_equal (&c, &dconst1))\n-\treturn arg0;\n-\n-      /* Optimize pow(x,-1.0) = 1.0/x.  */\n-      if (real_equal (&c, &dconstm1))\n-\treturn fold_build2_loc (loc, RDIV_EXPR, type,\n-\t\t\t    build_real (type, dconst1), arg0);\n-\n-      /* Optimize pow(x,0.5) = sqrt(x).  */\n-      if (flag_unsafe_math_optimizations\n-\t  && real_equal (&c, &dconsthalf))\n+      REAL_VALUE_TYPE cint1;\n+      const REAL_VALUE_TYPE *c0 = TREE_REAL_CST_PTR (arg0);\n+      const REAL_VALUE_TYPE *c1 = TREE_REAL_CST_PTR (arg1);\n+      HOST_WIDE_INT n1 = real_to_integer (c1);\n+      real_from_integer (&cint1, VOIDmode, n1, SIGNED);\n+      /* Attempt to evaluate pow at compile-time, unless this should\n+\t raise an exception.  */\n+      if (real_identical (c1, &cint1)\n+\t  && (n1 > 0\n+\t      || (!flag_trapping_math && !flag_errno_math)\n+\t      || !real_equal (c0, &dconst0)))\n \t{\n-\t  tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n-\n-\t  if (sqrtfn != NULL_TREE)\n-\t    return build_call_expr_loc (loc, sqrtfn, 1, arg0);\n-\t}\n-\n-      /* Optimize pow(x,1.0/3.0) = cbrt(x).  */\n-      if (flag_unsafe_math_optimizations)\n-\t{\n-\t  const REAL_VALUE_TYPE dconstroot\n-\t    = real_value_truncate (TYPE_MODE (type), dconst_third ());\n-\n-\t  if (real_equal (&c, &dconstroot))\n-\t    {\n-\t      tree cbrtfn = mathfn_built_in (type, BUILT_IN_CBRT);\n-\t      if (cbrtfn != NULL_TREE)\n-\t\treturn build_call_expr_loc (loc, cbrtfn, 1, arg0);\n-\t    }\n-\t}\n-\n-      /* Check for an integer exponent.  */\n-      n = real_to_integer (&c);\n-      real_from_integer (&cint, VOIDmode, n, SIGNED);\n-      if (real_identical (&c, &cint))\n-\t{\n-\t  /* Attempt to evaluate pow at compile-time, unless this should\n-\t     raise an exception.  */\n-\t  if (TREE_CODE (arg0) == REAL_CST\n-\t      && !TREE_OVERFLOW (arg0)\n-\t      && (n > 0\n-\t\t  || (!flag_trapping_math && !flag_errno_math)\n-\t\t  || !real_equal (&TREE_REAL_CST (arg0), &dconst0)))\n-\t    {\n-\t      REAL_VALUE_TYPE x;\n-\t      bool inexact;\n-\n-\t      x = TREE_REAL_CST (arg0);\n-\t      inexact = real_powi (&x, TYPE_MODE (type), &x, n);\n-\t      if (flag_unsafe_math_optimizations || !inexact)\n-\t\treturn build_real (type, x);\n-\t    }\n-\t}\n-    }\n-\n-  if (flag_unsafe_math_optimizations)\n-    {\n-      const enum built_in_function fcode = builtin_mathfn_code (arg0);\n-\n-      /* Optimize pow(expN(x),y) = expN(x*y).  */\n-      if (BUILTIN_EXPONENT_P (fcode))\n-\t{\n-\t  tree expfn = TREE_OPERAND (CALL_EXPR_FN (arg0), 0);\n-\t  tree arg = CALL_EXPR_ARG (arg0, 0);\n-\t  arg = fold_build2_loc (loc, MULT_EXPR, type, arg, arg1);\n-\t  return build_call_expr_loc (loc, expfn, 1, arg);\n-\t}\n-\n-      /* Optimize pow(sqrt(x),y) = pow(x,y*0.5).  */\n-      if (BUILTIN_SQRT_P (fcode))\n-\t{\n-\t  tree narg0 = CALL_EXPR_ARG (arg0, 0);\n-\t  tree narg1 = fold_build2_loc (loc, MULT_EXPR, type, arg1,\n-\t\t\t\t    build_real (type, dconsthalf));\n-\t  return build_call_expr_loc (loc, fndecl, 2, narg0, narg1);\n-\t}\n-\n-      /* Optimize pow(cbrt(x),y) = pow(x,y/3) iff x is nonnegative.  */\n-      if (BUILTIN_CBRT_P (fcode))\n-\t{\n-\t  tree arg = CALL_EXPR_ARG (arg0, 0);\n-\t  if (tree_expr_nonnegative_p (arg))\n-\t    {\n-\t      tree c = build_real_truncate (type, dconst_third ());\n-\t      tree narg1 = fold_build2_loc (loc, MULT_EXPR, type, arg1, c);\n-\t      return build_call_expr_loc (loc, fndecl, 2, arg, narg1);\n-\t    }\n-\t}\n-\n-      /* Optimize pow(pow(x,y),z) = pow(x,y*z) iff x is nonnegative.  */\n-      if (fcode == BUILT_IN_POW\n-\t  || fcode == BUILT_IN_POWF\n-\t  || fcode == BUILT_IN_POWL)\n-\t{\n-\t  tree arg00 = CALL_EXPR_ARG (arg0, 0);\n-\t  if (tree_expr_nonnegative_p (arg00))\n-\t    {\n-\t      tree arg01 = CALL_EXPR_ARG (arg0, 1);\n-\t      tree narg1 = fold_build2_loc (loc, MULT_EXPR, type, arg01, arg1);\n-\t      return build_call_expr_loc (loc, fndecl, 2, arg00, narg1);\n-\t    }\n+\t  REAL_VALUE_TYPE x;\n+\t  bool inexact = real_powi (&x, TYPE_MODE (type), c0, n1);\n+\t  if (flag_unsafe_math_optimizations || !inexact)\n+\t    return build_real (type, x);\n \t}\n     }\n \n@@ -9476,7 +9376,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n       return fold_builtin_expect (loc, arg0, arg1, NULL_TREE);\n \n     CASE_FLT_FN (BUILT_IN_POW):\n-      return fold_builtin_pow (loc, fndecl, arg0, arg1, type);\n+      return fold_const_builtin_pow (arg0, arg1, type);\n \n     CASE_FLT_FN (BUILT_IN_POWI):\n       return fold_builtin_powi (loc, fndecl, arg0, arg1, type);"}, {"sha": "a2f9405c4ac55ed087fd4b4ac0654911c5570fc7", "filename": "gcc/match.pd", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "patch": "@@ -2480,6 +2480,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n  (for sqrts (SQRT)\n       cbrts (CBRT)\n+      pows (POW)\n       exps (EXP EXP2 EXP10 POW10)\n   /* sqrt(expN(x)) -> expN(x*0.5).  */\n   (simplify\n@@ -2488,7 +2489,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   /* cbrt(expN(x)) -> expN(x/3).  */\n   (simplify\n    (cbrts (exps @0))\n-   (exps (mult @0 { build_real_truncate (type, dconst_third ()); }))))\n+   (exps (mult @0 { build_real_truncate (type, dconst_third ()); })))\n+  /* pow(expN(x), y) -> expN(x*y).  */\n+  (simplify\n+   (pows (exps @0) @1)\n+   (exps (mult @0 @1))))\n \n  /* tan(atan(x)) -> x.  */\n  (for tans (TAN)\n@@ -2524,6 +2529,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (hypot:c @0 real_zerop@1)\n  (abs @0))\n \n+/* pow(1,x) -> 1.  */\n+(simplify\n+ (POW real_onep@0 @1)\n+ @0)\n+\n /* Canonicalization of sequences of math builtins.  These rules represent\n    IL simplifications but are not necessarily optimizations.\n \n@@ -2615,7 +2625,19 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   /* cbrt(pow(x,y)) -> pow(x,y/3), iff x is nonnegative.  */\n   (simplify\n    (cbrts (pows tree_expr_nonnegative_p@0 @1))\n-   (pows @0 (mult @1 { build_real_truncate (type, dconst_third ()); }))))\n+   (pows @0 (mult @1 { build_real_truncate (type, dconst_third ()); })))\n+  /* pow(sqrt(x),y) -> pow(x,y*0.5).  */\n+  (simplify\n+   (pows (sqrts @0) @1)\n+   (pows @0 (mult @1 { build_real (type, dconsthalf); })))\n+  /* pow(cbrt(x),y) -> pow(x,y/3) iff x is nonnegative.  */\n+  (simplify\n+   (pows (cbrts tree_expr_nonnegative_p@0) @1)\n+   (pows @0 (mult @1 { build_real_truncate (type, dconst_third ()); })))\n+  /* pow(pow(x,y),z) -> pow(x,y*z) iff x is nonnegative.  */\n+  (simplify\n+   (pows (pows tree_expr_nonnegative_p@0 @1) @2)\n+   (pows @0 (mult @1 @2))))\n \n  /* cabs(x+xi) -> fabs(x)*sqrt(2).  */\n  (simplify\n@@ -2767,6 +2789,36 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (if (real_isinf (TREE_REAL_CST_PTR (@1)))\n   { build_complex_inf (type, TREE_REAL_CST_PTR (@1)->sign); }))\n \n+(for pows (POW)\n+     sqrts (SQRT)\n+     cbrts (CBRT)\n+ (simplify\n+  (pows @0 REAL_CST@1)\n+  (with {\n+    const REAL_VALUE_TYPE *value = TREE_REAL_CST_PTR (@1);\n+    REAL_VALUE_TYPE tmp;\n+   }\n+   (switch\n+    /* pow(x,0) -> 1.  */\n+    (if (real_equal (value, &dconst0))\n+     { build_real (type, dconst1); })\n+    /* pow(x,1) -> x.  */\n+    (if (real_equal (value, &dconst1))\n+     @0)\n+    /* pow(x,-1) -> 1/x.  */\n+    (if (real_equal (value, &dconstm1))\n+     (rdiv { build_real (type, dconst1); } @0))\n+    /* pow(x,0.5) -> sqrt(x).  */\n+    (if (flag_unsafe_math_optimizations\n+\t && canonicalize_math_p ()\n+\t && real_equal (value, &dconsthalf))\n+     (sqrts @0))\n+    /* pow(x,1/3) -> cbrt(x).  */\n+    (if (flag_unsafe_math_optimizations\n+\t && canonicalize_math_p ()\n+\t && (tmp = real_value_truncate (TYPE_MODE (type), dconst_third ()),\n+\t     real_equal (value, &tmp)))\n+     (cbrts @0))))))\n \n /* Narrowing of arithmetic and logical operations. \n "}, {"sha": "e808200ad42d66b9e1c42e1cd0e223245d54bd24", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "patch": "@@ -1,3 +1,7 @@\n+2015-10-27  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/torture/builtin-math-1.c: Skip at -O0.\n+\n 2015-10-27  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR c/64765"}, {"sha": "4ecc98d5f5c350e8727c9586bc72dcc6d580df71", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4838d77014a4bb6e9d3cd4a1e31ab303de268b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-1.c?ref=b4838d77014a4bb6e9d3cd4a1e31ab303de268b9", "patch": "@@ -6,6 +6,7 @@\n    Written by Roger Sayle, 16th August 2002.  */\n \n /* { dg-do link } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n \n extern double atan (double);\n extern float atanf (float);"}]}