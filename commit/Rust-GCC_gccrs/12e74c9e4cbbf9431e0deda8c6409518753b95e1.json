{"sha": "12e74c9e4cbbf9431e0deda8c6409518753b95e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJlNzRjOWU0Y2JiZjk0MzFlMGRlZGE4YzY0MDk1MTg3NTNiOTVlMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-08T12:22:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-08T12:22:39Z"}, "message": "Clean up prototypes for functions in expr.c and optabs.c and add some\nmissing ones.\n\nFrom-SVN: r3673", "tree": {"sha": "06603a73d50879ba48c64dfcffe4784ca9e9006b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06603a73d50879ba48c64dfcffe4784ca9e9006b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12e74c9e4cbbf9431e0deda8c6409518753b95e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e74c9e4cbbf9431e0deda8c6409518753b95e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12e74c9e4cbbf9431e0deda8c6409518753b95e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e74c9e4cbbf9431e0deda8c6409518753b95e1/comments", "author": null, "committer": null, "parents": [{"sha": "d8e8f34647c370e68fdbb8b328090d16c79fd5ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e8f34647c370e68fdbb8b328090d16c79fd5ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8e8f34647c370e68fdbb8b328090d16c79fd5ad"}], "stats": {"total": 237, "additions": 174, "deletions": 63}, "files": [{"sha": "f3a8cb594164ac2a1e374178216f9507c0df2d5e", "filename": "gcc/expr.h", "status": "modified", "additions": 174, "deletions": 63, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e74c9e4cbbf9431e0deda8c6409518753b95e1/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e74c9e4cbbf9431e0deda8c6409518753b95e1/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=12e74c9e4cbbf9431e0deda8c6409518753b95e1", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -446,68 +446,120 @@ extern rtxfun bcc_gen_fctn[NUM_RTX_CODE];\n \n extern enum insn_code setcc_gen_code[NUM_RTX_CODE];\n \n+/* Define functions given in optabs.c.  */\n+\n /* Expand a binary operation given optab and rtx operands.  */\n-extern rtx expand_binop PROTO((enum machine_mode, optab, rtx, rtx, rtx, int, enum optab_methods));\n+extern rtx expand_binop PROTO((enum machine_mode, optab, rtx, rtx, rtx,\n+\t\t\t       int, enum optab_methods));\n \n /* Expand a binary operation with both signed and unsigned forms.  */\n-extern rtx sign_expand_binop PROTO((enum machine_mode, optab, optab, rtx, rtx, rtx, int, enum optab_methods));\n+extern rtx sign_expand_binop PROTO((enum machine_mode, optab, optab, rtx,\n+\t\t\t\t    rtx, rtx, int, enum optab_methods));\n+\n+/* Generate code to perform an operation on two operands with two results.  */\n+extern int expand_twoval_binop PROTO((optab, rtx, rtx, rtx, rtx, int));\n \n /* Expand a unary arithmetic operation given optab rtx operand.  */\n extern rtx expand_unop PROTO((enum machine_mode, optab, rtx, rtx, int));\n \n /* Expand the complex absolute value operation.  */\n extern rtx expand_complex_abs PROTO((enum machine_mode, rtx, rtx, int));\n \n-/* Arguments MODE, RTX: return an rtx for the negation of that value.\n-   May emit insns.  */\n-extern rtx negate_rtx PROTO((enum machine_mode, rtx));\n+/* Generate an instruction with a given INSN_CODE with an output and\n+   an input.  */\n+extern void emit_unop_insn PROTO((int, rtx, rtx, enum rtx_code));\n \n-/* Expand a logical AND operation.  */\n-extern rtx expand_and PROTO((rtx, rtx, rtx));\n+/* Emit code to perform a series of operations on a multi-word quantity, one\n+   word at a time.  */\n+extern rtx emit_no_conflict_block PROTO((rtx, rtx, rtx, rtx, rtx));\n \n-/* Emit a store-flag operation.  */\n-extern rtx emit_store_flag PROTO((rtx, enum rtx_code, rtx, rtx, enum machine_mode, int, int));\n+/* Emit code to make a call to a constant function or a library call. */\n+extern void emit_libcall_block PROTO((rtx, rtx, rtx, rtx));\n \n+/* Emit one rtl instruction to store zero in specified rtx.  */\n+extern void emit_clr_insn PROTO((rtx));\n \n-/* Given a JUMP_INSN, return a description of the test being made.  */\n-extern rtx get_condition PROTO((rtx, rtx *));\n+/* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\n+extern void emit_0_to_1_insn PROTO((rtx));\n+\n+/* Emit one rtl insn to compare two rtx's.  */\n+extern void emit_cmp_insn PROTO((rtx, rtx, enum rtx_code, rtx,\n+\t\t\t\t enum machine_mode, int, int));\n+\n+/* Nonzero if a compare of mode MODE can be done straightforwardly\n+   (without splitting it into pieces).  */\n+extern int can_compare_p PROTO((enum machine_mode));\n+\n+/* Generate code to indirectly jump to a location given in the rtx LOC.  */\n+extern void emit_indirect_jump PROTO((rtx));\n+\n+/* Create but don't emit one rtl instruction to add one rtx into another.\n+   Modes must match; operands must meet the operation's predicates.\n+   Likewise for subtraction and for just copying.\n+   These do not call protect_from_queue; caller must do so.  */\n+extern rtx gen_add2_insn PROTO((rtx, rtx));\n+extern rtx gen_sub2_insn PROTO((rtx, rtx));\n+extern rtx gen_move_insn PROTO((rtx, rtx));\n+extern int have_add2_insn PROTO((enum machine_mode));\n+extern int have_sub2_insn PROTO((enum machine_mode));\n \n /* Return the INSN_CODE to use for an extend operation.  */\n-extern enum insn_code can_extend_p PROTO((enum machine_mode, enum machine_mode, int));\n+extern enum insn_code can_extend_p PROTO((enum machine_mode,\n+\t\t\t\t\t  enum machine_mode, int));\n+\n+/* Generate the body of an insn to extend Y (with mode MFROM)\n+   into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\n+extern rtx gen_extend_insn PROTO((rtx, rtx, enum machine_mode,\n+\t\t\t\t  enum machine_mode, int));\n \n /* Initialize the tables that control conversion between fixed and\n    floating values.  */\n extern void init_fixtab PROTO((void));\n extern void init_floattab PROTO((void));\n \n+/* Generate code for a FLOAT_EXPR.  */\n+extern void expand_float PROTO((rtx, rtx, int));\n+\n /* Generate code for a FIX_EXPR.  */\n extern void expand_fix PROTO((rtx, rtx, int));\n \n-/* Generate code for a FLOAT_EXPR.  */\n-extern void expand_float PROTO((rtx, rtx, int));\n+/* Call this once to initialize the contents of the optabs\n+   appropriately for the current target machine.  */\n+extern void init_optabs\tPROTO((void));\n+\f\n+/* Functions from expmed.c:  (/\n \n-/* Create but don't emit one rtl instruction to add one rtx into another.\n-   Modes must match; operands must meet the operation's predicates.\n-   Likewise for subtraction and for just copying.\n-   These do not call protect_from_queue; caller must do so.  */\n-extern rtx gen_add2_insn PROTO((rtx, rtx));\n-extern rtx gen_sub2_insn PROTO((rtx, rtx));\n-extern rtx gen_move_insn PROTO((rtx, rtx));\n+/* Arguments MODE, RTX: return an rtx for the negation of that value.\n+   May emit insns.  */\n+extern rtx negate_rtx PROTO((enum machine_mode, rtx));\n \n-/* Emit one rtl instruction to store zero in specified rtx.  */\n-extern void emit_clr_insn PROTO((rtx));\n+/* Expand a logical AND operation.  */\n+extern rtx expand_and PROTO((rtx, rtx, rtx));\n \n-/* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\n-extern void emit_0_to_1_insn PROTO((rtx));\n+/* Emit a store-flag operation.  */\n+extern rtx emit_store_flag PROTO((rtx, enum rtx_code, rtx, rtx,\n+\t\t\t\t  enum machine_mode, int, int));\n \n-/* Emit one rtl insn to compare two rtx's.  */\n-extern void emit_cmp_insn PROTO((rtx, rtx, enum rtx_code, rtx, enum machine_mode, int, int));\n+/* Functions from loop.c:  */\n \n-/* Emit insns to set X from Y, with no frills.  */\n-extern rtx emit_move_insn_1 PROTO ((rtx, rtx));\n+/* Given a JUMP_INSN, return a description of the test being made.  */\n+extern rtx get_condition PROTO((rtx, rtx *));\n+\f\n+/* Functions from expr.c:  */\n \n-/* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n-extern rtx compare_from_rtx PROTO((rtx, rtx, enum rtx_code, int, enum machine_mode, rtx, int));\n+/* This is run once per compilation to set up which modes can be used\n+   directly in memory and to initialize the block move optab.  */\n+extern void init_expr_once PROTO((void));\n+\n+/* This is run at the start of compiling a function.  */\n+extern void init_expr PROTO((void));\n+\n+/* Use protect_from_queue to convert a QUEUED expression\n+   into something that you can put immediately into an instruction.  */\n+extern rtx protect_from_queue PROTO((rtx, int));\n+\n+/* Perform all the pending incrementations.  */\n+extern void emit_queue PROTO((void));\n \n /* Emit some rtl insns to move data between rtx's, converting machine modes.\n    Both modes must be floating or both fixed.  */\n@@ -516,16 +568,103 @@ extern void convert_move PROTO((rtx, rtx, int));\n /* Convert an rtx to specified machine mode and return the result.  */\n extern rtx convert_to_mode PROTO((enum machine_mode, rtx, int));\n \n-/* Emit code to push some arguments and call a library routine,\n-   storing the value in a specified place.  Calling sequence is\n-   complicated.  */\n+/* Emit code to move a block Y to a block X.\n+extern void emit_block_move PROTO((rtx, rtx, rtx, int));\n+\n+/* Copy all or part of a value X into registers starting at REGNO.\n+   The number of registers to be filled is NREGS.  */\n+extern void move_block_to_reg PROTO((int, rtx, int, enum machine_mode));\n+\n+/* Copy all or part of a BLKmode value X out of registers starting at REGNO.\n+   The number of registers to be filled is NREGS.  */\n+extern void move_block_from_reg PROTO((int, rtx, int));\n+\n+/* Mark NREGS consecutive regs, starting at REGNO, as being live now.  */\n+extern void use_regs PROTO((int, int));\n+\n+/* Write zeros through the storage of OBJECT.\n+   If OBJECT has BLKmode, SIZE is its length in bytes.  */\n+extern void clear_storage PROTO((rtx, int));\n+\n+/* Emit insns to set X from Y.  */\n+extern rtx emit_move_insn PROTO((rtx, rtx));\n+\n+/* Emit insns to set X from Y, with no frills.  */\n+extern rtx emit_move_insn_1 PROTO ((rtx, rtx));\n+\n+/* Push a block of length SIZE (perhaps variable)\n+   and return an rtx to address the beginning of the block.  */\n+extern rtx push_block PROTO((rtx, int, int));\n+\n+/* Make an operand to push someting on the stack.  */\n+extern rtx gen_push_operand PROTO((void));\n+\n+#ifdef TREE_CODE\n+/* Generate code to push something onto the stack, given its mode and type.  */\n+extern void emit_push_insn PROTO((rtx, enum machine_mode, tree, rtx, int,\n+\t\t\t\t  int, rtx, int, rtx, rtx));\n+\n+/* Emit library call.  These cannot have accurate prototypes since they have\n+   a variable number of args.  */\n extern void emit_library_call ();\n+extern void emit_library_call_value ();\n+\n+/* Expand an assignment that stores the value of FROM into TO. */\n+extern rtx expand_assignment PROTO((tree, tree, int, int));\n+\n+/* Generate code for computing expression EXP,\n+   and storing the value into TARGET.\n+   If SUGGEST_REG is nonzero, copy the value through a register\n+   and return that register, if that is possible.  */\n+extern rtx store_expr PROTO((tree, rtx, int));\n+#endif\n \n /* Given an rtx that may include add and multiply operations,\n    generate them as insns and return a pseudo-reg containing the value.\n    Useful after calling expand_expr with 1 as sum_ok.  */\n extern rtx force_operand PROTO((rtx, rtx));\n \n+#ifdef TREE_CODE\n+/* Generate code for computing expression EXP.\n+   An rtx for the computed value is returned.  The value is never null.\n+   In the case of a void EXP, const0_rtx is returned.  */\n+extern rtx expand_expr PROTO((tree, rtx, enum machine_mode,\n+\t\t\t      enum expand_modifier));\n+#endif\n+\n+/* At the start of a function, record that we have no previously-pushed\n+   arguments waiting to be popped.  */\n+extern void init_pending_stack_adjust PROTO((void));\n+\n+/* When exiting from function, if safe, clear out any pending stack adjust\n+   so the adjustment won't get done.  */\n+extern void clear_pending_stack_adjust PROTO((void));\n+\n+/* Pop any previously-pushed arguments that have not been popped yet.  */\n+extern void do_pending_stack_adjust PROTO((void));\n+\n+#ifdef TREE_CODE\n+/* Expand all cleanups up to OLD_CLEANUPS.  */\n+extern void expand_cleanups_to PROTO((tree));\n+\n+/* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n+extern void jumpifnot PROTO((tree, rtx));\n+\n+/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n+extern void jumpif PROTO((tree, rtx));\n+\n+/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n+   the result is zero, or IF_TRUE_LABEL if the result is one.  */\n+extern void do_jump PROTO((tree, rtx, rtx));\n+#endif\n+\n+/* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n+extern rtx compare_from_rtx PROTO((rtx, rtx, enum rtx_code, int,\n+\t\t\t\t   enum machine_mode, rtx, int));\n+\n+/* Generate a tablejump instruction (used for switch statements).  */\n+extern void do_tablejump PROTO((rtx, enum machine_mode, rtx, rtx, rtx));\n+\f\n #ifdef TREE_CODE\n /* rtl.h and tree.h were included.  */\n /* Return an rtx for the size in bytes of the value of an expr.  */\n@@ -544,22 +683,14 @@ extern rtx trampoline_address PROTO((tree));\n    in its original home.  This becomes invalid if any more code is emitted.  */\n extern rtx hard_function_value PROTO((tree, tree));\n \n-/* Generate code for computing expression EXP,\n-   and storing the value into TARGET.\n-   If SUGGEST_REG is nonzero, copy the value through a register\n-   and return that register, if that is possible.  */\n-extern rtx store_expr PROTO((tree, rtx, int));\n \n extern rtx prepare_call_address PROTO((rtx, tree, rtx*));\n \n extern rtx expand_call PROTO((tree, rtx, int));\n extern void emit_call_1 PROTO((rtx, tree, int, int, rtx, rtx, int, rtx, int));\n \n-extern void emit_push_insn PROTO((rtx, enum machine_mode, tree, rtx, int, int, rtx, int, rtx, rtx));\n extern rtx expand_shift PROTO((enum tree_code, enum machine_mode, rtx, tree, rtx, int));\n extern rtx expand_divmod PROTO((int, enum tree_code, enum machine_mode, rtx, rtx, rtx, int));\n-extern void jumpif PROTO((tree, rtx));\n-extern void do_jump PROTO((tree, rtx, rtx));\n extern void locate_and_pad_parm PROTO((enum machine_mode, tree, int, tree, struct args_size *, struct args_size *, struct args_size *));\n extern rtx expand_inline_function PROTO((tree, tree, rtx, int, tree, rtx));\n /* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n@@ -581,28 +712,18 @@ extern rtx trampoline_address ();\n    in its original home.  This becomes invalid if any more code is emitted.  */\n extern rtx hard_function_value ();\n \n-/* Generate code for computing expression EXP,\n-   and storing the value into TARGET.\n-   If SUGGEST_REG is nonzero, copy the value through a register\n-   and return that register, if that is possible.  */\n-extern rtx store_expr ();\n-\n extern rtx prepare_call_address ();\n extern rtx expand_call ();\n extern void emit_call_1 ();\n-extern void emit_push_insn ();\n extern rtx expand_shift ();\n extern rtx expand_divmod ();\n-extern void jumpif ();\n-extern void do_jump ();\n extern void locate_and_pad_parm ();\n extern rtx expand_inline_function ();\n \n /* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n extern rtx label_rtx ();\n #endif\n \n-\n /* Indicate how an input argument register was promoted.  */\n extern rtx promoted_input_arg ();\n \n@@ -699,23 +820,13 @@ extern void copy_function_value ();\n    of STACK_BOUNDARY / BITS_PER_UNIT.  */\n extern rtx round_push PROTO((rtx));\n \n-/* Push a block of length SIZE (perhaps variable)\n-   and return an rtx to address the beginning of the block.  */\n-extern rtx push_block PROTO((rtx, int, int));\n-\n extern void emit_block_move PROTO((rtx, rtx, rtx, int));\n-extern void use_regs PROTO((int, int));\n-extern void move_block_to_reg PROTO((int, rtx, int, enum machine_mode));\n \n extern rtx store_bit_field PROTO((rtx, int, int, enum machine_mode, rtx, int, int));\n extern rtx extract_bit_field PROTO((rtx, int, int, int, rtx, enum machine_mode, enum machine_mode, int, int));\n extern rtx expand_mult PROTO((enum machine_mode, rtx, rtx, rtx, int));\n extern rtx expand_mult_add PROTO((rtx, rtx, rtx, rtx,enum machine_mode, int));\n extern rtx expand_stmt_expr ();\n-extern rtx emit_no_conflict_block PROTO((rtx, rtx, rtx, rtx, rtx));\n-extern void emit_libcall_block PROTO((rtx, rtx, rtx, rtx));\n-\n-extern void jumpifnot ();\n \n extern rtx assemble_static_space PROTO((int));\n "}]}