{"sha": "dc6758f03effbf7d6946d8c314576c7a6c0003af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2NzU4ZjAzZWZmYmY3ZDY5NDZkOGMzMTQ1NzZjN2E2YzAwMDNhZg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-19T00:33:09Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-19T20:22:13Z"}, "message": "Split gimple range folding with ranges into a stand alone class.\n\nIntroduces fold_using_range which folds any kind of gimple statement by\nquerying argument ranges thru a generic range_query.\nThis pulls all the statement processing into a client neutral location.\n\n\t* gimple-range.cc (fur_source::get_operand): New.\n\t(gimple_range_fold): Delete.\n\t(fold_using_range::fold_stmt): Move from gimple_ranger::calc_stmt.\n\t(fold_using_range::range_of_range_op): Move from gimple_ranger.\n\t(fold_using_range::range_of_address): Ditto.\n\t(fold_using_range::range_of_phi): Ditto.\n\t(fold_using_range::range_of_call): Ditto.\n\t(fold_using_range::range_of_builtin_ubsan_call): Move from\n\trange_of_builtin_ubsan_call.\n\t(fold_using_range::range_of_builtin_call): Move from\n\trange_of_builtin_call.\n\t(gimple_ranger::range_of_builtin_call): Delete.\n\t(fold_using_range::range_of_cond_expr): Move from gimple_ranger.\n\t(gimple_ranger::fold_range_internal): New.\n\t(gimple_ranger::range_of_stmt): Use new fold_using_range API.\n\t(fold_using_range::range_of_ssa_name_with_loop_info): Move from\n\tgimple_ranger.  Improve ranges of SSA_NAMES when possible.\n\t* gimple-range.h (gimple_ranger): Remove various range_of routines.\n\t(class fur_source): New.\n\t(class fold_using_range): New.\n\t(fur_source::fur_source): New.\n\t(fold_range): New.\n\t* vr-values.c (vr_values::extract_range_basic): Use fold_using_range\n\tinstead of range_of_builtin_call.", "tree": {"sha": "5d56151f75df24c220ad5f0908dd195781553f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d56151f75df24c220ad5f0908dd195781553f9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc6758f03effbf7d6946d8c314576c7a6c0003af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6758f03effbf7d6946d8c314576c7a6c0003af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc6758f03effbf7d6946d8c314576c7a6c0003af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6758f03effbf7d6946d8c314576c7a6c0003af/comments", "author": null, "committer": null, "parents": [{"sha": "cd67343703ef4fa61de837f4690eba70d2760825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd67343703ef4fa61de837f4690eba70d2760825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd67343703ef4fa61de837f4690eba70d2760825"}], "stats": {"total": 380, "additions": 257, "deletions": 123}, "files": [{"sha": "06e9804494b828926b71302d2f1d08b93c482f30", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 142, "deletions": 101, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6758f03effbf7d6946d8c314576c7a6c0003af/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6758f03effbf7d6946d8c314576c7a6c0003af/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=dc6758f03effbf7d6946d8c314576c7a6c0003af", "patch": "@@ -47,6 +47,31 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vr-values.h\"\n #include \"gimple-range.h\"\n \n+// Evaluate expression EXPR using the source information the class was\n+// instantiated with.  Place the result in R, and return TRUE.  If a range\n+// cannot be calcluated, return FALSE.\n+\n+bool\n+fur_source::get_operand (irange &r, tree expr)\n+{\n+  if (!gimple_range_ssa_p (expr))\n+    return get_tree_range (r, expr);\n+\n+  // If no query engine is present, simply get the global value.\n+  if (!m_query)\n+    {\n+       r = gimple_range_global (expr);\n+       return true;\n+    }\n+\n+  // First look for a stmt.\n+  if (m_stmt)\n+    return m_query->range_of_expr (r, expr, m_stmt);\n+\n+  // Finally must be on an edge.\n+  return m_query->range_on_edge (r, m_edge, expr);\n+}\n+\n \n // Adjust the range for a pointer difference where the operands came\n // from a memchr.\n@@ -193,41 +218,9 @@ get_tree_range (irange &r, tree expr)\n   return true;\n }\n \n-// Fold this unary statement using R1 as operand1's range, returning\n-// the result in RES.  Return false if the operation fails.\n-\n-bool\n-gimple_range_fold (irange &res, const gimple *stmt, const irange &r1)\n-{\n-  gcc_checking_assert (gimple_range_handler (stmt));\n-\n-  tree type = gimple_expr_type (stmt);\n-  // Unary SSA operations require the LHS type as the second range.\n-  int_range<2> r2 (type);\n-\n-  return gimple_range_fold (res, stmt, r1, r2);\n-}\n-\n-// Fold this binary statement using R1 and R2 as the operands ranges,\n-// returning the result in RES.  Return false if the operation fails.\n-\n-bool\n-gimple_range_fold (irange &res, const gimple *stmt,\n-\t\t   const irange &r1, const irange &r2)\n-{\n-  gcc_checking_assert (gimple_range_handler (stmt));\n-\n-  gimple_range_handler (stmt)->fold_range (res, gimple_expr_type (stmt),\n-\t\t\t\t\t   r1, r2);\n-\n-  // If there are any gimple lookups, do those now.\n-  gimple_range_adjustment (res, stmt);\n-  return true;\n-}\n-\n // Return the base of the RHS of an assignment.\n \n-tree\n+static tree\n gimple_range_base_of_assignment (const gimple *stmt)\n {\n   gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n@@ -364,20 +357,29 @@ gimple_range_calc_op2 (irange &r, const gimple *stmt,\n // be calculated, return false.\n \n bool\n-gimple_ranger::calc_stmt (irange &r, gimple *s, tree name)\n+fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n {\n   bool res = false;\n-  // If name is specified, make sure it is an LHS of S.\n-  gcc_checking_assert (name ? SSA_NAME_DEF_STMT (name) == s : true);\n+  // If name and S are specified, make sure it is an LHS of S.\n+  gcc_checking_assert (!name || !gimple_get_lhs (s) ||\n+\t\t       name == gimple_get_lhs (s));\n+\n+  if (!name)\n+    name = gimple_get_lhs (s);\n+\n+  // Process addresses.\n+  if (gimple_code (s) == GIMPLE_ASSIGN\n+      && gimple_assign_rhs_code (s) == ADDR_EXPR)\n+    return range_of_address (r, s, src);\n \n   if (gimple_range_handler (s))\n-    res = range_of_range_op (r, s);\n+    res = range_of_range_op (r, s, src);\n   else if (is_a<gphi *>(s))\n-    res = range_of_phi (r, as_a<gphi *> (s));\n+    res = range_of_phi (r, as_a<gphi *> (s), src);\n   else if (is_a<gcall *>(s))\n-    res = range_of_call (r, as_a<gcall *> (s));\n+    res = range_of_call (r, as_a<gcall *> (s), src);\n   else if (is_a<gassign *> (s) && gimple_assign_rhs_code (s) == COND_EXPR)\n-    res = range_of_cond_expr (r, as_a<gassign *> (s));\n+    res = range_of_cond_expr (r, as_a<gassign *> (s), src);\n \n   if (!res)\n     {\n@@ -414,36 +416,45 @@ gimple_ranger::calc_stmt (irange &r, gimple *s, tree name)\n // If a range cannot be calculated, return false.\n \n bool\n-gimple_ranger::range_of_range_op (irange &r, gimple *s)\n+fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n {\n   int_range_max range1, range2;\n-  tree lhs = gimple_get_lhs (s);\n   tree type = gimple_expr_type (s);\n+  range_operator *handler = gimple_range_handler (s);\n+  gcc_checking_assert (handler);\n   gcc_checking_assert (irange::supports_type_p (type));\n \n+  tree lhs = gimple_get_lhs (s);\n   tree op1 = gimple_range_operand1 (s);\n   tree op2 = gimple_range_operand2 (s);\n \n-  if (lhs)\n-    {\n-      // Register potential dependencies for stale value tracking.\n-      m_cache.register_dependency (lhs, op1);\n-      m_cache.register_dependency (lhs, op2);\n-    }\n-\n-  if (gimple_code (s) == GIMPLE_ASSIGN\n-      && gimple_assign_rhs_code (s) == ADDR_EXPR)\n-    return range_of_address (r, s);\n-\n-  if (range_of_expr (range1, op1, s))\n+  if (src.get_operand (range1, op1))\n     {\n       if (!op2)\n-\treturn gimple_range_fold (r, s, range1);\n-\n-      if (range_of_expr (range2, op2, s))\n-\treturn gimple_range_fold (r, s, range1, range2);\n+\t{\n+\t  // Fold range, and register any dependency if available.\n+\t  int_range<2> r2 (type);\n+\t  handler->fold_range (r, type, range1, r2);\n+\t  if (lhs && src.m_cache)\n+\t    src.m_cache->register_dependency (lhs, op1);\n+\t}\n+      else if (src.get_operand (range2, op2))\n+\t{\n+\t  // Fold range, and register any dependency if available.\n+\t  handler->fold_range (r, type, range1, range2);\n+\t  if (lhs && src.m_cache)\n+\t    {\n+\t      src.m_cache->register_dependency (lhs, op1);\n+\t      src.m_cache->register_dependency (lhs, op2);\n+\t    }\n+\t}\n+      else\n+\tr.set_varying (type);\n     }\n-  r.set_varying (type);\n+  else\n+    r.set_varying (type);\n+  // Make certain range-op adjustments that aren't handled any other way.\n+  gimple_range_adjustment (r, s);\n   return true;\n }\n \n@@ -452,7 +463,7 @@ gimple_ranger::range_of_range_op (irange &r, gimple *s)\n // If a range cannot be calculated, set it to VARYING and return true.\n \n bool\n-gimple_ranger::range_of_address (irange &r, gimple *stmt)\n+fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n {\n   gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n   gcc_checking_assert (gimple_assign_rhs_code (stmt) == ADDR_EXPR);\n@@ -473,8 +484,11 @@ gimple_ranger::range_of_address (irange &r, gimple *stmt)\n       && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n       tree ssa = TREE_OPERAND (base, 0);\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (src.m_cache && lhs && gimple_range_ssa_p (ssa))\n+\tsrc.m_cache->register_dependency (lhs, ssa);\n       gcc_checking_assert (irange::supports_type_p (TREE_TYPE (ssa)));\n-      range_of_expr (r, ssa, stmt);\n+      src.get_operand (r, ssa);\n       range_cast (r, TREE_TYPE (gimple_assign_rhs1 (stmt)));\n \n       poly_offset_int off = 0;\n@@ -531,7 +545,7 @@ gimple_ranger::range_of_address (irange &r, gimple *stmt)\n // If a range cannot be calculated, return false.\n \n bool\n-gimple_ranger::range_of_phi (irange &r, gphi *phi)\n+fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n {\n   tree phi_def = gimple_phi_result (phi);\n   tree type = TREE_TYPE (phi_def);\n@@ -549,9 +563,19 @@ gimple_ranger::range_of_phi (irange &r, gphi *phi)\n       edge e = gimple_phi_arg_edge (phi, x);\n \n       // Register potential dependencies for stale value tracking.\n-      m_cache.register_dependency (phi_def, arg);\n-\n-      range_on_edge (arg_range, e, arg);\n+      if (src.m_cache && gimple_range_ssa_p (arg))\n+\tsrc.m_cache->register_dependency (phi_def, arg);\n+\n+      // Get the range of the argument on its edge.\n+      fur_source e_src (src.m_query, e);\n+      e_src.get_operand (arg_range, arg);\n+      // If we're recomputing the argument elsewhere, try to refine it.\n+      if (src.m_stmt != phi)\n+\t{\n+\t  int_range_max tmp;\n+\t  e_src.get_operand (tmp, arg);\n+\t  arg_range.intersect (tmp);\n+\t}\n       r.union_ (arg_range);\n       // Once the value reaches varying, stop looking.\n       if (r.varying_p ())\n@@ -565,7 +589,7 @@ gimple_ranger::range_of_phi (irange &r, gphi *phi)\n       class loop *l = loop_containing_stmt (phi);\n       if (l && loop_outer (l))\n         {\n-\t  range_of_ssa_name_with_loop_info (loop_range, phi_def, l, phi);\n+\t  range_of_ssa_name_with_loop_info (loop_range, phi_def, l, phi, src);\n \t  if (!loop_range.varying_p ())\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -590,7 +614,7 @@ gimple_ranger::range_of_phi (irange &r, gphi *phi)\n // If a range cannot be calculated, return false.\n \n bool\n-gimple_ranger::range_of_call (irange &r, gcall *call)\n+fold_using_range::range_of_call (irange &r, gcall *call, fur_source &src)\n {\n   tree type = gimple_call_return_type (call);\n   tree lhs = gimple_call_lhs (call);\n@@ -599,7 +623,7 @@ gimple_ranger::range_of_call (irange &r, gcall *call)\n   if (!irange::supports_type_p (type))\n     return false;\n \n-  if (range_of_builtin_call (r, call))\n+  if (range_of_builtin_call (r, call, src))\n     ;\n   else if (gimple_stmt_nonnegative_warnv_p (call, &strict_overflow_p))\n     r.set (build_int_cst (type, 0), TYPE_MAX_VALUE (type));\n@@ -623,9 +647,9 @@ gimple_ranger::range_of_call (irange &r, gcall *call)\n // CODE is the type of ubsan call (PLUS_EXPR, MINUS_EXPR or\n // MULT_EXPR).\n \n-static void\n-range_of_builtin_ubsan_call (range_query &query, irange &r, gcall *call,\n-\t\t\t     tree_code code)\n+void\n+fold_using_range::range_of_builtin_ubsan_call (irange &r, gcall *call,\n+\t\t\t\t\t       tree_code code, fur_source &src)\n {\n   gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR\n \t\t       || code == MULT_EXPR);\n@@ -635,8 +659,8 @@ range_of_builtin_ubsan_call (range_query &query, irange &r, gcall *call,\n   int_range_max ir0, ir1;\n   tree arg0 = gimple_call_arg (call, 0);\n   tree arg1 = gimple_call_arg (call, 1);\n-  query.range_of_expr (ir0, arg0, call);\n-  query.range_of_expr (ir1, arg1, call);\n+  src.get_operand (ir0, arg0);\n+  src.get_operand (ir1, arg1);\n \n   bool saved_flag_wrapv = flag_wrapv;\n   // Pretend the arithmetic is wrapping.  If there is any overflow,\n@@ -656,7 +680,8 @@ range_of_builtin_ubsan_call (range_query &query, irange &r, gcall *call,\n // TRUE.  Otherwise return FALSE.\n \n bool\n-range_of_builtin_call (range_query &query, irange &r, gcall *call)\n+fold_using_range::range_of_builtin_call (irange &r, gcall *call,\n+\t\t\t\t\t fur_source &src)\n {\n   combined_fn func = gimple_call_combined_fn (call);\n   if (func == CFN_LAST)\n@@ -677,7 +702,7 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n \t  return true;\n \t}\n       arg = gimple_call_arg (call, 0);\n-      if (query.range_of_expr (r, arg, call) && r.singleton_p ())\n+      if (src.get_operand (r, arg) && r.singleton_p ())\n \t{\n \t  r.set (build_one_cst (type), build_one_cst (type));\n \t  return true;\n@@ -691,7 +716,7 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n       prec = TYPE_PRECISION (TREE_TYPE (arg));\n       mini = 0;\n       maxi = prec;\n-      query.range_of_expr (r, arg, call);\n+      src.get_operand (r, arg);\n       // If arg is non-zero, then ffs or popcount are non-zero.\n       if (!range_includes_zero_p (&r))\n \tmini = 1;\n@@ -735,7 +760,7 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n \t    }\n \t}\n \n-      query.range_of_expr (r, arg, call);\n+      src.get_operand (r, arg);\n       // From clz of minimum we can compute result maximum.\n       if (r.constant_p () && !r.varying_p ())\n \t{\n@@ -800,7 +825,7 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n \t\tmini = -2;\n \t    }\n \t}\n-      query.range_of_expr (r, arg, call);\n+      src.get_operand (r, arg);\n       if (!r.undefined_p ())\n \t{\n \t  if (r.lower_bound () != 0)\n@@ -838,13 +863,13 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n       r.set (build_int_cst (type, 0), build_int_cst (type, prec - 1));\n       return true;\n     case CFN_UBSAN_CHECK_ADD:\n-      range_of_builtin_ubsan_call (query, r, call, PLUS_EXPR);\n+      range_of_builtin_ubsan_call (r, call, PLUS_EXPR, src);\n       return true;\n     case CFN_UBSAN_CHECK_SUB:\n-      range_of_builtin_ubsan_call (query, r, call, MINUS_EXPR);\n+      range_of_builtin_ubsan_call (r, call, MINUS_EXPR, src);\n       return true;\n     case CFN_UBSAN_CHECK_MUL:\n-      range_of_builtin_ubsan_call (query, r, call, MULT_EXPR);\n+      range_of_builtin_ubsan_call (r, call, MULT_EXPR, src);\n       return true;\n \n     case CFN_GOACC_DIM_SIZE:\n@@ -894,17 +919,11 @@ range_of_builtin_call (range_query &query, irange &r, gcall *call)\n }\n \n \n-bool\n-gimple_ranger::range_of_builtin_call (irange &r, gcall *call)\n-{\n-  return ::range_of_builtin_call (*this, r, call);\n-}\n-\n // Calculate a range for COND_EXPR statement S and return it in R.\n // If a range cannot be calculated, return false.\n \n bool\n-gimple_ranger::range_of_cond_expr  (irange &r, gassign *s)\n+fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n {\n   int_range_max cond_range, range1, range2;\n   tree cond = gimple_assign_rhs1 (s);\n@@ -917,9 +936,9 @@ gimple_ranger::range_of_cond_expr  (irange &r, gassign *s)\n   if (!irange::supports_type_p (TREE_TYPE (op1)))\n     return false;\n \n-  range_of_expr (cond_range, cond, s);\n-  range_of_expr (range1, op1, s);\n-  range_of_expr (range2, op2, s);\n+  src.get_operand (cond_range, cond);\n+  src.get_operand (range1, op1);\n+  src.get_operand (range2, op2);\n \n   // If the condition is known, choose the appropriate expression.\n   if (cond_range.singleton_p ())\n@@ -1047,6 +1066,16 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n   return true;\n }\n \n+// fold_range wrapper for range_of_stmt to use as an internal client.\n+\n+bool\n+gimple_ranger::fold_range_internal (irange &r, gimple *s, tree name)\n+{\n+  fold_using_range f;\n+  fur_source src (this, &m_cache, NULL, s);\n+  return f.fold_stmt (r, s, src, name);\n+}\n+\n // Calculate a range for statement S and return it in R.  If NAME is\n // provided it represents the SSA_NAME on the LHS of the statement.\n // It is only required if there is more than one lhs/output.  Check\n@@ -1063,7 +1092,7 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n \n   // If no name, simply call the base routine.\n   if (!name)\n-    return calc_stmt (r, s, NULL_TREE);\n+    return fold_range_internal (r, s, NULL_TREE);\n \n   if (!gimple_range_ssa_p (name))\n     return false;\n@@ -1074,7 +1103,7 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n \n   // Otherwise calculate a new value.\n   int_range_max tmp;\n-  calc_stmt (tmp, s, name);\n+  fold_range_internal (tmp, s, name);\n \n   // Combine the new value with the old value.  This is required because\n   // the way value propagation works, when the IL changes on the fly we\n@@ -1216,20 +1245,32 @@ gimple_ranger::dump (FILE *f)\n // If SCEV has any information about phi node NAME, return it as a range in R.\n \n void\n-gimple_ranger::range_of_ssa_name_with_loop_info (irange &r, tree name,\n-\t\t\t\t\t\t class loop *l, gphi *phi)\n+fold_using_range::range_of_ssa_name_with_loop_info (irange &r, tree name,\n+\t\t\t\t\t\t    class loop *l, gphi *phi,\n+\t\t\t\t\t\t    fur_source &src)\n {\n   gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n   tree min, max, type = TREE_TYPE (name);\n-  if (bounds_of_var_in_loop (&min, &max, this, l, phi, name))\n+  if (bounds_of_var_in_loop (&min, &max, src.m_query, l, phi, name))\n     {\n-      // ?? We could do better here.  Since MIN/MAX can only be an\n-      // SSA, SSA +- INTEGER_CST, or INTEGER_CST, we could easily call\n-      // the ranger and solve anything not an integer.\n       if (TREE_CODE (min) != INTEGER_CST)\n-\tmin = vrp_val_min (type);\n+\t{\n+\t  if (src.m_query\n+\t      && src.m_query->range_of_expr (r, min, phi)\n+\t      && !r.undefined_p ())\n+\t    min = wide_int_to_tree (type, r.lower_bound ());\n+\t  else\n+\t    min = vrp_val_min (type);\n+\t}\n       if (TREE_CODE (max) != INTEGER_CST)\n-\tmax = vrp_val_max (type);\n+\t{\n+\t  if (src.m_query\n+\t      && src.m_query->range_of_expr (r, max, phi)\n+\t      && !r.undefined_p ())\n+\t    max = wide_int_to_tree (type, r.upper_bound ());\n+\t  else\n+\t    max = vrp_val_max (type);\n+\t}\n       r.set (min, max);\n     }\n   else"}, {"sha": "53205066ab4f78dcd33424423828cbb69fbddd9b", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 114, "deletions": 21, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6758f03effbf7d6946d8c314576c7a6c0003af/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6758f03effbf7d6946d8c314576c7a6c0003af/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=dc6758f03effbf7d6946d8c314576c7a6c0003af", "patch": "@@ -30,6 +30,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range-cache.h\"\n #include \"value-query.h\"\n \n+// This file is the main include point for gimple ranges.\n+// There are two fold_range routines of interest:\n+//   bool fold_range (irange &r, gimple *s, range_query *q)\n+//   bool fold_range (irange &r, gimple *s, edge on_edge, range_query *q)\n+// These routines will fold stmt S into the result irange R.\n+// Any ssa_names on the stmt will be calculated using the range_query\n+// parameter via a call to range_of_expr.\n+// If no range_query is provided, current global range info will be used.\n+// The second variation specifies an edge, and stmt S is recalculated as if\n+// it appeared on that edge.\n+\n+\n // This is the basic range generator interface.\n //\n // This base class provides all the API entry points, but only provides\n@@ -55,32 +67,116 @@ class gimple_ranger : public range_query\n   void export_global_ranges ();\n   void dump (FILE *f);\n protected:\n-  bool calc_stmt (irange &r, gimple *s, tree name = NULL_TREE);\n-  bool range_of_range_op (irange &r, gimple *s);\n-  bool range_of_call (irange &r, gcall *call);\n-  bool range_of_cond_expr (irange &r, gassign* cond);\n+  bool fold_range_internal (irange &r, gimple *s, tree name);\n   ranger_cache m_cache;\n-private:\n-  bool range_of_phi (irange &r, gphi *phi);\n-  bool range_of_address (irange &r, gimple *s);\n-  bool range_of_builtin_call (irange &r, gcall *call);\n-  bool range_with_loop_info (irange &r, tree name);\n-  void range_of_ssa_name_with_loop_info (irange &, tree, class loop *,\n-\t\t\t\t\t gphi *);\n };\n \n-// Calculate a basic range for a tree expression.\n+// Source of an operand for fold_using_range.\n+// It can specify a stmt or and edge, or thru an internal API which uses\n+// the ranger cache.\n+// Its primary function is to retreive an operand from the source via a\n+// call thru the range_query object.\n+\n+class fur_source\n+{\n+  friend class fold_using_range;\n+public:\n+  inline fur_source (range_query *q, edge e);\n+  inline fur_source (range_query *q, gimple *s);\n+  inline fur_source (range_query *q, class ranger_cache *g, edge e, gimple *s);\n+  bool get_operand (irange &r, tree expr);\n+protected:\n+  ranger_cache *m_cache;\n+  range_query *m_query;\n+  edge m_edge;\n+  gimple *m_stmt;\n+};\n+\n+\n+// This class uses ranges to fold a gimple statement producinf a range for\n+// the LHS.  The source of all operands is supplied via the fur_source class\n+// which provides a range_query as well as a source location and any other\n+// required information.\n+\n+class fold_using_range\n+{\n+public:\n+  bool fold_stmt (irange &r, gimple *s, class fur_source &src,\n+\t\t  tree name = NULL_TREE);\n+protected:\n+  bool range_of_range_op (irange &r, gimple *s, fur_source &src);\n+  bool range_of_call (irange &r, gcall *call, fur_source &src);\n+  bool range_of_cond_expr (irange &r, gassign* cond, fur_source &src);\n+  bool range_of_address (irange &r, gimple *s, fur_source &src);\n+  bool range_of_builtin_call (irange &r, gcall *call, fur_source &src);\n+  void range_of_builtin_ubsan_call (irange &r, gcall *call, tree_code code,\n+\t\t\t\t    fur_source &src);\n+  bool range_of_phi (irange &r, gphi *phi, fur_source &src);\n+  void range_of_ssa_name_with_loop_info (irange &, tree, class loop *, gphi *,\n+\t\t\t\t\t fur_source &src);\n+};\n+\n+\n+// Create a source for a query on an edge.\n+\n+inline\n+fur_source::fur_source (range_query *q, edge e)\n+{\n+  m_query = q;\n+  m_cache = NULL;\n+  m_edge = e;\n+  m_stmt = NULL;\n+}\n+\n+// Create a source for a query at a statement.\n+\n+inline\n+fur_source::fur_source (range_query *q, gimple *s)\n+{\n+  m_query = q;\n+  m_cache = NULL;\n+  m_edge = NULL;\n+  m_stmt = s;\n+}\n+\n+// Create a source for Ranger.  THis can recalculate from a different location\n+// and can also set the dependency information as appropriate when invoked.\n+\n+inline\n+fur_source::fur_source (range_query *q, ranger_cache *g, edge e, gimple *s)\n+{\n+  m_query = q;\n+  m_cache = g;\n+  m_edge = e;\n+  m_stmt = s;\n+}\n+\n+// Fold stmt S into range R using range query Q.\n+\n+inline bool\n+fold_range (irange &r, gimple *s, range_query *q = NULL)\n+{\n+  fold_using_range f;\n+  fur_source src (q, s);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n+\n+inline bool\n+fold_range (irange &r, gimple *s, edge on_edge, range_query *q = NULL)\n+{\n+  fold_using_range f;\n+  fur_source src (q, on_edge);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Calculate a basic range for a tree node expression.\n extern bool get_tree_range (irange &r, tree expr);\n \n // These routines provide a GIMPLE interface to the range-ops code.\n extern tree gimple_range_operand1 (const gimple *s);\n extern tree gimple_range_operand2 (const gimple *s);\n-extern tree gimple_range_base_of_assignment (const gimple *s);\n-extern bool gimple_range_fold (irange &res, const gimple *s,\n-\t\t\t       const irange &r1);\n-extern bool gimple_range_fold (irange &res, const gimple *s,\n-\t\t\t       const irange &r1,\n-\t\t\t       const irange &r2);\n extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n \t\t\t\t   const irange &lhs_range);\n extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n@@ -199,7 +295,4 @@ class trace_ranger : public gimple_ranger\n // Flag to enable debugging the various internal Caches.\n #define DEBUG_RANGE_CACHE (dump_file && (param_evrp_mode & EVRP_MODE_DEBUG))\n \n-// Temporary external interface to share with vr_values.\n-bool range_of_builtin_call (range_query &query, irange &r, gcall *call);\n-\n #endif // GCC_GIMPLE_RANGE_STMT_H"}, {"sha": "02bc0db9088deb63eee030b1cdfbb3a019adadab", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6758f03effbf7d6946d8c314576c7a6c0003af/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6758f03effbf7d6946d8c314576c7a6c0003af/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=dc6758f03effbf7d6946d8c314576c7a6c0003af", "patch": "@@ -1229,7 +1229,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t    return;\n \t  break;\n \tdefault:\n-\t  if (range_of_builtin_call (*this, *vr, as_a<gcall *> (stmt)))\n+\t  if (fold_range (*vr, stmt, this))\n \t    {\n \t      /* The original code nuked equivalences every time a\n \t\t range was found, so do the same here.  */"}]}