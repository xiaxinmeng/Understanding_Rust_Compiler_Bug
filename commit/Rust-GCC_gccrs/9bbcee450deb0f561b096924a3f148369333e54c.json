{"sha": "9bbcee450deb0f561b096924a3f148369333e54c", "node_id": "C_kwDOANBUbNoAKDliYmNlZTQ1MGRlYjBmNTYxYjA5NjkyNGEzZjE0ODM2OTMzM2U1NGM", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-08T22:49:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-08T22:49:07Z"}, "message": "analyzer: eliminate region_model::eval_condition_without_cm [PR101962]\n\nIn r12-3094-ge82e0f149b0aba I added the assumption that\nPOINTER_PLUS_EXPR of non-NULL is non-NULL (for PR analyzer/101962).\n\nWhilst working on another bug, I noticed that this only works\nwhen the LHS is known to be non-NULL via\nregion_model::eval_condition_without_cm, but not when it's known through\na constraint.\n\nThis distinction predates the original commit of the analyzer in GCC 10,\nbut I believe it became irrelevant in the GCC 11 rewrite of the region\nmodel code (r11-2694-g808f4dfeb3a95f).\n\nHence this patch eliminates region_model::eval_condition_without_cm in\nfavor of all users simply calling region_model::eval_condition.  Doing\nso enables the \"POINTER_PLUS_EXPR of non-NULL is non-NULL\" assumption to\nalso be made when the LHS is known through a constraint (e.g. a\nconditional).\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/101962\n\t* region-model-impl-calls.cc: Update comment.\n\t* region-model.cc (region_model::check_symbolic_bounds): Fix\n\tlayout of \"void\" return.  Replace usage of\n\teval_condition_without_cm with eval_condition.\n\t(region_model::eval_condition): Take over body of...\n\t(region_model::eval_condition_without_cm): ...this subroutine,\n\tdropping the latter.  Eliminating this distinction avoids issues\n\twhere constraints were not considered when recursing.\n\t(region_model::compare_initial_and_pointer): Update comment.\n\t(region_model::symbolic_greater_than): Replace usage of\n\teval_condition_without_cm with eval_condition.\n\t* region-model.h\n\t(region_model::eval_condition_without_cm): Delete decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/101962\n\t* gcc.dg/analyzer/data-model-23.c (test_3): New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "6358dbe490eac21d01fd7270d686b0ebd944ea1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6358dbe490eac21d01fd7270d686b0ebd944ea1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bbcee450deb0f561b096924a3f148369333e54c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bbcee450deb0f561b096924a3f148369333e54c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bbcee450deb0f561b096924a3f148369333e54c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bbcee450deb0f561b096924a3f148369333e54c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbcb84bba0a21ff367c95d3d0970926992b20cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbcb84bba0a21ff367c95d3d0970926992b20cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbcb84bba0a21ff367c95d3d0970926992b20cdd"}], "stats": {"total": 91, "additions": 38, "deletions": 53}, "files": [{"sha": "9ef31f6ab0517f6cf3c931c5d0ca007980f9a9a3", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=9bbcee450deb0f561b096924a3f148369333e54c", "patch": "@@ -498,7 +498,7 @@ region_model::impl_call_fread (const call_details &cd)\n \n    This has to be done here so that the sm-handling can use the fact\n    that they point to the same region to establish that they are equal\n-   (in region_model::eval_condition_without_cm), and thus transition\n+   (in region_model::eval_condition), and thus transition\n    all pointers to the region to the \"freed\" state together, regardless\n    of casts.  */\n "}, {"sha": "5ffad64a9c52ce3830085d69deb4bb96420372af", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 26, "deletions": 49, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=9bbcee450deb0f561b096924a3f148369333e54c", "patch": "@@ -1764,20 +1764,21 @@ class symbolic_buffer_overread : public symbolic_past_the_end\n \n /* Check whether an access is past the end of the BASE_REG.  */\n \n-void region_model::check_symbolic_bounds (const region *base_reg,\n-\t\t\t\t\t  const svalue *sym_byte_offset,\n-\t\t\t\t\t  const svalue *num_bytes_sval,\n-\t\t\t\t\t  const svalue *capacity,\n-\t\t\t\t\t  enum access_direction dir,\n-\t\t\t\t\t  region_model_context *ctxt) const\n+void\n+region_model::check_symbolic_bounds (const region *base_reg,\n+\t\t\t\t     const svalue *sym_byte_offset,\n+\t\t\t\t     const svalue *num_bytes_sval,\n+\t\t\t\t     const svalue *capacity,\n+\t\t\t\t     enum access_direction dir,\n+\t\t\t\t     region_model_context *ctxt) const\n {\n   gcc_assert (ctxt);\n \n   const svalue *next_byte\n     = m_mgr->get_or_create_binop (num_bytes_sval->get_type (), PLUS_EXPR,\n \t\t\t\t  sym_byte_offset, num_bytes_sval);\n \n-  if (eval_condition_without_cm (next_byte, GT_EXPR, capacity).is_true ())\n+  if (eval_condition (next_byte, GT_EXPR, capacity).is_true ())\n     {\n       tree diag_arg = get_representative_tree (base_reg);\n       tree offset_tree = get_representative_tree (sym_byte_offset);\n@@ -4161,44 +4162,18 @@ tristate\n region_model::eval_condition (const svalue *lhs,\n \t\t\t       enum tree_code op,\n \t\t\t       const svalue *rhs) const\n-{\n-  /* For now, make no attempt to capture constraints on floating-point\n-     values.  */\n-  if ((lhs->get_type () && FLOAT_TYPE_P (lhs->get_type ()))\n-      || (rhs->get_type () && FLOAT_TYPE_P (rhs->get_type ())))\n-    return tristate::unknown ();\n-\n-  tristate ts = eval_condition_without_cm (lhs, op, rhs);\n-  if (ts.is_known ())\n-    return ts;\n-\n-  /* Otherwise, try constraints.  */\n-  return m_constraints->eval_condition (lhs, op, rhs);\n-}\n-\n-/* Determine what is known about the condition \"LHS_SVAL OP RHS_SVAL\" within\n-   this model, without resorting to the constraint_manager.\n-\n-   This is exposed so that impl_region_model_context::on_state_leak can\n-   check for equality part-way through region_model::purge_unused_svalues\n-   without risking creating new ECs.  */\n-\n-tristate\n-region_model::eval_condition_without_cm (const svalue *lhs,\n-\t\t\t\t\t  enum tree_code op,\n-\t\t\t\t\t  const svalue *rhs) const\n {\n   gcc_assert (lhs);\n   gcc_assert (rhs);\n \n-  /* See what we know based on the values.  */\n-\n   /* For now, make no attempt to capture constraints on floating-point\n      values.  */\n   if ((lhs->get_type () && FLOAT_TYPE_P (lhs->get_type ()))\n       || (rhs->get_type () && FLOAT_TYPE_P (rhs->get_type ())))\n     return tristate::unknown ();\n \n+  /* See what we know based on the values.  */\n+\n   /* Unwrap any unmergeable values.  */\n   lhs = lhs->unwrap_any_unmergeable ();\n   rhs = rhs->unwrap_any_unmergeable ();\n@@ -4292,9 +4267,7 @@ region_model::eval_condition_without_cm (const svalue *lhs,\n \t       shouldn't warn for.  */\n \t    if (binop->get_op () == POINTER_PLUS_EXPR)\n \t      {\n-\t\ttristate lhs_ts\n-\t\t  = eval_condition_without_cm (binop->get_arg0 (),\n-\t\t\t\t\t       op, rhs);\n+\t\ttristate lhs_ts = eval_condition (binop->get_arg0 (), op, rhs);\n \t\tif (lhs_ts.is_known ())\n \t\t  return lhs_ts;\n \t      }\n@@ -4327,7 +4300,7 @@ region_model::eval_condition_without_cm (const svalue *lhs,\n       }\n \n   /* Handle comparisons between two svalues with more than one operand.  */\n-\tif (const binop_svalue *binop = lhs->dyn_cast_binop_svalue ())\n+  if (const binop_svalue *binop = lhs->dyn_cast_binop_svalue ())\n     {\n       switch (op)\n \t{\n@@ -4369,10 +4342,14 @@ region_model::eval_condition_without_cm (const svalue *lhs,\n \t}\n     }\n \n-  return tristate::TS_UNKNOWN;\n+  /* Otherwise, try constraints.\n+     Cast to const to ensure we don't change the constraint_manager as we\n+     do this (e.g. by creating equivalence classes).  */\n+  const constraint_manager *constraints = m_constraints;\n+  return constraints->eval_condition (lhs, op, rhs);\n }\n \n-/* Subroutine of region_model::eval_condition_without_cm, for rejecting\n+/* Subroutine of region_model::eval_condition, for rejecting\n    equality of INIT_VAL(PARM) with &LOCAL.  */\n \n tristate\n@@ -4424,18 +4401,18 @@ region_model::symbolic_greater_than (const binop_svalue *bin_a,\n       /* Eliminate the right-hand side of both svalues.  */\n       if (const binop_svalue *bin_b = dyn_cast <const binop_svalue *> (b))\n \tif (bin_a->get_op () == bin_b->get_op ()\n-\t    && eval_condition_without_cm (bin_a->get_arg1 (),\n-\t\t\t\t\t  GT_EXPR,\n-\t\t\t\t\t  bin_b->get_arg1 ()).is_true ()\n-\t    && eval_condition_without_cm (bin_a->get_arg0 (),\n-\t\t\t\t\t  GE_EXPR,\n-\t\t\t\t\t  bin_b->get_arg0 ()).is_true ())\n+\t    && eval_condition (bin_a->get_arg1 (),\n+\t\t\t       GT_EXPR,\n+\t\t\t       bin_b->get_arg1 ()).is_true ()\n+\t    && eval_condition (bin_a->get_arg0 (),\n+\t\t\t       GE_EXPR,\n+\t\t\t       bin_b->get_arg0 ()).is_true ())\n \t  return tristate (tristate::TS_TRUE);\n \n       /* Otherwise, try to remove a positive offset or factor from BIN_A.  */\n       if (is_positive_svalue (bin_a->get_arg1 ())\n-\t  && eval_condition_without_cm (bin_a->get_arg0 (),\n-\t\t\t\t\tGE_EXPR, b).is_true ())\n+\t  && eval_condition (bin_a->get_arg0 (),\n+\t\t\t     GE_EXPR, b).is_true ())\n \t  return tristate (tristate::TS_TRUE);\n     }\n   return tristate::unknown ();"}, {"sha": "70c808f4973417c0036363b465e4a848770897a9", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=9bbcee450deb0f561b096924a3f148369333e54c", "patch": "@@ -450,9 +450,6 @@ class region_model\n   tristate eval_condition (const svalue *lhs,\n \t\t\t   enum tree_code op,\n \t\t\t   const svalue *rhs) const;\n-  tristate eval_condition_without_cm (const svalue *lhs,\n-\t\t\t\t      enum tree_code op,\n-\t\t\t\t      const svalue *rhs) const;\n   tristate compare_initial_and_pointer (const initial_svalue *init,\n \t\t\t\t\tconst region_svalue *ptr) const;\n   tristate symbolic_greater_than (const binop_svalue *a,"}, {"sha": "d10dd057d965444fb7d70a0e264a129a76b4a865", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-23.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbcee450deb0f561b096924a3f148369333e54c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-23.c?ref=9bbcee450deb0f561b096924a3f148369333e54c", "patch": "@@ -24,3 +24,14 @@ void test_2 (void)\n   __analyzer_eval (hide (NULL) - 1 == NULL); /* { dg-warning \"FALSE\" } */\n   __analyzer_eval (hide (NULL) + 1 == NULL); /* { dg-warning \"FALSE\" } */\n }\n+\n+void test_3 (void *p)\n+{\n+  if (!p)\n+    return;\n+  __analyzer_eval (hide (p) == NULL); /* { dg-warning \"FALSE\" } */\n+  __analyzer_eval (hide (p) + 1 != NULL); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (hide (p) + 1 == NULL); /* { dg-warning \"FALSE\" } */\n+  __analyzer_eval (hide (p) - 1 != NULL); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (hide (p) - 1 == NULL); /* { dg-warning \"FALSE\" } */\n+}"}]}