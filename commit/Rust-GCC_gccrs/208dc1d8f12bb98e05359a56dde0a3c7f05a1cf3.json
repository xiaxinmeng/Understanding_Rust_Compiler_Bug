{"sha": "208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA4ZGMxZDhmMTJiYjk4ZTA1MzU5YTU2ZGRlMGEzYzdmMDVhMWNmMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-08-20T17:31:16Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-08-20T17:31:16Z"}, "message": "sched.c (sched_analyze_insn): Add new parameter loop_note.\n\n* sched.c (sched_analyze_insn): Add new parameter loop_note.\nIf loop_note set, then serialize on this insn.\n(sched_analyze): New variable loop_note.  Pass to\nsched_analyze_insn.  Set it if we pass a NOTE_INSN_LOOP_BEG or\nNOTE_INSN_LOOP_END.\n(unlink_notes): Don't save away NOTE_INSN_LOOP_BEG or\nNOTE_INSN_LOOP_END notes.\n(schedule_block): Generalize code that looks for magic REG_DEAD\nnotes and converts them to notes.\n\nFrom-SVN: r7956", "tree": {"sha": "9f55e7470ea62cf3c5dd18e903c666cdfad9da06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f55e7470ea62cf3c5dd18e903c666cdfad9da06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3/comments", "author": null, "committer": null, "parents": [{"sha": "c4a9dd2e3a0bbe4b95a118cebb1c3063a74108f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4a9dd2e3a0bbe4b95a118cebb1c3063a74108f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4a9dd2e3a0bbe4b95a118cebb1c3063a74108f4"}], "stats": {"total": 78, "additions": 61, "deletions": 17}, "files": [{"sha": "6f8d42394843a7504ccfe086b34d9bd8f49eedd5", "filename": "gcc/sched.c", "status": "modified", "additions": 61, "deletions": 17, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=208dc1d8f12bb98e05359a56dde0a3c7f05a1cf3", "patch": "@@ -315,7 +315,7 @@ static void add_insn_mem_dependence\tPROTO((rtx *, rtx *, rtx, rtx));\n static void flush_pending_lists\t\tPROTO((rtx));\n static void sched_analyze_1\t\tPROTO((rtx, rtx));\n static void sched_analyze_2\t\tPROTO((rtx, rtx));\n-static void sched_analyze_insn\t\tPROTO((rtx, rtx));\n+static void sched_analyze_insn\t\tPROTO((rtx, rtx, int));\n static int sched_analyze\t\tPROTO((rtx, rtx));\n static void sched_note_set\t\tPROTO((int, rtx, int));\n static int rank_for_schedule\t\tPROTO((rtx *, rtx *));\n@@ -2013,8 +2013,9 @@ sched_analyze_2 (x, insn)\n /* Analyze an INSN with pattern X to find all dependencies.  */\n \n static void\n-sched_analyze_insn (x, insn)\n+sched_analyze_insn (x, insn, loop_note)\n      rtx x, insn;\n+     int loop_note;\n {\n   register RTX_CODE code = GET_CODE (x);\n   rtx link;\n@@ -2048,6 +2049,32 @@ sched_analyze_insn (x, insn)\n \t  sched_analyze_2 (XEXP (link, 0), insn);\n       }\n \n+  /* If there is a LOOP_{BEG,END} note in the middle of a basic block, then\n+     we must be sure that no instructions are scheduled across it.\n+     Otherwise, the reg_n_refs info (which depends on loop_depth) would\n+     become incorrect.  */\n+\n+  if (loop_note)\n+    {\n+      int max_reg = max_reg_num ();\n+\n+      for (i = 0; i < max_reg; i++)\n+\t{\n+\t  rtx u;\n+\t  for (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n+\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t  reg_last_uses[i] = 0;\n+\t  if (reg_last_sets[i])\n+\t    add_dependence (insn, reg_last_sets[i], 0);\n+\t}\n+      reg_pending_sets_all = 1;\n+\n+      flush_pending_lists (insn);\n+\n+      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n+\t\t\t\t       GEN_INT (loop_note), REG_NOTES (insn));\n+    }\n+\n   /* After reload, it is possible for an instruction to have a REG_DEAD note\n      for a register that actually dies a few instructions earlier.  For\n      example, this can happen with SECONDARY_MEMORY_NEEDED reloads.\n@@ -2135,14 +2162,16 @@ sched_analyze (head, tail)\n   register int n_insns = 0;\n   register rtx u;\n   register int luid = 0;\n+  int loop_note = 0;\n \n   for (insn = head; ; insn = NEXT_INSN (insn))\n     {\n       INSN_LUID (insn) = luid++;\n \n       if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n \t{\n-\t  sched_analyze_insn (PATTERN (insn), insn);\n+\t  sched_analyze_insn (PATTERN (insn), insn, loop_note);\n+\t  loop_note = 0;\n \t  n_insns += 1;\n \t}\n       else if (GET_CODE (insn) == CALL_INSN)\n@@ -2179,7 +2208,8 @@ sched_analyze (head, tail)\n \n \t      /* Add a fake REG_NOTE which we will later convert\n \t\t back into a NOTE_INSN_SETJMP note.  */\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD, constm1_rtx,\n+\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n+\t\t\t\t\t  GEN_INT (NOTE_INSN_SETJMP),\n \t\t\t\t\t  REG_NOTES (insn));\n \t    }\n \t  else\n@@ -2207,7 +2237,8 @@ sched_analyze (head, tail)\n \t    }\n \t  LOG_LINKS (sched_before_next_call) = 0;\n \n-\t  sched_analyze_insn (PATTERN (insn), insn);\n+\t  sched_analyze_insn (PATTERN (insn), insn, loop_note);\n+\t  loop_note = 0;\n \n \t  /* We don't need to flush memory for a function call which does\n \t     not involve memory.  */\n@@ -2224,6 +2255,10 @@ sched_analyze (head, tail)\n \t  last_function_call = insn;\n \t  n_insns += 1;\n \t}\n+      else if (GET_CODE (insn) == NOTE\n+\t       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END))\n+\tloop_note = NOTE_LINE_NUMBER (insn);\n \n       if (insn == tail)\n \treturn n_insns;\n@@ -2995,8 +3030,11 @@ unlink_notes (insn, tail)\n \n       /* Don't save away NOTE_INSN_SETJMPs, because they must remain\n \t immediately after the call they follow.  We use a fake\n-\t (REG_DEAD (const_int -1)) note to remember them.  */\n-      else if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP)\n+\t (REG_DEAD (const_int -1)) note to remember them.\n+\t Likewise with NOTE_INSN_LOOP_BEG and NOTE_INSN_LOOP_END.  */\n+      else if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END)\n \t{\n \t  /* Insert the note at the end of the notes list.  */\n \t  PREV_INSN (insn) = note_list;\n@@ -3813,17 +3851,23 @@ schedule_block (b, file)\n       PREV_INSN (last) = insn;\n       last = insn;\n \n-      /* Check to see if we need to re-emit a NOTE_INSN_SETJMP here.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  rtx note = find_reg_note (insn, REG_DEAD, constm1_rtx);\n+      /* Check to see if we need to re-emit any notes here.  */\n+      {\n+\trtx note;\n \n-\t  if (note)\n-\t    {\n-\t      emit_note_after (NOTE_INSN_SETJMP, insn);\n-\t      remove_note (insn, note);\n-\t    }\n-\t}\n+\tfor (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t  {\n+\t    if (REG_NOTE_KIND (note) == REG_DEAD\n+\t\t&& GET_CODE (XEXP (note, 0)) == CONST_INT)\n+\t      {\n+\t\tif (INTVAL (XEXP (note, 0)) == NOTE_INSN_SETJMP)\n+\t\t  emit_note_after (INTVAL (XEXP (note, 0)), insn);\n+\t\telse\n+\t\t  last = emit_note_before (INTVAL (XEXP (note, 0)), insn);\n+\t\tremove_note (insn, note);\n+\t      }\n+\t  }\n+      }\n \n       /* Everything that precedes INSN now either becomes \"ready\", if\n \t it can execute immediately before INSN, or \"pending\", if"}]}