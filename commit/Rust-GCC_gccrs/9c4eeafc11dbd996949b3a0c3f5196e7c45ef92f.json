{"sha": "9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM0ZWVhZmMxMWRiZDk5Njk0OWIzYTBjM2Y1MTk2ZTdjNDVlZjkyZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-10-10T19:43:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-10-10T19:43:49Z"}, "message": "tree.c (type_with_interoperable_signedness): New.\n\n\n\t* tree.c (type_with_interoperable_signedness): New.\n\t(gimple_canonical_types_compatible_p): Use it.\n\t* tree.h (type_with_interoperable_signedness): Declare\n\n\t* lto.c (hash_canonical_type): Honor\n\ttype_with_interoperable_signedness.\n\n\t* gfortran.dg/lto/bind_c-2_0.f90: New testcase.\n\t* gfortran.dg/lto/bind_c-2_1.c: New testcase.\n\t* gfortran.dg/lto/bind_c-3_0.f90: New testcase.\n\t* gfortran.dg/lto/bind_c-3_1.c: New testcase.\n\t* gfortran.dg/lto/bind_c-4_0.f90: New testcase.\n\t* gfortran.dg/lto/bind_c-4_1.c: New testcase.\n\t* gfortran.dg/lto/bind_c-5_0.f90: New testcase.\n\t* gfortran.dg/lto/bind_c-5_1.c: New testcase.\n\nFrom-SVN: r228680", "tree": {"sha": "a70d4b968b6a34668f485e3a39033f4dc68cf53c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a70d4b968b6a34668f485e3a39033f4dc68cf53c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/comments", "author": null, "committer": null, "parents": [{"sha": "05486daafd85d56f457ab6808a02de02d53d60b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05486daafd85d56f457ab6808a02de02d53d60b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05486daafd85d56f457ab6808a02de02d53d60b3"}], "stats": {"total": 424, "additions": 417, "deletions": 7}, "files": [{"sha": "e75b4eaac41a5c8a65b32b993c67e17befda9229", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -1,3 +1,8 @@\n+2015-10-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (hash_canonical_type): Honor\n+\ttype_with_interoperable_signedness.\n+\n 2015-09-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* lto-lang.c (DEF_FUNCTION_TYPE_VAR_6): New."}, {"sha": "76f8e07800670b6e2f3cb3b702bba570c5902e1c", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -288,6 +288,7 @@ static hashval_t\n hash_canonical_type (tree type)\n {\n   inchash::hash hstate;\n+  enum tree_code code;\n \n   /* We compute alias sets only for types that needs them.\n      Be sure we do not recurse to something else as we can not hash incomplete\n@@ -299,7 +300,8 @@ hash_canonical_type (tree type)\n      smaller sets; when searching for existing matching types to merge,\n      only existing types having the same features as the new type will be\n      checked.  */\n-  hstate.add_int (tree_code_for_canonical_type_merging (TREE_CODE (type)));\n+  code = tree_code_for_canonical_type_merging (TREE_CODE (type));\n+  hstate.add_int (code);\n   hstate.add_int (TYPE_MODE (type));\n \n   /* Incorporate common features of numerical types.  */\n@@ -309,8 +311,9 @@ hash_canonical_type (tree type)\n       || TREE_CODE (type) == OFFSET_TYPE\n       || POINTER_TYPE_P (type))\n     {\n-      hstate.add_int (TYPE_UNSIGNED (type));\n       hstate.add_int (TYPE_PRECISION (type));\n+      if (!type_with_interoperable_signedness (type))\n+        hstate.add_int (TYPE_UNSIGNED (type));\n     }\n \n   if (VECTOR_TYPE_P (type))"}, {"sha": "b558a9e972395f50b1e5e70b2f95d22fb83df560", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -1,3 +1,14 @@\n+2015-10-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gfortran.dg/lto/bind_c-2_0.f90: New testcase.\n+\t* gfortran.dg/lto/bind_c-2_1.c: New testcase.\n+\t* gfortran.dg/lto/bind_c-3_0.f90: New testcase.\n+\t* gfortran.dg/lto/bind_c-3_1.c: New testcase.\n+\t* gfortran.dg/lto/bind_c-4_0.f90: New testcase.\n+\t* gfortran.dg/lto/bind_c-4_1.c: New testcase.\n+\t* gfortran.dg/lto/bind_c-5_0.f90: New testcase.\n+\t* gfortran.dg/lto/bind_c-5_1.c: New testcase.\n+\n 2015-10-09  Steve Ellcey  <sellcey@imgtec.com>\n \n \t* gcc.target/mips/mips.exp (mips_option_groups): Add -mframe-header-opt"}, {"sha": "8ac2fd4bc0026f70d8f6a937b70cba65f2da5745", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-2_0.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-2_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-2_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-2_0.f90?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,21 @@\n+! { dg-lto-do run }\n+! { dg-lto-options {{ -O3 -flto }} }\n+! This testcase will abort if C_PTR is not interoperable with both int *\n+! and float *\n+module lto_type_merge_test\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  type, bind(c) :: MYFTYPE_1\n+     integer(c_signed_char) :: chr\n+     integer(c_signed_char) :: chrb\n+  end type MYFTYPE_1\n+\n+  type(myftype_1), bind(c, name=\"myVar\") :: myVar\n+\n+contains\n+  subroutine types_test() bind(c)\n+    myVar%chr = myVar%chrb\n+  end subroutine types_test\n+end module lto_type_merge_test\n+"}, {"sha": "22ec591d0815e048572a96e1a5beb4e57da7dbd2", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-2_1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-2_1.c?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,36 @@\n+#include <stdlib.h>\n+/* interopse with myftype_1 */\n+typedef struct {\n+   unsigned char chr;\n+   signed char chr2;\n+} myctype_t;\n+\n+\n+extern void abort(void);\n+void types_test(void);\n+/* declared in the fortran module */\n+extern myctype_t myVar;\n+\n+int main(int argc, char **argv)\n+{\n+   myctype_t *cchr;\n+   asm(\"\":\"=r\"(cchr):\"0\"(&myVar));\n+   cchr->chr = 1;\n+   cchr->chr2 = 2;\n+\n+   types_test();\n+\n+   if(cchr->chr != 2)\n+      abort();\n+   if(cchr->chr2 != 2)\n+      abort();\n+   myVar.chr2 = 3;\n+   types_test();\n+\n+   if(myVar.chr != 3)\n+      abort();\n+   if(myVar.chr2 != 3)\n+      abort();\n+   return 0;\n+}\n+"}, {"sha": "e969eef3dc03c410d3e3d26a97e3263e78824271", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-3_0.f90", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-3_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-3_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-3_0.f90?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,91 @@\n+! { dg-lto-do run }\n+! { dg-lto-options {{ -O3 -flto }} }\n+! This testcase will abort if integer types are not interoperable.\n+module lto_type_merge_test\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  type, bind(c) :: MYFTYPE_1\n+    integer(c_int) :: val_int\n+    integer(c_short) :: val_short\n+    integer(c_long) :: val_long\n+    integer(c_long_long) :: val_long_long\n+    integer(c_size_t) :: val_size_t\n+    integer(c_int8_t) :: val_int8_t\n+    integer(c_int16_t) :: val_int16_t\n+    integer(c_int32_t) :: val_int32_t\n+    integer(c_int64_t) :: val_int64_t\n+    integer(c_int_least8_t) :: val_intleast_8_t\n+    integer(c_int_least16_t) :: val_intleast_16_t\n+    integer(c_int_least32_t) :: val_intleast_32_t\n+    integer(c_int_least64_t) :: val_intleast_64_t\n+    integer(c_int_fast8_t) :: val_intfast_8_t\n+    integer(c_int_fast16_t) :: val_intfast_16_t\n+    integer(c_int_fast32_t) :: val_intfast_32_t\n+    integer(c_int_fast64_t) :: val_intfast_64_t\n+    integer(c_intmax_t) :: val_intmax_t\n+    integer(c_intptr_t) :: val_intptr_t\n+  end type MYFTYPE_1\n+\n+  type(myftype_1), bind(c, name=\"myVar\") :: myVar\n+\n+contains\n+  subroutine types_test1() bind(c)\n+    myVar%val_int = 2\n+  end subroutine types_test1\n+  subroutine types_test2() bind(c)\n+    myVar%val_short = 2\n+  end subroutine types_test2\n+  subroutine types_test3() bind(c)\n+    myVar%val_long = 2\n+  end subroutine types_test3\n+  subroutine types_test4() bind(c)\n+    myVar%val_long_long = 2\n+  end subroutine types_test4\n+  subroutine types_test5() bind(c)\n+    myVar%val_size_t = 2\n+  end subroutine types_test5\n+  subroutine types_test6() bind(c)\n+    myVar%val_int8_t = 2\n+  end subroutine types_test6\n+  subroutine types_test7() bind(c)\n+    myVar%val_int16_t = 2\n+  end subroutine types_test7\n+  subroutine types_test8() bind(c)\n+    myVar%val_int32_t = 2\n+  end subroutine types_test8\n+  subroutine types_test9() bind(c)\n+    myVar%val_int64_t = 2\n+  end subroutine types_test9\n+  subroutine types_test10() bind(c)\n+    myVar%val_intleast_8_t = 2\n+  end subroutine types_test10\n+  subroutine types_test11() bind(c)\n+    myVar%val_intleast_16_t = 2\n+  end subroutine types_test11\n+  subroutine types_test12() bind(c)\n+    myVar%val_intleast_32_t = 2\n+  end subroutine types_test12\n+  subroutine types_test13() bind(c)\n+    myVar%val_intleast_64_t = 2\n+  end subroutine types_test13\n+  subroutine types_test14() bind(c)\n+    myVar%val_intfast_8_t = 2\n+  end subroutine types_test14\n+  subroutine types_test15() bind(c)\n+    myVar%val_intfast_16_t = 2\n+  end subroutine types_test15\n+  subroutine types_test16() bind(c)\n+    myVar%val_intfast_32_t = 2\n+  end subroutine types_test16\n+  subroutine types_test17() bind(c)\n+    myVar%val_intfast_64_t = 2\n+  end subroutine types_test17\n+  subroutine types_test18() bind(c)\n+    myVar%val_intmax_t = 2\n+  end subroutine types_test18\n+  subroutine types_test19() bind(c)\n+    myVar%val_intptr_t = 2\n+  end subroutine types_test19\n+end module lto_type_merge_test\n+"}, {"sha": "5c4835c66f8a33c8f737b14376ffde4aa10004d3", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-3_1.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-3_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-3_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-3_1.c?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,78 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+/* interopse with myftype_1 */\n+typedef struct {\n+  int val1;\n+  short int val2;\n+  long int val3;\n+  long long int val4;\n+  size_t val5;\n+  int8_t val6;\n+  int16_t val7;\n+  int32_t val8;\n+  int64_t val9;\n+  int_least8_t val10;\n+  int_least16_t val11;\n+  int_least32_t val12;\n+  int_least64_t val13;\n+  int_fast8_t val14;\n+  int_fast16_t val15;\n+  int_fast32_t val16;\n+  int_fast64_t val17;\n+  intmax_t val18;\n+  intptr_t val19;\n+} myctype_t;\n+\n+\n+extern void abort(void);\n+void types_test1(void);\n+void types_test2(void);\n+void types_test3(void);\n+void types_test4(void);\n+void types_test5(void);\n+void types_test6(void);\n+void types_test7(void);\n+void types_test8(void);\n+void types_test9(void);\n+void types_test10(void);\n+void types_test11(void);\n+void types_test12(void);\n+void types_test13(void);\n+void types_test14(void);\n+void types_test15(void);\n+void types_test16(void);\n+void types_test17(void);\n+void types_test18(void);\n+void types_test19(void);\n+/* declared in the fortran module */\n+extern myctype_t myVar;\n+\n+#define test(n)\\\n+  cchr->val##n = 1; types_test##n (); if (cchr->val##n != 2) abort ();\n+\n+int main(int argc, char **argv)\n+{\n+   myctype_t *cchr;\n+   asm(\"\":\"=r\"(cchr):\"0\"(&myVar));\n+   test(1);\n+   test(2);\n+   test(3);\n+   test(4);\n+   test(5);\n+   test(6);\n+   test(7);\n+   test(8);\n+   test(9);\n+   test(10);\n+   test(11);\n+   test(12);\n+   test(13);\n+   test(14);\n+   test(15);\n+   test(16);\n+   test(17);\n+   test(18);\n+   test(19);\n+   return 0;\n+}\n+"}, {"sha": "2dadb38dcbda38e392b2f8d01a9345bdded04369", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-4_0.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-4_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-4_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-4_0.f90?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,48 @@\n+! { dg-lto-do run }\n+! { dg-lto-options {{ -O3 -flto }} }\n+! This testcase will abort if real/complex/boolean/character types are not interoperable\n+module lto_type_merge_test\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  type, bind(c) :: MYFTYPE_1\n+    real(c_float) :: val_1\n+    real(c_double) :: val_2\n+    real(c_long_double) :: val_3\n+    complex(c_float_complex) :: val_4\n+    complex(c_double_complex) :: val_5\n+    complex(c_long_double_complex) :: val_6\n+    logical(c_bool) :: val_7\n+    !FIXME: Fortran define c_char as array of size 1.\n+    !character(c_char) :: val_8\n+  end type MYFTYPE_1\n+\n+  type(myftype_1), bind(c, name=\"myVar\") :: myVar\n+\n+contains\n+  subroutine types_test1() bind(c)\n+    myVar%val_1 = 2\n+  end subroutine types_test1\n+  subroutine types_test2() bind(c)\n+    myVar%val_2 = 2\n+  end subroutine types_test2\n+  subroutine types_test3() bind(c)\n+    myVar%val_3 = 2\n+  end subroutine types_test3\n+  subroutine types_test4() bind(c)\n+    myVar%val_4 = 2\n+  end subroutine types_test4\n+  subroutine types_test5() bind(c)\n+    myVar%val_5 = 2\n+  end subroutine types_test5\n+  subroutine types_test6() bind(c)\n+    myVar%val_6 = 2\n+  end subroutine types_test6\n+  subroutine types_test7() bind(c)\n+    myVar%val_7 = myVar%val_7 .or. .not. myVar%val_7\n+  end subroutine types_test7\n+  !subroutine types_test8() bind(c)\n+    !myVar%val_8 = \"a\"\n+  !end subroutine types_test8\n+end module lto_type_merge_test\n+"}, {"sha": "2e2a3e34a276644bb73f6386646be38946a3ff46", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-4_1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-4_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-4_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-4_1.c?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,46 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+/* interopse with myftype_1 */\n+typedef struct {\n+  float val1;\n+  double val2;\n+  long double val3;\n+  float _Complex val4;\n+  double _Complex val5;\n+  long double _Complex val6;\n+  _Bool val7;\n+  /* FIXME: Fortran define c_char as array of size 1.\n+     char val8;  */\n+} myctype_t;\n+\n+\n+extern void abort(void);\n+void types_test1(void);\n+void types_test2(void);\n+void types_test3(void);\n+void types_test4(void);\n+void types_test5(void);\n+void types_test6(void);\n+void types_test7(void);\n+void types_test8(void);\n+/* declared in the fortran module */\n+extern myctype_t myVar;\n+\n+#define test(n)\\\n+  cchr->val##n = 1; types_test##n (); if (cchr->val##n != 2) abort ();\n+\n+int main(int argc, char **argv)\n+{\n+   myctype_t *cchr;\n+   asm(\"\":\"=r\"(cchr):\"0\"(&myVar));\n+   test(1);\n+   test(2);\n+   test(3);\n+   test(4);\n+   test(5);\n+   test(6);\n+   cchr->val7 = 0; types_test7 (); if (cchr->val7 != 1) abort ();\n+   /*cchr->val8 = 0; types_test8 (); if (cchr->val8 != 'a') abort ();*/\n+   return 0;\n+}\n+"}, {"sha": "836db098d4ac06838658a623c5513263df3f44d4", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-5_0.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-5_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-5_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-5_0.f90?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,17 @@\n+! { dg-lto-do run }\n+! { dg-lto-options {{ -O3 -flto }} }\n+! This testcase will abort if C_FUNPTR is not interoperable with both int *\n+! and float *\n+module lto_type_merge_test\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  type(c_funptr), bind(c, name=\"myVar\") :: myVar\n+  type(c_funptr), bind(c, name=\"myVar2\") :: myVar2\n+\n+contains\n+  subroutine types_test() bind(c)\n+    myVar = myVar2\n+  end subroutine types_test\n+end module lto_type_merge_test\n+"}, {"sha": "6a0eb0352a914860385cd33940fab7e430db8f10", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-5_1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-5_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-5_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-5_1.c?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -0,0 +1,31 @@\n+#include <stdlib.h>\n+/* declared in the fortran module */\n+extern int (*myVar) (int);\n+extern float (*myVar2) (float);\n+void types_test(void);\n+\n+\n+extern void abort(void);\n+\n+int main(int argc, char **argv)\n+{\n+   int (**myptr) (int);\n+   float (**myptr2) (float);\n+   asm(\"\":\"=r\"(myptr):\"0\"(&myVar));\n+   asm(\"\":\"=r\"(myptr2):\"0\"(&myVar2));\n+   *myptr = (int (*) (int)) (size_t) (void *)1;\n+   *myptr2 = (float (*) (float)) (size_t) (void *)2;\n+   types_test();\n+   if (*myptr != (int (*) (int)) (size_t) (void *)2)\n+\tabort ();\n+   if (*myptr2 != (float (*) (float)) (size_t) (void *)2)\n+\tabort ();\n+   *myptr2 = (float (*) (float)) (size_t) (void *)3;\n+   types_test();\n+   if (*myptr != (int (*) (int)) (size_t) (void *)3)\n+\tabort ();\n+   if (*myptr2 != (float (*) (float)) (size_t) (void *)3)\n+\tabort ();\n+   return 0;\n+}\n+"}, {"sha": "02f0a7aa4d498542e039343666fff779ebd307dc", "filename": "gcc/tree.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -13012,6 +13012,23 @@ verify_type_variant (const_tree t, tree tv)\n    back to pointer-comparison of TYPE_CANONICAL for aggregates\n    for example.  */\n \n+/* Return true if TYPE_UNSIGNED of TYPE should be ignored for canonical\n+   type calculation because we need to allow inter-operability between signed\n+   and unsigned variants.  */\n+\n+bool\n+type_with_interoperable_signedness (const_tree type)\n+{\n+  /* Fortran standard require C_SIGNED_CHAR to be interoperable with both\n+     signed char and unsigned char.  Similarly fortran FE builds\n+     C_SIZE_T as signed type, while C defines it unsigned.  */\n+\n+  return tree_code_for_canonical_type_merging (TREE_CODE (type))\n+\t   == INTEGER_TYPE\n+         && (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node)\n+\t     || TYPE_PRECISION (type) == TYPE_PRECISION (size_type_node));\n+}\n+\n /* Return true iff T1 and T2 are structurally identical for what\n    TBAA is concerned.  \n    This function is used both by lto.c canonical type merging and by the\n@@ -13062,8 +13079,8 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n     return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n \n   /* Can't be the same type if the types don't have the same code.  */\n-  if (tree_code_for_canonical_type_merging (TREE_CODE (t1))\n-      != tree_code_for_canonical_type_merging (TREE_CODE (t2)))\n+  enum tree_code code = tree_code_for_canonical_type_merging (TREE_CODE (t1));\n+  if (code != tree_code_for_canonical_type_merging (TREE_CODE (t2)))\n     return false;\n \n   /* Qualifiers do not matter for canonical type comparison purposes.  */\n@@ -13086,9 +13103,14 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n       || TREE_CODE (t1) == OFFSET_TYPE\n       || POINTER_TYPE_P (t1))\n     {\n-      /* Can't be the same type if they have different sign or precision.  */\n-      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+      /* Can't be the same type if they have different recision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2))\n+\treturn false;\n+\n+      /* In some cases the signed and unsigned types are required to be\n+\t inter-operable.  */\n+      if (TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2)\n+\t  && !type_with_interoperable_signedness (t1))\n \treturn false;\n \n       /* Fortran's C_SIGNED_CHAR is !TYPE_STRING_FLAG but needs to be"}, {"sha": "a776b899b802b6b719b359df553002ce642b3ce9", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9c4eeafc11dbd996949b3a0c3f5196e7c45ef92f", "patch": "@@ -4609,6 +4609,7 @@ extern int tree_map_base_marked_p (const void *);\n extern void DEBUG_FUNCTION verify_type (const_tree t);\n extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,\n \t\t\t\t\t\t bool trust_type_canonical = true);\n+extern bool type_with_interoperable_signedness (const_tree);\n /* Return simplified tree code of type that is used for canonical type merging.  */\n inline enum tree_code\n tree_code_for_canonical_type_merging (enum tree_code code)"}]}