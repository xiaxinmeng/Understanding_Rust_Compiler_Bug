{"sha": "c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU5ZjVkMWI2NDRiNmVkMTZhMDY0MTBkZDBmZTQwNTVhOGEzN2JkMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-10-22T11:40:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-10-22T11:40:18Z"}, "message": "re PR tree-optimization/40556 (ICE in IPA-CP with recursion)\n\n\n\tPR tree-optimize/40556                                                                                                                                         \n\t* ipa-reference.c (has_proper_scope_for_analysis): Add fixme about global vars.                                                                                \n\t(check_call): Handle only indirect calls.                                                                                                                      \n\t(propagate_bits): Update comment.                                                                                                                              \n\t(write_node_summary_p): Turn bogus check to assert.                                                                                                            \n\t(ipa_reference_write_summary): Stream calls_read_all properly.                                                                                                 \n\t(ipa_reference_read_summary): Stream in calls_read_all properly.                                                                                               \n\t(read_write_all_from_decl): New function.                                                                                                                      \n\t(propagate): Handle OVERWRITABLE nodes and external calls here.                                                                                                \n\t* ipa-pre-const.c (check_call): In IPA mode handle indirect calls                                                                                              \n\tonly.                                                                                                                                                          \n\t(analyze_function): Do not check visibility here.                                                                                                              \n\t(add_new_function): We summary OVERWRITABLE too.                                                                                                               \n\t(generate_summary): Stream OVERWRITABLE nodes too.                                                                                                             \n\t(propagate): Handle external calls and OVERWRITABLE nodes here.                                                                                                \n\t(local_pure_const): Check visibility here.\n\nFrom-SVN: r153450", "tree": {"sha": "0ab06e5072b8d0118d4bed1aa031422e8dd59204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ab06e5072b8d0118d4bed1aa031422e8dd59204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/comments", "author": null, "committer": null, "parents": [{"sha": "fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d"}], "stats": {"total": 264, "additions": 186, "deletions": 78}, "files": [{"sha": "a709e5312d5fc303d132c80f9f151ce6d08aaae0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "patch": "@@ -1,3 +1,22 @@\n+2009-10-22  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimize/40556                                                                                                                                         \n+\t* ipa-reference.c (has_proper_scope_for_analysis): Add fixme about global vars.                                                                                \n+\t(check_call): Handle only indirect calls.                                                                                                                      \n+\t(propagate_bits): Update comment.                                                                                                                              \n+\t(write_node_summary_p): Turn bogus check to assert.                                                                                                            \n+\t(ipa_reference_write_summary): Stream calls_read_all properly.                                                                                                 \n+\t(ipa_reference_read_summary): Stream in calls_read_all properly.                                                                                               \n+\t(read_write_all_from_decl): New function.                                                                                                                      \n+\t(propagate): Handle OVERWRITABLE nodes and external calls here.                                                                                                \n+\t* ipa-pre-const.c (check_call): In IPA mode handle indirect calls                                                                                              \n+\tonly.                                                                                                                                                          \n+\t(analyze_function): Do not check visibility here.                                                                                                              \n+\t(add_new_function): We summary OVERWRITABLE too.                                                                                                               \n+\t(generate_summary): Stream OVERWRITABLE nodes too.                                                                                                             \n+\t(propagate): Handle external calls and OVERWRITABLE nodes here.                                                                                                \n+\t(local_pure_const): Check visibility here.                                                                                                                     \n+\n 2009-10-22  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-cp.c (ipcp_write_summary, ipcp_read_summary): New functions."}, {"sha": "e37af05d08ee3af04d66888b8703b95927c2029c", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "patch": "@@ -330,12 +330,11 @@ check_call (funct_state local, gimple call, bool ipa)\n   /* When not in IPA mode, we can still handle self recursion.  */\n   if (!ipa && callee_t == current_function_decl)\n     local->looping = true;\n-  /* The callee is either unknown (indirect call) or there is just no\n-     scannable code for it (external call) .  We look to see if there\n-     are any bits available for the callee (such as by declaration or\n-     because it is builtin) and process solely on the basis of those\n-     bits. */\n-  else if (avail <= AVAIL_OVERWRITABLE || !ipa)\n+  /* Either calle is unknown or we are doing local analysis.\n+     Look to see if there are any bits available for the callee (such as by\n+     declaration or because it is builtin) and process solely on the basis of\n+     those bits. */\n+  else if (!ipa || !callee_t)\n     {\n       if (possibly_throws && flag_non_call_exceptions)\n         {\n@@ -492,13 +491,6 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   funct_state l;\n   basic_block this_block;\n \n-  if (cgraph_function_body_availability (fn) <= AVAIL_OVERWRITABLE)\n-    {\n-      if (dump_file)\n-        fprintf (dump_file, \"Function is not available or overwrittable; not analyzing.\\n\");\n-      return NULL;\n-    }\n-\n   l = XCNEW (struct funct_state_d);\n   l->pure_const_state = IPA_CONST;\n   l->state_previously_known = IPA_NEITHER;\n@@ -609,7 +601,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n static void\n add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n- if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+ if (cgraph_function_body_availability (node) < AVAIL_OVERWRITABLE)\n    return;\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n@@ -686,12 +678,12 @@ generate_summary (void)\n \n   /* Process all of the functions. \n \n-     We do NOT process any AVAIL_OVERWRITABLE functions, we cannot\n-     guarantee that what we learn about the one we see will be true\n-     for the one that overrides it.\n-  */\n+     We process AVAIL_OVERWRITABLE functions.  We can not use the results\n+     by default, but the info can be used at LTO with -fwhole-program or\n+     when function got clonned and the clone is AVAILABLE.  */\n+\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n+    if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       set_function_state (node, analyze_function (node, true));\n \n   pointer_set_destroy (visited_nodes);\n@@ -878,6 +870,12 @@ propagate (void)\n \n \t  if (w_l->looping)\n \t    looping = true;\n+\t  if (cgraph_function_body_availability (w) == AVAIL_OVERWRITABLE)\n+\t    {\n+\t      looping |= w_l->looping_previously_known;\n+\t      if (pure_const_state < w_l->state_previously_known)\n+\t        pure_const_state = w_l->state_previously_known;\n+\t    }\n \n \t  if (pure_const_state == IPA_NEITHER)\n \t    break;\n@@ -901,6 +899,20 @@ propagate (void)\n \t\t  if (y_l->looping)\n \t\t    looping = true;\n \t\t}\n+\t      else\n+\t        {\n+\t\t  int flags = flags_from_decl_or_type (y->decl);\n+\n+\t\t  if (flags & ECF_LOOPING_CONST_OR_PURE)\n+\t\t    looping = true;\n+\t\t  if (flags & ECF_CONST)\n+\t\t    ;\n+\t\t  else if ((flags & ECF_PURE) && pure_const_state == IPA_CONST)\n+\t\t    pure_const_state = IPA_PURE;\n+\t\t  else\n+\t\t    pure_const_state = IPA_NEITHER, looping = true;\n+\n+\t\t}\n \t    }\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n@@ -988,7 +1000,8 @@ propagate (void)\n \t  struct cgraph_edge *e;\n \t  funct_state w_l = get_function_state (w);\n \n-\t  if (w_l->can_throw)\n+\t  if (w_l->can_throw\n+\t      || cgraph_function_body_availability (w) == AVAIL_OVERWRITABLE)\n \t    can_throw = true;\n \n \t  if (can_throw)\n@@ -1008,6 +1021,8 @@ propagate (void)\n \t\t      && e->can_throw_external)\n \t\t    can_throw = true;\n \t\t}\n+\t      else if (e->can_throw_external && !TREE_NOTHROW (y->decl))\n+\t        can_throw = true;\n \t    }\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n@@ -1046,7 +1061,7 @@ propagate (void)\n \t  free (node->aux);\n \t  node->aux = NULL;\n \t}\n-      if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n+      if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n \tfree (get_function_state (node));\n     }\n   \n@@ -1109,15 +1124,16 @@ local_pure_const (void)\n         fprintf (dump_file, \"Function called in recursive cycle; ignoring\\n\");\n       return 0;\n     }\n-\n-  l = analyze_function (cgraph_node (current_function_decl), false);\n-  if (!l)\n+  if (cgraph_function_body_availability (cgraph_node (current_function_decl))\n+      <= AVAIL_OVERWRITABLE)\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Function has wrong visibility; ignoring\\n\");\n       return 0;\n     }\n \n+  l = analyze_function (cgraph_node (current_function_decl), false);\n+\n   switch (l->pure_const_state)\n     {\n     case IPA_CONST:"}, {"sha": "f0e8aa0aaedacc051c47c4b0702e64c2273ed290", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 101, "deletions": 54, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "patch": "@@ -318,6 +318,8 @@ has_proper_scope_for_analysis (tree t)\n   if (!TREE_STATIC (t) && !DECL_EXTERNAL (t))\n     return false;\n \n+  /* FIXME: for LTO we should include PUBLIC vars too.  This is bit difficult\n+     as summarie would need unsharing.  */\n   if (DECL_EXTERNAL (t) || TREE_PUBLIC (t))\n     return false;\n \n@@ -413,31 +415,21 @@ check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n {\n   int flags = gimple_call_flags (stmt);\n   tree callee_t = gimple_call_fndecl (stmt);\n-  enum availability avail = AVAIL_NOT_AVAILABLE;\n \n-  if (callee_t)\n+  /* Process indirect calls.  All direct calles are handled at propagation\n+     time.  */\n+  if (!callee_t)\n     {\n-      struct cgraph_node* callee = cgraph_node(callee_t);\n-      avail = cgraph_function_body_availability (callee);\n-    }\n-\n-  if (avail <= AVAIL_OVERWRITABLE)\n-    if (local) \n-      {\n-\tif (flags & ECF_CONST) \n-\t  ;\n-\telse if (flags & ECF_PURE)\n+      if (flags & ECF_CONST) \n+\t;\n+      else if (flags & ECF_PURE)\n+\tlocal->calls_read_all = true;\n+      else \n+\t{\n \t  local->calls_read_all = true;\n-\telse \n-\t  {\n-\t    local->calls_read_all = true;\n-\t    local->calls_write_all = true;\n-\t  }\n-      }\n-   /* TODO: To be able to produce sane results, we should also handle\n-      common builtins, in particular throw.\n-      Indirect calls hsould be only counted and as inliner is replacing them\n-      by direct calls, we can conclude if any indirect calls are left in body */\n+\t  local->calls_write_all = true;\n+\t}\n+    }\n }\n \n /* TP is the part of the tree currently under the microscope.\n@@ -527,7 +519,7 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n     {\n       struct cgraph_node *y = e->callee;\n \n-      /* Only look at the master nodes and skip external nodes.  */\n+      /* Only look into nodes we can propagate something.  */\n       if (cgraph_function_body_availability (e->callee) > AVAIL_OVERWRITABLE)\n \t{\n \t  if (get_reference_vars_info (y))\n@@ -1012,8 +1004,8 @@ generate_summary (void)\n static bool\n write_node_summary_p (struct cgraph_node *node)\n {\n+  gcc_assert (node->global.inlined_to == NULL);\n   return (node->analyzed \n-\t  && node->global.inlined_to == NULL\n \t  && cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE\n \t  && get_reference_vars_info (node) != NULL);\n }\n@@ -1053,18 +1045,28 @@ ipa_reference_write_summary (cgraph_node_set set)\n \t  lto_output_uleb128_stream (ob->main_stream, node_ref);\n \n \t  /* Stream out the statics read.  */\n-\t  lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t     bitmap_count_bits (l->statics_read));\n-\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_read, 0, index, bi)\n-\t    lto_output_var_decl_index(ob->decl_state, ob->main_stream,\n-\t\t\t\t      get_static_decl (index));\n+\t  if (l->calls_read_all)\n+\t    lto_output_sleb128_stream (ob->main_stream, -1);\n+\t  else\n+\t    {\n+\t      lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t\t\t bitmap_count_bits (l->statics_read));\n+\t      EXECUTE_IF_SET_IN_BITMAP (l->statics_read, 0, index, bi)\n+\t\tlto_output_var_decl_index(ob->decl_state, ob->main_stream,\n+\t\t\t\t\t  get_static_decl (index));\n+\t    }\n \n \t  /* Stream out the statics written.  */\n-\t  lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t     bitmap_count_bits (l->statics_written));\n-\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_written, 0, index, bi)\n-\t    lto_output_var_decl_index(ob->decl_state, ob->main_stream,\n-\t\t\t\t      get_static_decl (index));\n+\t  if (l->calls_write_all)\n+\t    lto_output_sleb128_stream (ob->main_stream, -1);\n+\t  else\n+\t    {\n+\t      lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t\t\t bitmap_count_bits (l->statics_written));\n+\t      EXECUTE_IF_SET_IN_BITMAP (l->statics_written, 0, index, bi)\n+\t\tlto_output_var_decl_index(ob->decl_state, ob->main_stream,\n+\t\t\t\t\t  get_static_decl (index));\n+\t    }\n \t}\n     }\n   lto_destroy_simple_output_block (ob);\n@@ -1101,7 +1103,7 @@ ipa_reference_read_summary (void)\n \t      unsigned int j, index;\n \t      struct cgraph_node *node;\n \t      ipa_reference_local_vars_info_t l;\n-\t      unsigned int v_count;\n+\t      int v_count;\n \t      lto_cgraph_encoder_t encoder;\n \n \t      index = lto_input_uleb128 (ib);\n@@ -1110,26 +1112,32 @@ ipa_reference_read_summary (void)\n \t      l = init_function_info (node);\n \n \t      /* Set the statics read.  */\n-\t      v_count = lto_input_uleb128 (ib);\n-\t      for (j = 0; j < v_count; j++)\n-\t\t{\n-\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n-\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n-\t\t\t\t\t\t\t\t var_index);\n-\t\t  add_static_var (v_decl);\n-\t\t  bitmap_set_bit (l->statics_read, DECL_UID (v_decl));\n-\t\t} \n+\t      v_count = lto_input_sleb128 (ib);\n+\t      if (v_count == -1)\n+\t        l->calls_read_all = true;\n+\t      else\n+\t\tfor (j = 0; j < (unsigned int)v_count; j++)\n+\t\t  {\n+\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t   var_index);\n+\t\t    add_static_var (v_decl);\n+\t\t    bitmap_set_bit (l->statics_read, DECL_UID (v_decl));\n+\t\t  } \n \n \t      /* Set the statics written.  */\n-\t      v_count = lto_input_uleb128 (ib);\n-\t      for (j = 0; j < v_count; j++)\n-\t\t{\n-\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n-\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n-\t\t\t\t\t\t\t\t var_index);\n-\t\t  add_static_var (v_decl);\n-\t\t  bitmap_set_bit (l->statics_written, DECL_UID (v_decl));\n-\t\t} \n+\t      v_count = lto_input_sleb128 (ib);\n+\t      if (v_count == -1)\n+\t        l->calls_read_all = true;\n+\t      else\n+\t\tfor (j = 0; j < (unsigned int)v_count; j++)\n+\t\t  {\n+\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t   var_index);\n+\t\t    add_static_var (v_decl);\n+\t\t    bitmap_set_bit (l->statics_written, DECL_UID (v_decl));\n+\t\t  } \n \t    }\n \n \t  lto_destroy_simple_input_block (file_data, \n@@ -1141,6 +1149,26 @@ ipa_reference_read_summary (void)\n \n \n \f\n+/* Set READ_ALL/WRITE_ALL based on DECL flags.  */\n+static void\n+read_write_all_from_decl (tree decl, bool * read_all, bool * write_all)\n+{\n+  int flags = flags_from_decl_or_type (decl);\n+  if (flags & ECF_CONST)\n+    ;\n+  else if (flags & ECF_PURE)\n+    *read_all = true;\n+  else\n+    {\n+       /* TODO: To be able to produce sane results, we should also handle\n+\t  common builtins, in particular throw.\n+\t  Indirect calls hsould be only counted and as inliner is replacing them\n+\t  by direct calls, we can conclude if any indirect calls are left in body */\n+      *read_all = true;\n+      *write_all = true;\n+    }\n+}\n+\n /* Produce the global information by preforming a transitive closure\n    on the local information that was produced by ipa_analyze_function\n    and ipa_analyze_variable.  */\n@@ -1173,6 +1201,7 @@ propagate (void)\n       ipa_reference_global_vars_info_t node_g = \n \tXCNEW (struct ipa_reference_global_vars_info_d);\n       ipa_reference_local_vars_info_t node_l;\n+      struct cgraph_edge *e;\n       \n       bool read_all;\n       bool write_all;\n@@ -1193,6 +1222,15 @@ propagate (void)\n       read_all = node_l->calls_read_all;\n       write_all = node_l->calls_write_all;\n \n+      /* When function is overwrittable, we can not assume anything.  */\n+      if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+        read_write_all_from_decl (node->decl, &read_all, &write_all);\n+\n+      for (e = node->callees; e; e = e->next_callee) \n+        if (cgraph_function_body_availability (e->callee) <= AVAIL_OVERWRITABLE)\n+          read_write_all_from_decl (e->callee->decl, &read_all, &write_all);\n+\n+\n       /* If any node in a cycle is calls_read_all or calls_write_all\n \t they all are. */\n       w_info = (struct ipa_dfs_info *) node->aux;\n@@ -1201,13 +1239,23 @@ propagate (void)\n \t{\n \t  ipa_reference_local_vars_info_t w_l = \n \t    get_reference_vars_info (w)->local;\n+\n+\t  /* When function is overwrittable, we can not assume anything.  */\n+\t  if (cgraph_function_body_availability (w) <= AVAIL_OVERWRITABLE)\n+\t    read_write_all_from_decl (w->decl, &read_all, &write_all);\n+\n+\t  for (e = w->callees; e; e = e->next_callee) \n+\t    if (cgraph_function_body_availability (e->callee) <= AVAIL_OVERWRITABLE)\n+\t      read_write_all_from_decl (e->callee->decl, &read_all, &write_all);\n+\n \t  read_all |= w_l->calls_read_all;\n \t  write_all |= w_l->calls_write_all;\n \n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n \n+\n       /* Initialized the bitmaps for the reduced nodes */\n       if (read_all) \n \tnode_g->statics_read = all_module_statics;\n@@ -1217,7 +1265,6 @@ propagate (void)\n \t  bitmap_copy (node_g->statics_read, \n \t\t       node_l->statics_read);\n \t}\n-\n       if (write_all) \n \tnode_g->statics_written = all_module_statics;\n       else"}, {"sha": "78f21bd42cba2cb0232e025da16fc009f82ae4c2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "patch": "@@ -1,3 +1,7 @@\n+2009-10-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.c-torture/compile/pr40556.c: New testcase.\n+\n 2009-10-22  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/41781"}, {"sha": "a7b25b7af8fa130ebe68682585f4cc5bfd209d9f", "filename": "gcc/testsuite/gcc.c-torture/compile/pr40556.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr40556.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr40556.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr40556.c?ref=c59f5d1b644b6ed16a06410dd0fe4055a8a37bd1", "patch": "@@ -0,0 +1,22 @@\n+struct A {};\n+\n+struct A foo()\n+{\n+  return foo();\n+}\n+\n+void bar()\n+{\n+  foo();\n+}\n+struct A {};\n+\n+struct A foo()\n+{\n+  return foo();\n+}\n+\n+void bar()\n+{\n+  foo();\n+}"}]}