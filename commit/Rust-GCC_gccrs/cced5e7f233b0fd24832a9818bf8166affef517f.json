{"sha": "cced5e7f233b0fd24832a9818bf8166affef517f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlZDVlN2YyMzNiMGZkMjQ4MzJhOTgxOGJmODE2NmFmZmVmNTE3Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-05-28T13:46:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-05-28T13:46:46Z"}, "message": "re PR debug/41048 (bad DW_AT_data_member_location from g++)\n\n\tPR debug/41048\n\t* dwarf2out.c (double_int_type_size_in_bits): New function.\n\t(round_up_to_align): Change first argument and return value to\n\tdouble_int.\n\t(field_byte_offset): Work internally on double_ints.\n\nFrom-SVN: r159975", "tree": {"sha": "2545ef3e368256123596ea105daba7dece3a0fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2545ef3e368256123596ea105daba7dece3a0fcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cced5e7f233b0fd24832a9818bf8166affef517f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cced5e7f233b0fd24832a9818bf8166affef517f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cced5e7f233b0fd24832a9818bf8166affef517f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cced5e7f233b0fd24832a9818bf8166affef517f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa6d7c816c8b6ed5f1348a14ad242fa936d5840f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6d7c816c8b6ed5f1348a14ad242fa936d5840f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6d7c816c8b6ed5f1348a14ad242fa936d5840f"}], "stats": {"total": 180, "additions": 102, "deletions": 78}, "files": [{"sha": "9543eea614873b828695c3474e62ad7c22f3f279", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cced5e7f233b0fd24832a9818bf8166affef517f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cced5e7f233b0fd24832a9818bf8166affef517f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cced5e7f233b0fd24832a9818bf8166affef517f", "patch": "@@ -1,5 +1,11 @@\n 2010-05-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR debug/41048\n+\t* dwarf2out.c (double_int_type_size_in_bits): New function.\n+\t(round_up_to_align): Change first argument and return value to\n+\tdouble_int.\n+\t(field_byte_offset): Work internally on double_ints.\n+\n \tPR target/43636\n \t* builtins.c (expand_movstr): Use a temporary pseudo instead\n \tof target even when target is not NULL and not const0_rtx, but"}, {"sha": "e9f11e8ce156ca64663a01c636b0ac3b73a330bd", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 96, "deletions": 78, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cced5e7f233b0fd24832a9818bf8166affef517f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cced5e7f233b0fd24832a9818bf8166affef517f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cced5e7f233b0fd24832a9818bf8166affef517f", "patch": "@@ -12361,6 +12361,21 @@ simple_type_size_in_bits (const_tree type)\n     return TYPE_ALIGN (type);\n }\n \n+/* Similarly, but return a double_int instead of UHWI.  */\n+\n+static inline double_int\n+double_int_type_size_in_bits (const_tree type)\n+{\n+  if (TREE_CODE (type) == ERROR_MARK)\n+    return uhwi_to_double_int (BITS_PER_WORD);\n+  else if (TYPE_SIZE (type) == NULL_TREE)\n+    return double_int_zero;\n+  else if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n+    return tree_to_double_int (TYPE_SIZE (type));\n+  else\n+    return uhwi_to_double_int (TYPE_ALIGN (type));\n+}\n+\n /*  Given a pointer to a tree node for a subrange type, return a pointer\n     to a DIE that describes the given type.  */\n \n@@ -15410,20 +15425,15 @@ simple_decl_align_in_bits (const_tree decl)\n \n /* Return the result of rounding T up to ALIGN.  */\n \n-static inline HOST_WIDE_INT\n-round_up_to_align (HOST_WIDE_INT t, unsigned int align)\n+static inline double_int\n+round_up_to_align (double_int t, unsigned int align)\n {\n-  /* We must be careful if T is negative because HOST_WIDE_INT can be\n-     either \"above\" or \"below\" unsigned int as per the C promotion\n-     rules, depending on the host, thus making the signedness of the\n-     direct multiplication and division unpredictable.  */\n-  unsigned HOST_WIDE_INT u = (unsigned HOST_WIDE_INT) t;\n-\n-  u += align - 1;\n-  u /= align;\n-  u *= align;\n-\n-  return (HOST_WIDE_INT) u;\n+  double_int alignd = uhwi_to_double_int (align);\n+  t = double_int_add (t, alignd);\n+  t = double_int_add (t, double_int_minus_one);\n+  t = double_int_div (t, alignd, true, TRUNC_DIV_EXPR);\n+  t = double_int_mul (t, alignd);\n+  return t;\n }\n \n /* Given a pointer to a FIELD_DECL, compute and return the byte offset of the\n@@ -15436,8 +15446,9 @@ round_up_to_align (HOST_WIDE_INT t, unsigned int align)\n static HOST_WIDE_INT\n field_byte_offset (const_tree decl)\n {\n-  HOST_WIDE_INT object_offset_in_bits;\n-  HOST_WIDE_INT bitpos_int;\n+  double_int object_offset_in_bits;\n+  double_int object_offset_in_bytes;\n+  double_int bitpos_int;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n@@ -15447,24 +15458,24 @@ field_byte_offset (const_tree decl)\n   /* We cannot yet cope with fields whose positions are variable, so\n      for now, when we see such things, we simply return 0.  Someday, we may\n      be able to handle such cases, but it will be damn difficult.  */\n-  if (! host_integerp (bit_position (decl), 0))\n+  if (TREE_CODE (bit_position (decl)) != INTEGER_CST)\n     return 0;\n \n-  bitpos_int = int_bit_position (decl);\n+  bitpos_int = tree_to_double_int (bit_position (decl));\n \n #ifdef PCC_BITFIELD_TYPE_MATTERS\n   if (PCC_BITFIELD_TYPE_MATTERS)\n     {\n       tree type;\n       tree field_size_tree;\n-      HOST_WIDE_INT deepest_bitpos;\n-      unsigned HOST_WIDE_INT field_size_in_bits;\n+      double_int deepest_bitpos;\n+      double_int field_size_in_bits;\n       unsigned int type_align_in_bits;\n       unsigned int decl_align_in_bits;\n-      unsigned HOST_WIDE_INT type_size_in_bits;\n+      double_int type_size_in_bits;\n \n       type = field_type (decl);\n-      type_size_in_bits = simple_type_size_in_bits (type);\n+      type_size_in_bits = double_int_type_size_in_bits (type);\n       type_align_in_bits = simple_type_align_in_bits (type);\n \n       field_size_tree = DECL_SIZE (decl);\n@@ -15475,85 +15486,92 @@ field_byte_offset (const_tree decl)\n \tfield_size_tree = bitsize_zero_node;\n \n       /* If the size of the field is not constant, use the type size.  */\n-      if (host_integerp (field_size_tree, 1))\n-        field_size_in_bits = tree_low_cst (field_size_tree, 1);\n+      if (TREE_CODE (field_size_tree) == INTEGER_CST)\n+\tfield_size_in_bits = tree_to_double_int (field_size_tree);\n       else\n-        field_size_in_bits = type_size_in_bits;\n+\tfield_size_in_bits = type_size_in_bits;\n \n       decl_align_in_bits = simple_decl_align_in_bits (decl);\n \n       /* The GCC front-end doesn't make any attempt to keep track of the\n-         starting bit offset (relative to the start of the containing\n-         structure type) of the hypothetical \"containing object\" for a\n-         bit-field.  Thus, when computing the byte offset value for the\n-         start of the \"containing object\" of a bit-field, we must deduce\n-         this information on our own. This can be rather tricky to do in\n-         some cases.  For example, handling the following structure type\n-         definition when compiling for an i386/i486 target (which only\n-         aligns long long's to 32-bit boundaries) can be very tricky:\n+\t starting bit offset (relative to the start of the containing\n+\t structure type) of the hypothetical \"containing object\" for a\n+\t bit-field.  Thus, when computing the byte offset value for the\n+\t start of the \"containing object\" of a bit-field, we must deduce\n+\t this information on our own. This can be rather tricky to do in\n+\t some cases.  For example, handling the following structure type\n+\t definition when compiling for an i386/i486 target (which only\n+\t aligns long long's to 32-bit boundaries) can be very tricky:\n \n \t struct S { int field1; long long field2:31; };\n \n-         Fortunately, there is a simple rule-of-thumb which can be used\n-         in such cases.  When compiling for an i386/i486, GCC will\n-         allocate 8 bytes for the structure shown above.  It decides to\n-         do this based upon one simple rule for bit-field allocation.\n-         GCC allocates each \"containing object\" for each bit-field at\n-         the first (i.e. lowest addressed) legitimate alignment boundary\n-         (based upon the required minimum alignment for the declared\n-         type of the field) which it can possibly use, subject to the\n-         condition that there is still enough available space remaining\n-         in the containing object (when allocated at the selected point)\n-         to fully accommodate all of the bits of the bit-field itself.\n-\n-         This simple rule makes it obvious why GCC allocates 8 bytes for\n-         each object of the structure type shown above.  When looking\n-         for a place to allocate the \"containing object\" for `field2',\n-         the compiler simply tries to allocate a 64-bit \"containing\n-         object\" at each successive 32-bit boundary (starting at zero)\n-         until it finds a place to allocate that 64- bit field such that\n-         at least 31 contiguous (and previously unallocated) bits remain\n-         within that selected 64 bit field.  (As it turns out, for the\n-         example above, the compiler finds it is OK to allocate the\n-         \"containing object\" 64-bit field at bit-offset zero within the\n-         structure type.)\n-\n-         Here we attempt to work backwards from the limited set of facts\n-         we're given, and we try to deduce from those facts, where GCC\n-         must have believed that the containing object started (within\n-         the structure type). The value we deduce is then used (by the\n-         callers of this routine) to generate DW_AT_location and\n-         DW_AT_bit_offset attributes for fields (both bit-fields and, in\n-         the case of DW_AT_location, regular fields as well).  */\n+\t Fortunately, there is a simple rule-of-thumb which can be used\n+\t in such cases.  When compiling for an i386/i486, GCC will\n+\t allocate 8 bytes for the structure shown above.  It decides to\n+\t do this based upon one simple rule for bit-field allocation.\n+\t GCC allocates each \"containing object\" for each bit-field at\n+\t the first (i.e. lowest addressed) legitimate alignment boundary\n+\t (based upon the required minimum alignment for the declared\n+\t type of the field) which it can possibly use, subject to the\n+\t condition that there is still enough available space remaining\n+\t in the containing object (when allocated at the selected point)\n+\t to fully accommodate all of the bits of the bit-field itself.\n+\n+\t This simple rule makes it obvious why GCC allocates 8 bytes for\n+\t each object of the structure type shown above.  When looking\n+\t for a place to allocate the \"containing object\" for `field2',\n+\t the compiler simply tries to allocate a 64-bit \"containing\n+\t object\" at each successive 32-bit boundary (starting at zero)\n+\t until it finds a place to allocate that 64- bit field such that\n+\t at least 31 contiguous (and previously unallocated) bits remain\n+\t within that selected 64 bit field.  (As it turns out, for the\n+\t example above, the compiler finds it is OK to allocate the\n+\t \"containing object\" 64-bit field at bit-offset zero within the\n+\t structure type.)\n+\n+\t Here we attempt to work backwards from the limited set of facts\n+\t we're given, and we try to deduce from those facts, where GCC\n+\t must have believed that the containing object started (within\n+\t the structure type). The value we deduce is then used (by the\n+\t callers of this routine) to generate DW_AT_location and\n+\t DW_AT_bit_offset attributes for fields (both bit-fields and, in\n+\t the case of DW_AT_location, regular fields as well).  */\n \n       /* Figure out the bit-distance from the start of the structure to\n-         the \"deepest\" bit of the bit-field.  */\n-      deepest_bitpos = bitpos_int + field_size_in_bits;\n+\t the \"deepest\" bit of the bit-field.  */\n+      deepest_bitpos = double_int_add (bitpos_int, field_size_in_bits);\n \n       /* This is the tricky part.  Use some fancy footwork to deduce\n-         where the lowest addressed bit of the containing object must\n-         be.  */\n-      object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n+\t where the lowest addressed bit of the containing object must\n+\t be.  */\n+      object_offset_in_bits\n+\t= double_int_add (deepest_bitpos, double_int_neg (type_size_in_bits));\n \n       /* Round up to type_align by default.  This works best for\n-         bitfields.  */\n+\t bitfields.  */\n       object_offset_in_bits\n-        = round_up_to_align (object_offset_in_bits, type_align_in_bits);\n+\t= round_up_to_align (object_offset_in_bits, type_align_in_bits);\n \n-      if (object_offset_in_bits > bitpos_int)\n-        {\n-          object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n+      if (double_int_ucmp (object_offset_in_bits, bitpos_int) > 0)\n+\t{\n+\t  object_offset_in_bits\n+\t    = double_int_add (deepest_bitpos,\n+\t\t\t      double_int_neg (type_size_in_bits));\n \n-          /* Round up to decl_align instead.  */\n-          object_offset_in_bits\n-            = round_up_to_align (object_offset_in_bits, decl_align_in_bits);\n-        }\n+\t  /* Round up to decl_align instead.  */\n+\t  object_offset_in_bits\n+\t    = round_up_to_align (object_offset_in_bits, decl_align_in_bits);\n+\t}\n     }\n   else\n #endif\n     object_offset_in_bits = bitpos_int;\n \n-  return object_offset_in_bits / BITS_PER_UNIT;\n+  object_offset_in_bytes\n+    = double_int_div (object_offset_in_bits,\n+\t\t      uhwi_to_double_int (BITS_PER_UNIT), true,\n+\t\t      TRUNC_DIV_EXPR);\n+  return double_int_to_shwi (object_offset_in_bytes);\n }\n \f\n /* The following routines define various Dwarf attributes and any data"}]}