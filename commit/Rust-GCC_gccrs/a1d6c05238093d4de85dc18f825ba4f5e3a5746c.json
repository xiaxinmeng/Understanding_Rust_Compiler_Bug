{"sha": "a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFkNmMwNTIzODA5M2Q0ZGU4NWRjMThmODI1YmE0ZjVlM2E1NzQ2Yw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-02T18:14:04Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-02T18:14:04Z"}, "message": "re PR fortran/45689 ([F03] Missing transformational intrinsic in the trans_func_f2003 list)\n\n2017-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45689\n\t* intrinsic.c (add_function): Add gfc_simplify_maxloc and\n\tgfc_simplify_minloc to maxloc and minloc, respectively.\n\t* intrinsic.h: Add prototypes for gfc_simplify_minloc\n\tand gfc_simplify_maxloc.\n\t* simplify.c (min_max_chose): Adjust prototype.  Modify function\n\tto have a return value which indicates if the extremum was found.\n\t(is_constant_array_expr): Fix typo in comment.\n\t(simplify_minmaxloc_to_scalar): New function.\n\t(simplify_minmaxloc_nodim): New function.\n\t(new_array): New function.\n\t(simplify_minmaxloc_to_array): New function.\n\t(gfc_simplify_minmaxloc): New function.\n\t(simplify_minloc): New function.\n\t(simplify_maxloc): New function.\n\n2017-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45689\n\t* gfortran.dg/minloc_4.f90: New test case.\n\t* gfortran.dg/maxloc_4.f90: New test case.\n\nFrom-SVN: r256088", "tree": {"sha": "2605c1b38b5db5d39d8b02cc9db867b2106e10aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2605c1b38b5db5d39d8b02cc9db867b2106e10aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/comments", "author": null, "committer": null, "parents": [{"sha": "0a552ae22a4b7d4a71afab9f845398597a4d230d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a552ae22a4b7d4a71afab9f845398597a4d230d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a552ae22a4b7d4a71afab9f845398597a4d230d"}], "stats": {"total": 520, "additions": 504, "deletions": 16}, "files": [{"sha": "23bca56c9b70b8bb141d25fa07558ace4e724069", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "patch": "@@ -1,3 +1,21 @@\n+2017-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45689\n+\t* intrinsic.c (add_function): Add gfc_simplify_maxloc and\n+\tgfc_simplify_minloc to maxloc and minloc, respectively.\n+\t* intrinsic.h: Add prototypes for gfc_simplify_minloc\n+\tand gfc_simplify_maxloc.\n+\t* simplify.c (min_max_chose): Adjust prototype.  Modify function\n+\tto have a return value which indicates if the extremum was found.\n+\t(is_constant_array_expr): Fix typo in comment.\n+\t(simplify_minmaxloc_to_scalar): New function.\n+\t(simplify_minmaxloc_nodim): New function.\n+\t(new_array): New function.\n+\t(simplify_minmaxloc_to_array): New function.\n+\t(gfc_simplify_minmaxloc): New function.\n+\t(simplify_minloc): New function.\n+\t(simplify_maxloc): New function.\n+\n 2018-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/45689"}, {"sha": "80b8ee004693bb84fccaf96128b4f9c3f4f0c0a5", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "patch": "@@ -2458,7 +2458,7 @@ add_functions (void)\n   make_generic (\"maxexponent\", GFC_ISYM_MAXEXPONENT, GFC_STD_F95);\n \n   add_sym_4ml (\"maxloc\", GFC_ISYM_MAXLOC, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t       gfc_check_minloc_maxloc, NULL, gfc_resolve_maxloc,\n+\t       gfc_check_minloc_maxloc, gfc_simplify_maxloc, gfc_resolve_maxloc,\n \t       ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t       msk, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n \n@@ -2534,7 +2534,7 @@ add_functions (void)\n   make_generic (\"minexponent\", GFC_ISYM_MINEXPONENT, GFC_STD_F95);\n \n   add_sym_4ml (\"minloc\", GFC_ISYM_MINLOC, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,\n-\t       gfc_check_minloc_maxloc, NULL, gfc_resolve_minloc,\n+\t       gfc_check_minloc_maxloc, gfc_simplify_minloc, gfc_resolve_minloc,\n \t       ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t       msk, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n "}, {"sha": "dce6eb0d165c95f8aa1281b951cfaf061fbc72fe", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "patch": "@@ -347,8 +347,10 @@ gfc_expr *gfc_simplify_maskr (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_merge_bits (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_min (gfc_expr *);\n+gfc_expr *gfc_simplify_minloc (gfc_expr*, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_minval (gfc_expr *, gfc_expr*, gfc_expr*);\n gfc_expr *gfc_simplify_max (gfc_expr *);\n+gfc_expr *gfc_simplify_maxloc (gfc_expr*, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_maxval (gfc_expr *, gfc_expr*, gfc_expr*);\n gfc_expr *gfc_simplify_maxexponent (gfc_expr *);\n gfc_expr *gfc_simplify_minexponent (gfc_expr *);"}, {"sha": "afd59b2c4510f52e40e37e480a73dbe6fa5eb8b3", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 402, "deletions": 14, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "patch": "@@ -31,7 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Prototypes.  */\n \n-static void min_max_choose (gfc_expr *, gfc_expr *, int);\n+static int min_max_choose (gfc_expr *, gfc_expr *, int);\n \n gfc_expr gfc_bad_expr;\n \n@@ -230,7 +230,7 @@ convert_boz (gfc_expr *x, int kind)\n }\n \n \n-/* Test that the expression is an constant array, simplifying if\n+/* Test that the expression is a constant array, simplifying if\n    we are dealing with a parameter array.  */\n \n static bool\n@@ -4534,25 +4534,34 @@ gfc_simplify_merge_bits (gfc_expr *i, gfc_expr *j, gfc_expr *mask_expr)\n \n /* Selects between current value and extremum for simplify_min_max\n    and simplify_minval_maxval.  */\n-static void\n+static int\n min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)\n {\n+  int ret;\n+\n   switch (arg->ts.type)\n     {\n       case BT_INTEGER:\n-\tif (mpz_cmp (arg->value.integer,\n-\t\t\textremum->value.integer) * sign > 0)\n-\tmpz_set (extremum->value.integer, arg->value.integer);\n+\tret = mpz_cmp (arg->value.integer,\n+\t\t       extremum->value.integer) * sign;\n+\tif (ret > 0)\n+\t  mpz_set (extremum->value.integer, arg->value.integer);\n \tbreak;\n \n       case BT_REAL:\n-\t/* We need to use mpfr_min and mpfr_max to treat NaN properly.  */\n-\tif (sign > 0)\n-\t  mpfr_max (extremum->value.real, extremum->value.real,\n-\t\t      arg->value.real, GFC_RND_MODE);\n+\tif (mpfr_nan_p (extremum->value.real))\n+\t  {\n+\t    ret = 1;\n+\t    mpfr_set (extremum->value.real, arg->value.real, GFC_RND_MODE);\n+\t  }\n+\telse if (mpfr_nan_p (arg->value.real))\n+\t  ret = -1;\n \telse\n-\t  mpfr_min (extremum->value.real, extremum->value.real,\n-\t\t      arg->value.real, GFC_RND_MODE);\n+\t  {\n+\t    ret = mpfr_cmp (arg->value.real, extremum->value.real) * sign;\n+\t    if (ret > 0)\n+\t      mpfr_set (extremum->value.real, arg->value.real, GFC_RND_MODE);\n+\t  }\n \tbreak;\n \n       case BT_CHARACTER:\n@@ -4571,8 +4580,8 @@ min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)\n \t    LENGTH(extremum) = LENGTH(arg);\n \t    free (tmp);\n \t  }\n-\n-\tif (gfc_compare_string (arg, extremum) * sign > 0)\n+\tret = gfc_compare_string (arg, extremum) * sign;\n+\tif (ret > 0)\n \t  {\n \t    free (STRING(extremum));\n \t    STRING(extremum) = gfc_get_wide_string (LENGTH(extremum) + 1);\n@@ -4589,6 +4598,7 @@ min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)\n       default:\n \tgfc_internal_error (\"simplify_min_max(): Bad type in arglist\");\n     }\n+  return ret;\n }\n \n \n@@ -4701,6 +4711,384 @@ gfc_simplify_maxval (gfc_expr *array, gfc_expr* dim, gfc_expr *mask)\n }\n \n \n+/* Transform minloc or maxloc of an array, according to MASK,\n+   to the scalar result.  This code is mostly identical to\n+   simplify_transformation_to_scalar.  */\n+\n+static gfc_expr *\n+simplify_minmaxloc_to_scalar (gfc_expr *result, gfc_expr *array, gfc_expr *mask,\n+\t\t\t      gfc_expr *extremum, int sign)\n+{\n+  gfc_expr *a, *m;\n+  gfc_constructor *array_ctor, *mask_ctor;\n+  mpz_t count;\n+\n+  mpz_set_si (result->value.integer, 0);\n+\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    return result;\n+\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  if (mask && mask->expr_type == EXPR_ARRAY)\n+    mask_ctor = gfc_constructor_first (mask->value.constructor);\n+  else\n+    mask_ctor = NULL;\n+\n+  mpz_init_set_si (count, 0);\n+  while (array_ctor)\n+    {\n+      mpz_add_ui (count, count, 1);\n+      a = array_ctor->expr;\n+      array_ctor = gfc_constructor_next (array_ctor);\n+      /* A constant MASK equals .TRUE. here and can be ignored.  */\n+      if (mask_ctor)\n+\t{\n+\t  m = mask_ctor->expr;\n+\t  mask_ctor = gfc_constructor_next (mask_ctor);\n+\t  if (!m->value.logical)\n+\t    continue;\n+\t}\n+      if (min_max_choose (a, extremum, sign) > 0)\n+\tmpz_set (result->value.integer, count);\n+    }\n+  mpz_clear (count);\n+  gfc_free_expr (extremum);\n+  return result;\n+}\n+\n+/* Simplify minloc / maxloc in the absence of a dim argument.  */\n+\n+static gfc_expr *\n+simplify_minmaxloc_nodim (gfc_expr *result, gfc_expr *extremum,\n+\t\t\t  gfc_expr *array, gfc_expr *mask, int sign)\n+{\n+  ssize_t res[GFC_MAX_DIMENSIONS];\n+  int i, n;\n+  gfc_constructor *result_ctor, *array_ctor, *mask_ctor;\n+  ssize_t count[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS],\n+    sstride[GFC_MAX_DIMENSIONS];\n+  gfc_expr *a, *m;\n+  bool continue_loop;\n+  bool ma;\n+\n+  for (i = 0; i<array->rank; i++)\n+    res[i] = -1;\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    goto finish;\n+\n+  for (i = 0; i < array->rank; i++)\n+    {\n+      count[i] = 0;\n+      sstride[i] = (i == 0) ? 1 : sstride[i-1] * mpz_get_si (array->shape[i-1]);\n+      extent[i] = mpz_get_si (array->shape[i]);\n+      if (extent[i] <= 0)\n+\tgoto finish;\n+    }\n+\n+  continue_loop = true;\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  if (mask && mask->rank > 0)\n+    mask_ctor = gfc_constructor_first (mask->value.constructor);\n+  else\n+    mask_ctor = NULL;\n+\n+  /* Loop over the array elements (and mask), keeping track of\n+     the indices to return.  */\n+  while (continue_loop)\n+    {\n+      do\n+\t{\n+\t  a = array_ctor->expr;\n+\t  if (mask_ctor)\n+\t    {\n+\t      m = mask_ctor->expr;\n+\t      ma = m->value.logical;\n+\t      mask_ctor = gfc_constructor_next (mask_ctor);\n+\t    }\n+\t  else\n+\t    ma = true;\n+\n+\t  if (ma && min_max_choose (a, extremum, sign) > 0)\n+\t    {\n+\t      for (i = 0; i<array->rank; i++)\n+\t\tres[i] = count[i];\n+\t    }\n+\t  array_ctor = gfc_constructor_next (array_ctor);\n+\t  count[0] ++;\n+\t} while (count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  n++;\n+\t  if (n >= array->rank)\n+\t    {\n+\t      continue_loop = false;\n+\t      break;\n+\t    }\n+\t  else\n+\t    count[n] ++;\n+\t} while (count[n] == extent[n]);\n+    }\n+\n+ finish:\n+  gfc_free_expr (extremum);\n+  result_ctor = gfc_constructor_first (result->value.constructor);\n+  for (i = 0; i<array->rank; i++)\n+    {\n+      gfc_expr *r_expr;\n+      r_expr = result_ctor->expr;\n+      mpz_set_si (r_expr->value.integer, res[i] + 1);\n+      result_ctor = gfc_constructor_next (result_ctor);\n+    }\n+  return result;\n+}\n+\n+/* Helper function for gfc_simplify_minmaxloc - build an array\n+   expression with n elements.  */\n+\n+static gfc_expr *\n+new_array (bt type, int kind, int n, locus *where)\n+{\n+  gfc_expr *result;\n+  int i;\n+\n+  result = gfc_get_array_expr (type, kind, where);\n+  result->rank = 1;\n+  result->shape = gfc_get_shape(1);\n+  mpz_init_set_si (result->shape[0], n);\n+  for (i = 0; i < n; i++)\n+    {\n+      gfc_constructor_append_expr (&result->value.constructor,\n+\t\t\t\t   gfc_get_constant_expr (type, kind, where),\n+\t\t\t\t   NULL);\n+    }\n+\n+  return result;\n+}\n+\n+/* Simplify minloc and maxloc. This code is mostly identical to\n+   simplify_transformation_to_array.  */\n+\n+static gfc_expr *\n+simplify_minmaxloc_to_array (gfc_expr *result, gfc_expr *array,\n+\t\t\t     gfc_expr *dim, gfc_expr *mask,\n+\t\t\t     gfc_expr *extremum, int sign)\n+{\n+  mpz_t size;\n+  int done, i, n, arraysize, resultsize, dim_index, dim_extent, dim_stride;\n+  gfc_expr **arrayvec, **resultvec, **base, **src, **dest;\n+  gfc_constructor *array_ctor, *mask_ctor, *result_ctor;\n+\n+  int count[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS],\n+      sstride[GFC_MAX_DIMENSIONS], dstride[GFC_MAX_DIMENSIONS],\n+      tmpstride[GFC_MAX_DIMENSIONS];\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    return result;\n+\n+  /* Build an indexed table for array element expressions to minimize\n+     linked-list traversal. Masked elements are set to NULL.  */\n+  gfc_array_size (array, &size);\n+  arraysize = mpz_get_ui (size);\n+  mpz_clear (size);\n+\n+  arrayvec = XCNEWVEC (gfc_expr*, arraysize);\n+\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  mask_ctor = NULL;\n+  if (mask && mask->expr_type == EXPR_ARRAY)\n+    mask_ctor = gfc_constructor_first (mask->value.constructor);\n+\n+  for (i = 0; i < arraysize; ++i)\n+    {\n+      arrayvec[i] = array_ctor->expr;\n+      array_ctor = gfc_constructor_next (array_ctor);\n+\n+      if (mask_ctor)\n+\t{\n+\t  if (!mask_ctor->expr->value.logical)\n+\t    arrayvec[i] = NULL;\n+\n+\t  mask_ctor = gfc_constructor_next (mask_ctor);\n+\t}\n+    }\n+\n+  /* Same for the result expression.  */\n+  gfc_array_size (result, &size);\n+  resultsize = mpz_get_ui (size);\n+  mpz_clear (size);\n+\n+  resultvec = XCNEWVEC (gfc_expr*, resultsize);\n+  result_ctor = gfc_constructor_first (result->value.constructor);\n+  for (i = 0; i < resultsize; ++i)\n+    {\n+      resultvec[i] = result_ctor->expr;\n+      result_ctor = gfc_constructor_next (result_ctor);\n+    }\n+\n+  gfc_extract_int (dim, &dim_index);\n+  dim_index -= 1;               /* zero-base index */\n+  dim_extent = 0;\n+  dim_stride = 0;\n+\n+  for (i = 0, n = 0; i < array->rank; ++i)\n+    {\n+      count[i] = 0;\n+      tmpstride[i] = (i == 0) ? 1 : tmpstride[i-1] * mpz_get_si (array->shape[i-1]);\n+      if (i == dim_index)\n+\t{\n+\t  dim_extent = mpz_get_si (array->shape[i]);\n+\t  dim_stride = tmpstride[i];\n+\t  continue;\n+\t}\n+\n+      extent[n] = mpz_get_si (array->shape[i]);\n+      sstride[n] = tmpstride[i];\n+      dstride[n] = (n == 0) ? 1 : dstride[n-1] * extent[n-1];\n+      n += 1;\n+    }\n+\n+  done = false;\n+  base = arrayvec;\n+  dest = resultvec;\n+  while (!done)\n+    {\n+      gfc_expr *ex;\n+      ex = gfc_copy_expr (extremum);\n+      for (src = base, n = 0; n < dim_extent; src += dim_stride, ++n)\n+\t{\n+\t  if (*src && min_max_choose (*src, ex, sign) > 0)\n+\t    mpz_set_si ((*dest)->value.integer, n + 1);\n+\t}\n+ \n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      gfc_free_expr (ex);\n+\n+      n = 0;\n+      while (!done && count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\n+\t  n++;\n+\t  if (n < result->rank)\n+\t    {\n+\t      /* If the nested loop is unrolled GFC_MAX_DIMENSIONS\n+\t\t times, we'd warn for the last iteration, because the\n+\t\t array index will have already been incremented to the\n+\t\t array sizes, and we can't tell that this must make\n+\t\t the test against result->rank false, because ranks\n+\t\t must not exceed GFC_MAX_DIMENSIONS.  */\n+\t      GCC_DIAGNOSTIC_PUSH_IGNORED (-Warray-bounds)\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t      GCC_DIAGNOSTIC_POP\n+\t    }\n+\t  else\n+\t    done = true;\n+       }\n+    }\n+\n+  /* Place updated expression in result constructor.  */\n+  result_ctor = gfc_constructor_first (result->value.constructor);\n+  for (i = 0; i < resultsize; ++i)\n+    {\n+      result_ctor->expr = resultvec[i];\n+      result_ctor = gfc_constructor_next (result_ctor);\n+    }\n+\n+  free (arrayvec);\n+  free (resultvec);\n+  free (extremum);\n+  return result;\n+}\n+\n+/* Simplify minloc and maxloc for constant arrays.  */\n+\n+gfc_expr *\n+gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n+\t\t\tgfc_expr *kind, int sign)\n+{\n+  gfc_expr *result;\n+  gfc_expr *extremum;\n+  int ikind;\n+  int init_val;\n+  \n+  if (!is_constant_array_expr (array)\n+      || !gfc_is_constant_expr (dim))\n+    return NULL;\n+\n+  if (mask\n+      && !is_constant_array_expr (mask)\n+      && mask->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  if (kind)\n+    {\n+      if (gfc_extract_int (kind, &ikind, -1))\n+\treturn NULL;\n+    }\n+  else\n+    ikind = gfc_default_integer_kind;\n+\n+  if (sign < 0)\n+    init_val = INT_MAX;\n+  else if (sign > 0)\n+    init_val = INT_MIN;\n+  else\n+    gcc_unreachable();\n+\n+  extremum = gfc_get_constant_expr (array->ts.type, array->ts.kind, &array->where);\n+  init_result_expr (extremum, init_val, array);\n+\n+  if (dim)\n+    {\n+      result = transformational_result (array, dim, BT_INTEGER,\n+\t\t\t\t\tikind, &array->where);\n+      init_result_expr (result, 0, array);\n+\n+      if (array->rank == 1)\n+\treturn simplify_minmaxloc_to_scalar (result, array, mask, extremum, sign);\n+      else\n+\treturn simplify_minmaxloc_to_array (result, array, dim, mask, extremum, sign);\n+    }\n+  else\n+    {\n+      result = new_array (BT_INTEGER, ikind, array->rank, &array->where);\n+      return simplify_minmaxloc_nodim (result, extremum, array, mask, sign);\n+    }\n+}\n+\n+gfc_expr *\n+gfc_simplify_minloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind)\n+{\n+  return gfc_simplify_minmaxloc (array, dim, mask, kind, -1);\n+}\n+\n+gfc_expr *\n+gfc_simplify_maxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask, gfc_expr *kind)\n+{\n+  return gfc_simplify_minmaxloc (array, dim, mask, kind, 1);\n+}\n+\n gfc_expr *\n gfc_simplify_maxexponent (gfc_expr *x)\n {"}, {"sha": "338341271245e2467a14ae207c58fc548aecd1a2", "filename": "gcc/testsuite/gfortran.dg/maxloc_4.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_4.f90?ref=a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do  run }\n+! Check that simplification of maxloc works\n+program main\n+  implicit none\n+  integer :: d\n+  real, dimension(2), parameter :: a = [1.0, 0.0]\n+  character(len=3), dimension(3), parameter :: c = [ \"fgh\", \"asd\", \"jkl\" ]\n+  integer, parameter :: b = maxloc(a,dim=1)\n+  integer, parameter :: b2 = maxloc(a,dim=1,mask=[.false.,.false.])\n+  integer, parameter :: b3 = maxloc(c,dim=1)\n+  integer, parameter :: b4 = maxloc(c,dim=1,mask=[c<\"iii\"])\n+  integer, parameter,dimension(2,2) :: i1 = reshape([4,5,3,2],shape(i1))\n+  integer, parameter, dimension(2) :: b5 = maxloc(i1)\n+  integer, parameter, dimension(2) :: b6 = maxloc(i1,mask=i1>7)\n+  integer, parameter, dimension(2) :: b7 = maxloc(i1, mask=i1<5)\n+  integer, parameter, dimension(2) :: b8 = maxloc(i1, mask=.true.)\n+  integer, parameter, dimension(2) :: b9 = maxloc(i1, mask=.false.)\n+  integer, parameter, dimension(2,3) :: i2 = &\n+       reshape([2, -1, -3, 4, -5, 6], shape(i2))\n+  integer, parameter, dimension(3) :: b10 = maxloc(i2, dim=1)\n+  integer, parameter, dimension(2) :: b11 = maxloc(i2, dim=2)\n+  integer, parameter, dimension(3) :: b12 = maxloc(i2,dim=1,mask=i2<0)\n+  integer, parameter, dimension(2) :: b13 = maxloc(i2,dim=2, mask=i2<-10)\n+  if (b /= 1) call abort\n+  if (b2 /= 0) call abort\n+  if (b3 /= 3) call abort\n+  if (b4 /= 1) call abort\n+  if (any(b5 /= [2,1])) call abort\n+  if (any(b6 /= [0, 0])) call abort\n+  if (any(b7 /= [1,1])) call abort\n+  if (any(b8 /= b5)) call abort\n+  if (any(b9 /= [0, 0])) call abort\n+  d = 1\n+  if (any(b10 /= maxloc(i2,dim=d))) call abort\n+  d = 2\n+  if (any(b11 /= maxloc(i2,dim=2))) call abort\n+  d = 1\n+  if (any(b12 /= maxloc(i2, dim=d,mask=i2<0))) call abort\n+  if (any(b13 /= 0)) call abort\n+end program main"}, {"sha": "1d9c0acca074b0bb715685c87e2644ed114d1054", "filename": "gcc/testsuite/gfortran.dg/minloc_4.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d6c05238093d4de85dc18f825ba4f5e3a5746c/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_4.f90?ref=a1d6c05238093d4de85dc18f825ba4f5e3a5746c", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do  run }\n+! Check that simplification of minloc works\n+program main\n+  implicit none\n+  integer :: d\n+  real, dimension(2), parameter :: a = [1.0, 0.0]\n+  character(len=3), dimension(3), parameter :: c = [ \"fgh\", \"asd\", \"jkl\" ]\n+  integer, parameter :: b = minloc(a,dim=1)\n+  integer, parameter :: b2 = minloc(a,dim=1,mask=[.false.,.false.])\n+  integer, parameter :: b3 = minloc(c,dim=1)\n+  integer, parameter :: b4 = minloc(c,dim=1,mask=[c>\"bbb\"])\n+  integer, parameter,dimension(2,2) :: i1 = reshape([4,3,2,5],shape(i1))\n+  integer, parameter, dimension(2) :: b5 = minloc(i1)\n+  integer, parameter, dimension(2) :: b6 = minloc(i1,mask=i1>7)\n+  integer, parameter, dimension(2) :: b7 = minloc(i1, mask=i1>2)\n+  integer, parameter, dimension(2) :: b8 = minloc(i1, mask=.true.)\n+  integer, parameter, dimension(2) :: b9 = minloc(i1, mask=.false.)\n+  integer, parameter, dimension(2,3) :: i2 = &\n+       reshape([2, -1, -3, 4, -5, 6], shape(i2))\n+  integer, parameter, dimension(3) :: b10 = minloc(i2, dim=1)\n+  integer, parameter, dimension(2) :: b11 = minloc(i2, dim=2)\n+  integer, parameter, dimension(3) :: b12 = minloc(i2,dim=1,mask=i2>3)\n+  integer, parameter, dimension(2) :: b13 = minloc(i2,dim=2, mask=i2<-10)\n+  if (b /= 2) call abort\n+  if (b2 /= 0) call abort\n+  if (b3 /= 2) call abort\n+  if (b4 /= 1) call abort\n+  if (any(b5 /= [1, 2])) call abort\n+  if (any(b6 /= [0, 0])) call abort\n+  if (any(b7 /= [2, 1])) call abort\n+  if (any(b8 /= [1, 2])) call abort\n+  if (any(b9 /= [0, 0])) call abort\n+  d = 1\n+  if (any(b10 /= minloc(i2,dim=d))) call abort\n+  d = 2\n+  if (any(b11 /= minloc(i2,dim=2))) call abort\n+  d = 1\n+  if (any(b12 /= minloc(i2, dim=d,mask=i2>3))) call abort\n+  if (any(b13 /= 0)) call abort\n+end program main"}]}