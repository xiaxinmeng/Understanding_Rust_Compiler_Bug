{"sha": "777e6d799a6db0549568c5dd668a226194486c02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3ZTZkNzk5YTZkYjA1NDk1NjhjNWRkNjY4YTIyNjE5NDQ4NmMwMg==", "commit": {"author": {"name": "Rolf W. Rasmussen", "email": "rolfwr@ii.uib.no", "date": "2000-08-16T18:03:48Z"}, "committer": {"name": "Rolf Rasmussen", "email": "rolfwr@gcc.gnu.org", "date": "2000-08-16T18:03:48Z"}, "message": "ComponentDataBlitOp.java: New file.\n\n\t* gnu/gcj/awt/ComponentDataBlitOp.java: New file.\n\t* gnu/gcj/awt/GLightweightPeer.java: New file.\n\t* java/awt/BorderLayout.java: Implemented all methods.\n\t* java/awt/Button.java (actionListener, actionCommand): Renamed\n\tand modifier change.\n\t(addNotify): Call super.\n\t(dispatchEventImpl): New method.\n\t(getListeners): New method.\n\t(label): Made package-private, not private.\n\t* java/awt/Canvas.java: Implemented class body.\n\t* java/awt/Color.java (brighter): New method.\n\t(darker): New method.\n\t(hashCode): New method.\n\t* java/awt/Component.java (visible, enabled, eventMask): Set defaults.\n\t(getGraphicsConfiguration): Delegate to\n\tgetGraphicsConfigurationImpl().\n\t(getGraphicsConfigurationImpl): New method.\n\t(getToolkit): Only return value from peer if not null.\n\t(isDisplayable): Check with parent.\n\t(isShowing): No parent implies not showing.\n\t(getForeground): Check parent property if local is null.\n\t(getBackground): Likewise.\n\t(getFont): Likewise.\n\t(setForeground): Inform peer.\n\t(setBackground): Likewise\n\t(setLocale): Invalidate component.\n\t(getColorModel): Implemented.\n\t(setLocation): Invalidate, or ignore if no change.\n\t(setSize): Invalidate, or ignore if no change.\n\t(setBounds): Invalidate, or ignore if no change.\n\t(isOpaque): By default, heavyweight implies opaque.\n\t(isLightweight): Implemented.\n\t(getMaximumSize): Implemented.\n\t(doLayout): Implemented, NOP.\n\t(validate): Implemented, NOP.\n\t(invalidate): Only propagate to parent if parent was valid.\n\t(getGraphics): Implemented.\n\t(getFontMetrics): Implemented.\n\t(update): Implemented.\n\t(paintAll): Implemented.\n\t(repaint): Implemented all repaint methods.\n\t(print): Implemented.\n\t(printAll): Implemented.\n\t(createImage): Implemented.\n\t(dispatchEvent): Give the peer a chance to handle the event.\n\t(dispatchEventImpl): Dispatch paint events.\n\t(enableEvents): Lightweights enable events on parent component.\n\t(coalesceEvents): Coalesce paint events, and select event type\n\tusing a switch.\n\t(coalescePaintEvents): New method.\n\t(processEvent): Fix unfortunate ordering of statements, and call\n\tcorrect method for MOUSE_CLICKED.\n\t(processPaintEvent): New method.\n\t(addNotify): Allow container to notify children before event\n\tmask is set in peer.\n\t(addNotifyContainerChildren): New method.\n\t(removeNotify): Visibility should not change on removeNotify.\n\t(paramString): Implemented.\n\t(list): Implemented two of the list methods.\n\t* Container (myInsets): Removed, insets are managed by peer.\n\t(getInsets): Query peer.\n\t(addImpl): Fix reparenting, enable events for lightweights,\n\tinitialize component array.\n\t(validate): Call doLayout in validateTree() instead.\n\t(validateTree): Do nothing if already valid. Call beginValidate(),\n\tendValidate() on peer. Call validateTree() instead of validate()\n\tfor children that are containers. Mark valid after validation of\n\tchildren.\n\t(setFont): Partial implementation.\n\t(paint): Implemented.\n\t(visitChildren): New method.\n\t(visitChild): New method.\n\t(update): Implemented.\n\t(print): Implemented.\n\t(paintComponents): Implemented.\n\t(printComponents): Consider translation and clipping.\n\t(getComponentAt): Ignore invisible children. Return this if no\n\tchild match.\n\t(addNotify): Call super.\n\t(addNotifyContainerChildren): New method.\n\t(paramString): Implemented.\n\t(list): Implemented.\n\t* java/awt/EventQueue (invokeAndWait): Get system event queue the\n\tright way.\n\t(invokeLater): Likewise.\n\t(isDispatchThread): Likewise.\n\t* java/awt/FontMetrics (getLeading): Formula change.\n\t(getDescent): Consider leading also.\n\t(getMaxAscent): Default to getAscent().\n\t(getMaxDescent): Default to getDescent.\n\t(getMaxAdvance): Return value signifying unknown.\n\t(charWidth): Both methods implemented.\n\t(charsWidth): Implemented.\n\t(bytesWidth): Implemented.\n\t(getWidths): Implemented.\n\t* java/awt/Frame.java (NORMAL, ICONIFIED, iconImage, isResizable,\n\tstate): New fields.\n\t(Frame): Rearragend constuctor chaining to disallow null being\n\tpassed as a graphics configuration.\n\t(getTitle): Return empty string if null.\n\t(dispose): Removed.\n\t(getIconImage): New method.\n\t(setIconImage): New method.\n\t(finalize): New method.\n\t(setMenuBar): Notify peer.\n\t(isResizable): New method.\n\t(setResizable): New method.\n\t(getState): New method.\n\t(getFont): Removed.\n\t(remove): Implemented.\n\t(removeNotify): New method.\n\t(getFrames): New method.\n\t* java/awt/Graphics.java: Implemented body of class.\n\t* java/awt/Graphics2D.java: New file.\n\t* java/awt/GraphicsConfiguration.java: Enabled part of the API.\n\t* java/awt/Image.java: Implemented body of class.\n\t* java/awt/Panel.java (Panel): Call correct super constructor.\n\t(addNotify): Implemented.\n\t* java/awt/Rectangle.java (isEmpty): Fixed reversed logic.\n\t* java/awt/RenderingHints.java: New file.\n\t* java/awt/Toolkit.java (createComponent): Implemented.\n\t(getSystemEventQueue): Delegate to getSystemEventQueueImpl().\n\t* java/awt/Window.java (Window): Two new constructors. Reordered\n\tconstructor chaining.\n\t(getGraphicsConfigurationImpl): New method.\n\t(finalize): Call super.\n\t(addNotify): Call super.\n\t(pack): Do layout stuff.\n\t(show): Ensure that peer exists and that component is valid.\n\t(dispose): Dispose owned children.\n\t(getOwner): Simplify code, casting null pointers is valid.\n\t(getGraphicsConfiguration): Ask peer if local value is null.\n\t* java/awt/event/ActionEvent.java (getActionCommand): Renamed from\n\tgetcmd().\n\t* java/awt/image/BufferedImage.java: New file.\n\t* java/awt/image/RasterOp.java: New file.\n\t* java/awt/peer/ComponentPeer.java (getGraphicsConfiguration):\n\tMore powerfull replacement for getColorModel().\n\t(getColorModel) Removed.\n\t(setEventMask) New method.\n\t* Makefile.am: Added new files.\n\t* Makefile.in: Rebuilt.\n\nFrom-SVN: r35748", "tree": {"sha": "de04aa08682f889d624d5649474e04a30121641f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de04aa08682f889d624d5649474e04a30121641f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777e6d799a6db0549568c5dd668a226194486c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e6d799a6db0549568c5dd668a226194486c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777e6d799a6db0549568c5dd668a226194486c02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e6d799a6db0549568c5dd668a226194486c02/comments", "author": null, "committer": null, "parents": [{"sha": "cfedbb1f824b2f2d9f48f2ed805808b00fa671b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfedbb1f824b2f2d9f48f2ed805808b00fa671b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfedbb1f824b2f2d9f48f2ed805808b00fa671b0"}], "stats": {"total": 2874, "additions": 2669, "deletions": 205}, "files": [{"sha": "480038b9cbd238c87ea15b00032ea8078382cd5f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -1,3 +1,148 @@\n+2000-08-16  Rolf W. Rasmussen  <rolfwr@ii.uib.no>\n+\n+\t* gnu/gcj/awt/ComponentDataBlitOp.java: New file.\n+\t* gnu/gcj/awt/GLightweightPeer.java: New file.\n+\t* java/awt/BorderLayout.java: Implemented all methods.\n+\t* java/awt/Button.java (actionListener, actionCommand): Renamed\n+\tand modifier change.\n+\t(addNotify): Call super.\n+\t(dispatchEventImpl): New method.\n+\t(getListeners): New method.\n+\t(label): Made package-private, not private.\n+\t* java/awt/Canvas.java: Implemented class body.\n+\t* java/awt/Color.java (brighter): New method.\n+\t(darker): New method.\n+\t(hashCode): New method.\n+\t* java/awt/Component.java (visible, enabled, eventMask): Set defaults.\n+\t(getGraphicsConfiguration): Delegate to\n+\tgetGraphicsConfigurationImpl().\n+\t(getGraphicsConfigurationImpl): New method.\n+\t(getToolkit): Only return value from peer if not null.\n+\t(isDisplayable): Check with parent.\n+\t(isShowing): No parent implies not showing.\n+\t(getForeground): Check parent property if local is null.\n+\t(getBackground): Likewise.\n+\t(getFont): Likewise.\n+\t(setForeground): Inform peer.\n+\t(setBackground): Likewise\n+\t(setLocale): Invalidate component.\n+\t(getColorModel): Implemented.\n+\t(setLocation): Invalidate, or ignore if no change.\n+\t(setSize): Invalidate, or ignore if no change.\n+\t(setBounds): Invalidate, or ignore if no change.\n+\t(isOpaque): By default, heavyweight implies opaque.\n+\t(isLightweight): Implemented.\n+\t(getMaximumSize): Implemented.\n+\t(doLayout): Implemented, NOP.\n+\t(validate): Implemented, NOP.\n+\t(invalidate): Only propagate to parent if parent was valid.\n+\t(getGraphics): Implemented.\n+\t(getFontMetrics): Implemented.\n+\t(update): Implemented.\n+\t(paintAll): Implemented.\n+\t(repaint): Implemented all repaint methods.\n+\t(print): Implemented.\n+\t(printAll): Implemented.\n+\t(createImage): Implemented.\n+\t(dispatchEvent): Give the peer a chance to handle the event.\n+\t(dispatchEventImpl): Dispatch paint events.\n+\t(enableEvents): Lightweights enable events on parent component.\n+\t(coalesceEvents): Coalesce paint events, and select event type\n+\tusing a switch.\n+\t(coalescePaintEvents): New method.\n+\t(processEvent): Fix unfortunate ordering of statements, and call\n+\tcorrect method for MOUSE_CLICKED.\n+\t(processPaintEvent): New method.\n+\t(addNotify): Allow container to notify children before event\n+\tmask is set in peer.\n+\t(addNotifyContainerChildren): New method.\n+\t(removeNotify): Visibility should not change on removeNotify.\n+\t(paramString): Implemented.\n+\t(list): Implemented two of the list methods.\n+\t* Container (myInsets): Removed, insets are managed by peer.\n+\t(getInsets): Query peer.\n+\t(addImpl): Fix reparenting, enable events for lightweights,\n+\tinitialize component array.\n+\t(validate): Call doLayout in validateTree() instead.\n+\t(validateTree): Do nothing if already valid. Call beginValidate(),\n+\tendValidate() on peer. Call validateTree() instead of validate()\n+\tfor children that are containers. Mark valid after validation of\n+\tchildren.\n+\t(setFont): Partial implementation.\n+\t(paint): Implemented.\n+\t(visitChildren): New method.\n+\t(visitChild): New method.\n+\t(update): Implemented.\n+\t(print): Implemented.\n+\t(paintComponents): Implemented.\n+\t(printComponents): Consider translation and clipping.\n+\t(getComponentAt): Ignore invisible children. Return this if no\n+\tchild match.\n+\t(addNotify): Call super.\n+\t(addNotifyContainerChildren): New method.\n+\t(paramString): Implemented.\n+\t(list): Implemented.\n+\t* java/awt/EventQueue (invokeAndWait): Get system event queue the\n+\tright way.\n+\t(invokeLater): Likewise.\n+\t(isDispatchThread): Likewise.\n+\t* java/awt/FontMetrics (getLeading): Formula change.\n+\t(getDescent): Consider leading also.\n+\t(getMaxAscent): Default to getAscent().\n+\t(getMaxDescent): Default to getDescent.\n+\t(getMaxAdvance): Return value signifying unknown.\n+\t(charWidth): Both methods implemented.\n+\t(charsWidth): Implemented.\n+\t(bytesWidth): Implemented.\n+\t(getWidths): Implemented.\n+\t* java/awt/Frame.java (NORMAL, ICONIFIED, iconImage, isResizable,\n+\tstate): New fields.\n+\t(Frame): Rearragend constuctor chaining to disallow null being\n+\tpassed as a graphics configuration.\n+\t(getTitle): Return empty string if null.\n+\t(dispose): Removed.\n+\t(getIconImage): New method.\n+\t(setIconImage): New method.\n+\t(finalize): New method.\n+\t(setMenuBar): Notify peer.\n+\t(isResizable): New method.\n+\t(setResizable): New method.\n+\t(getState): New method.\n+\t(getFont): Removed.\n+\t(remove): Implemented.\n+\t(removeNotify): New method.\n+\t(getFrames): New method.\n+\t* java/awt/Graphics.java: Implemented body of class.\n+\t* java/awt/Graphics2D.java: New file.\n+\t* java/awt/GraphicsConfiguration.java: Enabled part of the API.\n+\t* java/awt/Image.java: Implemented body of class.\n+\t* java/awt/Panel.java (Panel): Call correct super constructor.\n+\t(addNotify): Implemented.\n+\t* java/awt/Rectangle.java (isEmpty): Fixed reversed logic.\n+\t* java/awt/RenderingHints.java: New file.\n+\t* java/awt/Toolkit.java (createComponent): Implemented.\n+\t(getSystemEventQueue): Delegate to getSystemEventQueueImpl().\n+\t* java/awt/Window.java (Window): Two new constructors. Reordered\n+\tconstructor chaining.\n+\t(getGraphicsConfigurationImpl): New method.\n+\t(finalize): Call super.\n+\t(addNotify): Call super.\n+\t(pack): Do layout stuff.\n+\t(show): Ensure that peer exists and that component is valid.\n+\t(dispose): Dispose owned children.\n+\t(getOwner): Simplify code, casting null pointers is valid.\n+\t(getGraphicsConfiguration): Ask peer if local value is null.\n+\t* java/awt/event/ActionEvent.java (getActionCommand): Renamed from\n+\tgetcmd().\n+\t* java/awt/image/BufferedImage.java: New file.\n+\t* java/awt/image/RasterOp.java: New file.\n+\t* java/awt/peer/ComponentPeer.java (getGraphicsConfiguration):\n+\tMore powerfull replacement for getColorModel().\n+\t(getColorModel) Removed.\n+\t(setEventMask) New method.\n+\t* Makefile.am: Added new files.\n+\t* Makefile.in: Rebuilt.\n+\n 2000-08-15  Andrew Haley  <aph@cygnus.com>\n \n \t* include/jvm.h (_Jv_HashCode): New hash code."}, {"sha": "82ea83b30d6e15f6250a5088f50c686a28e86dac", "filename": "libjava/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -504,6 +504,8 @@ gnu/java/beans/ExplicitBeanInfo.java \\\n gnu/java/beans/IntrospectionIncubator.java \\\n gnu/gcj/awt/BitMaskExtent.java \\\n gnu/gcj/awt/Buffers.java \\\n+gnu/gcj/awt/ComponentDataBlitOp.java \\\n+gnu/gcj/awt/GLightweightPeer.java \\\n java/applet/Applet.java \\\n java/applet/AppletStub.java \\\n java/applet/AppletContext.java \\\n@@ -536,6 +538,7 @@ java/awt/Font.java \\\n java/awt/FontMetrics.java \\\n java/awt/Frame.java \\\n java/awt/Graphics.java \\\n+java/awt/Graphics2D.java \\\n java/awt/GraphicsConfiguration.java \\\n java/awt/IllegalComponentStateException.java \\\n java/awt/Image.java \\\n@@ -557,6 +560,7 @@ java/awt/Panel.java \\\n java/awt/Point.java \\\n java/awt/PopupMenu.java\t\\\n java/awt/Rectangle.java\t\\\n+java/awt/RenderingHints.java \\\n java/awt/ScrollPane.java \\\n java/awt/Scrollbar.java\t\\\n java/awt/Shape.java \\\n@@ -617,6 +621,7 @@ java/awt/geom/PathIterator.java\t\\\n java/awt/geom/Point2D.java \\\n java/awt/geom/Rectangle2D.java \\\n java/awt/geom/RectangularShape.java \\\n+java/awt/image/BufferedImage.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java\t\\\n java/awt/image/ComponentSampleModel.java \\\n@@ -631,6 +636,7 @@ java/awt/image/ImageProducer.java \\\n java/awt/image/IndexColorModel.java \\\n java/awt/image/PackedColorModel.java \\\n java/awt/image/Raster.java \\\n+java/awt/image/RasterOp.java \\\n java/awt/image/SampleModel.java\t\\\n java/awt/image/SinglePixelPackedSampleModel.java \\\n java/awt/image/WritableRaster.java \\"}, {"sha": "6f3af05239537bebd37934a6ba84ec1e510f355e", "filename": "libjava/Makefile.in", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -84,7 +84,6 @@ GCOBJS = @GCOBJS@\n GCSPEC = @GCSPEC@\n GCTESTSPEC = @GCTESTSPEC@\n INCLTDL = @INCLTDL@\n-JC1GCSPEC = @JC1GCSPEC@\n LIBDATASTARTSPEC = @LIBDATASTARTSPEC@\n LIBGCJTESTSPEC = @LIBGCJTESTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n@@ -281,6 +280,8 @@ gnu/java/beans/ExplicitBeanInfo.java \\\n gnu/java/beans/IntrospectionIncubator.java \\\n gnu/gcj/awt/BitMaskExtent.java \\\n gnu/gcj/awt/Buffers.java \\\n+gnu/gcj/awt/ComponentDataBlitOp.java \\\n+gnu/gcj/awt/GLightweightPeer.java \\\n java/applet/Applet.java \\\n java/applet/AppletStub.java \\\n java/applet/AppletContext.java \\\n@@ -313,6 +314,7 @@ java/awt/Font.java \\\n java/awt/FontMetrics.java \\\n java/awt/Frame.java \\\n java/awt/Graphics.java \\\n+java/awt/Graphics2D.java \\\n java/awt/GraphicsConfiguration.java \\\n java/awt/IllegalComponentStateException.java \\\n java/awt/Image.java \\\n@@ -334,6 +336,7 @@ java/awt/Panel.java \\\n java/awt/Point.java \\\n java/awt/PopupMenu.java\t\\\n java/awt/Rectangle.java\t\\\n+java/awt/RenderingHints.java \\\n java/awt/ScrollPane.java \\\n java/awt/Scrollbar.java\t\\\n java/awt/Shape.java \\\n@@ -394,6 +397,7 @@ java/awt/geom/PathIterator.java\t\\\n java/awt/geom/Point2D.java \\\n java/awt/geom/Rectangle2D.java \\\n java/awt/geom/RectangularShape.java \\\n+java/awt/image/BufferedImage.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java\t\\\n java/awt/image/ComponentSampleModel.java \\\n@@ -408,6 +412,7 @@ java/awt/image/ImageProducer.java \\\n java/awt/image/IndexColorModel.java \\\n java/awt/image/PackedColorModel.java \\\n java/awt/image/Raster.java \\\n+java/awt/image/RasterOp.java \\\n java/awt/image/SampleModel.java\t\\\n java/awt/image/SinglePixelPackedSampleModel.java \\\n java/awt/image/WritableRaster.java \\\n@@ -1003,8 +1008,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/$(srcdir)/$(CONVERT_DIR)/make-trie.P .deps/boehm.P \\\n .deps/defineclass.P .deps/exception.P .deps/gij.P \\\n .deps/gnu/gcj/RawData.P .deps/gnu/gcj/awt/BitMaskExtent.P \\\n-.deps/gnu/gcj/awt/Buffers.P .deps/gnu/gcj/convert/BytesToUnicode.P \\\n-.deps/gnu/gcj/convert/Convert.P .deps/gnu/gcj/convert/IOConverter.P \\\n+.deps/gnu/gcj/awt/Buffers.P .deps/gnu/gcj/awt/ComponentDataBlitOp.P \\\n+.deps/gnu/gcj/awt/GLightweightPeer.P \\\n+.deps/gnu/gcj/convert/BytesToUnicode.P .deps/gnu/gcj/convert/Convert.P \\\n+.deps/gnu/gcj/convert/IOConverter.P \\\n .deps/gnu/gcj/convert/Input_8859_1.P \\\n .deps/gnu/gcj/convert/Input_EUCJIS.P \\\n .deps/gnu/gcj/convert/Input_JavaSrc.P \\\n@@ -1073,7 +1080,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/EventQueue.P .deps/java/awt/FileDialog.P \\\n .deps/java/awt/Font.P .deps/java/awt/FontMetrics.P \\\n .deps/java/awt/Frame.P .deps/java/awt/Graphics.P \\\n-.deps/java/awt/GraphicsConfiguration.P \\\n+.deps/java/awt/Graphics2D.P .deps/java/awt/GraphicsConfiguration.P \\\n .deps/java/awt/IllegalComponentStateException.P .deps/java/awt/Image.P \\\n .deps/java/awt/Insets.P .deps/java/awt/ItemSelectable.P \\\n .deps/java/awt/Label.P .deps/java/awt/LayoutManager.P \\\n@@ -1084,12 +1091,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/Paint.P .deps/java/awt/PaintContext.P \\\n .deps/java/awt/Panel.P .deps/java/awt/Point.P \\\n .deps/java/awt/PopupMenu.P .deps/java/awt/Rectangle.P \\\n-.deps/java/awt/ScrollPane.P .deps/java/awt/Scrollbar.P \\\n-.deps/java/awt/Shape.P .deps/java/awt/TextArea.P \\\n-.deps/java/awt/TextComponent.P .deps/java/awt/TextField.P \\\n-.deps/java/awt/Toolkit.P .deps/java/awt/Transparency.P \\\n-.deps/java/awt/Window.P .deps/java/awt/color/ColorSpace.P \\\n-.deps/java/awt/color/ICC_ColorSpace.P \\\n+.deps/java/awt/RenderingHints.P .deps/java/awt/ScrollPane.P \\\n+.deps/java/awt/Scrollbar.P .deps/java/awt/Shape.P \\\n+.deps/java/awt/TextArea.P .deps/java/awt/TextComponent.P \\\n+.deps/java/awt/TextField.P .deps/java/awt/Toolkit.P \\\n+.deps/java/awt/Transparency.P .deps/java/awt/Window.P \\\n+.deps/java/awt/color/ColorSpace.P .deps/java/awt/color/ICC_ColorSpace.P \\\n .deps/java/awt/color/ICC_Profile.P \\\n .deps/java/awt/datatransfer/Clipboard.P \\\n .deps/java/awt/event/AWTEventListener.P \\\n@@ -1130,7 +1137,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/geom/PathIterator.P .deps/java/awt/geom/Point2D.P \\\n .deps/java/awt/geom/Rectangle2D.P \\\n .deps/java/awt/geom/RectangularShape.P \\\n-.deps/java/awt/image/ColorModel.P \\\n+.deps/java/awt/image/BufferedImage.P .deps/java/awt/image/ColorModel.P \\\n .deps/java/awt/image/ComponentColorModel.P \\\n .deps/java/awt/image/ComponentSampleModel.P \\\n .deps/java/awt/image/DataBuffer.P .deps/java/awt/image/DataBufferByte.P \\\n@@ -1142,7 +1149,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/image/ImageProducer.P \\\n .deps/java/awt/image/IndexColorModel.P \\\n .deps/java/awt/image/PackedColorModel.P .deps/java/awt/image/Raster.P \\\n-.deps/java/awt/image/SampleModel.P \\\n+.deps/java/awt/image/RasterOp.P .deps/java/awt/image/SampleModel.P \\\n .deps/java/awt/image/SinglePixelPackedSampleModel.P \\\n .deps/java/awt/image/WritableRaster.P .deps/java/awt/peer/ButtonPeer.P \\\n .deps/java/awt/peer/CanvasPeer.P \\"}, {"sha": "34861c65f1d0ebcc5938a9c34f080f3da620dbe6", "filename": "libjava/gnu/gcj/awt/ComponentDataBlitOp.java", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fgnu%2Fgcj%2Fawt%2FComponentDataBlitOp.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fgnu%2Fgcj%2Fawt%2FComponentDataBlitOp.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fawt%2FComponentDataBlitOp.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -0,0 +1,123 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.awt;\n+\n+import java.awt.geom.*;\n+import java.awt.image.*;\n+import java.awt.RenderingHints;\n+\n+/**\n+ * This raster copy operation assumes that both source and destination\n+ * sample models are tightly pixel packed and contain the same number\n+ * of bands.\n+ *\n+ * @throws java.lang.ClassCastException if the sample models of the\n+ * rasters are not of type ComponentSampleModel.\n+ * \n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class ComponentDataBlitOp implements RasterOp\n+{\n+  public static ComponentDataBlitOp INSTANCE = new ComponentDataBlitOp();\n+\n+  public WritableRaster filter(Raster src, WritableRaster dest)\n+  {\n+    if (dest == null)\n+      dest = createCompatibleDestRaster(src);\n+    \n+    DataBuffer  srcDB =  src.getDataBuffer();\n+    DataBuffer destDB = dest.getDataBuffer();\n+    \n+    ComponentSampleModel  srcSM = (ComponentSampleModel)  src.getSampleModel();\n+    ComponentSampleModel destSM = (ComponentSampleModel) dest.getSampleModel();\n+\n+    \n+    // Calculate offset to data in the underlying arrays:\n+\n+    int  srcScanlineStride =  srcSM.getScanlineStride();\n+    int destScanlineStride = destSM.getScanlineStride();\n+    int srcX  =  src.getMinX() -  src.getSampleModelTranslateX();\n+    int srcY  =  src.getMinY() -  src.getSampleModelTranslateY();\n+    int destX = dest.getMinX() - dest.getSampleModelTranslateX();\n+    int destY = dest.getMinY() - dest.getSampleModelTranslateY();\n+\n+    int numBands = srcSM.getNumBands();\n+\n+    /* We can't use getOffset(x, y) from the sample model since we\n+       don't want the band offset added in. */\n+\t\n+    int srcOffset = \n+      numBands*srcX + srcScanlineStride*srcY +    // from sample model\n+      srcDB.getOffset();                          // from data buffer\n+\n+    int destOffset =\n+      numBands*destX + destScanlineStride*destY + // from sample model\n+      destDB.getOffset();                         // from data buffer\n+\n+    // Determine how much, and how many times to blit.\n+    \n+    int rowSize = src.getWidth()*numBands;\n+    int h = src.getHeight();\n+    \n+    if ((rowSize == srcScanlineStride) &&\n+\t(rowSize == destScanlineStride))\n+      {\n+\t// collapse scan line blits to one large blit.\n+\trowSize *= h;\n+\th = 1;\n+      }\n+\n+\t\n+    // Do blitting\n+    \n+    Object srcArray  = Buffers.getData(srcDB);\n+    Object destArray = Buffers.getData(destDB);\n+    \n+    for (int yd = 0; yd<h; yd++)\n+      {\n+\tSystem.arraycopy(srcArray, srcOffset, \n+\t\t\t destArray, destOffset,\n+\t\t\t rowSize);\n+\tsrcOffset  +=  srcScanlineStride;\n+\tdestOffset += destScanlineStride;\n+      }\n+    \n+\n+    return dest;\n+  }\n+\n+  public Rectangle2D getBounds2D(Raster src) \n+  {\n+    return src.getBounds();\n+  }\n+\n+  public WritableRaster createCompatibleDestRaster(Raster src) {\n+    \n+    /* FIXME: Maybe we should explicitly create a raster with a\n+       tightly pixel packed sample model, rather than assuming\n+       that the createCompatibleWritableRaster() method in Raster\n+       will create one. */\n+\n+    return src.createCompatibleWritableRaster();\n+  }\n+\n+  public Point2D getPoint2D(Point2D srcPoint, Point2D destPoint) \n+  {\n+    if (destPoint == null)\n+      return (Point2D) srcPoint.clone();\n+\n+    destPoint.setLocation(srcPoint);\n+    return destPoint;\n+  }\n+\n+  public RenderingHints getRenderingHints() \n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+}"}, {"sha": "f59c91758b51731fdabf245862defc3085ba03e3", "filename": "libjava/gnu/gcj/awt/GLightweightPeer.java", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fgnu%2Fgcj%2Fawt%2FGLightweightPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fgnu%2Fgcj%2Fawt%2FGLightweightPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fawt%2FGLightweightPeer.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -0,0 +1,134 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.awt;\n+\n+import java.awt.*;\n+import java.awt.peer.*;\n+import java.awt.image.*;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class GLightweightPeer implements LightweightPeer\n+{\n+  public static final GLightweightPeer INSTANCE = new GLightweightPeer();\n+\n+  public GLightweightPeer() {}\n+\n+  // -------- java.awt.peer.ComponentPeer implementation:\n+  \n+  public int checkImage(Image img, int width, int height, ImageObserver o)\n+  {\n+    return 0;\n+  }\n+\n+  public Image createImage(ImageProducer prod)\n+  {\n+    return null;\n+  }\n+\n+  public Image createImage(int width, int height)\n+  {\n+    return null;\n+  }\n+\n+  public void disable() {}\n+\n+  public void dispose() {}\n+\n+  public void enable() {}\n+\n+  public GraphicsConfiguration getGraphicsConfiguration()\n+  {\n+    return null;\n+  }\n+  \n+  public FontMetrics getFontMetrics(Font f)\n+  {\n+    return null;\n+  }\n+\n+  public Graphics getGraphics()\n+  {\n+    return null;\n+  }\n+\n+  public Point getLocationOnScreen()\n+  {\n+    return null;\n+  }\n+\n+  public Dimension getMinimumSize()\n+  {\n+    return null;\n+  }\n+\n+  public Dimension getPreferredSize()\n+  {\n+    return null;\n+  }\n+\n+  public Toolkit getToolkit()\n+  {\n+    return null;\n+  }\n+\n+  public void handleEvent(AWTEvent e) {}\n+\n+  public void hide() {}\n+\n+  public boolean isFocusTraversable()\n+  {\n+    return false;\n+  }\n+\n+  public Dimension minimumSize()\n+  {\n+    return null;\n+  }\n+\n+  public Dimension preferredSize()\n+  {\n+    return null;\n+  }\n+\n+  public void paint(Graphics graphics) {}\n+\n+  public boolean prepareImage(Image img, int width, int height,\n+\t\t\t      ImageObserver o)\n+  {\n+    return false;\n+  }\n+\n+  public void print(Graphics graphics) {}\n+\n+  public void repaint(long tm, int x, int y, int width, int height) {}\n+\n+  public void requestFocus() {}\n+\n+  public void reshape(int x, int y, int width, int height) {}\n+\n+  public void setBackground(Color color) {}\n+\n+  public void setBounds(int x, int y, int width, int height) {}\n+\n+  public void setCursor(Cursor cursor) {}\n+\n+  public void setEnabled(boolean enabled) {}\n+\n+  public void setEventMask(long eventMask) {}\n+\n+  public void setFont(Font font) {}\n+\n+  public void setForeground(Color color) {}\n+\n+  public void setVisible(boolean visible) {}\n+\n+  public void show() {}\n+}"}, {"sha": "0d779c1a752129b919496e630e1760a82e2a35b2", "filename": "libjava/java/awt/BorderLayout.java", "status": "modified", "additions": 227, "deletions": 24, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FBorderLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FBorderLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FBorderLayout.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -8,12 +8,25 @@\n \n package java.awt;\n \n-/* A very incomplete placeholder. */\n-\n-public class BorderLayout implements LayoutManager2\n+public class BorderLayout implements LayoutManager2, java.io.Serializable\n {\n+  public static final String NORTH  = \"North\",\n+                             SOUTH  = \"South\",\n+                             EAST   = \"East\",\n+                             WEST   = \"West\",\n+                             CENTER = \"Center\";\n+  \n+  // FIXME: use these too\n+  public static final String BEFORE_FIRST_LINE = \"First\",\n+                             AFTER_LAST_LINE = \"Last\",\n+                             BEFORE_LINE_BEGINS = \"Before\",\n+                             AFTER_LINE_ENDS = \"After\";\n+\n+\n+  // FIXME: check serialization of fields\n   int hgap;\n   int vgap;\n+  Component north, south, east, west, center;\n \n   public BorderLayout ()\n   {\n@@ -26,26 +39,216 @@ public BorderLayout (int hgap, int vgap)\n     this.vgap = vgap;\n   }\n \n-  public void addLayoutComponent (String name, Component comp)\n-  { /* FIXME */ }\n-  public void layoutContainer (Container parent)\n-  { /* FIXME */ }\n-  public Dimension minimumLayoutSize (Container parent)\n-  { /* FIXME */ return null; }\n-  public Dimension preferredLayoutSize (Container parent)\n-  { /* FIXME */ return null; }\n-  public void removeLayoutComponent (Component comp)\n-  { /* FIXME */ }\n-\n-  public void addLayoutComponent (Component comp, Object constraints)\n-  { /* FIXME */ }\n-  public float getLayoutAlignmentX (Container target)\n-  { /* FIXME */ return (float) 0.0; }\n-  public float getLayoutAlignmentY (Container target)\n-  { /* FIXME */ return (float) 0.0; }\n-  public void invalidateLayout (Container target)\n-  { /* FIXME */ }\n-  public Dimension maximumLayoutSize (Container target)\n-  { /* FIXME */ return null; }\n+  public int getHgap()\n+  {\n+    return hgap;\n+  }    \n+\n+  public void setHgap(int hgap)\n+  {\n+    this.hgap = hgap;\n+  }\n+\n+  public int getVgap()\n+  {\n+    return vgap;\n+  }    \n+\n+  public void setVgap(int vgap)\n+  {\n+    this.vgap = vgap;\n+  }\n+  \n+  public void addLayoutComponent(Component comp, Object constraints)\n+  {\n+    if ((constraints == null) || CENTER.equals(constraints))\n+      {\n+\tcenter = comp; \n+      }\n+    else if (NORTH.equals(constraints))\n+      {\n+\tnorth = comp;\n+      }\n+    else if (SOUTH.equals(constraints))\n+      {\n+\tsouth = comp;\n+      }\n+    else if (EAST.equals(constraints))\n+      {\n+\teast = comp;\n+      }\n+    else if (WEST.equals(constraints))\n+      {\n+\twest = comp;\n+      }\n+  }\n+    \n+  public void addLayoutComponent(String name, Component comp)\n+  {\n+    addLayoutComponent(comp, name);\n+  }\n+\n+  public void removeLayoutComponent(Component comp)\n+  {\n+    if (center == comp)\n+      {\n+\tcenter = null;\n+      }\n+    else if (north == comp)\n+      {\n+\tnorth = null;\n+      }\n+    else if (south == comp)\n+      {\n+\tsouth = null;\n+      }\n+    else if (east == comp)\n+      {\n+\teast = null;\n+      }\n+    else if (west == comp)\n+      {\n+\twest = null;\n+      }\n+  }\n+\n+  public Dimension minimumLayoutSize(Container target)\n+  {\n+    return calcSize(getMinimumSize(center),\n+\t\t    getMinimumSize(north),\n+\t\t    getMinimumSize(south),\n+\t\t    getMinimumSize(east),\n+\t\t    getMinimumSize(west),\n+\t\t    target);\n+  }\n+\n+  public Dimension preferredLayoutSize(Container target)\n+  {\n+    return calcSize(getPreferredSize(center),\n+\t\t    getPreferredSize(north),\n+\t\t    getPreferredSize(south),\n+\t\t    getPreferredSize(east),\n+\t\t    getPreferredSize(west),\n+\t\t    target);\t\n+  }\n+    \n+  /**\n+   * Completely disregards the requested maximum sizes of the\n+   * components, and states that the container has no upper size\n+   * limit.\n+   *\n+   * @return a dimension of width and height Integer.MAX_VALUE.\n+   */\n+  public Dimension maximumLayoutSize(Container target)\n+  {\n+    return (Dimension) DIM_MAX.clone();\n+  }\t\n+\n+  public float getLayoutAlignmentX(Container parent)\n+  {\n+    return Component.CENTER_ALIGNMENT;\n+  }\n+\n+  public float getLayoutAlignmentY(Container parent)\n+  {\n+    return Component.CENTER_ALIGNMENT;\n+  }\n+    \n+  public void invalidateLayout(Container target)\n+  {\n+    // TODO... implement caching?\n+  }\n+\n+  public void layoutContainer(Container target)\n+  {\n+    Insets i = target.getInsets();\n+    Dimension c = getPreferredSize(center);\n+    Dimension n = getPreferredSize(north);\n+    Dimension s = getPreferredSize(south);\n+    Dimension e = getPreferredSize(east);\n+    Dimension w = getPreferredSize(west);\n+    Dimension t = target.getSize();\n+    \n+    /*\n+             <-> hgap     <-> hgap\n+      +----------------------------+          }\n+      |t                           |          } i.top\n+      |  +----------------------+  |  --- y1  }\n+      |  |n                     |  |\n+      |  +----------------------+  |          } vgap\n+      |  +---+ +----------+ +---+  |  --- y2  }        }\n+      |  |w  | |c         | |e  |  |                   } hh\n+      |  +---+ +----------+ +---+  |          } vgap   }\n+      |  +----------------------+  |  --- y3  }\n+      |  |s                     |  |\n+      |  +----------------------+  |          }\n+      |                            |          } i.bottom\n+      +----------------------------+          }\n+         |x1   |x2          |x3\n+         <---------------------->\n+      <-->         ww           <-->\n+     i.left                    i.right\n+    */\n+\n+    int x1 = i.left;\n+    int x2 = x1 + w.width + hgap;\n+    int x3 = t.width - i.right - e.width;\n+    int ww = t.width - i.right - i.left;\n+\n+    int y1 = i.top;\n+    int y2 = y1 + n.height + vgap;\n+    int y3 = t.height - i.bottom - s.height;\n+    int hh = y3-y2-vgap;\n+\n+    setBounds(center, x2, y2, x3-x2-hgap, hh);\n+    setBounds(north, x1, y1, ww, n.height);\n+    setBounds(south, x1, y3, ww, s.height);\n+    setBounds(west, x1, y2, w.width, hh);\n+    setBounds(east, x3, y2, e.width, hh);\n+  }\n+  \n+  public String toString()\n+  {\n+    return getClass().getName() + \"[hgap=\" + hgap + \",vgap=\" + vgap + \"]\";\n+  }\n \n+\n+  // Support:\n+\n+  static final Dimension DIM_0   = new Dimension(0, 0);\n+  static final Dimension DIM_MAX = new Dimension(Integer.MAX_VALUE,\n+\t\t\t\t\t\t Integer.MAX_VALUE);\n+\n+  void setBounds(Component comp, int x, int y, int w, int h)\n+  {\n+    if (comp == null)\n+      return;\n+    comp.setBounds(x, y, w, h);\n+  }\n+\n+  Dimension getMinimumSize(Component comp)\n+  {\n+    if (comp == null)\n+      return DIM_0;\n+    return comp.getMinimumSize();\n+  }\n+\n+  Dimension getPreferredSize(Component comp)\n+  {\n+    if (comp == null)\n+      return DIM_0;\n+    return comp.getPreferredSize();\n+  }\n+\n+  Dimension calcSize(Dimension c, Dimension n, Dimension s,\n+\t\t     Dimension e, Dimension w, Container target)\n+  {\n+    Insets i = target.getInsets();\n+    \n+    return new Dimension(c.width + e.width + w.width + hgap*2 +\n+\t\t\t i.left + i.right,\n+\t\t\t c.height + n.height + s.height + vgap*2 +\n+\t\t\t i.top + i.bottom\n+\t\t\t );\n+  }\n }"}, {"sha": "cee3ae753583109526adcff93c2d70f26faf5d9d", "filename": "libjava/java/awt/Button.java", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FButton.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -11,6 +11,7 @@\n import java.awt.peer.ComponentPeer;\n import java.awt.event.ActionListener;\n import java.awt.event.ActionEvent;\n+import java.util.EventListener;\n \n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n@@ -31,18 +32,19 @@ public Button (String label)\n \n   public void addActionListener (ActionListener l)\n   {\n-    listeners = AWTEventMulticaster.add (listeners, l);\n+    actionListener = AWTEventMulticaster.add (actionListener, l);\n   }\n \n   public void addNotify ()\n   {\n     if (peer == null)\n       peer = (ComponentPeer) getToolkit ().createButton (this);\n+    super.addNotify();\n   }\n \n   public String getActionCommand ()\n   {\n-    return command;\n+    return actionCommand;\n   }\n \n   public String getLabel ()\n@@ -55,10 +57,21 @@ protected String paramString ()\n     return \"Button[\" + label + \"]\";\n   }\n \n+  void dispatchEventImpl(AWTEvent e)\n+  {\n+      super.dispatchEventImpl(e);\n+      \n+      if (e.id <= ActionEvent.ACTION_LAST \n+\t  && e.id >= ActionEvent.ACTION_FIRST\n+\t  && (actionListener != null \n+\t      || (eventMask & AWTEvent.ACTION_EVENT_MASK) != 0))\n+\t  processEvent(e);\n+  }\n+\n   protected void processActionEvent (ActionEvent e)\n   {\n-    if (listeners != null)\n-      listeners.actionPerformed (e);\n+    if (actionListener != null)\n+      actionListener.actionPerformed (e);\n   }\n \n   protected void processEvent (AWTEvent e)\n@@ -71,12 +84,19 @@ protected void processEvent (AWTEvent e)\n \n   public void removeActionListener (ActionListener l)\n   {\n-    listeners = AWTEventMulticaster.remove (listeners, l);\n+    actionListener = AWTEventMulticaster.remove (actionListener, l);\n+  }\n+\n+  public EventListener[] getListeners(Class listenerType)\n+  {\n+    if (listenerType == ActionListener.class)\n+      return getListenersImpl(listenerType, actionListener);\n+    return super.getListeners(listenerType);\n   }\n \n   public void setActionCommand (String command)\n   {\n-    this.command = (command == null) ? label : command;\n+    this.actionCommand = (command == null) ? label : command;\n   }\n \n   public void setLabel (String label)\n@@ -89,7 +109,8 @@ public void setLabel (String label)\n       }\n   }\n \n-  private String label;\n-  private String command;\n-  private ActionListener listeners;\n+  String label;\n+  String actionCommand;\n+\n+  transient ActionListener actionListener;\n }"}, {"sha": "a4fe50fc5ec5f94f1ae42cceb3cac4562636765f", "filename": "libjava/java/awt/Canvas.java", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FCanvas.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FCanvas.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FCanvas.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -8,8 +8,45 @@\n \n package java.awt;\n \n-/* A very incomplete placeholder. */\n+import java.awt.peer.ComponentPeer;\n \n public class Canvas extends Component\n {\n+  transient GraphicsConfiguration graphicsConfiguration;\n+  \n+  public Canvas() { }\n+  \n+  public Canvas(GraphicsConfiguration graphicsConfiguration)\n+  {\n+    this.graphicsConfiguration = graphicsConfiguration;\n+  }\n+\n+  GraphicsConfiguration getGraphicsConfigurationImpl()\n+  {\n+    if (graphicsConfiguration != null)\n+      return graphicsConfiguration;\n+    return super.getGraphicsConfigurationImpl();\n+  }\n+\n+  public void addNotify()\n+  {\n+    if (peer == null)\n+      {\n+\tpeer = (ComponentPeer) getToolkit().createCanvas(this);\n+      }\n+    super.addNotify();\n+  }\n+\n+  /** Override this to create components with custom painting.\n+      Defaults to filling the component with the background color. */\n+  public void paint(Graphics gfx)\n+  {\n+    /* This implementation doesn't make much sense since the filling\n+      of background color is guaranteed for heavyweight components\n+      such as this.  But there's no need to worry, since paint() is\n+      usually overridden anyway.  */\n+    gfx.setColor(getBackground());\n+    Dimension size = getSize();\n+    gfx.fillRect(0, 0, size.width, size.height);\n+  }\n }"}, {"sha": "6225767d2fd382fe975531bff8a2fda06c36f784", "filename": "libjava/java/awt/Color.java", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FColor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FColor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FColor.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -87,6 +87,29 @@ public int getRGB()\n   {\n     return rgba;\n   }\n+\n+  static final int BRIGHT_STEP = 0x30;\n+\n+  public Color brighter()\n+  {\n+    return new Color(Math.min(255, getRed()   + BRIGHT_STEP),\n+\t\t     Math.min(255, getGreen() + BRIGHT_STEP),\n+\t\t     Math.min(255, getBlue()  + BRIGHT_STEP),\n+\t\t     getAlpha());\n+  }\n+    \n+  public Color darker()\n+  {\n+    return new Color(Math.max(0, getRed()   - BRIGHT_STEP),\n+\t\t     Math.max(0, getGreen() - BRIGHT_STEP),\n+\t\t     Math.max(0, getBlue()  - BRIGHT_STEP),\n+\t\t     getAlpha());\n+  }\n+    \n+  public int hashCode()\n+  {\n+    return rgba;\n+  }\n   \n   public int getTransparency()\n   {\n@@ -96,3 +119,4 @@ public int getTransparency()\n       return Transparency.TRANSLUCENT;\n   }\n }\n+"}, {"sha": "e748904675552627fd09b53ba561b0edf0d7497f", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 294, "deletions": 58, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -17,6 +17,7 @@\n import java.util.ResourceBundle;\n import java.util.Vector;\n import java.awt.peer.ComponentPeer;\n+import java.awt.peer.LightweightPeer;\n import java.beans.PropertyChangeSupport;\n import java.beans.PropertyChangeListener;\n // import javax.accessibility.AccessibleContext;\n@@ -59,8 +60,8 @@ public abstract class Component implements ImageObserver, MenuContainer,\n   Font peerFont;\n   Cursor cursor;\n   Locale locale;\n-  boolean visible;\n-  boolean enabled;\n+  boolean visible = true; // default (except for Window)\n+  boolean enabled = true;\n   boolean valid;\n   boolean hasFocus;\n   //DropTarget dropTarget;\n@@ -70,7 +71,7 @@ public abstract class Component implements ImageObserver, MenuContainer,\n   Dimension minSize;\n   Dimension prefSize;\n   boolean newEventsOnly;  \n-  long eventMask;\n+  long eventMask = AWTEvent.PAINT_EVENT_MASK;\n   PropertyChangeSupport changeSupport;\n   boolean isPacked;\n   int componentSerializedDataVersion;\n@@ -143,8 +144,24 @@ public DropTarget getDropTarget()\n   /** @since 1.3 */\n   public GraphicsConfiguration getGraphicsConfiguration()\n   {\n+    return getGraphicsConfigurationImpl();\n+  }\n+\n+  /** Implementation method that allows classes such as Canvas and\n+      Window to override the graphics configuration without violating\n+      the published API. */\n+  GraphicsConfiguration getGraphicsConfigurationImpl()\n+  {\n+    if (peer != null)\n+      {\n+\tGraphicsConfiguration config = peer.getGraphicsConfiguration();\n+\tif (config != null)\n+\t  return config;\n+      }\n+\n     if (parent != null)\n       return parent.getGraphicsConfiguration();\n+\n     return null;\n   }\n \n@@ -156,7 +173,11 @@ public final Object getTreeLock()\n   public Toolkit getToolkit()\n   {\n     if (peer != null)\n-      return peer.getToolkit ();\n+      {\n+\tToolkit tk = peer.getToolkit();\n+\tif (tk != null)\n+\t  return tk;\n+      }\n     if (parent != null)\n       return parent.getToolkit ();\n     return Toolkit.getDefaultToolkit ();\n@@ -170,7 +191,9 @@ public boolean isValid()\n   /** @since 1.2 */\n   public boolean isDisplayable()\n   {\n-    return (peer != null);\n+    if (parent != null)\n+      return parent.isDisplayable();\n+    return false;\n   }\n   \n   public boolean isVisible()\n@@ -186,7 +209,7 @@ public boolean isShowing()\n     if (parent != null)\n       return (parent.isShowing());\n \n-    return true;\n+    return false;\n   }\n   \n   public boolean isEnabled()\n@@ -264,31 +287,50 @@ public void hide()\n   \n   public Color getForeground()\n   {\n-    return this.foreground;\n+    if (foreground != null)\n+      return foreground;\n+    if (parent != null)\n+      return parent.getForeground();\n+    return null;\n   }\n   \n   public void setForeground(Color c)\n   {\n     if (peer != null)\n       peer.setForeground(c);\n     this.foreground = c;\n+    if (peer != null)\n+      peer.setForeground(foreground);\n   }\n-  \n+\n+  /** @return the background color of the component. null may be\n+      returned instead of the actual background color, if this\n+      method is called before the component is added to the\n+      component hierarchy. */\n   public Color getBackground()\n   {\n-    return this.background;\n+    if (background != null)\n+      return background;\n+    if (parent != null)\n+      return parent.getBackground();\n+    return null;\n   }\n   \n   public void setBackground(Color c)\n   {\n     if (peer != null)\n       peer.setBackground(c);\n     this.background = c;\n+    if (peer != null) peer.setBackground(background);\n   }\n   \n   public Font getFont()\n   {\n-    return this.font;\n+    if (font != null)\n+      return font;\n+    if (parent != null)\n+      return parent.getFont();\n+    return null;\n   }\n   \n   public void setFont(Font f)\n@@ -311,12 +353,20 @@ public Locale getLocale() throws IllegalComponentStateException\n   public void setLocale(Locale l)  \n   {\n     this.locale = l;\n+    \n+    /* new writing/layout direction perhaps, or make more/less\n+       room for localized text labels */\n+    invalidate();\n   }\n   \n   public ColorModel getColorModel()\n   {\n-    // FIXME\n-    return null;\n+    GraphicsConfiguration config = getGraphicsConfiguration();\n+\n+    if (config != null)\n+      return config.getColorModel();\n+\n+    return getToolkit().getColorModel();    \n   }\n \n   public Point getLocation()\n@@ -338,6 +388,11 @@ public Point location()\n \n   public void setLocation (int x, int y)\n   {\n+    if ((this.x == x) && (this.y == y))\n+      return;\n+    \n+    invalidate();\n+    \n     this.x = x;\n     this.y = y;\n     if (peer != null)\n@@ -368,6 +423,11 @@ public Dimension size()\n   \n   public void setSize(int width, int height)\n   {\n+    if ((this.width == width) && (this.height == height))\n+      return;\n+\n+    invalidate();\n+\n     this.width = width;\n     this.height = height;\n     if (peer != null)\n@@ -404,10 +464,19 @@ public Rectangle bounds()\n   \n   public void setBounds(int x, int y, int w, int h)\n   {\n+    if (this.x == x\n+\t&& this.y == y\n+\t&& this.width == w\n+\t&& this.height == h)\n+      return;\n+\n+    invalidate();\n+\n     this.x = x;\n     this.y = y;\n     this.width = w;\n     this.height = h;\n+\n     if (peer != null)\n       peer.setBounds(x, y, w, h);\n   }\n@@ -473,14 +542,19 @@ public Point getLocation(Point p)\n   /** @since 1.2 */\n   public boolean isOpaque()\n   {\n-    return false;\n+    return !isLightweight();\n   }\n   \n-  /** @since 1.2 */  \n+  /** \n+   * Return whether the component is lightweight.\n+   *\n+   * @return true if component has a peer and and the peer is lightweight.\n+   *\n+   * @since 1.2\n+   */  \n   public boolean isLightweight()\n   {\n-    // FIXME\n-    return false;\n+    return (peer != null) && (peer instanceof LightweightPeer);\n   }\n   \n   public Dimension getPreferredSize()\n@@ -515,8 +589,7 @@ public Dimension minimumSize()\n   \n   public Dimension getMaximumSize()\n   {\n-    // FIXME\n-    return null;\n+    return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n   }\n   \n   public float getAlignmentX()\n@@ -533,7 +606,7 @@ public float getAlignmentY()\n   \n   public void doLayout()\n   {\n-    // FIXME\n+    // nothing to do unless we're a container\n   }\n   \n   /** @deprecated */\n@@ -544,26 +617,42 @@ public void layout()\n   \n   public void validate()\n   {\n-    // FIXME\n+    // nothing to do unless we're a container\n   }\n   \n   public void invalidate()\n   {\n     valid = false;\n-    if (parent != null)\n-      parent.invalidate ();\n+\n+    if ((parent != null) && parent.valid)\n+\tparent.invalidate ();\n   }\n   \n   public Graphics getGraphics()\n   {\n-    // FIXME\n+    if (peer != null)\n+      {\n+\tGraphics gfx = peer.getGraphics();\n+\tif (gfx != null)\n+\t  return gfx;\n+      \n+\t// create graphics for lightweight:\n+\tContainer parent = getParent();\n+\tif (parent != null)\n+\t  {\n+\t    gfx = parent.getGraphics();\n+\t    Rectangle bounds = getBounds();\n+\t    gfx.setClip(bounds);\n+\t    gfx.translate(bounds.x, bounds.y);\n+\t    return gfx;\n+\t  }\n+      }\n     return null;\n   }\n   \n   public FontMetrics getFontMetrics(Font font)\n   {\n-    // FIXME\n-    return null;\n+    return getToolkit().getFontMetrics(font);\n   }\n   \n   public void setCursor(Cursor cursor)\n@@ -582,41 +671,56 @@ public void paint(Graphics g)\n   \n   public void update(Graphics g)\n   {\n-    // FIXME\n+    paint(g);\n   }\n   \n   public void paintAll(Graphics g)\n   {    \n+    if (!visible)\n+      return;\n+\t\n+    if (peer != null)\n+      peer.paint(g);\n+    paint(g);\n   }\n   \n   public void repaint()\n   {\n-    // FIXME\n+    repaint(0, 0, 0, getWidth(), getHeight());\n   }\n   \n   public void repaint(long tm)\n   {\n-    // FIXME\n+    repaint(tm, 0, 0, getWidth(), getHeight());\n   }\n   \n   public void repaint(int x, int y, int width, int height)\n   {\n-    // FIXME  \n+    repaint(0, x, y, width, height);\n   }\n   \n   public void repaint(long tm, int x, int y, int width, int height)\n   {    \n-    // FIXME  \n+    // Handle lightweight repainting by forwarding to native parent\n+    if (isLightweight() && (parent != null))\n+      {\n+\tif (parent != null)\n+\t  parent.repaint(tm, x+getX(), y+getY(), width, height);\n+\treturn;\n+      }\n+    \n+    if (peer != null)\n+      peer.repaint(tm, x, y, width, height);\n   }\n   \n   public void print(Graphics g)\n   {\n-    // FIXME    \n+    paint(g);\n   }\n   \n   public void printAll(Graphics g)\n   {\n-    // FIXME      \n+    paintAll(g);\n   }\n   \n   public boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h)\n@@ -633,8 +737,7 @@ public Image createImage(ImageProducer producer)\n   \n   public Image createImage(int width, int height)\n   {\n-    // FIXME\n-    return null;\n+    return getGraphicsConfiguration().createCompatibleImage(width, height);\n   }\n   \n   public boolean prepareImage(Image image, ImageObserver observer)\n@@ -717,6 +820,10 @@ public void deliverEvent(Event e)\n   public final void dispatchEvent(AWTEvent e)\n   {\n     dispatchEventImpl(e);\n+\n+    /* Give the peer a chance to handle the event. */\n+    if (peer != null)\n+      peer.handleEvent(e);\n   }\n   \n   void dispatchEventImpl(AWTEvent e)\n@@ -754,6 +861,10 @@ else if (e.id <= HierarchyEvent.HIERARCHY_LAST\n \t\t || hierarchyBoundsListener != null\n \t\t || (eventMask & AWTEvent.HIERARCHY_EVENT_MASK) != 0))\n       processEvent(e);\n+    else if (e.id <= PaintEvent.PAINT_LAST\n+\t     && e.id >= PaintEvent.PAINT_FIRST\n+\t     && (eventMask & AWTEvent.PAINT_EVENT_MASK) != 0)      \n+      processEvent(e);\n   }\n   \n   /** @deprecated */\n@@ -939,6 +1050,9 @@ protected final void enableEvents(long eventsToEnable)\n     // interface, but thats okay because the peer interfaces have been\n     // deprecated for a long time, and no longer feature in the \n     // API specification at all.\n+\n+    if (isLightweight() && (parent != null))\n+      parent.enableEvents(eventsToEnable);\n   }\n   \n   protected final void disableEvents(long eventsToDisable)\n@@ -953,37 +1067,84 @@ protected final void disableEvents(long eventsToDisable)\n     */\n   protected AWTEvent coalesceEvents(AWTEvent existingEvent, AWTEvent newEvent)\n   {\n-    if (existingEvent instanceof MouseEvent\n-        && (existingEvent.id == MouseEvent.MOUSE_DRAGGED\n-\t    || existingEvent.id == MouseEvent.MOUSE_MOVED))\n+    switch (existingEvent.id)\n       {\n-        // Just drop the old (intermediate) event and return the new one.\n+      case MouseEvent.MOUSE_MOVED:\n+      case MouseEvent.MOUSE_DRAGGED:\n+\t// Just drop the old (intermediate) event and return the new one.\n \treturn newEvent;\n+      case PaintEvent.PAINT:\n+      case PaintEvent.UPDATE:\n+\treturn coalescePaintEvents((PaintEvent) existingEvent,\n+\t\t\t\t   (PaintEvent) newEvent);\n       }\n-    /*\n-    else if (existingEvent instanceof PaintEvent)\n-      {\n-        // The JDK 1.3 documentation says that in this case a complex \n-\t// RepaintArea is generated. We don't do that yet, and creating a \n-\t// union area as suggested by older documentation sounds ugly.\n-      }\n-    */\n-      \n-    // FIXME\n     return null;\n   }\n   \n+  /**\n+   * Coalesce paint events. Current heuristic is: Merge if the union of\n+   * areas is less than twice that of the sum of the areas. The X server\n+   * tend to create a lot of paint events that are adjacent but not\n+   * overlapping.\n+   *\n+   * <pre>\n+   * +------+\n+   * |      +-----+  ...will be merged\n+   * |      |     |\n+   * |      |     |\n+   * +------+     |\n+   *        +-----+\n+   * \n+   * +---------------+--+\n+   * |               |  |  ...will not be merged\n+   * +---------------+  |\n+   *                 |  |\n+   *                 |  |\n+   *                 |  |\n+   *                 |  |\n+   *                 |  |\n+   *                 +--+\n+   * </pre>\n+   */\n+\n+  private PaintEvent coalescePaintEvents(PaintEvent queuedEvent,\n+\t\t\t\t\t PaintEvent newEvent)\n+  {\n+    Rectangle r1 = queuedEvent.getUpdateRect();\n+    Rectangle r2 = newEvent.getUpdateRect();\n+    Rectangle union = r1.union(r2);\n+    \n+    int r1a = r1.width * r1.height;\n+    int r2a = r2.width * r2.height;\n+    int ua  = union.width * union.height;\n+    \n+    if (ua > (r1a+r2a)*2)\n+      return null;\n+    /* The 2 factor should maybe be reconsidered. Perhaps 3/2\n+       would be better? */\n+\n+    newEvent.setUpdateRect(union);\n+    return newEvent;\n+  }\n+\n+\n+\n+\n   /** Forward event to the appropriate processXXXEvent method based on the\n     * event type.\n     */\n   protected void processEvent(AWTEvent e)\n   {\n-    if (e instanceof ComponentEvent)\n-      processComponentEvent((ComponentEvent) e);\n-    else if (e instanceof FocusEvent)\n+\n+    /* Note: the order of these if statements are\n+       important. Subclasses must be checked first. Eg. MouseEvent\n+       must be checked before ComponentEvent, since a MouseEvent\n+       object is also an instance of a ComponentEvent. */\n+\n+    if (e instanceof FocusEvent)\n       processFocusEvent((FocusEvent) e);\n-    else if (e instanceof KeyEvent)\n-      processKeyEvent((KeyEvent) e);\n+    else if (e instanceof PaintEvent)\n+      processPaintEvent((PaintEvent) e);\n     else if (e instanceof MouseEvent)\n       {\n         if (e.id == MouseEvent.MOUSE_MOVED \n@@ -992,6 +1153,10 @@ else if (e instanceof MouseEvent)\n \telse\n \t  processMouseEvent((MouseEvent) e);\n       }\n+    else if (e instanceof ComponentEvent)\n+      processComponentEvent((ComponentEvent) e);\n+    else if (e instanceof KeyEvent)\n+      processKeyEvent((KeyEvent) e);\n     else if (e instanceof InputMethodEvent)\n       processInputMethodEvent((InputMethodEvent) e);\n     else if (e instanceof HierarchyEvent)\n@@ -1067,7 +1232,7 @@ protected void processMouseEvent(MouseEvent e)\n     switch (e.id)\n       {\n \tcase MouseEvent.MOUSE_CLICKED:\n-\t  mouseListener.mousePressed(e);\n+\t  mouseListener.mouseClicked(e);\n \tbreak;\n         case MouseEvent.MOUSE_ENTERED:\n \t  mouseListener.mouseEntered(e);\n@@ -1139,6 +1304,31 @@ protected void processHierarchyBoundsEvent(HierarchyEvent e)\n \tbreak;\n       }\n   }\n+\n+  private void processPaintEvent(PaintEvent event)\n+  {\n+    ComponentPeer peer = getPeer();\n+\t\n+    // Can't do graphics without peer\n+    if (peer == null)\n+      return;\n+\n+    Graphics gfx = getGraphics();\n+    Shape clip = event.getUpdateRect();\n+    gfx.setClip(clip);\n+\n+    switch (event.id)\n+      {\n+      case PaintEvent.PAINT:\n+\tif (peer != null) paint(gfx);\n+\tbreak;\n+      case PaintEvent.UPDATE:\n+\tif (peer != null) update(gfx);\n+\tbreak;\n+      default:\n+\tthrow new IllegalArgumentException(\"unknown paint event\");\n+      }\n+  }\n   \n   /** @deprecated */\n   public boolean handleEvent(Event evt)\n@@ -1204,14 +1394,33 @@ public void addNotify()\n   {\n     if (peer == null)\n       peer = getToolkit().createComponent(this);\n+\n+    /* Add notify children using a template method, so that it is\n+       possible to ensure that the new event mask delivered to the\n+       peer. */\n+    addNotifyContainerChildren();\n+\n+    /* Now that all the children has gotten their peers, we should\n+       have the event mask needed for this component and its\n+       lightweight subcomponents. */\n+\n+    peer.setEventMask(eventMask);\n+\n+    /* We do not invalidate here, but rather leave that job up to\n+       the peer. For efficiency, the peer can choose not to\n+       invalidate if it is happy with the current dimensions,\n+       etc. */\n   }\n-  \n+\n+  void addNotifyContainerChildren() {\n+    // nothing to do unless we're a container\n+  }\n+\n   public void removeNotify()\n   {    \n     if (peer != null)\n       peer.dispose();\n     peer = null;\n-    visible = false;\n   }\n   \n   /** @deprecated */\n@@ -1269,8 +1478,33 @@ public synchronized void remove(MenuComponent popup)\n   \n   protected String paramString()\n   {\n-    // FIXME\n-    return \"FIXME\";\n+    StringBuffer param = new StringBuffer();\n+    String name = getName();\n+    if (name != null)\n+      {\n+\tparam.append(name);\n+\tparam.append(\",\");\n+      }\n+    param.append(width);\n+    param.append(\"x\");\n+    param.append(height);\n+    param.append(\"+\");\n+    param.append(x);\n+    param.append(\"+\");\n+    param.append(y);\n+    \n+    if (!isValid())\n+      param.append(\",invalid\");\n+    if (!isVisible())\n+      param.append(\",invisible\");\n+    if (!isEnabled())\n+      param.append(\",disabled\");\n+    if (!isOpaque())\n+      param.append(\",translucent\");\n+    if (isDoubleBuffered())\n+      param.append(\",doublebuffered\");\n+    \n+    return param.toString();\n   }\n   \n   public String toString()\n@@ -1280,10 +1514,12 @@ public String toString()\n   \n   public void list()\n   {\n+    list(System.out);\n   }\n   \n   public void list(PrintStream out)\n   {\n+    list(out, 0);\n   }\n   \n   public void list(PrintStream out, int indent)"}, {"sha": "0cb60bae1c2e4863c4c53f4945a02213cacb1172", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 171, "deletions": 19, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -14,8 +14,9 @@\n import java.util.EventListener;\n import java.awt.peer.ComponentPeer;\n import java.awt.peer.ContainerPeer;\n+import java.awt.peer.LightweightPeer;\n \n-/* A very incomplete placeholder. */\n+/* A somewhat incomplete class. */\n \n public abstract class Container extends Component\n {\n@@ -30,9 +31,6 @@ public abstract class Container extends Component\n   /* Anything else is non-serializable, and should be declared \"transient\". */\n   transient ContainerListener containerListener;  \n \n-  // Insets.\n-  private transient Insets myInsets;\n-\n   public Container()\n   {\n   }\n@@ -65,7 +63,10 @@ public Component[] getComponents()\n \n   public Insets getInsets()\n   {\n-    return myInsets;\n+    if (peer == null)\n+\treturn new Insets(0, 0, 0, 0);\n+\t\n+    return ((ContainerPeer) peer).getInsets();\n   }\n \n   /** @deprecated Use getInsets() instead. */\n@@ -112,14 +113,22 @@ protected void addImpl (Component comp, Object constraints, int index)\n \n     // Reparent component, and make sure component is instantiated if\n     // we are.\n-    if (comp.parent != this)\n+    if (comp.parent != null)\n       comp.parent.remove (comp);\n     comp.parent = this;\n     if (peer != null)\n-      comp.addNotify ();\n+      {\n+\tcomp.addNotify ();\n+    \n+\tif (comp.isLightweight())\n+\t  enableEvents(comp.eventMask);\n+      }\n \n     invalidate ();\n \n+    if (component == null)\n+\tcomponent = new Component[4]; // FIXME, better initial size?\n+\n     // This isn't the most efficient implementation.  We could do less\n     // copying when growing the array.  It probably doesn't matter.\n     if (ncomponents >= component.length)\n@@ -228,20 +237,48 @@ public void validate()\n   {\n     if (! isValid ())\n       {\n-\tdoLayout ();\n \tvalidateTree ();\n       }\n   }\n \n   protected void validateTree()\n   {\n+    if (valid) return; \n+\n+    ContainerPeer cPeer = null;\n+    if ((peer != null) && !(peer instanceof LightweightPeer))\n+      {\n+\tcPeer = (ContainerPeer) peer;\n+\tcPeer.beginValidate();\n+      }\n+\n+    doLayout ();\n     for (int i = 0; i < ncomponents; ++i)\n-      component[i].validate ();\n+      {\n+\tComponent comp = component[i];\n+\tif (comp instanceof Container)\n+\t  {\n+\t    ((Container) comp).validateTree();\n+\t  }\n+\telse\n+\t  {\n+\t    component[i].validate();\n+\t  }\n+      }\n+    \n+    /* children will call invalidate() when they are layed out. It\n+       is therefore imporant that valid is not set to true\n+       before after the children has been layed out. */\n+    valid = true;\n+\n+    if (cPeer != null)\n+      cPeer.endValidate();\n   }\n \n   public void setFont(Font f)\n   {\n-    // FIXME\n+    super.setFont(f);\n+    // FIXME, should invalidate all children with font == null\n   }\n \n   public Dimension getPreferredSize()\n@@ -307,28 +344,91 @@ public float getAlignmentY()\n \n   public void paint(Graphics g)\n   {\n-    // FIXME\n+    if (!isShowing())\n+      return;\n+    super.paint(g);\n+    visitChildren(g, GfxPaintVisitor.INSTANCE, true);\n+  }\n+\n+  /** \n+   * Perform a graphics operation on the children of this container.\n+   * For each applicable child, the visitChild() method will be called\n+   * to perform the graphics operation.\n+   *\n+   * @param gfx The graphics object that will be used to derive new\n+   * graphics objects for the children.\n+   *\n+   * @param visitor Object encapsulating the graphics operation that\n+   * should be performed.\n+   *\n+   * @param lightweightOnly If true, only lightweight components will\n+   * be visited.\n+   */\n+  private void visitChildren(Graphics gfx, GfxVisitor visitor,\n+\t\t     boolean lightweightOnly)\n+  {\n+    // FIXME: do locking\n+\n+    for (int i = 0; i < ncomponents; ++i)\n+      {\n+\tComponent comp = component[i];\n+\tboolean applicable = comp.isVisible()\n+\t  && (comp.isLightweight() || !lightweightOnly);\n+\n+\tif (applicable)\n+\t  visitChild(gfx, visitor, comp);\n+      }\n+  }\n+\n+  /**\n+   * Perform a graphics operation on a child. A translated and clipped\n+   * graphics object will be created, and the visit() method of the\n+   * visitor will be called to perform the operation.\n+   *\n+   * @param gfx The graphics object that will be used to derive new\n+   * graphics objects for the child.\n+   *\n+   * @param visitor Object encapsulating the graphics operation that\n+   * should be performed.\n+   *\n+   * @param comp The child component that should be visited.\n+   */\n+  private void visitChild(Graphics gfx, GfxVisitor visitor,\n+\t\t\t  Component comp)\n+  {\n+    Rectangle bounds = comp.getBounds();\n+    Rectangle clip = gfx.getClipBounds().intersection(bounds);\n+    \n+    if (clip.isEmpty()) return;\n+\n+    Graphics gfx2 = gfx.create();\n+    gfx2.setClip(clip.x, clip.y, clip.width, clip.height);\n+    gfx2.translate(bounds.x, bounds.y);\n+    \n+    visitor.visit(comp, gfx2);\n   }\n \n   public void update(Graphics g)\n   {\n-    // FIXME\n+    super.update(g);\n   }\n \n   public void print(Graphics g)\n   {\n-    // FIXME\n+    super.print(g);\n+    visitChildren(g, GfxPrintVisitor.INSTANCE, true);\n   }\n \n   public void paintComponents(Graphics g)\n   {\n-    // FIXME\n+    super.paint(g);\n+    visitChildren(g, GfxPaintAllVisitor.INSTANCE, true);\n   }\n \n   public void printComponents(Graphics g)\n   {\n-    for (int i = 0; i < ncomponents; ++i)\n-      component[i].printAll (g);\n+    super.paint(g);\n+    visitChildren(g, GfxPrintAllVisitor.INSTANCE, true);\n   }\n   \n   void dispatchEventImpl(AWTEvent e)\n@@ -393,12 +493,16 @@ public Component getComponentAt (int x, int y)\n       return null;\n     for (int i = 0; i < ncomponents; ++i)\n       {\n+\t// Ignore invisible children...\n+\tif (!component[i].isVisible())\n+\t  continue;\n+\t\n \tint x2 = x - component[i].x;\n \tint y2 = y - component[i].y;\n \tif (component[i].contains (x2, y2))\n \t  return component[i];\n       }\n-    return null;\n+    return this;\n   }\n \n   /** @deprecated Use getComponentAt() instead */\n@@ -424,9 +528,18 @@ public Component findComponentAt(Point p)\n   }\n \n   public void addNotify ()\n+  {\n+    super.addNotify();\n+  }\n+\n+  void addNotifyContainerChildren()\n   {\n     for (int i = ncomponents;  --i >= 0; )\n-      component[i].addNotify();\n+      {\n+\tcomponent[i].addNotify();\n+\tif (component[i].isLightweight())\n+\t  enableEvents(component[i].eventMask);\n+      }\n   }\n \n   public void removeNotify()\n@@ -450,7 +563,11 @@ public boolean isAncestorOf (Component comp)\n \n   protected String paramString()\n   {\n-    return \"FIXME\";\n+    String param = super.paramString();\n+    if (layoutMgr != null)\n+      param = param + \",\" + layoutMgr.getClass().getName();\n+\n+    return param;\n   }\n   \n   public void list (PrintStream out, int indent)\n@@ -470,4 +587,39 @@ public void list(PrintWriter out, int indent)\n     for (int i = 0; i < ncomponents; ++i)\n       component[i].list (out, indent + 2);\n   }\n+\n+\n+  /* The following classes are used in concert with the\n+     visitChildren() method to implement all the graphics operations\n+     that requires traversal of the containment hierarchy. */\n+\n+  abstract static class GfxVisitor\n+  {\n+    public abstract void visit(Component c, Graphics gfx);\n+  }\n+\n+  static class GfxPaintVisitor extends GfxVisitor\n+  {\n+    public void visit(Component c, Graphics gfx) { c.paint(gfx); }\n+    public static final GfxVisitor INSTANCE = new GfxPaintVisitor();\n+  }\n+\n+  static class GfxPrintVisitor extends GfxVisitor\n+  {\n+    public void visit(Component c, Graphics gfx) { c.print(gfx); }\n+    public static final GfxVisitor INSTANCE = new GfxPrintVisitor();\n+  }\n+\n+  static class GfxPaintAllVisitor extends GfxVisitor\n+  {\n+    public void visit(Component c, Graphics gfx) { c.paintAll(gfx); }\n+    public static final GfxVisitor INSTANCE = new GfxPaintAllVisitor();\n+  }\n+\n+  static class GfxPrintAllVisitor extends GfxVisitor\n+  {\n+    public void visit(Component c, Graphics gfx) { c.printAll(gfx); }\n+    public static final GfxVisitor INSTANCE = new GfxPrintAllVisitor();\n+  }\n+\n }"}, {"sha": "2cddc6ba119b34f70721fa7f90fab456d2c01e2b", "filename": "libjava/java/awt/EventQueue.java", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FEventQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FEventQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FEventQueue.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -145,8 +145,7 @@ public synchronized void postEvent(AWTEvent evt)\n   public static void invokeAndWait(Runnable runnable)\n     throws InterruptedException, InvocationTargetException\n   {\n-    // FIXME: Is this an appropriate way to access the event queue?\n-    EventQueue eq = Toolkit.systemEventQueue; \n+    EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue(); \n     Thread current = Thread.currentThread();\n     if (current == eq.dispatchThread)\n       throw new Error(\"Can't call invokeAndWait from event dispatch thread\");\n@@ -169,8 +168,7 @@ public static void invokeAndWait(Runnable runnable)\n   /** @since JDK1.2 */\n   static void invokeLater(Runnable runnable)\n   {\n-    // FIXME: Is this an appropriate way to access the event queue?\n-    EventQueue eq = Toolkit.systemEventQueue; \n+    EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue(); \n \n     InvocationEvent ie = \n       new InvocationEvent(eq, runnable, null, false);\n@@ -180,8 +178,7 @@ static void invokeLater(Runnable runnable)\n   \n   static boolean isDispatchThread()\n   {\n-    // FIXME: Is this an appropriate way to access the event queue?\n-    EventQueue eq = Toolkit.systemEventQueue; \n+    EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue(); \n     return (Thread.currentThread() == eq.dispatchThread);\n   }\n   "}, {"sha": "dcd0946fa5b1af0c21bd0312b1922e7c7c60e019", "filename": "libjava/java/awt/FontMetrics.java", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FFontMetrics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FFontMetrics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFontMetrics.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -28,38 +28,32 @@ public Font getFont()\n \n   public int getLeading()\n   {\n-    // FIXME??\n-    return getHeight() - (getDescent() + getAscent());\n+    return getMaxAscent() + getMaxDescent() - (getAscent() + getDescent());\n   }\n \n   public int getAscent()\n   {\n-    // FIXME??\n     return getHeight() - (getDescent() + getLeading());\n   }\n \n   public int getDescent()\n   {\n-    // FIXME??\n-    return getHeight() - getDescent();\n+    return getHeight() - (getLeading() + getDescent());\n   }\n \n   public int getHeight()\n   {\n-    // FIXME??\n     return getLeading() + getAscent() + getDescent();\n   }\n \n   public int getMaxAscent()\n   {\n-    // FIXME\n-    return 0;\n+    return getAscent();\n   }\n \n   public int getMaxDescent()\n   {\n-    // FIXME\n-    return 0;\n+    return getDescent();\n   }\n \n   /* @deprecated Use getMaxDescent() instead. */\n@@ -68,45 +62,44 @@ public int getMaxDecent()\n     return getMaxDescent();\n   }\n \n+  /** @return max advance, or -1 if unknown. */\n   public int getMaxAdvance()\n   {\n-    // FIXME\n-    return 0;\n+    return -1;\n   }\n \n+\n   public int charWidth(int ch)\n   {\n-    // FIXME\n-    return 0;\n+    return charWidth((char) ch);\n   }\n \n   public int charWidth(char ch)\n   {\n-    // FIXME\n-    return 0;\n+    Character chObj = new Character(ch);\n+    return stringWidth(chObj.toString());\n   }\n-\n+    \n   public int stringWidth(String str)\n   {\n     return charsWidth(str.toCharArray(), 0, str.length());\n   }\n \n   public int charsWidth(char[] data, int off, int len)\n   {\n-    // FIXME\n-    return -1;\n+    return stringWidth(new String(data, off, len));\n   }\n \n   public int bytesWidth(byte[] data, int off, int len)\n   {\n-    // FIXME?\n-    return -1;\n+    return stringWidth(new String(data, off, len));\n   }\n-\n+    \n   public int[] getWidths()\n   {\n-    // FIXME\n-    return new int[0];\n+    int[] widths = new int[256];\n+    for (char c=0; c<256; c++) widths[c] = charWidth(c);\n+    return widths;\n   }\n \n   public boolean hasUniformLineMetrics()"}, {"sha": "22497f7f6b72d31e402a6ac00757680a3fac3ada", "filename": "libjava/java/awt/Frame.java", "status": "modified", "additions": 103, "deletions": 8, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFrame.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -13,34 +13,104 @@\n \n public class Frame extends Window implements MenuContainer\n {\n+  public static final int NORMAL = 0;\n+  public static final int ICONIFIED = 1;\n+\n   MenuBar menuBar = null;\n   String title;\n \n+  private transient Image iconImage;\n+  private transient boolean isResizable = true;\n+  private transient int state = NORMAL;\n+\n   public Frame ()\n   {\n-    super (null);\n+    super();\n+  }\n+\n+  public Frame(GraphicsConfiguration gc)\n+  {\n+    super(gc);\n   }\n \n   public Frame (String title)\n   {\n-    super (null);\n+    super();\n     setTitle(title);\n   }\n \n-  public String getTitle () { return title; }\n+  public Frame(String title, GraphicsConfiguration gc)\n+  {\n+    super(gc);\n+    setTitle(title);\n+  }\n \n+  public String getTitle()\n+  {\n+    return (title != null) ? title : \"\";\n+  }\n+    \n   public void setTitle (String title)\n   {\n     this.title = title;\n     if (peer != null)\n       ((FramePeer)peer).setTitle(title);\n   }\n \n-  public synchronized void dispose ()\n-  { /* FIXME */ }\n+  public Image getIconImage()\n+  {\n+    return iconImage;\n+  }\n+  \n+  public void setIconImage(Image image)\n+  {\n+    iconImage = image;\n+    if (peer != null)\n+      ((FramePeer) peer).setIconImage(iconImage);\n+  }\n+\n+  protected void finalize() throws Throwable\n+  {\n+    //frames.remove(this);\n+    /* FIXME: This won't work. Finalize will never be called if frames\n+       has a reference to the object. We need weak references to\n+       implement this correctly. */\n+\n+    super.finalize();\n+  }\n \n   public synchronized void setMenuBar (MenuBar menuBar)\n-  { this.menuBar = menuBar; }\n+  { \n+    if (this.menuBar != menuBar)\n+      {\n+\t//this.menuBar.removeNotify();\n+\tthis.menuBar = menuBar;\n+\t//this.menuBar.addNotify();\n+      }\t\n+\n+    if (peer != null)\n+      ((FramePeer) peer).setMenuBar(menuBar);\n+  }\n+  \n+  public boolean isResizable()\n+  {\n+    return isResizable;\n+  }\n+\n+  public void setResizable(boolean resizable)\n+  {\n+    isResizable = resizable;\n+    if (peer != null)\n+      ((FramePeer) peer).setResizable(isResizable);\n+  }\n+\n+  public int getState()\n+  {\n+    /* FIXME: State might have changed in the peer... Must check. */\n+    \n+    return state;\n+  }\n+\n \n   public synchronized void addNotify ()\n   {\n@@ -49,7 +119,32 @@ public synchronized void addNotify ()\n     super.addNotify();\n   }\n \n-  public Font getFont() { return null; } // FIXME\n   public boolean postEvent(Event evt) { return false; } // FIXME\n-  public void remove(MenuComponent comp) { } // FIXME\n+ \n+  public void remove(MenuComponent m)\n+  {\n+    if (m == menuBar)\n+      {\n+\tsetMenuBar(null);\n+\treturn;\n+      }\n+\t\n+    super.remove(m);\n+  }\n+  \n+  public void removeNotify()\n+  {\n+    //if ((peer != null) && (menuBar != null)) menuBar.removeNotify();\n+    super.removeNotify();\n+  }\n+    \n+  public static Frame[] getFrames()\n+  {\n+    //Frame[] array = new Frames[frames.size()];\n+    //return frames.toArray(array);\n+    \n+    // see finalize() comment\n+    String msg = \"FIXME: can't be implemented without weak references\";\n+    throw new UnsupportedOperationException(msg);\n+  }\n }"}, {"sha": "56c732fc2f1cd7e47d0be94087efecfd1c6da673", "filename": "libjava/java/awt/Graphics.java", "status": "modified", "additions": 211, "deletions": 5, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGraphics.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -8,6 +8,8 @@\n \n package java.awt;\n \n+import java.awt.image.ImageObserver;\n+\n /**\n  * @author Warren Levy <warrenl@cygnus.com>\n  * @date March 15, 2000.\n@@ -16,14 +18,218 @@\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n- * Status:  Stubbed; A very incomplete placeholder.\n+ * Status:  Almost complete\n  */\n \n-public abstract class Graphics extends Object\n+public abstract class Graphics\n {\n-  protected Graphics()\n+  protected Graphics() {}\n+  \n+  public abstract Graphics create();\n+\n+  public Graphics create(int x, int y, int width, int height)\n+  {\n+    Graphics gfx = create();\n+    gfx.translate(x, y);\n+    gfx.setClip(0, y, width, height);\n+    return gfx;\n+  }\n+\n+  public abstract void translate(int x, int y);\n+\n+  public abstract Color getColor();\n+\n+  public abstract void setColor(Color color);\n+\n+  public abstract void setPaintMode();\n+\n+  public abstract void setXORMode(Color altColor);\n+\n+  public abstract Font getFont();\n+\n+  public abstract void setFont(Font font);\n+\n+  public FontMetrics getFontMetrics()\n+  {\n+    return getFontMetrics(getFont());\n+  }\n+\n+  public abstract FontMetrics getFontMetrics(Font font);\n+\n+  public abstract Rectangle getClipBounds();\n+\n+  public abstract void clipRect(int x, int y, int width, int height);\n+\n+  public abstract void setClip(int x, int y, int width, int height);\n+\n+  public abstract Shape getClip();\n+\n+  public abstract void setClip(Shape clip);\n+\n+  public abstract void copyArea(int x, int y, int width, int height,\n+\t\t\t\tint dx, int dy);\n+\n+  public abstract void drawLine(int x1, int y1, int x2, int y2);\n+    \n+  public abstract void fillRect(int x, int y, int width, int height);\n+\n+  public void drawRect(int x, int y, int width, int height)\n+  {\n+    int x1 = x;\n+    int y1 = y;\n+    int x2 = x + width;\n+    int y2 = y + height;\n+    drawLine(x1, y1, x2, y1);\n+    drawLine(x2, y1, x2, y2);\n+    drawLine(x2, y2, x1, y2);\n+    drawLine(x1, y2, x1, y1);\n+  }\n+\n+  public abstract void clearRect(int x, int y, int width, int height);\n+  \n+  public abstract void drawRoundRect(int x, int y, int width, int height,\n+\t\t\t\t     int arcWidth, int arcHeight);\n+  \n+  public abstract void fillRoundRect(int x, int y, int width, int height,\n+\t\t\t\t     int arcWidth, int arcHeight);\n+  \n+  public void draw3DRect(int x, int y, int width, int height,\n+\t\t\t boolean raised)\n+  {\n+    Color color = getColor();\n+    Color tl = color.brighter();\n+    Color br = color.darker();\n+    \n+    if (!raised)\n+      {\n+\tColor tmp = tl;\n+\ttl = br;\n+\tbr = tmp;\n+      }\n+    \n+    int x1 = x;\n+    int y1 = y;\n+    int x2 = x + width;\n+    int y2 = y + height;\n+    \n+    setColor(tl);\n+    drawLine(x1, y1, x2, y1);\n+    drawLine(x1, y2, x1, y1);\n+    setColor(br);\n+    drawLine(x2, y1, x2, y2);\n+    drawLine(x2, y1, x1, y2);\n+    setColor(color);\n+  }\n+\n+  public void fill3DRect(int x, int y, int width, int height,\n+\t\t\t boolean raised)\n+  {\n+    fillRect(x, y, width, height);\n+    draw3DRect(x, y, width-1, height-1, raised);\n+  }\n+\n+  public abstract void drawOval(int x, int y, int width, int height);\n+  \n+  public abstract void fillOval(int x, int y, int width, int height);\n+  \n+  public abstract void drawArc(int x, int y, int width, int height,\n+\t\t\t       int startAngle, int arcAngle);\n+  \n+  public abstract void fillArc(int x, int y, int width, int height,\n+\t\t\t       int startAngle, int arcAngle);\n+  \n+  public abstract void drawPolyline(int[] xPoints, int[] yPoints,\n+\t\t\t\t    int nPoints);\n+  \n+  public abstract void drawPolygon(int[] xPoints, int[] yPoints,\n+\t\t\t\t   int nPoints);\n+  \n+  //public void drawPolygon(Polygon p);\n+    \n+  public abstract void fillPolygon(int[] xPoints, int[] yPoints,\n+\t\t\t\t   int nPoints);\n+\n+  //public void fillPolygon(Polygon p);\n+\n+  public abstract void drawString(String str, int x, int y);\n+\n+  /*\n+  public abstract void drawString(AttributedCharacterIterator iterator,\n+\t        \t\t  int x, int y)\n+  */\n+\n+  public void drawChars(char[] data, int offset, int length,\n+\t\t\tint x, int y)\n+  {\n+    String str = new String(data, offset, length);\n+    drawString(str, x, y);\n+  }\n+\n+  public void drawBytes(byte[] data, int offset, int length,\n+\t\t\tint x, int y)\n+  {\n+    String str = new String(data, offset, length);\n+    drawString(str, x, y);\n+  }\n+\n+  public abstract boolean drawImage(Image img, int x, int y,\n+\t\t\t\t    ImageObserver observer);\n+\n+  public abstract boolean drawImage(Image img, int x, int y,\n+\t\t\t\t    int width, int height,\n+\t\t\t\t    ImageObserver observer);\n+\n+  public abstract boolean drawImage(Image img, int x, int y, Color bgcolor,\n+\t\t\t\t    ImageObserver observer);\n+  \n+  public abstract boolean drawImage(Image img, int x, int y,\n+\t\t\t\t    int width, int height, Color bgcolor,\n+\t\t\t\t    ImageObserver observer);\n+\n+  public abstract boolean drawImage(Image img,\n+\t\t\t\t    int dx1, int dy1, int dx2, int dy2,\n+\t\t\t\t    int sx1, int sy1, int sx2, int sy2,\n+\t\t\t\t    ImageObserver observer);\n+\n+  public abstract boolean drawImage(Image img,\n+\t\t\t\t    int dx1, int dy1, int dx2, int dy2,\n+\t\t\t\t    int sx1, int sy1, int sx2, int sy2,\n+\t\t\t\t    Color bgcolor, ImageObserver observer);\n+\n+  public abstract void dispose();\n+  \n+  public void finalize()\n+  {\n+    dispose();\n+  }\n+\n+  public String toString()\n+  {\n+    return super.toString(); // FIXME\n+  }\n+    \n+  /** @deprecated */\n+  public Rectangle getClipRect()\n   {\n-    super();  // ???\n-    throw new Error (\"java.awt.Graphics: not implemented\");\n+    return getClipBounds(null);\n+  }\n+\n+  public boolean hitClip(int x, int y, int width, int height)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public Rectangle getClipBounds(Rectangle r)\n+  {\n+    Rectangle clipBounds = getClipBounds();\n+\n+    if (r == null)\n+      return clipBounds;\n+\n+    r.x      = clipBounds.x;\n+    r.y      = clipBounds.y;\n+    r.width  = clipBounds.width;\n+    r.height = clipBounds.height;\n+    return r;\n   }\n }"}, {"sha": "54133834874b9ca3beb26bdeaeb6b9f39a842ab0", "filename": "libjava/java/awt/Graphics2D.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGraphics2D.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -0,0 +1,133 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt;\n+\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.ImageObserver;\n+\n+//import java.util.Map;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public abstract class Graphics2D extends Graphics\n+{\n+\n+  protected Graphics2D()\n+  {\n+  }\n+  \n+  public void draw3DRect(int x, int y, int width, int height,\n+\t\t\t boolean raised)\n+  {\n+    super.draw3DRect(x, y, width, height, raised);\n+  }\n+  \n+  public void fill3DRect(int x, int y, int width, int height,\n+\t\t\t boolean raised)\n+  {\n+    super.fill3DRect(x, y, width, height, raised);\n+  }\n+\n+  public abstract void draw(Shape shape);\n+\n+  public abstract boolean drawImage(Image image, AffineTransform xform,\n+\t\t\t\t    ImageObserver obs);\n+\n+  /*\n+  public abstract void drawImage(BufferedImage image,\n+\t\t\t\t BufferedImageOp op,\n+\t\t\t\t int x,\n+\t\t\t\t int y);\n+  */\n+\n+  /*\n+  public abstract void drawRenderedImage(RenderedImage image,\n+\t\t\t\t\t AffineTransform xform);\n+  */\n+\n+  /*\n+  public abstract void drawRenderableImage(RenderableImage image,\n+                                           AffineTransform xform);\n+  */\n+\n+  public abstract void drawString(String text, int x, int y);\n+\n+  public abstract void drawString(String text, float x, float y);\n+    \n+  /*\n+  public abstract void drawString(AttributedCharacterIterator iterator,\n+                                  int x, int y);\n+  */\n+\n+  /*\n+  public abstract void drawString(AttributedCharacterIterator iterator,\n+\t\t\t\t  float x, float y);\n+  */\n+\n+  /*\n+  public abstract void drawGlyphVector(GlyphVector g, float x, float y);\n+  */\n+\n+  public abstract void fill(Shape shape);\n+    \n+  public abstract boolean hit(Rectangle rect, Shape text,\n+\t\t\t      boolean onStroke);\n+\n+  public abstract GraphicsConfiguration getDeviceConfiguration();\n+\n+  //public abstract void setComposite(Composite comp);\n+    \n+  public abstract void setPaint(Paint paint);\n+\n+  //public abstract void setStroke(Stroke stroke)\n+\n+  public abstract void setRenderingHint(RenderingHints.Key hintKey,\n+                                        Object hintValue);\n+\n+  public abstract Object getRenderingHint(RenderingHints.Key hintKey);\n+  \n+  //public abstract void setRenderingHints(Map hints);\n+\n+  //public abstract void addRenderingHints(Map hints);\n+\n+  public abstract RenderingHints getRenderingHints();\n+\n+  public abstract void translate(int x, int y);\n+\n+  public abstract void translate(double tx, double ty);\n+    \n+  public abstract void rotate(double theta);\n+\n+  public abstract void rotate(double theta, double x, double y);\n+\n+  public abstract void scale(double scaleX, double scaleY);\n+\n+  public abstract void shear(double shearX, double shearY);\n+\n+  public abstract void transform(AffineTransform Tx);\n+  \n+  public abstract void setTransform(AffineTransform Tx);\n+\n+  public abstract AffineTransform getTransform();\n+\n+  public abstract Paint getPaint();\n+\n+  //public abstract Composite getComposite();\n+\n+  public abstract void setBackground(Color color);\n+\n+  public abstract Color getBackground();\n+\n+  //public abstract Stroke getStroke();    \n+\n+  public abstract void clip(Shape s);\n+\n+  //public abstract FontRenderContext getFontRenderContext()\n+}"}, {"sha": "ca4b56622a6b06eebc39b19b00f5ff34c49f10f3", "filename": "libjava/java/awt/GraphicsConfiguration.java", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FGraphicsConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FGraphicsConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGraphicsConfiguration.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -6,23 +6,29 @@\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n-/* Status: Complete, but commented out until we have the required Java2D\n-   classes. */\n+/* Status: Complete, but commented out until we have the required\n+   GraphicsDevice. */\n \n package java.awt;\n \n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.geom.AffineTransform;\n+\n public abstract class GraphicsConfiguration\n {\n   /*\n   public abstract GraphicsDevice getDevice();\n+  */\n+\n   public abstract BufferedImage createCompatibleImage(int width, int height);\n   public abstract BufferedImage createCompatibleImage(int width, int height,\n                                                       int transparency);\n   public abstract ColorModel getColorModel();\n   public abstract ColorModel getColorModel(int transparency);\n   public abstract AffineTransform getDefaultTransform();\n   public abstract AffineTransform getNormalizingTransform();\n-  */\n+\n   /* @since 1.3 */\n   public abstract Rectangle getBounds();\n }"}, {"sha": "488109b73a9f4ab0b3bc1673b515ca1bb33de1a6", "filename": "libjava/java/awt/Image.java", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FImage.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -8,6 +8,9 @@\n \n package java.awt;\n \n+import java.awt.image.ImageObserver;\n+import java.awt.image.ImageProducer;\n+\n /**\n  * @author Warren Levy <warrenl@cygnus.com>\n  * @date March 15, 2000.\n@@ -16,14 +19,33 @@\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n- * Status:  Stubbed; A very incomplete placeholder.\n+ * Status:  Mostly complete, but look for FIXMEs.\n  */\n \n public abstract class Image extends Object\n {\n-  public Image()\n+  public static final Object UndefinedProperty;\n+\n+  public static final int SCALE_DEFAULT        = 1<<0,\n+                          SCALE_FAST           = 1<<1,\n+                          SCALE_SMOOTH         = 1<<2,\n+                          SCALE_REPLICATE      = 1<<3,\n+                          SCALE_AREA_AVERAGING = 1<<4;\n+\n+  public abstract int getWidth(ImageObserver observer);\n+\n+  public abstract int getHeight(ImageObserver observer);\n+\n+  public abstract ImageProducer getSource();\n+  \n+  public abstract Graphics getGraphics();\n+\n+  public abstract Object getProperty(String name, ImageObserver observer);\n+\n+  public Image getScaledInstance(int width, int height, int hints)\n   {\n-    super();  // ???\n-    throw new Error(\"java.awt.Image: not implemented\");\n+    throw new UnsupportedOperationException(\"FIXME: not implemented yet\");\n   }\n+\n+  public abstract void flush();\n }"}, {"sha": "a6e4f3e39f260e2a24b0328dce69845717f38391", "filename": "libjava/java/awt/Panel.java", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPanel.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -8,15 +8,20 @@\n \n package java.awt;\n \n+import java.awt.peer.ComponentPeer;\n+\n /* An incomplete placeholder. */\n \n public class Panel extends Container\n {\n   public Panel()\n-  {\n-    super();\n+  { \n+    this(\n+\t // should be: new FlowLayout()\n+\t null // FIXME\n+\t );\n   }\n-  \n+\n   public Panel(LayoutManager layout)\n   {\n     super();\n@@ -27,6 +32,8 @@ public Panel(LayoutManager layout)\n \n   public void addNotify()\n   {\n-    // FIXME\n+    if (getPeer() == null)\n+      peer = (ComponentPeer) getToolkit().createPanel(this);\n+    super.addNotify();\n   }\n }"}, {"sha": "6695c580b1f278dd0596c23c03762e6d0511f4ec", "filename": "libjava/java/awt/Rectangle.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FRectangle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FRectangle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FRectangle.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -220,7 +220,7 @@ public boolean intersects(Rectangle r)\n \n   public boolean isEmpty()\n   {\n-    return (width > 0 && height > 0);\n+    return !(width > 0 && height > 0);\n   }\n \n   /** @deprecated Use setLocation() instead. */"}, {"sha": "2994a8bba76b129fa7dc8e05677aa47a09143c43", "filename": "libjava/java/awt/RenderingHints.java", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FRenderingHints.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FRenderingHints.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FRenderingHints.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -0,0 +1,299 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt;\n+\n+/**\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class RenderingHints implements\n+    //java.util.Map,\n+    Cloneable\n+{\n+\n+  static abstract class Key\n+  {\n+    private int intKey;\n+\n+    protected Key(int privateKey)\n+    {\n+      intKey = privateKey;\n+    }\n+\n+    public abstract boolean isCompatibleValue(Object value);\n+    \n+    protected final int intKey() \n+    {\n+      return intKey;\n+    }    \n+\n+    public final int hashCode() \n+    {\n+      return System.identityHashCode(this);\n+    }\n+    \n+    public final boolean equals(Object other) \n+    {\n+      return (this == other);\n+    }\n+  }\n+\n+  private static class KeyImpl extends Key\n+  {\n+    String description;\n+    Object v1, v2, v3;\n+\n+    KeyImpl(int privateKey, String description,\n+\t    Object v1, Object v2, Object v3)\n+    {\n+      super(privateKey);\n+      this.description = description;\n+      this.v1 = v1;\n+      this.v2 = v2;\n+      this.v3 = v3;\n+    }\n+    \n+    public boolean isCompatibleValue(Object value) \n+    {\n+      return (value == v1) || (value == v2) || (value == v3);\n+    }\n+\n+    public String toString() \n+    {\n+      return description;\n+    }\n+  }\n+\n+\n+  //java.util.HashMap hintMap;\n+\n+  public static final Key KEY_ANTIALIASING;\n+  public static final Object\n+    VALUE_ANTIALIAS_ON = \"Antialiased rendering mode\",\n+    VALUE_ANTIALIAS_DEFAULT = \"Default antialiasing rendering mode\";\n+\n+  static \n+  {\n+    KEY_ANTIALIASING = new KeyImpl(1, \"Global antialiasing enable key\",\n+\t\t\t\t   VALUE_ANTIALIAS_ON,\n+\t\t\t\t   VALUE_ANTIALIAS_DEFAULT,\n+\t\t\t\t   VALUE_ANTIALIAS_DEFAULT);\n+  }\n+\n+  public static final Key KEY_RENDERING;\n+  public static final Object \n+    VALUE_RENDER_SPEED = \"Fastest rendering methods\",\n+    VALUE_RENDER_QUALITY = \"Highest quality rendering methods\",\n+    VALUE_RENDER_DEFAULT = \"Default rendering methods\";\n+\n+  static\n+  {\n+    KEY_RENDERING = new KeyImpl(2, \"Global rendering quality key\",\n+\t\t\t\tVALUE_RENDER_SPEED,\n+\t\t\t\tVALUE_RENDER_QUALITY,\n+\t\t\t\tVALUE_RENDER_DEFAULT);\n+  }\n+  \n+  public static final Key KEY_DITHERING;\n+  public static final Object\n+    VALUE_DITHER_DISABLE = \"Nondithered rendering mode\",\n+    VALUE_DITHER_ENABLE = \"Dithered rendering mode\",\n+    VALUE_DITHER_DEFAULT = \"Default dithering mode\";\n+\n+  static\n+  {\n+    KEY_DITHERING = new KeyImpl(3, \"Dithering quality key\",\n+\t\t\t\tVALUE_DITHER_DISABLE,\n+\t\t\t\tVALUE_DITHER_ENABLE,\n+\t\t\t\tVALUE_DITHER_DEFAULT);\n+  }\n+  \n+  public static final Key KEY_TEXT_ANTIALIASING;\n+  public static final Object\n+    VALUE_TEXT_ANTIALIAS_ON = \"Antialiased text mode\",\n+    VALUE_TEXT_ANTIALIAS_OFF = \"Nonantialiased text mode\",\n+    VALUE_TEXT_ANTIALIAS_DEFAULT = \"Default antialiasing text mode\";\n+\n+  static \n+  {\n+    KEY_TEXT_ANTIALIASING = new KeyImpl(4, \"Text-specific antialiasing enable key\",\n+\t\t\t\t\tVALUE_TEXT_ANTIALIAS_ON,\n+\t\t\t\t\tVALUE_TEXT_ANTIALIAS_OFF,\n+\t\t\t\t\tVALUE_TEXT_ANTIALIAS_DEFAULT);\n+  }\n+  \n+  public static final Key KEY_FRACTIONALMETRICS;\n+  public static final Object\n+    VALUE_FRACTIONALMETRICS_OFF = \"Integer text metrics mode\",\n+    VALUE_FRACTIONALMETRICS_ON = \"Fractional text metrics mode\",\n+    VALUE_FRACTIONALMETRICS_DEFAULT = \"Default fractional text metrics mode\";\n+\n+  static \n+  {\n+    KEY_FRACTIONALMETRICS = new KeyImpl(5, \"Fractional metrics enable key\",\n+\t\t\t\t\tVALUE_FRACTIONALMETRICS_OFF,\n+\t\t\t\t\tVALUE_FRACTIONALMETRICS_ON,\n+\t\t\t\t\tVALUE_FRACTIONALMETRICS_DEFAULT);\n+  }\n+  \n+  public static final Key KEY_INTERPOLATION;\n+  public static final Object\n+    VALUE_INTERPOLATION_NEAREST_NEIGHBOR = \"Nearest Neighbor image interpolation mode\",\n+    VALUE_INTERPOLATION_BILINEAR = \"Bilinear image interpolation mode\",\n+    VALUE_INTERPOLATION_BICUBIC = \"Bicubic image interpolation mode\";\n+\n+  static \n+  {\n+    KEY_INTERPOLATION = new KeyImpl(6, \"Image interpolation method key\",\n+\t\t\t\t    VALUE_INTERPOLATION_NEAREST_NEIGHBOR,\n+\t\t\t\t    VALUE_INTERPOLATION_BILINEAR,\n+\t\t\t\t    VALUE_INTERPOLATION_BICUBIC);\n+  }\n+  \n+  public static final Key KEY_ALPHA_INTERPOLATION;\n+  public static final Object\n+    VALUE_ALPHA_INTERPOLATION_SPEED = \"Fastest alpha blending methods\",\n+    VALUE_ALPHA_INTERPOLATION_QUALITY = \"Highest quality alpha blending methods\",\n+    VALUE_ALPHA_INTERPOLATION_DEFAULT = \"Default alpha blending methods\";\n+\n+  static\n+  {\n+    KEY_ALPHA_INTERPOLATION = new KeyImpl(7, \"Alpha blending interpolation method key\",\n+\t\t\t\t\t  VALUE_ALPHA_INTERPOLATION_SPEED,\n+\t\t\t\t\t  VALUE_ALPHA_INTERPOLATION_QUALITY,\n+\t\t\t\t\t  VALUE_ALPHA_INTERPOLATION_DEFAULT);\n+  }\n+  \n+  public static final Key KEY_COLOR_RENDERING;\n+  public static final Object\n+    VALUE_COLOR_RENDER_SPEED = \"Fastest color rendering mode\",\n+    VALUE_COLOR_RENDER_QUALITY = \"Highest quality color rendering mode\",\n+    VALUE_COLOR_RENDER_DEFAULT = \"Default color rendering mode\";\n+\n+  static \n+  {\n+    KEY_COLOR_RENDERING = new KeyImpl(8, \"Color rendering quality key\",\n+\t\t\t\t      VALUE_COLOR_RENDER_SPEED,\n+\t\t\t\t      VALUE_COLOR_RENDER_QUALITY,\n+\t\t\t\t      VALUE_COLOR_RENDER_DEFAULT);\n+  }\n+\n+  public static final Key KEY_STROKE_CONTROL;\n+  public static final Object\n+    VALUE_STROKE_DEFAULT = \"Default stroke control mode\",\n+    VALUE_STROKE_NORMALIZE = \"Normalize stroke control mode\",\n+    VALUE_STROKE_PURE = \"Pure stroke control mode\";\n+\n+  static \n+  {\n+    KEY_STROKE_CONTROL = new KeyImpl(9, \"Stroke normalization control key\",\n+\t\t\t\t     VALUE_STROKE_DEFAULT,\n+\t\t\t\t     VALUE_STROKE_NORMALIZE,\n+\t\t\t\t     VALUE_STROKE_PURE);\n+  }\n+  \n+  //public RenderingHints(Map init);\n+\n+  public RenderingHints(Key key, Object value)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+\n+  public int size() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public boolean isEmpty() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+\n+  public boolean containsKey(Object key) \n+  {      \n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public boolean containsValue(Object value) \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public Object get(Object key)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public Object put(Object key, Object value) \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public void add(RenderingHints hints) \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+\n+  public void clear() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public Object remove(Object key) \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  /*\n+  public void putAll(Map m) \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  */\n+  \n+  /*\n+  public Set keySet() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  */\n+  \n+  /*\n+  public Collection values() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  */\n+  \n+  /*\n+  public Set entrySet() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  */\n+  \n+  public boolean equals(Object o) \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public int hashCode() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public Object clone() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+  \n+  public String toString() \n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented yet\");\n+  }\n+}"}, {"sha": "9675e20975c8eedf7a73e9c5089b252763437391", "filename": "libjava/java/awt/Toolkit.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FToolkit.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -14,6 +14,7 @@\n import java.awt.image.*;\n import java.awt.datatransfer.Clipboard;\n import java.util.Hashtable;\n+import gnu.gcj.awt.GLightweightPeer;\n \n /* A very incomplete placeholder. */\n \n@@ -28,7 +29,7 @@ public static Toolkit getDefaultToolkit()\n   {\n     if (defaultToolkit != null)\n       return defaultToolkit;\n-      \n+    \n     Class toolkit_class;\n     String tk_class_name = System.getProperty(\"awt.toolkit\");\n     if (tk_class_name == null)\n@@ -72,8 +73,7 @@ public static Toolkit getDefaultToolkit()\n \n   protected LightweightPeer createComponent(Component target)\n   {\n-    // FIXME\n-    return null;\n+    return GLightweightPeer.INSTANCE;\n   }\n   \n   /* @deprecated Use GraphicsEnvironment.getAllFonts() */\n@@ -191,7 +191,7 @@ public static String getProperty(String key, String defaultValue)\n \n   public final EventQueue getSystemEventQueue()\n   {\n-      return systemEventQueue;\n+      return getSystemEventQueueImpl();\n   }\n \n   protected abstract EventQueue getSystemEventQueueImpl();"}, {"sha": "928c255e76142b8b63a1f94e925f80af8f2f681e", "filename": "libjava/java/awt/Window.java", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FWindow.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -28,20 +28,47 @@ public class Window extends Container\n   private transient WindowListener windowListener;\n   private transient GraphicsConfiguration graphicsConfiguration;\n \n+  /** \n+   * This (package access) constructor is used by subclasses that want\n+   * to build windows that do not have parents.  Eg. toplevel\n+   * application frames.  Subclasses cannot call super(null), since\n+   * null is an illegal argument.\n+   */\n+  Window()\n+  {\n+    setVisible(false);\n+    setLayout((LayoutManager) new BorderLayout());\n+  }\n+\n+  Window(GraphicsConfiguration gc)\n+  {\n+    this();\n+    graphicsConfiguration = gc;\n+  }\n+    \n   public Window(Frame owner)\n   {\n-    this (owner, null);\n+    this((Window) owner);\n   }\n \n   /** @since 1.2 */\n   public Window(Window owner)\n   {\n-    this (owner, null);\n+    this();\n+    if (owner == null)\n+      throw new IllegalArgumentException(\"owner must not be null\");\n+    \n+    this.parent = owner;\n+\n+    // FIXME: add to owner's \"owned window\" list\n+    //owner.owned.add(this); // this should be a weak reference\n   }\n   \n   /** @since 1.3 */\n   public Window(Window owner, GraphicsConfiguration gc)\n   {\n+    this(owner);\n+\n     /*  FIXME: Security check\n     SecurityManager.checkTopLevelWindow(...)\n \n@@ -55,29 +82,29 @@ public Window(Window owner, GraphicsConfiguration gc)\n \t\t\t     .getDefaultConfiguration();\n     else\n     */    \n-      graphicsConfiguration = gc;\n+    graphicsConfiguration = gc;\n+  }\n \n-    // FIXME: compiler bug\n-    // this.layoutMgr = new BorderLayout ();\n-    \n-    if (owner == null)\n-      throw new IllegalArgumentException (\"Owner can not be null\");\n-          \n-    this.parent = owner;\n-    \n-    // FIXME: add to owner's \"owned window\" list\n+  GraphicsConfiguration getGraphicsConfigurationImpl()\n+  {\n+    if (graphicsConfiguration != null)\n+\treturn graphicsConfiguration;\n+\n+    return super.getGraphicsConfigurationImpl();\n   }\n \n   protected void finalize() throws Throwable\n   {\n     // FIXME: remove from owner's \"owned window\" list (Weak References)\n+    super.finalize();\n   }\n \n   public void addNotify()\n   {\n     if (peer == null)\n       // FIXME: This cast should NOT be required. ??? Compiler bug ???\n       peer = (ComponentPeer) getToolkit ().createWindow (this);\n+    super.addNotify ();\n   }\n \n   /** @specnote pack() doesn't appear to be called internally by show(), so\n@@ -87,16 +114,20 @@ public void pack()\n     if (parent != null\n         && !parent.isDisplayable())\n       parent.addNotify();\n-        if (peer == null)\n+    if (peer == null)\n       addNotify();\n-    \n-    // FIXME: do layout stuff here\n+\n+    setSize(getPreferredSize());\n     \n     validate();\n   }\n \n   public void show ()\n   {\n+    if (peer == null)\n+      addNotify();\n+    validate ();\n+\n     if (isVisible())\n       {\n \tthis.toFront();\n@@ -126,7 +157,12 @@ public void hide()\n \n   public void dispose()\n   {\n-    // FIXME: first call removeNotify() on owned children\n+    hide();\n+\n+    Window[] list = getOwnedWindows();\n+    for (int i=0; i<list.length; i++)\n+      list[i].dispose();\n+\n     for (int i = 0; i < ncomponents; ++i)\n       component[i].removeNotify();\n     this.removeNotify();\n@@ -195,10 +231,7 @@ public void setCursor(Cursor cursor)\n \n   public Window getOwner()\n   {\n-    if (parent != null)\n-      return (Window) parent;\n-    else \n-      return null;\n+    return (Window) parent;\n   }\n \n   /** @since 1.2 */\n@@ -317,8 +350,16 @@ public AccessibleContext getAccessibleContext()\n   }\n   */\n \n+  /** \n+   * Get graphics configuration.  The implementation for Window will\n+   * not ask any parent containers, since Window is a toplevel\n+   * window and not actually embedded in the parent component.\n+   */\n   public GraphicsConfiguration getGraphicsConfiguration()\n   {\n-    return graphicsConfiguration;\n+    if (graphicsConfiguration != null) return graphicsConfiguration;\n+    if (peer != null) return peer.getGraphicsConfiguration();\n+    return null;\n   }\n+\n }"}, {"sha": "891b6bd4e515ea899a69b2efb9c8d981fbee78ea", "filename": "libjava/java/awt/event/ActionEvent.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fevent%2FActionEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fevent%2FActionEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fevent%2FActionEvent.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -37,7 +37,7 @@ public ActionEvent (Object source, int id, String command, int modifiers)\n     this.modifiers = modifiers;\n   }\n \n-  public String getcmd ()\n+  public String getActionCommand ()\n   {\n     return cmd;\n   }"}, {"sha": "fce3d1fd916d4b83d3848ad7c8fc12e004cd81a1", "filename": "libjava/java/awt/image/BufferedImage.java", "status": "added", "additions": 543, "deletions": 0, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -0,0 +1,543 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.*;\n+import java.awt.color.*;\n+import java.util.*;\n+\n+import gnu.gcj.awt.ComponentDataBlitOp;\n+\n+/**\n+ * A buffered image always starts at coordinates (0, 0).\n+ *\n+ * The buffered image is not subdivided into multiple tiles. Instead,\n+ * the image consists of one large tile (0,0) with the width and\n+ * height of the image. This tile is always considered to be checked\n+ * out.\n+ * \n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class BufferedImage extends java.awt.Image\n+    //implements java.awt.image.WritableRenderedImage\n+{\n+  public static final int TYPE_CUSTOM         =  0,\n+                          TYPE_INT_RGB        =  1,\n+                          TYPE_INT_ARGB       =  2,\n+                          TYPE_INT_ARGB_PRE   =  3,\n+                          TYPE_INT_BGR        =  4,\n+                          TYPE_3BYTE_BGR      =  5,\n+                          TYPE_4BYTE_ABGR     =  6,\n+                          TYPE_4BYTE_ABGR_PRE =  7,\n+                          TYPE_USHORT_565_RGB =  8,\n+                          TYPE_USHORT_555_RGB =  9,\n+                          TYPE_BYTE_GRAY      = 10,\n+                          TYPE_USHORT_GRAY    = 11,\n+                          TYPE_BYTE_BINARY    = 12,\n+                          TYPE_BYTE_INDEXED   = 13;\n+  \n+  final static int[] bits3 = { 8, 8, 8 };\n+  final static int[] bits4 = { 8, 8, 8 };\n+  final static int[] bits1byte = { 8 };\n+  final static int[] bits1ushort = { 16 };\n+  \n+  final static int[] masks_int = { 0x00ff0000,\n+\t\t\t\t   0x0000ff00,\n+\t\t\t\t   0x000000ff,\n+\t\t\t\t   DataBuffer.TYPE_INT };\n+  final static int[] masks_565 = { 0xf800,\n+\t\t\t\t   0x07e0,\n+\t\t\t\t   0x001f,\n+\t\t\t\t   DataBuffer.TYPE_USHORT};\n+  final static int[] masks_555 = { 0x7c00,\n+\t\t\t\t   0x03e0,\n+\t\t\t\t   0x001f,\n+\t\t\t\t   DataBuffer.TYPE_USHORT};\n+  \n+  public BufferedImage(int w, int h, int type)\n+  {\n+    ColorModel cm;\n+    \n+    boolean alpha = false;\n+    boolean premultiplied = false;\n+    switch (type)\n+      {\n+      case TYPE_4BYTE_ABGR_PRE:\n+      case TYPE_INT_ARGB_PRE:\n+\tpremultiplied = true;\n+\t// fall through\n+      case TYPE_INT_ARGB:\n+      case TYPE_4BYTE_ABGR:\n+\talpha = true;\n+      }\n+\t\n+    ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+    switch (type)\n+      {\n+      case TYPE_INT_RGB:\n+      case TYPE_INT_ARGB:\n+      case TYPE_INT_ARGB_PRE:\n+      case TYPE_USHORT_565_RGB:\n+      case TYPE_USHORT_555_RGB:\n+\tint[] masks;\n+\tswitch (type)\n+\t  {\n+\t  case TYPE_INT_RGB:\n+\t  case TYPE_INT_ARGB:\n+\t  case TYPE_INT_ARGB_PRE:\n+\t    masks = masks_int;\n+\t    break;\n+\t  case TYPE_USHORT_565_RGB:\n+\t    masks = masks_565;\n+\t    break;\n+\t  case TYPE_USHORT_555_RGB:\n+\t    masks = masks_555;\n+\t    break;\n+\t  }\n+\t\n+\tcm = new DirectColorModel(cs,\n+\t\t\t\t  32, // 32 bits in an int\n+\t\t\t\t  masks[0], // r\n+\t\t\t\t  masks[1], // g\n+\t\t\t\t  masks[2], // b\n+\t\t\t\t  alpha ? 0xff000000 : 0,\n+\t\t\t\t  premultiplied,\n+\t\t\t\t  masks[3] // data type\n+\t\t\t\t  );\n+\tbreak;\n+\t\n+      case TYPE_INT_BGR:\n+\tString msg =\n+\t  \"FIXME: Programmer is confused. Why (and how) does a \" +\n+\t  \"TYPE_INT_BGR image use ComponentColorModel to store \" +\n+\t  \"8-bit values? Is data type TYPE_INT or TYPE_BYTE. What \" +\n+\t  \"is the difference between TYPE_INT_BGR and TYPE_3BYTE_BGR?\";\n+\tthrow new UnsupportedOperationException(msg);\n+\t\n+      case TYPE_3BYTE_BGR:\n+      case TYPE_4BYTE_ABGR:\n+      case TYPE_4BYTE_ABGR_PRE:\n+      case TYPE_BYTE_GRAY:\n+      case TYPE_USHORT_GRAY:\n+\tint[] bits = null;\n+\tint dataType = DataBuffer.TYPE_BYTE;\n+\tswitch (type) {\n+\tcase TYPE_3BYTE_BGR:\n+\t  bits = bits3;\n+\t  break;\n+\tcase TYPE_4BYTE_ABGR:\n+\tcase TYPE_4BYTE_ABGR_PRE:\n+\t  bits = bits4;\n+\t  break;\n+\tcase TYPE_BYTE_GRAY:\n+\t  bits = bits1byte;\n+\t  break;\n+\tcase TYPE_USHORT_GRAY:\n+\t  bits = bits1ushort;\n+\t  dataType = DataBuffer.TYPE_USHORT;\n+\t  break;\n+\t}\n+\tcm = new ComponentColorModel(cs, bits, alpha, premultiplied,\n+\t\t\t\t     alpha ?\n+\t\t\t\t     Transparency.TRANSLUCENT:\n+\t\t\t\t     Transparency.OPAQUE,\n+\t\t\t\t     dataType);\n+\tbreak;\n+      case TYPE_BYTE_BINARY:\n+\tbyte[] vals = { 0, (byte) 0xff };\n+\tcm = new IndexColorModel(8, 2, vals, vals, vals);\n+\tbreak;\n+      case TYPE_BYTE_INDEXED:\n+\tString msg2 = \"type not implemented yet\";\n+\tthrow new UnsupportedOperationException(msg2);\n+\t// FIXME: build color-cube and create color model\n+      }\n+    \n+    init(cm,\n+\t cm.createCompatibleWritableRaster(w, h),\n+\t premultiplied,\n+\t null, // no properties\n+\t type\n+\t );\n+  }\n+\n+  public BufferedImage(int w, int h, int type,\n+\t\t       IndexColorModel indexcolormodel)\n+  {\n+    if ((type != TYPE_BYTE_BINARY) && (type != TYPE_BYTE_INDEXED))\n+      throw new IllegalArgumentException(\"type must be binary or indexed\");\n+\n+    init(indexcolormodel,\n+\t indexcolormodel.createCompatibleWritableRaster(w, h),\n+\t false, // not premultiplied (guess)\n+\t null, // no properties\n+\t type);\n+  }\n+\n+  public BufferedImage(ColorModel colormodel, \n+\t\t       WritableRaster writableraster,\n+\t\t       boolean premultiplied,\n+\t\t       Hashtable properties)\n+  {\n+    init(colormodel, writableraster, premultiplied, properties,\n+\t TYPE_CUSTOM);\n+    // TODO: perhaps try to identify type?\n+  }\n+ \n+  WritableRaster raster;\n+  ColorModel colorModel;\n+  Hashtable properties;\n+  boolean isPremultiplied;\n+  int type;\n+  \n+  private void init(ColorModel cm,\n+\t\t    WritableRaster writableraster,\n+\t\t    boolean premultiplied,\n+\t\t    Hashtable properties,\n+\t\t    int type)\n+  {\n+    raster = writableraster;\n+    colorModel = cm;\n+    this.properties = properties;\n+    isPremultiplied = premultiplied;\n+    this.type = type;\n+  }\n+    \n+  //public void addTileObserver(TileObserver tileobserver) {}\n+  \n+  public void coerceData(boolean premultiplied)\n+  {\n+    colorModel = colorModel.coerceData(raster, premultiplied);\n+  }\n+\n+  public WritableRaster copyData(WritableRaster dest)\n+  {\n+    if (dest == null)\n+      dest = raster.createCompatibleWritableRaster();\n+\n+    int x = dest.getMinX();\n+    int y = dest.getMinY();\n+    int w = dest.getWidth();\n+    int h = dest.getHeight();\n+    \n+    // create a src child that has the right bounds...\n+    WritableRaster src =\n+      raster.createWritableChild(x, y, w, h, x, y,\n+\t\t\t\t null  // same bands\n+\t\t\t\t );\n+    \n+    // Refer to ComponentDataBlitOp for optimized data blitting:\n+    ComponentDataBlitOp.INSTANCE.filter(src, dest);\n+    return dest;\n+  }\n+\n+  public Graphics2D createGraphics()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+    // will require a lot of effort to implement\n+  }\n+\n+  public void flush() {\n+  }\n+  \n+  public WritableRaster getAlphaRaster()\n+  {\n+    return colorModel.getAlphaRaster(raster);\n+  }\n+  \n+  public ColorModel getColorModel()\n+  {\n+    return colorModel;\n+  }\n+  \n+  public Raster getData()\n+  {\n+    return copyData(null);\n+    /* TODO: this might be optimized by returning the same\n+       raster (not writable) as long as image data doesn't change. */\n+  }\n+\n+  public Raster getData(Rectangle rectangle)\n+  {\n+    WritableRaster dest =\n+      raster.createCompatibleWritableRaster(rectangle);\n+    return copyData(dest);\n+  }\n+  \n+  public Graphics getGraphics()\n+  {\n+    return createGraphics();\n+  }\n+\n+  public int getHeight()\n+  {\n+    return raster.getHeight();\n+  }\n+  \n+  public int getHeight(ImageObserver imageobserver)\n+  {\n+    return getHeight();\n+  }\n+    \n+  public int getMinTileX()\n+  {\n+    return 0;\n+  }\n+  \n+  public int getMinTileY()\n+  {\n+    return 0;\n+  }\n+\n+  public int getMinX()\n+  {\n+    return 0; \n+  }\n+\n+  public int getMinY() \n+  {\n+    return 0;\n+  }\n+  \n+  public int getNumXTiles()\n+  {\n+    return 1;\n+  }\n+\n+  public int getNumYTiles()\n+  {\n+\treturn 1;\n+  }\n+\n+  public Object getProperty(String string)\n+  {\n+    if (properties == null)\n+      return null;\n+    return properties.get(string);\n+  }\n+\n+  public Object getProperty(String string, ImageObserver imageobserver)\n+  {\n+    return getProperty(string);\n+  }\n+\n+  \n+  public String[] getPropertyNames()\n+  {\n+    // FIXME: implement\n+    return null;\n+  }\n+\n+  public int getRGB(int x, int y)\n+  {\n+    Object rgbElem = raster.getDataElements(x, y,\n+\t\t\t\t\t    null // create as needed\n+\t\t\t\t\t    );\n+    return colorModel.getRGB(rgbElem);\n+  }\n+    \n+  public int[] getRGB(int startX, int startY, int w, int h,\n+\t\t      int[] rgbArray,\n+\t\t      int offset, int scanlineStride)\n+  {\n+    if (rgbArray == null)\n+    {\n+      /*\n+\t000000000000000000\n+\t00000[#######-----   [ = start\n+\t-----########-----   ] = end\n+\t-----#######]00000\n+\t000000000000000000  */\n+      int size = (h-1)*scanlineStride + w;\n+      rgbArray = new int[size];\n+    }\n+\t\n+    int endX = startX + w;\n+    int endY = startY + h;\n+    \n+    /* *TODO*:\n+       Opportunity for optimization by examining color models...\n+       \n+       Perhaps wrap the rgbArray up in a WritableRaster with packed\n+       sRGB color model and perform optimized rendering into the\n+       array. */\n+\n+    Object rgbElem = null;\n+    for (int y=startY; y<endY; y++)\n+      {\n+\tint xoffset = offset;\n+\tfor (int x=startX; x<endX; x++)\n+\t  {\n+\t    int rgb;\n+\t    rgbElem = raster.getDataElements(x, y, rgbElem);\n+\t    rgb = colorModel.getRGB(rgbElem);\n+\t    rgbArray[xoffset++] = rgb;\n+\t  }\n+\toffset += scanlineStride;\n+      }\n+    return rgbArray;\n+  }\n+\n+  public WritableRaster getRaster()\n+  {\n+    return raster;\n+  }\n+  \n+  public SampleModel getSampleModel()\n+  {\n+    return raster.getSampleModel();\n+  }\n+    \n+  public ImageProducer getSource()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+  \n+  public Vector getSources()\n+  {\n+    return null;\n+  }\n+  \n+  public BufferedImage getSubimage(int x, int y, int w, int h)\n+  {\n+    WritableRaster subRaster = \n+      getRaster().createWritableChild(x, y, w, h, 0, 0, null);\n+    \n+    return new BufferedImage(getColorModel(),\n+\t\t\t     subRaster,\n+\t\t\t     isPremultiplied,\n+\t\t\t     properties);\n+  }\n+\n+  public Raster getTile(int tileX, int tileY)\n+  {\n+    return getWritableTile(tileX, tileY);\n+  }\n+    \n+  public int getTileGridXOffset()\n+  {\n+    return 0; // according to javadocs\n+  }\n+\n+  public int getTileGridYOffset()\n+  {\n+    return 0; // according to javadocs\n+  }\n+\n+  public int getTileHeight()\n+  {\n+    return getHeight(); // image is one big tile\n+  }\n+\n+  public int getTileWidth()\n+  {\n+    return getWidth(); // image is one big tile\n+  }\n+\n+  public int getType()\n+  {\n+    return type;\n+  }\n+\n+  public int getWidth()\n+  {\n+    return raster.getWidth();\n+  }\n+\n+  public int getWidth(ImageObserver imageobserver)\n+  {\n+    return getWidth();\n+  }\n+\n+  public WritableRaster getWritableTile(int tileX, int tileY)\n+  {\n+    isTileWritable(tileX, tileY);  // for exception\n+    return raster;\n+  }\n+\n+  private static final Point[] tileIndices = { new Point() };\n+    \n+  public Point[] getWritableTileIndices()\n+  {\n+    return tileIndices;\n+  }\n+\n+  public boolean hasTileWriters()\n+  {\n+    return true;\n+  }\n+  \n+  public boolean isAlphaPremultiplied()\n+  {\n+    return isPremultiplied;\n+  }\n+\n+  public boolean isTileWritable(int tileX, int tileY)\n+  {\n+    if ((tileX != 0) || (tileY != 0))\n+      throw new ArrayIndexOutOfBoundsException(\"only tile is (0,0)\");\n+    return true;\n+  }\n+\n+  public void releaseWritableTile(int tileX, int tileY)\n+  {\n+    isTileWritable(tileX, tileY);  // for exception\n+  }\n+\n+  //public void removeTileObserver(TileObserver tileobserver) {}\n+\n+  public void setData(Raster src)\n+  {\n+    int x = src.getMinX();\n+    int y = src.getMinY();\n+    int w = src.getWidth();\n+    int h = src.getHeight();\n+    \n+    // create a dest child that has the right bounds...\n+    WritableRaster dest =\n+      raster.createWritableChild(x, y, w, h, x, y,\n+\t\t\t\t null  // same bands\n+\t\t\t\t );\n+    \n+    // Refer to ComponentDataBlitOp for optimized data blitting:\n+    ComponentDataBlitOp.INSTANCE.filter(src, dest);\n+  }\n+\n+  public void setRGB(int x, int y, int argb)\n+  {\n+    Object rgbElem = colorModel.getDataElements(argb, null);\n+    raster.setDataElements(x, y, rgbElem);\n+  }\n+  \n+  public void setRGB(int startX, int startY, int w, int h,\n+\t\t     int[] argbArray, int offset, int scanlineStride)\n+  {\n+    int endX = startX + w;\n+    int endY = startY + h;\n+    \n+    Object rgbElem = null;\n+    for (int y=startY; y<endY; y++)\n+      {\n+\tint xoffset = offset;\n+\tfor (int x=startX; x<endX; x++)\n+\t  {\n+\t    int argb = argbArray[xoffset++];\n+\t    rgbElem = colorModel.getDataElements(argb, rgbElem);\n+\t    raster.setDataElements(x, y, rgbElem);\n+\t  }\n+\toffset += scanlineStride;    \n+      }\n+  }\n+    \n+  public String toString()\n+  {\n+    // FIXME: implement:\n+    return super.toString();\n+  }\n+}"}, {"sha": "7fd3565492eadfc1fa60c1fa18e71d5199f0a360", "filename": "libjava/java/awt/image/RasterOp.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fimage%2FRasterOp.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fimage%2FRasterOp.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FRasterOp.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -0,0 +1,27 @@\n+/* Copyright \ufffd 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.awt.image;\n+\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.RenderingHints;\n+\n+public interface RasterOp {\n+\n+  WritableRaster filter(Raster src, WritableRaster dest);\n+\n+  Rectangle2D getBounds2D(Raster src);\n+\n+  WritableRaster createCompatibleDestRaster(Raster src);\n+\n+  Point2D getPoint2D(Point2D srcPoint, Point2D destPoint);\n+\n+  public RenderingHints getRenderingHints();\n+}\n+"}, {"sha": "12e4749fbaf90b093b4cd7191a728016069d9f75", "filename": "libjava/java/awt/peer/ComponentPeer.java", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e6d799a6db0549568c5dd668a226194486c02/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java?ref=777e6d799a6db0549568c5dd668a226194486c02", "patch": "@@ -19,7 +19,13 @@\n   void disable();\n   void dispose();\n   void enable();\n-  ColorModel getColorModel();\n+\n+  /** \n+   * Get the graphics configuration of the component. The color model\n+   * of the component can be derived from the configuration.\n+   */\n+  GraphicsConfiguration getGraphicsConfiguration();\n+\n   FontMetrics getFontMetrics(Font f);\n   Graphics getGraphics();\n   Point getLocationOnScreen();\n@@ -41,6 +47,7 @@\n   void setBounds(int x, int y, int width, int height);\n   void setCursor(Cursor cursor);\n   void setEnabled(boolean enabled);\n+  void setEventMask(long eventMask);\n   void setFont(Font font);\n   void setForeground(Color color);\n   void setVisible(boolean visible);"}]}