{"sha": "d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "node_id": "C_kwDOANBUbNoAKGQ3MzBhYThhOWZmMjZhMzZjM2I0ODA0MDJjMTUwN2YzZDJlNDhkYjk", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T06:37:08Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T06:37:08Z"}, "message": "Generate XXSPLTIW on power10.\n\nThis patch adds support to automatically generate the ISA 3.1 XXSPLTIW\ninstruction for V8HImode, V4SImode, and V4SFmode vectors.  It does this by\nadding support for vector constants that can be used, and adding a\nVEC_DUPLICATE pattern to generate the actual XXSPLTIW instruction.\n\nAdd the eP constraint to recognize constants that can be loaded into\nvector registers with a single prefixed instruction such as xxspltiw and\nxxspltidp.\n\nI added 4 new tests to test loading up V16QI, V8HI, V4SI, and V4SF vector\nconstants.\n\n2021-12-14  Michael Meissner  <meissner@linux.ibm.com>\n\ngcc/\n\n\t* config/rs6000/constraints.md (eP): Update comment.\n\t* config/rs6000/predicates.md (easy_fp_constant): Add support for\n\tgenerating XXSPLTIW.\n\t(vsx_prefixed_constant): New predicate.\n\t(easy_vector_constant): Add support for\n\tgenerating XXSPLTIW.\n\t* config/rs6000/rs6000-protos.h (prefixed_xxsplti_p): New\n\tdeclaration.\n\t(constant_generates_xxspltiw): Likewise.\n\t* config/rs6000/rs6000.c (xxspltib_constant_p): Generate XXSPLTIW\n\tif possible instead of XXSPLTIB and sign extending the constant.\n\t(output_vec_const_move): Add support for XXSPLTIW.\n\t(prefixed_xxsplti_p): New function.\n\t(constant_generates_xxspltiw): New function.\n\t* config/rs6000/rs6000.md (prefixed attribute): Add support to\n\tmark XXSPLTI* instructions as being prefixed.\n\t* config/rs6000/rs6000.opt (-msplat-word-constant): New debug\n\tswitch.\n\t* config/rs6000/vsx.md (vsx_mov<mode>_64bit): Add support for\n\tgenerating XXSPLTIW or XXSPLTIDP.\n\t(vsx_mov<mode>_32bit): Likewise.\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document the\n\teP constraint.\n\ngcc/testsuite/\n\n\t* gcc.target/powerpc/vec-splat-constant-v16qi.c: New test.\n\t* gcc.target/powerpc/vec-splat-constant-v4sf.c: New test.\n\t* gcc.target/powerpc/vec-splat-constant-v4si.c: New test.\n\t* gcc.target/powerpc/vec-splat-constant-v8hi.c: New test.\n\t* gcc.target/powerpc/vec-splati-runnable.c: Update insn count.", "tree": {"sha": "93336fa21f3198b2624110980cadbd0157fb242e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93336fa21f3198b2624110980cadbd0157fb242e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/comments", "author": null, "committer": null, "parents": [{"sha": "8ccd8b12ded1782f4273fd1f381b7d554df61a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccd8b12ded1782f4273fd1f381b7d554df61a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ccd8b12ded1782f4273fd1f381b7d554df61a12"}], "stats": {"total": 389, "additions": 371, "deletions": 18}, "files": [{"sha": "a4b05837fa6152aa607d7271254a2b26463300d9", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -213,6 +213,12 @@\n   \"A signed 34-bit integer constant if prefixed instructions are supported.\"\n   (match_operand 0 \"cint34_operand\"))\n \n+;; A SF/DF scalar constant or a vector constant that can be loaded into vector\n+;; registers with one prefixed instruction such as XXSPLTIDP or XXSPLTIW.\n+(define_constraint \"eP\"\n+  \"A constant that can be loaded into a VSX register with one prefixed insn.\"\n+  (match_operand 0 \"vsx_prefixed_constant\"))\n+\n ;; A TF/KF scalar constant or a vector constant that can load certain IEEE\n ;; 128-bit constants into vector registers using LXVKQ.\n (define_constraint \"eQ\""}, {"sha": "886ace79075c77f8b0004c8470727d72e0540eb8", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -605,7 +605,10 @@\n   vec_const_128bit_type vsx_const;\n   if (TARGET_POWER10 && vec_const_128bit_to_bytes (op, mode, &vsx_const))\n     {\n-      if (constant_generates_lxvkq (&vsx_const) != 0)\n+      if (constant_generates_lxvkq (&vsx_const))\n+\treturn true;\n+\n+      if (constant_generates_xxspltiw (&vsx_const))\n \treturn true;\n     }\n \n@@ -617,6 +620,42 @@\n    return 0;\n })\n \n+;; Return 1 if the operand is a 64-bit floating point scalar constant or a\n+;; vector constant that can be loaded to a VSX register with one prefixed\n+;; instruction, such as XXSPLTIDP or XXSPLTIW.\n+;;\n+;; In addition regular constants, we also recognize constants formed with the\n+;; VEC_DUPLICATE insn from scalar constants.\n+;;\n+;; We don't handle scalar integer constants here because the assumption is the\n+;; normal integer constants will be loaded into GPR registers.  For the\n+;; constants that need to be loaded into vector registers, the instructions\n+;; don't work well with TImode variables assigned a constant.  This is because\n+;; the 64-bit scalar constants are splatted into both halves of the register.\n+\n+(define_predicate \"vsx_prefixed_constant\"\n+  (match_code \"const_double,const_vector,vec_duplicate\")\n+{\n+  /* If we can generate the constant with a few Altivec instructions, don't\n+      generate a prefixed instruction.  */\n+  if (CONST_VECTOR_P (op) && easy_altivec_constant (op, mode))\n+    return false;\n+\n+  /* Do we have prefixed instructions and are VSX registers available?  Is the\n+     constant recognized?  */\n+  if (!TARGET_PREFIXED || !TARGET_VSX)\n+    return false;\n+\n+  vec_const_128bit_type vsx_const;\n+  if (!vec_const_128bit_to_bytes (op, mode, &vsx_const))\n+    return false;\n+\n+  if (constant_generates_xxspltiw (&vsx_const))\n+    return true;\n+\n+  return false;\n+})\n+\n ;; Return 1 if the operand is a special IEEE 128-bit value that can be loaded\n ;; via the LXVKQ instruction.\n \n@@ -683,7 +722,10 @@\n       vec_const_128bit_type vsx_const;\n       if (TARGET_POWER10 && vec_const_128bit_to_bytes (op, mode, &vsx_const))\n \t{\n-\t  if (constant_generates_lxvkq (&vsx_const) != 0)\n+\t  if (constant_generates_lxvkq (&vsx_const))\n+\t    return true;\n+\n+\t  if (constant_generates_xxspltiw (&vsx_const))\n \t    return true;\n \t}\n "}, {"sha": "74699ab6f72f2c939622410f2661b65577d24cf7", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -198,6 +198,7 @@ enum non_prefixed_form reg_to_non_prefixed (rtx reg, machine_mode mode);\n extern bool prefixed_load_p (rtx_insn *);\n extern bool prefixed_store_p (rtx_insn *);\n extern bool prefixed_paddi_p (rtx_insn *);\n+extern bool prefixed_xxsplti_p (rtx_insn *);\n extern void rs6000_asm_output_opcode (FILE *);\n extern void output_pcrel_opt_reloc (rtx);\n extern void rs6000_final_prescan_insn (rtx_insn *, rtx [], int);\n@@ -251,6 +252,7 @@ typedef struct {\n extern bool vec_const_128bit_to_bytes (rtx, machine_mode,\n \t\t\t\t       vec_const_128bit_type *);\n extern unsigned constant_generates_lxvkq (vec_const_128bit_type *);\n+extern unsigned constant_generates_xxspltiw (vec_const_128bit_type *);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "5c1b620a1e21edeb8d32d4fb6b3479c2c3cfa14a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -6649,6 +6649,13 @@ xxspltib_constant_p (rtx op,\n   else if (IN_RANGE (value, -1, 0))\n     *num_insns_ptr = 1;\n \n+  /* Do not generate XXSPLTIB and a sign extend operation if we can generate a\n+     single XXSPLTIW or XXSPLTIDP instruction.  */\n+  else if (vsx_prefixed_constant (op, mode))\n+    return false;\n+\n+  /* Return XXSPLITB followed by a sign extend operation to convert the\n+     constant to V8HImode or V4SImode.  */\n   else\n     *num_insns_ptr = 2;\n \n@@ -6709,6 +6716,13 @@ output_vec_const_move (rtx *operands)\n \t      operands[2] = GEN_INT (imm);\n \t      return \"lxvkq %x0,%2\";\n \t    }\n+\n+\t  imm = constant_generates_xxspltiw (&vsx_const);\n+\t  if (imm)\n+\t    {\n+\t      operands[2] = GEN_INT (imm);\n+\t      return \"xxspltiw %x0,%2\";\n+\t    }\n \t}\n \n       if (TARGET_P9_VECTOR\n@@ -26480,6 +26494,41 @@ prefixed_paddi_p (rtx_insn *insn)\n   return (iform == INSN_FORM_PCREL_EXTERNAL || iform == INSN_FORM_PCREL_LOCAL);\n }\n \n+/* Whether an instruction is a prefixed XXSPLTI* instruction.  This is called\n+   from the prefixed attribute processing.  */\n+\n+bool\n+prefixed_xxsplti_p (rtx_insn *insn)\n+{\n+  rtx set = single_set (insn);\n+  if (!set)\n+    return false;\n+\n+  rtx dest = SET_DEST (set);\n+  rtx src = SET_SRC (set);\n+  machine_mode mode = GET_MODE (dest);\n+\n+  if (!REG_P (dest) && !SUBREG_P (dest))\n+    return false;\n+\n+  if (GET_CODE (src) == UNSPEC)\n+    {\n+      int unspec = XINT (src, 1);\n+      return (unspec == UNSPEC_XXSPLTIW\n+\t      || unspec == UNSPEC_XXSPLTIDP\n+\t      || unspec == UNSPEC_XXSPLTI32DX);\n+    }\n+\n+  vec_const_128bit_type vsx_const;\n+  if (vec_const_128bit_to_bytes (src, mode, &vsx_const))\n+    {\n+      if (constant_generates_xxspltiw (&vsx_const))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Whether the next instruction needs a 'p' prefix issued before the\n    instruction is printed out.  */\n static bool prepend_p_to_next_insn;\n@@ -28648,6 +28697,40 @@ constant_generates_lxvkq (vec_const_128bit_type *vsx_const)\n   return 0;\n }\n \n+/* Determine if a vector constant can be loaded with XXSPLTIW.  Return zero if\n+   the XXSPLTIW instruction cannot be used.  Otherwise return the immediate\n+   value to be used with the XXSPLTIW instruction.  */\n+\n+unsigned\n+constant_generates_xxspltiw (vec_const_128bit_type *vsx_const)\n+{\n+  if (!TARGET_SPLAT_WORD_CONSTANT || !TARGET_PREFIXED || !TARGET_VSX)\n+    return 0;\n+\n+  if (!vsx_const->all_words_same)\n+    return 0;\n+\n+  /* If we can use XXSPLTIB, don't generate XXSPLTIW.  */\n+  if (vsx_const->all_bytes_same)\n+    return 0;\n+\n+  /* See if we can use VSPLTISH or VSPLTISW.  */\n+  if (vsx_const->all_half_words_same)\n+    {\n+      unsigned short h_word = vsx_const->half_words[0];\n+      short sign_h_word = ((h_word & 0xffff) ^ 0x8000) - 0x8000;\n+      if (EASY_VECTOR_15 (sign_h_word))\n+\treturn 0;\n+    }\n+\n+  unsigned int word = vsx_const->words[0];\n+  int sign_word = ((word & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+  if (EASY_VECTOR_15 (sign_word))\n+    return 0;\n+\n+  return vsx_const->words[0];\n+}\n+\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "3a7bcd2426e7a13564e61da2069ecebce71783bd", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -314,6 +314,11 @@\n \n \t (eq_attr \"type\" \"integer,add\")\n \t (if_then_else (match_test \"prefixed_paddi_p (insn)\")\n+\t\t       (const_string \"yes\")\n+\t\t       (const_string \"no\"))\n+\n+\t (eq_attr \"type\" \"vecperm\")\n+\t (if_then_else (match_test \"prefixed_xxsplti_p (insn)\")\n \t\t       (const_string \"yes\")\n \t\t       (const_string \"no\"))]\n "}, {"sha": "ec7b106fddb4fce0f62c9b4093647a766fd20e93", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -640,6 +640,10 @@ mprivileged\n Target Var(rs6000_privileged) Init(0)\n Generate code that will run in privileged state.\n \n+msplat-word-constant\n+Target Var(TARGET_SPLAT_WORD_CONSTANT) Init(1) Save\n+Generate (do not generate) code that uses the XXSPLTIW instruction.\n+\n mieee128-constant\n Target Var(TARGET_IEEE128_CONSTANT) Init(1) Save\n Generate (do not generate) code that uses the LXVKQ instruction."}, {"sha": "802db0d112b4a9946737c498e6268040eddc1ea0", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -1192,19 +1192,19 @@\n \n ;;              VSX store  VSX load   VSX move  VSX->GPR   GPR->VSX    LQ (GPR)\n ;;              STQ (GPR)  GPR load   GPR store GPR move   XXSPLTIB    VSPLTISW\n-;;              LXVKQ\n+;;              LXVKQ      XXSPLTI*\n ;;              VSX 0/-1   VMX const  GPR const LVX (VMX)  STVX (VMX)\n (define_insn \"vsx_mov<mode>_64bit\"\n   [(set (match_operand:VSX_M 0 \"nonimmediate_operand\"\n                \"=ZwO,      wa,        wa,        r,         we,        ?wQ,\n                 ?&r,       ??r,       ??Y,       <??r>,     wa,        v,\n-                wa,\n+                wa,        wa,\n                 ?wa,       v,         <??r>,     wZ,        v\")\n \n \t(match_operand:VSX_M 1 \"input_operand\" \n                \"wa,        ZwO,       wa,        we,        r,         r,\n                 wQ,        Y,         r,         r,         wE,        jwM,\n-                eQ,\n+                eQ,        eP,\n                 ?jwM,      W,         <nW>,      v,         wZ\"))]\n \n   \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n@@ -1216,43 +1216,43 @@\n   [(set_attr \"type\"\n                \"vecstore,  vecload,   vecsimple, mtvsr,     mfvsr,     load,\n                 store,     load,      store,     *,         vecsimple, vecsimple,\n-                vecperm,\n+                vecperm,   vecperm,\n                 vecsimple, *,         *,         vecstore,  vecload\")\n    (set_attr \"num_insns\"\n                \"*,         *,         *,         2,         *,         2,\n                 2,         2,         2,         2,         *,         *,\n-                *,\n+                *,         *,\n                 *,         5,         2,         *,         *\")\n    (set_attr \"max_prefixed_insns\"\n                \"*,         *,         *,         *,         *,         2,\n                 2,         2,         2,         2,         *,         *,\n-                *,\n+                *,         *,\n                 *,         *,         *,         *,         *\")\n    (set_attr \"length\"\n                \"*,         *,         *,         8,         *,         8,\n                 8,         8,         8,         8,         *,         *,\n-                *,\n+                *,         *,\n                 *,         20,        8,         *,         *\")\n    (set_attr \"isa\"\n                \"<VSisa>,   <VSisa>,   <VSisa>,   *,         *,         *,\n                 *,         *,         *,         *,         p9v,       *,\n-                p10,\n+                p10,       p10,\n                 <VSisa>,   *,         *,         *,         *\")])\n \n ;;              VSX store  VSX load   VSX move   GPR load   GPR store  GPR move\n-;;              LXVKQ\n+;;              LXVKQ      XXSPLTI*\n ;;              XXSPLTIB   VSPLTISW   VSX 0/-1   VMX const  GPR const\n ;;              LVX (VMX)  STVX (VMX)\n (define_insn \"*vsx_mov<mode>_32bit\"\n   [(set (match_operand:VSX_M 0 \"nonimmediate_operand\"\n                \"=ZwO,      wa,        wa,        ??r,       ??Y,       <??r>,\n-                wa,\n+                wa,        wa,\n                 wa,        v,         ?wa,       v,         <??r>,\n                 wZ,        v\")\n \n \t(match_operand:VSX_M 1 \"input_operand\" \n                \"wa,        ZwO,       wa,        Y,         r,         r,\n-                eQ,\n+                eQ,        eP,\n                 wE,        jwM,       ?jwM,      W,         <nW>,\n                 v,         wZ\"))]\n \n@@ -1264,17 +1264,17 @@\n }\n   [(set_attr \"type\"\n                \"vecstore,  vecload,   vecsimple, load,      store,    *,\n-                vecperm,\n+                vecperm,   vecperm,\n                 vecsimple, vecsimple, vecsimple, *,         *,\n                 vecstore,  vecload\")\n    (set_attr \"length\"\n                \"*,         *,         *,         16,        16,        16,\n-                *,\n+                *,         *,\n                 *,         *,         *,         20,        16,\n                 *,         *\")\n    (set_attr \"isa\"\n                \"<VSisa>,   <VSisa>,   <VSisa>,   *,         *,         *,\n-                p10,\n+                p10,       p10,\n                 p9v,       *,         <VSisa>,   *,         *,\n                 *,         *\")])\n "}, {"sha": "9ec051e94e10cca9eec2773e1b8c01b74b6ea4db", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -3336,6 +3336,10 @@ A constant whose negation is a signed 16-bit constant.\n @item eI\n A signed 34-bit integer constant if prefixed instructions are supported.\n \n+@item eP\n+A scalar floating point constant or a vector constant that can be\n+loaded to a VSX register with one prefixed instruction.\n+\n @item eQ\n An IEEE 128-bit constant that can be loaded into a VSX register with\n the @code{lxvkq} instruction."}, {"sha": "27764ddbc83e8289443c741732124b6fdf4adcb4", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-v16qi.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v16qi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v16qi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v16qi.c?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* Test whether XXSPLTIW is generated for V16HI vector constants where the\n+   first 4 elements are the same as the next 4 elements, etc.  */\n+\n+vector unsigned char\n+v16qi_const_1 (void)\n+{\n+  return (vector unsigned char) { 1, 1, 1, 1, 1, 1, 1, 1,\n+\t\t\t\t  1, 1, 1, 1, 1, 1, 1, 1, }; /* VSLTPISB.  */\n+}\n+\n+vector unsigned char\n+v16qi_const_2 (void)\n+{\n+  return (vector unsigned char) { 1, 2, 3, 4, 1, 2, 3, 4,\n+\t\t\t\t  1, 2, 3, 4, 1, 2, 3, 4, }; /* XXSPLTIW.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltiw\\M}              1 } } */\n+/* { dg-final { scan-assembler-times {\\mvspltisb\\M|\\mxxspltib\\M} 1 } } */\n+/* { dg-final { scan-assembler-not   {\\mlxvx?\\M}                   } } */\n+/* { dg-final { scan-assembler-not   {\\mplxv\\M}                    } } */"}, {"sha": "1f0475cf47ac4edef746433a0aeb5d48c4de561b", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-v4sf.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v4sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v4sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v4sf.c?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* Test whether XXSPLTIW is generated for V4SF vector constants.  */\n+\n+vector float\n+v4sf_const_1 (void)\n+{\n+  return (vector float) { 1.0f, 1.0f, 1.0f, 1.0f };\t/* XXSPLTIW.  */\n+}\n+\n+vector float\n+v4sf_const_nan (void)\n+{\n+  return (vector float) { __builtin_nanf (\"\"),\n+\t\t\t  __builtin_nanf (\"\"),\n+\t\t\t  __builtin_nanf (\"\"),\n+\t\t\t  __builtin_nanf (\"\") };\t/* XXSPLTIW.  */\n+}\n+\n+vector float\n+v4sf_const_inf (void)\n+{\n+  return (vector float) { __builtin_inff (),\n+\t\t\t  __builtin_inff (),\n+\t\t\t  __builtin_inff (),\n+\t\t\t  __builtin_inff () };\t\t/* XXSPLTIW.  */\n+}\n+\n+vector float\n+v4sf_const_m0 (void)\n+{\n+  return (vector float) { -0.0f, -0.0f, -0.0f, -0.0f };\t/* XXSPLTIB/VSLW.  */\n+}\n+\n+vector float\n+v4sf_splats_1 (void)\n+{\n+  return vec_splats (1.0f);\t\t\t\t/* XXSPLTIW.  */\n+}\n+\n+vector float\n+v4sf_splats_nan (void)\n+{\n+  return vec_splats (__builtin_nanf (\"\"));\t\t/* XXSPLTIW.  */\n+}\n+\n+vector float\n+v4sf_splats_inf (void)\n+{\n+  return vec_splats (__builtin_inff ());\t\t/* XXSPLTIW.  */\n+}\n+\n+vector float\n+v8hi_splats_m0 (void)\n+{\n+  return vec_splats (-0.0f);\t\t\t\t/* XXSPLTIB/VSLW.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltiw\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxspltib\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvslw\\M}     2 } } */\n+/* { dg-final { scan-assembler-not   {\\mlxvx?\\M}      } } */\n+/* { dg-final { scan-assembler-not   {\\mplxv\\M}       } } */"}, {"sha": "02d0c6d66a26da9f188e8bdc97f6f11c76ca9c1e", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-v4si.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v4si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v4si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v4si.c?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* Test whether XXSPLTIW is generated for V4SI vector constants.  We make sure\n+   the power9 support (XXSPLTIB/VEXTSB2W) is not done.  */\n+\n+vector int\n+v4si_const_1 (void)\n+{\n+  return (vector int) { 1, 1, 1, 1 };\t\t\t/* VSLTPISW.  */\n+}\n+\n+vector int\n+v4si_const_126 (void)\n+{\n+  return (vector int) { 126, 126, 126, 126 };\t\t/* XXSPLTIW.  */\n+}\n+\n+vector int\n+v4si_const_1023 (void)\n+{\n+  return (vector int) { 1023, 1023, 1023, 1023 };\t/* XXSPLTIW.  */\n+}\n+\n+vector int\n+v4si_splats_1 (void)\n+{\n+  return vec_splats (1);\t\t\t\t/* VSLTPISW.  */\n+}\n+\n+vector int\n+v4si_splats_126 (void)\n+{\n+  return vec_splats (126);\t\t\t\t/* XXSPLTIW.  */\n+}\n+\n+vector int\n+v8hi_splats_1023 (void)\n+{\n+  return vec_splats (1023);\t\t\t\t/* XXSPLTIW.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltiw\\M}  4 } } */\n+/* { dg-final { scan-assembler-times {\\mvspltisw\\M}  2 } } */\n+/* { dg-final { scan-assembler-not   {\\mxxspltib\\M}    } } */\n+/* { dg-final { scan-assembler-not   {\\mvextsb2w\\M}    } } */\n+/* { dg-final { scan-assembler-not   {\\mlxvx?\\M}       } } */\n+/* { dg-final { scan-assembler-not   {\\mplxv\\M}        } } */"}, {"sha": "59418d3bb0a8ef0d1142843f2b73add30f1ef676", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-v8hi.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v8hi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v8hi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v8hi.c?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <altivec.h>\n+\n+/* Test whether XXSPLTIW is generated for V8HI vector constants.  We make sure\n+   the power9 support (XXSPLTIB/VUPKLSB) is not done.  */\n+\n+vector short\n+v8hi_const_1 (void)\n+{\n+  return (vector short) { 1, 1, 1, 1, 1, 1, 1, 1 };\t/* VSLTPISH.  */\n+}\n+\n+vector short\n+v8hi_const_126 (void)\n+{\n+  return (vector short) { 126, 126, 126, 126,\n+\t\t\t  126, 126, 126, 126 };\t\t/* XXSPLTIW.  */\n+}\n+\n+vector short\n+v8hi_const_1023 (void)\n+{\n+  return (vector short) { 1023, 1023, 1023, 1023,\n+\t\t\t  1023, 1023, 1023, 1023 };\t/* XXSPLTIW.  */\n+}\n+\n+vector short\n+v8hi_splats_1 (void)\n+{\n+  return vec_splats ((short)1);\t\t\t\t/* VSLTPISH.  */\n+}\n+\n+vector short\n+v8hi_splats_126 (void)\n+{\n+  return vec_splats ((short)126);\t\t\t/* XXSPLTIW.  */\n+}\n+\n+vector short\n+v8hi_splats_1023 (void)\n+{\n+  return vec_splats ((short)1023);\t\t\t/* XXSPLTIW.  */\n+}\n+\n+/* Test that we can optimiza V8HI where all of the even elements are the same\n+   and all of the odd elements are the same.  */\n+vector short\n+v8hi_const_1023_1000 (void)\n+{\n+  return (vector short) { 1023, 1000, 1023, 1000,\n+\t\t\t  1023, 1000, 1023, 1000 };\t/* XXSPLTIW.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltiw\\M}  5 } } */\n+/* { dg-final { scan-assembler-times {\\mvspltish\\M}  2 } } */\n+/* { dg-final { scan-assembler-not   {\\mxxspltib\\M}    } } */\n+/* { dg-final { scan-assembler-not   {\\mvupklsb\\M}     } } */\n+/* { dg-final { scan-assembler-not   {\\mlxvx?\\M}       } } */\n+/* { dg-final { scan-assembler-not   {\\mplxv\\M}        } } */"}, {"sha": "6c01666b6257b897e8a8480c4c76694977e5061a", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splati-runnable.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splati-runnable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d730aa8a9ff26a36c3b480402c1507f3d2e48db9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splati-runnable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splati-runnable.c?ref=d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "patch": "@@ -149,8 +149,8 @@ main (int argc, char *argv [])\n   return 0;\n }\n \n-/* { dg-final { scan-assembler-times {\\mxxspltiw\\M} 2 } } */\n-/* { dg-final { scan-assembler-times {\\mxxspltidp\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mxxspltiw\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mxxspltidp\\M} 3 } } */\n /* { dg-final { scan-assembler-times {\\mxxsplti32dx\\M} 3 } } */\n \n "}]}