{"sha": "f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxY2Y1NmEzODZmNjBlNWJhZjVlMGEyYTg4OTEzYWIzNjYzN2VjOA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@linaro.org", "date": "2012-05-04T12:26:03Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-05-04T12:26:03Z"}, "message": "tree-vect-patterns.c (vect_same_loop_or_bb_p): New function.\n\n\t* tree-vect-patterns.c (vect_same_loop_or_bb_p): New function.\n\t(vect_handle_widen_op_by_const): Use it instead of open-coding test.\n\t(vect_recog_widen_mult_pattern): Likewise.\n\t(vect_operation_fits_smaller_type): Likewise.\n\t(vect_recog_over_widening_pattern): Likewise.\n\t(vect_recog_widen_shift_pattern): Add to vect_same_loop_or_bb_p test.\n\nFrom-SVN: r187156", "tree": {"sha": "76e3b5aaf7799558caa38c4a3a600ba989c2f99d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76e3b5aaf7799558caa38c4a3a600ba989c2f99d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71cf56a386f60e5baf5e0a2a88913ab36637ec8/comments", "author": null, "committer": null, "parents": [{"sha": "8bb50e5ce09c531440ec0c1e73b24c3b0a945c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb50e5ce09c531440ec0c1e73b24c3b0a945c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bb50e5ce09c531440ec0c1e73b24c3b0a945c69"}], "stats": {"total": 111, "additions": 56, "deletions": 55}, "files": [{"sha": "4f4195aa39034943ecfbe53c41beb7e6caabeb76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71cf56a386f60e5baf5e0a2a88913ab36637ec8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71cf56a386f60e5baf5e0a2a88913ab36637ec8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "patch": "@@ -1,3 +1,12 @@\n+2012-05-04  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* tree-vect-patterns.c (vect_same_loop_or_bb_p): New function.\n+\t(vect_handle_widen_op_by_const): Use it instead of open-coding test.\n+\t(vect_recog_widen_mult_pattern): Likewise.\n+\t(vect_operation_fits_smaller_type): Likewise.\n+\t(vect_recog_over_widening_pattern): Likewise.\n+\t(vect_recog_widen_shift_pattern): Add to vect_same_loop_or_bb_p test.\n+\n 2012-05-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/50602"}, {"sha": "bb70b929ae6900a02e9025221a384ba408c43ffd", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 47, "deletions": 55, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71cf56a386f60e5baf5e0a2a88913ab36637ec8/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71cf56a386f60e5baf5e0a2a88913ab36637ec8/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=f71cf56a386f60e5baf5e0a2a88913ab36637ec8", "patch": "@@ -84,6 +84,41 @@ new_pattern_def_seq (stmt_vec_info stmt_info, gimple stmt)\n   append_pattern_def_seq (stmt_info, stmt);\n }\n \n+/* Check whether STMT2 is in the same loop or basic block as STMT1.\n+   Which of the two applies depends on whether we're currently doing\n+   loop-based or basic-block-based vectorization, as determined by\n+   the vinfo_for_stmt for STMT1 (which must be defined).\n+\n+   If this returns true, vinfo_for_stmt for STMT2 is guaranteed\n+   to be defined as well.  */\n+\n+static bool\n+vect_same_loop_or_bb_p (gimple stmt1, gimple stmt2)\n+{\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt1);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+\n+  if (!gimple_bb (stmt2))\n+    return false;\n+\n+  if (loop_vinfo)\n+    {\n+      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      if (!flow_bb_inside_loop_p (loop, gimple_bb (stmt2)))\n+\treturn false;\n+    }\n+  else\n+    {\n+      if (gimple_bb (stmt2) != BB_VINFO_BB (bb_vinfo)\n+\t  || gimple_code (stmt2) == GIMPLE_PHI)\n+\treturn false;\n+    }\n+\n+  gcc_assert (vinfo_for_stmt (stmt2));\n+  return true;\n+}\n+\n /* Check whether NAME, an ssa-name used in USE_STMT,\n    is a result of a type promotion or demotion, such that:\n      DEF_STMT: NAME = NOP (name0)\n@@ -400,16 +435,6 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n {\n   tree new_type, new_oprnd, tmp;\n   gimple new_stmt;\n-  loop_vec_info loop_vinfo;\n-  struct loop *loop = NULL;\n-  bb_vec_info bb_vinfo;\n-  stmt_vec_info stmt_vinfo;\n-\n-  stmt_vinfo = vinfo_for_stmt (stmt);\n-  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n-  if (loop_vinfo)\n-    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if (code != MULT_EXPR && code != LSHIFT_EXPR)\n     return false;\n@@ -425,12 +450,10 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n       return true;\n     }\n \n-  if (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 4)\n-      || !gimple_bb (def_stmt)\n-      || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n-      || (!loop && gimple_bb (def_stmt) != BB_VINFO_BB (bb_vinfo)\n-\t  && gimple_code (def_stmt) != GIMPLE_PHI)\n-      || !vinfo_for_stmt (def_stmt))\n+  if (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 4))\n+    return false;\n+\n+  if (!vect_same_loop_or_bb_p (stmt, def_stmt))\n     return false;\n \n   /* TYPE is 4 times bigger than HALF_TYPE, try widening operation for\n@@ -564,16 +587,6 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n   VEC (tree, heap) *dummy_vec;\n   bool op1_ok;\n   bool promotion;\n-  loop_vec_info loop_vinfo;\n-  struct loop *loop = NULL;\n-  bb_vec_info bb_vinfo;\n-  stmt_vec_info stmt_vinfo;\n-\n-  stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n-  if (loop_vinfo)\n-    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -645,9 +658,7 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n           || gimple_assign_rhs_code (use_stmt) != NOP_EXPR)\n         return NULL;\n \n-      if (!gimple_bb (use_stmt)\n-\t  || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n-\t  || (!loop && gimple_bb (use_stmt) != BB_VINFO_BB (bb_vinfo)))\n+      if (!vect_same_loop_or_bb_p (last_stmt, use_stmt))\n \treturn NULL;\n \n       use_lhs = gimple_assign_lhs (use_stmt);\n@@ -952,14 +963,8 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n   tree interm_type = NULL_TREE, half_type, tmp, new_oprnd, type;\n   gimple def_stmt, new_stmt;\n   bool first = false;\n-  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt));\n-  bb_vec_info bb_info = STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt));\n-  struct loop *loop = NULL;\n   bool promotion;\n \n-  if (loop_info)\n-    loop = LOOP_VINFO_LOOP (loop_info);\n-\n   *op0 = NULL_TREE;\n   *op1 = NULL_TREE;\n   *new_def_stmt = NULL;\n@@ -991,13 +996,9 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n     {\n       first = true;\n       if (!type_conversion_p (oprnd, stmt, false, &half_type, &def_stmt,\n-                               &promotion)\n-         || !promotion\n-          || !gimple_bb (def_stmt)\n-          || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n-\t  || (!loop && gimple_bb (def_stmt) != BB_VINFO_BB (bb_info)\n-\t      && gimple_code (def_stmt) != GIMPLE_PHI)\n-          || !vinfo_for_stmt (def_stmt))\n+\t\t\t      &promotion)\n+\t  || !promotion\n+\t  || !vect_same_loop_or_bb_p (stmt, def_stmt))\n         return false;\n     }\n \n@@ -1171,16 +1172,6 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n   tree var = NULL_TREE, new_type = NULL_TREE, tmp, new_oprnd;\n   bool first;\n   tree type = NULL;\n-  loop_vec_info loop_vinfo;\n-  struct loop *loop = NULL;\n-  bb_vec_info bb_vinfo;\n-  stmt_vec_info stmt_vinfo;\n-\n-  stmt_vinfo = vinfo_for_stmt (stmt);\n-  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n-  if (loop_vinfo)\n-    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   first = true;\n   while (1)\n@@ -1212,9 +1203,7 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n         }\n \n       if (nuses != 1 || !is_gimple_assign (use_stmt)\n-          || !gimple_bb (use_stmt)\n-          || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n-\t  || (!loop && gimple_bb (use_stmt) != BB_VINFO_BB (bb_vinfo)))\n+\t  || !vect_same_loop_or_bb_p (stmt, use_stmt))\n         return NULL;\n \n       /* Create pattern statement for STMT.  */\n@@ -1495,6 +1484,9 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n \t      || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n \t    return NULL;\n \n+\t  if (!vect_same_loop_or_bb_p (last_stmt, use_stmt))\n+\t    return NULL;\n+\n           use_lhs = gimple_assign_lhs (use_stmt);\n           use_type = TREE_TYPE (use_lhs);\n "}]}