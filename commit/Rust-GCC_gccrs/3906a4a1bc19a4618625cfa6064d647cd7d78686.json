{"sha": "3906a4a1bc19a4618625cfa6064d647cd7d78686", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwNmE0YTFiYzE5YTQ2MTg2MjVjZmE2MDY0ZDY0N2NkN2Q3ODY4Ng==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-04-12T19:43:46Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-04-12T19:43:46Z"}, "message": "invoke.texi (max_gcse_passes): Remove documentation.\n\n\t* doc/invoke.texi (max_gcse_passes): Remove documentation.\n\t* params.def (PARAM_MAX_GCSE_PASSES): Remove.\n\t* params.h (MAX_GCSE_PASSES): Remove.\n\t* gcse.c (gcse_main): Run CPROP1, PRE or HOIST, and CPROP2\n\tin sequence.  Remove ability to run multiple passes.\n\t(bypass_jumps): Report run as third CPROP pass.\n\nFrom-SVN: r145987", "tree": {"sha": "9dbf1cc66ef55758e837e4c3dd40cbb0d6e48d4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dbf1cc66ef55758e837e4c3dd40cbb0d6e48d4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3906a4a1bc19a4618625cfa6064d647cd7d78686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3906a4a1bc19a4618625cfa6064d647cd7d78686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3906a4a1bc19a4618625cfa6064d647cd7d78686", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3906a4a1bc19a4618625cfa6064d647cd7d78686/comments", "author": null, "committer": null, "parents": [{"sha": "efaadb930b1db67a8b25b53c31a1ffb2000cdae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efaadb930b1db67a8b25b53c31a1ffb2000cdae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efaadb930b1db67a8b25b53c31a1ffb2000cdae0"}], "stats": {"total": 198, "additions": 97, "deletions": 101}, "files": [{"sha": "8b1a41a99db4cf07daf518d907045e6ad59dae85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3906a4a1bc19a4618625cfa6064d647cd7d78686", "patch": "@@ -1,3 +1,12 @@\n+2009-04-12  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* doc/invoke.texi (max_gcse_passes): Remove documentation.\n+\t* params.def (PARAM_MAX_GCSE_PASSES): Remove.\n+\t* params.h (MAX_GCSE_PASSES): Remove.\n+\t* gcse.c (gcse_main): Run CPROP1, PRE or HOIST, and CPROP2\n+\tin sequence.  Remove ability to run multiple passes.\n+\t(bypass_jumps): Report run as third CPROP pass.\n+\n 2009-04-12  Adam Nemet  <anemet@caviumnetworks.com>\n \n \tPR middle-end/39651"}, {"sha": "c5f8dfbdc212747d6f6b30baa0a1e6b21ec86ae6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3906a4a1bc19a4618625cfa6064d647cd7d78686", "patch": "@@ -7330,9 +7330,6 @@ order to perform the global common subexpression elimination\n optimization.  If more memory than specified is required, the\n optimization will not be done.\n \n-@item max-gcse-passes\n-The maximum number of passes of GCSE to run.  The default is 1.\n-\n @item max-pending-list-length\n The maximum number of pending dependencies scheduling will allow\n before flushing the current state and starting over.  Large functions"}, {"sha": "00f09862cb6ab12f7cd87d063dd48b8d69ed870a", "filename": "gcc/gcse.c", "status": "modified", "additions": 87, "deletions": 91, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3906a4a1bc19a4618625cfa6064d647cd7d78686", "patch": "@@ -190,16 +190,18 @@ along with GCC; see the file COPYING3.  If not see\n \n    We perform the following steps:\n \n-   1) Compute basic block information.\n+   1) Compute table of places where registers are set.\n \n-   2) Compute table of places where registers are set.\n+   2) Perform copy/constant propagation.\n \n-   3) Perform copy/constant propagation.\n-\n-   4) Perform global cse using lazy code motion if not optimizing\n+   3) Perform global cse using lazy code motion if not optimizing\n       for size, or code hoisting if we are.\n \n-   5) Perform another pass of copy/constant propagation.\n+   4) Perform another pass of copy/constant propagation.  Try to bypass\n+      conditional jumps if the condition can be computed from a value of\n+      an incoming edge.\n+\n+   5) Perform store motion.\n \n    Two passes of copy/constant propagation are done because the first one\n    enables more GCSE and the second one helps to clean up the copies that\n@@ -212,6 +214,11 @@ along with GCC; see the file COPYING3.  If not see\n    (set (pseudo-reg) (expression)).\n    Function want_to_gcse_p says what these are.\n \n+   In addition, expressions in REG_EQUAL notes are candidates for GXSE-ing.\n+   This allows PRE to hoist expressions that are expressed in multiple insns,\n+   such as comprex address calculations (e.g. for PIC code, or loads with a \n+   high part and as lowe part).\n+\n    PRE handles moving invariant expressions out of loops (by treating them as\n    partially redundant).\n \n@@ -235,9 +242,13 @@ along with GCC; see the file COPYING3.  If not see\n    It was found doing copy propagation between each pass enables further\n    substitutions.\n \n+   This study was done before expressions in REG_EQUAL notes were added as\n+   candidate expressions for optimization, and before the GIMPLE optimizers\n+   were added.  Probably, multiple passes is even less efficient now than\n+   at the time when the study was conducted.\n+\n    PRE is quite expensive in complicated functions because the DFA can take\n-   a while to converge.  Hence we only perform one pass.  The parameter\n-   max-gcse-passes can be modified if one wants to experiment.\n+   a while to converge.  Hence we only perform one pass.\n \n    **********************\n \n@@ -661,11 +672,7 @@ static bool is_too_expensive (const char *);\n static int\n gcse_main (rtx f ATTRIBUTE_UNUSED)\n {\n-  int changed, pass;\n-  /* Bytes used at start of pass.  */\n-  int initial_bytes_used;\n-  /* Maximum number of bytes used by a pass.  */\n-  int max_pass_bytes;\n+  int changed;\n   /* Point to release obstack data from for each pass.  */\n   char *gcse_obstack_bottom;\n \n@@ -697,114 +704,102 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n \n   /* We need alias.  */\n   init_alias_analysis ();\n+\n   /* Record where pseudo-registers are set.  This data is kept accurate\n      during each pass.  ??? We could also record hard-reg information here\n      [since it's unchanging], however it is currently done during hash table\n      computation.\n \n      It may be tempting to compute MEM set information here too, but MEM sets\n      will be subject to code motion one day and thus we need to compute\n-     information about memory sets when we build the hash tables.  */\n+     information about memory sets when we build the hash tables.\n+     \n+     ??? Actually, we already know the information that compute_sets computes\n+     because it is available from DF.  FIXME.  */\n \n   alloc_reg_set_mem (max_gcse_regno);\n   compute_sets ();\n \n-  pass = 0;\n-  initial_bytes_used = bytes_used;\n-  max_pass_bytes = 0;\n   gcse_obstack_bottom = GOBNEWVAR (char, 1);\n-  changed = 1;\n-  while (changed && pass < MAX_GCSE_PASSES)\n-    {\n-      changed = 0;\n-      if (dump_file)\n-\tfprintf (dump_file, \"GCSE pass %d\\n\\n\", pass + 1);\n-\n-      /* Initialize bytes_used to the space for the pred/succ lists,\n-\t and the reg_set_table data.  */\n-      bytes_used = initial_bytes_used;\n+  changed = 0;\n+ \n+  if (dump_file)\n+    fprintf (dump_file, \"GCSE pass\\n\\n\");\n \n-      /* Each pass may create new registers, so recalculate each time.  */\n-      max_gcse_regno = max_reg_num ();\n+  max_gcse_regno = max_reg_num ();\n \n-      alloc_gcse_mem ();\n+  alloc_gcse_mem ();\n \n-      /* Don't allow constant propagation to modify jumps\n-\t during this pass.  */\n-      if (dbg_cnt (cprop1))\n-\t{\n-\t  timevar_push (TV_CPROP1);\n-\t  changed = one_cprop_pass (pass + 1, false, false);\n-\t  timevar_pop (TV_CPROP1);\n-\t}\n+  /* Don't allow constant propagation to modify jumps\n+     during this pass.  */\n+  if (dbg_cnt (cprop1))\n+    {\n+      timevar_push (TV_CPROP1);\n+      changed = one_cprop_pass (1, false, false);\n+      timevar_pop (TV_CPROP1);\n+    }\n \n-      if (optimize_function_for_speed_p (cfun))\n+  if (optimize_function_for_speed_p (cfun))\n+    {\n+      timevar_push (TV_PRE);\n+      changed |= one_pre_gcse_pass (1);\n+      /* We may have just created new basic blocks.  Release and\n+\t recompute various things which are sized on the number of\n+\t basic blocks.\n+\t ??? There would be no need for this if we used a block\n+\t based Lazy Code Motion variant, with all (or selected)\n+\t edges split before running the pass.  That would also\n+\t help find_implicit_sets for cprop.  FIXME.  */\n+      if (changed)\n \t{\n-\t  timevar_push (TV_PRE);\n-\t  changed |= one_pre_gcse_pass (pass + 1);\n-\t  /* We may have just created new basic blocks.  Release and\n-\t     recompute various things which are sized on the number of\n-\t     basic blocks.  */\n-\t  if (changed)\n-\t    {\n-\t      free_modify_mem_tables ();\n-\t      modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n-\t      canon_modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n-\t    }\n-\t  free_reg_set_mem ();\n-\t  alloc_reg_set_mem (max_reg_num ());\n-\t  compute_sets ();\n-\t  run_jump_opt_after_gcse = 1;\n-\t  timevar_pop (TV_PRE);\n+\t  free_modify_mem_tables ();\n+\t  modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n+\t  canon_modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n \t}\n \n-      if (max_pass_bytes < bytes_used)\n-\tmax_pass_bytes = bytes_used;\n-\n-      /* Free up memory, then reallocate for code hoisting.  We can\n-\t not re-use the existing allocated memory because the tables\n-\t will not have info for the insns or registers created by\n-\t partial redundancy elimination.  */\n-      free_gcse_mem ();\n-\n-      /* It does not make sense to run code hoisting unless we are optimizing\n+      /* ??? When we allocate this at the start of the function,\n+\t the comment says that \"this data is kept accurate during\n+\t each pass\".  Apparently this is not so?  FIXME.  */\n+      free_reg_set_mem ();\n+      alloc_reg_set_mem (max_reg_num ());\n+      compute_sets ();\n+      run_jump_opt_after_gcse = 1;\n+      timevar_pop (TV_PRE);\n+    }\n+  else\n+    {\n+      /* This function is being optimized for code size.\n+\t It does not make sense to run code hoisting unless we are optimizing\n \t for code size -- it rarely makes programs faster, and can make\n \t them bigger if we did partial redundancy elimination (when optimizing\n \t for space, we don't run the partial redundancy algorithms).  */\n-      if (optimize_function_for_size_p (cfun))\n-\t{\n-\t  timevar_push (TV_HOIST);\n-\t  max_gcse_regno = max_reg_num ();\n-\t  alloc_gcse_mem ();\n-\t  changed |= one_code_hoisting_pass ();\n-\t  free_gcse_mem ();\n-\n-\t  if (max_pass_bytes < bytes_used)\n-\t    max_pass_bytes = bytes_used;\n-\t  timevar_pop (TV_HOIST);\n-\t}\n+      timevar_push (TV_HOIST);\n+      max_gcse_regno = max_reg_num ();\n+      alloc_gcse_mem ();\n+      one_code_hoisting_pass ();\n+      timevar_pop (TV_HOIST);\n+    }\n \n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n\");\n-\t  fflush (dump_file);\n-\t}\n+  free_gcse_mem ();\n \n-      obstack_free (&gcse_obstack, gcse_obstack_bottom);\n-      pass++;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n\");\n+      fflush (dump_file);\n     }\n \n-  /* Do one last pass of copy propagation, including cprop into\n-     conditional jumps.  */\n+  obstack_free (&gcse_obstack, gcse_obstack_bottom);\n \n+  /* Do the second const/copy propagation pass, including cprop into\n+     conditional jumps.  */\n   if (dbg_cnt (cprop2))\n     {\n       max_gcse_regno = max_reg_num ();\n       alloc_gcse_mem ();\n \n       /* This time, go ahead and allow cprop to alter jumps.  */\n       timevar_push (TV_CPROP2);\n-      one_cprop_pass (pass + 1, true, true);\n+      one_cprop_pass (2, true, true);\n       timevar_pop (TV_CPROP2);\n       free_gcse_mem ();\n     }\n@@ -813,16 +808,17 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n     {\n       fprintf (dump_file, \"GCSE of %s: %d basic blocks, \",\n \t       current_function_name (), n_basic_blocks);\n-      fprintf (dump_file, \"%d pass%s, %d bytes\\n\\n\",\n-\t       pass, pass > 1 ? \"es\" : \"\", max_pass_bytes);\n+      fprintf (dump_file, \"pass 1, %d bytes\\n\\n\", bytes_used);\n     }\n \n   obstack_free (&gcse_obstack, NULL);\n   free_reg_set_mem ();\n \n-  /* We are finished with alias.  */\n+  /* We are finished with alias.\n+     ??? Actually we recompute alias in store_motion.  */\n   end_alias_analysis ();\n \n+  /* Run store motion.  */\n   if (optimize_function_for_speed_p (cfun) && flag_gcse_sm)\n     {\n       timevar_push (TV_LSM);\n@@ -6530,7 +6526,7 @@ bypass_jumps (void)\n \n   max_gcse_regno = max_reg_num ();\n   alloc_gcse_mem ();\n-  changed = one_cprop_pass (MAX_GCSE_PASSES + 2, true, true);\n+  changed = one_cprop_pass (3, true, true);\n   free_gcse_mem ();\n \n   if (dump_file)"}, {"sha": "684de5ed3ca65c0fedd4668dbcb01a04621bf02c", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=3906a4a1bc19a4618625cfa6064d647cd7d78686", "patch": "@@ -223,11 +223,7 @@ DEFPARAM(PARAM_MAX_GCSE_MEMORY,\n \t \"max-gcse-memory\",\n \t \"The maximum amount of memory to be allocated by GCSE\",\n \t 50 * 1024 * 1024, 0, 0)\n-/* The number of repetitions of copy/const prop and PRE to run.  */\n-DEFPARAM(PARAM_MAX_GCSE_PASSES,\n-\t\"max-gcse-passes\",\n-\t\"The maximum number of passes to make when doing GCSE\",\n-\t1, 1, 0)\n+\n /* This is the threshold ratio when to perform partial redundancy\n    elimination after reload. We perform partial redundancy elimination\n    when the following holds:"}, {"sha": "e9e6834ed2e8c4603061b1b442c1f650c5b4e6ac", "filename": "gcc/params.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3906a4a1bc19a4618625cfa6064d647cd7d78686/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=3906a4a1bc19a4618625cfa6064d647cd7d78686", "patch": "@@ -124,8 +124,6 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_MAX_PENDING_LIST_LENGTH)\n #define MAX_GCSE_MEMORY \\\n   ((size_t) PARAM_VALUE (PARAM_MAX_GCSE_MEMORY))\n-#define MAX_GCSE_PASSES \\\n-  PARAM_VALUE (PARAM_MAX_GCSE_PASSES)\n #define GCSE_AFTER_RELOAD_PARTIAL_FRACTION \\\n   PARAM_VALUE (PARAM_GCSE_AFTER_RELOAD_PARTIAL_FRACTION)\n #define GCSE_AFTER_RELOAD_CRITICAL_FRACTION \\"}]}