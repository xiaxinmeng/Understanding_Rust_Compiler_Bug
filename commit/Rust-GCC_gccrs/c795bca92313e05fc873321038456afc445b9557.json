{"sha": "c795bca92313e05fc873321038456afc445b9557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc5NWJjYTkyMzEzZTA1ZmM4NzMzMjEwMzg0NTZhZmM0NDViOTU1Nw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-11-19T22:47:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-11-19T22:47:55Z"}, "message": "expr.c (STACK_BYTES): Delete unused macro.\n\n\t* expr.c (STACK_BYTES): Delete unused macro.\n\t* calls.c: Provide default for PREFERRED_STACK_BOUNDARY.\n\t(STACK_BYTES): Use PREFERRED_STACK_BOUNDARY, not STACK_BOUNDARY.\n\t(expand_call): Likewise.\n\t(emit_library_call): Likewise.\n\t(emit_library_call_value): Likewise.\n\t* function.c: Provide default for PREFERRED_STACK_BOUNDARY.\n\t(STACK_BYTES): Use PREFERRED_STACK_BOUNDARY, not STACK_BOUNDARY.\n\t* explow.c: Provide default for PREFERRED_STACK_BOUNDARY.\n\t(round_push): Use PREFERRED_STACK_BOUNDARY, not STACK_BOUNDARY.\n\t(allocate_dynamic_stack_space): Likewise.\n\t* tm.texi (PREFERRED_STACK_BOUNDARY): Document new macro.\n\t(STACK_BOUNDARY): Update description to reflect the new situation.\n\nFrom-SVN: r23730", "tree": {"sha": "310800560c2d56240298d18712cd2147a03cd10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/310800560c2d56240298d18712cd2147a03cd10c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c795bca92313e05fc873321038456afc445b9557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c795bca92313e05fc873321038456afc445b9557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c795bca92313e05fc873321038456afc445b9557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c795bca92313e05fc873321038456afc445b9557/comments", "author": null, "committer": null, "parents": [{"sha": "9f5a2691a147626d10fba7bc366a059678c606e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f5a2691a147626d10fba7bc366a059678c606e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f5a2691a147626d10fba7bc366a059678c606e9"}], "stats": {"total": 102, "additions": 68, "deletions": 34}, "files": [{"sha": "fff326d2c7c0e0c3531fd598392ae82b58d7dd77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c795bca92313e05fc873321038456afc445b9557/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c795bca92313e05fc873321038456afc445b9557/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c795bca92313e05fc873321038456afc445b9557", "patch": "@@ -1,3 +1,19 @@\n+Thu Nov 19 23:44:38 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* expr.c (STACK_BYTES): Delete unused macro.\n+\t* calls.c: Provide default for PREFERRED_STACK_BOUNDARY.\n+\t(STACK_BYTES): Use PREFERRED_STACK_BOUNDARY, not STACK_BOUNDARY.\n+\t(expand_call): Likewise.\n+\t(emit_library_call): Likewise.\n+\t(emit_library_call_value): Likewise.\n+\t* function.c: Provide default for PREFERRED_STACK_BOUNDARY.\n+\t(STACK_BYTES): Use PREFERRED_STACK_BOUNDARY, not STACK_BOUNDARY.\n+\t* explow.c: Provide default for PREFERRED_STACK_BOUNDARY.\n+\t(round_push): Use PREFERRED_STACK_BOUNDARY, not STACK_BOUNDARY.\n+\t(allocate_dynamic_stack_space): Likewise.\n+\t* tm.texi (PREFERRED_STACK_BOUNDARY): Document new macro.\n+\t(STACK_BOUNDARY): Update description to reflect the new situation.\n+\n Thu Nov 19 22:20:51 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* reorg.c (relax_delay_slots): When optimizing for code size, if a"}, {"sha": "6f67b7c009f951d30a1eb8d7781d5571f2eef5d5", "filename": "gcc/calls.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c795bca92313e05fc873321038456afc445b9557/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c795bca92313e05fc873321038456afc445b9557/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c795bca92313e05fc873321038456afc445b9557", "patch": "@@ -29,6 +29,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"output.h\"\n \n+#if !defined PREFERRED_STACK_BOUNDARY && defined STACK_BOUNDARY\n+#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n+#endif\n+\n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n \n@@ -43,8 +47,8 @@ Boston, MA 02111-1307, USA.  */\n \n #endif\n \n-/* Like STACK_BOUNDARY but in units of bytes, not bits.  */\n-#define STACK_BYTES (STACK_BOUNDARY / BITS_PER_UNIT)\n+/* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n+#define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n \n /* Data structure and subroutines used within expand_call.  */\n \n@@ -311,7 +315,7 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n    says that the pointer to this aggregate is to be popped by the callee.\n \n    STACK_SIZE is the number of bytes of arguments on the stack,\n-   rounded up to STACK_BOUNDARY; zero if the size is variable.\n+   rounded up to PREFERRED_STACK_BOUNDARY; zero if the size is variable.\n    This is both to put into the call insn and\n    to generate explicit popping code if necessary.\n \n@@ -1240,8 +1244,8 @@ expand_call (exp, target, ignore)\n       args_size.var = ARGS_SIZE_TREE (args_size);\n       args_size.constant = 0;\n \n-#ifdef STACK_BOUNDARY\n-      if (STACK_BOUNDARY != BITS_PER_UNIT)\n+#ifdef PREFERRED_STACK_BOUNDARY\n+      if (PREFERRED_STACK_BOUNDARY != BITS_PER_UNIT)\n \targs_size.var = round_up (args_size.var, STACK_BYTES);\n #endif\n \n@@ -1262,7 +1266,7 @@ expand_call (exp, target, ignore)\n     }\n   else\n     {\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n       args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n \t\t\t     / STACK_BYTES) * STACK_BYTES);\n #endif\n@@ -1589,7 +1593,7 @@ expand_call (exp, target, ignore)\n     }\n \t\t\t\t\t       \n #ifdef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   /* If we push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n   if (argblock == 0)\n@@ -1838,7 +1842,7 @@ expand_call (exp, target, ignore)\n \t\t       args_size.var != 0, reg_parm_stack_space);\n \n #ifndef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n   if (argblock == 0)\n@@ -2386,7 +2390,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   assemble_external_libcall (fun);\n \n   original_args_size = args_size;\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n \t\t\t / STACK_BYTES) * STACK_BYTES);\n #endif\n@@ -2454,7 +2458,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n #endif\n \n #ifdef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   /* If we push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n   if (argblock == 0)\n@@ -2599,7 +2603,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n     }\n \n #ifndef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n   if (argblock == 0)\n@@ -2950,7 +2954,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   assemble_external_libcall (fun);\n \n   original_args_size = args_size;\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n \t\t\t / STACK_BYTES) * STACK_BYTES);\n #endif\n@@ -3018,7 +3022,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n #endif\n \n #ifdef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   /* If we push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n   if (argblock == 0)\n@@ -3164,7 +3168,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n     }\n \n #ifndef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n   if (argblock == 0)"}, {"sha": "0dbf002b4d2cc6375795f8e3351e14b09893e4e2", "filename": "gcc/explow.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c795bca92313e05fc873321038456afc445b9557/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c795bca92313e05fc873321038456afc445b9557/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c795bca92313e05fc873321038456afc445b9557", "patch": "@@ -31,6 +31,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n \n+#if !defined PREFERRED_STACK_BOUNDARY && defined STACK_BOUNDARY\n+#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n+#endif\n+\n static rtx break_out_memory_refs\tPROTO((rtx));\n static void emit_stack_probe\t\tPROTO((rtx));\n /* Return an rtx for the sum of X and the integer C.\n@@ -830,8 +834,8 @@ rtx\n round_push (size)\n      rtx size;\n {\n-#ifdef STACK_BOUNDARY\n-  int align = STACK_BOUNDARY / BITS_PER_UNIT;\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n   if (align == 1)\n     return size;\n   if (GET_CODE (size) == CONST_INT)\n@@ -851,7 +855,7 @@ round_push (size)\n \t\t\t    NULL_RTX, 1);\n       size = expand_mult (Pmode, size, GEN_INT (align), NULL_RTX, 1);\n     }\n-#endif /* STACK_BOUNDARY */\n+#endif /* PREFERRED_STACK_BOUNDARY */\n   return size;\n }\n \f\n@@ -1124,10 +1128,10 @@ allocate_dynamic_stack_space (size, target, known_align)\n      If we have to align, we must leave space in SIZE for the hole\n      that might result from the alignment operation.  */\n \n-#if defined (STACK_DYNAMIC_OFFSET) || defined (STACK_POINTER_OFFSET) || ! defined (STACK_BOUNDARY)\n+#if defined (STACK_DYNAMIC_OFFSET) || defined (STACK_POINTER_OFFSET) || ! defined (PREFERRED_STACK_BOUNDARY)\n #define MUST_ALIGN 1\n #else\n-#define MUST_ALIGN (STACK_BOUNDARY < BIGGEST_ALIGNMENT)\n+#define MUST_ALIGN (PREFERRED_STACK_BOUNDARY < BIGGEST_ALIGNMENT)\n #endif\n \n   if (MUST_ALIGN)\n@@ -1154,12 +1158,12 @@ allocate_dynamic_stack_space (size, target, known_align)\n \n     if (!current_function_calls_setjmp)\n       {\n-\tint align = STACK_BOUNDARY / BITS_PER_UNIT;\n+\tint align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n \n \t/* See optimize_save_area_alloca to understand what is being\n \t   set up here.  */\n \n-#if !defined(STACK_BOUNDARY) || !defined(MUST_ALIGN) || (STACK_BOUNDARY != BIGGEST_ALIGNMENT)\n+#if !defined(PREFERRED_STACK_BOUNDARY) || !defined(MUST_ALIGN) || (PREFERRED_STACK_BOUNDARY != BIGGEST_ALIGNMENT)\n \t/* If anyone creates a target with these characteristics, let them\n \t   know that our optimization cannot work correctly in such a case.  */\n \tabort();\n@@ -1209,11 +1213,11 @@ allocate_dynamic_stack_space (size, target, known_align)\n      way of knowing which systems have this problem.  So we avoid even\n      momentarily mis-aligning the stack.  */\n \n-#ifdef STACK_BOUNDARY\n+#ifdef PREFERRED_STACK_BOUNDARY\n   /* If we added a variable amount to SIZE,\n      we can no longer assume it is aligned.  */\n #if !defined (SETJMP_VIA_SAVE_AREA)\n-  if (MUST_ALIGN || known_align % STACK_BOUNDARY != 0)\n+  if (MUST_ALIGN || known_align % PREFERRED_STACK_BOUNDARY != 0)\n #endif\n     size = round_push (size);\n #endif"}, {"sha": "ca0aba102348771236594c676b60201b7aad8b9d", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c795bca92313e05fc873321038456afc445b9557/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c795bca92313e05fc873321038456afc445b9557/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c795bca92313e05fc873321038456afc445b9557", "patch": "@@ -65,9 +65,6 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #endif\n \n-/* Like STACK_BOUNDARY but in units of bytes, not bits.  */\n-#define STACK_BYTES (STACK_BOUNDARY / BITS_PER_UNIT)\n-\n /* Assume that case vectors are not pc-relative.  */\n #ifndef CASE_VECTOR_PC_RELATIVE\n #define CASE_VECTOR_PC_RELATIVE 0"}, {"sha": "fa8b14ae1c218d8c99a0535178b667da7df023fd", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c795bca92313e05fc873321038456afc445b9557/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c795bca92313e05fc873321038456afc445b9557/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c795bca92313e05fc873321038456afc445b9557", "patch": "@@ -57,6 +57,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"toplev.h\"\n \n+#if !defined PREFERRED_STACK_BOUNDARY && defined STACK_BOUNDARY\n+#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n+#endif\n+\n #ifndef TRAMPOLINE_ALIGNMENT\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n #endif\n@@ -669,7 +673,7 @@ void pop_function_context ()\n /* Allocate fixed slots in the stack frame of the current function.  */\n \n /* Return size needed for stack frame based on slots so far allocated.\n-   This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n+   This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n    the caller may have to do that.  */\n \n HOST_WIDE_INT\n@@ -4645,8 +4649,8 @@ assign_parms (fndecl, second_time)\n #endif\n #endif\n \n-#ifdef STACK_BOUNDARY\n-#define STACK_BYTES (STACK_BOUNDARY / BITS_PER_UNIT)\n+#ifdef PREFERRED_STACK_BOUNDARY\n+#define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n \n   current_function_args_size\n     = ((current_function_args_size + STACK_BYTES - 1)"}, {"sha": "7a0dd0e4756b3b4e6ac8ad2db5f12b919a9ac8ba", "filename": "gcc/tm.texi", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c795bca92313e05fc873321038456afc445b9557/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c795bca92313e05fc873321038456afc445b9557/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=c795bca92313e05fc873321038456afc445b9557", "patch": "@@ -790,15 +790,24 @@ size of an integer.\n \n @findex STACK_BOUNDARY\n @item STACK_BOUNDARY\n+Define this macro if there is a guaranteed alignment for the stack\n+pointer on this machine.  The definition is a C expression\n+for the desired alignment (measured in bits).  This value is used as a\n+default if PREFERRED_STACK_BOUNDARY is not defined.\n+\n+@findex PREFERRED_STACK_BOUNDARY\n+@item PREFERRED_STACK_BOUNDARY\n Define this macro if you wish to preserve a certain alignment for\n the stack pointer.  The definition is a C expression\n-for the desired alignment (measured in bits).\n+for the desired alignment (measured in bits).  If STACK_BOUNDARY is\n+also defined, this macro must evaluate to a value equal to or larger\n+than STACK_BOUNDARY.\n \n-@cindex @code{PUSH_ROUNDING}, interaction with @code{STACK_BOUNDARY}\n+@cindex @code{PUSH_ROUNDING}, interaction with @code{PREFERRED_STACK_BOUNDARY}\n If @code{PUSH_ROUNDING} is not defined, the stack will always be aligned\n-to the specified boundary.  If @code{PUSH_ROUNDING} is defined and specifies a\n-less strict alignment than @code{STACK_BOUNDARY}, the stack may be\n-momentarily unaligned while pushing arguments.\n+to the specified boundary.  If @code{PUSH_ROUNDING} is defined and specifies\n+a less strict alignment than @code{PREFERRED_STACK_BOUNDARY}, the stack may\n+be momentarily unaligned while pushing arguments.\n \n @findex FUNCTION_BOUNDARY\n @item FUNCTION_BOUNDARY"}]}