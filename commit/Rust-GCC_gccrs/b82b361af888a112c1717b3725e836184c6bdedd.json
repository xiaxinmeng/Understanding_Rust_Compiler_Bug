{"sha": "b82b361af888a112c1717b3725e836184c6bdedd", "node_id": "C_kwDOANBUbNoAKGI4MmIzNjFhZjg4OGExMTJjMTcxN2IzNzI1ZTgzNjE4NGM2YmRlZGQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-01T02:26:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-01T02:26:42Z"}, "message": "analyzer: move bounds checking to a new bounds-checking.cc\n\ngcc/ChangeLog:\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/bounds-checking.o.\n\ngcc/analyzer/ChangeLog:\n\t* bounds-checking.cc: New file, taken from region-model.cc.\n\t* region-model.cc (class out_of_bounds): Move to\n\tbounds-checking.cc.\n\t(class past_the_end): Likewise.\n\t(class buffer_overflow): Likewise.\n\t(class buffer_overread): Likewise.\n\t(class buffer_underflow): Likewise.\n\t(class buffer_underread): Likewise.\n\t(class symbolic_past_the_end): Likewise.\n\t(class symbolic_buffer_overflow): Likewise.\n\t(class symbolic_buffer_overread): Likewise.\n\t(region_model::check_symbolic_bounds): Likewise.\n\t(maybe_get_integer_cst_tree): Likewise.\n\t(region_model::check_region_bounds): Likewise.\n\t* region-model.h: Add comment.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "40d15722cb73cb4b6a5dbb284a16867b8abc56d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40d15722cb73cb4b6a5dbb284a16867b8abc56d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b82b361af888a112c1717b3725e836184c6bdedd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82b361af888a112c1717b3725e836184c6bdedd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b82b361af888a112c1717b3725e836184c6bdedd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82b361af888a112c1717b3725e836184c6bdedd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45a75fd3d31265e43aa3ce7a5e851083d534b00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a75fd3d31265e43aa3ce7a5e851083d534b00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a75fd3d31265e43aa3ce7a5e851083d534b00b"}], "stats": {"total": 1351, "additions": 698, "deletions": 653}, "files": [{"sha": "615a07089ee220a9e6f11f480d92f1f63c85551c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b82b361af888a112c1717b3725e836184c6bdedd", "patch": "@@ -1255,6 +1255,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/analyzer-pass.o \\\n \tanalyzer/analyzer-selftests.o \\\n \tanalyzer/bar-chart.o \\\n+\tanalyzer/bounds-checking.o \\\n \tanalyzer/call-info.o \\\n \tanalyzer/call-string.o \\\n \tanalyzer/call-summary.o \\"}, {"sha": "19aaa51e6a820fbc8d25241129291f748c87014b", "filename": "gcc/analyzer/bounds-checking.cc", "status": "added", "additions": 695, "deletions": 0, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2Fanalyzer%2Fbounds-checking.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2Fanalyzer%2Fbounds-checking.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fbounds-checking.cc?ref=b82b361af888a112c1717b3725e836184c6bdedd", "patch": "@@ -0,0 +1,695 @@\n+/* Bounds-checking of reads and writes to memory regions.\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_MEMORY\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"make-unique.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/region-model.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Abstract base class for all out-of-bounds warnings with concrete values.  */\n+\n+class out_of_bounds : public pending_diagnostic_subclass<out_of_bounds>\n+{\n+public:\n+  out_of_bounds (const region *reg, tree diag_arg,\n+\t\t byte_range out_of_bounds_range)\n+  : m_reg (reg), m_diag_arg (diag_arg),\n+    m_out_of_bounds_range (out_of_bounds_range)\n+  {}\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"out_of_bounds_diagnostic\";\n+  }\n+\n+  bool operator== (const out_of_bounds &other) const\n+  {\n+    return m_reg == other.m_reg\n+\t   && m_out_of_bounds_range == other.m_out_of_bounds_range\n+\t   && pending_diagnostic::same_tree_p (m_diag_arg, other.m_diag_arg);\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_out_of_bounds;\n+  }\n+\n+  void mark_interesting_stuff (interesting_t *interest) final override\n+  {\n+    interest->add_region_creation (m_reg);\n+  }\n+\n+protected:\n+  const region *m_reg;\n+  tree m_diag_arg;\n+  byte_range m_out_of_bounds_range;\n+};\n+\n+/* Abstract subclass to complaing about out-of-bounds\n+   past the end of the buffer.  */\n+\n+class past_the_end : public out_of_bounds\n+{\n+public:\n+  past_the_end (const region *reg, tree diag_arg, byte_range range,\n+\t\ttree byte_bound)\n+  : out_of_bounds (reg, diag_arg, range), m_byte_bound (byte_bound)\n+  {}\n+\n+  bool operator== (const past_the_end &other) const\n+  {\n+    return out_of_bounds::operator== (other)\n+\t   && pending_diagnostic::same_tree_p (m_byte_bound,\n+\t\t\t\t\t       other.m_byte_bound);\n+  }\n+\n+  label_text\n+  describe_region_creation_event (const evdesc::region_creation &ev) final\n+  override\n+  {\n+    if (m_byte_bound && TREE_CODE (m_byte_bound) == INTEGER_CST)\n+      return ev.formatted_print (\"capacity is %E bytes\", m_byte_bound);\n+\n+    return label_text ();\n+  }\n+\n+protected:\n+  tree m_byte_bound;\n+};\n+\n+/* Concrete subclass to complain about buffer overflows.  */\n+\n+class buffer_overflow : public past_the_end\n+{\n+public:\n+  buffer_overflow (const region *reg, tree diag_arg,\n+\t\t   byte_range range, tree byte_bound)\n+  : past_the_end (reg, diag_arg, range, byte_bound)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    bool warned;\n+    switch (m_reg->get_memory_space ())\n+      {\n+      default:\n+\tm.add_cwe (787);\n+\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t       \"buffer overflow\");\n+\tbreak;\n+      case MEMSPACE_STACK:\n+\tm.add_cwe (121);\n+\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t       \"stack-based buffer overflow\");\n+\tbreak;\n+      case MEMSPACE_HEAP:\n+\tm.add_cwe (122);\n+\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t       \"heap-based buffer overflow\");\n+\tbreak;\n+      }\n+\n+    if (warned)\n+      {\n+\tchar num_bytes_past_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+\tprint_dec (m_out_of_bounds_range.m_size_in_bytes,\n+\t\t   num_bytes_past_buf, UNSIGNED);\n+\tif (m_diag_arg)\n+\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n+\t\t\t\t\t\" of %qE\", num_bytes_past_buf,\n+\t\t\t\t\t\t   m_diag_arg);\n+\telse\n+\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n+\t\t\t\t\t\"of the region\",\n+\t\t\t\t\tnum_bytes_past_buf);\n+      }\n+\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write at byte %s but %qE\"\n+\t\t\t\t     \" ends at byte %E\", start_buf, m_diag_arg,\n+\t\t\t\t\t\t\t m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds write at byte %s but region\"\n+\t\t\t\t   \" ends at byte %E\", start_buf,\n+\t\t\t\t\t\t       m_byte_bound);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE ends at byte %E\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg,\n+\t\t\t\t     m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t   \" byte %s but region ends at byte %E\",\n+\t\t\t\t   start_buf, end_buf, m_byte_bound);\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about buffer overreads.  */\n+\n+class buffer_overread : public past_the_end\n+{\n+public:\n+  buffer_overread (const region *reg, tree diag_arg,\n+\t\t   byte_range range, tree byte_bound)\n+  : past_the_end (reg, diag_arg, range, byte_bound)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (126);\n+    bool warned = warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t\t\"buffer overread\");\n+\n+    if (warned)\n+      {\n+\tchar num_bytes_past_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+\tprint_dec (m_out_of_bounds_range.m_size_in_bytes,\n+\t\t   num_bytes_past_buf, UNSIGNED);\n+\tif (m_diag_arg)\n+\t  inform (rich_loc->get_loc (), \"read is %s bytes past the end\"\n+\t\t\t\t\t\" of %qE\", num_bytes_past_buf,\n+\t\t\t\t\t\t    m_diag_arg);\n+\telse\n+\t  inform (rich_loc->get_loc (), \"read is %s bytes past the end\"\n+\t\t\t\t\t\"of the region\",\n+\t\t\t\t\tnum_bytes_past_buf);\n+      }\n+\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read at byte %s but %qE\"\n+\t\t\t\t     \" ends at byte %E\", start_buf, m_diag_arg,\n+\t\t\t\t\t\t\t m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds read at byte %s but region\"\n+\t\t\t\t   \" ends at byte %E\", start_buf,\n+\t\t\t\t\t\t       m_byte_bound);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE ends at byte %E\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg,\n+\t\t\t\t     m_byte_bound);\n+\treturn ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t   \" byte %s but region ends at byte %E\",\n+\t\t\t\t   start_buf, end_buf, m_byte_bound);\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about buffer underflows.  */\n+\n+class buffer_underflow : public out_of_bounds\n+{\n+public:\n+  buffer_underflow (const region *reg, tree diag_arg, byte_range range)\n+  : out_of_bounds (reg, diag_arg, range)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (124);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"buffer underflow\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write at byte %s but %qE\"\n+\t\t\t\t     \" starts at byte 0\", start_buf,\n+\t\t\t\t\t\t\t  m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds write at byte %s but region\"\n+\t\t\t\t   \" starts at byte 0\", start_buf);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE starts at byte 0\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds write from byte %s till\"\n+\t\t\t\t   \" byte %s but region starts at byte 0\",\n+\t\t\t\t   start_buf, end_buf);;\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about buffer underreads.  */\n+\n+class buffer_underread : public out_of_bounds\n+{\n+public:\n+  buffer_underread (const region *reg, tree diag_arg, byte_range range)\n+  : out_of_bounds (reg, diag_arg, range)\n+  {}\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (127);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"buffer underread\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev)\n+  final override\n+  {\n+    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n+    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n+    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (start, start_buf, SIGNED);\n+    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+    print_dec (end, end_buf, SIGNED);\n+\n+    if (start == end)\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read at byte %s but %qE\"\n+\t\t\t\t     \" starts at byte 0\", start_buf,\n+\t\t\t\t\t\t\t  m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds read at byte %s but region\"\n+\t\t\t\t  \" starts at byte 0\", start_buf);\n+      }\n+    else\n+      {\n+\tif (m_diag_arg)\n+\t  return ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t     \" byte %s but %qE starts at byte 0\",\n+\t\t\t\t     start_buf, end_buf, m_diag_arg);\n+\treturn ev.formatted_print (\"out-of-bounds read from byte %s till\"\n+\t\t\t\t   \" byte %s but region starts at byte 0\",\n+\t\t\t\t   start_buf, end_buf);;\n+      }\n+  }\n+};\n+\n+/* Abstract class to complain about out-of-bounds read/writes where\n+   the values are symbolic.  */\n+\n+class symbolic_past_the_end\n+  : public pending_diagnostic_subclass<symbolic_past_the_end>\n+{\n+public:\n+  symbolic_past_the_end (const region *reg, tree diag_arg, tree offset,\n+\t\t\t tree num_bytes, tree capacity)\n+  : m_reg (reg), m_diag_arg (diag_arg), m_offset (offset),\n+    m_num_bytes (num_bytes), m_capacity (capacity)\n+  {}\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"symbolic_past_the_end\";\n+  }\n+\n+  bool operator== (const symbolic_past_the_end &other) const\n+  {\n+    return m_reg == other.m_reg\n+\t   && pending_diagnostic::same_tree_p (m_diag_arg, other.m_diag_arg)\n+\t   && pending_diagnostic::same_tree_p (m_offset, other.m_offset)\n+\t   && pending_diagnostic::same_tree_p (m_num_bytes, other.m_num_bytes)\n+\t   && pending_diagnostic::same_tree_p (m_capacity, other.m_capacity);\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_out_of_bounds;\n+  }\n+\n+  void mark_interesting_stuff (interesting_t *interest) final override\n+  {\n+    interest->add_region_creation (m_reg);\n+  }\n+\n+  label_text\n+  describe_region_creation_event (const evdesc::region_creation &ev) final\n+  override\n+  {\n+    if (m_capacity)\n+      return ev.formatted_print (\"capacity is %qE bytes\", m_capacity);\n+\n+    return label_text ();\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    const char *byte_str;\n+    if (pending_diagnostic::same_tree_p (m_num_bytes, integer_one_node))\n+      byte_str = \"byte\";\n+    else\n+      byte_str = \"bytes\";\n+\n+    if (m_offset)\n+      {\n+\tif (m_num_bytes && TREE_CODE (m_num_bytes) == INTEGER_CST)\n+\t  {\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n+\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str,\n+\t\t\t\t\t m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n+\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n+\t  }\n+\telse if (m_num_bytes)\n+\t  {\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n+\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str,\n+\t\t\t\t\t m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n+\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n+\t  }\n+\telse\n+\t  {\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"%s at offset %qE exceeds %qE\",\n+\t\t\t\t\t m_dir_str, m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"%s at offset %qE exceeds the\"\n+\t\t\t\t\t \" buffer\", m_dir_str, m_offset);\n+\t  }\n+      }\n+    if (m_diag_arg)\n+      return ev.formatted_print (\"out-of-bounds %s on %qE\",\n+\t\t\t\t m_dir_str, m_diag_arg);\n+    return ev.formatted_print (\"out-of-bounds %s\", m_dir_str);\n+  }\n+\n+protected:\n+  const region *m_reg;\n+  tree m_diag_arg;\n+  tree m_offset;\n+  tree m_num_bytes;\n+  tree m_capacity;\n+  const char *m_dir_str;\n+};\n+\n+/* Concrete subclass to complain about overflows with symbolic values.  */\n+\n+class symbolic_buffer_overflow : public symbolic_past_the_end\n+{\n+public:\n+  symbolic_buffer_overflow (const region *reg, tree diag_arg, tree offset,\n+\t\t\t    tree num_bytes, tree capacity)\n+  : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n+  {\n+    m_dir_str = \"write\";\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    switch (m_reg->get_memory_space ())\n+      {\n+      default:\n+\tm.add_cwe (787);\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t     \"buffer overflow\");\n+      case MEMSPACE_STACK:\n+\tm.add_cwe (121);\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t     \"stack-based buffer overflow\");\n+      case MEMSPACE_HEAP:\n+\tm.add_cwe (122);\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t     \"heap-based buffer overflow\");\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about overreads with symbolic values.  */\n+\n+class symbolic_buffer_overread : public symbolic_past_the_end\n+{\n+public:\n+  symbolic_buffer_overread (const region *reg, tree diag_arg, tree offset,\n+\t\t\t    tree num_bytes, tree capacity)\n+  : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n+  {\n+    m_dir_str = \"read\";\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (126);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"buffer overread\");\n+  }\n+};\n+\n+/* Check whether an access is past the end of the BASE_REG.  */\n+\n+void\n+region_model::check_symbolic_bounds (const region *base_reg,\n+\t\t\t\t     const svalue *sym_byte_offset,\n+\t\t\t\t     const svalue *num_bytes_sval,\n+\t\t\t\t     const svalue *capacity,\n+\t\t\t\t     enum access_direction dir,\n+\t\t\t\t     region_model_context *ctxt) const\n+{\n+  gcc_assert (ctxt);\n+\n+  const svalue *next_byte\n+    = m_mgr->get_or_create_binop (num_bytes_sval->get_type (), PLUS_EXPR,\n+\t\t\t\t  sym_byte_offset, num_bytes_sval);\n+\n+  if (eval_condition (next_byte, GT_EXPR, capacity).is_true ())\n+    {\n+      tree diag_arg = get_representative_tree (base_reg);\n+      tree offset_tree = get_representative_tree (sym_byte_offset);\n+      tree num_bytes_tree = get_representative_tree (num_bytes_sval);\n+      tree capacity_tree = get_representative_tree (capacity);\n+      switch (dir)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tcase DIR_READ:\n+\t  ctxt->warn (make_unique<symbolic_buffer_overread> (base_reg,\n+\t\t\t\t\t\t\t     diag_arg,\n+\t\t\t\t\t\t\t     offset_tree,\n+\t\t\t\t\t\t\t     num_bytes_tree,\n+\t\t\t\t\t\t\t     capacity_tree));\n+\t  break;\n+\tcase DIR_WRITE:\n+\t  ctxt->warn (make_unique<symbolic_buffer_overflow> (base_reg,\n+\t\t\t\t\t\t\t     diag_arg,\n+\t\t\t\t\t\t\t     offset_tree,\n+\t\t\t\t\t\t\t     num_bytes_tree,\n+\t\t\t\t\t\t\t     capacity_tree));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+static tree\n+maybe_get_integer_cst_tree (const svalue *sval)\n+{\n+  tree cst_tree = sval->maybe_get_constant ();\n+  if (cst_tree && TREE_CODE (cst_tree) == INTEGER_CST)\n+    return cst_tree;\n+\n+  return NULL_TREE;\n+}\n+\n+/* May complain when the access on REG is out-of-bounds.  */\n+\n+void\n+region_model::check_region_bounds (const region *reg,\n+\t\t\t\t   enum access_direction dir,\n+\t\t\t\t   region_model_context *ctxt) const\n+{\n+  gcc_assert (ctxt);\n+\n+  /* Get the offset.  */\n+  region_offset reg_offset = reg->get_offset (m_mgr);\n+  const region *base_reg = reg_offset.get_base_region ();\n+\n+  /* Bail out on symbolic regions.\n+     (e.g. because the analyzer did not see previous offsets on the latter,\n+     it might think that a negative access is before the buffer).  */\n+  if (base_reg->symbolic_p ())\n+    return;\n+\n+  /* Find out how many bytes were accessed.  */\n+  const svalue *num_bytes_sval = reg->get_byte_size_sval (m_mgr);\n+  tree num_bytes_tree = maybe_get_integer_cst_tree (num_bytes_sval);\n+  /* Bail out if 0 bytes are accessed.  */\n+  if (num_bytes_tree && zerop (num_bytes_tree))\n+    return;\n+\n+  /* Get the capacity of the buffer.  */\n+  const svalue *capacity = get_capacity (base_reg);\n+  tree cst_capacity_tree = maybe_get_integer_cst_tree (capacity);\n+\n+  /* The constant offset from a pointer is represented internally as a sizetype\n+     but should be interpreted as a signed value here.  The statement below\n+     converts the offset from bits to bytes and then to a signed integer with\n+     the same precision the sizetype has on the target system.\n+\n+     For example, this is needed for out-of-bounds-3.c test1 to pass when\n+     compiled with a 64-bit gcc build targeting 32-bit systems.  */\n+  byte_offset_t offset;\n+  if (!reg_offset.symbolic_p ())\n+    offset = wi::sext (reg_offset.get_bit_offset () >> LOG2_BITS_PER_UNIT,\n+\t\t       TYPE_PRECISION (size_type_node));\n+\n+  /* If either the offset or the number of bytes accessed are symbolic,\n+     we have to reason about symbolic values.  */\n+  if (reg_offset.symbolic_p () || !num_bytes_tree)\n+    {\n+      const svalue* byte_offset_sval;\n+      if (!reg_offset.symbolic_p ())\n+\t{\n+\t  tree offset_tree = wide_int_to_tree (integer_type_node, offset);\n+\t  byte_offset_sval\n+\t    = m_mgr->get_or_create_constant_svalue (offset_tree);\n+\t}\n+      else\n+\tbyte_offset_sval = reg_offset.get_symbolic_byte_offset ();\n+      check_symbolic_bounds (base_reg, byte_offset_sval, num_bytes_sval,\n+\t\t\t     capacity, dir, ctxt);\n+      return;\n+    }\n+\n+  /* Otherwise continue to check with concrete values.  */\n+  byte_range out (0, 0);\n+  /* NUM_BYTES_TREE should always be interpreted as unsigned.  */\n+  byte_offset_t num_bytes_unsigned = wi::to_offset (num_bytes_tree);\n+  byte_range read_bytes (offset, num_bytes_unsigned);\n+  /* If read_bytes has a subset < 0, we do have an underflow.  */\n+  if (read_bytes.falls_short_of_p (0, &out))\n+    {\n+      tree diag_arg = get_representative_tree (base_reg);\n+      switch (dir)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tcase DIR_READ:\n+\t  ctxt->warn (make_unique<buffer_underread> (reg, diag_arg, out));\n+\t  break;\n+\tcase DIR_WRITE:\n+\t  ctxt->warn (make_unique<buffer_underflow> (reg, diag_arg, out));\n+\t  break;\n+\t}\n+    }\n+\n+  /* For accesses past the end, we do need a concrete capacity.  No need to\n+     do a symbolic check here because the inequality check does not reason\n+     whether constants are greater than symbolic values.  */\n+  if (!cst_capacity_tree)\n+    return;\n+\n+  byte_range buffer (0, wi::to_offset (cst_capacity_tree));\n+  /* If READ_BYTES exceeds BUFFER, we do have an overflow.  */\n+  if (read_bytes.exceeds_p (buffer, &out))\n+    {\n+      tree byte_bound = wide_int_to_tree (size_type_node,\n+\t\t\t\t\t  buffer.get_next_byte_offset ());\n+      tree diag_arg = get_representative_tree (base_reg);\n+\n+      switch (dir)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tcase DIR_READ:\n+\t  ctxt->warn (make_unique<buffer_overread> (reg, diag_arg,\n+\t\t\t\t\t\t    out, byte_bound));\n+\t  break;\n+\tcase DIR_WRITE:\n+\t  ctxt->warn (make_unique<buffer_overflow> (reg, diag_arg,\n+\t\t\t\t\t\t    out, byte_bound));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "91b868f7b168566ec59fdeb92150aa4a16bdb8ea", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 0, "deletions": 653, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=b82b361af888a112c1717b3725e836184c6bdedd", "patch": "@@ -1212,659 +1212,6 @@ region_model::on_stmt_pre (const gimple *stmt,\n     }\n }\n \n-/* Abstract base class for all out-of-bounds warnings with concrete values.  */\n-\n-class out_of_bounds : public pending_diagnostic_subclass<out_of_bounds>\n-{\n-public:\n-  out_of_bounds (const region *reg, tree diag_arg,\n-\t\t byte_range out_of_bounds_range)\n-  : m_reg (reg), m_diag_arg (diag_arg),\n-    m_out_of_bounds_range (out_of_bounds_range)\n-  {}\n-\n-  const char *get_kind () const final override\n-  {\n-    return \"out_of_bounds_diagnostic\";\n-  }\n-\n-  bool operator== (const out_of_bounds &other) const\n-  {\n-    return m_reg == other.m_reg\n-\t   && m_out_of_bounds_range == other.m_out_of_bounds_range\n-\t   && pending_diagnostic::same_tree_p (m_diag_arg, other.m_diag_arg);\n-  }\n-\n-  int get_controlling_option () const final override\n-  {\n-    return OPT_Wanalyzer_out_of_bounds;\n-  }\n-\n-  void mark_interesting_stuff (interesting_t *interest) final override\n-  {\n-    interest->add_region_creation (m_reg);\n-  }\n-\n-protected:\n-  const region *m_reg;\n-  tree m_diag_arg;\n-  byte_range m_out_of_bounds_range;\n-};\n-\n-/* Abstract subclass to complaing about out-of-bounds\n-   past the end of the buffer.  */\n-\n-class past_the_end : public out_of_bounds\n-{\n-public:\n-  past_the_end (const region *reg, tree diag_arg, byte_range range,\n-\t\ttree byte_bound)\n-  : out_of_bounds (reg, diag_arg, range), m_byte_bound (byte_bound)\n-  {}\n-\n-  bool operator== (const past_the_end &other) const\n-  {\n-    return out_of_bounds::operator== (other)\n-\t   && pending_diagnostic::same_tree_p (m_byte_bound,\n-\t\t\t\t\t       other.m_byte_bound);\n-  }\n-\n-  label_text\n-  describe_region_creation_event (const evdesc::region_creation &ev) final\n-  override\n-  {\n-    if (m_byte_bound && TREE_CODE (m_byte_bound) == INTEGER_CST)\n-      return ev.formatted_print (\"capacity is %E bytes\", m_byte_bound);\n-\n-    return label_text ();\n-  }\n-\n-protected:\n-  tree m_byte_bound;\n-};\n-\n-/* Concrete subclass to complain about buffer overflows.  */\n-\n-class buffer_overflow : public past_the_end\n-{\n-public:\n-  buffer_overflow (const region *reg, tree diag_arg,\n-\t\t   byte_range range, tree byte_bound)\n-  : past_the_end (reg, diag_arg, range, byte_bound)\n-  {}\n-\n-  bool emit (rich_location *rich_loc) final override\n-  {\n-    diagnostic_metadata m;\n-    bool warned;\n-    switch (m_reg->get_memory_space ())\n-      {\n-      default:\n-\tm.add_cwe (787);\n-\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t       \"buffer overflow\");\n-\tbreak;\n-      case MEMSPACE_STACK:\n-\tm.add_cwe (121);\n-\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t       \"stack-based buffer overflow\");\n-\tbreak;\n-      case MEMSPACE_HEAP:\n-\tm.add_cwe (122);\n-\twarned = warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t       \"heap-based buffer overflow\");\n-\tbreak;\n-      }\n-\n-    if (warned)\n-      {\n-\tchar num_bytes_past_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-\tprint_dec (m_out_of_bounds_range.m_size_in_bytes,\n-\t\t   num_bytes_past_buf, UNSIGNED);\n-\tif (m_diag_arg)\n-\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n-\t\t\t\t\t\" of %qE\", num_bytes_past_buf,\n-\t\t\t\t\t\t   m_diag_arg);\n-\telse\n-\t  inform (rich_loc->get_loc (), \"write is %s bytes past the end\"\n-\t\t\t\t\t\"of the region\",\n-\t\t\t\t\tnum_bytes_past_buf);\n-      }\n-\n-    return warned;\n-  }\n-\n-  label_text describe_final_event (const evdesc::final_event &ev)\n-  final override\n-  {\n-    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n-    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n-    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (start, start_buf, SIGNED);\n-    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (end, end_buf, SIGNED);\n-\n-    if (start == end)\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds write at byte %s but %qE\"\n-\t\t\t\t     \" ends at byte %E\", start_buf, m_diag_arg,\n-\t\t\t\t\t\t\t m_byte_bound);\n-\treturn ev.formatted_print (\"out-of-bounds write at byte %s but region\"\n-\t\t\t\t   \" ends at byte %E\", start_buf,\n-\t\t\t\t\t\t       m_byte_bound);\n-      }\n-    else\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds write from byte %s till\"\n-\t\t\t\t     \" byte %s but %qE ends at byte %E\",\n-\t\t\t\t     start_buf, end_buf, m_diag_arg,\n-\t\t\t\t     m_byte_bound);\n-\treturn ev.formatted_print (\"out-of-bounds write from byte %s till\"\n-\t\t\t\t   \" byte %s but region ends at byte %E\",\n-\t\t\t\t   start_buf, end_buf, m_byte_bound);\n-      }\n-  }\n-};\n-\n-/* Concrete subclass to complain about buffer overreads.  */\n-\n-class buffer_overread : public past_the_end\n-{\n-public:\n-  buffer_overread (const region *reg, tree diag_arg,\n-\t\t   byte_range range, tree byte_bound)\n-  : past_the_end (reg, diag_arg, range, byte_bound)\n-  {}\n-\n-  bool emit (rich_location *rich_loc) final override\n-  {\n-    diagnostic_metadata m;\n-    m.add_cwe (126);\n-    bool warned = warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t\t\"buffer overread\");\n-\n-    if (warned)\n-      {\n-\tchar num_bytes_past_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-\tprint_dec (m_out_of_bounds_range.m_size_in_bytes,\n-\t\t   num_bytes_past_buf, UNSIGNED);\n-\tif (m_diag_arg)\n-\t  inform (rich_loc->get_loc (), \"read is %s bytes past the end\"\n-\t\t\t\t\t\" of %qE\", num_bytes_past_buf,\n-\t\t\t\t\t\t    m_diag_arg);\n-\telse\n-\t  inform (rich_loc->get_loc (), \"read is %s bytes past the end\"\n-\t\t\t\t\t\"of the region\",\n-\t\t\t\t\tnum_bytes_past_buf);\n-      }\n-\n-    return warned;\n-  }\n-\n-  label_text describe_final_event (const evdesc::final_event &ev)\n-  final override\n-  {\n-    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n-    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n-    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (start, start_buf, SIGNED);\n-    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (end, end_buf, SIGNED);\n-\n-    if (start == end)\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds read at byte %s but %qE\"\n-\t\t\t\t     \" ends at byte %E\", start_buf, m_diag_arg,\n-\t\t\t\t\t\t\t m_byte_bound);\n-\treturn ev.formatted_print (\"out-of-bounds read at byte %s but region\"\n-\t\t\t\t   \" ends at byte %E\", start_buf,\n-\t\t\t\t\t\t       m_byte_bound);\n-      }\n-    else\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds read from byte %s till\"\n-\t\t\t\t     \" byte %s but %qE ends at byte %E\",\n-\t\t\t\t     start_buf, end_buf, m_diag_arg,\n-\t\t\t\t     m_byte_bound);\n-\treturn ev.formatted_print (\"out-of-bounds read from byte %s till\"\n-\t\t\t\t   \" byte %s but region ends at byte %E\",\n-\t\t\t\t   start_buf, end_buf, m_byte_bound);\n-      }\n-  }\n-};\n-\n-/* Concrete subclass to complain about buffer underflows.  */\n-\n-class buffer_underflow : public out_of_bounds\n-{\n-public:\n-  buffer_underflow (const region *reg, tree diag_arg, byte_range range)\n-  : out_of_bounds (reg, diag_arg, range)\n-  {}\n-\n-  bool emit (rich_location *rich_loc) final override\n-  {\n-    diagnostic_metadata m;\n-    m.add_cwe (124);\n-    return warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t \"buffer underflow\");\n-  }\n-\n-  label_text describe_final_event (const evdesc::final_event &ev)\n-  final override\n-  {\n-    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n-    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n-    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (start, start_buf, SIGNED);\n-    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (end, end_buf, SIGNED);\n-\n-    if (start == end)\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds write at byte %s but %qE\"\n-\t\t\t\t     \" starts at byte 0\", start_buf,\n-\t\t\t\t\t\t\t  m_diag_arg);\n-\treturn ev.formatted_print (\"out-of-bounds write at byte %s but region\"\n-\t\t\t\t   \" starts at byte 0\", start_buf);\n-      }\n-    else\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds write from byte %s till\"\n-\t\t\t\t     \" byte %s but %qE starts at byte 0\",\n-\t\t\t\t     start_buf, end_buf, m_diag_arg);\n-\treturn ev.formatted_print (\"out-of-bounds write from byte %s till\"\n-\t\t\t\t   \" byte %s but region starts at byte 0\",\n-\t\t\t\t   start_buf, end_buf);;\n-      }\n-  }\n-};\n-\n-/* Concrete subclass to complain about buffer underreads.  */\n-\n-class buffer_underread : public out_of_bounds\n-{\n-public:\n-  buffer_underread (const region *reg, tree diag_arg, byte_range range)\n-  : out_of_bounds (reg, diag_arg, range)\n-  {}\n-\n-  bool emit (rich_location *rich_loc) final override\n-  {\n-    diagnostic_metadata m;\n-    m.add_cwe (127);\n-    return warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t \"buffer underread\");\n-  }\n-\n-  label_text describe_final_event (const evdesc::final_event &ev)\n-  final override\n-  {\n-    byte_size_t start = m_out_of_bounds_range.get_start_byte_offset ();\n-    byte_size_t end = m_out_of_bounds_range.get_last_byte_offset ();\n-    char start_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (start, start_buf, SIGNED);\n-    char end_buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-    print_dec (end, end_buf, SIGNED);\n-\n-    if (start == end)\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds read at byte %s but %qE\"\n-\t\t\t\t     \" starts at byte 0\", start_buf,\n-\t\t\t\t\t\t\t  m_diag_arg);\n-\treturn ev.formatted_print (\"out-of-bounds read at byte %s but region\"\n-\t\t\t\t  \" starts at byte 0\", start_buf);\n-      }\n-    else\n-      {\n-\tif (m_diag_arg)\n-\t  return ev.formatted_print (\"out-of-bounds read from byte %s till\"\n-\t\t\t\t     \" byte %s but %qE starts at byte 0\",\n-\t\t\t\t     start_buf, end_buf, m_diag_arg);\n-\treturn ev.formatted_print (\"out-of-bounds read from byte %s till\"\n-\t\t\t\t   \" byte %s but region starts at byte 0\",\n-\t\t\t\t   start_buf, end_buf);;\n-      }\n-  }\n-};\n-\n-/* Abstract class to complain about out-of-bounds read/writes where\n-   the values are symbolic.  */\n-\n-class symbolic_past_the_end\n-  : public pending_diagnostic_subclass<symbolic_past_the_end>\n-{\n-public:\n-  symbolic_past_the_end (const region *reg, tree diag_arg, tree offset,\n-\t\t\t tree num_bytes, tree capacity)\n-  : m_reg (reg), m_diag_arg (diag_arg), m_offset (offset),\n-    m_num_bytes (num_bytes), m_capacity (capacity)\n-  {}\n-\n-  const char *get_kind () const final override\n-  {\n-    return \"symbolic_past_the_end\";\n-  }\n-\n-  bool operator== (const symbolic_past_the_end &other) const\n-  {\n-    return m_reg == other.m_reg\n-\t   && pending_diagnostic::same_tree_p (m_diag_arg, other.m_diag_arg)\n-\t   && pending_diagnostic::same_tree_p (m_offset, other.m_offset)\n-\t   && pending_diagnostic::same_tree_p (m_num_bytes, other.m_num_bytes)\n-\t   && pending_diagnostic::same_tree_p (m_capacity, other.m_capacity);\n-  }\n-\n-  int get_controlling_option () const final override\n-  {\n-    return OPT_Wanalyzer_out_of_bounds;\n-  }\n-\n-  void mark_interesting_stuff (interesting_t *interest) final override\n-  {\n-    interest->add_region_creation (m_reg);\n-  }\n-\n-  label_text\n-  describe_region_creation_event (const evdesc::region_creation &ev) final\n-  override\n-  {\n-    if (m_capacity)\n-      return ev.formatted_print (\"capacity is %qE bytes\", m_capacity);\n-\n-    return label_text ();\n-  }\n-\n-  label_text\n-  describe_final_event (const evdesc::final_event &ev) final override\n-  {\n-    const char *byte_str;\n-    if (pending_diagnostic::same_tree_p (m_num_bytes, integer_one_node))\n-      byte_str = \"byte\";\n-    else\n-      byte_str = \"bytes\";\n-\n-    if (m_offset)\n-      {\n-\tif (m_num_bytes && TREE_CODE (m_num_bytes) == INTEGER_CST)\n-\t  {\n-\t    if (m_diag_arg)\n-\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n-\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str,\n-\t\t\t\t\t m_offset, m_diag_arg);\n-\t    else\n-\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n-\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n-\t  }\n-\telse if (m_num_bytes)\n-\t  {\n-\t    if (m_diag_arg)\n-\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n-\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str,\n-\t\t\t\t\t m_offset, m_diag_arg);\n-\t    else\n-\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n-\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n-\t  }\n-\telse\n-\t  {\n-\t    if (m_diag_arg)\n-\t      return ev.formatted_print (\"%s at offset %qE exceeds %qE\",\n-\t\t\t\t\t m_dir_str, m_offset, m_diag_arg);\n-\t    else\n-\t      return ev.formatted_print (\"%s at offset %qE exceeds the\"\n-\t\t\t\t\t \" buffer\", m_dir_str, m_offset);\n-\t  }\n-      }\n-    if (m_diag_arg)\n-      return ev.formatted_print (\"out-of-bounds %s on %qE\",\n-\t\t\t\t m_dir_str, m_diag_arg);\n-    return ev.formatted_print (\"out-of-bounds %s\", m_dir_str);\n-  }\n-\n-protected:\n-  const region *m_reg;\n-  tree m_diag_arg;\n-  tree m_offset;\n-  tree m_num_bytes;\n-  tree m_capacity;\n-  const char *m_dir_str;\n-};\n-\n-/* Concrete subclass to complain about overflows with symbolic values.  */\n-\n-class symbolic_buffer_overflow : public symbolic_past_the_end\n-{\n-public:\n-  symbolic_buffer_overflow (const region *reg, tree diag_arg, tree offset,\n-\t\t\t    tree num_bytes, tree capacity)\n-  : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n-  {\n-    m_dir_str = \"write\";\n-  }\n-\n-  bool emit (rich_location *rich_loc) final override\n-  {\n-    diagnostic_metadata m;\n-    switch (m_reg->get_memory_space ())\n-      {\n-      default:\n-\tm.add_cwe (787);\n-\treturn warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t     \"buffer overflow\");\n-      case MEMSPACE_STACK:\n-\tm.add_cwe (121);\n-\treturn warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t     \"stack-based buffer overflow\");\n-      case MEMSPACE_HEAP:\n-\tm.add_cwe (122);\n-\treturn warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t     \"heap-based buffer overflow\");\n-      }\n-  }\n-};\n-\n-/* Concrete subclass to complain about overreads with symbolic values.  */\n-\n-class symbolic_buffer_overread : public symbolic_past_the_end\n-{\n-public:\n-  symbolic_buffer_overread (const region *reg, tree diag_arg, tree offset,\n-\t\t\t    tree num_bytes, tree capacity)\n-  : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n-  {\n-    m_dir_str = \"read\";\n-  }\n-\n-  bool emit (rich_location *rich_loc) final override\n-  {\n-    diagnostic_metadata m;\n-    m.add_cwe (126);\n-    return warning_meta (rich_loc, m, get_controlling_option (),\n-\t\t\t \"buffer overread\");\n-  }\n-};\n-\n-/* Check whether an access is past the end of the BASE_REG.  */\n-\n-void\n-region_model::check_symbolic_bounds (const region *base_reg,\n-\t\t\t\t     const svalue *sym_byte_offset,\n-\t\t\t\t     const svalue *num_bytes_sval,\n-\t\t\t\t     const svalue *capacity,\n-\t\t\t\t     enum access_direction dir,\n-\t\t\t\t     region_model_context *ctxt) const\n-{\n-  gcc_assert (ctxt);\n-\n-  const svalue *next_byte\n-    = m_mgr->get_or_create_binop (num_bytes_sval->get_type (), PLUS_EXPR,\n-\t\t\t\t  sym_byte_offset, num_bytes_sval);\n-\n-  if (eval_condition (next_byte, GT_EXPR, capacity).is_true ())\n-    {\n-      tree diag_arg = get_representative_tree (base_reg);\n-      tree offset_tree = get_representative_tree (sym_byte_offset);\n-      tree num_bytes_tree = get_representative_tree (num_bytes_sval);\n-      tree capacity_tree = get_representative_tree (capacity);\n-      switch (dir)\n-\t{\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t  break;\n-\tcase DIR_READ:\n-\t  ctxt->warn (make_unique<symbolic_buffer_overread> (base_reg,\n-\t\t\t\t\t\t\t     diag_arg,\n-\t\t\t\t\t\t\t     offset_tree,\n-\t\t\t\t\t\t\t     num_bytes_tree,\n-\t\t\t\t\t\t\t     capacity_tree));\n-\t  break;\n-\tcase DIR_WRITE:\n-\t  ctxt->warn (make_unique<symbolic_buffer_overflow> (base_reg,\n-\t\t\t\t\t\t\t     diag_arg,\n-\t\t\t\t\t\t\t     offset_tree,\n-\t\t\t\t\t\t\t     num_bytes_tree,\n-\t\t\t\t\t\t\t     capacity_tree));\n-\t  break;\n-\t}\n-    }\n-}\n-\n-static tree\n-maybe_get_integer_cst_tree (const svalue *sval)\n-{\n-  tree cst_tree = sval->maybe_get_constant ();\n-  if (cst_tree && TREE_CODE (cst_tree) == INTEGER_CST)\n-    return cst_tree;\n-\n-  return NULL_TREE;\n-}\n-\n-/* May complain when the access on REG is out-of-bounds.  */\n-\n-void\n-region_model::check_region_bounds (const region *reg,\n-\t\t\t\t   enum access_direction dir,\n-\t\t\t\t   region_model_context *ctxt) const\n-{\n-  gcc_assert (ctxt);\n-\n-  /* Get the offset.  */\n-  region_offset reg_offset = reg->get_offset (m_mgr);\n-  const region *base_reg = reg_offset.get_base_region ();\n-\n-  /* Bail out on symbolic regions.\n-     (e.g. because the analyzer did not see previous offsets on the latter,\n-     it might think that a negative access is before the buffer).  */\n-  if (base_reg->symbolic_p ())\n-    return;\n-\n-  /* Find out how many bytes were accessed.  */\n-  const svalue *num_bytes_sval = reg->get_byte_size_sval (m_mgr);\n-  tree num_bytes_tree = maybe_get_integer_cst_tree (num_bytes_sval);\n-  /* Bail out if 0 bytes are accessed.  */\n-  if (num_bytes_tree && zerop (num_bytes_tree))\n-    return;\n-\n-  /* Get the capacity of the buffer.  */\n-  const svalue *capacity = get_capacity (base_reg);\n-  tree cst_capacity_tree = maybe_get_integer_cst_tree (capacity);\n-\n-  /* The constant offset from a pointer is represented internally as a sizetype\n-     but should be interpreted as a signed value here.  The statement below\n-     converts the offset from bits to bytes and then to a signed integer with\n-     the same precision the sizetype has on the target system.\n-\n-     For example, this is needed for out-of-bounds-3.c test1 to pass when\n-     compiled with a 64-bit gcc build targeting 32-bit systems.  */\n-  byte_offset_t offset;\n-  if (!reg_offset.symbolic_p ())\n-    offset = wi::sext (reg_offset.get_bit_offset () >> LOG2_BITS_PER_UNIT,\n-\t\t       TYPE_PRECISION (size_type_node));\n-\n-  /* If either the offset or the number of bytes accessed are symbolic,\n-     we have to reason about symbolic values.  */\n-  if (reg_offset.symbolic_p () || !num_bytes_tree)\n-    {\n-      const svalue* byte_offset_sval;\n-      if (!reg_offset.symbolic_p ())\n-\t{\n-\t  tree offset_tree = wide_int_to_tree (integer_type_node, offset);\n-\t  byte_offset_sval\n-\t    = m_mgr->get_or_create_constant_svalue (offset_tree);\n-\t}\n-      else\n-\tbyte_offset_sval = reg_offset.get_symbolic_byte_offset ();\n-      check_symbolic_bounds (base_reg, byte_offset_sval, num_bytes_sval,\n-\t\t\t     capacity, dir, ctxt);\n-      return;\n-    }\n-\n-  /* Otherwise continue to check with concrete values.  */\n-  byte_range out (0, 0);\n-  /* NUM_BYTES_TREE should always be interpreted as unsigned.  */\n-  byte_offset_t num_bytes_unsigned = wi::to_offset (num_bytes_tree);\n-  byte_range read_bytes (offset, num_bytes_unsigned);\n-  /* If read_bytes has a subset < 0, we do have an underflow.  */\n-  if (read_bytes.falls_short_of_p (0, &out))\n-    {\n-      tree diag_arg = get_representative_tree (base_reg);\n-      switch (dir)\n-\t{\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t  break;\n-\tcase DIR_READ:\n-\t  ctxt->warn (make_unique<buffer_underread> (reg, diag_arg, out));\n-\t  break;\n-\tcase DIR_WRITE:\n-\t  ctxt->warn (make_unique<buffer_underflow> (reg, diag_arg, out));\n-\t  break;\n-\t}\n-    }\n-\n-  /* For accesses past the end, we do need a concrete capacity.  No need to\n-     do a symbolic check here because the inequality check does not reason\n-     whether constants are greater than symbolic values.  */\n-  if (!cst_capacity_tree)\n-    return;\n-\n-  byte_range buffer (0, wi::to_offset (cst_capacity_tree));\n-  /* If READ_BYTES exceeds BUFFER, we do have an overflow.  */\n-  if (read_bytes.exceeds_p (buffer, &out))\n-    {\n-      tree byte_bound = wide_int_to_tree (size_type_node,\n-\t\t\t\t\t  buffer.get_next_byte_offset ());\n-      tree diag_arg = get_representative_tree (base_reg);\n-\n-      switch (dir)\n-\t{\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t  break;\n-\tcase DIR_READ:\n-\t  ctxt->warn (make_unique<buffer_overread> (reg, diag_arg,\n-\t\t\t\t\t\t    out, byte_bound));\n-\t  break;\n-\tcase DIR_WRITE:\n-\t  ctxt->warn (make_unique<buffer_overflow> (reg, diag_arg,\n-\t\t\t\t\t\t    out, byte_bound));\n-\t  break;\n-\t}\n-    }\n-}\n-\n /* Ensure that all arguments at the call described by CD are checked\n    for poisoned values, by calling get_rvalue on each argument.  */\n "}, {"sha": "86bfb4ff8a06b6e18b39f9b7e06f4c5b6528b9fd", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82b361af888a112c1717b3725e836184c6bdedd/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=b82b361af888a112c1717b3725e836184c6bdedd", "patch": "@@ -606,6 +606,8 @@ class region_model\n \t\t\t      region_model_context *ctxt) const;\n   void check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n \t\t\t  region_model_context *ctxt) const;\n+\n+  /* Implemented in bounds-checking.cc  */\n   void check_symbolic_bounds (const region *base_reg,\n \t\t\t      const svalue *sym_byte_offset,\n \t\t\t      const svalue *num_bytes_sval,"}]}