{"sha": "575bfb0052b008995fc992d0728f7bea2173391a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc1YmZiMDA1MmIwMDg5OTVmYzk5MmQwNzI4ZjdiZWEyMTczMzkxYQ==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2011-05-02T22:19:48Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2011-05-02T22:19:48Z"}, "message": "Upgrade the utility of timevars.\n\nIndex: gcc/ChangeLog\n\n2011-04-27  Lawrence Crowl  <crowl@google.com>\n\n\t* timevar.h (timevar_cond_start): Remove unused POP_TIMEVAR_AND_RETURN.\n\t(timevar_cond_start): New for starting a timer only when it is not\n\talready running.\n\t(timevar_cond_stop): New for stopping a timer when it was not already\n\trunning.\n\n\t* timevar.c (timevar_stop): Enable start/stop timers to start again.\n\t(timevar_cond_start): New as above.\n\t(timevar_cond_stop): New as above.\n\n\t* timevar.def: Add start/stop timers for compiler phases,\n\tTV_PHASE_SETUP, TV_PHASE_PARSING, TV_PHASE_DEFERRED, TV_PHASE_CGRAPH,\n\tTV_PHASE_DBGINFO (C), TV_PHASE_CHECK_DBGINFO (C++), TV_PHASE_GENERATE,\n\tand TV_PHASE_FINALIZE.\n\tChange push/pop timer TV_PARSE to TV_PARSE_GLOBAL.\n\tAdd push/pop timers TV_PARSE_STRUCT, TV_PARSE_ENUM, TV_PARSE_FUNC,\n\tTV_PARSE_INLINE, TV_PARSE_INMETH, TV_TEMPLATE_INST.\n\tChange push/pop timer TV_NAME_LOOKUP into a start/stop timer.\n\tMake unused TV_OVERLOAD into a start/stop timer.\n\n\tRemove unused timers TV_OVERLOAD, TV_TEMPLATE_INSTANTIATION.\n\tMark the strings for TV_NAME_LOOKUP and TV_OVERLOAD with a \"|\"\n\tto indicate that they are start/stop timers.\n\n\t* toplev.c (compile_file): Change TV_PARSE to TV_PARSE_GLOBAL.\n\tAdd start/stop timers TV_PHASE_PARSING and TV_PHASE_GENERATE.\n\tMove initialization to do_compile.\n\t(do_compile): Add initialization from above.\n\tAdd start/stop timers TV_PHASE_SETUP and TV_PHASE_FINALIZE.\n\n\t* c-decl.c (c_write_global_declarations): Add start/stop of\n\tTV_PHASE_DEFERRED, TV_PHASE_CGRAPH, TV_PHASE_DBGINFO.\n\n\t* c-parser.c (c_parser_declaration_or_fndef): Push/pop TV_PARSE_FUNC\n\tor TV_PARSE_INLINE, as appropriate.\n\t(c_parser_enum_specifier): Push/pop TV_PARSE_ENUM.\n\t(c_parser_struct_or_union_specifier): Push/pop TV_PARSE_STRUCT.\n\nIndex: gcc/cp/ChangeLog\n\n2011-04-27  Lawrence Crowl  <crowl@google.com>\n\n\t* decl.c: (push_local_name): Change TV_NAME_LOOKUP to start/stop.\n\t(poplevel): Refactor POP_TIMEVAR_AND_RETURN to plain code.\n\tChange TV_NAME_LOOKUP to start/stop.\n\t(define_label): Refactor timevar calls out to a wrapper function.\n\tChange TV_NAME_LOOKUP to start/stop.\n\t(xref_tag): Likewise.\n\t(lookup_label): Refactor timevar calls out to a wrapper function.\n\tChange TV_NAME_LOOKUP to start_cond/stop_cond.\n\n        * pt.c: (instantiate_class_template): Add a wrapper to push/pop new\n\tTV_TEMPLATE_INST.\n\t(instantiate_template): Add a wrapper to push/pop new TV_TEMPLATE_INST.\n\t(lookup_template_class): Refactor timevar calls out to a wrapper\n\tfunction.  Change use of TV_NAME_LOOKUP to TV_TEMPLATE_INST.\n\t(instantiate_decl): Change TV_PARSE to TV_TEMPLATE_INST.\n\n\t* name-lookup.c: (store_bindings): Change TV_NAME_LOOKUP to start/stop.\n\t(poplevel_class): Change TV_NAME_LOOKUP to start_cond/stop_cond.\n\t(push_namespace): Likewise.\n\t(pop_nested_namespace): Likewise.\n\t(pushdecl_namespace_level): Likewise.\n\t(store_class_bindings): Likewise.\n\t(push_to_top_level): Likewise.\n\t(identifier_type_value): Refactor timevar calls out to a wrapper\n\tfunction.  Change TV_NAME_LOOKUP to start/stop.\n\t(find_binding): Likewise.\n\t(push_using_decl): Likewise.\n\t(lookup_arg_dependent): Likewise.\n\t(push_using_directive): Likewise.\n\t(qualified_lookup_using_namespace): Refactor POP_TIMEVAR_AND_RETURN\n\tto plain code.  Change TV_NAME_LOOKUP to start/stop.\n\t(lookup_type_current_level): Likewise.  Refactor inner return to\n\tbreak.\n\t(pushdecl_class_level): Refactor POP_TIMEVAR_AND_RETURN to plain\n\tcode.  Change TV_NAME_LOOKUP to start_cond/stop_cond.\n\t(pushdecl_top_level_1): Likewise.\n\t(lookup_using_namespace): Likewise.\n\t(pushdecl_with_scope): Refactor timevar calls out to a wrapper\n\tfunction.  Change TV_NAME_LOOKUP to start_cond/stop_cond.\n\t(push_overloaded_decl): Likewise.\n\t(push_class_level_binding): Likewise.\n\t(namespace_binding): Likewise.\n\t(set_namespace_binding): Likewise.\n\t(supplement_binding): Likewise.\n\t(unqualified_namespace_lookup): Likewise.\n\t(lookup_name_real): Likewise.\n\t(lookup_type_scope): Likewise.\n\t(namespace_ancestor): Likewise.\n\t(lookup_name_innermost_nonclass_level): Likewise.\n\t(pushtag): Likewise.\n\t(pop_from_top_level): Likewise.\n\t(pushdecl_maybe_friend): Refactor timevar calls out to a wrapper\n\tfunction.  Change TV_NAME_LOOKUP to start_cond/stop_cond.  Wrap long\n\tlines.\n\t(add_using_namespace): Refactor timevar calls out to a wrapper\n\tfunction.  Change TV_NAME_LOOKUP to start_cond/stop_cond.  Bypass\n\twrapper on call to self.\n\n\t* decl2.c: (cp_write_global_declarations):  Add start/stop of\n\tnew TV_PHASE_DEFERRED, TV_PHASE_CGRAPH, TV_PHASE_CHECK_DBGINFO.\n\tRemove push/pop calls to TV_VARCONST.\n\n\t* parser.c: Add include of \"timevar.h\".\n\t(cp_parser_explicit_instantiation): Add push/pop calls to\n\tTV_TEMPLATE_INST.\n\t(cp_parser_enum_specifier): Add push/pop calls to new TV_PARSE_ENUM.\n\t(cp_parser_class_specifier): Add wrapper to add push/pop calls to\n\tTV_PARSE_STRUCT.\n\t(cp_parser_function_definition_from_specifiers_and_declarator): Add\n\tpush/pop calls to new TV_PARSE_FUNC or TV_PARSE_INLINE.\n\t(cp_parser_late_parsing_for_member):  Add push/pop calls to\n\tnew TV_PARSE_INMETH.\n\n\t* call.c: Add include of \"timevar.h\".\n        (convert_class_to_reference): Wrap and add push/pop calls to \n\tTV_OVERLOAD.\n\t(build_op_call): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(build_new_op): Likewise.\n\t(build_new_method_call): Likewise.\n        (build_user_type_conversion): Reorganize to single return and add\n\tpush/pop calls to TV_OVERLOAD.\n        (perform_overload_resolution): Likewise.\n\n\t* Make-lang.in: Add dependence of call.o and parser.o on $(TIMEVAR_H).\n\nFrom-SVN: r173277", "tree": {"sha": "e709db0f9ae81e48e0b44043f323c0d49b1f2a66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e709db0f9ae81e48e0b44043f323c0d49b1f2a66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/575bfb0052b008995fc992d0728f7bea2173391a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575bfb0052b008995fc992d0728f7bea2173391a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/575bfb0052b008995fc992d0728f7bea2173391a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575bfb0052b008995fc992d0728f7bea2173391a/comments", "author": null, "committer": null, "parents": [{"sha": "9c69dcea0d67714ca0ce52317725ccf1644ce93e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c69dcea0d67714ca0ce52317725ccf1644ce93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c69dcea0d67714ca0ce52317725ccf1644ce93e"}], "stats": {"total": 1169, "additions": 907, "deletions": 262}, "files": [{"sha": "026a90b546939f53d5096a0832e0d2c28ba8704c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -1,3 +1,43 @@\n+2011-05-02  Lawrence Crowl  <crowl@google.com>\n+\n+\t* timevar.h (timevar_cond_start): Remove unused POP_TIMEVAR_AND_RETURN.\n+\t(timevar_cond_start): New for starting a timer only when it is not\n+\talready running.\n+\t(timevar_cond_stop): New for stopping a timer when it was not already\n+\trunning.\n+\n+\t* timevar.c (timevar_stop): Enable start/stop timers to start again.\n+\t(timevar_cond_start): New as above.\n+\t(timevar_cond_stop): New as above.\n+\n+\t* timevar.def: Add start/stop timers for compiler phases,\n+\tTV_PHASE_SETUP, TV_PHASE_PARSING, TV_PHASE_DEFERRED, TV_PHASE_CGRAPH,\n+\tTV_PHASE_DBGINFO (C), TV_PHASE_CHECK_DBGINFO (C++), TV_PHASE_GENERATE,\n+\tand TV_PHASE_FINALIZE.\n+\tChange push/pop timer TV_PARSE to TV_PARSE_GLOBAL.\n+\tAdd push/pop timers TV_PARSE_STRUCT, TV_PARSE_ENUM, TV_PARSE_FUNC,\n+\tTV_PARSE_INLINE, TV_PARSE_INMETH, TV_TEMPLATE_INST.\n+\tChange push/pop timer TV_NAME_LOOKUP into a start/stop timer.\n+\tMake unused TV_OVERLOAD into a start/stop timer.\n+\n+\tRemove unused timers TV_OVERLOAD, TV_TEMPLATE_INSTANTIATION.\n+\tMark the strings for TV_NAME_LOOKUP and TV_OVERLOAD with a \"|\"\n+\tto indicate that they are start/stop timers.\n+\n+\t* toplev.c (compile_file): Change TV_PARSE to TV_PARSE_GLOBAL.\n+\tAdd start/stop timers TV_PHASE_PARSING and TV_PHASE_GENERATE.\n+\tMove initialization to do_compile.\n+\t(do_compile): Add initialization from above.\n+\tAdd start/stop timers TV_PHASE_SETUP and TV_PHASE_FINALIZE.\n+\n+\t* c-decl.c (c_write_global_declarations): Add start/stop of\n+\tTV_PHASE_DEFERRED, TV_PHASE_CGRAPH, TV_PHASE_DBGINFO.\n+\n+\t* c-parser.c (c_parser_declaration_or_fndef): Push/pop TV_PARSE_FUNC\n+\tor TV_PARSE_INLINE, as appropriate.\n+\t(c_parser_enum_specifier): Push/pop TV_PARSE_ENUM.\n+\t(c_parser_struct_or_union_specifier): Push/pop TV_PARSE_STRUCT.\n+\n 2011-05-02  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/40975"}, {"sha": "9c6cc90d11a2378e92344a0f2164db3671133f4c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -9837,6 +9837,8 @@ c_write_global_declarations (void)\n   if (pch_file)\n     return;\n \n+  timevar_start (TV_PHASE_DEFERRED);\n+\n   /* Do the Objective-C stuff.  This is where all the Objective-C\n      module stuff gets generated (symtab, class/protocol/selector\n      lists etc).  */\n@@ -9878,10 +9880,16 @@ c_write_global_declarations (void)\n     c_write_global_declarations_1 (BLOCK_VARS (DECL_INITIAL (t)));\n   c_write_global_declarations_1 (BLOCK_VARS (ext_block));\n \n+  timevar_stop (TV_PHASE_DEFERRED);\n+  timevar_start (TV_PHASE_CGRAPH);\n+\n   /* We're done parsing; proceed to optimize and emit assembly.\n      FIXME: shouldn't be the front end's responsibility to call this.  */\n   cgraph_finalize_compilation_unit ();\n \n+  timevar_stop (TV_PHASE_CGRAPH);\n+  timevar_start (TV_PHASE_DBGINFO);\n+\n   /* After cgraph has had a chance to emit everything that's going to\n      be emitted, output debug information for globals.  */\n   if (!seen_error ())\n@@ -9894,6 +9902,7 @@ c_write_global_declarations (void)\n     }\n \n   ext_block = NULL;\n+  timevar_stop (TV_PHASE_DBGINFO);\n }\n \n /* Register reserved keyword WORD as qualifier for address space AS.  */"}, {"sha": "698a080d4527d52bf57b5c587653eb8055cdc2fe", "filename": "gcc/c-parser.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -1570,6 +1570,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n     {\n       struct c_declarator *declarator;\n       bool dummy = false;\n+      timevar_id_t tv;\n       tree fnbody;\n       /* Declaring either one or more declarators (in which case we\n \t should diagnose if there were no declaration specifiers) or a\n@@ -1699,6 +1700,13 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    c_pop_function_context ();\n \t  break;\n \t}\n+\n+      if (DECL_DECLARED_INLINE_P (current_function_decl))\n+        tv = TV_PARSE_INLINE;\n+      else\n+        tv = TV_PARSE_FUNC;\n+      timevar_push (tv);\n+\n       /* Parse old-style parameter declarations.  ??? Attributes are\n \t not allowed to start declaration specifiers here because of a\n \t syntax conflict between a function declaration with attribute\n@@ -1737,6 +1745,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  add_stmt (fnbody);\n \t  finish_function ();\n \t}\n+\n+      timevar_pop (tv);\n       break;\n     }\n }\n@@ -2189,11 +2199,14 @@ c_parser_enum_specifier (c_parser *parser)\n     {\n       /* Parse an enum definition.  */\n       struct c_enum_contents the_enum;\n-      tree type = start_enum (enum_loc, &the_enum, ident);\n+      tree type;\n       tree postfix_attrs;\n       /* We chain the enumerators in reverse order, then put them in\n \t forward order at the end.  */\n-      tree values = NULL_TREE;\n+      tree values;\n+      timevar_push (TV_PARSE_ENUM);\n+      type = start_enum (enum_loc, &the_enum, ident);\n+      values = NULL_TREE;\n       c_parser_consume_token (parser);\n       while (true)\n \t{\n@@ -2257,6 +2270,7 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      timevar_pop (TV_PARSE_ENUM);\n       return ret;\n     }\n   else if (!ident)\n@@ -2370,7 +2384,9 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t semicolon separated fields than comma separated fields, and\n \t so we'll be minimizing the number of node traversals required\n \t by chainon.  */\n-      tree contents = NULL_TREE;\n+      tree contents;\n+      timevar_push (TV_PARSE_STRUCT);\n+      contents = NULL_TREE;\n       c_parser_consume_token (parser);\n       /* Handle the Objective-C @defs construct,\n \t e.g. foo(sizeof(struct{ @defs(ClassName) }));.  */\n@@ -2457,6 +2473,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      timevar_pop (TV_PARSE_STRUCT);\n       return ret;\n     }\n   else if (!ident)"}, {"sha": "e44ff10d9fbd5c638a3f28b2ae5e5e7b1a991090", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -1,3 +1,91 @@\n+2011-05-02  Lawrence Crowl  <crowl@google.com>\n+\n+\t* decl.c: (push_local_name): Change TV_NAME_LOOKUP to start/stop.\n+\t(poplevel): Refactor POP_TIMEVAR_AND_RETURN to plain code.\n+\tChange TV_NAME_LOOKUP to start/stop.\n+\t(define_label): Refactor timevar calls out to a wrapper function.\n+\tChange TV_NAME_LOOKUP to start/stop.\n+\t(xref_tag): Likewise.\n+\t(lookup_label): Refactor timevar calls out to a wrapper function.\n+\tChange TV_NAME_LOOKUP to start_cond/stop_cond.\n+\n+        * pt.c: (instantiate_class_template): Add a wrapper to push/pop new\n+\tTV_TEMPLATE_INST.\n+\t(instantiate_template): Add a wrapper to push/pop new TV_TEMPLATE_INST.\n+\t(lookup_template_class): Refactor timevar calls out to a wrapper\n+\tfunction.  Change use of TV_NAME_LOOKUP to TV_TEMPLATE_INST.\n+\t(instantiate_decl): Change TV_PARSE to TV_TEMPLATE_INST.\n+\n+\t* name-lookup.c: (store_bindings): Change TV_NAME_LOOKUP to start/stop.\n+\t(poplevel_class): Change TV_NAME_LOOKUP to start_cond/stop_cond.\n+\t(push_namespace): Likewise.\n+\t(pop_nested_namespace): Likewise.\n+\t(pushdecl_namespace_level): Likewise.\n+\t(store_class_bindings): Likewise.\n+\t(push_to_top_level): Likewise.\n+\t(identifier_type_value): Refactor timevar calls out to a wrapper\n+\tfunction.  Change TV_NAME_LOOKUP to start/stop.\n+\t(find_binding): Likewise.\n+\t(push_using_decl): Likewise.\n+\t(lookup_arg_dependent): Likewise.\n+\t(push_using_directive): Likewise.\n+\t(qualified_lookup_using_namespace): Refactor POP_TIMEVAR_AND_RETURN\n+\tto plain code.  Change TV_NAME_LOOKUP to start/stop.\n+\t(lookup_type_current_level): Likewise.  Refactor inner return to\n+\tbreak.\n+\t(pushdecl_class_level): Refactor POP_TIMEVAR_AND_RETURN to plain\n+\tcode.  Change TV_NAME_LOOKUP to start_cond/stop_cond.\n+\t(pushdecl_top_level_1): Likewise.\n+\t(lookup_using_namespace): Likewise.\n+\t(pushdecl_with_scope): Refactor timevar calls out to a wrapper\n+\tfunction.  Change TV_NAME_LOOKUP to start_cond/stop_cond.\n+\t(push_overloaded_decl): Likewise.\n+\t(push_class_level_binding): Likewise.\n+\t(namespace_binding): Likewise.\n+\t(set_namespace_binding): Likewise.\n+\t(supplement_binding): Likewise.\n+\t(unqualified_namespace_lookup): Likewise.\n+\t(lookup_name_real): Likewise.\n+\t(lookup_type_scope): Likewise.\n+\t(namespace_ancestor): Likewise.\n+\t(lookup_name_innermost_nonclass_level): Likewise.\n+\t(pushtag): Likewise.\n+\t(pop_from_top_level): Likewise.\n+\t(pushdecl_maybe_friend): Refactor timevar calls out to a wrapper\n+\tfunction.  Change TV_NAME_LOOKUP to start_cond/stop_cond.  Wrap long\n+\tlines.\n+\t(add_using_namespace): Refactor timevar calls out to a wrapper\n+\tfunction.  Change TV_NAME_LOOKUP to start_cond/stop_cond.  Bypass\n+\twrapper on call to self.\n+\n+\t* decl2.c: (cp_write_global_declarations):  Add start/stop of\n+\tnew TV_PHASE_DEFERRED, TV_PHASE_CGRAPH, TV_PHASE_CHECK_DBGINFO.\n+\tRemove push/pop calls to TV_VARCONST.\n+\n+\t* parser.c: Add include of \"timevar.h\".\n+\t(cp_parser_explicit_instantiation): Add push/pop calls to\n+\tTV_TEMPLATE_INST.\n+\t(cp_parser_enum_specifier): Add push/pop calls to new TV_PARSE_ENUM.\n+\t(cp_parser_class_specifier): Add wrapper to add push/pop calls to\n+\tTV_PARSE_STRUCT.\n+\t(cp_parser_function_definition_from_specifiers_and_declarator): Add\n+\tpush/pop calls to new TV_PARSE_FUNC or TV_PARSE_INLINE.\n+\t(cp_parser_late_parsing_for_member):  Add push/pop calls to\n+\tnew TV_PARSE_INMETH.\n+\n+\t* call.c: Add include of \"timevar.h\".\n+        (convert_class_to_reference): Wrap and add push/pop calls to \n+\tTV_OVERLOAD.\n+\t(build_op_call): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(build_new_op): Likewise.\n+\t(build_new_method_call): Likewise.\n+        (build_user_type_conversion): Reorganize to single return and add\n+\tpush/pop calls to TV_OVERLOAD.\n+        (perform_overload_resolution): Likewise.\n+\n+\t* Make-lang.in: Add dependence of call.o and parser.o on $(TIMEVAR_H).\n+\n 2011-05-02  Jason Merrill  <jason@redhat.com>\n \n \t* tree.c (build_vec_init_expr): Take complain parm."}, {"sha": "22a58464560b763c3aece3956ed9347e8d74673d", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -287,7 +287,7 @@ cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h \\\n   $(SPLAY_TREE_H)\n cp/call.o: cp/call.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h \\\n   $(DIAGNOSTIC_CORE_H) intl.h gt-cp-call.h convert.h $(TARGET_H) langhooks.h \\\n-  c-family/c-objc.h\n+  $(TIMEVAR_H) c-family/c-objc.h\n cp/friend.o: cp/friend.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H)\n cp/init.o: cp/init.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n   $(EXCEPT_H) $(TARGET_H)\n@@ -326,7 +326,7 @@ cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H) $(CGRAPH_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n   gt-cp-parser.h output.h $(TARGET_H) $(PLUGIN_H) intl.h \\\n-  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H)\n+  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR.H)\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h\n "}, {"sha": "4dbcce922ee5b26ddf2e6f96d4a9d36e23a63f74", "filename": "gcc/cp/call.c", "status": "modified", "additions": 110, "deletions": 25, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"convert.h\"\n #include \"langhooks.h\"\n #include \"c-family/c-objc.h\"\n+#include \"timevar.h\"\n \n /* The various kinds of conversion.  */\n \n@@ -1263,7 +1264,7 @@ reference_compatible_p (tree t1, tree t2)\n    converted to T as in [over.match.ref].  */\n \n static conversion *\n-convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n+convert_class_to_reference_1 (tree reference_type, tree s, tree expr, int flags)\n {\n   tree conversions;\n   tree first_arg;\n@@ -1399,6 +1400,18 @@ convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n   return cand->second_conv;\n }\n \n+/* Wrapper for above.  */\n+\n+static conversion *\n+convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n+{\n+  conversion *ret;\n+  bool subtime = timevar_cond_start (TV_OVERLOAD);\n+  ret = convert_class_to_reference_1 (reference_type, s, expr, flags);\n+  timevar_cond_stop (TV_OVERLOAD, subtime);\n+  return ret;\n+}\n+\n /* A reference of the indicated TYPE is being bound directly to the\n    expression represented by the implicit conversion sequence CONV.\n    Return a conversion sequence for this binding.  */\n@@ -3493,20 +3506,32 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   return cand;\n }\n \n+/* Wrapper for above. */\n+\n tree\n build_user_type_conversion (tree totype, tree expr, int flags)\n {\n-  struct z_candidate *cand\n-    = build_user_type_conversion_1 (totype, expr, flags);\n+  struct z_candidate *cand;\n+  tree ret;\n+\n+  timevar_start (TV_OVERLOAD);\n+  cand = build_user_type_conversion_1 (totype, expr, flags);\n \n   if (cand)\n     {\n       if (cand->second_conv->kind == ck_ambig)\n-\treturn error_mark_node;\n-      expr = convert_like (cand->second_conv, expr, tf_warning_or_error);\n-      return convert_from_reference (expr);\n+\tret = error_mark_node;\n+      else\n+        {\n+          expr = convert_like (cand->second_conv, expr, tf_warning_or_error);\n+          ret = convert_from_reference (expr);\n+        }\n     }\n-  return NULL_TREE;\n+  else\n+    ret = NULL_TREE;\n+\n+  timevar_stop (TV_OVERLOAD);\n+  return ret;\n }\n \n /* Subroutine of convert_nontype_argument.\n@@ -3622,8 +3647,13 @@ perform_overload_resolution (tree fn,\n \t\t\t     bool *any_viable_p)\n {\n   struct z_candidate *cand;\n-  tree explicit_targs = NULL_TREE;\n-  int template_only = 0;\n+  tree explicit_targs;\n+  int template_only;\n+\n+  bool subtime = timevar_cond_start (TV_OVERLOAD);\n+\n+  explicit_targs = NULL_TREE;\n+  template_only = 0;\n \n   *candidates = NULL;\n   *any_viable_p = true;\n@@ -3650,10 +3680,12 @@ perform_overload_resolution (tree fn,\n \t\t  candidates);\n \n   *candidates = splice_viable (*candidates, pedantic, any_viable_p);\n-  if (!*any_viable_p)\n-    return NULL;\n+  if (*any_viable_p)\n+    cand = tourney (*candidates);\n+  else\n+    cand = NULL;\n \n-  cand = tourney (*candidates);\n+  timevar_cond_stop (TV_OVERLOAD, subtime);\n   return cand;\n }\n \n@@ -3852,8 +3884,8 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n \n /* Build a new call to operator().  This may change ARGS.  */\n \n-tree\n-build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n+static tree\n+build_op_call_1 (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, first_mem_arg = NULL_TREE;\n@@ -3984,6 +4016,18 @@ build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n   return result;\n }\n \n+/* Wrapper for above.  */\n+\n+tree\n+build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n+{\n+  tree ret;\n+  timevar_start (TV_OVERLOAD);\n+  ret = build_op_call_1 (obj, args, complain);\n+  timevar_stop (TV_OVERLOAD);\n+  return ret;\n+}\n+\n static void\n op_error (enum tree_code code, enum tree_code code2,\n \t  tree arg1, tree arg2, tree arg3, bool match)\n@@ -4121,9 +4165,9 @@ conditional_conversion (tree e1, tree e2)\n /* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three\n    arguments to the conditional expression.  */\n \n-tree\n-build_conditional_expr (tree arg1, tree arg2, tree arg3,\n-                        tsubst_flags_t complain)\n+static tree\n+build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n+                          tsubst_flags_t complain)\n {\n   tree arg2_type;\n   tree arg3_type;\n@@ -4552,6 +4596,19 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n   return result;\n }\n \n+/* Wrapper for above.  */\n+\n+tree\n+build_conditional_expr (tree arg1, tree arg2, tree arg3,\n+                        tsubst_flags_t complain)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_OVERLOAD);\n+  ret = build_conditional_expr_1 (arg1, arg2, arg3, complain);\n+  timevar_cond_stop (TV_OVERLOAD, subtime);\n+  return ret;\n+}\n+\n /* OPERAND is an operand to an expression.  Perform necessary steps\n    required before using it.  If OPERAND is NULL_TREE, NULL_TREE is\n    returned.  */\n@@ -4720,8 +4777,8 @@ avoid_sign_compare_warnings (tree orig_arg, tree arg)\n     TREE_NO_WARNING (arg) = 1;\n }\n \n-tree\n-build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n+static tree\n+build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t      bool *overloaded_p, tsubst_flags_t complain)\n {\n   tree orig_arg1 = arg1;\n@@ -4888,8 +4945,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t    code = PREINCREMENT_EXPR;\n \t  else\n \t    code = PREDECREMENT_EXPR;\n-\t  result = build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE,\n-\t\t\t\t overloaded_p, complain);\n+\t  result = build_new_op_1 (code, flags, arg1, NULL_TREE, NULL_TREE,\n+\t\t\t\t   overloaded_p, complain);\n \t  break;\n \n \t  /* The caller will deal with these.  */\n@@ -5092,6 +5149,19 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   return NULL_TREE;\n }\n \n+/* Wrapper for above.  */\n+\n+tree\n+build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n+\t      bool *overloaded_p, tsubst_flags_t complain)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_OVERLOAD);\n+  ret = build_new_op_1 (code, flags, arg1, arg2, arg3, overloaded_p, complain);\n+  timevar_cond_stop (TV_OVERLOAD, subtime);\n+  return ret;\n+}\n+\n /* Returns true iff T, an element of an OVERLOAD chain, is a usual\n    deallocation function (3.7.4.2 [basic.stc.dynamic.deallocation]).  */\n \n@@ -6862,10 +6932,10 @@ name_as_c_string (tree name, tree type, bool *free_p)\n    be set, upon return, to the function called.  ARGS may be NULL.\n    This may change ARGS.  */\n \n-tree\n-build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n-\t\t       tree conversion_path, int flags,\n-\t\t       tree *fn_p, tsubst_flags_t complain)\n+static tree\n+build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n+\t\t         tree conversion_path, int flags,\n+\t\t         tree *fn_p, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree explicit_targs = NULL_TREE;\n@@ -7171,6 +7241,21 @@ build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n   return call;\n }\n \n+/* Wrapper for above.  */\n+\n+tree\n+build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n+\t\t       tree conversion_path, int flags,\n+\t\t       tree *fn_p, tsubst_flags_t complain)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_OVERLOAD);\n+  ret = build_new_method_call_1 (instance, fns, args, conversion_path, flags,\n+                                 fn_p, complain);\n+  timevar_cond_stop (TV_OVERLOAD, subtime);\n+  return ret;\n+}\n+\n /* Returns true iff standard conversion sequence ICS1 is a proper\n    subsequence of ICS2.  */\n "}, {"sha": "e489caefd0b829a1e35cefa64e876cc52bf8bbdb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 62, "deletions": 27, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -552,7 +552,7 @@ poplevel (int keep, int reverse, int functionbody)\n   unsigned ix;\n   cp_label_binding *label_bind;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  timevar_start (TV_NAME_LOOKUP);\n  restart:\n \n   block = NULL_TREE;\n@@ -815,7 +815,8 @@ poplevel (int keep, int reverse, int functionbody)\n   if (kind == sk_cleanup)\n     goto restart;\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, block);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return block;\n }\n \n /* Walk all the namespaces contained NAMESPACE, including NAMESPACE\n@@ -899,7 +900,7 @@ push_local_name (tree decl)\n   size_t i, nelts;\n   tree t, name;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  timevar_start (TV_NAME_LOOKUP);\n \n   name = DECL_NAME (decl);\n \n@@ -918,13 +919,13 @@ push_local_name (tree decl)\n \t    DECL_DISCRIMINATOR (decl) = 1;\n \n \t  VEC_replace (tree, local_names, i, decl);\n-\t  timevar_pop (TV_NAME_LOOKUP);\n+\t  timevar_stop (TV_NAME_LOOKUP);\n \t  return;\n \t}\n     }\n \n   VEC_safe_push (tree, gc, local_names, decl);\n-  timevar_pop (TV_NAME_LOOKUP);\n+  timevar_stop (TV_NAME_LOOKUP);\n }\n \f\n /* Subroutine of duplicate_decls: return truthvalue of whether\n@@ -2535,26 +2536,37 @@ make_label_decl (tree id, int local_p)\n    be found, create one.  (We keep track of used, but undefined,\n    labels, and complain about them at the end of a function.)  */\n \n-tree\n-lookup_label (tree id)\n+static tree\n+lookup_label_1 (tree id)\n {\n   tree decl;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   /* You can't use labels at global scope.  */\n   if (current_function_decl == NULL_TREE)\n     {\n       error (\"label %qE referenced outside of any function\", id);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+      return NULL_TREE;\n     }\n \n   /* See if we've already got this label.  */\n   decl = IDENTIFIER_LABEL_VALUE (id);\n   if (decl != NULL_TREE && DECL_CONTEXT (decl) == current_function_decl)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+    return decl;\n \n   decl = make_label_decl (id, /*local_p=*/0);\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+  return decl;\n+}\n+\n+/* Wrapper for lookup_label_1.  */\n+\n+tree\n+lookup_label (tree id)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = lookup_label_1 (id);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \n /* Declare a local label named ID.  */\n@@ -2827,15 +2839,13 @@ check_omp_return (void)\n /* Define a label, specifying the location in the source file.\n    Return the LABEL_DECL node for the label.  */\n \n-tree\n-define_label (location_t location, tree name)\n+static tree\n+define_label_1 (location_t location, tree name)\n {\n   struct named_label_entry *ent, dummy;\n   struct cp_binding_level *p;\n   tree decl;\n \n-  timevar_push (TV_NAME_LOOKUP);\n-\n   decl = lookup_label (name);\n \n   dummy.label_decl = decl;\n@@ -2855,7 +2865,7 @@ define_label (location_t location, tree name)\n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {\n       error (\"duplicate label %qD\", decl);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+      return error_mark_node;\n     }\n   else\n     {\n@@ -2874,9 +2884,22 @@ define_label (location_t location, tree name)\n       ent->uses = NULL;\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+  return decl;\n }\n \n+/* Wrapper for define_label_1.  */\n+\n+tree\n+define_label (location_t location, tree name)\n+{\n+  tree ret;\n+  timevar_start (TV_NAME_LOOKUP);\n+  ret = define_label_1 (location, name);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return ret;\n+}\n+\n+\n struct cp_switch\n {\n   struct cp_binding_level *level;\n@@ -11262,16 +11285,14 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n    TEMPLATE_HEADER_P is true when this declaration is preceded by\n    a set of template parameters.  */\n \n-tree\n-xref_tag (enum tag_types tag_code, tree name,\n-\t  tag_scope scope, bool template_header_p)\n+static tree\n+xref_tag_1 (enum tag_types tag_code, tree name,\n+            tag_scope scope, bool template_header_p)\n {\n   enum tree_code code;\n   tree t;\n   tree context = NULL_TREE;\n \n-  timevar_push (TV_NAME_LOOKUP);\n-\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   switch (tag_code)\n@@ -11299,7 +11320,7 @@ xref_tag (enum tag_types tag_code, tree name,\n \t\t\t       scope, template_header_p);\n \n   if (t == error_mark_node)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+    return error_mark_node;\n \n   if (scope != ts_current && t && current_class_type\n       && template_class_depth (current_class_type)\n@@ -11354,7 +11375,7 @@ xref_tag (enum tag_types tag_code, tree name,\n       if (code == ENUMERAL_TYPE)\n \t{\n \t  error (\"use of enum %q#D without previous declaration\", name);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t  return error_mark_node;\n \t}\n       else\n \t{\n@@ -11368,15 +11389,15 @@ xref_tag (enum tag_types tag_code, tree name,\n       if (template_header_p && MAYBE_CLASS_TYPE_P (t))\n         {\n \t  if (!redeclare_class_template (t, current_template_parms))\n-            POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+            return error_mark_node;\n         }\n       else if (!processing_template_decl\n \t       && CLASS_TYPE_P (t)\n \t       && CLASSTYPE_IS_TEMPLATE (t))\n \t{\n \t  error (\"redeclaration of %qT as a non-template\", t);\n \t  error (\"previous declaration %q+D\", t);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t  return error_mark_node;\n \t}\n \n       /* Make injected friend class visible.  */\n@@ -11394,9 +11415,23 @@ xref_tag (enum tag_types tag_code, tree name,\n \t}\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+  return t;\n+}\n+\n+/* Wrapper for xref_tag_1.  */\n+\n+tree\n+xref_tag (enum tag_types tag_code, tree name,\n+          tag_scope scope, bool template_header_p)\n+{\n+  tree ret;\n+  timevar_start (TV_NAME_LOOKUP);\n+  ret = xref_tag_1 (tag_code, name, scope, template_header_p);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return ret;\n }\n \n+\n tree\n xref_tag_from_type (tree old, tree id, tag_scope scope)\n {"}, {"sha": "ef8de31b8077b7d2c1396ae932384e32eae0381b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -3678,6 +3678,8 @@ cp_write_global_declarations (void)\n \n   /* FIXME - huh?  was  input_line -= 1;*/\n \n+  timevar_start (TV_PHASE_DEFERRED);\n+\n   /* We now have to write out all the stuff we put off writing out.\n      These include:\n \n@@ -3694,8 +3696,6 @@ cp_write_global_declarations (void)\n      generating the initializer for an object may cause templates to be\n      instantiated, etc., etc.  */\n \n-  timevar_push (TV_VARCONST);\n-\n   emit_support_tinfos ();\n \n   do\n@@ -4002,8 +4002,14 @@ cp_write_global_declarations (void)\n   /* Collect candidates for Java hidden aliases.  */\n   candidates = collect_candidates_for_java_method_aliases ();\n \n+  timevar_stop (TV_PHASE_DEFERRED);\n+  timevar_start (TV_PHASE_CGRAPH);\n+\n   cgraph_finalize_compilation_unit ();\n \n+  timevar_stop (TV_PHASE_CGRAPH);\n+  timevar_start (TV_PHASE_CHECK_DBGINFO);\n+\n   /* Now, issue warnings about static, but not defined, functions,\n      etc., and emit debugging information.  */\n   walk_namespaces (wrapup_globals_for_namespace, /*data=*/&reconsider);\n@@ -4039,8 +4045,6 @@ cp_write_global_declarations (void)\n       }\n   }\n \n-  timevar_pop (TV_VARCONST);\n-\n   if (flag_detailed_statistics)\n     {\n       dump_tree_statistics ();\n@@ -4051,6 +4055,8 @@ cp_write_global_declarations (void)\n #ifdef ENABLE_CHECKING\n   validate_conversion_obstack ();\n #endif /* ENABLE_CHECKING */\n+\n+  timevar_stop (TV_PHASE_CHECK_DBGINFO);\n }\n \n /* FN is an OFFSET_REF, DOTSTAR_EXPR or MEMBER_REF indicating the"}, {"sha": "e1cf1cf0f1db6ba9920aec99559d734e1a0ffbd5", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 364, "deletions": 151, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -434,12 +434,11 @@ pop_binding (tree id, tree decl)\n    was successful.  */\n \n static bool\n-supplement_binding (cxx_binding *binding, tree decl)\n+supplement_binding_1 (cxx_binding *binding, tree decl)\n {\n   tree bval = binding->value;\n   bool ok = true;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n     /* The new name is the type name.  */\n     binding->type = decl;\n@@ -526,7 +525,19 @@ supplement_binding (cxx_binding *binding, tree decl)\n       ok = false;\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ok);\n+  return ok;\n+}\n+\n+/* Wrapper for supplement_binding_1.  */\n+\n+static bool\n+supplement_binding (cxx_binding *binding, tree decl)\n+{\n+  bool ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = supplement_binding_1 (binding, decl);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \n /* Add DECL to the list of things declared in B.  */\n@@ -574,17 +585,15 @@ add_decl_to_level (tree decl, cxx_scope *b)\n    If an old decl is returned, it may have been smashed\n    to agree with what X says.  */\n \n-tree\n-pushdecl_maybe_friend (tree x, bool is_friend)\n+static tree\n+pushdecl_maybe_friend_1 (tree x, bool is_friend)\n {\n   tree t;\n   tree name;\n   int need_new_binding;\n \n-  timevar_push (TV_NAME_LOOKUP);\n-\n   if (x == error_mark_node)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+    return error_mark_node;\n \n   need_new_binding = 1;\n \n@@ -720,7 +729,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t      /* Check for duplicate params.  */\n \t      tree d = duplicate_decls (x, t, is_friend);\n \t      if (d)\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, d);\n+\t\treturn d;\n \t    }\n \t  else if ((DECL_EXTERN_C_FUNCTION_P (x)\n \t\t    || DECL_FUNCTION_TEMPLATE_P (x))\n@@ -733,7 +742,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t\t TREE_TYPE (x));\n \t      \n \t      /* Throw away the redeclaration.  */\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t      return t;\n \t    }\n \t  else\n \t    {\n@@ -742,14 +751,14 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t      /* If the redeclaration failed, we can stop at this\n \t\t point.  */\n \t      if (olddecl == error_mark_node)\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t\treturn error_mark_node;\n \n \t      if (olddecl)\n \t\t{\n \t\t  if (TREE_CODE (t) == TYPE_DECL)\n \t\t    SET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n \n-\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t\t  return t;\n \t\t}\n \t      else if (DECL_MAIN_P (x) && TREE_CODE (t) == FUNCTION_DECL)\n \t\t{\n@@ -763,7 +772,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t  error (\"as %qD\", x);\n \t\t  /* We don't try to push this declaration since that\n \t\t     causes a crash.  */\n-\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+\t\t  return x;\n \t\t}\n \t    }\n \t}\n@@ -806,12 +815,15 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t\t\t\t  x_exception_spec,\n \t\t\t\t\t  ce_normal))\n \t\t    {\n-\t\t      pedwarn (input_location, 0, \"declaration of %q#D with C language linkage\",\n+\t\t      pedwarn (input_location, 0,\n+                               \"declaration of %q#D with C language linkage\",\n \t\t\t       x);\n-\t\t      pedwarn (input_location, 0, \"conflicts with previous declaration %q+#D\",\n+\t\t      pedwarn (input_location, 0,\n+                               \"conflicts with previous declaration %q+#D\",\n \t\t\t       previous);\n-\t\t      pedwarn (input_location, 0, \"due to different exception specifications\");\n-\t\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t\t      pedwarn (input_location, 0,\n+                               \"due to different exception specifications\");\n+\t\t      return error_mark_node;\n \t\t    }\n \t\t}\n \t      else\n@@ -856,7 +868,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \tcheck_default_args (t);\n \n       if (t != x || DECL_FUNCTION_TEMPLATE_P (t))\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\treturn t;\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n \t at line 0), and install this TYPE_DECL as the new type's typedef\n@@ -1143,7 +1155,19 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n \t\t       : current_binding_level);\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+  return x;\n+}\n+\n+/* Wrapper for pushdecl_maybe_friend_1.  */\n+\n+tree\n+pushdecl_maybe_friend (tree x, bool is_friend)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = pushdecl_maybe_friend_1 (x, is_friend);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \n /* Record a decl-node X as belonging to the current lexical scope.  */\n@@ -1754,26 +1778,38 @@ print_binding_stack (void)\n   print_binding_level (NAMESPACE_LEVEL (global_namespace));\n }\n \f\n-/* Return the type associated with id.  */\n+/* Return the type associated with ID.  */\n \n-tree\n-identifier_type_value (tree id)\n+static tree\n+identifier_type_value_1 (tree id)\n {\n-  timevar_push (TV_NAME_LOOKUP);\n   /* There is no type with that name, anywhere.  */\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+    return NULL_TREE;\n   /* This is not the type marker, but the real thing.  */\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, REAL_IDENTIFIER_TYPE_VALUE (id));\n+    return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types.  */\n   id = lookup_name_real (id, 2, 1, /*block_p=*/true, 0, LOOKUP_COMPLAIN);\n   if (id)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_TYPE (id));\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+    return TREE_TYPE (id);\n+  return NULL_TREE;\n }\n \n+/* Wrapper for identifier_type_value_1.  */\n+\n+tree\n+identifier_type_value (tree id)\n+{\n+  tree ret;\n+  timevar_start (TV_NAME_LOOKUP);\n+  ret = identifier_type_value_1 (id);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return ret;\n+}\n+\n+\n /* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since\n    the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */\n \n@@ -1914,13 +1950,11 @@ make_lambda_name (void)\n static inline cxx_binding *\n find_binding (cxx_scope *scope, cxx_binding *binding)\n {\n-  timevar_push (TV_NAME_LOOKUP);\n-\n   for (; binding != NULL; binding = binding->previous)\n     if (binding->scope == scope)\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, binding);\n+      return binding;\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (cxx_binding *)0);\n+  return (cxx_binding *)0;\n }\n \n /* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */\n@@ -1999,36 +2033,45 @@ lookup_extern_c_fun_binding_in_all_ns (tree function)\n    scope, a using decl might extend any previous bindings).  */\n \n static tree\n-push_using_decl (tree scope, tree name)\n+push_using_decl_1 (tree scope, tree name)\n {\n   tree decl;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   gcc_assert (TREE_CODE (scope) == NAMESPACE_DECL);\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n   for (decl = current_binding_level->usings; decl; decl = DECL_CHAIN (decl))\n     if (USING_DECL_SCOPE (decl) == scope && DECL_NAME (decl) == name)\n       break;\n   if (decl)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-\t\t\t    namespace_bindings_p () ? decl : NULL_TREE);\n+    return namespace_bindings_p () ? decl : NULL_TREE;\n   decl = build_lang_decl (USING_DECL, name, NULL_TREE);\n   USING_DECL_SCOPE (decl) = scope;\n   DECL_CHAIN (decl) = current_binding_level->usings;\n   current_binding_level->usings = decl;\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+  return decl;\n+}\n+\n+/* Wrapper for push_using_decl_1.  */\n+\n+static tree\n+push_using_decl (tree scope, tree name)\n+{\n+  tree ret;\n+  timevar_start (TV_NAME_LOOKUP);\n+  ret = push_using_decl_1 (scope, name);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return ret;\n }\n \n /* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the\n    caller to set DECL_CONTEXT properly.  */\n \n-tree\n-pushdecl_with_scope (tree x, cxx_scope *level, bool is_friend)\n+static tree\n+pushdecl_with_scope_1 (tree x, cxx_scope *level, bool is_friend)\n {\n   struct cp_binding_level *b;\n   tree function_decl = current_function_decl;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   current_function_decl = NULL_TREE;\n   if (level->kind == sk_class)\n     {\n@@ -2045,8 +2088,21 @@ pushdecl_with_scope (tree x, cxx_scope *level, bool is_friend)\n       current_binding_level = b;\n     }\n   current_function_decl = function_decl;\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+  return x;\n }\n+ \n+/* Wrapper for pushdecl_with_scope_1.  */\n+\n+tree\n+pushdecl_with_scope (tree x, cxx_scope *level, bool is_friend)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = pushdecl_with_scope_1 (x, level, is_friend);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n+}\n+\n \n /* DECL is a FUNCTION_DECL for a non-member function, which may have\n    other definitions already in place.  We get around this by making\n@@ -2070,14 +2126,13 @@ pushdecl_with_scope (tree x, cxx_scope *level, bool is_friend)\n    it's always DECL (and never something that's not a _DECL).  */\n \n static tree\n-push_overloaded_decl (tree decl, int flags, bool is_friend)\n+push_overloaded_decl_1 (tree decl, int flags, bool is_friend)\n {\n   tree name = DECL_NAME (decl);\n   tree old;\n   tree new_binding;\n   int doing_global = (namespace_bindings_p () || !(flags & PUSH_LOCAL));\n \n-  timevar_push (TV_NAME_LOOKUP);\n   if (doing_global)\n     old = namespace_binding (name, DECL_CONTEXT (decl));\n   else\n@@ -2115,7 +2170,7 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n \t      /* If DECL was a redeclaration of FN -- even an invalid\n \t\t one -- pass that information along to our caller.  */\n \t      if (dup == fn || dup == error_mark_node)\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, dup);\n+\t\treturn dup;\n \t    }\n \n \t  /* We don't overload implicit built-ins.  duplicate_decls()\n@@ -2133,7 +2188,7 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n \t{\n \t  error (\"previous non-function declaration %q+#D\", old);\n \t  error (\"conflicts with function declaration %q#D\", decl);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+\t  return decl;\n \t}\n     }\n \n@@ -2185,7 +2240,7 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n \n \t\t/* And update the cxx_binding node.  */\n \t\tIDENTIFIER_BINDING (name)->value = new_binding;\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+\t\treturn decl;\n \t      }\n \n \t  /* We should always find a previous binding in this case.  */\n@@ -2196,7 +2251,19 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n       push_local_binding (name, new_binding, flags);\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+  return decl;\n+}\n+\n+/* Wrapper for push_overloaded_decl_1.  */\n+\n+static tree\n+push_overloaded_decl (tree decl, int flags, bool is_friend)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = push_overloaded_decl_1 (decl, flags, is_friend);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \n /* Check a non-member using-declaration. Return the name and scope\n@@ -2643,7 +2710,7 @@ poplevel_class (void)\n   size_t i;\n   tree shadowed;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   gcc_assert (level != 0);\n \n   /* If we're leaving a toplevel class, cache its binding level.  */\n@@ -2667,7 +2734,7 @@ poplevel_class (void)\n      `pushlevel_class' routine.  */\n   gcc_assert (current_binding_level == level);\n   leave_scope ();\n-  timevar_pop (TV_NAME_LOOKUP);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Set INHERITED_VALUE_BINDING_P on BINDING to true or false, as\n@@ -2711,13 +2778,14 @@ pushdecl_class_level (tree x)\n {\n   tree name;\n   bool is_valid = true;\n+  bool subtime;\n \n   /* Do nothing if we're adding to an outer lambda closure type,\n      outer_binding will add it later if it's needed.  */\n   if (current_class_type != class_binding_level->this_entity)\n     return true;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   /* Get the name of X.  */\n   if (TREE_CODE (x) == OVERLOAD)\n     name = DECL_NAME (get_first_fn (x));\n@@ -2746,7 +2814,8 @@ pushdecl_class_level (tree x)\n \t  input_location = save_location;\n \t}\n     }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, is_valid);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return is_valid;\n }\n \n /* Return the BINDING (if any) for NAME in SCOPE, which is a class\n@@ -2813,21 +2882,20 @@ get_class_binding (tree name, cxx_scope *scope)\n /* Make the declaration(s) of X appear in CLASS scope under the name\n    NAME.  Returns true if the binding is valid.  */\n \n-bool\n-push_class_level_binding (tree name, tree x)\n+static bool\n+push_class_level_binding_1 (tree name, tree x)\n {\n   cxx_binding *binding;\n   tree decl = x;\n   bool ok;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n   if (!class_binding_level)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+    return true;\n \n   if (name == error_mark_node)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+    return false;\n \n   /* Check for invalid member names.  */\n   gcc_assert (TYPE_BEING_DEFINED (current_class_type));\n@@ -2842,7 +2910,7 @@ push_class_level_binding (tree name, tree x)\n     decl = TREE_VALUE (decl);\n \n   if (!check_template_shadow (decl))\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+    return false;\n \n   /* [class.mem]\n \n@@ -2876,7 +2944,7 @@ push_class_level_binding (tree name, tree x)\n \t  error (\"%qD has the same name as the class in which it is \"\n \t\t \"declared\",\n \t\t x);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+\t  return false;\n \t}\n     }\n \n@@ -2927,11 +2995,11 @@ push_class_level_binding (tree name, tree x)\n       else if (TREE_CODE (x) == OVERLOAD && is_overloaded_fn (bval))\n \told_decl = bval;\n       else if (TREE_CODE (x) == USING_DECL && TREE_CODE (bval) == USING_DECL)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+\treturn true;\n       else if (TREE_CODE (x) == USING_DECL && is_overloaded_fn (bval))\n \told_decl = bval;\n       else if (TREE_CODE (bval) == USING_DECL && is_overloaded_fn (x))\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+\treturn true;\n \n       if (old_decl && binding->scope == class_binding_level)\n \t{\n@@ -2940,7 +3008,7 @@ push_class_level_binding (tree name, tree x)\n \t     here.  This function is only used to register bindings\n \t     from with the class definition itself.  */\n \t  INHERITED_VALUE_BINDING_P (binding) = 0;\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+\t  return true;\n \t}\n     }\n \n@@ -2962,7 +3030,19 @@ push_class_level_binding (tree name, tree x)\n       ok = true;\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ok);\n+  return ok;\n+}\n+\n+/* Wrapper for push_class_level_binding_1.  */\n+\n+bool\n+push_class_level_binding (tree name, tree x)\n+{\n+  bool ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = push_class_level_binding_1 (name, x);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \n /* Process \"using SCOPE::NAME\" in a class scope.  Return the\n@@ -3080,8 +3160,9 @@ do_class_using_decl (tree scope, tree name)\n \f\n /* Return the binding value for name in scope.  */\n \n-tree\n-namespace_binding (tree name, tree scope)\n+\n+static tree\n+namespace_binding_1 (tree name, tree scope)\n {\n   cxx_binding *binding;\n \n@@ -3096,22 +3177,40 @@ namespace_binding (tree name, tree scope)\n   return binding ? binding->value : NULL_TREE;\n }\n \n+tree\n+namespace_binding (tree name, tree scope)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = namespace_binding_1 (name, scope);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n+}\n+\n /* Set the binding value for name in scope.  */\n \n-void\n-set_namespace_binding (tree name, tree scope, tree val)\n+static void\n+set_namespace_binding_1 (tree name, tree scope, tree val)\n {\n   cxx_binding *b;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   if (scope == NULL_TREE)\n     scope = global_namespace;\n   b = binding_for_name (NAMESPACE_LEVEL (scope), name);\n   if (!b->value || TREE_CODE (val) == OVERLOAD || val == error_mark_node)\n     b->value = val;\n   else\n     supplement_binding (b, val);\n-  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Wrapper for set_namespace_binding_1.  */\n+\n+void\n+set_namespace_binding (tree name, tree scope, tree val)\n+{\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  set_namespace_binding_1 (name, scope, val);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Set the context of a declaration to scope. Complain if we are not\n@@ -3297,7 +3396,7 @@ push_namespace (tree name)\n   int implicit_use = 0;\n   bool anon = !name;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n \n   /* We should not get here if the global_namespace is not yet constructed\n      nor if NAME designates the global namespace:  The global scope is\n@@ -3357,7 +3456,7 @@ push_namespace (tree name)\n   /* Enter the name space.  */\n   current_namespace = d;\n \n-  timevar_pop (TV_NAME_LOOKUP);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Pop from the scope of the current namespace.  */\n@@ -3392,7 +3491,7 @@ push_nested_namespace (tree ns)\n void\n pop_nested_namespace (tree ns)\n {\n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   gcc_assert (current_namespace == ns);\n   while (ns != global_namespace)\n     {\n@@ -3401,7 +3500,7 @@ pop_nested_namespace (tree ns)\n     }\n \n   pop_from_top_level ();\n-  timevar_pop (TV_NAME_LOOKUP);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Temporarily set the namespace for the current declaration.  */\n@@ -3426,13 +3525,26 @@ pop_decl_namespace (void)\n    of two given namespaces.  */\n \n static tree\n-namespace_ancestor (tree ns1, tree ns2)\n+namespace_ancestor_1 (tree ns1, tree ns2)\n {\n-  timevar_push (TV_NAME_LOOKUP);\n+  tree nsr;\n   if (is_ancestor (ns1, ns2))\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ns1);\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-\t\t\t  namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2));\n+    nsr = ns1;\n+  else\n+    nsr = namespace_ancestor_1 (CP_DECL_CONTEXT (ns1), ns2);\n+  return nsr;\n+}\n+\n+/* Wrapper for namespace_ancestor_1.  */\n+\n+static tree\n+namespace_ancestor (tree ns1, tree ns2)\n+{\n+  tree nsr;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  nsr = namespace_ancestor_1 (ns1, ns2);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return nsr;\n }\n \n /* Process a namespace-alias declaration.  */\n@@ -3468,7 +3580,7 @@ pushdecl_namespace_level (tree x, bool is_friend)\n   struct cp_binding_level *b = current_binding_level;\n   tree t;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace), is_friend);\n \n   /* Now, the type_shadowed stack may screw us.  Munge it so it does\n@@ -3502,23 +3614,21 @@ pushdecl_namespace_level (tree x, bool is_friend)\n \t  *ptr = newval;\n \t}\n     }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return t;\n }\n \n /* Insert USED into the using list of USER. Set INDIRECT_flag if this\n    directive is not directly from the source. Also find the common\n    ancestor and let our users know about the new namespace */\n+\n static void\n-add_using_namespace (tree user, tree used, bool indirect)\n+add_using_namespace_1 (tree user, tree used, bool indirect)\n {\n   tree t;\n-  timevar_push (TV_NAME_LOOKUP);\n   /* Using oneself is a no-op.  */\n   if (user == used)\n-    {\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n+    return;\n   gcc_assert (TREE_CODE (user) == NAMESPACE_DECL);\n   gcc_assert (TREE_CODE (used) == NAMESPACE_DECL);\n   /* Check if we already have this.  */\n@@ -3528,7 +3638,6 @@ add_using_namespace (tree user, tree used, bool indirect)\n       if (!indirect)\n \t/* Promote to direct usage.  */\n \tTREE_INDIRECT_USING (t) = 0;\n-      timevar_pop (TV_NAME_LOOKUP);\n       return;\n     }\n \n@@ -3546,12 +3655,21 @@ add_using_namespace (tree user, tree used, bool indirect)\n   /* Recursively add all namespaces used.  */\n   for (t = DECL_NAMESPACE_USING (used); t; t = TREE_CHAIN (t))\n     /* indirect usage */\n-    add_using_namespace (user, TREE_PURPOSE (t), 1);\n+    add_using_namespace_1 (user, TREE_PURPOSE (t), 1);\n \n   /* Tell everyone using us about the new used namespaces.  */\n   for (t = DECL_NAMESPACE_USERS (user); t; t = TREE_CHAIN (t))\n-    add_using_namespace (TREE_PURPOSE (t), used, 1);\n-  timevar_pop (TV_NAME_LOOKUP);\n+    add_using_namespace_1 (TREE_PURPOSE (t), used, 1);\n+}\n+\n+/* Wrapper for add_using_namespace_1.  */\n+\n+static void\n+add_using_namespace (tree user, tree used, bool indirect)\n+{\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  add_using_namespace_1 (user, used, indirect);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Process a using-declaration not appearing in class or local scope.  */\n@@ -3658,13 +3776,14 @@ parse_using_directive (tree name_space, tree attribs)\n static tree\n pushdecl_top_level_1 (tree x, tree *init, bool is_friend)\n {\n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   push_to_top_level ();\n   x = pushdecl_namespace_level (x, is_friend);\n   if (init)\n     cp_finish_decl (x, *init, false, NULL_TREE, 0);\n   pop_from_top_level ();\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return x;\n }\n \n /* Like pushdecl, only it places X in the global scope if appropriate.  */\n@@ -4000,16 +4119,14 @@ suggest_alternatives_for (location_t location, tree name)\n    considering using-directives.  */\n \n static tree\n-unqualified_namespace_lookup (tree name, int flags)\n+unqualified_namespace_lookup_1 (tree name, int flags)\n {\n   tree initial = current_decl_namespace ();\n   tree scope = initial;\n   tree siter;\n   struct cp_binding_level *level;\n   tree val = NULL_TREE;\n \n-  timevar_push (TV_NAME_LOOKUP);\n-\n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n       struct scope_binding binding = EMPTY_SCOPE_BINDING;\n@@ -4026,7 +4143,7 @@ unqualified_namespace_lookup (tree name, int flags)\n \tif (!lookup_using_namespace (name, &binding, level->using_directives,\n \t\t\t\t     scope, flags))\n \t  /* Give up because of error.  */\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t  return error_mark_node;\n \n       /* Add all _DECLs seen through global using-directives.  */\n       /* XXX local and global using lists should work equally.  */\n@@ -4037,7 +4154,7 @@ unqualified_namespace_lookup (tree name, int flags)\n \t\t\t\t       DECL_NAMESPACE_USING (siter),\n \t\t\t\t       scope, flags))\n \t    /* Give up because of error.  */\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t    return error_mark_node;\n \t  if (siter == scope) break;\n \t  siter = CP_DECL_CONTEXT (siter);\n \t}\n@@ -4046,7 +4163,19 @@ unqualified_namespace_lookup (tree name, int flags)\n       if (scope == global_namespace)\n \tbreak;\n     }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+  return val;\n+}\n+\n+/* Wrapper for unqualified_namespace_lookup_1.  */\n+\n+static tree\n+unqualified_namespace_lookup (tree name, int flags)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = unqualified_namespace_lookup_1 (name, flags);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \n /* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n@@ -4096,7 +4225,7 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n \t\t\ttree usings, tree scope, int flags)\n {\n   tree iter;\n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   /* Iterate over all used namespaces in current, searching for using\n      directives of scope.  */\n   for (iter = usings; iter; iter = TREE_CHAIN (iter))\n@@ -4109,7 +4238,8 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n \tif (val1)\n \t  ambiguous_decl (val, val1, flags);\n       }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return val->value != error_mark_node;\n }\n \n /* Returns true iff VEC contains TARGET.  */\n@@ -4142,7 +4272,7 @@ qualified_lookup_using_namespace (tree name, tree scope,\n   VEC(tree,gc) *todo_maybe = NULL;\n   VEC(tree,gc) *todo_inline = NULL;\n   tree usings;\n-  timevar_push (TV_NAME_LOOKUP);\n+  timevar_start (TV_NAME_LOOKUP);\n   /* Look through namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n \n@@ -4201,7 +4331,8 @@ qualified_lookup_using_namespace (tree name, tree scope,\n   VEC_free (tree,gc,todo_inline);\n   VEC_free (tree,gc,seen);\n   VEC_free (tree,gc,seen_inline);\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return result->value != error_mark_node;\n }\n \n /* Subroutine of outer_binding.\n@@ -4328,14 +4459,13 @@ innermost_non_namespace_value (tree name)\n    If NONCLASS is nonzero, bindings in class scopes are ignored.  If\n    BLOCK_P is false, bindings in block scopes are ignored.  */\n \n-tree\n-lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n-\t\t  int namespaces_only, int flags)\n+static tree\n+lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n+\t\t    int namespaces_only, int flags)\n {\n   cxx_binding *iter;\n   tree val = NULL_TREE;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   /* Conversion operators are handled specially because ordinary\n      unqualified name lookup will not find template conversion\n      operators.  */\n@@ -4359,10 +4489,10 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n \t  class_type = level->this_entity;\n \t  operators = lookup_fnfields (class_type, name, /*protect=*/0);\n \t  if (operators)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, operators);\n+\t    return operators;\n \t}\n \n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+      return NULL_TREE;\n     }\n \n   flags |= lookup_flags (prefer_type, namespaces_only);\n@@ -4457,7 +4587,21 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n   if (val && TREE_CODE (val) == OVERLOAD && !really_overloaded_fn (val))\n     val = OVL_FUNCTION (val);\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+  return val;\n+}\n+\n+/* Wrapper for lookup_name_real_1.  */\n+\n+tree\n+lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n+\t\t  int namespaces_only, int flags)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = lookup_name_real_1 (name, prefer_type, nonclass, block_p,\n+\t\t\t    namespaces_only, flags);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \n tree\n@@ -4504,14 +4648,12 @@ lookup_name_prefer_type (tree name, int prefer_type)\n    A TYPE_DECL best matching the NAME is returned.  Catching error\n    and issuing diagnostics are caller's responsibility.  */\n \n-tree\n-lookup_type_scope (tree name, tag_scope scope)\n+static tree\n+lookup_type_scope_1 (tree name, tag_scope scope)\n {\n   cxx_binding *iter = NULL;\n   tree val = NULL_TREE;\n \n-  timevar_push (TV_NAME_LOOKUP);\n-\n   /* Look in non-namespace scope first.  */\n   if (current_binding_level->kind != sk_namespace)\n     iter = outer_binding (name, NULL, /*class_p=*/ true);\n@@ -4566,7 +4708,7 @@ lookup_type_scope (tree name, tag_scope scope)\n       while (b)\n \t{\n \t  if (iter->scope == b)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+\t    return val;\n \n \t  if (b->kind == sk_cleanup || b->kind == sk_template_parms\n \t      || b->kind == sk_function_parms)\n@@ -4579,19 +4721,31 @@ lookup_type_scope (tree name, tag_scope scope)\n \t}\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+  return NULL_TREE;\n }\n+ \n+/* Wrapper for lookup_type_scope_1.  */\n+\n+tree\n+lookup_type_scope (tree name, tag_scope scope)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = lookup_type_scope_1 (name, scope);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n+}\n+\n \n /* Similar to `lookup_name' but look only in the innermost non-class\n    binding level.  */\n \n-tree\n-lookup_name_innermost_nonclass_level (tree name)\n+static tree\n+lookup_name_innermost_nonclass_level_1 (tree name)\n {\n   struct cp_binding_level *b;\n   tree t = NULL_TREE;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   b = innermost_nonclass_level ();\n \n   if (b->kind == sk_namespace)\n@@ -4612,7 +4766,7 @@ lookup_name_innermost_nonclass_level (tree name)\n \t  if (binding->scope == b\n \t      && !(TREE_CODE (binding->value) == VAR_DECL\n \t\t   && DECL_DEAD_FOR_LOCAL (binding->value)))\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, binding->value);\n+\t    return binding->value;\n \n \t  if (b->kind == sk_cleanup)\n \t    b = b->level_chain;\n@@ -4621,9 +4775,22 @@ lookup_name_innermost_nonclass_level (tree name)\n \t}\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+  return t;\n }\n \n+/* Wrapper for lookup_name_innermost_nonclass_level_1.  */\n+\n+tree\n+lookup_name_innermost_nonclass_level (tree name)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = lookup_name_innermost_nonclass_level_1 (name);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n+}\n+\n+\n /* Returns true iff DECL is a block-scope extern declaration of a function\n    or variable.  */\n \n@@ -4659,7 +4826,7 @@ lookup_type_current_level (tree name)\n {\n   tree t = NULL_TREE;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  timevar_start (TV_NAME_LOOKUP);\n   gcc_assert (current_binding_level->kind != sk_namespace);\n \n   if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n@@ -4669,16 +4836,19 @@ lookup_type_current_level (tree name)\n       while (1)\n \t{\n \t  if (purpose_member (name, b->type_shadowed))\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-\t\t\t\t    REAL_IDENTIFIER_TYPE_VALUE (name));\n+\t    {\n+\t      t = REAL_IDENTIFIER_TYPE_VALUE (name);\n+\t      break;\n+\t    }\n \t  if (b->kind == sk_cleanup)\n \t    b = b->level_chain;\n \t  else\n \t    break;\n \t}\n     }\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return t;\n }\n \n /* [basic.lookup.koenig] */\n@@ -5150,14 +5320,12 @@ arg_assoc (struct arg_lookup *k, tree n)\n /* Performs Koenig lookup depending on arguments, where fns\n    are the functions found in normal lookup.  */\n \n-tree\n-lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args,\n-\t\t      bool include_std)\n+static tree\n+lookup_arg_dependent_1 (tree name, tree fns, VEC(tree,gc) *args,\n+\t\t\tbool include_std)\n {\n   struct arg_lookup k;\n \n-  timevar_push (TV_NAME_LOOKUP);\n-\n   /* Remove any hidden friend functions from the list of functions\n      found so far.  They will be added back by arg_assoc_class as\n      appropriate.  */\n@@ -5193,23 +5361,36 @@ lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args,\n   release_tree_vector (k.classes);\n   release_tree_vector (k.namespaces);\n     \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fns);\n+  return fns;\n }\n \n+/* Wrapper for lookup_arg_dependent_1.  */\n+\n+tree\n+lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args,\n+                      bool include_std)\n+{\n+  tree ret;\n+  timevar_start (TV_NAME_LOOKUP);\n+  ret = lookup_arg_dependent_1 (name, fns, args, include_std);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return ret;\n+}\n+\n+\n /* Add namespace to using_directives. Return NULL_TREE if nothing was\n    changed (i.e. there was already a directive), or the fresh\n    TREE_LIST otherwise.  */\n \n static tree\n-push_using_directive (tree used)\n+push_using_directive_1 (tree used)\n {\n   tree ud = current_binding_level->using_directives;\n   tree iter, ancestor;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   /* Check if we already have this.  */\n   if (purpose_member (used, ud) != NULL_TREE)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+    return NULL_TREE;\n \n   ancestor = namespace_ancestor (current_decl_namespace (), used);\n   ud = current_binding_level->using_directives;\n@@ -5220,7 +5401,19 @@ push_using_directive (tree used)\n   for (iter = DECL_NAMESPACE_USING (used); iter; iter = TREE_CHAIN (iter))\n     push_using_directive (TREE_PURPOSE (iter));\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ud);\n+  return ud;\n+}\n+\n+/* Wrapper for push_using_directive_1.  */\n+\n+static tree\n+push_using_directive (tree used)\n+{\n+  tree ret;\n+  timevar_start (TV_NAME_LOOKUP);\n+  ret = push_using_directive_1 (used);\n+  timevar_stop (TV_NAME_LOOKUP);\n+  return ret;\n }\n \n /* The type TYPE is being declared.  If it is a class template, or a\n@@ -5313,13 +5506,12 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n \n    Returns TYPE upon success and ERROR_MARK_NODE otherwise.  */\n \n-tree\n-pushtag (tree name, tree type, tag_scope scope)\n+static tree\n+pushtag_1 (tree name, tree type, tag_scope scope)\n {\n   struct cp_binding_level *b;\n   tree decl;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n   while (/* Cleanup scopes are not scopes from the point of view of\n \t    the language.  */\n@@ -5344,7 +5536,7 @@ pushtag (tree name, tree type, tag_scope scope)\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   /* Do C++ gratuitous typedefing.  */\n-  if (IDENTIFIER_TYPE_VALUE (name) != type)\n+  if (identifier_type_value_1 (name) != type)\n     {\n       tree tdef;\n       int in_class = 0;\n@@ -5390,12 +5582,12 @@ pushtag (tree name, tree type, tag_scope scope)\n       decl = maybe_process_template_type_declaration\n \t(type, scope == ts_within_enclosing_non_class, b);\n       if (decl == error_mark_node)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+\treturn decl;\n \n       if (b->kind == sk_class)\n \t{\n \t  if (!TYPE_BEING_DEFINED (current_class_type))\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t    return error_mark_node;\n \n \t  if (!PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t    /* Put this TYPE_DECL on the TYPE_FIELDS list for the\n@@ -5408,9 +5600,9 @@ pushtag (tree name, tree type, tag_scope scope)\n \t}\n       else if (b->kind != sk_template_parms)\n \t{\n-\t  decl = pushdecl_with_scope (decl, b, /*is_friend=*/false);\n+\t  decl = pushdecl_with_scope_1 (decl, b, /*is_friend=*/false);\n \t  if (decl == error_mark_node)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+\t    return decl;\n \t}\n \n       if (! in_class)\n@@ -5449,7 +5641,19 @@ pushtag (tree name, tree type, tag_scope scope)\n   TREE_PUBLIC (decl) = 1;\n   determine_visibility (decl);\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n+  return type;\n+}\n+\n+/* Wrapper for pushtag_1.  */\n+\n+tree\n+pushtag (tree name, tree type, tag_scope scope)\n+{\n+  tree ret;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  ret = pushtag_1 (name, type, scope);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ret;\n }\n \f\n /* Subroutines for reverting temporarily to top-level for instantiation\n@@ -5487,7 +5691,7 @@ store_bindings (tree names, VEC(cxx_saved_binding,gc) **old_bindings)\n {\n   tree t;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   for (t = names; t; t = TREE_CHAIN (t))\n     {\n       tree id;\n@@ -5499,7 +5703,7 @@ store_bindings (tree names, VEC(cxx_saved_binding,gc) **old_bindings)\n \n       store_binding (id, old_bindings);\n     }\n-  timevar_pop (TV_NAME_LOOKUP);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Like store_bindings, but NAMES is a vector of cp_class_binding\n@@ -5512,10 +5716,10 @@ store_class_bindings (VEC(cp_class_binding,gc) *names,\n   size_t i;\n   cp_class_binding *cb;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   for (i = 0; VEC_iterate(cp_class_binding, names, i, cb); ++i)\n     store_binding (cb->identifier, old_bindings);\n-  timevar_pop (TV_NAME_LOOKUP);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n void\n@@ -5527,7 +5731,7 @@ push_to_top_level (void)\n   size_t i;\n   bool need_pop;\n \n-  timevar_push (TV_NAME_LOOKUP);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   s = ggc_alloc_cleared_saved_scope ();\n \n   b = scope_chain ? current_binding_level : 0;\n@@ -5587,17 +5791,16 @@ push_to_top_level (void)\n   push_class_stack ();\n   cp_unevaluated_operand = 0;\n   c_inhibit_evaluation_warnings = 0;\n-  timevar_pop (TV_NAME_LOOKUP);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n-void\n-pop_from_top_level (void)\n+static void\n+pop_from_top_level_1 (void)\n {\n   struct saved_scope *s = scope_chain;\n   cxx_saved_binding *saved;\n   size_t i;\n \n-  timevar_push (TV_NAME_LOOKUP);\n   /* Clear out class-level bindings cache.  */\n   if (previous_class_level)\n     invalidate_class_lookup_cache ();\n@@ -5621,9 +5824,19 @@ pop_from_top_level (void)\n   current_function_decl = s->function_decl;\n   cp_unevaluated_operand = s->unevaluated_operand;\n   c_inhibit_evaluation_warnings = s->inhibit_evaluation_warnings;\n-  timevar_pop (TV_NAME_LOOKUP);\n }\n \n+/* Wrapper for pop_from_top_level_1.  */\n+\n+void\n+pop_from_top_level (void)\n+{\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  pop_from_top_level_1 ();\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+}\n+\n+\n /* Pop off extraneous binding levels left over due to syntax errors.\n \n    We don't pop past namespaces, as they might be valid.  */"}, {"sha": "9ec571e793c59eb473a807c617f5d64ec3b7b6ea", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"timevar.h\"\n #include \"cpplib.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n@@ -12152,6 +12153,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n   cp_decl_specifier_seq decl_specifiers;\n   tree extension_specifier = NULL_TREE;\n \n+  timevar_push (TV_TEMPLATE_INST);\n+\n   /* Look for an (optional) storage-class-specifier or\n      function-specifier.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n@@ -12235,6 +12238,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n   end_explicit_instantiation ();\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n+  timevar_pop (TV_TEMPLATE_INST);\n }\n \n /* Parse an explicit-specialization.\n@@ -13446,6 +13451,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n      elaborated-type-specifier.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n+      timevar_push (TV_PARSE_ENUM);\n       if (nested_name_specifier)\n \t{\n \t  /* The following catches invalid code such as:\n@@ -13507,6 +13513,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n \n       if (scoped_enum_p)\n \tfinish_scope ();\n+      timevar_pop (TV_PARSE_ENUM);\n     }\n   else\n     {\n@@ -16742,7 +16749,7 @@ cp_parser_class_name (cp_parser *parser,\n    Returns the TREE_TYPE representing the class.  */\n \n static tree\n-cp_parser_class_specifier (cp_parser* parser)\n+cp_parser_class_specifier_1 (cp_parser* parser)\n {\n   tree type;\n   tree attributes = NULL_TREE;\n@@ -17005,6 +17012,16 @@ cp_parser_class_specifier (cp_parser* parser)\n   return type;\n }\n \n+static tree\n+cp_parser_class_specifier (cp_parser* parser)\n+{\n+  tree ret;\n+  timevar_push (TV_PARSE_STRUCT);\n+  ret = cp_parser_class_specifier_1 (parser);\n+  timevar_pop (TV_PARSE_STRUCT);\n+  return ret;\n+}\n+\n /* Parse a class-head.\n \n    class-head:\n@@ -19650,8 +19667,17 @@ cp_parser_function_definition_from_specifiers_and_declarator\n \tpop_nested_class ();\n     }\n   else\n-    fn = cp_parser_function_definition_after_declarator (parser,\n+    {\n+      timevar_id_t tv;\n+      if (DECL_DECLARED_INLINE_P (current_function_decl))\n+        tv = TV_PARSE_INLINE;\n+      else\n+        tv = TV_PARSE_FUNC;\n+      timevar_push (tv);\n+      fn = cp_parser_function_definition_after_declarator (parser,\n \t\t\t\t\t\t\t /*inline_p=*/false);\n+      timevar_pop (tv);\n+    }\n \n   return fn;\n }\n@@ -20268,6 +20294,7 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n static void\n cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n {\n+  timevar_push (TV_PARSE_INMETH);\n   /* If this member is a template, get the underlying\n      FUNCTION_DECL.  */\n   if (DECL_FUNCTION_TEMPLATE_P (member_function))\n@@ -20334,6 +20361,7 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n \n   /* Restore the queue.  */\n   pop_unparsed_function_queues (parser);\n+  timevar_pop (TV_PARSE_INMETH);\n }\n \n /* If DECL contains any default args, remember it on the unparsed"}, {"sha": "b56ab1f1abdc93fbb99dadf8865153fb69edccab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 58, "deletions": 27, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -6682,13 +6682,9 @@ maybe_get_template_decl_from_type_decl (tree decl)\n    that we want to avoid. It also causes some problems with argument\n    coercion (see convert_nontype_argument for more information on this).  */\n \n-tree\n-lookup_template_class (tree d1,\n-\t\t       tree arglist,\n-\t\t       tree in_decl,\n-\t\t       tree context,\n-\t\t       int entering_scope,\n-\t\t       tsubst_flags_t complain)\n+static tree\n+lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n+\t\t\t int entering_scope, tsubst_flags_t complain)\n {\n   tree templ = NULL_TREE, parmlist;\n   tree t;\n@@ -6697,8 +6693,6 @@ lookup_template_class (tree d1,\n   spec_entry elt;\n   hashval_t hash;\n \n-  timevar_push (TV_NAME_LOOKUP);\n-\n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n       tree value = innermost_non_namespace_value (d1);\n@@ -6751,7 +6745,7 @@ lookup_template_class (tree d1,\n     {\n       if (complain & tf_error)\n \terror (\"%qT is not a template\", d1);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+      return error_mark_node;\n     }\n \n   if (TREE_CODE (templ) != TEMPLATE_DECL\n@@ -6766,7 +6760,7 @@ lookup_template_class (tree d1,\n \t  if (in_decl)\n \t    error (\"for template declaration %q+D\", in_decl);\n \t}\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+      return error_mark_node;\n     }\n \n   complain &= ~tf_user;\n@@ -6816,10 +6810,10 @@ lookup_template_class (tree d1,\n       if (arglist2 == error_mark_node\n \t  || (!uses_template_parms (arglist2)\n \t      && check_instantiated_args (templ, arglist2, complain)))\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\treturn error_mark_node;\n \n       parm = bind_template_template_parm (TREE_TYPE (templ), arglist2);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, parm);\n+      return parm;\n     }\n   else\n     {\n@@ -6895,7 +6889,7 @@ lookup_template_class (tree d1,\n \t\t{\n \t\t  /* Restore the ARGLIST to its full size.  */\n \t\t  TREE_VEC_LENGTH (arglist) = saved_depth;\n-\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t\t  return error_mark_node;\n \t\t}\n \n \t      SET_TMPL_ARGS_LEVEL (bound_args, i, a);\n@@ -6923,7 +6917,7 @@ lookup_template_class (tree d1,\n \n       if (arglist == error_mark_node)\n \t/* We were unable to bind the arguments.  */\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\treturn error_mark_node;\n \n       /* In the scope of a template class, explicit references to the\n \t template class refer to the type of the template, not any\n@@ -6939,7 +6933,7 @@ lookup_template_class (tree d1,\n \t  /* comp_template_args is expensive, check it last.  */\n \t  && comp_template_args (TYPE_TI_ARGS (template_type),\n \t\t\t\t arglist))\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, template_type);\n+\treturn template_type;\n \n       /* If we already have this specialization, return it.  */\n       elt.tmpl = gen_tmpl;\n@@ -6949,7 +6943,7 @@ lookup_template_class (tree d1,\n \t\t\t\t\t\t  &elt, hash);\n \n       if (entry)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->spec);\n+\treturn entry->spec;\n \n       is_dependent_type = uses_template_parms (arglist);\n \n@@ -6959,7 +6953,7 @@ lookup_template_class (tree d1,\n \t  && check_instantiated_args (gen_tmpl,\n \t\t\t\t      INNERMOST_TEMPLATE_ARGS (arglist),\n \t\t\t\t      complain))\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\treturn error_mark_node;\n \n       if (!is_dependent_type\n \t  && !PRIMARY_TEMPLATE_P (gen_tmpl)\n@@ -6969,7 +6963,7 @@ lookup_template_class (tree d1,\n \t  found = xref_tag_from_type (TREE_TYPE (gen_tmpl),\n \t\t\t\t      DECL_NAME (gen_tmpl),\n \t\t\t\t      /*tag_scope=*/ts_global);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n+\t  return found;\n \t}\n \n       context = tsubst (DECL_CONTEXT (gen_tmpl), arglist,\n@@ -7162,9 +7156,22 @@ lookup_template_class (tree d1,\n       TREE_PUBLIC (type_decl) = 1;\n       determine_visibility (type_decl);\n \n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+      return t;\n     }\n-  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Wrapper for lookup_template_class_1.  */\n+\n+tree\n+lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n+                       int entering_scope, tsubst_flags_t complain)\n+{\n+  tree ret;\n+  timevar_push (TV_TEMPLATE_INST);\n+  ret = lookup_template_class_1 (d1, arglist, in_decl, context,\n+                                 entering_scope, complain);\n+  timevar_pop (TV_TEMPLATE_INST);\n+  return ret;\n }\n \f\n struct pair_fn_data\n@@ -8102,8 +8109,8 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n     input_location = saved_location;\n }\n \n-tree\n-instantiate_class_template (tree type)\n+static tree\n+instantiate_class_template_1 (tree type)\n {\n   tree templ, args, pattern, t, member;\n   tree typedecl;\n@@ -8597,6 +8604,18 @@ instantiate_class_template (tree type)\n   return type;\n }\n \n+/* Wrapper for instantiate_class_template_1.  */\n+\n+tree\n+instantiate_class_template (tree type)\n+{\n+  tree ret;\n+  timevar_push (TV_TEMPLATE_INST);\n+  ret = instantiate_class_template_1 (type);\n+  timevar_pop (TV_TEMPLATE_INST);\n+  return ret;\n+}\n+\n static tree\n tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n@@ -13505,8 +13524,8 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n /* Instantiate the indicated variable or function template TMPL with\n    the template arguments in TARG_PTR.  */\n \n-tree\n-instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n+static tree\n+instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n {\n   tree targ_ptr = orig_args;\n   tree fndecl;\n@@ -13615,6 +13634,18 @@ instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n   return fndecl;\n }\n \n+/* Wrapper for instantiate_template_1.  */\n+\n+tree\n+instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n+{\n+  tree ret;\n+  timevar_push (TV_TEMPLATE_INST);\n+  ret = instantiate_template_1 (tmpl, orig_args,  complain);\n+  timevar_pop (TV_TEMPLATE_INST);\n+  return ret;\n+}\n+\n /* The FN is a TEMPLATE_DECL for a function.  ARGS is an array with\n    NARGS elements of the arguments that are being used when calling\n    it.  TARGS is a vector into which the deduced template arguments\n@@ -17204,7 +17235,7 @@ instantiate_decl (tree d, int defer_ok,\n   if (! push_tinst_level (d))\n     return d;\n \n-  timevar_push (TV_PARSE);\n+  timevar_push (TV_TEMPLATE_INST);\n \n   /* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern\n      for the instantiation.  */\n@@ -17497,7 +17528,7 @@ instantiate_decl (tree d, int defer_ok,\n   pop_deferring_access_checks ();\n   pop_tinst_level ();\n \n-  timevar_pop (TV_PARSE);\n+  timevar_pop (TV_TEMPLATE_INST);\n \n   return d;\n }"}, {"sha": "c87695bec822f1e3139d820b8fb3da3e1c65346e", "filename": "gcc/timevar.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -361,11 +361,66 @@ timevar_stop (timevar_id_t timevar)\n \n   /* TIMEVAR must have been started via timevar_start.  */\n   gcc_assert (tv->standalone);\n+  tv->standalone = 0; /* Enable a restart.  */\n \n   get_time (&now);\n   timevar_accumulate (&tv->elapsed, &tv->start_time, &now);\n }\n \n+\n+/* Conditionally start timing TIMEVAR independently of the timing stack.\n+   If the timer is already running, leave it running and return true.\n+   Otherwise, start the timer and return false.\n+   Elapsed time until the corresponding timevar_cond_stop\n+   is called for the same timing variable is attributed to TIMEVAR.  */\n+\n+bool\n+timevar_cond_start (timevar_id_t timevar)\n+{\n+  struct timevar_def *tv = &timevars[timevar];\n+\n+  if (!timevar_enable)\n+    return false;\n+\n+  /* Mark this timing variable as used.  */\n+  tv->used = 1;\n+\n+  if (tv->standalone)\n+    return true;  /* The timevar is already running.  */\n+\n+  /* Don't allow the same timing variable\n+     to be unconditionally started more than once.  */\n+  tv->standalone = 1;\n+\n+  get_time (&tv->start_time);\n+  return false;  /* The timevar was not already running.  */\n+}\n+\n+/* Conditionally stop timing TIMEVAR.  The RUNNING parameter must come\n+   from the return value of a dynamically matching timevar_cond_start.\n+   If the timer had already been RUNNING, do nothing.  Otherwise, time\n+   elapsed since timevar_cond_start was called is attributed to it.  */\n+\n+void\n+timevar_cond_stop (timevar_id_t timevar, bool running)\n+{\n+  struct timevar_def *tv;\n+  struct timevar_time_def now;\n+\n+  if (!timevar_enable || running)\n+    return;\n+\n+  tv = &timevars[timevar];\n+\n+  /* TIMEVAR must have been started via timevar_cond_start.  */\n+  gcc_assert (tv->standalone);\n+  tv->standalone = 0; /* Enable a restart.  */\n+\n+  get_time (&now);\n+  timevar_accumulate (&tv->elapsed, &tv->start_time, &now);\n+}\n+\n+\n /* Summarize timing variables to FP.  The timing variable TV_TOTAL has\n    a special meaning -- it's considered to be the total elapsed time,\n    for normalizing the others, and is displayed last.  */"}, {"sha": "2921c9088bdb6a11a3b5d57736d6ed16cf1b81d1", "filename": "gcc/timevar.def", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -33,6 +33,18 @@\n \n /* The total execution time.  */\n DEFTIMEVAR (TV_TOTAL                 , \"total time\")\n+DEFTIMEVAR (TV_PHASE_SETUP           , \"phase setup\")\n+DEFTIMEVAR (TV_PHASE_PARSING         , \"phase parsing\")\n+DEFTIMEVAR (TV_PHASE_DEFERRED        , \"phase lang. deferred\")\n+DEFTIMEVAR (TV_PHASE_CGRAPH          , \"phase cgraph\")\n+DEFTIMEVAR (TV_PHASE_DBGINFO         , \"phase debug info\")\n+DEFTIMEVAR (TV_PHASE_CHECK_DBGINFO   , \"phase check & debug info\")\n+DEFTIMEVAR (TV_PHASE_GENERATE        , \"phase generate\")\n+DEFTIMEVAR (TV_PHASE_FINALIZE        , \"phase finalize\")\n+\n+/* Concurrent timers, indicated by \"|\".  */\n+DEFTIMEVAR (TV_NAME_LOOKUP           , \"|name lookup\")\n+DEFTIMEVAR (TV_OVERLOAD              , \"|overload resolution\")\n \n /* Time spent garbage-collecting.  */\n DEFTIMEVAR (TV_GC                    , \"garbage collection\")\n@@ -102,8 +114,13 @@ DEFTIMEVAR (TV_REBUILD_JUMP\t     , \"rebuild jump labels\")\n /* Timing in various stages of the compiler.  */\n DEFTIMEVAR (TV_CPP\t\t     , \"preprocessing\")\n DEFTIMEVAR (TV_LEX\t\t     , \"lexical analysis\")\n-DEFTIMEVAR (TV_PARSE                 , \"parser\")\n-DEFTIMEVAR (TV_NAME_LOOKUP           , \"name lookup\")\n+DEFTIMEVAR (TV_PARSE_GLOBAL          , \"parser (global)\")\n+DEFTIMEVAR (TV_PARSE_STRUCT          , \"parser struct body\")\n+DEFTIMEVAR (TV_PARSE_ENUM            , \"parser enumerator list\")\n+DEFTIMEVAR (TV_PARSE_FUNC            , \"parser function body\")\n+DEFTIMEVAR (TV_PARSE_INLINE          , \"parser inl. func. body\")\n+DEFTIMEVAR (TV_PARSE_INMETH          , \"parser inl. meth. body\")\n+DEFTIMEVAR (TV_TEMPLATE_INST         , \"template instantiation\")\n DEFTIMEVAR (TV_INLINE_HEURISTICS     , \"inline heuristics\")\n DEFTIMEVAR (TV_INTEGRATION           , \"integration\")\n DEFTIMEVAR (TV_TREE_GIMPLIFY\t     , \"tree gimplify\")\n@@ -170,8 +187,6 @@ DEFTIMEVAR (TV_CGRAPH_VERIFY         , \"callgraph verifier\")\n DEFTIMEVAR (TV_DOM_FRONTIERS         , \"dominance frontiers\")\n DEFTIMEVAR (TV_DOMINANCE             , \"dominance computation\")\n DEFTIMEVAR (TV_CONTROL_DEPENDENCES   , \"control dependences\")\n-DEFTIMEVAR (TV_OVERLOAD              , \"overload resolution\")\n-DEFTIMEVAR (TV_TEMPLATE_INSTANTIATION, \"template instantiation\")\n DEFTIMEVAR (TV_OUT_OF_SSA\t     , \"out of ssa\")\n DEFTIMEVAR (TV_VAR_EXPAND\t     , \"expand vars\")\n DEFTIMEVAR (TV_EXPAND\t\t     , \"expand\")"}, {"sha": "dad9dfdf2b06b3d754917195ffd4341f4dec7c0e", "filename": "gcc/timevar.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -87,14 +87,13 @@ extern bool timevar_enable;\n /* Total amount of memory allocated by garbage collector.  */\n extern size_t timevar_ggc_mem_total;\n \n-/* Execute the sequence: timevar_pop (TV), return (E);  */\n-#define POP_TIMEVAR_AND_RETURN(TV, E)  do { timevar_pop (TV); return (E); }while(0)\n-\n extern void timevar_init (void);\n extern void timevar_push_1 (timevar_id_t);\n extern void timevar_pop_1 (timevar_id_t);\n extern void timevar_start (timevar_id_t);\n extern void timevar_stop (timevar_id_t);\n+extern bool timevar_cond_start (timevar_id_t);\n+extern void timevar_cond_stop (timevar_id_t, bool);\n extern void timevar_print (FILE *);\n \n /* Provided for backward compatibility.  */"}, {"sha": "d61addedfadb98016d665e94eab354e1fef8b3d6", "filename": "gcc/toplev.c", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575bfb0052b008995fc992d0728f7bea2173391a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=575bfb0052b008995fc992d0728f7bea2173391a", "patch": "@@ -562,36 +562,34 @@ emit_debug_global_declarations (tree *vec, int len)\n static void\n compile_file (void)\n {\n-  /* Initialize yet another pass.  */\n-\n-  ggc_protect_identifiers = true;\n-\n-  init_cgraph ();\n-  init_final (main_input_filename);\n-  coverage_init (aux_base_name);\n-  statistics_init ();\n-  invoke_plugin_callbacks (PLUGIN_START_UNIT, NULL);\n-\n-  timevar_push (TV_PARSE);\n+  timevar_start (TV_PHASE_PARSING);\n+  timevar_push (TV_PARSE_GLOBAL);\n \n   /* Call the parser, which parses the entire file (calling\n      rest_of_compilation for each function).  */\n   lang_hooks.parse_file ();\n \n+  timevar_pop (TV_PARSE_GLOBAL);\n+  timevar_stop (TV_PHASE_PARSING);\n+\n   /* Compilation is now finished except for writing\n      what's left of the symbol table output.  */\n-  timevar_pop (TV_PARSE);\n \n   if (flag_syntax_only || flag_wpa)\n     return;\n \n+  timevar_start (TV_PHASE_GENERATE);\n+\n   ggc_protect_identifiers = false;\n \n   /* This must also call cgraph_finalize_compilation_unit.  */\n   lang_hooks.decls.final_write_globals ();\n \n   if (seen_error ())\n-    return;\n+    {\n+      timevar_stop (TV_PHASE_GENERATE);\n+      return;\n+    }\n \n   varpool_assemble_pending_decls ();\n   finish_aliases_2 ();\n@@ -671,6 +669,8 @@ compile_file (void)\n      into the assembly file here, and hence we can not output anything to the\n      assembly file after this point.  */\n   targetm.asm_out.file_end ();\n+\n+  timevar_stop (TV_PHASE_GENERATE);\n }\n \n /* Indexed by enum debug_info_type.  */\n@@ -1899,6 +1899,8 @@ do_compile (void)\n   /* Don't do any more if an error has already occurred.  */\n   if (!seen_error ())\n     {\n+      timevar_start (TV_PHASE_SETUP);\n+\n       /* This must be run always, because it is needed to compute the FP\n \t predefined macros, such as __LDBL_MAX__, for targets using non\n \t default FP formats.  */\n@@ -1910,9 +1912,31 @@ do_compile (void)\n \n       /* Language-dependent initialization.  Returns true on success.  */\n       if (lang_dependent_init (main_input_filename))\n-\tcompile_file ();\n+        {\n+          /* Initialize yet another pass.  */\n+\n+          ggc_protect_identifiers = true;\n+\n+          init_cgraph ();\n+          init_final (main_input_filename);\n+          coverage_init (aux_base_name);\n+          statistics_init ();\n+          invoke_plugin_callbacks (PLUGIN_START_UNIT, NULL);\n+\n+          timevar_stop (TV_PHASE_SETUP);\n+\n+          compile_file ();\n+        }\n+      else\n+        {\n+          timevar_stop (TV_PHASE_SETUP);\n+        }\n+\n+      timevar_start (TV_PHASE_FINALIZE);\n \n       finalize (no_backend);\n+\n+      timevar_stop (TV_PHASE_FINALIZE);\n     }\n \n   /* Stop timing and print the times.  */"}]}