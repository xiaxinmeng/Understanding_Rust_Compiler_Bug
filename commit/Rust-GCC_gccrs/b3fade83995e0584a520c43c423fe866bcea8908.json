{"sha": "b3fade83995e0584a520c43c423fe866bcea8908", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNmYWRlODM5OTVlMDU4NGE1MjBjNDNjNDIzZmU4NjZiY2VhODkwOA==", "commit": {"author": {"name": "Brian Booth", "email": "bbooth@redhat.com", "date": "2004-07-27T18:32:50Z"}, "committer": {"name": "Brian Booth", "email": "bbooth@gcc.gnu.org", "date": "2004-07-27T18:32:50Z"}, "message": "tree-optimize.c (register_one_dump_file): Update condition that uses static_pass_number.\n\n\n\t* tree-optimize.c (register_one_dump_file): Update condition that uses\n\tstatic_pass_number.\n\t(dup_pass_1): Replace with...\n\t(next_pass_1): This.\n\t(NEXT_PASS): Call next_pass_1.\n\t(DUP_PASS): Remove.\n\t(init_tree_optimization_passes): Remove uses of DUP_PASS.\n\t(execute_one_pass): Update condition that uses\n\tstatic_pass_number.\n\t* tree-pass.h (tree_opt_pass): Declare static_pass_number as a signed\n\tinteger.\n\nFrom-SVN: r85226", "tree": {"sha": "8ef09fae76670cdbb4009e3f7685931d33dd0c19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ef09fae76670cdbb4009e3f7685931d33dd0c19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3fade83995e0584a520c43c423fe866bcea8908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3fade83995e0584a520c43c423fe866bcea8908", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3fade83995e0584a520c43c423fe866bcea8908", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3fade83995e0584a520c43c423fe866bcea8908/comments", "author": null, "committer": null, "parents": [{"sha": "62d591893b22a727b229a2984453da12198b69e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d591893b22a727b229a2984453da12198b69e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62d591893b22a727b229a2984453da12198b69e4"}], "stats": {"total": 108, "additions": 64, "deletions": 44}, "files": [{"sha": "d64b7ea1c038d330fb8690b7e4b4adc6017aa093", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3fade83995e0584a520c43c423fe866bcea8908/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3fade83995e0584a520c43c423fe866bcea8908/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3fade83995e0584a520c43c423fe866bcea8908", "patch": "@@ -1,3 +1,17 @@\n+2004-07-27  Brian Booth  <bbooth@redhat.com>\n+\n+\t* tree-optimize.c (register_one_dump_file): Update condition that uses\n+\tstatic_pass_number.\n+\t(dup_pass_1): Replace with...\n+\t(next_pass_1): This.\n+\t(NEXT_PASS): Call next_pass_1.\n+\t(DUP_PASS): Remove.\n+\t(init_tree_optimization_passes): Remove uses of DUP_PASS.\n+\t(execute_one_pass): Update condition that uses\n+\tstatic_pass_number.\n+\t* tree-pass.h (tree_opt_pass): Declare static_pass_number as a signed\n+\tinteger.\n+\n 2004-07-27  Nick Clifton  <nickc@redhat.com>\n \n \t* config/m32r/m32r.c: Include integrate.h in order to get the"}, {"sha": "7cdb30bbcf4cd295e23d01d151c777d686cbd07b", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3fade83995e0584a520c43c423fe866bcea8908/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3fade83995e0584a520c43c423fe866bcea8908/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=b3fade83995e0584a520c43c423fe866bcea8908", "patch": "@@ -213,9 +213,9 @@ register_one_dump_file (struct tree_opt_pass *pass)\n   if (!pass->name)\n     return;\n \n-  /* See below in dup_pass_1.  */\n+  /* See below in next_pass_1.  */\n   num[0] = '\\0';\n-  if (pass->static_pass_number)\n+  if (pass->static_pass_number != -1)\n     sprintf (num, \"%d\", ((int) pass->static_pass_number < 0\n \t\t\t ? 1 : pass->static_pass_number));\n \n@@ -252,34 +252,42 @@ register_dump_files (struct tree_opt_pass *pass, int properties)\n   return properties;\n }\n \n-/* Duplicate a pass that's to be run more than once.  */\n+/* Add a pass to the pass list. Duplicate the pass if it's already\n+   in the list.  */\n \n-static struct tree_opt_pass *\n-dup_pass_1 (struct tree_opt_pass *pass)\n+static struct tree_opt_pass **\n+next_pass_1 (struct tree_opt_pass **list, struct tree_opt_pass *pass)\n {\n-  struct tree_opt_pass *new;\n-\n-  new = xmalloc (sizeof (*new));\n-  memcpy (new, pass, sizeof (*new));\n \n-  /* Indicate to register_dump_files that this pass has duplicates,\n-     and so it should rename the dump file.  The first instance will\n-     be < 0, and be number of duplicates = -static_pass_number + 1.\n-     Subsequent instances will be > 0 and just the duplicate number.  */\n-  if (pass->name)\n+  /* A non-zero static_pass_number indicates that the\n+     pass is already in the list. */\n+  if (pass->static_pass_number)\n     {\n-      int n, p = pass->static_pass_number;\n-\t\n-      if (p)\n-\tn = -(--p) + 1;\n-      else\n-\tn = 2, p = -1;\n-\n-      pass->static_pass_number = p;\n-      new->static_pass_number = n;\n+      struct tree_opt_pass *new;\n+\n+      new = xmalloc (sizeof (*new));\n+      memcpy (new, pass, sizeof (*new));\n+\n+      /* Indicate to register_dump_files that this pass has duplicates,\n+         and so it should rename the dump file.  The first instance will\n+         be -1, and be number of duplicates = -static_pass_number - 1.\n+         Subsequent instances will be > 0 and just the duplicate number.  */\n+      if (pass->name)\n+        {\n+          pass->static_pass_number -= 1;\n+          new->static_pass_number = -pass->static_pass_number;\n+\t}\n+      \n+      *list = new;\n     }\n-\n-  return new;\n+  else\n+    {\n+      pass->static_pass_number = -1;\n+      *list = pass;\n+    }  \n+  \n+  return &(*list)->next;\n+          \n }\n \n /* Construct the pass tree.  */\n@@ -289,8 +297,7 @@ init_tree_optimization_passes (void)\n {\n   struct tree_opt_pass **p;\n \n-#define NEXT_PASS(PASS) (*p = &PASS, p = &(*p)->next)\n-#define DUP_PASS(PASS)  (*dup_pass_1 (&PASS))\n+#define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n \n   p = &all_passes;\n   NEXT_PASS (pass_gimple);\n@@ -319,34 +326,34 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_dominator);\n   NEXT_PASS (pass_redundant_phi);\n-  NEXT_PASS (DUP_PASS (pass_dce));\n+  NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_forwprop);\n   NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_tail_recursion);\n   NEXT_PASS (pass_ch);\n   NEXT_PASS (pass_profile);\n   NEXT_PASS (pass_sra);\n-  NEXT_PASS (DUP_PASS (pass_rename_ssa_copies));\n-  NEXT_PASS (DUP_PASS (pass_dominator));\n-  NEXT_PASS (DUP_PASS (pass_redundant_phi));\n-  NEXT_PASS (DUP_PASS (pass_dce));\n+  NEXT_PASS (pass_rename_ssa_copies);\n+  NEXT_PASS (pass_dominator);\n+  NEXT_PASS (pass_redundant_phi);\n+  NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_dse);\n-  NEXT_PASS (DUP_PASS (pass_may_alias));\n-  NEXT_PASS (DUP_PASS (pass_forwprop));\n-  NEXT_PASS (DUP_PASS (pass_phiopt));\n+  NEXT_PASS (pass_may_alias);\n+  NEXT_PASS (pass_forwprop);\n+  NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_ccp);\n-  NEXT_PASS (DUP_PASS (pass_redundant_phi));\n+  NEXT_PASS (pass_redundant_phi);\n   NEXT_PASS (pass_fold_builtins);\n   NEXT_PASS (pass_split_crit_edges);\n   NEXT_PASS (pass_pre);\n   NEXT_PASS (pass_loop);\n-  NEXT_PASS (DUP_PASS (pass_dominator));\n-  NEXT_PASS (DUP_PASS (pass_redundant_phi));\n+  NEXT_PASS (pass_dominator);\n+  NEXT_PASS (pass_redundant_phi);\n   NEXT_PASS (pass_cd_dce);\n-  NEXT_PASS (DUP_PASS (pass_dse));\n-  NEXT_PASS (DUP_PASS (pass_forwprop));\n-  NEXT_PASS (DUP_PASS (pass_phiopt));\n+  NEXT_PASS (pass_dse);\n+  NEXT_PASS (pass_forwprop);\n+  NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_tail_calls);\n   NEXT_PASS (pass_late_warn_uninitialized);\n   NEXT_PASS (pass_del_pta);\n@@ -363,7 +370,6 @@ init_tree_optimization_passes (void)\n   *p = NULL;\n \n #undef NEXT_PASS\n-#undef DUP_PASS\n \n   /* Register the passes with the tree dump code.  */\n   register_dump_files (all_passes, 0);\n@@ -424,7 +430,7 @@ execute_one_pass (struct tree_opt_pass *pass)\n     execute_todo (todo);\n \n   /* If a dump file name is present, open it if enabled.  */\n-  if (pass->static_pass_number)\n+  if (pass->static_pass_number != -1)\n     {\n       dump_file = dump_begin (pass->static_pass_number, &dump_flags);\n       if (dump_file)"}, {"sha": "9651c9e659b51727b02747384ca0629a95eab5fb", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3fade83995e0584a520c43c423fe866bcea8908/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3fade83995e0584a520c43c423fe866bcea8908/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b3fade83995e0584a520c43c423fe866bcea8908", "patch": "@@ -50,7 +50,7 @@ struct tree_opt_pass\n   struct tree_opt_pass *next;\n \n   /* Static pass number, used as a fragment of the dump file name.  */\n-  unsigned int static_pass_number;\n+  int static_pass_number;\n \n   /* The timevar id associated with this pass.  */\n   /* ??? Ideally would be dynamically assigned.  */"}]}