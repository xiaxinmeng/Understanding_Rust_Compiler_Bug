{"sha": "85c3f0b9e91b7a4bb421b945577890ebcead33ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVjM2YwYjllOTFiN2E0YmI0MjFiOTQ1NTc3ODkwZWJjZWFkMzNhYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T12:51:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T12:51:37Z"}, "message": "[multiple changes]\n\n2010-10-12  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_util.adb (Side_Effect_Free): Return true for object renaming\n\tdeclarations that were previously generated by Remove_Side_Effects.\n\n2010-10-12  Emmanuel Briot  <briot@adacore.com>\n\n\t* xref_lib.adb (Get_Full_Type): Display \"private variable\" instead of\n\t\"???\" when an entity is defined as \"*\" in the ALI file.\n\t* g-comlin.ads, g-comlin.adb: Fix handling of null parameters.\n\tMinor reformatting.\n\nFrom-SVN: r165371", "tree": {"sha": "c22b107098eed6d70567e9a2fbc0d6b3b5de164e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c22b107098eed6d70567e9a2fbc0d6b3b5de164e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85c3f0b9e91b7a4bb421b945577890ebcead33ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c3f0b9e91b7a4bb421b945577890ebcead33ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85c3f0b9e91b7a4bb421b945577890ebcead33ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c3f0b9e91b7a4bb421b945577890ebcead33ac/comments", "author": null, "committer": null, "parents": [{"sha": "b799980e58fb0c6d760ddb88c5856b6314efc4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b799980e58fb0c6d760ddb88c5856b6314efc4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b799980e58fb0c6d760ddb88c5856b6314efc4b4"}], "stats": {"total": 465, "additions": 286, "deletions": 179}, "files": [{"sha": "48779adefbbca9c284ebd57cfdd3768feb61a476", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=85c3f0b9e91b7a4bb421b945577890ebcead33ac", "patch": "@@ -1,3 +1,15 @@\n+2010-10-12  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_util.adb (Side_Effect_Free): Return true for object renaming\n+\tdeclarations that were previously generated by Remove_Side_Effects.\n+\n+2010-10-12  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* xref_lib.adb (Get_Full_Type): Display \"private variable\" instead of\n+\t\"???\" when an entity is defined as \"*\" in the ALI file.\n+\t* g-comlin.ads, g-comlin.adb: Fix handling of null parameters.\n+\tMinor reformatting.\n+\n 2010-10-12  Emmanuel Briot  <briot@adacore.com>\n \n \t* g-comlin.adb, g-comlin.ads (Display_Help, Getopt, Current_Section,"}, {"sha": "6624802a15041a6e8d0edcc92af91c652d795700", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=85c3f0b9e91b7a4bb421b945577890ebcead33ac", "patch": "@@ -4645,6 +4645,20 @@ package body Exp_Util is\n            and then Ekind (Entity (Original_Node (N))) /= E_Constant\n          then\n             return False;\n+\n+         --  Remove_Side_Effects generates an object renaming declaration to\n+         --  capture the expression of a class-wide expression. In VM targets\n+         --  the frontend performs no expansion for dispatching calls to\n+         --  class-wide types since they are handled by the VM. Hence, we must\n+         --  locate here if this node corresponds to a previous invocation of\n+         --  Remove_Side_Effects to avoid a never ending loop in the frontend.\n+\n+         elsif VM_Target /= No_VM\n+            and then not Comes_From_Source (N)\n+            and then Is_Class_Wide_Type (Etype (N))\n+            and then Nkind (Parent (N)) = N_Object_Renaming_Declaration\n+         then\n+            return True;\n          end if;\n \n          --  For other than entity names and compile time known values,"}, {"sha": "77e0c7def2f69e814f727951c7eaf40daab2a9fe", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 212, "deletions": 142, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=85c3f0b9e91b7a4bb421b945577890ebcead33ac", "patch": "@@ -29,10 +29,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Characters.Handling;   use Ada.Characters.Handling;\n+with Ada.Characters.Handling;    use Ada.Characters.Handling;\n with Ada.Strings.Unbounded;\n-with Ada.Text_IO;               use Ada.Text_IO;\n+with Ada.Text_IO;                use Ada.Text_IO;\n with Ada.Unchecked_Deallocation;\n+\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n@@ -114,10 +115,12 @@ package body GNAT.Command_Line is\n    --  Add a new element to Line. If Before is True, the item is inserted at\n    --  the beginning, else it is appended.\n \n-   procedure Add (Config : in out Command_Line_Configuration;\n-                  Switch : Switch_Definition);\n-   procedure Add (Def : in out Alias_Definitions_List;\n-                  Alias  : Alias_Definition);\n+   procedure Add\n+     (Config : in out Command_Line_Configuration;\n+      Switch : Switch_Definition);\n+   procedure Add\n+     (Def : in out Alias_Definitions_List;\n+      Alias  : Alias_Definition);\n    --  Add a new element to Def.\n \n    procedure Initialize_Switch_Def\n@@ -260,9 +263,10 @@ package body GNAT.Command_Line is\n \n             if Current = 1 then\n                return String'(1 .. 0 => ' ');\n-            else\n-               --  Otherwise continue with the directory at the previous level\n \n+            --  Otherwise continue with the directory at the previous level\n+\n+            else\n                Current := Current - 1;\n                It.Current_Depth := Current;\n             end if;\n@@ -272,8 +276,8 @@ package body GNAT.Command_Line is\n \n          elsif Is_Directory\n            (It.Dir_Name (1 .. It.Levels (Current).Name_Last) & S (1 .. Last))\n-           and then S (1 .. Last) /= \".\"\n-           and then S (1 .. Last) /= \"..\"\n+             and then S (1 .. Last) /= \".\"\n+             and then S (1 .. Last) /= \"..\"\n          then\n             --  We can go to the next level only if we have not reached the\n             --  maximum depth,\n@@ -327,7 +331,8 @@ package body GNAT.Command_Line is\n    ---------------------\n \n    function Current_Section\n-     (Parser : Opt_Parser := Command_Line_Parser) return String is\n+     (Parser : Opt_Parser := Command_Line_Parser) return String\n+   is\n    begin\n       if Parser.Current_Section = 1 then\n          return \"\";\n@@ -391,7 +396,7 @@ package body GNAT.Command_Line is\n             Parser.Current_Argument := 1;\n             while Parser.Current_Argument <= Parser.Arg_Count\n               and then Parser.Section (Parser.Current_Argument) /=\n-                Parser.Current_Section\n+                                                      Parser.Current_Section\n             loop\n                Parser.Current_Argument := Parser.Current_Argument + 1;\n             end loop;\n@@ -402,7 +407,7 @@ package body GNAT.Command_Line is\n       elsif Parser.Section (Parser.Current_Argument) = 0 then\n          while Parser.Current_Argument <= Parser.Arg_Count\n            and then Parser.Section (Parser.Current_Argument) /=\n-             Parser.Current_Section\n+                                                      Parser.Current_Section\n          loop\n             Parser.Current_Argument := Parser.Current_Argument + 1;\n          end loop;\n@@ -462,6 +467,12 @@ package body GNAT.Command_Line is\n       Switch_Last    : out Integer)\n    is\n    begin\n+      if Switch = \"\" then\n+         Parameter_Type := Parameter_None;\n+         Switch_Last := Switch'Last;\n+         return;\n+      end if;\n+\n       case Switch (Switch'Last) is\n          when ':'    =>\n             Parameter_Type := Parameter_With_Optional_Space;\n@@ -676,7 +687,7 @@ package body GNAT.Command_Line is\n               (Parser.The_Switch,\n                Arg_Num => Parser.Current_Argument,\n                First   => Parser.Current_Index,\n-               Last    => Arg'Last);\n+               Last    => End_Index);\n             Parser.Current_Index := End_Index + 1;\n \n             raise Invalid_Switch;\n@@ -722,7 +733,6 @@ package body GNAT.Command_Line is\n                --  If the switch is of the form <switch>=xxx\n \n                if End_Index < Arg'Last then\n-\n                   if Arg (End_Index + 1) = '='\n                     and then End_Index + 1 < Arg'Last\n                   then\n@@ -759,7 +769,6 @@ package body GNAT.Command_Line is\n                end if;\n \n             when Parameter_No_Space =>\n-\n                if End_Index < Arg'Last then\n                   Set_Parameter\n                     (Parser.The_Parameter,\n@@ -774,7 +783,6 @@ package body GNAT.Command_Line is\n                end if;\n \n             when Parameter_Optional =>\n-\n                if End_Index < Arg'Last then\n                   Set_Parameter\n                     (Parser.The_Parameter,\n@@ -786,7 +794,6 @@ package body GNAT.Command_Line is\n                Dummy := Goto_Next_Argument_In_Section (Parser);\n \n             when Parameter_None =>\n-\n                if Concatenate or else End_Index = Arg'Last then\n                   Parser.Current_Index := End_Index + 1;\n \n@@ -1195,6 +1202,7 @@ package body GNAT.Command_Line is\n       procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n         (Switch_Definitions, Switch_Definitions_List);\n       Tmp : Switch_Definitions_List;\n+\n    begin\n       if Config = null then\n          Config := new Command_Line_Configuration_Record;\n@@ -1223,6 +1231,7 @@ package body GNAT.Command_Line is\n       procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n         (Alias_Definitions, Alias_Definitions_List);\n       Tmp : Alias_Definitions_List := Def;\n+\n    begin\n       if Tmp = null then\n          Def := new Alias_Definitions (1 .. 1);\n@@ -1246,8 +1255,9 @@ package body GNAT.Command_Line is\n       Help        : String := \"\";\n       Section     : String := \"\")\n    is\n-      P1, P2 : Switch_Parameter_Type := Parameter_None;\n+      P1, P2       : Switch_Parameter_Type := Parameter_None;\n       Last1, Last2 : Integer;\n+\n    begin\n       if Switch /= \"\" then\n          Def.Switch := new String'(Switch);\n@@ -1291,7 +1301,7 @@ package body GNAT.Command_Line is\n       Help        : String := \"\";\n       Section     : String := \"\")\n    is\n-      Def    : Switch_Definition;\n+      Def : Switch_Definition;\n    begin\n       if Switch /= \"\" or else Long_Switch /= \"\" then\n          Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n@@ -1418,15 +1428,19 @@ package body GNAT.Command_Line is\n \n    function Get_Switches\n      (Config      : Command_Line_Configuration;\n-      Section     : String := \"\";\n-      Switch_Char : Character := '-') return String\n+      Switch_Char : Character := '-';\n+      Section     : String := \"\") return String\n    is\n       Ret : Ada.Strings.Unbounded.Unbounded_String;\n       use Ada.Strings.Unbounded;\n \n       function Add_Switch (S : String; Index : Integer) return Boolean;\n       --  Add a switch to Ret\n \n+      ----------------\n+      -- Add_Switch --\n+      ----------------\n+\n       function Add_Switch (S : String; Index : Integer) return Boolean is\n          pragma Unreferenced (Index);\n       begin\n@@ -1442,10 +1456,14 @@ package body GNAT.Command_Line is\n \n       Tmp : Boolean;\n       pragma Unreferenced (Tmp);\n+\n+   --  Start of processing for Get_Switches\n+\n    begin\n       Foreach_Switch (Config, Add_Switch'Access, Section => Section);\n \n       --  Adding relevant aliases\n+\n       if Config.Aliases /= null then\n          for A in Config.Aliases'Range loop\n             if Config.Aliases (A).Section.all = Section then\n@@ -1462,10 +1480,11 @@ package body GNAT.Command_Line is\n    ------------------------\n \n    function Section_Delimiters\n-     (Config      : Command_Line_Configuration) return String\n+     (Config : Command_Line_Configuration) return String\n    is\n       use Ada.Strings.Unbounded;\n       Result : Unbounded_String;\n+\n    begin\n       if Config /= null and then Config.Sections /= null then\n          for S in Config.Sections'Range loop\n@@ -1493,7 +1512,8 @@ package body GNAT.Command_Line is\n    -----------------------\n \n    function Get_Configuration\n-     (Cmd : Command_Line) return Command_Line_Configuration is\n+     (Cmd : Command_Line) return Command_Line_Configuration\n+   is\n    begin\n       return Cmd.Config;\n    end Get_Configuration;\n@@ -1574,29 +1594,10 @@ package body GNAT.Command_Line is\n \n                   if not Is_Section then\n                      if Section = null then\n-\n-                        --  Work around some weird cases: some switches may\n-                        --  expect parameters, but have the same value as\n-                        --  longer switches: -gnaty3 (-gnaty, parameter=3) and\n-                        --  -gnatya (-gnatya, no parameter).\n-\n-                        --  So we are calling add_switch here with parameter\n-                        --  attached. This will be anyway correctly handled by\n-                        --  Add_Switch if -gnaty3 is actually provided.\n-\n-                        if Separator (Parser) = ASCII.NUL then\n-                           Add_Switch (Cmd, Sw & Parameter (Parser), \"\");\n-                        else\n-                           Add_Switch (Cmd, Sw, Parameter (Parser));\n-                        end if;\n+                        Add_Switch (Cmd, Sw, Parameter (Parser));\n                      else\n-                        if Separator (Parser) = ASCII.NUL then\n-                           Add_Switch\n-                             (Cmd, Sw & Parameter (Parser), \"\", Section.all);\n-                        else\n-                           Add_Switch\n-                             (Cmd, Sw, Parameter (Parser), Section.all);\n-                        end if;\n+                        Add_Switch\n+                          (Cmd, Sw, Parameter (Parser), Section.all);\n                      end if;\n                   end if;\n                end;\n@@ -1633,7 +1634,8 @@ package body GNAT.Command_Line is\n    function Looking_At\n      (Type_Str  : String;\n       Index     : Natural;\n-      Substring : String) return Boolean is\n+      Substring : String) return Boolean\n+   is\n    begin\n       return Index + Substring'Length - 1 <= Type_Str'Last\n         and then Type_Str (Index .. Index + Substring'Length - 1) = Substring;\n@@ -1734,6 +1736,10 @@ package body GNAT.Command_Line is\n          function Analyze_Simple_Switch\n            (Switch : String; Index : Integer) return Boolean;\n \n+         ---------------------------\n+         -- Analyze_Simple_Switch --\n+         ---------------------------\n+\n          function Analyze_Simple_Switch\n            (Switch : String; Index : Integer) return Boolean\n          is\n@@ -1810,6 +1816,8 @@ package body GNAT.Command_Line is\n             return True;\n          end Analyze_Simple_Switch;\n \n+      --  Start of processing for Group_Analysis\n+\n       begin\n          Idx := Group'First;\n          while Idx <= Group'Last loop\n@@ -1834,8 +1842,9 @@ package body GNAT.Command_Line is\n       function Is_In_Config\n         (Config_Switch : String; Index : Integer) return Boolean\n       is\n-         Last  : Natural;\n-         P     : Switch_Parameter_Type;\n+         Last : Natural;\n+         P    : Switch_Parameter_Type;\n+\n       begin\n          Decompose_Switch (Config_Switch, P, Last);\n \n@@ -1869,6 +1878,7 @@ package body GNAT.Command_Line is\n                   return False;\n             end case;\n          end if;\n+\n          return True;\n       end Is_In_Config;\n \n@@ -1882,22 +1892,29 @@ package body GNAT.Command_Line is\n          Last  : Natural;\n          Param : Natural;\n          P     : Switch_Parameter_Type;\n+\n       begin\n          --  This function is called when we believe the parameter was\n          --  specified as part of the switch, instead of separately. Thus we\n          --  look in the config to find all possible switches.\n \n          Decompose_Switch (Config_Switch, P, Last);\n+\n          if Looking_At\n            (Switch, Switch'First, Config_Switch (Config_Switch'First .. Last))\n          then\n-            Param := Switch'First + Last;   --  First char of parameter\n+            --  Set first char of Param, and last char of Switch\n+\n+            Param := Switch'First + Last;\n             Last  := Switch'First + Last - Config_Switch'First;\n-            --  last char of Switch\n \n             case P is\n+\n+               --  None is already handled in Is_In_Config\n+\n                when Parameter_None =>\n-                  null;  --  Already handled in Is_In_Config\n+                  null;\n+\n                when Parameter_With_Space_Or_Equal =>\n                   if Switch (Param) = ' '\n                     or else Switch (Param) = '='\n@@ -1909,7 +1926,7 @@ package body GNAT.Command_Line is\n                   end if;\n \n                when Parameter_With_Optional_Space =>\n-                  if Switch (Param) = ' '  then\n+                  if Param <= Switch'Last and then Switch (Param) = ' '  then\n                      Param := Param + 1;\n                   end if;\n \n@@ -1928,11 +1945,14 @@ package body GNAT.Command_Line is\n          return True;\n       end Starts_With;\n \n+   --  Start of processing for For_Each_Simple_Switch\n+\n    begin\n       --  First determine if the switch corresponds to one belonging to the\n       --  configuration. If so, run callback and exit.\n \n       Foreach_Switch (Config, Is_In_Config'Access, Section);\n+\n       if Found_In_Config then\n          return;\n       end if;\n@@ -2031,8 +2051,7 @@ package body GNAT.Command_Line is\n       Success : Boolean;\n       pragma Unreferenced (Success);\n    begin\n-      Add_Switch\n-        (Cmd, Switch, Parameter, Section, Add_Before, Success);\n+      Add_Switch (Cmd, Switch, Parameter, Section, Add_Before, Success);\n    end Add_Switch;\n \n    ----------------\n@@ -2048,7 +2067,10 @@ package body GNAT.Command_Line is\n       Success    : out Boolean)\n    is\n       procedure Add_Simple_Switch\n-        (Simple, Separator, Param : String; Index : Integer);\n+        (Simple    : String;\n+         Separator : String;\n+         Param     : String;\n+         Index     : Integer);\n       --  Add a new switch that has had all its aliases expanded, and switches\n       --  ungrouped. We know there are no more aliases in Switches.\n \n@@ -2057,27 +2079,29 @@ package body GNAT.Command_Line is\n       -----------------------\n \n       procedure Add_Simple_Switch\n-        (Simple, Separator, Param : String; Index : Integer)\n+        (Simple    : String;\n+         Separator : String;\n+         Param     : String;\n+         Index     : Integer)\n       is\n          pragma Unreferenced (Index);\n+\n       begin\n          if Cmd.Expanded = null then\n             Cmd.Expanded := new Argument_List'(1 .. 1 => new String'(Simple));\n \n             if Param /= \"\" then\n-               Cmd.Params := new Argument_List'\n-                 (1 .. 1 => new String'(Separator & Param));\n-\n+               Cmd.Params :=\n+                 new Argument_List'(1 .. 1 => new String'(Separator & Param));\n             else\n                Cmd.Params := new Argument_List'(1 .. 1 => null);\n             end if;\n \n             if Section = \"\" then\n                Cmd.Sections := new Argument_List'(1 .. 1 => null);\n-\n             else\n-               Cmd.Sections := new Argument_List'\n-                 (1 .. 1 => new String'(Section));\n+               Cmd.Sections :=\n+                 new Argument_List'(1 .. 1 => new String'(Section));\n             end if;\n \n          else\n@@ -2110,7 +2134,6 @@ package body GNAT.Command_Line is\n                  (Cmd.Params,\n                   new String'(Separator & Param),\n                   Add_Before);\n-\n             else\n                Add\n                  (Cmd.Params,\n@@ -2135,9 +2158,12 @@ package body GNAT.Command_Line is\n       procedure Add_Simple_Switches is\n         new For_Each_Simple_Switch (Add_Simple_Switch);\n \n-   --  Start of processing for Add_Switch\n+      --  Local Variables\n \n       Section_Valid : Boolean := False;\n+\n+   --  Start of processing for Add_Switch\n+\n    begin\n       if Section /= \"\" and then Cmd.Config /= null then\n          for S in Cmd.Config.Sections'Range loop\n@@ -2363,7 +2389,7 @@ package body GNAT.Command_Line is\n    --  Start of processing for Remove_Switch\n \n    begin\n-      Remove_Simple_Switches (Cmd.Config, Switch, Parameter);\n+      Remove_Simple_Switches (Cmd.Config, Section, Switch, Parameter);\n       Free (Cmd.Coalesce);\n    end Remove_Switch;\n \n@@ -2464,10 +2490,10 @@ package body GNAT.Command_Line is\n \n                   Free (Result (C));\n \n-               else\n-                  --  We changed section: we put the grouped switches to the\n-                  --  first place, on continue with the new section.\n+               --  We changed section: we put the grouped switches to the first\n+               --  place, on continue with the new section.\n \n+               else\n                   Result (First) :=\n                     new String'\n                       (Cmd.Config.Prefixes (P).all &\n@@ -2521,6 +2547,7 @@ package body GNAT.Command_Line is\n         (Switch, Separator, Param : String; Index : Integer)\n       is\n          pragma Unreferenced (Separator, Index);\n+\n       begin\n          if Found then\n             for E in Result'Range loop\n@@ -2546,18 +2573,20 @@ package body GNAT.Command_Line is\n       procedure Remove_Cb (Switch, Separator, Param : String; Index : Integer)\n       is\n          pragma Unreferenced (Separator, Index);\n+\n       begin\n          for E in Result'Range loop\n             if Result (E) /= null\n                  and then\n                    (Params (E) = null\n-                    or else Params (E) (Params (E)'First + 1\n-                                            .. Params (E)'Last) = Param)\n+                     or else Params (E) (Params (E)'First + 1\n+                                             .. Params (E)'Last) = Param)\n               and then Result (E).all = Switch\n             then\n                if First > E then\n                   First := E;\n                end if;\n+\n                Free (Result (E));\n                Free (Params (E));\n                return;\n@@ -2934,79 +2963,22 @@ package body GNAT.Command_Line is\n \n    procedure Display_Help (Config : Command_Line_Configuration) is\n       function Switch_Name\n-        (Def : Switch_Definition; Section : String) return String;\n+        (Def : Switch_Definition;\n+         Section : String) return String;\n       --  Return the \"-short, --long=ARG\" string for Def.\n-      --  Returns \"\" if the switch is not in the section\n+      --  Returns \"\" if the switch is not in the section.\n \n       function Param_Name\n-        (P : Switch_Parameter_Type; Name : String := \"ARG\") return String;\n+        (P    : Switch_Parameter_Type;\n+         Name : String := \"ARG\") return String;\n       --  Return the display for a switch parameter\n \n       procedure Display_Section_Help (Section : String);\n       --  Display the help for a specific section (\"\" is the default section)\n \n-      function Param_Name\n-        (P : Switch_Parameter_Type; Name : String := \"ARG\") return String is\n-      begin\n-         case P is\n-            when Parameter_None =>\n-               return \"\";\n-\n-            when Parameter_With_Optional_Space =>\n-               return \" \" & To_Upper (Name);\n-\n-            when Parameter_With_Space_Or_Equal =>\n-               return \"=\" & To_Upper (Name);\n-\n-            when Parameter_No_Space =>\n-               return To_Upper (Name);\n-\n-            when Parameter_Optional =>\n-               return '[' & To_Upper (Name) & ']';\n-         end case;\n-      end Param_Name;\n-\n-      function Switch_Name\n-        (Def : Switch_Definition; Section : String) return String\n-      is\n-         use Ada.Strings.Unbounded;\n-         Result       : Unbounded_String;\n-         P1, P2       : Switch_Parameter_Type;\n-         Last1, Last2 : Integer := 0;\n-      begin\n-         if (Section = \"\" and then Def.Section = null)\n-           or else (Def.Section /= null and then Def.Section.all = Section)\n-         then\n-            if Def.Switch /= null\n-              and then Def.Switch.all = \"*\"\n-            then\n-               return \"[any switch]\";\n-            end if;\n-\n-            if Def.Switch /= null then\n-               Decompose_Switch (Def.Switch.all, P1, Last1);\n-               Append (Result, Def.Switch (Def.Switch'First .. Last1));\n-\n-               if Def.Long_Switch /= null then\n-                  Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n-                  Append (Result, \", \"\n-                          & Def.Long_Switch (Def.Long_Switch'First .. Last2));\n-                  Append (Result, Param_Name (P2, \"ARG\"));\n-\n-               else\n-                  Append (Result, Param_Name (P1, \"ARG\"));\n-               end if;\n-\n-            else  --  Long_Switch necessarily not null\n-               Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n-               Append (Result,\n-                       Def.Long_Switch (Def.Long_Switch'First .. Last2));\n-               Append (Result, Param_Name (P2, \"ARG\"));\n-            end if;\n-         end if;\n-\n-         return To_String (Result);\n-      end Switch_Name;\n+      --------------------------\n+      -- Display_Section_Help --\n+      --------------------------\n \n       procedure Display_Section_Help (Section : String) is\n          Max_Len : Natural := 0;\n@@ -3072,6 +3044,83 @@ package body GNAT.Command_Line is\n          end if;\n       end Display_Section_Help;\n \n+      ----------------\n+      -- Param_Name --\n+      ----------------\n+\n+      function Param_Name\n+        (P    : Switch_Parameter_Type;\n+         Name : String := \"ARG\") return String\n+      is\n+      begin\n+         case P is\n+            when Parameter_None =>\n+               return \"\";\n+\n+            when Parameter_With_Optional_Space =>\n+               return \" \" & To_Upper (Name);\n+\n+            when Parameter_With_Space_Or_Equal =>\n+               return \"=\" & To_Upper (Name);\n+\n+            when Parameter_No_Space =>\n+               return To_Upper (Name);\n+\n+            when Parameter_Optional =>\n+               return '[' & To_Upper (Name) & ']';\n+         end case;\n+      end Param_Name;\n+\n+      -----------------\n+      -- Switch_Name --\n+      -----------------\n+\n+      function Switch_Name\n+        (Def : Switch_Definition;\n+         Section : String) return String\n+      is\n+         use Ada.Strings.Unbounded;\n+         Result       : Unbounded_String;\n+         P1, P2       : Switch_Parameter_Type;\n+         Last1, Last2 : Integer := 0;\n+\n+      begin\n+         if (Section = \"\" and then Def.Section = null)\n+           or else (Def.Section /= null and then Def.Section.all = Section)\n+         then\n+            if Def.Switch /= null\n+              and then Def.Switch.all = \"*\"\n+            then\n+               return \"[any switch]\";\n+            end if;\n+\n+            if Def.Switch /= null then\n+               Decompose_Switch (Def.Switch.all, P1, Last1);\n+               Append (Result, Def.Switch (Def.Switch'First .. Last1));\n+\n+               if Def.Long_Switch /= null then\n+                  Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n+                  Append (Result, \", \"\n+                          & Def.Long_Switch (Def.Long_Switch'First .. Last2));\n+                  Append (Result, Param_Name (P2, \"ARG\"));\n+\n+               else\n+                  Append (Result, Param_Name (P1, \"ARG\"));\n+               end if;\n+\n+            else  --  Long_Switch necessarily not null\n+               Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n+               Append (Result,\n+                       Def.Long_Switch (Def.Long_Switch'First .. Last2));\n+               Append (Result, Param_Name (P2, \"ARG\"));\n+            end if;\n+         end if;\n+\n+         return To_String (Result);\n+      end Switch_Name;\n+\n+   --  Start of processing for Display_Help\n+\n    begin\n       if Config = null then\n          return;\n@@ -3091,6 +3140,7 @@ package body GNAT.Command_Line is\n       end if;\n \n       Display_Section_Help (\"\");\n+\n       if Config.Sections /= null and then Config.Switches /= null then\n          for S in Config.Sections'Range loop\n             Display_Section_Help (Config.Sections (S).all);\n@@ -3115,9 +3165,18 @@ package body GNAT.Command_Line is\n       Section_Name : not null access constant String := Empty_Name'Access;\n \n       procedure Simple_Callback\n-        (Simple_Switch, Separator, Parameter : String; Index : Integer);\n+        (Simple_Switch : String;\n+         Separator     : String;\n+         Parameter     : String;\n+         Index         : Integer);\n+      --  Needs comments ???\n+\n       procedure Do_Callback (Switch, Parameter : String; Index : Integer);\n \n+      -----------------\n+      -- Do_Callback --\n+      -----------------\n+\n       procedure Do_Callback (Switch, Parameter : String; Index : Integer) is\n       begin\n          --  Do automatic handling when possible\n@@ -3164,8 +3223,18 @@ package body GNAT.Command_Line is\n          end if;\n       end Do_Callback;\n \n+      procedure For_Each_Simple\n+        is new For_Each_Simple_Switch (Simple_Callback);\n+\n+      ---------------------\n+      -- Simple_Callback --\n+      ---------------------\n+\n       procedure Simple_Callback\n-        (Simple_Switch, Separator, Parameter : String; Index : Integer)\n+        (Simple_Switch : String;\n+         Separator     : String;\n+         Parameter     : String;\n+         Index         : Integer)\n       is\n          pragma Unreferenced (Separator);\n       begin\n@@ -3174,8 +3243,7 @@ package body GNAT.Command_Line is\n                       Index     => Index);\n       end Simple_Callback;\n \n-      procedure For_Each_Simple\n-        is new For_Each_Simple_Switch (Simple_Callback);\n+   --  Start of processing for Getopt\n \n    begin\n       --  Initialize sections\n@@ -3191,7 +3259,7 @@ package body GNAT.Command_Line is\n          Section_Delimiters       => Section_Delimiters (Config));\n \n       Getopt_Switches := new String'\n-        (Get_Switches (Config, Section_Name.all, Parser.Switch_Character)\n+        (Get_Switches (Config, Parser.Switch_Character, Section_Name.all)\n          & \" h -help\");\n \n       --  Initialize output values for automatically handled switches\n@@ -3258,7 +3326,7 @@ package body GNAT.Command_Line is\n             Free (Getopt_Switches);\n             Getopt_Switches := new String'\n               (Get_Switches\n-                 (Config, Section_Name.all, Parser.Switch_Character));\n+                 (Config, Parser.Switch_Character, Section_Name.all));\n          end if;\n       end loop;\n \n@@ -3269,6 +3337,7 @@ package body GNAT.Command_Line is\n          Free (Getopt_Switches);\n \n          --  Message inspired by \"ls\" on Unix\n+\n          Put_Line (Standard_Error,\n                    Base_Name (Ada.Command_Line.Command_Name)\n                    & \": unrecognized option '\"\n@@ -3298,6 +3367,7 @@ package body GNAT.Command_Line is\n    is\n       Iter  : Command_Line_Iterator;\n       Count : Natural := 0;\n+\n    begin\n       Start (Line, Iter, Expanded => Expanded);\n       while Has_More (Iter) loop"}, {"sha": "668bfd837310b7edfa6cfb0ebb553feac7ecbdce", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=85c3f0b9e91b7a4bb421b945577890ebcead33ac", "patch": "@@ -33,9 +33,9 @@\n \n --  High level package for command line parsing and manipulation\n \n---------------------------------------\n---  Simple parsing of the command line\n---------------------------------------\n+----------------------------------------\n+-- Simple Parsing of the Command Line --\n+----------------------------------------\n \n --  This package provides an interface for parsing command line arguments,\n --  when they are either read from Ada.Command_Line or read from a string list.\n@@ -84,9 +84,9 @@\n --     when Invalid_Parameter => Put_Line (\"No parameter for \" & Full_Switch);\n --  end;\n \n--------------\n---  Sections\n--------------\n+--------------\n+-- Sections --\n+--------------\n \n --  A more complicated example would involve the use of sections for the\n --  switches, as for instance in gnatmake. The same command line is used to\n@@ -113,9 +113,9 @@\n --     end loop;\n --  end;\n \n-------------------------------\n---  Parsing a list of strings\n-------------------------------\n+-------------------------------\n+-- Parsing a List of Strings --\n+-------------------------------\n \n --  The examples above show how to parse the command line when the arguments\n --  are read directly from Ada.Command_Line. However, these arguments can also\n@@ -144,9 +144,9 @@\n --     Free (Parser);\n --  end;\n \n-----------------------------------------------\n---  High level command line configuration\n-----------------------------------------------\n+-------------------------------------------\n+-- High-Level Command Line Configuration --\n+-------------------------------------------\n \n --  As shown above, the code is still relatively low-level. For instance, there\n --  is no way to indicate which switches are related (thus if \"-l\" and \"--long\"\n@@ -219,9 +219,9 @@\n --  Optimization and Verbose have been properly initialized, either to the\n --  default value or to the value found on the command line.\n \n-----------------------------------------------\n---  Creating and manipulating the command line\n-----------------------------------------------\n+------------------------------------------------\n+-- Creating and Manipulating the Command Line --\n+------------------------------------------------\n \n --  This package provides mechanisms to create and modify command lines by\n --  adding or removing arguments from them. The resulting command line is kept\n@@ -276,6 +276,7 @@\n --  and will not be grouped with other parts of the command line.\n \n with Ada.Command_Line;\n+\n with GNAT.Directory_Operations;\n with GNAT.OS_Lib;\n with GNAT.Regexp;\n@@ -537,12 +538,14 @@ package GNAT.Command_Line is\n    -----------------\n    -- Configuring --\n    -----------------\n+\n    --  The following subprograms are used to manipulate a command line\n    --  represented as a string (for instance \"-g -O2\"), as well as parsing\n    --  the switches from such a string. They provide high-level configurations\n    --  to define aliases (a switch is equivalent to one or more other switches)\n    --  or grouping of switches (\"-gnatyac\" is equivalent to \"-gnatya\" and\n    --  \"-gnatyc\").\n+\n    --  See the top of this file for examples on how to use these subprograms\n \n    type Command_Line_Configuration is private;\n@@ -553,8 +556,10 @@ package GNAT.Command_Line is\n    --  Indicates a new switch section. All switches belonging to the same\n    --  section are ordered together, preceded by the section. They are placed\n    --  at the end of the command line (as in \"gnatmake somefile.adb -cargs -g\")\n-   --  The section name should not include the leading '-'.\n-   --  So for instance in the case of gnatmake we would use:\n+   --\n+   --  The section name should not include the leading '-'. So for instance in\n+   --  the case of gnatmake we would use:\n+   --\n    --      Define_Section (Config, \"cargs\");\n    --      Define_Section (Config, \"bargs\");\n \n@@ -567,12 +572,13 @@ package GNAT.Command_Line is\n    --  be expanded as Expanded. For instance, for the GNAT compiler switches,\n    --  we would define \"-gnatwa\" as an alias for \"-gnatwcfijkmopruvz\", ie some\n    --  default warnings to be activated.\n+   --\n    --  This expansion is only done within the specified section, which must\n    --  have been defined first through a call to [Define_Section].\n \n    procedure Define_Prefix\n-     (Config   : in out Command_Line_Configuration;\n-      Prefix   : String);\n+     (Config : in out Command_Line_Configuration;\n+      Prefix : String);\n    --  Indicates that all switches starting with the given prefix should be\n    --  grouped. For instance, for the GNAT compiler we would define \"-gnatw\" as\n    --  a prefix, so that \"-gnatwu -gnatwv\" can be grouped into \"-gnatwuv\" It is\n@@ -666,14 +672,14 @@ package GNAT.Command_Line is\n \n    function Get_Switches\n      (Config      : Command_Line_Configuration;\n-      Section     : String := \"\";\n-      Switch_Char : Character := '-') return String;\n+      Switch_Char : Character := '-';\n+      Section     : String := \"\") return String;\n    --  Get the switches list as expected by Getopt, for a specific section of\n    --  the command line. This list is built using all switches defined\n    --  previously via Define_Switch above.\n \n    function Section_Delimiters\n-     (Config      : Command_Line_Configuration) return String;\n+     (Config : Command_Line_Configuration) return String;\n    --  Return a string suitable for use in Initialize_Option_Scan\n \n    procedure Free (Config : in out Command_Line_Configuration);\n@@ -728,13 +734,16 @@ package GNAT.Command_Line is\n    ------------------------------\n    -- Generating command lines --\n    ------------------------------\n+\n    --  Once the command line configuration has been created, you can build your\n    --  own command line. This will be done in general because you need to spawn\n    --  external tools from your application.\n+\n    --  Although it could be done by concatenating strings, the following\n    --  subprograms will properly take care of grouping switches when possible,\n    --  so as to keep the command line as short as possible. They also provide a\n    --  way to remove a switch from an existing command line.\n+\n    --  For instance:\n    --      declare\n    --         Config : Command_Line_Configuration;\n@@ -920,11 +929,12 @@ package GNAT.Command_Line is\n       Args        : out GNAT.OS_Lib.Argument_List_Access;\n       Expanded    : Boolean := False;\n       Switch_Char : Character := '-');\n-   --  This is a wrapper using the Command_Line_Iterator.\n-   --  It provides a simple way to get all switches (grouped as much as\n-   --  possible), and possibly create an Opt_Parser.\n-   --  [Args] must be freed by the caller.\n-   --  [Expanded] has the same meaning as in [Start].\n+   --  This is a wrapper using the Command_Line_Iterator. It provides a simple\n+   --  way to get all switches (grouped as much as possible), and possibly\n+   --  create an Opt_Parser.\n+   --\n+   --  Args must be freed by the caller.\n+   --  Expanded has the same meaning as in Start.\n \n private\n \n@@ -1020,7 +1030,7 @@ private\n    end record;\n \n    Command_Line_Parser_Data : aliased Opt_Parser_Data\n-     (Ada.Command_Line.Argument_Count);\n+                                        (Ada.Command_Line.Argument_Count);\n    --  The internal data used when parsing the command line\n \n    type Opt_Parser is access all Opt_Parser_Data;\n@@ -1057,24 +1067,24 @@ private\n    --  [Switch] includes the leading '-'\n \n    type Alias_Definition is record\n-      Alias       : GNAT.OS_Lib.String_Access;\n-      Expansion   : GNAT.OS_Lib.String_Access;\n-      Section     : GNAT.OS_Lib.String_Access;\n+      Alias     : GNAT.OS_Lib.String_Access;\n+      Expansion : GNAT.OS_Lib.String_Access;\n+      Section   : GNAT.OS_Lib.String_Access;\n    end record;\n    type Alias_Definitions is array (Natural range <>) of Alias_Definition;\n    type Alias_Definitions_List is access all Alias_Definitions;\n \n    type Command_Line_Configuration_Record is record\n-      Prefixes          : GNAT.OS_Lib.Argument_List_Access;\n+      Prefixes : GNAT.OS_Lib.Argument_List_Access;\n       --  The list of prefixes\n \n-      Sections          : GNAT.OS_Lib.Argument_List_Access;\n+      Sections : GNAT.OS_Lib.Argument_List_Access;\n       --  The list of sections\n \n-      Aliases           : Alias_Definitions_List;\n-      Usage             : GNAT.OS_Lib.String_Access;\n-      Help              : GNAT.OS_Lib.String_Access;\n-      Switches          : Switch_Definitions_List;\n+      Aliases  : Alias_Definitions_List;\n+      Usage    : GNAT.OS_Lib.String_Access;\n+      Help     : GNAT.OS_Lib.String_Access;\n+      Switches : Switch_Definitions_List;\n       --  List of expected switches (Used when expanding switch groups)\n    end record;\n    type Command_Line_Configuration is access Command_Line_Configuration_Record;"}, {"sha": "1a0d2c4b5395e9ea930822d8d226fea8bd111931", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c3f0b9e91b7a4bb421b945577890ebcead33ac/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=85c3f0b9e91b7a4bb421b945577890ebcead33ac", "patch": "@@ -555,6 +555,7 @@ package body Xref_Lib is\n          when 'Y' => return \"entry\";\n \n          when '+' => return \"private type\";\n+         when '*' => return \"private variable\";\n \n          --  The above should be the only possibilities, but for this kind\n          --  of informational output, we don't want to bomb if we find"}]}