{"sha": "eba55d501f7a2e4b95b7fedd3463424e403f2c54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJhNTVkNTAxZjdhMmU0Yjk1YjdmZWRkMzQ2MzQyNGU0MDNmMmM1NA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-11-24T10:17:26Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-11-24T10:17:26Z"}, "message": "re PR fortran/33541 (gfortran wrongly imports renamed-use-associated symbol unrenamed)\n\n2007-11-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33541\n\t* module.c (find_symtree_for_symbol): Move to new location.\n\t(find_symbol): New function.\n\t(load_generic_interfaces): Rework completely so that symtrees\n\thave the local name and symbols have the use name.  Renamed\n\tgeneric interfaces exclude the use of the interface without an\n\tONLY clause (11.3.2).\n\t(read_module): Implement 11.3.2 in the same way as for generic\n\tinterfaces.\n\n2007-11-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33541\n\t* gfortran.dg/nested_modules_1.f90: Change the reference to\n\tFOO, forbidden by the standard, to a reference to W.\n\t* gfortran.dg/use_only_1.f90: New test.\n\nFrom-SVN: r130395", "tree": {"sha": "21ec542f34f69afb88c52c5d30f8758eca1c37d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21ec542f34f69afb88c52c5d30f8758eca1c37d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eba55d501f7a2e4b95b7fedd3463424e403f2c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eba55d501f7a2e4b95b7fedd3463424e403f2c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eba55d501f7a2e4b95b7fedd3463424e403f2c54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eba55d501f7a2e4b95b7fedd3463424e403f2c54/comments", "author": null, "committer": null, "parents": [{"sha": "a298680ca5bbf7254b79e310e683c33baffa18af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a298680ca5bbf7254b79e310e683c33baffa18af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a298680ca5bbf7254b79e310e683c33baffa18af"}], "stats": {"total": 280, "additions": 239, "deletions": 41}, "files": [{"sha": "aedee5e979d27a25273a2ad5d73dbca03a91ca41", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eba55d501f7a2e4b95b7fedd3463424e403f2c54", "patch": "@@ -1,3 +1,15 @@\n+2007-11-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33541\n+\t* module.c (find_symtree_for_symbol): Move to new location.\n+\t(find_symbol): New function.\n+\t(load_generic_interfaces): Rework completely so that symtrees\n+\thave the local name and symbols have the use name.  Renamed\n+\tgeneric interfaces exclude the use of the interface without an\n+\tONLY clause (11.3.2).\n+\t(read_module): Implement 11.3.2 in the same way as for generic\n+\tinterfaces.\n+\n 2007-11-23 Christopher D. Rickett <crickett@lanl.gov>\n \n \t* trans-common.c (build_common_decl): Fix the alignment for"}, {"sha": "5f03b49744c4bcdf8102b82ad2a434745363295c", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 128, "deletions": 40, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=eba55d501f7a2e4b95b7fedd3463424e403f2c54", "patch": "@@ -3104,6 +3104,63 @@ mio_symbol (gfc_symbol *sym)\n \n /************************* Top level subroutines *************************/\n \n+/* Given a root symtree node and a symbol, try to find a symtree that\n+   references the symbol that is not a unique name.  */\n+\n+static gfc_symtree *\n+find_symtree_for_symbol (gfc_symtree *st, gfc_symbol *sym)\n+{\n+  gfc_symtree *s = NULL;\n+\n+  if (st == NULL)\n+    return s;\n+\n+  s = find_symtree_for_symbol (st->right, sym);\n+  if (s != NULL)\n+    return s;\n+  s = find_symtree_for_symbol (st->left, sym);\n+  if (s != NULL)\n+    return s;\n+\n+  if (st->n.sym == sym && !check_unique_name (st->name))\n+    return st;\n+\n+  return s;\n+}\n+\n+\n+/* A recursive function to look for a speficic symbol by name and by\n+   module.  Whilst several symtrees might point to one symbol, its\n+   is sufficient for the purposes here than one exist.  Note that\n+   generic interfaces are distinguished.  */\n+static gfc_symtree *\n+find_symbol (gfc_symtree *st, const char *name,\n+\t     const char *module, int generic)\n+{\n+  int c;\n+  gfc_symtree *retval;\n+\n+  if (st == NULL || st->n.sym == NULL)\n+    return NULL;\n+\n+  c = strcmp (name, st->n.sym->name);\n+  if (c == 0 && st->n.sym->module\n+\t     && strcmp (module, st->n.sym->module) == 0)\n+    {\n+      if ((!generic && !st->n.sym->attr.generic)\n+\t     || (generic && st->n.sym->attr.generic))\n+\treturn st;\n+    }\n+\n+  retval = find_symbol (st->left, name, module, generic);\n+\n+  if (retval == NULL)\n+    retval = find_symbol (st->right, name, module, generic);\n+\n+  return retval;\n+}\n+\n+\n /* Skip a list between balanced left and right parens.  */\n \n static void\n@@ -3219,41 +3276,79 @@ load_generic_interfaces (void)\n \n       for (i = 1; i <= n; i++)\n \t{\n+\t  gfc_symtree *st;\n \t  /* Decide if we need to load this one or not.  */\n \t  p = find_use_name_n (name, &i, false);\n \n-\t  if (p == NULL || gfc_find_symbol (p, NULL, 0, &sym))\n+\t  st = find_symbol (gfc_current_ns->sym_root,\n+\t\t\t    name, module_name, 1);\n+\n+\t  if (!p || gfc_find_symbol (p, NULL, 0, &sym))\n \t    {\n-\t      while (parse_atom () != ATOM_RPAREN);\n+\t      /* Skip the specific names for these cases.  */\n+\t      while (i == 1 && parse_atom () != ATOM_RPAREN);\n+\n \t      continue;\n \t    }\n \n-\t  if (sym == NULL)\n+\t  /* If the symbol exists already and is being USEd without being\n+\t     in an ONLY clause, do not load a new symtree(11.3.2).  */\n+\t  if (!only_flag && st)\n+\t    sym = st->n.sym;\n+\n+\t  if (!sym)\n \t    {\n-\t      gfc_get_symbol (p, NULL, &sym);\n+\t      /* Make symtree inaccessible by renaming if the symbol has\n+\t\t been added by a USE statement without an ONLY(11.3.2).  */\n+\t      if (st && !st->n.sym->attr.use_only && only_flag\n+\t\t     && strcmp (st->n.sym->module, module_name) == 0)\n+\t\tst->name = gfc_get_string (\"hidden.%s\", name);\n+\t      else if (st)\n+\t\t{\n+\t\t  sym = st->n.sym;\n+\t\t  if (strcmp (st->name, p) != 0)\n+\t\t    {\n+\t              st = gfc_new_symtree (&gfc_current_ns->sym_root, p);\n+\t\t      st->n.sym = sym;\n+\t\t      sym->refs++;\n+\t\t    }\n+\t\t}\n \n-\t      sym->attr.flavor = FL_PROCEDURE;\n-\t      sym->attr.generic = 1;\n-\t      sym->attr.use_assoc = 1;\n+\t      /* Since we haven't found a valid generic interface, we had\n+\t\t better make one.  */\n+\t      if (!sym)\n+\t\t{\n+\t\t  gfc_get_symbol (p, NULL, &sym);\n+\t\t  sym->name = gfc_get_string (name);\n+\t\t  sym->module = gfc_get_string (module_name);\n+\t\t  sym->attr.flavor = FL_PROCEDURE;\n+\t\t  sym->attr.generic = 1;\n+\t\t  sym->attr.use_assoc = 1;\n+\t\t}\n \t    }\n \t  else\n \t    {\n \t      /* Unless sym is a generic interface, this reference\n \t\t is ambiguous.  */\n-\t      gfc_symtree *st;\n-\t      p = p ? p : name;\n-\t      st = gfc_find_symtree (gfc_current_ns->sym_root, p);\n-\t      if (!sym->attr.generic\n-\t\t  && sym->module != NULL\n-\t\t  && strcmp(module, sym->module) != 0)\n+\t      if (st == NULL)\n+\t        st = gfc_find_symtree (gfc_current_ns->sym_root, p);\n+\n+\t      sym = st->n.sym;\n+\n+\t      if (st && !sym->attr.generic\n+\t\t     && sym->module\n+\t\t     && strcmp(module, sym->module))\n \t\tst->ambiguous = 1;\n \t    }\n+\n+\t  sym->attr.use_only = only_flag;\n+\n \t  if (i == 1)\n \t    {\n \t      mio_interface_rest (&sym->generic);\n \t      generic = sym->generic;\n \t    }\n-\t  else\n+\t  else if (!sym->generic)\n \t    {\n \t      sym->generic = generic;\n \t      sym->attr.generic_copy = 1;\n@@ -3468,31 +3563,6 @@ read_cleanup (pointer_info *p)\n }\n \n \n-/* Given a root symtree node and a symbol, try to find a symtree that\n-   references the symbol that is not a unique name.  */\n-\n-static gfc_symtree *\n-find_symtree_for_symbol (gfc_symtree *st, gfc_symbol *sym)\n-{\n-  gfc_symtree *s = NULL;\n-\n-  if (st == NULL)\n-    return s;\n-\n-  s = find_symtree_for_symbol (st->right, sym);\n-  if (s != NULL)\n-    return s;\n-  s = find_symtree_for_symbol (st->left, sym);\n-  if (s != NULL)\n-    return s;\n-\n-  if (st->n.sym == sym && !check_unique_name (st->name))\n-    return st;\n-\n-  return s;\n-}\n-\n-\n /* Read a module file.  */\n \n static void\n@@ -3609,14 +3679,24 @@ read_module (void)\n \n \t  /* Skip symtree nodes not in an ONLY clause, unless there\n \t     is an existing symtree loaded from another USE statement.  */\n-\t  if (p == NULL)\n+\t  if (p == NULL && only_flag)\n \t    {\n \t      st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n \t      if (st != NULL)\n \t\tinfo->u.rsym.symtree = st;\n \t      continue;\n \t    }\n \n+\t  /* If a symbol of the same name and module exists already,\n+\t     this symbol, which is not in an ONLY clause, must not be\n+\t     added to the namespace(11.3.2).  Note that find_symbol\n+\t     only returns the first occurrence that it finds.  */\n+\t  if (!only_flag\n+\t\t&& strcmp (name, module_name) != 0\n+\t\t&& find_symbol (gfc_current_ns->sym_root, name,\n+\t\t\t\tmodule_name, 0))\n+\t    continue;\n+\n \t  st = gfc_find_symtree (gfc_current_ns->sym_root, p);\n \n \t  if (st != NULL)\n@@ -3628,6 +3708,14 @@ read_module (void)\n \t    }\n \t  else\n \t    {\n+\t      st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n+\n+\t      /* Make symtree inaccessible by renaming if the symbol has\n+\t\t been added by a USE statement without an ONLY(11.3.2).  */\n+\t      if (st && !st->n.sym->attr.use_only && only_flag\n+\t\t     && strcmp (st->n.sym->module, module_name) == 0)\n+\t\tst->name = gfc_get_string (\"hidden.%s\", name);\n+\n \t      /* Create a symtree node in the current namespace for this\n \t\t symbol.  */\n \t      st = check_unique_name (p)"}, {"sha": "d83f28f2059f3b8c45930e0569594ce0b6948aeb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eba55d501f7a2e4b95b7fedd3463424e403f2c54", "patch": "@@ -1,3 +1,10 @@\n+2007-11-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33541\n+\t* gfortran.dg/nested_modules_1.f90: Change the reference to\n+\tFOO, forbidden by the standard, to a reference to W.\n+\t* gfortran.dg/use_only_1.f90: New test.\n+\n 2007-11-23  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34209"}, {"sha": "a0bd9636144b88fff73dd38cbb6fbf21467dec0e", "filename": "gcc/testsuite/gfortran.dg/nested_modules_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_1.f90?ref=eba55d501f7a2e4b95b7fedd3463424e403f2c54", "patch": "@@ -35,7 +35,7 @@ end module mod2\n \n        use mod2\n        use mod0, only: w=>foo\n-       FOO = (0.0d0, 1.0d0)\n+       w = (0.0d0, 1.0d0)  ! Was foo but this is forbidden (11.3.2)\n        KANGA = (0.0d0, -1.0d0)\n        ROBIN = (99.0d0, 99.0d0)\n        call eyeore ()"}, {"sha": "30808fb856fa1f2325467f6ab2c6b0b3e9eee4c4", "filename": "gcc/testsuite/gfortran.dg/use_only_1.f90", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55d501f7a2e4b95b7fedd3463424e403f2c54/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_1.f90?ref=eba55d501f7a2e4b95b7fedd3463424e403f2c54", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do run }\n+! { dg-options \"-O1\" }\n+! Checks the fix for PR33541, in which a requirement of\n+! F95 11.3.2 was not being met: The local names 'x' and\n+! 'y' coming from the USE statements without an ONLY clause\n+! should not survive in the presence of the locally renamed\n+! versions. In fixing the PR, the same correction has been\n+! made to generic interfaces.\n+!\n+! Reported by Reported by John Harper in\n+! http://gcc.gnu.org/ml/fortran/2007-09/msg00397.html\n+!\n+MODULE xmod\n+  integer(4) :: x = -666\n+  private foo, bar\n+  interface xfoobar\n+    module procedure foo, bar\n+  end interface\n+contains\n+  integer function foo ()\n+    foo = 42\n+  end function\n+  integer function bar (a)\n+    integer a\n+    bar = a\n+  end function\n+END MODULE xmod\n+\n+MODULE ymod\n+  integer(4) :: y = -666\n+  private foo, bar\n+  interface yfoobar\n+    module procedure foo, bar\n+  end interface\n+contains\n+  integer function foo ()\n+    foo = 42\n+  end function\n+  integer function bar (a)\n+    integer a\n+    bar = a\n+  end function\n+END MODULE ymod\n+\n+  integer function xfoobar () ! These function as defaults should...\n+    xfoobar = 99\n+  end function\n+\n+  integer function yfoobar () ! ...the rename works correctly.\n+    yfoobar = 99\n+  end function\n+\n+PROGRAM test2uses\n+  implicit integer(2) (a-z)\n+  x = 666  ! These assignments generate implicitly typed\n+  y = 666  ! local variables 'x' and 'y'.\n+  call test1\n+  call test2\n+  call test3\n+contains\n+  subroutine test1  ! Test the fix of the original PR\n+    USE xmod\n+    USE xmod, ONLY: xrenamed => x\n+    USE ymod, ONLY: yrenamed => y\n+    USE ymod\n+    implicit integer(2) (a-z)\n+    if (kind(xrenamed) == kind(x)) call abort ()\n+    if (kind(yrenamed) == kind(y)) call abort ()\n+  end subroutine\n+\n+  subroutine test2  ! Test the fix applies to generic interfaces\n+    USE xmod\n+    USE xmod, ONLY: xfoobar_renamed => xfoobar\n+    USE ymod, ONLY: yfoobar_renamed => yfoobar\n+    USE ymod\n+    if (xfoobar_renamed (42) == xfoobar ()) call abort ()\n+    if (yfoobar_renamed (42) == yfoobar ()) call abort ()\n+  end subroutine\n+\n+  subroutine test3  ! Check that USE_NAME == LOCAL_NAME is OK\n+    USE xmod\n+    USE xmod, ONLY: x => x, xfoobar => xfoobar\n+    USE ymod, ONLY: y => y, yfoobar => yfoobar\n+    USE ymod\n+    if (kind (x) /= 4) call abort ()    \n+    if (kind (y) /= 4) call abort ()    \n+    if (xfoobar (77) /= 77_4) call abort ()\n+    if (yfoobar (77) /= 77_4) call abort ()\n+  end subroutine\n+END PROGRAM test2uses\n+! { dg-final { cleanup-modules \"xmod ymod\" } }"}]}