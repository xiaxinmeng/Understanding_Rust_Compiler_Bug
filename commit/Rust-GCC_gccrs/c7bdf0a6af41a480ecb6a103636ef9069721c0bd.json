{"sha": "c7bdf0a6af41a480ecb6a103636ef9069721c0bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiZGYwYTZhZjQxYTQ4MGVjYjZhMTAzNjM2ZWY5MDY5NzIxYzBiZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-05-25T02:10:46Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-05-25T02:10:46Z"}, "message": "config.gcc: Remove all stanzas for previously obsoleted systems.\n\n\t* config.gcc: Remove all stanzas for previously obsoleted\n\tsystems.  Where necessary, add explicit error stanzas to\n\tprevent removed systems from being misidentified as something\n\telse.  Begin a fresh obsoletions list, with the systems that\n\twere reprieved last round.\n\t* doc/install.texi: Remove all mention of dead targets.\n\t* fixinc/mkfixinc.sh: Likewise.\n\n\t* config/arm/arm.h: Bit 31 of target_flags is no longer\n\treserved.\n\n\t* config/1750a/1750a-protos.h, config/1750a/1750a.c,\n\tconfig/1750a/1750a.h, config/1750a/1750a.md, config/1750a/ms1750.inc,\n\tconfig/a29k/a29k-protos.h, config/a29k/a29k.c, config/a29k/a29k.h,\n\tconfig/a29k/a29k.md, config/a29k/rtems.h, config/a29k/t-a29kbare,\n\tconfig/a29k/t-vx29k, config/a29k/unix.h, config/a29k/vx29k.h,\n\tconfig/alpha/osf12.h, config/alpha/osf2or3.h,\n\tconfig/arm/arm-wince-pe.h, config/arm/arm.h, config/arm/riscix.h,\n\tconfig/arm/riscix1-1.h, config/arm/rix-gas.h, config/arm/t-riscix,\n\tconfig/clipper/clipper-protos.h, config/clipper/clipper.c,\n\tconfig/clipper/clipper.h, config/clipper/clipper.md,\n\tconfig/clipper/clix.h, config/convex/convex-protos.h,\n\tconfig/convex/convex.c, config/convex/convex.h,\n\tconfig/convex/convex.md, config/convex/fixinc.convex,\n\tconfig/convex/proto.h, config/elxsi/elxsi-protos.h,\n\tconfig/elxsi/elxsi.c, config/elxsi/elxsi.h, config/elxsi/elxsi.md,\n\tconfig/i386/386bsd.h, config/i386/aix386.h, config/i386/aix386ng.h,\n\tconfig/i386/bsd386.h, config/i386/dgux.h, config/i386/djgpp-rtems.h,\n\tconfig/i386/isc.h, config/i386/iscdbx.h, config/i386/linux-oldld.h,\n\tconfig/i386/next.h, config/i386/osf1-ci.asm, config/i386/osf1-cn.asm,\n\tconfig/i386/osf1elf.h, config/i386/osf1elfgdb.h, config/i386/osfelf.h,\n\tconfig/i386/osfrose.h, config/i386/rtems.h, config/i386/seq-gas.h,\n\tconfig/i386/seq-sysv3.h, config/i386/seq2-sysv3.h,\n\tconfig/i386/sequent.h, config/i386/sun.h, config/i386/sun386.h,\n\tconfig/i386/t-dgux, config/i386/t-next, config/i386/t-osf,\n\tconfig/i386/t-osf1elf, config/i860/bsd-gas.h, config/i860/bsd.h,\n\tconfig/i860/fx2800.h, config/i860/i860-protos.h, config/i860/i860.c,\n\tconfig/i860/i860.h, config/i860/i860.md, config/i860/mach.h,\n\tconfig/i860/paragon.h, config/i860/sysv3.h, config/i860/sysv4.h,\n\tconfig/i860/t-fx2800, config/i860/varargs.asm, config/m68k/a-ux.h,\n\tconfig/m68k/altos3068.h, config/m68k/apollo68.h,\n\tconfig/m68k/aux-crt1.c, config/m68k/aux-crt2.asm,\n\tconfig/m68k/aux-crtn.asm, config/m68k/aux-exit.c,\n\tconfig/m68k/aux-low.gld, config/m68k/aux-mcount.c,\n\tconfig/m68k/auxas.h, config/m68k/auxgas.h, config/m68k/auxgld.h,\n\tconfig/m68k/auxld.h, config/m68k/ctix.h, config/m68k/dpx2.h,\n\tconfig/m68k/dpx2.ifile, config/m68k/dpx2cdbx.h, config/m68k/dpx2g.h,\n\tconfig/m68k/isi-nfp.h, config/m68k/isi.h, config/m68k/lynx-ng.h,\n\tconfig/m68k/lynx.h, config/m68k/math-3300.h, config/m68k/news.h,\n\tconfig/m68k/news3.h, config/m68k/news3gas.h, config/m68k/newsgas.h,\n\tconfig/m68k/next.h, config/m68k/next21.h, config/m68k/rtems.h,\n\tconfig/m68k/t-aux, config/m68k/t-lynx, config/m68k/t-next,\n\tconfig/m68k/x-next, config/m88k/dgux.h, config/m88k/dgux.ld,\n\tconfig/m88k/dguxbcs.h, config/m88k/dolph.h, config/m88k/dolphin.ld,\n\tconfig/m88k/luna.h, config/m88k/m88k-coff.h, config/m88k/sysv3.h,\n\tconfig/m88k/t-bug, config/m88k/t-dgux, config/m88k/t-dgux-gas,\n\tconfig/m88k/t-dguxbcs, config/m88k/t-dolph, config/m88k/t-m88k-gas,\n\tconfig/m88k/t-tekXD88, config/m88k/tekXD88.h, config/m88k/tekXD88.ld,\n\tconfig/mips/bsd-4.h, config/mips/bsd-5.h, config/mips/dec-bsd.h,\n\tconfig/mips/dec-osf1.h, config/mips/elflorion.h,\n\tconfig/mips/iris4loser.h, config/mips/mips-5.h, config/mips/news4.h,\n\tconfig/mips/news5.h, config/mips/nws3250v4.h, config/mips/osfrose.h,\n\tconfig/mips/svr3-4.h, config/mips/svr3-5.h, config/mips/svr4-4.h,\n\tconfig/mips/svr4-5.h, config/mips/svr4-t.h, config/mips/t-bsd,\n\tconfig/mips/t-bsd-gas, config/mips/t-svr3, config/mips/t-svr3-gas,\n\tconfig/mips/t-svr4, config/mips/t-svr4-gas, config/mips/t-ultrix,\n\tconfig/mips/ultrix.h, config/nextstep-protos.h, config/nextstep.c,\n\tconfig/nextstep.h, config/nextstep21.h, config/ns32k/encore.h,\n\tconfig/ns32k/merlin.h, config/ns32k/pc532-mach.h,\n\tconfig/ns32k/pc532-min.h, config/ns32k/pc532.h,\n\tconfig/ns32k/sequent.h, config/ns32k/tek6000.h,\n\tconfig/ns32k/tek6100.h, config/ns32k/tek6200.h, config/pj/lib1funcs.S,\n\tconfig/pj/linux.h, config/pj/pj-protos.h, config/pj/pj.c,\n\tconfig/pj/pj.h, config/pj/pj.md, config/pj/pjl.h, config/pj/t-pj,\n\tconfig/sparc/rtems.h, config/we32k/we32k-protos.h,\n\tconfig/we32k/we32k.c, config/we32k/we32k.h, config/we32k/we32k.md:\n\tDelete file.\n\nFrom-SVN: r53862", "tree": {"sha": "438092b3a65efe5f21ab0cbc2da199e04d05c211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438092b3a65efe5f21ab0cbc2da199e04d05c211"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7bdf0a6af41a480ecb6a103636ef9069721c0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bdf0a6af41a480ecb6a103636ef9069721c0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7bdf0a6af41a480ecb6a103636ef9069721c0bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/comments", "author": null, "committer": null, "parents": [{"sha": "755ac5d48039681a08775d40dae2be21298dbb99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/755ac5d48039681a08775d40dae2be21298dbb99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/755ac5d48039681a08775d40dae2be21298dbb99"}], "stats": {"total": 44958, "additions": 159, "deletions": 44799}, "files": [{"sha": "418fb02f39b5528156b7d16559731a2b3813db7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 4, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7bdf0a6af41a480ecb6a103636ef9069721c0bd", "patch": "@@ -1,3 +1,83 @@\n+2002-05-24  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* config.gcc: Remove all stanzas for previously obsoleted\n+\tsystems.  Where necessary, add explicit error stanzas to\n+\tprevent removed systems from being misidentified as something\n+\telse.  Begin a fresh obsoletions list, with the systems that\n+\twere reprieved last round.\n+\t* doc/install.texi: Remove all mention of dead targets.\n+\t* fixinc/mkfixinc.sh: Likewise.\n+\n+\t* config/arm/arm.h: Bit 31 of target_flags is no longer\n+\treserved.\n+\n+\t* config/1750a/1750a-protos.h, config/1750a/1750a.c,\n+\tconfig/1750a/1750a.h, config/1750a/1750a.md, config/1750a/ms1750.inc,\n+\tconfig/a29k/a29k-protos.h, config/a29k/a29k.c, config/a29k/a29k.h,\n+\tconfig/a29k/a29k.md, config/a29k/rtems.h, config/a29k/t-a29kbare,\n+\tconfig/a29k/t-vx29k, config/a29k/unix.h, config/a29k/vx29k.h,\n+\tconfig/alpha/osf12.h, config/alpha/osf2or3.h,\n+\tconfig/arm/arm-wince-pe.h, config/arm/arm.h, config/arm/riscix.h,\n+\tconfig/arm/riscix1-1.h, config/arm/rix-gas.h, config/arm/t-riscix,\n+\tconfig/clipper/clipper-protos.h, config/clipper/clipper.c,\n+\tconfig/clipper/clipper.h, config/clipper/clipper.md,\n+\tconfig/clipper/clix.h, config/convex/convex-protos.h,\n+\tconfig/convex/convex.c, config/convex/convex.h,\n+\tconfig/convex/convex.md, config/convex/fixinc.convex,\n+\tconfig/convex/proto.h, config/elxsi/elxsi-protos.h,\n+\tconfig/elxsi/elxsi.c, config/elxsi/elxsi.h, config/elxsi/elxsi.md,\n+\tconfig/i386/386bsd.h, config/i386/aix386.h, config/i386/aix386ng.h,\n+\tconfig/i386/bsd386.h, config/i386/dgux.h, config/i386/djgpp-rtems.h,\n+\tconfig/i386/isc.h, config/i386/iscdbx.h, config/i386/linux-oldld.h,\n+\tconfig/i386/next.h, config/i386/osf1-ci.asm, config/i386/osf1-cn.asm,\n+\tconfig/i386/osf1elf.h, config/i386/osf1elfgdb.h, config/i386/osfelf.h,\n+\tconfig/i386/osfrose.h, config/i386/rtems.h, config/i386/seq-gas.h,\n+\tconfig/i386/seq-sysv3.h, config/i386/seq2-sysv3.h,\n+\tconfig/i386/sequent.h, config/i386/sun.h, config/i386/sun386.h,\n+\tconfig/i386/t-dgux, config/i386/t-next, config/i386/t-osf,\n+\tconfig/i386/t-osf1elf, config/i860/bsd-gas.h, config/i860/bsd.h,\n+\tconfig/i860/fx2800.h, config/i860/i860-protos.h, config/i860/i860.c,\n+\tconfig/i860/i860.h, config/i860/i860.md, config/i860/mach.h,\n+\tconfig/i860/paragon.h, config/i860/sysv3.h, config/i860/sysv4.h,\n+\tconfig/i860/t-fx2800, config/i860/varargs.asm, config/m68k/a-ux.h,\n+\tconfig/m68k/altos3068.h, config/m68k/apollo68.h,\n+\tconfig/m68k/aux-crt1.c, config/m68k/aux-crt2.asm,\n+\tconfig/m68k/aux-crtn.asm, config/m68k/aux-exit.c,\n+\tconfig/m68k/aux-low.gld, config/m68k/aux-mcount.c,\n+\tconfig/m68k/auxas.h, config/m68k/auxgas.h, config/m68k/auxgld.h,\n+\tconfig/m68k/auxld.h, config/m68k/ctix.h, config/m68k/dpx2.h,\n+\tconfig/m68k/dpx2.ifile, config/m68k/dpx2cdbx.h, config/m68k/dpx2g.h,\n+\tconfig/m68k/isi-nfp.h, config/m68k/isi.h, config/m68k/lynx-ng.h,\n+\tconfig/m68k/lynx.h, config/m68k/math-3300.h, config/m68k/news.h,\n+\tconfig/m68k/news3.h, config/m68k/news3gas.h, config/m68k/newsgas.h,\n+\tconfig/m68k/next.h, config/m68k/next21.h, config/m68k/rtems.h,\n+\tconfig/m68k/t-aux, config/m68k/t-lynx, config/m68k/t-next,\n+\tconfig/m68k/x-next, config/m88k/dgux.h, config/m88k/dgux.ld,\n+\tconfig/m88k/dguxbcs.h, config/m88k/dolph.h, config/m88k/dolphin.ld,\n+\tconfig/m88k/luna.h, config/m88k/m88k-coff.h, config/m88k/sysv3.h,\n+\tconfig/m88k/t-bug, config/m88k/t-dgux, config/m88k/t-dgux-gas,\n+\tconfig/m88k/t-dguxbcs, config/m88k/t-dolph, config/m88k/t-m88k-gas,\n+\tconfig/m88k/t-tekXD88, config/m88k/tekXD88.h, config/m88k/tekXD88.ld,\n+\tconfig/mips/bsd-4.h, config/mips/bsd-5.h, config/mips/dec-bsd.h,\n+\tconfig/mips/dec-osf1.h, config/mips/elflorion.h,\n+\tconfig/mips/iris4loser.h, config/mips/mips-5.h, config/mips/news4.h,\n+\tconfig/mips/news5.h, config/mips/nws3250v4.h, config/mips/osfrose.h,\n+\tconfig/mips/svr3-4.h, config/mips/svr3-5.h, config/mips/svr4-4.h,\n+\tconfig/mips/svr4-5.h, config/mips/svr4-t.h, config/mips/t-bsd,\n+\tconfig/mips/t-bsd-gas, config/mips/t-svr3, config/mips/t-svr3-gas,\n+\tconfig/mips/t-svr4, config/mips/t-svr4-gas, config/mips/t-ultrix,\n+\tconfig/mips/ultrix.h, config/nextstep-protos.h, config/nextstep.c,\n+\tconfig/nextstep.h, config/nextstep21.h, config/ns32k/encore.h,\n+\tconfig/ns32k/merlin.h, config/ns32k/pc532-mach.h,\n+\tconfig/ns32k/pc532-min.h, config/ns32k/pc532.h,\n+\tconfig/ns32k/sequent.h, config/ns32k/tek6000.h,\n+\tconfig/ns32k/tek6100.h, config/ns32k/tek6200.h, config/pj/lib1funcs.S,\n+\tconfig/pj/linux.h, config/pj/pj-protos.h, config/pj/pj.c,\n+\tconfig/pj/pj.h, config/pj/pj.md, config/pj/pjl.h, config/pj/t-pj,\n+\tconfig/sparc/rtems.h, config/we32k/we32k-protos.h,\n+\tconfig/we32k/we32k.c, config/we32k/we32k.h, config/we32k/we32k.md:\n+\tDelete file.\n+\n 2002-05-24  Richard Henderson  <rth@redhat.com>\n \n \t* flags.h (TLS_MODEL_GLOBAL_DYNAMIC): Set to 1.\n@@ -34,8 +114,8 @@\n \n 2002-05-24  Richard Henderson  <rth@redhat.com>\n \n-        * varasm.c (asm_output_bss): Always output one byte.\n-        * config/alpha/elf.h (ASM_OUTPUT_ALIGNED_LOCAL): Likewise.\n+\t* varasm.c (asm_output_bss): Always output one byte.\n+\t* config/alpha/elf.h (ASM_OUTPUT_ALIGNED_LOCAL): Likewise.\n \n 2002-05-24  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n@@ -56,7 +136,7 @@\n \t* config/i386/mingw32.h (CPP_SPEC): Remove -remap.\n \n 2002-05-23  Gabriel Dos Reis  <gdr@codesourcery.com>\n-            Zack Weinberg     <zack@codesourcery.com>\n+\t    Zack Weinberg     <zack@codesourcery.com>\n \n \t* config/i386/mingw32.h (OUTPUT_QUOTED_STRING): Properly output\n \tquoted strings.\n@@ -430,7 +510,7 @@ Thu May 23 09:22:23 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \tdynamic linker.\n \t(STARTFILE_PREFIX_SPEC): Define.\n \t(STARTFILE_LINUX_SPEC, ENDFILE_LINUX_SPEC): Rewrite without\n-        absolute paths.\n+\tabsolute paths.\n \n 2002-05-22  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "171173b0b5618f14bda4a176db8a5e95ffe8f4ee", "filename": "gcc/config.gcc", "status": "modified", "additions": 49, "deletions": 872, "changes": 921, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c7bdf0a6af41a480ecb6a103636ef9069721c0bd", "patch": "@@ -208,77 +208,22 @@ gnu_ld=\"$gnu_ld_flag\"\n enable_threads=$enable_threads_flag\n \n # Obsolete configurations.\n-# To avoid some tedious lists, we have a blacklist with a whitelist\n-# embedded within it.\n case $machine in\n-\t  1750a-* \\\n-\t| a29k-* \\\n-\t| alpha*-*-osf[123]* \\\n-\t| arm-*-riscix* \\\n-\t| c*-convex-* \\\n-\t| clipper-* \\\n-\t| elxsi-* \\\n-\t| i860-* \\\n-\t| i?86-*-aix* \\\n-\t| i?86-*-bsd* \\\n-\t| i?86-*-chorusos* \\\n-\t| i?86-*-dgux* \\\n-\t| i?86-*-freebsd1.* \\\n-\t| i?86-*-isc* \\\n-\t| i?86-*-linux*oldld* \\\n-\t| i?86-*-osf1* \\\n-\t| i?86-*-osfrose* \\\n-\t| i?86-*-rtemscoff* \\\n-\t| i?86-*-sunos* \\\n-\t| i?86-go32-rtems* \\\n-\t| i?86-next-* \\\n-\t| i?86-sequent-bsd* \\\n-\t| i?86-sequent-ptx[12]* \\\n-\t| i?86-sequent-sysv3* \\\n-\t| m68[k0]*-*-lynxos* \\\n-\t| m68[k0]*-*-rtemscoff* \\\n-\t| m68[k0]*-*-sysv3* \\\n-\t| m68[k0]*-altos-* \\\n-\t| m68[k0]*-apollo-* \\\n-\t| m68[k0]*-apple-* \\\n-\t| m68[k0]*-bull-* \\\n-\t| m68[k0]*-convergent-* \\\n-\t| m68[k0]*-isi-* \\\n-\t| m68[k0]*-next-* \\\n-\t| m68[k0]*-sony-* \\\n-\t| m88k-* \\\n-\t| mips-*-bsd* \\\n-\t| mips-*-riscos* \\\n-\t| mips-*-sysv* \\\n-\t| mips-*-ultrix* \\\n-\t| mips-dec-* \\\n-\t| mips-sgi-irix[1234]* \\\n-\t| mips-sony-* \\\n-\t| mips-tandem-* \\\n-\t| ns32k-* \\\n-\t| pj-* \\\n-\t| pjl-* \\\n-\t| romp-* \\\n-\t| sparc-*-rtemsaout* \\\n-\t| we32k-* \\\n-)\n-  case $machine in\n-\t  mips-sni-sysv4 \\\n-\t| m88k-*-aout* | m88k-*-openbsd* | m88k-*-sysv4* \\\n-\t| ns32k-*-netbsd* | ns32k-*-openbsd* \\\n-\t| romp-*-openbsd* \\\n-   )\n-    # Whitelisted.\n-    ;;\n-  *)\n+   m88k-*-aout*     \\\n+ | m88k-*-openbsd*  \\\n+ | m88k-*-sysv4*    \\\n+ | mips-sni-sysv4   \\\n+ | ns32k-*-netbsd*  \\\n+ | ns32k-*-openbsd* \\\n+ | romp-*-openbsd*  \\\n+ )\n     if test \"x$enable_obsolete\" != xyes; then\n       echo \"*** Configuration $machine is obsolete.\" >&2\n       echo \"*** Specify --enable-obsolete to build it anyway.\" >&2\n       echo \"*** Support will be REMOVED in the next major release of GCC,\" >&2\n       echo \"*** unless a maintainer comes forward.\" >&2\n       exit 1\n     fi;;\n-  esac\n esac\n \n # Set default cpu_type, tm_file, tm_p_file and xm_file so it can be\n@@ -299,10 +244,6 @@ arm*-*-*)\n xscale-*-*)\n \tcpu_type=arm\n \t;;\n-c*-convex-*)\n-\tcpu_type=convex\n-\textra_headers=proto.h\n-\t;;\n i[34567]86-*-*)\n \tcpu_type=i386\n \textra_headers=\"mmintrin.h xmmintrin.h\"\n@@ -327,9 +268,6 @@ m68k-*-*)\n mips*-*-*)\n \tcpu_type=mips\n \t;;\n-pj*-*-*)\n-\tcpu_type=pj\n-\t;;\n powerpc*-*-*)\n \tcpu_type=rs6000\n \textra_headers=\"ppc-asm.h altivec.h\"\n@@ -476,39 +414,6 @@ case $machine in\n \tthen tmake_file=${cpu_type}/t-$rest\n \tfi\n \t;;\n-1750a-*-*)\n-\t# 1750a is only supported as a target.\n-\tcase \"$build,$host\" in 1750a*,* | *,1750a* )\n-\t\techo \"*** $machine is only supported as a target\" >&2\n-\t\texit 1\n-\tesac\n-\t;;\n-a29k-*-bsd* | a29k-*-sym1*)\n-\ttm_file=\"${tm_file} a29k/unix.h\"\n-\txm_defines=POSIX\n-\tuse_collect2=yes\n-\t;;\n-a29k-*-udi | a29k-*-coff)\n-\ttm_file=\"${tm_file} dbxcoff.h\"\n-\ttmake_file=a29k/t-a29kbare\n-\t;;\n-a29k*-*-rtems*)\n-\txm_defines=POSIX\n-\ttm_file=\"a29k/a29k.h a29k/rtems.h rtems.h\"\n-\ttmake_file=\"a29k/t-a29kbare t-rtems\"\n-\tif test x$enable_threads = xyes; then\n-\t  thread_file='rtems'\n-\tfi\n-\t;;\n-a29k-wrs-vxworks*)\n-\ttm_file=\"${tm_file} dbxcoff.h a29k/vx29k.h\"\n-\ttmake_file=a29k/t-vx29k\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tthread_file='vxworks'\n-\t;;\n-a29k-*-*)\t\t\t# Default a29k environment.\n-\tuse_collect2=yes\n-\t;;\n alpha*-*-unicosmk*)\n \tuse_collect2=yes\n \ttm_file=\"${tm_file} alpha/unicosmk.h\"\n@@ -585,7 +490,7 @@ alpha*-*-openbsd*)\n \ttmake_file=\"alpha/t-alpha alpha/t-ieee\"\n \t;;\n \n-alpha*-dec-osf*)\n+alpha*-dec-osf[45]*)\n \txm_defines=POSIX\n \tif test x$stabs = xyes\n \tthen\n@@ -596,31 +501,24 @@ alpha*-dec-osf*)\n \t\textra_passes=\"mips-tfile mips-tdump\"\n \tfi\n \tuse_collect2=yes\n-\ttmake_file=\"alpha/t-alpha alpha/t-ieee alpha/t-crtfm\"\n+\ttmake_file=\"alpha/t-alpha alpha/t-ieee alpha/t-crtfm alpha/t-osf4\"\n+\ttm_file=\"${tm_file} alpha/osf.h\"\n \textra_headers=va_list.h\n \tcase $machine in\n-\t  *-*-osf1*)\n-\t    tm_file=\"${tm_file} alpha/osf.h alpha/osf12.h alpha/osf2or3.h\"\n-\t    ;;\n-\t  *-*-osf[23]*)\n-\t    tm_file=\"${tm_file} alpha/osf.h alpha/osf2or3.h\"\n-\t    ;;\n \t  *-*-osf4*)\n-\t    tm_file=\"${tm_file} alpha/osf.h\"\n-\t    tmake_file=\"$tmake_file alpha/t-osf4\"\n \t    # Some versions of OSF4 (specifically X4.0-9 296.7) have\n \t    # a broken tar, so we use cpio instead.\n \t    install_headers_dir=install-headers-cpio\n+\t    # Set target_cpu_default except on 4.0a.\n+\t    case $machine in\n+\t\t*-*-osf4.0a) ;;\n+\t\t*) target_cpu_default=MASK_SUPPORT_ARCH\n+\t    esac\n \t    ;;\n \t  *-*-osf5*)\n-\t    tm_file=\"${tm_file} alpha/osf.h alpha/osf5.h\"\n-\t    tmake_file=\"$tmake_file alpha/t-osf4\"\n-\t    float_format=i128\n-\t    ;;\n-\tesac\n-\tcase $machine in\n-\t  *-*-osf4.0[b-z] | *-*-osf4.[1-9]* | *-*-osf5*)\n+\t    tm_file=\"${tm_file} alpha/osf5.h\"\n \t    target_cpu_default=MASK_SUPPORT_ARCH\n+\t    float_format=i128\n \t    ;;\n \tesac\n \t;;\n@@ -684,20 +582,6 @@ arm-*-vxworks*)\n \ttmake_file=arm/t-arm-coff\n \tthread_file='vxworks'\n \t;;\n-arm-*-riscix1.[01]*)\t\t# Acorn RISC machine (early versions)\n-\ttm_file=\"arm/riscix1-1.h arm/arm.h\"\n-\tuse_collect2=yes\n-\t;;\n-arm-*-riscix*)\t\t\t# Acorn RISC machine\n-\tif test x$gas = xyes\n-\tthen\n-\t    tm_file=\"arm/riscix.h arm/rix-gas.h arm/arm.h\"\n-\telse\n-\t    tm_file=\"arm/riscix.h arm/arm.h\"\n-\tfi\n-\ttmake_file=arm/t-riscix\n-\tuse_collect2=yes\n-\t;;\n arm-semi-aout | armel-semi-aout)\n \ttm_file=\"arm/semi.h arm/aout.h arm/arm.h\"\n \ttmake_file=arm/t-semi\n@@ -768,26 +652,6 @@ arm-*-pe*)\n \t;;\n avr-*-*)\n \t;;\n-c1-convex-*)\t\t\t# Convex C1\n-\ttarget_cpu_default=1\n-\tuse_collect2=yes\n-\t;;\n-c2-convex-*)\t\t\t# Convex C2\n-\ttarget_cpu_default=2\n-\tuse_collect2=yes\n-\t;;\n-c32-convex-*)\n-\ttarget_cpu_default=4\n-\tuse_collect2=yes\n-\t;;\n-c34-convex-*)\n-\ttarget_cpu_default=8\n-\tuse_collect2=yes\n-\t;;\n-c38-convex-*)\n-\ttarget_cpu_default=16\n-\tuse_collect2=yes\n-\t;;\n c4x-*-rtems*)\n \txm_defines=POSIX\n \ttmake_file=\"c4x/t-c4x t-rtems\"\n@@ -804,12 +668,6 @@ c4x-*)\n \tc_target_objs=\"c4x-c.o\"\n \tcxx_target_objs=\"c4x-c.o\"\n \t;;\n-clipper-intergraph-clix*)\n-\ttm_file=\"${tm_file} svr3.h clipper/clix.h\"\n-\txm_defines=POSIX\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tinstall_headers_dir=install-headers-cpio\n-\t;;\n cris-*-aout)\n \ttm_file=\"dbxelf.h ${tm_file} cris/aout.h\"\n \tgas=yes\n@@ -837,9 +695,6 @@ d30v-*)\n \t;;\n dsp16xx-*)\n \t;;\n-elxsi-elxsi-*)\n-\tuse_collect2=yes\n-\t;;\n fr30-*-elf)\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n \ttmake_file=fr30/t-fr30\n@@ -1126,33 +981,11 @@ i370-*-linux*)\n \t\tthread_file='posix'\n \tfi\n \t;;\n-i[34567]86-*-chorusos*)\n-\txm_defines=POSIX\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h chorus.h\"\n-\ttmake_file=\"i386/t-i386elf t-svr4\"\n-\tcase x${enable_threads} in\n-\t  xyes | xpthreads | xposix)\n-\t\tthread_file='posix'\n-\t\t;;\n-\tesac\n-\t;;\n i[34567]86-*-elf*)\n \txm_defines=POSIX\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h\"\n \ttmake_file=\"i386/t-i386elf t-svr4\"\n \t;;\n-i[34567]86-ibm-aix*)\t\t# IBM PS/2 running AIX\n-        if test x$gas = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} svr3.h i386/unix.h i386/att.h i386/aix386.h\"\n-\t\textra_parts=\"crtbegin.o crtend.o\"\n-\t\ttmake_file=i386/t-crtstuff\n-\telse\n-\t\ttm_file=\"${tm_file} svr3.h i386/unix.h i386/att.h i386/aix386ng.h\"\n-\t\tuse_collect2=yes\n-\tfi\n-\txm_defines=POSIX\n-\t;;\n i[34567]86-ncr-sysv4*)\t\t# NCR 3000 - ix86 running system V.4\n \txm_defines=\"POSIX SMALL_ARG_MAX\"\n \tif test x$stabs = xyes -a x$gas = xyes\n@@ -1164,43 +997,10 @@ i[34567]86-ncr-sysv4*)\t\t# NCR 3000 - ix86 running system V.4\n \textra_parts=\"crtbegin.o crtend.o\"\n \ttmake_file=i386/t-crtpic\n \t;;\n-i[34567]86-next-*)\n-\ttm_p_file=\"${tm_p_file} nextstep-protos.h\"\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h nextstep.h i386/next.h\"\n-\ttmake_file=i386/t-next\n-\textra_objs=nextstep.o\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='mach'\n-\tfi\n-\t;;\n i[34567]86-*-netware)\t\t# Intel 80386's running netware\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h netware.h i386/netware.h\"\n \ttmake_file=i386/t-netware\n \t;;\n-i[34567]86-sequent-bsd*) \t\t# 80386 from Sequent\n-\tuse_collect2=yes\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/sequent.h i386/seq-gas.h\"\n-\telse\n-\t\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/sequent.h\"\n-\tfi\n-\t;;\n-i[34567]86-sequent-ptx1*)\n-\txm_defines=POSIX\n-\ttm_file=\"${tm_file} svr3.h i386/unix.h i386/att.h i386/sysv3.h i386/seq-sysv3.h\"\n-\ttmake_file=i386/t-crtstuff\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tinstall_headers_dir=install-headers-cpio\n-\t;;\n-i[34567]86-sequent-ptx2* | i[34567]86-sequent-sysv3*)\n-\txm_defines=POSIX\n-\ttm_file=\"${tm_file} svr3.h i386/unix.h i386/att.h i386/sysv3.h i386/seq-sysv3.h i386/seq2-sysv3.h\"\n-\ttmake_file=i386/t-crtstuff\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tinstall_headers_dir=install-headers-cpio\n-\t;;\n i[34567]86-sequent-ptx4* | i[34567]86-sequent-sysv4*)\n \tif test x$gas = xyes\n \tthen\n@@ -1212,10 +1012,9 @@ i[34567]86-sequent-ptx4* | i[34567]86-sequent-sysv4*)\n \textra_parts=\"crtbegin.o crtend.o\"\n \tinstall_headers_dir=install-headers-cpio\n \t;;\n-i386-sun-sunos*)\t\t# Sun i386 roadrunner\n-\txm_defines=POSIX\n-\ttm_file=\"${tm_file} i386/unix.h i386/sun386.h i386/sun.h\"\n-\tuse_collect2=yes\n+i[34567]86-sequent-sysv*)\t# would otherwise be caught by i?86-*-sysv*\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n \t;;\n i[34567]86-wrs-vxworks*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/i386-aout.h i386/vxi386.h\"\n@@ -1230,17 +1029,7 @@ i[34567]86-*-beoself* | i[34567]86-*-beos*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/beos-elf.h\"\n \textra_parts='crtbegin.o crtend.o'\n \t;;\n-i[34567]86-*-bsdi* | i[34567]86-*-bsd386*)\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/386bsd.h i386/bsd386.h\"\n-#\ttmake_file=t-libc-ok\n-\t;;\n-i[34567]86-*-bsd*)\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/386bsd.h\"\n-#\ttmake_file=t-libc-ok\n-# Next line turned off because both 386BSD and BSD/386 use GNU ld.\n-#\tuse_collect2=yes\n-\t;;\n-i[34567]86-*-freebsd[12] | i[34567]86-*-freebsd[12].* | i[34567]86-*-freebsd*aout*)\n+i[34567]86-*-freebsd2 | i[34567]86-*-freebsd2.* | i[34567]86-*-freebsd*aout*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/freebsd-aout.h\"\n \ttmake_file=t-freebsd\n \t;;\n@@ -1273,27 +1062,9 @@ i[34567]86-*-openbsd*)\n i[34567]86-*-coff*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h\"\n \t;;\n-i[34567]86-*-isc*)\t\t# 80386 running ISC system\n-\txm_defines=POSIX\n-        if test x$gas = xyes -a x$stabs = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/svr3gas.h i386/svr3dbx.h i386/iscdbx.h\"\n-\t\ttmake_file=i386/t-svr3dbx\n-\t\textra_parts=\"svr3.ifile svr3z.ifile\"\n-\telse\n-\t\ttm_file=\"${tm_file} svr3.h i386/unix.h i386/att.h i386/sysv3.h i386/isc.h\"\n-\t\ttmake_file=i386/t-crtstuff\n-\t\textra_parts=\"crtbegin.o crtend.o\"\n-\tfi\n-\tinstall_headers_dir=install-headers-cpio\n-\t;;\n-i[34567]86-*-linux*oldld*)\t# Intel 80386's running GNU/Linux\n-\t\t\t\t# with a.out format using\n-\t\t\t\t# pre BFD linkers\n-\ttmake_file=\"t-linux-aout i386/t-crtstuff\"\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h linux-aout.h i386/linux-oldld.h\"\n-\tgnu_ld=yes\n-\tfloat_format=i386\n+i[34567]86-*-linux*oldld*)\t# would otherwise be caught by i?86-*-linux*\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n \t;;\n i[34567]86-*-linux*aout*)\t# Intel 80386's running GNU/Linux\n \t\t\t\t# with a.out format\n@@ -1376,35 +1147,12 @@ i[34567]86-*-mach*)\n #\ttmake_file=t-libc-ok\n \tuse_collect2=yes\n \t;;\n-i[34567]86-*-osfrose*)\t\t# 386 using OSF/rose\n-        if test x$elf = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} halfpic.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/osfrose.h i386/osfelf.h\"\n-\t\tuse_collect2=\n-\telse\n-\t\ttm_file=\"${tm_file} halfpic.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/osfrose.h\"\n-\t\tuse_collect2=yes\n-\tfi\n-\ttmake_file=i386/t-osf\n-\textra_objs=halfpic.o\n-\t;;\n-i[34567]86-go32-rtems*)\n-\txm_defines=POSIX\n-\ttm_file=\"dbxcoff.h ${tm_file} i386/djgpp.h i386/djgpp-rtems.h rtems.h\"\n-\ttmake_file=t-rtems\n-\tif test x$enable_threads = xyes; then\n-\t  thread_file='rtems'\n-\tfi\n-\t;;\n-i[34567]86-*-rtemscoff*)\n-\txm_defines=POSIX\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h i386/rtems.h rtems.h\"\n-\ttmake_file=t-rtems\n-\tif test x$enable_threads = xyes; then\n-\t  thread_file='rtems'\n-\tfi\n+i[34567]86-go32-rtems* | i[34567]86-*-rtemscoff*)\n+\t# would otherwise be caught by i?86-*-rtems*\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n \t;;\n-i[34567]86-*-rtems*|i[34567]86-*-rtemself*)\n+i[34567]86-*-rtems*)\n \txm_defines=POSIX\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h i386/rtemself.h rtems.h\"\n \textra_parts=\"crtbegin.o crtend.o crti.o crtn.o\"\n@@ -1483,17 +1231,6 @@ i[34567]86-*-udk*)      # Intel x86 on SCO UW/OSR5 Dev Kit\n \textra_parts=\"crtbegin.o crtend.o\"\n \tinstall_headers_dir=install-headers-cpio\n \t;;\n-i[34567]86-*-osf1*)\t\t# Intel 80386's running OSF/1 1.3+\n-\txm_defines='POSIX USE_C_ALLOCA SMALL_ARG_MAX'\n-\tif test x$stabs = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/osf1elf.h i386/osf1elfgdb.h\"\n-\telse\n-\t\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/osf1elf.h\"\n-\tfi\n-\ttmake_file=i386/t-osf1elf\n-\textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n-\t;;\n i[34567]86-*-sysv*)\t\t# Intel 80386's running system V\n \txm_defines=POSIX\n \tif test x$gas = xyes\n@@ -1502,7 +1239,7 @@ i[34567]86-*-sysv*)\t\t# Intel 80386's running system V\n \t\tthen\n \t\t\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/svr3gas.h i386/svr3dbx.h\"\n \t\t\ttmake_file=i386/t-svr3dbx\n-\t\t\textra_parts=\"svr3.ifile svr3z.rfile\"\n+\t\t\textra_parts=\"svr3.ifile svr3z.ifile\"\n \t\telse\n \t\t\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/svr3gas.h\"\n \t\t\textra_parts=\"crtbegin.o crtend.o\"\n@@ -1598,44 +1335,6 @@ i[34567]86-*-interix*)\n \t\ttm_file=\"${tm_file} dbxcoff.h\"\n \tfi\n \t;;\n-i[34567]86-dg-dgux*)\n-\txm_defines=POSIX\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/dgux.h\"\n-\ttmake_file=i386/t-dgux\n-\tinstall_headers_dir=install-headers-cpio\n-      ;;\n-i860-alliant-*)\t\t# Alliant FX/2800\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h i860/sysv4.h i860/fx2800.h\"\n-\ttmake_file=i860/t-fx2800\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\t;;\n-i860-*-bsd*)\n-\ttm_file=\"${tm_file} i860/bsd.h\"\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} i860/bsd-gas.h\"\n-\tfi\n-\tuse_collect2=yes\n-\t;;\n-i860-*-mach*)\n-\ttm_file=\"${tm_file} i860/mach.h\"\n-\ttmake_file=t-libc-ok\n-\t;;\n-i860-*-osf*)\t\t\t# Intel Paragon XP/S, OSF/1AD\n-\ttm_file=\"${tm_file} svr3.h i860/paragon.h\"\n-\txm_defines=POSIX\n-\t;;\n-i860-*-sysv3*)\n-\ttm_file=\"${tm_file} svr3.h i860/sysv3.h\"\n-\txm_defines=POSIX\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\t;;\n-i860-*-sysv4*)\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h i860/sysv4.h\"\n-\txm_defines=POSIX\n-\ttmake_file=t-svr4\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\t;;\n i960-wrs-vxworks5 | i960-wrs-vxworks5.0*)\n \ttm_file=\"${tm_file} i960/vx960.h\"\n \ttmake_file=i960/t-vxworks960\n@@ -1744,11 +1443,6 @@ m68hc12-*-*|m6812-*-*)\n \tout_file=\"m68hc11/m68hc11.c\"\n \ttmake_file=\"m68hc11/t-m68hc11-gas\"\n         ;;\n-m68000-convergent-sysv*)\n-\ttm_file=m68k/ctix.h\n-\txm_defines=POSIX\n-\tuse_collect2=yes\n-\t;;\n m68000-hp-bsd*)\t\t\t# HP 9000/200 running BSD\n \ttm_file=m68k/hp2bsd.h\n \tuse_collect2=yes\n@@ -1783,64 +1477,18 @@ m68000-att-sysv*)\n \tfi\n \tuse_collect2=yes\n \t;;\n-m68k-apple-aux*)\t\t# Apple Macintosh running A/UX\n-\txm_defines=POSIX\n-\ttmake_file=m68k/t-aux\n-\tinstall_headers_dir=install-headers-cpio\n-\textra_parts=\"crt1.o mcrt1.o maccrt1.o crt2.o crtn.o\"\n-\ttm_file=\n-\tif test \"$gnu_ld\" = yes\n-\tthen\n-\t\ttm_file=\"${tm_file} m68k/auxgld.h\"\n-\telse\n-\t\ttm_file=\"${tm_file} m68k/auxld.h\"\n-\tfi\n-\tif test \"$gas\" = yes\n-\tthen\n-\t\ttm_file=\"${tm_file} m68k/auxgas.h\"\n-\telse\n-\t\ttm_file=\"${tm_file} m68k/auxas.h\"\n-\tfi\n-\ttm_file=\"${tm_file} m68k/a-ux.h\"\n-\tfloat_format=m68k\n-\t;;\n-m68k-apollo-*)\n-\ttm_file=m68k/apollo68.h\n-\tuse_collect2=yes\n-\tfloat_format=m68k\n-\t;;\n-m68k-altos-sysv*)\t\t   # Altos 3068\n-\tif test x$gas = xyes\n-\tthen\n-\t        tm_file=m68k/altos3068.h\n-\t\txm_defines=POSIX\n-\telse\n-\t\techo \"The Altos is supported only with the GNU assembler\" 1>&2\n-\t\texit 1\n-\tfi\n-        ;;\n-m68k-bull-sysv*)\t\t# Bull DPX/2\n-\tif test x$gas = xyes\n-\tthen\n-\t\tif test x$stabs = xyes\n-\t\tthen\n-\t\t\ttm_file=m68k/dpx2cdbx.h\n-\t\telse\n-\t\t\ttm_file=m68k/dpx2g.h\n-\t\tfi\n-\telse\n-\t\ttm_file=m68k/dpx2.h\n-\tfi\n-\txm_defines=POSIX\n-\tuse_collect2=yes\n-\t;;\n m68k-atari-sysv4*)              # Atari variant of V.4.\n \ttm_file=m68k/atari.h\n \txm_defines=POSIX\n \ttmake_file=t-svr4\n \textra_parts=\"crtbegin.o crtend.o\"\n \tfloat_format=m68k\n \t;;\n+m68k-apollo-sysv* | m68k-bull-sysv*)\n+\t# can otherwise be caught by m68k-*-sysv4*\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n+\t;;\n m68k-motorola-sysv*)\n \ttm_file=m68k/mot3300.h\n \txm_defines=POSIX\n@@ -1907,16 +1555,6 @@ m68k-hp-bsd*)\t\t\t# HP 9000/3xx running Berkeley Unix\n \tuse_collect2=yes\n \tfloat_format=m68k\n \t;;\n-m68k-isi-bsd*)\n-\tif test x$with_fp = xno\n-\tthen\n-\t\ttm_file=m68k/isi-nfp.h\n-\telse\n-\t\ttm_file=m68k/isi.h\n-\t\tfloat_format=m68k\n-\tfi\n-\tuse_collect2=yes\n-\t;;\n m68k-hp-hpux7*)\t# HP 9000 series 300 running HPUX version 7.\n \txm_defines=POSIX\n \tif test x$gas = xyes\n@@ -1950,47 +1588,6 @@ m68k-sun-mach*)\n \tuse_collect2=yes\n \tfloat_format=m68k\n \t;;\n-m68k-sony-newsos3*)\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_file=m68k/news3gas.h\n-\telse\n-\t\ttm_file=m68k/news3.h\n-\tfi\n-\tuse_collect2=yes\n-\tfloat_format=m68k\n-\t;;\n-m68k-sony-bsd* | m68k-sony-newsos*)\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_file=m68k/newsgas.h\n-\telse\n-\t\ttm_file=m68k/news.h\n-\tfi\n-\tuse_collect2=yes\n-\tfloat_format=m68k\n-\t;;\n-m68k-next-nextstep2*)\n-\ttm_p_file=\"${tm_p_file} nextstep-protos.h\"\n-\ttm_file=m68k/next21.h\n-\ttmake_file=m68k/t-next\n-\txmake_file=m68k/x-next\n-\textra_objs=nextstep.o\n-\tuse_collect2=yes\n-\tfloat_format=m68k\n-        ;;\n-m68k-next-nextstep[34]*)\n-\ttm_p_file=\"${tm_p_file} nextstep-protos.h\"\n-\ttm_file=m68k/next.h\n-\ttmake_file=m68k/t-next\n-\txmake_file=m68k/x-next\n-\textra_objs=nextstep.o\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tfloat_format=m68k\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='mach'\n-\tfi\n-\t;;\n m68k-sun-sunos3*)\n \tif test x$with_fp = xno\n \tthen\n@@ -2033,16 +1630,6 @@ m68020-*-elf* | m68k-*-elf*)\n \ttmake_file=m68k/t-m68kelf\n \textra_parts=\"crtbegin.o crtend.o\"\n \t;;\n-m68k-*-lynxos*)\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_file=m68k/lynx.h\n-\telse\n-\t\ttm_file=m68k/lynx-ng.h\n-\tfi\n-\ttmake_file=m68k/t-lynx\n-\tfloat_format=m68k\n-\t;;\n m68010-*-netbsdelf* | m68k*-*-netbsdelf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h netbsd.h netbsd-elf.h m68k/netbsd-elf.h\"\n \tcase $machine in\n@@ -2068,11 +1655,6 @@ m68k*-*-openbsd*)\n \t# we need collect2 until our bug is fixed...\n \tuse_collect2=yes\n \t;;\n-m68k-*-sysv3*)\t\t\t# Motorola m68k's running system V.3\n-\txm_defines=POSIX\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tfloat_format=m68k\n-\t;;\n m68k-*-sysv4*)\t\t\t# Motorola m68k's running system V.4\n \ttm_file=m68k/m68kv4.h\n \txm_defines=POSIX\n@@ -2113,16 +1695,11 @@ m68k-*-psos*)\n \ttm_file=m68k/m68k-psos.h\n \tfloat_format=m68k\n \t;;\n-m68k-*-rtemscoff*)\n-\txm_defines=POSIX\n-\ttmake_file=\"m68k/t-m68kbare t-rtems\"\n-\ttm_file=\"m68k/m68k-coff.h m68k/rtems.h rtems.h\"\n-\tfloat_format=m68k\n-\tif test x$enable_threads = xyes; then\n-\t  thread_file='rtems'\n-\tfi\n+m68k-*-rtemscoff*)\t# would otherwise be caught by m68k-*-rtems*\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n \t;;\n-m68k-*-rtemself*|m68k-*-rtems*)\n+m68k-*-rtems*)\n \txm_defines=POSIX\n \ttmake_file=\"m68k/t-m68kbare t-rtems m68k/t-crtstuff\"\n \ttm_file=\"m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/m68kemb.h m68k/m68020-elf.h m68k/rtemself.h rtems.h\"\n@@ -2132,76 +1709,14 @@ m68k-*-rtemself*|m68k-*-rtems*)\n \t  thread_file='rtems'\n \tfi\n \t;;\n-m88k-dg-dgux*)\n-\txm_defines=POSIX\n-\tcase $machine in\n-\t  m88k-dg-dguxbcs*)\n-\t    tm_file=\"dbxelf.h elfos.h svr4.h m88k/dgux.h m88k/dguxbcs.h\"\n-\t    tmake_file=\"m88k/t-dgux m88k/t-dguxbcs\"\n-\t    ;;\n-\t  *)\n-\t    tm_file=\"dbxelf.h elfos.h svr4.h m88k/dgux.h\"\n-\t    tmake_file=m88k/t-dgux\n-\t    ;;\n-\tesac\n-\textra_parts=\"crtbegin.o bcscrtbegin.o crtend.o m88kdgux.ld\"\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=m88k/t-dgux-gas\n-\tfi\n-\t;;\n-m88k-dolphin-sysv3*)\n-\txm_defines=POSIX\n-\ttm_file=m88k/dolph.h\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\ttmake_file=m88k/t-dolph\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=m88k/t-m88k-gas\n-\tfi\n-\t;;\n-m88k-tektronix-sysv3)\n-\txm_defines=POSIX\n-\ttm_file=m88k/tekXD88.h\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\ttmake_file=m88k/t-tekXD88\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=m88k/t-m88k-gas\n-\tfi\n-\t;;\n m88k-*-aout*)\n \txm_defines=POSIX\n \ttm_file=m88k/m88k-aout.h\n \t;;\n-m88k-*-coff*)\n-\txm_defines=POSIX\n-\ttm_file=m88k/m88k-coff.h\n-\ttmake_file=m88k/t-bug\n-\t;;\n-m88k-*-luna*)\n-\ttm_file=m88k/luna.h\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=m88k/t-luna-gas\n-\telse\n-\t\ttmake_file=m88k/t-luna\n-\tfi\n-\t;;\n m88k-*-openbsd*)\n \ttmake_file=\"${tmake_file} m88k/t-luna-gas\"\n \ttm_file=\"m88k/aout-dbx.h aoutos.h m88k/m88k.h openbsd.h ${tm_file}\"\n \t;;\n-m88k-*-sysv3*)\n-\txm_defines=POSIX\n-\ttm_file=m88k/sysv3.h\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=m88k/t-m88k-gas\n-\tfi\n-\t;;\n m88k-*-sysv4*)\n \txm_defines=POSIX\n \ttm_file=\"dbxelf.h elfos.h svr4.h m88k/sysv4.h\"\n@@ -2287,96 +1802,10 @@ mips-sgi-irix5*)\t\t# SGI System V.4., IRIX 5\n #\t\tthread_file='irix'\n #\tfi\n \t;;\n-mips-sgi-irix4loser*)\t\t# Mostly like a MIPS.\n-\ttm_file=\"mips/iris4loser.h mips/iris3.h ${tm_file} mips/iris4.h\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\ttmake_file=mips/t-iris\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-#\tif test x$enable_threads = xyes; then\n-#\t\tthread_file='irix'\n-#\tfi\n-\t;;\n-mips-sgi-irix4*)\t\t# Mostly like a MIPS.\n-\ttm_file=\"mips/iris3.h ${tm_file} mips/iris4.h\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\ttmake_file=mips/t-iris\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-#\tif test x$enable_threads = xyes; then\n-#\t\tthread_file='irix'\n-#\tfi\n-\t;;\n-mips-sgi-*)\t\t\t# Mostly like a MIPS.\n-\ttm_file=\"mips/iris3.h ${tm_file}\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-dec-osfrose*)\t\t# Decstation running OSF/1 reference port with OSF/rose.\n-\ttm_file=\"mips/osfrose.h ${tm_file}\"\n-\textra_objs=halfpic.o\n-\tuse_collect2=yes\n-\t;;\n-mips-dec-osf*)\t\t\t# Decstation running OSF/1 as shipped by DIGITAL\n-\ttm_file=mips/dec-osf1.h\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\ttmake_file=mips/t-ultrix\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n+mips-sgi-*)\t# would otherwise be caught by mips-*-elf*\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n \t;;\n-mips-dec-bsd*)                  # Decstation running 4.4 BSD\n-      tm_file=mips/dec-bsd.h\n-      if test x$gas = xyes\n-      then\t:\n-      else\n-\t\ttmake_file=mips/t-ultrix\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-      fi\n-      if test x$gnu_ld != xyes\n-      then\n-\t\tuse_collect2=yes\n-      fi\n-      ;;\n mips*-*-netbsd*)\t\t\t# NetBSD/mips, either endian.\n \ttm_file=\"elfos.h mips/netbsd.h\"\n \tcase $machine in\n@@ -2413,192 +1842,6 @@ mips*-*-openbsd*)\t\t# mips big endian\n \ttarget_cpu_default=\"MASK_GAS|MASK_ABICALLS\"\n \ttm_file=\"mips/openbsd-be.h ${tm_file}\"\n \t;;\n-mips-sony-bsd* | mips-sony-newsos*)\t# Sony NEWS 3600 or risc/news.\n-\ttm_file=\"mips/news4.h ${tm_file}\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-sony-sysv*)\t\t# Sony NEWS 3800 with NEWSOS5.0.\n-\t\t\t\t# That is based on svr4.\n-\t# t-svr4 is not right because this system doesn't use ELF.\n-\ttm_file=\"mips/news5.h ${tm_file}\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-tandem-sysv4*)\t\t# Tandem S2 running NonStop UX\n-\ttm_file=\"mips/svr4-5.h mips/svr4-t.h\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\n-\t\textra_parts=\"crtbegin.o crtend.o\"\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-*-ultrix* | mips-dec-mach3)\t# Decstation.\n-\ttm_file=\"mips/ultrix.h ${tm_file}\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\ttmake_file=mips/t-ultrix\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-        ;;\n-mips-*-riscos[56789]bsd*)\n-\ttm_file=mips/bsd-5.h\t# MIPS BSD 4.3, RISC-OS 5.0\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=mips/t-bsd-gas\n-\telse\n-\t\ttmake_file=mips/t-bsd\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-        ;;\n-mips-*-bsd* | mips-*-riscosbsd* | mips-*-riscos[1234]bsd*)\n-\ttm_file=\"mips/bsd-4.h ${tm_file}\" # MIPS BSD 4.3, RISC-OS 4.0\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=mips/t-bsd-gas\n-\telse\n-\t\ttmake_file=mips/t-bsd\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-        ;;\n-mips-*-riscos[56789]sysv4*)\n-\ttm_file=mips/svr4-5.h\t# MIPS System V.4., RISC-OS 5.0\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=mips/t-svr4-gas\n-\telse\n-\t\ttmake_file=mips/t-svr4\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-*-sysv4* | mips-*-riscos[1234]sysv4* | mips-*-riscossysv4*)\n-\ttm_file=\"mips/svr4-4.h ${tm_file}\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=mips/t-svr4-gas\n-\telse\n-\t\ttmake_file=mips/t-svr4\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-*-riscos[56789]sysv*)\n-\ttm_file=mips/svr3-5.h\t# MIPS System V.3, RISC-OS 5.0\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=mips/t-svr3-gas\n-\telse\n-\t\ttmake_file=mips/t-svr3\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-*-sysv* | mips-*-riscos*sysv*)\n-\ttm_file=\"mips/svr3-4.h ${tm_file}\"\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\txm_defines=POSIX\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttmake_file=mips/t-svr3-gas\n-\telse\n-\t\ttmake_file=mips/t-svr3\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n-mips-*-riscos[56789]*)\t\t# Default MIPS RISC-OS 5.0.\n-\ttm_file=mips/mips-5.h\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n mipsel-*-ecoff*)\n \ttm_file=mips/ecoffl.h\n \tif test x$stabs = xyes; then\n@@ -2667,20 +1910,6 @@ mipstx39-*-elf*)\n \ttm_file=\"mips/r3900.h mips/elf.h mips/abi64.h\"\n \ttmake_file=mips/t-r3900\n \t;;\n-mips-*-*)\t\t\t\t# Default MIPS RISC-OS 4.0.\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tif test x$gas = xyes\n-\tthen\t:\n-\telse\n-\t\textra_passes=\"mips-tfile mips-tdump\"\n-\tfi\n-\tif test x$gnu_ld != xyes\n-\tthen\n-\t\tuse_collect2=yes\n-\tfi\n-\t;;\n mmix-knuth-mmixware)\n \t;;\n mn10200-*-*)\n@@ -2700,35 +1929,6 @@ mn10300-*-*)\n \tfi\n \tuse_collect2=no\n \t;;\n-ns32k-encore-bsd*)\n-\ttm_file=ns32k/encore.h\n-\tuse_collect2=yes\n-\t;;\n-ns32k-sequent-bsd*)\n-\ttm_file=ns32k/sequent.h\n-\tuse_collect2=yes\n-\t;;\n-ns32k-tek6100-bsd*)\n-\ttm_file=ns32k/tek6100.h\n-\tuse_collect2=yes\n-\t;;\n-ns32k-tek6200-bsd*)\n-\ttm_file=ns32k/tek6200.h\n-\tuse_collect2=yes\n-\t;;\n-ns32k-merlin-*)\n-\ttm_file=ns32k/merlin.h\n-\tuse_collect2=yes\n-\t;;\n-ns32k-pc532-mach*)\n-\ttm_file=ns32k/pc532-mach.h\n-\tuse_collect2=yes\n-\t;;\n-ns32k-pc532-minix*)\n-\ttm_file=ns32k/pc532-min.h\n-\txm_defines='POSIX HZ=60'\n-\tuse_collect2=yes\n-\t;;\n ns32k-*-netbsdelf*)\n \techo \"GCC does not yet support the ${machine} target\"; exit 1\n \t;;\n@@ -2748,21 +1948,6 @@ avr-*-*)\n ns32k-*-openbsd*)\n \t# Nothing special\n \t;;\n-pj*-linux*)\n-\ttm_file=\"dbxelf.h elfos.h svr4.h pj/linux.h ${tm_file}\"\n-\t;;\n-pj-*)\n-\t;;\n-pjl-*)\n-\ttm_file=\"dbxelf.h elfos.h svr4.h pj/pjl.h ${tm_file}\"\n-\t;;\n-\n-romp-*-aos*)\n-\tuse_collect2=yes\n-\t;;\n-romp-*-mach*)\n-\tuse_collect2=yes\n-\t;;\n romp-*-openbsd*)\n \t# Nothing special\n \t;;\n@@ -3028,7 +2213,7 @@ sh64-*-elf*)\n \ttmake_file=\"sh/t-sh sh/t-elf sh/t-sh64\"\n \ttm_file=\"${tm_file} sh/sh.h sh/embed-elf.h sh/sh64.h\"\n \tfloat_format=sh\n-\textra_headers=\"../../config/sh/shmedia.h ../../config/sh/ushmedia.h ../../config/sh/sshmedia.h\"\n+\textra_headers=\"shmedia.h ushmedia.h sshmedia.h\"\n \t# Not strictly necessary to check this, but a good idea anyway.\n \tif test $machine = $target; then\n \t\ttarget_requires_64bit_host_wide_int=yes\n@@ -3149,15 +2334,11 @@ sparc-*-lynxos*)\n \tfi\n \ttmake_file=sparc/t-sunos41\n \t;;\n-sparc-*-rtemsaout*)\n-\txm_defines=POSIX\n-\ttmake_file=\"sparc/t-sparcbare t-rtems\"\n-\ttm_file=\"${tm_file} aoutos.h sparc/aout.h sparc/rtems.h rtems.h\"\n-\tif test x$enable_threads = xyes; then\n-\t  thread_file='rtems'\n-\tfi\n+sparc-*-rtemsaout*)\t# would otherwise be caught by sparc-*-rtems*\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n \t;;\n-sparc-*-rtems*|sparc-*-rtemself*)\n+sparc-*-rtems*)\n \txm_defines=POSIX\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sol2.h sparc/elf.h sparc/rtemself.h rtems.h\"\n \ttmake_file=\"sparc/t-elf sparc/t-crtfm t-rtems\"\n@@ -3429,10 +2610,6 @@ vax-*-vms*)\t\t\t# VAXen running VMS\n vax-*-*)\t\t\t# VAX default entry\n \tfloat_format=vax\n \t;;\n-we32k-att-sysv*)\n-\txm_defines=POSIX\n-\tuse_collect2=yes\n-\t;;\n xscale-*-elf)\n \ttm_file=\"arm/xscale-elf.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h\"\n \ttmake_file=arm/t-xscale-elf\n@@ -3471,7 +2648,7 @@ xtensa-*-linux*)\n \tfi\n \t;;\n *)\n-\techo \"Configuration $machine not supported\" 1>&2\n+\techo \"*** Configuration $machine not supported\" 1>&2\n \texit 1\n \t;;\n esac"}, {"sha": "c437f00f3e176bdb30df8d715b4115f2b9853b21", "filename": "gcc/config/1750a/1750a-protos.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,46 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by O.M.Kellogg, DASA (oliver.kellogg@space.otn.dasa.de)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-#ifdef TREE_CODE\n-extern struct rtx_def *function_arg PARAMS ((int, enum machine_mode, tree, int));\n-#endif /* TREE_CODE */\n-extern const char *movcnt_regno_adjust PARAMS ((rtx *));\n-extern const char *mod_regno_adjust PARAMS ((const char *, rtx *));\n-extern void notice_update_cc PARAMS ((rtx));\n-extern int memop_valid PARAMS ((rtx));\n-extern int mov_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int small_nonneg_const PARAMS ((rtx, enum machine_mode));\n-extern int zero_operand PARAMS ((rtx, enum machine_mode));\n-extern int b_mode_operand PARAMS ((rtx));\n-extern int unsigned_comparison_operator PARAMS ((rtx));\n-extern int next_cc_user_is_unsigned PARAMS ((rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-#endif /* RTX_CODE */\n-\n-extern const char *branch_or_jump PARAMS ((const char *, int));\n-extern int find_jmplbl PARAMS ((int));\n-extern int one_bit_set_p PARAMS ((int));\n-extern void check_section PARAMS ((enum section));\n-\n-extern long real_value_to_target_single PARAMS((double));\n-extern void real_value_to_target_double PARAMS((double, long[]));"}, {"sha": "c8b6a796efc2db967fe508f255a38501182e3585", "filename": "gcc/config/1750a/1750a.c", "status": "removed", "additions": 0, "deletions": 932, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,932 +0,0 @@\n-/* Subroutines for insn-output.c for MIL-STD-1750.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000 Free Software Foundation, Inc.\n-   Contributed by O.M.Kellogg, DASA (kellogg@space.otn.dasa.de)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define __datalbl\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#define HAVE_cc0\n-#include \"conditions.h\"\n-#include \"real.h\"\n-#include \"regs.h\"\n-#include \"output.h\"\n-#include \"flags.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-struct datalabel_array datalbl[DATALBL_ARRSIZ];\n-int datalbl_ndx = -1;\n-struct jumplabel_array jmplbl[JMPLBL_ARRSIZ];\n-int jmplbl_ndx = -1;\n-int label_pending = 0, program_counter = 0;\n-enum section current_section = Normal;\n-const char *const sectname[4] =\n-{\"Init\", \"Normal\", \"Konst\", \"Static\"};\n-\n-static int which_bit PARAMS ((int));\n-static bool assemble_integer_1750a PARAMS ((rtx, unsigned int, int));\n-static void output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_BYTE_OP\n-#define TARGET_ASM_BYTE_OP \"\\tdata\\t\"\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\tdatal\\t\"\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP NULL\n-#undef TARGET_ASM_INTEGER\n-#define TARGET_ASM_INTEGER assemble_integer_1750a\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE output_function_epilogue\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Generate the assembly code for function entry.  FILE is a stdio\n-   stream to output the code to.  SIZE is an int: how many units of\n-   temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers to\n-   save; `regs_ever_live[I]' is nonzero if register number I is ever\n-   used in the function.  This function is responsible for knowing\n-   which registers should not be saved even if used.  */\n-\n-static void\n-output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  if (flag_verbose_asm)\n-    {\n-      int regno, regs_used = 0;\n-\n-      fprintf (file, \"\\t; registers used: \");\n-      for (regno = 0; regno < 14; regno++)\n-\tif (regs_ever_live[regno])\n-\t  {\n-\t    fprintf (file, \" %s\", reg_names[regno]);\n-\t    regs_used++;\n-\t  }\n-\n-      if (regs_used == 0)\n-\tfprintf (file, \"(none)\");\n-    }\n-\n-  if (size > 0)\n-    {\n-      fprintf (file, \"\\n\\t%s\\tr15,%d\",\n-\t       (size <= 16 ? \"sisp\" : \"sim\"), size);\n-      if (flag_verbose_asm)\n-\tfprintf (file, \"  ; reserve local-variable space\");\n-    }\n-\n-  if (frame_pointer_needed)\n-    {\n-      fprintf(file, \"\\n\\tpshm\\tr14,r14\");\n-      if (flag_verbose_asm)\n-\tfprintf (file, \"  ; push old frame\");\n-      fprintf (file, \"\\n\\tlr\\tr14,r15\");\n-      if (flag_verbose_asm)\n-\tfprintf (file, \"  ; set new frame\");\n-    }\n-\n-  fprintf (file, \"\\n\");\n-  program_counter = 0;\n-  jmplbl_ndx = -1;\n-}\n-\n-/* This function generates the assembly code for function exit.\n-   Args are as for output_function_prologue ().\n-\n-   The function epilogue should not depend on the current stack\n-   pointer!  It should use the frame pointer only.  This is mandatory\n-   because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning.  */\n-\n-static void\n-output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  if (frame_pointer_needed)\n-    {\n-      fprintf (file, \"\\tlr\\tr15,r14\");\n-      if (flag_verbose_asm)\n-        fprintf (file, \"  ; set stack ptr to frame ptr\");\n-      fprintf (file, \"\\n\\tpopm\\tr14,r14\");\n-      if (flag_verbose_asm)\n-        fprintf (file, \"  ; restore previous frame ptr\");\n-      fprintf (file, \"\\n\");\n-    }\n-\n-  if (size > 0)\n-    {\n-      fprintf (file, \"\\t%s\\tr15,%d\",\n-\t       (size <= 16 ? \"aisp\" : \"aim\"), size);\n-      if (flag_verbose_asm)\n-\tfprintf (file, \"  ; free up local-var space\");\n-      fprintf (file, \"\\n\");\n-    }\n-\n-  fprintf (file, \"\\turs\\tr15\\n\\n\");\n-}\n-\n-void\n-notice_update_cc (exp)\n-     rtx exp;\n-{\n-  if (GET_CODE (exp) == SET)\n-    {\n-      enum rtx_code src_code = GET_CODE (SET_SRC (exp));\n-      /* Jumps do not alter the cc's.  */\n-      if (SET_DEST (exp) == pc_rtx)\n-\treturn;\n-      /* Moving a register or constant into memory doesn't alter the cc's.  */\n-      if (GET_CODE (SET_DEST (exp)) == MEM\n-\t  && (src_code == REG || src_code == CONST_INT))\n-\treturn;\n-      /* Function calls clobber the cc's.  */\n-      if (src_code == CALL)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t  return;\n-\t}\n-      /* Emulated longword bit-ops leave cc's incorrect */\n-      if (GET_MODE (SET_DEST (exp)) == HImode ?\n-\t       src_code == AND || src_code == IOR ||\n-\t       src_code == XOR || src_code == NOT : 0)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t  return;\n-\t}\n-      /* Tests and compares set the cc's in predictable ways.  */\n-      if (SET_DEST (exp) == cc0_rtx)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t  cc_status.value1 = SET_SRC (exp);\n-\t  return;\n-\t}\n-      /* Anything else will set cc_status.  */\n-      cc_status.flags = CC_NO_OVERFLOW;\n-      cc_status.value1 = SET_SRC (exp);\n-      cc_status.value2 = SET_DEST (exp);\n-      return;\n-    }\n-  else if (GET_CODE (exp) == PARALLEL\n-\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n-    {\n-      if (SET_DEST (XVECEXP (exp, 0, 0)) == pc_rtx)\n-\treturn;\n-      if (SET_DEST (XVECEXP (exp, 0, 0)) == cc0_rtx)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t  cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n-\t  return;\n-\t}\n-      CC_STATUS_INIT;\n-    }\n-  else\n-    {\n-      CC_STATUS_INIT;\n-    }\n-}\n-\n-\n-rtx\n-function_arg (cum, mode, type, named)\n-     int cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n-{\n-  int size;\n-\n-  if (MUST_PASS_IN_STACK (mode, type))\n-    return (rtx) 0;\n-  if (mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-  if (cum + size < 12)\n-    return gen_rtx_REG (mode, cum);\n-  else\n-    return (rtx) 0;\n-}\n-\n-const char *\n-movcnt_regno_adjust (op)\n-     rtx *op;\n-{\n-  static char outstr[80];\n-  int op0r = REGNO (op[0]), op1r = REGNO (op[1]), op2r = REGNO (op[2]);\n-#define dstreg op0r\n-#define srcreg op1r\n-#define cntreg op2r\n-#define cntreg_1750 (op0r + 1)\n-\n-  if (cntreg == cntreg_1750)\n-    sprintf (outstr, \"mov r%d,r%d\", op0r, op1r);\n-  else if (dstreg + 1 == srcreg && cntreg > srcreg)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,r%d\", op2r, op1r, op0r, op2r);\n-  else if (dstreg == cntreg + 1)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,r%d\", op0r, op2r, op2r, op1r);\n-  else if (dstreg == srcreg + 1)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\txwr r%d,r%d\\n\\tmov r%d,r%d\",\n-\t     op0r, op1r, op0r, op2r, op1r, op2r);\n-  else if (cntreg + 1 == srcreg)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\txwr r%d,r%d\\n\\tmov r%d,r%d\",\n-\t     op2r, op1r, op0r, op2r, op2r, op0r);\n-  else if (cntreg == srcreg + 1)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,r%d\", op0r, op1r, op1r, op0r);\n-  else\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,r%d\\n\\txwr r%d,r%d\",\n-\t     op2r, cntreg_1750, op0r, op1r, op2r, cntreg_1750);\n-  return outstr;\n-}\n-\n-const char *\n-mod_regno_adjust (instr, op)\n-     const char *instr;\n-     rtx *op;\n-{\n-  static char outstr[40];\n-  const char *const r = (!strncmp (instr, \"dvr\", 3) ? \"r\" : \"\");\n-  int modregno_gcc = REGNO (op[3]), modregno_1750 = REGNO (op[0]) + 1;\n-\n-  if (modregno_gcc == modregno_1750\n-      || (reg_renumber != NULL\n-\t  && reg_renumber[modregno_gcc] >= 0\n-\t  && reg_renumber[modregno_gcc] == reg_renumber[modregno_1750]))\n-    sprintf (outstr, \"%s r%%0,%s%%2\", instr, r);\n-  else\n-    sprintf (outstr, \"lr r%d,r%d\\n\\t%s r%%0,%s%%2\\n\\txwr r%d,r%d\",\n-\t     modregno_gcc, modregno_1750, instr, r, modregno_1750,\n-\t     modregno_gcc);\n-  return outstr;\n-}\n-\n-\n-/* Check if op is a valid memory operand for 1750A Load/Store instructions\n-   (memory indirection permitted.)  */\n-\n-int\n-memop_valid (op)\n-     rtx op;\n-{\n-  static int recurred = 0;\n-  int valid_operand;\n-\n-  if (GET_MODE (op) != Pmode && GET_MODE (op) != VOIDmode\n-      && GET_MODE (op) != QImode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case MEM:\n-      if (!recurred && GET_CODE (XEXP (op, 0)) == REG)\n-\treturn 1;\n-    case MINUS:\n-    case MULT:\n-    case DIV:\n-      return 0;\n-    case PLUS:\n-      recurred = 1;\n-      valid_operand = memop_valid (XEXP (op, 0));\n-      if (valid_operand)\n-\tvalid_operand = memop_valid (XEXP (op, 1));\n-       recurred = 0;\n-       return valid_operand;\n-    case REG:\n-      if (REGNO (op) > 0)\n-\treturn 1;\n-      return 0;\n-    case CONST:\n-    case CONST_INT:\n-    case SYMBOL_REF:\n-    case SUBREG:\n-      return 1;\n-    default:\n-      printf (\"memop_valid: code=%d\\n\", (int) GET_CODE (op));\n-      return 1;\n-    }\n-}\n-\n-\n-/* predicate for the MOV instruction: */\n-int\n-mov_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG);\n-}\n-\n-/* predicate for the STC instruction: */\n-int\n-small_nonneg_const (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) <= 15)\n-    return 1;\n-  return 0;\n-}\n-\n-/* predicate for constant zero: */\n-int\n-zero_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return op == CONST0_RTX (mode);\n-}\n-\n-\n-/* predicate for 1750 `B' addressing mode (Base Register with Offset)\n-   memory operand */\n-int\n-b_mode_operand (op)\n-     rtx op;\n-{\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx inner = XEXP (op, 0);\n-      if (GET_CODE (inner) == REG && REG_OK_FOR_INDEX_P (inner))\n-\treturn 1;\n-      if (GET_CODE (inner) == PLUS)\n-\t{\n-\t  rtx plus_op0 = XEXP (inner, 0);\n-\t  if (GET_CODE (plus_op0) == REG && REG_OK_FOR_INDEX_P (plus_op0))\n-\t    {\n-\t      rtx plus_op1 = XEXP (inner, 1);\n-\t      if (GET_CODE (plus_op1) == CONST_INT\n-\t\t  && INTVAL (plus_op1) >= 0\n-\t\t  && INTVAL (plus_op1) <= 255)\n-\t\treturn 1;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n-\n-/* Decide whether to output a conditional jump as a \"Jump Conditional\"\n-   or as a \"Branch Conditional\": */\n-\n-int\n-find_jmplbl (labelnum)\n-     int labelnum;\n-{\n-  int i, found = 0;\n-\n-  for (i = 0; i <= jmplbl_ndx; i++)\n-    if (labelnum == jmplbl[i].num)\n-      {\n-\tfound = 1;\n-\tbreak;\n-      }\n-  if (found)\n-    return i;\n-  return -1;\n-}\n-\n-const char *\n-branch_or_jump (condition, targetlabel_number)\n-     const char *condition;\n-     int targetlabel_number;\n-{\n-  static char buf[30];\n-  int index;\n-\n-  if ((index = find_jmplbl (targetlabel_number)) >= 0)\n-    if (program_counter - jmplbl[index].pc < 128)\n-      {\n-\tsprintf (buf, \"b%s %%l0\", condition);\n-\treturn buf;\n-      }\n-  sprintf (buf, \"jc %s,%%l0\", condition);\n-  return buf;\n-}\n-\n-\n-int\n-unsigned_comparison_operator (insn)\n-     rtx insn;\n-{\n-  switch (GET_CODE (insn))\n-    {\n-    case GEU:\n-    case GTU:\n-    case LEU:\n-    case LTU:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-int\n-next_cc_user_is_unsigned (insn)\n-     rtx insn;\n-{\n-  if ( !(insn = next_cc0_user (insn)))\n-    abort ();\n-  else if (GET_CODE (insn) == JUMP_INSN\n-\t   && GET_CODE (PATTERN (insn)) == SET\n-\t   && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n-    return unsigned_comparison_operator (XEXP (SET_SRC (PATTERN (insn)), 0));\n-  else if (GET_CODE (insn) == INSN\n-\t   && GET_CODE (PATTERN (insn)) == SET)\n-    return unsigned_comparison_operator (SET_SRC (PATTERN (insn)));\n-  else\n-    abort ();\n-}\n-\n-\n-static int addr_inc;\n-\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand X.  X is an RTL\n-   expression.\n-\n-   CODE is a value that can be used to specify one of several ways\n-   of printing the operand.  It is used when identical operands\n-   must be printed differently depending on the context.  CODE\n-   comes from the `%' specification that was used to request\n-   printing of the operand.  If the specification was just `%DIGIT'\n-   then CODE is 0; if the specification was `%LTR DIGIT' then CODE\n-   is the ASCII code for LTR.\n-\n-   If X is a register, this macro should print the register's name.\n-   The names can be found in an array `reg_names' whose type is\n-   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n-\n-   When the machine description has a specification `%PUNCT' (a `%'\n-   followed by a punctuation character), this macro is called with\n-   a null pointer for X and the punctuation character for CODE.\n-\n-   The 1750 specific codes are:\n-   'J' for the negative of a constant\n-   'Q' for printing addresses in B mode syntax\n-   'd' for the second register in a pair\n-   't' for the third register in a triple \n-   'b' for the bit number (using 1750 test bit convention)\n-   'B' for the bit number of the 1's complement (for bit clear)\n-   'w' for int - 16\n-*/\n-\n-void\n-print_operand (file, x, letter)\n-     FILE *file;\n-     rtx x;\n-     int letter;\n-{\n-  switch (GET_CODE (x))\n-    {\n-    case REG:\n-      if (letter == 'd')\n-\tfprintf (file, \"%d\", REGNO (x) + 1);\n-      else if (letter == 't')\n-\tfprintf (file, \"%d\", REGNO (x) + 2);\n-      else\n-\tfprintf (file, \"%d\", REGNO (x));\n-      break;\n-\n-    case SYMBOL_REF:\n-      fprintf (file, \"%s\", XSTR (x, 0));\n-      if (letter == 'A')\n-\tfprintf (file, \"+1\");\n-      break;\n-\n-    case LABEL_REF:\n-    case CONST:\n-    case MEM:\n-      if (letter == 'Q')\n-\t{\n-\t  rtx inner = XEXP (x, 0);\n-\t  switch (GET_CODE (inner))\n-\t    {\n-\t    case REG:\n-\t      fprintf (file, \"r%d,0\", REGNO (inner));\n-\t      break;\n-\t    case PLUS:\n-\t      fprintf (file, \"r%d,%d\", REGNO (XEXP (inner, 0)),\n-\t\t       INTVAL (XEXP (inner, 1)));\n-\t      break;\n-\t    default:\n-\t      fprintf (file, \"[ill Q code=%d]\", GET_CODE (inner));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  addr_inc = (letter == 'A' ? 1 : 0);\n-\t  output_address (XEXP (x, 0));\n-\t}\n-      break;\n-\n-    case CONST_DOUBLE:\n-      {\n-\tREAL_VALUE_TYPE r;\n-\tchar buf[30];\n-\n-\tREAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\tREAL_VALUE_TO_DECIMAL (r, \"%f\", buf);\n-\n-\tfputs (buf, file);\n-      }\n-      break;\n-\n-    case CONST_INT:\n-      if (letter == 'J')\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, -INTVAL (x));\n-      else if (letter == 'b')\n-        fprintf (file, \"%d\", which_bit (INTVAL (x)));\n-      else if (letter == 'B')\n-        fprintf (file, \"%d\", which_bit (~INTVAL (x)));\n-      else if (letter == 'w')\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) - 16);\n-      else\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n-      break;\n-\n-    case CODE_LABEL:\n-      fprintf (file, \"L%d\", XINT (x, 3));\n-      break;\n-\n-    case CALL:\n-      fprintf (file, \"CALL nargs=\");\n-      fprintf (file, HOST_PTR_PRINTF, (PTR) XEXP (x, 1));\n-      fprintf (file, \", func is either '%s' or '%s'\",\n-\t       XSTR (XEXP (XEXP (x, 0), 1), 0), XSTR (XEXP (x, 0), 1));\n-      break;\n-\n-    case PLUS:\n-      {\n-\trtx op0 = XEXP (x, 0), op1 = XEXP (x, 1);\n-\tint op0code = GET_CODE (op0), op1code = GET_CODE (op1);\n-\tif (op1code == CONST_INT)\n-\t  switch (op0code)\n-\t    {\n-\t    case REG:\n-\t      fprintf (file, \"%d,r%d  ; p_o_PLUS for REG and CONST_INT\",\n-\t\t       INTVAL (op1), REGNO (op0));\n-\t      break;\n-\t    case SYMBOL_REF:\n-\t      fprintf (file, \"%d+%s\", INTVAL (op1), XSTR (op0, 0));\n-\t      break;\n-\t    case MEM:\n-\t      fprintf (file, \"%d,[mem:\", INTVAL (op1));\n-\t      output_address (XEXP (op0, 0));\n-\t      fprintf (file, \"] ;P_O plus\");\n-\t      break;\n-\t    default:\n-\t      fprintf (file, \"p_o_PLUS UFO, code=%d, with CONST=%d\",\n-\t\t       (int) op0code, INTVAL (op1));\n-\t    }\n-\telse if (op1code == SYMBOL_REF && op0code == REG)\n-\t  fprintf (file, \"%s,r%d  ; P_O: (plus reg sym)\",\n-\t\t   XSTR (op1, 0), REGNO (op0));\n-\telse\n-\t  fprintf (file, \"p_o_+: op0code=%d, op1code=%d\", op0code, op1code);\n-      }\n-      break;\n-\n-    default:\n-      fprintf (file, \"p_o_UFO code=%d\", GET_CODE (x));\n-    }\n-\n-  addr_inc = 0;\n-}\n-\n-void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n-{\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      fprintf (file, \"%d,r%d ; P_O_A\", addr_inc, REGNO (addr));\n-      break;\n-    case PLUS:\n-      {\n-\tregister rtx x = XEXP (addr, 0), y = XEXP (addr, 1);\n-\tswitch (GET_CODE (x))\n-\t  {\n-\t  case REG:\n-\t    switch (GET_CODE (y))\n-\t      {\n-\t      case CONST:\n-\t\toutput_address (XEXP (y, 0));\n-\t\tfprintf (file, \",r%d ;P_O_A reg + const expr\", REGNO (x));\n-\t\tbreak;\n-\t      case CONST_INT:\n-\t\tfprintf (file, \"%d,r%d\", INTVAL (y) + addr_inc, REGNO (x));\n-\t\tbreak;\n-\t      case SYMBOL_REF:\n-\t\tfprintf (file, \"%s\", XSTR (y, 0));\n-\t\tif (addr_inc)\n-\t\t  fprintf (file, \"+%d\", addr_inc);\n-\t\tfprintf (file, \",r%d  ; P_O_A reg + sym\", REGNO (x));\n-\t\tbreak;\n-\t      case LABEL_REF:\n-\t\toutput_address (XEXP (y, 0));\n-\t\tfprintf (file, \",r%d  ; P_O_A reg + label\", REGNO (x));\n-\t\tbreak;\n-\t      default:\n-\t\tfprintf (file, \"[P_O_A reg%d+UFO code=%d]\",\n-\t\t\t REGNO (x), GET_CODE (y));\n-\t      }\n-\t    break;\n-\t  case LABEL_REF:\n-\t    output_address (XEXP (x, 0));\n-\t    break;\n-\t  case SYMBOL_REF:\n-\t    switch (GET_CODE (y))\n-\t      {\n-\t      case CONST_INT:\n-\t\tfprintf (file, \"%d+%s\", INTVAL (y) + addr_inc, XSTR (x, 0));\n-\t\tbreak;\n-\t      case REG:\n-\t\tfprintf (file, \"%s,r%d ;P_O_A sym + reg\",\n-\t\t\t XSTR (x, 0), REGNO (y));\n-\t\tbreak;\n-\t      default:\n-\t\tfprintf (file, \"P_O_A sym/lab+UFO[sym=%s,code(y)=%d]\",\n-\t\t\t XSTR (x, 0), GET_CODE (y));\n-\t      }\n-\t    break;\n-\t  case CONST:\n-\t    output_address (XEXP (x, 0));\n-\t    if (GET_CODE (y) == REG)\n-\t      fprintf (file, \",r%d ;P_O_A const + reg\", REGNO (x));\n-\t    else\n-\t      fprintf (file, \"P_O_A const+UFO code(y)=%d]\", GET_CODE (y));\n-\t    break;\n-\t  case MEM:\n-\t    output_address (y);\n-\t    fprintf (file, \",[mem:\");\n-\t    output_address (XEXP (x, 0));\n-\t    fprintf (file, \"] ;P_O_A plus\");\n-\t    break;\n-\t  default:\n-\t    fprintf (file, \"P_O_A plus op1_UFO[code1=%d,code2=%d]\",\n-\t\t     GET_CODE (x), GET_CODE (y));\n-\t  }\n-      }\n-      break;\n-    case CONST_INT:\n-      if (INTVAL (addr) < 0x10000 && INTVAL (addr) >= -0x10000)\n-\tfprintf (file, \"%d ; p_o_a const addr?!\", INTVAL (addr));\n-      else\n-\t{\n-\t  fprintf (file, \"[p_o_a=ILLEGAL_CONST]\");\n-\t  output_addr_const (file, addr);\n-\t}\n-      break;\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      fprintf (file, \"%s\", XSTR (addr, 0));\n-      if (addr_inc)\n-\tfprintf (file, \"+%d\", addr_inc);\n-      break;\n-    case MEM:\n-      fprintf (file, \"[memUFO:\");\n-      output_address (XEXP (addr, 0));\n-      fprintf (file, \"]\");\n-      break;\n-    case CONST:\n-      output_address (XEXP (addr, 0));\n-      fprintf (file, \" ;P_O_A const\");\n-      break;\n-    case CODE_LABEL:\n-      fprintf (file, \"L%d\", XINT (addr, 3));\n-      break;\n-    default:\n-      fprintf (file, \" p_o_a UFO, code=%d val=0x%x\",\n-\t       (int) GET_CODE (addr), INTVAL (addr));\n-      break;\n-    }\n-  addr_inc = 0;\n-}\n-\n-/* Target hook for assembling integer objects.  The 1750a version needs to\n-   keep track of how many bytes have been written.  */\n-\n-static bool\n-assemble_integer_1750a (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n-{\n-  if (default_assemble_integer (x, size, aligned_p))\n-    {\n-      if (label_pending)\n-\tlabel_pending = 0;\n-      datalbl[datalbl_ndx].size += size;\n-      return true;\n-    }\n-  return false;\n-}\n-\n-\n-/*\n- *  Return non zero if the LS 16 bits of the given value has just one bit set,\n- *  otherwise return zero. Note this function may be used to detect one\n- *  bit clear by inverting the param.\n- */\n-int\n-one_bit_set_p (x)\n-     int x;\n-{\n-  x &= 0xffff; \n-  return x && (x & (x - 1)) == 0;\n-}\n-\n-\n-/*\n- * Return the number of the least significant bit set, using the  same\n- * convention for bit numbering as in the MIL-STD-1750 sb instruction.\n- */\n-static int\n-which_bit (x)\n-     int x;\n-{\n-  int b = 15;\n-\n-  while (b > 0 && (x & 1) == 0)\n-    {\n-      b--;\n-      x >>= 1;\n-    }\n-\n-  return b;\n-}\n-\n-\f\n-/* Convert a REAL_VALUE_TYPE to the target float format:\n-\n-        MSB                             LSB MSB            LSB\n-        ------------------------------------------------------\n-        |S|                 Mantissa       |  Exponent       |\n-        ------------------------------------------------------\n-         0 1                             23 24             31\n-\n-*/\n-\n-long\n-real_value_to_target_single(in)\n-     REAL_VALUE_TYPE in;\n-{\n-  union {\n-    double d;\n-    struct {\n-#if HOST_WORDS_BIG_ENDIAN\n-        unsigned int negative:1;\n-        unsigned int exponent:11;\n-        unsigned int mantissa0:20;\n-        unsigned int mantissa1:32;\n-#else\n-        unsigned int mantissa1:32;\n-        unsigned int mantissa0:20;\n-        unsigned int exponent:11;\n-        unsigned int negative:1;\n-#endif\n-    } s;\n-  } ieee;\n-\n-  unsigned int mant;\n-  int exp;\n-\n-  if (HOST_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n-    abort ();\n-\n-  ieee.d = in;\n-\n-  /* Don't bother with NaN, Inf, 0 special cases, since they'll be handled\n-     by the over/underflow code below.  */\n-  exp = ieee.s.exponent - 0x3ff;\n-  mant = 1 << 23 | ieee.s.mantissa0 << 3 | ieee.s.mantissa1 >> 29;\n-\n-  /* The sign is actually part of the mantessa.  Since we're comming from\n-     IEEE we know that either bit 23 is set or we have a zero.  */\n-  if (! ieee.s.negative)\n-    {\n-      mant >>= 1;\n-      exp += 1;\n-    }\n-\n-  /* Check for overflow.  Crop to FLT_MAX.  */\n-  if (exp > 127)\n-    {\n-      exp = 127;\n-      mant = (ieee.s.negative ? 0xffffff : 0x7fffff);\n-    }\n-  /* Underflow to zero.  */\n-  else if (exp < -128)\n-    {\n-      exp = 0;\n-      mant = 0;\n-    }\n-\n-  return mant << 8 | (exp & 0xff);\n-}\n-\n-/* Convert a REAL_VALUE_TYPE to the target 1750a extended float format:\n-\n-        ----------------------------------------------------\n-        | |      Mantissa       |        |   Mantissa      |\n-        |S|         MS          |Exponent|      LS         |\n-        ----------------------------------------------------\n-         0 1                  23 24    31 32             47\n-\n-*/\n-\n-void\n-real_value_to_target_double(in, out)\n-     REAL_VALUE_TYPE in;\n-     long out[];\n-{\n-  union {\n-    double d;\n-    struct {\n-#if HOST_WORDS_BIG_ENDIAN\n-        unsigned int negative:1;\n-        unsigned int exponent:11;\n-        unsigned int mantissa0:20;\n-        unsigned int mantissa1:32;\n-#else\n-        unsigned int mantissa1:32;\n-        unsigned int mantissa0:20;\n-        unsigned int exponent:11;\n-        unsigned int negative:1;\n-#endif\n-    } s;\n-  } ieee;\n-\n-  unsigned int mant_h24, mant_l16;\n-  int exp;\n-\n-  if (HOST_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n-    abort ();\n-\n-  ieee.d = in;\n-\n-  /* Don't bother with NaN, Inf, 0 special cases, since they'll be handled\n-     by the over/underflow code below.  */\n-  exp = ieee.s.exponent - 0x3ff;\n-  mant_h24 = 1 << 23 | ieee.s.mantissa0 << 3 | ieee.s.mantissa1 >> 29;\n-  mant_l16 = (ieee.s.mantissa1 >> 13) & 0xffff;\n-\n-  /* The sign is actually part of the mantessa.  Since we're comming from\n-     IEEE we know that either bit 23 is set or we have a zero.  */\n-  if (! ieee.s.negative)\n-    {\n-      mant_l16 = mant_l16 >> 1 | (mant_h24 & 1) << 15;\n-      mant_h24 >>= 1;\n-      exp += 1;\n-    }\n-\n-  /* Check for overflow.  Crop to DBL_MAX.  */\n-  if (exp > 127)\n-    {\n-      exp = 127;\n-      mant_h24 = (ieee.s.negative ? 0xffffff : 0x7fffff);\n-      mant_l16 = 0xffff;\n-    }\n-  /* Underflow to zero.  */\n-  else if (exp < -128)\n-    {\n-      exp = 0;\n-      mant_h24 = 0;\n-      mant_l16 = 0;\n-    }\n-\n-  out[0] = mant_h24 << 8 | (exp & 0xff);\n-  out[1] = mant_l16;\n-}"}, {"sha": "c6116942077392bd83da98003438db7ea129549a", "filename": "gcc/config/1750a/1750a.h", "status": "removed", "additions": 0, "deletions": 1133, "changes": 1133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1133 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002 Free Software Foundation, Inc.\n-   Contributed by O.M.Kellogg, DASA (oliver.kellogg@space.otn.dasa.de)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-/* See tm-sun3.h, tm-sun2.h, tm-isi68.h for different CPP_PREDEFINES.  */\n-#define CPP_PREDEFINES \"\"\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#ifdef IEEE\n-#define TARGET_VERSION fprintf (stderr, \" (1750A, IEEE syntax)\");\n-#else\n-#define TARGET_VERSION fprintf (stderr, \" (MIL-STD-1750A)\");\n-#endif\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-#define TARGET_SWITCHES\t\t\t\t\t\\\n-  { {\"vaxc-alignment\", 2, N_(\"Use VAX-C alignment\")},\t\\\n-    { \"\", TARGET_DEFAULT, NULL}}\n-\n-/* Default target_flags if no switches specified.  */\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT 1\n-#endif\n-\n-/*****************************************************************************/\n-\n-/* SPECIAL ADDITION FOR MIL-STD-1750A     by O.M.Kellogg, 15-Apr-1993 */\n-/* See file aux-output.c for the actual data instances.  */\n-struct datalabel_array {\n-    char *name;\n-    char value[14];\n-    int size;\n-};\n-struct jumplabel_array {\n-    int pc;\n-    int num;\n-};\n-enum section { Init, Normal, Konst, Static };\n-#define DATALBL_ARRSIZ 256\n-#define JMPLBL_ARRSIZ  256\n-#ifndef __datalbl\n-extern struct datalabel_array datalbl[DATALBL_ARRSIZ];\n-extern struct jumplabel_array jmplbl[JMPLBL_ARRSIZ];\n-extern int datalbl_ndx, jmplbl_ndx, label_pending, program_counter;\n-extern enum section current_section;\n-extern const char *const sectname[4];\n-#endif\n-/*--------------------------------------------------------------------*/\n-\n-/* target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   Though 1750 actually counts bits in big-endian fashion, the sign bit\n-   is still the most significant bit, which is leftmost. Therefore leaving\n-   this little-endian. Adjust short before assembler output when needed:\n-   e.g. in QImode, a GCC bit n is a 1750 bit (15-n).  */\n-#define BITS_BIG_ENDIAN 0 \n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* For 1750 we can decide arbitrarily\n-   since there are no machine instructions for them.  */\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword value is lowest\n-   numbered.\n-   True for 1750.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* number of bits in an addressable storage unit */\n-#define BITS_PER_UNIT        16\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD       1\n-\n-#define PTRDIFF_TYPE        \"int\"\n-\n-/* Type to use for `size_t'. If undefined, uses `long unsigned int'.  */\n-#define SIZE_TYPE           \"int\"\n-\n-/* 1750a preliminary.  Ought to properly define the format in real.c.  */\n-#define TARGET_FLOAT_FORMAT UNKNOWN_FLOAT_FORMAT\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY     16\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-/* 1750: should have had to make this 32 when BITS_PER_WORD is 32.  */\n-#define PARM_BOUNDARY        16\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY       16\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY    16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 16\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT    16\n-\n-/* Define this to 1 if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 0\n-\n-/* Define number of bits in most basic integer type.\n-   (If undefined, default is BITS_PER_WORD).\n-   #define INT_TYPE_SIZE  16  */\n-\n-/* Define number of bits in short integer type.\n-   (If undefined, default is half of BITS_PER_WORD).  */\n-#define SHORT_TYPE_SIZE 16\n-\n-/* Define number of bits in long integer type.\n-   (If undefined, default is BITS_PER_WORD).  */\n-#define LONG_TYPE_SIZE  32\n-\n-/* Define number of bits in long long integer type.\n-   (If undefined, default is twice BITS_PER_WORD).  */\n-/* 1750 PRELIMINARY : no processor support for `long long', therefore\n-        need to check out the long-long opencodings ! */\n-#define LONG_LONG_TYPE_SIZE  64\n-\n-/* Define number of bits in float type.\n-   (If undefined, default is BITS_PER_WORD).  */\n-#define FLOAT_TYPE_SIZE  32\n-\n-/* Define number of bits in double type.\n-   (If undefined, default is twice BITS_PER_WORD).  */\n-#define DOUBLE_TYPE_SIZE  48\n-\n-/*****************************************************************************/\n-\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER 16\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   R15 is the 1750A stack pointer. R14 is the frame pointer.  */\n-\n-#define FIXED_REGISTERS  \\\n- { 0, 0, 0, 0, 0, 0, 0, 0, \\\n-   0, 0, 0, 0, 0, 0, 1, 1 }\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.\n-   1750: return value in R0 foll. (depending on size of retval).\n-   Should be possible to refine this (how many regs are actually used) */\n-\n-#define CALL_USED_REGISTERS \\\n- { 1, 1, 1, 1, 1, 1, 1, 1, \\\n-   1, 1, 1, 1, 1, 1, 1, 1 }\n-\n-/* Order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.  List frame pointer\n-   late and fixed registers last.  Note that, in general, we prefer\n-   registers listed in CALL_USED_REGISTERS, keeping the others\n-   available for storage of persistent values.  */\n-\n-/* #define REG_ALLOC_ORDER \\\n-   { 2, 0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }\n- */\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-   All 1750 registers are one word long.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t1\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* 1750A pc isn't overloaded on a register.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 15\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 14\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 14\n-\n-/* Define this if successive args to a function occupy decreasing addresses\n-   on the stack. \n-   #define ARGS_GROW_DOWNWARD\n-*/\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 13\n-\n-/* Place in which caller passes the structure value address.\n-   0 means push the value on the stack like an argument. \n-   #define STRUCT_VALUE 0\n-*/\n-\n-/* Register in which address to store a structure value\n-   arrives in the function.  \n-   #define STRUCT_VALUE_INCOMING 0\n-*/\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 12\n-\n-/* Define this to be 1 if all structure return values must be in memory.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/*****************************************************************************/\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-/* 1750 note: The names (BASE_REGS/INDEX_REGS) are used in their *gcc sense*\n-   (i.e. *opposite* to the MIL-STD-1750A defined meanings). This means that\n-   R1..R15 are called \"base\" regs and R12..R15 are \"index\" regs.\n-   Index reg mode (in the gcc sense) is not yet implemented (these are the\n-   1750 \"Base with Index Reg\" instructions, LBX etc. See 1750.md)\n-\n-   Here's an example to drive this point home: in \"LBX B12,R5\"\n-   B12 shall be called the \"index\" reg and R5 shall be the \"base\" reg.\n-   This naming inversion is due to the GCC defined capabilities of\n-   \"Base\" vs. \"Index\" regs.  */\n-\n-enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Since GENERAL_REGS is the same class as ALL_REGS,\n-   don't give it a different class number; just make it an alias.  */\n-#define GENERAL_REGS ALL_REGS\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n- { \"NO_REGS\", \"R2\", \"R0_1\", \"INDEX_REGS\", \"BASE_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.\n-   1750 \"index\" (remember, in the *GCC* sense!) regs are R12 through R15. \n-   The only 1750 register not usable as BASE_REG is R0.  */\n-\n-#define REG_CLASS_CONTENTS  { {0}, {0x0004}, {0x0003}, {0xf000}, {0xfffe}, {0xffff} }\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-#define REGNO_REG_CLASS(REGNO) ((REGNO) == 2 ? R2 : (REGNO) == 0 ? R0_1 : \\\n-  (REGNO) >= 12 ? INDEX_REGS : (REGNO) >  0 ? BASE_REGS : ALL_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define BASE_REG_CLASS  BASE_REGS\n-#define INDEX_REG_CLASS INDEX_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.\n-   For the 1750, we have 'z' for R0_1, 't' for R2, 'b' for gcc Base regs \n-   and 'x' for gcc Index regs.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) ((C) == 't' ? R2 : \\\n-\t\t\t\t  (C) == 'z' ? R0_1 : \\\n-\t\t\t\t  (C) == 'b' ? BASE_REGS : \\\n-\t\t\t\t  (C) == 'x' ? INDEX_REGS : NO_REGS)\n-\n-/* The letters I,J,K,.. to P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For the 1750A, \n-   `I' is used for ISP mode instructions,\n-   `J' is used for ISN mode instructions,\n-   `K' is used for the STC instruction's constant range,\n-   `L' is used for unsigned 8-bit address displacements in instructions\n-       of addressing mode \"Base Relative\",\n-   `M' is for IM mode instructions et al.,\n-   `O' is a synonym for (const_int 0).  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'I' ? (VALUE) > 0 && (VALUE) <=  16 :\t\t\t\\\n-   (C) == 'J' ? (VALUE) < 0 && (VALUE) >= -16 :\t\t\t\\\n-   (C) == 'K' ? (VALUE) >= 0 && (VALUE) <= 15 :\t\t\t\\\n-   (C) == 'L' ? (VALUE) >= 0 && (VALUE) <= 0xFF :\t\t\\\n-   (C) == 'M' ? (VALUE) >= -0x8000 && (VALUE) <= 0x7FFF : \t\\\n-   (C) == 'O' ? (VALUE) == 0 :\t\t\t\t0)\n-\n-/* Similar, but for floating constants, and defining letter 'G'.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'G' ? ((VALUE) == CONST0_RTX (HFmode)         \\\n-                 || (VALUE) == CONST0_RTX (TQFmode)) : 0)\n-\n-/* Optional extra constraints for this machine.\n-\n-   For the 1750, `Q' means that this is a memory operand consisting\n-   of the sum of an Index Register (in the GCC sense, i.e. R12..R15)\n-   and a constant in the range 0..255. This constraint is used for\n-   the Base Register with Offset address mode instructions (LB,STB,AB,..)  */\n-\n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' && b_mode_operand (OP))\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  CLASS\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.\n-   On the 1750A, this is the size of MODE in words,\n-   since class doesn't make any difference.  */\n-#define CLASS_MAX_NREGS(CLASS,MODE)  GET_MODE_SIZE(MODE)\n-\n-/*****************************************************************************/\n-\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD 1\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   goes at a more negative offset in the frame. \n-   #define FRAME_GROWS_DOWNWARD\n-*/\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.\n-*/\n-#define STARTING_FRAME_OFFSET 1\n-\n-/* This is the default anyway:\n-   #define DYNAMIC_CHAIN_ADDRESS(FRAMEADDR) FRAMEADDR\n-*/\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   1750 note: what GCC calls a \"byte\" is really a 16-bit word,\n-   because BITS_PER_UNIT is 16.  */\n-\n-#define PUSH_ROUNDING(BYTES) (BYTES)\n-\n-/* Define this macro if functions should assume that stack space has\n-   been allocated for arguments even when their values are passed in\n-   registers.\n-   Size, in bytes, of the area reserved for arguments passed in\n-   registers for the function represented by FNDECL. \n-   #define REG_PARM_STACK_SPACE(FNDECL) 14 */\n-\n-/* Define this if it is the responsibility of the caller to allocate\n-   the area reserved for arguments passed in registers. \n-   #define OUTGOING_REG_PARM_STACK_SPACE */\n-\n-/* Offset of first parameter from the argument pointer register value.\n-   1750 note:\n-   Parameters appear in reversed order on the frame (so when they are\n-   popped, they come off in the normal left-to-right order.)\n-   Computed as follows:\n-   one word for the caller's (PC+1) (i.e. the return address)\n-   plus total size of called function's \"auto\" variables\n-   plus one word for the caller's frame pointer (i.e. the old FP) */\n-\n-#define FIRST_PARM_OFFSET(FNDECL) \\\n-   (1 + get_frame_size() + 1)\n-\n-/* Value is 1 if returning from a function call automatically\n-   pops the arguments described by the number-of-args field in the call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-*/\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-/* 1750 note: no libcalls yet */\n-\n-#define LIBCALL_VALUE(MODE)  printf(\"LIBCALL_VALUE called!\\n\"), \\\n-  gen_rtx_REG (MODE, 0)\n-\n-/* 1 if N is a possible register number for a function value.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N)  ((N) == 0)\n-\n-/* 1 if the tree TYPE should be returned in memory instead of in regs. \n-   #define RETURN_IN_MEMORY(TYPE) \\\n-   (int_size_in_bytes(TYPE) > 12)\n-*/\n-\n-/* Define this if PCC uses the nonreentrant convention for returning\n-   structure and union values. \n-   #define PCC_STATIC_STRUCT_RETURN  */\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N)  ((N) < 12)\n-\n-/*****************************************************************************/\n-\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   For 1750A, this is a single integer, which is a number of words\n-   of arguments scanned so far.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   For 1750A, the offset starts at 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)   ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)\n-\n-   1750 note: \"int_size_in_bytes()\" returns a unit relative to\n-   BITS_PER_UNIT, so in our case not bytes, but 16-bit words.  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += (MODE) == BLKmode ? int_size_in_bytes(TYPE) : GET_MODE_SIZE(MODE))\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) function_arg (CUM,MODE,TYPE,NAMED)\n-\n-/* Define the following macro if function calls on the target machine\n-   do not preserve any registers; in other words, if `CALL_USED_REGISTERS'\n-   has 1 for all registers. This macro enables `-fcaller-saves' by\n-   default. Eventually that option will be enabled by default on all\n-   machines and both the option and this macro will be eliminated.  */\n-\n-#define DEFAULT_CALLER_SAVES\n-\n-/************* 1750: PROFILER HANDLING NOT YET DONE !!!!!!! *************/\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"; got into FUNCTION_PROFILER with label # %d\\n\", (LABELNO))\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 0\n-\n-/* If the memory address ADDR is relative to the frame pointer,\n-   correct it to be relative to the stack pointer instead.\n-   This is for when we don't use a frame pointer.\n-   ADDR should be a variable name.\n-\n-   #define FIX_FRAME_POINTER_ADDRESS(ADDR,DEPTH)  \n-*/\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) DEPTH = 0\n-*/\n-\n-#define ELIMINABLE_REGS { \\\n-\t{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },  \\\n-\t{ ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM },  \\\n-\t{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM } }\n-\n-#define CAN_ELIMINATE(FROM, TO)   1\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)   \\\n-\tOFFSET = (TO == STACK_POINTER_REGNUM) ? -1 : 0\n-\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)  fprintf(FILE,\"TRAMPOLINE_TEMPLATE called\\n\")\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 2\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  printf(\"INITIALIZE_TRAMPO called\\n\")\n-/* {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (QImode, plus_constant (TRAMP, 1)), CXT); \\\n-  emit_move_insn (gen_rtx_MEM (QImode, plus_constant (TRAMP, 6)), FNADDR); \\\n-} */\n-\n-\n-/*****************************************************************************/\n-\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* 1750 doesn't have a lot of auto-incr./decr. - just for the stack ptr.  */\n-\n-/* #define HAVE_POST_INCREMENT 0 just for R15 (stack pointer) */\n-/* #define HAVE_POST_DECREMENT 0 */\n-/* #define HAVE_PRE_DECREMENT 0  just for R15 (stack pointer) */\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c. \n-   1750 note: The words BASE and INDEX are used in their GCC senses:\n-   The \"Index Registers\", R12 through R15, are used in the 1750\n-   instructions LB,STB,AB,SBB,MB,DB,LBX,STBX,...\n-   */\n-\n-#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n- (((REGNO) > 0 && (REGNO) <= 15) ||   \\\n-  (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] <= 15))\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n- (((REGNO) >= 12 && (REGNO) <= 15) || \\\n-  (reg_renumber[REGNO] >= 12 && reg_renumber[REGNO] <= 15))\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.  */\n-\n-/* 1 if X is an address register  */\n-\n-#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)  CONSTANT_P(X)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifdef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P(REGNO(X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P(REGNO(X))\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) (REGNO (X) >= 12)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) (REGNO (X) > 0)\n-\n-#endif\n-\n-\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.\n-\n-   1750 note: Currently we don't implement address expressions that use\n-   GCC \"Index\"-class regs. To be expanded to handle the 1750 \"Base with Index\"\n-   instructions (see also MAX_REGS_PER_ADDRESS and others).  */\n-\n-#define GO_IF_BASED_ADDRESS(X, ADDR) {\t\t\t\t\t\\\n-   if ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P(X)))\t\t\t\\\n-     goto ADDR;\t\t\t\t\t\t\t\t\\\n-   if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { register rtx x0 = XEXP(X,0), x1 = XEXP(X,1);\t\t\t\\\n-      if ((REG_P(x0) && REG_OK_FOR_BASE_P(x0) && CONSTANT_ADDRESS_P(x1)) \\\n-       || (REG_P(x1) && REG_OK_FOR_BASE_P(x1) && CONSTANT_ADDRESS_P(x0))) \\\n-     goto ADDR; } }\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) {\t\t\t\\\n-\tif (CONSTANT_ADDRESS_P(X)) goto ADDR;\t\t\t\t\\\n-\tGO_IF_BASED_ADDRESS(X,ADDR) }\n-\n-\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the 68000, only predecrement and postincrement address depend thus\n-   (the amount of decrement or increment being the length of the operand).  */\n-/* 1750: not used.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\n-/*****************************************************************************/\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE QImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 65536\n-\n-/* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movstr or libcall instead.  */\n-#define MOVE_RATIO 4\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Define if shifts truncate the shift count\n-   which implies one can omit a sign-extension or zero-extension\n-   of a shift count.  */\n-/* #define SHIFT_COUNT_TRUNCATED 1 */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* We assume that the store-condition-codes instructions store 0 for false\n-   and some other value for true.  This is the value stored for true.  */\n-\n-#define STORE_FLAG_VALUE 1\n-\n-/* When a prototype says `char' or `short', really pass an `int'. \n-   1750: for now, `char' is 16 bits wide anyway.  */\n-#define PROMOTE_PROTOTYPES 0\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode QImode\n-\n-/* A function address in a call instruction\n-   is a 16-bit address (for indexing purposes) */\n-#define FUNCTION_MODE QImode\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE)  \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    return (INTVAL(RTX) >= -16 && INTVAL(RTX) <= 16) ? 1 : 3;\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 4;\n-\n-#define ADDRESS_COST(ADDRESS)  (memop_valid (ADDRESS) ?  3 : 10)\n-\n-#define REGISTER_MOVE_COST(MODE,FROM,TO)\t2\n-\n-#define MEMORY_MOVE_COST(M,C,I)\t\t4\n-\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-/* MIL-STD-1750: none -- just has the garden variety C,P,Z,N flags.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.\n-   1750: See file out-1750a.c for notice_update_cc().  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP)\n-\n-/**********************************************/\n-/* Produce debugging info in the DWARF format \n-   #define DWARF_DEBUGGING_INFO\n-*/\n-\n-/*****************************************************************************/\n-\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#define ASM_FILE_START(FILE)   {\t\t\t\t\t\\\n-   char *p2, name[40];\t\t\t\t\t\t\t\\\n-   const char *p;\t\t\t\t\t\t\t\\\n-   if ((p = strrchr(main_input_filename,'/')) != NULL ? 1 :\t\t\\\n-       (p = strrchr(main_input_filename,']')) != NULL)\t\t\t\\\n-\tp++;\t\t\t\t\t\t\t\t\\\n-   else\t\t\t\t\t\t\t\t\t\\\n-\tp = main_input_filename;\t\t\t\t\t\\\n-   strcpy(name,p);\t\t\t\t\t\t\t\\\n-   if ((p2 = strchr(name,'.')))\t\t\t\t\t\t\\\n-\t*p2 = '\\0';\t\t\t\t\t\t\t\\\n-   fputs (\"\\tname \", FILE);                                             \\\n-   output_clean_symbol_name (FILE, name);                               \\\n-   putc ('\\n', FILE);                                                   \\\n-   fprintf(FILE,\"\\tnolist\\n\\tinclude \\\"ms1750.inc\\\"\\n\\tlist\\n\\n\");\t\\\n-   fprintf(FILE,\"\\tglobal\\t__main\\n\\n\");  }\n-\n-/* Output at end of assembler file.  \n-   For 1750, we copy the data labels accrued in datalbl[] from the Constants \n-   section (Konst) to the Writable-Data section (Static).     */\n-\n-#define ASM_FILE_END(FILE)\t\\\n-   do {\t\t\t\t\t\t\t\t\t\\\n-      if (datalbl_ndx >= 0) {\t\t\t\t\t\t\\\n-         int i, cum_size=0;\t\t\t\t\t\t\\\n-         fprintf(FILE,\"\\n\\tstatic\\ninit_srel\\n\");\t\t\t\\\n-         for (i = 0; i <= datalbl_ndx; i++) {\t\t\t\t\\\n-\t    if (datalbl[i].name == NULL)\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t       fprintf(stderr, \"asm_file_end internal datalbl err\\n\");\t\\\n-\t       exit (0);\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-            fprintf(FILE,\"%s \\tblock %d\\n\",\t\t\t\t\\\n-                 datalbl[i].name,datalbl[i].size);\t\t\t\\\n-            cum_size += datalbl[i].size;\t\t\t\t\\\n-\t }\t\t\t\t\t\t\t\t\\\n-         fprintf(FILE,\"\\n\\tinit\\n\");\t\t\t\t\t\\\n-         fprintf(FILE,\"\\tlim\\tr0,init_srel\\n\");           /* destin.  */\t\\\n-         fprintf(FILE,\"\\tlim\\tr1,%d\\n\",cum_size);         /* count */\t\\\n-         fprintf(FILE,\"\\tlim\\tr2,K%s\\n\",datalbl[0].name); /* source */\t\\\n-         fprintf(FILE,\"\\tmov\\tr0,r2\\n\");\t\t\t\t\\\n-         fprintf(FILE,\"\\n\\tnormal\\n\");\t\t\t\t\t\\\n-         datalbl_ndx = -1;\t\t\t/* reset stuff */\t\\\n-         for (i = 0; i < DATALBL_ARRSIZ; i++)\t\t\t\t\\\n-            datalbl[i].size = 0;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-      fprintf(FILE,\"\\n\\tend\\n\");\t\t\t\t\t\\\n-   } while (0)\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"; ASM_APP_ON\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"; ASM_APP_OFF\\n\"\n-\n-#define EXTRA_SECTION_FUNCTIONS\t\t\\\n-    void check_section(sect)\t\t\t\t\t\\\n-\t enum section sect;\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-        if (current_section != sect) {\t\t\t\t\\\n-\t    fprintf(asm_out_file,\"\\t%s\\n\",sectname[(int)sect]); \\\n-\t    current_section = sect;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\tswitch (sect) {\t\t\t\t\t\t\\\n-\t  case Init:\t\t\t\t\t\t\\\n-\t  case Normal:\t\t\t\t\t\t\\\n-\t    in_section = in_text;\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t  case Static:\t\t\t\t\t\t\\\n-\t    in_section = in_data;\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t  case Konst:\t\t\t\t\t\t\\\n-\t    in_section = in_readonly_data;\t\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\n-\n-#define READONLY_DATA_SECTION_ASM_OP \"\\tkonst\"\n-\n-/* Output before program init section */\n-#define INIT_SECTION_ASM_OP \"\\n\\tinit     ; init_section\\n\"\n-\n-/* Output before program text section */\n-#define TEXT_SECTION_ASM_OP \"\\n\\tnormal   ; text_section\\n\"\n-\n-/* Output before writable data.\n-   1750 Note: This is actually read-only data. The copying from read-only\n-   to writable memory is done elsewhere (in ASM_FILE_END.)\n- */\n-#define DATA_SECTION_ASM_OP \"\\n\\tkonst    ; data_section\\n\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n- { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \\\n-   \"8\", \"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\" }\n-\n-/******************  Assembler output formatting  **********************/\n-\n-#define ASM_COMMENT_START  \";\"\n-\n-#define ASM_OUTPUT_OPCODE(FILE,PTR)  do {\t\t\\\n-\twhile (*(PTR) != '\\0' && *(PTR) != ' ') {\t\\\n-\t    putc (*(PTR), FILE);\t\t\t\\\n-\t    (PTR)++;\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\\\n-\twhile (*(PTR) == ' ')\t\t\t\t\\\n-\t    (PTR)++;\t\t\t\t\t\\\n-\tputc ('\\t', FILE);\t\t\t\t\\\n-\tprogram_counter += 2;\t\t\t\t\\\n-     } while (0)\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n-\tfprintf(FILE,\"%s\\n\",NAME)\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-/* 1750 note: Labels are prefixed with a 'K'. This is because handling\n-   has been changed for labels to be output in the \"Constants\" section\n-   (named \"Konst\"), and special initialization code takes care of copying\n-   the Const-section data into the writable data section (named \"Static\").\n-   In the Static section we therefore have the true label names (i.e.\n-   not prefixed with 'K').  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do {  if (NAME[0] == '.') {\t\t\t\t\t\\\n-\t   fprintf(stderr,\"Oops! label %s can't begin with '.'\\n\",NAME); \\\n-\t   abort();\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\telse {\t\t\t\t\t\t\t\\\n-\t   check_section(Konst);\t\t\t\t\\\n-\t   fprintf(FILE,\"K%s\\n\",NAME);\t\t\t\t\\\n-\t   fflush(FILE);\t\t\t\t\t\\\n-\t   datalbl[++datalbl_ndx].name = (char *)xstrdup (NAME);\\\n-\t   datalbl[datalbl_ndx].size = 0;\t\t\t\\\n-\t   label_pending = 1;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME) do {\t\t\\\n-\t   fprintf (FILE, \"\\tglobal  %s\\t; export\\n\", NAME);\t\\\n-  } while (0)\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t  if (strcmp(PREFIX,\"LC\") == 0) {\t\t\t\\\n-\t     label_pending = 1;\t\t\t\t\t\\\n-\t     datalbl[++datalbl_ndx].name = (char *) xmalloc (9);\\\n-\t     sprintf(datalbl[datalbl_ndx].name,\"LC%d\",NUM);\t\\\n-\t     datalbl[datalbl_ndx].size = 0;\t\t\t\\\n-\t     check_section(Konst);\t\t\t\t\\\n-\t     fprintf(FILE,\"K%s%d\\n\",PREFIX,NUM);\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\t  else if (find_jmplbl(NUM) < 0) {\t\t\t\\\n-\t     jmplbl[++jmplbl_ndx].num = NUM;\t\t\t\\\n-\t     jmplbl[jmplbl_ndx].pc = program_counter;\t\t\\\n-\t     fprintf(FILE, \"%s%d\\n\", PREFIX, NUM);\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\t  fflush(FILE);\t\t\t\t\t\t\\\n-\t} while (0)\n-\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-\t  sprintf (LABEL, \"%s%d\", PREFIX, NUM)\n-\n-/* Output at the end of a jump table.\n-   1750: To be uncommented when we can put jump tables in Konst.  \n-   #define ASM_OUTPUT_CASE_END(FILE,NUM,INSN)      \\\n-\tfprintf (FILE, \"\\tnormal\\t; case_end\\n\")\n- */\n-\n-/* Currently, it is not possible to put jump tables in section Konst.\n-   This is because there is a one-to-one relation between sections Konst\n-   and Static (i.e., all Konst data are copied to Static, and the order\n-   of data is the same between the two sections.) However, jump tables are\n-   not copied to Static, which destroys the equivalence between Konst and\n-   Static. When a more intelligent Konst-to-Static copying mechanism is\n-   implemented (i.e. one that excludes the copying of jumptables), then\n-   ASM_OUTPUT_CASE_END shall be defined, and JUMP_LABELS_IN_TEXT_SECTION\n-   shall be undefined.   */\n-\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-/* This is how to output an assembler line defining a string constant.  */\n-\n-#define ASM_OUTPUT_ASCII(FILE, PTR, LEN)  do {\t\t\\\n-\tint i;\t\t\t\t\t\t\t\t\\\n-\tif (label_pending)\t\t\t\t\t\t\\\n-\t   label_pending = 0;\t\t\t\t\t\t\\\n-\tdatalbl[datalbl_ndx].size += LEN;\t\t\t\t\\\n-\tfor (i = 0; i < (int) LEN; i++) {\t\t\t\t\\\n-\t  if ((i % 15) == 0) {\t\t\t\t\t\t\\\n-\t    if (i != 0)\t\t\t\t\t\t\t\\\n-\t      fprintf(FILE,\"\\n\");\t\t\t\t\t\\\n-\t    fprintf(FILE,\"\\tdata\\t\");\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf(FILE,\",\");\t\t\t\t\t\t\\\n-\t  if (PTR[i] >= 32 && PTR[i] < 127)\t\t\t\t\\\n-\t    fprintf(FILE,\"'%c'\",PTR[i]);\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf(FILE,\"%d\",PTR[i]);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\tfprintf(FILE,\"\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tPSHM R%s,R%s\\n\", reg_names[REGNO], \"FIXME: missing arg\")\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-\tfprintf (FILE, \"\\tPOPM R%s,R%s\\n\", reg_names[REGNO], \"FIXME: missing arg\")\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)   \\\n-\tfprintf (FILE, \"\\tdata\\tL%d ;addr_vec_elt\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-\tfprintf (FILE, \"\\tdata\\tL%d-L%d ;addr_diff_elt\\n\", VALUE,REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n- fprintf(FILE,\"; in ASM_OUTPUT_ALIGN: pwr_of_2_bytcnt=%d\\n\",LOG)\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)\t\\\n-   fprintf(FILE,\"; in ASM_OUTPUT_SKIP: size=%d\\n\",SIZE)\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  do {\t\\\n-\tcheck_section(Static);\t\t\t\t\t  \\\n-\tfprintf (FILE, \"\\tcommon  %s,%d\\n\", NAME, SIZE);\t  \\\n-     } while (0)\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)  do {\t\t\\\n-\tfprintf (FILE, \"\\tglobal  %s\\t; import\\n\", NAME);\t\\\n-     }  while (0)\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  do {  \\\n-\tcheck_section (Static);\t\t\t\t\t\\\n-\tfprintf(FILE,\"%s \\tblock   %d\\t; local common\\n\",NAME,SIZE);\t\\\n-     } while (0)\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-   1750 note:  there are three special CODE characters:\n-        'D', 'E': print a reference to a floating point constant (D=double,\n-\t\t  E=single precision) label name\n-\t'F': print a label defining a floating-point constant value\n-\t'J': print the absolute value of a negative INT_CONST\n-\t     (this is used in LISN/CISN/MISN/SISP and others)\n-\t'Q': print a 1750 Base-Register-with-offset instruction's operands\n- */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address(FILE,ADDR)\n-\n-/* Convert a REAL_VALUE_TYPE to the target 1750a float format.  */\n-#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT) \\\n-  ((OUT) = real_value_to_target_single(IN))\n-\n-/* Convert a REAL_VALUE_TYPE to the target 1750a extended float format.  */\n-#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT) \\\n-  real_value_to_target_double((IN), (OUT))"}, {"sha": "2117e94fab6b719f7bd9e31e140436a6b2c6878a", "filename": "gcc/config/1750a/1750a.md", "status": "removed", "additions": 0, "deletions": 1436, "changes": 1436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2F1750a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.md?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1436 +0,0 @@\n-;;- Machine description for GNU compiler\n-;;- MIL-STD-1750A version.\n-;; Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999,\n-;; 2000 Free Software Foundation, Inc.\n-;; Contributed by O.M.Kellogg, DASA (oliver.kellogg@space.otn.dasa.de).\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-\n-;;- instruction definitions\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;;- When naming insn's (operand 0 of define_insn) be careful about using\n-;;- names from other targets machine descriptions.\n-\n-;; MIL-STD-1750 specific remarks:\n-;;\n-;; 1) BITS_PER_UNIT = 16\n-;;\n-;; 2) GCC   to    MIL-STD-1750       data type mappings:\n-;;    QImode => single integer (16 bits or 1 reg).\n-;;    HImode => double integer (32 bits or 2 regs).\n-;;    HFmode => single precision float (32 bits or 2 regs).\n-;;    TQFmode => extended precision float (48 bits or 3 regs).\n-;; \n-;; 3) Immediate integer operands Constraints:\n-;;    'I'  1 .. 16\n-;;    'J' -1 ..-16\n-;;    'K'  0 .. 15\n-;;    'L'  0 .. 255\n-;;    'M' -32768 .. 32767\n-;;    'O' => 0  (for optimizations and GCC quirks)\n-;;\n-;; Further notes:\n-;;-  Assembly output ending in \".M\" are macros in file M1750.INC\n-\n-\n-;; stackpush\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"push_operand\" \"=<\")\n-        (match_operand:QI 1 \"general_operand\" \"r\"))]\n-  \"\"\n-  \"pshm r%1,r%1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n-        (match_operand:HI 1 \"general_operand\" \"r\"))]\n-  \"\"\n-  \"pshm r%1,r%d1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HF 0 \"push_operand\" \"=<\")\n-        (match_operand:HF 1 \"general_operand\" \"r\"))]\n-  \"\"\n-  \"pshm r%1,r%d1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:TQF 0 \"push_operand\" \"=<\")\n-        (match_operand:TQF 1 \"general_operand\" \"r\"))]\n-  \"\"\n-  \"pshm r%1,r%t1\")\n-\n-;; stackpop\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n-        (match_operand:QI 1 \"push_operand\" \">\"))]\n-  \"\"\n-  \"popm r%1,r%1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n-        (match_operand:HI 1 \"push_operand\" \">\"))]\n-  \"\"\n-  \"popm r%1,r%d1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HF 0 \"general_operand\" \"=r\")\n-        (match_operand:HF 1 \"push_operand\" \">\"))]\n-  \"\"\n-  \"popm r%1,r%d1\")\n-   \n-(define_insn \"\"\n-  [(set (match_operand:TQF 0 \"general_operand\" \"=r\")\n-        (match_operand:TQF 1 \"push_operand\" \">\"))]\n-  \"\"\n-  \"popm r%1,r%t1\")\n-\n-\n-;; Test operations.\n-\n-(define_insn \"tstqi\"\n-  [(set (cc0)\n-        (match_operand:QI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"lr r%0,r%0   ; from tstqi\")\n-\n-(define_insn \"tsthi\"\n-  [(set (cc0)\n-        (match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"dlr r%0,r%0   ; from tsthi\")\n-\n-; With 1750A floats, testing the most significant word suffices.\n-\n-(define_insn \"tsthf\"\n-  [(set (cc0)\n-        (match_operand:HF 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"lr r%0,r%0   ; tsthf\")\n-\n-(define_insn \"tsttqf\"\n-  [(set (cc0)\n-        (match_operand:TQF 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"lr r%0,r%0   ; tsttqf\")\n-\n-\n-;; block move.\n-\n-(define_insn \"movstrqi\"\n-  [(set (match_operand:BLK 0 \"mov_memory_operand\" \"=m\")\n-\t(match_operand:BLK 1 \"mov_memory_operand\" \"m\"))\n-   (use (match_operand:QI 2 \"general_operand\" \"r\"))\n-   (match_operand 3 \"\" \"\")\n-   (clobber (match_dup 0))\n-   (clobber (match_dup 1))\n-   (clobber (match_dup 2))]\n-  \"\"\n-  \"*\n-   {\n-     rtx regops[3];\n-\n-     regops[0] = XEXP (operands[0], 0);\n-     regops[1] = XEXP (operands[1], 0);\n-     regops[2] = operands[2];\n-\n-     return movcnt_regno_adjust (regops);\n-   } \")\n-\n-\n-;; compare instructions.\n-\n-(define_insn \"cmpqi\"\n-  [(set (cc0)\n-        (compare (match_operand:QI 0 \"register_operand\" \"r,r,r,r,r\")\n-                 (match_operand:QI 1 \"general_operand\"  \"I,J,i,r,m\")))]\n-  \"\"\n-  \"*\n-   {\n-     if (next_cc_user_is_unsigned (insn))\n-       switch (which_alternative)\n-\t {\n-\t case 0:\n-\t case 1:\n-\t case 2:\n-\t   return \\\"ucim.m %0,%1\\\";\n-\t case 3:\n-\t   return \\\"ucr.m %0,%1\\\";\n-\t case 4:\n-\t   return \\\"uc.m %0,%1\\\";\n-\t default:\n-\t   abort();\n-\t }\n-     else\n-       switch (which_alternative)\n-\t {\n-\t case 0:\n-\t   return \\\"cisp r%0,%1\\\";\n-\t case 1:\n-\t   return \\\"cisn r%0,%J1\\\";\n-\t case 2:\n-\t   return \\\"cim  r%0,%1\\\";\n-\t case 3:\n-\t   return \\\"cr   r%0,r%1\\\";\n-\t case 4:\n-\t   return \\\"c    r%0,%1\\\";\n-\t default:\n-\t   abort();\n-\t }\n-   } \")\n-\n-(define_insn \"cmphi\"\n-  [(set (cc0)\n-        (compare (match_operand:HI 0 \"general_operand\" \"r,r\")\n-                 (match_operand:HI 1 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"*\n-   {\n-     if (next_cc_user_is_unsigned (insn))\n-       {\n-         if (which_alternative == 0)\n-\t   return \\\"ducr.m %0,%1\\\";\n-\t return \\\"duc.m %0,%1\\\";\n-       }\n-     else\n-       {\n-         if (which_alternative == 0)\n-           return \\\"dcr r%0,r%1\\\";\n-         return \\\"dc  r%0,%1\\\";\n-       }\n-   } \")\n-\n-(define_insn \"cmphf\"\n- [(set (cc0)\n-       (compare (match_operand:HF 0 \"general_operand\" \"r,r\")\n-                (match_operand:HF 1 \"general_operand\" \"r,m\")))]\n- \"\"\n- \"@\n-   fcr r%0,r%1\n-   fc  r%0,%1 \")\n-\n-(define_insn \"cmptqf\"\n-  [(set (cc0)\n-        (compare (match_operand:TQF 0 \"general_operand\" \"r,r\")\n-                 (match_operand:TQF 1 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    efcr r%0,r%1\n-    efc  r%0,%1 \")\n-\n-\n-;; truncation instructions\n-;;- 1750: any needed?\n-\n-(define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (truncate:QI (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"lr  r%0,r%d1\")\n-\n-\n-;; zero extension instructions: not defined, GCC can synthesize\n-\n-;; sign extension instructions\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (sign_extend:HI (match_operand:QI 1 \"general_operand\" \"r,m\")) )]\n-  \"\"\n-  \"*\n-    if (which_alternative == 0)\n-      {\n-        if (REGNO (operands [0]) != REGNO (operands [1]))\n-          output_asm_insn (\\\"lr r%0,r%1\\\", operands);\n-      }\n-    else\n-      output_asm_insn (\\\"l  r%0,%1\\\", operands);\n-    return \\\"dsra r%0,16  ;extendqihi2\\\";\n-  \")\n-\n-\n-;; Conversions between float and double.\n-\n-; 1750 HF-to-TQF extend: just append 16 bits (least signif.) with all bits zero\n-(define_insn \"extendhftqf2\"\n-  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n-        (float_extend:TQF (match_operand:HF 1 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"*\n-    output_asm_insn(\\\"xorr r%t0,r%t0   ;extendhftqf2\\\", operands);\n-    if (which_alternative == 0)\n-      {\n-        if (REGNO (operands[1]) != REGNO (operands[0]))\n-          return \\\"dlr r%0,r%1\\\";\n-        else\n-          return \\\";\\\";\n-      }\n-    else\n-      return \\\"dl  r%0,%1\\\";\n-   \")\n-\n-; 1750 TQF-to-HF truncate is a no-op: just leave away the least signif. 16 bits\n-(define_insn \"trunctqfhf2\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (float_truncate:HF\n-          (match_operand:TQF 1 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-     dlr r%0,r%1  ;trunctqfhf2\n-     dl  r%0,%1   ;trunctqfhf2 \")\n-\n-\n-;; Conversion between fixed point and floating point.\n-\n-(define_insn \"floatqihf2\"\n-  [(set           (match_operand:HF 0 \"register_operand\" \"=r\")\n-        (float:HF (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"flt r%0,r%1\")\n-\n-(define_insn \"floathitqf2\"\n-  [(set           (match_operand:TQF 0 \"register_operand\" \"=r\")\n-        (float:TQF (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"eflt r%0,r%1\")\n-\n-\n-;; Convert floats to ints\n-\n-(define_insn \"fix_trunchfqi2\"\n-  [(set                 (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (fix:QI (fix:HF (match_operand:HF 1 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"fix r%0,r%1\")\n-\n-(define_insn \"fix_trunctqfhi2\"\n-  [(set                 (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (fix:HI (fix:TQF (match_operand:TQF 1 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"efix r%0,r%1\")\n-\n-\n-;; Move instructions\n-\n-;; We can't deal with normal byte-size characters, only with WIDE characters!\n-;; This may appear as a serious restriction, but it also opens the doors\n-;; for ISO 10646  :-)\n-\n-;; 16-bit moves\n-\n-; memory indirect to reg\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (mem:QI (match_operand 1 \"memory_operand\"  \"m\")))]\n-  \"\"\n-  \"li   r%0,%1\")\n-\n-; reg/const to memory indirect\n-(define_insn \"\"\n-  [(set (mem:QI (match_operand 0 \"memory_operand\" \"=m,m\"))\n-        (match_operand:QI 1 \"nonmemory_operand\"  \"r,K\"))]\n-  \"\"\n-  \"@\n-     sti  r%1,%0\n-     stci %1,%0\")\n-\n-; general case\n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,r,m,m\")\n-        (match_operand:QI 1 \"general_operand\"  \"O,I,J,i,r,m,r,K\"))]\n-  \"\"\n-  \"@\n-     xorr r%0,r%0\n-     lisp r%0,%1\n-     lisn r%0,%J1\n-     lim  r%0,%1\n-     lr   r%0,r%1\n-     l    r%0,%1\n-     st   r%1,%0\n-     stc  %1,%0   \")\n-\n-;; 32-bit moves\n-\n-; memory indirect to reg\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (mem:HI (match_operand 1 \"memory_operand\"  \"m\")))]\n-  \"\"\n-  \"dli  r%0,%1\")\n-\n-; reg to memory indirect\n-(define_insn \"\"\n-  [(set (mem:HI (match_operand 0 \"memory_operand\" \"=m\"))\n-        (match_operand:HI 1 \"register_operand\"  \"r\"))]\n-  \"\"\n-  \"dsti r%1,%0\")\n-\n-; general case\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,r,r,m,m\")\n-        (match_operand:HI 1 \"general_operand\"  \"O,I,J,r,m,r,K\"))]\n-  \"\"\n-  \"@\n-    xorr r%0,r%0\\;xorr r%d0,r%d0\n-    xorr r%0,r%0\\;lisp r%d0,%1\n-    lisn r%0,1  \\;lisn r%d0,%J1\n-    dlr  r%0,r%1\n-    dl   r%0,%1\n-    dst  r%1,%0\n-    stc  0,%0   \\;stc  %1,%A0 \")\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n-        (match_operand:HI 1 \"general_operand\"  \"g\"))]\n-  \"\"\n-  \"\n-   {\n-     rtx op1 = operands[1];\n-     if (GET_CODE (operands[0]) == MEM)\n-       {\n-         if (GET_CODE (op1) == MEM\n-\t     || (GET_CODE (op1) == CONST_INT\n-\t\t && (INTVAL (op1) < 0 || INTVAL (op1) > 15)))\n-\t   operands[1] = force_reg (HImode, operands[1]);\n-       }\n-     else if (GET_CODE (op1) == CONST_INT\n-\t      && (INTVAL (op1) < -16 || INTVAL (op1) > 16))\n-       operands[1] = force_const_mem (HImode, operands[1]);\n-   }\")\n-\n-\n-;; Single-Float moves\n-\n-(define_insn \"\"\n-  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,m,m\")\n-        (match_operand:HF 1 \"general_operand\"  \"r,m,r,G\"))]\n-  \"\"\n-  \"@\n-    dlr  r%0,r%1\n-    dl   r%0,%1\n-    dst  r%1,%0\n-    stc  0,%0   \\;stc 0,%A0 \")\n-\n-(define_expand \"movhf\"\n-  [(set (match_operand:HF 0 \"general_operand\" \"\")\n-        (match_operand:HF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-   {\n-     enum rtx_code op1code = GET_CODE (operands[1]);\n-     if (GET_CODE (operands[0]) == MEM)\n-       {\n-         if (op1code == MEM || (op1code == CONST_DOUBLE\n-             && !rtx_equal_p (operands[1], CONST0_RTX (HFmode))))\n-\t   operands[1] = force_reg (HFmode, operands[1]);\n-       }\n-     else if (op1code == CONST_DOUBLE)\n-       operands[1] = force_const_mem (HFmode, operands[1]);\n-   }\")\n-\n-\n-;; Longfloat moves\n-\n-(define_insn \"\"\n-  [(set (match_operand:TQF 0 \"general_operand\" \"=r,r,m\")\n-        (match_operand:TQF 1 \"general_operand\"  \"r,m,r\"))]\n-  \"\"\n-  \"@\n-    eflr.m %0,%1\n-    efl  r%0,%1\n-    efst r%1,%0 \")\n-\n-(define_expand \"movtqf\"\n-  [(set (match_operand:TQF 0 \"general_operand\" \"\")\n-        (match_operand:TQF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-   {\n-     enum rtx_code op1code = GET_CODE (operands[1]);\n-     if (GET_CODE (operands[0]) == MEM)\n-       {\n-         if (op1code == MEM || op1code == CONST_DOUBLE)\n-\t   operands[1] = force_reg (TQFmode, operands[1]);\n-       }\n-     else if (op1code == CONST_DOUBLE)\n-       operands[1] = force_const_mem (TQFmode, operands[1]);\n-   }\")\n-\n-\n-;; add instructions \n-\n-;; single integer\n-\n-(define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,m,m\")\n-        (plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0,0,0\")\n-                 (match_operand:QI 2 \"general_operand\"  \"I,J,i,r,m,I,J\")))]\n-  \"\"\n-  \"*\n-    switch (which_alternative)\n-      {\n-        case 0:\n-          return \\\"aisp r%0,%2\\\";\n-        case 1:\n-          return \\\"sisp r%0,%J2\\\";\n-        case 2:\n-          if (INTVAL(operands[2]) < 0)\n-            return \\\"sim r%0,%J2\\\";\n-          else\n-            return \\\"aim r%0,%2\\\";\n-        case 3:\n-          return \\\"ar r%0,r%2\\\";\n-        case 4:\n-          return \\\"a r%0,%2\\\";\n-        case 5:\n-          return \\\"incm %2,%0\\\";\n-        case 6:\n-          return \\\"decm %J2,%0\\\";\n-\tdefault:\n-\t  abort();\n-      } \")\n-\n-;; double integer\n-(define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    dar r%0,r%2\n-    da  r%0,%2 \")\n-\n-(define_insn \"addhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (plus:HF (match_operand:HF 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    far r%0,r%2\n-    fa  r%0,%2 \")\n-\n-(define_insn \"addtqf3\"\n-  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n-        (plus:TQF (match_operand:TQF 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    efar r%0,r%2\n-    efa  r%0,%2 \")\n-\n-\n-;; subtract instructions\n-\n-;; single integer\n-(define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,m\")\n-        (minus:QI (match_operand:QI 1 \"general_operand\" \"0,0,0,0,0\")\n-                  (match_operand:QI 2 \"general_operand\"  \"I,i,r,m,I\")))]\n-  \"\"\n-  \"@\n-    sisp r%0,%2\n-    sim  r%0,%2\n-    sr   r%0,r%2\n-    s    r%0,%2\n-    decm %2,%0 \")\n-\n-;; double integer\n-(define_insn \"subhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (minus:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-                  (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    dsr r%0,r%2\n-    ds  r%0,%2 \")\n-\n-(define_insn \"subhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (minus:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n-                  (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    fsr r%0,r%2\n-    fs  r%0,%2 \")\n-\n-(define_insn \"subtqf3\"\n-  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n-        (minus:TQF (match_operand:TQF 1 \"register_operand\" \"0,0\")\n-                  (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    efsr r%0,r%2\n-    efs  r%0,%2 \")\n-\n-\n-;; multiply instructions\n-\n-(define_insn \"mulqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n-        (mult:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0\")\n-                 (match_operand:QI 2 \"general_operand\"  \"I,J,M,r,m\")))]\n-  \"\"\n-  \"@\n-     misp r%0,%2\n-     misn r%0,%J2\n-     msim r%0,%2\n-     msr  r%0,r%2\n-     ms   r%0,%2  \")\n-\n-\n-; 32-bit product\n-(define_insn \"mulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n-    (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%r,r,r\"))\n-             (sign_extend:HI (match_operand:QI 2 \"general_operand\" \"r,m,i\"))))]\n-  \"\"\n-  \"*\n-    if (REGNO (operands[1]) != REGNO (operands[0]))\n-      output_asm_insn (\\\"lr r%0,r%1\\\", operands);\n-\n-    switch (which_alternative)\n-      {\n-      case 0:\n-        return \\\"mr  r%0,r%2\\\";\n-      case 1:\n-        return \\\"m   r%0,%2\\\";\n-      case 2:\n-        return \\\"mim r%0,%2\\\";\n-      default:\n-        abort();\n-      }\n-  \")\n-\n-\n-(define_insn \"mulhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    dmr r%0,r%2\n-    dm  r%0,%2 \")\n-\n-; not available on 1750: \"umulhi3\",\"umulhisi3\",\"umulsi3\" (unsigned multiply's)\n-\n-(define_insn \"mulhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (mult:HF (match_operand:HF 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    fmr r%0,r%2\n-    fm  r%0,%2 \")\n-\n-(define_insn \"multqf3\"\n-  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n-        (mult:TQF (match_operand:TQF 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    efmr r%0,r%2\n-    efm  r%0,%2 \")\n-\n-\n-;; divide instructions\n-;; The 1750 16bit integer division instructions deliver a 16-bit\n-;; quotient and a 16-bit remainder, where the remainder is in the next higher\n-;; register number above the quotient. For now, we haven't found a way\n-;; to give the reload pass knowledge of this property. So we make do with\n-;; whatever registers the allocator wants, and willy-nilly output a pair of\n-;; register-copy ops when needed. (See mod_regno_adjust() in file aux-output.c)\n-;; A comment in the description of `divmodM4' suggests that one leave the divM3\n-;; undefined when there is a divmodM4 available.\n-\n-(define_insn \"divmodqi4\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n-        (div:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0\")\n-                (match_operand:QI 2 \"general_operand\"  \"I,J,M,r,m\")))\n-   (set (match_operand:QI 3 \"register_operand\" \"=r,r,r,r,r\")\n-        (mod:QI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"*\n-   {\n-     const char *istr;\n-     switch(which_alternative)\n-       {\n-       case 0:\n-         istr = \\\"disp\\\";\n-         break;\n-       case 1:\n-\t {\n-\t   rtx new_opnds[4];\n-\t   new_opnds[0] = operands[0];\n-\t   new_opnds[1] = operands[1];\n-\t   new_opnds[2] = GEN_INT (-INTVAL(operands[2]));\n-\t   new_opnds[3] = operands[3];\n-           istr = \\\"disn\\\";\n-\t   return mod_regno_adjust (istr, new_opnds);\n-\t }\n-         break;\n-       case 2:\n-         istr = \\\"dvim\\\";\n-         break;\n-       case 3:\n-         istr = \\\"dvr \\\";\n-         break;\n-       case 4:\n-         istr = \\\"dv  \\\";\n-         break;\n-       default:\n-         abort();\n-      }\n-      return mod_regno_adjust (istr, operands);\n-     }\")\n-\n-;; Division for other types is straightforward.\n-\n-(define_insn \"divhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (div:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-                (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    ddr r%0,r%2\n-    dd  r%0,%2 \")\n-\n-(define_insn \"divhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (div:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n-                (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    fdr r%0,r%2\n-    fd  r%0,%2 \")\n-\n-(define_insn \"divtqf3\"\n-  [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n-        (div:TQF (match_operand:TQF 1 \"register_operand\" \"0,0\")\n-                (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-    efdr r%0,r%2\n-    efd  r%0,%2 \")\n-\n-\n-;; Other arithmetic instructions:\n-\n-;; Absolute value\n-\n-(define_insn \"absqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (abs:QI (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"abs r%0,r%1\")\n-\n-(define_insn \"abshi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (abs:HI (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"dabs r%0,r%1\")\n-\n-(define_insn \"abshf2\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n-        (abs:HF (match_operand:HF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"fabs r%0,r%1\")\n-\n-\n-;; Negation\n-\n-(define_insn \"negqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (neg:QI (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"neg r%0,r%1\")\n-\n-(define_insn \"neghi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (neg:HI (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"dneg r%0,r%1\")\n-\n-(define_insn \"neghf2\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n-        (neg:HF (match_operand:HF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"fneg r%0,r%1\")\n-\n-; The 1750A does not have an extended float negate instruction, so simulate.\n-(define_expand \"negtqf2\"\n-  [(set (match_operand:TQF 0 \"register_operand\" \"=&r\")\n-        (neg:TQF (match_operand:TQF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"\n-   emit_insn (gen_rtx_SET (VOIDmode, operands[0], CONST0_RTX (TQFmode)));\n-   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t   gen_rtx_MINUS (TQFmode, operands[0], operands[1])));\n-   DONE;\n-  \")\n-\n-\n-;; bit-logical instructions\n-\n-;; Set Bit\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,m\")\n-        (ior:QI  (match_operand:QI 1 \"general_operand\" \"0,0\")\n-                 (match_operand:QI 2 \"const_int_operand\" \"i,i\")))]\n-  \"one_bit_set_p (INTVAL (operands [2]))\"\n-  \"@\n-    sbr    %b2,r%0\n-    sb     %b2,%0\")\n-\n-;; Reset Bit\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,m\")\n-        (and:QI  (match_operand:QI 1 \"general_operand\" \"0,0\")\n-                 (match_operand:QI 2 \"const_int_operand\" \"i,i\")))]\n-  \"one_bit_set_p ((~INTVAL (operands [2])) & 0xffff)\"\n-  \"@\n-    rbr    %B2,r%0\n-    rb     %B2,%0\")\n-\n-;; Set Variable Bit\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (ior:QI  (match_operand:QI 1 \"register_operand\" \"0\")\n-                 (lshiftrt:QI (const_int 32768)\n-                      (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"svbr   r%2,%r0\")\n-\n-;; Reset Variable Bit\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n-        (and:QI  (match_operand:QI 1 \"general_operand\" \"0\")\n-            (not:QI (lshiftrt:QI (const_int 32768)\n-                        (match_operand:QI 2 \"register_operand\" \"r\")))))]\n-  \"\"\n-  \"rvbr   r%2,%r0\")\n-\n-\n-;; AND\n-\n-(define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r\")\n-        (and:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0\")\n-                (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n-  \"\"\n-  \"@\n-    andm r%0,%2\n-    andr r%0,r%2\n-    and  r%0,%2 \")\n-\n-; This sets incorrect condition codes. See notice_update_cc()\n-(define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n-                (match_operand:HI 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"danr.m %0,%2\")\n-\n-;; OR\n-\n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r\")\n-        (ior:QI  (match_operand:QI 1 \"general_operand\" \"%0,0,0\")\n-                 (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n-  \"\"\n-  \"@\n-    orim r%0,%2\n-    orr  r%0,r%2\n-    or   r%0,%2 \")\n-\n-; This sets incorrect condition codes. See notice_update_cc()\n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (ior:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n-                (match_operand:HI 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"dorr.m %0,%2\")\n-\n-;; XOR\n-\n-(define_insn \"xorqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n-        (xor:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0\")\n-                (match_operand:QI 2 \"general_operand\"  \"M,r,m\")))]\n-  \"\"\n-  \"@\n-    xorm r%0,%2\n-    xorr r%0,r%2\n-    xor  r%0,%2 \")\n-\n-; This sets incorrect condition codes. See notice_update_cc()\n-(define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (xor:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n-                (match_operand:HI 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"dxrr.m %0,%2\")\n-\n-;; NAND\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n-\t(ior:QI (not:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0\"))\n-\t\t(not:QI (match_operand:QI 2 \"general_operand\" \"M,r,m\"))))]\n-  \"\"\n-  \"@\n-    nim r%0,%2\n-    nr  r%0,r%2\n-    n   r%0,%2 \")\n-\n-; This sets incorrect condition codes. See notice_update_cc()\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ior:HI (not:HI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t(not:HI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"dnr.m %0,%2\")\n-\n-;; NOT\n-\n-(define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (not:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"nr r%0,r%0\")\n-\n-; This sets incorrect condition codes. See notice_update_cc()\n-(define_insn \"one_cmplhi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"dnr.m %0,%0\")\n-\n-\n-;; Shift instructions\n-\n-; (What to the 1750 is logical-shift-left, GCC likes to call \"arithmetic\")\n-(define_insn \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-        (ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n-                   (match_operand:QI 2 \"nonmemory_operand\" \"I,r\")))]\n-  \"\"\n-  \"@\n-    sll r%0,%2\n-    slr r%0,r%2 \")\n-\n-(define_insn \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-                   (match_operand:QI 2 \"nonmemory_operand\" \"L,r\")))]\n-  \"\"                        ; the 'L' constraint is a slight imprecise...\n-  \"*\n-    if (which_alternative == 1)\n-      return \\\"dslr r%0,r%2\\\";\n-    else if (INTVAL(operands[2]) <= 16)\n-      return \\\"dsll r%0,%2\\\";\n-    else\n-      {\n-        output_asm_insn (\\\"dsll r%0,16  ; ashlhi3 shiftcnt > 16\\\", operands);\n-        return \\\"sll r%0,%w2\\\";\n-      }\n-  \")\n-\n-\n-;; Right shift by a variable shiftcount works by negating the shift count,\n-;; then emitting a right shift with the shift count negated.  This means\n-;; that all actual shift counts in the RTL will be positive.  This \n-;; prevents converting shifts to ZERO_EXTRACTs with negative positions,\n-;; which isn't valid.\n-(define_expand \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"g\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"immediate_operand\" \"I\")))]\n-  \"\"\n-  \"srl r%0,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"slr r%0,r%2 \")\n-\n-;; Same thing for HImode.\n-\n-(define_expand \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"g\")))]\n-  \"\"\n-  \"\n-  {\n-    if (GET_CODE (operands[2]) != CONST_INT)\n-      operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n-  }\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"immediate_operand\" \"L\")))]\n-  \"\"\n-  \"*\n-    if (INTVAL (operands[2]) <= 16)\n-      return \\\"dsrl r%0,%2\\\";\n-    output_asm_insn (\\\"dsrl r%0,16  ; lshrhi3 shiftcount > 16\\\", operands);\n-    return \\\"srl  r%d0,%w2\\\";\n-  \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"dslr r%0,r%2 \")\n-\n-;; Same applies for arithmetic shift right.\n-(define_expand \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"g\")))]\n-  \"\"\n-  \"\n-  {\n-    if (GET_CODE (operands[2]) != CONST_INT)\n-      operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n-  }\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"immediate_operand\" \"I\")))]\n-  \"\"\n-  \"sra r%0,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"sar r%0,r%2 \")\n-\n-;; HImode arithmetic shift right.\n-(define_expand \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"g\")))]\n-  \"\"\n-  \"\n-  {\n-    if (GET_CODE (operands[2]) != CONST_INT)\n-      operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n-  }\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"immediate_operand\" \"L\")))]\n-  \"\"\n-  \"*\n-    if (INTVAL (operands[2]) <= 16)\n-      return \\\"dsra r%0,%2\\\";\n-    output_asm_insn (\\\"dsra r%0,16  ; ashrhi3 shiftcount > 16\\\", operands);\n-    return \\\"sra  r%d0,%w2\\\";\n-  \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"dsar r%0,r%2 \")\n-\n-\n-;; rotate instructions\n-\n-(define_insn \"rotlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-        (rotate:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n-                   (match_operand:QI 2 \"nonmemory_operand\" \"I,r\")))]\n-  \"\"\n-  \"@\n-    slc r%0,%2\n-    scr r%0,r%2 \")\n-\n-(define_insn \"rotlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (rotate:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-                   (match_operand:QI 2 \"nonmemory_operand\" \"I,r\")))]\n-  \"\"\n-  \"@\n-    dslc r%0,%2\n-    dscr r%0,r%2 \")\n-\n-(define_insn \"rotrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (rotatert:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-                     (match_operand:QI 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"neg r%2,r%2\\;scr r%0,r%2 \")\n-\n-(define_insn \"rotrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (rotatert:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-                     (match_operand:QI 2 \"nonmemory_operand\" \"r\")))]\n-  \"\"\n-  \"neg  r%2,r%2\\;dscr r%0,r%2 \")\n-\n-\n-\n-;; Special cases of bit-field insns which we should\n-;; recognize in preference to the general case.\n-;; These handle aligned 8-bit and 16-bit fields,\n-;; which can usually be done with move instructions.\n-;    1750: t.b.d.\n-;********************\n-\n-;; Bit field instructions, general cases.\n-;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n-;; so that its address is reloaded.\n-\n-;; (define_insn \"extv\" ...\n-\n-;; (define_insn \"extzv\" ...\n-\n-;; (define_insn \"insv\" ...\n-\n-;; Now recognize bit field insns that operate on registers\n-;; (or at least were intended to do so).\n-;[unnamed only]\n-\n-;; Special patterns for optimizing bit-field instructions.\n-;**************************************\n-\n-; cc status test ops n.a. on 1750 ......... e.g. \"sleu\" on 68k:\n-;  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-;        (leu (cc0) (const_int 0)))]\n-;  \"\"\n-;  \"* cc_status = cc_prev_status;\n-;     return \\\"sls %0\\\"; \")\n-\n-\n-;; Basic conditional jump instructions.\n-\n-(define_insn \"beq\"\n-  [(set (pc)\n-        (if_then_else (eq (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"ez\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-        (if_then_else (ne (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"nz\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-        (if_then_else (gt (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"gt\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"blt\"\n-  [(set (pc)\n-        (if_then_else (lt (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"lt\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"bge\"\n-  [(set (pc)\n-        (if_then_else (ge (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"ge\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"ble\"\n-  [(set (pc)\n-        (if_then_else (le (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"le\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-\n-; no unsigned branches available on 1750. But GCC still needs them, so faking:\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-        (if_then_else (gtu (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"jc gt,%l0 ; Warning: this should be an *unsigned* test!\")\n-\n-(define_insn \"bltu\"\n-  [(set (pc)\n-        (if_then_else (ltu (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"jc lt,%l0 ; Warning: this should be an *unsigned* test!\")\n-\n-(define_insn \"bgeu\"\n-  [(set (pc)\n-        (if_then_else (geu (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"jc ge,%l0 ; Warning: this should be an *unsigned* test!\")\n-\n-(define_insn \"bleu\"\n-  [(set (pc)\n-        (if_then_else (leu (cc0)\n-                          (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"jc le,%l0 ; Warning: this should be an *unsigned* test!\")\n-\n-\n-;; Negated conditional jump instructions.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (eq (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"nz\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ne (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"ez\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (gt (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"le\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (lt (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"ge\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ge (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"lt\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (le (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return branch_or_jump (\\\"gt\\\", CODE_LABEL_NUMBER (operands[0]));\n-  \")\n-\n-\n-;; Negated unsigned conditional jump instructions (faked for 1750).\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (gtu (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"jc le,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ltu (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"jc ge,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (geu (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"jc lt,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (leu (cc0)\n-                          (const_int 0))\n-                      (pc)\n-                      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"jc gt,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n-\n-;; Tablejump \n-;; 1750 note: CASE_VECTOR_PC_RELATIVE is not defined\n-(define_insn \"tablejump\"\n-  [(set (pc)\n-        (match_operand:QI 0 \"register_operand\" \"b\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jc 15,0,r%0   ; tablejump label_ref=%1\")\n-\n-\n-;; Unconditional jump\n-(define_insn \"jump\"\n-  [(set (pc)\n-        (label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"jc 15,%0\")\n-\n-;; Call subroutine, returning value in operand 0\n-;; (which must be a hard register).\n-(define_insn \"call_value\"\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n-        (call (match_operand:QI 1 \"memory_operand\" \"m\")\n-              (match_operand:QI 2 \"general_operand\" \"g\")))]\n-  ;; Operand 2 not really used for 1750.\n-  \"\"\n-  \"sjs r15,%1   ; return value in R0\")\n-\n-;; Call subroutine with no return value.\n-\n-;;  Operand 1 not really used in MIL-STD-1750.\n-(define_insn \"\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"mp\")\n-         (match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"sjs r15,%0   ; no return value\")\n-\n-;;;;;;;;;;;; 1750: NOT READY YET.\n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"\" \"\")\n-         (match_operand:QI 1 \"\" \"\"))]\n-  \"\"\n-  \"ANYCALL %0\")\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:QI 0 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"jci 15,%0\")\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\")\n-\n-\n-;; Subtract One and Jump (if non-zero)\n-(define_peephole \n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n-                 (match_operand:QI 2 \"immediate_operand\" \"J\")))\n-   (set (cc0) (match_dup 0))\n-   (set (pc)\n-        (if_then_else (ne (cc0) (const_int 0))\n-         (label_ref (match_operand 3 \"\" \"\"))\n-         (pc)))\n-   ]\n-  \"INTVAL(operands[2]) == -1\"\n-  \"soj r%0,%3\")\n-\n-;; Combine a Load Register with subsequent increment/decrement into a LIM\n-(define_peephole \n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (match_operand:QI 1 \"register_operand\" \"b\"))\n-   (set (match_dup 0)\n-        (plus:QI (match_dup 0)\n-                 (match_operand:QI 2 \"immediate_operand\" \"i\")))]\n-  \"REGNO(operands[1]) > 0\"\n-  \"lim r%0,%2,r%1  ; LR,inc/dec peephole\")\n-\n-;; Eliminate the redundant load in a store/load sequence\n-(define_peephole \n-  [(set (mem:QI (plus:QI (match_operand:QI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:QI 1 \"immediate_operand\" \"i\")))\n-\t(match_operand:QI 2 \"register_operand\" \"r\"))\n-   (set (match_operand:QI 3 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:QI (match_dup 0)\n-\t\t\t (match_dup 1))))\n-   ]\n-  \"REGNO(operands[2]) == REGNO(operands[3])\"\n-  \"st r%2,%1,r%0  ; eliminated previous redundant load\")\n-\n-;;;End."}, {"sha": "cb41e95b649beb603f61b5b07d4174a5c53a3929", "filename": "gcc/config/1750a/ms1750.inc", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2Fms1750.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2F1750a%2Fms1750.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2Fms1750.inc?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,158 +0,0 @@\n-;; GCC assembler includefile for AS1750\n-;;\n-;; Macros defined:\n-;;   EFLR.M  #d,#s\tLoad the three regs starting at R#s to R#d following.\n-;;   RET.M   #fs\tReturn from function (uses the framesize #fs)\n-\n-\n-UC\tSET\t15\n-\n-; Return from function ; parameter: framesize\n-     MACRO RET.M\n-\tIF `1` > 0\n-\t    IF `1` <= 16\n-\t\tAISP R14,`1`\n-\t    ELSE\n-\t\tAIM  R14,`1`\n-\t    ENDIF\n-\tENDIF\n-\tLR   R15,R14\n-\tURS  R15\n-     ENDMACRO\n-\n-; Useful instructions missing from the 1750A standard:\n-\n-; Extended Float Load from Registers\n-     MACRO EFLR.M\t; args : #1=dest-regno, #2=source-regno\n-ONE \tSET  `1` + 2\n-TWO \tSET  `2` + 2\n-\tIF `1` >= `2` || `1`+2 < `2`\n-\t    LR    R`ONE`,R`TWO`\n-\t    DLR   R`1`,R`2`\n-\tELSE\n-\t    DLR   R`1`,R`2`\n-\t    LR    R`ONE`,R`TWO`\n-\t    DLR   R`1`,R`1`\t; Just to update condition codes\n-\tENDIF\n-     ENDMACRO\n-\n-; The following leave the condition codes haywire. But that is\n-; accounted for (see notice_update_cc in config/1750a.c.)\n-\n-; Double ANd Register with Register\n-     MACRO DANR.M\n-ONE \tSET  `1` + 1\n-TWO \tSET  `2` + 1\n-\tANDR  R`1`,R`2`\n-\tANDR  R`ONE`,R`TWO`\n-     ENDMACRO\n-\n-; Double OR Register with Register\n-     MACRO DORR.M\n-ONE \tSET  `1` + 1\n-TWO \tSET  `2` + 1\n-\tORR   R`1`,R`2`\n-\tORR   R`ONE`,R`TWO`\n-     ENDMACRO\n-\n-; Double eXoR Register with Register\n-     MACRO DXRR.M\n-ONE \tSET  `1` + 1\n-TWO \tSET  `2` + 1\n-\tXORR  R`1`,R`2`\n-\tXORR  R`ONE`,R`TWO`\n-     ENDMACRO\n-\n-; Double Nand Register with register\n-     MACRO DNR.M\n-ONE \tSET  `1` + 1\n-TWO \tSET  `2` + 1\n-\tNR    R`1`,R`2`\n-\tNR    R`ONE`,R`TWO`\n-     ENDMACRO\n-\n-; Unsigned Compare Immediate\n-\n-     MACRO UCIM.M\n-LAST\tSET   `1` + 3\n-\tPSHM  R`1`,R`LAST`\n-LO\tSET   `1` + 1\n-\tLR    R`LO`,R`1`\n-\tXORR  R`1`,R`1`\n-HI\tSET   `1` + 2\n-\tXORR  R`HI`,R`HI`\n-\tLIM   R`LAST`,`2`\n-\tDCR   R`1`,R`HI`\n-\tPOPM  R`1`,R`LAST`\n-     ENDMACRO\n-\n-\n-; Unsigned Compare Register with register\n-\n-     MACRO UCR.M\n-\tPSHM  R10,R13    ; R12 and R13 are assumed not to be input parameters\n-\tLR    R13,R`2`\n-\tLR    R11,R`1`\n-\tXORR  R12,R12\n-\tXORR  R10,R10\n-\tDCR   R10,R12\n-\tPOPM  R10,R13\n-     ENDMACRO\n-\n-\n-; Unsigned Compare register with memory\n-\n-     MACRO UC.M\n-\tPSHM  R10,R13\n-\tL     R13,`2`\n-\tLR    R11,R`1`\n-\tXORR  R12,R12\n-\tXORR  R10,R10\n-\tDCR   R10,R12\n-\tPOPM  R10,R13\n-     ENDMACRO\n-\n-\n-; Double Unsigned Compare Register with register\n-\n-     MACRO DUCR.M\n-\tPSHM\tR13,R14    ; R13 and R14 are assumed not to be input parameters\n-LOW1\tSET\t`1` + 1\n-LOW2\tSET\t`2` + 1\n-\tPSHM\tR`1`,R`LOW1`\n-\tPSHM\tR`2`,R`LOW2`\n-\tLR\tR13,R`LOW1`\n-\tLR\tR14,R`LOW2`\n-\tDSRL\tR`1`,1\n-\tDSRL\tR`2`,1\n-\tDCR\tR`1`,R`2`\n-\tBNE\t+6\n-\tANDM\tR13,1\n-\tANDM\tR14,1\n-\tCR\tR13,R14\n-\tPOPM\tR`2`,R`LOW2`\n-\tPOPM\tR`1`,R`LOW1`\n-\tPOPM\tR13,R14\n-     ENDMACRO\n-\n-\n-; Double Unsigned Compare register with memory\n-\n-     MACRO DUC.M\n-\tPSHM\tR13,R14    ; R13 and R14 are assumed not to be input parameters\n-LOW1\tSET\t`1` + 1\n-\tPSHM\tR`1`,R`LOW1`\n-\tDL\tR13,`2`\n-\tDSRL\tR`1`,1\n-\tDSRL\tR13,1\n-\tDCR\tR`1`,R13\n-\tBNE\t+10        ; done, go pop the saved regs\n-\tDL\tR13,`2`    ; interested in the *low* word (R14)\n-\tL\tR13,1,R15\n-\tANDM\tR13,1\n-\tANDM\tR14,1\n-\tCR\tR13,R14\n-\tPOPM\tR`1`,R`LOW1`\n-\tPOPM\tR13,R14\n-     ENDMACRO\n-"}, {"sha": "59d1dd28244184baa7e7b3c2b0b168a4719057b8", "filename": "gcc/config/a29k/a29k-protos.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,65 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for AMD Am29000 CPU.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-/* This function is used to get the address of an object.  */\n-extern struct rtx_def *a29k_get_reloaded_address PARAMS ((rtx));\n-extern int gpc_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int long_const_operand PARAMS ((rtx, enum machine_mode));\n-extern int cint_8_operand PARAMS ((rtx, enum machine_mode));\n-extern int cint_16_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_8_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_16_operand PARAMS ((rtx, enum machine_mode));\n-extern int const_24_operand PARAMS ((rtx, enum machine_mode));\n-extern int float_const_operand PARAMS ((rtx, enum machine_mode));\n-extern int gpc_reg_or_float_constant_operand PARAMS ((rtx, enum machine_mode));\n-extern int gpc_reg_or_integer_constant_operand PARAMS ((rtx, enum machine_mode));\n-extern int spec_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int accum_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int srcb_operand PARAMS ((rtx, enum machine_mode));\n-extern int cmplsrcb_operand PARAMS ((rtx, enum machine_mode));\n-extern int gpc_reg_or_immediate_operand PARAMS ((rtx, enum machine_mode));\n-extern int and_operand PARAMS ((rtx, enum machine_mode));\n-extern int add_operand PARAMS ((rtx, enum machine_mode));\n-extern int call_operand PARAMS ((rtx, enum machine_mode));\n-extern int in_operand PARAMS ((rtx, enum machine_mode));\n-extern int out_operand PARAMS ((rtx, enum machine_mode));\n-extern int reload_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern void a29k_set_memflags PARAMS ((rtx, rtx));\n-extern int fp_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int branch_operator PARAMS ((rtx, enum machine_mode));\n-extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n-extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n-extern int masks_bits_for_special PARAMS ((rtx, rtx));\n-extern int epilogue_operand PARAMS ((rtx, enum machine_mode));\n-extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n-\t\t\t\t\t\t      enum machine_mode, rtx));\n-extern int incoming_reg PARAMS ((int, int));\n-extern void a29k_clobbers_to PARAMS ((rtx, rtx));\n-extern int needs_regstack_p PARAMS ((void));\n-extern int uses_local_reg_p PARAMS ((rtx));\n-extern int null_epilogue PARAMS ((void));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void a29k_compute_reg_names PARAMS ((void));\n-#endif /* RTX_CODE */\n-\n-extern void literal_section PARAMS ((void));"}, {"sha": "2f61dfe61277c0361be65d272658492bdfaefe60", "filename": "gcc/config/a29k/a29k.c", "status": "removed", "additions": 0, "deletions": 1631, "changes": 1631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1631 +0,0 @@\n-/* Subroutines used for code generation on AMD Am29000.\n-   Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000 Free Software\n-   Foundation, Inc. \n-   Contributed by Richard Kenner (kenner@nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"obstack.h\"\n-#include \"reload.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-static int shift_constant_operand PARAMS ((rtx, enum machine_mode, int));\n-static void a29k_set_memflags_1 PARAMS ((rtx, int, int, int, int));\n-static void compute_regstack_size PARAMS ((void));\n-static void check_epilogue_internal_label PARAMS ((FILE *));\n-static void output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void a29k_asm_named_section PARAMS ((const char *, unsigned int));\n-static int a29k_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static void a29k_encode_section_info PARAMS ((tree, int));\n-\n-#define min(A,B)\t((A) < (B) ? (A) : (B))\n-\n-/* This gives the size in words of the register stack for the current\n-   procedure.  */\n-\n-static int a29k_regstack_size;\n-\n-/* True if the current procedure has a call instruction.  */\n-\n-static int a29k_makes_calls;\n-\n-/* This points to the last insn of the insn prologue.  It is set when\n-   an insn without a filled delay slot is found near the start of the\n-   function.  */\n-\n-static char *a29k_last_prologue_insn;\n-\n-/* This points to the first insn that will be in the epilogue.  It is null if\n-   no epilogue is required.  */\n-\n-static char *a29k_first_epilogue_insn;\n-\n-/* This is nonzero if a a29k_first_epilogue_insn was put in a delay slot.  It\n-   indicates that an intermediate label needs to be written.  */\n-\n-static int a29k_first_epilogue_insn_used;\n-\n-/* Location to hold the name of the current function.  We need this prolog to\n-   contain the tag words prior to the declaration.  So the name must be stored\n-   away.  */\n-\n-const char *a29k_function_name;\n-\n-/* Mapping of registers to debug register numbers.  The only change is\n-   for the frame pointer and the register numbers used for the incoming\n-   arguments.  */\n-\n-int a29k_debug_reg_map[FIRST_PSEUDO_REGISTER];\n-\n-/* Save information from a \"cmpxx\" operation until the branch or scc is\n-   emitted.  */\n-\n-rtx a29k_compare_op0, a29k_compare_op1;\n-int a29k_compare_fp_p;\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE output_function_epilogue\n-#undef TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST a29k_adjust_cost\n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO a29k_encode_section_info\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Returns 1 if OP is a 8-bit constant.  */\n-\n-int\n-cint_8_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffffff00) == 0;\n-}\n-\n-/* Returns 1 if OP is a 16-bit constant.  */\n-\n-int\n-cint_16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff0000) == 0;\n-}\n-\n-/* Returns 1 if OP is a constant that cannot be moved in a single insn.  */\n-\n-int\n-long_const_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (! CONSTANT_P (op))\n-    return 0;\n-\n-  if (TARGET_29050 && GET_CODE (op) == CONST_INT\n-      && (INTVAL (op) & 0xffff) == 0)\n-    return 0;\n-\n-  return (GET_CODE (op) != CONST_INT\n-\t  || ((INTVAL (op) & 0xffff0000) != 0\n-\t      && (INTVAL (op) & 0xffff0000) != 0xffff0000\n-\t      && INTVAL (op) != 0x80000000));\n-}\n-\f\n-/* The following four functions detect constants of 0, 8, 16, and 24 used as\n-   a position in ZERO_EXTRACT operations.  They can either be the appropriate\n-   constant integer or a shift (which will be produced by combine).  */\n-\n-static int\n-shift_constant_operand (op, mode, val)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int val;\n-{\n-  return ((GET_CODE (op) == CONST_INT && INTVAL (op) == val)\n-\t  || (GET_CODE (op) == ASHIFT\n-\t      && GET_CODE (XEXP (op, 0)) == CONST_INT\n-\t      && INTVAL (XEXP (op, 0)) == val / 8\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n-\t      && INTVAL (XEXP (op, 1)) == 3));\n-}\n-\n-int\n-const_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return shift_constant_operand (op, mode, 0);\n-}\n-\n-int\n-const_8_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return shift_constant_operand (op, mode, 8);\n-}\n-\n-int\n-const_16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return shift_constant_operand (op, mode, 16);\n-}\n-\n-int\n-const_24_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return shift_constant_operand (op, mode, 24);\n-}\n-\n-/* Returns 1 if OP is a floating-point constant of the proper mode.  */\n-\n-int\n-float_const_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == mode;\n-}\n-\n-/* Returns 1 if OP is a floating-point constant of the proper mode or a\n-   general-purpose register.  */\n-\n-int\n-gpc_reg_or_float_constant_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return float_const_operand (op, mode) || gpc_reg_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP is an integer constant of the proper mode or a\n-   general-purpose register.  */\n-\n-int\n-gpc_reg_or_integer_constant_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return ((GET_MODE (op) == VOIDmode\n-\t   && (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE))\n-\t  || gpc_reg_operand (op, mode));\n-}\n-\f     \n-/* Returns 1 if OP is a special machine register.  */\n-\n-int\n-spec_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) != REG || GET_MODE (op) != mode)\n-    return 0;\n-\n-  switch (GET_MODE_CLASS (mode))\n-    {\n-    case MODE_PARTIAL_INT:\n-      return REGNO (op) >= R_BP && REGNO (op) <= R_CR;\n-    case MODE_INT:\n-      return REGNO (op) >= R_Q && REGNO (op) <= R_EXO;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Returns 1 if OP is an accumulator register.  */\n-\n-int\n-accum_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (GET_CODE (op) == REG\n-\t  && REGNO (op) >= R_ACU (0) && REGNO (op) <= R_ACU (3));\n-}\n-\n-/* Returns 1 if OP is a normal data register.  */\n-\n-int\n-gpc_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == REG)\n-    regno = REGNO (op);\n-  else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n-    {\n-      if (REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n-\tregno = subreg_regno (op);\n-      else\n-\tregno = REGNO (SUBREG_REG (op));\n-    }\n-  else\n-    return 0;\n-\n-  return (regno >= FIRST_PSEUDO_REGISTER || regno < R_BP\n-\t  || (regno >= R_KR (0) && regno <= R_KR (31)));\n-}\n-\n-/* Returns 1 if OP is either an 8-bit constant integer or a general register.\n-   If a register, it must be in the proper mode unless MODE is VOIDmode.  */\n-\n-int\n-srcb_operand (op, mode)\n-      register rtx op;\n-      enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT\n-      && (mode == QImode\n-\t  || (INTVAL (op) & 0xffffff00) == 0))\n-    return 1;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  return gpc_reg_operand (op, mode);\n-}\n-\n-int\n-cmplsrcb_operand (op, mode)\n-      register rtx op;\n-      enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT\n-      && (mode == QImode\n-\t  || (INTVAL (op) & 0xffffff00) == 0xffffff00))\n-    return 1;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  return gpc_reg_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is either an immediate or a general register.  This is used\n-   for the input operand of mtsr/mtrsim.  */\n-\n-int\n-gpc_reg_or_immediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return gpc_reg_operand (op, mode) || immediate_operand (op, mode);\n-}\n-\n-/* Return 1 if OP can be used as the second operand of and AND insn.  This\n-   includes srcb_operand and a constant whose complement fits in 8 bits.  */\n-\n-int\n-and_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (srcb_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && ((unsigned) ((~ INTVAL (op)) & GET_MODE_MASK (mode)) < 256)));\n-}\n-\n-/* Return 1 if OP can be used as the second operand of an ADD insn.\n-   This is the same as above, except we use negative, rather than\n-   complement.  */\n-\n-int\n-add_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (srcb_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && ((unsigned) ((- INTVAL (op)) & GET_MODE_MASK (mode)) < 256)));\n-}\n-\n-/* Return 1 if OP is a valid address in a CALL_INSN.  These are a SYMBOL_REF\n-   to the current function, all SYMBOL_REFs if TARGET_SMALL_MEMORY, or\n-   a sufficiently-small constant.  */\n-\n-int\n-call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-      return (TARGET_SMALL_MEMORY\n-\t      || (! TARGET_LARGE_MEMORY\n-\t\t  && ((GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_FLAG (op))\n-\t\t      || ! strcmp (XSTR (op, 0), current_function_name))));\n-\n-    case CONST_INT:\n-      return (unsigned HOST_WIDE_INT) INTVAL (op) < 0x40000;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\f\n-/* Return 1 if OP can be used as the input operand for a move insn.  */\n-\n-int\n-in_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (! general_operand (op, mode))\n-    return 0;\n-\n-  while (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  switch (GET_CODE (op))\n-    {\n-    case REG:\n-      return 1;\n-\n-    case MEM:\n-      return (GET_MODE_SIZE (mode) >= UNITS_PER_WORD || TARGET_DW_ENABLE);\n-\n-    case CONST_INT:\n-      if (GET_MODE_CLASS (mode) != MODE_INT\n-\t  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n-\treturn 0;\n-\n-      return 1;\n-\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return (GET_MODE (op) == mode\n-\t      || mode == SImode || mode == HImode || mode == QImode);\n-\n-    case CONST_DOUBLE:\n-      return ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t       && mode == GET_MODE (op))\n-\t      || (GET_MODE (op) == VOIDmode\n-\t\t  && GET_MODE_CLASS (mode) == MODE_INT));\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return 1 if OP can be used as the output operand for a move insn.  */\n-\n-int\n-out_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  rtx orig_op = op;\n-\n-  if (! general_operand (op, mode))\n-    return 0;\n-\n-  while (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) == REG)\n-    return (gpc_reg_operand (orig_op, mode)\n-\t    || spec_reg_operand (orig_op, mode)\n-\t    || (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t\t&& accum_reg_operand (orig_op, mode)));\n-\n-  else if (GET_CODE (op) == MEM)\n-    return (GET_MODE_SIZE (mode) >= UNITS_PER_WORD || TARGET_DW_ENABLE);\n-  else\n-    return 0;\n-}\n-\n-/* Return 1 if OP is an item in memory, given that we are in reload.  */\n-\n-int\n-reload_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  int regno = true_regnum (op);\n-\n-  return (! CONSTANT_P (op)\n-\t  && (regno == -1\n-\t      || (GET_CODE (op) == REG\n-\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n-}\n-\n-/* Given an object for which reload_memory_operand is true, return the address\n-   of the operand, taking into account anything that reload may do.  */\n-\n-rtx\n-a29k_get_reloaded_address (op)\n-     rtx op;\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (SUBREG_BYTE (op) != 0)\n-\tabort ();\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) == REG)\n-    op = reg_equiv_mem[REGNO (op)];\n-\n-  return find_replacement (&XEXP (op, 0));\n-}\n-\f\n-/* Subfunction of the following function.  Update the flags of any MEM\n-   found in part of X.  */\n-\n-static void\n-a29k_set_memflags_1 (x, in_struct_p, scalar_p, volatile_p, unchanging_p)\n-     rtx x;\n-     int in_struct_p, scalar_p, volatile_p, unchanging_p;\n-{\n-  int i;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case SEQUENCE:\n-    case PARALLEL:\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\ta29k_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, scalar_p,\n-\t\t\t     volatile_p, unchanging_p);\n-      break;\n-\n-    case INSN:\n-      a29k_set_memflags_1 (PATTERN (x), in_struct_p, scalar_p, volatile_p,\n-\t\t\t   unchanging_p);\n-      break;\n-\n-    case SET:\n-      a29k_set_memflags_1 (SET_DEST (x), in_struct_p, scalar_p, volatile_p,\n-\t\t\t   unchanging_p);\n-      a29k_set_memflags_1 (SET_SRC (x), in_struct_p, scalar_p, volatile_p,\n-\t\t\t   unchanging_p);\n-      break;\n-\n-    case MEM:\n-      MEM_IN_STRUCT_P (x) = in_struct_p;\n-      MEM_SCALAR_P (x) = scalar_p;\n-      MEM_VOLATILE_P (x) = volatile_p;\n-      RTX_UNCHANGING_P (x) = unchanging_p;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-/* Given INSN, which is either an INSN or a SEQUENCE generated to\n-   perform a memory operation, look for any MEMs in either a SET_DEST or\n-   a SET_SRC and copy the in-struct, unchanging, and volatile flags from\n-   REF into each of the MEMs found.  If REF is not a MEM, don't do\n-   anything.  */\n-\n-void\n-a29k_set_memflags (insn, ref)\n-     rtx insn;\n-     rtx ref;\n-{\n-  /* Note that it is always safe to get these flags, though they won't\n-     be what we think if REF is not a MEM.  */\n-  int in_struct_p = MEM_IN_STRUCT_P (ref);\n-  int scalar_p = MEM_SCALAR_P (ref);\n-  int volatile_p = MEM_VOLATILE_P (ref);\n-  int unchanging_p = RTX_UNCHANGING_P (ref);\n-\n-  if (GET_CODE (ref) != MEM\n-      || (! in_struct_p && ! volatile_p && ! unchanging_p))\n-    return;\n-\n-  a29k_set_memflags_1 (insn, in_struct_p, scalar_p, volatile_p, unchanging_p);\n-}\n-\f\n-/* Return 1 if OP is a comparison operator that we have in floating-point.  */\n-\n-int\n-fp_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && (GET_CODE (op) == EQ || GET_CODE (op) == GT ||\n-\t      GET_CODE (op) == GE));\n-}\n-\n-/* Return 1 if OP is a valid branch comparison.  */\n-\n-int\n-branch_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && (GET_CODE (op) == GE || GET_CODE (op) == LT));\n-}\n-\f\n-/* Return 1 if OP is a load multiple operation.  It is known to be a\n-   PARALLEL and the first three sections will be tested.  */\n-\n-int\n-load_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  int count = XVECLEN (op, 0) - 2;\n-  int dest_regno;\n-  rtx src_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i + 2);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Similar, but tests for store multiple.  */\n-\n-int\n-store_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  int num_special = TARGET_NO_STOREM_BUG ? 2 : 1;\n-  int count = XVECLEN (op, 0) - num_special;\n-  int src_regno;\n-  rtx dest_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i + num_special);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || REGNO (SET_SRC (elt)) != src_regno + i\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\f\n-/* Given a special register REG and MASK, a value being masked against a\n-   quantity to which the special register is set, return 1 if the masking\n-   operation is built-in to the setting of that special register.  */\n-\n-int\n-masks_bits_for_special (reg, mask)\n-     rtx reg;\n-     rtx mask;\n-{\n-   int needed_mask_value;\n-\n-  if (GET_CODE (reg) != REG || GET_CODE (mask) != CONST_INT)\n-    abort ();\n-\n-  switch (REGNO (reg))\n-    {\n-    case R_BP:\n-    case R_INT:\n-      needed_mask_value = 3;\n-      break;\n-\n-    case R_FC:\n-      needed_mask_value = 31;\n-      break;\n-\n-    case R_CR:\n-    case R_LRU:\n-      needed_mask_value = 255;\n-      break;\n-\n-    case R_FPE:\n-      needed_mask_value = 511;\n-      break;\n-\n-    case R_MMU:\n-      needed_mask_value = 0x3ff;\n-      break;\n-\n-    case R_OPS:\n-    case R_CPS:\n-    case R_RBP:\n-    case R_FPS:\n-      needed_mask_value = 0xffff;\n-      break;\n-\n-    case R_VAB:\n-      needed_mask_value = 0xffff0000;\n-      break;\n-\n-    case R_Q:\n-    case R_CFG:\n-    case R_CHA:\n-    case R_CHD:\n-    case R_CHC:\n-    case R_TMC:\n-    case R_TMR:\n-    case R_PC0:\n-    case R_PC1:\n-    case R_PC2:\n-      return 0;\n-\n-    default:\n-      abort ();\n-    }\n-\n-   return (INTVAL (mask) & ~ needed_mask_value) == 0;\n-}\n-\f\n-/* Return nonzero if this label is that of the return point, but there is\n-   a non-null epilogue.  */\n-\n-int\n-epilogue_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return next_active_insn (op) == 0 && a29k_first_epilogue_insn != 0;\n-}\n-\f\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n-{\n-  int regno = -1;\n-  enum rtx_code code = GET_CODE (in);\n-\n-  if (! CONSTANT_P (in))\n-    {\n-      regno = true_regnum (in);\n-\n-      /* A pseudo is the same as memory.  */\n-      if (regno == -1 || regno >= FIRST_PSEUDO_REGISTER)\n-\tcode = MEM;\n-    }\n-\n-  /* If we are transferring between memory and a multi-word mode, we need\n-     CR.  */\n-\n-  if (code == MEM && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-    return CR_REGS;\n-\n-  /* If between memory and a mode smaller than a word without DW being\n-     enabled, we need BP.  */\n-\n-  if (code == MEM && ! TARGET_DW_ENABLE\n-      && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n-    return BP_REGS;\n-\n-  /* Otherwise, we can place anything into GENERAL_REGS and can put\n-     GENERAL_REGS into anything.  */\n-  if (class == GENERAL_REGS\n-      || (regno != -1\n-\t  && (regno < R_BP\n-\t      || (regno >= R_KR (0) && regno <= R_KR (31)))))\n-    return NO_REGS;\n-\n-  /* We can place 16-bit constants into a special register.  */\n-  if (code == CONST_INT\n-      && (GET_MODE_BITSIZE (mode) <= 16 || (unsigned) INTVAL (in) <= 65535)\n-      && (class == BP_REGS || class == Q_REGS || class == SPECIAL_REGS))\n-    return NO_REGS;\n-\n-  /* Otherwise, we need GENERAL_REGS.  */\n-  return GENERAL_REGS;\n-}\n-\f\n-/* START is the zero-based incoming argument register index used (0 is 160,\n-   i.e., the first incoming argument register) and COUNT is the number used.\n-\n-   Mark the corresponding incoming registers as neither fixed nor call used.\n-   For each register used for incoming arguments, we have one less local\n-   register that can be used.  So also mark some high-numbered registers as\n-   fixed.\n-\n-   Return the first register number to use for the argument.  */\n-\n-int\n-incoming_reg (start, count)\n-     int start;\n-     int count;\n-{\n-  int i;\n-\n-  /* We only use 16 argument registers, so truncate at the end of the\n-     area.  */\n-  if (start + count > 16)\n-    count = 16 - start;\n-\n-  if (! TARGET_NO_REUSE_ARGS)\n-    /* Mark all the used registers as not fixed and saved over calls.  */\n-    for (i = R_AR (start); i < R_AR (start + count); i++)\n-      {\n-\tfixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 0;\n-\tCLEAR_HARD_REG_BIT (fixed_reg_set, i);\n-\tCLEAR_HARD_REG_BIT (call_used_reg_set, i);\n-\tCLEAR_HARD_REG_BIT (call_fixed_reg_set, i);\n-      }\n-\n-  /* Shorten the maximum size of the frame.\n-     Remember that R_AR(-1,-2) are place holders for the caller's lr0,lr1.\n-     Make sure to keep the frame rounded to an even boundary.  Rounding up\n-     to an 8 byte boundary will use a slot.  Otherwise a frame with 121 local\n-     regs and 5 arguments will overrun the stack (121+1 + 5 + 2 > 128).  */\n-  /* ??? An alternative would be to never allocate one reg.  */\n-  for (i = (R_AR (0) - 2 - start - count) & ~1; i < R_AR (0) - 2 - start; i++)\n-    {\n-      fixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 1;\n-      SET_HARD_REG_BIT (fixed_reg_set, i);\n-      SET_HARD_REG_BIT (call_used_reg_set, i);\n-      SET_HARD_REG_BIT (call_fixed_reg_set, i);\n-    }\n-\n-  return R_AR (start);\n-}\n-\f\n-/* Add CLOBBERs to CALL_INSN_FUNCTION_USAGE chain of INSN indicating\n-   that LR2 up to, but not including, OP are clobbered.  If OP is\n-   zero, indicate all parameter registers are clobbered.  */\n-\n-void\n-a29k_clobbers_to (insn, op)\n-     rtx insn;\n-     rtx op;\n-{\n-  int i;\n-  int high_regno;\n-\n-  if (op == 0)\n-    high_regno = R_LR (18);\n-  else if (GET_CODE (op) != REG || REGNO (op) < R_LR (0)\n-\t   || REGNO (op) > R_LR (18))\n-    abort ();\n-  else\n-    high_regno = REGNO (op);\n-\n-  for (i = R_LR (2); i < high_regno; i++)\n-    CALL_INSN_FUNCTION_USAGE (insn)\n-      = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t    gen_rtx (REG, SImode, i)),\n-\t\t\t   CALL_INSN_FUNCTION_USAGE (insn));\n-}\n-\f\n-/* These routines are used in finding insns to fill delay slots in the\n-   epilogue.  */\n-\n-/* Return 1 if the current function will adjust the register stack.  */\n-\n-int\n-needs_regstack_p ()\n-{\n-  int i;\n-  rtx insn;\n-\n-  if (frame_pointer_needed)\n-    return 1;\n-\n-  /* If any local register is used, we need to adjust the regstack.  */\n-  for (i = R_LR (127); i >= R_LR (0); i --)\n-    if (regs_ever_live[i])\n-      return 1;\n-\n-  /* We need a register stack if we make any calls.  */\n-  for (insn = get_insns (); insn; insn = next_insn (insn))\n-    if (GET_CODE (insn) == CALL_INSN\n-\t|| (GET_CODE (insn) == INSN\n-\t    && GET_CODE (PATTERN (insn)) == SEQUENCE\n-\t    && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN))\n-      return 1;\n-\n-  /* Otherwise, we don't.  */\n-  return 0;\n-}\n-\n-/* Return 1 if X uses a local register.  */\n-\n-int\n-uses_local_reg_p (x)\n-     rtx x;\n-{\n-  const char *fmt;\n-  int i, j;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case REG:\n-      return REGNO (x) >= R_LR (0) && REGNO (x) <= R_FP;\n-\n-    case CONST_INT:\n-    case CONST:\n-    case PC:\n-    case CC0:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      return 0;\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (uses_local_reg_p (XEXP (x, i)))\n-\t    return 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (uses_local_reg_p (XVECEXP (x, i, j)))\n-\t      return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Returns 1 if this function is known to have a null epilogue.  */\n-\n-int\n-null_epilogue ()\n-{\n-  return (reload_completed && ! needs_regstack_p ()\n-\t  && get_frame_size () == 0\n-\t  && current_function_pretend_args_size == 0);\n-}\n-\f\n-/* Write out the assembler form of an operand.  Recognize the following\n-   special options:\n-\n-\t%N means write the low-order 8 bits of the negative of the constant\n-\t%Q means write a QImode operand (truncate constants to 8 bits)\n-\t%M means write the low-order 16 bits of the constant\n-\t%m means write the low-order 16 bits shifted left 16 bits\n-\t%C means write the low-order 8 bits of the complement of the constant\n-\t%b means write `f' is this is a reversed condition, `t' otherwise\n-\t%B means write `t' is this is a reversed condition, `f' otherwise\n-\t%J means write the 29k opcode part for a comparison operation\n-\t%e means write the label with an extra `X' is this is the epilogue\n-\t               otherwise the normal label name\n-\t%E means write nothing if this insn has a delay slot,\n-\t\t       a nop unless this is the epilogue label, in which case\n-\t\t       write the first epilogue insn\n-\t%F means write just the normal operand if the insn has a delay slot;\n-\t\t       otherwise, this is a recursive call so output the\n-\t\t       symbol + 4 and write the first prologue insn in the\n-\t\t       delay slot.\n-\t%L means write the register number plus one (\"low order\" register)\n-\t\t       or the low-order part of a multi-word constant\n-\t%O means write the register number plus two\n-\t%P means write the register number plus three (\"low order\" of TImode)\n-\t%S means write the number of words in the mode of the operand,\n-\t\t       minus one (for CR)\n-        %V means write the number of elements in a PARALLEL minus 1\n-\t%# means write nothing if we have a delay slot, \"\\n\\tnop\" otherwise\n-\t%* means write the register name for TPC.  */\n-\n-void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     char code;\n-{\n-  char buf[100];\n-\n-  /* These macros test for integers and extract the low-order bits.  */\n-#define INT_P(X)  \\\n-((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)\t\\\n- && GET_MODE (X) == VOIDmode)\n-\n-#define INT_LOWPART(X) \\\n-  (GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))\n-\n-  switch (code)\n-    {\n-    case 'Q':\n-      if (GET_CODE (x) == REG)\n-\tbreak;\n-      else if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%Q value\");\n-      fprintf (file, \"%d\", INT_LOWPART (x) & 0xff);\n-      return;\n-\n-    case 'C':\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%C value\");\n-      fprintf (file, \"%d\", (~ INT_LOWPART (x)) & 0xff);\n-      return;\n-\n-    case 'N':\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%N value\");\n-      fprintf (file, \"%d\", (- INT_LOWPART (x)) & 0xff);\n-      return;\n-\n-    case 'M':\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%M value\");\n-      fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n-      return;\n-\n-    case 'm':\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%m value\");\n-      fprintf (file, \"%d\", (INT_LOWPART (x) & 0xffff) << 16);\n-      return;\n-\n-    case 'b':\n-      if (GET_CODE (x) == GE)\n-\tfprintf (file, \"f\");\n-      else\n-\tfprintf (file, \"t\");\n-      return;\n-\n-    case 'B':\n-      if (GET_CODE (x) == GE)\n-\tfprintf (file, \"t\");\n-      else\n-\tfprintf (file, \"f\");\n-      return;\n-\n-    case 'J':\n-      /* It so happens that the RTX names for the conditions are the same as\n-\t the 29k's insns except for \"ne\", which requires \"neq\".  */\n-      fprintf (file, GET_RTX_NAME (GET_CODE (x)));\n-      if (GET_CODE (x) == NE)\n-\tfprintf (file, \"q\");\n-      return;\n-\n-    case 'e':\n-      if (optimize && flag_delayed_branch\n-\t  && a29k_last_prologue_insn == 0 && epilogue_operand (x, VOIDmode)\n-\t  && dbr_sequence_length () == 0)\n-\t{\n-\t  /* We need to output the label number of the last label in the\n-\t     function, which is not necessarily X since there might be\n-\t     a USE insn in between.  First go forward to the last insn, then\n-\t     back up to a label.  */\n-\t  while (NEXT_INSN (x) != 0)\n-\t    x = NEXT_INSN (x);\n-\n-\t  while (GET_CODE (x) != CODE_LABEL)\n-\t    x = PREV_INSN (x);\n-\n-\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LX\", CODE_LABEL_NUMBER (x));\n-\t  assemble_name (file, buf);\n-\t}\n-      else\n-\toutput_asm_label (x);\n-      return;\n-\n-    case 'E':\n-      if (dbr_sequence_length ())\n-\t;\n-      else if (a29k_last_prologue_insn)\n-\t{\n-\t  fprintf (file, \"\\n\\t%s\", a29k_last_prologue_insn);\n-\t  free (a29k_last_prologue_insn);\n-\t  a29k_last_prologue_insn = 0;\n-\t}\n-      else if (optimize && flag_delayed_branch\n-\t       && epilogue_operand (x, VOIDmode))\n-\t{\n-\t  fprintf (file, \"\\n\\t%s\", a29k_first_epilogue_insn);\n-\t  a29k_first_epilogue_insn_used = 1;\n-\t}\n-      else\n-\tfprintf (file, \"\\n\\tnop\");\n-      return;\n-      \n-    case 'F':\n-      output_addr_const (file, x);\n-      if (dbr_sequence_length () == 0)\n-\t{\n-\t  /* If this doesn't have its delay slot filled, see if we need to\n-\t     put the last insn of the prolog in it.  If not, see if this is\n-\t     a recursive call.  If so, we can put the first insn of its\n-\t     prolog in the delay slot.  Otherwise, write a nop.  */\n-\t  if (a29k_last_prologue_insn)\n-\t    {\n-\t      fprintf (file, \"\\n\\t%s\", a29k_last_prologue_insn);\n-\t      free (a29k_last_prologue_insn);\n-\t      a29k_last_prologue_insn = 0;\n-\t    }\n-\t  else if (GET_CODE (x) == SYMBOL_REF\n-\t      && ! strcmp (XSTR (x, 0), current_function_name))\n-\t    fprintf (file, \"+4\\n\\t%s,%d\",\n-\t\t     a29k_regstack_size >= 64 ? \"const gr121\" : \"sub gr1,gr1\",\n-\t\t     a29k_regstack_size * 4);\n-\t  else\n-\t    fprintf (file, \"\\n\\tnop\");\n-\t}\n-      return;\n-\n-    case 'L':\n-      if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n-\t{\n-\t  REAL_VALUE_TYPE r;\n-\t  char s[30];\n-\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\t  REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n-\n-\t  fprintf (file, \"$double1(%s)\", s);\n-\t}\n-      else if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n-      else\n-\toutput_operand_lossage (\"invalid %%L value\");\n-      return;\n-\n-    case 'O':\n-      if (GET_CODE (x) != REG)\n-\toutput_operand_lossage (\"invalid %%O value\");\n-      fprintf (file, \"%s\", reg_names[REGNO (x) + 2]);\n-      return;\n-\n-    case 'P':\n-      if (GET_CODE (x) != REG)\n-\toutput_operand_lossage (\"invalid %%P value\");\n-      fprintf (file, \"%s\", reg_names[REGNO (x) + 3]);\n-      return;\n-\n-    case 'S':\n-      fprintf (file, \"%d\", (GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD)-1);\n-      return;\n-\n-    case 'V':\n-      if (GET_CODE (x) != PARALLEL)\n-\toutput_operand_lossage (\"invalid %%V value\");\n-      fprintf (file, \"%d\", XVECLEN (x, 0) - 2);\n-      return;\n-\n-    case '#':\n-      if (dbr_sequence_length () == 0)\n-\t{\n-\t  if (a29k_last_prologue_insn)\n-\t    {\n-\t      fprintf (file, \"\\n\\t%s\", a29k_last_prologue_insn);\n-\t      free (a29k_last_prologue_insn);\n-\t      a29k_last_prologue_insn = 0;\n-\t    }\n-\t  else\n-\t    fprintf (file, \"\\n\\tnop\");\n-\t}\n-      return;\n-\n-    case '*':\n-      fprintf (file, \"%s\", reg_names [R_TPC]);\n-      return;\n-    }\n-\n-  if (GET_CODE (x) == REG)\n-    fprintf (file, \"%s\", reg_names [REGNO (x)]);\n-\n-  else if (GET_CODE (x) == MEM)\n-    output_address (XEXP (x, 0));\n-\n-  else if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (XEXP (x, 0))) == CONST_DOUBLE)\n-    {\n-      REAL_VALUE_TYPE r;\n-      char s[30];\n-\n-      if (GET_MODE (SUBREG_REG (XEXP (x, 0))) == SFmode)\n-\tfprintf (file, \"$float\");\n-      else\n-\tfprintf (file, \"$double%d\", \n-\t\t (SUBREG_BYTE (XEXP (x, 0)) / GET_MODE_SIZE (GET_MODE (x))));\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-      REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n-      fprintf (file, \"(%s)\", s);\n-    }\n-\n-  else if (GET_CODE (x) == CONST_DOUBLE\n-\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-    {\n-      REAL_VALUE_TYPE r;\n-      char s[30];\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-      REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n-      fprintf (file, \"$%s(%s)\",\n-\t       GET_MODE (x) == SFmode ? \"float\" : \"double0\", s);\n-    }\n-\n-  else\n-    output_addr_const (file, x);\n-}\n-\f\n-/* This page contains routines to output function prolog and epilog code.  */\n-\n-/* Compute the size of the register stack, and determine if there are any\n-   call instructions.  */\n-\n-static void\n-compute_regstack_size ()\n-{\n-  int i;\n-  rtx insn;\n-\n-  /* See if we make any calls.  We need to set lr1 if so.  */\n-  a29k_makes_calls = 0;\n-  for (insn = get_insns (); insn; insn = next_insn (insn))\n-    if (GET_CODE (insn) == CALL_INSN\n-\t|| (GET_CODE (insn) == INSN\n-\t    && GET_CODE (PATTERN (insn)) == SEQUENCE\n-\t    && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN))\n-      {\n-\ta29k_makes_calls = 1;\n-\tbreak;\n-      }\n-\n-  /* Find the highest local register used.  */\n-  for (i = R_LR (127); i >= R_LR (0); i--)\n-    if (regs_ever_live[i])\n-      break;\n-\n-  a29k_regstack_size = i - (R_LR (0) - 1);\n-\n-  /* If calling routines, ensure we count lr0 & lr1.  */\n-  if (a29k_makes_calls && a29k_regstack_size < 2)\n-    a29k_regstack_size = 2;\n-\n-  /* Count frame pointer and align to 8 byte boundary (even number of\n-     registers).  */\n-  a29k_regstack_size += frame_pointer_needed;\n-  if (a29k_regstack_size & 1) a29k_regstack_size++;\n-}\n-\n-/*  Sets register names for incoming arguments and frame pointer.\n-    This can't be computed until after register allocation.  */\n-\n-void\n-a29k_compute_reg_names ()\n-{\n-  int i;\n-\n-  compute_regstack_size ();\n-\n-  /* Set the names and numbers of the frame pointer and incoming argument\n-     registers.  */\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    a29k_debug_reg_map[i] = i;\n-\n-  reg_names[FRAME_POINTER_REGNUM] = reg_names[R_LR (a29k_regstack_size - 1)];\n-  a29k_debug_reg_map[FRAME_POINTER_REGNUM] = R_LR (a29k_regstack_size - 1);\n-\n-  for (i = 0; i < 16; i++)\n-    {\n-      reg_names[R_AR (i)] = reg_names[R_LR (a29k_regstack_size + i + 2)];\n-      a29k_debug_reg_map[R_AR (i)] = R_LR (a29k_regstack_size + i + 2);\n-    }\n-\n-  /* If using kernel register map, swap numbers for kernel and user\n-     registers.  */\n-  if (TARGET_KERNEL_REGISTERS)\n-    for (i = 0; i < 32; i++)\n-      {\n-\tint tem = a29k_debug_reg_map[i];\n-\ta29k_debug_reg_map[i] = a29k_debug_reg_map[R_KR (i)];\n-\ta29k_debug_reg_map[R_KR (i)] = tem;\n-      }\n-}\n-\n-/* Output function prolog code to file FILE.  Memory stack size is SIZE.  */\n-\n-static void\n-output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  int i;\n-  int arg_count = 0;\n-  rtx insn;\n-  unsigned int tag_word;\n-\n-  /* See how many incoming arguments we have in registers.  */\n-  for (i = R_AR (0); i < R_AR (16); i++)\n-    if (! fixed_regs[i])\n-      arg_count++;\n-\n-  /* The argument count includes the caller's lr0 and lr1.  */\n-  arg_count += 2;\n-\n-  /* Compute memory stack size.  Add in number of bytes that the we should\n-     push and pretend the caller did and the size of outgoing arguments.\n-     Then round to a doubleword boundary.  */\n-  size += (current_function_pretend_args_size\n-\t   + current_function_outgoing_args_size);\n-  size = (size + 7) & ~7;\n-\n-  /* Write header words.  See if one or two word form.  */\n-  tag_word = (frame_pointer_needed ? 0x400000 : 0) + (arg_count << 16);\n-\n-  if (size / 8 > 0xff)\n-    fprintf (file, \"\\t.word %d, 0x%0x\\n\", (size / 8) << 2,\n-\t     0x800000 + tag_word);\n-  else\n-    fprintf (file, \"\\t.word 0x%0x\\n\", tag_word + ((size / 8) << 3));\n-\n-  /* Define the function name.  */\n-  assemble_name (file, a29k_function_name);\n-  fprintf (file, \":\\n\");\n-\n-  /* Push the register stack by the proper amount.  There are two possible\n-     ways to do this.  */\n-  if (a29k_regstack_size >= 256/4)\n-    fprintf (file, \"\\tconst %s,%d\\n\\tsub gr1,gr1,%s\\n\",\n-\t     reg_names[R_TAV], a29k_regstack_size * 4, reg_names[R_TAV]);\n-  else if (a29k_regstack_size)\n-    fprintf (file, \"\\tsub gr1,gr1,%d\\n\", a29k_regstack_size * 4);\n-\n-  /* Test that the registers are available.  */\n-  if (a29k_regstack_size)\n-    fprintf (file, \"\\tasgeu V_%sSPILL,gr1,%s\\n\",\n-\t     TARGET_KERNEL_REGISTERS ? \"K\" : \"\", reg_names[R_RAB]);\n-\n-  /* Set up frame pointer, if one is needed.  */\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\tsll %s,%s,0\\n\", reg_names[FRAME_POINTER_REGNUM],\n-\t     reg_names[R_MSP]);\n-\n-  /* Make room for any frame space.  There are three ways to do this.  */\n-  if (size >= 256)\n-    {\n-      fprintf (file, \"\\tconst %s,%d\\n\", reg_names[R_TAV], size);\n-      if (size >= 65536)\n-\tfprintf (file, \"\\tconsth %s,%d\\n\", reg_names[R_TAV], size);\n-      if (TARGET_STACK_CHECK)\n-\tfprintf (file, \"\\tcall %s,__msp_check\\n\", reg_names[R_TPC]);\n-      fprintf (file, \"\\tsub %s,%s,%s\\n\",\n-\t       reg_names[R_MSP], reg_names[R_MSP], reg_names[R_TAV]);\n-    }\n-  else if (size)\n-    {\n-      if (TARGET_STACK_CHECK)\n-\tfprintf (file, \"\\tcall %s,__msp_check\\n\", reg_names[R_TPC]);\n-      fprintf (file, \"\\tsub %s,%s,%d\\n\",\n-\t       reg_names[R_MSP], reg_names[R_MSP], size);\n-    }\n-\n-  /* If this routine will make calls, set lr1.  If we see an insn that\n-     can use a delay slot before a call or jump, save this insn for that\n-     slot (this condition is equivalent to seeing if we have an insn that\n-     needs delay slots before an insn that has a filled delay slot).  */\n-  a29k_last_prologue_insn = 0;\n-  if (a29k_makes_calls)\n-    {\n-      i = (a29k_regstack_size + arg_count) * 4;\n-      if (i >= 256)\n-\tfprintf (file, \"\\tconst %s,%d\\n\\tadd lr1,gr1,%s\\n\",\n-\t\t reg_names[R_TAV], i, reg_names[R_TAV]);\n-      else\n-\t{\n-\t  if (optimize && flag_delayed_branch)\n-\t    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\t      {\n-\t\tif (GET_CODE (insn) == CODE_LABEL\n-\t\t    || (GET_CODE (insn) == INSN\n-\t\t\t&& GET_CODE (PATTERN (insn)) == SEQUENCE))\n-\t\t  break;\n-\n-\t\tif (GET_CODE (insn) == NOTE\n-\t\t    || (GET_CODE (insn) == INSN\n-\t\t\t&& (GET_CODE (PATTERN (insn)) == USE\n-\t\t\t    || GET_CODE (PATTERN (insn)) == CLOBBER)))\n-\t\t  continue;\n-\n-\t\tif (num_delay_slots (insn) > 0)\n-\t\t  {\n-\t\t    a29k_last_prologue_insn = (char *) xmalloc (100);\n-\t\t    sprintf (a29k_last_prologue_insn, \"add lr1,gr1,%d\", i);\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\n-\t  if (a29k_last_prologue_insn == 0)\n-\t    fprintf (file, \"\\tadd lr1,gr1,%d\\n\", i);\n-\t}\n-    }\n-\n-  /* Compute the first insn of the epilogue.  */\n-  a29k_first_epilogue_insn_used = 0;\n-\n-  if (size == 0 && a29k_regstack_size == 0 && ! frame_pointer_needed)\n-    a29k_first_epilogue_insn = 0;\n-  else\n-    a29k_first_epilogue_insn = (char *) xmalloc (100);\n-\n-  if (frame_pointer_needed)\n-    sprintf (a29k_first_epilogue_insn, \"sll %s,%s,0\",\n-\t     reg_names[R_MSP], reg_names[FRAME_POINTER_REGNUM]);\n-  else if (a29k_regstack_size)\n-    {\n-      if (a29k_regstack_size >= 256 / 4)\n-\tsprintf (a29k_first_epilogue_insn, \"const %s,%d\",\n-\t\t reg_names[R_TAV], a29k_regstack_size * 4);\n-      else\n-\tsprintf (a29k_first_epilogue_insn, \"add gr1,gr1,%d\",\n-\t\t a29k_regstack_size * 4);\n-    }\n-  else if (size)\n-    {\n-      if (size >= 256)\n-\tsprintf (a29k_first_epilogue_insn, \"const %s,%d\",\n-\t\t reg_names[R_TAV], size);\n-      else\n-\tsprintf (a29k_first_epilogue_insn, \"add %s,%s,%d\",\n-\t\t reg_names[R_MSP], reg_names[R_MSP], size);\n-    }\n-}\n-\f\n-/* Call this after writing what might be the first instruction of the\n-   epilogue.  If that first insn was used in a delay slot, an intermediate\n-   label is written.  */\n-\n-static void\n-check_epilogue_internal_label (file)\n-     FILE *file;\n-{\n-  rtx insn;\n-\n-  if (! a29k_first_epilogue_insn_used)\n-    return;\n-\n-  for (insn = get_last_insn ();\n-       GET_CODE (insn) != CODE_LABEL;\n-       insn = PREV_INSN (insn))\n-    ;\n-\n-  ASM_OUTPUT_INTERNAL_LABEL (file, \"LX\", CODE_LABEL_NUMBER (insn));\n-  a29k_first_epilogue_insn_used = 0;\n-}\n-\n-/* Output the epilog of the last procedure to file FILE.  SIZE is the memory\n-   stack size.  The register stack size is in the variable\n-   A29K_REGSTACK_SIZE.  */\n-\n-static void\n-output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  rtx insn;\n-  int locals_unavailable = 0;\t/* True until after first insn\n-\t\t\t\t   after gr1 update.  */\n-\n-  /* If we hit a BARRIER before a real insn or CODE_LABEL, we don't\n-     need to do anything because we are never jumped to.  */\n-  insn = get_last_insn ();\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-\n-  if (insn && GET_CODE (insn) == BARRIER)\n-    return;\n-\n-  /* If a frame pointer was needed we must restore the memory stack pointer\n-     before adjusting the register stack.  */\n-  if (frame_pointer_needed)\n-    {\n-      fprintf (file, \"\\tsll %s,%s,0\\n\",\n-\t       reg_names[R_MSP], reg_names[FRAME_POINTER_REGNUM]);\n-      check_epilogue_internal_label (file);\n-    }\n-\n-  /* Restore the register stack.  There are two ways to do this.  */\n-  if (a29k_regstack_size)\n-    {\n-      if (a29k_regstack_size >= 256/4)\n-\t{\n-\t  fprintf (file, \"\\tconst %s,%d\\n\",\n-\t\t   reg_names[R_TAV], a29k_regstack_size * 4);\n-\t  check_epilogue_internal_label (file);\n-\t  fprintf (file, \"\\tadd gr1,gr1,%s\\n\", reg_names[R_TAV]);\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, \"\\tadd gr1,gr1,%d\\n\", a29k_regstack_size * 4);\n-\t  check_epilogue_internal_label (file);\n-\t}\n-      locals_unavailable = 1;\n-    }\n-\n-  /* Restore the memory stack pointer if there is no frame pointer.\n-     Adjust the size to include any pretend arguments and pushed\n-     arguments and round to doubleword boundary.  */\n-  size += (current_function_pretend_args_size\n-\t   + current_function_outgoing_args_size);\n-  size = (size + 7) & ~7;\n-\n-  if (size && ! frame_pointer_needed)\n-    {\n-      if (size >= 256)\n-\t{\n-\t  fprintf (file, \"\\tconst %s,%d\\n\", reg_names[R_TAV], size);\n-\t  check_epilogue_internal_label (file);\n-\t  locals_unavailable = 0;\n-\t  if (size >= 65536)\n-\t    fprintf (file, \"\\tconsth %s,%d\\n\", reg_names[R_TAV], size);\n-\t  fprintf (file, \"\\tadd %s,%s,%s\\n\",\n-\t\t   reg_names[R_MSP], reg_names[R_MSP], reg_names[R_TAV]);\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, \"\\tadd %s,%s,%d\\n\",\n-\t\t   reg_names[R_MSP], reg_names[R_MSP], size);\n-\t  check_epilogue_internal_label (file);\n-\t  locals_unavailable = 0;\n-\t}\n-    }\n-\n-  if (locals_unavailable)\n-    {\n-      /* If we have an insn for this delay slot, write it.  */\n-      if (current_function_epilogue_delay_list)\n-\tfinal_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t\t file, 1, -2, 1);\n-      else\n-\tfprintf (file, \"\\tnop\\n\");\n-    }\n-\n-  fprintf (file, \"\\tjmpi lr0\\n\");\n-  if (a29k_regstack_size)\n-    fprintf (file, \"\\tasleu V_%sFILL,lr1,%s\\n\",\n-\t     TARGET_KERNEL_REGISTERS ? \"K\" : \"\", reg_names[R_RFB]);\n-  else if (current_function_epilogue_delay_list)\n-    final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t     file, 1, -2, 1);\n-  else\n-    fprintf (file, \"\\tnop\\n\");\n-  \n-  if (a29k_first_epilogue_insn)\n-    free (a29k_first_epilogue_insn);\n-  a29k_first_epilogue_insn = 0;\n-}\n-\n-static void\n-a29k_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags ATTRIBUTE_UNUSED;\n-{\n-  /* ??? Is it really correct to mark all sections as \"bss\"?  */\n-  fprintf (asm_out_file, \"\\t.sect %s, bss\\n\\t.use %s\\n\", name, name);\n-}\n-\n-/* Return a new value for COST based on the relationship between INSN\n-   that is dependent on DEP_INSN through the dependence LINK.  The\n-   default is to make no adjustment to COST.\n-\n-   On the a29k, ignore the cost of anti- and output-dependencies.  */\n-static int\n-a29k_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx link;\n-     rtx dep_insn ATTRIBUTE_UNUSED;\n-     int cost;\n-{\n-  if (REG_NOTE_KIND (link) != 0)\n-    return 0;\t/* Anti or output dependence.  */\n-\n-  return cost;\n-}\n-\n-/* If we are referencing a function that is static or is known to be\n-   in this file, make the SYMBOL_REF special.  We can use this to\n-   indicate that we can branch to this function without emitting a\n-   no-op after the call.  */\n-\n-static void\n-a29k_encode_section_info (decl, first)\n-     tree decl;\n-     int first ATTRIBUTE_UNUSED;\n-{\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && (TREE_ASM_WRITTEN (decl) || ! TREE_PUBLIC (decl)))\n-    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n-}"}, {"sha": "1665368e9204f107d18eadef4a040d9d43b10132", "filename": "gcc/config/a29k/a29k.h", "status": "removed", "additions": 0, "deletions": 1538, "changes": 1538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1538 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for AMD Am29000 CPU.\n-   Copyright (C) 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   2000, 2001, 2002 Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-D_AM29K -D_AM29000 -D_EPI -Acpu=a29k -Amachine=a29k\"\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION\n-\n-/* Pass -w to assembler.  */\n-#define ASM_SPEC \"-w\"\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-/* This means that the DW bit will be enabled, to allow direct loads\n-   of bytes.  */\n-\n-#define TARGET_DW_ENABLE\t(target_flags & 1)\n-\n-/* This means that the external hardware does supports byte writes.  */\n-\n-#define TARGET_BYTE_WRITES\t(target_flags & 2)\n-\n-/* This means that a \"small memory model\" has been selected where all\n-   function addresses are known to be within 256K.  This allows CALL to be\n-   used.  */\n-\n-#define TARGET_SMALL_MEMORY\t(target_flags & 4)\n-\n-/* This means that we must always used on indirect call, even when\n-   calling a function in the same file, since the file might be > 256KB.  */\n-\n-#define TARGET_LARGE_MEMORY\t(target_flags & 8)\n-\n-/* This means that we are compiling for a 29050.  */\n-\n-#define TARGET_29050\t\t(target_flags & 16)\n-\n-/* This means that we are compiling for the kernel which means that we use\n-   gr64-gr95 instead of gr96-126.  */\n-\n-#define TARGET_KERNEL_REGISTERS\t(target_flags & 32)\n-\n-/* This means that a call to \"__msp_check\" should be inserted after each stack\n-   adjustment to check for stack overflow.  */\n-\n-#define TARGET_STACK_CHECK\t(target_flags & 64)\n-\n-/* This handles 29k processors which cannot handle the separation\n-   of a mtsrim insns and a storem insn (most 29000 chips to date, but\n-   not the 29050.  */\n-\n-#define TARGET_NO_STOREM_BUG\t(target_flags & 128)\n-\n-/* This forces the compiler not to use incoming argument registers except\n-   for copying out arguments.  It helps detect problems when a function is\n-   called with fewer arguments than it is declared with.  */\n-\n-#define TARGET_NO_REUSE_ARGS\t(target_flags & 256)\n-\n-/* This means that neither builtin nor emulated float operations are\n-   available, and that GCC should generate libcalls instead.  */\n-\n-#define TARGET_SOFT_FLOAT\t(target_flags & 512)\n-\n-/* This means that we should not emit the multm or mutmu instructions\n-   that some embedded systems' trap handlers don't support.  */\n-\n-#define TARGET_MULTM\t\t((target_flags & 1024) == 0)\n-\n-#define TARGET_SWITCHES\t\t\t\\\n-  { {\"dw\", 1, N_(\"Generate code assuming DW bit is set\")},\t\t\\\n-    {\"ndw\", -1, N_(\"Generate code assuming DW bit is not set\")},\t\\\n-    {\"bw\", 2, N_(\"Generate code using byte writes\")},\t\t\t\\\n-    {\"nbw\", - (1|2), N_(\"Do not generate byte writes\")},\t\t\\\n-    {\"small\", 4, N_(\"Use small memory model\")},\t\t\t\t\\\n-    {\"normal\", - (4|8), N_(\"Use normal memory model\")},\t\t\t\\\n-    {\"large\", 8, N_(\"Use large memory model\")},\t\t\t\t\\\n-    {\"29050\", 16+128, N_(\"Generate 29050 code\")},\t\t\t\\\n-    {\"29000\", -16, N_(\"Generate 29000 code\")},\t\t\t\t\\\n-    {\"kernel-registers\", 32, N_(\"Use kernel global registers\")},\t\\\n-    {\"user-registers\", -32, N_(\"Use user global registers\")},\t\t\\\n-    {\"stack-check\", 64, N_(\"Emit stack checking code\")},\t\t\\\n-    {\"no-stack-check\", - 74, N_(\"Do not emit stack checking code\")},\t\\\n-    {\"storem-bug\", -128, N_(\"Work around storem hardware bug\")},\t\\\n-    {\"no-storem-bug\", 128, N_(\"Do not work around storem hardware bug\")},\t\\\n-    {\"reuse-arg-regs\", -256, N_(\"Store locals in argument registers\")},\t\t\\\n-    {\"no-reuse-arg-regs\", 256, N_(\"Do not store locals in arg registers\")},\t\\\n-    {\"soft-float\", 512, N_(\"Use software floating point\")},\t\t\t\\\n-    {\"no-multm\", 1024, N_(\"Do not generate multm instructions\")},\t\t\\\n-    {\"\", TARGET_DEFAULT, NULL}}\n-\n-#define TARGET_DEFAULT 3\n-\n-/* Show we can debug even without a frame pointer.  */\n-#define CAN_DEBUG_WITHOUT_FP\n-\f\n-/* target machine storage layout */\n-\n-/* Define the types for size_t, ptrdiff_t, and wchar_t.  These are the\n-   same as those used by EPI.  The type for wchar_t does not make much\n-   sense, but is what is used.  */\n-\n-#define SIZE_TYPE \"unsigned int\"\n-#define PTRDIFF_TYPE \"int\"\n-#define WCHAR_TYPE \"char\"\n-#define WCHAR_TYPE_SIZE BITS_PER_UNIT\n-\n-/* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases, \n-   the value is constrained to be within the bounds of the declared\n-   type, but kept valid in the wider mode.  The signedness of the\n-   extension may differ from that of the type.  */\n-\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\\\n-      && GET_MODE_SIZE (MODE) < 4)  \t\\\n-    (MODE) = SImode;\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   This is arbitrary on the 29k since it has no actual bit-field insns.\n-   It is better to define this as TRUE because BYTES_BIG_ENDIAN is TRUE\n-   and we want to be able to convert BP position to bit position with\n-   just a shift.  */\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.\n-   This is true on 29k.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is lowest\n-   numbered. \n-\n-   For 29k we can decide arbitrarily since there are no machine instructions\n-   for them.  Might as well be consistent with bytes.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 64\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 32\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Set this non-zero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 0\n-\n-/* Set this non-zero if unaligned move instructions are extremely slow.\n-\n-   On the 29k, they trap.  */\n-#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   29k has 256 registers, of which 62 are not defined.  gr0 and gr1 are\n-   not produced in generated RTL so we can start at gr96, and call it\n-   register zero.\n-\n-   So 0-31 are gr96-gr127, lr0-lr127 are 32-159.  To represent the input\n-   arguments, whose register numbers we won't know until we are done,\n-   use register 160-175.  They cannot be modified.  Similarly, 176 is used\n-   for the frame pointer.  It is assigned the last local register number\n-   once the number of registers used is known.\n-\n-   We use 177, 178, 179, and 180 for the special registers BP, FC, CR, and Q,\n-   respectively.  Registers 181 through 199 are used for the other special\n-   registers that may be used by the programmer, but are never used by the\n-   compiler.\n-\n-   Registers 200-203 are the four floating-point accumulator register in\n-   the 29050.\n-\n-   Registers 204-235 are the 32 global registers for kernel mode when\n-   -mkernel-registers is not specified, and the 32 global user registers\n-   when it is.\n-\n-   When -mkernel-registers is specified, we still use the same register\n-   map but change the names so 0-31 print as gr64-gr95.  */\n-\n-#define FIRST_PSEUDO_REGISTER 236\n-\n-/* Because of the large number of registers on the 29k, we define macros\n-   to refer to each group of registers and then define the number for some\n-   registers used in the calling sequence.  */\n-\n-#define R_GR(N)\t\t((N) - 96)\t/* gr96 is register number 0 */\n-#define R_LR(N)\t\t((N) + 32)\t/* lr0 is register number 32 */\n-#define R_FP\t\t176\t\t/* frame pointer is register 176 */\n-#define R_AR(N)\t\t((N) + 160)\t/* first incoming arg reg is 160 */\n-#define R_KR(N)\t\t((N) + 204)\t/* kernel registers (gr64 to gr95) */\n-\n-/* Define the numbers of the special registers.  */\n-#define R_BP\t177\n-#define R_FC\t178\n-#define R_CR\t179\n-#define R_Q\t180\n-\n-/* These special registers are not used by the compiler, but may be referenced\n-   by the programmer via asm declarations.  */\n-\n-#define R_VAB\t181\n-#define R_OPS\t182\n-#define R_CPS\t183\n-#define R_CFG\t184\n-#define R_CHA\t185\n-#define R_CHD\t186\n-#define R_CHC\t187\n-#define R_RBP\t188\n-#define R_TMC\t189\n-#define R_TMR\t190\n-#define R_PC0\t191\n-#define R_PC1\t192\n-#define R_PC2\t193\n-#define R_MMU\t194\n-#define R_LRU\t195\n-#define R_FPE\t196\n-#define R_INT\t197\n-#define R_FPS\t198\n-#define R_EXO\t199\n-\n-/* Define the number for floating-point accumulator N.  */\n-#define R_ACU(N)\t((N) + 200)\n-\n-/* Now define the registers used in the calling sequence.  */\n-#define R_TAV\tR_GR (121)\n-#define R_TPC\tR_GR (122)\n-#define R_LRP\tR_GR (123)\n-#define R_SLP\tR_GR (124)\n-#define R_MSP\tR_GR (125)\n-#define R_RAB\tR_GR (126)\n-#define R_RFB\tR_GR (127)\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.  */\n-\n-#define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, \\\n-  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\t\t  \\\n-  0, 0, 0, 0,\t\t\t\t\t  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\t\t  \\\n-  1, 1, 1, 1,\t\t\t\t\t  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n-\n-/* List the order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.\n-\n-   We allocate in the following order:\n-\tgr116-gr120\t(not used for anything but temps)\n-\tgr96-gr111\t(function return values, reverse order)\n-\targument registers (160-175)\n-\tlr0-lr127\t(locals, saved)\n-        acc3-0\t\t(acc0 special)\n-\teverything else  */\n-\n-#define REG_ALLOC_ORDER\t\t\\\n-  {R_GR (116), R_GR (117), R_GR (118), R_GR (119), R_GR (120),\t\t\\\n-   R_GR (111), R_GR (110), R_GR (109), R_GR (108), R_GR (107),\t\t\\\n-   R_GR (106), R_GR (105), R_GR (104), R_GR (103), R_GR (102),\t\t\\\n-   R_GR (101), R_GR (100), R_GR (99), R_GR (98), R_GR (97), R_GR (96),\t\\\n-   R_AR (0), R_AR (1), R_AR (2), R_AR (3), R_AR (4), R_AR (5),\t\t\\\n-   R_AR (6), R_AR (7), R_AR (8), R_AR (9), R_AR (10), R_AR (11),\t\\\n-   R_AR (12), R_AR (13), R_AR (14), R_AR (15),\t\t\t\t\\\n-   R_LR (0), R_LR (1), R_LR (2), R_LR (3), R_LR (4), R_LR (5),\t\t\\\n-   R_LR (6), R_LR (7), R_LR (8), R_LR (9), R_LR (10), R_LR (11),\t\\\n-   R_LR (12), R_LR (13), R_LR (14), R_LR (15), R_LR (16), R_LR (17),\t\\\n-   R_LR (18), R_LR (19), R_LR (20), R_LR (21), R_LR (22), R_LR (23),\t\\\n-   R_LR (24), R_LR (25), R_LR (26), R_LR (27), R_LR (28), R_LR (29),\t\\\n-   R_LR (30), R_LR (31), R_LR (32), R_LR (33), R_LR (34), R_LR (35),\t\\\n-   R_LR (36), R_LR (37), R_LR (38), R_LR (39), R_LR (40), R_LR (41),\t\\\n-   R_LR (42), R_LR (43), R_LR (44), R_LR (45), R_LR (46), R_LR (47), \t\\\n-   R_LR (48), R_LR (49), R_LR (50), R_LR (51), R_LR (52), R_LR (53),\t\\\n-   R_LR (54), R_LR (55), R_LR (56), R_LR (57), R_LR (58), R_LR (59),\t\\\n-   R_LR (60), R_LR (61), R_LR (62), R_LR (63), R_LR (64), R_LR (65),\t\\\n-   R_LR (66), R_LR (67), R_LR (68), R_LR (69), R_LR (70), R_LR (71),\t\\\n-   R_LR (72), R_LR (73), R_LR (74), R_LR (75), R_LR (76), R_LR (77),\t\\\n-   R_LR (78), R_LR (79), R_LR (80), R_LR (81), R_LR (82), R_LR (83),\t\\\n-   R_LR (84), R_LR (85), R_LR (86), R_LR (87), R_LR (88), R_LR (89),\t\\\n-   R_LR (90), R_LR (91), R_LR (92), R_LR (93), R_LR (94), R_LR (95),\t\\\n-   R_LR (96), R_LR (97), R_LR (98), R_LR (99), R_LR (100), R_LR (101),\t\\\n-   R_LR (102), R_LR (103), R_LR (104), R_LR (105), R_LR (106),\t\t\\\n-   R_LR (107), R_LR (108), R_LR (109), R_LR (110), R_LR (111),\t\t\\\n-   R_LR (112), R_LR (113), R_LR (114), R_LR (115), R_LR (116),\t\t\\\n-   R_LR (117), R_LR (118), R_LR (119), R_LR (120), R_LR (121),\t\t\\\n-   R_LR (122), R_LR (123), R_LR (124), R_LR (124), R_LR (126),\t\t\\\n-   R_LR (127),\t\t\t\t\t\t\t\t\\\n-   R_ACU (3), R_ACU (2), R_ACU (1), R_ACU (0),\t\t\t\t\\\n-   R_GR (112), R_GR (113), R_GR (114), R_GR (115), R_GR (121),\t\t\\\n-   R_GR (122), R_GR (123), R_GR (124), R_GR (125), R_GR (126),\t\t\\\n-   R_GR (127),\t\t\t\t\t\t\t\t\\\n-   R_FP, R_BP, R_FC, R_CR, R_Q,\t\t\t\t\t\t\\\n-   R_VAB, R_OPS, R_CPS, R_CFG, R_CHA, R_CHD, R_CHC, R_RBP, R_TMC,\t\\\n-   R_TMR, R_PC0, R_PC1, R_PC2, R_MMU, R_LRU, R_FPE, R_INT, R_FPS,\t\\\n-   R_EXO,\t\t\t\t\t\t\t\t\\\n-   R_KR (0), R_KR (1), R_KR (2), R_KR (3), R_KR (4), R_KR (5), \t\t\\\n-   R_KR (6), R_KR (7), R_KR (8), R_KR (9), R_KR (10), R_KR (11),\t\\\n-   R_KR (12), R_KR (13), R_KR (14), R_KR (15), R_KR (16), R_KR (17),\t\\\n-   R_KR (18), R_KR (19), R_KR (20), R_KR (21), R_KR (22), R_KR (23),\t\\\n-   R_KR (24), R_KR (25), R_KR (26), R_KR (27), R_KR (28), R_KR (29),\t\\\n-   R_KR (30), R_KR (31) }\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) >= R_ACU (0) && (REGNO) <= R_ACU (3)? 1\t\t\\\n-   : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On 29k, the cpu registers can hold any mode.  But a double-precision\n-   floating-point value should start at an even register.  The special\n-   registers cannot hold floating-point values, BP, CR, and FC cannot\n-   hold integer or floating-point values,  and the accumulators cannot\n-   hold integer values.\n-\n-   DImode and larger values should start at an even register just like\n-   DFmode values, even though the instruction set doesn't require it, in order\n-   to prevent reload from aborting due to a modes_equiv_for_class_p failure.\n-\n-   (I'd like to use the \"?:\" syntax to make this more readable, but Sun's\n-   compiler doesn't seem to accept it.)  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)  \t\t\t\t\\\n-(((REGNO) >= R_ACU (0) && (REGNO) <= R_ACU (3)\t\t\t\t\\\n-    && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-\t|| GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT))\t\t\\\n-   || ((REGNO) >= R_BP && (REGNO) <= R_CR\t\t\t\t\\\n-       && GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT)\t\t\t\\\n-   || ((REGNO) >= R_Q && (REGNO) < R_ACU (0)\t\t\t\t\\\n-       && GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n-       && GET_MODE_CLASS (MODE) != MODE_COMPLEX_FLOAT)\t\t\t\\\n-   || (((REGNO) < R_BP || (REGNO) >= R_KR (0))\t\t\t\t \\\n-       && ((((REGNO) & 1) == 0)\t\t\t\t\t\t\\\n-\t   || GET_MODE_UNIT_SIZE (MODE) <= UNITS_PER_WORD)))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.\n-\n-   On the 29k, normally we'd just have problems with DFmode because of the\n-   even alignment.  However, we also have to be a bit concerned about\n-   the special register's restriction to non-floating and the floating-point\n-   accumulator's restriction to only floating.  This probably won't\n-   cause any great inefficiencies in practice.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n-  ((MODE1) == (MODE2)\t\t\t\t\t\\\n-   || (GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n-       && GET_MODE_CLASS (MODE2) == MODE_INT))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* 29k pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM R_GR (125)\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM R_FP\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM R_FP\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM R_SLP\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM R_LRP\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.\n-   \n-   The 29k has nine registers classes: LR0_REGS, GENERAL_REGS, SPECIAL_REGS,\n-   BP_REGS, FC_REGS, CR_REGS, Q_REGS, ACCUM_REGS, and ACCUM0_REGS.\n-   LR0_REGS, BP_REGS, FC_REGS, CR_REGS, and Q_REGS contain just the single\n-   register.  The latter two classes are used to represent the floating-point\n-   accumulator registers in the 29050.  We also define the union class\n-   FLOAT_REGS to represent any register that can be used to hold a\n-   floating-point value.  The union of SPECIAL_REGS and ACCUM_REGS isn't\n-   useful as the former cannot contain floating-point and the latter can only\n-   contain floating-point.  */\n-\n-enum reg_class { NO_REGS, LR0_REGS, GENERAL_REGS, BP_REGS, FC_REGS, CR_REGS,\n-\t\t Q_REGS, SPECIAL_REGS, ACCUM0_REGS, ACCUM_REGS, FLOAT_REGS,\n-\t\t ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES\t\t\t\t\\\n- {\"NO_REGS\", \"LR0_REGS\", \"GENERAL_REGS\", \"BP_REGS\", \"FC_REGS\", \"CR_REGS\", \\\n-  \"Q_REGS\", \"SPECIAL_REGS\", \"ACCUM0_REGS\", \"ACCUM_REGS\", \"FLOAT_REGS\",    \\\n-  \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS\t\\\n-  { {0, 0, 0, 0, 0, 0, 0, 0}, \t\t\t\t   \\\n-    {0, 1, 0, 0, 0, 0, 0, 0},\t\t\t\t   \\\n-    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, ~ 0xfff, 0xfff},\t   \\\n-    {0, 0, 0, 0, 0, 0x20000, 0, 0}, \t\t\t   \\\n-    {0, 0, 0, 0, 0, 0x40000, 0, 0}, \t\t\t   \\\n-    {0, 0, 0, 0, 0, 0x80000, 0, 0}, \t\t\t   \\\n-    {0, 0, 0, 0, 0, 0x100000, 0, 0}, \t\t\t   \\\n-    {0, 0, 0, 0, 0, 0xfffe0000, 0xff, 0},\t\t   \\\n-    {0, 0, 0, 0, 0, 0, 0x100, 0},\t\t\t   \\\n-    {0, 0, 0, 0, 0, 0, 0xf00, 0},\t\t\t   \\\n-    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, ~ 0xff, 0xfff}, \t   \\\n-    {~0, ~0, ~0, ~0, ~0, ~0, ~0, 0xfff} }\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO)\t\t\\\n-  ((REGNO) == R_BP ? BP_REGS\t\t\\\n-   : (REGNO) == R_FC ? FC_REGS\t\t\\\n-   : (REGNO) == R_CR ? CR_REGS\t\t\\\n-   : (REGNO) == R_Q ? Q_REGS\t\t\\\n-   : (REGNO) > R_BP && (REGNO) <= R_EXO ? SPECIAL_REGS\t\\\n-   : (REGNO) == R_ACU (0) ? ACCUM0_REGS\t\\\n-   : (REGNO) >= R_KR (0) ? GENERAL_REGS \\\n-   : (REGNO) > R_ACU (0) ? ACCUM_REGS\t\\\n-   : (REGNO) == R_LR (0) ? LR0_REGS\t\\\n-   : GENERAL_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS NO_REGS\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\\\n- ((C) == 'r' ? GENERAL_REGS\t\t\\\n-  : (C) == 'l' ? LR0_REGS\t\t\\\n-  : (C) == 'b' ? BP_REGS\t\t\\\n-  : (C) == 'f' ? FC_REGS\t\t\\\n-  : (C) == 'c' ? CR_REGS\t\t\\\n-  : (C) == 'q' ? Q_REGS\t\t\t\\\n-  : (C) == 'h' ? SPECIAL_REGS\t\t\\\n-  : (C) == 'a' ? ACCUM_REGS\t\t\\\n-  : (C) == 'A' ? ACCUM0_REGS\t\t\\\n-  : (C) == 'f' ? FLOAT_REGS\t\t\\\n-  : NO_REGS)\n-\n-/* Define this macro to change register usage conditional on target flags.\n-\n-   On the 29k, we use this to change the register names for kernel mapping.  */\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\t\\\n-  {\t\t\t\t\t\t\\\n-    const char *p;\t\t\t\t\\\n-    int i;\t\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-    if (TARGET_KERNEL_REGISTERS)\t\t\\\n-      for (i = 0; i < 32; i++)\t\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  p = reg_names[i];\t\t\t\\\n-\t  reg_names[i] = reg_names[R_KR (i)];\t\\\n-\t  reg_names[R_KR (i)] = p;\t\t\\\n-\t}\t\t\t\t\t\\\n-  }\n-\n-/* The letters I, J, K, L, M, N, O, and P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For 29k:\n-   `I' is used for the range of constants most insns can contain.\n-   `J' is for the few 16-bit insns.\n-   `K' is a constant whose high-order 24 bits are all one\n-   `L' is a HImode constant whose high-order 8 bits are all one\n-   `M' is a 32-bit constant whose high-order 16 bits are all one (for CONSTN)\n-   `N' is a 32-bit constant whose negative is 8 bits\n-   `O' is the 32-bit constant 0x80000000, any constant with low-order\n-          16 bits zero for 29050.\n-   `P' is a HImode constant whose negative is 8 bits  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'I' ? (unsigned) (VALUE) < 0x100\t\t\t\\\n-   : (C) == 'J' ? (unsigned) (VALUE) < 0x10000\t\t\t\\\n-   : (C) == 'K' ? ((VALUE) & 0xffffff00) == 0xffffff00\t\t\\\n-   : (C) == 'L' ? ((VALUE) & 0xff00) == 0xff00\t\t\t\\\n-   : (C) == 'M' ? ((VALUE) & 0xffff0000) == 0xffff0000\t\t\\\n-   : (C) == 'N' ? ((VALUE) < 0 && (VALUE) > -256)\t\t\\\n-   : (C) == 'O' ? ((VALUE) == 0x80000000\t\t\t\\\n-\t\t   || (TARGET_29050 && ((VALUE) & 0xffff) == 0)) \\\n-   : (C) == 'P' ? (((VALUE) | 0xffff0000) < 0\t\t\t\\\n-\t\t   && ((VALUE) | 0xffff0000) > -256)\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-   All floating-point constants are valid on 29k.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\tCLASS\n-\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  secondary_reload_class (CLASS, MODE, IN)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.\n-\n-   On 29k, this is the size of MODE in words except that the floating-point\n-   accumulators only require one word for anything they can hold.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\\\n- (((CLASS) == ACCUM_REGS || (CLASS) == ACCUM0_REGS) ? 1\t\t\\\n-  : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Define the cost of moving between registers of various classes.  Everything\n-   involving a general register is cheap, but moving between the other types\n-   (even within a class) is two insns.  */\n-\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\\\n-  ((CLASS1) == GENERAL_REGS || (CLASS2) == GENERAL_REGS ? 2 : 4)\n-\n-/* A C expressions returning the cost of moving data of MODE from a register to\n-   or from memory.\n-\n-   It takes extra insns on the 29k to form addresses, so we want to make\n-   this higher.  In addition, we need to keep it more expensive than the\n-   most expensive register-register copy.  */\n-\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) 6\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-\n-#define STARTING_FRAME_OFFSET (- current_function_pretend_args_size)\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On 29k, don't define this because there are no push insns.  */\n-/*  #define PUSH_ROUNDING(BYTES) */\n-\n-/* Define this if the maximum size of all the outgoing args is to be\n-   accumulated and pushed during the prologue.  The amount can be\n-   found in the variable current_function_outgoing_args_size.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL) (- current_function_pretend_args_size)\n-\n-/* Define this if stack space is still allocated for a parameter passed\n-   in a register.  */\n-/* #define REG_PARM_STACK_SPACE */\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.\n-\n-   On 29k the value is found in gr96.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), R_GR (96))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, R_GR (96))\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.\n-   On 29k, gr96-gr111 are used.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == R_GR (96))\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On 29k, these are lr2-lr17.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) <= R_LR (17) && (N) >= R_LR (2))\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On 29k, this is a single integer, which is a number of words\n-   of arguments scanned so far.\n-   Thus 16 or more means all following args should go on the stack.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)  (CUM) = 0\n-\n-/* Same, but called for incoming args.\n-\n-   On the 29k, we use this to set all argument registers to fixed and\n-   set the last 16 local regs, less two, (lr110-lr125) to available.  Some\n-   will later be changed to call-saved by FUNCTION_INCOMING_ARG.\n-   lr126,lr127 are always fixed, they are place holders for the caller's\n-   lr0,lr1.  */\n-\n-#define INIT_CUMULATIVE_INCOMING_ARGS(CUM,FNTYPE,IGNORE)\t\\\n-{ int i;\t\t\t\t\t\t\t\\\n-  for (i = R_AR (0) - 2; i < R_AR (16); i++)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 1; \\\n-      SET_HARD_REG_BIT (fixed_reg_set, i);\t\t\t\\\n-      SET_HARD_REG_BIT (call_used_reg_set, i);\t\t\t\\\n-      SET_HARD_REG_BIT (call_fixed_reg_set, i);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  for (i = R_LR (110); i < R_LR (126); i++)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 0; \\\n-      CLEAR_HARD_REG_BIT (fixed_reg_set, i);\t\t\t\\\n-      CLEAR_HARD_REG_BIT (call_used_reg_set, i);\t\t\\\n-      CLEAR_HARD_REG_BIT (call_fixed_reg_set, i);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  (CUM) = 0;\t\t\t\t\t\t\t\\\n- }\n-\n-/* Define intermediate macro to compute the size (in registers) of an argument\n-   for the 29k.  */\n-\n-#define A29K_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n-(! (NAMED) ? 0\t\t\t\t\t\t\t\t\\\n- : (MODE) != BLKmode\t\t\t\t\t\t\t\\\n- ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n- : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\t\\\n-    (CUM) = 16;\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    (CUM) += A29K_ARG_SIZE (MODE, TYPE, NAMED)\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n-\n-   On 29k the first 16 words of args are normally in registers\n-   and the rest are pushed.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-((CUM) < 16 && (NAMED) && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\\\n- ? gen_rtx_REG ((MODE), R_LR (2) + (CUM)) : 0)\n-\n-/* Define where a function finds its arguments.\n-   This is different from FUNCTION_ARG because of register windows.\n-\n-   On the 29k, we hack this to call a function that sets the used registers\n-   as non-fixed and not used by calls.  */\n-\n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-((CUM) < 16 && (NAMED) && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\t\\\n- ? gen_rtx_REG (MODE,\t\t\t\t\t\t\t\\\n-\t\tincoming_reg (CUM, A29K_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n- : 0)\n-\n-/* This indicates that an argument is to be passed with an invisible reference\n-   (i.e., a pointer to the object is passed).\n-\n-   On the 29k, we do this if it must be passed on the stack.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n-  (MUST_PASS_IN_STACK (MODE, TYPE))\n-\n-/* Specify the padding direction of arguments.\n-\n-   On the 29k, we must pad upwards in order to be able to pass args in\n-   registers.  */\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\tupward\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n-((CUM) < 16 && 16 < (CUM) + A29K_ARG_SIZE (MODE, TYPE, NAMED) && (NAMED) \\\n- ? 16 - (CUM) : 0)\n-\n-/* Perform any needed actions needed for a function that is receiving a\n-   variable number of arguments. \n-\n-   CUM is as above.\n-\n-   MODE and TYPE are the mode and type of the current parameter.\n-\n-   PRETEND_SIZE is a variable that should be set to the amount of stack\n-   that must be pushed by the prolog to pretend that our caller pushed\n-   it.\n-\n-   Normally, this macro will push all remaining incoming registers on the\n-   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n-\n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n-{ if ((CUM) < 16)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int first_reg_offset = (CUM);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n-\tfirst_reg_offset += A29K_ARG_SIZE (TYPE_MODE (TYPE), TYPE, 1);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (first_reg_offset > 16)\t\t\t\t\t\\\n-\tfirst_reg_offset = 16;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (! (NO_RTL) && first_reg_offset != 16)\t\t\t\t\\\n-\tmove_block_from_reg\t\t\t\t\t\t\\\n-\t  (R_AR (0) + first_reg_offset,\t\t\t\t\t\\\n-\t   gen_rtx_MEM (BLKmode, virtual_incoming_args_rtx),\t\t\\\n-\t   16 - first_reg_offset, (16 - first_reg_offset) * UNITS_PER_WORD); \\\n-      PRETEND_SIZE = (16 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-\n-extern struct rtx_def *a29k_compare_op0, *a29k_compare_op1;\n-extern int a29k_compare_fp_p;\n-\n-/* This macro produces the initial definition of a function name.\n-\n-   For the 29k, we need the prolog to contain one or two words prior to\n-   the declaration of the function name.  So just store away the name and\n-   write it as part of the prolog.  This also computes the register names,\n-   which can't be done until after register allocation, but must be done\n-   before final_start_function is called.  */\n-\n-extern const char *a29k_function_name;\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n-  a29k_function_name = NAME; \\\n-  a29k_compute_reg_names ();\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/* Define the number of delay slots needed for the function epilogue.\n-\n-   On the 29k, we need a slot except when we have a register stack adjustment,\n-   have a memory stack adjustment, and have no frame pointer.  */\n-\n-#define DELAY_SLOTS_FOR_EPILOGUE \t\t\t\t\t\\\n-  (! (needs_regstack_p ()\t\t\t\t\t\t\\\n-      && (get_frame_size () + current_function_pretend_args_size\t\\\n-\t   + current_function_outgoing_args_size) != 0\t\t\t\\\n-      && ! frame_pointer_needed))\n-\n-/* Define whether INSN can be placed in delay slot N for the epilogue.\n-\n-   On the 29k, we must be able to place it in a delay slot, it must\n-   not use sp if the frame pointer cannot be eliminated, and it cannot\n-   use local regs if we need to push the register stack.\n-   If this is a SET with a memory as source, it might load from\n-   a stack slot, unless the address is constant.  */\n-\n-#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN,N)\t\t\t\t\\\n-  (get_attr_in_delay_slot (INSN) == IN_DELAY_SLOT_YES\t\t\t\\\n-   && ! (frame_pointer_needed\t\t\t\t\t\t\\\n-\t && reg_mentioned_p (stack_pointer_rtx, PATTERN (INSN)))\t\\\n-   && ! (needs_regstack_p () && uses_local_reg_p (PATTERN (INSN)))\t\\\n-   && (GET_CODE (PATTERN (INSN)) != SET\t\t\t\t\t\\\n-       || GET_CODE (SET_SRC (PATTERN (INSN))) != MEM\t\t\t\\\n-       || ! rtx_varies_p (XEXP (SET_SRC (PATTERN (INSN)), 0), 0)))\n-\f\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.\n-\n-   The trampoline should set the static chain pointer to value placed\n-   into the trampoline and should branch to the specified routine.  We\n-   use gr121 (tav) as a temporary.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tconst %s,0\\n\", reg_names[R_TAV]);\t\\\n-  fprintf (FILE, \"\\tconsth %s,0\\n\", reg_names[R_TAV]);\t\\\n-  fprintf (FILE, \"\\tconst %s,0\\n\", reg_names[R_SLP]);\t\\\n-  fprintf (FILE, \"\\tjmpi %s\\n\", reg_names[R_TAV]);\t\\\n-  fprintf (FILE, \"\\tconsth %s,0\\n\", reg_names[R_SLP]);\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE    20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.\n-\n-   We do this on the 29k by writing the bytes of the addresses into the\n-   trampoline one byte at a time.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  INITIALIZE_TRAMPOLINE_VALUE (TRAMP, FNADDR, 0, 4);\t\t\t\\\n-  INITIALIZE_TRAMPOLINE_VALUE (TRAMP, CXT, 8, 16);\t\t\t\\\n-}\n-\n-/* Define a sub-macro to initialize one value into the trampoline.\n-   We specify the offsets of the CONST and CONSTH instructions, respectively\n-   and copy the value a byte at a time into these instructions.  */\n-\n-#define INITIALIZE_TRAMPOLINE_VALUE(TRAMP, VALUE, CONST, CONSTH)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx _addr, _temp;\t\t\t\t\t\t\t\\\n-  rtx _val = force_reg (SImode, VALUE);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  _addr = memory_address (QImode, plus_constant (TRAMP, (CONST) + 3));\t\\\n-  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n-\t\t  gen_lowpart (QImode, _val));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  _temp = expand_shift (RSHIFT_EXPR, SImode, _val,\t\t\t\\\n-\t\t       build_int_2 (8, 0), 0, 1);\t\t\t\\\n-  _addr = memory_address (QImode, plus_constant (TRAMP, (CONST) + 1));\t\\\n-  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n-\t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  _temp = expand_shift (RSHIFT_EXPR, SImode, _temp,\t\t\t\\\n-\t\t       build_int_2 (8, 0), _temp, 1);\t\t\t\\\n-  _addr = memory_address (QImode, plus_constant (TRAMP, (CONSTH) + 3));\t\\\n-  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n-\t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  _temp = expand_shift (RSHIFT_EXPR, SImode, _temp,\t\t\t\\\n-\t\t       build_int_2 (8, 0), _temp, 1);\t\t\t\\\n-  _addr = memory_address (QImode, plus_constant (TRAMP, (CONSTH) + 1));\t\\\n-  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n-\t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n-}\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* #define HAVE_POST_INCREMENT 0 */\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-/* #define HAVE_PRE_DECREMENT 0 */\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n-#define REGNO_OK_FOR_BASE_P(REGNO) 1\n-\n-/* Given the value returned from get_frame_size, compute the actual size\n-   of the frame we will allocate.   We include the pretend and outgoing\n-   arg sizes and round to a doubleword.  */\n-\n-#define ACTUAL_FRAME_SIZE(SIZE)\t\t\t\t\\\n-  (((SIZE) + current_function_pretend_args_size\t\t\\\n-    + current_function_outgoing_args_size + 7) & ~7)\n-\n-/* Define the initial offset between the frame and stack pointer.  */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\\\n-  (DEPTH) = ACTUAL_FRAME_SIZE (get_frame_size ())\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)  \\\n-(GET_CODE (X) == CONST_INT && (unsigned) INTVAL (X) < 0x100)\n-\n-/* Include all constant integers and constant doubles */\n-#define LEGITIMATE_CONSTANT_P(X)\t1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) 0\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)  1\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the 29k, a legitimate address is a register and so is a\n-   constant of less than 256.  */\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-  if (GET_CODE (X) == CONST_INT\t\t\t\\\n-      && (unsigned) INTVAL (X) < 0x100)\t\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-}\n-\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the 29k, we need not do anything.  However, if we don't,\n-   `memory_address' will try lots of things to get a valid address, most of\n-   which will result in dead code and extra pseudos.  So we make the address\n-   valid here.\n-\n-   This is easy:  The only valid addresses are an offset from a register\n-   and we know the address isn't valid.  So just call either `force_operand'\n-   or `force_reg' unless this is a (plus (reg ...) (const_int 0)).  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{ if (GET_CODE (X) == PLUS && XEXP (X, 1) == const0_rtx)\t\\\n-    X = XEXP (x, 0);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == MULT || GET_CODE (X) == PLUS)\t\t\\\n-    X = force_operand (X, 0);\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    X = force_reg (Pmode, X);\t\t\t\t\t\\\n-  goto WIN;\t\t\t\t\t\t\t\\\n-}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the 29k this is never true.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\n-/* Compute the cost of an address.  For the 29k, all valid addresses are\n-   the same cost.  */\n-\n-#define ADDRESS_COST(X)  0\n-\n-/* Define this if some processing needs to be done immediately before\n-   emitting code for an insn.  */\n-\n-/* #define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS) */\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* This flag, if defined, says the same insns that convert to a signed fixnum\n-   also convert validly to an unsigned one.\n-\n-   We actually lie a bit here as overflow conditions are different.  But\n-   they aren't being checked anyway.  */\n-\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* Max number of bytes we can move to of from memory\n-   in one reasonably fast instruction.\n-\n-   For the 29k, we will define movti, so put this at 4 words.  */\n-#define MOVE_MAX 16\n-\n-/* Largest number of bytes of an object that can be placed in a register.\n-   On the 29k we have plenty of registers, so use TImode.  */\n-#define MAX_FIXED_MODE_SIZE\tGET_MODE_BITSIZE (TImode)\n-\n-/* Nonzero if access to memory by bytes is no faster than for words.\n-   Also non-zero if doing byte operations (specifically shifts) in registers\n-   is undesirable. \n-\n-   On the 29k, large masks are expensive, so we want to use bytes to\n-   manipulate fields.  */\n-#define SLOW_BYTE_ACCESS\t0\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n-   will either zero-extend or sign-extend.  The value of this macro should\n-   be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-/* Define if the object format being used is COFF or a superset.  */\n-#define OBJECT_FORMAT_COFF\n-\n-/* This uses COFF, so it wants SDB format.  */\n-#define SDB_DEBUGGING_INFO\n-\n-/* Define this to be the delimiter between SDB sub-sections.  The default\n-   is \";\".  */\n-#define SDB_DELIM\t\"\\n\"\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* Don't try to use the `x' type-cross-reference character in DBX data.\n-   Also has the consequence of putting each struct, union or enum\n-   into a separate .stabs, containing only cross-refs to the others.  */\n-#define DBX_NO_XREFS\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* We assume that the store-condition-codes instructions store 0 for false\n-   and some other value for true.  This is the value stored for true, which\n-   is just the sign bit.  */\n-\n-#define STORE_FLAG_VALUE (-2147483647 - 1)\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* Mode of a function address in a call instruction (for indexing purposes).\n-\n-   Doesn't matter on 29k.  */\n-#define FUNCTION_MODE SImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits.  */\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.\n-\n-   We only care about the cost if it is valid in an insn.  The only\n-   constants that cause an insn to generate more than one machine\n-   instruction are those involving floating-point or address.  So \n-   only these need be expensive.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    return 0;\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 6;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return GET_MODE (RTX) == SFmode ? 6 : 8;\n-    \n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.\n-\n-   All MEMs cost the same if they are valid.  This is used to ensure\n-   that (mem (symbol_ref ...)) is placed into a CALL when valid.\n-\n-   The multiply cost depends on whether this is a 29050 or not.  */\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return TARGET_29050 ? COSTS_N_INSNS (2) : COSTS_N_INSNS (40);  \\\n-  case DIV:\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (50);\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n-{ const char *p, *after_dir = main_input_filename;\t\t\\\n-  if (TARGET_29050)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.cputype 29050\\n\");\t\t\t\\\n-  for (p = main_input_filename; *p; p++)\t\t\t\\\n-    if (*p == '/')\t\t\t\t\t\t\\\n-      after_dir = p + 1;\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.file \");\t\t\t\t\t\\\n-  output_quoted_string (FILE, after_dir);\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.sect .lit,lit\\n\"); }\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n-\n-/* The next few macros don't have tabs on most machines, but\n-   at least one 29K assembler wants them.  */\n-\n-/* Output before instructions.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before read-only data.  */\n-\n-#define READONLY_DATA_SECTION_ASM_OP \"\\t.use .lit\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"gr96\", \"gr97\", \"gr98\", \"gr99\", \"gr100\", \"gr101\", \"gr102\", \"gr103\", \"gr104\", \\\n- \"gr105\", \"gr106\", \"gr107\", \"gr108\", \"gr109\", \"gr110\", \"gr111\", \"gr112\", \\\n- \"gr113\", \"gr114\", \"gr115\", \"gr116\", \"gr117\", \"gr118\", \"gr119\", \"gr120\", \\\n- \"gr121\", \"gr122\", \"gr123\", \"gr124\", \"gr125\", \"gr126\", \"gr127\",\t\t \\\n- \"lr0\", \"lr1\", \"lr2\", \"lr3\", \"lr4\", \"lr5\", \"lr6\", \"lr7\", \"lr8\", \"lr9\",   \\\n- \"lr10\", \"lr11\", \"lr12\", \"lr13\", \"lr14\", \"lr15\", \"lr16\", \"lr17\", \"lr18\", \\\n- \"lr19\", \"lr20\", \"lr21\", \"lr22\", \"lr23\", \"lr24\", \"lr25\", \"lr26\", \"lr27\", \\\n- \"lr28\", \"lr29\", \"lr30\", \"lr31\", \"lr32\", \"lr33\", \"lr34\", \"lr35\", \"lr36\", \\\n- \"lr37\", \"lr38\", \"lr39\", \"lr40\", \"lr41\", \"lr42\", \"lr43\", \"lr44\", \"lr45\", \\\n- \"lr46\", \"lr47\", \"lr48\", \"lr49\", \"lr50\", \"lr51\", \"lr52\", \"lr53\", \"lr54\", \\\n- \"lr55\", \"lr56\", \"lr57\", \"lr58\", \"lr59\", \"lr60\", \"lr61\", \"lr62\", \"lr63\", \\\n- \"lr64\", \"lr65\", \"lr66\", \"lr67\", \"lr68\", \"lr69\", \"lr70\", \"lr71\", \"lr72\", \\\n- \"lr73\", \"lr74\", \"lr75\", \"lr76\", \"lr77\", \"lr78\", \"lr79\", \"lr80\", \"lr81\", \\\n- \"lr82\", \"lr83\", \"lr84\", \"lr85\", \"lr86\", \"lr87\", \"lr88\", \"lr89\", \"lr90\", \\\n- \"lr91\", \"lr92\", \"lr93\", \"lr94\", \"lr95\", \"lr96\", \"lr97\", \"lr98\", \"lr99\", \\\n- \"lr100\", \"lr101\", \"lr102\", \"lr103\", \"lr104\", \"lr105\", \"lr106\", \"lr107\", \\\n- \"lr108\", \"lr109\", \"lr110\", \"lr111\", \"lr112\", \"lr113\", \"lr114\", \"lr115\", \\\n- \"lr116\", \"lr117\", \"lr118\", \"lr119\", \"lr120\", \"lr121\", \"lr122\", \"lr123\", \\\n- \"lr124\", \"lr125\", \"lr126\", \"lr127\",\t\t\t\t\t \\\n-  \"AI0\", \"AI1\", \"AI2\", \"AI3\", \"AI4\", \"AI5\", \"AI6\", \"AI7\", \"AI8\", \"AI9\",  \\\n-  \"AI10\", \"AI11\", \"AI12\", \"AI13\", \"AI14\", \"AI15\", \"FP\",\t\t\t \\\n-  \"bp\", \"fc\", \"cr\", \"q\",\t\t\t\t\t\t \\\n-  \"vab\", \"ops\", \"cps\", \"cfg\", \"cha\", \"chd\", \"chc\", \"rbp\", \"tmc\", \"tmr\",\t \\\n-  \"pc0\", \"pc1\", \"pc2\", \"mmu\", \"lru\", \"fpe\", \"int\", \"fps\", \"exo\",\t \\\n-  \"0\", \"1\", \"2\", \"3\",\t\t\t\t\t\t\t \\\n-  \"gr64\", \"gr65\", \"gr66\", \"gr67\", \"gr68\", \"gr69\", \"gr70\", \"gr71\",\t \\\n-  \"gr72\", \"gr73\", \"gr74\", \"gr75\", \"gr76\", \"gr77\", \"gr78\", \"gr79\",\t \\\n-  \"gr80\", \"gr81\", \"gr82\", \"gr83\", \"gr84\", \"gr85\", \"gr86\", \"gr87\",\t \\\n-  \"gr88\", \"gr89\", \"gr90\", \"gr91\", \"gr92\", \"gr93\", \"gr94\", \"gr95\" }\n-\n-/* How to renumber registers for dbx and gdb.  */\n-\n-extern int a29k_debug_reg_map[FIRST_PSEUDO_REGISTER];\n-#define DBX_REGISTER_NUMBER(REGNO) a29k_debug_reg_map[REGNO]\n-\n-/* Switch into a generic section.  */\n-#define TARGET_ASM_NAMED_SECTION a29k_asm_named_section\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n-\n-/* This is how to output a label for a jump table.  Arguments are the same as\n-   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n-   passed.  */\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n-{ ASM_OUTPUT_ALIGN (FILE, 2); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tsub %s,%s,4\\n\\tstore 0,0,%s,%s\\n\",\t\t\t\\\n-           reg_names[R_MSP], reg_names[R_MSP], reg_names[REGNO],\t\\\n-\t   reg_names[R_MSP]);\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tload 0,0,%s,%s\\n\\tadd %s,%s,4\\n\",\t\t\t\\\n-           reg_names[REGNO], reg_names[R_MSP], reg_names[R_MSP],\t\\\n-\t   reg_names[R_MSP]);\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.\n-   Don't define this if it is not supported.  */\n-\n-/* #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) */\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.block %d\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d\\n\", (SIZE)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n-( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\t\\\n-  fprintf ((FILE), \",%d\\n\", (SIZE)))\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n-\n-/* Determine which codes are valid without a following integer.  These must\n-   not be alphabetic.\n-\n-   We support `#' which is null if a delay slot exists, otherwise\n-   \"\\n\\tnop\" and `*' which prints the register name for TPC (gr122).  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#' || (CODE) == '*')\n-\f\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx addr = ADDR;\t\t\t\t\t\\\n-  if (!REG_P (addr)\t\t\t\t\t\t\\\n-      && ! (GET_CODE (addr) == CONST_INT\t\t\t\\\n-\t    && INTVAL (addr) >= 0 && INTVAL (addr) < 256))\t\\\n-    abort ();\t\t\t\t\t\t\t\\\n-  output_operand (addr, 0);\t\t\t\t\t\\\n-}\n-/* Define the codes that are matched by predicates in a29k.c.  */\n-\n-#define PREDICATE_CODES \\\n-  {\"cint_8_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"cint_16_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"long_const_operand\", {CONST_INT, CONST, CONST_DOUBLE,\t\\\n-\t\t\t  LABEL_REF, SYMBOL_REF}},\t\t\\\n-  {\"const_0_operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n-  {\"const_8_operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n-  {\"const_16_operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n-  {\"const_24_operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n-  {\"float_const_operand\", {CONST_DOUBLE}},\t\t\t\\\n-  {\"gpc_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"gpc_reg_or_float_constant_operand\", {SUBREG, REG, CONST_DOUBLE}}, \\\n-  {\"gpc_reg_or_integer_constant_operand\", {SUBREG, REG,\t\t\\\n-\t\t\t\t\t   CONST_INT, CONST_DOUBLE}}, \\\n-  {\"gpc_reg_or_immediate_operand\", {SUBREG, REG, CONST_INT,\t\\\n-\t\t\t\t    CONST_DOUBLE, CONST,\t\\\n-\t\t\t\t    SYMBOL_REF, LABEL_REF}},\t\\\n-  {\"spec_reg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"accum_reg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"srcb_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"cmplsrcb_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"reg_or_immediate_operand\", {SUBREG, REG, CONST_INT, CONST,\t\\\n-\t\t\t\tCONST_DOUBLE, CONST, SYMBOL_REF, LABEL_REF}}, \\\n-  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"call_operand\", {SYMBOL_REF, CONST_INT}},\t\t\t\\\n-  {\"in_operand\", {SUBREG, MEM, REG, CONST_INT, CONST, SYMBOL_REF, \\\n-\t\t  LABEL_REF, CONST_DOUBLE}},\t\t\t\\\n-  {\"out_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"reload_memory_operand\", {SUBREG, REG, MEM}},\t\t\\\n-  {\"fp_comparison_operator\", {EQ, GT, GE}},\t\t\t\\\n-  {\"branch_operator\", {GE, LT}},\t\t\t\t\\\n-  {\"load_multiple_operation\", {PARALLEL}},\t\t\t\\\n-  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\\\n-  {\"epilogue_operand\", {CODE_LABEL}},"}, {"sha": "d4e4f34595f245ef3f306f33f2d5fecf41aa263e", "filename": "gcc/config/a29k/a29k.md", "status": "removed", "additions": 0, "deletions": 2875, "changes": 2875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fa29k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.md?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,2875 +0,0 @@\n-;;- Machine description for AMD Am29000 for GNU C compiler\n-;;   Copyright (C) 1991, 1992, 1994, 1998, 1999, 2001\n-;;   Free Software Foundation, Inc.\n-;;   Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;; The insns in this file are presented in the same order as the AMD 29000\n-;; User's Manual (i.e., alphabetical by machine op-code).\n-;;\n-;; DEFINE_EXPAND's are located near the first occurrence of the major insn\n-;; that they generate.\n-\f\n-;; The only attribute we have is the type.  We only care about calls, branches,\n-;; loads, stores, floating-point operations, and multi-word insns.\n-;; Everything else is miscellaneous.\n-\n-(define_attr \"type\"\n-  \"call,branch,load,store,fadd,fmul,fam,fdiv,fsqrt,dmul,dam,ddiv,dsqrt,multi,misc\"\n-  (const_string \"misc\"))\n-\n-;; ASM insns cannot go into a delay slot, so call them \"multi\".\n-(define_asm_attributes [(set_attr \"type\" \"multi\")])\n-\n-(define_attr \"in_delay_slot\" \"yes,no\"\n-  (if_then_else (eq_attr \"type\" \"call,branch,multi\")  (const_string \"no\")\n-\t\t(const_string \"yes\")))\n-\n-;; Branch and call insns require a single delay slot.  Annulling is not\n-;; supported.\n-(define_delay (eq_attr \"type\" \"call,branch\")\n-  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n-\n-;; Define the function unit usages.  We first define memory as a unit.\n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load\") 6 5\n-  [(eq_attr \"type\" \"load\")])\n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load\") 6 6\n-  [(eq_attr \"type\" \"store\")])\n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"store\") 1 0)\n-\n-;; Now define the function units for the floating-point support.  Most\n-;; units are pipelined and can accept an input every cycle.\n-;;\n-;; Note that we have an inaccuracy here.  If a fmac insn is issued, followed\n-;; 2 cycles later by a fadd, there will be a conflict for the floating\n-;; adder that we can't represent.  Also, all insns will conflict for the\n-;; floating-point rounder.  It isn't clear how to represent this.\n-\n-(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"fmul\") 3 0)\n-(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"dmul\") 6 4)\n-(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"fam\") 6 0)\n-(define_function_unit \"multiplier\" 1 0 (eq_attr \"type\" \"dam\") 9 4)\n-\n-(define_function_unit \"adder\" 1 0 (eq_attr \"type\" \"fadd,fam,dam\") 3 0)\n-\n-(define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"fdiv\") 11 10)\n-(define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"fsqrt\") 28 27)\n-(define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"ddiv\") 18 17)\n-(define_function_unit \"divider\" 1 0 (eq_attr \"type\" \"dsqrt\") 57 56)\n-\f\n-;; ADD\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t (match_operand:SI 2 \"add_operand\" \"rI,N\")))]\n-  \"\"\n-  \"@\n-   add %0,%1,%2\n-   sub %0,%1,%n2\")\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"add %L0,%L1,%L2\\;addc %0,%1,%2\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-;; AND/ANDN\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"rI,K\")))]\n-  \"\"\n-  \"@\n-   and %0,%1,%2\n-   andn %0,%1,%C2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t(match_operand:SI 2 \"cmplsrcb_operand\" \"r,K\")))]\n-  \"\"\n-  \"@\n-   andn %0,%2,%1\n-   nor %0,%1,%C2\")\n-\f\n-;; CALLI\n-;;\n-;; Each call pattern is duplicated so that we can add CLOBBERs to the\n-;; resulting insn.\n-;;\n-;; We indicate that LR0 is clobbered in the CALL_INSN itself.  Otherwise,\n-;; reorg will think it is just clobbered by the called function.\n-\n-(define_expand \"call\"\n-  [(use (match_operand:SI 0 \"\" \"\"))\n-   (use (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))]\n-  \"\"\n-  \"\n-{ rtx insn = emit_call_insn (gen_call_internal (operands[0], operands[1]));\n-  a29k_clobbers_to (insn, operands[2]);\n-\n-  DONE;\n-}\")\n- \n-(define_expand \"call_internal\"\n-  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n-\t\t    (match_operand 1 \"\" \"\"))\n-\t      (clobber (scratch:SI))])]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n-\n-  /* We tell here whether this is a recursive call, since this insn may\n-     later be inlined into another function.  */\n-  if (! TARGET_SMALL_MEMORY\n-      && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n-    operands[0] = gen_rtx_MEM (SImode,\n-\t\t\t       force_reg (Pmode, XEXP (operands[0], 0)));\n-}\")\n- \n-(define_expand \"call_value\"\n-  [(use (match_operand:SI 0 \"gpc_reg_operand\" \"\"))\n-   (use (match_operand:SI 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))\n-   (use (match_operand 3 \"\" \"\"))]\n-  \"\"\n-  \"\n-{ rtx insn = emit_call_insn (gen_call_value_internal (operands[0], operands[1],\n-\t\t\t\t\t\t      operands[2]));\n-\n-  a29k_clobbers_to (insn, operands[3]);\n-  DONE;\n-}\")\n- \n-(define_expand \"call_value_internal\"\n-  [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t   (call (match_operand:SI 1 \"\" \"\")\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t\t   (clobber (scratch:SI))])]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n-\n-  /* We tell here whether this is a recursive call, since this insn may\n-     later be inlined into another function.  */\n-  if (! TARGET_SMALL_MEMORY\n-      && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n-    operands[1] = gen_rtx_MEM (SImode,\n-\t\t\t       force_reg (Pmode, XEXP (operands[1], 0)));\n-}\")\n- \n-(define_insn \"\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (match_scratch:SI 2 \"=&l\"))]\n-  \"GET_CODE (XEXP (operands[0], 0)) != CONST_INT\"\n-  \"calli lr0,%0%#\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"i\"))\n-\t (match_operand:SI 1 \"general_operand\" \"g\"))\n-   (clobber (match_scratch:SI 2 \"=&l\"))]\n-  \"\"\n-  \"call lr0,%F0\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (match_scratch:SI 3 \"=&l\"))]\n-  \"GET_CODE (XEXP (operands[1], 0)) != CONST_INT\"\n-  \"calli lr0,%1%#\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"i\"))\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))\n-   (clobber (match_scratch:SI 3 \"=&l\"))]\n-  \"\"\n-  \"call lr0,%F1\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_expand \"probe\"\n-  [(call (mem:SI (symbol_ref:SI \"_msp_check\"))\n-\t (const_int 1))]\n-  \"TARGET_STACK_CHECK\"\n-  \"\")\n-\n-;; This is used for internal routine calls via TPC.  Currently used only\n-;; in probe, above.\n-(define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"immediate_operand\" \"s\"))\n-\t (const_int 1))]\n-  \"\"\n-  \"call %*,%0\"\n-  [(set_attr \"type\" \"call\")])\n-\f\n-;; CONST, CONSTH, CONSTN\n-;;\n-;; Many of these are generated from move insns.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"immediate_operand\" \"i\")\n-\t\t(const_int 65535)))]\n-  \"\"\n-  \"const %0,%1\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (const_int 16)\n-\t\t\t (match_operand:SI 1 \"const_0_operand\" \"\"))\n-\t(ashiftrt:SI (match_operand:SI 2 \"immediate_operand\" \"i\")\n-\t\t     (const_int 16)))]\n-  \"\"\n-  \"consth %0,%2\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (const_int 16)\n-\t\t\t (match_operand:SI 1 \"const_0_operand\" \"\"))\n-\t(match_operand:SI 2 \"cint_16_operand\" \"J\"))]\n-  \"\"\n-  \"consth %0,%m2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (zero_extend:SI (match_operand:HI 1 \"gpc_reg_operand\" \"0\"))\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(INTVAL (operands[2]) & 0xffff) == 0\"\n-  \"consth %0,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (zero_extend:SI (match_operand:HI 1 \"gpc_reg_operand\" \"0\"))\n-\t\t(and:SI (match_operand:SI 2 \"immediate_operand\" \"i\")\n-\t\t\t(const_int -65536))))]\n-  \"\"\n-  \"consth %0,%2\")\n-\f\n-;; CONVERT\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,0,3,0,1\")\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(fix:SI (match_operand:DF 1 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,0,3,0,2\")\n-\n-(define_insn \"fixuns_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unsigned_fix:SI (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,1,3,0,1\")\n-\n-(define_insn \"fixuns_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unsigned_fix:SI (match_operand:DF 1 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,1,3,0,2\")\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,0,4,1,2\")\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,0,4,2,1\")\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(float:SF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,0,4,1,0\")\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,0,4,2,0\")\n-\n-(define_insn \"floatunssisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(unsigned_float:SF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,1,4,1,0\")\n-\n-(define_insn \"floatunssidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"convert %0,%1,1,4,2,0\")\n-\f\n-;; CPxxx, DEQ, DGT, DGE, FEQ, FGT, FGE\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operator:SI 3 \"comparison_operator\"\n-\t\t\t[(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"srcb_operand\" \"rI\")]))]\n-  \"\"\n-  \"cp%J3 %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operator:SI 3 \"fp_comparison_operator\"\n-\t\t\t[(match_operand:SF 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SF 2 \"register_operand\" \"r\")]))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"f%J3 %0,%1,%2\"\n-  [(set_attr \"type\" \"fadd\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operator:SI 3 \"fp_comparison_operator\"\n-\t\t\t[(match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:DF 2 \"register_operand\" \"r\")]))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"d%J3 %0,%1,%2\"\n-  [(set_attr \"type\" \"fadd\")])\n-\f\n-;; DADD\n-(define_expand \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_29050 \"\n-  \"dadd %0,%1,%2\"\n-  [(set_attr \"type\" \"fadd\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r,a\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r,0\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   dadd %0,%1,%2\n-   dmac 8,%0,%1,%1\"\n-  [(set_attr \"type\" \"fadd,dam\")])\n-\n-;; DDIV\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"=r\")\n-\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"ddiv %0,%1,%2\"\n-  [(set_attr \"type\" \"ddiv\")])\n-\f\n-;; DIVIDE\n-;;\n-;; We must set Q to the sign extension of the dividend first.  For MOD, we\n-;; must get the remainder from Q.\n-;;\n-;; For divmod: operand 1 is divided by operand 2; quotient goes to operand\n-;; 0 and remainder to operand 3.\n-(define_expand \"divmodsi4\"\n-  [(set (match_dup 4)\n-\t(ashiftrt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t     (const_int 31)))\n-   (parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t   (div:SI (match_dup 1)\n-\t\t\t   (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n-\t      (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-\t\t   (mod:SI (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-\t      (use (match_dup 4))])]\n-  \"\"\n-  \"\n-{\n-  operands[4] = gen_reg_rtx (SImode);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=q\")\n-\t(mod:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (use (match_operand:SI 4 \"register_operand\" \"3\"))]\n-  \"\"\n-  \"divide %0,%1,%2\")\n-\f\n-;; DIVIDU\n-;;\n-;; Similar to DIVIDE.\n-(define_expand \"udivmodsi4\"\n-  [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t   (udiv:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"\")))\n-\t      (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n-\t\t   (umod:SI (match_dup 1)\n-\t\t\t    (match_dup 2)))\n-\t      (use (const_int 0))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(udiv:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=q\")\n-\t(umod:SI (match_dup 1)\n-\t\t (match_dup 2)))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"3\"))]\n-  \"\"\n-  \"dividu %0,%1,%2\")\n-\f\n-;; DMAC/DMSM\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a,*r\")\n-\t(plus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"%r,A\")\n-\t\t\t  (match_operand:DF 2 \"register_operand\" \"r,r\"))\n-\t\t (match_operand:DF 3 \"register_operand\" \"0,*r\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   dmac 0,%0,%1,%2\n-   dmsm %0,%2,%3\"\n-  [(set_attr \"type\" \"dam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n-\t(plus:DF (mult:DF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))\n-\t\t\t  (match_operand:DF 2 \"register_operand\" \"r\"))\n-\t\t (match_operand:DF 3 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"dmac 1,%0,%2,%1\"\n-  [(set_attr \"type\" \"dam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n-\t(minus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n-\t\t\t   (match_operand:DF 2 \"register_operand\" \"r\"))\n-\t\t  (match_operand:DF 3 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"dmac 2,%0,%1,%2\"\n-  [(set_attr \"type\" \"dam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n-\t(minus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t\t   (neg:DF (match_operand:DF 2 \"register_operand\" \"r\")))\n-\t\t  (match_operand:DF 3 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"dmac 3,%0,%1,%2\"\n-  [(set_attr \"type\" \"dam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n-\t(mult:DF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"TARGET_29050\"\n-  \"dmac 5,%0,%2,%1\"\n-  [(set_attr \"type\" \"dam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n-\t(minus:DF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))\n-\t\t  (match_operand:DF 2 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"dmac 11,%0,%1,%1\"\n-  [(set_attr \"type\" \"dam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n-\t(neg:DF (plus:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n-\t\t\t (match_operand:DF 2 \"register_operand\" \"0\"))))]\n-  \"TARGET_29050\"\n-  \"dmac 11,%0,%1,%1\"\n-  [(set_attr \"type\" \"dam\")])\n-\n-(define_insn \"\"\n- [(set (match_operand:DF 0 \"register_operand\" \"=r,r,a\")\n-       (neg:DF (match_operand:DF 1 \"register_operand\" \"0,r,r\")))\n-  (clobber (match_scratch:SI 2 \"=&r,&r,X\"))]\n- \"TARGET_29050\"\n- \"@\n-  cpeq %2,gr1,gr1\\;xor %0,%1,%2\n-  cpeq %2,gr1,gr1\\;xor %0,%1,%2\\;sll %L0,%L1,0\n-  dmac 13,%0,%1,%1\"\n- [(set_attr \"type\" \"multi,multi,dam\")])\n-\n-;; DMUL\n-(define_expand \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_29050\"\n-  \"dmul %0,%1,%2\"\n-  [(set_attr \"type\" \"dmul\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r,a\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r,r\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   dmul %0,%1,%2\n-   dmac 4,%0,%1,%2\"\n-  [(set_attr \"type\" \"dmul,dam\")])\n-\n-;; DSUB\n-(define_expand \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_29050\"\n-  \"dsub %0,%1,%2\"\n-  [(set_attr \"type\" \"fadd\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r,a,a\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r,0,r\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"r,r,0\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   dsub %0,%1,%2\n-   dmac 9,%0,%2,%2\n-   dmac 10,%0,%1,%1\"\n-  [(set_attr \"type\" \"fadd,dam,dam\")])\n-\f\n-;; EXBYTE\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (match_operand:SI 1 \"srcb_operand\" \"rI\")\n-\t\t\t(const_int -256))\n-\t\t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n-\t\t\t\t (const_int 8)\n-\t\t\t\t (ashift:PSI\n-\t\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n-\t\t\t\t  (const_int 3)))))]\n-  \"\"\n-  \"exbyte %0,%2,%1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t (const_int 8)\n-\t\t\t (ashift:PSI\n-\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n-\t\t\t  (const_int 3))))]\n-  \"\"\n-  \"exbyte %0,%1,0\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (const_int 8)\n-\t\t\t (match_operand:PSI 1 \"const_24_operand\" \"\"))\n-\t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n-\t\t\t (const_int 8)\n-\t\t\t (ashift:PSI\n-\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n-\t\t\t  (const_int 3))))]\n-  \"\"\n-  \"exbyte %0,%2,%0\")\n-\n-(define_expand \"extzv\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(zero_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  int size, pos;\n-\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || GET_CODE (operands[3]) != CONST_INT)\n-    FAIL;\n-\n-  size = INTVAL (operands[2]);\n-  pos = INTVAL (operands[3]);\n-\n-  /* Can't do this unless a byte extraction.  If extracting the high\n-     or low byte, don't do this because a shift or AND is shorter.\n-     Don't do 16-bit extracts, since the only two are the high and low\n-     ends, and it is faster to do them with CONSTH and SRL.  */\n-\n-  if (size != 8 || (pos != 8 && pos != 16))\n-    FAIL;\n-\n-  operands[3] = gen_rtx_ASHIFT (PSImode,\n-\t\t\t\tforce_reg (PSImode, GEN_INT (pos / 8)),\n-\t\t\t\tGEN_INT (3));\n-\n-}\")\n-\n-;; EXHW\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI (match_operand:SI 1 \"srcb_operand\" \"rI\")\n-\t\t(const_int -65536))\n-\t\t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n-\t\t\t\t (const_int 16)\n-\t\t\t\t (ashift:PSI\n-\t\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n-\t\t\t\t  (const_int 3)))))]\n-  \"\"\n-  \"exhw %0,%2,%1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t (const_int 16)\n-\t\t\t (ashift:PSI\n-\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n-\t\t\t  (const_int 3))))]\n-  \"\"\n-  \"exhw %0,%1,0\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (const_int 16)\n-\t\t\t (match_operand:PSI 1 \"const_16_operand\" \"\"))\n-\t(zero_extract:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n-\t\t\t (const_int 16)\n-\t\t\t (ashift:PSI\n-\t\t\t  (match_operand:PSI 3 \"register_operand\" \"b\")\n-\t\t\t  (const_int 3))))]\n-  \"\"\n-  \"exhw %0,%2,%0\")\n-\n-;; EXHWS\n-;;\n-;; This is probably unused.  The high-order 16-bits are obtained with an SRA\n-;; insn.  The low-order 16 bits are a sign-extend, which is a pair of\n-;; shifts.  Setting BP followed by the insn is equivalent, so we don't\n-;; bother going to any trouble to generate this insn.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(sign_extract:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t (const_int 16)\n-\t\t\t (ashift:PSI\n-\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n-\t\t\t  (const_int 3))))]\n-  \"\"\n-  \"exhws %0,%1\")\n-\f\n-;; EXTRACT\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t   (match_operand:PSI 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"extract %0,%1,%1\")\n-\n-(define_expand \"rotlsi3\"\n-  [(set (match_dup 3)\n-\t(match_operand:SI 2 \"gpc_reg_or_immediate_operand\" \"\"))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t   (match_dup 3)))]\n-  \"\"\n-  \"\n-{ operands[2] = gen_lowpart (PSImode, operands[2]);\n-  operands[3] = gen_reg_rtx (PSImode);\n-}\")\n-\n-;; It would be nice to be able to have a define_split corresponding to the\n-;; above, but there is no way to tell combine we need a PSImode temporary.\n-;; If we put a (clobber (scratch:PSI)) there, combine would merge the above\n-;; two insns.  This is bad because it then thinks only one insn is needed.\n-\f\n-;; FADD\n-(define_expand \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_29050\"\n-  \"fadd %0,%1,%2\"\n-  [(set_attr \"type\" \"fadd\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r,a\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r,0\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   fadd %0,%1,%2\n-   fmac 8,%0,%1,%1\"\n-  [(set_attr \"type\" \"fadd,fam\")])\n-\n-;; FDIV\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"=r\")\n-\t\t(match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"fdiv %0,%1,%2\"\n-  [(set_attr \"type\" \"fdiv\")])\n-\n-;; FDMUL\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"%r\"))\n-\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"fdmul %0,%1,%2\")\n-\n-;; FMAC/FMSM\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=a,*r\")\n-\t(plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%r,A\")\n-\t\t\t  (match_operand:SF 2 \"register_operand\" \"r,r\"))\n-\t\t (match_operand:SF 3 \"register_operand\" \"0,*r\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   fmac 0,%0,%1,%2\n-   fmsm %0,%2,%3\"\n-  [(set_attr \"type\" \"fam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n-\t(plus:SF (mult:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t\t  (match_operand:SF 2 \"register_operand\" \"r\"))\n-\t\t (match_operand:SF 3 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"fmac 1,%0,%2,%1\"\n-  [(set_attr \"type\" \"fam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n-\t(minus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n-\t\t\t   (match_operand:SF 2 \"register_operand\" \"r\"))\n-\t\t  (match_operand:SF 3 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"fmac 2,%0,%1,%2\"\n-  [(set_attr \"type\" \"fam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n-\t(minus:SF (mult:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t\t   (match_operand:SF 2 \"register_operand\" \"r\"))\n-\t\t  (match_operand:SF 3 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"fmac 3,%0,%2,%1\"\n-  [(set_attr \"type\" \"fam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n-\t(mult:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"TARGET_29050\"\n-  \"fmac 5,%0,%2,%1\"\n-  [(set_attr \"type\" \"fam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n-\t(minus:SF (neg:SF (match_operand:SF 1 \"register_operand\" \"%r\"))\n-\t\t  (match_operand:SF 2 \"register_operand\" \"0\")))]\n-  \"TARGET_29050\"\n-  \"fmac 11,%0,%1,%1\"\n-  [(set_attr \"type\" \"fam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n-\t(neg:SF (plus:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n-\t\t\t (match_operand:SF 2 \"register_operand\" \"0\"))))]\n-  \"TARGET_29050\"\n-  \"fmac 11,%0,%1,%1\"\n-  [(set_attr \"type\" \"fam\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r,a\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"r,r\")))\n-   (clobber (match_scratch:SI 2 \"=&r,X\"))]\n-  \"TARGET_29050\"\n-  \"@\n-   cpeq %2,gr1,gr1\\;xor %0,%1,%2\n-   fmac 13,%0,%1,%1\"\n-  [(set_attr \"type\" \"multi,fam\")])\n-\n-;; FMUL\n-(define_expand \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_29050\"\n-  \"fmul %0,%1,%2\"\n-  [(set_attr \"type\" \"fmul\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r,a\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r,r\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   fmul %0,%1,%2\n-   fmac 4,%0,%1,%2\"\n-  [(set_attr \"type\" \"fmul,fam\")])\n-\n-;; FSUB\n-(define_expand \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t  (match_operand:SF 2 \"register_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"! TARGET_29050\"\n-  \"fsub %0,%1,%2\"\n-  [(set_attr \"type\" \"fadd\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r,a,a\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r,0,r\")\n-\t\t  (match_operand:SF 2 \"register_operand\" \"r,r,0\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   fsub %0,%1,%2\n-   fmac 9,%0,%2,%2\n-   fmac 10,%0,%1,%1\"\n-  [(set_attr \"type\" \"fadd,fam,fam\")])\n-\f\n-;; INBYTE\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (const_int 8)\n-\t\t\t (ashift:PSI\n-\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n-\t\t\t  (const_int 3)))\n-\t(match_operand:SI 1 \"srcb_operand\" \"rI\"))]\n-  \"\"\n-  \"inbyte %0,%0,%1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI\n-\t\t (not:SI\n-\t\t  (ashift:SI (const_int 255)\n-\t\t\t     (ashift:PSI\n-\t\t\t      (match_operand:PSI 3 \"register_operand\" \"b\")\n-\t\t\t      (const_int 3))))\n-\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(ashift:SI (zero_extend:SI\n-\t\t\t    (match_operand:QI 2 \"srcb_operand\" \"rI\"))\n-\t\t\t   (ashift:PSI (match_dup 3) (const_int 3)))))]\n-  \"\"\n-  \"inbyte %0,%1,%2\")\n-\n-;; INHW\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (const_int 16)\n-\t\t\t (ashift:PSI\n-\t\t\t  (match_operand:PSI 2 \"register_operand\" \"b\")\n-\t\t\t  (const_int 3)))\n-\t(match_operand:SI 1 \"srcb_operand\" \"rI\"))]\n-  \"\"\n-  \"inhw %0,%0,%1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (and:SI\n-\t\t (not:SI\n-\t\t  (ashift:SI (const_int 65535)\n-\t\t\t     (ashift:PSI\n-\t\t\t      (match_operand:PSI 3 \"register_operand\" \"b\")\n-\t\t\t      (const_int 3))))\n-\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(ashift:SI (zero_extend:SI\n-\t\t\t    (match_operand:HI 2 \"srcb_operand\" \"rI\"))\n-\t\t\t   (ashift:PSI (match_dup 3) (const_int 3)))))]\n-  \"\"\n-  \"inhw %0,%1,%2\")\n-\n-(define_expand \"insv\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\"))\n-\t(match_operand:SI 3 \"srcb_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  int size, pos;\n-\n-  if (GET_CODE (operands[1]) != CONST_INT\n-      || GET_CODE (operands[2]) != CONST_INT)\n-    FAIL;\n-\n-  size = INTVAL (operands[1]);\n-  pos = INTVAL (operands[2]);\n-  if ((size != 8 && size != 16) || pos % size != 0)\n-    FAIL;\n-\n-  operands[2] = gen_rtx_ASHIFT (PSImode,\n-\t\t\t\tforce_reg (PSImode, GEN_INT (pos / 8)),\n-\t\t\t\tGEN_INT (3));\n-}\")\n-\f\n-;; LOAD (also used by move insn).\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(mem:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(const_int -4))))\n-   (set (match_operand:PSI 2 \"register_operand\" \"=b\")\n-\t(truncate:PSI (match_dup 1)))]\n-  \"! TARGET_DW_ENABLE\"\n-  \"load 0,16,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_DW_ENABLE\"\n-  \"load 0,1,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_DW_ENABLE\"\n-  \"load 0,1,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_DW_ENABLE\"\n-  \"load 0,2,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:PSI 2 \"=&b\"))]\n-  \"TARGET_DW_ENABLE\"\n-  \"load 0,17,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:PSI 2 \"=&b\"))]\n-  \"TARGET_DW_ENABLE\"\n-  \"load 0,17,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:PSI 2 \"=&b\"))]\n-  \"TARGET_DW_ENABLE\"\n-  \"load 0,18,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\f\n-;; LOADM\n-(define_expand \"load_multiple\"\n-  [(set (match_dup 4)\n-\t(match_operand:PSI 2 \"const_int_operand\" \"\"))\n-   (match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n-\t\t\t  (match_operand:SI 1 \"\" \"\"))])]\n-  \"\"\n-  \"\n-{\n-  int regno;\n-  int count;\n-  rtx from;\n-  int i;\n-\n-  /* Support only loading a constant number of hard registers from memory.  */\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || operands[2] == const1_rtx\n-      || GET_CODE (operands[1]) != MEM\n-      || GET_CODE (operands[0]) != REG\n-      || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n-    FAIL;\n-\n-  count = INTVAL (operands[2]);\n-  regno = REGNO (operands[0]);\n-\n-  /* CR gets set to the number of registers minus one.  */\n-  operands[2] = GEN_INT(count - 1);\n-\n-  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 2));\n-  from = memory_address (SImode, XEXP (operands[1], 0));\n-  XVECEXP (operands[3], 0, 0) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t     gen_rtx_REG (SImode, regno),\n-\t\t\t\t\t     gen_rtx_MEM (SImode, from));\n-  operands[4] = gen_reg_rtx (PSImode);\n-\n-  XVECEXP (operands[3], 0, 1) = gen_rtx_USE (VOIDmode, operands[4]);\n-  XVECEXP (operands[3], 0, 2) = gen_rtx_CLOBBER (VOIDmode, operands[4]);\n-\n-  for (i = 1; i < count; i++)\n-    XVECEXP (operands[3], 0, i + 2)\n-      = gen_rtx_SET (VOIDmode, gen_rtx (REG, SImode, regno + i),\n-\t\t gen_rtx_MEM (SImode, plus_constant (from, i * 4)));\n-}\")\n-\n-;; Indicate that CR is used and is then clobbered.\n-(define_insn \"\"\n-  [(set (match_operand 0 \"gpc_reg_operand\" \"=r\")\n-\t(match_operand 1 \"memory_operand\" \"m\"))\n-   (use (match_operand:PSI 2 \"register_operand\" \"+c\"))\n-   (clobber (match_dup 2))]\n-  \"GET_MODE (operands[0]) == GET_MODE (operands[1])\n-   && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\"\n-  \"loadm 0,0,%0,%1\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"\"\n-  [(match_parallel 0 \"load_multiple_operation\"\n-\t\t   [(set (match_operand:SI 1 \"gpc_reg_operand\" \"=r\")\n-\t\t\t (match_operand:SI 2 \"memory_operand\" \"m\"))\n-\t\t    (use (match_operand:PSI 3 \"register_operand\" \"+c\"))\n-\t\t    (clobber (match_dup 3))])]\n-  \"\"\n-  \"loadm 0,0,%1,%2\"\n-  [(set_attr \"type\" \"load\")])\n-\f\n-;; MTSR (used also by move insn)\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"spec_reg_operand\" \"=*h,*h\")\n-\t(and:SI (match_operand:SI 1 \"gpc_reg_or_immediate_operand\" \"r,i\")\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"n,n\")))]\n-  \"masks_bits_for_special (operands[0], operands[2])\"\n-  \"@\n-   mtsr %0,%1\n-   mtsrim %0,%1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"register_operand\" \"=h,h\")\n-\t(truncate:PSI\n-\t (match_operand:SI 1 \"gpc_reg_or_immediate_operand\" \"r,i\")))]\n-  \"\"\n-  \"@\n-   mtsr %0,%1\n-   mtsrim %0,%1\")\n-\f\n-;; MULTIPLY, MULTM, MULTMU\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(mult:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n-   (clobber (match_scratch:SI 3 \"=&q\"))]\n-  \"\"\n-  \"multiply %0,%1,%2\")\n-\n-(define_insn \"mulsidi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t (sign_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))\n-   (clobber (match_scratch:SI 3 \"=&q\"))]\n-  \"TARGET_MULTM\"\n-  \"multiply %L0,%1,%2\\;multm %0,%1,%2\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t (sign_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"\"))))\n-   (clobber (reg:SI 180))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (mult:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:SI 180))])\n-   (parallel [(set (match_dup 4)\n-\t\t   (truncate:SI\n-\t\t    (lshiftrt:DI\n-\t\t     (mult:DI (sign_extend:DI (match_dup 1))\n-\t\t\t      (sign_extend:DI (match_dup 2)))\n-\t\t     (const_int 32))))\n-\t      (clobber (reg:SI 180))])]\n-  \"\n-{ operands[3] = operand_subword (operands[0], 1, 1, DImode);\n-  operands[4] = operand_subword (operands[0], 0, 1, DImode); } \")\n-\t\t\t    \n-(define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))\n-   (clobber (match_scratch:SI 3 \"=&q\"))]\n-  \"TARGET_MULTM\"\n-  \"multiplu %L0,%1,%2\\;multmu %0,%1,%2\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"\"))))\n-   (clobber (reg:SI 180))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (mult:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:SI 180))])\n-   (parallel [(set (match_dup 4)\n-\t\t   (truncate:SI\n-\t\t    (lshiftrt:DI\n-\t\t     (mult:DI (zero_extend:DI (match_dup 1))\n-\t\t\t      (zero_extend:DI (match_dup 2)))\n-\t\t     (const_int 32))))\n-\t      (clobber (reg:SI 180))])]\n-  \"\n-{ operands[3] = operand_subword (operands[0], 1, 1, DImode);\n-  operands[4] = operand_subword (operands[0], 0, 1, DImode); } \")\n-\t\t\t    \n-(define_insn \"smulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(truncate:SI\n-\t (lshiftrt:DI\n-\t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t   (sign_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n-\t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=&q\"))]\n-  \"TARGET_MULTM\"\n-  \"multm %0,%1,%2\")\n-\n-(define_insn \"umulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(truncate:SI\n-\t (lshiftrt:DI\n-\t  (mult:DI (zero_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t   (zero_extend:DI (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n-\t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=&q\"))]\n-  \"TARGET_MULTM\"\n-  \"multmu %0,%1,%2\")\n-\n-;; NAND\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t(not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n-  \"\"\n-  \"nand %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"K\")))]\n-  ; Match TARGET_29050 in \"orn\" pattern for slightly better reload.\n-  \"! TARGET_29050 && ((unsigned) ~ INTVAL (operands[2])) < 256\"\n-  \"nand %0,%1,%C2\")\n-\n-;; NOR\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t(not:SI (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n-  \"\"\n-  \"nor %0,%1,%2\")\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"nor %0,%1,0\")\n-\f\n-;; OR/ORN\n-(define_expand \"iorsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"srcb_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"srcb_operand\" \"rI\")))]\n-  \"! TARGET_29050\"\n-  \"or %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"rI,K\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   or %0,%1,%2\n-   orn %0,%1,%C2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\"))\n-\t\t(match_operand:SI 2 \"cmplsrcb_operand\" \"r,K\")))]\n-  \"TARGET_29050\"\n-  \"@\n-   orn %0,%2,%1\n-   nand %0,%1,%C2\")\n-\n-\f\n-;; SLL (also used by move insn)\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"aseq 0x40,gr1,gr1\")\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t   (match_operand:QI 2 \"srcb_operand\" \"rn\")))]\n-  \"\"\n-  \"sll %0,%1,%Q2\")\n-\n-;; SQRT\n-(define_insn \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n-\t(sqrt:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_29050\"\n-  \"sqrt %0,%1,1\"\n-  [(set_attr \"type\" \"fsqrt\")])\n-\n-(define_insn \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r\")\n-\t(sqrt:DF (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_29050\"\n-  \"sqrt %0,%1,2\"\n-  [(set_attr \"type\" \"dsqrt\")])\n-\n-;; SRA\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t     (match_operand:QI 2 \"srcb_operand\" \"rn\")))]\n-  \"\"\n-  \"sra %0,%1,%Q2\")\n-\n-;; SRL\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t     (match_operand:QI 2 \"srcb_operand\" \"rn\")))]\n-  \"\"\n-  \"srl %0,%1,%Q2\")\n-\f\n-;; STORE\n-;;\n-;; These somewhat bogus patterns exist to set OPT = 001/010 for partial-word\n-;; stores on systems with DW not set.\n-(define_insn \"\"\n-  [(set (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n-\t\t\t(const_int -4)))\n-\t(match_operand:SI 1 \"gpc_reg_operand\" \"r\"))]\n-  \"! TARGET_DW_ENABLE\"\n-  \"store 0,1,%1,%0\"\n-  [(set_attr \"type\" \"store\")])\n-\n-(define_insn \"\"\n-  [(set (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n-\t\t\t(const_int -3)))\n-\t(match_operand:SI 1 \"gpc_reg_operand\" \"r\"))]\n-  \"! TARGET_DW_ENABLE\"\n-  \"store 0,2,%1,%0\"\n-  [(set_attr \"type\" \"store\")])\n-\n-;; STOREM\n-(define_expand \"store_multiple\"\n-  [(use (match_operand 0 \"\" \"\"))\n-   (use (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))]\n-  \"\"\n-  \"\n-{ rtx pat;\n-\n- if (TARGET_NO_STOREM_BUG)\n-    pat = gen_store_multiple_no_bug (operands[0], operands[1], operands[2]);\n-  else\n-    pat = gen_store_multiple_bug (operands[0], operands[1], operands[2]);\n-\n-  if (pat)\n-    emit_insn (pat);\n-  else\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"store_multiple_no_bug\"\n-  [(set (match_dup 4)\n-\t(match_operand:PSI 2 \"const_int_operand\" \"\"))\n-   (match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n-\t\t\t  (match_operand:SI 1 \"\" \"\"))])]\n-  \"\"\n-  \"\n-{\n-  int regno;\n-  int count;\n-  rtx from;\n-  int i;\n-\n-  /* Support only storing a constant number of hard registers to memory.  */\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || operands[2] == const1_rtx\n-      || GET_CODE (operands[0]) != MEM\n-      || GET_CODE (operands[1]) != REG\n-      || REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-    FAIL;\n-\n-  count = INTVAL (operands[2]);\n-  regno = REGNO (operands[1]);\n-\n-  /* CR gets set to the number of registers minus one.  */\n-  operands[2] = GEN_INT(count - 1);\n-\n-  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 2));\n-  from = memory_address (SImode, XEXP (operands[0], 0));\n-  XVECEXP (operands[3], 0, 0) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t     gen_rtx_MEM (SImode, from),\n-\t\t\t\t\t     gen_rtx_REG (SImode, regno));\n-  operands[4] = gen_reg_rtx (PSImode);\n-  XVECEXP (operands[3], 0, 1) = gen_rtx_USE (VOIDmode, operands[4]);\n-  XVECEXP (operands[3], 0, 2) = gen_rtx_CLOBBER (VOIDmode, operands[4]);\n-\n-  for (i = 1; i < count; i++)\n-    XVECEXP (operands[3], 0, i + 2)\n-      = gen_rtx_SET (VOIDmode,\n-\t\t     gen_rtx_MEM (SImode, plus_constant (from, i * 4)),\n-\t\t     gen_rtx_REG (SImode, regno + i));\n-}\")\n-\n-(define_expand \"store_multiple_bug\"\n-  [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n-\t\t\t  (match_operand:SI 1 \"\" \"\"))\n-\t\t     (use (match_operand:SI 2 \"\" \"\"))])]\n-  \"\"\n-  \"\n-{\n-  int regno;\n-  int count;\n-  rtx from;\n-  int i;\n-\n-  /* Support only storing a constant number of hard registers to memory.  */\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || operands[2] == const1_rtx\n-      || GET_CODE (operands[0]) != MEM\n-      || GET_CODE (operands[1]) != REG\n-      || REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-    FAIL;\n-\n-  count = INTVAL (operands[2]);\n-  regno = REGNO (operands[1]);\n-\n-  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n-  from = memory_address (SImode, XEXP (operands[0], 0));\n-  XVECEXP (operands[3], 0, 0) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t     gen_rtx_MEM (SImode, from),\n-\t\t\t\t\t     gen_rtx_REG (SImode, regno));\n-  XVECEXP (operands[3], 0, 1)\n-    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (PSImode));\n-\n-  for (i = 1; i < count; i++)\n-    XVECEXP (operands[3], 0, i + 1)\n-      = gen_rtx_SET (VOIDmode,\n-\t\t     gen_rtx_MEM (SImode, plus_constant (from, i * 4)),\n-\t\t     gen_rtx_REG (SImode, regno + i));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand 0 \"memory_operand\" \"=m\")\n-\t(match_operand 1 \"gpc_reg_operand\" \"r\"))\n-   (clobber (match_scratch:PSI 2 \"=&c\"))]\n-  \"!TARGET_NO_STOREM_BUG\n-   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n-   && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\"\n-  \"mtsrim cr,%S1\\;storem 0,0,%1,%0\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-\t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")\n-\t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-\t\t    (clobber (match_scratch:PSI 3 \"=&c\"))])]\n-  \"!TARGET_NO_STOREM_BUG\"\n-  \"mtsrim cr,%V0\\;storem 0,0,%2,%1\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand 0 \"memory_operand\" \"=m\")\n-\t(match_operand 1 \"gpc_reg_operand\" \"r\"))\n-   (use (match_operand:PSI 2 \"register_operand\" \"+c\"))\n-   (clobber (match_dup 2))]\n-  \"TARGET_NO_STOREM_BUG\n-   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n-   && GET_MODE_SIZE (GET_MODE (operands[0])) > UNITS_PER_WORD\"\n-  \"storem 0,0,%1,%0\"\n-  [(set_attr \"type\" \"store\")])\n-\n-(define_insn \"\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n-\t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")\n-\t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n-\t\t    (use (match_operand:PSI 3 \"register_operand\" \"+c\"))\n-\t\t    (clobber (match_dup 3))])]\n-  \"TARGET_NO_STOREM_BUG\"\n-  \"storem 0,0,%2,%1\"\n-  [(set_attr \"type\" \"store\")])\n-\f\n-;; SUB\n-;;\n-;; Either operand can be a register or an 8-bit constant, but both cannot be\n-;; constants (can't usually occur anyway).\n-(define_expand \"subsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(minus:SI (match_operand:SI 1 \"srcb_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"srcb_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == CONST_INT\n-      && GET_CODE (operands[1]) == CONST_INT)\n-    operands[1] = force_reg (SImode, operands[1]);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(minus:SI (match_operand:SI 1 \"srcb_operand\" \"r,I\")\n-\t\t  (match_operand:SI 2 \"srcb_operand\" \"rI,r\")))]\n-  \"register_operand (operands[1], SImode)\n-   || register_operand (operands[2], SImode)\"\n-  \"@\n-   sub %0,%1,%2\n-   subr %0,%2,%1\")\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(minus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"sub %L0,%L1,%L2\\;subc %0,%1,%2\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-;; SUBR (also used above in SUB)\n-(define_insn \"negdi2\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"subr %L0,%L1,0\\;subrc %0,%1,0\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"subr %0,%1,0\")\n-\f\n-;; XNOR\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(not:SI (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\"))))]\n-  \"\"\n-  \"xnor %0,%1,%2\")\n-\n-;; XOR\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"rI,K\")))]\n-  \"\"\n-  \"@\n-   xor %0,%1,%2\n-   xnor %0,%1,%C2\")\n-\n-;; Can use XOR to negate floating-point values, but we are better off not doing\n-;; it that way on the 29050 so it can combine with the fmac insns.\n-(define_expand \"negsf2\"\n-  [(parallel [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t   (neg:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 2 \"\"))])]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\n-{\n-  rtx result;\n-  rtx target;\n-\n-  if (! TARGET_29050)\n-    {\n-      target = operand_subword_force (operands[0], 0, SFmode);\n-      result = expand_binop (SImode, xor_optab,\n-\t\t\t     operand_subword_force (operands[1], 0, SFmode),\n-\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n-\n-      if (result != target)\n-\temit_move_insn (result, target);\n-\n-      /* Make a place for REG_EQUAL.  */\n-      emit_move_insn (operands[0], operands[0]);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"negdf2\"\n-  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t\t   (neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 2 \"\"))])]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\n-{\n-  rtx result;\n-  rtx target;\n-  rtx insns;\n-\n-  if (! TARGET_29050)\n-    {\n-      start_sequence ();\n-      target = operand_subword (operands[0], 0, 1, DFmode);\n-      result = expand_binop (SImode, xor_optab,\n-\t\t\t     operand_subword_force (operands[1], 0, DFmode),\n-\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n-      if (result == 0)\n-\tabort ();\n-\n-      if (result != target)\n-\temit_move_insn (result, target);\n-  \n-      emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n-\t\t      operand_subword_force (operands[1], 1, DFmode));\n-\n-      insns = get_insns ();\n-      end_sequence ();\n-\n-      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n-      DONE;\n-    }\n-}\")\n-\f\n-;; Sign extend and truncation operations.\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"and %0,%1,255\")\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"and %0,%1,255\")\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"gpc_reg_operand\" \"0\")))]\n-  \"\"\n-  \"consth %0,0\")\n-\n-(define_expand \"extendqihi2\"\n-  [(set (match_dup 2)\n-\t(ashift:SI (match_operand:QI 1 \"gpc_reg_operand\" \"\")\n-\t\t   (const_int 24)))\n-   (set (match_operand:HI 0 \"gpc_reg_operand\" \"\")\n-\t(ashiftrt:SI (match_dup 2)\n-\t\t     (const_int 24)))]\n-  \"\"\n-  \"\n-{ operands[0] = gen_lowpart (SImode, operands[0]);\n-  operands[1] = gen_lowpart (SImode, operands[1]);\n-  operands[2] = gen_reg_rtx (SImode); }\")\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_dup 2)\n-\t(ashift:SI (match_operand:QI 1 \"gpc_reg_operand\" \"\")\n-\t\t   (const_int 24)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ashiftrt:SI (match_dup 2)\n-\t\t     (const_int 24)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-  operands[2] = gen_reg_rtx (SImode); }\")\n-\n-(define_expand \"extendhisi2\"\n-  [(set (match_dup 2)\n-\t(ashift:SI (match_operand:HI 1 \"gpc_reg_operand\" \"\")\n-\t\t   (const_int 16)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ashiftrt:SI (match_dup 2)\n-\t\t     (const_int 16)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_lowpart (SImode, operands[1]);\n-  operands[2] = gen_reg_rtx (SImode); }\")\n-\f\n-;; Define the methods used to move data around.\n-;;\n-;; movsi:\n-;;\n-;; If storing into memory, force source into register.\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && ! gpc_reg_operand (operands[1], SImode))\n-    operands[1] = copy_to_mode_reg (SImode, operands[1]);\n-  else if (spec_reg_operand (operands[0], SImode)\n-\t   && ! (register_operand (operands[1], SImode)\n-\t\t || cint_16_operand (operands[1], SImode)))\n-    operands[1] = force_reg (SImode, operands[1]);\n-}\")\n-\n-(define_expand \"movpsi\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n-\t(match_operand:PSI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM\n-      && ! gpc_reg_operand (operands[1], PSImode))\n-    operands[1] = copy_to_mode_reg (PSImode, operands[1]);\n-  else if (spec_reg_operand (operands[0], PSImode)\n-\t   && ! (register_operand (operands[1], PSImode)\n-\t\t || cint_16_operand (operands[1], PSImode)))\n-    operands[1] = force_reg (PSImode, operands[1]);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:SI 1 \"long_const_operand\" \"\"))]\n-  \"\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 1)\n-\t\t(const_int 65535)))\n-   (set (match_dup 0)\n-\t(ior:SI (zero_extend:SI (match_dup 2))\n-\t\t(and:SI (match_dup 1)\n-\t\t\t(const_int -65536))))]\n-  \" operands[2] = gen_lowpart (HImode, operands[0]); \")\n-\f\n-;; Subroutines to load/store halfwords.  Operands 0 and 1 are the output and\n-;; input, respectively, except that the address is passed for a MEM instead \n-;; of the MEM itself and the short item is passed in QImode.\n-;;\n-;; Operand 2 is a scratch general register and operand 3 is a scratch register\n-;; used for BP.  When called before reload, pseudos are passed for both\n-;; operands.  During reload, R_TAV is used for the general register, and\n-;; a reload register of class BR_REGS (R_VP) for BP.\n-;;\n-;; We have two versions of the store operations, for when halfword writes are\n-;; supported and when they are not.\n-(define_expand \"loadhi\"\n-  [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t\t   (mem:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t   (const_int -4))))\n-\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n-\t\t   (truncate:PSI (match_dup 1)))])\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(zero_extract:SI (match_dup 2)\n-\t\t\t (const_int 16)\n-\t\t\t (ashift:PSI (match_dup 3) (const_int 3))))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"storehinhww\"\n- [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t\t\t   (const_int -4))))\n-\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n-\t\t   (truncate:PSI (match_dup 0)))])\n-   (set (zero_extract:SI (match_dup 2)\n-\t\t\t (const_int 16)\n-\t\t\t (ashift:PSI (match_dup 3) (const_int 3)))\n-\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-   (set (mem:SI (match_dup 0))\n-\t(match_dup 2))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"storehihww\"\n-  [(set (match_operand:PSI 3 \"register_operand\" \"\")\n-\t(truncate:PSI (match_operand:SI 0 \"gpc_reg_operand\" \"\")))\n-   (set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 65535)\n-\t\t\t\t\t   (ashift:PSI (match_dup 3)\n-\t\t\t\t\t\t       (const_int 3))))\n-\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t(ashift:SI (zero_extend:SI (match_dup 4))\n-\t\t\t   (ashift:PSI (match_dup 3) (const_int 3)))))\n-   (set (mem:SI (and:SI (match_dup 0)\n-\t\t\t(const_int -3)))\n-\t(match_dup 2))]\n-  \"\"\n-  \"\n-{ operands[4] = gen_lowpart (HImode, operands[1]); }\")\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{ if (GET_CODE (operands[0]) == MEM) \n-    {\n-      if (! gpc_reg_operand (operands[1], HImode))\n-\toperands[1] = copy_to_mode_reg (HImode, operands[1]);\n-      if (! TARGET_DW_ENABLE)\n-\t{\n-\t  rtx general = gen_reg_rtx (SImode);\n-\t  rtx bp = gen_reg_rtx (PSImode);\n-\t  rtx (*fcn) PARAMS ((rtx, rtx, rtx, rtx))\n-\t    = TARGET_BYTE_WRITES ? gen_storehihww : gen_storehinhww;\n-\t  rtx seq = (*fcn) (XEXP (operands[0], 0),\n-\t\t\t    gen_lowpart (SImode, operands[1]),\n-\t\t\t    general, bp);\n-\t    \n-\t  a29k_set_memflags (seq, operands[0]);\n-\t  emit_insn (seq);\n-\t  DONE;\n-\t}\n-    }\n-  else if (GET_CODE (operands[1]) == MEM)\n-    {\n-      if (! TARGET_DW_ENABLE)\n-\t{\n-\t  rtx general = gen_reg_rtx (SImode);\n-\t  rtx bp = gen_reg_rtx (PSImode);\n-\t  rtx seq = gen_loadhi (gen_lowpart (SImode, operands[0]),\n-\t\t\t\tXEXP (operands[1], 0), general, bp);\n-\n-\t  a29k_set_memflags (seq, operands[1]);\n-\t  emit_insn (seq);\n-\t  DONE;\n-\t}\n-    }\n-}\")\n-\n-(define_expand \"reload_inhi\"\n-  [(parallel [(match_operand:SI 0 \"register_operand\" \"=r\")\n-\t      (match_operand:SI 1 \"reload_memory_operand\" \"m\")\n-\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n-  \"! TARGET_DW_ENABLE\"\n-  \"\n-{ rtx seq = gen_loadhi (gen_lowpart (SImode, operands[0]),\n-\t\t\ta29k_get_reloaded_address (operands[1]),\n-\t\t\tgen_rtx_REG (SImode, R_TAV),\n-\t\t\toperands[2]);\n-\n-  a29k_set_memflags (seq, operands[1]);\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\n-(define_expand \"reload_outhi\"\n-  [(parallel [(match_operand:SI 0 \"reload_memory_operand\" \"=m\")\n-\t      (match_operand:SI 1 \"register_operand\" \"m\")\n-\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n-  \"! TARGET_DW_ENABLE\"\n-  \"\n-{ rtx (*fcn) PARAMS ((rtx, rtx, rtx, rtx)) =\n-    TARGET_BYTE_WRITES ? gen_storehihww : gen_storehinhww;\n-  rtx seq = (*fcn) (a29k_get_reloaded_address (operands[0]),\n-\t\t    gen_lowpart (SImode, operands[1]),\n-\t\t    gen_rtx_REG (SImode, R_TAV), operands[2]);\n-\n-  a29k_set_memflags (seq, operands[0]);\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\f\n-;; Subroutines to load/store bytes.  Operands 0 and 1 are the output and\n-;; input, respectively, except that the address is passed for a MEM instead \n-;; of the MEM itself and the short item is passed in QImode.\n-;;\n-;; Operand 2 is a scratch general register and operand 3 is a scratch register\n-;; used for BP.  When called before reload, pseudos are passed for both\n-;; operands.  During reload, R_TAV is used for the general register, and\n-;; a reload register of class BR_REGS (R_VP) for BP.\n-;;\n-;; We have two versions of the store operations, for when byte writes are\n-;; supported and when they are not.\n-(define_expand \"loadqi\"\n-  [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t\t   (mem:SI (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t   (const_int -4))))\n-\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n-\t\t   (truncate:PSI (match_dup 1)))])\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(zero_extract:SI (match_dup 2)\n-\t\t\t (const_int 8)\n-\t\t\t (ashift:PSI (match_dup 3) (const_int 3))))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"storeqinhww\"\n-  [(parallel [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t\t   (mem:SI (and:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t\t\t   (const_int -4))))\n-\t      (set (match_operand:PSI 3 \"register_operand\" \"\")\n-\t\t   (truncate:PSI (match_dup 0)))])\n-   (set (zero_extract:SI (match_dup 2)\n-\t\t\t (const_int 8)\n-\t\t\t (ashift:PSI (match_dup 3)\n-\t\t\t\t     (const_int 3)))\n-\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-   (set (mem:SI (match_dup 0))\n-\t(match_dup 2))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"storeqihww\"\n-  [(set (match_operand:PSI 3 \"register_operand\" \"\")\n-\t(truncate:PSI (match_operand:SI 0 \"gpc_reg_operand\" \"\")))\n-   (set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t(ior:SI (and:SI (not:SI (ashift:SI (const_int 255)\n-\t\t\t\t\t   (ashift:PSI (match_dup 3)\n-\t\t\t\t\t\t       (const_int 3))))\n-\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t(ashift:SI (zero_extend:SI (match_dup 4))\n-\t\t\t   (ashift:PSI (match_dup 3)\n-\t\t\t\t       (const_int 3)))))\n-   (set (mem:SI (and:SI (match_dup 0)\n-\t\t        (const_int -4)))\n-\t(match_dup 2))]\n-  \"\"\n-  \"\n-{ operands[4] = gen_lowpart (QImode, operands[1]); }\")\n-\f\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{ if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (! gpc_reg_operand (operands[1], QImode))\n-\toperands[1] = copy_to_mode_reg (QImode, operands[1]);\n-      if (! TARGET_DW_ENABLE)\n-\t{\n-\t  rtx general = gen_reg_rtx (SImode);\n-\t  rtx bp = gen_reg_rtx (PSImode);\n-\t  rtx (*fcn) PARAMS ((rtx, rtx, rtx, rtx))\n-\t    = TARGET_BYTE_WRITES ? gen_storeqihww : gen_storeqinhww;\n-\t  rtx seq = (*fcn) (XEXP (operands[0], 0),\n-\t\t\t    gen_lowpart (SImode, operands[1]),\n-\t\t\t    general, bp);\n-\t    \n-\t  a29k_set_memflags (seq, operands[0]);\n-\t  emit_insn (seq);\n-\t  DONE;\n-\t}\n-    }\n-  else if (GET_CODE (operands[1]) == MEM)\n-    {\n-      if (! TARGET_DW_ENABLE)\n-\t{\n-\t  rtx general = gen_reg_rtx (SImode);\n-\t  rtx bp = gen_reg_rtx (PSImode);\n-\t  rtx seq = gen_loadqi (gen_lowpart (SImode, operands[0]),\n-\t\t\t\tXEXP (operands[1], 0), general, bp);\n-\n-\t  a29k_set_memflags (seq, operands[1]);\n-\t  emit_insn (seq);\n-\t  DONE;\n-\t}\n-    }\n-}\")\n-\n-(define_expand \"reload_inqi\"\n-  [(parallel [(match_operand:SI 0 \"register_operand\" \"=r\")\n-\t      (match_operand:SI 1 \"reload_memory_operand\" \"m\")\n-\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n-  \"! TARGET_DW_ENABLE\"\n-  \"\n-{ rtx seq = gen_loadqi (gen_lowpart (SImode, operands[0]),\n-\t\t\ta29k_get_reloaded_address (operands[1]),\n-\t\t\tgen_rtx_REG (SImode, R_TAV),\n-\t\t\toperands[2]);\n-\n-  a29k_set_memflags (seq, operands[1]);\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\n-(define_expand \"reload_outqi\"\n-  [(parallel [(match_operand:SI 0 \"reload_memory_operand\" \"=m\")\n-\t      (match_operand:SI 1 \"register_operand\" \"m\")\n-\t      (match_operand:PSI 2 \"register_operand\" \"=b\")])]\n-  \"! TARGET_DW_ENABLE\"\n-  \"\n-{ rtx (*fcn) PARAMS ((rtx, rtx, rtx, rtx)) =\n-    TARGET_BYTE_WRITES ? gen_storeqihww : gen_storeqinhww;\n-  rtx seq = (*fcn) (a29k_get_reloaded_address (operands[0]),\n-\t\t    gen_lowpart (SImode, operands[1]),\n-\t\t    gen_rtx_REG (SImode, R_TAV), operands[2]);\n-\n-  a29k_set_memflags (seq, operands[0]);\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\f\n-;; Now the actual insns used to move data around.  We include here the\n-;; DEFINE_SPLITs that may be needed.  In some cases these will be\n-;; split again.  For floating-point, if we can look inside the constant,\n-;; always split it.  This can eliminate unnecessary insns.\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"out_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:SF 1 \"in_operand\" \"r,E,F,m,r\"))]\n-  \"(gpc_reg_operand (operands[0], SFmode)\n-    || gpc_reg_operand (operands[1], SFmode))\n-   && ! TARGET_29050\"\n-  \"@\n-   sll %0,%1,0\n-   #\n-   const %0,%1\\;consth %0,%1\n-   load 0,0,%0,%1\n-   store 0,0,%1,%0\"\n-  [(set_attr \"type\" \"misc,multi,multi,load,store\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"out_operand\" \"=r,r,r,r,m,*a,r\")\n-\t(match_operand:SF 1 \"in_operand\" \"r,E,F,m,r,r,*a\"))]\n-  \"(gpc_reg_operand (operands[0], SFmode)\n-    || gpc_reg_operand (operands[1], SFmode))\n-   && TARGET_29050\"\n-  \"@\n-   sll %0,%1,0\n-   #\n-   const %0,%1\\;consth %0,%1\n-   load 0,0,%0,%1\n-   store 0,0,%1,%0\n-   mtacc %1,1,%0\n-   mfacc %0,1,%1\"\n-  [(set_attr \"type\" \"misc,multi,multi,load,store,fadd,fadd\")])\n-\n-;; Turn this into SImode.  It will then be split up that way.\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(match_operand:SF 1 \"float_const_operand\" \"\"))]\n-  \"\"\n-  [(set (match_dup 0)\n-\t(match_dup 1))]\n-  \"\n-{ operands[0] = operand_subword (operands[0], 0, 0, SFmode);\n-  operands[1] = operand_subword (operands[1], 0, 0, SFmode);\n-\n-  if (operands[0] == 0 || operands[1] == 0)\n-    FAIL;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"out_operand\" \"=?r,?r,r,m\")\n-\t(match_operand:DF 1 \"in_operand\" \"rE,F,m,r\"))\n-   (clobber (match_scratch:PSI 2 \"=X,X,&c,&c\"))]\n-  \"(gpc_reg_operand (operands[0], DFmode)\n-    || gpc_reg_operand (operands[1], DFmode))\n-   && ! TARGET_29050\"\n-  \"@\n-   #\n-   const %0,%1\\;consth %0,%1\\;const %L0,%L1\\;consth %L0,%L1\n-   mtsrim cr,1\\;loadm 0,0,%0,%1\n-   mtsrim cr,1\\;storem 0,0,%1,%0\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"out_operand\" \"=?r,?r,r,m,?*a,?r\")\n-\t(match_operand:DF 1 \"in_operand\" \"rE,F,m,r,r,*a\"))\n-   (clobber (match_scratch:PSI 2 \"=X,X,&c,&c,X,X\"))]\n-  \"(gpc_reg_operand (operands[0], DFmode)\n-    || gpc_reg_operand (operands[1], DFmode))\n-   && TARGET_29050\"\n-  \"@\n-   #\n-   const %0,%1\\;consth %0,%1\\;const %L0,%L1\\;consth %L0,%L1\n-   mtsrim cr,1\\;loadm 0,0,%0,%1\n-   mtsrim cr,1\\;storem 0,0,%1,%0\n-   mtacc %1,2,%0\n-   mfacc %0,2,%1\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi,fadd,fadd\")])\n-\n-;; Split register-register copies and constant loads into two SImode loads,\n-;; one for each word.  In the constant case, they will get further split.\n-;; Don't so this until register allocation, though, since it will\n-;; interfere with register allocation.  Normally copy the lowest-addressed\n-;; word first; the exception is if we are copying register to register and\n-;; the lowest register of the first operand is the highest register of the\n-;; second operand.\n-(define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"gpc_reg_or_float_constant_operand\" \"\"))\n-   (clobber (match_scratch:PSI 2 \"\"))]\n-  \"reload_completed\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 5) (match_dup 6))]\n-  \"\n-{ if (GET_CODE (operands[1]) == REG\n-      && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-    {\n-      operands[3] = operand_subword (operands[0], 1, 1, DFmode);\n-      operands[4] = operand_subword (operands[1], 1, 1, DFmode);\n-      operands[5] = operand_subword (operands[0], 0, 1, DFmode);\n-      operands[6] = operand_subword (operands[1], 0, 1, DFmode);\n-    }\n-  else\n-    {\n-      operands[3] = operand_subword (operands[0], 0, 1, DFmode);\n-      operands[4] = operand_subword (operands[1], 0, 1, DFmode);\n-      operands[5] = operand_subword (operands[0], 1, 1, DFmode);\n-      operands[6] = operand_subword (operands[1], 1, 1, DFmode);\n-    }\n-\n-  if (operands[3] == 0 || operands[4] == 0\n-      || operands[5] == 0 || operands[6] == 0)\n-    FAIL;\n-}\")\n-\n-;; Split memory loads and stores into the MTSR and LOADM/STOREM.\n-(define_split\n-  [(set (match_operand:DF 0 \"out_operand\" \"\")\n-\t(match_operand:DF 1 \"in_operand\" \"\"))\n-   (clobber (reg:PSI 179))]\n-  \"TARGET_NO_STOREM_BUG\n-   && (memory_operand (operands[0], DFmode)\n-       || memory_operand (operands[1], DFmode))\"\n-  [(set (reg:PSI 179) (const_int 1))\n-   (parallel [(set (match_dup 0) (match_dup 1))\n-\t      (use (reg:PSI 179))\n-\t      (clobber (reg:PSI 179))])]\n-  \"\")\n-\n-;; DI move is similar to DF move.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"out_operand\" \"=?r,r,m\")\n-\t(match_operand:DI 1 \"in_operand\" \"rn,m,r\"))\n-   (clobber (match_scratch:PSI 2 \"=X,&c,&c\"))]\n-  \"(gpc_reg_operand (operands[0], DImode)\n-     || gpc_reg_operand (operands[1], DImode))\"\n-  \"@\n-   #\n-   mtsrim cr,1\\;loadm 0,0,%0,%1\n-   mtsrim cr,1\\;storem 0,0,%1,%0\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"gpc_reg_or_integer_constant_operand\" \"\"))\n-   (clobber (match_scratch:PSI 2 \"\"))]\n-  \"reload_completed\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 5) (match_dup 6))]\n-  \"\n-{ if (GET_CODE (operands[1]) == REG\n-      && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-    {\n-      operands[3] = operand_subword (operands[0], 1, 1, DImode);\n-      operands[4] = operand_subword (operands[1], 1, 1, DImode);\n-      operands[5] = operand_subword (operands[0], 0, 1, DImode);\n-      operands[6] = operand_subword (operands[1], 0, 1, DImode);\n-    }\n-  else\n-    {\n-      operands[3] = operand_subword (operands[0], 0, 1, DImode);\n-      operands[4] = operand_subword (operands[1], 0, 1, DImode);\n-      operands[5] = operand_subword (operands[0], 1, 1, DImode);\n-      operands[6] = operand_subword (operands[1], 1, 1, DImode);\n-    }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"out_operand\" \"\")\n-\t(match_operand:DI 1 \"in_operand\" \"\"))\n-   (clobber (reg:PSI 179))]\n-  \"TARGET_NO_STOREM_BUG\n-   && (memory_operand (operands[0], DImode)\n-       || memory_operand (operands[1], DImode))\"\n-  [(set (reg:PSI 179) (const_int 1))\n-   (parallel [(set (match_dup 0) (match_dup 1))\n-\t      (use (reg:PSI 179))\n-\t      (clobber (reg:PSI 179))])]\n-  \"\")\n-\n-;; TImode moves are very similar to DImode moves, except that we can't\n-;; have constants.\n-(define_insn \"\"\n-  [(set (match_operand:TI 0 \"out_operand\" \"=?r,r,m\")\n-\t(match_operand:TI 1 \"in_operand\" \"r,m,r\"))\n-   (clobber (match_scratch:PSI 2 \"=X,&c,&c\"))]\n-  \"(gpc_reg_operand (operands[0], TImode)\n-    || gpc_reg_operand (operands[1], TImode))\"\n-  \"@\n-   #\n-   mtsrim cr,3\\;loadm 0,0,%0,%1\n-   mtsrim cr,3\\;storem 0,0,%1,%0\"\n-  [(set_attr \"type\" \"multi,multi,multi\")])\n-\n-(define_split\n-  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:TI 1 \"gpc_reg_operand\" \"\"))\n-   (clobber (match_scratch:PSI 2 \"\"))]\n-  \"reload_completed\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 5) (match_dup 6))\n-   (set (match_dup 7) (match_dup 8))\n-   (set (match_dup 9) (match_dup 10))]\n-  \"\n-{\n-  if (REGNO (operands[0]) >= REGNO (operands[1]) + 1\n-      && REGNO (operands[0]) <= REGNO (operands[1]) + 3)\n-    {\n-      operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]) + 3);\n-      operands[4] = gen_rtx_REG (SImode, REGNO (operands[1]) + 3);\n-      operands[5] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n-      operands[6] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n-      operands[7] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      operands[8] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-      operands[9] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-      operands[10] = gen_rtx_REG (SImode, REGNO (operands[1]));\n-    }\n-  else\n-    {\n-      operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-      operands[4] = gen_rtx_REG (SImode, REGNO (operands[1]));\n-      operands[5] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      operands[6] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-      operands[7] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n-      operands[8] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n-      operands[9] = gen_rtx_REG (SImode, REGNO (operands[0]) + 3);\n-      operands[10] = gen_rtx_REG (SImode, REGNO (operands[1]) + 3); \n-    }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:TI 0 \"out_operand\" \"\")\n-\t(match_operand:TI 1 \"in_operand\" \"\"))\n-   (clobber (reg:PSI 179))]\n-  \"TARGET_NO_STOREM_BUG\n-   && (memory_operand (operands[0], TImode)\n-       || memory_operand (operands[1], TImode))\"\n-  [(set (reg:PSI 179) (const_int 3))\n-   (parallel [(set (match_dup 0) (match_dup 1))\n-\t      (use (reg:PSI 179))\n-\t      (clobber (reg:PSI 179))])]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"out_operand\" \"=r,r,r,r,r,r,r,m,*h,*h\")\n-        (match_operand:SI 1 \"in_operand\" \"r,J,M,O,i,m,*h,r,r,J\"))]\n-  \"(gpc_reg_operand (operands[0], SImode)\n-    || gpc_reg_operand (operands[1], SImode)\n-    || (spec_reg_operand (operands[0], SImode)\n-        && cint_16_operand (operands[1], SImode)))\n-   && ! TARGET_29050\"\n-  \"@\n-   sll %0,%1,0\n-   const %0,%1\n-   constn %0,%M1\n-   cpeq %0,gr1,gr1\n-   #\n-   load 0,0,%0,%1\n-   mfsr %0,%1\n-   store 0,0,%1,%0\n-   mtsr %0,%1\n-   mtsrim %0,%1\"\n-  [(set_attr \"type\" \"misc,misc,misc,misc,multi,load,misc,store,misc,misc\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"out_operand\" \"=r,r,r,r,r,r,r,m,*h,*h\")\n-        (match_operand:SI 1 \"in_operand\" \"r,J,M,O,i,m,*h,r,r,J\"))]\n-  \"(gpc_reg_operand (operands[0], SImode)\n-    || gpc_reg_operand (operands[1], SImode)\n-    || (spec_reg_operand (operands[0], SImode)\n-        && cint_16_operand (operands[1], SImode)))\n-   && TARGET_29050\"\n-  \"@\n-   sll %0,%1,0\n-   const %0,%1\n-   constn %0,%M1\n-   consthz %0,%1\n-   #\n-   load 0,0,%0,%1\n-   mfsr %0,%1\n-   store 0,0,%1,%0\n-   mtsr %0,%1\n-   mtsrim %0,%1\"\n-  [(set_attr \"type\" \"misc,misc,misc,misc,multi,load,misc,store,misc,misc\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"out_operand\" \"=*r,*r,*r,*r,m,h,h\")\n-        (match_operand:PSI 1 \"in_operand\" \"r,i,m,h,r,r,J\"))]\n-  \"(gpc_reg_operand (operands[0], PSImode)\n-    || gpc_reg_operand (operands[1], PSImode)\n-    || (spec_reg_operand (operands[0], PSImode)\n-        && cint_16_operand (operands[1], PSImode)))\"\n-  \"@\n-   sll %0,%1,0\n-   const %0,%1\n-   load 0,0,%0,%1\n-   mfsr %0,%1\n-   store 0,0,%1,%0\n-   mtsr %0,%1\n-   mtsrim %0,%1\"\n-  [(set_attr \"type\" \"misc,multi,load,misc,store,misc,misc\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"out_operand\" \"=r,r,r,m,r,*h,*h\")\n-        (match_operand:HI 1 \"in_operand\" \"r,i,m,r,*h,r,i\"))]\n-  \"gpc_reg_operand (operands[0], HImode)\n-   || gpc_reg_operand (operands[1], HImode)\n-   || (spec_reg_operand (operands[0], HImode)\n-       && cint_16_operand (operands[1], HImode))\"\n-  \"@\n-   sll %0,%1,0\n-   const %0,%1\n-   load 0,2,%0,%1\n-   store 0,2,%1,%0\n-   mfsr %0,%1\n-   mtsr %0,%1\n-   mtsrim %0,%1\"\n-  [(set_attr \"type\" \"misc,misc,load,store,misc,misc,misc\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"out_operand\" \"=r,r,r,m,r,*h,*h\")\n-        (match_operand:QI 1 \"in_operand\" \"r,i,m,r,*h,r,i\"))]\n-  \"gpc_reg_operand (operands[0], QImode)\n-   || gpc_reg_operand (operands[1], QImode)\n-   || (spec_reg_operand (operands[0], HImode)\n-       && cint_16_operand (operands[1], HImode))\"\n-  \"@\n-   sll %0,%1,0\n-   const %0,%1\n-   load 0,1,%0,%1\n-   store 0,1,%1,%0\n-   mfsr %0,%1\n-   mtsr %0,%1\n-   mtsrim %0,%1\"\n-  [(set_attr \"type\" \"misc,misc,load,store,misc,misc,misc\")])\n-\f\n-;; Define move insns for DI, TI, SF, and DF.\n-;;\n-;; In no case do we support mem->mem directly.\n-;;\n-;; For DI move of constant to register, split apart at this time since these\n-;; can require anywhere from 2 to 4 insns and determining which is complex.\n-;;\n-;; In other cases, handle similarly to SImode moves.\n-;;\n-;; However, indicate that DI, TI, and DF moves may clobber CR (reg 179).\n-(define_expand \"movdi\"\n-  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (match_operand:DI 1 \"general_operand\" \"\"))\n-\t      (clobber (scratch:PSI))])]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (DImode, operands[1]);\n-}\")\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{ if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (SFmode, operands[1]);\n-}\")\n-\n-(define_expand \"movdf\"\n-  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t\t   (match_operand:DF 1 \"general_operand\" \"\"))\n-\t      (clobber (scratch:PSI))])]\n-  \"\"\n-  \"\n-{ if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (DFmode, operands[1]);\n-}\")\n-\n-(define_expand \"movti\"\n-  [(parallel [(set (match_operand:TI 0 \"general_operand\" \"\")\n-\t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n-\t      (clobber (scratch:PSI))])]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (TImode, operands[1]);\n-\n-  /* We can't handle constants in general because there is no rtl to represent\n-     128 bit constants.  Splitting happens to work for CONST_INTs so we split\n-     them for good code.  Other constants will get forced to memory.  */\n-\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-     rtx part0, part1, part2, part3;\n-\n-     part0 = operand_subword (operands[0], 0, 1, TImode);\n-     part1 = operand_subword (operands[0], 1, 1, TImode);\n-     part2 = operand_subword (operands[0], 2, 1, TImode);\n-     part3 = operand_subword (operands[0], 3, 1, TImode);\n-\n-     emit_move_insn (part0, const0_rtx);\n-     emit_move_insn (part1, const0_rtx);\n-     emit_move_insn (part2, const0_rtx);\n-     emit_move_insn (part3, const0_rtx);\n-\n-     DONE;\n-    }\n-  else if (CONSTANT_P (operands[1]))\n-    {\n-      operands[1] = force_const_mem (TImode, operands[1]);\n-      if (! memory_address_p (TImode, XEXP (operands[1], 0))\n-\t  && ! reload_in_progress)\n-        operands[1] = adjust_address (operands[1], TImode, 0);\n-    }\n-}\")\n-\f\n-;; Here are the variants of the above for use during reload.\n-\n-(define_expand \"reload_indf\"\n-  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t\t   (match_operand:DF 1 \"reload_memory_operand\" \"m\"))\n-\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&c\"))])]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"reload_outdf\"\n-  [(parallel [(set (match_operand:DF 0 \"reload_memory_operand\" \"=m\")\n-\t\t   (match_operand:DF 1 \"register_operand\" \"r\"))\n-\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&c\"))])]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"reload_indi\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t\t   (match_operand:DI 1 \"reload_memory_operand\" \"m\"))\n-\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&c\"))])]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"reload_outdi\"\n-  [(parallel [(set (match_operand:DI 0 \"reload_memory_operand\" \"=m\")\n-\t\t   (match_operand:DI 1 \"register_operand\" \"r\"))\n-\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&c\"))])]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"reload_inti\"\n-  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n-\t\t   (match_operand:TI 1 \"reload_memory_operand\" \"m\"))\n-\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&c\"))])]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"reload_outti\"\n-  [(parallel [(set (match_operand:TI 0 \"reload_memory_operand\" \"=m\")\n-\t\t   (match_operand:TI 1 \"register_operand\" \"r\"))\n-\t      (clobber (match_operand:PSI 2 \"register_operand\" \"=&c\"))])]\n-  \"\"\n-  \"\")\n-\f\n-;; For compare operations, we simply store the comparison operands and\n-;; do nothing else.  The following branch or scc insn will output whatever\n-;; is needed.\n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SI 1 \"srcb_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  a29k_compare_op0 = operands[0];\n-  a29k_compare_op1 = operands[1];\n-  a29k_compare_fp_p = 0;\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\n-{\n-  a29k_compare_op0 = operands[0];\n-  a29k_compare_op1 = operands[1];\n-  a29k_compare_fp_p = 1;\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\n-{\n-  a29k_compare_op0 = operands[0];\n-  a29k_compare_op1 = operands[1];\n-  a29k_compare_fp_p = 1;\n-  DONE;\n-}\")\n-\n-;; We can generate bit-tests better if we use NE instead of EQ, but we\n-;; don't have an NE for floating-point.  So we have to have two patterns\n-;; for EQ and two for NE.\n-\n-(define_expand \"beq\"\n-  [(set (match_dup 1) (ne:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (a29k_compare_op0)) == MODE_FLOAT)\n-    {\n-      emit_insn (gen_beq_fp (operands[0]));\n-      DONE;\n-    }\n-\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"beq_fp\"\n-  [(set (match_dup 1) (eq:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (match_dup 1) (ne:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (a29k_compare_op0)) == MODE_FLOAT)\n-    {\n-      emit_insn (gen_bne_fp (operands[0]));\n-      DONE;\n-    }\n-\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"bne_fp\"\n-  [(set (match_dup 1) (eq:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-;; We don't have a floating-point \"lt\" insn, so we have to use \"gt\" in that\n-;; case with the operands swapped.  The operands must both be registers in\n-;; the floating-point case, so we know that swapping them is OK.\n-(define_expand \"blt\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  if (a29k_compare_fp_p)\n-    operands[2] = gen_rtx_GT (SImode, a29k_compare_op1, a29k_compare_op0);\n-  else\n-    operands[2] = gen_rtx_LT (SImode, a29k_compare_op0, a29k_compare_op1);\n-}\")\n-\n-;; Similarly for \"le\".\n-(define_expand \"ble\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  if (a29k_compare_fp_p)\n-    operands[2] = gen_rtx_GE (SImode, a29k_compare_op1, a29k_compare_op0);\n-  else\n-    operands[2] = gen_rtx_LE (SImode, a29k_compare_op0, a29k_compare_op1);\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(set (match_dup 1) (ltu:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (match_dup 1) (leu:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(set (match_dup 1) (gt:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (match_dup 1) (ge:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (match_dup 1) (gtu:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (match_dup 1) (geu:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = a29k_compare_op0;\n-  operands[3] = a29k_compare_op1;\n-}\")\n-\f\n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(eq:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-}\")\n-\t\t \n-;; This is the most complicated case, because we don't have a floating-point\n-;; \"ne\" insn.  If integer, handle normally.  If floating-point, write the\n-;; compare and then write an insn to reverse the test.\n-(define_expand \"sne_fp\"\n-  [(set (match_dup 3)\n-\t(eq:SI (match_operand 1 \"gpc_reg_operand\" \"\")\n-\t       (match_operand 2 \"gpc_reg_operand\" \"\")))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ge:SI (match_dup 3) (const_int 0)))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\n-{ operands[3] = gen_reg_rtx (SImode);\n-}\");\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ne:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-\n-  if (a29k_compare_fp_p)\n-    {\n-      emit_insn (gen_sne_fp (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-}\")\n-\t\t \n-;; We don't have a floating-point \"lt\" insn, so use \"gt\" and swap the\n-;; operands, the same as we do \"blt\".\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (a29k_compare_fp_p)\n-    operands[1] = gen_rtx_GT (SImode, a29k_compare_op1, a29k_compare_op0);\n-  else\n-    operands[1] = gen_rtx_LT (SImode, a29k_compare_op0, a29k_compare_op1);\n-}\")\n-\n-;; Similarly for \"le\"\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (a29k_compare_fp_p)\n-    operands[1] = gen_rtx_GE (SImode, a29k_compare_op1, a29k_compare_op0);\n-  else\n-    operands[1] = gen_rtx_LE (SImode, a29k_compare_op0, a29k_compare_op1);\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ltu:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(leu:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(gt:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ge:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-}\")\n-\t\t \n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(gtu:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(geu:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = a29k_compare_op0;\n-  operands[2] = a29k_compare_op1;\n-}\")\n-\f\n-;; Now define the actual jump insns.\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"branch_operator\"\n-\t\t\t\t      [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t\t       (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jmp%b0 %1,%l2%#\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"branch_operator\"\n-\t\t\t\t      [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t\t       (const_int 0)])\n-\t\t      (return)\n-\t\t      (pc)))]\n-  \"null_epilogue ()\"\n-  \"jmp%b0i %1,lr0%#\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"branch_operator\"\n-\t\t\t\t      [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t\t       (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"jmp%B0 %1,%l2%#\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"branch_operator\"\n-\t\t\t\t      [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t\t       (const_int 0)])\n-\t\t      (pc)\n-\t\t      (return)))]\n-  \"null_epilogue ()\"\n-  \"jmp%B0i %1,lr0%#\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"jmp %e0%E0\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"return\"\n-  [(return)]\n-  \"null_epilogue ()\"\n-  \"jmpi lr0%#\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc)\n-\t(match_operand:SI 0 \"gpc_reg_operand\" \"r\"))]\n-  \"\"\n-  \"jmpi %0%#\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"tablejump\"\n-  [(set (pc)\n-\t(match_operand:SI 0 \"gpc_reg_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jmpi %0%#\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-;; JMPFDEC\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"\"\n-  \"jmpfdec %0,%l1%#\"\n-  [(set_attr \"type\" \"branch\")])"}, {"sha": "ef654450cfc44c5bb06bb65c926acfb35a69bec5", "filename": "gcc/config/a29k/rtems.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Frtems.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,26 +0,0 @@\n-/* Definitions for rtems targeting a AMD A29K using COFF.\n-   Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.\n-   Contributed by Joel Sherrill (joel@OARcorp.com).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Specify predefined symbols in preprocessor.  */\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-D_AM29K -D_AM29000 -D_EPI -D__rtems__ \\\n-  -Asystem=rtems -Acpu=a29k -Amachine=a29k\""}, {"sha": "c304196c3a804a32e93ec30195071968e3a07c0a", "filename": "gcc/config/a29k/t-a29kbare", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Ft-a29kbare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Ft-a29kbare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Ft-a29kbare?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,13 +0,0 @@\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-"}, {"sha": "d6c79852ca48bcdb0f36fbe67e8bdae04863cf82", "filename": "gcc/config/a29k/t-vx29k", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Ft-vx29k", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Ft-vx29k", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Ft-vx29k?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,15 +0,0 @@\n-# We don't want to put exit in libgcc.a for VxWorks, because VxWorks\n-# does not have _exit.\n-TARGET_LIBGCC2_CFLAGS = -Dexit=unused_exit\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c"}, {"sha": "eae03bf6767e583e898640b855563c83176f9445", "filename": "gcc/config/a29k/unix.h", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Funix.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,92 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for AMD Am29000 CPU, Unix.\n-   Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* We define unix instead of EPI and define unix-style machine names.  */\n-\n-/* Set our default target to be the 29050; that is the more interesting chip\n-   for Unix systems.  */\n-\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (1+2+16+128)\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dam29k -Da29k -Dam29000 -Asystem=unix -Acpu=a29k -Amachine=a29k\"\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%{!m29000:-Dam29050 -D__am29050__}\"\n-\n-/* Use a default linker configuration file.  */\n-#undef LINK_SPEC\n-#define LINK_SPEC \"-T default.gld%s\"\n-\n-/* Define the magic numbers that we recognize as COFF.  */\n-\n-#define MY_ISCOFF(magic) ((magic) == SIPFBOMAGIC || (magic) == SIPRBOMAGIC)\n-\n-/* For some systems, it is best if double-word objects are aligned on a \n-   doubleword boundary.  We want to maintain compatibility with MetaWare in\n-   a29k.h, but do not feel constrained to do so here.  */\n-\n-#undef BIGGEST_ALIGNMENT\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* Add shared data as a kludge for now.  */\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n-{ const char *p, *after_dir = main_input_filename;\t\t\\\n-  if (TARGET_29050)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.cputype 29050\\n\");\t\t\t\\\n-  for (p = main_input_filename; *p; p++)\t\t\t\\\n-    if (*p == '/')\t\t\t\t\t\t\\\n-      after_dir = p + 1;\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.file \");\t\t\t\t\t\\\n-  output_quoted_string (FILE, after_dir);\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  if (flag_shared_data)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.sect .shdata,data\\n\");\t\t\t\\\n-  fprintf (FILE, \"\\t.sect .lit,lit\\n\");  }\n-\n-/* Output before shared  data.  */\n-\n-#define SHARED_SECTION_ASM_OP \"\\t.use .shdata\"\n-\n-/* If we want shared data, we have to turn off commons.  */\n-\n-#define OVERRIDE_OPTIONS if (flag_shared_data) flag_no_common = 1;\n-\n-/* Default to -fno-pcc-struct-return, since we don't have to worry about\n-   compatibility.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-#if 0 /* This would be needed except that the 29k doesn't have strict\n-\t alignment requirements.  */\n-\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n-  (((TYPE) != 0)\t\t\t\t\t\t\t\\\n-\t? ((TYPE_ALIGN(TYPE) <= PARM_BOUNDARY)\t\t\t\t\\\n-\t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n-\t\t: TYPE_ALIGN(TYPE))\t\t\t\t\t\\\n-\t: ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\t\\\n-\t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n-\t\t: GET_MODE_ALIGNMENT(MODE)))\n-#endif"}, {"sha": "e79626285e0b6234c9a134caa31cda648f549fdc", "filename": "gcc/config/a29k/vx29k.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fvx29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fa29k%2Fvx29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fvx29k.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,46 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Vxworks 29k version.\n-   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This file just exists to give specs for the 29k running on VxWorks.  */\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#undef  CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-D_AM29K -D_AM29000 -Acpu=a29k -Amachine=a29k -D__vxworks -D__vxworks_5\"\n-\n-/* Vxworks header files require that the macro CPU be set.\n-   We could define it in CPP_PREDEFINES, but the value is (or will be)\n-   dependent upon GCC options.  */\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"-DCPU=AM29200\"\n-\n-/* VxWorks does all the library stuff itself.  */\n-\n-#undef LIB_SPEC\n-#define LIB_SPEC \"\"\n-\n-/* VxWorks provides the functionality of crt0.o and friends itself.  */\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC \"crtbegin.o%s\"\n-\n-#undef ENDFILE_SPEC\n-#define ENDFILE_SPEC \"crtend.o%s\""}, {"sha": "87e21111f4dc511363f6f5a0241f5b914c884ae4", "filename": "gcc/config/alpha/osf12.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Falpha%2Fosf12.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Falpha%2Fosf12.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf12.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,33 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for DEC Alpha.\n-   Copyright (C) 1992, 1993, 1995, 1996 Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* In OSF 1.2, there is a linker bug that prevents use of -O3 to\n-   the linker.  */\n-\n-#undef LINK_SPEC\n-#define LINK_SPEC  \\\n-  \"-G 8 -O1 %{static:-non_shared} %{rpath*} \\\n-   %{!static:%{shared:-shared} %{!shared:-call_shared}} %{taso}\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"short unsigned int\"\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 16"}, {"sha": "9d8c8f5e656ae4e9b156b55b4149d088fbacd4ef", "filename": "gcc/config/alpha/osf2or3.h", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Falpha%2Fosf2or3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Falpha%2Fosf2or3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf2or3.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,32 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for DEC Alpha, osf[23].\n-   Copyright (C) 1997 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* In OSF 2 or 3, linking with -lprof1 doesn't require -lpdf.  */\n-\n-#undef LIB_SPEC\n-#define LIB_SPEC \"%{p:-lprof1} %{pg:-lprof1} %{a:-lprof2} -lc\"\n-\n-/* As of OSF 3.2, as still can't subtract adjacent labels.  */\n-#undef TARGET_AS_CAN_SUBTRACT_LABELS\n-#define TARGET_AS_CAN_SUBTRACT_LABELS 0\n-\n-/* The frame unwind data requires the ability to subtract labels.  */\n-#undef DWARF2_UNWIND_INFO\n-#define DWARF2_UNWIND_INFO 0"}, {"sha": "511a40d5acec5ca055a88a65f8917cb7859e99a4", "filename": "gcc/config/arm/arm-wince-pe.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Farm-wince-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Farm-wince-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-wince-pe.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,66 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   for ARM with PE obj format running under the WinCE operating system. \n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n-   \n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define ARM_WINCE\t\t\t1\n-\n-#include \"pe.h\"\n-\n-#undef  USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"\"\n-\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION\tfputs (\" (ARM/WinCE/PE)\", stderr);\n-\n-/* The next three definitions are defined in pe.h,\n-   undefined in arm/arm-pe.h and then redefined back here!  */\n-#undef  LIB_SPEC\n-#define LIB_SPEC \"-lcoredll -lcorelibc\"\n-\n-#define MATH_LIBRARY \"\"\n-\n-#define LIBSTDCXX \"-lc\"\n-\n-#undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC \"\"\n-#define ENDFILE_SPEC \"\"\n-\n-#undef  CPP_APCS_PC_DEFAULT_SPEC\n-#define CPP_APCS_PC_DEFAULT_SPEC\t\"-D__APCS_32__\"\n-\n-#undef  CC1_SPEC\n-#define CC1_SPEC  \"%{!mapcs-32:%{!mapcs-26:-mapcs-32}}\"\n-\n-#undef  ASM_SPEC\n-#define ASM_SPEC \"\t\t\t\\\n-%{mbig-endian:-EB}\t\t\t\\\n-%{mcpu=*:-mcpu=%*}\t\t\t\\\n-%{march=*:-march=%*}\t\t\t\\\n-%{mapcs-*:-mapcs-%*}\t\t\t\\\n-%{mthumb-interwork:-mthumb-interwork}\t\\\n-%{!mapcs-32:%{!mapcs-26:-mapcs-32}}\t\\\n-\"\n-\n-/* WinCE headers require -DARM */\n-#undef  PE_SUBTARGET_CPP_SPEC\n-#define PE_SUBTARGET_CPP_SPEC \"-D__pe__ -DARM -D__unaligned=__attribute__((aligned(1))) \"\n-\n-#undef  SIZE_TYPE\n-#define SIZE_TYPE \"long unsigned int\""}, {"sha": "3a3e6bad6810fa2d994044c70d7297d85a843746", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c7bdf0a6af41a480ecb6a103636ef9069721c0bd", "patch": "@@ -390,8 +390,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \t\t\t\t         ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE)\t\\\n \t\t\t\t         : (target_flags & THUMB_FLAG_BACKTRACE))\n \n-/* SUBTARGET_SWITCHES is used to add flags on a per-config basis.\n-   Bit 31 is reserved.  See riscix.h.  */\n+/* SUBTARGET_SWITCHES is used to add flags on a per-config basis.  */\n #ifndef SUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES\n #endif"}, {"sha": "46f52e19cdc7e9d81afbf25dac72e4a4e6c405fd", "filename": "gcc/config/arm/riscix.h", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Friscix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Friscix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Friscix.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,146 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  ARM RISCiX version.\n-   Copyright (C) 1993, 1994, 1995, 1997, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Richard Earnshaw (rwe11@cl.cam.ac.uk), based on original\n-\t      work by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n-   \t      and Martin Simmons (@harleqn.co.uk).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Translation to find startup files.  On RISC iX boxes,\n-   crt0, mcrt0 and gcrt0.o are in /usr/lib.  */\n-#define STARTFILE_SPEC  \"\\\n-  %{pg:/usr/lib/gcrt0.o%s}\\\n-  %{!pg:%{p:/usr/lib/mcrt0.o%s}\\\n-        %{!p:/usr/lib/crt0.o%s}}\"\n-\n-/* RISC iX has no concept of -lg */\n-/* If -static is specified then link with -lc_n */\n-\n-#ifndef LIB_SPEC\n-#define LIB_SPEC \"\\\n-  %{g*:-lg}\\\n-  %{!p:%{!pg:%{!static:-lc}%{static:-lc_n}}}\\\n-  %{p:-lc_p}\\\n-  %{pg:-lc_p}\"\n-#endif\n-  \n-/* The RISC iX assembler never deletes any symbols from the object module;\n-   and, by default, ld doesn't either.  -X causes local symbols starting\n-   with 'L' to be deleted, which is what we want.  */\n-#ifndef LINK_SPEC\n-#define LINK_SPEC \"-X\"\n-#endif\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define_std (\"arm\");\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define_std (\"riscix\");\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-    } while (0)\n-\n-/* RISCiX has some weird symbol name munging, that is done to the object module\n-   after assembly, which enables multiple libraries to be supported within\n-   one (possibly shared) library.  It basically changes the symbol name of\n-   certain symbols (for example _bcopy is converted to _$bcopy if using BSD)\n-   Symrename's parameters are determined as follows:\n-     -mno-symrename\tDon't run symrename\n-     -mbsd\tsymrename -BSD <file>\n-     -mxopen\tsymrename -XOPEN <file>\n-     -ansi\tsymrename - <file>\n-     <none>\tsymrename -BSD <file>\n- */\n-\n-#ifndef ASM_FINAL_SPEC\n-#if !defined (CROSS_COMPILE)\n-#define ASM_FINAL_SPEC \"\\\n-%{!mno-symrename: \\\n-\t\\n /usr/bin/symrename \\\n-\t-%{mbsd:%{pedantic:%e-mbsd and -pedantic incompatible}BSD}\\\n-%{mxopen:%{mbsd:%e-mbsd and -mxopen incompatible}\\\n-%{pedantic:%e-mxopen and -pedantic incompatible}XOPEN}\\\n-%{!mbsd:%{!mxopen:%{!ansi:BSD}}} %{c:%{o*:%*}%{!o*:%b.o}}%{!c:%U.o}}\"\n-#endif\n-#endif\n-\n-/* None of these is actually used in cc1.  If we don't define them in target\n-   switches cc1 complains about them.  For the sake of argument lets allocate\n-   bit 31 of target flags for such options.  */\n-#define SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n-  {\"bsd\",\t   0x80000000, N_(\"Do symbol renaming for BSD\")},\t\\\n-  {\"xopen\",\t   0x80000000, N_(\"Do symbol renaming for X/OPEN\")},\t\\\n-  {\"no-symrename\", 0x80000000, N_(\"Don't do symbol renaming\")},\n-    \n-\n-/* Run-time Target Specification.  */\n-#define TARGET_VERSION  \\\n-  fputs (\" (ARM/RISCiX)\", stderr);\n-\n-/* This is used in ASM_FILE_START */\n-#define ARM_OS_NAME \"RISCiX\"\n-\n-/* Unsigned chars produces much better code than signed.  */\n-#define DEFAULT_SIGNED_CHAR  0\n-\n-/* Some systems use __main in a way incompatible with its use in gcc, in these\n-   cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n-   give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or neither. */\n-#ifndef NAME__MAIN\n-#define NAME__MAIN \"__gccmain\"\n-#define SYMBOL__MAIN __gccmain\n-#endif\n-\n-/* size_t is \"unsigned int\" in RISCiX */\n-#define SIZE_TYPE \"unsigned int\"\n-\n-/* ptrdiff_t is \"int\" in RISCiX */\n-#define PTRDIFF_TYPE \"int\"\n-\n-/* Maths operation domain error number, EDOM */\n-#define TARGET_EDOM 33\n-\n-/* Override the normal default CPU */\n-#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm2\n-\n-/* r10 is reserved by RISCiX  */\n-#define SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\\\n-  fixed_regs[10] = 1;\t\t\t\t\\\n-  call_used_regs[10] = 1;\n-\n-#include \"arm/aout.h\"\n-\n-/* The RISCiX assembler does not understand .set */\n-#undef SET_ASM_OP\n-\n-/* Add to CPP_SPEC, we want to add the right #defines when using the include\n-   files.  */\n-#define SUBTARGET_CPP_SPEC \"\\\n-\t%{mbsd:%{pedantic:%e-mbsd and -pedantic incompatible} -D_BSD_C} \\\n-\t%{mxopen:%{mbsd:%e-mbsd and -mxopen incompatible} \t\t\\\n-\t  %{pedantic:%e-mxopen and -pedantic incompatible} -D_XOPEN_C}  \\\n-\t%{!mbsd:%{!mxopen:%{!ansi: -D_BSD_C}}}\"\n-\n-/* The native RISCiX assembler does not support stabs of any kind; because\n-   the native assembler is not used by the compiler, Acorn didn't feel it was\n-   necessary to put them in!  */\n-\n-#ifdef DBX_DEBUGGING_INFO\n-#undef DBX_DEBUGGING_INFO\n-#endif"}, {"sha": "aadbc6c3b1b6d2d856e683c34767cf3c8502875c", "filename": "gcc/config/arm/riscix1-1.h", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Friscix1-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Friscix1-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Friscix1-1.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,107 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  ARM RISCiX 1.1x version.\n-   Copyright (C) 1993, 1995, 1997, 1999 Free Software Foundation, Inc.\n-   Contributed by Richard Earnshaw (rwe11@cl.cam.ac.uk), based on original\n-\t      work by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n-   \t      and Martin Simmons (@harleqn.co.uk).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* RISCiX 1.1x is basically the same as 1.2x except that it doesn't have\n-   symrename or atexit. */\n-\n-/* Translation to find startup files.  On RISCiX boxes, gcrt0.o is in\n-   /usr/lib.  */\n-#define STARTFILE_SPEC  \\\n-  \"%{pg:/usr/lib/gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\"\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define_std (\"arm\");\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define_std (\"riscix\");\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-    } while (0)\n-\n-/* Riscix 1.1 doesn't have X/OPEN support, so only accept -mbsd (but ignore\n-   it).  \n-   By not having -mxopen and -mno-symrename, we get warning messages,\n-   but everything still compiles.  */\n-/* None of these is actually used in cc1, so they modify bit 31 */\n-#define SUBTARGET_SWITCHES \\\n-{\"bsd\", 0x80000000, \"\"}, \n-    \n-\n-/* Run-time Target Specification.  */\n-#define TARGET_VERSION  \\\n-  fputs (\" (ARM/RISCiX)\", stderr);\n-\n-/* This is used in ASM_FILE_START */\n-#define ARM_OS_NAME \"RISCiX\"\n-\n-#ifdef riscos\n-#define TARGET_WHEN_DEBUGGING  3\n-#else\n-#define TARGET_WHEN_DEBUGGING  1\n-#endif\n-\n-/* 'char' is signed by default on RISCiX, unsigned on RISCOS.  */\n-#ifdef riscos\n-#define DEFAULT_SIGNED_CHAR  0\n-#else\n-#define DEFAULT_SIGNED_CHAR  1\n-#endif\n-\n-/* Define this if the target system lacks the function atexit from the\n-   ANSI C standard.  If this is defined, and ON_EXIT is not\n-   defined, a default exit function will be provided to support C++.  \n-   The man page only describes on_exit, but atexit is also there.  \n-   This seems to be missing in early versions.\n-\n-   FIXME Should we define ON_EXIT here?  */\n-#define NEED_ATEXIT\n-\n-/* Some systems use __main in a way incompatible with its use in gcc, in these\n-   cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n-   give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or neither. */\n-#ifndef NAME__MAIN\n-#define NAME__MAIN \"__gccmain\"\n-#define SYMBOL__MAIN __gccmain\n-#endif\n-\n-/* Override the normal default CPU */\n-#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm2\n-\n-/* r10 is reserved by RISCiX  */\n-#define SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\\\n-  fixed_regs[10] = 1;\t\t\t\t\\\n-  call_used_regs[10] = 1;\n-\n-\n-#include \"arm/aout.h\"\n-\n-#define SUBTARGET_CPP_SPEC \"%{!ansi: -D_BSD_C}\"\n-\n-\n-/* The native RISCiX assembler does not support stabs of any kind; because\n-   the native assembler is not used by the compiler, Acorn didn't feel it was\n-   necessary to put them in!  */\n-\n-#ifdef DBX_DEBUGGING_INFO\n-#undef DBX_DEBUGGING_INFO\n-#endif"}, {"sha": "cfb5312f3b6cc3dd1ca7ebfb9cef750d97a03c8c", "filename": "gcc/config/arm/rix-gas.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Frix-gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Frix-gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Frix-gas.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,42 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  ARM RISCiX(stabs) version.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-   Contributed by Richard Earnshaw (rwe11@cl.cam.ac.uk), based on original\n-\t      work by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n-   \t      and Martin Simmons (@harleqn.co.uk).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Limit the length of a stabs entry (for the broken Acorn assembler) */\n-#undef  DBX_CONTIN_LENGTH\n-#define DBX_CONTIN_LENGTH 80\n-\n-/* The native RISCiX assembler does not support stabs of any kind; because\n-   the native assembler is not used by the compiler, Acorn didn't feel it was\n-   necessary to put them in!  \n-   However, this file assumes that we have an assembler that does have stabs,\n-   so we put them back in.  */\n-\n-#define DBX_DEBUGGING_INFO\n-\n-/* Unfortunately dbx doesn't understand these */\n-/* Dbx on RISCiX is so broken that I've given up trying to support it.\n-   lets just support gdb. */\n-/* #define DEFAULT_GDB_EXTENSIONS 0 */\n-/* RISCiX dbx doesn't accept xrefs */\n-/* #define DBX_NO_XREFS 1 */\n-"}, {"sha": "0d38cb0bb551044d39e9bdb422d9957691686b33", "filename": "gcc/config/arm/t-riscix", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Ft-riscix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Farm%2Ft-riscix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-riscix?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,6 +0,0 @@\n-# Just for these, we omit the frame pointer since it makes such a big\n-# difference.  It is then pointless adding debugging.\n-TARGET_LIBGCC2_CFLAGS = -fomit-frame-pointer\n-LIBGCC2_DEBUG_CFLAGS = -g0\n-\n-FIXPROTO_DEFINES= -D_POSIX_SOURCE -D_XOPEN_C -D_BSD_C -D_XOPEN_SOURCE"}, {"sha": "bfdb7c7b9dad58a13bed627702aadbc4a53dbafc", "filename": "gcc/config/clipper/clipper-protos.h", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,38 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Clipper version.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-#ifdef TREE_CODE\n-extern void clipper_va_start PARAMS ((int, tree, rtx));\n-extern rtx clipper_va_arg PARAMS ((tree, tree));\n-#endif /* TREE_CODE */\n-extern void clipper_movstr PARAMS ((rtx *));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern const char *rev_cond_name PARAMS ((rtx));\n-extern int int_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int fp_reg_operand PARAMS ((rtx, enum machine_mode));\n-#endif /* RTX_CODE */\n-\n-extern struct rtx_def *clipper_builtin_saveregs PARAMS ((void));\n-extern int clipper_frame_size PARAMS ((int));\n-#ifdef TREE_CODE\n-extern tree clipper_build_va_list PARAMS ((void));\n-#endif /* TREE_CODE */"}, {"sha": "96c1caa7a6ea4ac3c036175fd5491fed1a8e7de7", "filename": "gcc/config/clipper/clipper.c", "status": "removed", "additions": 0, "deletions": 692, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,692 +0,0 @@\n-/* Subroutines for insn-output.c for Clipper\n-   Copyright (C) 1987, 1988, 1991, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n-   Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"libfuncs.h\"\n-#include \"c-tree.h\"\n-#include \"function.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-static void clipper_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void clipper_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void clix_asm_out_constructor PARAMS ((rtx, int));\n-static void clix_asm_out_destructor PARAMS ((rtx, int));\n-\n-extern char regs_ever_live[];\n-\n-extern int frame_pointer_needed;\n-\n-static int frame_size;\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE clipper_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE clipper_output_function_epilogue\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Compute size of a clipper stack frame where 'lsize' is the required\n-   space for local variables.  */\n-\n-int\n-clipper_frame_size (lsize)\n-     int lsize;\n-{\n-  int i, size;\t\t\t\t/* total size of frame */\n-  int save_size;\n-  save_size = 0;\t\t\t/* compute size for reg saves */\n-\n-  for (i = 16; i < 32; i++)\n-    if (regs_ever_live[i] && !call_used_regs[i])\n-      save_size += 8;\n-\n-  for (i = 0; i < 16; i++)\n-    if (regs_ever_live[i] && !call_used_regs[i])\n-      save_size += 4;\n-\n-  size = lsize + save_size;\n-\n-  size = (size + 7) & ~7;\t\t/* align to 64 Bit */\n-  return size;\n-}\n-\n-/* Prologue and epilogue output\n-   Function is entered with pc pushed, i.e. stack is 32 bit aligned\n-\n-   current_function_args_size == 0 means that the current function's args\n-   are passed totally in registers i.e fp is not used as ap.\n-   If frame_size is also 0 the current function does not push anything and\n-   can run with misaligned stack -> subq $4,sp / add $4,sp on entry and exit\n-   can be omitted.  */\n-\n-static void\n-clipper_output_function_prologue (file, lsize)\n-     FILE *file;\n-     HOST_WIDE_INT lsize;\t\t\t/* size for locals */\n-{\n-  int i, offset;\n-  int size;\n-\n-  frame_size = size = clipper_frame_size (lsize);\n-\n-  if (frame_pointer_needed)\n-    {\n-      fputs (\"\\tpushw  fp,sp\\n\", file);\n-      fputs (\"\\tmovw   sp,fp\\n\", file);\n-    }\n-  else if (size != 0 || current_function_args_size != 0)\n-    {\n-      size += 4;\t\t\t/* keep stack aligned */\n-      frame_size = size;\t\t/* must push data or access args */\n-    }\n-\n-  if (size)\n-    {\n-      if (size < 16)\n-\tfprintf (file, \"\\tsubq   $%d,sp\\n\", size);\n-      else\n-\tfprintf (file, \"\\tsubi   $%d,sp\\n\", size);\n-\n-      /* register save slots are relative to sp, because we have small positive\n-\t displacements and this works whether we have a frame pointer or not */\n-\n-      offset = 0;\n-      for (i = 16; i < 32; i++)\n-\tif (regs_ever_live[i] && !call_used_regs[i])\n-\t  {\n-\t    if (offset == 0)\n-\t      fprintf (file, \"\\tstord  f%d,(sp)\\n\", i-16);\n-\t    else\n-\t      fprintf (file, \"\\tstord  f%d,%d(sp)\\n\", i-16, offset);\n-\t    offset += 8;\n-\t  }\n-\n-      for (i = 0; i < 16; i++)\n-\tif (regs_ever_live[i] && !call_used_regs[i])\n-\t  {\n-\t    if (offset == 0)\n-\t      fprintf (file, \"\\tstorw  r%d,(sp)\\n\", i);\n-\t    else\n-\t      fprintf (file, \"\\tstorw  r%d,%d(sp)\\n\", i, offset);\n-\t    offset += 4;\n-\t  }\n-    }\n-}\n-\n-static void\n-clipper_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  int i, offset;\n-\n-  if (frame_pointer_needed)\n-    {\n-      offset = -frame_size;\n-\n-      for (i = 16; i < 32; i++)\n-\tif (regs_ever_live[i] && !call_used_regs[i])\n-\t  {\n-\t    fprintf (file, \"\\tloadd  %d(fp),f%d\\n\", offset, i-16);\n-\t    offset += 8;\n-\t  }\n-\n-      for (i = 0; i < 16; i++)\n-\tif (regs_ever_live[i] && !call_used_regs[i])\n-\t  {\n-\t    fprintf (file, \"\\tloadw  %d(fp),r%d\\n\", offset, i);\n-\t    offset += 4;\n-\t  }\n-\n-      fputs (\"\\tmovw   fp,sp\\n\\tpopw   sp,fp\\n\\tret    sp\\n\",\n-\t     file);\n-    }\n-\n-  else\t\t\t\t\t/* no frame pointer */\n-    {\n-      offset = 0;\n-\n-      for (i = 16; i < 32; i++)\n-\tif (regs_ever_live[i] && !call_used_regs[i])\n-\t  {\n-\t    if (offset == 0)\n-\t      fprintf (file, \"\\tloadd  (sp),f%d\\n\", i-16);\n-\t    else\n-\t      fprintf (file, \"\\tloadd  %d(sp),f%d\\n\", offset, i-16);\n-\t    offset += 8;\n-\t  }\n-\n-      for (i = 0; i < 16; i++)\n-\tif (regs_ever_live[i] && !call_used_regs[i])\n-\t  {\n-\t    if (offset == 0)\n-\t      fprintf (file, \"\\tloadw  (sp),r%d\\n\", i);\n-\t    else\n-\t      fprintf (file, \"\\tloadw  %d(sp),r%d\\n\", offset, i);\n-\t    offset += 4;\n-\t  }\n-\n-      if (frame_size > 0)\n-\t{\n-\t  if (frame_size < 16)\n-\t    fprintf (file, \"\\taddq   $%d,sp\\n\", frame_size);\n-\t  else\n-\t    fprintf (file, \"\\taddi   $%d,sp\\n\", frame_size);\n-\t}\n-\n-      fputs (\"\\tret    sp\\n\", file);\n-    }\n-}\n-\n-/*\n- * blockmove\n- *\n- * clipper_movstr ()\n- */\n-void\n-clipper_movstr (operands)\n-     rtx *operands;\n-{\n-  rtx dst,src,cnt,tmp,top,bottom=NULL_RTX,xops[3];\n-  int align;\n-  int fixed;\n-\n-  extern FILE *asm_out_file;\n-\n-  dst = operands[0];\n-  src = operands[1];\n-  /* don't change this operands[2]; gcc 2.3.3 doesn't honor clobber note */\n-  align = INTVAL (operands[3]);\n-  tmp = operands[4];\n-  cnt = operands[5];\n-\n-  if (GET_CODE (operands[2]) == CONST_INT) /* fixed size move */\n-    {\n-      if ((fixed = INTVAL (operands[2])) <= 0)\n-\tabort ();\n-\n-      if (fixed <16)\n-\toutput_asm_insn (\"loadq  %2,%5\", operands);\n-      else\n-\toutput_asm_insn (\"loadi  %2,%5\", operands);\n-    }\n-  else\n-    {\n-      fixed = 0;\n-      bottom = (rtx)gen_label_rtx ();\t/* need a bottom label */\n-      xops[0] = cnt; xops[1] = bottom;\n-      output_asm_insn (\"movw   %2,%5\", operands); /* count is scratch reg 5 */\n-      output_asm_insn (\"brle   %l1\", xops);\n-    }\n-\n-\n-  top = (rtx)gen_label_rtx ();\t\t/* top of loop label */\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (top));\n-\n-\n-  xops[0] = src; xops[1] = tmp; xops[2] = dst;\n-\n-  if (fixed && (align & 0x3) == 0)\t/* word aligned move with known size */\n-    {\n-      if (fixed >= 4)\n-\t{\n-\t  rtx xops1[2];\n-\t  output_asm_insn(\n-\t    \"loadw  %a0,%1\\n\\taddq   $4,%0\\n\\tstorw  %1,%a2\\n\\taddq   $4,%2\",\n-\t\t\t  xops);\n-\n-\t  xops1[0] = cnt; xops1[1] = top;\n-\t  output_asm_insn (\"subq   $4,%0\\n\\tbrgt   %l1\", xops1);\n-\t}\n-\n-      if (fixed & 0x2)\n-\t{\n-\t  output_asm_insn (\"loadh  %a0,%1\\n\\tstorh  %1,%a2\", xops);\n-\t  if (fixed & 0x1)\n-\t    output_asm_insn (\"loadb  2%a0,%1\\n\\tstorb  %1,2%a2\", xops);\n-\t}\n-      else\n-\tif (fixed & 0x1)\n-\t  output_asm_insn (\"loadb  %a0,%1\\n\\tstorb  %1,%a2\", xops);\n-    }\n-  else\n-    {\n-      output_asm_insn(\n-\t  \"loadb  %a0,%1\\n\\taddq   $1,%0\\n\\tstorb  %1,%a2\\n\\taddq   $1,%2\",\n-\t\t      xops);\n-\n-      xops[0] = cnt; xops[1] = top;\n-      output_asm_insn (\"subq   $1,%0\\n\\tbrgt   %l1\", xops);\n-    }\n-\n-  if (fixed == 0)\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (bottom));\n-}\n-\n-\f\n-void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     register rtx addr;\n-{\n-  rtx op0,op1;\n-\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      fprintf (file, \"(%s)\", reg_names[REGNO (addr)]);\n-      break;\n-\n-    case PLUS:\n-      /* can be 'symbol + reg' or 'reg + reg' */\n-\n-      op0 = XEXP (addr, 0);\n-      op1 = XEXP (addr, 1);\n-\n-      if (GET_CODE (op0) == REG && GET_CODE (op1) == REG)\n-\t{\n-\t  fprintf (file, \"[%s](%s)\",\n-\t\t   reg_names[REGNO (op0)], reg_names[REGNO (op1)]);\n-\t  break;\n-\t}\n-\n-      if (GET_CODE (op0) == REG && CONSTANT_ADDRESS_P (op1))\n-\t{\n-\t  output_addr_const (file, op1);\n-\t  fprintf (file, \"(%s)\", reg_names[REGNO (op0)]);\n-\t  break;\n-\t}\n-\n-      if (GET_CODE (op1) == REG && CONSTANT_ADDRESS_P (op0))\n-\t{\n-\t  output_addr_const (file, op0);\n-\t  fprintf (file, \"(%s)\", reg_names[REGNO (op1)]);\n-\t  break;\n-\t}\n-      abort ();\t\t\t\t/* Oh no */\n-\n-    default:\n-      output_addr_const (file, addr);\n-    }\n-}\n-\n-\f\n-const char *\n-rev_cond_name (op)\n-     rtx op;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case EQ:\n-      return \"ne\";\n-    case NE:\n-      return \"eq\";\n-    case LT:\n-      return \"ge\";\n-    case LE:\n-      return \"gt\";\n-    case GT:\n-      return \"le\";\n-    case GE:\n-      return \"lt\";\n-    case LTU:\n-      return \"geu\";\n-    case LEU:\n-      return \"gtu\";\n-    case GTU:\n-      return \"leu\";\n-    case GEU:\n-      return \"ltu\";\n-\n-    default:\n-      abort ();\n-    }\n-}\n-\n-\f\n-/* Dump the argument register to the stack; return the location\n-   of the block.  */\n-\n-struct rtx_def *\n-clipper_builtin_saveregs ()\n-{\n-  rtx block, addr, r0_addr, r1_addr, f0_addr, f1_addr, mem;\n-  int set = get_varargs_alias_set ();\n-\n-  /* Allocate the save area for r0,r1,f0,f1 */\n-\n-  block = assign_stack_local (BLKmode, 6 * UNITS_PER_WORD, 2 * BITS_PER_WORD);\n-\n-  RTX_UNCHANGING_P (block) = 1;\n-  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n-\n-  addr = XEXP (block, 0);\n-\n-  r0_addr = addr;\n-  r1_addr = plus_constant (addr, 4);\n-  f0_addr = plus_constant (addr, 8);\n-  f1_addr = plus_constant (addr, 16);\n-\n-  /* Store int regs  */\n-\n-  mem = gen_rtx_MEM (SImode, r0_addr);\n-  set_mem_alias_set (mem, set);\n-  emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n-\n-  mem = gen_rtx_MEM (SImode, r1_addr);\n-  set_mem_alias_set (mem, set);\n-  emit_move_insn (mem, gen_rtx_REG (SImode, 1));\n-\n-  /* Store float regs  */\n-\n-  mem = gen_rtx_MEM (DFmode, f0_addr);\n-  set_mem_alias_set (mem, set);\n-  emit_move_insn (mem, gen_rtx_REG (DFmode, 16));\n-\n-  mem = gen_rtx_MEM (DFmode, f1_addr);\n-  set_mem_alias_set (mem, set);\n-  emit_move_insn (mem, gen_rtx_REG (DFmode, 17));\n-\n-  return addr;\n-}\n-\n-tree\n-clipper_build_va_list ()\n-{\n-  tree record, ap, reg, num;\n-\n-  /*\n-    struct\n-    {\n-      int __va_ap;\t\t// pointer to stack args\n-      void *__va_reg[4];\t// pointer to r0,f0,r1,f1\n-      int __va_num;\t\t// number of args processed\n-    };\n-  */\n-\n-  record = make_node (RECORD_TYPE);\n-\n-  num = build_decl (FIELD_DECL, get_identifier (\"__va_num\"),\n-\t\t    integer_type_node);\n-  DECL_FIELD_CONTEXT (num) = record;\n-\n-  reg = build_decl (FIELD_DECL, get_identifier (\"__va_reg\"),\n-\t\t    build_array_type (ptr_type_node,\n-\t\t\t\t      build_index_type (build_int_2 (3, 0))));\n-  DECL_FIELD_CONTEXT (reg) = record;\n-  TREE_CHAIN (reg) = num;\n-\n-  ap = build_decl (FIELD_DECL, get_identifier (\"__va_ap\"),\n-\t\t   integer_type_node);\n-  DECL_FIELD_CONTEXT (ap) = record;\n-  TREE_CHAIN (ap) = reg;\n-\n-  TYPE_FIELDS (record) = ap;\n-  layout_type (record);\n-\n-  return record;\n-}\n-\n-void\n-clipper_va_start (stdarg_p, valist, nextarg)\n-     int stdarg_p;\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n-{\n-  tree ap_field, reg_field, num_field;\n-  tree t, u, save_area;\n-\n-  ap_field = TYPE_FIELDS (TREE_TYPE (valist));\n-  reg_field = TREE_CHAIN (ap_field);\n-  num_field = TREE_CHAIN (reg_field);\n-\n-  ap_field = build (COMPONENT_REF, TREE_TYPE (ap_field), valist, ap_field);\n-  reg_field = build (COMPONENT_REF, TREE_TYPE (reg_field), valist, reg_field);\n-  num_field = build (COMPONENT_REF, TREE_TYPE (num_field), valist, num_field);\n-\n-  /* Call __builtin_saveregs to save r0, r1, f0, and f1 in a block.  */\n-\n-  save_area = make_tree (integer_type_node, expand_builtin_saveregs ());\n-\n-  /* Set __va_ap.  */\n-\n-  t = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n-  if (stdarg_p && current_function_args_info.size != 0)\n-    t = build (PLUS_EXPR, ptr_type_node, t,\n-\t       build_int_2 (current_function_args_info.size, 0));\n-  t = build (MODIFY_EXPR, TREE_TYPE (ap_field), ap_field, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* Set the four entries of __va_reg.  */\n-\n-  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n-  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int_2 (0, 0));\n-  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  t = fold (build (PLUS_EXPR, integer_type_node, save_area,\n-\t\t   build_int_2 (8, 0)));\n-  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n-  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int_2 (1, 0));\n-  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  t = fold (build (PLUS_EXPR, integer_type_node, save_area,\n-\t\t   build_int_2 (4, 0)));\n-  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n-  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int_2 (2, 0));\n-  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  t = fold (build (PLUS_EXPR, integer_type_node, save_area,\n-\t\t   build_int_2 (16, 0)));\n-  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n-  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int_2 (3, 0));\n-  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* Set __va_num.  */\n-\n-  t = build_int_2 (current_function_args_info.num, 0);\n-  t = build (MODIFY_EXPR, TREE_TYPE (num_field), num_field, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-}\n-\n-rtx\n-clipper_va_arg (valist, type)\n-     tree valist, type;\n-{\n-  tree ap_field, reg_field, num_field;\n-  tree addr, t;\n-  HOST_WIDE_INT align;\n-  rtx addr_rtx, over_label = NULL_RTX, tr;\n-\n-  /*\n-    Integers:\n-\n-    if (VA.__va_num < 2)\n-      addr = VA.__va_reg[2 * VA.__va_num];\n-    else\n-      addr = round(VA.__va_ap), VA.__va_ap = round(VA.__va_ap) + sizeof(TYPE);\n-    VA.__va_num++;\n-\n-    Floats:\n-\n-    if (VA.__va_num < 2)\n-      addr = VA.__va_reg[2 * VA.__va_num + 1];\n-    else\n-      addr = round(VA.__va_ap), VA.__va_ap = round(VA.__va_ap) + sizeof(TYPE);\n-    VA.__va_num++;\n-\n-    Aggregates:\n-\n-    addr = round(VA.__va_ap), VA.__va_ap = round(VA.__va_ap) + sizeof(TYPE);\n-    VA.__va_num++;\n-  */\n-\n-  ap_field = TYPE_FIELDS (TREE_TYPE (valist));\n-  reg_field = TREE_CHAIN (ap_field);\n-  num_field = TREE_CHAIN (reg_field);\n-\n-  ap_field = build (COMPONENT_REF, TREE_TYPE (ap_field), valist, ap_field);\n-  reg_field = build (COMPONENT_REF, TREE_TYPE (reg_field), valist, reg_field);\n-  num_field = build (COMPONENT_REF, TREE_TYPE (num_field), valist, num_field);\n-\n-  addr_rtx = gen_reg_rtx (Pmode);\n-\n-  if (! AGGREGATE_TYPE_P (type))\n-    {\n-      tree inreg;\n-      rtx false_label;\n-\n-      over_label = gen_label_rtx ();\n-      false_label = gen_label_rtx ();\n-\n-      emit_cmp_and_jump_insns (expand_expr (num_field, NULL_RTX, 0,\n-\t\t\t\t\t    OPTAB_LIB_WIDEN),\n-\t\t\t       GEN_INT (2), GE, const0_rtx,\n-\t\t\t       TYPE_MODE (TREE_TYPE (num_field)),\n-\t\t\t       TREE_UNSIGNED (num_field), false_label);\n-\n-      inreg = fold (build (MULT_EXPR, integer_type_node, num_field,\n-\t\t\t   build_int_2 (2, 0)));\n-      if (FLOAT_TYPE_P (type))\n-\tinreg = fold (build (PLUS_EXPR, integer_type_node, inreg,\n-\t\t\t     build_int_2 (1, 0)));\n-      inreg = fold (build (ARRAY_REF, ptr_type_node, reg_field, inreg));\n-\n-      tr = expand_expr (inreg, addr_rtx, VOIDmode, EXPAND_NORMAL);\n-      if (tr != addr_rtx)\n-\temit_move_insn (addr_rtx, tr);\n-\n-      emit_jump_insn (gen_jump (over_label));\n-      emit_barrier ();\n-      emit_label (false_label);\n-    }\n-\n-  /* Round to alignment of `type', or at least integer alignment.  */\n-\n-  align = TYPE_ALIGN (type);\n-  if (align < TYPE_ALIGN (integer_type_node))\n-    align = TYPE_ALIGN (integer_type_node);\n-  align /= BITS_PER_UNIT;\n-\n-  addr = fold (build (PLUS_EXPR, ptr_type_node, ap_field,\n-\t\t      build_int_2 (align-1, 0)));\n-  addr = fold (build (BIT_AND_EXPR, ptr_type_node, addr,\n-\t\t      build_int_2 (-align, -1)));\n-  addr = save_expr (addr);\n-\n-  tr = expand_expr (addr, addr_rtx, Pmode, EXPAND_NORMAL);\n-  if (tr != addr_rtx)\n-    emit_move_insn (addr_rtx, tr);\n-  \n-  t = build (MODIFY_EXPR, TREE_TYPE (ap_field), ap_field,\n-\t     build (PLUS_EXPR, TREE_TYPE (ap_field), \n-\t\t    addr, build_int_2 (int_size_in_bytes (type), 0)));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  if (over_label)\n-    emit_label (over_label);\n-\n-  t = build (MODIFY_EXPR, TREE_TYPE (num_field), num_field,\n-\t     build (PLUS_EXPR, TREE_TYPE (num_field), \n-\t\t    num_field, build_int_2 (1, 0)));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  return addr_rtx;\n-}\n-\n-/* Return truth value of whether OP can be used as an word register\n-   operand. Reject (SUBREG:SI (REG:SF )) */\n-\n-int\n-int_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) &&\n-\t  (GET_CODE (op) != SUBREG ||\n-\t   GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) == MODE_INT));\n-}\n-\n-/* Return truth value of whether OP can be used as a float register\n-   operand. Reject (SUBREG:SF (REG:SI )) )) */\n-\n-int\n-fp_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) &&\n-\t  (GET_CODE (op) != SUBREG ||\n-\t   GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) == MODE_FLOAT));\n-}\n-\n-static void\n-clix_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n-{\n-  init_section ();\n-  fputs (\"\\tloada  \", asm_out_file);\n-  assemble_name (asm_out_file, XSTR (symbol, 0));\n-  fputs (\",r0\\n\\tsubq   $8,sp\\n\\tstorw   r0,(sp)\\n\", asm_out_file);\n-}\n-\n-static void\n-clix_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n-{\n-  fini_section ();\n-  assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n-  assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n-}"}, {"sha": "90e8ae8749d2efc91af549f684310ff36667c4d3", "filename": "gcc/config/clipper/clipper.h", "status": "removed", "additions": 0, "deletions": 1037, "changes": 1037, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1037 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Clipper version.\n-   Copyright (C) 1987, 1988, 1991, 1993, 1994, 1995, 1996, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n-   Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (clipper)\");\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES\t\t\t\t\t\t\\\n-  { { \"c400\", 1, N_(\"Generate code for the C400\") },\t\t\\\n-    { \"c300\", -1, N_(\"Generate code for the C300\") },\t\t\\\n-    { \"\", TARGET_DEFAULT, NULL} }\n-\n-#define TARGET_C400 1\n-#define TARGET_C300 0\n-\n-/* Default target_flags if no switches specified.  */\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT TARGET_C300\n-#endif\n-\n-/* Show that we can debug generated code without a frame pointer.  */\n-#define CAN_DEBUG_WITHOUT_FP\n-\f\n-/* Target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields. */\n-\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n-\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Largest alignment for stack parameters (if greater than PARM_BOUNDARY).  */\n-#define MAX_PARM_BOUNDARY 64\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 128\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* No structure field wants to be aligned rounder than this.  */\n-#define BIGGEST_FIELD_ALIGNMENT 64\n-\n-/*  Make strcpy of constants fast. */\n-#define CONSTANT_ALIGNMENT(CODE, TYPEALIGN) \\\n-  ((TYPEALIGN) < 32 ? 32 : (TYPEALIGN))\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\n-/* Let's keep the stack somewhat aligned.  */\n-#define STACK_BOUNDARY 64\n-\n-/* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases, \n-   the value is constrained to be within the bounds of the declared\n-   type, but kept valid in the wider mode.  The signedness of the\n-   extension may differ from that of the type.\n-\n-   For Clipper, we always store objects in a full register. */\n-\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n-    {\t\t\t\t\t\t\\\n-      (UNSIGNEDP) = 0;\t\t\t\t\\\n-      (MODE) = SImode;\t\t\t\t\\\n-    }\n-\n-\n-/* Define this if function arguments should also be promoted using the above\n-   procedure.  */\n-\n-/* FIXME: do we loose compatibility to acc if we define this? */\n-\n-/* #define PROMOTE_FUNCTION_ARGS */\n-\n-/* Likewise, if the function return value is promoted.  */\n-\n-/* #define PROMOTE_FUNCTION_RETURN */\n-\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER 32\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   On the clipper, these are the FP and SP .  */\n-#define FIXED_REGISTERS \\\n-{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\\\n- 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1} /* Default: C300 */\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS \\\n-{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\\\n- 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1} /* default: C300 */\n-\n-/* Zero or more C statements that may conditionally modify two\n-   variables `fixed_regs' and `call_used_regs' (both of type `char\n-   []') after they have been initialized from the two preceding\n-   macros. A C400 has additional floating registers f8 -> f15 */\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\\\n-   if (target_flags & TARGET_C400)\t\\\n-     { int i;\t\t\t\t\\\n-       for (i = 24; i < 32; i++) fixed_regs[i] = call_used_regs[i] = 0; }\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-   On the clipper, fp registers are 64 bits.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) >= 16 ? 1 \\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the clipper 0-15 may hold any mode but DImode and DFmode must be even.\n-   Registers 16-31 hold SFmode and DFmode */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  ((REGNO) < 16 \t\t\t\t\t\t\t\\\n-   ? (((MODE) != DImode && (MODE) != DFmode) || ((REGNO) & 1) == 0)\t\\\n-   : ((MODE) == SFmode || (MODE) == DFmode))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)  ((MODE1) == (MODE2))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* clipper has extra PC  */\n-/* #define PC_REGNUM */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 15\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 14\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED \\\n-   (! leaf_function_p ())\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 2\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 0\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-/* The clipper has general and FP regs.  */\n-\n-enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS, LIM_REG_CLASSES};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"GENERAL_REGS\", \"FLOAT_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS { {0}, {0x0000ffff}, {0xffff0000}, {0xffffffff} }\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) ((REGNO) >= 16 ? FLOAT_REGS : GENERAL_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'r' ? GENERAL_REGS : ((C) == 'f' ? FLOAT_REGS: NO_REGS))\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C. */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) 0\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself. */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n-\n-/* Optional extra constraints for this machine. */\n-\n-/* #define EXTRA_CONSTRAINT(OP, C) */\n-\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FLOAT_REGS\t\t\t\\\n-  ? 1\t\t\t\t\t\\\n-  : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* Given an rtx for the address of a frame,\n-   return an rtx for the address of the word in the frame\n-   that holds the dynamic chain--the previous frame's address.  */\n-#define DYNAMIC_CHAIN_ADDRESS(frame) (frame)\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by. */\n-\n-/* #define PUSH_ROUNDING(BYTES) (BYTES) */\n-\n-/* Keep the stack pointer constant throughout the function. */\n-/* we can't set this for clipper as library calls may have 3 args and we pass\n-   only 2 args in regs. */\n-\n-/* #define ACCUMULATE_OUTGOING_ARGS 1*/\n-  \n-\n-/* Offset of first parameter from the argument pointer register value.\n-   size of PC + FP  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL) 8\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack. */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\\\n-\t\t\t\t      TYPE_MODE (VALTYPE) == DFmode) ? \\\n-\t\t\t\t     16 : 0))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)  \\\n-  gen_rtx_REG ((MODE), ((MODE) == SFmode || (MODE) == DFmode ? 16 : 0))\n-\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 16)\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) \\\n-  ((N) == 0 || (N) == 1 || (N) == 16 || (N) == 17)\n-\n-/* Define this if PCC uses the nonreentrant convention for returning\n-   structure and union values. Old Green Hills C-Clipper returns static\n-   structs but the newer Apogee compiler passes structs as hidden arg 0.\n-   Structs etc are always passed in memory */\n-\n-/* #define PCC_STATIC_STRUCT_RETURN */\n-\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   Clipper uses 2 register 'slots' that pass arguments in r0/r1 or f0/f1.\n-   An argument that must be passed in memory (struct... ) leaves that slot\n-   free.\n-   We pass 'long long' only in registers when both slots are free.\n-   Returned structs must be allocated by the caller, the address is passed\n-   in r0.\n-\n-   struct ss {..}\n-\n-   fun (i,j,k)\t\ti in r0, j in r1, k on stack\n-   fun (s,j,k)\t\ts on stack, j in r1, k on stack\n-   fun (i,s,k)\t\ti in r0, s on stack, k on stack\n-   s1 = fun (i,s,k)\t&s1 in r0, i in r1, s on stack, k on stack\n-\n-   We must keep enough information for varargs/stdargs.\n-\n-   _clipper_cum_args is a struct of 2 integers, with\n-\tnum =  slots used\n-\tsize = size of all stack args = offset to next arg without alignment\n-\n-   If we use stdarg.h, size points to the first unnamed arg,\n-   see va-clipper.h */\n-\n-struct _clipper_cum_args { int num; int size; };\n-\n-#define CUMULATIVE_ARGS struct _clipper_cum_args\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   clipper passes the address of a struct in r0, set num = 1 in this case */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n-  ((CUM).num = ((FNTYPE) != 0 && aggregate_value_p (TREE_TYPE (FNTYPE))), \\\n-   (CUM).size = 0)\n-\n-/* internal helper : size of an argument */\n-\n-#define CLIPPER_ARG_SIZE(MODE, TYPE)\t\t\t\t\\\n-(((MODE) != BLKmode\t\t\t\t\t\t\t\\\n-  ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n-  : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\t\\\n- * UNITS_PER_WORD)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t      \\\n-do\t\t\t\t\t\t\t\t\t      \\\n-{\t\t\t\t\t\t\t\t\t      \\\n-  int reg = 0;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-  if ((CUM).num < 2\t\t\t\t\t\t\t      \\\n-      && (GET_MODE_CLASS(MODE)==MODE_INT || GET_MODE_CLASS(MODE)==MODE_FLOAT) \\\n-      && (GET_MODE_SIZE (MODE) <= 8)\t\t\t\t\t      \\\n-      && ((TYPE) == NULL || !AGGREGATE_TYPE_P(TYPE))\t\t\t      \\\n-      && ((MODE) != DImode || (CUM).num == 0))\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      reg = 1;\t\t\t\t\t\t\t\t      \\\n-      if ((MODE) == DImode)\t\t\t\t\t\t      \\\n-\t(CUM).num = 1;\t\t\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-  (CUM).num++;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-  if (! reg)\t\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      int align = FUNCTION_ARG_BOUNDARY (MODE, TYPE) / BITS_PER_UNIT;\t      \\\n-      (CUM).size += align - 1;\t\t\t\t\t\t      \\\n-      (CUM).size &= ~(align - 1);\t\t\t\t\t      \\\n-      (CUM).size += CLIPPER_ARG_SIZE (MODE, TYPE);\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-} while (0)\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n-\n-   2 args may go into regs. These must be MODE_INT or MODE_FLOAT but only\n-   if they really fit into ONE register. The exception is a DImode arg\n-   that occupies both register slots. */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t     \\\n-  (((CUM).num < 2\t\t\t\t\t\t\t     \\\n-    && (GET_MODE_CLASS(MODE)==MODE_INT || GET_MODE_CLASS(MODE)==MODE_FLOAT)  \\\n-    && (GET_MODE_SIZE (MODE) <= 8)\t\t\t\t\t     \\\n-    && ((TYPE) == NULL || !AGGREGATE_TYPE_P(TYPE))\t\t\t     \\\n-    && ((MODE) != DImode || (CUM).num == 0))\t\t\t\t     \\\n-   ? gen_rtx_REG ((MODE),\t\t\t\t\t\t     \\\n-\t\t  GET_MODE_CLASS(MODE) == MODE_FLOAT\t\t\t     \\\n-\t\t  ? (CUM).num+16 : (CUM).num)\t\t\t\t     \\\n-   : 0)\n-\n-/* If defined, a C expression that gives the alignment boundary, in bits,\n-   of an argument with the specified mode and type.  If it is not defined,\n-   `PARM_BOUNDARY' is used for all arguments.  */\n-\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n-  (((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_SIZE (MODE)) <= PARM_BOUNDARY \\\n-    ? PARM_BOUNDARY : 2 * PARM_BOUNDARY)\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.\n-   Clipper never passed args partially in regs/mem. */\n-\n-/* #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  0 */\n-\n-/* Generate necessary RTL for __builtin_saveregs().\n-   ARGLIST is the argument list; see expr.c.  */\n-\n-#define EXPAND_BUILTIN_SAVEREGS() clipper_builtin_saveregs ()\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  /* FIXME */\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved. */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) \\\n-  DEPTH = clipper_frame_size (get_frame_size ())\n-\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t      \\\n-{\t\t\t\t\t\t\t\t\t      \\\n-  fputs (\"\\t.word  0x459F,0x0004\\t# call   sp,.+4\\n\", FILE);\t\t      \\\n-  fputs (\"\\tmovw   (sp),r3\\n\", FILE);\t\t\t\t\t      \\\n-  fputs (\"\\taddq   $4,sp\\n\", FILE);\t\t\t\t\t      \\\n-  fputs (\"\\tloadw  20(r3),r2\\n\", FILE);\t\t\t\t\t      \\\n-  fputs (\"\\tloadw  24(r3),r3\\n\", FILE);\t\t\t\t\t      \\\n-  fputs (\"\\tb      (r3)\\n\", FILE);\t\t\t\t\t      \\\n-  fputs (\"\\t.long  0,0\\n\", FILE);\t\t\t\t\t      \\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 32\n-\n-/* Alignment required for a trampoline.  128 is used to find the\n-   beginning of a line in the instruction cache and to allow for\n-   instruction cache lines of up to 128 bytes.  */\n-\n-#define TRAMPOLINE_ALIGNMENT 128\n-\n-/* Section in which to place the trampoline.  */\n-\n-#define TRAMPOLINE_SECTION text_section\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 24)), CXT); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 28)), FNADDR); \\\n-}\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(regno)  \\\n-((regno) < 16 || (unsigned)reg_renumber[regno] < 16)\n-#define REGNO_OK_FOR_BASE_P(regno) \\\n-((regno) < 16 || (unsigned)reg_renumber[regno] < 16)\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* 1 if X is an rtx for a constant that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-  /* clipper doesn't have true indexing */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) < 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (REGNO (X) < 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) (REGNO(X) < 16)\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) (REGNO(X) < 16)\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n-\n-/* Non-zero if X is an address which can be indirected. */\n-\n-#define INDIRECTABLE_CONSTANT_ADDRESS_P(X) 0\n-\n-#define INDIRECTABLE_ADDRESS_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n-\n-/* Go to ADDR if X is a valid address not using indexing.\n-   (This much is the easy part.)  */\n-\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)\t\\\n-{ if (CONSTANT_ADDRESS_P (X)) goto ADDR;\t\\\n-  if (INDIRECTABLE_ADDRESS_P (X)) goto ADDR; }\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-{ register rtx xfoo = (X);\t\t\t\\\n-  GO_IF_NONINDEXED_ADDRESS (xfoo, ADDR);\t\\\n-  if (GET_CODE (xfoo) == PLUS)\t\t\t\\\n-    { register rtx xfoo0, xfoo1;\t\t\\\n-      xfoo0 = XEXP (xfoo, 0);\t\t\t\\\n-      xfoo1 = XEXP (xfoo, 1);\t\t\t\\\n-    /* handle reg + reg -> [r1](r0) */\t\t\\\n-      if (INDIRECTABLE_ADDRESS_P (xfoo0) && INDIRECTABLE_ADDRESS_P (xfoo1)) \\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-    /* Handle <symbol>(reg) -> xxx(r0) */\t\t\t\t\\\n-      if (INDIRECTABLE_ADDRESS_P (xfoo0) && CONSTANT_ADDRESS_P (xfoo1))\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-      if (INDIRECTABLE_ADDRESS_P (xfoo1) && CONSTANT_ADDRESS_P (xfoo0))\t\\\n-\tgoto ADDR; }}\n-\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the clipper, nothing needs to be done.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for. */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL) {}\n-\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Define this if the case instruction drops through after the table\n-   when the index is out of range.  Don't define it if the case insn\n-   jumps to the default label instead.  */\n-/* #define CASE_DROPS_THROUGH */\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n-   will either zero-extend or sign-extend.  The value of this macro should\n-   be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n-#define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* This flag, if defined, says the same insns that convert to a signed fixnum\n-   also convert validly to an unsigned one.  */\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n-\n-/* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction pairs, we will do a movstr or libcall instead.\n-\n-   Make this large on clipper, since the block move is very\n-   inefficient with small blocks, and the hard register needs of the\n-   block move require much reload work. */\n-\n-#define MOVE_RATIO 20\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Define if shifts truncate the shift count\n-   which implies one can omit a sign-extension or zero-extension\n-   of a shift count.  */\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE QImode\n-\n-/* This machine uses IEEE floats.  */\n-\n-#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n-\n-/* Check a `double' value for validity for a particular machine mode.\n-   This is defined to avoid crashes outputting certain constants.\n-   Since we output the number in hex, the assembler won't choke on it.  */\n-/* #define CHECK_FLOAT_VALUE(MODE,VALUE) */\n-\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-/* On a Clipper, constants from 0..15 are cheap because they can use the\n-   'quick' mode. */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (0 <= INTVAL (RTX) && INTVAL(RTX) <= 15 ) return 0;\t\\\n-      return 1;\t\t\t\t\t\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 5;\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (4);\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (40);\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\\\n-    return COSTS_N_INSNS (2);\t\t\t\t\\\n- case SIGN_EXTEND:\t\t\t\t\t\\\n-    return (GET_CODE (XEXP (X,0)) == REG ? COSTS_N_INSNS (3) : 4);\n-\n-/* Specify the cost of a branch insn; roughly the number of extra insns that\n-   should be added to avoid a branch */\n-\n-/* #define BRANCH_COST 0 */\n-\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the clipper.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-{\t\t\t\t\t\t\t\t\t      \\\n-  enum attr_cc cc = get_attr_cc (INSN);\t\t\t\t\t      \\\n-  rtx dest = SET_DEST (EXP);\t\t\t\t\t\t      \\\n-  switch (cc)\t\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-    case CC_CHANGE0:\t\t\t\t\t\t\t      \\\n-      if (GET_CODE (EXP) == PARALLEL) abort();\t\t\t\t      \\\n-      if ((cc_status.value1 && rtx_equal_p (dest, cc_status.value1)) ||\t      \\\n-\t  (cc_status.value2 && rtx_equal_p (dest, cc_status.value2)))\t      \\\n-\tCC_STATUS_INIT;\t\t\t\t\t\t\t      \\\n-      break;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-    case CC_SET1:\t\t\t\t\t\t\t      \\\n-      if (GET_CODE (EXP) == PARALLEL) abort();\t\t\t\t      \\\n-      cc_status.flags = 0;\t\t\t\t\t\t      \\\n-      cc_status.value1 = dest;\t\t\t\t\t\t      \\\n-      cc_status.value2 = 0;\t\t\t\t\t\t      \\\n-      break;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-    case CC_SET2:\t\t\t\t\t\t\t      \\\n-      if (GET_CODE (EXP) == PARALLEL) abort();\t\t\t\t      \\\n-      cc_status.flags = 0;\t\t\t\t\t\t      \\\n-      cc_status.value1 = dest;\t\t\t\t\t\t      \\\n-      cc_status.value2 = SET_SRC (EXP);\t\t\t\t\t      \\\n-      break;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-    case CC_UNCHANGED:\t\t\t\t\t\t\t      \\\n-      break;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-    case CC_CLOBBER:\t\t\t\t\t\t\t      \\\n-      CC_STATUS_INIT;\t\t\t\t\t\t\t      \\\n-      break;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-    default:\t\t\t\t\t\t\t\t      \\\n-      abort ();\t\t\t\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-}\n-\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#define ASM_FILE_START(FILE) fprintf (FILE, \"#NO_APP\\n\");\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \\\n- \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"fp\", \"sp\", \\\n- \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \\\n- \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\" }\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tsubq   $8,sp\\n\\t%s  %s,(sp)\\n\",\t\\\n-\t   (REGNO) < 16 ? \"storw\" : \"stord\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\t%s  (sp),%s\\n\\taddq  $8,sp\\n\",\t\\\n-\t   (REGNO) < 16 ? \"loadw\" : \"loadd\", reg_names[REGNO])\n-/* This is how to output an element of a case-vector that is absolute */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter by SIZE bytes.  */\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-/* ??? The use of .bss here seems odd.  */\n-\n-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE,NAME,SIZE,ALIGN)\t\\\n-( data_section (),\t\t\t\t\t\\\n-  fputs (\"\\t.bss\\t\", (FILE)),\t\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\t\\\n-  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN)/BITS_PER_UNIT))\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Print an instruction operand X on file FILE.\n-   CODE is the code from the %-spec that requested printing this operand;\n-   if `%z3' was used to print operand 3, then CODE is 'z'.\n-\n-Clipper operand formatting codes:\n-\n- letter\t   print\n-   C\treverse branch condition\n-*/\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == 'C')\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (CODE == 'C')\t\t\t\t\t\t\t\\\n-    fputs (rev_cond_name (X), FILE);\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n-\n-/* Print a memory operand whose address is X, on file FILE.\n-   This uses a function in output-clipper.c.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n- print_operand_address (FILE, ADDR)\n-\n-/* Define the codes that are matched by predicates in clipper.c */\n-\n-#define PREDICATE_CODES \\\n-  {\"int_reg_operand\", {SUBREG, REG}},\t\\\n-  {\"fp_reg_operand\", {SUBREG, REG}},\n-\f\n-/* Define the `__builtin_va_list' type for the ABI.  */\n-#define BUILD_VA_LIST_TYPE(VALIST) \\\n-  (VALIST) = clipper_build_va_list ()\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n-  clipper_va_start (stdarg, valist, nextarg)\n-\n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  clipper_va_arg (valist, type)"}, {"sha": "b6906fa5526bd801b04a6268432c65865b8eac75", "filename": "gcc/config/clipper/clipper.md", "status": "removed", "additions": 0, "deletions": 1421, "changes": 1421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclipper.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.md?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1421 +0,0 @@\n-;;- Machine description for GNU compiler, Clipper Version\n-;;  Copyright (C) 1987, 1988, 1991, 1993, 1994, 1997, 1998, 1999, 2001\n-;;  Free Software Foundation, Inc.\n-;; Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-\n-;;- Instruction patterns.  When multiple patterns apply,\n-;;- the first one in the file is chosen.\n-;;-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-;;-\n-;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;;- updates for most instructions.\n-\n-;;\n-;; define attributes\n-;;\n-;; instruction type\n-;;\n-;; unknown is temporary in order to generate 'cc clobber' until attribute\n-;; assignment is consistent\n-;;\n-(define_attr \"type\" \"load,store,arith,fp,branch,unknown\"\n- (const_string \"unknown\"))\n-\n-;; condition code setting\n-;;\n-;; clobber\tdestroyed\n-;; unchanged\n-;; set1\t\tset cc_status.value1, e.g. sub r0,r1\n-;; set2\t\tset value1 and value2, e.g. mov r0,r1\n-;; change0\tmay be side effect, i.e. load mem,r0\n-;;\n-;; note: loadi and loadq are 'arith' instructions that set the condition codes\n-;;       mul,div,mod do NOT set the condition codes\n-;;\n-(define_attr \"cc\" \"clobber,unchanged,set1,set2,change0\"\n- (cond [(eq_attr \"type\" \"load\")\t(const_string \"change0\")\n-\t(eq_attr \"type\" \"store,branch\") (const_string \"unchanged\")\n-\t(eq_attr \"type\" \"arith\") (if_then_else (match_operand:SI 0 \"\" \"\")\n-\t\t\t\t  (const_string \"set1\")\n-\t\t\t\t  (const_string \"clobber\"))\n-\t]\n-  (const_string \"clobber\")))\n-\n-;;\n-;; clipper seems to be a traditional risc processor\n-;; we define a functional unit 'memory'\n-;;\n-(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 4 0)     \n-\n-\f\n-;; We don't want to allow a constant operand for test insns because\n-;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n-;; be folded while optimizing anyway.\n-\n-(define_insn \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"int_reg_operand\" \"r\"))]\n-  \"\"\n-  \"cmpq   $0,%0\")\n-\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"r,r,n\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,n,r\")))]\n-  \"\"\n-  \"*\n-{\n-  int val;\n-\n-  if (which_alternative == 0)\n-    return \\\"cmpw   %1,%0\\\";\n-\n-  if (which_alternative == 1)\n-    {\n-      val = INTVAL (operands[1]);\n-      if (0 <= val && val < 16)\n-\treturn \\\"cmpq   %1,%0\\\";\n-      return \\\"cmpi   %1,%0\\\";\n-    }\n-\n-  cc_status.flags |= CC_REVERSED;\t/* immediate must be first */\n-\n-  val = INTVAL (operands[0]);\n-\n-  if (0 <= val && val < 16)\n-    return \\\"cmpq   %0,%1\\\";\n-\n-  return \\\"cmpi   %0,%1\\\";\n-}\")\n-\n-(define_insn \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"fp_reg_operand\" \"f\")\n-\t\t (match_operand:DF 1 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"cmpd   %1,%0\")\n-\n-(define_insn \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"fp_reg_operand\" \"f\")\n-\t\t (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"cmps   %1,%0\")\n-\n-\f\n-;;\n-;; double and single float move\n-;;\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\toperands[1] = force_reg (DFmode,\n-\t\t\t\t force_const_mem (DFmode, operands[1]));\n-      else if (GET_CODE (operands[1]) != REG)\n-\toperands[1] = force_reg (DFmode, operands[1]);\n-    }\n-\n-  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = force_const_mem (DFmode, operands[1]);\n-}\")\n-\n-;;\n-;; provide two patterns with different predicates as we don't want combine\n-;; to recombine a mem -> mem move\n-;; \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=*rf\")\n-\t(match_operand:DF 1 \"nonimmediate_operand\" \"*rfo\"))]\n-  \"\"\n-  \"*\n-{\n-#define FP_REG_P(X) (GET_CODE (X) == REG && REGNO (X) >= 16)\n-\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\t/* f -> f */\n-\treturn \\\"movd   %1,%0\\\";\n-\n-      if (GET_CODE (operands[1]) == REG) /* r -> f */\n-\treturn \\\"movld  %1,%0\\\";\n-\n-      return \\\"loadd  %1,%0\\\";\t\t/* m -> f */\n-    }\n-\n-  if (FP_REG_P (operands[1]))\n-    {\n-      if (GET_CODE (operands[0]) == REG) /* f -> r */\n-\treturn \\\"movdl  %1,%0\\\";\n-\n-      abort ();\n-    }\n-\n-  if (GET_CODE (operands[1]) == MEM)\t/* m -> r */\n-    {\n-      rtx xops[4];\n-      xops[0] = operands[0];\n-      xops[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      xops[2] = operands[1];\n-      xops[3] = adjust_address (operands[1], SImode, 4);\n-      output_asm_insn (\\\"loadw  %2,%0\\;loadw  %3,%1\\\", xops);\n-      return \\\"\\\";\n-    }\n-\n-  if (GET_CODE (operands[1]) == REG)\t/* r -> r */\n-    {\n-      rtx xops[4];\n-      xops[0] = operands[0];\n-      xops[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      xops[2] = operands[1];\n-      xops[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-      output_asm_insn (\\\"movw   %2,%0\\;movw   %3,%1\\\", xops);\n-      return \\\"\\\";\n-    }\n-\n-  abort ();\n-#undef FP_REG_P\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"memory_operand\" \"=o,m\")\n-\t(match_operand:DF 1 \"register_operand\" \"*rf,f\"))]\n-  \"\"\n-  \"*\n-{\n-  rtx xops[4];\n-\n-  if (REGNO (operands[1]) >= 16)\t/* f -> m */\n-    return \\\"stord  %1,%0\\\";\n-\n-  xops[0] = operands[0];\t\t/* r -> o */\n-  xops[1] = adjust_address (operands[0], SImode, 4);\n-  xops[2] = operands[1];\n-  xops[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  output_asm_insn (\\\"storw  %2,%0\\;storw  %3,%1\\\", xops);\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"type\" \"store,store\")\n- (set_attr \"cc\" \"clobber,unchanged\")])\n-\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\toperands[1] = force_reg (SFmode,\n-\t\t\t\t force_const_mem (SFmode, operands[1]));\n-      else if (GET_CODE (operands[1]) != REG)\n-\toperands[1] = force_reg (SFmode, operands[1]);\n-    }\n-\n-  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = force_const_mem (SFmode, operands[1]);\n-}\")\n-\n-;;\n-;; provide two patterns with different predicates as we don't want combine\n-;; to recombine a mem -> mem move\n-;; \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=*rf\")\n-\t(match_operand:SF 1 \"nonimmediate_operand\" \"*rfm\"))]\n-  \"\"\n-  \"*\n-{\n-#define FP_REG_P(X) (GET_CODE (X) == REG && REGNO (X) >= 16)\n-\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\t/* f -> f */\n-\treturn \\\"movs   %1,%0\\\";\n-      if (GET_CODE (operands[1]) == REG) /* r -> f */\n-\treturn\n-\t  \\\"subq   $8,sp\\;storw  %1,(sp)\\;loads  (sp),%0\\;addq   $8,sp\\\";\n-      return \\\"loads  %1,%0\\\";\t\t/* m -> f */\n-    }\n-\n-  if (FP_REG_P (operands[1]))\n-    {\n-      if (GET_CODE (operands[0]) == REG) /* f -> r */\n-\treturn\n-\t  \\\"subq   $8,sp\\;stors  %1,(sp)\\;loadw  (sp),%0\\;addq   $8,sp\\\";\n-      abort ();\n-    }\n-\n-  if (GET_CODE (operands[1]) == MEM)\t/* m -> r */\n-    return \\\"loadw   %1,%0\\\";\n-\n-  if (GET_CODE (operands[1]) == REG)\t/* r -> r */\n-    return \\\"movw    %1,%0\\\";\n-\n-  abort ();\n-#undef FP_REG_P\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SF 1 \"register_operand\" \"*rf\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) >= 16)\n-    return \\\"stors  %1,%0\\\";\t\t/* f-> m */\n-\n-  return \\\"storw   %1,%0\\\";\t\t/* r -> m */\n-}\"\n-[(set_attr \"type\" \"store\")])\n-\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) != REG)\n-    operands[1] = force_reg (DImode, operands[1]);\n-}\")\n-\n-;; If an operand is a MEM but not offsettable, we can't load it into\n-;; a register, so we must force the third alternative to be the one\n-;; reloaded.  Hence we show the first as more expensive.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=?r,r,r\")\n-\t(match_operand:DI 1 \"general_operand\"   \"r,n,o\"))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[2],yoperands[2];\n-\n-  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\n-  if (which_alternative == 0)\t\t/* r -> r */\n-    {\n-      output_asm_insn (\\\"movw   %1,%0\\\", operands);\n-      xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-      output_asm_insn (\\\"movw   %1,%0\\\", xoperands);\n-      return \\\"\\\";\n-    }\n-\n-  if (which_alternative == 1)\t\t/* n -> r */\n-    {\n-      if (GET_CODE (operands[1]) == CONST_INT)\n-\t{\n-\t  output_asm_insn (\\\"loadi   %1,%0\\\", operands);\n-\t  output_asm_insn (\\\"loadq   $0,%0\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-\n-      if (GET_CODE (operands[1]) != CONST_DOUBLE)\n-\tabort ();\n-\n-      yoperands[0] = operands[0];\n-      yoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-      output_asm_insn (\\\"loadi  %1,%0\\\", yoperands);\n-\n-      xoperands[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-      output_asm_insn (\\\"loadi  %1,%0\\\", xoperands);\n-      return \\\"\\\";\n-    }\n-\t\t\t\t\t/* m -> r */\n-  output_asm_insn (\\\"loadw  %1,%0\\\", operands);\n-  xoperands[1] = adjust_address (operands[1], SImode, 4);\n-  output_asm_insn (\\\"loadw  %1,%0\\\", xoperands);\n-  return \\\"\\\";\n-}\" \n-[(set_attr \"type\" \"arith,arith,load\")\n-  (set_attr \"cc\" \"clobber,clobber,clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=o\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"*\n-{\n-  rtx xops[4];\n-  xops[0] = operands[0];\n-  xops[1] = adjust_address (operands[0], SImode, 4);\n-  xops[2] = operands[1];\n-  xops[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  output_asm_insn (\\\"storw  %2,%0\\;storw  %3,%1\\\", xops);\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"type\" \"store\")\n- (set_attr \"cc\" \"clobber\")])\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM &&\n-      GET_CODE (operands[1]) != REG)\n-    operands[1] = force_reg (SImode, operands[1]);\n-}\")\n-\n-;; Reject both args with `general_operand' if not reloading because a\n-;; mem -> mem move that was split by 'movsi' can be recombined to\n-;; mem -> mem by the combiner.\n-;;\n-;; As a pseudo register can end up in a stack slot during reloading we must\n-;; allow a r->m move for the next pattern. \n-;; The first predicate must be `general_operand' because a predicate must\n-;; be true for each constraint.\n-;;  \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:SI 1 \"general_operand\"  \"r,m,n,i,r\"))]\n-  \"reload_in_progress || register_operand (operands[0], SImode)\"\n-  \"*\n-{\n-  int val;\n-\n-  if (which_alternative == 0)\n-    return \\\"movw   %1,%0\\\";\t\t/* reg -> reg */\n-\n-  if (which_alternative == 1)\n-    return \\\"loadw  %1,%0\\\";\t\t/* mem -> reg */\n-\n-  if (which_alternative == 2)\n-    {\n-      val = INTVAL (operands[1]);\t/* known const ->reg */\n-\n-      if (val == -1)\n-\treturn \\\"notq   $0,%0\\\";\n-\n-      if (val < 0 || val >= 16)\n-\treturn \\\"loadi  %1,%0\\\";\n-\n-      return \\\"loadq  %1,%0\\\";\n-    }\n-\n-  if (which_alternative == 3)\t\t/* unknown const */\n-    return \\\"loada  %a1,%0\\\";\n-\n-  return \\\"storw  %1,%0\\\";\n-}\"\n-[(set_attr \"type\" \"arith,load,arith,load,store\")\n- (set_attr \"cc\" \"set2,change0,set1,change0,unchanged\")])\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SI 1 \"int_reg_operand\" \"r\"))]\n-  \"\"\n-  \"storw  %1,%0\"\n-[(set_attr \"type\" \"store\")])\n-\n-;; movhi\n-;;\n-;; loadh  mem to reg\n-;; storh  reg to mem\n-;;\n-;;\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM\n-      && ! register_operand (operands[1], HImode))\n-    operands[1] = force_reg (HImode, operands[1]);\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n-\t(match_operand:HI 1 \"general_operand\"   \"r,m,n\"))]\n-  \"\"\n-  \"@\n-   movw   %1,%0\n-   loadh  %1,%0\n-   loadi  %1,%0\"\n-[(set_attr \"type\" \"arith,load,arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"memory_operand\"  \"=m\")\n-\t(match_operand:HI 1 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"storh  %1,%0\"\n- [(set_attr \"type\" \"store\")])\n-\n-;; movqi\n-;;\n-;; loadb  mem to reg\n-;; storb  reg to mem\n-;;\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && \n-      ! register_operand (operands[1], QImode))\n-    operands[1] = force_reg (QImode, operands[1]);\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n-\t(match_operand:QI 1 \"general_operand\"   \"r,m,n\"))]\n-  \"\"\n-  \"@\n-   movw   %1,%0\n-   loadb  %1,%0\n-   loadi  %1,%0\"\n-[(set_attr \"type\" \"arith,load,arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:QI 1 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"storb  %1,%0\"\n-[(set_attr \"type\" \"store\")])\n-\n-\f\n-;;\n-;; block move\n-;;\n-(define_expand \"movstrsi\"\n-  [(parallel\n-    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-          (match_operand:BLK 1 \"memory_operand\" \"\"))\n-     (use (match_operand:SI 2 \"general_operand\" \"\"))\n-     (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n-     (clobber (match_scratch:SI 4 \"\"))\n-     (clobber (match_scratch:SI 5 \"\"))\n-     (clobber (match_dup 6))\n-     (clobber (match_dup 7))])]\n-  \"\"\n-  \"\n-{\n-  rtx addr0, addr1;\n-\n-  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-  addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n-\n-  operands[6] = addr0;\n-  operands[7] = addr1;\n-\n-  operands[0] = replace_equiv_address (operands[0], addr0);\n-  operands[1] = replace_equiv_address (operands[1], addr1);\n-\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = force_reg (SImode, operands[2]);\n-}\")\n-\n-;;\n-;; there is a problem with this insn in gcc-2.2.3\n-;; (clobber (match_dup 2)) does not prevent use of this operand later\n-;; we always use a scratch register and leave operand 2 unchanged\n-;;\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\n-\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\n-   (use (match_operand:SI 2 \"nonmemory_operand\" \"rn\"))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"n\"))\n-   (clobber (match_scratch:SI 4 \"=r\"))\n-   (clobber (match_scratch:SI 5 \"=r\"))\n-   (clobber (match_dup 0))\n-   (clobber (match_dup 1))]\n-  \"\"\n-  \"*\n-{\n-  clipper_movstr (operands);\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"cc\" \"clobber\")])\n-\n-\n-\f\n-;; Extension and truncation insns.\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,m\")))]\n-  \"\"\n-  \"@\n-   andi   $65535,%0\\;xori   $32768,%0\\;subi   $32768,%0\n-   loadh  %1,%0\"\n-[(set_attr \"type\" \"arith,load\")])\n-\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"int_reg_operand\" \"=r,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n-  \"\"\n-  \"@\n-   andi   $255,%0\\;xori   $128,%0\\;subi   $128,%0\n-   loadb  %1,%0\"\n-[(set_attr \"type\" \"arith,load\")\n- (set_attr \"cc\" \"set1,change0\")])\n-\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n-  \"\"\n-  \"@\n-   andi   $255,%0\\;xori   $128,%0\\;subi   $128,%0\n-   loadb  %1,%0\"\n-[(set_attr \"type\" \"arith,load\")])\n-\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n-\t(float_extend:DF (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"cnvsd  %1,%0\")\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n-\t(float_truncate:SF (match_operand:DF 1 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"cnvds  %1,%0\")\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,m\")))]\n-  \"\"\n-  \"@\n-   andi   $65535,%0\n-   loadhu %1,%0\"\n-[(set_attr \"type\" \"arith,load\")])\n-\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"int_reg_operand\" \"=r,r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n-  \"\"\n-  \"@\n-   andi   $255,%0\n-   loadbu %1,%0\"\n-[(set_attr \"type\" \"arith,load\")\n- (set_attr \"cc\" \"clobber,clobber\")])\n-\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n-  \"\"\n-  \"@\n-   andi   $255,%0\n-   loadbu %1,%0\"\n-[(set_attr \"type\" \"arith,load\")])\n-\n-\n-\f\n-;; Fix-to-float conversion insns.\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n-\t(float:SF (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"cnvws  %1,%0\")\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n-\t(float:DF (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"cnvwd  %1,%0\")\n-\n-\n-;; Float-to-fix conversion insns.\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\"))))]\n-  \"\"\n-  \"cnvtsw %1,%0\")\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"fp_reg_operand\" \"f\"))))]\n-  \"\"\n-  \"cnvtdw %1,%0\")\n-\f\n-;;- All kinds of add instructions.\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n-\t(plus:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n-\t\t (match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"addd   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n-\t(plus:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n-\t\t (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"adds   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"int_reg_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[4];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  xoperands[2] = operands[2];\n-  xoperands[3] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-  output_asm_insn (\\\"addw   %2,%0\\;addwc  %3,%1\\\", xoperands);\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"type\" \"arith\")\n- (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r,r\")\n-\t(plus:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,r,r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rn,0,rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 2)\t\t/* 3 address version */\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\treturn \\\"loada  %a2(%1),%0\\\";\n-      return \\\"loada  [%2](%1),%0\\\";\n-    }\n-\t\t\t\t\t/* 2 address version */\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int val = INTVAL (operands[2]);\n-\n-      if (val >= 16 || val == 0x80000000)\n-\treturn \\\"addi   %2,%0\\\";\n-\n-      if (val < 0)\t\t\t/* change to sub */\n-\t{\n-\t  rtx xops[2];\n-\n-\t  val = -val;\n-\n-\t  xops[0] = operands[0];\n-\t  xops[1] = GEN_INT (val);\n-\n-\t  if (val >= 16)\n-\t    output_asm_insn (\\\"subi   %1,%0\\\", xops);\n-\t  else\n-\t    output_asm_insn (\\\"subq   %1,%0\\\", xops);\n-\n-\t  return \\\"\\\";\n-\t}\n-\n-      return \\\"addq   %2,%0\\\";\n-    }\n-\n-  if (which_alternative == 0)\n-    return \\\"addw   %2,%0\\\";\n-\n-  return \\\"addw   %1,%0\\\";\n-}\"\n-[(set_attr \"type\" \"arith,arith,arith\")\n- (set_attr \"cc\" \"set1,set1,change0\")])\n-\n-\f\n-;;- All kinds of subtract instructions.\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(minus:DI (match_operand:DI 1 \"int_reg_operand\" \"0\")\n-\t\t  (match_operand:DI 2 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[4];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  xoperands[2] = operands[2];\n-  xoperands[3] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-  output_asm_insn (\\\"subw   %2,%0\\;subwc  %3,%1\\\", xoperands);\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"type\" \"arith\")\n- (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int val = INTVAL (operands[2]);\n-\n-      if (val < 0 || val >= 16)\n-\treturn \\\"subi   %2,%0\\\";\n-      else\n-\treturn \\\"subq   %2,%0\\\";\n-    }\n-\n-  return \\\"subw   %2,%0\\\";\n-}\"\n-[(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n-\t\t  (match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"subd   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n-\t\t  (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"subs   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-\f\n-;;- Multiply instructions.\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n-\t(mult:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n-\t\t (match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"muld   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n-\t(mult:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n-\t\t (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"muls   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"mulsidi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"int_reg_operand\" \"%0\"))\n-\t         (sign_extend:DI (match_operand:SI 2 \"int_reg_operand\" \"r\"))))]\n-  \"\"\n-  \"mulwx  %2,%0\"\n-[(set_attr \"type\" \"arith\")\n- (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"int_reg_operand\" \"%0\"))\n-\t         (zero_extend:DI (match_operand:SI 2 \"int_reg_operand\" \"r\"))))]\n-  \"\"\n-  \"mulwux %2,%0\"\n-[(set_attr \"type\" \"arith\")\n- (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(mult:SI (match_operand:SI 1 \"int_reg_operand\" \"%0\")\n-\t         (match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"mulw   %2,%0\"\n- [(set_attr \"type\" \"arith\")\n-  (set_attr \"cc\" \"clobber\")])\n-\n-\f\n-;;- Divide and mod instructions.\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n-\t\t(match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"divd   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n-\t\t(match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"divs   %2,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(div:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"divw   %2,%0\"\n- [(set_attr \"type\" \"arith\")\n-  (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(udiv:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t         (match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"divwu  %2,%0\"\n- [(set_attr \"type\" \"arith\")\n-  (set_attr \"cc\" \"clobber\")])\n-\n-\n-(define_insn \"modsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(mod:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"modw   %2,%0\"\n- [(set_attr \"type\" \"arith\")\n-  (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"umodsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(umod:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t         (match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"modwu  %2,%0\"\n- [(set_attr \"type\" \"arith\")\n-  (set_attr \"cc\" \"clobber\")])\n-\f\n-;;\n-;; bit and/or instructions\n-;;\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-        (and:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"\"\n-  \"@\n-   andw   %2,%0\n-   andi   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(ior:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,0\")\n-\t        (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"\"\n-  \"@\n-   orw    %2,%0\n-   ori    %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(xor:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"\"\n-  \"@\n-   xorw   %2,%0\n-   xori   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\f\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n-\t(neg:DF (match_operand:DF 1 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"negd   %1,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n-\t(neg:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n-  \"\"\n-  \"negs   %1,%0\"\n- [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"negw   %1,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-\f\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n-  \"\"\n-  \"notw   %1,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-\n-\f\n-;; Right shift on the clipper works by negating the shift count,\n-;; then emitting a right shift with the shift count negated.  This means\n-;; that all actual shift counts in the RTL will be positive.\n-\n-(define_expand \"ashrdi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"int_reg_operand\" \"\")\n-\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"int_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"shali  $%n2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"int_reg_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n-  \"\"\n-  \"shal   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"\")\n-\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"shai   $%n2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n-  \"\"\n-  \"shaw   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-;;\n-;; left shift\n-;;\n-\n-(define_insn \"ashldi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r,r\")\n-\t(ashift:DI (match_operand:DI 1 \"int_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"\"\n-  \"@\n-   shal   %2,%0\n-   shali  %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(ashift:SI (match_operand:SI 1 \"int_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"\"\n-  \"*\n-{\n-  int val;\n-\n-  if (which_alternative == 0)\n-   return \\\"shaw   %2,%0\\\";\n-\n-  val = INTVAL (operands[2]);\n-\n-  if (val == 2)\n-    return \\\"addw   %0,%0\\;addw   %0,%0\\\";\n-\n-  if (val == 1)\n-    return \\\"addw   %0,%0\\\";\n-\n-  return \\\"shai   %2,%0\\\";\n-}\"\n-[(set_attr \"type\" \"arith\")])\n-\n-;;\n-;; logical shift\n-;;\n-\n-(define_expand \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"int_reg_operand\" \"\")\n-\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"int_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"shlli  $%n2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"int_reg_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n-  \"\"\n-  \"shll   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"\")\n-\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"shli   $%n2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n-  \"\"\n-  \"shlw   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-\n-;;\n-;; rotate insn\n-;;\n-(define_expand \"rotrdi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"\")\n-\t(rotatert:DI (match_operand:DI 1 \"int_reg_operand\" \"\")\n-\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(rotatert:DI (match_operand:DI 1 \"int_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"rotli  $%n2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n-\t(rotatert:DI (match_operand:DI 1 \"int_reg_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n-  \"\"\n-  \"rotl   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_expand \"rotrsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n-\t(rotatert:SI (match_operand:SI 1 \"int_reg_operand\" \"\")\n-\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(rotatert:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"roti   $%n2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n-\t(rotatert:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n-  \"\"\n-  \"rotw   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"rotldi3\"\n-  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r,r\")\n-\t(rotate:DI (match_operand:DI 1 \"int_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"\"\n-  \"@\n-   rotl   %2,%0\n-   rotli  %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n-\t(rotate:SI (match_operand:SI 1 \"int_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n-  \"\"\n-  \"@\n-   rotw   %2,%0\n-   roti   %2,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-\f\n-;;\n-;; jump and branch insns\n-;;\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"b      %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"b      (%0)\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"breq   %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brne   %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brgt   %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brgtu  %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brlt   %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brltu  %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brge   %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brgeu  %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n- \"\"\n- \"brle   %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n- \"\"\n- \"brleu  %l0\"\n- [(set_attr \"type\" \"branch\")])\n-\n-;; Recognize reversed jumps.\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(cc0)\n-\t\t\t\t       (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n- \"\"\n- \"br%C0    %l1\" ; %C0 negates condition\n- [(set_attr \"type\" \"branch\")])\n-\f\n-;;\n-;; call instructions\n-;;\n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"general_operand\" \"m\")\n-\t (match_operand:SI 1 \"general_operand\" \"\"))]\n-  ;; Operand 1 not used on the clipper.\n-  \"\"\n-  \"call   sp,%0\")\n-\n-(define_insn \"call_value\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n-\t(call (match_operand:QI 1 \"general_operand\" \"m\")\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  ;; Operand 2 not used on the clipper\n-  \"\"\n-  \"call   sp,%1\")\n-\n-;; Call subroutine returning any type.\n-\n-(define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-\t\t    (const_int 0))\n-\t      (match_operand 1 \"\" \"\")\n-\t      (match_operand 2 \"\" \"\")])]\n-  \"\"\n-  \"\n-{\n-  int i;\n-\n-  emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));\n-\n-  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n-    {\n-      rtx set = XVECEXP (operands[2], 0, i);\n-      emit_move_insn (SET_DEST (set), SET_SRC (set));\n-    }\n-\n-  /* The optimizer does not know that the call sets the function value\n-     registers we stored in the result block.  We avoid problems by\n-     claiming that all hard registers are used and clobbered at this\n-     point.  */\n-  emit_insn (gen_blockage ());\n-\n-  DONE;\n-}\")\n-\n-;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n-;; all of memory.  This blocks insns from being moved across this point.\n-\n-(define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"b      (%0)\"\n- [(set_attr \"type\" \"branch\")])\n-\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"noop\"\n- [(set_attr \"type\" \"arith\")\n-  (set_attr \"cc\" \"unchanged\")])\n-\n-\f\n-\n-;; while (--foo >= 0)\n-;;\n-;; Combiners for 'decrement test and branch' do not work for clipper.\n-;; These patters are jump_insns that do not allow output reloads and clipper\n-;; can only decrement and test registers.\n-;;"}, {"sha": "cae454b8b01f17fe51875123b0fd8049bd692c86", "filename": "gcc/config/clipper/clix.h", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fclipper%2Fclix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclix.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,125 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Clipper/Clix version.\n-   Copyright (C) 1988, 1993, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dclipper -Dunix -Asystem=unix -Asystem=svr3 -Acpu=clipper -Amachine=clipper\"\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC  \\\n-  \"%{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} crtbegin.o%s\"\n-\n-#undef ENDFILE_SPEC\n-#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n-\n-#undef LIB_SPEC\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  const unsigned char *s = (const unsigned char *)(PTR);\\\n-  size_t i, limit = (LEN);\t\t\t\t\\\n-  for (i = 0; i < limit; s++, i++)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if ((i % 8) == 0)\t\t\t\t\t\\\n-\tfputs (\"\\n\\t.byte\\t\", (FILE));\t\t\t\\\n-      fprintf ((FILE), \"%s0x%x\", (i%8?\",\":\"\"), (unsigned)*s); \\\n-    }\t\t\t\t\t\t\t\\\n-  fputs (\"\\n\", (FILE));\t\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n-  fprintf(FILE, \"\\t.align %d\\n\", 1 << (LOG))\n-\n-\n-#define BSS_SECTION_ASM_OP  \"\\t.bss\"\n-#undef INIT_SECTION_ASM_OP\n-#define INIT_SECTION_ASM_OP \"\\t.section .init,\\\"x\\\"\"\n-\n-\f\n-/* Define a few machine-specific details of the implementation of\n-   constructors.\n-\n-   The __CTORS_LIST__ goes in the .init section.  Define CTOR_LIST_BEGIN\n-   and CTOR_LIST_END to contribute to the .init section an instruction to\n-   push a word containing 0 (or some equivalent of that).\n-\n-   TARGET_ASM_CONSTRUCTOR should be defined to push the address of the\n-   constructor.  */\n-\n-#define CTOR_LIST_BEGIN\t\t\t\t\\\n-  asm (INIT_SECTION_ASM_OP);\t\t\t\\\n-  asm (\"subq   $8,sp\");\t\t\t\t\\\n-  asm (\"loadq  $0,r0\");\t\t\t\t\\\n-  asm (\"storw  r0,(sp)\")\n-\n-/* don't need end marker */\n-\n-#undef CTOR_LIST_END\n-\n-/* fini psect is 8 aligned */\n-\n-#define DTOR_LIST_BEGIN\t\\\n-  asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n-  func_ptr __DTOR_LIST__[2] = { (func_ptr) (-1), 0 };\n-\n-#undef TARGET_ASM_CONSTRUCTOR\n-#define TARGET_ASM_CONSTRUCTOR  clix_asm_out_constructor\n-#undef TARGET_ASM_DESTRUCTOR\n-#define TARGET_ASM_DESTRUCTOR   clix_asm_out_destructor\n-\n-/* On clix crt1.o first calls init code and then sets environ and a valid\n-   chrclass. Unfortunately stdio routines bomb with unset chrclass.\n-   Therefore we set chrclass prior to calling global constructors. */\n-\n-#undef DO_GLOBAL_CTORS_BODY\n-#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  func_ptr *p, *beg = alloca (0);\t\t\t\t\\\n-  _setchrclass (0);\t\t\t\t\t\t\\\n-  for (p = beg; *p; p+=2)\t\t\t\t\t\\\n-    ;\t\t\t\t\t\t\t\t\\\n-  while (p != beg)\t\t\t\t\t\t\\\n-    { p-= 2; (*p) (); }\t\t\t\t\t\t\\\n-} while (0)\n-\n-\n-#undef DO_GLOBAL_DTORS_BODY\n-#define DO_GLOBAL_DTORS_BODY\t\\\n-  func_ptr *f = &__DTOR_LIST__[2];\t/* 0,1 contains -1,0 */\t\\\n-  int n = 0;\t\t\t\t\t\t\t\\\n-  while (*f)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-     f+= 2;\t\t\t\t/* skip over alignment 0 */\t\\\n-     n++;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  f -= 2;\t\t\t\t\t\t\t\\\n-  while (--n >= 0)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-     (*f) ();\t\t\t\t\t\t\t\\\n-     f-= 2;\t\t\t\t/* skip over alignment 0 */\t\\\n-    }\n-\n-"}, {"sha": "9ec9680309bf4f7409aef91ed7ff1bcf29f2b6fa", "filename": "gcc/config/convex/convex-protos.h", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,50 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Convex version.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-extern int const_double_low_int PARAMS ((rtx));\n-extern int const_double_high_int PARAMS ((rtx));\n-extern const char *output_cmp PARAMS ((rtx, rtx, int));\n-extern const char *output_condjump PARAMS ((rtx, const char *, int));\n-extern const char *output_call PARAMS ((rtx, rtx *));\n-extern rtx simplify_for_convex PARAMS ((rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void expand_movstr PARAMS ((rtx *));\n-\n-extern int nonmemory_operand PARAMS ((rtx, enum machine_mode));\n-extern int nonmemory_cmpsf_operand PARAMS ((rtx, enum machine_mode));\n-#endif /* RTX_CODE */\n-\n-#ifdef TREE_CODE\n-extern void asm_declare_function_name PARAMS ((FILE *, const char *, tree));\n-#endif /* TREE_CODE */\n-\n-#ifdef REAL_VALUE_TYPE\n-extern int check_float_value PARAMS ((enum machine_mode, REAL_VALUE_TYPE *,\n-\t\t\t\t      int));\n-extern void outfloat PARAMS ((FILE *, REAL_VALUE_TYPE, const char *,\n-\t\t\t      const char *, const char *));\n-#endif /* REAL_VALUE_TYPE */\n-\n-extern void psw_disable_float PARAMS ((void));\n-extern void init_convex PARAMS ((void));\n-extern void replace_arg_pushes PARAMS ((void));\n-extern void emit_ap_optimizations PARAMS ((void));"}, {"sha": "74af45ec2a5754da2755a317417a53ac9b392964", "filename": "gcc/config/convex/convex.c", "status": "removed", "additions": 0, "deletions": 792, "changes": 792, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,792 +0,0 @@\n-/* Subroutines for insn-output.c for Convex.\n-   Copyright (C) 1988, 1993, 1994, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-attr.h\"\n-#include \"output.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-/* Tables used in convex.h */\n-\n-char regno_ok_for_index_p_base[1 + LAST_VIRTUAL_REGISTER + 1];\n-enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n-enum reg_class reg_class_from_letter[256];\n-\n-/* Target cpu index.  */\n-\n-int target_cpu;\n-\n-/* Boolean to keep track of whether the current section is .text or not.\n-   Used by .align handler in convex.h.  */\n-\n-int current_section_is_text;\n-\n-/* Communication between output_compare and output_condjump.  */\n-\n-static rtx cmp_operand0, cmp_operand1;\n-static char cmp_modech;\n-\n-/* Forwards */\n-\n-#if 0\n-static rtx frame_argblock;\n-static int frame_argblock_size;\n-static rtx convert_arg_pushes ();\n-#endif\n-static void expand_movstr_call PARAMS ((rtx *));\n-static void convex_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void convex_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static int convex_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_BYTE_OP\n-#define TARGET_ASM_BYTE_OP \"\\tds.b\\t\"\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\tds.h\\t\"\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP \"\\tds.w\\t\"\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE convex_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE convex_output_function_epilogue\n-#undef TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST convex_adjust_cost\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Generate the assembly code for function entry.  FILE is a stdio\n-   stream to output the code to.  SIZE is an int: how many units of\n-   temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers to\n-   save; `regs_ever_live[I]' is nonzero if register number I is ever\n-   used in the function.  This function is responsible for knowing\n-   which registers should not be saved even if used.  */\n-\n-static void\n-convex_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  size = ((size) + 7) & -8;\n-  if (size)\n-    {\n-      fprintf (file, \"\\tsub.w #\");\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, size);\n-      fprintf (file, \",sp\\n\");\n-    }\n-}\n-\n-/* This function generates the assembly code for function exit.\n-   Args are as for output_function_prologue ().\n-\n-   The function epilogue should not depend on the current stack\n-   pointer!  It should use the frame pointer only.  This is mandatory\n-   because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning.  */\n-\n-static void\n-convex_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  /* Follow function with a zero to stop c34 icache prefetching.  */\n-  fprintf (file, \"\\tds.h 0\\n\");\n-}\n-\n-/* Adjust the cost of dependences.  */\n-static int\n-convex_adjust_cost (insn, link, dep, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep;\n-     int cost;\n-{\n-  /* Antidependencies don't block issue.  */\n-  if (REG_NOTE_KIND (link) != 0)\n-    cost = 0;\n-  /* C38 situations where delay depends on context */\n-  else if (TARGET_C38\n-\t   && GET_CODE (PATTERN (insn)) == SET\n-\t   && GET_CODE (PATTERN (dep)) == SET)\n-    {\n-      enum attr_type insn_type = get_attr_type (insn);\n-      enum attr_type dep_type = get_attr_type (dep);\n-      /* index register must be ready one cycle early */\n-      if (insn_type == TYPE_MLDW || insn_type == TYPE_MLDL\n-          || (insn_type == TYPE_MST\n-\t      && reg_mentioned_p (SET_DEST (PATTERN (dep)),\n-\t\t\t\t  SET_SRC (PATTERN (insn)))))\n-\tcost += 1;\n-      /* alu forwarding off alu takes two */\n-      if (dep_type == TYPE_ALU\n-\t  && insn_type != TYPE_ALU\n-\t  && ! (insn_type == TYPE_MST\n-\t\t&& SET_DEST (PATTERN (dep)) == SET_SRC (PATTERN (insn))))\n-\tcost += 1;\n-    }\n-\n-  return cost;\n-}\n-\n-\n-\n-/* Here from OVERRIDE_OPTIONS at startup.  Initialize constant tables.  */\n-\n-void\n-init_convex ()\n-{\n-  int regno;\n-\n-  /* Set A and S reg classes.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (A_REGNO_P (regno))\n-      {\n-\tregno_ok_for_index_p[regno] = 1;\n-\tregno_reg_class[regno] = INDEX_REGS;\n-      }\n-    else\n-      {\n-\tregno_ok_for_index_p[regno] = 0;\n-\tregno_reg_class[regno] = S_REGS;\n-      }\n-\n-  /* Can't index off the stack pointer, register 0.  */\n-  regno_ok_for_index_p[STACK_POINTER_REGNUM] = 0;\n-  regno_reg_class[STACK_POINTER_REGNUM] = SP_REGS;\n-\n-  /* Can't index off aliases of the stack pointer.  */\n-  regno_ok_for_index_p[VIRTUAL_INCOMING_ARGS_REGNUM] = 1;\n-  regno_ok_for_index_p[VIRTUAL_STACK_VARS_REGNUM] = 1;\n-  regno_ok_for_index_p[VIRTUAL_STACK_DYNAMIC_REGNUM] = 0;\n-  regno_ok_for_index_p[VIRTUAL_OUTGOING_ARGS_REGNUM] = 0;\n-\n-  /* Can't index off hard reg -1 == pseudos not assigned */\n-  regno_ok_for_index_p[-1] = 0;\n-\n-  /* Set reg class letters */\n-  reg_class_from_letter['a'] = A_REGS;\n-  reg_class_from_letter['A'] = INDEX_REGS;\n-  reg_class_from_letter['d'] = S_REGS;\n-\n-  /* Turn off floating point exception enables in the psw.  */\n-  psw_disable_float ();\n-}\n-\n-void\n-psw_disable_float ()\n-{\n-#if __convex__ && __GNUC__\n-  register int *p;\n-  asm (\"mov fp,%0\" : \"=a\" (p));\n-  while (p)\n-    {\n-      p[1] &= ~0x1000c400;\n-      p = (int *) p[2];\n-    }\n-#endif  \n-}\n-\f\n-/* Here to output code for a compare insn.  Output nothing, just\n-   record the operands and their mode.  */\n-\n-const char *\n-output_cmp (operand0, operand1, modech)\n-     rtx operand0, operand1;\n-     int modech;\n-{\n-  cmp_operand0 = operand0;\n-  cmp_operand1 = operand1;\n-  cmp_modech = modech;\n-  return \"\";\n-}\n-\n-/* Output code for a conditional jump.  The preceding instruction\n-   is necessarily a compare.  Output two instructions, for example\n-       eq.w a1,a2\n-       jbra.t L5\n-   for\n-       (cmpsi a1 a2)\n-       (beq L5)\n- */\n-\n-const char *\n-output_condjump (label, cond, jbr_sense)\n-     rtx label;\n-     const char *cond;\n-     int jbr_sense;\n-{\n-  rtx operands[3];\n-  char cmp_op[4];\n-  char buf[80];\n-  char jbr_regch;\n-\n-  strcpy (cmp_op, cond);\n-\n-  /* [BL] mean the value is being compared against immediate 0.\n-     Use neg.x, which produces the same carry that eq.x #0 would if it\n-     existed.  In this case operands[1] is a scratch register, not a\n-     compare operand.  */\n-\n-  if (cmp_modech == 'B' || cmp_modech == 'L')\n-    {\n-      cmp_modech = cmp_modech - 'A' + 'a';\n-      strcpy (cmp_op, \"neg\");\n-    }\n-\n-  /* [WH] mean the value being compared resulted from \"add.[wh] #-1,rk\"\n-     when rk was nonnegative -- we can omit equality compares against -1\n-     or inequality compares against 0.  */\n-\n-  else if (cmp_modech == 'W' || cmp_modech == 'H')\n-    {\n-      if (! strcmp (cmp_op, \"eq\") && cmp_operand1 == constm1_rtx)\n-\tjbr_sense ^= 't' ^ 'f';\n-      else if (! strcmp (cmp_op, \"lt\") && cmp_operand1 == const0_rtx)\n-\t;\n-      else\n-\tcmp_modech = cmp_modech - 'A' + 'a';\n-    }\n-\n-  /* Constant must be first; swap operands if necessary.\n-     If lt, le, ltu, leu are swapped, change to le, lt, leu, ltu\n-     and reverse the sense of the jump.  */\n-\n-  if (! REG_P (cmp_operand1))\n-    {\n-      operands[0] = cmp_operand1;\n-      operands[1] = cmp_operand0;\n-      if (cmp_op[0] == 'l')\n-\t{\n-\t  cmp_op[1] ^= 'e' ^ 't';\n-\t  jbr_sense ^= 't' ^ 'f';\n-\t}\n-    }\n-  else\n-    {\n-      operands[0] = cmp_operand0;\n-      operands[1] = cmp_operand1;\n-    }\n-\n-  operands[2] = label;\n-\n-  if (S_REG_P (operands[1]))\n-    jbr_regch = 's';\n-  else if (A_REG_P (operands[1]))\n-    jbr_regch = 'a';\n-  else\n-    abort ();\n-\n-  if (cmp_modech == 'W' || cmp_modech == 'H')\n-    sprintf (buf, \"jbr%c.%c %%l2\", jbr_regch, jbr_sense);\n-  else\n-    sprintf (buf, \"%s.%c %%0,%%1\\n\\tjbr%c.%c %%l2\",\n-\t     cmp_op, cmp_modech, jbr_regch, jbr_sense);\n-  output_asm_insn (buf, operands);\n-  return \"\";\n-}\n-\n-/* Return 1 if OP is valid for cmpsf.\n-   In IEEE mode, +/- zero compares are not handled by \n-     the immediate versions of eq.s and on some machines, lt.s, and le.s.  \n-   So disallow 0.0 as the immediate operand of xx.s compares in IEEE mode.  */\n-\n-int\n-nonmemory_cmpsf_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-#if _IEEE_FLOAT_\n-  if (op == CONST0_RTX (SFmode))\n-    return 0;\n-#endif\n-\n-  return nonmemory_operand (op, mode);\n-}\n-\f\n-/* Convex /bin/as does not like unary minus in some contexts.\n-   Simplify CONST addresses to remove it.  */\n-\n-rtx\n-simplify_for_convex (x)\n-     rtx x;\n-{\n-  switch (GET_CODE (x))\n-    {\n-    case MINUS:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (x, 1)) < 0)\n-\t{\n-\t  PUT_CODE (x, PLUS);\n-\t  XEXP (x, 1) = GEN_INT (- INTVAL (XEXP (x, 1)));\n-\t}\n-      break;\n-\n-    case CONST:\n-      return simplify_for_convex (XEXP (x, 0));\n-    default:\n-      break;\n-    }\n-\n-  return x;\n-}\n-\f\n-/* Routines to separate CONST_DOUBLEs into component parts.  */\n-\n-int\n-const_double_high_int (x)\n-     rtx x;\n-{\n-  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-    return CONST_DOUBLE_LOW (x);\n-  else\n-    return CONST_DOUBLE_HIGH (x);\n-}\n-\n-int\n-const_double_low_int (x)\n-     rtx x;\n-{\n-  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-    return CONST_DOUBLE_HIGH (x);\n-  else\n-    return CONST_DOUBLE_LOW (x);\n-}\n-\f\n-/* Inline block copy.  */\n-\n-void\n-expand_movstr (operands)\n-     rtx *operands;\n-{\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-  int align = INTVAL (operands[3]);\n-  int nregs, maxsize;\n-  unsigned len;\n-  enum machine_mode mode;\n-  rtx reg, load, store, prev_store, prev_store_2;\n-  int size;\n-\n-  /* Decide how many regs to use, depending on load latency, and what\n-     size pieces to move, depending on whether machine does unaligned\n-     loads and stores efficiently.  */\n-\n-  if (TARGET_C1)\n-    {\n-      /* ld.l latency is 4, no alignment problems.  */\n-      nregs = 3, maxsize = 8;\n-    }\n-  else if (TARGET_C2)\n-    {\n-      /* loads are latency 2 if we avoid ld.l not at least word aligned.  */\n-      if (align >= 4)\n-\tnregs = 2, maxsize = 8;\n-      else\n-\tnregs = 2, maxsize = 4;\n-    }\n-  else if (TARGET_C34)\n-    {\n-      /* latency is 4 if aligned, horrible if not.  */\n-      nregs = 3, maxsize = align;\n-    }\n-  else if (TARGET_C38)\n-    {\n-      /* latency is 2 if at least word aligned, 3 or 4 if unaligned.  */\n-      if (align >= 4)\n-\tnregs = 2, maxsize = 8;\n-      else\n-\tnregs = 3, maxsize = 8;\n-    }\n-  else\n-    abort ();\n-\n-  /* Caller is not necessarily prepared for us to fail in this\n-     expansion.  So fall back by generating memcpy call here.  */\n-\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || (len = INTVAL (operands[2])) > (unsigned) 32 * maxsize)\n-    {\n-      expand_movstr_call (operands);\n-      return;\n-    }\n-\n-  reg = 0;\n-  prev_store = prev_store_2 = 0;\n-\n-  while (len > 0)\n-    {\n-      if (len >= 8 && maxsize >= 8)\n-\tmode = DImode;\n-      else if (len >= 4 && maxsize >= 4)\n-\tmode = SImode;\n-      else if (len >= 2 && maxsize >= 2)\n-\tmode = HImode;\n-      else\n-\tmode = QImode;\n-\n-      /* If no temp pseudo to reuse, or not the right mode, make one */\n-      if (! reg || GET_MODE (reg) != mode)\n-\treg = gen_reg_rtx (mode);\n-\n-      /* Get src and dest in the right mode */\n-      if (GET_MODE (src) != mode)\n-\t{\n-\t  src = adjust_address (src, mode, 0);\n-\t  dest = adjust_address (dest, mode, 0);\n-\t}\n-\n-      /* Make load and store patterns for this piece */\n-      load = gen_rtx_SET (VOIDmode, reg, src);\n-      store = gen_rtx_SET (VOIDmode, dest, reg);\n-\n-      /* Emit the load and the store from last time. \n-\t When we emit a store, we can reuse its temp reg.  */\n-      emit_insn (load);\n-      if (prev_store)\n-\t{\n-\t  reg = SET_SRC (prev_store);\n-\t  emit_insn (prev_store);\n-\t}\n-      else\n-\treg = 0;\n-\n-      /* Queue up the store, for next time or the time after that.  */\n-      if (nregs == 2)\n-\tprev_store = store;\n-      else\n-\tprev_store = prev_store_2, prev_store_2 = store;\n-\n-      /* Advance to next piece.  */\n-      size = GET_MODE_SIZE (mode);\n-      src = adjust_address (src, mode, size);\n-      dest = adjust_address (dest, mode, size);\n-      len -= size;\n-    }\n-\n-  /* Finally, emit the last stores.  */\n-  if (prev_store)\n-    emit_insn (prev_store);\n-  if (prev_store_2)\n-    emit_insn (prev_store_2);\n-}\n-\n-static void\n-expand_movstr_call (operands)\n-     rtx *operands;\n-{\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n-\t\t     VOIDmode, 3,\n-\t\t     XEXP (operands[0], 0), Pmode,\n-\t\t     XEXP (operands[1], 0), Pmode,\n-\t\t     convert_to_mode (TYPE_MODE (sizetype), operands[2],\n-\t\t\t\t      TREE_UNSIGNED (sizetype)),\n-\t\t     TYPE_MODE (sizetype));\n-}\n-\f\n-#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#define MAX_FLOAT \"3.4028234663852886e+38\"\n-#define MIN_FLOAT \"1.1754943508222875e-38\"\n-#else\n-#define MAX_FLOAT \"1.7014117331926443e+38\"\n-#define MIN_FLOAT \"2.9387358770557188e-39\"\n-#endif\n-\n-int\n-check_float_value (mode, dp, overflow)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE *dp;\n-     int overflow;\n-{\n-  REAL_VALUE_TYPE d = *dp;\n-  REAL_VALUE_TYPE maxfloat = REAL_VALUE_ATOF (MAX_FLOAT, mode);\n-  REAL_VALUE_TYPE minfloat = REAL_VALUE_ATOF (MIN_FLOAT, mode);\n-  REAL_VALUE_TYPE neg_maxfloat = REAL_VALUE_NEGATE (maxfloat);\n-  REAL_VALUE_TYPE neg_minfloat = REAL_VALUE_NEGATE (minfloat);\n-\n-  if (overflow)\n-    {\n-      *dp = maxfloat;\n-      return 1;\n-    }\n-\n-  if (mode == SFmode)\n-    {\n-      if (REAL_VALUES_LESS (maxfloat, d))\n-\t{\n-\t  *dp = maxfloat;\n-\t  return 1;\n-\t}\n-      else if (REAL_VALUES_LESS (d, neg_maxfloat))\n-\t{\n-\t  *dp = neg_maxfloat;\n-\t  return 1;\n-\t}\t\n-      else if ((REAL_VALUES_LESS (dconst0, d)\n-\t\t&& REAL_VALUES_LESS (d, minfloat))\n-\t       || (REAL_VALUES_LESS (d, dconst0)\n-\t\t   && REAL_VALUES_LESS (neg_minfloat, d)))\n-\t{\n-\t  *dp = dconst0;\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\f\n-/* Output the label at the start of a function.\n-   Precede it with the number of formal args so debuggers will have\n-   some idea of how many args to print.  */\n-\n-void\n-asm_declare_function_name (file, name, decl)\n-    FILE *file;\n-    const char *name;\n-    tree decl;\n-{\n-  int nargs = list_length (DECL_ARGUMENTS (decl));\n-\n-  const char *p;\n-  char c;\n-  static char vers[4];\n-  int i;\n-  \n-  p = version_string;\n-  for (i = 0; i < 3; ) {\n-    c = *p;\n-    if (ISDIGIT (c))\n-      vers[i++] = c;\n-    if (c == 0 || c == ' ')\n-      vers[i++] = '0';\n-    else\n-      p++;\n-  }\n-  fprintf (file, \"\\tds.b \\\"g%s\\\"\\n\", vers);\n-\n-  if (nargs < 100)\n-    fprintf (file, \"\\tds.b \\\"+%02d\\\\0\\\"\\n\", nargs);\n-  else\n-    fprintf (file, \"\\tds.b \\\"+00\\\\0\\\"\\n\");\n-\n-  ASM_OUTPUT_LABEL (file, name);\n-}\n-\f\n-/* Print an instruction operand X on file FILE.\n-   CODE is the code from the %-spec that requested printing this operand;\n-   if `%z3' was used to print operand 3, then CODE is 'z'.  */\n-/* Convex codes:\n-    %u prints a CONST_DOUBLE's high word\n-    %v prints a CONST_DOUBLE's low word\n-    %z prints a CONST_INT shift count as a multiply operand -- viz. 1 << n.\n- */\n-\n-void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n-{\n-  long u[2];\n-  REAL_VALUE_TYPE d;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case REG:\n-      fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-      break;\n-\n-    case MEM:\n-      output_address (XEXP (x, 0));\n-      break;\n-\n-    case CONST_DOUBLE:\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n-      switch (GET_MODE (x)) {\n-      case DFmode:\n-\tREAL_VALUE_TO_TARGET_DOUBLE (d, u); \n-\tif (code == 'u')\n-\t  fprintf (file, \"#%#lx\", u[0]);\n-\telse if (code == 'v')\n-\t  fprintf (file, \"#%#lx\", u[1]);\n-\telse\n-\t  outfloat (file, d, \"%.17e\", \"#\", \"\");\n-\tbreak;\n-      case SFmode:\n-\toutfloat (file, d, \"%.9e\", \"#\", \"\");\n-\tbreak;\n-      default:\n-\tif (code == 'u')\n-\t  {\n-\t    fprintf (file, \"#\");\n-\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_HIGH (x));\n-\t  }\n-\telse\n-\t  {\n-\t    fprintf (file, \"#\");\n-\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x));\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      if (code == 'z')\n-\t{\n-\t  if (GET_CODE (x) != CONST_INT)\n-\t    abort ();\n-\t  fprintf (file, \"#%d\", 1 << INTVAL (x));\n-\t}\n-      else\n-\t{\n-\t  putc ('#', file);\n-\t  output_addr_const (file, x);\n-\t}\n-    }\n-}\n-\n-/* Print a memory operand whose address is X, on file FILE.  */\n-\n-void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n-{\n-  rtx index = 0;\n-  rtx offset = 0;\n-\n-  if (GET_CODE (addr) == MEM)\n-    {\n-      fprintf (file, \"@\");\n-      addr = XEXP (addr, 0);\n-    }\n-\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      index = addr;\n-      break;\n-\n-    case PLUS:\n-      index = XEXP (addr, 0);\n-      if (REG_P (index))\n-\toffset = XEXP (addr, 1);\n-      else\n-\t{\n-\t  offset = XEXP (addr, 0);\n-\t  index = XEXP (addr, 1);\n-\t  if (! REG_P (index))\n-\t    abort ();\n-        }\n-      break;\n-\n-    default:\n-      offset = addr;\n-      break;\n-    }\n-\n-  if (offset)\n-    output_addr_const (file, offset);\n-\n-  if (index)\n-    fprintf (file, \"(%s)\", reg_names[REGNO (index)]);\n-}\n-\n-/* Output a float to FILE, value VALUE, format FMT, preceded by PFX\n-   and followed by SFX.  */\n-\n-void\n-outfloat (file, value, fmt, pfx, sfx)\n-     FILE *file;\n-     REAL_VALUE_TYPE value;\n-     const char *fmt, *pfx, *sfx;\n-{\n-  char buf[64];\n-  fputs (pfx, file);\n-  REAL_VALUE_TO_DECIMAL (value, fmt, buf);\n-  fputs (buf, file);\n-  fputs (sfx, file);\n-}\n-\f\n-/* Here during RTL generation of return.  If we are at the final return\n-   in a function, go through the function and replace pushes with stores\n-   into a frame arg block.  This is similar to what ACCUMULATE_OUTGOING_ARGS\n-   does, but we must index off the frame pointer, not the stack pointer,\n-   and the calling sequence does not require the arg block to be at the\n-   top of the stack.  */\n-\n-void\n-replace_arg_pushes ()\n-{\n-  /* Doesn't work yet.  */\n-}\n-\n-/* Output the insns needed to do a call.  operands[] are\n-     0 - MEM, the place to call\n-     1 - CONST_INT, the number of bytes in the arg list\n-     2 - CONST_INT, the number of arguments\n-     3 - CONST_INT, the number of bytes to pop\n-     4 - address of the arg list.  \n- */\n-\n-const char *\n-output_call (insn, operands)\n-     rtx insn ATTRIBUTE_UNUSED, *operands;\n-{\n-  if (operands[4] == stack_pointer_rtx)\n-    output_asm_insn (\"mov sp,ap\", operands);\n-  else\n-    abort ();\n-\n-  if (TARGET_ARGCOUNT)\n-    output_asm_insn (\"pshea %a2\", operands);\n-\n-  output_asm_insn (\"calls %0\", operands);\n-\n-  output_asm_insn (\"ld.w 12(fp),ap\", operands);\n-\n-  if (operands[4] == stack_pointer_rtx && operands[3] != const0_rtx)\n-    output_asm_insn (\"add.w %3,sp\", operands);\n-\n-  return \"\";\n-}\n-\n-\n-/* Here after reloading, before the second scheduling pass.  */\n-\n-void\n-emit_ap_optimizations ()\n-{\n-  /* Removed for now.  */\n-}\n-"}, {"sha": "d50f60b0fd2d8ff2624bffe56485ffa269dfad24", "filename": "gcc/config/convex/convex.h", "status": "removed", "additions": 0, "deletions": 1326, "changes": 1326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1326 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Convex version.\n-   Copyright (C) 1988, 1994, 1995, 1996, 2000, 2001, 2002\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Standard GCC variables that we reference.  */\n-\n-extern int target_flags;\n-\n-/* Convex machine-specific flags\n-   -mc1\t\t      target instruction set, libraries, scheduling \n-   -mc2\t\n-   -mc32\n-   -mc34\n-   -mc38\n-   -margcount\t      use standard calling sequence, with arg count word\n-   -mno-argcount      don't push arg count, depend on symbol table\n-   -margcount-nop     place arg count in a nop instruction (faster than push)\n-   -mvolatile-cache   use data cache for volatile mem refs (default)\n-   -mvolatile-nocache  bypass data cache for volatile mem refs\n-   -mlong32\t      cc- and libc-compatible 32-bit longs\n-   -mlong64\t      64-bit longs\n-*/\n-\n-/* Macro to define tables used to set -mXXX flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0\n-#endif\n-\n-#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-  { { \"c1\", 001, N_(\"Generate code for c1\") },\t\t\t\t\\\n-    { \"c2\", 002, N_(\"Generate code for c2\") },\t\t\t\t\\\n-    { \"c32\", 004, N_(\"Generate code for c32\") },\t\t\t\\\n-    { \"c34\", 010, N_(\"Generate code for c34\") },\t\t\t\\\n-    { \"c38\", 020, N_(\"Generate code for c34\") },\t\t\t\\\n-    { \"argcount\", 0100,\t\t\t\t\t\t\t\\\n-      N_(\"Use standard calling sequence, with arg count word\")},\t\\\n-    { \"argcount-nop\", 0200,\t\t\t\t\t\t\\\n-      N_(\"Place arg count in a nop instruction (faster than push)\") },\t\\\n-    { \"no-argcount\", -0300,\t\t\t\t\t\t\\\n-      N_(\"Don't push arg count, depend on symbol table\") },\t\t\\\n-    { \"volatile-cache\", -0400,\t\t\t\t\t\t\\\n-      N_(\"Use data cache for volatile mem refs (default)\") },\t\t\\\n-    { \"no-volatile-cache\", 0400,\t\t\t\t\t\\\n-      N_(\"Don't use data cache for volatile mem refs\") },\t\t\\\n-    { \"volatile-nocache\", 0400,\t\t\t\t\t\t\\\n-      N_(\"Bypass data cache for volatile mem refs\") },\t\t\t\\\n-    { \"long64\", 01000, N_(\"Use 64-bit longs\") },\t\t\t\\\n-    { \"long32\", -01000, N_(\"Use cc- and libc-compatible 32-bit longs\")},\\\n-    { \"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT}}\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-#define TARGET_C1 (target_cpu == 0)\n-#define TARGET_C2 (target_cpu == 1)\n-#define TARGET_C34 (target_cpu == 2)\n-#define TARGET_C38 (target_cpu == 3)\n-#define TARGET_ARGCOUNT (target_flags & 0100)\n-#define TARGET_ARGCOUNT_NOP (target_flags & 0200)\n-#define TARGET_LONG64 (target_flags & 01000)\n-#define TARGET_VOLATILE_NOCACHE (target_flags & 0400)\n-\n-#define OVERRIDE_OPTIONS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  init_convex ();\t\t\t\t\t\t\t\\\n-  if ((target_flags & 077) != ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 077)) \\\n-    target_flags &= ~ (TARGET_DEFAULT | TARGET_CPU_DEFAULT);\t\t\\\n-  if (target_flags & 001)\t\t\t\t\t\t\\\n-    target_cpu = 0;\t\t\t\t\t\t\t\\\n-  else if (target_flags & 006)\t\t\t\t\t\t\\\n-    target_cpu = 1;\t\t\t\t\t\t\t\\\n-  else if (target_flags & 010)\t\t\t\t\t\t\\\n-    target_cpu = 2;\t\t\t\t\t\t\t\\\n-  else if (target_flags & 020)\t\t\t\t\t\t\\\n-    target_cpu = 3;\t\t\t\t\t\t\t\\\n-}\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dconvex -Dunix -Asystem=unix -Acpu=convex -Amachine=convex\"\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (convex)\");\n-\n-/* Target-dependent specs.\n-   Some libraries come in c1 and c2+ versions; use the appropriate ones.\n-   Make a target-dependent __convex_cxx__ define to relay the target cpu\n-   to the program being compiled.  */\n-\n-#if (TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 1\n-\n-/* C1 default */\n-\n-#if _IEEE_FLOAT_\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{!mc2:%{!mc32:%{!mc34:%{!mc38:-D__convex_c1__}}}}\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#else\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{!mc2:%{!mc32:%{!mc34:%{!mc38:-D__convex_c1__}}}}\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#endif\n-\n-#define LIB_SPEC\t\t\t\t\t\t\t\\\n-\"%{!mc2:%{!mc32:%{!mc34:%{!mc38:-lC1%{p:_p}%{pg:_p}}}}} \\\n- %{mc2:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc32:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc34:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc38:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- -lc%{p:_p}%{pg:_p}\"\n-\n-#endif\n-\n-#if (TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 2\n-\n-/* C2 default */\n-\n-#if _IEEE_FLOAT_\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{!mc1:%{!mc32:%{!mc34:%{!mc38:-D__convex_c2__}}}}\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#else\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{!mc1:%{!mc32:%{!mc34:%{!mc38:-D__convex_c2__}}}}\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#endif\n-\n-#define LIB_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-lC1%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{!mc1:%{!mc32:%{!mc34:%{!mc38:-lC2%{p:_p}%{pg:_p}}}}} \\\n- %{mc32:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc34:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc38:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- -lc%{p:_p}%{pg:_p}\"\n-\n-#endif\n-\n-#if (TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 4\n-\n-/* C32 default */\n-\n-#if _IEEE_FLOAT_\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc34:%{!mc38:-D__convex_c32__}}}}\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#else\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc34:%{!mc38:-D__convex_c32__}}}}\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#endif\n-\n-#define LIB_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-lC1%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc2:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc34:%{!mc38:-lC2%{p:_p}%{pg:_p}}}}} \\\n- %{mc34:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc38:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- -lc%{p:_p}%{pg:_p}\"\n-\n-#endif\n-\n-#if (TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 010\n-\n-/* C34 default */\n-\n-#if _IEEE_FLOAT_\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc32:%{!mc38:-D__convex_c34__}}}}\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#else\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc32:%{!mc38:-D__convex_c34__}}}}\t\t\t\\\n- %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#endif\n-\n-#define LIB_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-lC1%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc2:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc32:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc32:%{!mc38:-lC2%{p:_p}%{pg:_p}}}}} \\\n- %{mc38:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- -lc%{p:_p}%{pg:_p}\"\n-\n-#endif\n-\n-#if (TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 020\n-\n-/* C38 default */\n-\n-#if _IEEE_FLOAT_\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc32:%{!mc34:-D__convex_c38__}}}}\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#else\n-\n-#define CPP_SPEC\t\t\t\t\t\t\t\\\n-\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n- %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n- %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n- %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n- %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n- -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n- -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc32:%{!mc34:-D__convex_c38__}}}}\t\t\t\\\n- %{.S:-P}\t\t\t\t\t\t\t\t\\\n- -D__stdc__ -D_LONGLONG\t\t\t\t\t\t\t\\\n- -Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long\t\t\t\\\n- %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n- %{!ansi:-D_CONVEX_SOURCE}\"\n-\n-#endif\n-\n-#define LIB_SPEC\t\t\t\t\t\\\n-\"%{mc1:-lC1%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc2:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc32:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{mc34:-lC2%{p:_p}%{pg:_p}}\t\t\t\t\\\n- %{!mc1:%{!mc2:%{!mc32:%{!mc34:-lC2%{p:_p}%{pg:_p}}}}}\t\\\n- -lc%{p:_p}%{pg:_p}\"\n-\n-#endif\n-\n-#if _IEEE_FLOAT_\n-\n-/* ieee default */\n-\n-#define ASM_SPEC \"-fi\"\n-\n-#define LINK_SPEC\t\t\t\t\t\t\t\\\n-\"-Eposix\t\t\t\t\t\t\t\t\\\n- -X\t\t\t\t\t\t\t\t\t\\\n- %{F} %{M*} %{y*}\t\t\t\t\t\t\t\\\n- -fi\t\t\t\t\t\t\t\t\t\\\n- -A__iob=___ap$iob\t\t\t\t\t\t\t\\\n- -A_use_libc_sema=___ap$use_libc_sema\t\t\t\t\t\\\n- %-A___gcc_cleanup=___ap$do_registered_functions\t\t\t\\\n- -L/usr/lib\"\n-\n-#define STARTFILE_SPEC\t\t\t\t\t\t\t\\\n-\"%{!pg:%{!p:/usr/lib/crt/crt0.o}}\t\t\t\t\t\\\n- %{!pg:%{p:/usr/lib/crt/mcrt0.o}}\t\t\t\t\t\\\n- %{pg:/usr/lib/crt/gcrt0.o}\t\t\t\t\t\t\\\n- /usr/lib/crt/fpmode_i.o\"\n-\n-#else\n-\n-/* native default */\n-\n-#define ASM_SPEC \"-fn\"\n-\n-#define LINK_SPEC\t\t\t\t\t\t\t\\\n-\"-Eposix\t\t\t\t\t\t\t\t\\\n- -X\t\t\t\t\t\t\t\t\t\\\n- %{F} %{M*} %{y*}\t\t\t\t\t\t\t\\\n- -fn\t\t\t\t\t\t\t\t\t\\\n- -A__iob=___ap$iob\t\t\t\t\t\t\t\\\n- -A_use_libc_sema=___ap$use_libc_sema\t\t\t\t\t\\\n- -A___gcc_cleanup=___ap$do_registered_functions\t\t\t\t\\\n- -L/usr/lib\"\n-\n-#define STARTFILE_SPEC\t\t\t\t\t\t\t\\\n-\"%{!pg:%{!p:/usr/lib/crt/crt0.o}}\t\t\t\t\t\\\n- %{!pg:%{p:/usr/lib/crt/mcrt0.o}}\t\t\t\t\t\\\n- %{pg:/usr/lib/crt/gcrt0.o}\"\n-\n-#endif\n-\n-/* Use /path/libgcc.a instead of -lgcc, makes bootstrap work more smoothly.  */\n-\n-#define LINK_LIBGCC_SPECIAL_1\n-\n-\f\n-/* Target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.  */\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is numbered.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 8\n-\n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 64\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* No data type wants to be aligned rounder than this.  */\n-/* beware of doubles in structs -- 64 is incompatible with cc */\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 0\n-\n-/* Define sizes of basic C types to conform to ordinary usage -- these\n-   types depend on BITS_PER_WORD otherwise.  */\n-#define SHORT_TYPE_SIZE\t\t16\n-#define INT_TYPE_SIZE\t\t32\n-#define LONG_TYPE_SIZE\t\t(TARGET_LONG64 ? 64 : 32)\n-#define LONG_LONG_TYPE_SIZE\t64\n-#define FLOAT_TYPE_SIZE\t\t32\n-#define DOUBLE_TYPE_SIZE\t64\n-#define LONG_DOUBLE_TYPE_SIZE\t64\n-#define MAX_LONG_TYPE_SIZE      64\n-\n-/* Declare the standard types used by builtins to match convex stddef.h --\n-   with int rather than long.  */\n-\n-#define SIZE_TYPE \"unsigned int\"\n-#define PTRDIFF_TYPE \"int\"\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER 16\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   For Convex, these are AP, FP, and SP.  */\n-#define FIXED_REGISTERS \\\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1 }\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS \\\n-  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n-\n-/* List the order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.\n-   For Convex, put S0 (the return register) last.  */\n-#define REG_ALLOC_ORDER \\\n-  { 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 0, 8, 14, 15 }\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On Convex, S registers can hold any type, A registers any nonfloat.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  (S_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n-   || (GET_MODE_SIZE (MODE) <= 4 && (MODE) != SFmode))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)  \\\n-  ((GET_MODE_SIZE (MODE1) <= 4 && (MODE1) != SFmode)\t\t\t\\\n-   == (GET_MODE_SIZE (MODE2) <= 4 && (MODE2) != SFmode))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-#define S0_REGNUM 0\n-#define A0_REGNUM 8\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM A0_REGNUM\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM (A0_REGNUM + 7)\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM (A0_REGNUM + 6)\n-\n-/* Register in which static-chain is passed to a function.\n-   Use S0, not an A reg, because this rare use would otherwise prevent\n-   an A reg from being available to global-alloc across calls.  */\n-#define STATIC_CHAIN_REGNUM S0_REGNUM\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM (A0_REGNUM + 1)\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-/* Convex has classes A (address) and S (scalar).\n-   A is further divided into SP_REGS (stack pointer) and INDEX_REGS.\n-   SI_REGS is S_REGS + INDEX_REGS -- all the regs except SP.  */\n-\n-enum reg_class {\n-  NO_REGS, S_REGS, INDEX_REGS, SP_REGS, A_REGS, SI_REGS,\n-  ALL_REGS, LIM_REG_CLASSES \n-};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Since GENERAL_REGS is the same class as ALL_REGS,\n-   don't give it a different class number; just make it an alias.  */\n-\n-#define GENERAL_REGS ALL_REGS\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"S_REGS\", \"INDEX_REGS\", \"SP_REGS\", \"A_REGS\", \"SI_REGS\", \\\n-  \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS \\\n-  { {0}, {0x00ff}, {0xfe00}, {0x0100}, {0xff00}, {0xfeff}, {0xffff} }\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) (regno_reg_class[REGNO])\n-\n-#define S_REGNO_P(REGNO) ((unsigned)((REGNO) - S0_REGNUM) < 8)\n-#define A_REGNO_P(REGNO) ((unsigned)((REGNO) - A0_REGNUM) < 8)\n-\n-#define S_REG_P(X) (REG_P (X) && S_REGNO_P (REGNO (X)))\n-#define A_REG_P(X) (REG_P (X) && A_REGNO_P (REGNO (X)))\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS INDEX_REGS\n-#define BASE_REG_CLASS INDEX_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-/* a => A_REGS\n-   d => S_REGS  ('s' is taken)\n-   A => INDEX_REGS  (i.e., A_REGS except sp) */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  reg_class_from_letter[(unsigned char) (C)]\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-/* 'I' is used to pass any CONST_INT and reject any CONST_DOUBLE.\n-   CONST_DOUBLE integers are handled by G and H constraint chars.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  1\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-/* Convex uses G, H:\n-   value usable in ld.d (low word 0) or ld.l (high word all sign) */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  (((C) == 'G' && LD_D_P (VALUE)) ||\t\t\t\t\t\\\n-   ((C) == 'H' && LD_L_P (VALUE)) ||\t\t\t\t\t\\\n-   0)\n-\n-#define LD_D_P(X) (const_double_low_int (X) == 0)\n-\n-#define LD_L_P(X) (const_double_low_int (X) >= 0 \\\n-\t\t   ? const_double_high_int (X) == 0 \\\n-\t\t   : const_double_high_int (X) == -1)\n-\n-/* Optional extra constraints for this machine.\n-   For Convex, 'Q' means that OP is a volatile MEM.\n-   For volatile scalars, we use instructions that bypass the data cache.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C) \\\n-  ((C) == 'Q' ? (GET_CODE (OP) == MEM && MEM_VOLATILE_P (OP)\t\t\\\n-\t\t && ! TARGET_C1 && TARGET_VOLATILE_NOCACHE)   \t\t\\\n-   : 0)\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-/* Put 2-word constants that can't be immediate operands into memory.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n-  ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n-    || GET_MODE (X) == SFmode\t\t\t\t\t\t\\\n-    || LD_L_P (X) || LD_D_P (X))  ? (CLASS) : NO_REGS)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)  ((GET_MODE_SIZE (MODE) + 7) / 8)\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Define this if should default to -fcaller-saves.  */\n-#define DEFAULT_CALLER_SAVES\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.  */\n-#define PUSH_ROUNDING(BYTES) (((BYTES) + 3) & ~3)\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) (SIZE)\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), S0_REGNUM)\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, S0_REGNUM)\n-\n-/* Define this if PCC uses the nonreentrant convention for returning\n-   structure and union values.  */\n-\n-#define PCC_STATIC_STRUCT_RETURN\n-\n-/* 1 if N is a possible register number for a function value.\n-   On the Convex, S0 is the only register thus used.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == S0_REGNUM)\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.  */\n-/* On convex, simply count the arguments in case TARGET_ARGCOUNT is set.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n-  ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n-  ((CUM) += 1)\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n-\n-    Convex: all args go on the stack.  But return the arg count\n-    as the \"next arg register\" to be passed to gen_call.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  ((MODE) == VOIDmode ? GEN_INT ((CUM)) : 0)\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-/* On convex, the code for a trampoline is\n-       ld.w #<link>,s0\n-       jmp <func>  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tld.w #69696969,s0\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\tjmp 52525252\\n\");\t\t\t\t\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 12\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 2)), CXT);\t\\\n-  emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 8)), FNADDR); \\\n-  emit_call_insn (gen_call_pop (gen_rtx (MEM, QImode,\t\t\t\\\n-\t\t\t\t\t gen_rtx (SYMBOL_REF, Pmode,\t\\\n-\t\t\t\t\t\t  \"__enable_execute_stack\")), \\\n-\t\t\t\tconst0_rtx, const0_rtx, const0_rtx));\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   fprintf (FILE, \"\\tldea LP%d,a1\\n\\tcallq mcount\\n\", (LABELNO));\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.  */\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n-{ (DEPTH) = (get_frame_size () + 7) & -8; }\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* #define HAVE_POST_INCREMENT 0 */\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-/* #define HAVE_PRE_DECREMENT 0 */\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(regno)  \\\n-  ((regno) <= LAST_VIRTUAL_REGISTER\t\t\t\t\t\\\n-    ? regno_ok_for_index_p[regno]\t\t\t\t\t\\\n-    : regno_ok_for_index_p[reg_renumber[regno]])\n-\n-#define REGNO_OK_FOR_BASE_P(regno)  REGNO_OK_FOR_INDEX_P (regno)\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-/* 1 if X is an rtx for a constant that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-/* For convex, bounce 2-word constants that can't be immediate operands.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\t\\\n-   || GET_MODE (X) == SFmode\t\t\t\t\t\t\\\n-   || LD_L_P (X) || LD_D_P (X))\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) > LAST_VIRTUAL_REGISTER || regno_ok_for_index_p[REGNO (X)])\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) REG_OK_FOR_INDEX_P (X)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   For Convex, valid addresses are\n-       indirectable or (MEM indirectable)\n-   where indirectable is \n-       const, reg, (PLUS reg const)\n-\n-   We don't use indirection since with insn scheduling, load + indexing\n-   is better.  */\n-\n-/* 1 if X is an address that we could indirect through.  */\n-#define INDIRECTABLE_ADDRESS_P(X)  \\\n-  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-       && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 1))\t\t\t\t\\\n-       && CONSTANT_ADDRESS_P (XEXP (X, 0))))\n-\n-/* Go to ADDR if X is a valid address.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if (INDIRECTABLE_ADDRESS_P (xfoob))\t\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (xfoob) == PRE_DEC && XEXP (xfoob, 0) == stack_pointer_rtx) \\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For Convex, nothing needs to be done.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Define this if the case instruction drops through after the table\n-   when the index is out of range.  Don't define it if the case insn\n-   jumps to the default label instead.  */\n-/* #define CASE_DROPS_THROUGH */\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* This flag, if defined, says the same insns that convert to a signed fixnum\n-   also convert validly to an unsigned one.  */\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 8\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS (! TARGET_C2)\n-\n-/* Define if shifts truncate the shift count\n-   which implies one can omit a sign-extension or zero-extension\n-   of a shift count.  */\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* On Convex, it is as good to call a constant function address as to\n-   call an address kept in a register.  */\n-#define NO_FUNCTION_CSE\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE QImode\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST: \\\n-  case LABEL_REF: \\\n-  case SYMBOL_REF: \\\n-  case CONST_INT: \\\n-  case CONST_DOUBLE: \\\n-    return 0;\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE.  */\n-\n-#define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (RTX, 0)) == REG\t\t\t\t\t\\\n-\t&& REG_POINTER (XEXP (RTX, 0))\t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (RTX, 1)) == CONST_INT)\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\t\\\n-    else break;\t\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\t\\\n-    return 4 * (char) (0x03060403 >> target_cpu * 8);\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-    return 4 * (char) (0x03010403 >> target_cpu * 8);\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\t\t\\\n-    return 5;\n-\n-/* Compute the cost of an address.  This is meant to approximate the size\n-   and/or execution delay of an insn using that address.  If the cost is\n-   approximated by the RTL complexity, including CONST_COSTS above, as\n-   is usually the case for CISC machines, this macro should not be defined.\n-   For aggressively RISCy machines, only one insn format is allowed, so\n-   this macro should be a constant.  The value of this macro only matters\n-   for valid addresses.  */\n-\n-#define ADDRESS_COST(RTX) 0\n-\n-/* Specify the cost of a branch insn; roughly the number of extra insns that\n-   should be added to avoid a branch.  */\n-\n-#define BRANCH_COST 0\n-\n-/* Convex uses VAX or IEEE floats.  Default to IEEE.  */\n-#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n-\n-/* Check a `double' value for validity for a particular machine mode.  */\n-#define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) \\\n-   (OVERFLOW = check_float_value (MODE, &D, OVERFLOW))\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for convex.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP,INSN)  {}\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#if _IEEE_FLOAT_\n-#define ASM_FILE_START(FILE)  fprintf (FILE, \";NO_APP\\n.fpmode ieee\\n\")\n-#else\n-#define ASM_FILE_START(FILE)  fprintf (FILE, \";NO_APP\\n.fpmode native\\n\")\n-#endif\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \";APP\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \";NO_APP\\n\"\n-\n-/* Alignment with Convex's assembler goes like this:\n-   .text can be .aligned up to a halfword.\n-   .data and .bss can be .aligned up to a longword.\n-   .lcomm is not supported, explicit declarations in .bss must be used instead.\n-   We get alignment for word and longword .text data by conventionally\n-   using .text 2 for word-aligned data and .text 3 for longword-aligned\n-   data.  This requires that the data's size be a multiple of its alignment,\n-   which seems to be always true.  */\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP (current_section_is_text = 1, \"\\t.text\")\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP (current_section_is_text = 0, \"\\t.data\") \n-\n-/* Output before uninitialized data.  */\n-\n-#define BSS_SECTION_ASM_OP (current_section_is_text = 0, \"\\t.bss\") \n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) do { \\\n-  if (current_section_is_text && (LOG) > 1)\t\t\t\t\\\n-    fprintf (FILE, \".text %d\\n\", LOG);\t\t\t\t\t\\\n-  else if (current_section_is_text)\t\t\t\t\t\\\n-    fprintf (FILE, \".text\\n.align %d\\n\", 1 << (LOG));\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \".align %d\\n\", 1 << (LOG)); } while (0)\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  \"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \t\t\t\\\n-  \"sp\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"ap\", \"fp\",\t\t\t\\\n-}\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* This is the char to use for continuation (in case we need to turn\n-   continuation back on).  */\n-\n-#define DBX_CONTIN_CHAR '?'\n-\n-/* Don't use stab extensions until GDB v4 port is available for convex.  */\n-\n-#define DEFAULT_GDB_EXTENSIONS 0\n-#define DBX_NO_XREFS\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n-\n-/* Put case tables in .text 2, where they will be word-aligned */\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n-  ASM_OUTPUT_ALIGN (FILE, 2); \\\n-  ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM)\n-\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE) \\\n-  ASM_OUTPUT_ALIGN (FILE, 1)\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* This is how to output a string */\n-\n-#define ASM_OUTPUT_ASCII(FILE,STR,SIZE) do {\t\t\t\t\\\n-  size_t i, limit = (SIZE);\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\tds.b \\\"\");\t\t\t\t\t\\\n-  for (i = 0; i < limit; i++) {\t\t\t\t\t\t\\\n-      register int c = (STR)[i] & 0377;\t\t\t\t\t\\\n-      if (c >= ' ' && c < 0177 && c != '\\\\' && c != '\"')\t\t\\\n-\t  putc (c, (FILE));\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t  fprintf ((FILE), \"\\\\%03o\", c);}\t\t\t\t\\\n-  fprintf ((FILE), \"\\\"\\n\");} while (0)\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \t\\\n-   fprintf (FILE, \"\\tpsh.%c %s\\n\",\t\t\\\n-\t    S_REGNO_P (REGNO) ? 'l' : 'w',\t\\\n-\t    reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\\\n-   fprintf (FILE, \"\\tpop.%c %s\\n\",\t\t\\\n-\t    S_REGNO_P (REGNO) ? 'l' : 'w',\t\\\n-\t    reg_names[REGNO])\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\tds.w L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  \n-   (not used on Convex) */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\tds.w L%d-L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter by SIZE bytes.  */\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\tds.b %u(0)\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( bss_section (),\t\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \":\\tbs.b %u\\n\", (ROUNDED)))\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Output an arg count before function entries.  */\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n-  asm_declare_function_name (FILE, NAME, DECL)\n-\n-/* Print an instruction operand X on file FILE.\n-   CODE is the code from the %-spec that requested printing this operand;\n-   if `%z3' was used to print operand 3, then CODE is 'z'.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-    print_operand (FILE, X, CODE)\n-\n-/* Print a memory operand whose address is X, on file FILE.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n-    print_operand_address (FILE, ADDR)\n-\f\n-/* Do not put out GNU stabs for constructors and destructors.\n-   ld bounces them.  */\n-\n-#define FASCIST_ASSEMBLER\n-\n-/* __gcc_cleanup is loader-aliased to __ap$do_registered_functions if we\n-   are linking against standard libc.   */\n-\n-#define EXIT_BODY \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  extern void __gcc_cleanup ();\t\t\t\t\t\t\\\n-  if (__gcc_cleanup != _cleanup)\t\t\t\t\t\\\n-    __gcc_cleanup ();\t\t\t\t\t\t\t\\\n-  _cleanup ();\t\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Header for convex.c.\n-   Here at the end so we can use types defined above.  */\n-\n-extern int target_cpu;\n-extern int current_section_is_text;\n-extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n-extern enum reg_class reg_class_from_letter[256];\n-extern char regno_ok_for_index_p_base[];\n-#define regno_ok_for_index_p (regno_ok_for_index_p_base + 1)\n-"}, {"sha": "ca4978f0606fec8f237b31c261047e2a7bd3909d", "filename": "gcc/config/convex/convex.md", "status": "removed", "additions": 0, "deletions": 1885, "changes": 1885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fconvex.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.md?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,1885 +0,0 @@\n-;;- Machine description for GNU compiler, Convex Version\n-;;  Copyright (C) 1988, 1994, 1995, 1998, 1999 Free Software Foundation, Inc.\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\f\n-;; Attribute specifications\n-\n-; Target CPU\n-(define_attr \"cpu\" \"c1,c32,c34,c38\"\n-  (const (symbol_ref \"(enum attr_cpu) target_cpu\")))\n-\n-;; Instruction classification\n-\n-(define_attr \"type\"\n-  \"alu,xalu,mldw,mldl,mldb,mst,adds,addd,mulw,mull,muls,muld,divw,divl,divs,divd,shfw,shfl,cvts,cvtd\"\n-  (const_string \"alu\"))\n-\n-;; Instruction times\n-\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mldw\")) 2 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mldl\")) 4 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mldw,mldl\")) 2 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mldw,mldl\")) 4 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mldw,mldl\")) 2 0)\n-\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mldb\")) 9 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mldb\")) 36 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mldb\")) 21 0)\n-\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"xalu\")) 1 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"xalu\")) 1 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"xalu\")) 5 0)\n-(define_function_unit \"mem\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"xalu\")) 2 0)\n-\n-(define_function_unit \"add\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"adds,addd\")) 3 2)\n-(define_function_unit \"add\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"adds,addd\")) 2 1)\n-(define_function_unit \"add\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"adds,addd\")) 5 2)\n-(define_function_unit \"add\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"adds,addd\")) 2 1)\n-\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mulw,muls\")) 3 2)\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mulw,muls\")) 4 2)\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mulw,muls\")) 6 2)\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mulw,muls\")) 3 2)\n-\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mull,muld\")) 4 3)\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mull\")) 10 7)\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"muld\")) 5 2)\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mull,muld\")) 7 3)\n-(define_function_unit \"mul\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mull,muld\")) 4 3)\n-\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divw\")) 24 24)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divw\")) 44 6)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divw\")) 14 10)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divw\")) 11 10)\n-\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divl\")) 41 42)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divl\")) 76 5)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divl\")) 22 18)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divl\")) 19 18)\n-\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divs\")) 22 22)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divs\")) 8 6)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divs\")) 13 9)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divs\")) 10 9)\n-\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divd\")) 37 38)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divd\")) 12 8)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divd\")) 20 16)\n-(define_function_unit \"div\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divd\")) 17 16)\n-\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"cvts,cvtd\")) 4 3)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"cvts\")) 9 7)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"cvtd\")) 9 6)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"cvts\")) 6 2)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"cvtd\")) 6 1)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"cvts,cvtd\")) 3 1)\n-\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"shfw,shfl\")) 3 2)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"shfw\")) 7 5)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"shfl\")) 7 4)\n-(define_function_unit \"misc\" 1 0\n-  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"shfw,shfl\")) 3 1)\n-\n-(define_function_unit \"mystery_latch\" 1 1\n-  (and (eq_attr \"type\" \"!alu,mldw,mldl,adds,addd\") (eq_attr \"cpu\" \"c32\")) 2 2)\n-\n-;(define_function_unit \"ip\" 1 1\n-;  (and (eq_attr \"cpu\" \"c1\")\n-;       (eq_attr \"type\" \"divw,divl,divs,divd,xalu\")) 2 2)\n-;(define_function_unit \"ip\" 1 1\n-;  (and (eq_attr \"cpu\" \"c1\")\n-;       (eq_attr \"type\" \"!divw,divl,divs,divd,xalu\")) 1 1)\n-;(define_function_unit \"ip\" 1 1\n-;  (and (eq_attr \"cpu\" \"c32\")\n-;       (eq_attr \"type\" \"mull,muld,divl,divd,shfl,cvtd,xalu\")) 2 2)\n-;(define_function_unit \"ip\" 1 1\n-;  (and (eq_attr \"cpu\" \"c32\")\n-;       (eq_attr \"type\" \"!mull,muld,divl,divd,shfl,cvtd,xalu\")) 1 1)\n-;(define_function_unit \"ip\" 1 1\n-;  (and (eq_attr \"cpu\" \"c34\")\n-;       (eq_attr \"type\" \"addd,mull,muld,divl,divd,cvtd,xalu\")) 2 2)\n-;(define_function_unit \"ip\" 1 1\n-;  (and (eq_attr \"cpu\" \"c34\")\n-;       (eq_attr \"type\" \"!addd,mull,muld,divl,divd,cvtd,xalu\")) 1 1)\n-\f\n-;; Make the first thing a real insn in case of genattrtab bug\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\")\n-\f\n-;; Moves\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"if (GET_CODE (operands[0]) != REG)\n-     operands[1] = force_reg (DFmode, operands[1]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=d,d,d,d,d,<,m\")\n-\t(match_operand:DF 1 \"general_operand\"  \"d,Q,m,G,H,d,d\"))]\n-  \"register_operand (operands[0], DFmode)\n-   || register_operand (operands[1], DFmode)\"\n-  \"@\n-   mov %1,%0\n-   ldb.d %1,%0\n-   ld.d %1,%0\n-   ld.d %u1,%0\n-   ld.l %v1,%0\n-   psh.l %1\n-   st.d %1,%0\"\n-  [(set_attr \"type\" \"alu,mldb,mldl,alu,alu,alu,mst\")])\n-\n-;; This is here so we can load any result of RTL constant folding\n-;; but do not use it on constants that can be loaded from memory.\n-;; It is never better and can be worse.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(match_operand:DF 1 \"const_double_operand\" \"F\"))]\n-  \"mem_for_const_double (operands[1]) == 0\"\n-  \"ld.u %u1,%0\\;ld.w %v1,%0\"\n-  [(set_attr \"type\" \"xalu\")])\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"if (GET_CODE (operands[0]) != REG)\n-     operands[1] = force_reg (SFmode, operands[1]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=d,d,d,d,<,m\")\n-\t(match_operand:SF 1 \"general_operand\" \"d,Q,m,F,d,d\"))]\n-  \"register_operand (operands[0], SFmode)\n-   || register_operand (operands[1], SFmode)\"\n-  \"@\n-   mov.s %1,%0\n-   ldb.s %1,%0\n-   ld.s %1,%0\n-   ld.s %1,%0\n-   psh.w %1\n-   st.s %1,%0\"\n-  [(set_attr \"type\" \"alu,mldb,mldw,alu,alu,mst\")])\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"if (GET_CODE (operands[0]) != REG)\n-     operands[1] = force_reg (DImode, operands[1]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,d,<,m\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,Q,m,G,HI,d,d\"))]\n-  \"register_operand (operands[0], DImode)\n-   || register_operand (operands[1], DImode)\"\n-  \"@\n-   mov %1,%0\n-   ldb.l %1,%0\n-   ld.l %1,%0\n-   ld.d %u1,%0\n-   ld.l %1,%0\n-   psh.l %1\n-   st.l %1,%0\"\n-  [(set_attr \"type\" \"alu,mldb,mldl,alu,alu,alu,mst\")])\n-\n-;; This is here so we can load any result of RTL constant folding\n-;; but do not use it on constants that can be loaded from memory.\n-;; It is never better and can be worse.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"F\"))]\n-  \"mem_for_const_double (operands[1]) == 0\"\n-  \"ld.u %u1,%0\\;ld.w %v1,%0\"\n-  [(set_attr \"type\" \"xalu\")])\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"if (GET_CODE (operands[0]) != REG)\n-     operands[1] = force_reg (SImode, operands[1]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SI 1 \"nonmemory_operand\" \"Ad,i\"))]\n-  \"\"\n-  \"@\n-   psh.w %1\n-   pshea %a1\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,r,d,r,r,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"d,r,Q,m,i,r\"))]\n-  \"register_operand (operands[0], SImode)\n-   || register_operand (operands[1], SImode)\"\n-  \"@\n-   mov.w %1,%0\n-   mov %1,%0\n-   ldb.w %1,%0\n-   ld.w %1,%0\n-   ld.w %1,%0\n-   st.w %1,%0\"\n-  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,mst\")])\n-\n-(define_expand \"movstrictsi\"\n-  [(set (strict_low_part (match_operand:SI 0 \"general_operand\" \"\"))\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"if (GET_CODE (operands[0]) != REG)\n-     operands[1] = force_reg (SImode, operands[1]);\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:SI 0 \"general_operand\" \"+d,r,d,r,r,m\"))\n-\t(match_operand:SI 1 \"general_operand\" \"d,r,Q,m,i,r\"))]\n-  \"register_operand (operands[0], SImode)\n-   || register_operand (operands[1], SImode)\"\n-  \"@\n-   mov.w %1,%0\n-   mov %1,%0\n-   ldb.w %1,%0\n-   ld.w %1,%0\n-   ld.w %1,%0\n-   st.w %1,%0\"\n-  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,mst\")])\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"if (GET_CODE (operands[0]) != REG)\n-     operands[1] = force_reg (HImode, operands[1]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,r,d,r,r,<,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"d,r,Q,m,i,Ad,r\"))]\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\"\n-  \"@\n-   mov.w %1,%0\n-   mov %1,%0\n-   ldb.h %1,%0\n-   ld.h %1,%0\n-   ld.w %1,%0\n-   psh.w %1\n-   st.h %1,%0\"\n-  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,alu,mst\")])\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"if (GET_CODE (operands[0]) != REG)\n-     operands[1] = force_reg (QImode, operands[1]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,r,d,r,r,<,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"d,r,Q,m,i,Ad,r\"))]\n-  \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\"\n-  \"@\n-   mov.w %1,%0\n-   mov %1,%0\n-   ldb.b %1,%0\n-   ld.b %1,%0\n-   ld.w %1,%0\n-   psh.w %1\n-   st.b %1,%0\"\n-  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,alu,mst\")])\n-\n-;; Expand block moves manually to get code that pipelines the loads.\n-\n-(define_expand \"movstrsi\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n-\t(match_operand:BLK 1 \"memory_operand\" \"m\"))\n-   (use (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"i\"))]\n-  \"\"\n-  \" expand_movstr (operands); DONE; \")\n-\f\n-;; Extension and truncation insns.\n-;; Those for integer source operand\n-;; are ordered widest source type first.\n-\n-(define_insn \"truncsiqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n-\t(truncate:QI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"cvtw.b %1,%0\")\n-\n-(define_insn \"truncsihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(truncate:HI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"cvtw.h %1,%0\")\n-\n-(define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(truncate:QI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"truncdisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(truncate:SI (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"cvtl.w %1,%0\")\n-\n-(define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"cvtw.l %1,%0\")\n-\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"cvth.w %1,%0\")\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"cvtb.w %1,%0\")\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"cvtb.w %1,%0\")\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"cvts.d %1,%0\"\n-  [(set_attr \"type\" \"cvts\")])\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"cvtd.s %1,%0\"\n-  [(set_attr \"type\" \"cvtd\")])\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"and #0xffff,%0\")\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"and #0xff,%0\")\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"and #0xff,%0\")\n-\n-(define_insn \"zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"ld.u #0,%0\")\n-\f\n-;; Fix-to-float conversion insns.\n-;; Note that the ones that start with SImode come first.\n-;; That is so that an operand that is a CONST_INT\n-;; (and therefore lacks a specific machine mode).\n-;; will be recognized as SImode (which is always valid)\n-;; rather than as QImode or HImode.\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"cvtw.s %1,%0\"\n-  [(set_attr \"type\" \"cvts\")])\n-\n-(define_insn \"floatdisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float:SF (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"cvtl.s %1,%0\"\n-  [(set_attr \"type\" \"cvtd\")])\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"! TARGET_C1\"\n-  \"cvtw.d %1,%0\"\n-  [(set_attr \"type\" \"cvts\")])\n-\n-(define_insn \"floatdidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(float:DF (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"cvtl.d %1,%0\"\n-  [(set_attr \"type\" \"cvtd\")])\n-\n-;; These are a little slower than gcc's normal way of doing unsigned\n-;; DI floats (if the DI number is \"negative\") but they avoid double\n-;; rounding and they avoid explicit constants.\n-\n-(define_expand \"floatunsdidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(float:DF (match_operand:DI 1 \"register_operand\" \"d\")))\n-   (set (cc0) (compare:DI (match_dup 3) (match_dup 1)))\n-   (set (pc)\n-\t(if_then_else (le (cc0) (const_int 0))\n-\t\t      (label_ref (match_dup 4))\n-\t\t      (pc)))\n-   (set (match_dup 2) (lshiftrt:DI (match_dup 1) (const_int 1)))\n-   (set (match_dup 0) (float:DF (match_dup 2)))\n-   (set (match_dup 0) (plus:DF (match_dup 0) (match_dup 0)))\n-   (match_dup 4)\n-   (set (match_dup 0) (match_dup 0))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DImode);\n-  operands[3] = force_reg (DImode, const0_rtx);\n-  operands[4] = gen_label_rtx ();\n-}\")\n-\n-(define_expand \"floatunsdisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float:SF (match_operand:DI 1 \"register_operand\" \"d\")))\n-   (set (cc0) (compare:DI (match_dup 3) (match_dup 1)))\n-   (set (pc)\n-\t(if_then_else (le (cc0) (const_int 0))\n-\t\t      (label_ref (match_dup 4))\n-\t\t      (pc)))\n-   (set (match_dup 2) (lshiftrt:DI (match_dup 1) (const_int 1)))\n-   (set (match_dup 0) (float:SF (match_dup 2)))\n-   (set (match_dup 0) (plus:SF (match_dup 0) (match_dup 0)))\n-   (match_dup 4)\n-   (set (match_dup 0) (match_dup 0))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DImode);\n-  operands[3] = force_reg (DImode, const0_rtx);\n-  operands[4] = gen_label_rtx ();\n-}\")\n-\n-;; These patterns are identical to gcc's default action \n-;; if DI->DF and DI->SF are not present.  There are here\n-;; only to prevent SI->*F from promoting to DI->*F.\n-\n-(define_expand \"floatunssidf2\"\n-  [(set (match_dup 2)\n-\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n-   (set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(float:DF (match_dup 2)))]\n-  \"\"\n-  \"operands[2] = gen_reg_rtx (DImode);\")\n-\n-(define_expand \"floatunssisf2\"\n-  [(set (match_dup 2)\n-        (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n-   (set (match_operand:SF 0 \"register_operand\" \"\")\n-        (float:SF (match_dup 2)))]\n-  \"\"\n-  \"operands[2] = gen_reg_rtx (DImode);\")\n-\f\n-;; Float-to-fix conversion insns.\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"cvts.w %1,%0\"\n-  [(set_attr \"type\" \"cvts\")])\n-\n-(define_insn \"fix_truncsfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"cvts.l %1,%0\"\n-  [(set_attr \"type\" \"cvts\")])\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"cvtd.l %1,%0\"\n-  [(set_attr \"type\" \"cvtd\")])\n-\n-(define_insn \"fix_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"cvtd.l %1,%0\"\n-  [(set_attr \"type\" \"cvtd\")])\n-\f\n-;;- All kinds of add instructions.\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"add.d %2,%0\"\n-  [(set_attr \"type\" \"addd\")])\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n-  \"\"\n-  \"add.s %2,%0\"\n-  [(set_attr \"type\" \"adds\")])\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"add.l %2,%0\")\n-\n-(define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%A\")\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"operands[1] == frame_pointer_rtx || operands[1] == arg_pointer_rtx\"\n-  \"ldea %a2(%1),%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%a\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))]\n-  \"operands[1] == stack_pointer_rtx && operands[0] != stack_pointer_rtx\"\n-  \"mov %1,%0\\;add.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"A\")\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"operands[1] != stack_pointer_rtx\"\n-  \"pshea %a2(%1)\"\n-  [(set_attr \"type\" \"mst\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,A\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ri,i\")))]\n-  \"TARGET_C1\"\n-  \"@\n-   add.w %2,%0\n-   add.w %2,%0\n-   ldea %a2(%1),%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,A\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ri,i\")))]\n-  \"\"\n-  \"@\n-   add.w %2,%0\n-   add.w %2,%0\n-   ldea %a2(%1),%0\")\n-\n-(define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"add.h %2,%0\")\n-\n-(define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,d\")\n-\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:QI 2 \"nonmemory_operand\" \"d,i\")))]\n-  \"\"\n-  \"@\n-   add.b %2,%0\n-   add.w %2,%0\")\n-\f\n-;;- All kinds of subtract instructions.\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"sub.d %2,%0\"\n-  [(set_attr \"type\" \"addd\")])\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n-  \"\"\n-  \"sub.s %2,%0\"\n-  [(set_attr \"type\" \"adds\")])\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"sub.l %2,%0\")\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,?d,?a\")\n-\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,0,di,ai\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"di,ai,0,0\")))]\n-  \"\"\n-  \"@\n-  sub.w %2,%0\n-  sub.w %2,%0\n-  sub.w %1,%0\\;neg.w %0,%0\n-  sub.w %1,%0\\;neg.w %0,%0\")\n-\n-(define_insn \"subhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"sub.h %2,%0\")\n-\n-(define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,d\")\n-\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n-\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"d,i\")))]\n-  \"\"\n-  \"@\n-   sub.b %2,%0\n-   sub.w %2,%0\")\n-\f\n-;;- Multiply instructions.\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"mul.d %2,%0\"\n-  [(set_attr \"type\" \"muld\")])\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n-  \"\"\n-  \"mul.s %2,%0\"\n-  [(set_attr \"type\" \"muls\")])\n-\n-(define_insn \"muldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(mult:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"mul.l %2,%0\"\n-  [(set_attr \"type\" \"mull\")])\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"mul.w %2,%0\"\n-  [(set_attr \"type\" \"mulw\")])\n-\n-(define_insn \"mulhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"mul.h %2,%0\"\n-  [(set_attr \"type\" \"mulw\")])\n-\n-(define_insn \"mulqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,d\")\n-\t(mult:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:QI 2 \"nonmemory_operand\" \"d,i\")))]\n-  \"\"\n-  \"@\n-   mul.b %2,%0\n-   mul.w %2,%0\"\n-  [(set_attr \"type\" \"mulw,mulw\")])\n-\f\n-;;- Divide instructions.\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"0\")\n-\t\t(match_operand:DF 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"div.d %2,%0\"\n-  [(set_attr \"type\" \"divd\")])\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t(match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n-  \"\"\n-  \"div.s %2,%0\"\n-  [(set_attr \"type\" \"divs\")])\n-\n-(define_insn \"divdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(div:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"div.l %2,%0\"\n-  [(set_attr \"type\" \"divl\")])\n-\n-(define_expand \"udivsi3\"\n-  [(set (match_dup 3)\n-\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n-   (set (match_dup 4)\n-\t(zero_extend:DI (match_operand:SI 2 \"register_operand\" \"\")))\n-   (set (match_dup 3)\n-\t(div:DI (match_dup 3) (match_dup 4)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(subreg:SI (match_dup 3) 0))]\n-  \"\"\n-  \"operands[3] = gen_reg_rtx (DImode);\n-   operands[4] = gen_reg_rtx (DImode); \")\n-\n-(define_insn \"udivdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"psh.l %2\\;psh.l %1\\;callq udiv64\\;pop.l %0\\;add.w #8,sp\")\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"div.w %2,%0\"\n-  [(set_attr \"type\" \"divw\")])\n-\n-(define_insn \"divhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(div:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"div.h %2,%0\"\n-  [(set_attr \"type\" \"divw\")])\n-\n-(define_insn \"divqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n-\t(div:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t(match_operand:QI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"div.b %2,%0\"\n-  [(set_attr \"type\" \"divw\")])\n-\f\n-;;- Bit clear instructions.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(and:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"\" \"\")))]\n-  \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-   || (GET_CODE (operands[2]) == CONST_DOUBLE\n-       && CONST_DOUBLE_HIGH (operands[2]) == -1)\"\n-  \"and %2,%0\")\n-\n-(define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(and:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"and %2,%0\")\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"and %2,%0\")\n-\n-(define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"and %2,%0\")\n-\n-(define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n-\t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"and %2,%0\")\n-\n-;;- Bit set instructions.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"\" \"\")))]\n-  \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0)\n-   || (GET_CODE (operands[2]) == CONST_DOUBLE\n-       && CONST_DOUBLE_HIGH (operands[2]) == 0)\"\n-  \"or %2,%0\")\n-\n-(define_insn \"iordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"or %2,%0\")\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"or %2,%0\")\n-\n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"or %2,%0\")\n-\n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n-\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"or %2,%0\")\n-\n-;;- xor instructions.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"\" \"\")))]\n-  \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0)\n-   || (GET_CODE (operands[2]) == CONST_DOUBLE\n-       && CONST_DOUBLE_HIGH (operands[2]) == 0)\"\n-  \"xor %2,%0\")\n-\n-(define_insn \"xordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"xor %2,%0\")\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"xor %2,%0\")\n-\n-(define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(xor:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"xor %2,%0\")\n-\n-(define_insn \"xorqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n-\t(xor:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"xor %2,%0\")\n-\f\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"neg.d %1,%0\"\n-  [(set_attr \"type\" \"addd\")])\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"neg.s %1,%0\"\n-  [(set_attr \"type\" \"adds\")])\n-\n-(define_insn \"negdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(neg:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"neg.l %1,%0\")\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"neg.w %1,%0\")\n-\n-(define_insn \"neghi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(neg:HI (match_operand:HI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"neg.h %1,%0\")\n-\n-(define_insn \"negqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n-\t(neg:QI (match_operand:QI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"neg.b %1,%0\")\n-\f\n-(define_insn \"one_cmpldi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(not:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"not %1,%0\")\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"not %1,%0\")\n-\n-(define_insn \"one_cmplhi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n-\t(not:HI (match_operand:HI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"not %1,%0\")\n-\n-(define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n-\t(not:QI (match_operand:QI 1 \"register_operand\" \"d,a\")))]\n-  \"\"\n-  \"not %1,%0\")\n-\f\n-;;- Shifts\n-;;\n-;; The extreme profusion of patterns here is due to the different-speed\n-;; shifts on different machines, and the C1's lack of word shift S-register\n-;; instructions.\n-\n-;; SImode\n-\n-;; Arithmetic left 1, 1 cycle on all machines via add\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t   (const_int 1)))]\n-  \"\"\n-  \"add.w %0,%0\")\n-\n-;; C34 general shift is 1 cycle\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"TARGET_C34\"\n-  \"@\n-   shf.w %2,%0\n-   shf %2,%0\"\n-  [(set_attr \"type\" \"shfw,shfw\")])\n-\n-;; else shift left 0..7 is 1 cycle if we use an A register\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"ai,di\")))]\n-  \"TARGET_C1 && INTVAL (operands[2]) < (unsigned) 8\"\n-  \"@\n-   shf %2,%0\n-   shf %2,%0\"\n-  [(set_attr \"type\" \"alu,shfl\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"ai,di\")))]\n-  \"INTVAL (operands[2]) < (unsigned) 8\"\n-  \"@\n-   shf %2,%0\n-   shf.w %2,%0\"\n-  [(set_attr \"type\" \"alu,shfw\")])\n-\n-;; else general left shift\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"TARGET_C1\"\n-  \"@\n-   shf %2,%0\n-   shf %2,%0\"\n-  [(set_attr \"type\" \"shfl,shfw\")])\n-\n-;; but C2 left shift by a constant is faster via multiply\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n-  \"TARGET_C2 && INTVAL (operands[2]) < (unsigned) 32\"\n-  \"mul.w %z2,%0\"\n-  [(set_attr \"type\" \"mulw\")])\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"@\n-   shf.w %2,%0\n-   shf %2,%0\"\n-  [(set_attr \"type\" \"shfw,shfw\")])\n-\n-;; Logical right, general\n-;; The hardware wants the negative of the shift count\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n-  \"\"\n-  \"operands[2] = negate_rtx (SImode, operands[2]);\")\n-\n-;; C1 lacks word shift S reg\n-\n-(define_insn \"\"\n-  [(set\n-    (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n-    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"ai,di\"))))]\n-  \"TARGET_C1\"\n-  \"@\n-   shf %2,%0\n-   ld.u #0,%0\\;shf %2,%0\"\n-  [(set_attr \"type\" \"shfw,shfl\")])\n-\n-;; general case\n-\n-(define_insn \"\"\n-  [(set\n-    (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\"))))]\n-  \"\"\n-  \"@\n-   shf.w %2,%0\n-   shf %2,%0\"\n-  [(set_attr \"type\" \"shfw,shfw\")])\n-\n-;; Patterns without neg produced by constant folding\n-\n-(define_insn \"\"\n-  [(set\n-    (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n-    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n-  \"TARGET_C1\"\n-  \"@\n-   shf #%n2,%0\n-   ld.u #0,%0\\;shf #%n2,%0\"\n-  [(set_attr \"type\" \"shfw,shfl\")])\n-\n-(define_insn \"\"\n-  [(set\n-    (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n-  \"\"\n-  \"@\n-   shf.w #%n2,%0\n-   shf #%n2,%0\"\n-  [(set_attr \"type\" \"shfw,shfw\")])\n-\n-;; Arithmetic right, general\n-;; Sign-extend to 64 bits, then shift that.  Works for 0..32.\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n-  \"\"\n-  \"operands[2] = negate_rtx (SImode, operands[2]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,&d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n-\t\t     (neg:SI\n-\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"di,di\"))))]\n-  \"\"\n-  \"cvtw.l %1,%0\\;shf %2,%0\"\n-  [(set_attr \"type\" \"shfl,shfl\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"\"\n-  \"cvtw.l %1,%0\\;shf #%n2,%0\"\n-  [(set_attr \"type\" \"shfl\")])\n-\n-;; DImode\n-;; Arithmetic left, 1-cycle\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t   (const_int 1)))]\n-  \"\"\n-  \"add.l %0,%0\")\n-\n-;; Arithmetic left, general\n-\n-(define_insn \"ashldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n-  \"\"\n-  \"shf %2,%0\"\n-  [(set_attr \"type\" \"shfl\")])\n-\n-;; Can omit zero- or sign-extend if shift is 32 or more.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashift:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"0\"))\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n-  \"INTVAL (operands[2]) >= 32\"\n-  \"shf %2,%0\"\n-  [(set_attr \"type\" \"shfl\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashift:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"0\"))\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n-  \"INTVAL (operands[2]) >= 32\"\n-  \"shf %2,%0\"\n-  [(set_attr \"type\" \"shfl\")])\n-\n-;; Logical right, general\n-\n-(define_expand \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n-  \"\"\n-  \"operands[2] = negate_rtx (SImode, operands[2]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n-  \"\"\n-  \"shf %2,%0\"\n-  [(set_attr \"type\" \"shfl\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"\"\n-  \"shf #%n2,%0\"\n-  [(set_attr \"type\" \"shfl\")])\n-\n-;; Arithmetic right, general\n-;; Use\n-;;     ((a >> b) ^ signbit) - signbit\n-;; where signbit is (1 << 63) >> b\n-;; Works for 0..63.  Does not work for 64; unfortunate but valid.\n-\n-(define_expand \"ashrdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))\n-   (set (match_dup 3) (lshiftrt:DI (match_dup 3) (neg:SI (match_dup 2))))\n-   (set (match_dup 0) (xor:DI (match_dup 0) (match_dup 3)))\n-   (set (match_dup 0) (minus:DI (match_dup 0) (match_dup 3)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    switch (INTVAL (operands[2]))\n-      {\n-      case 32:\n-\temit_insn (gen_ashrdi3_32 (operands[0], operands[1]));\n-\tDONE;\n-      }\n-\n-  operands[2] = negate_rtx (SImode, operands[2]);\n-  operands[3] = force_reg (DImode, immed_double_const (0, 1 << 31, DImode));\n-}\")\n-\n-;; Arithmetic right 32, a common case that can save a couple of insns.\n-\n-(define_expand \"ashrdi3_32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t     (const_int 32)))\n-   (set (match_dup 0)\n-\t(sign_extend:DI (subreg:SI (match_dup 0) 0)))]\n-  \"\"\n-  \"\")\n-\f\n-;; __builtin instructions\n-\n-(define_insn \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n-  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n-  \"sqrt.d %0\"\n-  [(set_attr \"type\" \"divd\")])\n-\n-(define_insn \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n-  \"sqrt.s %0\"\n-  [(set_attr \"type\" \"divs\")])\n-\n-(define_insn \"sindf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n-  \"sin.d %0\")\n-\n-(define_insn \"sinsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n-  \"sin.s %0\")\n-\n-(define_insn \"cosdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n-  \"cos.d %0\")\n-\n-(define_insn \"cossf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n-  \"cos.s %0\")\n-\n-(define_insn \"ftruncdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(fix:DF (match_operand:DF 1 \"register_operand\" \"d\")))]\n-  \"! TARGET_C1\"\n-  \"frint.d %1,%0\"\n-  [(set_attr \"type\" \"cvtd\")])\n-\n-(define_insn \"ftruncsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(fix:SF (match_operand:SF 1 \"register_operand\" \"d\")))]\n-  \"! TARGET_C1\"\n-  \"frint.s %1,%0\"\n-  [(set_attr \"type\" \"cvts\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t  (const_int 1)))]\n-  \"\"\n-  \"tzc %1,%0\\;le.w #32,%0\\;jbrs.f L0%=\\;ld.w #-1,%0\\\\nL0%=:\")\n-\n-(define_expand \"ffssi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t  (const_int 1)))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int 1)))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"and #0x7fffffff,%0\")\n-\n-(define_expand \"absdf2\"\n-  [(set (subreg:DI (match_operand:DF 0 \"register_operand\" \"=d\") 0)\n-\t(and:DI (subreg:DI (match_operand:DF 1 \"register_operand\" \"d\") 0)\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"operands[2] = force_reg (DImode,\n-                            immed_double_const (-1, 0x7fffffff, DImode));\")\n-\f\n-;;- Compares\n-\n-(define_insn \"cmpdi\"\n-  [(set (cc0)\n-\t(compare (match_operand:DI 0 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 'l');\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (match_operand:DI 0 \"register_operand\" \"d\"))\n-   (clobber (match_scratch:DI 1 \"=d\"))]\n-  \"next_insn_tests_no_inequality (insn)\"\n-  \"* return output_cmp (operands[0], operands[1], 'L');\")\n-\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"d,a\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 'w');\")\n-\n-(define_insn \"cmphi\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"d,a\")\n-\t\t (match_operand:HI 1 \"nonmemory_operand\" \"di,ai\")))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 'h');\")\n-\n-; cmpqi is intentionally omitted.\n-;\n-; gcc will sign-extend or zero-extend the operands to the next\n-; wider mode, HImode.\n-;\n-; For reg .cmp. constant, we just go with the halfword immediate\n-; instruction.  Perhaps the widening insn can be cse'd or combined away.\n-; If not, we're still as good as loading a byte constant into a register\n-; to do a reg-reg byte compare.\n-;\n-; The following patterns pick up cases that can use reg .cmp. reg after all.\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare\n-\t (sign_extend:HI (match_operand:QI 0 \"register_operand\" \"d\"))\n-\t (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 'b');\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare\n-\t (ashift:HI (subreg:HI (match_operand:QI 0 \"register_operand\" \"d\") 0)\n-\t\t    (const_int 8))\n-\t (ashift:HI (subreg:HI (match_operand:QI 1 \"register_operand\" \"d\") 0)\n-\t\t    (const_int 8))))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 'b');\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"register_operand\" \"d\")\n-\t\t (match_operand:QI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 'b');\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"d\"))\n-   (clobber (match_scratch:QI 1 \"=d\"))]\n-  \"next_insn_tests_no_inequality (insn)\"\n-  \"* return output_cmp (operands[0], operands[1], 'B');\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (subreg (match_operand:QI 0 \"register_operand\" \"d\") 0))\n-   (clobber (match_scratch:QI 1 \"=d\"))]\n-  \"next_insn_tests_no_inequality (insn)\"\n-  \"* return output_cmp (operands[0], operands[1], 'B');\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(zero_extend (subreg (match_operand:QI 0 \"register_operand\" \"d\") 0)))\n-   (clobber (match_scratch:QI 1 \"=d\"))]\n-  \"next_insn_tests_no_inequality (insn)\"\n-  \"* return output_cmp (operands[0], operands[1], 'B');\")\n-\n-(define_insn \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"register_operand\" \"d\")\n-\t\t (match_operand:DF 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 'd');\")\n-\n-(define_insn \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"register_operand\" \"d\")\n-\t\t (match_operand:SF 1 \"nonmemory_cmpsf_operand\" \"dF\")))]\n-  \"\"\n-  \"* return output_cmp (operands[0], operands[1], 's');\")\n-\f\n-;; decrement-and-set-cc0 insns.\n-;;\n-;; The most important case where we can use the carry bit from an\n-;; arithmetic insn to eliminate a redundant compare is the decrement in\n-;; constructs like while (n--) and while (--n >= 0).  \n-;;\n-;; We do it with combine patterns instead of NOTICE_UPDATE_CC because\n-;; the decrement needs to be kept at the end of the block during scheduling.\n-;; \n-;; These patterns must have memory alternatives because reload refuses\n-;; to do output reloads for an insn that sets cc0 (since it does not\n-;; want to clobber cc0 with its moves).  Convex moves do not clobber\n-;; cc0, but there is no evident way to get reload to know that.\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"register_operand\" \"+r,*m\"))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"next_insn_tests_no_inequality (insn)\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      output_cmp (operands[0], constm1_rtx, 'W');\n-      return \\\"add.w #-1,%0\\\";\n-    }\n-  else\n-    {\n-      output_cmp (gen_rtx_REG (SImode, 7), constm1_rtx, 'W');\n-      return \\\"psh.w s7\\;ld.w %0,s7\\;add.w #-1,s7\\;st.w s7,%0\\;pop.w s7\\\";\n-    }\n-}\")\n-     \n-(define_insn \"\"\n-  [(set (cc0)\n-\t(plus:SI (match_operand:SI 0 \"register_operand\" \"+r,*m\")\n-\t\t (const_int -1)))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"find_reg_note (next_cc0_user (insn), REG_NONNEG, 0)\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      output_cmp (operands[0], const0_rtx, 'W');\n-      return \\\"add.w #-1,%0\\\";\n-    }\n-  else\n-    {\n-      output_cmp (gen_rtx_REG (SImode, 7), const0_rtx, 'W');\n-      return \\\"psh.w s7\\;ld.w %0,s7\\;add.w #-1,s7\\;st.w s7,%0\\;pop.w s7\\\";\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"register_operand\" \"+r,*m\"))\n-   (set (match_dup 0)\n-\t(plus:HI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"next_insn_tests_no_inequality (insn)\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      output_cmp (operands[0], constm1_rtx, 'H');\n-      return \\\"add.h #-1,%0\\\";\n-    }\n-  else\n-    {\n-      output_cmp (gen_rtx_REG (HImode, 7), constm1_rtx, 'H');\n-      return \\\"psh.w s7\\;ld.h %0,s7\\;add.h #-1,s7\\;st.h s7,%0\\;pop.w s7\\\";\n-    }\n-}\")\n-     \n-(define_insn \"\"\n-  [(set (cc0)\n-\t(plus:HI (match_operand:HI 0 \"register_operand\" \"+r,*m\")\n-\t\t (const_int -1)))\n-   (set (match_dup 0)\n-\t(plus:HI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"find_reg_note (next_cc0_user (insn), REG_NONNEG, 0)\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      output_cmp (operands[0], const0_rtx, 'H');\n-      return \\\"add.h #-1,%0\\\";\n-    }\n-  else\n-    {\n-      output_cmp (gen_rtx_REG (HImode, 7), const0_rtx, 'H');\n-      return \\\"psh.w s7\\;ld.h %0,s7\\;add.h #-1,s7\\;st.h s7,%0\\;pop.w s7\\\";\n-    }\n-}\")\n-\f\n-;;- Jumps\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"jbr %l0\")\n-\n-(define_insn \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"eq\\\", 't'); \")\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"eq\\\", 'f'); \")\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"le\\\", 'f'); \")\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"leu\\\", 'f'); \")\n-\n-(define_insn \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"lt\\\", 't'); \")\n-\n-(define_insn \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"ltu\\\", 't'); \")\n-\n-(define_insn \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"lt\\\", 'f'); \")\n-\n-(define_insn \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"ltu\\\", 'f'); \")\n-\n-(define_insn \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"le\\\", 't'); \")\n-\n-(define_insn \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"leu\\\", 't'); \")\n-\f\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"eq\\\", 'f'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"eq\\\", 't'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"le\\\", 't'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"leu\\\", 't'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"lt\\\", 'f'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"ltu\\\", 'f'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"lt\\\", 't'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"ltu\\\", 't'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"le\\\", 'f'); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_condjump (operands[0], \\\"leu\\\", 'f'); \")\n-\f\n-;;- Calls\n-\n-(define_expand \"call_pop\"\n-  [(parallel [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t    (match_operand:SI 1 \"const_int_operand\" \"i\"))\n-\t      (match_operand:SI 2 \"const_int_operand\" \"i\")\n-\t      (match_operand:SI 3 \"const_int_operand\" \"i\")\n-\t      (reg:SI 8)])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t (match_operand:SI 1 \"const_int_operand\" \"i\"))\n-   (match_operand:SI 2 \"const_int_operand\" \"i\")\n-   (match_operand:SI 3 \"const_int_operand\" \"i\")\n-   (match_operand:SI 4 \"\" \"\")]\n-  \"\"\n-  \"* return output_call (insn, &operands[0]);\")\n-\n-(define_expand \"call_value_pop\"\n-  [(parallel [(set (match_operand 0 \"\" \"=g\")\n-\t\t   (call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")))\n-\t      (match_operand:SI 3 \"const_int_operand\" \"i\")\n-\t      (match_operand:SI 4 \"const_int_operand\" \"i\")\n-\t      (reg:SI 8)])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand 0 \"\" \"=g\")\n-\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:SI 2 \"const_int_operand\" \"i\")))\n-   (match_operand:SI 3 \"const_int_operand\" \"i\")\n-   (match_operand:SI 4 \"const_int_operand\" \"i\")\n-   (match_operand:SI 5 \"\" \"\")]\n-  \"\"\n-  \"* return output_call (insn, &operands[1]); \")\n-\n-;; Call subroutine returning any type.\n-\n-(define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-                  (const_int 0))\n-            (match_operand 1 \"\" \"\")\n-            (match_operand 2 \"\" \"\")])]\n-  \"\"\n-  \"\n-{\n-  int i;\n-\n-  emit_call_insn (gen_call_pop (operands[0], const0_rtx,\n-\t\t\t\tconst0_rtx, const0_rtx));\n-\n-  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n-    {\n-      rtx set = XVECEXP (operands[2], 0, i);\n-      emit_move_insn (SET_DEST (set), SET_SRC (set));\n-    }\n-\n-  /* The optimizer does not know that the call sets the function value\n-     registers we stored in the result block.  We avoid problems by\n-     claiming that all hard registers are used and clobbered at this\n-     point.  */\n-  emit_insn (gen_blockage ());\n-\n-  DONE;\n-}\")\n-\n-;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n-;; all of memory.  This blocks insns from being moved across this point.\n-\n-(define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"return\"\n-  [(return)]\n-  \"\"\n-  \" replace_arg_pushes (); \")\n-\n-(define_insn \"\"\n-  [(return)]\n-  \"\"\n-  \"rtn\")\n-\n-(define_expand \"prologue\"\n-  [(const_int 0)]\n-  \"\"\n-  \"\n-{\n-  emit_ap_optimizations ();\n-  DONE; \n-}\")\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jmp %a0\")\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"jmp %a0\")"}, {"sha": "c14dcd42b03f85025f6a3a878492fa46e61783ed", "filename": "gcc/config/convex/fixinc.convex", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Ffixinc.convex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Ffixinc.convex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Ffixinc.convex?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,416 +0,0 @@\n-\n-# This is a shell archive.  Remove anything before this line,\n-# then unpack it by saving it in a file and typing \"sh file\".\n-#\n-# Wrapped by  on Fri Mar 12 08:41:28 CST 1993\n-# Contents:  include/ include/limits.h include/math.h include/stddef.h\n-#\tinclude/stdlib.h\n- \n-echo mkdir - include\n-mkdir include\n-chmod u=rwx,g=rwx,o=rx include\n- \n-echo x - include/limits.h\n-sed 's/^@//' > \"include/limits.h\" <<'@//E*O*F include/limits.h//'\n-#ifndef _LIMITS_H\n-#define _LIMITS_H\n-\n- #include_next <limits.h>\n-\n-/* Minimum and maximum values a `char' can hold.  */\n-#ifdef __CHAR_UNSIGNED__\n-#undef CHAR_MIN\n-#define CHAR_MIN 0\n-#undef CHAR_MAX\n-#define CHAR_MAX 255\n-#endif\n-\n-#endif /* _LIMITS_H */\n-@//E*O*F include/limits.h//\n-chmod u=rw,g=rw,o=r include/limits.h\n- \n-echo x - include/math.h\n-sed 's/^@//' > \"include/math.h\" <<'@//E*O*F include/math.h//'\n-#ifndef _MATH_H\n-#define _MATH_H\n-\n- #include_next <math.h>\n-\n-#undef HUGE_VAL\n-\n-#if _IEEE_FLOAT_\n-#define HUGE_VAL 1.79769313486231570e+308\n-#else\n-#define HUGE_VAL 8.98846567431157854e+307\n-#endif\n-\n-#if __OPTIMIZE__ && ! __NO_INLINE\n-\n-#define frexp(x,y)\t__inline_frexp ((x), (y))\n-#define ldexp(x,y)\t__inline_ldexp ((x), (y))\n-#define irint(x)\t__inline_irint (x)\n-#define frexpf(x,y)\t__inline_frexpf ((x), (y))\n-#define ldexpf(x,y)\t__inline_ldexpf ((x), (y))\n-#define irintf(x)\t__inline_irintf (x)\n-\n-#if __convex_c2__ || __convex_c32__ || __convex_c34__ || __convex_c38__\n-\n-#define atan(x)\t\t__inline_atan (x)\n-#define ceil(x)\t\t__inline_ceil (x)\n-#define cos(x)\t\t__inline_cos (x)\n-#define exp(x)\t\t__inline_exp (x)\n-#define floor(x)\t__inline_floor (x)\n-#define log(x)\t\t__inline_log (x)\n-#define log10(x)\t__inline_log10 (x)\n-#define modf(x,y)\t__inline_modf ((x), (y))\n-#define rint(x)\t\t__inline_rint (x)\n-#define sin(x)\t\t__inline_sin (x)\n-#define sqrt(x)\t\t__inline_sqrt (x)\n-\n-#define atanf(x)\t__inline_atanf (x)\n-#define ceilf(x)\t__inline_ceilf (x)\n-#define cosf(x)\t\t__inline_cosf (x)\n-#define expf(x)\t\t__inline_expf (x)\n-#define floorf(x)\t__inline_floorf (x)\n-#define logf(x)\t\t__inline_logf (x)\n-#define log10f(x)\t__inline_log10f (x)\n-#define modff(x,y)\t__inline_modff ((x), (y))\n-#define rintf(x)\t__inline_rintf (x)\n-#define sinf(x)\t\t__inline_sinf (x)\n-#define sqrtf(x)\t__inline_sqrtf (x)\n-\n-#endif /* __convex_c[23*]__ */\n-\n-#endif /* __OPTIMIZE__ */\n-\n-static __inline__ __const__ double __inline_atan (double x)\n-{\n-  double z;\n-  __asm__ (\"atan.d %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_atanf (float x)\n-{\n-  float z;\n-  __asm__ (\"atan.s %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_cos (double x)\n-{\n-  double z;\n-  __asm__ (\"cos.d %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_cosf (float x)\n-{\n-  float z;\n-  __asm__ (\"cos.s %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_exp (double x)\n-{\n-  double z;\n-  __asm__ (\"exp.d %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_expf (float x)\n-{\n-  float z;\n-  __asm__ (\"exp.s %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_log (double x)\n-{\n-  double z;\n-  __asm__ (\"ln.d %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_logf (float x)\n-{\n-  float z;\n-  __asm__ (\"ln.s %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_sin (double x)\n-{\n-  double z;\n-  __asm__ (\"sin.d %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_sinf (float x)\n-{\n-  float z;\n-  __asm__ (\"sin.s %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_sqrt (double x)\n-{\n-  double z;\n-  __asm__ (\"sqrt.d %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_sqrtf (float x)\n-{\n-  float z;\n-  __asm__ (\"sqrt.s %0\" : \"=d\" (z) : \"0\" (x));\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_ceil (double x)\n-{\n-  double z;\n-  __asm__ (\"frint.d %1,%0\" : \"=d\" (z) : \"d\" (x));\n-  if (z < x) z += 1.0;\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_ceilf (float x)\n-{\n-  float z;\n-  __asm__ (\"frint.s %1,%0\" : \"=d\" (z) : \"d\" (x));\n-  if (z < x) z += 1.0F;\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_floor (double x)\n-{\n-  double z;\n-  __asm__ (\"frint.d %1,%0\" : \"=d\" (z) : \"d\" (x));\n-  if (z > x) z -= 1.0;\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_floorf (float x)\n-{\n-  float z;\n-  __asm__ (\"frint.s %1,%0\" : \"=d\" (z) : \"d\" (x));\n-  if (z > x) z -= 1.0F;\n-  return z;\n-}\n-\n-static __inline__ __const__ double __inline_log10 (double x)\n-{\n-  return 0.43429448190325182765 * __inline_log (x);\n-}\n-\n-static __inline__ __const__ float __inline_log10f (float x)\n-{\n-  return 0.43429448190325182765F * __inline_logf (x);\n-}\n-\n-static __inline__ double __inline_modf (double x, double *np)\n-{\n-  double intpart;\n-  __asm__ (\"frint.d %1,%0\" : \"=d\" (intpart) : \"d\" (x));\n-  *np = intpart;\n-  return x - intpart;\n-}\n-\n-static __inline__ float __inline_modff (float x, float *np)\n-{\n-  float intpart;\n-  __asm__ (\"frint.s %1,%0\" : \"=d\" (intpart) : \"d\" (x));\n-  *np = intpart;\n-  return x - intpart;\n-}\n-\n-static __inline__ double __inline_frexp (double x, int *np)\n-{\n-  union u { double d; unsigned long long ll; } u;\n-  if ((u.d = x) == 0)\n-    *np = 0;\n-  else\n-    {\n-#if _IEEE_FLOAT_\n-      *np = ((u.ll >> 52) & 03777) - 01776;\n-      u.ll = (u.ll & 0x800fffffffffffffLL) | 0x3fe0000000000000LL;\n-#else\n-      *np = ((u.ll >> 52) & 03777) - 02000;\n-      u.ll = (u.ll & 0x800fffffffffffffLL) | 0x4000000000000000LL;\n-#endif\n-    }\n-  return u.d;\n-}\n-\n-static __inline__ float __inline_frexpf (float x, int *np)\n-{\n-  union u { float f; unsigned int i; } u;\n-  if ((u.f = x) == 0)\n-    *np = 0;\n-  else\n-    {\n-#if _IEEE_FLOAT_\n-      *np = ((u.i >> 23) & 0377) - 0176;\n-      u.i = (u.i & 0x807fffff) | 0x3f000000;\n-#else\n-      *np = ((u.i >> 23) & 0377) - 0200;\n-      u.i = (u.i & 0x807fffff) | 0x40000000;\n-#endif\n-    }\n-  return u.f;\n-}\n-\n-static __inline__ double __inline_ldexp (double x, int n)\n-{\n-  extern int errno;\n-  union { double d; long long ll; unsigned sexp : 12; } u;\n-  if ((u.d = x) != 0)\n-    {\n-      int exp = n + (u.sexp & 03777);\n-      long long nn = (long long) n << 52;\n-#if _IEEE_FLOAT_\n-      if (exp <= 0)\n-\tu.ll &= 0x8000000000000000LL, errno = 34;\n-      else if (exp > 03776)\n-\tu.ll = u.ll & 0x8000000000000000LL | 0x7fefffffffffffffLL, errno = 34;\n-#else\n-      if (exp <= 0)\n-\tu.ll = 0, errno = 34;\n-      else if (exp > 03777)\n-\tu.ll |= 0x7fffffffffffffffLL, errno = 34;\n-#endif\n-      else\n-\tu.ll += nn;\n-    }\n-  return u.d;\n-}\n-\n-static __inline__ float __inline_ldexpf (float x, int n)\n-{\n-  extern int errno;\n-  union { float f; int i; unsigned sexp : 9; } u;\n-  if ((u.f = x) != 0)\n-    {\n-      int exp = n + (u.sexp & 0377);\n-      int nn = n << 23;\n-#if _IEEE_FLOAT_\n-      if (exp <= 0)\n-\tu.i &= 0x80000000, errno = 34;\n-      else if (exp > 0376)\n-\tu.i = u.i & 0x80000000 | 0x7f7fffff, errno = 34;\n-#else\n-      if (exp <= 0)\n-\tu.i = 0, errno = 34;\n-      else if (exp > 0377)\n-\tu.i |= 0x7fffffff, errno = 34;\n-#endif\n-      else\n-\tu.i += nn;\n-    }\n-  return u.f;\n-}\n-\n-static __inline__ __const__ double __inline_rint (double x)\n-{\n-  double z;\n-  union { double d; unsigned long long ll; } u;\n-  u.d = x;\n-#if _IEEE_FLOAT_\n-  u.ll = (u.ll & 0x8000000000000000LL) | 0x3fe0000000000000LL;\n-#else\n-  u.ll = (u.ll & 0x8000000000000000LL) | 0x4000000000000000LL;\n-#endif\n-  __asm__ (\"frint.d %1,%0\" : \"=d\" (z) : \"d\" (x + u.d));\n-  return z;\n-}\n-\n-static __inline__ __const__ float __inline_rintf (float x)\n-{\n-  float z;\n-  union { float f; unsigned int i; } u;\n-  u.f = x;\n-#if _IEEE_FLOAT_\n-  u.i = (u.i & 0x80000000) | 0x3f000000;\n-#else\n-  u.i = (u.i & 0x80000000) | 0x40000000;\n-#endif\n-  __asm__ (\"frint.s %1,%0\" : \"=d\" (z) : \"d\" (x + u.f));\n-  return z;\n-}\n-\n-static __inline__ __const__ int __inline_irint (double x)\n-{\n-  union { double d; unsigned long long ll; } u;\n-  u.d = x;\n-#if _IEEE_FLOAT_\n-  u.ll = (u.ll & 0x8000000000000000LL) | 0x3fe0000000000000LL;\n-#else\n-  u.ll = (u.ll & 0x8000000000000000LL) | 0x4000000000000000LL;\n-#endif\n-  return x + u.d;\n-}\n-\n-static __inline__ __const__ int __inline_irintf (float x)\n-{\n-  union { float f; unsigned int i; } u;\n-  u.f = x;\n-#if _IEEE_FLOAT_\n-  u.i = (u.i & 0x80000000) | 0x3f000000;\n-#else\n-  u.i = (u.i & 0x80000000) | 0x40000000;\n-#endif\n-  return x + u.f;\n-}\n-\n-#endif /* _MATH_H */\n-@//E*O*F include/math.h//\n-chmod u=rw,g=rw,o=r include/math.h\n- \n-echo x - include/stddef.h\n-sed 's/^@//' > \"include/stddef.h\" <<'@//E*O*F include/stddef.h//'\n-#ifndef _STDDEF_H\n-#define _STDDEF_H\n-\n-#ifndef __WCHAR_T\n-#define __WCHAR_T\n-\n-#ifdef __GNUG__\n-/* In C++, wchar_t is a distinct basic type,\n-   and we can expect __wchar_t to be defined by cc1plus.  */\n-typedef __wchar_t wchar_t;\n-#else\n-/* In C, cpp tells us which type to make an alias for.  */\n-typedef __WCHAR_TYPE__ wchar_t;\n-#endif\n-\n-#endif /* __WCHAR_T */\n-\n- #include_next <stddef.h>\n-\n-#endif /* _STDDEF_H */\n-@//E*O*F include/stddef.h//\n-chmod u=rw,g=rw,o=r include/stddef.h\n- \n-echo x - include/stdlib.h\n-sed 's/^@//' > \"include/stdlib.h\" <<'@//E*O*F include/stdlib.h//'\n-#ifndef\t_STDLIB_H\n-#define _STDLIB_H\n-\n-#if _CONVEX_SOURCE\n-\n-#define alloca __non_builtin_alloca\n- #include_next <stdlib.h>\n-#undef alloca\n-\n-#else\n-\n- #include_next <stdlib.h>\n-\n-#endif  /* _CONVEX_SOURCE */\n-\n-#endif\t/* _STDLIB_H */\n-@//E*O*F include/stdlib.h//\n-chmod u=rw,g=rw,o=r include/stdlib.h\n- \n-exit 0"}, {"sha": "cc48915d842179bb33fb643db740bcce283a216a", "filename": "gcc/config/convex/proto.h", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fproto.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fconvex%2Fproto.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fproto.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,4 +0,0 @@\n-/* This header file is to avoid trouble with semi-ANSI header files\n-   on the Convex in system version 8.0.  */\n-\n-#define _PROTO(list) ()"}, {"sha": "f40ce21ea2b2e162bd53e16a94d7dab3bc1f3210", "filename": "gcc/config/elxsi/elxsi-protos.h", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,31 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Elxsi version.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Mike Stump <mrs@cygnus.com> in 1988.  This is the first\n-   64 bit port of GNU CC.\n-   Based upon the VAX port.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Functions used in the md file. */\n-\n-#ifdef RTX_CODE\n-extern const char *cmp_set PARAMS ((const char *, const char *, rtx));\n-extern const char *cmp_jmp PARAMS ((const char *, int, rtx));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-#endif /* RTX_CODE */\n-"}, {"sha": "f27d9286a4268ceedb47dd95db7a429ccf270071", "filename": "gcc/config/elxsi/elxsi.c", "status": "removed", "additions": 0, "deletions": 275, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.c?ref=755ac5d48039681a08775d40dae2be21298dbb99", "patch": "@@ -1,275 +0,0 @@\n-/* Subroutines for insn-output.c for GNU compiler.  Elxsi version.\n-   Copyright (C) 1987, 1992, 1998, 1999, 2000 Free Software Foundation, Inc\n-   Contributrd by Mike Stump <mrs@cygnus.com> in 1988 and is the first\n-   64 bit port of GNU CC.\n-   Based upon the VAX port.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"function.h\"\n-#include \"output.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"regs.h\"\n-#include \"flags.h\"\n-#include \"hard-reg-set.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-extern const char *reg_names[];\n-rtx cmp_op0=0, cmp_op1=0;\n-\n-/* table of relations for compares and branches */\n-static const char *const cmp_tab[] = {\n-    \"gt\", \"gt\", \"eq\", \"eq\", \"ge\", \"ge\", \"lt\", \"lt\", \"ne\", \"ne\",\n-    \"le\", \"le\" };\n-\n-static bool elxsi_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static void elxsi_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void elxsi_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_BYTE_OP\n-#define TARGET_ASM_BYTE_OP NULL\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP NULL\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP NULL\n-#undef TARGET_ASM_INTEGER\n-#define TARGET_ASM_INTEGER elxsi_assemble_integer\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE elxsi_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE elxsi_output_function_epilogue\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Target hook for assembling integer objects.  The ELXSI assembler\n-   syntax uses a suffix to indicate the size of data, so we can't use\n-   the usual string hooks.  */\n-\n-static bool\n-elxsi_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n-{\n-  if (aligned_p)\n-    switch (size)\n-      {\n-      case 1:\n-      case 2:\n-      case 4:\n-\tfputs (\"\\t.data\\t\", asm_out_file);\n-\toutput_addr_const (asm_out_file, x);\n-\tfprintf (asm_out_file, \"{%d}\\n\", size * BITS_PER_UNIT);\n-\treturn true;\n-      }\n-  return default_assemble_integer (x, size, aligned_p);\n-}\n-\f\n-/* Generate the assembly code for function entry.  FILE is a stdio\n-   stream to output the code to.  SIZE is an int: how many units of\n-   temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers to\n-   save; `regs_ever_live[I]' is nonzero if register number I is ever\n-   used in the function.  This function is responsible for knowing\n-   which registers should not be saved even if used.  */\n-\n-static void\n-elxsi_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  register int regno;\n-  register int cnt = 0;\n-\n-  /* the below two lines are a HACK, and should be deleted, but\n-     for now are very much needed (1.35) */\n-  if (frame_pointer_needed)\n-    regs_ever_live[14] = 1, call_used_regs[14] = 0;\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\n-      cnt += 8;\n-\n-  if (size + cnt)\n-    fprintf (file, \"\\tadd.64\\t.sp,=%d\\n\", -size - cnt);\n-\n-  cnt = 0;\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\n-      fprintf (file, \"\\tst.64\\t.r%d,[.sp]%d\\n\", regno, (cnt += 8) - 12);\n-\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\tadd.64\\t.r14,.sp,=%d\\n\", size + cnt);\n-}\n-\n-/* This function generates the assembly code for function exit.\n-   Args are as for output_function_prologue ().\n-\n-   The function epilogue should not depend on the current stack\n-   pointer!  It should use the frame pointer only.  This is mandatory\n-   because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning. */\n-\n-static void\n-elxsi_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  register int regno;\n-  register int cnt = 0;\n-\n-  /* this conditional is ONLY here because there is a BUG;\n-     EXIT_IGNORE_STACK is ignored itself when the first part of\n-     the condition is true! (at least in version 1.35) */\n-  /* the 8*10 is for 64 bits of .r5 - .r14 */\n-  if (current_function_calls_alloca || size >= (256 - 8 * 10))\n-    {\n-      /* use .r4 as a temporary! Ok for now.... */\n-      fprintf (file, \"\\tld.64\\t.r4,.r14\\n\");\n-\n-      for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)\n-\tif (regs_ever_live[regno] && !call_used_regs[regno])\n-\t  cnt += 8;\n-\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n-\tif (regs_ever_live[regno] && !call_used_regs[regno])\n-\t  fprintf (file, \"\\tld.64\\t.r%d,[.r14]%d\\n\", regno,\n-\t\t   -((cnt -= 8) + 8) - 4 - size);\n-\n-      fprintf (file, \"\\tld.64\\t.sp,.r4\\n\\texit\\t0\\n\");\n-    }\n-  else\n-    {\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n-\tif (regs_ever_live[regno] && !call_used_regs[regno])\n-\t  fprintf (file, \"\\tld.64\\t.r%d,[.sp]%d\\n\", regno, (cnt += 8) - 12);\n-\n-      fprintf (file, \"\\texit\\t%d\\n\", size + cnt);\n-    }\n-}\n-\n-/* type is the index into the above table */\n-/* s is \"\" for signed, or \"u\" for unsigned */\n-const char *\n-cmp_jmp (s, type, where)\n-     const char *s;\n-     int type;\n-     rtx where;\n-{\n-    rtx br_ops[3];\n-    char template[50];\n-    const char *f = \"\";\n-    const char *bits = \"64\";\n-    if (GET_MODE (cmp_op0) == SFmode) f = \"f\", bits = \"32\";\n-    if (GET_MODE (cmp_op0) == DFmode) f = \"f\";\n-    br_ops[0] = where;\n-    br_ops[1] = cmp_op0;\n-    br_ops[2] = cmp_op1;\n-    if (cmp_op1)\n-\tsprintf(template, \"%scmp%s.br.%s\\t%%1,%%2:j%s\\t%%l0\",\n-\t\tf, s, bits, cmp_tab[type]);\n-    else if (*f)\n-\tsprintf(template, \"fcmp.br.%s\\t%%1,=0:j%s\\t%%l0\",\n-\t\tbits, cmp_tab[type]);\n-    else if (*s) /* can turn the below in to a jmp ... */\n-\tsprintf(template, \"cmpu.br.64\\t%%1,=0:j%s\\t%%l0\", s);\n-    else\n-\tsprintf(template, \"jmp.%s\\t%%1,%%l0\", cmp_tab[type+1]);\n-    output_asm_insn(template, br_ops);\n-    return \"\";\n-}\n-\n-const char *\n-cmp_set (s, type, reg)\n-     const char *s, *type;\n-     rtx reg;\n-{\n-    rtx br_ops[3];\n-    char template[50];\n-    const char *f = \"\";\n-    const char *bits = \"64\";\n-    if (GET_MODE (cmp_op0) == SFmode) f = \"f\", bits = \"32\";\n-    else if (GET_MODE (cmp_op0) == DFmode) f = \"f\";\n-    else if (GET_MODE (cmp_op0) == SImode) bits = \"32\";\n-    else if (GET_MODE (cmp_op0) == HImode) bits = \"16\";\n-    else if (GET_MODE (cmp_op0) == QImode) bits = \"8\";\n-    br_ops[0] = reg;\n-    br_ops[1] = cmp_op0;\n-    br_ops[2] = cmp_op1;\n-    if (cmp_op1)\n-\tsprintf(template, \"%scmp%s.%s\\t%%0,%%1,%%2:%s\",\n-\t\tf, s, bits, type);\n-    else\n-\tsprintf(template, \"%scmp%s.%s\\t%%0,%%1,=0:%s\",\n-\t\tf, s, bits, type);\n-    output_asm_insn(template, br_ops);\n-    return \"\";\n-}\n-\n-void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     register rtx addr;\n-{\n-  register rtx reg1, reg2, breg, ireg;\n-  rtx offset;\n-\n-  switch (GET_CODE (addr))\n-    {\n-\n-    case MEM:\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-        fprintf (file, \"%s\", reg_names[REGNO (addr)]);\n-      else abort();\n-      break;\n-\n-    case REG:\n-      fprintf (file, \"[%s]\", reg_names[REGNO (addr)]);\n-      break;\n-\n-    case PLUS:\n-      reg1 = 0;\treg2 = 0;\n-      ireg = 0;\tbreg = 0;\n-      offset = 0;\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\t{\n-\t  offset = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\t{\n-\t  offset = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n-      fprintf (file, \"[%s]\", reg_names[REGNO (addr)]);\n-      output_address (offset);\n-      break;\n-\n-    default:\n-      output_addr_const (file, addr);\n-    }\n-}"}, {"sha": "b33afd9542f7bb49aec84d9c44ec217c0f855dfa", "filename": "gcc/config/elxsi/elxsi.h", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "54ef22a0e7b42c48e905a0f423bb80c640c6069c", "filename": "gcc/config/elxsi/elxsi.md", "status": "removed", "additions": 0, "deletions": 1420, "changes": 1420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Felxsi%2Felxsi.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.md?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "9745530abec0725eb05aee4a2e9b28e307956fc7", "filename": "gcc/config/i386/386bsd.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2F386bsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2F386bsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2F386bsd.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "f085c4210fe5c8686e38e325f706514b3ba9a8a2", "filename": "gcc/config/i386/aix386.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Faix386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Faix386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Faix386.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "5905867ac7ae28411d649f1c3963f32198f78eb0", "filename": "gcc/config/i386/aix386ng.h", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Faix386ng.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Faix386ng.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Faix386ng.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "eda80d213ed5a78e5e51ef0c1b978dc6d8871916", "filename": "gcc/config/i386/bsd386.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fbsd386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fbsd386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fbsd386.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "fa6b4a5edfd8d254bd8527459d7c5ebd8a0931c2", "filename": "gcc/config/i386/dgux.h", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fdgux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fdgux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdgux.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "551b666b765c21789d3d36c7cfe63381e2f73feb", "filename": "gcc/config/i386/djgpp-rtems.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fdjgpp-rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fdjgpp-rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdjgpp-rtems.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "171918c60dd1a643dcb42203e608aae904a3e8ca", "filename": "gcc/config/i386/isc.h", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fisc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fisc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fisc.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "09de0fddb86a23c4034d05f5aa328a8eab86b71e", "filename": "gcc/config/i386/iscdbx.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fiscdbx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fiscdbx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fiscdbx.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "476a9ed2ec55e1d6abddcbadeb9fe75ebe60859e", "filename": "gcc/config/i386/linux-oldld.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Flinux-oldld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Flinux-oldld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux-oldld.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "80f9b0ce2173a93d99d9ca7e3d4c8b923a810536", "filename": "gcc/config/i386/next.h", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fnext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fnext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnext.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "a0f077304a826b31f8109b27715f1ca2eb0f62c2", "filename": "gcc/config/i386/osf1-ci.asm", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1-ci.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1-ci.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1-ci.asm?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "a10298fd288f23f48247f6e3dbc9828d09febbcb", "filename": "gcc/config/i386/osf1-cn.asm", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1-cn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1-cn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1-cn.asm?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "a772442c4fc89536e9d94ee697d1554eb05c993e", "filename": "gcc/config/i386/osf1elf.h", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1elf.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "4071c66ce720634997a606ca4d6ceff07e79e1cf", "filename": "gcc/config/i386/osf1elfgdb.h", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1elfgdb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosf1elfgdb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1elfgdb.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "095749079d5bda8550399404f8abe4f600417d71", "filename": "gcc/config/i386/osfelf.h", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosfelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosfelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfelf.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "83cade2eb83b319765cfc794f10fb1874fddc2b5", "filename": "gcc/config/i386/osfrose.h", "status": "removed", "additions": 0, "deletions": 668, "changes": 668, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "16fd6fb9eb1d5dcd8aa87ef687a1d600726cb448", "filename": "gcc/config/i386/rtems.h", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Frtems.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "dde1f058d50e2af89a586e0beb35ceddef6012c2", "filename": "gcc/config/i386/seq-gas.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fseq-gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fseq-gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fseq-gas.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "f30cf77c1974892e0412993d3177b84af43e414d", "filename": "gcc/config/i386/seq-sysv3.h", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fseq-sysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fseq-sysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fseq-sysv3.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "a759e8b318501a005b144e12134fc918dc6c7fc2", "filename": "gcc/config/i386/seq2-sysv3.h", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fseq2-sysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fseq2-sysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fseq2-sysv3.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "bc16b19102cc4f8f3f8517189f96f2016a03c624", "filename": "gcc/config/i386/sequent.h", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fsequent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fsequent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsequent.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c4390e270232b11ff2e8cfe528798b097331aa72", "filename": "gcc/config/i386/sun.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fsun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fsun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsun.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "0c107c70a632ff10e3f13150bad3977357508069", "filename": "gcc/config/i386/sun386.h", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fsun386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Fsun386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsun386.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e1bccee610fb4941cc63e9593ff966e60c528358", "filename": "gcc/config/i386/t-dgux", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-dgux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-dgux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-dgux?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "4b70ba78ae0fc57ae11ba4a1888cebc777aa6784", "filename": "gcc/config/i386/t-next", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-next", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-next", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-next?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c996e0c9e77b76a840b7f854131857efc0c71764", "filename": "gcc/config/i386/t-osf", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-osf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-osf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-osf?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "77c7df1a6dfd197007082166ecdbdffa3371c206", "filename": "gcc/config/i386/t-osf1elf", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-osf1elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi386%2Ft-osf1elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-osf1elf?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "9965b83cd26dcc9dfedf4fd91736c37342ab7b8e", "filename": "gcc/config/i860/bsd-gas.h", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fbsd-gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fbsd-gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fbsd-gas.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "f0845ea7940c25a3d9005b0e6028907a4f2fe2d8", "filename": "gcc/config/i860/bsd.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fbsd.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "04a62a5a0db7c4eda4fc6a27a9de8fa94629bcbb", "filename": "gcc/config/i860/fx2800.h", "status": "removed", "additions": 0, "deletions": 345, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Ffx2800.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Ffx2800.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Ffx2800.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "42cbe184fae31d48cb00f2d36f78f1ecb1ea40e2", "filename": "gcc/config/i860/i860-protos.h", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "18493976615d5b935907510fd88ccd1e758a9b2f", "filename": "gcc/config/i860/i860.c", "status": "removed", "additions": 0, "deletions": 2361, "changes": 2361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "f9fd62c88d6a2205197b8b0c21221e6f4f04a762", "filename": "gcc/config/i860/i860.h", "status": "removed", "additions": 0, "deletions": 1319, "changes": 1319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b866c91386a20a32c5f5eb7cc02792c9baf4e50c", "filename": "gcc/config/i860/i860.md", "status": "removed", "additions": 0, "deletions": 2327, "changes": 2327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e1f0e896e671bcf144e87a66ce74c7a1166522ba", "filename": "gcc/config/i860/mach.h", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fmach.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fmach.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fmach.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e69574dde5d6f9fd71a0e3484e856a39270944c7", "filename": "gcc/config/i860/paragon.h", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fparagon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fparagon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fparagon.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "f361a0108b55e94c405f6a840a50267a55daaa2f", "filename": "gcc/config/i860/sysv3.h", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fsysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fsysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv3.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "753807fe123ca3f200a931206530e68eae3528c6", "filename": "gcc/config/i860/sysv4.h", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv4.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "5f081735714a21b0958ed329005987245235fbd2", "filename": "gcc/config/i860/t-fx2800", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Ft-fx2800", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Ft-fx2800", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Ft-fx2800?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "8f870063c4164574ef2981c51c16412330b391e4", "filename": "gcc/config/i860/varargs.asm", "status": "removed", "additions": 0, "deletions": 201, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fvarargs.asm?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c4c6c448b5280e314ba9b105d3a934035dae7c44", "filename": "gcc/config/m68k/a-ux.h", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fa-ux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fa-ux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fa-ux.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "63a129ca506fd5e8ca2bd5d3e8f659e42fadf550", "filename": "gcc/config/m68k/altos3068.h", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faltos3068.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faltos3068.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faltos3068.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "38fd5dd5eff3bb18ecb6e4b1be07810bad57aded", "filename": "gcc/config/m68k/apollo68.h", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fapollo68.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fapollo68.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fapollo68.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "effa16aa396c7bcb906151779ebe027a89bb999a", "filename": "gcc/config/m68k/aux-crt1.c", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-crt1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-crt1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faux-crt1.c?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c5a0b1c4d0c7305b57cecce950f5afd0f105618c", "filename": "gcc/config/m68k/aux-crt2.asm", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-crt2.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-crt2.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faux-crt2.asm?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b7948101ef9b95a1921d2cf753d7991f868df43d", "filename": "gcc/config/m68k/aux-crtn.asm", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-crtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-crtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faux-crtn.asm?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b6619d9ece56e03deaa060db1971338d6a8c99a1", "filename": "gcc/config/m68k/aux-exit.c", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faux-exit.c?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "d1bb2a990807e6a62170f54e3903138209ccea60", "filename": "gcc/config/m68k/aux-low.gld", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-low.gld", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-low.gld", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faux-low.gld?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c0b0e4a8c9b07c407f3c9feb58522a3b1c5c0e5d", "filename": "gcc/config/m68k/aux-mcount.c", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-mcount.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Faux-mcount.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faux-mcount.c?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "86d9853c3f00041a0141282970b949d1760c2405", "filename": "gcc/config/m68k/auxas.h", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fauxas.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b828848ece9ca2489f379c9cc82d77ba5b09cb18", "filename": "gcc/config/m68k/auxgas.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fauxgas.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "12c97afaead1f5e2f647e52e57c9ecc5dfb71a2c", "filename": "gcc/config/m68k/auxgld.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxgld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxgld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fauxgld.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "932dd6ab9530e2a3f726f91d1221d7ee96e22d0a", "filename": "gcc/config/m68k/auxld.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fauxld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fauxld.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "2309bae427d22d578d70e530c141c7898c1b41f8", "filename": "gcc/config/m68k/ctix.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fctix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fctix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fctix.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "0686b736065998ca297e422bbf1c7b12641e8742", "filename": "gcc/config/m68k/dpx2.h", "status": "removed", "additions": 0, "deletions": 492, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "2c8acd808e3d6439209d17e65864e23dea297cf9", "filename": "gcc/config/m68k/dpx2.ifile", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2.ifile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2.ifile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.ifile?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "88a180e91cfa6e1afdd1459ae731ab6e319beb00", "filename": "gcc/config/m68k/dpx2cdbx.h", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2cdbx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2cdbx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2cdbx.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "8fa6b42ac333d73547bddee33c8e82bbbc68033a", "filename": "gcc/config/m68k/dpx2g.h", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fdpx2g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2g.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "fbded9e8bdb1047e26f3d0aee3375ae191a19ec2", "filename": "gcc/config/m68k/isi-nfp.h", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fisi-nfp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fisi-nfp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fisi-nfp.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e7faced8da6fd0e9faffe96498a40d01d8ee1a7f", "filename": "gcc/config/m68k/isi.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fisi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fisi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fisi.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "d6e3fbad9c841bf7adc20b969496c720571165f3", "filename": "gcc/config/m68k/lynx-ng.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Flynx-ng.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Flynx-ng.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flynx-ng.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "38e83b97497674ce07ac0084fed111ab1ea1514a", "filename": "gcc/config/m68k/lynx.h", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Flynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Flynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flynx.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "5d7ba28f67f6ecc4a376699c7bbb5089babf4325", "filename": "gcc/config/m68k/math-3300.h", "status": "removed", "additions": 0, "deletions": 461, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fmath-3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fmath-3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmath-3300.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "7b48a10e1433f78e282a7a76c6d58eb05529e7fc", "filename": "gcc/config/m68k/news.h", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnews.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnews.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnews.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b4a3f4100d1c2879f59177cda499deec0d3a6b05", "filename": "gcc/config/m68k/news3.h", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnews3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnews3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnews3.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "7c2d2b0595fd689d7c14edd20562a68913489a7f", "filename": "gcc/config/m68k/news3gas.h", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnews3gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnews3gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnews3gas.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "56db6dedd9d4d786299e2b93ba8100c6a6bdb0f7", "filename": "gcc/config/m68k/newsgas.h", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnewsgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnewsgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnewsgas.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "3ccffc8ee0cef8345eb1b557bd1fab585075650a", "filename": "gcc/config/m68k/next.h", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnext.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b4d8aee8eeb3fa3e9f2cb8c09ec4a929e8030150", "filename": "gcc/config/m68k/next21.h", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnext21.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fnext21.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnext21.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "7a6f55b62a97a033b2b8c62843ddd4ab161a3a1a", "filename": "gcc/config/m68k/rtems.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Frtems.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "1d441e7077cec75cd30f570b86499673deafa8cd", "filename": "gcc/config/m68k/t-aux", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Ft-aux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Ft-aux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-aux?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "2e30d9105e458d56784a708f12631875f4a6ca60", "filename": "gcc/config/m68k/t-lynx", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Ft-lynx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Ft-lynx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-lynx?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b7d464c6f83de91d97a5cdc350efb07b8af53dc1", "filename": "gcc/config/m68k/t-next", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Ft-next", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Ft-next", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-next?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "729069df1efcd0f016cf7cab0c4d02bf1d9906e7", "filename": "gcc/config/m68k/x-next", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fx-next", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm68k%2Fx-next", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fx-next?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "b8be2a17c3895c19b42a5b681cf9906dc49f7cc3", "filename": "gcc/config/m88k/dgux.h", "status": "removed", "additions": 0, "deletions": 292, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdgux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdgux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fdgux.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "cc5dc0fec2a0fc8ba73f3abd98af0b956f9501a9", "filename": "gcc/config/m88k/dgux.ld", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdgux.ld", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdgux.ld", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fdgux.ld?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "92109c0f8ae784b0a51cc0ce4c0fe1ccb2c65a4d", "filename": "gcc/config/m88k/dguxbcs.h", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdguxbcs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdguxbcs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fdguxbcs.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "bb96b31b3b68705955a6ade343a8fd8542eab484", "filename": "gcc/config/m88k/dolph.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdolph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdolph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fdolph.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "ce5c8f0aa7b56738c8f78c291663678132cac65b", "filename": "gcc/config/m88k/dolphin.ld", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdolphin.ld", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fdolphin.ld", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fdolphin.ld?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "ca2e683ee224d4ee51689c7cbfff762e8b7a44f0", "filename": "gcc/config/m88k/luna.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fluna.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fluna.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fluna.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "3acc6a62c97783c996d422366ee58f7b2d8187b5", "filename": "gcc/config/m88k/m88k-coff.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fm88k-coff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fm88k-coff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-coff.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "bd9f4a1823d65c6b0cf11df70cb4c3318f230bd3", "filename": "gcc/config/m88k/sysv3.h", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fsysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Fsysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fsysv3.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c4406233d97d7c20a8242dc5cd36fc5f38f331cd", "filename": "gcc/config/m88k/t-bug", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-bug", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-bug", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-bug?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "afce596ceb00f1b91a77b623c0d6b7e8233ac33b", "filename": "gcc/config/m88k/t-dgux", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dgux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dgux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-dgux?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "1627b277c81139c5ab5962115f5e97b79bb778f4", "filename": "gcc/config/m88k/t-dgux-gas", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dgux-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dgux-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-dgux-gas?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "cdebc7890c7adad6cd46ab3ff2025562d4d22b3e", "filename": "gcc/config/m88k/t-dguxbcs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dguxbcs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dguxbcs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-dguxbcs?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "9788d971a4680ed2da10058dc1d5efec707f435b", "filename": "gcc/config/m88k/t-dolph", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dolph", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-dolph", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-dolph?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c5096ea53b9ac42607668af94aa0f024c2c8d430", "filename": "gcc/config/m88k/t-m88k-gas", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-m88k-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-m88k-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-m88k-gas?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "8e262eafe1cde1f61af83a3fee5227cae779ae7e", "filename": "gcc/config/m88k/t-tekXD88", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-tekXD88", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2Ft-tekXD88", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-tekXD88?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "8a52f14a0fb36eea69b91244578986fdc006ab52", "filename": "gcc/config/m88k/tekXD88.h", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2FtekXD88.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2FtekXD88.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2FtekXD88.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "86c652249ad05e7fd92974a1e71c423ab7c22746", "filename": "gcc/config/m88k/tekXD88.ld", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2FtekXD88.ld", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fm88k%2FtekXD88.ld", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2FtekXD88.ld?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "a25507f890e31f58b856832c40aa291ea22ca0d5", "filename": "gcc/config/mips/bsd-4.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fbsd-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fbsd-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fbsd-4.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "c7f9127c0df3a6784f0f72b223b405c0bdc121bb", "filename": "gcc/config/mips/bsd-5.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fbsd-5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fbsd-5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fbsd-5.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "705a97fcdb17242661c14b55d35f429c4c068bcc", "filename": "gcc/config/mips/dec-bsd.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fdec-bsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fdec-bsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fdec-bsd.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "3f54d14c3b4a45d03db1c52cc1cbca7f48e43386", "filename": "gcc/config/mips/dec-osf1.h", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fdec-osf1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fdec-osf1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fdec-osf1.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "4b7f111873ff47bdb871b48d951a93cd101fc8a5", "filename": "gcc/config/mips/elflorion.h", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Felflorion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Felflorion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Felflorion.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "426c822b68a59b935ffa7dfae1fa3d3e74cbe841", "filename": "gcc/config/mips/iris4loser.h", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Firis4loser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Firis4loser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis4loser.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "4f00565854625f9dcf6c5122621c62df530affaa", "filename": "gcc/config/mips/mips-5.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fmips-5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fmips-5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-5.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e2caa5141f059cc4f0c90e70b6751ca6fdaf7ca9", "filename": "gcc/config/mips/news4.h", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fnews4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fnews4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fnews4.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e959bcdb830de65e67139d412dd4b33826502b25", "filename": "gcc/config/mips/news5.h", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fnews5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fnews5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fnews5.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "31f619a6520f91f23983237032b7f9481cb8e50e", "filename": "gcc/config/mips/nws3250v4.h", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fnws3250v4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fnws3250v4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fnws3250v4.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "62d61e6dffdbfac5fd049f1fcbd8a72de3032896", "filename": "gcc/config/mips/osfrose.h", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fosfrose.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "a124d6c6aa84772258d40619595c92ffcff53b02", "filename": "gcc/config/mips/svr3-4.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr3-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr3-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsvr3-4.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "657841be392382715cc955d387599107b4b32ea4", "filename": "gcc/config/mips/svr3-5.h", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr3-5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr3-5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsvr3-5.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "fd751bc700f3c509faae7bca17e811dbac7dad1a", "filename": "gcc/config/mips/svr4-4.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr4-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr4-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsvr4-4.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "d432b42e17af390f757d30c2b4b9660eb02e6966", "filename": "gcc/config/mips/svr4-5.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr4-5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr4-5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsvr4-5.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "62bf664feb9dc730d64eb53ee89923610d71fc12", "filename": "gcc/config/mips/svr4-t.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr4-t.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fsvr4-t.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsvr4-t.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "3dc437caa816200a1ddcef4d0831c9f4a55a0f39", "filename": "gcc/config/mips/t-bsd", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-bsd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-bsd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-bsd?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "2cdad601a9b65a4001f80c25ef370652a9784f4f", "filename": "gcc/config/mips/t-bsd-gas", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-bsd-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-bsd-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-bsd-gas?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e27c02b19ffa76836938137f0eb62929e602e618", "filename": "gcc/config/mips/t-svr3", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-svr3?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e9f3f9e6da9ebbff58065917d10d459bbdf66408", "filename": "gcc/config/mips/t-svr3-gas", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr3-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr3-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-svr3-gas?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "2b1a24e804f2b17c8a785423845ddd78c066fd1f", "filename": "gcc/config/mips/t-svr4", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-svr4?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "8c4bff8bc417ddd92e903c8a455d90cde6c9f153", "filename": "gcc/config/mips/t-svr4-gas", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr4-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-svr4-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-svr4-gas?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "ab40040911194b51c5cc62e82b38d94f11f5a3b6", "filename": "gcc/config/mips/t-ultrix", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-ultrix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Ft-ultrix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-ultrix?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "7b55987613af7b74e6c8d46cc5046cbc40f13f5e", "filename": "gcc/config/mips/ultrix.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fultrix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fmips%2Fultrix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fultrix.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "66b8f7c7d53676b1ae5daa5a9b21c8e46e9dc1c0", "filename": "gcc/config/nextstep-protos.h", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e7ae8f67674f95f17b9f516efbf82915731c1042", "filename": "gcc/config/nextstep.c", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.c?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "4f2eb3fd4ee34363c54a651e3f563d0ee5601fde", "filename": "gcc/config/nextstep.h", "status": "removed", "additions": 0, "deletions": 453, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "7827054d8975fa3cf2ac71a34326fe1a8bff3c44", "filename": "gcc/config/nextstep21.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep21.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fnextstep21.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep21.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "452b893ec2d93bb5fefe63e13f637c597aa6f81c", "filename": "gcc/config/ns32k/encore.h", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fencore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fencore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fencore.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "f38870dd3fc6808eba19f2531faea3d582711cef", "filename": "gcc/config/ns32k/merlin.h", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fmerlin.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "51b3165a392dbfa84ce1b72df737842b12ce2632", "filename": "gcc/config/ns32k/pc532-mach.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fpc532-mach.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fpc532-mach.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fpc532-mach.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "d5f4ad1db06f1df7dbaf0035958f2586d849ebbc", "filename": "gcc/config/ns32k/pc532-min.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fpc532-min.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fpc532-min.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fpc532-min.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "f589d13e581fec30dd170b2962860bdce1b11f21", "filename": "gcc/config/ns32k/pc532.h", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fpc532.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fpc532.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fpc532.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "ab1669185316dae22f32b931d468be60f379ba25", "filename": "gcc/config/ns32k/sequent.h", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fsequent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Fsequent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fsequent.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "219d9198903861aa79f98d30c140873dd2c21173", "filename": "gcc/config/ns32k/tek6000.h", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Ftek6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Ftek6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Ftek6000.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "846f401db885e7bd384fa0e4043598ec021d05e7", "filename": "gcc/config/ns32k/tek6100.h", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Ftek6100.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Ftek6100.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Ftek6100.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "04e37c1939a70f584deb8ed14f6fb59c8b43a6f2", "filename": "gcc/config/ns32k/tek6200.h", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Ftek6200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fns32k%2Ftek6200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Ftek6200.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "02390bc5740a2cb20d0a7684130743bb493f5369", "filename": "gcc/config/pj/lib1funcs.S", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Flib1funcs.S?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "a073c7a97ce4e6572e2150d317c4447ffe5b99ee", "filename": "gcc/config/pj/linux.h", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Flinux.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "9bec3332e428577c3f447a84c60ede2914f091aa", "filename": "gcc/config/pj/pj-protos.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "736a30a09669f45d4b3d9f34be274e631d25f5c0", "filename": "gcc/config/pj/pj.c", "status": "removed", "additions": 0, "deletions": 1286, "changes": 1286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.c?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "4167973c2c8e0da33044b97cc6614d0dc97f4636", "filename": "gcc/config/pj/pj.h", "status": "removed", "additions": 0, "deletions": 1281, "changes": 1281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "6ce6b351642a755c8cf8146832f016a2cc4c1680", "filename": "gcc/config/pj/pj.md", "status": "removed", "additions": 0, "deletions": 980, "changes": 980, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpj.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.md?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "dcfe8612e280963ece40ccc568793c1a00b196c5", "filename": "gcc/config/pj/pjl.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpjl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Fpjl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpjl.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "af390cf9c250aee6326b8eb3be94760a3c2232e3", "filename": "gcc/config/pj/t-pj", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Ft-pj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fpj%2Ft-pj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Ft-pj?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e537f1ca988f00fd718826b9d48c8b3f58021c1c", "filename": "gcc/config/sparc/rtems.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fsparc%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fsparc%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Frtems.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "d3d98ea6135788ae845bb852f69cb466c5d22f28", "filename": "gcc/config/we32k/we32k-protos.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k-protos.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "2403041ac69bd1f92d6f6d2e27f75fcf25af3057", "filename": "gcc/config/we32k/we32k.c", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.c?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "982bdc07e83522db91e782c3a6806614ae7d1f33", "filename": "gcc/config/we32k/we32k.h", "status": "removed", "additions": 0, "deletions": 893, "changes": 893, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.h?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "e9a789a0b364f22a8893adb52ce4a9186df8eac1", "filename": "gcc/config/we32k/we32k.md", "status": "removed", "additions": 0, "deletions": 1186, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755ac5d48039681a08775d40dae2be21298dbb99/gcc%2Fconfig%2Fwe32k%2Fwe32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.md?ref=755ac5d48039681a08775d40dae2be21298dbb99"}, {"sha": "8b927f09c3c62b4bed2a30326f0ef5117b62aa17", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 25, "deletions": 691, "changes": 716, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=c7bdf0a6af41a480ecb6a103636ef9069721c0bd"}, {"sha": "8c69385fad0c2fba374e6e1f58be671af8ecd497", "filename": "gcc/fixinc/mkfixinc.sh", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Ffixinc%2Fmkfixinc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bdf0a6af41a480ecb6a103636ef9069721c0bd/gcc%2Ffixinc%2Fmkfixinc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fmkfixinc.sh?ref=c7bdf0a6af41a480ecb6a103636ef9069721c0bd"}]}