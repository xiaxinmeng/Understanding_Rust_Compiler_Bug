{"sha": "70f910247bd52a16c6195b0508d4ae4c4dce91d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBmOTEwMjQ3YmQ1MmExNmM2MTk1YjA1MDhkNGFlNGM0ZGNlOTFkOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-06-11T05:16:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-06-11T05:16:20Z"}, "message": "Use backend interface for type descriptors.\n\n\t* go-gcc.cc: Include \"toplev.h\".\n\t(Gcc_backend::immutable_struct): New function.\n\t(Gcc_backend::immutable_struct_set_init): New function.\n\t(Gcc_backend::immutable_struct_reference): New function.\n\t* Make-lang.in (go/go-gcc.o): Depend on toplev.h.\n\nFrom-SVN: r174941", "tree": {"sha": "e38b79e1691f08d71d1b559926d7877b343c1d4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e38b79e1691f08d71d1b559926d7877b343c1d4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70f910247bd52a16c6195b0508d4ae4c4dce91d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f910247bd52a16c6195b0508d4ae4c4dce91d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f910247bd52a16c6195b0508d4ae4c4dce91d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f910247bd52a16c6195b0508d4ae4c4dce91d8/comments", "author": null, "committer": null, "parents": [{"sha": "ba68a139acb11620867d3202fd708d655082ef86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba68a139acb11620867d3202fd708d655082ef86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba68a139acb11620867d3202fd708d655082ef86"}], "stats": {"total": 612, "additions": 359, "deletions": 253}, "files": [{"sha": "11abbbcd42130b1997f8ec735d7a491410ddaa5a", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -1,3 +1,11 @@\n+2011-06-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc: Include \"toplev.h\".\n+\t(Gcc_backend::immutable_struct): New function.\n+\t(Gcc_backend::immutable_struct_set_init): New function.\n+\t(Gcc_backend::immutable_struct_reference): New function.\n+\t* Make-lang.in (go/go-gcc.o): Depend on toplev.h.\n+\n 2011-06-09  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::zero_expression): New function."}, {"sha": "61a0f3c875a2954eff8ec8e8593609860c47e5ec", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -239,7 +239,8 @@ go/go-lang.o: go/go-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n GOINCLUDES = -I $(srcdir)/go -I $(srcdir)/go/gofrontend\n \n go/go-gcc.o: go/go-gcc.cc $(GO_SYSTEM_H) $(TREE_H) tree-iterator.h \\\n-\t\t$(GIMPLE_H) $(GO_C_H) $(GO_GOGO_H) go/gofrontend/backend.h\n+\t\t$(GIMPLE_H) toplev.h $(GO_C_H) $(GO_GOGO_H) \\\n+\t\tgo/gofrontend/backend.h\n \t$(CXX) -c $(GOINCLUDES) $(ALL_CPPFLAGS) $(ALL_CXXFLAGS) $< $(OUTPUT_OPTION)\n \n go/%.o: go/gofrontend/%.cc"}, {"sha": "dbdf95f2e7bdabdfb4a9324c4ded2aaf772e9efc", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -32,6 +32,7 @@ extern \"C\"\n #include \"tree.h\"\n #include \"tree-iterator.h\"\n #include \"gimple.h\"\n+#include \"toplev.h\"\n \n #ifndef ENABLE_BUILD_WITH_CXX\n }\n@@ -276,6 +277,16 @@ class Gcc_backend : public Backend\n   temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression*, bool,\n \t\t     source_location, Bstatement**);\n \n+  Bvariable*\n+  immutable_struct(const std::string&, bool, Btype*, source_location);\n+\n+  void\n+  immutable_struct_set_init(Bvariable*, const std::string&, bool, Btype*,\n+\t\t\t    source_location, Bexpression*);\n+\n+  Bvariable*\n+  immutable_struct_reference(const std::string&, Btype*, source_location);\n+\n   // Labels.\n \n   Blabel*\n@@ -1198,6 +1209,83 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n   return new Bvariable(var);\n }\n \n+// Create a named immutable initialized data structure.\n+\n+Bvariable*\n+Gcc_backend::immutable_struct(const std::string& name, bool, Btype* btype,\n+\t\t\t      source_location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_variable();\n+  gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n+  tree decl = build_decl(location, VAR_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t build_qualified_type(type_tree, TYPE_QUAL_CONST));\n+  TREE_STATIC(decl) = 1;\n+  TREE_READONLY(decl) = 1;\n+  TREE_CONSTANT(decl) = 1;\n+  TREE_USED(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+\n+  // We don't call rest_of_decl_compilation until we have the\n+  // initializer.\n+\n+  go_preserve_from_gc(decl);\n+  return new Bvariable(decl);\n+}\n+\n+// Set the initializer for a variable created by immutable_struct.\n+// This is where we finish compiling the variable.\n+\n+void\n+Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n+\t\t\t\t       bool is_common, Btype*,\n+\t\t\t\t       source_location,\n+\t\t\t\t       Bexpression* initializer)\n+{\n+  tree decl = var->get_tree();\n+  tree init_tree = initializer->get_tree();\n+  if (decl == error_mark_node || init_tree == error_mark_node)\n+    return;\n+\n+  DECL_INITIAL(decl) = init_tree;\n+\n+  // We can't call make_decl_one_only until we set DECL_INITIAL.\n+  if (!is_common)\n+    TREE_PUBLIC(decl) = 1;\n+  else\n+    {\n+      make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n+      resolve_unique_section(decl, 1, 0);\n+    }\n+\n+  rest_of_decl_compilation(decl, 1, 0);\n+}\n+\n+// Return a reference to an immutable initialized data structure\n+// defined in another package.\n+\n+Bvariable*\n+Gcc_backend::immutable_struct_reference(const std::string& name, Btype* btype,\n+\t\t\t\t\tsource_location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_variable();\n+  gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n+  tree decl = build_decl(location, VAR_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t build_qualified_type(type_tree, TYPE_QUAL_CONST));\n+  TREE_READONLY(decl) = 1;\n+  TREE_CONSTANT(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+  TREE_PUBLIC(decl) = 1;\n+  DECL_EXTERNAL(decl) = 1;\n+  go_preserve_from_gc(decl);\n+  return new Bvariable(decl);\n+}\n+\n // Make a label.\n \n Blabel*"}, {"sha": "b18c18c763facacbb730697237274f4408bf1af3", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -361,6 +361,52 @@ class Backend\n \t\t     bool address_is_taken, source_location location,\n \t\t     Bstatement** pstatement) = 0;\n \n+  // Create a named immutable initialized data structure.  This is\n+  // used for type descriptors and map descriptors.  This returns a\n+  // Bvariable because it corresponds to an initialized const global\n+  // variable in C.\n+  //\n+  // NAME is the name to use for the initialized global variable which\n+  // this call will create.\n+  //\n+  // IS_COMMON is true if NAME may be defined by several packages, and\n+  // the linker should merge all such definitions.  If IS_COMMON is\n+  // false, NAME should be defined in only one file.  In general\n+  // IS_COMMON will be true for the type descriptor of an unnamed type\n+  // or a builtin type.\n+  //\n+  // TYPE will be a struct type; the type of the returned expression\n+  // must be a pointer to this struct type.\n+  // \n+  // We must create the named structure before we know its\n+  // initializer, because the initializer refer to its own address.\n+  // After calling this the frontend will call\n+  // set_immutable_struct_initializer.\n+  virtual Bvariable*\n+  immutable_struct(const std::string& name, bool is_common, Btype* type,\n+\t\t   source_location) = 0;\n+\n+  // Set the initial value of a variable created by immutable_struct.\n+  // The NAME, IS_COMMON, TYPE, and location parameters are the same\n+  // ones passed to immutable_struct.  INITIALIZER will be a composite\n+  // literal of type TYPE.  It will not contain any function calls or\n+  // anything else which can not be put into a read-only data section.\n+  // It may contain the address of variables created by\n+  // immutable_struct.\n+  virtual void\n+  immutable_struct_set_init(Bvariable*, const std::string& name,\n+\t\t\t    bool is_common, Btype* type, source_location,\n+\t\t\t    Bexpression* initializer) = 0;\n+\n+  // Create a reference to a named immutable initialized data\n+  // structure defined in some other package.  This will be a\n+  // structure created by a call to immutable_struct_expression with\n+  // the same NAME and TYPE and with IS_COMMON passed as false.  This\n+  // corresponds to an extern const global variable in C.\n+  virtual Bvariable*\n+  immutable_struct_reference(const std::string& name, Btype* type,\n+\t\t\t     source_location) = 0;\n+\n   // Labels.\n   \n   // Create a new label.  NAME will be empty if this is a label"}, {"sha": "00af29620685bead9d769b687325a4c3109f3985", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -335,7 +335,7 @@ Expression::convert_type_to_interface(Translate_context* context,\n   // Otherwise it is the interface method table for RHS_TYPE.\n   tree first_field_value;\n   if (lhs_is_empty)\n-    first_field_value = rhs_type->type_descriptor_pointer(gogo);\n+    first_field_value = rhs_type->type_descriptor_pointer(gogo, location);\n   else\n     {\n       // Build the interface method table for this interface and this\n@@ -492,7 +492,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n   if (for_type_guard)\n     {\n       // A type assertion fails when converting a nil interface.\n-      tree lhs_type_descriptor = lhs_type->type_descriptor_pointer(gogo);\n+      tree lhs_type_descriptor = lhs_type->type_descriptor_pointer(gogo,\n+\t\t\t\t\t\t\t\t   location);\n       static tree assert_interface_decl;\n       tree call = Gogo::call_builtin(&assert_interface_decl,\n \t\t\t\t     location,\n@@ -524,7 +525,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n       // type assertion converting nil will always succeed.\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\")\n \t\t == 0);\n-      tree lhs_type_descriptor = lhs_type->type_descriptor_pointer(gogo);\n+      tree lhs_type_descriptor = lhs_type->type_descriptor_pointer(gogo,\n+\t\t\t\t\t\t\t\t   location);\n       static tree convert_interface_decl;\n       tree call = Gogo::call_builtin(&convert_interface_decl,\n \t\t\t\t     location,\n@@ -578,7 +580,7 @@ Expression::convert_interface_to_type(Translate_context* context,\n   // will panic with an appropriate runtime type error if the type is\n   // not valid.\n \n-  tree lhs_type_descriptor = lhs_type->type_descriptor_pointer(gogo);\n+  tree lhs_type_descriptor = lhs_type->type_descriptor_pointer(gogo, location);\n \n   if (!DECL_P(rhs_tree))\n     rhs_tree = save_expr(rhs_tree);\n@@ -587,7 +589,8 @@ Expression::convert_interface_to_type(Translate_context* context,\n     Expression::get_interface_type_descriptor(context, rhs_type, rhs_tree,\n \t\t\t\t\t      location);\n \n-  tree rhs_inter_descriptor = rhs_type->type_descriptor_pointer(gogo);\n+  tree rhs_inter_descriptor = rhs_type->type_descriptor_pointer(gogo,\n+\t\t\t\t\t\t\t\tlocation);\n \n   static tree check_interface_type_decl;\n   tree call = Gogo::call_builtin(&check_interface_type_decl,\n@@ -6400,7 +6403,8 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t}\n       arg = fold_convert_loc(location, ptr_type_node, arg);\n \n-      tree descriptor = right_type->type_descriptor_pointer(context->gogo());\n+      tree descriptor = right_type->type_descriptor_pointer(context->gogo(),\n+\t\t\t\t\t\t\t    location);\n \n       if (left_type->interface_type()->is_empty())\n \t{\n@@ -12588,7 +12592,10 @@ class Type_descriptor_expression : public Expression\n \n   tree\n   do_get_tree(Translate_context* context)\n-  { return this->type_->type_descriptor_pointer(context->gogo()); }\n+  {\n+    return this->type_->type_descriptor_pointer(context->gogo(),\n+\t\t\t\t\t\tthis->location());\n+  }\n \n  private:\n   // The type for which this is the descriptor."}, {"sha": "0c5cb671c05c28735e570a3b8520535b707be390", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 5, "deletions": 189, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -959,9 +959,9 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t    // descriptor, even though we don't do anything with it.\n \t    if (this->package_ == NULL)\n \t      {\n-\t\tnamed_type->type_descriptor_pointer(gogo);\n+\t\tnamed_type->type_descriptor_pointer(gogo, BUILTINS_LOCATION);\n \t\tType* pn = Type::make_pointer_type(named_type);\n-\t\tpn->type_descriptor_pointer(gogo);\n+\t\tpn->type_descriptor_pointer(gogo, BUILTINS_LOCATION);\n \t      }\n \t  }\n       }\n@@ -2053,7 +2053,7 @@ Gogo::map_descriptor(Map_type* maptype)\n \n   constructor_elt* elt = VEC_quick_push(constructor_elt, descriptor, NULL);\n   elt->index = map_descriptor_field;\n-  elt->value = maptype->type_descriptor_pointer(this);\n+  elt->value = maptype->type_descriptor_pointer(this, BUILTINS_LOCATION);\n \n   elt = VEC_quick_push(constructor_elt, descriptor, NULL);\n   elt->index = entry_size_field;\n@@ -2109,190 +2109,6 @@ Gogo::map_descriptor_type()\n \t\t\t      sizetype);\n }\n \n-// Return the name to use for a type descriptor decl for TYPE.  This\n-// is used when TYPE does not have a name.\n-\n-std::string\n-Gogo::unnamed_type_descriptor_decl_name(const Type* type)\n-{\n-  return \"__go_td_\" + type->mangled_name(this);\n-}\n-\n-// Return the name to use for a type descriptor decl for a type named\n-// NAME, defined in the function IN_FUNCTION.  IN_FUNCTION will\n-// normally be NULL.\n-\n-std::string\n-Gogo::type_descriptor_decl_name(const Named_object* no,\n-\t\t\t\tconst Named_object* in_function)\n-{\n-  std::string ret = \"__go_tdn_\";\n-  if (no->type_value()->is_builtin())\n-    go_assert(in_function == NULL);\n-  else\n-    {\n-      const std::string& unique_prefix(no->package() == NULL\n-\t\t\t\t       ? this->unique_prefix()\n-\t\t\t\t       : no->package()->unique_prefix());\n-      const std::string& package_name(no->package() == NULL\n-\t\t\t\t      ? this->package_name()\n-\t\t\t\t      : no->package()->name());\n-      ret.append(unique_prefix);\n-      ret.append(1, '.');\n-      ret.append(package_name);\n-      ret.append(1, '.');\n-      if (in_function != NULL)\n-\t{\n-\t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n-\t  ret.append(1, '.');\n-\t}\n-    }\n-  ret.append(no->name());\n-  return ret;\n-}\n-\n-// Where a type descriptor decl should be defined.\n-\n-Gogo::Type_descriptor_location\n-Gogo::type_descriptor_location(const Type* type)\n-{\n-  const Named_type* name = type->named_type();\n-  if (name != NULL)\n-    {\n-      if (name->named_object()->package() != NULL)\n-\t{\n-\t  // This is a named type defined in a different package.  The\n-\t  // descriptor should be defined in that package.\n-\t  return TYPE_DESCRIPTOR_UNDEFINED;\n-\t}\n-      else if (name->is_builtin())\n-\t{\n-\t  // We create the descriptor for a builtin type whenever we\n-\t  // need it.\n-\t  return TYPE_DESCRIPTOR_COMMON;\n-\t}\n-      else\n-\t{\n-\t  // This is a named type defined in this package.  The\n-\t  // descriptor should be defined here.\n-\t  return TYPE_DESCRIPTOR_DEFINED;\n-\t}\n-    }\n-  else\n-    {\n-      if (type->points_to() != NULL\n-\t  && type->points_to()->named_type() != NULL\n-\t  && type->points_to()->named_type()->named_object()->package() != NULL)\n-\t{\n-\t  // This is an unnamed pointer to a named type defined in a\n-\t  // different package.  The descriptor should be defined in\n-\t  // that package.\n-\t  return TYPE_DESCRIPTOR_UNDEFINED;\n-\t}\n-      else\n-\t{\n-\t  // This is an unnamed type.  The descriptor could be defined\n-\t  // in any package where it is needed, and the linker will\n-\t  // pick one descriptor to keep.\n-\t  return TYPE_DESCRIPTOR_COMMON;\n-\t}\n-    }\n-}\n-\n-// Build a type descriptor decl for TYPE.  INITIALIZER is a struct\n-// composite literal which initializers the type descriptor.\n-\n-void\n-Gogo::build_type_descriptor_decl(const Type* type, Expression* initializer,\n-\t\t\t\t tree* pdecl)\n-{\n-  const Named_type* name = type->named_type();\n-\n-  // We can have multiple instances of unnamed types, but we only want\n-  // to emit the type descriptor once.  We use a hash table to handle\n-  // this.  This is not necessary for named types, as they are unique,\n-  // and we store the type descriptor decl in the type itself.\n-  tree* phash = NULL;\n-  if (name == NULL)\n-    {\n-      if (this->type_descriptor_decls_ == NULL)\n-\tthis->type_descriptor_decls_ = new Type_descriptor_decls(10);\n-\n-      std::pair<Type_descriptor_decls::iterator, bool> ins =\n-\tthis->type_descriptor_decls_->insert(std::make_pair(type, NULL_TREE));\n-      if (!ins.second)\n-\t{\n-\t  // We've already built a type descriptor for this type.\n-\t  *pdecl = ins.first->second;\n-\t  return;\n-\t}\n-      phash = &ins.first->second;\n-    }\n-\n-  std::string decl_name;\n-  if (name == NULL)\n-    decl_name = this->unnamed_type_descriptor_decl_name(type);\n-  else\n-    decl_name = this->type_descriptor_decl_name(name->named_object(),\n-\t\t\t\t\t\tname->in_function());\n-  tree id = get_identifier_from_string(decl_name);\n-  Type* init_type = initializer->type();\n-  tree descriptor_type_tree = type_to_tree(init_type->get_backend(this));\n-  if (descriptor_type_tree == error_mark_node)\n-    {\n-      *pdecl = error_mark_node;\n-      return;\n-    }\n-  tree decl = build_decl(name == NULL ? BUILTINS_LOCATION : name->location(),\n-\t\t\t VAR_DECL, id,\n-\t\t\t build_qualified_type(descriptor_type_tree,\n-\t\t\t\t\t      TYPE_QUAL_CONST));\n-  TREE_READONLY(decl) = 1;\n-  TREE_CONSTANT(decl) = 1;\n-  DECL_ARTIFICIAL(decl) = 1;\n-\n-  go_preserve_from_gc(decl);\n-  if (phash != NULL)\n-    *phash = decl;\n-\n-  // We store the new DECL now because we may need to refer to it when\n-  // expanding INITIALIZER.\n-  *pdecl = decl;\n-\n-  // If appropriate, just refer to the exported type identifier.\n-  Gogo::Type_descriptor_location type_descriptor_location =\n-    this->type_descriptor_location(type);\n-  if (type_descriptor_location == TYPE_DESCRIPTOR_UNDEFINED)\n-    {\n-      TREE_PUBLIC(decl) = 1;\n-      DECL_EXTERNAL(decl) = 1;\n-      return;\n-    }\n-\n-  TREE_STATIC(decl) = 1;\n-  TREE_USED(decl) = 1;\n-\n-  Translate_context context(this, NULL, NULL, NULL);\n-  context.set_is_const();\n-  tree constructor = initializer->get_tree(&context);\n-\n-  if (constructor == error_mark_node)\n-    go_assert(saw_errors());\n-\n-  DECL_INITIAL(decl) = constructor;\n-\n-  if (type_descriptor_location == TYPE_DESCRIPTOR_DEFINED)\n-    TREE_PUBLIC(decl) = 1;\n-  else\n-    {\n-      go_assert(type_descriptor_location == TYPE_DESCRIPTOR_COMMON);\n-      make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n-      resolve_unique_section(decl, 1, 0);\n-    }\n-\n-  rest_of_decl_compilation(decl, 1, 0);\n-}\n-\n // Build an interface method table for a type: a list of function\n // pointers, one for each interface method.  This is used for\n // interfaces.\n@@ -2353,8 +2169,8 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n     td_type = type;\n   else\n     td_type = Type::make_pointer_type(type);\n-  elt->value = fold_convert(const_ptr_type_node,\n-\t\t\t    td_type->type_descriptor_pointer(this));\n+  tree tdp = td_type->type_descriptor_pointer(this, BUILTINS_LOCATION);\n+  elt->value = fold_convert(const_ptr_type_node, tdp);\n \n   size_t i = 1;\n   for (Typed_identifier_list::const_iterator p = interface_methods->begin();"}, {"sha": "484d1a11e8fbb44628a8a28e75ddd5e502e0aa82", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -30,7 +30,6 @@ Gogo::Gogo(Backend* backend, int int_type_size, int pointer_size)\n     imported_unsafe_(false),\n     packages_(),\n     map_descriptors_(NULL),\n-    type_descriptor_decls_(NULL),\n     init_functions_(),\n     need_init_fn_(false),\n     init_fn_name_(),"}, {"sha": "972369fe6fbdc6cf9739731a5e4d1d7d7c732160", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -483,12 +483,6 @@ class Gogo\n   tree\n   map_descriptor_type();\n \n-  // Build a type descriptor for TYPE using INITIALIZER as the type\n-  // descriptor.  This builds a new decl stored in *PDECL.\n-  void\n-  build_type_descriptor_decl(const Type*, Expression* initializer,\n-\t\t\t     tree* pdecl);\n-\n   // Build required interface method tables.\n   void\n   build_interface_method_tables();\n@@ -592,32 +586,6 @@ class Gogo\n   tree\n   ptr_go_string_constant_tree(const std::string&);\n \n-  // Return the name to use for a type descriptor decl for an unnamed\n-  // type.\n-  std::string\n-  unnamed_type_descriptor_decl_name(const Type* type);\n-\n-  // Return the name to use for a type descriptor decl for a type\n-  // named NO, defined in IN_FUNCTION.\n-  std::string\n-  type_descriptor_decl_name(const Named_object* no,\n-\t\t\t    const Named_object* in_function);\n-\n-  // Where a type descriptor should be defined.\n-  enum Type_descriptor_location\n-    {\n-      // Defined in this file.\n-      TYPE_DESCRIPTOR_DEFINED,\n-      // Defined in some other file.\n-      TYPE_DESCRIPTOR_UNDEFINED,\n-      // Common definition which may occur in multiple files.\n-      TYPE_DESCRIPTOR_COMMON\n-    };\n-\n-  // Return where the decl for TYPE should be defined.\n-  Type_descriptor_location\n-  type_descriptor_location(const Type* type);\n-\n   // Return the type of a trampoline.\n   static tree\n   trampoline_type_tree();\n@@ -635,10 +603,6 @@ class Gogo\n   typedef Unordered_map_hash(const Map_type*, tree, Type_hash_identical,\n \t\t\t     Type_identical) Map_descriptors;\n \n-  // Map unnamed types to type descriptor decls.\n-  typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n-\t\t\t     Type_identical) Type_descriptor_decls;\n-\n   // The backend generator.\n   Backend* backend_;\n   // The package we are compiling.\n@@ -657,8 +621,6 @@ class Gogo\n   Packages packages_;\n   // Mapping from map types to map descriptors.\n   Map_descriptors* map_descriptors_;\n-  // Mapping from unnamed types to type descriptor decls.\n-  Type_descriptor_decls* type_descriptor_decls_;\n   // The functions named \"init\", if there are any.\n   std::vector<Named_object*> init_functions_;\n   // Whether we need a magic initialization function."}, {"sha": "15e35c2b29d851c5499581a3c58931fc0516d826", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 170, "deletions": 12, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -37,8 +37,7 @@ extern \"C\"\n // Class Type.\n \n Type::Type(Type_classification classification)\n-  : classification_(classification), btype_(NULL),\n-    type_descriptor_decl_(NULL_TREE)\n+  : classification_(classification), btype_(NULL), type_descriptor_var_(NULL)\n {\n }\n \n@@ -926,20 +925,179 @@ Type::do_make_expression_tree(Translate_context*, Expression_list*,\n // Return a pointer to the type descriptor for this type.\n \n tree\n-Type::type_descriptor_pointer(Gogo* gogo)\n+Type::type_descriptor_pointer(Gogo* gogo, source_location location)\n {\n   Type* t = this->forwarded();\n-  if (t->type_descriptor_decl_ == NULL_TREE)\n+  if (t->type_descriptor_var_ == NULL)\n     {\n-      Expression* e = t->do_type_descriptor(gogo, NULL);\n-      gogo->build_type_descriptor_decl(t, e, &t->type_descriptor_decl_);\n-      go_assert(t->type_descriptor_decl_ != NULL_TREE\n-\t\t && (t->type_descriptor_decl_ == error_mark_node\n-\t\t     || DECL_P(t->type_descriptor_decl_)));\n+      t->make_type_descriptor_var(gogo);\n+      go_assert(t->type_descriptor_var_ != NULL);\n     }\n-  if (t->type_descriptor_decl_ == error_mark_node)\n+  tree var_tree = var_to_tree(t->type_descriptor_var_);\n+  if (var_tree == error_mark_node)\n     return error_mark_node;\n-  return build_fold_addr_expr(t->type_descriptor_decl_);\n+  return build_fold_addr_expr_loc(location, var_tree);\n+}\n+\n+// A mapping from unnamed types to type descriptor variables.\n+\n+Type::Type_descriptor_vars Type::type_descriptor_vars;\n+\n+// Build the type descriptor for this type.\n+\n+void\n+Type::make_type_descriptor_var(Gogo* gogo)\n+{\n+  go_assert(this->type_descriptor_var_ == NULL);\n+\n+  Named_type* nt = this->named_type();\n+\n+  // We can have multiple instances of unnamed types, but we only want\n+  // to emit the type descriptor once.  We use a hash table.  This is\n+  // not necessary for named types, as they are unique, and we store\n+  // the type descriptor in the type itself.\n+  Bvariable** phash = NULL;\n+  if (nt == NULL)\n+    {\n+      Bvariable* bvnull = NULL;\n+      std::pair<Type_descriptor_vars::iterator, bool> ins =\n+\tType::type_descriptor_vars.insert(std::make_pair(this, bvnull));\n+      if (!ins.second)\n+\t{\n+\t  // We've already build a type descriptor for this type.\n+\t  this->type_descriptor_var_ = ins.first->second;\n+\t  return;\n+\t}\n+      phash = &ins.first->second;\n+    }\n+\n+  std::string var_name;\n+  if (nt == NULL)\n+    var_name = this->unnamed_type_descriptor_var_name(gogo);\n+  else\n+    var_name = this->type_descriptor_var_name(gogo);\n+\n+  // Build the contents of the type descriptor.\n+  Expression* initializer = this->do_type_descriptor(gogo, NULL);\n+\n+  Btype* initializer_btype = initializer->type()->get_backend(gogo);\n+\n+  // See if this type descriptor is defined in a different package.\n+  bool is_defined_elsewhere = false;\n+  if (nt != NULL)\n+    {\n+      if (nt->named_object()->package() != NULL)\n+\t{\n+\t  // This is a named type defined in a different package.  The\n+\t  // type descriptor should be defined in that package.\n+\t  is_defined_elsewhere = true;\n+\t}\n+    }\n+  else\n+    {\n+      if (this->points_to() != NULL\n+\t  && this->points_to()->named_type() != NULL\n+\t  && this->points_to()->named_type()->named_object()->package() != NULL)\n+\t{\n+\t  // This is an unnamed pointer to a named type defined in a\n+\t  // different package.  The descriptor should be defined in\n+\t  // that package.\n+\t  is_defined_elsewhere = true;\n+\t}\n+    }\n+\n+  source_location loc = nt == NULL ? BUILTINS_LOCATION : nt->location();\n+\n+  if (is_defined_elsewhere)\n+    {\n+      this->type_descriptor_var_ =\n+\tgogo->backend()->immutable_struct_reference(var_name,\n+\t\t\t\t\t\t    initializer_btype,\n+\t\t\t\t\t\t    loc);\n+      if (phash != NULL)\n+\t*phash = this->type_descriptor_var_;\n+      return;\n+    }\n+\n+  // See if this type descriptor can appear in multiple packages.\n+  bool is_common = false;\n+  if (nt != NULL)\n+    {\n+      // We create the descriptor for a builtin type whenever we need\n+      // it.\n+      is_common = nt->is_builtin();\n+    }\n+  else\n+    {\n+      // This is an unnamed type.  The descriptor could be defined in\n+      // any package where it is needed, and the linker will pick one\n+      // descriptor to keep.\n+      is_common = true;\n+    }\n+\n+  // We are going to build the type descriptor in this package.  We\n+  // must create the variable before we convert the initializer to the\n+  // backend representation, because the initializer may refer to the\n+  // type descriptor of this type.  By setting type_descriptor_var_ we\n+  // ensure that type_descriptor_pointer will work if called while\n+  // converting INITIALIZER.\n+\n+  this->type_descriptor_var_ =\n+    gogo->backend()->immutable_struct(var_name, is_common, initializer_btype,\n+\t\t\t\t      loc);\n+  if (phash != NULL)\n+    *phash = this->type_descriptor_var_;\n+\n+  Translate_context context(gogo, NULL, NULL, NULL);\n+  context.set_is_const();\n+  Bexpression* binitializer = tree_to_expr(initializer->get_tree(&context));\n+\n+  gogo->backend()->immutable_struct_set_init(this->type_descriptor_var_,\n+\t\t\t\t\t     var_name, is_common,\n+\t\t\t\t\t     initializer_btype, loc,\n+\t\t\t\t\t     binitializer);\n+}\n+\n+// Return the name of the type descriptor variable for an unnamed\n+// type.\n+\n+std::string\n+Type::unnamed_type_descriptor_var_name(Gogo* gogo)\n+{\n+  return \"__go_td_\" + this->mangled_name(gogo);\n+}\n+\n+// Return the name of the type descriptor variable for a named type.\n+\n+std::string\n+Type::type_descriptor_var_name(Gogo* gogo)\n+{\n+  Named_type* nt = this->named_type();\n+  Named_object* no = nt->named_object();\n+  const Named_object* in_function = nt->in_function();\n+  std::string ret = \"__go_tdn_\";\n+  if (nt->is_builtin())\n+    go_assert(in_function == NULL);\n+  else\n+    {\n+      const std::string& unique_prefix(no->package() == NULL\n+\t\t\t\t       ? gogo->unique_prefix()\n+\t\t\t\t       : no->package()->unique_prefix());\n+      const std::string& package_name(no->package() == NULL\n+\t\t\t\t      ? gogo->package_name()\n+\t\t\t\t      : no->package()->name());\n+      ret.append(unique_prefix);\n+      ret.append(1, '.');\n+      ret.append(package_name);\n+      ret.append(1, '.');\n+      if (in_function != NULL)\n+\t{\n+\t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n+\t  ret.append(1, '.');\n+\t}\n+    }\n+  ret.append(no->name());\n+  return ret;\n }\n \n // Return a composite literal for a type descriptor.\n@@ -5114,7 +5272,7 @@ Channel_type::do_make_expression_tree(Translate_context* context,\n \n   Type* ptdt = Type::make_type_descriptor_ptr_type();\n   tree element_type_descriptor =\n-    this->element_type_->type_descriptor_pointer(gogo);\n+    this->element_type_->type_descriptor_pointer(gogo, location);\n \n   tree bad_index = NULL_TREE;\n "}, {"sha": "fc35431f6ad3fc2f896a372371d050c8ce7b6fa9", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f910247bd52a16c6195b0508d4ae4c4dce91d8/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=70f910247bd52a16c6195b0508d4ae4c4dce91d8", "patch": "@@ -44,6 +44,7 @@ class Export;\n class Import;\n class Btype;\n class Bexpression;\n+class Bvariable;\n \n // Type codes used in type descriptors.  These must match the values\n // in libgo/runtime/go-type.h.  They also match the values in the gc\n@@ -832,9 +833,10 @@ class Type\n   { return this->do_make_expression_tree(context, args, location); }\n \n   // Build a type descriptor entry for this type.  Return a pointer to\n-  // it.\n+  // it.  The location is the location which causes us to need the\n+  // entry.\n   tree\n-  type_descriptor_pointer(Gogo* gogo);\n+  type_descriptor_pointer(Gogo* gogo, source_location);\n \n   // Return the type reflection string for this type.\n   std::string\n@@ -1010,6 +1012,25 @@ class Type\n   are_assignable_check_hidden(const Type* lhs, const Type* rhs,\n \t\t\t      bool check_hidden_fields, std::string* reason);\n \n+  // Map unnamed types to type descriptor decls.\n+  typedef Unordered_map_hash(const Type*, Bvariable*, Type_hash_identical,\n+\t\t\t     Type_identical) Type_descriptor_vars;\n+\n+  static Type_descriptor_vars type_descriptor_vars;\n+\n+  // Build the type descriptor variable for this type.\n+  void\n+  make_type_descriptor_var(Gogo*);\n+\n+  // Return the name of the type descriptor variable for an unnamed\n+  // type.\n+  std::string\n+  unnamed_type_descriptor_var_name(Gogo*);\n+\n+  // Return the name of the type descriptor variable for a named type.\n+  std::string\n+  type_descriptor_var_name(Gogo*);\n+\n   // Get the hash and equality functions for a type.\n   void\n   type_functions(const char** hash_fn, const char** equal_fn) const;\n@@ -1101,9 +1122,9 @@ class Type\n   // The backend representation of the type, once it has been\n   // determined.\n   Btype* btype_;\n-  // The decl for the type descriptor for this type.  This starts out\n-  // as NULL and is filled in as needed.\n-  tree type_descriptor_decl_;\n+  // The type descriptor for this type.  This starts out as NULL and\n+  // is filled in as needed.\n+  Bvariable* type_descriptor_var_;\n };\n \n // Type hash table operations."}]}