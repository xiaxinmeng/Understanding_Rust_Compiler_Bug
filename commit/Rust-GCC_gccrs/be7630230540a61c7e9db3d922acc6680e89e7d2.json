{"sha": "be7630230540a61c7e9db3d922acc6680e89e7d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU3NjMwMjMwNTQwYTYxYzdlOWRiM2Q5MjJhY2M2NjgwZTg5ZTdkMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-10-07T06:38:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-10-07T06:38:15Z"}, "message": "mips.c (MIPS_MAX_FIRST_STACK_STEP): New macro.\n\n\t* config/mips/mips.c (MIPS_MAX_FIRST_STACK_STEP): New macro.\n\t(mips_save_restore_fn): New typedef.\n\t(mips_add_large_offset_to_sp, mips_emit_frame_related_store): Remove.\n\t(mips_set_frame_expr, mips_frame_set): Move above prologue code.\n\t(save_restore_insns): Remove, replacing with...\n\t(mips_save_restore_reg, mips_for_each_saved_reg): ...these new fns.\n\t(mips_save_reg, mips_restore_reg): New function.\n\t(mips_expand_prologue, mips_expand_epilogue): Rework.\n\t* config/mips/mips.h (MIPS_TEMP1_REGNUM, MIPS_TEMP2_REGNUM): Remove.\n\t(MIPS_PROLOGUE_TEMP_REGNUM, MIPS_EPILOGUE_TEMP_REGNUM): New macros.\n\t(MIPS_PROLOGUE_TEMP, MIPS_EPILOGUE_TEMP): New macros.\n\nFrom-SVN: r72182", "tree": {"sha": "617a7d41caa13c770aa91f143e1fdfc8cdcf91ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/617a7d41caa13c770aa91f143e1fdfc8cdcf91ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be7630230540a61c7e9db3d922acc6680e89e7d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7630230540a61c7e9db3d922acc6680e89e7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be7630230540a61c7e9db3d922acc6680e89e7d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7630230540a61c7e9db3d922acc6680e89e7d2/comments", "author": null, "committer": null, "parents": [{"sha": "aaa2154200561722a98504ce6f4ddd71dc76295a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa2154200561722a98504ce6f4ddd71dc76295a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa2154200561722a98504ce6f4ddd71dc76295a"}], "stats": {"total": 788, "additions": 310, "deletions": 478}, "files": [{"sha": "563d23867072aff3bd6fee736a3f8792a8aba566", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7630230540a61c7e9db3d922acc6680e89e7d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7630230540a61c7e9db3d922acc6680e89e7d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be7630230540a61c7e9db3d922acc6680e89e7d2", "patch": "@@ -1,3 +1,17 @@\n+2003-10-07  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (MIPS_MAX_FIRST_STACK_STEP): New macro.\n+\t(mips_save_restore_fn): New typedef.\n+\t(mips_add_large_offset_to_sp, mips_emit_frame_related_store): Remove.\n+\t(mips_set_frame_expr, mips_frame_set): Move above prologue code.\n+\t(save_restore_insns): Remove, replacing with...\n+\t(mips_save_restore_reg, mips_for_each_saved_reg): ...these new fns.\n+\t(mips_save_reg, mips_restore_reg): New function.\n+\t(mips_expand_prologue, mips_expand_epilogue): Rework.\n+\t* config/mips/mips.h (MIPS_TEMP1_REGNUM, MIPS_TEMP2_REGNUM): Remove.\n+\t(MIPS_PROLOGUE_TEMP_REGNUM, MIPS_EPILOGUE_TEMP_REGNUM): New macros.\n+\t(MIPS_PROLOGUE_TEMP, MIPS_EPILOGUE_TEMP): New macros.\n+\n 2003-10-07  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_expand_prologue): Remove unused"}, {"sha": "5a8b05938ff02f471666cfc5f3b65f6f71b05527", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 284, "deletions": 469, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7630230540a61c7e9db3d922acc6680e89e7d2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7630230540a61c7e9db3d922acc6680e89e7d2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=be7630230540a61c7e9db3d922acc6680e89e7d2", "patch": "@@ -80,6 +80,19 @@ enum internal_test {\n #define INTERNAL_SYMBOL_P(SYM) \\\n   (XSTR (SYM, 0)[0] == '*' && XSTR (SYM, 0)[1] == LOCAL_LABEL_PREFIX[0])\n \n+/* The maximum distance between the top of the stack frame and the\n+   value $sp has when we save & restore registers.\n+\n+   Use a maximum gap of 0x100 in the mips16 case.  We can then use\n+   unextended instructions to save and restore registers, and to\n+   allocate and deallocate the top part of the frame.\n+\n+   The value in the !mips16 case must be a SMALL_OPERAND and must\n+   preserve the maximum stack alignment.  It could really be 0x7ff0,\n+   but SGI's assemblers implement daddiu $sp,$sp,-0x7ff0 as a\n+   multi-instruction addu sequence.  Use 0x7fe0 to work around this.  */\n+#define MIPS_MAX_FIRST_STACK_STEP (TARGET_MIPS16 ? 0x100 : 0x7fe0)\n+\n /* Classifies a non-literal integer constant.\n \n    CONSTANT_NONE\n@@ -165,6 +178,9 @@ enum mips_address_type {\n   ADDRESS_SYMBOLIC\n };\n \n+/* A function to save or store a register.  The first argument is the\n+   register and the second is the stack slot.  */\n+typedef void (*mips_save_restore_fn) (rtx, rtx);\n \n struct constant;\n struct mips_arg_info;\n@@ -223,14 +239,16 @@ static void mips_file_start (void);\n static void mips_file_end (void);\n static unsigned int mips_global_pointer\t(void);\n static bool mips_save_reg_p (unsigned int);\n-static rtx mips_add_large_offset_to_sp (HOST_WIDE_INT);\n-static void mips_set_frame_expr (rtx);\n-static rtx mips_frame_set (rtx, int);\n-static void mips_emit_frame_related_store (rtx, rtx, HOST_WIDE_INT);\n-static void save_restore_insns (int, rtx, long);\n+static void mips_save_restore_reg (enum machine_mode, int, HOST_WIDE_INT,\n+\t\t\t\t   mips_save_restore_fn);\n+static void mips_for_each_saved_reg (HOST_WIDE_INT, mips_save_restore_fn);\n static void mips_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void mips_set_frame_expr (rtx);\n+static rtx mips_frame_set (rtx, rtx);\n+static void mips_save_reg (rtx, rtx);\n static void mips_gp_insn (rtx, rtx);\n static void mips_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void mips_restore_reg (rtx, rtx);\n static int symbolic_expression_p (rtx);\n static void mips_select_rtx_section (enum machine_mode, rtx,\n \t\t\t\t     unsigned HOST_WIDE_INT);\n@@ -6235,14 +6253,6 @@ mips_initial_elimination_offset (int from, int to)\n   return offset;\n }\n \f\n-/* Common code to emit the insns (or to write the instructions to a file)\n-   to save/restore registers.\n-\n-   Other parts of the code assume that MIPS_TEMP1_REGNUM (aka large_reg)\n-   is not modified within save_restore_insns.  */\n-\n-#define BITSET_P(VALUE,BIT) (((VALUE) & (1L << (BIT))) != 0)\n-\n /* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n    back to a previous frame.  */\n rtx\n@@ -6253,286 +6263,63 @@ mips_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n \n   return get_hard_reg_initial_val (Pmode, GP_REG_FIRST + 31);\n }\n-\n-\n-/* Emit instructions to load the value (SP + OFFSET) into MIPS_TEMP2_REGNUM\n-   and return an rtl expression for the register.\n-\n-   This function is a subroutine of save_restore_insns.  It is used when\n-   OFFSET is too large to add in a single instruction.  */\n-\n-static rtx\n-mips_add_large_offset_to_sp (HOST_WIDE_INT offset)\n-{\n-  rtx reg = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n-  rtx offset_rtx = GEN_INT (offset);\n-\n-  emit_move_insn (reg, offset_rtx);\n-  if (Pmode == DImode)\n-    emit_insn (gen_adddi3 (reg, reg, stack_pointer_rtx));\n-  else\n-    emit_insn (gen_addsi3 (reg, reg, stack_pointer_rtx));\n-  return reg;\n-}\n-\n-/* Make the last instruction frame related and note that it performs\n-   the operation described by FRAME_PATTERN.  */\n+\f\n+/* Use FN to save or restore register REGNO.  MODE is the register's\n+   mode and OFFSET is the offset of its save slot from the current\n+   stack pointer.  */\n \n static void\n-mips_set_frame_expr (rtx frame_pattern)\n+mips_save_restore_reg (enum machine_mode mode, int regno,\n+\t\t       HOST_WIDE_INT offset, mips_save_restore_fn fn)\n {\n-  rtx insn;\n-\n-  insn = get_last_insn ();\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-  REG_NOTES (insn) = alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t      frame_pattern,\n-\t\t\t\t      REG_NOTES (insn));\n-}\n+  rtx mem;\n \n-/* Return a frame-related rtx that stores REG at (SP + OFFSET).\n-   REG must be a single register.  */\n+  mem = gen_rtx_MEM (mode, plus_constant (stack_pointer_rtx, offset));\n+  if (!current_function_calls_eh_return)\n+    RTX_UNCHANGING_P (mem) = 1;\n \n-static rtx\n-mips_frame_set (rtx reg, int offset)\n-{\n-  rtx address = plus_constant (stack_pointer_rtx, offset);\n-  rtx set = gen_rtx_SET (VOIDmode, gen_rtx_MEM (GET_MODE (reg), address), reg);\n-  RTX_FRAME_RELATED_P (set) = 1;\n-  return set;\n+  fn (gen_rtx_REG (mode, regno), mem);\n }\n \n \n-/* Emit a move instruction that stores REG in MEM.  Make the instruction\n-   frame related and note that it stores REG at (SP + OFFSET).  This\n-   function may be asked to store an FPR pair.  */\n+/* Call FN for each register that is saved by the current function.\n+   SP_OFFSET is the offset of the current stack pointer from the start\n+   of the frame.  */\n \n static void\n-mips_emit_frame_related_store (rtx mem, rtx reg, HOST_WIDE_INT offset)\n+mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n {\n-  if (GET_MODE (reg) == DFmode && mips_split_64bit_move_p (mem, reg))\n-    mips_split_64bit_move (mem, reg);\n-  else\n-    emit_move_insn (mem, reg);\n+#define BITSET_P(VALUE, BIT) (((VALUE) & (1L << (BIT))) != 0)\n \n-  if (GET_MODE (reg) == DFmode && !TARGET_FLOAT64)\n-    {\n-      rtx x1, x2;\n-\n-      /* Two registers are being stored, so the frame-related expression\n-\t must be a PARALLEL rtx with one SET for each register.  */\n-      x1 = mips_frame_set (mips_subword (reg, TARGET_BIG_ENDIAN), offset);\n-      x2 = mips_frame_set (mips_subword (reg, !TARGET_BIG_ENDIAN),\n-\t\t\t   offset + UNITS_PER_FPREG);\n-      mips_set_frame_expr (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x1, x2)));\n-    }\n-  else\n-    mips_set_frame_expr (mips_frame_set (reg, offset));\n-}\n-\n-\n-/* Emit instructions to save or restore the registers in\n-   cfun->machine->frame.mask and cfun->machine->frame.fmask.\n-   STORE_P is true to save registers (meaning we are expanding\n-   the prologue).  If nonnull, LARGE_REG stores the value LARGE_OFFSET,\n-   which the caller thinks might be useful to us.  */\n-\n-static void\n-save_restore_insns (int store_p, rtx large_reg, long large_offset)\n-{\n-  long mask = cfun->machine->frame.mask;\n-  long fmask = cfun->machine->frame.fmask;\n+  enum machine_mode fpr_mode;\n+  HOST_WIDE_INT offset;\n   int regno;\n-  rtx base_reg_rtx;\n-  HOST_WIDE_INT base_offset;\n-  HOST_WIDE_INT gp_offset;\n-  HOST_WIDE_INT fp_offset;\n-  HOST_WIDE_INT end_offset;\n-\n-  if (frame_pointer_needed\n-      && ! BITSET_P (mask, HARD_FRAME_POINTER_REGNUM - GP_REG_FIRST))\n-    abort ();\n-\n-  if (mask == 0 && fmask == 0)\n-    return;\n \n   /* Save registers starting from high to low.  The debuggers prefer at least\n      the return register be stored at func+4, and also it allows us not to\n      need a nop in the epilog if at least one register is reloaded in\n      addition to return address.  */\n+  offset = cfun->machine->frame.gp_sp_offset - sp_offset;\n+  for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n+    if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))\n+      {\n+\tmips_save_restore_reg (gpr_mode, regno, offset, fn);\n+\toffset -= GET_MODE_SIZE (gpr_mode);\n+      }\n \n-  /* Save GP registers if needed.  */\n-  if (mask)\n-    {\n-      /* Pick which pointer to use as a base register.  For small frames, just\n-\t use the stack pointer.  Otherwise, use a temporary register.  Save 2\n-\t cycles if the save area is near the end of a large frame, by reusing\n-\t the constant created in the prologue/epilogue to adjust the stack\n-\t frame.  */\n-\n-      gp_offset = cfun->machine->frame.gp_sp_offset;\n-      end_offset\n-\t= gp_offset - (cfun->machine->frame.gp_reg_size\n-\t\t       - GET_MODE_SIZE (gpr_mode));\n-\n-      if (gp_offset < 0 || end_offset < 0)\n-\tinternal_error\n-\t  (\"gp_offset (%ld) or end_offset (%ld) is less than zero\",\n-\t   (long) gp_offset, (long) end_offset);\n-\n-      /* If we see a large frame in mips16 mode, we save the registers\n-         before adjusting the stack pointer, and load them afterward.  */\n-      else if (TARGET_MIPS16 && large_offset > 32767)\n-\tbase_reg_rtx = stack_pointer_rtx, base_offset = large_offset;\n-\n-      else if (gp_offset < 32768)\n-\tbase_reg_rtx = stack_pointer_rtx, base_offset  = 0;\n-\n-      else if (large_reg != 0\n-\t       && (unsigned HOST_WIDE_INT) (large_offset - gp_offset) < 32768\n-\t       && (unsigned HOST_WIDE_INT) (large_offset - end_offset) < 32768)\n-\t{\n-\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n-\t  base_offset = large_offset;\n-\t  if (Pmode == DImode)\n-\t    emit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n-\t  else\n-\t    emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n-\t}\n-      else\n-\t{\n-\t  base_offset = gp_offset;\n-\t  base_reg_rtx = mips_add_large_offset_to_sp (base_offset);\n-\t}\n-\n-      /* When we restore the registers in MIPS16 mode, then if we are\n-         using a frame pointer, and this is not a large frame, the\n-         current stack pointer will be offset by\n-         current_function_outgoing_args_size.  Doing it this way lets\n-         us avoid offsetting the frame pointer before copying it into\n-         the stack pointer; there is no instruction to set the stack\n-         pointer to the sum of a register and a constant.  */\n-      if (TARGET_MIPS16\n-\t  && ! store_p\n-\t  && frame_pointer_needed\n-\t  && large_offset <= 32767)\n-\tbase_offset += current_function_outgoing_args_size;\n-\n-      for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n-\t{\n-\t  if (BITSET_P (mask, regno - GP_REG_FIRST))\n-\t    {\n-\t      rtx reg_rtx;\n-\t      rtx mem_rtx\n-\t\t= gen_rtx (MEM, gpr_mode,\n-\t\t\t   gen_rtx (PLUS, Pmode, base_reg_rtx,\n-\t\t\t\t    GEN_INT (gp_offset - base_offset)));\n-\n-\t      if (! current_function_calls_eh_return)\n-\t\tRTX_UNCHANGING_P (mem_rtx) = 1;\n-\n-\t      /* The mips16 does not have an instruction to load\n-\t\t $31, so we load $7 instead, and work things out\n-\t\t in mips_expand_epilogue.  */\n-\t      if (TARGET_MIPS16 && ! store_p && regno == GP_REG_FIRST + 31)\n-\t\treg_rtx = gen_rtx (REG, gpr_mode, GP_REG_FIRST + 7);\n-\t      /* The mips16 sometimes needs to save $18.  */\n-\t      else if (TARGET_MIPS16\n-\t\t       && regno != GP_REG_FIRST + 31\n-\t\t       && ! M16_REG_P (regno))\n-\t\t{\n-\t\t  if (! store_p)\n-\t\t    reg_rtx = gen_rtx (REG, gpr_mode, 6);\n-\t\t  else\n-\t\t    {\n-\t\t      reg_rtx = gen_rtx (REG, gpr_mode, 3);\n-\t\t      emit_move_insn (reg_rtx,\n-\t\t\t\t      gen_rtx (REG, gpr_mode, regno));\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\treg_rtx = gen_rtx (REG, gpr_mode, regno);\n-\n-\t      if (store_p)\n-\t\tmips_emit_frame_related_store (mem_rtx, reg_rtx, gp_offset);\n-\t      else\n-\t\t{\n-\t\t  emit_move_insn (reg_rtx, mem_rtx);\n-\t\t  if (TARGET_MIPS16\n-\t\t      && regno != GP_REG_FIRST + 31\n-\t\t      && ! M16_REG_P (regno))\n-\t\t    emit_move_insn (gen_rtx (REG, gpr_mode, regno),\n-\t\t\t\t    reg_rtx);\n-\t\t}\n-\t      gp_offset -= GET_MODE_SIZE (gpr_mode);\n-\t    }\n-\t}\n-    }\n-  else\n-    base_reg_rtx = 0, base_offset  = 0;\n-\n-  /* Save floating point registers if needed.  */\n-  if (fmask)\n-    {\n-      /* Pick which pointer to use as a base register.  */\n-      fp_offset = cfun->machine->frame.fp_sp_offset;\n-      end_offset = fp_offset - (cfun->machine->frame.fp_reg_size\n-\t\t\t\t- UNITS_PER_HWFPVALUE);\n-\n-      if (fp_offset < 0 || end_offset < 0)\n-\tinternal_error\n-\t  (\"fp_offset (%ld) or end_offset (%ld) is less than zero\",\n-\t   (long) fp_offset, (long) end_offset);\n-\n-      else if (fp_offset < 32768)\n-\tbase_reg_rtx = stack_pointer_rtx, base_offset  = 0;\n-\n-      else if (base_reg_rtx != 0\n-\t       && (unsigned HOST_WIDE_INT) (base_offset - fp_offset) < 32768\n-\t       && (unsigned HOST_WIDE_INT) (base_offset - end_offset) < 32768)\n-\t;\t\t\t/* already set up for gp registers above */\n-\n-      else if (large_reg != 0\n-\t       && (unsigned HOST_WIDE_INT) (large_offset - fp_offset) < 32768\n-\t       && (unsigned HOST_WIDE_INT) (large_offset - end_offset) < 32768)\n-\t{\n-\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n-\t  base_offset = large_offset;\n-\t  if (Pmode == DImode)\n-\t    emit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n-\t  else\n-\t    emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n-\t}\n-      else\n-\t{\n-\t  base_offset = fp_offset;\n-\t  base_reg_rtx = mips_add_large_offset_to_sp (fp_offset);\n-\t}\n-\n-      /* This loop must iterate over the same space as its companion in\n-\t compute_frame_size.  */\n-      for (regno = (FP_REG_LAST - FP_INC + 1);\n-\t   regno >= FP_REG_FIRST;\n-\t   regno -= FP_INC)\n-\tif (BITSET_P (fmask, regno - FP_REG_FIRST))\n-\t  {\n-\t    enum machine_mode sz = TARGET_SINGLE_FLOAT ? SFmode : DFmode;\n-\t    rtx reg_rtx = gen_rtx (REG, sz, regno);\n-\t    rtx mem_rtx = gen_rtx (MEM, sz,\n-\t\t\t\t   gen_rtx (PLUS, Pmode, base_reg_rtx,\n-\t\t\t\t\t    GEN_INT (fp_offset\n-\t\t\t\t\t\t     - base_offset)));\n-\t    if (! current_function_calls_eh_return)\n-\t      RTX_UNCHANGING_P (mem_rtx) = 1;\n-\n-\t    if (store_p)\n-\t      mips_emit_frame_related_store (mem_rtx, reg_rtx, fp_offset);\n-\t    else\n-\t      emit_move_insn (reg_rtx, mem_rtx);\n-\n-\t    fp_offset -= UNITS_PER_HWFPVALUE;\n-\t  }\n-    }\n+  /* This loop must iterate over the same space as its companion in\n+     compute_frame_size.  */\n+  offset = cfun->machine->frame.fp_sp_offset - sp_offset;\n+  fpr_mode = (TARGET_SINGLE_FLOAT ? SFmode : DFmode);\n+  for (regno = (FP_REG_LAST - FP_INC + 1);\n+       regno >= FP_REG_FIRST;\n+       regno -= FP_INC)\n+    if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n+      {\n+\tmips_save_restore_reg (fpr_mode, regno, offset, fn);\n+\toffset -= GET_MODE_SIZE (fpr_mode);\n+      }\n+#undef BITSET_P\n }\n \f\n /* Set up the stack and frame (if desired) for the function.  */\n@@ -6623,6 +6410,68 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n     output_asm_insn (\"%(%<\", 0);\n }\n \f\n+/* Make the last instruction frame related and note that it performs\n+   the operation described by FRAME_PATTERN.  */\n+\n+static void\n+mips_set_frame_expr (rtx frame_pattern)\n+{\n+  rtx insn;\n+\n+  insn = get_last_insn ();\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  REG_NOTES (insn) = alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t      frame_pattern,\n+\t\t\t\t      REG_NOTES (insn));\n+}\n+\n+\n+/* Return a frame-related rtx that stores REG at MEM.\n+   REG must be a single register.  */\n+\n+static rtx\n+mips_frame_set (rtx mem, rtx reg)\n+{\n+  rtx set = gen_rtx_SET (VOIDmode, mem, reg);\n+  RTX_FRAME_RELATED_P (set) = 1;\n+  return set;\n+}\n+\n+\n+/* Save register REG to MEM.  Make the instruction frame-related.  */\n+\n+static void\n+mips_save_reg (rtx reg, rtx mem)\n+{\n+  if (GET_MODE (reg) == DFmode && mips_split_64bit_move_p (mem, reg))\n+    {\n+      rtx x1, x2;\n+\n+      mips_split_64bit_move (mem, reg);\n+      x1 = mips_frame_set (mips_subword (mem, 0), mips_subword (reg, 0));\n+      x2 = mips_frame_set (mips_subword (mem, 1), mips_subword (reg, 1));\n+      mips_set_frame_expr (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x1, x2)));\n+    }\n+  else\n+    {\n+      if (TARGET_MIPS16\n+\t  && REGNO (reg) != GP_REG_FIRST + 31\n+\t  && !M16_REG_P (REGNO (reg)))\n+\t{\n+\t  /* Save a non-mips16 register by moving it through a temporary.\n+\t     We don't need to do this for $31 since there's a special\n+\t     instruction for it.  */\n+\t  emit_move_insn (MIPS_PROLOGUE_TEMP (GET_MODE (reg)), reg);\n+\t  emit_move_insn (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n+\t}\n+      else\n+\temit_move_insn (mem, reg);\n+\n+      mips_set_frame_expr (mips_frame_set (mem, reg));\n+    }\n+}\n+\n+\n /* Emit an instruction to move SRC into DEST.  When generating\n    explicit reloc code, mark the instruction as potentially dead.  */\n \n@@ -6648,126 +6497,102 @@ mips_gp_insn (rtx dest, rtx src)\n void\n mips_expand_prologue (void)\n {\n-  HOST_WIDE_INT tsize;\n-  rtx tmp_rtx = 0;\n+  HOST_WIDE_INT size;\n \n   if (cfun->machine->global_pointer > 0)\n     REGNO (pic_offset_table_rtx) = cfun->machine->global_pointer;\n \n-  tsize = compute_frame_size (get_frame_size ());\n+  size = compute_frame_size (get_frame_size ());\n \n-  if (tsize > 0)\n+  /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP\n+     bytes beforehand; this is enough to cover the register save area\n+     without going out of range.  */\n+  if ((cfun->machine->frame.mask | cfun->machine->frame.fmask) != 0)\n     {\n-      rtx tsize_rtx = GEN_INT (tsize);\n+      HOST_WIDE_INT step1;\n \n-      /* In mips16 mode with a large frame, we save the registers before\n-         adjusting the stack.  */\n-      if (!TARGET_MIPS16 || tsize <= 32768)\n+      step1 = MIN (size, MIPS_MAX_FIRST_STACK_STEP);\n+      RTX_FRAME_RELATED_P (emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t\t     GEN_INT (-step1)))) = 1;\n+      size -= step1;\n+      mips_for_each_saved_reg (size, mips_save_reg);\n+    }\n+\n+  /* Allocate the rest of the frame.  */\n+  if (size > 0)\n+    {\n+      if (SMALL_OPERAND (-size))\n+\tRTX_FRAME_RELATED_P (emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t\t       GEN_INT (-size)))) = 1;\n+      else\n \t{\n-\t  if (tsize > 32768)\n+\t  emit_move_insn (MIPS_PROLOGUE_TEMP (Pmode), GEN_INT (size));\n+\t  if (TARGET_MIPS16)\n \t    {\n-\t      rtx adjustment_rtx;\n+\t      /* There are no instructions to add or subtract registers\n+\t\t from the stack pointer, so use the frame pointer as a\n+\t\t temporary.  We should always be using a frame pointer\n+\t\t in this case anyway.  */\n+\t      if (!frame_pointer_needed)\n+\t\tabort ();\n \n-\t      adjustment_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n-\t      emit_move_insn (adjustment_rtx, tsize_rtx);\n-\t      emit_insn (gen_sub3_insn (stack_pointer_rtx,\n-\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\tadjustment_rtx));\n+\t      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t      emit_insn (gen_sub3_insn (hard_frame_pointer_rtx,\n+\t\t\t\t\thard_frame_pointer_rtx,\n+\t\t\t\t\tMIPS_PROLOGUE_TEMP (Pmode)));\n+\t      emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n \t    }\n \t  else\n-\t    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t    emit_insn (gen_sub3_insn (stack_pointer_rtx,\n \t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t      GEN_INT (-tsize)));\n+\t\t\t\t      MIPS_PROLOGUE_TEMP (Pmode)));\n \n+\t  /* Describe the combined effect of the previous instructions.  */\n \t  mips_set_frame_expr\n \t    (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t  plus_constant (stack_pointer_rtx, -tsize)));\n+\t\t\t  plus_constant (stack_pointer_rtx, -size)));\n \t}\n+    }\n \n-      save_restore_insns (1, tmp_rtx, tsize);\n-\n-      if (TARGET_ABICALLS && !TARGET_NEWABI && !current_function_is_leaf)\n-\temit_insn (gen_cprestore\n-\t\t   (GEN_INT (current_function_outgoing_args_size)));\n-\n-      if (TARGET_MIPS16 && tsize > 32768)\n+  /* Set up the frame pointer, if we're using one.  In mips16 code,\n+     we point the frame pointer ahead of the outgoing argument area.\n+     This should allow more variables & incoming arguments to be\n+     acceesed with unextended instructions.  */\n+  if (frame_pointer_needed)\n+    {\n+      if (TARGET_MIPS16 && current_function_outgoing_args_size != 0)\n \t{\n-\t  rtx reg_rtx;\n-\n-\t  if (!frame_pointer_needed)\n-\t    abort ();\n-\n-\t  reg_rtx = gen_rtx (REG, Pmode, 3);\n-  \t  emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n-  \t  emit_move_insn (reg_rtx, tsize_rtx);\n-\t  emit_insn (gen_sub3_insn (hard_frame_pointer_rtx,\n-\t\t\t\t    hard_frame_pointer_rtx,\n-\t\t\t\t    reg_rtx));\n-\t  emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n-\t}\n-\n-      if (frame_pointer_needed)\n-\t{\n-          rtx insn = 0;\n-\n-\t  /* On the mips16, we encourage the use of unextended\n-             instructions when using the frame pointer by pointing the\n-             frame pointer ahead of the argument space allocated on\n-             the stack.  */\n-\t  if (TARGET_MIPS16 && tsize > 32767)\n-\t    {\n-\t      /* In this case, we have already copied the stack\n-                 pointer into the frame pointer, above.  We need only\n-                 adjust for the outgoing argument size.  */\n-\t      if (current_function_outgoing_args_size != 0)\n-\t\t{\n-\t\t  rtx incr = GEN_INT (current_function_outgoing_args_size);\n-\t\t  if (Pmode == DImode)\n-\t\t    insn = emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-                                                  hard_frame_pointer_rtx,\n-                                                  incr));\n-\t\t  else\n-\t\t    insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n-                                                  hard_frame_pointer_rtx,\n-                                                  incr));\n-\t\t}\n-\t    }\n-\t  else if (TARGET_MIPS16 && current_function_outgoing_args_size != 0)\n-\t    {\n-\t      rtx incr = GEN_INT (current_function_outgoing_args_size);\n-\t      if (Pmode == DImode)\n-\t\tinsn = emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-                                              stack_pointer_rtx,\n-                                              incr));\n-\t      else\n-\t\tinsn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n-                                              stack_pointer_rtx,\n-                                              incr));\n-\t    }\n-\t  else if (Pmode == DImode)\n-\t    insn = emit_insn (gen_movdi (hard_frame_pointer_rtx,\n-\t\t\t\t\t stack_pointer_rtx));\n-\t  else\n-\t    insn = emit_insn (gen_movsi (hard_frame_pointer_rtx,\n-\t\t\t\t\t stack_pointer_rtx));\n-\n-\t  if (insn)\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t  rtx offset = GEN_INT (current_function_outgoing_args_size);\n+\t  RTX_FRAME_RELATED_P\n+\t    (emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n+\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t       offset))) = 1;\n \t}\n+      else\n+\tRTX_FRAME_RELATED_P (emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t\t\t     stack_pointer_rtx)) = 1;\n     }\n \n+  /* If generating o32/o64 abicalls, save $gp on the stack.  */\n+  if (TARGET_ABICALLS && !TARGET_NEWABI && !current_function_is_leaf)\n+    emit_insn (gen_cprestore (GEN_INT (current_function_outgoing_args_size)));\n+\n+  /* If generating n32/n64 abicalls, emit the instructions to load $gp.  */\n   if (TARGET_ABICALLS && TARGET_NEWABI && cfun->machine->global_pointer > 0)\n     {\n-      rtx temp, fnsymbol, fnaddr;\n+      rtx fnsymbol, fnaddr;\n \n-      temp = gen_rtx_REG (Pmode, MIPS_TEMP1_REGNUM);\n       fnsymbol = XEXP (DECL_RTL (current_function_decl), 0);\n       fnaddr = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n \n-      mips_gp_insn (temp, mips_lui_reloc (fnsymbol, RELOC_LOADGP_HI));\n-      mips_gp_insn (temp, gen_rtx_PLUS (Pmode, temp, fnaddr));\n+      mips_gp_insn (MIPS_PROLOGUE_TEMP (Pmode),\n+\t\t    mips_lui_reloc (fnsymbol, RELOC_LOADGP_HI));\n+      mips_gp_insn (MIPS_PROLOGUE_TEMP (Pmode),\n+\t\t    gen_rtx_PLUS (Pmode, MIPS_PROLOGUE_TEMP (Pmode), fnaddr));\n       mips_gp_insn (pic_offset_table_rtx,\n-\t\t    gen_rtx_PLUS (Pmode, temp,\n+\t\t    gen_rtx_PLUS (Pmode, MIPS_PROLOGUE_TEMP (Pmode),\n \t\t\t\t  mips_reloc (fnsymbol, RELOC_LOADGP_LO)));\n \n       if (!TARGET_EXPLICIT_RELOCS)\n@@ -6840,139 +6665,129 @@ mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n   REGNO (pic_offset_table_rtx) = GLOBAL_POINTER_REGNUM;\n }\n \f\n+/* Emit instructions to restore register REG from slot MEM.  */\n+\n+static void\n+mips_restore_reg (rtx reg, rtx mem)\n+{\n+  /* There's no mips16 instruction to load $31 directly.  Load into\n+     $7 instead and adjust the return insn appropriately.  */\n+  if (TARGET_MIPS16 && REGNO (reg) == GP_REG_FIRST + 31)\n+    reg = gen_rtx_REG (GET_MODE (reg), 7);\n+\n+  if (TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))\n+    {\n+      /* Can't restore directly; move through a temporary.  */\n+      emit_move_insn (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);\n+      emit_move_insn (reg, MIPS_EPILOGUE_TEMP (GET_MODE (reg)));\n+    }\n+  else\n+    emit_move_insn (reg, mem);\n+}\n+\n+\n /* Expand the epilogue into a bunch of separate insns.  SIBCALL_P is true\n    if this epilogue precedes a sibling call, false if it is for a normal\n    \"epilogue\" pattern.  */\n \n void\n mips_expand_epilogue (int sibcall_p)\n {\n-  HOST_WIDE_INT tsize = cfun->machine->frame.total_size;\n-  rtx tsize_rtx = GEN_INT (tsize);\n-  rtx tmp_rtx = (rtx)0;\n+  HOST_WIDE_INT step1, step2;\n+  rtx base, target;\n \n   if (!sibcall_p && mips_can_use_return_insn ())\n     {\n       emit_jump_insn (gen_return ());\n       return;\n     }\n \n-  if (tsize > 32767 && ! TARGET_MIPS16)\n+  /* Split the frame into two.  STEP1 is the amount of stack we should\n+     deallocate before restoring the registers.  STEP2 is the amount we\n+     should deallocate afterwards.\n+\n+     Start off by assuming that no registers need to be restored.  */\n+  step1 = cfun->machine->frame.total_size;\n+  step2 = 0;\n+\n+  /* Work out which register holds the frame address.  Account for the\n+     frame pointer offset used by mips16 code.  */\n+  if (!frame_pointer_needed)\n+    base = stack_pointer_rtx;\n+  else\n     {\n-      tmp_rtx = gen_rtx_REG (Pmode, MIPS_TEMP1_REGNUM);\n-      emit_move_insn (tmp_rtx, tsize_rtx);\n-      tsize_rtx = tmp_rtx;\n+      base = hard_frame_pointer_rtx;\n+      if (TARGET_MIPS16)\n+\tstep1 -= current_function_outgoing_args_size;\n     }\n \n-  if (tsize > 0)\n+  /* If we need to restore registers, deallocate as much stack as\n+     possible in the second step without going out of range.  */\n+  if ((cfun->machine->frame.mask | cfun->machine->frame.fmask) != 0)\n     {\n-      long orig_tsize = tsize;\n-\n-      if (frame_pointer_needed)\n-\t{\n-\t  emit_insn (gen_blockage ());\n-\n-\t  /* On the mips16, the frame pointer is offset from the stack\n-             pointer by current_function_outgoing_args_size.  We\n-             account for that by changing tsize.  Note that this can\n-             actually make tsize negative.  */\n-\t  if (TARGET_MIPS16)\n-\t    {\n-\t      tsize -= current_function_outgoing_args_size;\n-\n-\t      /* If we have a large frame, it's easier to add to $6\n-                 than to $sp, since the mips16 has no instruction to\n-                 add a register to $sp.  */\n-\t      if (orig_tsize > 32767)\n-\t\t{\n-\t\t  rtx g6_rtx = gen_rtx (REG, Pmode, GP_REG_FIRST + 6);\n-\n-\t\t  emit_move_insn (g6_rtx, GEN_INT (tsize));\n-\t\t  if (Pmode == DImode)\n-\t\t    emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-\t\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t\t   g6_rtx));\n-\t\t  else\n-\t\t    emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n-\t\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t\t   g6_rtx));\n-\t\t  tsize = 0;\n-\t\t}\n-\n-\t      if (tsize && tsize != orig_tsize)\n-\t\ttsize_rtx = GEN_INT (tsize);\n-\t    }\n-\n-\t  if (Pmode == DImode)\n-\t    emit_insn (gen_movdi (stack_pointer_rtx, hard_frame_pointer_rtx));\n-\t  else\n-\t    emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));\n-\t}\n+      step2 = MIN (step1, MIPS_MAX_FIRST_STACK_STEP);\n+      step1 -= step2;\n+    }\n \n-      /* The GP/PIC register is implicitly used by all SYMBOL_REFs, so if we\n-\t are going to restore it, then we must emit a blockage insn to\n-\t prevent the scheduler from moving the restore out of the epilogue.  */\n-      else if (TARGET_ABICALLS && mips_abi != ABI_32 && mips_abi != ABI_O64\n-\t       && (cfun->machine->frame.mask\n-\t\t   & (1L << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))))\n-\temit_insn (gen_blockage ());\n-\n-      save_restore_insns (0, tmp_rtx, orig_tsize);\n-\n-      /* In mips16 mode with a large frame, we adjust the stack\n-         pointer before restoring the registers.  In this case, we\n-         should always be using a frame pointer, so everything should\n-         have been handled above.  */\n-      if (tsize > 32767 && TARGET_MIPS16)\n-\tabort ();\n+  /* Set TARGET to BASE + STEP1.  */\n+  target = base;\n+  if (step1 > 0)\n+    {\n+      rtx adjust;\n \n-      if (current_function_calls_eh_return)\n+      /* Get an rtx for STEP1 that we can add to BASE.  */\n+      adjust = GEN_INT (step1);\n+      if (!SMALL_OPERAND (step1))\n \t{\n-\t  rtx eh_ofs = EH_RETURN_STACKADJ_RTX;\n-\t  if (Pmode == DImode)\n-\t    emit_insn (gen_adddi3 (eh_ofs, eh_ofs, tsize_rtx));\n-\t  else\n-\t    emit_insn (gen_addsi3 (eh_ofs, eh_ofs, tsize_rtx));\n-\t  tsize_rtx = eh_ofs;\n+\t  emit_move_insn (MIPS_EPILOGUE_TEMP (Pmode), adjust);\n+\t  adjust = MIPS_EPILOGUE_TEMP (Pmode);\n \t}\n \n-      emit_insn (gen_blockage ());\n+      /* Normal mode code can copy the result straight into $sp.  */\n+      if (!TARGET_MIPS16)\n+\ttarget = stack_pointer_rtx;\n \n-      if (tsize != 0 || current_function_calls_eh_return)\n-\t{\n-\t  if (!TARGET_MIPS16 || !current_function_calls_eh_return)\n-\t    {\n-\t      if (Pmode == DImode)\n-\t\temit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t       tsize_rtx));\n-\t      else\n-\t\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t       tsize_rtx));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We need to work around not being able to add a register\n-\t\t to the stack pointer directly. Use register $6 as an\n-\t\t intermediate step.  */\n+      emit_insn (gen_add3_insn (target, base, adjust));\n+    }\n \n-\t      rtx g6_rtx = gen_rtx (REG, Pmode, GP_REG_FIRST + 6);\n+  /* Copy TARGET into the stack pointer.  */\n+  if (target != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, target);\n \n-\t      if (Pmode == DImode)\n-\t\t{\n-\t\t  emit_insn (gen_movdi (g6_rtx, stack_pointer_rtx));\n-\t\t  emit_insn (gen_adddi3 (g6_rtx, g6_rtx, tsize_rtx));\n-\t\t  emit_insn (gen_movdi (stack_pointer_rtx, g6_rtx));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  emit_insn (gen_movsi (g6_rtx, stack_pointer_rtx));\n-\t\t  emit_insn (gen_addsi3 (g6_rtx, g6_rtx, tsize_rtx));\n-\t\t  emit_insn (gen_movsi (stack_pointer_rtx, g6_rtx));\n-\t\t}\n-\t    }\n+  /* If we're using addressing macros for n32/n64 abicalls, $gp is\n+     implicitly used by all SYMBOL_REFs.  We must emit a blockage\n+     insn before restoring it.  */\n+  if (TARGET_ABICALLS && TARGET_NEWABI && !TARGET_EXPLICIT_RELOCS)\n+    emit_insn (gen_blockage ());\n \n+  /* Restore the registers.  */\n+  mips_for_each_saved_reg (cfun->machine->frame.total_size - step2,\n+\t\t\t   mips_restore_reg);\n+\n+  /* Deallocate the final bit of the frame.  */\n+  if (step2 > 0)\n+    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t      stack_pointer_rtx,\n+\t\t\t      GEN_INT (step2)));\n+    \n+  /* Add in the __builtin_eh_return stack adjustment.   We need to\n+     use a temporary in mips16 code.  */\n+  if (current_function_calls_eh_return)\n+    {\n+      if (TARGET_MIPS16)\n+\t{\n+\t  emit_move_insn (MIPS_EPILOGUE_TEMP (Pmode), stack_pointer_rtx);\n+\t  emit_insn (gen_add3_insn (MIPS_EPILOGUE_TEMP (Pmode),\n+\t\t\t\t    MIPS_EPILOGUE_TEMP (Pmode),\n+\t\t\t\t    EH_RETURN_STACKADJ_RTX));\n+\t  emit_move_insn (stack_pointer_rtx, MIPS_EPILOGUE_TEMP (Pmode));\n \t}\n+      else\n+\temit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  EH_RETURN_STACKADJ_RTX));\n     }\n+\n   if (!sibcall_p)\n     {\n       /* The mips16 loads the return address into $7, not $31.  */"}, {"sha": "b3de61ee71cafafb589779c955132744635294de", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7630230540a61c7e9db3d922acc6680e89e7d2/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7630230540a61c7e9db3d922acc6680e89e7d2/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=be7630230540a61c7e9db3d922acc6680e89e7d2", "patch": "@@ -1674,15 +1674,18 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* Pass structure addresses as an \"invisible\" first argument.  */\n #define STRUCT_VALUE 0\n \n-/* Mips registers used in prologue/epilogue code when the stack frame\n-   is larger than 32K bytes.  These registers must come from the\n-   scratch register set, and not used for passing and returning\n-   arguments and any other information used in the calling sequence\n-   (such as pic).  Must start at 12, since t0/t3 are parameter passing\n-   registers in the 64 bit ABI.  */\n-\n-#define MIPS_TEMP1_REGNUM (GP_REG_FIRST + 12)\n-#define MIPS_TEMP2_REGNUM (GP_REG_FIRST + 13)\n+/* Registers used as temporaries in prologue/epilogue code.  If we're\n+   generating mips16 code, these registers must come from the core set\n+   of 8.  The prologue register mustn't conflict with any incoming\n+   arguments, the static chain pointer, or the frame pointer.  The\n+   epilogue temporary mustn't conflict with the return registers, the\n+   frame pointer, the EH stack adjustment, or the EH data registers.  */\n+\n+#define MIPS_PROLOGUE_TEMP_REGNUM (GP_REG_FIRST + 3)\n+#define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))\n+\n+#define MIPS_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, MIPS_PROLOGUE_TEMP_REGNUM)\n+#define MIPS_EPILOGUE_TEMP(MODE) gen_rtx_REG (MODE, MIPS_EPILOGUE_TEMP_REGNUM)\n \n /* Define this macro if it is as good or better to call a constant\n    function address than to call an address kept in a register.  */"}]}