{"sha": "f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRiMzE2NDcwYmY3Y2NjYWIyMmZiYjk3ZDFiNmM1NDFmY2ZjMjg1NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-05T19:57:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-05T19:57:01Z"}, "message": "Make more use of int_mode_for_size\n\nThis patch converts more places that could use int_mode_for_size instead\nof mode_for_size.  This is in preparation for an upcoming patch that\nmakes mode_for_size itself return an opt_mode.\n\nrequire () seems like the right choice in expand_builtin_powi\nbecause we have got past the point of backing out.  We go on to do:\n\n  op1 = expand_expr (arg1, NULL_RTX, mode2, EXPAND_NORMAL);\n  if (GET_MODE (op1) != mode2)\n    op1 = convert_to_mode (mode2, op1, 0);\n\nwhich would be invalid for (and have failed for) BLKmode.\n\nIn get_builtin_sync_mode and expand_ifn_atomic_compare_exchange,\nthe possible bitsizes are {8, 16, 32, 64, 128}, all of which give\ntarget-independent integer modes (up to TImode).  The comment above\nthe call in get_builtin_sync_mode makes clear that an integer mode\nmust be found.\n\nWe can use require () in expand_builtin_atomic_clear and\nexpand_builtin_atomic_test_and_set because there's always an integer\nmode for the boolean type.  The same goes for the POINTER_SIZE request\nin layout_type.  Similarly we can use require () in combine_instructions\nand gen_lowpart_common because there's always an integer mode for\nHOST_BITS_PER_WIDE_INT (DImode when BITS_PER_UNIT == 8), and\nHOST_BITS_PER_DOUBLE_INT (TImode).\n\nThe calls in aarch64_function_value, arm_function_value,\naapcs_allocate_return_reg and mips_function_value_1 are handling\ncases in which a big-endian target passes or returns values at\nthe most significant end of a register.  In each case the ABI\nconstrains the size to a small amount and does not handle\nnon-power-of-2 sizes wider than a word.\n\nThe calls in c6x_expand_movmem, i386.c:emit_memset,\nlm32_block_move_inline, microblaze_block_move_straight and\nmips_block_move_straight are dealing with expansions of\nblock memory operations using register-wise operations,\nand those registers must have non-BLK mode.\n\nThe reason for using require () in ix86_expand_sse_cmp,\nmips_expand_ins_as_unaligned_store, spu.c:adjust_operand and\nspu_emit_branch_and_set is that we go on to emit non-call\ninstructions that use registers of that mode, which wouldn't\nbe valid for BLKmode.\n\n2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* builtins.c (expand_builtin_powi): Use int_mode_for_size.\n\t(get_builtin_sync_mode): Likewise.\n\t(expand_ifn_atomic_compare_exchange): Likewise.\n\t(expand_builtin_atomic_clear): Likewise.\n\t(expand_builtin_atomic_test_and_set): Likewise.\n\t(fold_builtin_atomic_always_lock_free): Likewise.\n\t* calls.c (compute_argument_addresses): Likewise.\n\t(emit_library_call_value_1): Likewise.\n\t(store_one_arg): Likewise.\n\t* combine.c (combine_instructions): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_function_value): Likewise.\n\t* config/arm/arm.c (arm_function_value): Likewise.\n\t(aapcs_allocate_return_reg): Likewise.\n\t* config/c6x/c6x.c (c6x_expand_movmem): Likewise.\n\t* config/i386/i386.c (construct_container): Likewise.\n\t(ix86_gimplify_va_arg): Likewise.\n\t(ix86_expand_sse_cmp): Likewise.\n\t(emit_memmov): Likewise.\n\t(emit_memset): Likewise.\n\t(expand_small_movmem_or_setmem): Likewise.\n\t(ix86_expand_pextr): Likewise.\n\t(ix86_expand_pinsr): Likewise.\n\t* config/lm32/lm32.c (lm32_block_move_inline): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_block_move_straight):\n\tLikewise.\n\t* config/mips/mips.c (mips_function_value_1) Likewise.\n\t(mips_block_move_straight): Likewise.\n\t(mips_expand_ins_as_unaligned_store): Likewise.\n\t* config/powerpcspe/powerpcspe.c\n\t(rs6000_darwin64_record_arg_advance_flush): Likewise.\n\t(rs6000_darwin64_record_arg_flush): Likewise.\n\t* config/rs6000/rs6000.c\n\t(rs6000_darwin64_record_arg_advance_flush): Likewise.\n\t(rs6000_darwin64_record_arg_flush): Likewise.\n\t* config/sparc/sparc.c (sparc_function_arg_1): Likewise.\n\t(sparc_function_value_1): Likewise.\n\t* config/spu/spu.c (adjust_operand): Likewise.\n\t(spu_emit_branch_or_set): Likewise.\n\t(arith_immediate_p): Likewise.\n\t* emit-rtl.c (gen_lowpart_common): Likewise.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t* function.c (assign_parm_setup_block): Likewise.\n\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Likewise.\n\t* reload1.c (alter_reg): Likewise.\n\t* stor-layout.c (mode_for_vector): Likewise.\n\t(layout_type): Likewise.\n\ngcc/ada/\n\t* gcc-interface/utils2.c (build_load_modify_store):\n\tUse int_mode_for_size.\n\nFrom-SVN: r251726", "tree": {"sha": "1748d5d00e74e2cc0822a013b07953ae10671f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1748d5d00e74e2cc0822a013b07953ae10671f16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/comments", "author": null, "committer": null, "parents": [{"sha": "636bfdfaa1b466c5699e8e3c5d46a4f94c9b845c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636bfdfaa1b466c5699e8e3c5d46a4f94c9b845c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636bfdfaa1b466c5699e8e3c5d46a4f94c9b845c"}], "stats": {"total": 221, "additions": 140, "deletions": 81}, "files": [{"sha": "8105f3d3ef3edc9211dd2990f633f74aca35f456", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -1,3 +1,52 @@\n+2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* builtins.c (expand_builtin_powi): Use int_mode_for_size.\n+\t(get_builtin_sync_mode): Likewise.\n+\t(expand_ifn_atomic_compare_exchange): Likewise.\n+\t(expand_builtin_atomic_clear): Likewise.\n+\t(expand_builtin_atomic_test_and_set): Likewise.\n+\t(fold_builtin_atomic_always_lock_free): Likewise.\n+\t* calls.c (compute_argument_addresses): Likewise.\n+\t(emit_library_call_value_1): Likewise.\n+\t(store_one_arg): Likewise.\n+\t* combine.c (combine_instructions): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_function_value): Likewise.\n+\t* config/arm/arm.c (arm_function_value): Likewise.\n+\t(aapcs_allocate_return_reg): Likewise.\n+\t* config/c6x/c6x.c (c6x_expand_movmem): Likewise.\n+\t* config/i386/i386.c (construct_container): Likewise.\n+\t(ix86_gimplify_va_arg): Likewise.\n+\t(ix86_expand_sse_cmp): Likewise.\n+\t(emit_memmov): Likewise.\n+\t(emit_memset): Likewise.\n+\t(expand_small_movmem_or_setmem): Likewise.\n+\t(ix86_expand_pextr): Likewise.\n+\t(ix86_expand_pinsr): Likewise.\n+\t* config/lm32/lm32.c (lm32_block_move_inline): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_block_move_straight):\n+\tLikewise.\n+\t* config/mips/mips.c (mips_function_value_1) Likewise.\n+\t(mips_block_move_straight): Likewise.\n+\t(mips_expand_ins_as_unaligned_store): Likewise.\n+\t* config/powerpcspe/powerpcspe.c\n+\t(rs6000_darwin64_record_arg_advance_flush): Likewise.\n+\t(rs6000_darwin64_record_arg_flush): Likewise.\n+\t* config/rs6000/rs6000.c\n+\t(rs6000_darwin64_record_arg_advance_flush): Likewise.\n+\t(rs6000_darwin64_record_arg_flush): Likewise.\n+\t* config/sparc/sparc.c (sparc_function_arg_1): Likewise.\n+\t(sparc_function_value_1): Likewise.\n+\t* config/spu/spu.c (adjust_operand): Likewise.\n+\t(spu_emit_branch_or_set): Likewise.\n+\t(arith_immediate_p): Likewise.\n+\t* emit-rtl.c (gen_lowpart_common): Likewise.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* function.c (assign_parm_setup_block): Likewise.\n+\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Likewise.\n+\t* reload1.c (alter_reg): Likewise.\n+\t* stor-layout.c (mode_for_vector): Likewise.\n+\t(layout_type): Likewise.\n+\n 2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/spu/spu.c (exp2_immediate_p): Use int_mode_for_mode."}, {"sha": "ce3d6fed1bf1962fdd168d9ce16923751f8d4894", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -1,3 +1,8 @@\n+2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc-interface/utils2.c (build_load_modify_store):\n+\tUse int_mode_for_size.\n+\n 2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/62235"}, {"sha": "543b5398941d3ba53a7aaf40836ad1045ec4468a", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -800,7 +800,8 @@ build_load_modify_store (tree dest, tree src, Node_Id gnat_node)\n \t\t{\n \t\t  unsigned int size = tree_to_uhwi (TYPE_SIZE (type));\n \t\t  type = copy_type (type);\n-\t\t  SET_TYPE_MODE (type, mode_for_size (size, MODE_INT, 0));\n+\t\t  machine_mode mode = int_mode_for_size (size, 0).else_blk ();\n+\t\t  SET_TYPE_MODE (type, mode);\n \t\t}\n \n \t      /* Create the temporary by inserting a SAVE_EXPR.  */"}, {"sha": "c8a5ea62611cb9cba811a6cfa5f2847bd6dad51b", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -2755,7 +2755,7 @@ expand_builtin_powi (tree exp, rtx target)\n   /* Emit a libcall to libgcc.  */\n \n   /* Mode of the 2nd argument must match that of an int.  */\n-  mode2 = mode_for_size (INT_TYPE_SIZE, MODE_INT, 0);\n+  mode2 = int_mode_for_size (INT_TYPE_SIZE, 0).require ();\n \n   if (target == NULL_RTX)\n     target = gen_reg_rtx (mode);\n@@ -5477,7 +5477,7 @@ get_builtin_sync_mode (int fcode_diff)\n {\n   /* The size is not negotiable, so ask not to get BLKmode in return\n      if the target indicates that a smaller size would be better.  */\n-  return mode_for_size (BITS_PER_UNIT << fcode_diff, MODE_INT, 0);\n+  return int_mode_for_size (BITS_PER_UNIT << fcode_diff, 0).require ();\n }\n \n /* Expand the memory expression LOC and return the appropriate memory operand\n@@ -5858,7 +5858,7 @@ expand_ifn_atomic_compare_exchange (gcall *call)\n {\n   int size = tree_to_shwi (gimple_call_arg (call, 3)) & 255;\n   gcc_assert (size == 1 || size == 2 || size == 4 || size == 8 || size == 16);\n-  machine_mode mode = mode_for_size (BITS_PER_UNIT * size, MODE_INT, 0);\n+  machine_mode mode = int_mode_for_size (BITS_PER_UNIT * size, 0).require ();\n   rtx expect, desired, mem, oldval, boolret;\n   enum memmodel success, failure;\n   tree lhs;\n@@ -6154,7 +6154,7 @@ expand_builtin_atomic_clear (tree exp)\n   rtx mem, ret;\n   enum memmodel model;\n \n-  mode = mode_for_size (BOOL_TYPE_SIZE, MODE_INT, 0);\n+  mode = int_mode_for_size (BOOL_TYPE_SIZE, 0).require ();\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n \n@@ -6189,7 +6189,7 @@ expand_builtin_atomic_test_and_set (tree exp, rtx target)\n   enum memmodel model;\n   machine_mode mode;\n \n-  mode = mode_for_size (BOOL_TYPE_SIZE, MODE_INT, 0);\n+  mode = int_mode_for_size (BOOL_TYPE_SIZE, 0).require ();\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n \n@@ -6210,8 +6210,11 @@ fold_builtin_atomic_always_lock_free (tree arg0, tree arg1)\n   if (TREE_CODE (arg0) != INTEGER_CST)\n     return NULL_TREE;\n \n+  /* We need a corresponding integer mode for the access to be lock-free.  */\n   size = INTVAL (expand_normal (arg0)) * BITS_PER_UNIT;\n-  mode = mode_for_size (size, MODE_INT, 0);\n+  if (!int_mode_for_size (size, 0).exists (&mode))\n+    return boolean_false_node;\n+\n   mode_align = GET_MODE_ALIGNMENT (mode);\n \n   if (TREE_CODE (arg1) == INTEGER_CST)"}, {"sha": "a4271bb6ab73788728a463b3361e37f0ca35eb6d", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -2209,8 +2209,8 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t      /* Only part of the parameter is being passed on the stack.\n \t\t Generate a simple memory reference of the correct size.  */\n \t      units_on_stack = args[i].locate.size.constant;\n-\t      partial_mode = mode_for_size (units_on_stack * BITS_PER_UNIT,\n-\t\t\t\t\t    MODE_INT, 1);\n+\t      unsigned int bits_on_stack = units_on_stack * BITS_PER_UNIT;\n+\t      partial_mode = int_mode_for_size (bits_on_stack, 1).else_blk ();\n \t      args[i].stack = gen_rtx_MEM (partial_mode, addr);\n \t      set_mem_size (args[i].stack, units_on_stack);\n \t    }\n@@ -4818,7 +4818,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t  unsigned int size\n \t\t    = argvec[argnum].locate.size.constant * BITS_PER_UNIT;\n \t\t  machine_mode save_mode\n-\t\t    = mode_for_size (size, MODE_INT, 1);\n+\t\t    = int_mode_for_size (size, 1).else_blk ();\n \t\t  rtx adr\n \t\t    = plus_constant (Pmode, argblock,\n \t\t\t\t     argvec[argnum].locate.offset.constant);\n@@ -5271,7 +5271,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t    {\n \t      /* We need to make a save area.  */\n \t      unsigned int size = arg->locate.size.constant * BITS_PER_UNIT;\n-\t      machine_mode save_mode = mode_for_size (size, MODE_INT, 1);\n+\t      machine_mode save_mode\n+\t\t= int_mode_for_size (size, 1).else_blk ();\n \t      rtx adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));\n \t      rtx stack_area = gen_rtx_MEM (save_mode, adr);\n "}, {"sha": "89e8eee36e5e1171af4283d7bec4b7b462de5df8", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -370,7 +370,7 @@ static int label_tick_ebb_start;\n /* Mode used to compute significance in reg_stat[].nonzero_bits.  It is the\n    largest integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n-static machine_mode nonzero_bits_mode;\n+static scalar_int_mode nonzero_bits_mode;\n \n /* Nonzero when reg_stat[].nonzero_bits and reg_stat[].sign_bit_copies can\n    be safely used.  It is zero while computing them and after combine has\n@@ -1157,7 +1157,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n   uid_insn_cost = XCNEWVEC (int, max_uid_known + 1);\n   gcc_obstack_init (&insn_link_obstack);\n \n-  nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n+  nonzero_bits_mode = int_mode_for_size (HOST_BITS_PER_WIDE_INT, 0).require ();\n \n   /* Don't use reg_stat[].nonzero_bits when computing it.  This can cause\n      problems when, for example, we have j <<= 1 in a loop.  */"}, {"sha": "d766307e6509d4575ee50f5c8db3486529d122e8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -2235,7 +2235,7 @@ aarch64_function_value (const_tree type, const_tree func,\n       if (size % UNITS_PER_WORD != 0)\n \t{\n \t  size += UNITS_PER_WORD - size % UNITS_PER_WORD;\n-\t  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\t  mode = int_mode_for_size (size * BITS_PER_UNIT, 0).require ();\n \t}\n     }\n "}, {"sha": "f0e7788a53f0fe1a0eca781a3bf6fcf31e95846e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -5350,7 +5350,7 @@ arm_function_value(const_tree type, const_tree func,\n       if (size % UNITS_PER_WORD != 0)\n \t{\n \t  size += UNITS_PER_WORD - size % UNITS_PER_WORD;\n-\t  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\t  mode = int_mode_for_size (size * BITS_PER_UNIT, 0).require ();\n \t}\n     }\n \n@@ -6307,7 +6307,7 @@ aapcs_allocate_return_reg (machine_mode mode, const_tree type,\n       if (size % UNITS_PER_WORD != 0)\n \t{\n \t  size += UNITS_PER_WORD - size % UNITS_PER_WORD;\n-\t  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\t  mode = int_mode_for_size (size * BITS_PER_UNIT, 0).require ();\n \t}\n     }\n "}, {"sha": "c5b1679c5475c52a5addf2139599d189b2549796", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -1758,8 +1758,8 @@ c6x_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       if (dst_size > src_size)\n \tdst_size = src_size;\n \n-      srcmode = mode_for_size (src_size * BITS_PER_UNIT, MODE_INT, 0);\n-      dstmode = mode_for_size (dst_size * BITS_PER_UNIT, MODE_INT, 0);\n+      srcmode = int_mode_for_size (src_size * BITS_PER_UNIT, 0).require ();\n+      dstmode = int_mode_for_size (dst_size * BITS_PER_UNIT, 0).require ();\n       if (src_size >= 4)\n \treg_lowpart = reg = gen_reg_rtx (srcmode);\n       else"}, {"sha": "9ceba8088d5833401562284ed3c3a86c375bbdca", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -9892,16 +9892,17 @@ construct_container (machine_mode mode, machine_mode orig_mode,\n \t  case X86_64_INTEGERSI_CLASS:\n \t    /* Merge TImodes on aligned occasions here too.  */\n \t    if (i * 8 + 8 > bytes)\n-\t      tmpmode\n-\t\t= mode_for_size ((bytes - i * 8) * BITS_PER_UNIT, MODE_INT, 0);\n+\t      {\n+\t\tunsigned int tmpbits = (bytes - i * 8) * BITS_PER_UNIT;\n+\t\tif (!int_mode_for_size (tmpbits, 0).exists (&tmpmode))\n+\t\t  /* We've requested 24 bytes we\n+\t\t     don't have mode for.  Use DImode.  */\n+\t\t  tmpmode = DImode;\n+\t      }\n \t    else if (regclass[i] == X86_64_INTEGERSI_CLASS)\n \t      tmpmode = SImode;\n \t    else\n \t      tmpmode = DImode;\n-\t    /* We've requested 24 bytes we\n-\t       don't have mode for.  Use DImode.  */\n-\t    if (tmpmode == BLKmode)\n-\t      tmpmode = DImode;\n \t    exp [nexps++]\n \t      = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t   gen_rtx_REG (tmpmode, *intreg),\n@@ -11880,8 +11881,8 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t      if (prev_size + cur_size > size)\n \t\t{\n \t\t  cur_size = size - prev_size;\n-\t\t  mode = mode_for_size (cur_size * BITS_PER_UNIT, MODE_INT, 1);\n-\t\t  if (mode == BLKmode)\n+\t\t  unsigned int nbits = cur_size * BITS_PER_UNIT;\n+\t\t  if (!int_mode_for_size (nbits, 1).exists (&mode))\n \t\t    mode = QImode;\n \t\t}\n \t      piece_type = lang_hooks.types.type_for_mode (mode, 1);\n@@ -24923,9 +24924,8 @@ ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n \n   if (GET_MODE_SIZE (cmp_ops_mode) == 64)\n     {\n-      cmp_mode = mode_for_size (GET_MODE_NUNITS (cmp_ops_mode), MODE_INT, 0);\n-      gcc_assert (cmp_mode != BLKmode);\n-\n+      unsigned int nbits = GET_MODE_NUNITS (cmp_ops_mode);\n+      cmp_mode = int_mode_for_size (nbits, 0).require ();\n       maskcmp = true;\n     }\n   else\n@@ -27524,13 +27524,11 @@ emit_memmov (rtx destmem, rtx *srcmem, rtx destptr, rtx srcptr,\n      Start with the biggest power of 2 less than SIZE_TO_MOVE and half\n      it until move of such size is supported.  */\n   piece_size = 1 << floor_log2 (size_to_move);\n-  move_mode = mode_for_size (piece_size * BITS_PER_UNIT, MODE_INT, 0);\n-  code = optab_handler (mov_optab, move_mode);\n-  while (code == CODE_FOR_nothing && piece_size > 1)\n+  while (!int_mode_for_size (piece_size * BITS_PER_UNIT, 0).exists (&move_mode)\n+\t || (code = optab_handler (mov_optab, move_mode)) == CODE_FOR_nothing)\n     {\n+      gcc_assert (piece_size > 1);\n       piece_size >>= 1;\n-      move_mode = mode_for_size (piece_size * BITS_PER_UNIT, MODE_INT, 0);\n-      code = optab_handler (mov_optab, move_mode);\n     }\n \n   /* Find the corresponding vector mode with the same size as MOVE_MODE.\n@@ -27713,7 +27711,8 @@ emit_memset (rtx destmem, rtx destptr, rtx promoted_val,\n     move_mode = QImode;\n   if (size_to_move < GET_MODE_SIZE (move_mode))\n     {\n-      move_mode = mode_for_size (size_to_move * BITS_PER_UNIT, MODE_INT, 0);\n+      unsigned int move_bits = size_to_move * BITS_PER_UNIT;\n+      move_mode = int_mode_for_size (move_bits, 0).require ();\n       promoted_val = gen_lowpart (move_mode, promoted_val);\n     }\n   piece_size = GET_MODE_SIZE (move_mode);\n@@ -27908,7 +27907,7 @@ expand_small_movmem_or_setmem (rtx destmem, rtx srcmem,\n \t\t\t       rtx done_label, bool issetmem)\n {\n   rtx_code_label *label = ix86_expand_aligntest (count, size, false);\n-  machine_mode mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 1);\n+  machine_mode mode = int_mode_for_size (size * BITS_PER_UNIT, 1).else_blk ();\n   rtx modesize;\n   int n;\n \n@@ -50569,7 +50568,8 @@ ix86_expand_pextr (rtx *operands)\n \tmachine_mode srcmode, dstmode;\n \trtx d, pat;\n \n-\tdstmode = mode_for_size (size, MODE_INT, 0);\n+\tif (!int_mode_for_size (size, 0).exists (&dstmode))\n+\t  return false;\n \n \tswitch (dstmode)\n \t  {\n@@ -50665,7 +50665,8 @@ ix86_expand_pinsr (rtx *operands)\n \trtx (*pinsr)(rtx, rtx, rtx, rtx);\n \trtx d;\n \n-\tsrcmode = mode_for_size (size, MODE_INT, 0);\n+\tif (!int_mode_for_size (size, 0).exists (&srcmode))\n+\t  return false;\n \n \tswitch (srcmode)\n \t  {"}, {"sha": "f088069868e5346428d281d3f2cf28ce8c03012f", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -836,7 +836,7 @@ lm32_block_move_inline (rtx dest, rtx src, HOST_WIDE_INT length,\n       break;\n     }\n \n-  mode = mode_for_size (bits, MODE_INT, 0);\n+  mode = int_mode_for_size (bits, 0).require ();\n   delta = bits / BITS_PER_UNIT;\n \n   /* Allocate a buffer for the temporary registers.  */"}, {"sha": "d935c3efa726e2f41af5d5d7b929a63ec13617f7", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -1087,7 +1087,7 @@ microblaze_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n   rtx *regs;\n \n   bits = BITS_PER_WORD;\n-  mode = mode_for_size (bits, MODE_INT, 0);\n+  mode = int_mode_for_size (bits, 0).require ();\n   delta = bits / BITS_PER_UNIT;\n \n   /* Allocate a buffer for the temporary registers.  */"}, {"sha": "bb9440590b1eae57295d2dc468159aa0943db0b5", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -6384,7 +6384,7 @@ mips_function_value_1 (const_tree valtype, const_tree fn_decl_or_type,\n \t  if (size % UNITS_PER_WORD != 0)\n \t    {\n \t      size += UNITS_PER_WORD - size % UNITS_PER_WORD;\n-\t      mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\t      mode = int_mode_for_size (size * BITS_PER_UNIT, 0).require ();\n \t    }\n \t}\n \n@@ -7992,7 +7992,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n \tbits = BITS_PER_WORD;\n     }\n \n-  mode = mode_for_size (bits, MODE_INT, 0);\n+  mode = int_mode_for_size (bits, 0).require ();\n   delta = bits / BITS_PER_UNIT;\n \n   /* Allocate a buffer for the temporary registers.  */\n@@ -8397,7 +8397,7 @@ mips_expand_ins_as_unaligned_store (rtx dest, rtx src, HOST_WIDE_INT width,\n   if (!mips_get_unaligned_mem (dest, width, bitpos, &left, &right))\n     return false;\n \n-  mode = mode_for_size (width, MODE_INT, 0);\n+  mode = int_mode_for_size (width, 0).require ();\n   src = gen_lowpart (mode, src);\n   if (mode == DImode)\n     {"}, {"sha": "9fd2d86abbf4ad9245fd9703ccd7236d1e9cdb1f", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -12222,7 +12222,6 @@ rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *cum,\n {\n   unsigned int startbit, endbit;\n   int intregs, intoffset;\n-  machine_mode mode;\n \n   /* Handle the situations where a float is taking up the first half\n      of the GPR, and the other half is empty (typically due to\n@@ -12246,9 +12245,8 @@ rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *cum,\n \n   if (intoffset % BITS_PER_WORD != 0)\n     {\n-      mode = mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n-\t\t\t    MODE_INT, 0);\n-      if (mode == BLKmode)\n+      unsigned int bits = BITS_PER_WORD - intoffset % BITS_PER_WORD;\n+      if (!int_mode_for_size (bits, 0).exists ())\n \t{\n \t  /* We couldn't find an appropriate mode, which happens,\n \t     e.g., in packed structs when there are 3 bytes to load.\n@@ -12714,9 +12712,8 @@ rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *cum,\n \n   if (intoffset % BITS_PER_WORD != 0)\n     {\n-      mode = mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n-\t\t\t  MODE_INT, 0);\n-      if (mode == BLKmode)\n+      unsigned int bits = BITS_PER_WORD - intoffset % BITS_PER_WORD;\n+      if (!int_mode_for_size (bits, 0).exists (&mode))\n \t{\n \t  /* We couldn't find an appropriate mode, which happens,\n \t     e.g., in packed structs when there are 3 bytes to load."}, {"sha": "1a934ec4dabe4d389caf48e346d7296d47ceb54b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -11654,7 +11654,6 @@ rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *cum,\n {\n   unsigned int startbit, endbit;\n   int intregs, intoffset;\n-  machine_mode mode;\n \n   /* Handle the situations where a float is taking up the first half\n      of the GPR, and the other half is empty (typically due to\n@@ -11678,9 +11677,8 @@ rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *cum,\n \n   if (intoffset % BITS_PER_WORD != 0)\n     {\n-      mode = mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n-\t\t\t    MODE_INT, 0);\n-      if (mode == BLKmode)\n+      unsigned int bits = BITS_PER_WORD - intoffset % BITS_PER_WORD;\n+      if (!int_mode_for_size (bits, 0).exists ())\n \t{\n \t  /* We couldn't find an appropriate mode, which happens,\n \t     e.g., in packed structs when there are 3 bytes to load.\n@@ -12049,9 +12047,8 @@ rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *cum,\n \n   if (intoffset % BITS_PER_WORD != 0)\n     {\n-      mode = mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n-\t\t\t  MODE_INT, 0);\n-      if (mode == BLKmode)\n+      unsigned int bits = BITS_PER_WORD - intoffset % BITS_PER_WORD;\n+      if (!int_mode_for_size (bits, 0).exists (&mode))\n \t{\n \t  /* We couldn't find an appropriate mode, which happens,\n \t     e.g., in packed structs when there are 3 bytes to load."}, {"sha": "3a532e580c6206108193981e378394f6cd8a3095", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -7123,7 +7123,7 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n       gcc_assert (size <= 16);\n \n-      mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+      mode = int_mode_for_size (size * BITS_PER_UNIT, 0).else_blk ();\n     }\n \n   return gen_rtx_REG (mode, regno);\n@@ -7499,7 +7499,7 @@ sparc_function_value_1 (const_tree type, machine_mode mode,\n \t  HOST_WIDE_INT size = int_size_in_bytes (type);\n \t  gcc_assert (size <= 32);\n \n-\t  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\t  mode = int_mode_for_size (size * BITS_PER_UNIT, 0).else_blk ();\n \n \t  /* ??? We probably should have made the same ABI change in\n \t     3.4.0 as the one we made for unions.   The latter was"}, {"sha": "4e49977c77afcfa6ec5d657c75014e41cc19b00d", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -368,7 +368,7 @@ adjust_operand (rtx op, HOST_WIDE_INT * start)\n       op_size = 32;\n     }\n   /* If it is not a MODE_INT (and/or it is smaller than SI) add a SUBREG. */\n-  mode = mode_for_size (op_size, MODE_INT, 0);\n+  mode = int_mode_for_size (op_size, 0).require ();\n   if (mode != GET_MODE (op))\n     op = gen_rtx_SUBREG (mode, op, 0);\n   return op;\n@@ -935,7 +935,7 @@ spu_emit_branch_or_set (int is_set, rtx cmp, rtx operands[])\n       rtx target = operands[0];\n       int compare_size = GET_MODE_BITSIZE (comp_mode);\n       int target_size = GET_MODE_BITSIZE (GET_MODE (target));\n-      machine_mode mode = mode_for_size (target_size, MODE_INT, 0);\n+      machine_mode mode = int_mode_for_size (target_size, 0).require ();\n       rtx select_mask;\n       rtx op_t = operands[2];\n       rtx op_f = operands[3];"}, {"sha": "88f28d1c8e47ed7b5f231c1a9e64447659690902", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -1430,9 +1430,9 @@ gen_lowpart_common (machine_mode mode, rtx x)\n   innermode = GET_MODE (x);\n   if (CONST_INT_P (x)\n       && msize * BITS_PER_UNIT <= HOST_BITS_PER_WIDE_INT)\n-    innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n+    innermode = int_mode_for_size (HOST_BITS_PER_WIDE_INT, 0).require ();\n   else if (innermode == VOIDmode)\n-    innermode = mode_for_size (HOST_BITS_PER_DOUBLE_INT, MODE_INT, 0);\n+    innermode = int_mode_for_size (HOST_BITS_PER_DOUBLE_INT, 0).require ();\n \n   xsize = GET_MODE_SIZE (innermode);\n "}, {"sha": "cc7ec420274a32c446614eb7ac3d6aa2d72aad97", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -10680,7 +10680,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t&& ! (target != 0 && MEM_P (op0)\n \t\t      && MEM_P (target)\n \t\t      && bitpos % BITS_PER_UNIT == 0))\n-\t      ext_mode = mode_for_size (bitsize, MODE_INT, 1);\n+\t      ext_mode = int_mode_for_size (bitsize, 1).else_blk ();\n \n \t    if (ext_mode == BLKmode)\n \t      {"}, {"sha": "7c5e8630108fef5a4b4821027af5d8f8ba5ec9aa", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -2978,8 +2978,8 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t that mode's store operation.  */\n       else if (size <= UNITS_PER_WORD)\n \t{\n-\t  machine_mode mode\n-\t    = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\t  unsigned int bits = size * BITS_PER_UNIT;\n+\t  machine_mode mode = int_mode_for_size (bits, 0).else_blk ();\n \n \t  if (mode != BLKmode\n #ifdef BLOCK_REG_PADDING"}, {"sha": "c60d56aad14542df99ec94d521ca7f33553a1e5d", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -354,7 +354,7 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n   tree tmp_int = expr;\n   bool sub_byte_op_p = ((bitlen % BITS_PER_UNIT)\n \t\t\t|| (bitpos % BITS_PER_UNIT)\n-\t\t\t|| mode_for_size (bitlen, MODE_INT, 0) == BLKmode);\n+\t\t\t|| !int_mode_for_size (bitlen, 0).exists ());\n \n   if (!sub_byte_op_p)\n     return (native_encode_expr (tmp_int, ptr + first_byte, total_bytes, 0)"}, {"sha": "647a97bb958182e3bfbe29e937dab83a3941b727", "filename": "gcc/reload1.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -2189,11 +2189,12 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t    {\n \t      adjust = inherent_size - total_size;\n \t      if (adjust)\n-\t\tstack_slot\n-\t\t  = adjust_address_nv (x, mode_for_size (total_size\n-\t\t\t\t\t\t         * BITS_PER_UNIT,\n-\t\t\t\t\t\t         MODE_INT, 1),\n-\t\t\t\t       adjust);\n+\t\t{\n+\t\t  unsigned int total_bits = total_size * BITS_PER_UNIT;\n+\t\t  machine_mode mem_mode\n+\t\t    = int_mode_for_size (total_bits, 1).else_blk ();\n+\t\t  stack_slot = adjust_address_nv (x, mem_mode, adjust);\n+\t\t}\n \t    }\n \n \t  if (! dont_share_p && ira_conflicts_p)\n@@ -2240,11 +2241,12 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t    {\n \t      adjust = GET_MODE_SIZE (mode) - total_size;\n \t      if (adjust)\n-\t\tstack_slot\n-\t\t  = adjust_address_nv (x, mode_for_size (total_size\n-\t\t\t\t\t\t\t * BITS_PER_UNIT,\n-\t\t\t\t\t\t\t MODE_INT, 1),\n-\t\t\t\t       adjust);\n+\t\t{\n+\t\t  unsigned int total_bits = total_size * BITS_PER_UNIT;\n+\t\t  machine_mode mem_mode\n+\t\t    = int_mode_for_size (total_bits, 1).else_blk ();\n+\t\t  stack_slot = adjust_address_nv (x, mem_mode, adjust);\n+\t\t}\n \t    }\n \n \t  spill_stack_slot[from_reg] = stack_slot;"}, {"sha": "27a1eba497568e2cc6b62db86846f6f494c08f43", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b316470bf7cccab22fbb97d1b6c541fcfc2855/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=f4b316470bf7cccab22fbb97d1b6c541fcfc2855", "patch": "@@ -506,8 +506,10 @@ mode_for_vector (scalar_mode innermode, unsigned nunits)\n   /* For integers, try mapping it to a same-sized scalar mode.  */\n   if (mode == VOIDmode\n       && GET_MODE_CLASS (innermode) == MODE_INT)\n-    mode = mode_for_size (nunits * GET_MODE_BITSIZE (innermode),\n-\t\t\t  MODE_INT, 0);\n+    {\n+      unsigned int nbits = nunits * GET_MODE_BITSIZE (innermode);\n+      mode = int_mode_for_size (nbits, 0).else_blk ();\n+    }\n \n   if (mode == VOIDmode\n       || (GET_MODE_CLASS (mode) == MODE_INT\n@@ -2295,7 +2297,7 @@ layout_type (tree type)\n       TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE_UNITS);\n       /* A pointer might be MODE_PARTIAL_INT, but ptrdiff_t must be\n \t integral, which may be an __intN.  */\n-      SET_TYPE_MODE (type, mode_for_size (POINTER_SIZE, MODE_INT, 0));\n+      SET_TYPE_MODE (type, int_mode_for_size (POINTER_SIZE, 0).require ());\n       TYPE_PRECISION (type) = POINTER_SIZE;\n       break;\n \n@@ -2304,7 +2306,8 @@ layout_type (tree type)\n       /* It's hard to see what the mode and size of a function ought to\n \t be, but we do know the alignment is FUNCTION_BOUNDARY, so\n \t make it consistent with that.  */\n-      SET_TYPE_MODE (type, mode_for_size (FUNCTION_BOUNDARY, MODE_INT, 0));\n+      SET_TYPE_MODE (type,\n+\t\t     int_mode_for_size (FUNCTION_BOUNDARY, 0).else_blk ());\n       TYPE_SIZE (type) = bitsize_int (FUNCTION_BOUNDARY);\n       TYPE_SIZE_UNIT (type) = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n       break;"}]}