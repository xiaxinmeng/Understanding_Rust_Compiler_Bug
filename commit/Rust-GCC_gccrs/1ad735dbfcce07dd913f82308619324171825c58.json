{"sha": "1ad735dbfcce07dd913f82308619324171825c58", "node_id": "C_kwDOANBUbNoAKDFhZDczNWRiZmNjZTA3ZGQ5MTNmODIzMDg2MTkzMjQxNzE4MjVjNTg", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-20T18:02:24Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-20T18:02:24Z"}, "message": "c++: cache the normal form of a concept-id\n\nWe already cache the overall normal form of a declaration's constraints\n(under the assumption that it can't change over the translation unit).\nBut if we have something like\n\n  template<class T> concept complicated = /* ... */;\n  template<class T> void f() requires complicated<T> && /* ... */;\n  template<class T> void g() requires complicated<T> && /* ... */;\n\nthen despite this high-level caching we'd still redundantly have to\nexpand the concept-id complicated<T> twice, once during normalization of\nf's constraints and again during normalization of g's.  Ideally, we'd\nreuse the previously computed normal form of complicated<T> the second\ntime around.\n\nTo that end this patch introduces an intermediate layer of caching\nduring constraint normalization -- caching of the normal form of a\nconcept-id -- that sits between our high-level caching of the overall\nnormal form of a declaration's constraints and our low-level caching of\neach individual atomic constraint.\n\nIt turns out this caching generalizes normalize_concept_check's caching\nof the normal form of a concept definition (which is equivalent to the\nnormal form of the concept-id C<gtargs> where gtargs is C's generic\narguments) so this patch unifies the caching accordingly.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (struct norm_entry): Define.\n\t(struct norm_hasher): Define.\n\t(norm_cache): Define.\n\t(normalize_concept_check): Add function comment.  Cache the\n\tthe normal form of the substituted concept-id.  Canonicalize\n\tgeneric arguments as NULL_TREE.  Don't coerce arguments unless\n\tthey were substituted.\n\t(normalize_concept_definition): Simplify.  Use norm_cache\n\tinstead of normalized_map.", "tree": {"sha": "5c582e002eaf2fcd0b57c1600f3a7299ae59a3ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c582e002eaf2fcd0b57c1600f3a7299ae59a3ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ad735dbfcce07dd913f82308619324171825c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad735dbfcce07dd913f82308619324171825c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad735dbfcce07dd913f82308619324171825c58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad735dbfcce07dd913f82308619324171825c58/comments", "author": null, "committer": null, "parents": [{"sha": "b36a5f8404d7c3681435b497ef6b27d69cba0a14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b36a5f8404d7c3681435b497ef6b27d69cba0a14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b36a5f8404d7c3681435b497ef6b27d69cba0a14"}], "stats": {"total": 95, "additions": 81, "deletions": 14}, "files": [{"sha": "ab0f66b3d7ee4ab9c33dd7a8b622f6e86c30fce0", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad735dbfcce07dd913f82308619324171825c58/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad735dbfcce07dd913f82308619324171825c58/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=1ad735dbfcce07dd913f82308619324171825c58", "patch": "@@ -698,6 +698,39 @@ normalize_logical_operation (tree t, tree args, tree_code c, norm_info info)\n   return build2 (c, ci, t0, t1);\n }\n \n+/* Data types and hash functions for caching the normal form of a concept-id.\n+   This essentially memoizes calls to normalize_concept_check.  */\n+\n+struct GTY((for_user)) norm_entry\n+{\n+  /* The CONCEPT_DECL of the concept-id.  */\n+  tree tmpl;\n+  /* The arguments of the concept-id.  */\n+  tree args;\n+  /* The normal form of the concept-id.  */\n+  tree norm;\n+};\n+\n+struct norm_hasher : ggc_ptr_hash<norm_entry>\n+{\n+  static hashval_t hash (norm_entry *e)\n+  {\n+    hashval_t hash = iterative_hash_template_arg (e->tmpl, 0);\n+    return iterative_hash_template_arg (e->args, hash);\n+  }\n+\n+  static bool equal (norm_entry *e1, norm_entry *e2)\n+  {\n+    return e1->tmpl == e2->tmpl\n+      && template_args_equal (e1->args, e2->args);\n+  }\n+};\n+\n+static GTY((deletable)) hash_table<norm_hasher> *norm_cache;\n+\n+/* Normalize the concept check CHECK where ARGS are the\n+   arguments to be substituted into CHECK's arguments.  */\n+\n static tree\n normalize_concept_check (tree check, tree args, norm_info info)\n {\n@@ -720,24 +753,52 @@ normalize_concept_check (tree check, tree args, norm_info info)\n     targs = tsubst_template_args (targs, args, info.complain, info.in_decl);\n   if (targs == error_mark_node)\n     return error_mark_node;\n+  if (template_args_equal (targs, generic_targs_for (tmpl)))\n+    /* Canonicalize generic arguments as NULL_TREE, as an optimization.  */\n+    targs = NULL_TREE;\n \n   /* Build the substitution for the concept definition.  */\n   tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (tmpl));\n-  /* Turn on template processing; coercing non-type template arguments\n-     will automatically assume they're non-dependent.  */\n-  ++processing_template_decl;\n-  tree subst = coerce_template_parms (parms, targs, tmpl, tf_none);\n-  --processing_template_decl;\n-  if (subst == error_mark_node)\n+  if (targs && args)\n+    /* As an optimization, coerce the arguments only if necessary\n+       (i.e. if they were substituted).  */\n+    targs = coerce_template_parms (parms, targs, tmpl, tf_none);\n+  if (targs == error_mark_node)\n     return error_mark_node;\n \n+  if (!norm_cache)\n+    norm_cache = hash_table<norm_hasher>::create_ggc (31);\n+  norm_entry entry = {tmpl, targs, NULL_TREE};\n+  norm_entry **slot = nullptr;\n+  hashval_t hash = 0;\n+  if (!info.generate_diagnostics ())\n+    {\n+      /* Cache the normal form of the substituted concept-id (when not\n+\t diagnosing).  */\n+      hash = norm_hasher::hash (&entry);\n+      slot = norm_cache->find_slot_with_hash (&entry, hash, INSERT);\n+      if (*slot)\n+\treturn (*slot)->norm;\n+    }\n+\n   /* The concept may have been ill-formed.  */\n   tree def = get_concept_definition (DECL_TEMPLATE_RESULT (tmpl));\n   if (def == error_mark_node)\n     return error_mark_node;\n \n   info.update_context (check, args);\n-  return normalize_expression (def, subst, info);\n+  tree norm = normalize_expression (def, targs, info);\n+  if (slot)\n+    {\n+      /* Recompute SLOT since norm_cache may have been expanded during\n+\t the recursive call.  */\n+      slot = norm_cache->find_slot_with_hash (&entry, hash, INSERT);\n+      gcc_checking_assert (!*slot);\n+      entry.norm = norm;\n+      *slot = ggc_alloc<norm_entry> ();\n+      **slot = entry;\n+    }\n+  return norm;\n }\n \n /* Used by normalize_atom to cache ATOMIC_CONSTRs.  */\n@@ -941,15 +1002,16 @@ get_normalized_constraints_from_decl (tree d, bool diag = false)\n /* Returns the normal form of TMPL's definition.  */\n \n static tree\n-normalize_concept_definition (tree tmpl, bool diag = false)\n+normalize_concept_definition (tree tmpl, bool diag)\n {\n+  if (!norm_cache)\n+    norm_cache = hash_table<norm_hasher>::create_ggc (31);\n+  norm_entry entry = {tmpl, NULL_TREE, NULL_TREE};\n+\n   if (!diag)\n-    if (tree *p = hash_map_safe_get (normalized_map, tmpl))\n-      return *p;\n+    if (norm_entry *found = norm_cache->find (&entry))\n+      return found->norm;\n \n-  gcc_assert (concept_definition_p (tmpl));\n-  if (OVL_P (tmpl))\n-    tmpl = OVL_FIRST (tmpl);\n   gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n   tree def = get_concept_definition (DECL_TEMPLATE_RESULT (tmpl));\n   ++processing_template_decl;\n@@ -958,7 +1020,12 @@ normalize_concept_definition (tree tmpl, bool diag = false)\n   --processing_template_decl;\n \n   if (!diag)\n-    hash_map_safe_put<hm_ggc> (normalized_map, tmpl, norm);\n+    {\n+      norm_entry **slot = norm_cache->find_slot (&entry, INSERT);\n+      entry.norm = norm;\n+      *slot = ggc_alloc<norm_entry> ();\n+      **slot = entry;\n+    }\n \n   return norm;\n }"}]}