{"sha": "6a74a7b056cc46079cd4146f25ee22708f473ac5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE3NGE3YjA1NmNjNDYwNzljZDQxNDZmMjVlZTIyNzA4ZjQ3M2FjNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T12:53:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T12:53:23Z"}, "message": "[multiple changes]\n\n2014-08-04  Olivier Hainque  <hainque@adacore.com>\n\n\t* a-comutr.ads: Set Root_Node_Type'Alignment to\n\tStandard'Maximum_Alignment, so that it is at least as large as\n\tthe max default for Tree_Node_Type'Alignment.\n\n2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Freeze_Type): Remove the generation and inheritance\n\tof the default initial condition procedure [body].\n\t* sem_ch3.adb (Analyze_Declarations): Create the bodies of\n\tall default initial condition procedures at the end of private\n\tdeclaration analysis.\n\t* sem_util.adb (Build_Default_Init_Cond_Procedure_Bodies): New\n\troutine.\n\t(Build_Default_Init_Cond_Procedure_Body): Merged in the\n\tprocessing of routine Build_Default_Init_Cond_Procedure_Bodies.\n\t* sem_util.ads (Build_Default_Init_Cond_Procedure_Bodies):\n\tNew routine.\n\t(Build_Default_Init_Cond_Procedure_Body): Removed.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_elab.adb (Check_Elab_Call): Do not check a call to a\n\tpostcondtion.\n\t* exp_ch6.adb (Expand_Call): Clarify handling of inserted\n\tpostcondition call.\n\nFrom-SVN: r213580", "tree": {"sha": "6da8c2645ef62d60d2561f874976f2d90c895f8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6da8c2645ef62d60d2561f874976f2d90c895f8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a74a7b056cc46079cd4146f25ee22708f473ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a74a7b056cc46079cd4146f25ee22708f473ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a74a7b056cc46079cd4146f25ee22708f473ac5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a74a7b056cc46079cd4146f25ee22708f473ac5/comments", "author": null, "committer": null, "parents": [{"sha": "51dcceecdf58128ea13fede4507327a3f8595804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51dcceecdf58128ea13fede4507327a3f8595804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51dcceecdf58128ea13fede4507327a3f8595804"}], "stats": {"total": 342, "additions": 217, "deletions": 125}, "files": [{"sha": "49127ff21bae69776f7214bb723b2f7200bd21d1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -1,3 +1,31 @@\n+2014-08-04  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* a-comutr.ads: Set Root_Node_Type'Alignment to\n+\tStandard'Maximum_Alignment, so that it is at least as large as\n+\tthe max default for Tree_Node_Type'Alignment.\n+\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Freeze_Type): Remove the generation and inheritance\n+\tof the default initial condition procedure [body].\n+\t* sem_ch3.adb (Analyze_Declarations): Create the bodies of\n+\tall default initial condition procedures at the end of private\n+\tdeclaration analysis.\n+\t* sem_util.adb (Build_Default_Init_Cond_Procedure_Bodies): New\n+\troutine.\n+\t(Build_Default_Init_Cond_Procedure_Body): Merged in the\n+\tprocessing of routine Build_Default_Init_Cond_Procedure_Bodies.\n+\t* sem_util.ads (Build_Default_Init_Cond_Procedure_Bodies):\n+\tNew routine.\n+\t(Build_Default_Init_Cond_Procedure_Body): Removed.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_elab.adb (Check_Elab_Call): Do not check a call to a\n+\tpostcondtion.\n+\t* exp_ch6.adb (Expand_Call): Clarify handling of inserted\n+\tpostcondition call.\n+\n 2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma): Ensure that an"}, {"sha": "c1a3dc85cd557ad4d69b8beb886482cd897190e6", "filename": "gcc/ada/a-comutr.ads", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -308,17 +308,16 @@ package Ada.Containers.Multiway_Trees is\n       Process : not null access procedure (Position : Cursor));\n \n private\n-\n    --  A node of this multiway tree comprises an element and a list of children\n    --  (that are themselves trees). The root node is distinguished because it\n    --  contains only children: it does not have an element itself.\n-   --\n-   --  This design feature puts two design goals in tension:\n+\n+   --  This design feature puts two design goals in tension with one another:\n    --   (1) treat the root node the same as any other node\n    --   (2) not declare any objects of type Element_Type unnecessarily\n-   --\n-   --  To satisfy (1), we could simply declare the Root node of the tree using\n-   --  the normal Tree_Node_Type, but that would mean that (2) is not\n+\n+   --  To satisfy (1), we could simply declare the Root node of the tree\n+   --  using the normal Tree_Node_Type, but that would mean that (2) is not\n    --  satisfied. To resolve the tension (in favor of (2)), we declare the\n    --  component Root as having a different node type, without an Element\n    --  component (thus satisfying goal (2)) but otherwise identical to a normal\n@@ -327,11 +326,11 @@ private\n    --  normal, non-root node (thus satisfying goal (1)). We make an explicit\n    --  check for Root when there is any attempt to manipulate the Element\n    --  component of the node (a check required by the RM anyway).\n-   --\n+\n    --  In order to be explicit about node (and pointer) representation, we\n-   --  specify that the respective node types have convention C, to ensure that\n-   --  the layout of the components of the node records is the same, thus\n-   --  guaranteeing that (unchecked) conversions between access types\n+   --  specify that the respective node types have convention C, to ensure\n+   --  that the layout of the components of the node records is the same,\n+   --  thus guaranteeing that (unchecked) conversions between access types\n    --  designating each kind of node type is a meaningful conversion.\n \n    type Tree_Node_Type;\n@@ -366,6 +365,11 @@ private\n    end record;\n    pragma Convention (C, Root_Node_Type);\n \n+   for Root_Node_Type'Alignment use Standard'Maximum_Alignment;\n+   --  The alignment has to be large enough to allow Root_Node to Tree_Node\n+   --  access value conversions, and Tree_Node_Type's alignment may be bumped\n+   --  up by the Element component.\n+\n    use Ada.Finalization;\n \n    --  The Count component of type Tree represents the number of nodes that"}, {"sha": "5e11962325ccbe9df02b05379cf008d0b4ac1d38", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -7394,20 +7394,6 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n-      --  If the type is subject to pragma Default_Initial_Condition, generate\n-      --  the body of the procedure which verifies the assertion of the pragma\n-      --  at runtime.\n-\n-      if Has_Default_Init_Cond (Def_Id) then\n-         Build_Default_Init_Cond_Procedure_Body (Def_Id);\n-\n-      --  A derived type inherits the default initial condition procedure from\n-      --  its parent type.\n-\n-      elsif Has_Inherited_Default_Init_Cond (Def_Id) then\n-         Inherit_Default_Init_Cond_Procedure (Def_Id);\n-      end if;\n-\n       --  Freeze processing for record types\n \n       if Is_Record_Type (Def_Id) then"}, {"sha": "82c87871f87866b0f58edaf646de8fa4ba6d6e23", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -5209,6 +5209,13 @@ package body Exp_Ch6 is\n                --  Analyze call, but something goes wrong in some weird cases\n                --  and it is not worth worrying about ???\n \n+               --  The return statement is handled properly, and the call to\n+               --  the postcondition, inserted below, does not require\n+               --  information from the body either. However, that call is\n+               --  analyzed in the enclosing scope, and an elaboration check\n+               --  might improperly be added to it.  A guard in sem_elab is\n+               --  needed to prevent that spurious check, see Check_Elab_Call.\n+\n                Append_To (S, Rtn);\n                Set_Analyzed (Rtn);\n "}, {"sha": "5b16aa2477aaba65b3f46a2c9730451b9a149e6f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -2388,10 +2388,13 @@ package body Sem_Ch3 is\n             --  When a package has private declarations, its contract must be\n             --  analyzed at the end of the said declarations. This way both the\n             --  analysis and freeze actions are properly synchronized in case\n-            --  of private type use within the contract.\n+            --  of private type use within the contract. Build the bodies of\n+            --  the default initial condition procedures for all types subject\n+            --  to pragma Default_Initial_Condition.\n \n             if L = Private_Declarations (Context) then\n                Analyze_Package_Contract (Defining_Entity (Context));\n+               Build_Default_Init_Cond_Procedure_Bodies (L);\n \n             --  Otherwise the contract is analyzed at the end of the visible\n             --  declarations."}, {"sha": "e5e29bcce21e04f819fa8248f5bbdf2052ca4605", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -1218,6 +1218,17 @@ package body Sem_Elab is\n          return;\n       end if;\n \n+      --  Nothing to do if this is a call to a postcondition, which is always\n+      --  within a subprogram body, even though the current scope may be the\n+      --  enclosing scope of the subprogram.\n+\n+      if Nkind (N) = N_Procedure_Call_Statement\n+        and then Is_Entity_Name (Name (N))\n+        and then Chars (Entity (Name (N))) = Name_uPostconditions\n+      then\n+         return;\n+      end if;\n+\n       --  Here we have a call at elaboration time which must be checked\n \n       if Debug_Flag_LL then"}, {"sha": "d55d7c5f63fc49dbc9db9d5292d63753ffd08475", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 148, "deletions": 94, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -1252,123 +1252,177 @@ package body Sem_Util is\n               Expression   => New_Occurrence_Of (Obj_Id, Loc))));\n    end Build_Default_Init_Cond_Call;\n \n-   --------------------------------------------\n-   -- Build_Default_Init_Cond_Procedure_Body --\n-   --------------------------------------------\n+   ----------------------------------------------\n+   -- Build_Default_Init_Cond_Procedure_Bodies --\n+   ----------------------------------------------\n \n-   procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id) is\n-      Param_Id : Entity_Id;\n-      --  The entity of the formal parameter of the default initial condition\n-      --  procedure.\n+   procedure Build_Default_Init_Cond_Procedure_Bodies (Priv_Decls : List_Id) is\n+      procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id);\n+      --  If type Typ is subject to pragma Default_Initial_Condition, build the\n+      --  body of the procedure which verifies the assumption of the pragma at\n+      --  runtime. The generated body is added after the type declaration.\n \n-      procedure Replace_Type_Reference (N : Node_Id);\n-      --  Replace a single reference to type Typ with a reference to Param_Id\n+      --------------------------------------------\n+      -- Build_Default_Init_Cond_Procedure_Body --\n+      --------------------------------------------\n \n-      ----------------------------\n-      -- Replace_Type_Reference --\n-      ----------------------------\n+      procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id) is\n+         Param_Id : Entity_Id;\n+         --  The entity of the sole formal parameter of the default initial\n+         --  condition procedure.\n \n-      procedure Replace_Type_Reference (N : Node_Id) is\n-      begin\n-         Rewrite (N, New_Occurrence_Of (Param_Id, Sloc (N)));\n-      end Replace_Type_Reference;\n+         procedure Replace_Type_Reference (N : Node_Id);\n+         --  Replace a single reference to type Typ with a reference to formal\n+         --  parameter Param_Id.\n \n-      procedure Replace_Type_References is\n-        new Replace_Type_References_Generic (Replace_Type_Reference);\n+         ----------------------------\n+         -- Replace_Type_Reference --\n+         ----------------------------\n \n-      --  Local variables\n+         procedure Replace_Type_Reference (N : Node_Id) is\n+         begin\n+            Rewrite (N, New_Occurrence_Of (Param_Id, Sloc (N)));\n+         end Replace_Type_Reference;\n \n-      Loc       : constant Source_Ptr := Sloc (Typ);\n-      Prag      : constant Node_Id    :=\n-                    Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n-      Proc_Id   : constant Entity_Id  := Default_Init_Cond_Procedure (Typ);\n-      Spec_Decl : constant Node_Id    := Unit_Declaration_Node (Proc_Id);\n-      Body_Decl : Node_Id;\n-      Expr      : Node_Id;\n-      Stmt      : Node_Id;\n+         procedure Replace_Type_References is\n+           new Replace_Type_References_Generic (Replace_Type_Reference);\n \n-   --  Start of processing for Build_Default_Init_Cond_Procedure\n+         --  Local variables\n \n-   begin\n-      --  The procedure should be generated only for types subject to pragma\n-      --  Default_Initial_Condition. Types that inherit the pragma do not get\n-      --  this specialized procedure.\n+         Loc       : constant Source_Ptr := Sloc (Typ);\n+         Prag      : constant Node_Id    :=\n+                       Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n+         Proc_Id   : constant Entity_Id  := Default_Init_Cond_Procedure (Typ);\n+         Spec_Decl : constant Node_Id    := Unit_Declaration_Node (Proc_Id);\n+         Body_Decl : Node_Id;\n+         Expr      : Node_Id;\n+         Stmt      : Node_Id;\n \n-      pragma Assert (Has_Default_Init_Cond (Typ));\n-      pragma Assert (Present (Prag));\n-      pragma Assert (Present (Proc_Id));\n+      --  Start of processing for Build_Default_Init_Cond_Procedure\n \n-      --  Nothing to do if the body was already built\n+      begin\n+         --  The procedure should be generated only for [sub]types subject to\n+         --  pragma Default_Initial_Condition. Types that inherit the pragma do\n+         --  not get this specialized procedure.\n \n-      if Present (Corresponding_Body (Spec_Decl)) then\n-         return;\n-      end if;\n+         pragma Assert (Has_Default_Init_Cond (Typ));\n+         pragma Assert (Present (Prag));\n+         pragma Assert (Present (Proc_Id));\n+\n+         --  Nothing to do if the body was already built\n+\n+         if Present (Corresponding_Body (Spec_Decl)) then\n+            return;\n+         end if;\n \n-      Param_Id := First_Formal (Proc_Id);\n+         Param_Id := First_Formal (Proc_Id);\n \n-      --  The pragma has an argument. Note that the argument is analyzed after\n-      --  all references to the current instance of the type are replaced.\n+         --  The pragma has an argument. Note that the argument is analyzed\n+         --  after all references to the current instance of the type are\n+         --  replaced.\n \n-      if Present (Pragma_Argument_Associations (Prag)) then\n-         Expr := Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n+         if Present (Pragma_Argument_Associations (Prag)) then\n+            Expr :=\n+              Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n \n-         if Nkind (Expr) = N_Null then\n-            Stmt := Make_Null_Statement (Loc);\n+            if Nkind (Expr) = N_Null then\n+               Stmt := Make_Null_Statement (Loc);\n+\n+            --  Preserve the original argument of the pragma by replicating it.\n+            --  Replace all references to the current instance of the type with\n+            --  references to the formal parameter.\n+\n+            else\n+               Expr := New_Copy_Tree (Expr);\n+               Replace_Type_References (Expr, Typ);\n+\n+               --  Generate:\n+               --    pragma Check (Default_Initial_Condition, <Expr>);\n+\n+               Stmt :=\n+                 Make_Pragma (Loc,\n+                   Pragma_Identifier            =>\n+                     Make_Identifier (Loc, Name_Check),\n+\n+                   Pragma_Argument_Associations => New_List (\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression =>\n+                         Make_Identifier (Loc,\n+                           Chars => Name_Default_Initial_Condition)),\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression => Expr)));\n+            end if;\n \n-         --  Preserve the original argument of the pragma by replicating it.\n-         --  Replace all references to the current instance of the type with\n-         --  references to the formal parameter.\n+         --  Otherwise the pragma appears without an argument\n \n          else\n-            Expr := New_Copy_Tree (Expr);\n-            Replace_Type_References (Expr, Typ);\n-\n-            --  Generate:\n-            --    pragma Check (Default_Initial_Condition, <Expr>);\n-\n-            Stmt :=\n-              Make_Pragma (Loc,\n-                Pragma_Identifier            =>\n-                  Make_Identifier (Loc, Name_Check),\n-\n-                Pragma_Argument_Associations => New_List (\n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression =>\n-                      Make_Identifier (Loc, Name_Default_Initial_Condition)),\n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression => Expr)));\n+            Stmt := Make_Null_Statement (Loc);\n          end if;\n \n-      --  Otherwise the pragma appears without an argument\n+         --  Generate:\n+         --    procedure <Typ>Default_Init_Cond (I : <Typ>) is\n+         --    begin\n+         --       <Stmt>;\n+         --    end <Typ>Default_Init_Cond;\n \n-      else\n-         Stmt := Make_Null_Statement (Loc);\n-      end if;\n+         Body_Decl :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Copy_Separate_Tree (Specification (Spec_Decl)),\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Stmt)));\n \n-      --  Generate:\n-      --    procedure <Typ>Default_Init_Cond (I : <Typ>) is\n-      --    begin\n-      --       <Stmt>;\n-      --    end <Typ>Default_Init_Cond;\n-\n-      Body_Decl :=\n-        Make_Subprogram_Body (Loc,\n-          Specification              =>\n-            Copy_Separate_Tree (Specification (Spec_Decl)),\n-          Declarations               => Empty_List,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Stmt)));\n-\n-      --  Link the spec and body of the default initial condition procedure\n-      --  to prevent the generation of a duplicate body in case there is an\n-      --  attempt to freeze the related type again.\n-\n-      Set_Corresponding_Body (Spec_Decl, Defining_Entity (Body_Decl));\n-      Set_Corresponding_Spec (Body_Decl, Proc_Id);\n-\n-      Append_Freeze_Action (Typ, Body_Decl);\n-   end Build_Default_Init_Cond_Procedure_Body;\n+         --  Link the spec and body of the default initial condition procedure\n+         --  to prevent the generation of a duplicate body.\n+\n+         Set_Corresponding_Body (Spec_Decl, Defining_Entity (Body_Decl));\n+         Set_Corresponding_Spec (Body_Decl, Proc_Id);\n+\n+         Insert_After_And_Analyze (Declaration_Node (Typ), Body_Decl);\n+      end Build_Default_Init_Cond_Procedure_Body;\n+\n+      --  Local variables\n+\n+      Decl : Node_Id;\n+      Typ  : Entity_Id;\n+\n+   --  Start of processing for Build_Default_Init_Cond_Procedure_Bodies\n+\n+   begin\n+      --  Inspect the private declarations looking for [sub]type declarations\n+\n+      Decl := First (Priv_Decls);\n+      while Present (Decl) loop\n+         if Nkind_In (Decl, N_Full_Type_Declaration,\n+                            N_Subtype_Declaration)\n+         then\n+            Typ := Defining_Entity (Decl);\n+\n+            --  Guard against partially decorate types due to previous errors\n+\n+            if Is_Type (Typ) then\n+\n+               --  If the type is subject to pragma Default_Initial_Condition,\n+               --  generate the body of the internal procedure which verifies\n+               --  the assertion of the pragma at runtime.\n+\n+               if Has_Default_Init_Cond (Typ) then\n+                  Build_Default_Init_Cond_Procedure_Body (Typ);\n+\n+               --  A derived type inherits the default initial condition\n+               --  procedure from its parent type.\n+\n+               elsif Has_Inherited_Default_Init_Cond (Typ) then\n+                  Inherit_Default_Init_Cond_Procedure (Typ);\n+               end if;\n+            end if;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+   end Build_Default_Init_Cond_Procedure_Bodies;\n \n    ---------------------------------------------------\n    -- Build_Default_Init_Cond_Procedure_Declaration --"}, {"sha": "2892916c75708b4687f7d7b2dea3f810035c9378", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a74a7b056cc46079cd4146f25ee22708f473ac5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=6a74a7b056cc46079cd4146f25ee22708f473ac5", "patch": "@@ -218,11 +218,10 @@ package Sem_Util is\n    --  Build a call to the default initial condition procedure of type Typ with\n    --  Obj_Id as the actual parameter.\n \n-   procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id);\n-   --  If private type Typ is subject to pragma Default_Initial_Condition,\n-   --  build the body of the procedure which verifies the assumption of the\n-   --  pragma at runtime. The generated body is added to the freeze actions\n-   --  of the type.\n+   procedure Build_Default_Init_Cond_Procedure_Bodies (Priv_Decls : List_Id);\n+   --  Inspect the contents of private declarations Priv_Decls and build the\n+   --  bodies the default initial condition procedures for all types subject\n+   --  to pragma Default_Initial_Condition.\n \n    procedure Build_Default_Init_Cond_Procedure_Declaration (Typ : Entity_Id);\n    --  If private type Typ is subject to pragma Default_Initial_Condition,"}]}