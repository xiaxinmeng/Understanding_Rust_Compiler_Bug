{"sha": "afa1738b588b778082a43c3c933f8a4b412a831d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZhMTczOGI1ODhiNzc4MDgyYTQzYzNjOTMzZjhhNGI0MTJhODMxZA==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-09-09T23:02:15Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-09-09T23:02:15Z"}, "message": "loop.h (struct loop_mem_info): Move from loop.c (struct loop_info): Add fields store_mems...\n\n\t* loop.h (struct loop_mem_info): Move from loop.c\n\t(struct loop_info): Add fields store_mems, mems, mems_idx,\n\tmems_allocated, unknown_address_altered,\n\tunknown_constant_address_altered, num_mem_sets, and\n\tfirst_loop_store_insn.\n\n\t* loop.c (loop_store_mems): Replace with field in loop_info struct.\n\t(loop_mems, loop_mems_idx, loop_mems_allocated): Likewise.\n\t(unknown_address_altered, unknown_constant_address_altered): Likewise.\n\t(num_mem_sets): Likewise.\n \t(replace_loop_mems, replace_loop_regs): New.\n\t(struct loop_replace_args): New.\n\t(load_mems): Use replace_loop_mems.\n\t(try_copy_prop): Use replace_loop_regs.\n\t(replace_loop_reg, replace_loop_mem): Use loop_replace_args structure.\n\nFrom-SVN: r36284", "tree": {"sha": "d8fbd83f8b201ad6fc4771e3ecc10960af06c915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8fbd83f8b201ad6fc4771e3ecc10960af06c915"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afa1738b588b778082a43c3c933f8a4b412a831d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa1738b588b778082a43c3c933f8a4b412a831d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa1738b588b778082a43c3c933f8a4b412a831d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa1738b588b778082a43c3c933f8a4b412a831d/comments", "author": null, "committer": null, "parents": [{"sha": "8a019bcf78138e8b202cf5a2f9164451fa335fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a019bcf78138e8b202cf5a2f9164451fa335fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a019bcf78138e8b202cf5a2f9164451fa335fac"}], "stats": {"total": 336, "additions": 188, "deletions": 148}, "files": [{"sha": "50a5643f02327896f4c27e1b4e5dd36984eddaab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1738b588b778082a43c3c933f8a4b412a831d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1738b588b778082a43c3c933f8a4b412a831d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afa1738b588b778082a43c3c933f8a4b412a831d", "patch": "@@ -1,3 +1,21 @@\n+2000-09-11  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* loop.h (struct loop_mem_info): Move from loop.c\n+\t(struct loop_info): Add fields store_mems, mems, mems_idx,\n+\tmems_allocated, unknown_address_altered,\n+\tunknown_constant_address_altered, num_mem_sets, and\n+\tfirst_loop_store_insn.\n+\n+\t* loop.c (loop_store_mems): Replace with field in loop_info struct.\n+\t(loop_mems, loop_mems_idx, loop_mems_allocated): Likewise.\n+\t(unknown_address_altered, unknown_constant_address_altered): Likewise.\n+\t(num_mem_sets): Likewise.\n+ \t(replace_loop_mems, replace_loop_regs): New.\n+\t(struct loop_replace_args): New.\n+\t(load_mems): Use replace_loop_mems.\n+\t(try_copy_prop): Use replace_loop_regs.\n+\t(replace_loop_reg, replace_loop_mem): Use loop_replace_args structure.\n+\n 2000-09-09  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* configure.in: Recognize m6811-elf and m6812-elf."}, {"sha": "33e2e292fd427932ccae2664ce9008a2274097a5", "filename": "gcc/loop.c", "status": "modified", "additions": 137, "deletions": 148, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1738b588b778082a43c3c933f8a4b412a831d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1738b588b778082a43c3c933f8a4b412a831d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=afa1738b588b778082a43c3c933f8a4b412a831d", "patch": "@@ -113,49 +113,6 @@ static varray_type reg_single_usage;\n \n static char *moved_once;\n \n-/* List of MEMs that are stored in this loop.  */\n-\n-static rtx loop_store_mems;\n-\n-/* The insn where the first of these was found.  */\n-static rtx first_loop_store_insn;\n-\n-typedef struct loop_mem_info {\n-  rtx mem;      /* The MEM itself.  */\n-  rtx reg;      /* Corresponding pseudo, if any.  */\n-  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n-} loop_mem_info;\n-\n-/* Array of MEMs that are used (read or written) in this loop, but\n-   cannot be aliased by anything in this loop, except perhaps\n-   themselves.  In other words, if loop_mems[i] is altered during the\n-   loop, it is altered by an expression that is rtx_equal_p to it.  */\n-\n-static loop_mem_info *loop_mems;\n-\n-/* The index of the next available slot in LOOP_MEMS.  */\n-\n-static int loop_mems_idx;\n-\n-/* The number of elements allocated in LOOP_MEMs.  */\n-\n-static int loop_mems_allocated;\n-\n-/* Nonzero if we don't know what MEMs were changed in the current\n-   loop.  This happens if the loop contains a call (in which case\n-   `loop_info->has_call' will also be set) or if we store into more\n-   than NUM_STORES MEMs.  */\n-\n-static int unknown_address_altered;\n-\n-/* The above doesn't count any readonly memory locations that are stored.\n-   This does.  */\n-\n-static int unknown_constant_address_altered;\n-\n-/* Count of memory write instructions discovered in the loop.  */\n-static int num_mem_sets;\n-\n /* Bound on pseudo register number before loop optimization.\n    A pseudo has valid regscan info if its number is < max_reg_before_loop.  */\n unsigned int max_reg_before_loop;\n@@ -314,7 +271,9 @@ static void load_mems_and_recount_loop_regs_set PARAMS ((const struct loop*,\n static void load_mems PARAMS ((const struct loop *));\n static int insert_loop_mem PARAMS ((rtx *, void *));\n static int replace_loop_mem PARAMS ((rtx *, void *));\n+static void replace_loop_mems PARAMS ((rtx, rtx, rtx));\n static int replace_loop_reg PARAMS ((rtx *, void *));\n+static void replace_loop_regs PARAMS ((rtx insn, rtx, rtx));\n static void note_reg_stored PARAMS ((rtx, rtx, void *));\n static void try_copy_prop PARAMS ((const struct loop *, rtx, unsigned int));\n static void try_swap_copy_prop PARAMS ((const struct loop *, rtx,\n@@ -327,16 +286,18 @@ static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n void debug_loop PARAMS ((const struct loop *));\n \n-typedef struct rtx_and_int {\n-  rtx r;\n-  int i;\n-} rtx_and_int;\n-\n typedef struct rtx_pair {\n   rtx r1;\n   rtx r2;\n } rtx_pair;\n \n+typedef struct loop_replace_args\n+{\n+  rtx match;\n+  rtx replacement;\n+  rtx insn;\n+} loop_replace_args;\n+\n /* Nonzero iff INSN is between START and END, inclusive.  */\n #define INSN_IN_RANGE_P(INSN, START, END) \t\\\n   (INSN_UID (INSN) < max_uid_for_loop \t\t\\\n@@ -616,12 +577,12 @@ scan_loop (loop, flags)\n   int loop_depth = 0;\n   int nregs;\n \n+  loop->top = 0;\n+\n   movables->head = 0;\n   movables->last = 0;\n   movables->num = 0;\n \n-  loop->top = 0;\n-\n   /* Determine whether this loop starts with a jump down to a test at\n      the end.  This will occur for a small number of loops with a test\n      that is too complex to duplicate in front of the loop.\n@@ -704,7 +665,7 @@ scan_loop (loop, flags)\n      that even after the moving of movables creates some new registers\n      we won't have to reallocate these arrays.  However, we do grow\n      the arrays, if necessary, in load_mems_recount_loop_regs_set.  */\n-  nregs = max_reg_num () + loop_mems_idx + 16;\n+  nregs = max_reg_num () + loop_info->mems_idx + 16;\n   VARRAY_INT_INIT (set_in_loop, nregs, \"set_in_loop\");\n   VARRAY_INT_INIT (n_times_set, nregs, \"n_times_set\");\n   VARRAY_CHAR_INIT (may_not_optimize, nregs, \"may_not_optimize\");\n@@ -2332,10 +2293,10 @@ count_nonfixed_reads (loop, x)\n }\n \f\n /* Scan a loop setting the elements `cont', `vtop', `loops_enclosed',\n-   `has_call', `has_volatile', and `has_tablejump' within LOOP.\n-   Set the global variables `unknown_address_altered',\n-   `unknown_constant_address_altered', and `num_mem_sets'.  Also, fill\n-   in the array `loop_mems' and the list `loop_store_mems'.  */\n+   `has_call', `has_volatile', `has_tablejump',\n+   `unknown_address_altered', `unknown_constant_address_altered', and\n+   `num_mem_sets' in LOOP.  Also, fill in the array `mems' and the\n+   list `store_mems' in LOOP.  */\n \n static void\n prescan_loop (loop)\n@@ -2359,12 +2320,12 @@ prescan_loop (loop)\n   loop_info->has_multiple_exit_targets = 0;\n   loop->level = 1;\n \n-  unknown_address_altered = 0;\n-  unknown_constant_address_altered = 0;\n-  loop_store_mems = NULL_RTX;\n-  first_loop_store_insn = NULL_RTX;\n-  loop_mems_idx = 0;\n-  num_mem_sets = 0;\n+  loop_info->unknown_address_altered = 0;\n+  loop_info->unknown_constant_address_altered = 0;\n+  loop_info->store_mems = NULL_RTX;\n+  loop_info->first_loop_store_insn = NULL_RTX;\n+  loop_info->mems_idx = 0;\n+  loop_info->num_mem_sets = 0;\n \n   for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n        insn = NEXT_INSN (insn))\n@@ -2385,7 +2346,7 @@ prescan_loop (loop)\n       else if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  if (! CONST_CALL_P (insn))\n-\t    unknown_address_altered = 1;\n+\t    loop_info->unknown_address_altered = 1;\n \t  loop_info->has_call = 1;\n \t}\n       else if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n@@ -2401,9 +2362,9 @@ prescan_loop (loop)\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n \t    loop_info->has_tablejump = 1;\n \n-\t  note_stores (PATTERN (insn), note_addr_stored, NULL);\n-\t  if (! first_loop_store_insn && loop_store_mems)\n-\t    first_loop_store_insn = insn;\n+\t  note_stores (PATTERN (insn), note_addr_stored, loop_info);\n+\t  if (! loop_info->first_loop_store_insn && loop_info->store_mems)\n+\t    loop_info->first_loop_store_insn = insn;\n \n \t  if (! loop_info->has_multiple_exit_targets\n \t      && GET_CODE (insn) == JUMP_INSN\n@@ -2463,23 +2424,25 @@ prescan_loop (loop)\n       && ! loop_info->has_multiple_exit_targets)\n     for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n \t insn = NEXT_INSN (insn))\n-      for_each_rtx (&insn, insert_loop_mem, 0);\n+      for_each_rtx (&insn, insert_loop_mem, loop_info);\n \n   /* BLKmode MEMs are added to LOOP_STORE_MEM as necessary so\n      that loop_invariant_p and load_mems can use true_dependence\n      to determine what is really clobbered.  */\n-  if (unknown_address_altered)\n+  if (loop_info->unknown_address_altered)\n     {\n       rtx mem = gen_rtx_MEM (BLKmode, const0_rtx);\n \n-      loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, mem, loop_store_mems);\n+      loop_info->store_mems \n+\t= gen_rtx_EXPR_LIST (VOIDmode, mem, loop_info->store_mems);\n     }\n-  if (unknown_constant_address_altered)\n+  if (loop_info->unknown_constant_address_altered)\n     {\n       rtx mem = gen_rtx_MEM (BLKmode, const0_rtx);\n \n       RTX_UNCHANGING_P (mem) = 1;\n-      loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, mem, loop_store_mems);\n+      loop_info->store_mems \n+\t= gen_rtx_EXPR_LIST (VOIDmode, mem, loop_info->store_mems);\n     }\n }\n \f\n@@ -3093,25 +3056,28 @@ note_addr_stored (x, y, data)\n      rtx y ATTRIBUTE_UNUSED;\n      void *data ATTRIBUTE_UNUSED;\n {\n+  struct loop_info *loop_info = data;\n+\n   if (x == 0 || GET_CODE (x) != MEM)\n     return;\n \n   /* Count number of memory writes.\n      This affects heuristics in strength_reduce.  */\n-  num_mem_sets++;\n-\n+  loop_info->num_mem_sets++;\n+  \n   /* BLKmode MEM means all memory is clobbered.  */\n-    if (GET_MODE (x) == BLKmode)\n+  if (GET_MODE (x) == BLKmode)\n     {\n       if (RTX_UNCHANGING_P (x))\n-\tunknown_constant_address_altered = 1;\n+\tloop_info->unknown_constant_address_altered = 1;\n       else\n-\tunknown_address_altered = 1;\n-\n+\tloop_info->unknown_address_altered = 1;\n+      \n       return;\n     }\n-\n-  loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, x, loop_store_mems);\n+  \n+  loop_info->store_mems = gen_rtx_EXPR_LIST (VOIDmode, x, \n+\t\t\t\t\t     loop_info->store_mems);\n }\n \n /* X is a value modified by an INSN that references a biv inside a loop\n@@ -3151,13 +3117,14 @@ note_set_pseudo_multiple_uses (x, y, data)\n    The value is 2 if we refer to something only conditionally invariant.\n \n    A memory ref is invariant if it is not volatile and does not conflict\n-   with anything stored in `loop_store_mems'.  */\n+   with anything stored in `loop_info->store_mems'.  */\n \n int\n loop_invariant_p (loop, x)\n      const struct loop *loop;\n      register rtx x;\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n   register int i;\n   register enum rtx_code code;\n   register const char *fmt;\n@@ -3221,7 +3188,7 @@ loop_invariant_p (loop, x)\n \treturn 0;\n \n       /* See if there is any dependence between a store and this load.  */\n-      mem_list_entry = loop_store_mems;\n+      mem_list_entry = loop_info->store_mems;\n       while (mem_list_entry)\n \t{\n \t  if (true_dependence (XEXP (mem_list_entry, 0), VOIDmode,\n@@ -8220,7 +8187,7 @@ check_dbra_loop (loop, insn_count)\n       if (no_use_except_counting)\n \t/* No need to worry about MEMs.  */\n \t;\n-      else if (num_mem_sets <= 1)\n+      else if (loop_info->num_mem_sets <= 1)\n \t{\n \t  for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n \t    if (INSN_P (p))\n@@ -8232,15 +8199,15 @@ check_dbra_loop (loop, insn_count)\n \t     This would work if the source was invariant also, however, in that\n \t     case, the insn should have been moved out of the loop.  */\n \n-\t  if (num_mem_sets == 1)\n+\t  if (loop_info->num_mem_sets == 1)\n \t    {\n \t      struct induction *v;\n \n \t      reversible_mem_store\n-\t\t= (! unknown_address_altered\n-\t\t   && ! unknown_constant_address_altered\n+\t\t= (! loop_info->unknown_address_altered\n+\t\t   && ! loop_info->unknown_constant_address_altered\n \t\t   && ! loop_invariant_p (loop,\n-\t\t\t\t\t  XEXP (XEXP (loop_store_mems, 0),\n+\t\t\t\t\t  XEXP (XEXP (loop_info->store_mems, 0),\n \t\t\t\t\t\t0)));\n \n \t      /* If the store depends on a register that is set after the\n@@ -8250,8 +8217,9 @@ check_dbra_loop (loop, insn_count)\n \t\t{\n \t\t  if (v->giv_type == DEST_REG\n \t\t      && reg_mentioned_p (v->dest_reg,\n-\t\t\t\t\t  PATTERN (first_loop_store_insn))\n-\t\t      && loop_insn_first_p (first_loop_store_insn, v->insn))\n+\t\t\t\t\t  PATTERN (loop_info->first_loop_store_insn))\n+\t\t      && loop_insn_first_p (loop_info->first_loop_store_insn, \n+\t\t\t\t\t    v->insn))\n \t\t    reversible_mem_store = 0;\n \t\t}\n \t    }\n@@ -8271,7 +8239,7 @@ check_dbra_loop (loop, insn_count)\n \t   && ! loop_info->has_call\n \t   && ! loop_info->has_volatile\n \t   && reversible_mem_store\n-\t   && (bl->giv_count + bl->biv_count + num_mem_sets\n+\t   && (bl->giv_count + bl->biv_count + loop_info->num_mem_sets\n \t      + the_movables.num + compare_and_branch == insn_count)\n \t   && (bl == loop_iv_list && bl->next == 0))\n \t  || no_use_except_counting)\n@@ -9544,6 +9512,7 @@ insert_loop_mem (mem, data)\n      rtx *mem;\n      void *data ATTRIBUTE_UNUSED;\n {\n+  struct loop_info *loop_info = data;\n   int i;\n   rtx m = *mem;\n \n@@ -9574,40 +9543,40 @@ insert_loop_mem (mem, data)\n     }\n \n   /* See if we've already seen this MEM.  */\n-  for (i = 0; i < loop_mems_idx; ++i)\n-    if (rtx_equal_p (m, loop_mems[i].mem))\n+  for (i = 0; i < loop_info->mems_idx; ++i)\n+    if (rtx_equal_p (m, loop_info->mems[i].mem))\n       {\n-\tif (GET_MODE (m) != GET_MODE (loop_mems[i].mem))\n+\tif (GET_MODE (m) != GET_MODE (loop_info->mems[i].mem))\n \t  /* The modes of the two memory accesses are different.  If\n \t     this happens, something tricky is going on, and we just\n \t     don't optimize accesses to this MEM.  */\n-\t  loop_mems[i].optimize = 0;\n+\t  loop_info->mems[i].optimize = 0;\n \n \treturn 0;\n       }\n \n   /* Resize the array, if necessary.  */\n-  if (loop_mems_idx == loop_mems_allocated)\n+  if (loop_info->mems_idx == loop_info->mems_allocated)\n     {\n-      if (loop_mems_allocated != 0)\n-\tloop_mems_allocated *= 2;\n+      if (loop_info->mems_allocated != 0)\n+\tloop_info->mems_allocated *= 2;\n       else\n-\tloop_mems_allocated = 32;\n+\tloop_info->mems_allocated = 32;\n \n-      loop_mems = (loop_mem_info*)\n-\txrealloc (loop_mems,\n-\t\t  loop_mems_allocated * sizeof (loop_mem_info));\n+      loop_info->mems = (loop_mem_info*)\n+\txrealloc (loop_info->mems,\n+\t\t  loop_info->mems_allocated * sizeof (loop_mem_info));\n     }\n \n   /* Actually insert the MEM.  */\n-  loop_mems[loop_mems_idx].mem = m;\n+  loop_info->mems[loop_info->mems_idx].mem = m;\n   /* We can't hoist this MEM out of the loop if it's a BLKmode MEM\n      because we can't put it in a register.  We still store it in the\n      table, though, so that if we see the same address later, but in a\n      non-BLK mode, we'll not think we can optimize it at that point.  */\n-  loop_mems[loop_mems_idx].optimize = (GET_MODE (m) != BLKmode);\n-  loop_mems[loop_mems_idx].reg = NULL_RTX;\n-  ++loop_mems_idx;\n+  loop_info->mems[loop_info->mems_idx].optimize = (GET_MODE (m) != BLKmode);\n+  loop_info->mems[loop_info->mems_idx].reg = NULL_RTX;\n+  ++loop_info->mems_idx;\n \n   return 0;\n }\n@@ -9678,6 +9647,7 @@ static void\n load_mems (loop)\n      const struct loop *loop;\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n   int maybe_never = 0;\n   int i;\n   rtx p;\n@@ -9687,7 +9657,7 @@ load_mems (loop)\n   int next_maybe_never = 0;\n   int last_max_reg = max_reg_num ();\n \n-  if (loop_mems_idx == 0)\n+  if (loop_info->mems_idx == 0)\n     return;\n \n   /* Find start of the extended basic block that enters the loop.  */\n@@ -9736,23 +9706,23 @@ load_mems (loop)\n     }\n \n   /* Actually move the MEMs.  */\n-  for (i = 0; i < loop_mems_idx; ++i)\n+  for (i = 0; i < loop_info->mems_idx; ++i)\n     {\n       regset_head load_copies;\n       regset_head store_copies;\n       int written = 0;\n       rtx reg;\n-      rtx mem = loop_mems[i].mem;\n+      rtx mem = loop_info->mems[i].mem;\n       rtx mem_list_entry;\n \n       if (MEM_VOLATILE_P (mem)\n \t  || loop_invariant_p (loop, XEXP (mem, 0)) != 1)\n \t/* There's no telling whether or not MEM is modified.  */\n-\tloop_mems[i].optimize = 0;\n+\tloop_info->mems[i].optimize = 0;\n \n       /* Go through the MEMs written to in the loop to see if this\n \t one is aliased by one of them.  */\n-      mem_list_entry = loop_store_mems;\n+      mem_list_entry = loop_info->store_mems;\n       while (mem_list_entry)\n \t{\n \t  if (rtx_equal_p (mem, XEXP (mem_list_entry, 0)))\n@@ -9761,35 +9731,35 @@ load_mems (loop)\n \t\t\t\t    mem, rtx_varies_p))\n \t    {\n \t      /* MEM is indeed aliased by this store.  */\n-\t      loop_mems[i].optimize = 0;\n+\t      loop_info->mems[i].optimize = 0;\n \t      break;\n \t    }\n \t  mem_list_entry = XEXP (mem_list_entry, 1);\n \t}\n \n       if (flag_float_store && written\n \t  && GET_MODE_CLASS (GET_MODE (mem)) == MODE_FLOAT)\n-\tloop_mems[i].optimize = 0;\n+\tloop_info->mems[i].optimize = 0;\n \n       /* If this MEM is written to, we must be sure that there\n \t are no reads from another MEM that aliases this one.  */\n-      if (loop_mems[i].optimize && written)\n+      if (loop_info->mems[i].optimize && written)\n \t{\n \t  int j;\n \n-\t  for (j = 0; j < loop_mems_idx; ++j)\n+\t  for (j = 0; j < loop_info->mems_idx; ++j)\n \t    {\n \t      if (j == i)\n \t\tcontinue;\n \t      else if (true_dependence (mem,\n \t\t\t\t\tVOIDmode,\n-\t\t\t\t\tloop_mems[j].mem,\n+\t\t\t\t\tloop_info->mems[j].mem,\n \t\t\t\t\trtx_varies_p))\n \t\t{\n-\t\t  /* It's not safe to hoist loop_mems[i] out of\n+\t\t  /* It's not safe to hoist loop_info->mems[i] out of\n \t\t     the loop because writes to it might not be\n-\t\t     seen by reads from loop_mems[j].  */\n-\t\t  loop_mems[i].optimize = 0;\n+\t\t     seen by reads from loop_info->mems[j].  */\n+\t\t  loop_info->mems[i].optimize = 0;\n \t\t  break;\n \t\t}\n \t    }\n@@ -9798,9 +9768,9 @@ load_mems (loop)\n       if (maybe_never && may_trap_p (mem))\n \t/* We can't access the MEM outside the loop; it might\n \t   cause a trap that wouldn't have happened otherwise.  */\n-\tloop_mems[i].optimize = 0;\n+\tloop_info->mems[i].optimize = 0;\n \n-      if (!loop_mems[i].optimize)\n+      if (!loop_info->mems[i].optimize)\n \t/* We thought we were going to lift this MEM out of the\n \t   loop, but later discovered that we could not.  */\n \tcontinue;\n@@ -9814,7 +9784,7 @@ load_mems (loop)\n \t user-variable nor used in the loop test.  */\n       reg = gen_reg_rtx (GET_MODE (mem));\n       REG_USERVAR_P (reg) = 1;\n-      loop_mems[i].reg = reg;\n+      loop_info->mems[i].reg = reg;\n \n       /* Now, replace all references to the MEM with the\n \t corresponding pesudos.  */\n@@ -9823,8 +9793,6 @@ load_mems (loop)\n \t   p != NULL_RTX;\n \t   p = next_insn_in_loop (loop, p))\n \t{\n-\t  rtx_and_int ri;\n-\n \t  if (INSN_P (p))\n \t    {\n \t      rtx set;\n@@ -9859,9 +9827,8 @@ load_mems (loop)\n  \t\tSET_REGNO_REG_SET (&store_copies, REGNO (SET_SRC (set)));\n  \t      \n  \t      /* Replace the memory reference with the shadow register.  */\n-\t      ri.r = p;\n-\t      ri.i = i;\n-\t      for_each_rtx (&p, replace_loop_mem, &ri);\n+\t      replace_loop_mems (p, loop_info->mems[i].mem,\n+\t\t\t\t loop_info->mems[i].reg);\n \t    }\n \n \t  if (GET_CODE (p) == CODE_LABEL\n@@ -9871,7 +9838,7 @@ load_mems (loop)\n \n       if (! apply_change_group ())\n \t/* We couldn't replace all occurrences of the MEM.  */\n-\tloop_mems[i].optimize = 0;\n+\tloop_info->mems[i].optimize = 0;\n       else\n \t{\n \t  /* Load the memory immediately before LOOP->START, which is\n@@ -10065,12 +10032,8 @@ try_copy_prop (loop, replacement, regno)\n       if (init_insn && insn != init_insn)\n \t{\n \t  struct note_reg_stored_arg arg;\n-\t  rtx array[3];\n-\t  array[0] = reg_rtx;\n-\t  array[1] = replacement;\n-\t  array[2] = insn;\n \n-\t  for_each_rtx (&insn, replace_loop_reg, array);\n+\t  replace_loop_regs (insn, reg_rtx, replacement);\n \t  if (REGNO_LAST_UID (regno) == INSN_UID (insn))\n \t    replaced_last = 1;\n \n@@ -10191,18 +10154,16 @@ try_swap_copy_prop (loop, replacement, regno)\n \n \n /* Replace MEM with its associated pseudo register.  This function is\n-   called from load_mems via for_each_rtx.  DATA is actually an\n-   rtx_and_int * describing the instruction currently being scanned\n+   called from load_mems via for_each_rtx.  DATA is actually a pointer\n+   to a structure describing the instruction currently being scanned\n    and the MEM we are currently replacing.  */\n \n static int\n replace_loop_mem (mem, data)\n      rtx *mem;\n      void *data;\n {\n-  rtx_and_int *ri;\n-  rtx insn;\n-  int i;\n+  loop_replace_args *args = (loop_replace_args *)data;\n   rtx m = *mem;\n \n   if (m == NULL_RTX)\n@@ -10223,43 +10184,71 @@ replace_loop_mem (mem, data)\n       return 0;\n     }\n \n-  ri = (rtx_and_int *) data;\n-  i = ri->i;\n-\n-  if (!rtx_equal_p (loop_mems[i].mem, m))\n+  if (!rtx_equal_p (args->match, m))\n     /* This is not the MEM we are currently replacing.  */\n     return 0;\n \n-  insn = ri->r;\n-\n   /* Actually replace the MEM.  */\n-  validate_change (insn, mem, loop_mems[i].reg, 1);\n+  validate_change (args->insn, mem, args->replacement, 1);\n \n   return 0;\n }\n \n+\n+static void\n+replace_loop_mems (insn, mem, reg)\n+      rtx insn;\n+      rtx mem;\n+      rtx reg;\n+{\t    \n+  loop_replace_args args;\n+\n+  args.insn = insn;\n+  args.match = mem;\n+  args.replacement = reg;\n+\n+  for_each_rtx (&insn, replace_loop_mem, &args);\n+}\n+\n+\n /* Replace one register with another.  Called through for_each_rtx; PX points\n-   to the rtx being scanned.  DATA is actually an array of three rtx's; the\n-   first one is the one to be replaced, and the second one the replacement.\n-   The third one is the current insn.  */\n+   to the rtx being scanned.  DATA is actually a pointer to \n+   a structure of arguments.  */\n \n static int\n replace_loop_reg (px, data)\n      rtx *px;\n      void *data;\n {\n   rtx x = *px;\n-  rtx *array = (rtx *) data;\n+  loop_replace_args *args = (loop_replace_args *)data;\n \n   if (x == NULL_RTX)\n     return 0;\n \n-  if (x == array[0])\n-    validate_change (array[2], px, array[1], 1);\n+  if (x == args->match)\n+    validate_change (args->insn, px, args->replacement, 1);\n \n   return 0;\n }\n \n+\n+static void\n+replace_loop_regs (insn, reg, replacement)\n+     rtx insn;\n+     rtx reg;\n+     rtx replacement;\n+{\n+  loop_replace_args args;\n+\n+  args.insn = insn;\n+  args.match = reg;\n+  args.replacement = replacement;\n+\n+  for_each_rtx (&insn, replace_loop_reg, &args);\n+}\n+\n+\n /* Replace occurrences of the old exit label for the loop with the new\n    one.  DATA is an rtx_pair containing the old and new labels,\n    respectively.  */"}, {"sha": "78939a1d1b944ae6c6bdf97ad68570b5b55339ca", "filename": "gcc/loop.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1738b588b778082a43c3c933f8a4b412a831d/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1738b588b778082a43c3c933f8a4b412a831d/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=afa1738b588b778082a43c3c933f8a4b412a831d", "patch": "@@ -164,6 +164,15 @@ struct iv_class {\n \t\t\t\t   biv controls. */\n };\n \n+\n+typedef struct loop_mem_info\n+{\n+  rtx mem;      /* The MEM itself.  */\n+  rtx reg;      /* Corresponding pseudo, if any.  */\n+  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n+} loop_mem_info;\n+\n+\n /* Information required to calculate the number of loop iterations. \n    This is set by loop_iterations.  */\n \n@@ -207,6 +216,30 @@ struct loop_info\n   /* The number of times the loop body was unrolled.  */\n   unsigned int unroll_number;\n   int used_count_register;\n+  /* List of MEMs that are stored in this loop.  */\n+  rtx store_mems;\n+  /* Array of MEMs that are used (read or written) in this loop, but\n+     cannot be aliased by anything in this loop, except perhaps\n+     themselves.  In other words, if mems[i] is altered during\n+     the loop, it is altered by an expression that is rtx_equal_p to\n+     it.  */\n+  loop_mem_info *mems;\n+  /* The index of the next available slot in MEMS.  */\n+  int mems_idx;\n+  /* The number of elements allocated in MEMS.  */\n+  int mems_allocated;\n+  /* Nonzero if we don't know what MEMs were changed in the current\n+     loop.  This happens if the loop contains a call (in which case\n+     `has_call' will also be set) or if we store into more than\n+     NUM_STORES MEMs.  */\n+  int unknown_address_altered;\n+  /* The above doesn't count any readonly memory locations that are\n+     stored.  This does.  */\n+  int unknown_constant_address_altered;\n+  /* Count of memory write instructions discovered in the loop.  */\n+  int num_mem_sets;\n+  /* The insn where the first of these was found.  */\n+  rtx first_loop_store_insn;\n };\n \n /* Definitions used by the basic induction variable discovery code.  */"}]}