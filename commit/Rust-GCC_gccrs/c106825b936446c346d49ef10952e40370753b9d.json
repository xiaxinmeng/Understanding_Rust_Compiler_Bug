{"sha": "c106825b936446c346d49ef10952e40370753b9d", "node_id": "C_kwDOANBUbNoAKGMxMDY4MjViOTM2NDQ2YzM0NmQ0OWVmMTA5NTJlNDAzNzA3NTNiOWQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-09T15:43:47Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-10T07:51:48Z"}, "message": "Cleanups to irange::nonzero bit code.\n\nIn discussions with Andrew we realized varying_p() was returning true\nfor a range of the entire domain with a non-empty nonzero mask.  This\nis confusing as varying_p() should only return true when absolutely no\ninformation is available.  A nonzero mask that has any cleared bits is\nextra information and must return false for varying_p().  This patch\nfixes this oversight.  Now a range of the entire domain with nonzero\nbits, is internally set to VR_RANGE (with the appropriate end points\nset).  VR_VARYING ranges must have a null nonzero mask.\n\nAlso, the union and intersect code were not quite right in the presence of\nnonzero masks.  Sometimes we would drop masks to -1 unnecessarily.  I\nwas trying to be too smart in avoiding extra work when the mask was\nNULL, but there's also an implicit mask in the range that must be\ntaken into account.  For example, [0,0] may have no nonzero bits set\nexplicitly, but the mask is really 0x0.  This will all be simpler when\nwe drop trees, because the nonzero bits will always be set, even if\n-1.\n\nFinally, I've added unit tests to the nonzero mask code.  This should\nhelp us maintain sanity going forward.\n\nThere should be no visible changes, as the main consumer of this code\nis the SSA_NAME_RANGE_INFO patchset which has yet to be committed.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (irange::operator=): Call verify_range.\n\t(irange::irange_set): Normalize kind after everything else has\n\tbeen set.\n\t(irange::irange_set_anti_range): Same.\n\t(irange::set): Same.\n\t(irange::verify_range): Disallow nonzero masks for VARYING.\n\t(irange::irange_union): Call verify_range.\n\tHandle nonzero masks better.\n\t(irange::irange_intersect): Same.\n\t(irange::set_nonzero_bits): Calculate mask if either range has an\n\texplicit mask.\n\t(irange::intersect_nonzero_bits): Same.\n\t(irange::union_nonzero_bits): Same.\n\t(range_tests_nonzero_bits): New.\n\t(range_tests): Call range_tests_nonzero_bits.\n\t* value-range.h (class irange): Remove set_nonzero_bits method\n\twith trees.\n\t(irange::varying_compatible_p): Set nonzero mask.", "tree": {"sha": "519b54e869fafe79f056e806c3f01b8ff762b68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/519b54e869fafe79f056e806c3f01b8ff762b68a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c106825b936446c346d49ef10952e40370753b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c106825b936446c346d49ef10952e40370753b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c106825b936446c346d49ef10952e40370753b9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c106825b936446c346d49ef10952e40370753b9d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8cfc36b9964e5b62433269182232e59d82d6a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8cfc36b9964e5b62433269182232e59d82d6a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8cfc36b9964e5b62433269182232e59d82d6a23"}], "stats": {"total": 172, "additions": 133, "deletions": 39}, "files": [{"sha": "a02fab47fc4afb00927be74d5accfc12f0973c6e", "filename": "gcc/value-range.cc", "status": "modified", "additions": 130, "deletions": 37, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c106825b936446c346d49ef10952e40370753b9d/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c106825b936446c346d49ef10952e40370753b9d/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=c106825b936446c346d49ef10952e40370753b9d", "patch": "@@ -275,6 +275,8 @@ irange::operator= (const irange &src)\n   m_num_ranges = lim;\n   m_kind = src.m_kind;\n   m_nonzero_mask = src.m_nonzero_mask;\n+  if (flag_checking)\n+    verify_range ();\n   return *this;\n }\n \n@@ -393,8 +395,8 @@ irange::irange_set (tree min, tree max)\n   m_base[1] = max;\n   m_num_ranges = 1;\n   m_kind = VR_RANGE;\n-  normalize_kind ();\n   m_nonzero_mask = NULL;\n+  normalize_kind ();\n \n   if (flag_checking)\n     verify_range ();\n@@ -467,8 +469,8 @@ irange::irange_set_anti_range (tree min, tree max)\n     }\n \n   m_kind = VR_RANGE;\n-  normalize_kind ();\n   m_nonzero_mask = NULL;\n+  normalize_kind ();\n \n   if (flag_checking)\n     verify_range ();\n@@ -577,8 +579,8 @@ irange::set (tree min, tree max, value_range_kind kind)\n   m_base[0] = min;\n   m_base[1] = max;\n   m_num_ranges = 1;\n-  normalize_kind ();\n   m_nonzero_mask = NULL;\n+  normalize_kind ();\n   if (flag_checking)\n     verify_range ();\n }\n@@ -599,6 +601,7 @@ irange::verify_range ()\n     gcc_checking_assert (wi::to_wide (m_nonzero_mask) != -1);\n   if (m_kind == VR_VARYING)\n     {\n+      gcc_checking_assert (!m_nonzero_mask);\n       gcc_checking_assert (m_num_ranges == 1);\n       gcc_checking_assert (varying_compatible_p ());\n       return;\n@@ -1759,6 +1762,8 @@ irange::legacy_verbose_intersect (const irange *other)\n \n // Perform an efficient union with R when both ranges have only a single pair.\n // Excluded are VARYING and UNDEFINED ranges.\n+//\n+// NOTE: It is the caller's responsibility to set the nonzero mask.\n \n bool\n irange::irange_single_pair_union (const irange &r)\n@@ -1831,23 +1836,28 @@ irange::irange_union (const irange &r)\n   if (undefined_p ())\n     {\n       operator= (r);\n+      if (flag_checking)\n+\tverify_range ();\n       return true;\n     }\n \n-  // Save the nonzero mask in case the set operations below clobber it.\n-  bool ret_nz = union_nonzero_bits (r);\n-  tree saved_nz = m_nonzero_mask;\n-\n   if (varying_p ())\n-    return ret_nz;\n+    return false;\n \n   if (r.varying_p ())\n     {\n-      set_varying (r.type ());\n-      set_nonzero_bits (saved_nz);\n+      set_varying (type ());\n       return true;\n     }\n \n+  // Save the nonzero mask in case the set operations below clobber it.\n+  bool ret_nz = union_nonzero_bits (r);\n+  tree saved_nz = m_nonzero_mask;\n+\n+  // The union_nonzero_bits may have turned things into a varying.\n+  if (varying_p ())\n+    return true;\n+\n   // Special case one range union one range.\n   if (m_num_ranges == 1 && r.m_num_ranges == 1)\n     {\n@@ -1948,8 +1958,8 @@ irange::irange_union (const irange &r)\n   m_num_ranges = i / 2;\n \n   m_kind = VR_RANGE;\n+  m_nonzero_mask = saved_nz;\n   normalize_kind ();\n-  set_nonzero_bits (saved_nz);\n \n   if (flag_checking)\n     verify_range ();\n@@ -2029,13 +2039,19 @@ irange::irange_intersect (const irange &r)\n   if (varying_p ())\n     {\n       operator= (r);\n-      set_nonzero_bits (saved_nz);\n+      if (saved_nz)\n+\tset_nonzero_bits (saved_nz);\n+      if (flag_checking)\n+\tverify_range ();\n       return true;\n     }\n \n   if (r.num_pairs () == 1)\n     {\n       bool res = intersect (r.lower_bound (), r.upper_bound ());\n+      if (undefined_p ())\n+\treturn true;\n+\n       set_nonzero_bits (saved_nz);\n       return res || saved_nz;\n     }\n@@ -2113,9 +2129,9 @@ irange::irange_intersect (const irange &r)\n   m_num_ranges = bld_pair;\n \n   m_kind = VR_RANGE;\n-  normalize_kind ();\n   if (!undefined_p ())\n-    set_nonzero_bits (saved_nz);\n+    m_nonzero_mask = saved_nz;\n+  normalize_kind ();\n \n   if (flag_checking)\n     verify_range ();\n@@ -2331,17 +2347,41 @@ irange::invert ()\n     verify_range ();\n }\n \n+void\n+irange::set_nonzero_bits (tree mask)\n+{\n+  gcc_checking_assert (!undefined_p ());\n+\n+  if (!mask)\n+    {\n+      if (m_nonzero_mask)\n+\t{\n+\t  m_nonzero_mask = NULL;\n+\t  // Clearing the mask may have turned a range into VARYING.\n+\t  normalize_kind ();\n+\t}\n+      return;\n+    }\n+  m_nonzero_mask = mask;\n+  // Setting the mask may have turned a VARYING into a range.\n+  if (m_kind == VR_VARYING)\n+    m_kind = VR_RANGE;\n+\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n void\n irange::set_nonzero_bits (const wide_int_ref &bits)\n {\n   gcc_checking_assert (!undefined_p ());\n \n   if (bits == -1)\n     {\n-      m_nonzero_mask = NULL;\n+      set_nonzero_bits (NULL);\n       return;\n     }\n-  m_nonzero_mask = wide_int_to_tree (type (), bits);\n+  set_nonzero_bits (wide_int_to_tree (type (), bits));\n }\n \n wide_int\n@@ -2378,17 +2418,14 @@ irange::intersect_nonzero_bits (const irange &r)\n {\n   gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n \n-  if (!r.m_nonzero_mask)\n-    return false;\n-  if (!m_nonzero_mask)\n+  if (m_nonzero_mask || r.m_nonzero_mask)\n     {\n-      m_nonzero_mask = r.m_nonzero_mask;\n+      wide_int nz = wi::bit_and (get_nonzero_bits (),\n+\t\t\t\t r.get_nonzero_bits ());\n+      set_nonzero_bits (nz);\n       return true;\n     }\n-  wide_int i = wi::bit_and (wi::to_wide (m_nonzero_mask),\n-\t\t\t    wi::to_wide (r.m_nonzero_mask));\n-  set_nonzero_bits (i);\n-  return true;\n+  return false;\n }\n \n // Union the nonzero bits in R into THIS.\n@@ -2398,21 +2435,14 @@ irange::union_nonzero_bits (const irange &r)\n {\n   gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n \n-  if (!m_nonzero_mask)\n-    return false;\n-  if (!r.m_nonzero_mask)\n+  if (m_nonzero_mask || r.m_nonzero_mask)\n     {\n-      if (m_nonzero_mask)\n-\t{\n-\t  m_nonzero_mask = NULL;\n-\t  return true;\n-\t}\n-      return false;\n+      wide_int nz = wi::bit_or (get_nonzero_bits (),\n+\t\t\t\tr.get_nonzero_bits ());\n+      set_nonzero_bits (nz);\n+      return true;\n     }\n-  wide_int i = wi::bit_or (wi::to_wide (m_nonzero_mask),\n-\t\t\t   wi::to_wide (r.m_nonzero_mask));\n-  set_nonzero_bits (i);\n-  return true;\n+  return false;\n }\n \n static void\n@@ -3054,13 +3084,76 @@ range_tests_misc ()\n   ASSERT_TRUE (r0.contains_p (UINT (2)));\n }\n \n+static void\n+range_tests_nonzero_bits ()\n+{\n+  int_range<2> r0, r1;\n+\n+  // Adding nonzero bits to a varying drops the varying.\n+  r0.set_varying (integer_type_node);\n+  r0.set_nonzero_bits (255);\n+  ASSERT_TRUE (!r0.varying_p ());\n+  // Dropping the nonzero bits brings us back to varying.\n+  r0.set_nonzero_bits (-1);\n+  ASSERT_TRUE (r0.varying_p ());\n+\n+  // Test contains_p with nonzero bits.\n+  r0.set_zero (integer_type_node);\n+  ASSERT_TRUE (r0.contains_p (INT (0)));\n+  ASSERT_FALSE (r0.contains_p (INT (1)));\n+  r0.set_nonzero_bits (0xfe);\n+  ASSERT_FALSE (r0.contains_p (INT (0x100)));\n+  ASSERT_FALSE (r0.contains_p (INT (0x3)));\n+\n+  // Union of nonzero bits.\n+  r0.set_varying (integer_type_node);\n+  r0.set_nonzero_bits (0xf0);\n+  r1.set_varying (integer_type_node);\n+  r1.set_nonzero_bits (0xf);\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0.get_nonzero_bits () == 0xff);\n+\n+  // Union where the mask of nonzero bits is implicit from the range.\n+  r0.set_varying (integer_type_node);\n+  r0.set_nonzero_bits (0xf00);\n+  r1.set_zero (integer_type_node); // nonzero mask is implicitly 0\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0.get_nonzero_bits () == 0xf00);\n+\n+  // Intersect of nonzero bits.\n+  r0.set (INT (0), INT (255));\n+  r0.set_nonzero_bits (0xfe);\n+  r1.set_varying (integer_type_node);\n+  r1.set_nonzero_bits (0xf0);\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.get_nonzero_bits () == 0xf0);\n+\n+  // Intersect where the mask of nonzero bits is implicit from the range.\n+  r0.set_varying (integer_type_node);\n+  r1.set (INT (0), INT (255));\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.get_nonzero_bits () == 0xff);\n+\n+  // The union of a mask of 0xff..ffff00 with a mask of 0xff spans the\n+  // entire domain, and makes the range a varying.\n+  r0.set_varying (integer_type_node);\n+  wide_int x = wi::shwi (0xff, TYPE_PRECISION (integer_type_node));\n+  x = wi::bit_not (x);\n+  r0.set_nonzero_bits (x); \t// 0xff..ff00\n+  r1.set_varying (integer_type_node);\n+  r1.set_nonzero_bits (0xff);\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0.varying_p ());\n+}\n+\n void\n range_tests ()\n {\n   range_tests_legacy ();\n   range_tests_irange3 ();\n   range_tests_int_range_max ();\n   range_tests_strict_enum ();\n+  range_tests_nonzero_bits ();\n   range_tests_misc ();\n }\n "}, {"sha": "0e341185f69e39a410559610b56d808d3c3100eb", "filename": "gcc/value-range.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c106825b936446c346d49ef10952e40370753b9d/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c106825b936446c346d49ef10952e40370753b9d/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=c106825b936446c346d49ef10952e40370753b9d", "patch": "@@ -201,7 +201,7 @@ class GTY((user)) irange : public vrange\n \n   void irange_set_1bit_anti_range (tree, tree);\n   bool varying_compatible_p () const;\n-  void set_nonzero_bits (tree bits) { m_nonzero_mask = bits; }\n+  void set_nonzero_bits (tree mask);\n   bool intersect_nonzero_bits (const irange &r);\n   bool union_nonzero_bits (const irange &r);\n   void dump_bitmasks (FILE *) const;\n@@ -555,7 +555,8 @@ irange::varying_compatible_p () const\n   signop sign = TYPE_SIGN (t);\n   if (INTEGRAL_TYPE_P (t))\n     return (wi::to_wide (l) == wi::min_value (prec, sign)\n-\t    && wi::to_wide (u) == wi::max_value (prec, sign));\n+\t    && wi::to_wide (u) == wi::max_value (prec, sign)\n+\t    && !m_nonzero_mask);\n   if (POINTER_TYPE_P (t))\n     return (wi::to_wide (l) == 0\n \t    && wi::to_wide (u) == wi::max_value (prec, sign));"}]}