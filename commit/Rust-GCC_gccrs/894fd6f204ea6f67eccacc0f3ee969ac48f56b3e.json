{"sha": "894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0ZmQ2ZjIwNGVhNmY2N2VjY2FjYzBmM2VlOTY5YWM0OGY1NmIzZQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2010-11-02T16:02:09Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2010-11-02T16:02:09Z"}, "message": "Model decoder of Core 2/i7 for multipass scheduling.\n\n\t* config/i386/i386-protos.h (struct ix86_first_cycle_multipass_data_):\n\tNew type to hold target-specific data for multipass scheduling.\n\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T): Define.\n\t* config/i386/i386.c (ia32_multipass_dfa_lookahead): Update for\n\tCore 2/i7.\n\t(core2i7_secondary_decoder_max_insn_size,)\n\t(core2i7_secondary_ifetch_block_size, core2i7_ifetch_block_max_insns):\n\tNew static variables.\n\t([const_]ix86_first_cycle_multipass_data_t): New typedefs.\n\t([_]ix86_first_cycle_multipass_data): New static variable.\n\t(core2i7_first_cycle_multipass_init, core2i7_dfa_poast_advance_cycle):\n\tImplement targetm.sched hooks.\n\t(core2i7_first_cycle_multipass_filter_ready_try): New static subroutine\n\tof ...\n\t(core2i7_first_cycle_multipass_{begin, issue, backtrack, end, fini}):\n\tImplement new targetm.sched hooks.\n\t(ix86_sched_init_global, TARGET_SCHED_INIT_GLOBAL): Define\n\ttargetm.sched hook to install multipass scheduling hooks on demand.\n\n\t* doc/tm.texi.in: Document new targetm.sched hooks.\n\t* doc/tm.texi: Regenerate.\n\n\t* haifa-sched.c (TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T): Define.\n\t(first_cycle_multipass_data_t): New typedef.\n\t(struct choice_entry: target_data): New field.\n\t(max_issue): Add first_cycle_insn_p parameter.  Call new target hooks\n\tto allow target model restrictions not represented in DFA.\n\t(choose_ready, schedule_block): Update.\n\t(sched_extend_ready_list, sched_finish_ready_list): Call new target\n\thooks to initialize target-specific data for multipass scheduling.\n\t* sched-int.h (max_issue): Update declaration.\n\t* sel-sched.c (choose_best_insn): Update.\n\t* target.def (first_cycle_multipass_{begin, issue, backtrack},)\n\t(first_cycle_multipass_{init, fini}): Define and document new\n\ttargetm.sched hooks.\n\nFrom-SVN: r166196", "tree": {"sha": "577fec572602f5e9c38ef19c8798360503bcb808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/577fec572602f5e9c38ef19c8798360503bcb808"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/comments", "author": null, "committer": null, "parents": [{"sha": "7350a36115f9752910ec4829f25e2d45a684d91e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7350a36115f9752910ec4829f25e2d45a684d91e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7350a36115f9752910ec4829f25e2d45a684d91e"}], "stats": {"total": 515, "additions": 501, "deletions": 14}, "files": [{"sha": "7f58b923164e4d51202354ddbbb7c63c8d6aa67b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -1,3 +1,43 @@\n+2010-11-02  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\tModel decoder of Core 2/i7 for multipass scheduling.\n+\n+\t* config/i386/i386-protos.h (struct ix86_first_cycle_multipass_data_):\n+\tNew type to hold target-specific data for multipass scheduling.\n+\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T): Define.\n+\t* config/i386/i386.c (ia32_multipass_dfa_lookahead): Update for\n+\tCore 2/i7.\n+\t(core2i7_secondary_decoder_max_insn_size,)\n+\t(core2i7_secondary_ifetch_block_size, core2i7_ifetch_block_max_insns):\n+\tNew static variables.\n+\t([const_]ix86_first_cycle_multipass_data_t): New typedefs.\n+\t([_]ix86_first_cycle_multipass_data): New static variable.\n+\t(core2i7_first_cycle_multipass_init, core2i7_dfa_poast_advance_cycle):\n+\tImplement targetm.sched hooks.\n+\t(core2i7_first_cycle_multipass_filter_ready_try): New static subroutine\n+\tof ...\n+\t(core2i7_first_cycle_multipass_{begin, issue, backtrack, end, fini}):\n+\tImplement new targetm.sched hooks.\n+\t(ix86_sched_init_global, TARGET_SCHED_INIT_GLOBAL): Define\n+\ttargetm.sched hook to install multipass scheduling hooks on demand.\n+\n+\t* doc/tm.texi.in: Document new targetm.sched hooks.\n+\t* doc/tm.texi: Regenerate.\n+\n+\t* haifa-sched.c (TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T): Define.\n+\t(first_cycle_multipass_data_t): New typedef.\n+\t(struct choice_entry: target_data): New field.\n+\t(max_issue): Add first_cycle_insn_p parameter.  Call new target hooks\n+\tto allow target model restrictions not represented in DFA.\n+\t(choose_ready, schedule_block): Update.\n+\t(sched_extend_ready_list, sched_finish_ready_list): Call new target\n+\thooks to initialize target-specific data for multipass scheduling.\n+\t* sched-int.h (max_issue): Update declaration.\n+\t* sel-sched.c (choose_best_insn): Update.\n+\t* target.def (first_cycle_multipass_{begin, issue, backtrack},)\n+\t(first_cycle_multipass_{init, fini}): Define and document new\n+\ttargetm.sched hooks.\n+\n 2010-11-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46184"}, {"sha": "13b1394b4252d7e703a092ef124a2029e3af7ae1", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -271,3 +271,21 @@ extern enum attr_cpu ix86_schedule;\n #endif\n \n extern const char * ix86_output_call_insn (rtx insn, rtx call_op, int addr_op);\n+\n+#ifdef RTX_CODE\n+/* Target data for multipass lookahead scheduling.\n+   Currently used for Core 2/i7 tuning.  */\n+struct ix86_first_cycle_multipass_data_\n+{\n+  /* The length (in bytes) of ifetch block in this solution.  */\n+  int ifetch_block_len;\n+  /* Number of instructions in ifetch block in this solution.  */\n+  int ifetch_block_n_insns;\n+  /* Bitmap to remember changes to ready_try for backtracking.  */\n+  sbitmap ready_try_change;\n+  /* Size of the bitmap.  */\n+  int ready_try_change_size;\n+};\n+# define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T\t\\\n+  struct ix86_first_cycle_multipass_data_\n+#endif /* RTX_CODE */"}, {"sha": "bda8ed3f9cd5abc4fb51c80cab68c04afcd85c8d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -22273,11 +22273,264 @@ ia32_multipass_dfa_lookahead (void)\n     case PROCESSOR_K6:\n       return 1;\n \n+    case PROCESSOR_CORE2:\n+    case PROCESSOR_COREI7_32:\n+    case PROCESSOR_COREI7_64:\n+      /* Generally, we want haifa-sched:max_issue() to look ahead as far\n+\t as many instructions can be executed on a cycle, i.e.,\n+\t issue_rate.  I wonder why tuning for many CPUs does not do this.  */\n+      return ix86_issue_rate ();\n+\n     default:\n       return 0;\n     }\n }\n \n+\f\n+\n+/* Model decoder of Core 2/i7.\n+   Below hooks for multipass scheduling (see haifa-sched.c:max_issue)\n+   track the instruction fetch block boundaries and make sure that long\n+   (9+ bytes) instructions are assigned to D0.  */\n+\n+/* Maximum length of an insn that can be handled by\n+   a secondary decoder unit.  '8' for Core 2/i7.  */\n+static int core2i7_secondary_decoder_max_insn_size;\n+\n+/* Ifetch block size, i.e., number of bytes decoder reads per cycle.\n+   '16' for Core 2/i7.  */\n+static int core2i7_ifetch_block_size;\n+\n+/* Maximum number of instructions decoder can handle per cycle.\n+   '6' for Core 2/i7.  */\n+static int core2i7_ifetch_block_max_insns;\n+\n+typedef struct ix86_first_cycle_multipass_data_ *\n+  ix86_first_cycle_multipass_data_t;\n+typedef const struct ix86_first_cycle_multipass_data_ *\n+  const_ix86_first_cycle_multipass_data_t;\n+\n+/* A variable to store target state across calls to max_issue within\n+   one cycle.  */\n+static struct ix86_first_cycle_multipass_data_ _ix86_first_cycle_multipass_data,\n+  *ix86_first_cycle_multipass_data = &_ix86_first_cycle_multipass_data;\n+\n+/* Initialize DATA.  */\n+static void\n+core2i7_first_cycle_multipass_init (void *_data)\n+{\n+  ix86_first_cycle_multipass_data_t data\n+    = (ix86_first_cycle_multipass_data_t) _data;\n+\n+  data->ifetch_block_len = 0;\n+  data->ifetch_block_n_insns = 0;\n+  data->ready_try_change = NULL;\n+  data->ready_try_change_size = 0;\n+}\n+\n+/* Advancing the cycle; reset ifetch block counts.  */\n+static void\n+core2i7_dfa_post_advance_cycle (void)\n+{\n+  ix86_first_cycle_multipass_data_t data = ix86_first_cycle_multipass_data;\n+\n+  gcc_assert (data->ifetch_block_n_insns <= core2i7_ifetch_block_max_insns);\n+\n+  data->ifetch_block_len = 0;\n+  data->ifetch_block_n_insns = 0;\n+}\n+\n+static int min_insn_size (rtx);\n+\n+/* Filter out insns from ready_try that the core will not be able to issue\n+   on current cycle due to decoder.  */\n+static void\n+core2i7_first_cycle_multipass_filter_ready_try\n+(const_ix86_first_cycle_multipass_data_t data,\n+ char *ready_try, int n_ready, bool first_cycle_insn_p)\n+{\n+  while (n_ready--)\n+    {\n+      rtx insn;\n+      int insn_size;\n+\n+      if (ready_try[n_ready])\n+\tcontinue;\n+\n+      insn = get_ready_element (n_ready);\n+      insn_size = min_insn_size (insn);\n+\n+      if (/* If this is a too long an insn for a secondary decoder ...  */\n+\t  (!first_cycle_insn_p\n+\t   && insn_size > core2i7_secondary_decoder_max_insn_size)\n+\t  /* ... or it would not fit into the ifetch block ...  */\n+\t  || data->ifetch_block_len + insn_size > core2i7_ifetch_block_size\n+\t  /* ... or the decoder is full already ...  */\n+\t  || data->ifetch_block_n_insns + 1 > core2i7_ifetch_block_max_insns)\n+\t/* ... mask the insn out.  */\n+\t{\n+\t  ready_try[n_ready] = 1;\n+\n+\t  if (data->ready_try_change)\n+\t    SET_BIT (data->ready_try_change, n_ready);\n+\t}\n+    }\n+}\n+\n+/* Prepare for a new round of multipass lookahead scheduling.  */\n+static void\n+core2i7_first_cycle_multipass_begin (void *_data, char *ready_try, int n_ready,\n+\t\t\t\t     bool first_cycle_insn_p)\n+{\n+  ix86_first_cycle_multipass_data_t data\n+    = (ix86_first_cycle_multipass_data_t) _data;\n+  const_ix86_first_cycle_multipass_data_t prev_data\n+    = ix86_first_cycle_multipass_data;\n+\n+  /* Restore the state from the end of the previous round.  */\n+  data->ifetch_block_len = prev_data->ifetch_block_len;\n+  data->ifetch_block_n_insns = prev_data->ifetch_block_n_insns;\n+\n+  /* Filter instructions that cannot be issued on current cycle due to\n+     decoder restrictions.  */\n+  core2i7_first_cycle_multipass_filter_ready_try (data, ready_try, n_ready,\n+\t\t\t\t\t\t  first_cycle_insn_p);\n+}\n+\n+/* INSN is being issued in current solution.  Account for its impact on\n+   the decoder model.  */\n+static void\n+core2i7_first_cycle_multipass_issue (void *_data, char *ready_try, int n_ready,\n+\t\t\t\t     rtx insn, const void *_prev_data)\n+{\n+  ix86_first_cycle_multipass_data_t data\n+    = (ix86_first_cycle_multipass_data_t) _data;\n+  const_ix86_first_cycle_multipass_data_t prev_data\n+    = (const_ix86_first_cycle_multipass_data_t) _prev_data;\n+\n+  int insn_size = min_insn_size (insn);\n+\n+  data->ifetch_block_len = prev_data->ifetch_block_len + insn_size;\n+  data->ifetch_block_n_insns = prev_data->ifetch_block_n_insns + 1;\n+  gcc_assert (data->ifetch_block_len <= core2i7_ifetch_block_size\n+\t      && data->ifetch_block_n_insns <= core2i7_ifetch_block_max_insns);\n+\n+  /* Allocate or resize the bitmap for storing INSN's effect on ready_try.  */\n+  if (!data->ready_try_change)\n+    {\n+      data->ready_try_change = sbitmap_alloc (n_ready);\n+      data->ready_try_change_size = n_ready;\n+    }\n+  else if (data->ready_try_change_size < n_ready)\n+    {\n+      data->ready_try_change = sbitmap_resize (data->ready_try_change,\n+\t\t\t\t\t       n_ready, 0);\n+      data->ready_try_change_size = n_ready;\n+    }\n+  sbitmap_zero (data->ready_try_change);\n+\n+  /* Filter out insns from ready_try that the core will not be able to issue\n+     on current cycle due to decoder.  */\n+  core2i7_first_cycle_multipass_filter_ready_try (data, ready_try, n_ready,\n+\t\t\t\t\t\t  false);\n+}\n+\n+/* Revert the effect on ready_try.  */\n+static void\n+core2i7_first_cycle_multipass_backtrack (const void *_data,\n+\t\t\t\t\t char *ready_try,\n+\t\t\t\t\t int n_ready ATTRIBUTE_UNUSED)\n+{\n+  const_ix86_first_cycle_multipass_data_t data\n+    = (const_ix86_first_cycle_multipass_data_t) _data;\n+  unsigned int i = 0;\n+  sbitmap_iterator sbi;\n+\n+  gcc_assert (sbitmap_last_set_bit (data->ready_try_change) < n_ready);\n+  EXECUTE_IF_SET_IN_SBITMAP (data->ready_try_change, 0, i, sbi)\n+    {\n+      ready_try[i] = 0;\n+    }\n+}\n+\n+/* Save the result of multipass lookahead scheduling for the next round.  */\n+static void\n+core2i7_first_cycle_multipass_end (const void *_data)\n+{\n+  const_ix86_first_cycle_multipass_data_t data\n+    = (const_ix86_first_cycle_multipass_data_t) _data;\n+  ix86_first_cycle_multipass_data_t next_data\n+    = ix86_first_cycle_multipass_data;\n+\n+  if (data != NULL)\n+    {\n+      next_data->ifetch_block_len = data->ifetch_block_len;\n+      next_data->ifetch_block_n_insns = data->ifetch_block_n_insns;\n+    }\n+}\n+\n+/* Deallocate target data.  */\n+static void\n+core2i7_first_cycle_multipass_fini (void *_data)\n+{\n+  ix86_first_cycle_multipass_data_t data\n+    = (ix86_first_cycle_multipass_data_t) _data;\n+\n+  if (data->ready_try_change)\n+    {\n+      sbitmap_free (data->ready_try_change);\n+      data->ready_try_change = NULL;\n+      data->ready_try_change_size = 0;\n+    }\n+}\n+\n+/* Prepare for scheduling pass.  */\n+static void\n+ix86_sched_init_global (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t\tint verbose ATTRIBUTE_UNUSED,\n+\t\t\tint max_uid ATTRIBUTE_UNUSED)\n+{\n+  /* Install scheduling hooks for current CPU.  Some of these hooks are used\n+     in time-critical parts of the scheduler, so we only set them up when\n+     they are actually used.  */\n+  switch (ix86_tune)\n+    {\n+    case PROCESSOR_CORE2:\n+    case PROCESSOR_COREI7_32:\n+    case PROCESSOR_COREI7_64:\n+      targetm.sched.dfa_post_advance_cycle\n+\t= core2i7_dfa_post_advance_cycle;\n+      targetm.sched.first_cycle_multipass_init\n+\t= core2i7_first_cycle_multipass_init;\n+      targetm.sched.first_cycle_multipass_begin\n+\t= core2i7_first_cycle_multipass_begin;\n+      targetm.sched.first_cycle_multipass_issue\n+\t= core2i7_first_cycle_multipass_issue;\n+      targetm.sched.first_cycle_multipass_backtrack\n+\t= core2i7_first_cycle_multipass_backtrack;\n+      targetm.sched.first_cycle_multipass_end\n+\t= core2i7_first_cycle_multipass_end;\n+      targetm.sched.first_cycle_multipass_fini\n+\t= core2i7_first_cycle_multipass_fini;\n+\n+      /* Set decoder parameters.  */\n+      core2i7_secondary_decoder_max_insn_size = 8;\n+      core2i7_ifetch_block_size = 16;\n+      core2i7_ifetch_block_max_insns = 6;\n+      break;\n+\n+    default:\n+      targetm.sched.dfa_post_advance_cycle = NULL;\n+      targetm.sched.first_cycle_multipass_init = NULL;\n+      targetm.sched.first_cycle_multipass_begin = NULL;\n+      targetm.sched.first_cycle_multipass_issue = NULL;\n+      targetm.sched.first_cycle_multipass_backtrack = NULL;\n+      targetm.sched.first_cycle_multipass_end = NULL;\n+      targetm.sched.first_cycle_multipass_fini = NULL;\n+      break;\n+    }\n+}\n+\n \f\n /* Compute the alignment given to a constant that is being placed in memory.\n    EXP is the constant and ALIGN is the alignment that the object would\n@@ -34030,6 +34283,8 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA\n #define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA i386_asm_output_addr_const_extra \n \n+#undef TARGET_SCHED_INIT_GLOBAL\n+#define TARGET_SCHED_INIT_GLOBAL ix86_sched_init_global\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST ix86_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE"}, {"sha": "7ce1c50f434eeecc681ca3e8246c677e3b60af87", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -6654,6 +6654,33 @@ be issued.\n The default is that any ready insns can be chosen to be issued.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN (void *@var{data}, char *@var{ready_try}, int @var{n_ready}, bool @var{first_cycle_insn_p})\n+This hook prepares the target backend for a new round of multipass\n+scheduling.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE (void *@var{data}, char *@var{ready_try}, int @var{n_ready}, rtx @var{insn}, const void *@var{prev_data})\n+This hook is called when multipass scheduling evaluates instruction INSN.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK (const void *@var{data}, char *@var{ready_try}, int @var{n_ready})\n+This is called when multipass scheduling backtracks from evaluation of\n+an instruction.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END (const void *@var{data})\n+This hook notifies the target about the result of the concluded current\n+round of multipass scheduling.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT (void *@var{data})\n+This hook initilizes target-specific data used in multipass scheduling.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI (void *@var{data})\n+This hook finilizes target-specific data used in multipass scheduling.\n+@end deftypefn\n+\n @deftypefn {Target Hook} int TARGET_SCHED_DFA_NEW_CYCLE (FILE *@var{dump}, int @var{verbose}, rtx @var{insn}, int @var{last_clock}, int @var{clock}, int *@var{sort_p})\n This hook is called by the insn scheduler before issuing @var{insn}\n on cycle @var{clock}.  If the hook returns nonzero,"}, {"sha": "23b38d3337f1d30d968c7280bb1d491da5249bc8", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -6642,6 +6642,33 @@ be issued.\n The default is that any ready insns can be chosen to be issued.\n @end deftypefn\n \n+@hook TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN\n+This hook prepares the target backend for a new round of multipass\n+scheduling.\n+@end deftypefn\n+\n+@hook TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE\n+This hook is called when multipass scheduling evaluates instruction INSN.\n+@end deftypefn\n+\n+@hook TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK\n+This is called when multipass scheduling backtracks from evaluation of\n+an instruction.\n+@end deftypefn\n+\n+@hook TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END\n+This hook notifies the target about the result of the concluded current\n+round of multipass scheduling.\n+@end deftypefn\n+\n+@hook TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT\n+This hook initilizes target-specific data used in multipass scheduling.\n+@end deftypefn\n+\n+@hook TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI\n+This hook finilizes target-specific data used in multipass scheduling.\n+@end deftypefn\n+\n @hook TARGET_SCHED_DFA_NEW_CYCLE\n This hook is called by the insn scheduler before issuing @var{insn}\n on cycle @var{clock}.  If the hook returns nonzero,"}, {"sha": "434b760d07d59c140e7417599bde4ad4127a4dfc", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -540,8 +540,6 @@ static void debug_ready_list (struct ready_list *);\n static rtx ready_remove (struct ready_list *, int);\n static void ready_remove_insn (rtx);\n \n-static int choose_ready (struct ready_list *, rtx *);\n-\n static void fix_inter_tick (rtx, rtx);\n static int fix_tick_ready (rtx);\n static void change_queue_index (rtx, int);\n@@ -2390,6 +2388,12 @@ insn_finishes_cycle_p (rtx insn)\n   return false;\n }\n \n+/* Define type for target data used in multipass scheduling.  */\n+#ifndef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T\n+# define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T int\n+#endif\n+typedef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T first_cycle_multipass_data_t;\n+\n /* The following structure describe an entry of the stack of choices.  */\n struct choice_entry\n {\n@@ -2401,6 +2405,8 @@ struct choice_entry\n   int n;\n   /* State after issuing the insn.  */\n   state_t state;\n+  /* Target-specific data.  */\n+  first_cycle_multipass_data_t target_data;\n };\n \n /* The following array is used to implement a stack of choices used in\n@@ -2451,7 +2457,7 @@ static int cached_issue_rate = 0;\n    CLOBBERs, etc must be filtered elsewhere.  */\n int\n max_issue (struct ready_list *ready, int privileged_n, state_t state,\n-\t   int *index)\n+\t   bool first_cycle_insn_p, int *index)\n {\n   int n, i, all, n_ready, best, delay, tries_num;\n   int more_issue;\n@@ -2484,6 +2490,10 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n   memcpy (top->state, state, dfa_state_size);\n   top->rest = dfa_lookahead;\n   top->n = 0;\n+  if (targetm.sched.first_cycle_multipass_begin)\n+    targetm.sched.first_cycle_multipass_begin (&top->target_data,\n+\t\t\t\t\t       ready_try, n_ready,\n+\t\t\t\t\t       first_cycle_insn_p);\n \n   /* Count the number of the insns to search among.  */\n   for (all = i = 0; i < n_ready; i++)\n@@ -2542,6 +2552,11 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \n \t  /* Backtrack.  */\n \t  ready_try [i] = 0;\n+\n+\t  if (targetm.sched.first_cycle_multipass_backtrack)\n+\t    targetm.sched.first_cycle_multipass_backtrack (&top->target_data,\n+\t\t\t\t\t\t\t   ready_try, n_ready);\n+\n \t  top--;\n \t  memcpy (state, top->state, dfa_state_size);\n \t}\n@@ -2573,8 +2588,15 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \t      top->index = i;\n \t      top->n = n;\n \t      memcpy (top->state, state, dfa_state_size);\n-\n \t      ready_try [i] = 1;\n+\n+\t      if (targetm.sched.first_cycle_multipass_issue)\n+\t\ttargetm.sched.first_cycle_multipass_issue (&top->target_data,\n+\t\t\t\t\t\t\t   ready_try, n_ready,\n+\t\t\t\t\t\t\t   insn,\n+\t\t\t\t\t\t\t   &((top - 1)\n+\t\t\t\t\t\t\t     ->target_data));\n+\n \t      i = -1;\n \t    }\n \t}\n@@ -2583,6 +2605,11 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n       i++;\n     }\n \n+  if (targetm.sched.first_cycle_multipass_end)\n+    targetm.sched.first_cycle_multipass_end (best != 0\n+\t\t\t\t\t     ? &choice_stack[1].target_data\n+\t\t\t\t\t     : NULL);\n+\n   /* Restore the original state of the DFA.  */\n   memcpy (state, choice_stack->state, dfa_state_size);\n \n@@ -2597,7 +2624,8 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n    0 if INSN_PTR is set to point to the desirable insn,\n    1 if choose_ready () should be restarted without advancing the cycle.  */\n static int\n-choose_ready (struct ready_list *ready, rtx *insn_ptr)\n+choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n+\t      rtx *insn_ptr)\n {\n   int lookahead;\n \n@@ -2726,7 +2754,7 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n \t\t     (insn)));\n \t  }\n \n-      if (max_issue (ready, 1, curr_state, &index) == 0)\n+      if (max_issue (ready, 1, curr_state, first_cycle_insn_p, &index) == 0)\n \t{\n \t  *insn_ptr = ready_remove_first (ready);\n \t  if (sched_verbose >= 4)\n@@ -2754,7 +2782,8 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n void\n schedule_block (basic_block *target_bb)\n {\n-  int i, first_cycle_insn_p;\n+  int i;\n+  bool first_cycle_insn_p;\n   int can_issue_more;\n   state_t temp_state = NULL;  /* It is used for multipass scheduling.  */\n   int sort_p, advance, start_clock_var;\n@@ -2960,7 +2989,7 @@ schedule_block (basic_block *target_bb)\n       else\n \tcan_issue_more = issue_rate;\n \n-      first_cycle_insn_p = 1;\n+      first_cycle_insn_p = true;\n       cycle_issued_insns = 0;\n       for (;;)\n \t{\n@@ -3003,7 +3032,7 @@ schedule_block (basic_block *target_bb)\n \t      int res;\n \n \t      insn = NULL_RTX;\n-\t      res = choose_ready (&ready, &insn);\n+\t      res = choose_ready (&ready, first_cycle_insn_p, &insn);\n \n \t      if (res < 0)\n \t\t/* Finish cycle.  */\n@@ -3156,7 +3185,7 @@ schedule_block (basic_block *target_bb)\n \t  if (advance != 0)\n \t    break;\n \n-\t  first_cycle_insn_p = 0;\n+\t  first_cycle_insn_p = false;\n \n \t  /* Sort the ready list based on priority.  This must be\n \t     redone here, as schedule_insn may have readied additional\n@@ -3952,7 +3981,13 @@ sched_extend_ready_list (int new_sched_ready_n_insns)\n \t\t\t     new_sched_ready_n_insns + 1);\n \n   for (; i <= new_sched_ready_n_insns; i++)\n-    choice_stack[i].state = xmalloc (dfa_state_size);\n+    {\n+      choice_stack[i].state = xmalloc (dfa_state_size);\n+\n+      if (targetm.sched.first_cycle_multipass_init)\n+\ttargetm.sched.first_cycle_multipass_init (&(choice_stack[i]\n+\t\t\t\t\t\t    .target_data));\n+    }\n \n   sched_ready_n_insns = new_sched_ready_n_insns;\n }\n@@ -3971,7 +4006,13 @@ sched_finish_ready_list (void)\n   ready_try = NULL;\n \n   for (i = 0; i <= sched_ready_n_insns; i++)\n-    free (choice_stack [i].state);\n+    {\n+      if (targetm.sched.first_cycle_multipass_fini)\n+\ttargetm.sched.first_cycle_multipass_fini (&(choice_stack[i]\n+\t\t\t\t\t\t    .target_data));\n+\n+      free (choice_stack [i].state);\n+    }\n   free (choice_stack);\n   choice_stack = NULL;\n "}, {"sha": "68cfa23ee06af3036b944e50f4e357da5d711f3c", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -195,7 +195,7 @@ struct ready_list\n extern char *ready_try;\n extern struct ready_list ready;\n \n-extern int max_issue (struct ready_list *, int, state_t, int *);\n+extern int max_issue (struct ready_list *, int, state_t, bool, int *);\n \n extern void ebb_compute_jump_reg_dependencies (rtx, regset, regset, regset);\n "}, {"sha": "70e831d7cee4d35958e43923bec2c18d4480d936", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -4320,8 +4320,9 @@ choose_best_insn (fence_t fence, int privileged_n, int *index)\n   if (dfa_lookahead > 0)\n     {\n       cycle_issued_insns = FENCE_ISSUED_INSNS (fence);\n+      /* TODO: pass equivalent of first_cycle_insn_p to max_issue ().  */\n       can_issue = max_issue (&ready, privileged_n,\n-                             FENCE_STATE (fence), index);\n+                             FENCE_STATE (fence), true, index);\n       if (sched_verbose >= 2)\n         sel_print (\"max_issue: we can issue %d insns, already did %d insns\\n\",\n                    can_issue, FENCE_ISSUED_INSNS (fence));"}, {"sha": "37ba3bc620e8c3ae39e6b161364b2d831323ac0c", "filename": "gcc/target.def", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894fd6f204ea6f67eccacc0f3ee969ac48f56b3e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=894fd6f204ea6f67eccacc0f3ee969ac48f56b3e", "patch": "@@ -650,6 +650,84 @@ DEFHOOK\n  \"\",\n  int, (rtx insn), NULL)\n \n+/* This hook prepares the target for a new round of multipass\n+   scheduling.\n+   DATA is a pointer to target-specific data used for multipass scheduling.\n+   READY_TRY and N_READY represent the current state of search in the\n+   optimization space.  The target can filter out instructions that\n+   should not be tried during current round by setting corresponding\n+   elements in READY_TRY to non-zero.\n+   FIRST_CYCLE_INSN_P is true if this is the first round of multipass\n+   scheduling on current cycle.  */\n+DEFHOOK\n+(first_cycle_multipass_begin,\n+ \"\",\n+ void, (void *data, char *ready_try, int n_ready, bool first_cycle_insn_p),\n+ NULL)\n+\n+/* This hook is called when multipass scheduling evaluates instruction INSN.\n+   DATA is a pointer to target-specific data that can be used to record effects\n+   of INSN on CPU that are not described in DFA.\n+   READY_TRY and N_READY represent the current state of search in the\n+   optimization space.  The target can filter out instructions that\n+   should not be tried after issueing INSN by setting corresponding\n+   elements in READY_TRY to non-zero.\n+   INSN is the instruction being evaluated.\n+   PREV_DATA is a pointer to target-specific data corresponding\n+   to a state before issueing INSN.  */\n+DEFHOOK\n+(first_cycle_multipass_issue,\n+ \"\",\n+ void, (void *data, char *ready_try, int n_ready, rtx insn,\n+\tconst void *prev_data), NULL)\n+\n+/* This hook is called when multipass scheduling backtracks from evaluation of\n+   instruction corresponding to DATA.\n+   DATA is a pointer to target-specific data that stores the effects\n+   of instruction from which the algorithm backtracks on CPU that are not\n+   described in DFA.\n+   READY_TRY and N_READY represent the current state of search in the\n+   optimization space.  The target can filter out instructions that\n+   should not be tried after issueing INSN by setting corresponding\n+   elements in READY_TRY to non-zero.  */\n+DEFHOOK\n+(first_cycle_multipass_backtrack,\n+ \"\",\n+ void, (const void *data, char *ready_try, int n_ready), NULL)\n+\n+/* This hook notifies the target about the result of the concluded current\n+   round of multipass scheduling.\n+   DATA is a pointer.\n+   If DATA is non-NULL it points to target-specific data used for multipass\n+   scheduling which corresponds to instruction at the start of the chain of\n+   the winning solution.  DATA is NULL when multipass scheduling cannot find\n+   a good enough solution on current cycle and decides to retry later,\n+   usually after advancing the cycle count.  */\n+DEFHOOK\n+(first_cycle_multipass_end,\n+ \"\",\n+ void, (const void *data), NULL)\n+\n+/* This hook is called to initialize target-specific data for multipass\n+   scheduling after it has been allocated.\n+   DATA is a pointer to target-specific data that stores the effects\n+   of instruction from which the algorithm backtracks on CPU that are not\n+   described in DFA.  */\n+DEFHOOK\n+(first_cycle_multipass_init,\n+ \"\",\n+ void, (void *data), NULL)\n+\n+/* This hook is called to finalize target-specific data for multipass\n+   scheduling before it is deallocated.\n+   DATA is a pointer to target-specific data that stores the effects\n+   of instruction from which the algorithm backtracks on CPU that are not\n+   described in DFA.  */\n+DEFHOOK\n+(first_cycle_multipass_fini,\n+ \"\",\n+ void, (void *data), NULL)\n+\n /* The following member value is pointer to a function called by\n    the insn scheduler before issuing insn passed as the third\n    parameter on given cycle.  If the hook returns nonzero, the"}]}