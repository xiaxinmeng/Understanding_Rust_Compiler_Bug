{"sha": "34b5375faef75cab6ecda04f161e5b81f662b2cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRiNTM3NWZhZWY3NWNhYjZlY2RhMDRmMTYxZTViODFmNjYyYjJjYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-07-15T16:10:05Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-07-15T16:10:05Z"}, "message": "re PR c++/22132 (Wrong code: upcasting a const class pointer to struct the class derives from (C/old-style cast))\n\n\tPR c++/22132\n\t* call.c (implicit_conversion): Add c_cast_p parameter.\n\t(standard_conversion): Likewise.  Allow conversions between\n\tdifferently-qualified pointer types when performing a C-style\n\tcast.\n\t(add_function_candidate): Adjust callee.\n\t(build_builtin_candidate): Likewise.\n\t(build_user_type_conversion_1): Likewise.\n\t(conditional_conversion): Likewise.\n\t(can_convert_arg): Likewise.\n\t(can_convert_arg_bad): Likewise.\n\t(perform_implicit_conversion): Likewise.\n\t* cp-tree.h (comp_ptr_ttypes_const): Declare.\n\t* typeck.c (comp_ptr_ttypes_const): Give it external linkage.\n\tReturn bool.\n\n\tPR c++/22132\n\t* g++.dg/expr/cast4.C: New test.\n\nFrom-SVN: r102059", "tree": {"sha": "59867dcc10601c3cce82c828262ad523c4dfee3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59867dcc10601c3cce82c828262ad523c4dfee3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34b5375faef75cab6ecda04f161e5b81f662b2cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b5375faef75cab6ecda04f161e5b81f662b2cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34b5375faef75cab6ecda04f161e5b81f662b2cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b5375faef75cab6ecda04f161e5b81f662b2cb/comments", "author": null, "committer": null, "parents": [{"sha": "e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e27d6202c07dbc70172733fcf6e79cb2ffe9a56c"}], "stats": {"total": 124, "additions": 98, "deletions": 26}, "files": [{"sha": "a52464a20e4495f3953cf76a5daf7b1ab8543742", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=34b5375faef75cab6ecda04f161e5b81f662b2cb", "patch": "@@ -1,3 +1,21 @@\n+2005-07-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/22132\n+\t* call.c (implicit_conversion): Add c_cast_p parameter.\n+\t(standard_conversion): Likewise.  Allow conversions between\n+\tdifferently-qualified pointer types when performing a C-style\n+\tcast.\n+\t(add_function_candidate): Adjust callee.\n+\t(build_builtin_candidate): Likewise.\n+\t(build_user_type_conversion_1): Likewise.\n+\t(conditional_conversion): Likewise.\n+\t(can_convert_arg): Likewise.\n+\t(can_convert_arg_bad): Likewise.\n+\t(perform_implicit_conversion): Likewise.\n+\t* cp-tree.h (comp_ptr_ttypes_const): Declare.\n+\t* typeck.c (comp_ptr_ttypes_const): Give it external linkage.\n+\tReturn bool.\n+\t\n 2005-07-12  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \t    Nathan Sidwell  <nathan@codesourcery.com>\n "}, {"sha": "1035f88441a468a486cd5c7659038439a9b99557", "filename": "gcc/cp/call.c", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=34b5375faef75cab6ecda04f161e5b81f662b2cb", "patch": "@@ -169,8 +169,8 @@ static struct z_candidate *add_conv_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree);\n static struct z_candidate *add_function_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree, int);\n-static conversion *implicit_conversion (tree, tree, tree, int);\n-static conversion *standard_conversion (tree, tree, tree, int);\n+static conversion *implicit_conversion (tree, tree, tree, bool, int);\n+static conversion *standard_conversion (tree, tree, tree, bool, int);\n static conversion *reference_binding (tree, tree, tree, int);\n static conversion *build_conv (conversion_kind, tree, conversion *);\n static bool is_subseq (conversion *, conversion *);\n@@ -578,10 +578,12 @@ strip_top_quals (tree t)\n \n /* Returns the standard conversion path (see [conv]) from type FROM to type\n    TO, if any.  For proper handling of null pointer constants, you must\n-   also pass the expression EXPR to convert from.  */\n+   also pass the expression EXPR to convert from.  If C_CAST_P is true,\n+   this conversion is coming from a C-style cast.  */\n \n static conversion *\n-standard_conversion (tree to, tree from, tree expr, int flags)\n+standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n+\t\t     int flags)\n {\n   enum tree_code fcode, tcode;\n   conversion *conv;\n@@ -631,7 +633,7 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \t the standard conversion sequence to perform componentwise\n \t conversion.  */\n       conversion *part_conv = standard_conversion\n-\t(TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, flags);\n+\t(TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, c_cast_p, flags);\n \n       if (part_conv)\n \t{\n@@ -737,7 +739,12 @@ standard_conversion (tree to, tree from, tree expr, int flags)\n \n       if (same_type_p (from, to))\n \t/* OK */;\n-      else if (comp_ptr_ttypes (to_pointee, from_pointee))\n+      else if (c_cast_p && comp_ptr_ttypes_const (to, from))\n+\t/* In a C-style cast, we ignore CV-qualification because we\n+\t   are allowed to perform a static_cast followed by a\n+\t   const_cast.  */\n+\tconv = build_conv (ck_qual, to, conv);\n+      else if (!c_cast_p && comp_ptr_ttypes (to_pointee, from_pointee))\n \tconv = build_conv (ck_qual, to, conv);\n       else if (expr && string_conv_p (to, expr, 0))\n \t/* converting from string constant to char *.  */\n@@ -1197,7 +1204,8 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n   if (related_p && !at_least_as_qualified_p (to, from))\n     return NULL;\n \n-  conv = implicit_conversion (to, from, expr, flags);\n+  conv = implicit_conversion (to, from, expr, /*c_cast_p=*/false, \n+\t\t\t      flags);\n   if (!conv)\n     return NULL;\n \n@@ -1209,13 +1217,15 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n   return conv;\n }\n \n-/* Returns the implicit conversion sequence (see [over.ics]) from type FROM\n-   to type TO.  The optional expression EXPR may affect the conversion.\n-   FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is\n-   significant.  */\n+/* Returns the implicit conversion sequence (see [over.ics]) from type\n+   FROM to type TO.  The optional expression EXPR may affect the\n+   conversion.  FLAGS are the usual overloading flags.  Only\n+   LOOKUP_NO_CONVERSION is significant.  If C_CAST_P is true, this\n+   conversion is coming from a C-style cast.  */\n \n static conversion *\n-implicit_conversion (tree to, tree from, tree expr, int flags)\n+implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n+\t\t     int flags)\n {\n   conversion *conv;\n \n@@ -1226,7 +1236,7 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     conv = reference_binding (to, from, expr, flags);\n   else\n-    conv = standard_conversion (to, from, expr, flags);\n+    conv = standard_conversion (to, from, expr, c_cast_p, flags);\n \n   if (conv)\n     return conv;\n@@ -1383,7 +1393,8 @@ add_function_candidate (struct z_candidate **candidates,\n \t      parmtype = build_pointer_type (parmtype);\n \t    }\n \n-\t  t = implicit_conversion (parmtype, argtype, arg, flags);\n+\t  t = implicit_conversion (parmtype, argtype, arg, \n+\t\t\t\t   /*c_cast_p=*/false, flags);\n \t}\n       else\n \t{\n@@ -1456,11 +1467,13 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n       conversion *t;\n \n       if (i == 0)\n-\tt = implicit_conversion (totype, argtype, arg, flags);\n+\tt = implicit_conversion (totype, argtype, arg, /*c_cast_p=*/false,\n+\t\t\t\t flags);\n       else if (parmnode == void_list_node)\n \tbreak;\n       else if (parmnode)\n-\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n+\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, \n+\t\t\t\t /*c_cast_p=*/false, flags);\n       else\n \t{\n \t  t = build_identity_conv (argtype, arg);\n@@ -1514,7 +1527,8 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n       if (! args[i])\n \tbreak;\n \n-      t = implicit_conversion (types[i], argtypes[i], args[i], flags);\n+      t = implicit_conversion (types[i], argtypes[i], args[i], \n+\t\t\t       /*c_cast_p=*/false, flags);\n       if (! t)\n \t{\n \t  viable = 0;\n@@ -1531,7 +1545,8 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n     {\n       convs[2] = convs[1];\n       convs[1] = convs[0];\n-      t = implicit_conversion (boolean_type_node, argtypes[2], args[2], flags);\n+      t = implicit_conversion (boolean_type_node, argtypes[2], args[2], \n+\t\t\t       /*c_cast_p=*/false, flags);\n       if (t)\n \tconvs[0] = t;\n       else\n@@ -2590,7 +2605,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t      conversion *ics\n \t\t= implicit_conversion (totype,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (cand->fn)),\n-\t\t\t\t       0, convflags);\n+\t\t\t\t       0, \n+\t\t\t\t       /*c_cast_p=*/false, convflags);\n \n \t      cand->second_conv = ics;\n \n@@ -3060,6 +3076,7 @@ conditional_conversion (tree e1, tree e2)\n       conv = implicit_conversion (build_reference_type (t2),\n \t\t\t\t  t1,\n \t\t\t\t  e1,\n+\t\t\t\t  /*c_cast_p=*/false,\n \t\t\t\t  LOOKUP_NO_TEMP_BIND);\n       if (conv)\n \treturn conv;\n@@ -3097,7 +3114,8 @@ conditional_conversion (tree e1, tree e2)\n        Otherwise: E1 can be converted to match E2 if E1 can be implicitly\n        converted to the type that expression E2 would have if E2 were\n        converted to an rvalue (or the type it has, if E2 is an rvalue).  */\n-    return implicit_conversion (t2, t1, e1, LOOKUP_NORMAL);\n+    return implicit_conversion (t2, t1, e1, /*c_cast_p=*/false,\n+\t\t\t\tLOOKUP_NORMAL);\n }\n \n /* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three\n@@ -6271,7 +6289,8 @@ can_convert_arg (tree to, tree from, tree arg)\n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n-  t  = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n+  t  = implicit_conversion (to, from, arg, /*c_cast_p=*/false, \n+\t\t\t    LOOKUP_NORMAL);\n   ok_p = (t && !t->bad_p);\n \n   /* Free all the conversions we allocated.  */\n@@ -6291,7 +6310,8 @@ can_convert_arg_bad (tree to, tree from, tree arg)\n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n   /* Try to perform the conversion.  */\n-  t  = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n+  t  = implicit_conversion (to, from, arg, /*c_cast_p=*/false,\n+\t\t\t    LOOKUP_NORMAL);\n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n \n@@ -6317,6 +6337,7 @@ perform_implicit_conversion (tree type, tree expr)\n   p = conversion_obstack_alloc (0);\n \n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n+\t\t\t      /*c_cast_p=*/false,\n \t\t\t      LOOKUP_NORMAL);\n   if (!conv)\n     {\n@@ -6370,6 +6391,7 @@ perform_direct_initialization_if_possible (tree type,\n   p = conversion_obstack_alloc (0);\n \n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n+\t\t\t      c_cast_p,\n \t\t\t      LOOKUP_NORMAL);\n   if (!conv || conv->bad_p)\n     expr = NULL_TREE;"}, {"sha": "440bdff1c6bc20165d824d0cb582cc6397189ee9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=34b5375faef75cab6ecda04f161e5b81f662b2cb", "patch": "@@ -4289,6 +4289,7 @@ extern tree build_modify_expr\t\t\t(tree, enum tree_code, tree);\n extern tree convert_for_initialization\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t const char *, tree, int);\n extern int comp_ptr_ttypes\t\t\t(tree, tree);\n+extern bool comp_ptr_ttypes_const               (tree, tree);\n extern int ptr_reasonably_similar\t\t(tree, tree);\n extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool);\n extern int cp_type_quals\t\t\t(tree);"}, {"sha": "b13c8cf6264ee9e099b8c6e94b2ba4f33d11ecea", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=34b5375faef75cab6ecda04f161e5b81f662b2cb", "patch": "@@ -47,7 +47,6 @@ static tree convert_for_assignment (tree, tree, const char *, tree, int);\n static tree cp_pointer_int_sum (enum tree_code, tree, tree);\n static tree rationalize_conditional_expr (enum tree_code, tree);\n static int comp_ptr_ttypes_real (tree, tree, int);\n-static int comp_ptr_ttypes_const (tree, tree);\n static bool comp_except_types (tree, tree, bool);\n static bool comp_array_types (tree, tree, bool);\n static tree common_base_type (tree, tree);\n@@ -6414,15 +6413,17 @@ ptr_reasonably_similar (tree to, tree from)\n     }\n }\n \n-/* Like comp_ptr_ttypes, for const_cast.  */\n+/* Return true if TO and FROM (both of which are POINTER_TYPEs or\n+   pointer-to-member types) are the same, ignoring cv-qualification at\n+   all levels.  */\n \n-static int\n+bool\n comp_ptr_ttypes_const (tree to, tree from)\n {\n   for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n     {\n       if (TREE_CODE (to) != TREE_CODE (from))\n-\treturn 0;\n+\treturn false;\n \n       if (TREE_CODE (from) == OFFSET_TYPE\n \t  && same_type_p (TYPE_OFFSET_BASETYPE (from),"}, {"sha": "4787bccf5b39a1f883eda3bb207674459f468de3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34b5375faef75cab6ecda04f161e5b81f662b2cb", "patch": "@@ -1,3 +1,8 @@\n+2005-07-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/22132\n+\t* g++.dg/expr/cast4.C: New test.\n+\n 2005-07-15  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/flatten-1.c: New testcase."}, {"sha": "72be9a6af19a2bb9b9e51e60e29caf17592691b4", "filename": "gcc/testsuite/g++.dg/expr/cast4.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b5375faef75cab6ecda04f161e5b81f662b2cb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast4.C?ref=34b5375faef75cab6ecda04f161e5b81f662b2cb", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do run }\n+// PR c++/22132\n+\n+extern \"C\" void abort ();\n+\n+struct foo {\n+  int a;\n+  int b;\n+};\n+\n+class Foobar : public foo {\n+public:\n+  Foobar() { a = 1; b = 2; };\n+  virtual ~Foobar() {};\n+};\n+\n+Foobar obj;\n+const Foobar* objPtr = &obj;\n+foo* f = (foo*)objPtr;\n+\n+int main () {\n+  if (f->a != 1 || f->b != 2)\n+    abort ();\n+}\n+"}]}