{"sha": "aa7a966b44190612dc1a052849512af924e75ea3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE3YTk2NmI0NDE5MDYxMmRjMWEwNTI4NDk1MTJhZjkyNGU3NWVhMw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-08-12T21:14:30Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-08-12T21:14:30Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r85899,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r85900", "tree": {"sha": "04a20c1272f19e0dc47db597960d24b86f18b6a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04a20c1272f19e0dc47db597960d24b86f18b6a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa7a966b44190612dc1a052849512af924e75ea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa7a966b44190612dc1a052849512af924e75ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa7a966b44190612dc1a052849512af924e75ea3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa7a966b44190612dc1a052849512af924e75ea3/comments", "author": null, "committer": null, "parents": [{"sha": "5c4dc10837d7f66311a5da622e054ea168483a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c4dc10837d7f66311a5da622e054ea168483a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c4dc10837d7f66311a5da622e054ea168483a5c"}], "stats": {"total": 783, "additions": 546, "deletions": 237}, "files": [{"sha": "4a5383ce4d1097abcc92a0d6eff34bb686b9d1ca", "filename": "boehm-gc/aix_irix_threads.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Faix_irix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Faix_irix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faix_irix_threads.c?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -422,12 +422,7 @@ void GC_thr_init()\n     struct sigaction act;\n \n     if (GC_thr_initialized) return;\n-#if 0\n-    /* unfortunately, GC_init_inner calls us without the lock, so\n-     * this assertion is not always true. */\n-    /* Why doesn't GC_init_inner hold the lock? - HB\t\t*/\n     GC_ASSERT(I_HOLD_LOCK());\n-#endif\n     GC_thr_initialized = TRUE;\n #ifndef GC_AIX_THREADS\n     (void) sigaction(SIG_SUSPEND, 0, &act);"}, {"sha": "36378cbbce01102c9bd6aca5f56009635a705d2b", "filename": "boehm-gc/darwin_stop_world.c", "status": "modified", "additions": 308, "deletions": 137, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fdarwin_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fdarwin_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdarwin_stop_world.c?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -2,8 +2,6 @@\n \n # if defined(GC_DARWIN_THREADS)\n \n-#define DEBUG_THREADS 0\n-\n /* From \"Inside Mac OS X - Mach-O Runtime Architecture\" published by Apple\n    Page 49:\n    \"The space beneath the stack pointer, where a new stack frame would normally\n@@ -16,101 +14,258 @@\n */\n #define PPC_RED_ZONE_SIZE 224\n \n+/* Not 64-bit clean. Wait until Apple defines their 64-bit ABI */\n+typedef struct StackFrame {\n+  unsigned int\tsavedSP;\n+  unsigned int\tsavedCR;\n+  unsigned int\tsavedLR;\n+  unsigned int\treserved[2];\n+  unsigned int\tsavedRTOC;\n+} StackFrame;\n+\n+\n+unsigned int FindTopOfStack(unsigned int stack_start) {\n+  StackFrame\t*frame;\n+  \n+  if (stack_start == 0) {\n+    __asm__ volatile(\"lwz\t%0,0(r1)\" : \"=r\" (frame));\n+  } else {\n+    frame = (StackFrame *)stack_start;\n+  }\n+\n+# ifdef DEBUG_THREADS\n+    /* GC_printf1(\"FindTopOfStack start at sp = %p\\n\", frame); */\n+# endif\n+  do {\n+    if (frame->savedSP == NULL) break;\n+    \t\t/* if there are no more stack frames, stop */\n+\n+    frame = (StackFrame*)frame->savedSP;\n+\n+    /* we do these next two checks after going to the next frame\n+       because the LR for the first stack frame in the loop\n+       is not set up on purpose, so we shouldn't check it. */\n+    if ((frame->savedLR & ~3) == 0) break; /* if the next LR is bogus, stop */\n+    if ((~(frame->savedLR) & ~3) == 0) break; /* ditto */\n+  } while (1); \n+\n+# ifdef DEBUG_THREADS\n+    /* GC_printf1(\"FindTopOfStack finish at sp = %p\\n\", frame); */\n+# endif\n+\n+  return (unsigned int)frame;\n+}\t\n+\n void GC_push_all_stacks() {\n     int i;\n     kern_return_t r;\n-    GC_thread p;\n-    pthread_t me;\n+    mach_port_t me;\n     ptr_t lo, hi;\n-#\tif defined(POWERPC)\n-        ppc_thread_state_t state;\n-#\telse\n-#\t\terror FIXME for non-ppc OS X\n-#\tendif\n-    mach_msg_type_number_t thread_state_count = MACHINE_THREAD_STATE_COUNT;\n-    \n-    me = pthread_self();\n+    thread_act_array_t act_list = 0;\n+    mach_msg_type_number_t listcount = 0;\n+\n+    me = mach_thread_self();\n     if (!GC_thr_initialized) GC_thr_init();\n     \n-    for(i=0;i<THREAD_TABLE_SZ;i++) {\n-        for(p=GC_threads[i];p!=0;p=p->next) {\n-            if(p -> flags & FINISHED) continue;\n-            if(pthread_equal(p->id,me)) {\n-                lo = GC_approx_sp();\n-            } else {\n-                /* Get the thread state (registers, etc) */\n-                r = thread_get_state(\n-                    p->stop_info.mach_thread,\n-                    MACHINE_THREAD_STATE,\n-                    (natural_t*)&state,\n-                    &thread_state_count);\n-                if(r != KERN_SUCCESS) ABORT(\"thread_get_state failed\");\n-    \n-                #ifdef POWERPC\n-                    lo = (void*)(state.r1 - PPC_RED_ZONE_SIZE);\n-                    \n-                    GC_push_one(state.r0); \n-                    GC_push_one(state.r2); \n-                    GC_push_one(state.r3); \n-                    GC_push_one(state.r4); \n-                    GC_push_one(state.r5); \n-                    GC_push_one(state.r6); \n-                    GC_push_one(state.r7); \n-                    GC_push_one(state.r8); \n-                    GC_push_one(state.r9); \n-                    GC_push_one(state.r10); \n-                    GC_push_one(state.r11); \n-                    GC_push_one(state.r12); \n-                    GC_push_one(state.r13); \n-                    GC_push_one(state.r14); \n-                    GC_push_one(state.r15); \n-                    GC_push_one(state.r16); \n-                    GC_push_one(state.r17); \n-                    GC_push_one(state.r18); \n-                    GC_push_one(state.r19); \n-                    GC_push_one(state.r20); \n-                    GC_push_one(state.r21); \n-                    GC_push_one(state.r22); \n-                    GC_push_one(state.r23); \n-                    GC_push_one(state.r24); \n-                    GC_push_one(state.r25); \n-                    GC_push_one(state.r26); \n-                    GC_push_one(state.r27); \n-                    GC_push_one(state.r28); \n-                    GC_push_one(state.r29); \n-                    GC_push_one(state.r30); \n-                    GC_push_one(state.r31);\n-                #else\n-                #\terror FIXME for non-PPC darwin\n-                #endif /* !POWERPC */\n-            } /* p != me */\n-            if(p->flags & MAIN_THREAD)\n-                hi = GC_stackbottom;\n-            else\n-                hi = p->stack_end;\n-            #if DEBUG_THREADS\n-                GC_printf3(\"Darwin: Stack for thread 0x%lx = [%lx,%lx)\\n\",\n-                    (unsigned long) p -> id,\n-                    (unsigned long) lo,\n-                    (unsigned long) hi\n-                );\n-            #endif\n-            GC_push_all_stack(lo,hi);\n-        } /* for(p=GC_threads[i]...) */\n-    } /* for(i=0;i<THREAD_TABLE_SZ...) */\n+    r = task_threads(current_task(), &act_list, &listcount);\n+    if(r != KERN_SUCCESS) ABORT(\"task_threads failed\");\n+    for(i = 0; i < listcount; i++) {\n+      thread_act_t thread = act_list[i];\n+      if (thread == me) {\n+\tlo = GC_approx_sp();\n+\thi = (ptr_t)FindTopOfStack(0);\n+      } else {\n+#      ifdef POWERPC\n+\tppc_thread_state_t info;\n+\tmach_msg_type_number_t outCount = THREAD_STATE_MAX;\n+\tr = thread_get_state(thread, MACHINE_THREAD_STATE,\n+\t\t\t     (natural_t *)&info, &outCount);\n+\tif(r != KERN_SUCCESS) ABORT(\"task_get_state failed\");\n+\n+\tlo = (void*)(info.r1 - PPC_RED_ZONE_SIZE);\n+\thi = (ptr_t)FindTopOfStack(info.r1);\n+\n+\tGC_push_one(info.r0); \n+\tGC_push_one(info.r2); \n+\tGC_push_one(info.r3); \n+\tGC_push_one(info.r4); \n+\tGC_push_one(info.r5); \n+\tGC_push_one(info.r6); \n+\tGC_push_one(info.r7); \n+\tGC_push_one(info.r8); \n+\tGC_push_one(info.r9); \n+\tGC_push_one(info.r10); \n+\tGC_push_one(info.r11); \n+\tGC_push_one(info.r12); \n+\tGC_push_one(info.r13); \n+\tGC_push_one(info.r14); \n+\tGC_push_one(info.r15); \n+\tGC_push_one(info.r16); \n+\tGC_push_one(info.r17); \n+\tGC_push_one(info.r18); \n+\tGC_push_one(info.r19); \n+\tGC_push_one(info.r20); \n+\tGC_push_one(info.r21); \n+\tGC_push_one(info.r22); \n+\tGC_push_one(info.r23); \n+\tGC_push_one(info.r24); \n+\tGC_push_one(info.r25); \n+\tGC_push_one(info.r26); \n+\tGC_push_one(info.r27); \n+\tGC_push_one(info.r28); \n+\tGC_push_one(info.r29); \n+\tGC_push_one(info.r30); \n+\tGC_push_one(info.r31);\n+#      else\n+\t/* FIXME: Remove after testing:\t*/\n+\tWARN(\"This is completely untested and likely will not work\\n\", 0);\n+\ti386_thread_state_t info;\n+\tmach_msg_type_number_t outCount = THREAD_STATE_MAX;\n+\tr = thread_get_state(thread, MACHINE_THREAD_STATE,\n+\t\t\t     (natural_t *)&info, &outCount);\n+\tif(r != KERN_SUCCESS) ABORT(\"task_get_state failed\");\n+\n+\tlo = (void*)info.esp;\n+\thi = (ptr_t)FindTopOfStack(info.esp);\n+\n+\tGC_push_one(info.eax); \n+\tGC_push_one(info.ebx); \n+\tGC_push_one(info.ecx); \n+\tGC_push_one(info.edx); \n+\tGC_push_one(info.edi); \n+\tGC_push_one(info.esi); \n+\t/* GC_push_one(info.ebp);  */\n+\t/* GC_push_one(info.esp);  */\n+\tGC_push_one(info.ss); \n+\tGC_push_one(info.eip); \n+\tGC_push_one(info.cs); \n+\tGC_push_one(info.ds); \n+\tGC_push_one(info.es); \n+\tGC_push_one(info.fs); \n+\tGC_push_one(info.gs); \n+#      endif /* !POWERPC */\n+      }\n+#     if DEBUG_THREADS\n+       GC_printf3(\"Darwin: Stack for thread 0x%lx = [%lx,%lx)\\n\",\n+\t\t  (unsigned long) thread,\n+\t\t  (unsigned long) lo,\n+\t\t  (unsigned long) hi\n+\t\t );\n+#     endif\n+      GC_push_all_stack(lo, hi); \n+    } /* for(p=GC_threads[i]...) */\n+}\n+\n+static mach_port_t GC_mach_handler_thread;\n+static int GC_use_mach_handler_thread = 0;\n+\n+static struct GC_mach_thread GC_mach_threads[THREAD_TABLE_SZ];\n+static int GC_mach_threads_count;\n+\n+void GC_stop_init() {\n+  int i;\n+\n+  for (i = 0; i < THREAD_TABLE_SZ; i++) {\n+    GC_mach_threads[i].thread = 0;\n+    GC_mach_threads[i].already_suspended = 0;\n+  }\n+  GC_mach_threads_count = 0;\n+}\n+\n+/* returns true if there's a thread in act_list that wasn't in old_list */\n+int GC_suspend_thread_list(thread_act_array_t act_list, int count, \n+\t\t\t   thread_act_array_t old_list, int old_count) {\n+  mach_port_t my_thread = mach_thread_self();\n+  int i, j;\n+\n+  int changed = 0;\n+\n+  for(i = 0; i < count; i++) {\n+    thread_act_t thread = act_list[i];\n+#   if DEBUG_THREADS \n+      GC_printf1(\"Attempting to suspend thread %p\\n\", thread);\n+#   endif\n+    /* find the current thread in the old list */\n+    int found = 0;\n+    for(j = 0; j < old_count; j++) {\n+      thread_act_t old_thread = old_list[j];\n+      if (old_thread == thread) {\n+\tfound = 1;\n+\tbreak;\n+      }\n+    }\n+    if (!found) {\n+      /* add it to the GC_mach_threads list */\n+      GC_mach_threads[GC_mach_threads_count].thread = thread;\n+      /* default is not suspended */\n+      GC_mach_threads[GC_mach_threads_count].already_suspended = 0;\n+      changed = 1;\n+    }      \n+\n+    if (thread != my_thread &&\n+\t(!GC_use_mach_handler_thread\n+\t || (GC_use_mach_handler_thread\n+\t     && GC_mach_handler_thread != thread))) {\n+      struct thread_basic_info info;\n+      mach_msg_type_number_t outCount = THREAD_INFO_MAX;\n+      kern_return_t kern_result = thread_info(thread, THREAD_BASIC_INFO,\n+\t\t\t\t(thread_info_t)&info, &outCount);\n+      if(kern_result != KERN_SUCCESS) {\n+\t/* the thread may have quit since the thread_threads () call \n+\t * we mark already_suspended so it's not dealt with anymore later\n+\t */\n+        if (!found) {\n+\t  GC_mach_threads[GC_mach_threads_count].already_suspended = TRUE;\n+    \t  GC_mach_threads_count++;\n+\t}\n+\tcontinue;\n+      }\n+#     if DEBUG_THREADS\n+        GC_printf2(\"Thread state for 0x%lx = %d\\n\", thread, info.run_state);\n+#     endif\n+      if (!found) {\n+\tGC_mach_threads[GC_mach_threads_count].already_suspended = info.suspend_count;\n+      }\n+      if (info.suspend_count) continue;\n+      \n+#     if DEBUG_THREADS\n+        GC_printf1(\"Suspending 0x%lx\\n\", thread);\n+#     endif\n+      /* Suspend the thread */\n+      kern_result = thread_suspend(thread);\n+      if(kern_result != KERN_SUCCESS) {\n+\t/* the thread may have quit since the thread_threads () call \n+\t * we mark already_suspended so it's not dealt with anymore later\n+\t */\n+        if (!found) {\n+\t  GC_mach_threads[GC_mach_threads_count].already_suspended = TRUE;\n+    \t  GC_mach_threads_count++;\n+\t}\n+\tcontinue;\n+      }\n+    } \n+    if (!found) GC_mach_threads_count++;\n+  }\n+  return changed;\n }\n \n+\n /* Caller holds allocation lock.\t*/\n void GC_stop_world()\n {\n-    int i;\n+  int i, changes;\n     GC_thread p;\n-    pthread_t my_thread = pthread_self();\n+    mach_port_t my_thread = mach_thread_self();\n     kern_return_t kern_result;\n+    thread_act_array_t act_list, prev_list;\n+    mach_msg_type_number_t listcount, prevcount;\n     \n-    #if DEBUG_THREADS\n-    GC_printf1(\"Stopping the world from 0x%lx\\n\", pthread_self());\n-    #endif\n+#   if DEBUG_THREADS\n+      GC_printf1(\"Stopping the world from 0x%lx\\n\", mach_thread_self());\n+#   endif\n+\n+    /* clear out the mach threads list table */\n+    GC_stop_init(); \n        \n     /* Make sure all free list construction has stopped before we start. */\n     /* No new construction can start, since free list construction is\t*/\n@@ -122,88 +277,104 @@ void GC_stop_world()\n       /* We should have previously waited for it to become zero. */\n #   endif /* PARALLEL_MARK */\n \n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-        for (p = GC_threads[i]; p != 0; p = p -> next) {\n-            if (p -> id == my_thread) continue;\n-            if (p -> flags & FINISHED) continue;\n-            if (p -> thread_blocked) /* Will wait */ continue;\n-            \n-            #if DEBUG_THREADS\n-            GC_printf1(\"Suspending thread 0x%lx\\n\", p -> id);\n-            #endif\n-            \n-            /* Suspend the thread */\n-            kern_result = thread_suspend(p->stop_info.mach_thread);\n-            if(kern_result != KERN_SUCCESS) ABORT(\"thread_suspend failed\");\n-            \n-            /* This is only needed if we are modifying the threads \n-               state. thread_abort_safely should also be used\n-               if this code is ever added in again.\n-               \n-               kern_result = thread_abort(p->stop_info.mach_thread);\n-               if(kern_result != KERN_SUCCESS)\n-                   ABORT(\"thread_abort failed (%ul)\",kern_result);\n-            */\n-        }\n-    }\n-    \n+      /* Loop stopping threads until you have gone over the whole list\n+\t twice without a new one appearing. thread_create() won't\n+\t return (and thus the thread stop) until the new thread\n+\t exists, so there is no window whereby you could stop a\n+\t thread, recognise it is stopped, but then have a new thread\n+\t it created before stopping show up later.\n+      */\n+      \n+      changes = 1;\n+      prev_list = NULL;\n+      prevcount = 0;\n+      do {\n+\tint result;\n+\tkern_result = task_threads(current_task(), &act_list, &listcount);\n+\tresult = GC_suspend_thread_list(act_list, listcount,\n+\t\t\t\t\tprev_list, prevcount);\n+\tchanges = result;\n+\tprev_list = act_list;\n+\tprevcount = listcount;\n+      } while (changes);\n+      \n+ \n #   ifdef MPROTECT_VDB\n-    if(GC_incremental) {\n+      if(GC_incremental) {\n         extern void GC_mprotect_stop();\n         GC_mprotect_stop();\n-    }\n+      }\n #   endif\n     \n #   ifdef PARALLEL_MARK\n       GC_release_mark_lock();\n #   endif\n     #if DEBUG_THREADS\n-      GC_printf1(\"World stopped from 0x%lx\\n\", pthread_self());\n+      GC_printf1(\"World stopped from 0x%lx\\n\", my_thread);\n     #endif\n }\n \n /* Caller holds allocation lock, and has held it continuously since\t*/\n /* the world stopped.\t\t\t\t\t\t\t*/\n void GC_start_world()\n {\n-    pthread_t my_thread = pthread_self();\n-    int i;\n-    GC_thread p;\n-    kern_return_t kern_result;\n-\n+  mach_port_t my_thread = mach_thread_self();\n+  int i, j;\n+  GC_thread p;\n+  kern_return_t kern_result;\n+  thread_act_array_t act_list;\n+  mach_msg_type_number_t listcount;\n+  \n #   if DEBUG_THREADS\n       GC_printf0(\"World starting\\n\");\n #   endif\n \n #   ifdef MPROTECT_VDB\n-    if(GC_incremental) {\n+      if(GC_incremental) {\n         extern void GC_mprotect_resume();\n         GC_mprotect_resume();\n-    }\n+      }\n #   endif\n \n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-        for (p = GC_threads[i]; p != 0; p = p -> next) {\n-            if (p -> id == my_thread) continue;\n-            if (p -> flags & FINISHED) continue;\n-            if (p -> thread_blocked) continue;\n-    \n-            #if DEBUG_THREADS\n-            GC_printf1(\"Resuming 0x%lx\\n\", p -> id);\n-            #endif\n-            \n-            /* Resume the thread */\n-            kern_result = thread_resume(p->stop_info.mach_thread);\n-            if(kern_result != KERN_SUCCESS) ABORT(\"thread_resume failed\");\n-        }\n+    kern_result = task_threads(current_task(), &act_list, &listcount);\n+    for(i = 0; i < listcount; i++) {\n+      thread_act_t thread = act_list[i];\n+      if (thread != my_thread &&\n+\t  (!GC_use_mach_handler_thread ||\n+\t   (GC_use_mach_handler_thread && GC_mach_handler_thread != thread))) {\n+\tfor(j = 0; j < GC_mach_threads_count; j++) {\n+\t  if (thread == GC_mach_threads[j].thread) {\n+\t    if (GC_mach_threads[j].already_suspended) {\n+#             if DEBUG_THREADS\n+\t        GC_printf1(\"Not resuming already suspended thread %p\\n\", thread);\n+#             endif\n+\t      continue;\n+\t    }\n+\t    struct thread_basic_info info;\n+\t    mach_msg_type_number_t outCount = THREAD_INFO_MAX;\n+\t    kern_result = thread_info(thread, THREAD_BASIC_INFO,\n+\t\t\t\t      (thread_info_t)&info, &outCount);\n+\t    if(kern_result != KERN_SUCCESS) ABORT(\"thread_info failed\");\n+#           if DEBUG_THREADS\n+\t      GC_printf2(\"Thread state for 0x%lx = %d\\n\", thread,\n+\t\t\t info.run_state);\n+\t      GC_printf1(\"Resuming 0x%lx\\n\", thread);\n+#           endif\n+\t    /* Resume the thread */\n+\t    kern_result = thread_resume(thread);\n+\t    if(kern_result != KERN_SUCCESS) ABORT(\"thread_resume failed\");\n+\t  } \n+\t}\n+      }\n     }\n-    #if DEBUG_THREADS\n-      GC_printf0(\"World started\\n\");\n-    #endif\n+#   if DEBUG_THREADS\n+     GC_printf0(\"World started\\n\");\n+#   endif\n }\n \n-void GC_stop_init() {\n-\n+void GC_darwin_register_mach_handler_thread(mach_port_t thread) {\n+  GC_mach_handler_thread = thread;\n+  GC_use_mach_handler_thread = 1;\n }\n \n #endif"}, {"sha": "72d60406d5cc9259b46da4f94d63d08bf626cefc", "filename": "boehm-gc/doc/README.darwin", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fdoc%2FREADME.darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fdoc%2FREADME.darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.darwin?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -1,5 +1,5 @@\n-Darwin/MacOSX Support - July 22, 2003\n-====================================\n+Darwin/MacOSX Support - December 16, 2003\n+=========================================\n \n Important Usage Notes\n =====================\n@@ -15,7 +15,7 @@ run and perhaps called GC_malloc(), create an initialization routine\n for each library to call GC_init():\n \n #include <gc/gc.h>\n-void my_library_init() { GC_init(); }\n+extern \"C\" void my_library_init() { GC_init(); }\n \n Compile this code into a my_library_init.o, and link it into your\n dylib. When you link the dylib, pass the -init argument with\n@@ -34,6 +34,12 @@ work reliably with workarounds for a few possible bugs in place however\n these workaround may not work correctly in all cases. There may also\n be additional problems that I have not found. \n \n+Thread-local GC allocation will not work with threads that are not\n+created using the GC-provided override of pthread_create(). Threads\n+created without the GC-provided pthread_create() do not have the\n+necessary data structures in the GC to store this data. \n+\n+\n Implementation Information\n ==========================\n Darwin/MacOSX support is nearly complete. Thread support is reliable on \n@@ -42,11 +48,27 @@ Darwin versions (MacOSX 10.1). Shared library support had also been\n added and the gc can be run from a shared library. There is currently only\n support for Darwin/PPC although adding x86 support should be trivial.\n \n-Thread support is implemented in terms of mach thread_suspend and \n+Thread support is implemented in terms of mach thread_suspend and\n thread_resume calls. These provide a very clean interface to thread\n suspension. This implementation doesn't rely on pthread_kill so the\n-code works on Darwin < 6.0 (MacOSX 10.1). All the code to stop the\n-world is located in darwin_stop_world.c.\n+code works on Darwin < 6.0 (MacOSX 10.1). All the code to stop and\n+start the world is located in darwin_stop_world.c.\n+\n+Since not all uses of the GC enable clients to override pthread_create()\n+before threads have been created, the code for stopping the world has\n+been rewritten to look for threads using Mach kernel calls. Each\n+thread identified in this way is suspended and resumed as above. In\n+addition, since Mach kernel threads do not contain pointers to their\n+stacks, a stack-walking function has been written to find the stack\n+limits. Given an initial stack pointer (for the current thread, a\n+pointer to a stack-allocated local variable will do; for a non-active\n+thread, we grab the value of register 1 (on PowerPC)), it\n+will walk the PPC Mach-O-ABI compliant stack chain until it reaches the\n+top of the stack. This appears to work correctly for GCC-compiled C,\n+C++, Objective-C, and Objective-C++ code, as well as for Java\n+programs that use JNI. If you run code that does not follow the stack\n+layout or stack pointer conventions laid out in the PPC Mach-O ABI,\n+then this will likely crash the garbage collector. \n \n The original incremental collector support unfortunatelly no longer works\n on recent Darwin versions. It also relied on some undocumented kernel"}, {"sha": "1716514bec164376f768bcedb4889f54e74f8758", "filename": "boehm-gc/doc/gcinterface.html", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fdoc%2Fgcinterface.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fdoc%2Fgcinterface.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgcinterface.html?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -5,31 +5,33 @@\n <BODY>\n <H1>C Interface</h1>\n On many platforms, a single-threaded garbage collector library can be built\n-to act as a plug-in malloc replacement.  (Build with -DREDIRECT_MALLOC=GC_malloc\n--DIGNORE_FREE.)  This is often the best way to deal with third-party libraries\n-which leak or prematurely free objects.  -DREDIRECT_MALLOC is intended\n+to act as a plug-in malloc replacement.\n+(Build with <TT>-DREDIRECT_MALLOC=GC_malloc -DIGNORE_FREE</tt>.)\n+This is often the best way to deal with third-party libraries\n+which leak or prematurely free objects.  <TT>-DREDIRECT_MALLOC</tt> is intended\n primarily as an easy way to adapt old code, not for new development.\n <P>\n New code should use the interface discussed below.\n <P>\n Code must be linked against the GC library.  On most UNIX platforms,\n-this will be gc.a.\n+depending on how the collector is built, this will be <TT>gc.a</tt>\n+or <TT>libgc.{a,so}</tt>.\n <P>\n The following describes the standard C interface to the garbage collector.\n It is not a complete definition of the interface.  It describes only the\n most commonly used functionality, approximately in decreasing order of\n-frequency of use.  The description assumes an ANSI C compiler.\n+frequency of use.\n The full interface is described in\n <A HREF=\"http://hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gch.txt\">gc.h</a>\n or <TT>gc.h</tt> in the distribution.\n <P>\n-Clients should include gc.h.\n+Clients should include <TT>gc.h</tt>.\n <P>\n In the case of multithreaded code,\n-gc.h should be included after the threads header file, and\n-after defining the appropriate GC_XXXX_THREADS macro.\n-(For 6.2alpha4 and later, simply defining GC_THREADS should suffice.)\n-Gc.h must be included\n+<TT>gc.h</tt> should be included after the threads header file, and\n+after defining the appropriate <TT>GC_</tt><I>XXXX</i><TT>_THREADS</tt> macro.\n+(For 6.2alpha4 and later, simply defining <TT>GC_THREADS</tt> should suffice.)\n+The header file <TT>gc.h</tt> must be included\n in files that use either GC or threads primitives, since threads primitives\n will be redefined to cooperate with the GC on many platforms.\n <DL>\n@@ -39,9 +41,10 @@ <H1>C Interface</h1>\n Requires (amortized) time proportional to <I>nbytes</i>.\n The resulting object will be automatically deallocated when unreferenced.\n References from objects allocated with the system malloc are usually not\n-considered by the collector.  (See GC_MALLOC_UNCOLLECTABLE, however.)\n-GC_MALLOC is a macro which invokes GC_malloc by default or, if GC_DEBUG\n-is defined before gc.h is included, a debugging version that checks\n+considered by the collector.  (See <TT>GC_MALLOC_UNCOLLECTABLE</tt>, however.)\n+<TT>GC_MALLOC</tt> is a macro which invokes <TT>GC_malloc</tt> by default or,\n+if <TT>GC_DEBUG</tt>\n+is defined before <TT>gc.h</tt> is included, a debugging version that checks\n occasionally for overwrite errors, and the like.\n <DT> <B>void * GC_MALLOC_ATOMIC(size_t <I>nbytes</i>)</b>\n <DD>\n@@ -57,60 +60,70 @@ <H1>C Interface</h1>\n <A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gc_typedh.txt\">gc_typed.h</a> in the distribution.\n <DT> <B>void * GC_MALLOC_UNCOLLECTABLE(size_t <I>nbytes</i>)</b>\n <DD>\n-Identical to GC_MALLOC, except that the resulting object is not automatically\n+Identical to <TT>GC_MALLOC</tt>,\n+except that the resulting object is not automatically\n deallocated.  Unlike the system-provided malloc, the collector does\n scan the object for pointers to garbage-collectable memory, even if the\n block itself does not appear to be reachable.  (Objects allocated in this way\n are effectively treated as roots by the collector.)\n-<DT> <B> void * GC_REALLOC(void *old, size_t new_size) </b>\n+<DT> <B> void * GC_REALLOC(void *<I>old</i>, size_t <I>new_size</i>) </b>\n <DD>\n Allocate a new object of the indicated size and copy (a prefix of) the\n old object into the new object.  The old object is reused in place if\n-convenient.  If the original object was allocated with GC_malloc_atomic,\n+convenient.  If the original object was allocated with\n+<TT>GC_MALLOC_ATOMIC</tt>,\n the new object is subject to the same constraints.  If it was allocated\n as an uncollectable object, then the new object is uncollectable, and\n the old object (if different) is deallocated.\n-(Use GC_REALLOC with GC_MALLOC, etc.)\n-<DT> <B> void GC_FREE(void *dead) </b>\n+<DT> <B> void GC_FREE(void *<I>dead</i>) </b>\n <DD>\n Explicitly deallocate an object.  Typically not useful for small\n-collectable objects.  (Use GC_FREE with GC_MALLOC, etc.)\n+collectable objects.\n <DT> <B> void * GC_MALLOC_IGNORE_OFF_PAGE(size_t <I>nbytes</i>) </b>\n <DD>\n <DT> <B> void * GC_MALLOC_ATOMIC_IGNORE_OFF_PAGE(size_t <I>nbytes</i>) </b>\n <DD>\n-Analogous to GC_MALLOC and GC_MALLOC_ATOMIC, except that the client\n+Analogous to <TT>GC_MALLOC</tt> and <TT>GC_MALLOC_ATOMIC</tt>,\n+except that the client\n guarantees that as long\n as the resulting object is of use, a pointer is maintained to someplace\n inside the first 512 bytes of the object.  This pointer should be declared\n volatile to avoid interference from compiler optimizations.\n (Other nonvolatile pointers to the object may exist as well.)\n This is the\n-preferred way to allocate objects that are likely to be > 100KBytes in size.\n+preferred way to allocate objects that are likely to be &gt; 100KBytes in size.\n It greatly reduces the risk that such objects will be accidentally retained\n when they are no longer needed.  Thus space usage may be significantly reduced.\n+<DT> <B> void GC_INIT(void) </b>\n+<DD>\n+On some platforms, it is necessary to invoke this\n+<I>from the main executable, not from a dynamic library,</i> before\n+the initial invocation of a GC routine.  It is recommended that this be done\n+in portable code, though we try to ensure that it expands to a no-op\n+on as many platforms as possible.\n <DT> <B> void GC_gcollect(void) </b>\n <DD>\n Explicitly force a garbage collection.\n <DT> <B> void GC_enable_incremental(void) </b>\n <DD>\n Cause the garbage collector to perform a small amount of work\n-every few invocations of GC_malloc or the like, instead of performing\n+every few invocations of <TT>GC_MALLOC</tt> or the like, instead of performing\n an entire collection at once.  This is likely to increase total\n running time.  It will improve response on a platform that either has\n-suitable support in the garbage collector (Irix and most other Unix\n+suitable support in the garbage collector (Linux and most Unix\n versions, win32 if the collector was suitably built) or if \"stubborn\"\n-allocation is used (see <A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gch.txt\">gc.h</a>).\n+allocation is used (see\n+<A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gch.txt\">gc.h</a>).\n On many platforms this interacts poorly with system calls \n that write to the garbage collected heap.\n-<DT> <B> GC_warn_proc GC_set_warn_proc(GC_warn_proc p) </b>\n+<DT> <B> GC_warn_proc GC_set_warn_proc(GC_warn_proc <I>p</i>) </b>\n <DD>\n Replace the default procedure used by the collector to print warnings.\n The collector\n may otherwise write to sterr, most commonly because GC_malloc was used\n in a situation in which GC_malloc_ignore_off_page would have been more\n appropriate.  See <A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gch.txt\">gc.h</a> for details.\n-<DT> <B> void GC_register_finalizer(...) </b>\n+<DT> <B> void GC_REGISTER_FINALIZER(...) </b>\n <DD>\n Register a function to be called when an object becomes inaccessible.\n This is often useful as a backup method for releasing system resources\n@@ -123,29 +136,54 @@ <H1>C Interface</h1>\n of the design.\n <P>\n Note that an object may become inaccessible before client code is done\n-operating on its fields.  Suitable synchronization is usually required.\n+operating on objects referenced by its fields.\n+Suitable synchronization is usually required.\n See <A HREF=\"http://portal.acm.org/citation.cfm?doid=604131.604153\">here</a>\n or <A HREF=\"http://www.hpl.hp.com/techreports/2002/HPL-2002-335.html\">here</a>\n for details.\n </dl>\n <P>\n If you are concerned with multiprocessor performance and scalability,\n you should consider enabling and using thread local allocation (<I>e.g.</i>\n-GC_LOCAL_MALLOC, see <TT>gc_local_alloc.h</tt>.  If your platform\n+<TT>GC_LOCAL_MALLOC</tt>, see <TT>gc_local_alloc.h</tt>.  If your platform\n supports it, you should build the collector with parallel marking support\n-(-DPARALLEL_MARK, or --enable-parallel-mark).\n+(<TT>-DPARALLEL_MARK</tt>, or <TT>--enable-parallel-mark</tt>).\n <P>\n If the collector is used in an environment in which pointer location\n information for heap objects is easily available, this can be passed on\n-to the colllector using the interfaces in either <TT>gc_typed.h</tt>\n+to the collector using the interfaces in either <TT>gc_typed.h</tt>\n or <TT>gc_gcj.h</tt>.\n <P>\n The collector distribution also includes a <B>string package</b> that takes\n advantage of the collector.  For details see\n <A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/cordh.txt\">cord.h</a>\n \n <H1>C++ Interface</h1>\n-There are three distinct ways to use the collector from C++:\n+Usage of the collector from C++ is complicated by the fact that there\n+are many \"standard\" ways to allocate memory in C++.  The default ::new\n+operator, default malloc, and default STL allocators allocate memory\n+that is not garbage collected, and is not normally \"traced\" by the\n+collector.  This means that any pointers in memory allocated by these\n+default allocators will not be seen by the collector.  Garbage-collectable\n+memory referenced only by pointers stored in such default-allocated\n+objects is likely to be reclaimed prematurely by the collector.\n+<P>\n+It is the programmers responsibility to ensure that garbage-collectable\n+memory is referenced by pointers stored in one of\n+<UL>\n+<LI> Program variables\n+<LI> Garbage-collected objects\n+<LI> Uncollected but \"traceable\" objects\n+</ul>\n+\"Traceable\" objects are not necessarily reclaimed by the collector,\n+but are scanned for pointers to collectable objects.\n+They are allocated by <TT>GC_MALLOC_UNCOLLECTABLE</tt>, as described\n+above, and through some interfaces described below.\n+<P>\n+The easiest way to ensure that collectable objects are properly referenced\n+is to allocate only collectable objects.  This requires that every\n+allocation go through one of the following interfaces, each one of\n+which replaces a standard C++ allocation mechanism:\n <DL>\n <DT> <B> STL allocators </b>\n <DD>\n@@ -170,7 +208,7 @@ <H1>C++ Interface</h1>\n For an example, click <A HREF=\"http://hpl.hp.com/personal/Hans_Boehm/gc/gc_alloc_exC.txt\">here</a>.\n <P>\n Recent versions of the collector also include a more standard-conforming\n-allocator implemention in <TT>gc_allocator.h</tt>.  It defines\n+allocator implementation in <TT>gc_allocator.h</tt>.  It defines\n <UL>\n <LI> traceable_allocator\n <LI> gc_allocator\n@@ -179,24 +217,31 @@ <H1>C++ Interface</h1>\n This should work with any fully standard-conforming C++ compiler.\n <DT> <B> Class inheritance based interface </b>\n <DD>\n-Users may include gc_cpp.h and then cause members of certain classes to\n-be allocated in garbage collectable memory by inheriting from class gc.\n+Users may include gc_cpp.h and then cause members of classes to\n+be allocated in garbage collectable memory by having those classes\n+inherit from class gc.\n For details see <A HREF=\"http://hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gc_cpph.txt\">gc_cpp.h</a>.\n+<P>\n+Linking against libgccpp in addition to the gc library overrides\n+::new (and friends) to allocate traceable memory but uncollectable\n+memory, making it safe to refer to collectable objects from the resulting\n+memory.\n <DT> <B> C interface </b>\n <DD>\n It is also possible to use the C interface from \n <A HREF=\"http://hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gch.txt\">gc.h</a> directly.\n On platforms which use malloc to implement ::new, it should usually be possible\n to use a version of the collector that has been compiled as a malloc\n replacement.  It is also possible to replace ::new and other allocation\n-functions suitably.\n+functions suitably, as is done by libgccpp.\n <P>\n Note that user-implemented small-block allocation often works poorly with\n an underlying garbage-collected large block allocator, since the collector\n has to view all objects accessible from the user's free list as reachable.\n-This is likely to cause problems if GC_malloc is used with something like\n+This is likely to cause problems if <TT>GC_MALLOC</tt>\n+is used with something like\n the original HP version of STL.\n-This approach works with the SGI versions of the STL only if the\n+This approach works well with the SGI versions of the STL only if the\n <TT>malloc_alloc</tt> allocator is used.\n </dl>\n </body>"}, {"sha": "200f181efa6f17261b8187570389c50c96ae2814", "filename": "boehm-gc/include/gc_allocator.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fgc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fgc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_allocator.h?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -35,7 +35,17 @@\n  * library, which itself was derived from the SGI STL implementation.\n  */\n \n-#include \"gc.h\" \t// For size_t\n+#ifndef GC_ALLOCATOR_H\n+\n+#define GC_ALLOCATOR_H\n+\n+#include \"gc.h\"\n+\n+#if defined(__GNUC__)\n+#  define GC_ATTR_UNUSED __attribute__((unused))\n+#else\n+#  define GC_ATTR_UNUSED\n+#endif\n \n /* First some helpers to allow us to dispatch on whether or not a type\n  * is known to be pointerfree.\n@@ -118,7 +128,7 @@ class gc_allocator {\n   }\n \n   // __p is not permitted to be a null pointer.\n-  void deallocate(pointer __p, size_type GC_n)\n+  void deallocate(pointer __p, size_type GC_ATTR_UNUSED GC_n)\n     { GC_FREE(__p); }\n \n   size_type max_size() const throw()\n@@ -194,7 +204,7 @@ class traceable_allocator {\n   }\n \n   // __p is not permitted to be a null pointer.\n-  void deallocate(pointer __p, size_type GC_n)\n+  void deallocate(pointer __p, size_type GC_ATTR_UNUSED GC_n)\n     { GC_FREE(__p); }\n \n   size_type max_size() const throw()\n@@ -230,3 +240,4 @@ inline bool operator!=(const traceable_allocator<GC_T1>&, const traceable_alloca\n   return false;\n }\n \n+#endif /* GC_ALLOCATOR_H */"}, {"sha": "d8d31141262d7d2f452f4c9f323cca1cdd782ac8", "filename": "boehm-gc/include/gc_config_macros.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fgc_config_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fgc_config_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config_macros.h?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -97,7 +97,10 @@\n # endif\n #endif /* GC_THREADS */\n \n-#if defined(GC_THREADS) && !defined(GC_PTHREADS) && defined(MSWIN32)\n+#if defined(GC_THREADS) && !defined(GC_PTHREADS) && \\\n+    (defined(_WIN32) || defined(_MSC_VER) || defined(__CYGWIN__) \\\n+     || defined(__MINGW32__) || defined(__BORLANDC__) \\\n+     || defined(_WIN32_WCE))\n # define GC_WIN32_THREADS\n #endif\n \n@@ -106,8 +109,9 @@\n #endif\n \n # define __GC\n-# include <stddef.h>\n-# ifdef _WIN32_WCE\n+# ifndef _WIN32_WCE\n+#   include <stddef.h>\n+# else /* ! _WIN32_WCE */\n /* Yet more kluges for WinCE */\n #   include <stdlib.h>\t\t/* size_t is defined here */\n     typedef long ptrdiff_t;\t/* ptrdiff_t is not defined */"}, {"sha": "f6f5314ee315a5410cade12e06a7045214bfda05", "filename": "boehm-gc/include/private/darwin_stop_world.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fprivate%2Fdarwin_stop_world.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fprivate%2Fdarwin_stop_world.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdarwin_stop_world.h?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -12,4 +12,11 @@ struct thread_stop_info {\n     mach_port_t mach_thread;\n };\n \n+struct GC_mach_thread {\n+  thread_act_t thread;\n+  int already_suspended;\n+};\n+\n+void GC_darwin_register_mach_handler_thread(mach_port_t thread);\n+\n #endif"}, {"sha": "d52e4da90aa0983d3e032b5effb065e145e9e25e", "filename": "boehm-gc/include/private/pthread_support.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -93,5 +93,10 @@ GC_thread GC_lookup_thread(pthread_t id);\n \n void GC_stop_init();\n \n+extern GC_bool GC_in_thread_creation;\n+\t/* We may currently be in thread creation or destruction.\t*/\n+\t/* Only set to TRUE while allocation lock is held.\t\t*/\n+\t/* When set, it is OK to run GC from unknown thread.\t\t*/\n+\n #endif /* GC_PTHREADS && !GC_SOLARIS_THREADS.... etc */\n #endif /* GC_PTHREAD_SUPPORT_H */"}, {"sha": "832c49ca81e53d6173deba6dd190fd0361f0d694", "filename": "boehm-gc/pthread_stop_world.c", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fpthread_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fpthread_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_stop_world.c?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -39,6 +39,34 @@ void GC_print_sig_mask()\n \n #endif\n \n+/* Remove the signals that we want to allow in thread stopping \t*/\n+/* handler from a set.\t\t\t\t\t\t*/\n+void GC_remove_allowed_signals(sigset_t *set)\n+{\n+#   ifdef NO_SIGNALS\n+      if (sigdelset(set, SIGINT) != 0\n+\t  || sigdelset(set, SIGQUIT) != 0\n+\t  || sigdelset(set, SIGABRT) != 0\n+\t  || sigdelset(set, SIGTERM) != 0) {\n+        ABORT(\"sigdelset() failed\");\n+      }\n+#   endif\n+\n+#   ifdef MPROTECT_VDB\n+      /* Handlers write to the thread structure, which is in the heap,\t*/\n+      /* and hence can trigger a protection fault.\t\t\t*/\n+      if (sigdelset(set, SIGSEGV) != 0\n+#\t  ifdef SIGBUS\n+\t    || sigdelset(set, SIGBUS) != 0\n+# \t  endif\n+\t  ) {\n+        ABORT(\"sigdelset() failed\");\n+      }\n+#   endif\n+}\n+\n+static sigset_t suspend_handler_mask;\n+\n word GC_stop_count;\t/* Incremented at the beginning of GC_stop_world. */\n \n #ifdef GC_OSF1_THREADS\n@@ -78,7 +106,6 @@ void GC_suspend_handler(int sig)\n     int dummy;\n     pthread_t my_thread = pthread_self();\n     GC_thread me;\n-    sigset_t mask;\n #   ifdef PARALLEL_MARK\n \tword my_mark_no = GC_mark_no;\n \t/* Marker can't proceed until we acknowledge.  Thus this is\t*/\n@@ -125,17 +152,9 @@ void GC_suspend_handler(int sig)\n     /* this thread a SIG_THR_RESTART signal.\t\t\t*/\n     /* SIG_THR_RESTART should be masked at this point.  Thus there\t*/\n     /* is no race.\t\t\t\t\t\t*/\n-    if (sigfillset(&mask) != 0) ABORT(\"sigfillset() failed\");\n-    if (sigdelset(&mask, SIG_THR_RESTART) != 0) ABORT(\"sigdelset() failed\");\n-#   ifdef NO_SIGNALS\n-      if (sigdelset(&mask, SIGINT) != 0) ABORT(\"sigdelset() failed\");\n-      if (sigdelset(&mask, SIGQUIT) != 0) ABORT(\"sigdelset() failed\");\n-      if (sigdelset(&mask, SIGTERM) != 0) ABORT(\"sigdelset() failed\");\n-      if (sigdelset(&mask, SIGABRT) != 0) ABORT(\"sigdelset() failed\");\n-#   endif\n     do {\n \t    me->stop_info.signal = 0;\n-\t    sigsuspend(&mask);             /* Wait for signal */\n+\t    sigsuspend(&suspend_handler_mask);        /* Wait for signal */\n     } while (me->stop_info.signal != SIG_THR_RESTART);\n     /* If the RESTART signal gets lost, we can still lose.  That should be  */\n     /* less likely than losing the SUSPEND signal, since we don't do much   */\n@@ -186,6 +205,7 @@ void GC_restart_handler(int sig)\n /* world is stopped.  Should not fail if it isn't.\t\t\t*/\n void GC_push_all_stacks()\n {\n+    GC_bool found_me = FALSE;\n     int i;\n     GC_thread p;\n     ptr_t lo, hi;\n@@ -206,6 +226,7 @@ void GC_push_all_stacks()\n #  \t    else\n  \t        lo = GC_approx_sp();\n #           endif\n+\t    found_me = TRUE;\n \t    IF_IA64(bs_hi = (ptr_t)GC_save_regs_in_stack();)\n \t} else {\n \t    lo = p -> stop_info.stack_ptr;\n@@ -232,6 +253,11 @@ void GC_push_all_stacks()\n           GC_push_all_stack(lo, hi);\n #\tendif\n #\tifdef IA64\n+#         if DEBUG_THREADS\n+            GC_printf3(\"Reg stack for thread 0x%lx = [%lx,%lx)\\n\",\n+    \t        (unsigned long) p -> id,\n+\t\t(unsigned long) bs_lo, (unsigned long) bs_hi);\n+#\t  endif\n           if (pthread_equal(p -> id, me)) {\n \t    GC_push_all_eager(bs_lo, bs_hi);\n \t  } else {\n@@ -240,6 +266,8 @@ void GC_push_all_stacks()\n #\tendif\n       }\n     }\n+    if (!found_me && !GC_in_thread_creation)\n+      ABORT(\"Collecting from unknown thread.\");\n }\n \n /* There seems to be a very rare thread stopping problem.  To help us  */\n@@ -408,16 +436,9 @@ void GC_stop_init() {\n     if (sigfillset(&act.sa_mask) != 0) {\n     \tABORT(\"sigfillset() failed\");\n     }\n-#   ifdef NO_SIGNALS\n-      if (sigdelset(&act.sa_mask, SIGINT) != 0\n-\t  || sigdelset(&act.sa_mask, SIGQUIT != 0)\n-\t  || sigdelset(&act.sa_mask, SIGABRT != 0)\n-\t  || sigdelset(&act.sa_mask, SIGTERM != 0)) {\n-        ABORT(\"sigdelset() failed\");\n-      }\n-#   endif\n-\n-    /* SIG_THR_RESTART is unmasked by the handler when necessary. \t*/\n+    GC_remove_allowed_signals(&act.sa_mask);\n+    /* SIG_THR_RESTART is set in the resulting mask.\t\t*/\n+    /* It is unmasked by the handler when necessary. \t\t*/\n     act.sa_handler = GC_suspend_handler;\n     if (sigaction(SIG_SUSPEND, &act, NULL) != 0) {\n     \tABORT(\"Cannot set SIG_SUSPEND handler\");\n@@ -428,6 +449,12 @@ void GC_stop_init() {\n     \tABORT(\"Cannot set SIG_THR_RESTART handler\");\n     }\n \n+    /* Inititialize suspend_handler_mask. It excludes SIG_THR_RESTART. */\n+      if (sigfillset(&suspend_handler_mask) != 0) ABORT(\"sigfillset() failed\");\n+      GC_remove_allowed_signals(&suspend_handler_mask);\n+      if (sigdelset(&suspend_handler_mask, SIG_THR_RESTART) != 0)\n+\t  ABORT(\"sigdelset() failed\");\n+\n     /* Check for GC_RETRY_SIGNALS.\t*/\n       if (0 != GETENV(\"GC_RETRY_SIGNALS\")) {\n \t  GC_retry_signals = TRUE;"}, {"sha": "5bb157f8b3fcb41ffa3a9d863cd2f598ee2f41c7", "filename": "boehm-gc/pthread_support.c", "status": "modified", "additions": 48, "deletions": 26, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fpthread_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa7a966b44190612dc1a052849512af924e75ea3/boehm-gc%2Fpthread_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_support.c?ref=aa7a966b44190612dc1a052849512af924e75ea3", "patch": "@@ -54,8 +54,17 @@\n      && !defined(GC_AIX_THREADS)\n \n # if defined(GC_HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \\\n-     && !defined(USE_HPUX_TLS)\n-#   define USE_HPUX_TLS\n+     && !defined(USE_COMPILER_TLS)\n+#   ifdef __GNUC__\n+#     define USE_PTHREAD_SPECIFIC\n+      /* Empirically, as of gcc 3.3, USE_COMPILER_TLS doesn't work.\t*/\n+#   else\n+#     define USE_COMPILER_TLS\n+#   endif\n+# endif\n+\n+# if defined USE_HPUX_TLS\n+    --> Macro replaced by USE_COMPILER_TLS\n # endif\n \n # if (defined(GC_DGUX386_THREADS) || defined(GC_OSF1_THREADS) || \\\n@@ -72,7 +81,7 @@\n # endif\n \n # ifdef THREAD_LOCAL_ALLOC\n-#   if !defined(USE_PTHREAD_SPECIFIC) && !defined(USE_HPUX_TLS)\n+#   if !defined(USE_PTHREAD_SPECIFIC) && !defined(USE_COMPILER_TLS)\n #     include \"private/specific.h\"\n #   endif\n #   if defined(USE_PTHREAD_SPECIFIC)\n@@ -81,7 +90,7 @@\n #     define GC_key_create pthread_key_create\n       typedef pthread_key_t GC_key_t;\n #   endif\n-#   if defined(USE_HPUX_TLS)\n+#   if defined(USE_COMPILER_TLS)\n #     define GC_getspecific(x) (x)\n #     define GC_setspecific(key, v) ((key) = (v), 0)\n #     define GC_key_create(key, d) 0\n@@ -99,6 +108,7 @@\n # include <sys/types.h>\n # include <sys/stat.h>\n # include <fcntl.h>\n+# include <signal.h>\n \n #if defined(GC_DARWIN_THREADS)\n # include \"private/darwin_semaphore.h\"\n@@ -158,7 +168,7 @@ void GC_init_parallel();\n \n /* We don't really support thread-local allocation with DBG_HDRS_ALL */\n \n-#ifdef USE_HPUX_TLS\n+#ifdef USE_COMPILER_TLS\n   __thread\n #endif\n GC_key_t GC_thread_key;\n@@ -500,19 +510,6 @@ static __inline__ void start_mark_threads()\n \n #endif /* !PARALLEL_MARK */\n \n-/* Defining INSTALL_LOOPING_SEGV_HANDLER causes SIGSEGV and SIGBUS to \t*/\n-/* result in an infinite loop in a signal handler.  This can be very\t*/\n-/* useful for debugging, since (as of RH7) gdb still seems to have\t*/\n-/* serious problems with threads.\t\t\t\t\t*/\n-#ifdef INSTALL_LOOPING_SEGV_HANDLER\n-void GC_looping_handler(int sig)\n-{\n-    GC_printf3(\"Signal %ld in thread %lx, pid %ld\\n\",\n-\t       sig, pthread_self(), getpid());\n-    for (;;);\n-}\n-#endif\n-\n GC_bool GC_thr_initialized = FALSE;\n \n volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n@@ -622,7 +619,7 @@ void GC_delete_gc_thread(pthread_t id, GC_thread gc_id)\n     GC_INTERNAL_FREE(p);\n }\n \n-/* Return a GC_thread corresponding to a given thread_t.\t*/\n+/* Return a GC_thread corresponding to a given pthread_t.\t*/\n /* Returns 0 if it's not there.\t\t\t\t\t*/\n /* Caller holds  allocation lock or otherwise inhibits \t\t*/\n /* updates.\t\t\t\t\t\t\t*/\n@@ -747,7 +744,9 @@ void GC_wait_for_gc_completion(GC_bool wait_for_all)\n \twhile (GC_incremental && GC_collection_in_progress()\n \t       && (wait_for_all || old_gc_no == GC_gc_no)) {\n \t    ENTER_GC();\n+\t    GC_in_thread_creation = TRUE;\n             GC_collect_a_little_inner(1);\n+\t    GC_in_thread_creation = FALSE;\n \t    EXIT_GC();\n \t    UNLOCK();\n \t    sched_yield();\n@@ -1055,9 +1054,10 @@ void GC_thread_exit_proc(void *arg)\n \tme -> flags |= FINISHED;\n     }\n #   if defined(THREAD_LOCAL_ALLOC) && !defined(USE_PTHREAD_SPECIFIC) \\\n-       && !defined(USE_HPUX_TLS) && !defined(DBG_HDRS_ALL)\n+       && !defined(USE_COMPILER_TLS) && !defined(DBG_HDRS_ALL)\n       GC_remove_specific(GC_thread_key);\n #   endif\n+    /* The following may run the GC from \"nonexistent\" thread.\t*/\n     GC_wait_for_gc_completion(FALSE);\n     UNLOCK();\n }\n@@ -1115,6 +1115,8 @@ WRAP_FUNC(pthread_detach)(pthread_t thread)\n     return result;\n }\n \n+GC_bool GC_in_thread_creation = FALSE;\n+\n void * GC_start_routine(void * arg)\n {\n     int dummy;\n@@ -1132,7 +1134,9 @@ void * GC_start_routine(void * arg)\n         GC_printf1(\"sp = 0x%lx\\n\", (long) &arg);\n #   endif\n     LOCK();\n+    GC_in_thread_creation = TRUE;\n     me = GC_new_thread(my_pthread);\n+    GC_in_thread_creation = FALSE;\n #ifdef GC_DARWIN_THREADS\n     me -> stop_info.mach_thread = mach_thread_self();\n #else\n@@ -1301,12 +1305,12 @@ WRAP_FUNC(pthread_create)(pthread_t *new_thread,\n void GC_pause()\n {\n     int i;\n-#\tifndef __GNUC__\n-        volatile word dummy = 0;\n-#\tendif\n+#   if !defined(__GNUC__) || defined(__INTEL_COMPILER)\n+      volatile word dummy = 0;\n+#   endif\n \n     for (i = 0; i < 10; ++i) { \n-#     ifdef __GNUC__\n+#     if defined(__GNUC__) && !defined(__INTEL_COMPILER)\n         __asm__ __volatile__ (\" \" : : : \"memory\");\n #     else\n \t/* Something that's unlikely to be optimized away. */\n@@ -1315,7 +1319,7 @@ void GC_pause()\n     }\n }\n     \n-#define SPIN_MAX 1024\t/* Maximum number of calls to GC_pause before\t*/\n+#define SPIN_MAX 128\t/* Maximum number of calls to GC_pause before\t*/\n \t\t\t/* give up.\t\t\t\t\t*/\n \n VOLATILE GC_bool GC_collecting = 0;\n@@ -1340,19 +1344,34 @@ VOLATILE GC_bool GC_collecting = 0;\n /* yield by calling pthread_mutex_lock(); it never makes sense to\t*/\n /* explicitly sleep.\t\t\t\t\t\t\t*/\n \n+#define LOCK_STATS\n+#ifdef LOCK_STATS\n+  unsigned long GC_spin_count = 0;\n+  unsigned long GC_block_count = 0;\n+  unsigned long GC_unlocked_count = 0;\n+#endif\n+\n void GC_generic_lock(pthread_mutex_t * lock)\n {\n #ifndef NO_PTHREAD_TRYLOCK\n     unsigned pause_length = 1;\n     unsigned i;\n     \n-    if (0 == pthread_mutex_trylock(lock)) return;\n+    if (0 == pthread_mutex_trylock(lock)) {\n+#       ifdef LOCK_STATS\n+\t    ++GC_unlocked_count;\n+#       endif\n+\treturn;\n+    }\n     for (; pause_length <= SPIN_MAX; pause_length <<= 1) {\n \tfor (i = 0; i < pause_length; ++i) {\n \t    GC_pause();\n \t}\n         switch(pthread_mutex_trylock(lock)) {\n \t    case 0:\n+#\t\tifdef LOCK_STATS\n+\t\t    ++GC_spin_count;\n+#\t\tendif\n \t\treturn;\n \t    case EBUSY:\n \t\tbreak;\n@@ -1361,6 +1380,9 @@ void GC_generic_lock(pthread_mutex_t * lock)\n         }\n     }\n #endif /* !NO_PTHREAD_TRYLOCK */\n+#   ifdef LOCK_STATS\n+\t++GC_block_count;\n+#   endif\n     pthread_mutex_lock(lock);\n }\n "}]}