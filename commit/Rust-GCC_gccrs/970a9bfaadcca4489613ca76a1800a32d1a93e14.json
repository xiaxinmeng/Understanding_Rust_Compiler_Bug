{"sha": "970a9bfaadcca4489613ca76a1800a32d1a93e14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcwYTliZmFhZGNjYTQ0ODk2MTNjYTc2YTE4MDBhMzJkMWE5M2UxNA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-16T21:47:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-16T21:47:22Z"}, "message": "Start work on <ranges> header\n\nFrom-SVN: r278363", "tree": {"sha": "2125e7828ee917f0ed67f7b4c01136b5f9f459ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2125e7828ee917f0ed67f7b4c01136b5f9f459ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/970a9bfaadcca4489613ca76a1800a32d1a93e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970a9bfaadcca4489613ca76a1800a32d1a93e14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/970a9bfaadcca4489613ca76a1800a32d1a93e14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970a9bfaadcca4489613ca76a1800a32d1a93e14/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e2d00114ba92463bd5a9f04adf7f9b0cc556fb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e2d00114ba92463bd5a9f04adf7f9b0cc556fb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e2d00114ba92463bd5a9f04adf7f9b0cc556fb2"}], "stats": {"total": 1310, "additions": 1310, "deletions": 0}, "files": [{"sha": "c0315b029fd08adede15261d289773416bb86b19", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 1310, "deletions": 0, "changes": 1310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/970a9bfaadcca4489613ca76a1800a32d1a93e14/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/970a9bfaadcca4489613ca76a1800a32d1a93e14/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=970a9bfaadcca4489613ca76a1800a32d1a93e14", "patch": "@@ -38,7 +38,11 @@\n \n #if __cpp_lib_concepts\n \n+// #include <compare>\n+#include <initializer_list>\n #include <iterator>\n+#include <limits>\n+#include <optional>\n \n /**\n  * @defgroup ranges Ranges\n@@ -48,7 +52,30 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n+namespace __debug\n+{\n+  template<typename _Key, typename _Cmp, typename _Allocator> class set;\n+  template<typename _Key, typename _Cmp, typename _Allocator> class multiset;\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Allocator>\n+    class unordered_set;\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Allocator>\n+    class unordered_multiset;\n+} // namespace __debug\n+\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n+  template<typename _Key, typename _Cmp, typename _Allocator> class set;\n+  template<typename _Key, typename _Cmp, typename _Allocator> class multiset;\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Allocator>\n+    class unordered_set;\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Allocator>\n+    class unordered_multiset;\n+_GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+  template<typename _It, typename _Alloc>\n+    class match_results;\n+\n namespace ranges\n {\n   // [range.range] The range concept.\n@@ -68,6 +95,12 @@ namespace ranges\n     using range_rvalue_reference_t\n       = iter_rvalue_reference_t<iterator_t<_Range>>;\n \n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      concept __forwarding_range = range<_Tp> && __range_impl<_Tp>;\n+  } // namespace __detail\n+\n   // [range.sized] The sized_range concept.\n   // Defined in <bits/range_iterator.h>\n   // template<typename> concept sized_range;\n@@ -104,6 +137,1283 @@ namespace ranges\n   template<typename _Tp>\n     concept common_range\n       = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n+\n+  struct view_base { };\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp, template<typename...> class _Tmpl>\n+      struct __is_specialization_of\n+      : false_type {};\n+\n+    template<template<typename...> class _Tmpl, typename... _Args>\n+      struct __is_specialization_of<_Tmpl<_Args...>, _Tmpl>\n+      : true_type { };\n+\n+    template<typename _Tp>\n+      concept __set_like\n+\t=  __is_specialization_of<_Tp, _GLIBCXX_STD_C::set>()\n+\t|| __is_specialization_of<_Tp, _GLIBCXX_STD_C::multiset>()\n+\t|| __is_specialization_of<_Tp, _GLIBCXX_STD_C::unordered_set>()\n+\t|| __is_specialization_of<_Tp, _GLIBCXX_STD_C::unordered_multiset>()\n+\t|| __is_specialization_of<_Tp, std::__debug::set>()\n+\t|| __is_specialization_of<_Tp, std::__debug::multiset>()\n+\t|| __is_specialization_of<_Tp, std::__debug::unordered_set>()\n+\t|| __is_specialization_of<_Tp, std::__debug::unordered_multiset>();\n+\n+    template<typename _Tp>\n+      concept __deep_const_range = range<_Tp> && range<const _Tp>\n+\t&& same_as<range_reference_t<_Tp>, range_reference_t<const _Tp>>;\n+\n+    template<typename _Tp>\n+      inline constexpr bool __enable_view_impl = derived_from<_Tp, view_base>\n+\t|| (!__set_like<_Tp> && !__deep_const_range<_Tp>);\n+\n+    template<typename _Tp>\n+      inline constexpr bool __enable_view_impl<std::initializer_list<_Tp>>\n+\t= false;\n+\n+    template<typename _It, typename _Alloc>\n+      inline constexpr bool __enable_view_impl<std::match_results<_It, _Alloc>>\n+\t= false;\n+  } // namespace __detail\n+\n+  template<typename _Tp>\n+    inline constexpr bool enable_view\n+      = __detail::__enable_view_impl<remove_cv_t<_Tp>>;\n+\n+  template<typename _Tp>\n+    concept view = range<_Tp> && semiregular<_Tp> && enable_view<_Tp>;\n+\n+  template<typename _Tp>\n+    concept viewable_range = range<_Tp>\n+      && (__detail::__forwarding_range<_Tp> || view<decay_t<_Tp>>);\n+\n+  namespace __detail\n+  {\n+    template<typename _Range>\n+      concept __simple_view = view<_Range> && range<const _Range>\n+\t&& same_as<iterator_t<_Range>, iterator_t<const _Range>>\n+\t&& same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;\n+\n+    template<typename _It>\n+      concept __has_arrow = input_iterator<_It>\n+\t&& (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });\n+\n+    template<typename _Tp, typename _Up>\n+      concept __not_same_as\n+\t= !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;\n+  } // namespace __detail\n+\n+  template<typename _Derived>\n+    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>\n+    class view_interface : public view_base\n+    {\n+    private:\n+      constexpr _Derived& _M_derived() noexcept\n+      {\n+\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n+\tstatic_assert(view<_Derived>);\n+\treturn static_cast<_Derived&>(*this);\n+      }\n+\n+      constexpr const _Derived& _M_derived() const noexcept\n+      {\n+\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n+\tstatic_assert(view<_Derived>);\n+\treturn static_cast<const _Derived&>(*this);\n+      }\n+\n+    public:\n+      constexpr bool\n+      empty() requires forward_range<_Derived>\n+      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n+\n+      constexpr bool\n+      empty() const requires forward_range<const _Derived>\n+      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n+\n+      constexpr explicit\n+      operator bool() requires requires { ranges::empty(_M_derived()); }\n+      { return !ranges::empty(_M_derived()); }\n+\n+      constexpr explicit\n+      operator bool() const requires requires { ranges::empty(_M_derived()); }\n+      { return !ranges::empty(_M_derived()); }\n+\n+      constexpr auto\n+      data() requires contiguous_iterator<iterator_t<_Derived>>\n+      { return to_address(ranges::begin(_M_derived())); }\n+\n+      constexpr auto\n+      data() const\n+      requires range<const _Derived>\n+\t&& contiguous_iterator<iterator_t<const _Derived>>\n+      { return to_address(ranges::begin(_M_derived())); }\n+\n+      constexpr auto\n+      size()\n+      requires forward_range<_Derived>\n+\t&& sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>\n+      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n+\n+      constexpr auto\n+      size() const\n+      requires forward_range<const _Derived>\n+\t&& sized_sentinel_for<sentinel_t<const _Derived>,\n+\t\t\t      iterator_t<const _Derived>>\n+      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n+\n+      constexpr decltype(auto)\n+      front() requires forward_range<_Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::begin(_M_derived());\n+      }\n+\n+      constexpr decltype(auto)\n+      front() const requires forward_range<const _Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::begin(_M_derived());\n+      }\n+\n+      constexpr decltype(auto)\n+      back()\n+      requires bidirectional_range<_Derived> && common_range<_Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::prev(ranges::end(_M_derived()));\n+      }\n+\n+      constexpr decltype(auto)\n+      back() const\n+      requires bidirectional_range<const _Derived>\n+\t&& common_range<const _Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::prev(ranges::end(_M_derived()));\n+      }\n+\n+      template<random_access_range _Range = _Derived>\n+\tconstexpr decltype(auto)\n+\toperator[](range_difference_t<_Range> __n)\n+\t{ return ranges::begin(_M_derived())[__n]; }\n+\n+      template<random_access_range _Range = const _Derived>\n+\tconstexpr decltype(auto)\n+\toperator[](range_difference_t<_Range> __n) const\n+\t{ return ranges::begin(_M_derived())[__n]; }\n+    };\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      concept __pair_like\n+\t= !is_reference_v<_Tp> && requires(_Tp __t)\n+\t{\n+\t  typename tuple_size<_Tp>::type;\n+\t  requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;\n+\t  typename tuple_element_t<0, remove_const_t<_Tp>>;\n+\t  typename tuple_element_t<1, remove_const_t<_Tp>>;\n+\t  { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;\n+\t  { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;\n+\t};\n+\n+    template<typename _Tp, typename _Up, typename _Vp>\n+      concept __pair_like_convertible_to\n+\t= !range<_Tp> && __pair_like<remove_reference_t<_Tp>>\n+\t&& requires(_Tp&& __t)\n+\t{\n+\t  { get<0>(std::forward<_Tp>(__t)) } -> convertible_to<_Up>;\n+\t  { get<1>(std::forward<_Tp>(__t)) } -> convertible_to<_Vp>;\n+\t};\n+\n+    template<typename _Tp, typename _Up, typename _Vp>\n+      concept __pair_like_convertible_from\n+\t= !range<_Tp> && __pair_like<_Tp>\n+\t&& constructible_from<_Tp, _Up, _Vp>;\n+\n+    template<typename _Tp>\n+      concept __iterator_sentinel_pair\n+\t= !range<_Tp> && __pair_like<_Tp>\n+\t&& sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;\n+\n+    template<typename _Tp, bool _MaxDiff = same_as<_Tp, __max_diff_type>>\n+      using __make_unsigned_like_t\n+\t= conditional_t<_MaxDiff, __max_size_type, make_unsigned_t<_Tp>>;\n+\n+  } // namespace __detail\n+\n+  enum class subrange_kind : bool { unsized, sized };\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,\n+\t   subrange_kind _Kind = sized_sentinel_for<_Sent, _It>\n+\t     ? subrange_kind::sized : subrange_kind::unsized>\n+    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)\n+    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>\n+    {\n+    private:\n+      static constexpr bool _S_store_size\n+\t= _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;\n+\n+      _It _M_begin = _It();\n+      _Sent _M_end = _Sent();\n+\n+      template<typename, bool = _S_store_size>\n+\tstruct _Size\n+\t{ };\n+\n+      template<typename _Tp>\n+\tstruct _Size<_Tp, true>\n+\t{ __detail::__make_unsigned_like_t<_Tp> _M_size; };\n+\n+      [[no_unique_address]] _Size<iter_difference_t<_It>> _M_size = {};\n+\n+    public:\n+      subrange() = default;\n+\n+      constexpr\n+      subrange(_It __i, _Sent __s) requires (!_S_store_size)\n+      : _M_begin(__i), _M_end(__s)\n+      { }\n+\n+      constexpr\n+      subrange(_It __i, _Sent __s,\n+\t       __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+      : _M_begin(__i), _M_end(__s)\n+      {\n+\tusing __detail::__to_unsigned_like;\n+\t__glibcxx_assert(__n == __to_unsigned_like(ranges::distance(__i, __s)));\n+\tif constexpr (_S_store_size)\n+\t  _M_size._M_size = __n;\n+      }\n+\n+      template<__detail::__not_same_as<subrange> _Rng>\n+\trequires __detail::__forwarding_range<_Rng>\n+\t  && convertible_to<iterator_t<_Rng>, _It>\n+\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n+\tconstexpr\n+\tsubrange(_Rng&& __r) requires (!_S_store_size || sized_range<_Rng>)\n+\t: subrange{ranges::begin(__r), ranges::end(__r)}\n+        {\n+\t  if constexpr (_S_store_size)\n+\t    _M_size._M_size = ranges::size(__r);\n+\t}\n+\n+      template<__detail::__forwarding_range _Rng>\n+\trequires convertible_to<iterator_t<_Rng>, _It>\n+\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n+\tconstexpr\n+\tsubrange(_Rng&& __r,\n+\t\t __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+\t: subrange{ranges::begin(__r), ranges::end(__r), __n}\n+\t{ }\n+\n+      template<__detail::__not_same_as<subrange> _PairLike>\n+\trequires __detail::__pair_like_convertible_to<_PairLike, _It, _Sent>\n+\tconstexpr\n+\tsubrange(_PairLike&& __r) requires (!_S_store_size)\n+\t: subrange{std::get<0>(std::forward<_PairLike>(__r)),\n+\t\t   std::get<1>(std::forward<_PairLike>(__r))}\n+\t{ }\n+\n+      template<__detail::__pair_like_convertible_to<_It, _Sent> _PairLike>\n+\tconstexpr\n+\tsubrange(_PairLike&& __r,\n+\t\t __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+\t: subrange{std::get<0>(std::forward<_PairLike>(__r)),\n+\t\t   std::get<1>(std::forward<_PairLike>(__r)), __n}\n+\t{ }\n+\n+      template<__detail::__not_same_as<subrange> _PairLike>\n+\trequires __detail::__pair_like_convertible_from<_PairLike, const _It&,\n+\t\t\t\t\t\t\tconst _Sent&>\n+      constexpr\n+      operator _PairLike() const\n+      { return _PairLike(_M_begin, _M_end); }\n+\n+      constexpr _It begin() const { return _M_begin; }\n+\n+      constexpr _Sent end() const { return _M_end; }\n+\n+      constexpr bool empty() const { return _M_begin == _M_end; }\n+\n+      constexpr __detail::__make_unsigned_like_t<iter_difference_t<_It>>\n+      size() const requires (_Kind == subrange_kind::sized)\n+      {\n+\tif constexpr (_S_store_size)\n+\t  return _M_size._M_size;\n+\telse\n+\t  return __detail::__to_unsigned_like(_M_end - _M_begin);\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      next(iter_difference_t<_It> __n = 1) const\n+      {\n+\tauto __tmp = *this;\n+\t__tmp.advance(__n);\n+\treturn __tmp;\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      prev(iter_difference_t<_It> __n = 1) const\n+\trequires bidirectional_iterator<_It>\n+      {\n+\tauto __tmp = *this;\n+\t__tmp.advance(--__n);\n+\treturn __tmp;\n+      }\n+\n+      constexpr subrange&\n+      advance(iter_difference_t<_It> __n)\n+      {\n+\tif constexpr (_S_store_size)\n+\t  {\n+\t    auto __d = __n - ranges::advance(_M_begin, __n, _M_end);\n+\t    if (__d >= 0)\n+\t      _M_size._M_size -= __detail::__to_unsigned_like(__d);\n+\t    else\n+\t      _M_size._M_size += __detail::__to_unsigned_like(-__d);\n+\t  }\n+\telse\n+\t  ranges::advance(_M_begin, __n, _M_end);\n+\treturn *this;\n+      }\n+\n+      friend constexpr _It\n+      begin(subrange&& __r) { return __r.begin(); }\n+\n+      friend constexpr _Sent\n+      end(subrange&& __r) { return __r.end(); }\n+    };\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    subrange(_It, _Sent,\n+\t     __detail::__make_unsigned_like_t<iter_difference_t<_It>>)\n+      -> subrange<_It, _Sent, subrange_kind::sized>;\n+\n+  template<__detail::__iterator_sentinel_pair _Pr>\n+    subrange(_Pr)\n+      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;\n+\n+  template<__detail::__iterator_sentinel_pair _Pr>\n+    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<\n+\t\t\t\t\t\t     tuple_element_t<0, _Pr>>>)\n+      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,\n+\t\t  subrange_kind::sized>;\n+\n+  template<__detail::__forwarding_range _Rng>\n+    subrange(_Rng&&)\n+      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,\n+\t\t (sized_range<_Rng>\n+\t\t  || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)\n+                 ? subrange_kind::sized : subrange_kind::unsized>;\n+\n+  template<__detail::__forwarding_range _Rng>\n+    subrange(_Rng&&,\n+\t     __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)\n+      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;\n+\n+  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>\n+    requires (_Num < 2)\n+    constexpr auto\n+    get(const subrange<_It, _Sent, _Kind>& __r)\n+    {\n+      if constexpr (_Num == 0)\n+\treturn __r.begin();\n+      else\n+\treturn __r.end();\n+    }\n+} // namespace ranges\n+\n+  using ranges::get;\n+\n+namespace ranges\n+{\n+  /// Type returned by algorithms instead of a dangling iterator or subrange.\n+  struct dangling\n+  {\n+    constexpr dangling() noexcept = default;\n+    template<typename... _Args>\n+      constexpr dangling(_Args&&...) noexcept { }\n+  };\n+\n+  template<typename _Tp> requires is_object_v<_Tp>\n+    class empty_view : public view_interface<empty_view<_Tp>>\n+    {\n+    public:\n+      static constexpr _Tp* begin() noexcept { return nullptr; }\n+      static constexpr _Tp* end() noexcept { return nullptr; }\n+      static constexpr _Tp* data() noexcept { return nullptr; }\n+      static constexpr size_t size() noexcept { return 0; }\n+      static constexpr bool empty() noexcept { return true; }\n+\n+      friend constexpr _Tp* begin(empty_view) noexcept { return nullptr; }\n+      friend constexpr _Tp* end(empty_view) noexcept { return nullptr; }\n+    };\n+\n+  namespace __detail\n+  {\n+    template<copy_constructible _Tp> requires is_object_v<_Tp>\n+      struct __box : std::optional<_Tp>\n+      {\n+\tusing std::optional<_Tp>::optional;\n+\n+\tconstexpr\n+\t__box()\n+\tnoexcept(is_nothrow_default_constructible_v<_Tp>)\n+\trequires default_constructible<_Tp>\n+\t: std::optional<_Tp>{std::in_place}\n+\t{ }\n+\n+\tusing std::optional<_Tp>::operator=;\n+\n+        __box&\n+\toperator=(const __box& __that)\n+\tnoexcept(is_nothrow_copy_constructible_v<_Tp>)\n+\trequires (!assignable_from<_Tp&, const _Tp&>)\n+\t{\n+\t  if ((bool)__that)\n+\t    this->emplace(*__that);\n+\t  else\n+\t    this->reset();\n+\t  return *this;\n+\t}\n+\n+\t__box&\n+\toperator=(__box&& __that)\n+\tnoexcept(is_nothrow_move_constructible_v<_Tp>)\n+\trequires (!assignable_from<_Tp&, _Tp>)\n+\t{\n+\t  if ((bool)__that)\n+\t    this->emplace(std::move(*__that));\n+\t  else\n+\t    this->reset();\n+\t  return *this;\n+\t}\n+      };\n+\n+  } // namespace __detail\n+\n+  /// A view that contains exactly one element.\n+  template<copy_constructible _Tp> requires is_object_v<_Tp>\n+    class single_view : public view_interface<single_view<_Tp>>\n+    {\n+    public:\n+      single_view() = default;\n+\n+      constexpr explicit\n+      single_view(const _Tp& __t)\n+      : _M_value(__t)\n+      { }\n+\n+      constexpr explicit\n+      single_view(_Tp&& __t)\n+      : _M_value(std::move(__t))\n+      { }\n+\n+      template<typename... _Args>\n+\trequires constructible_from<_Tp, _Args...>\n+\tconstexpr\n+\tsingle_view(in_place_t, _Args&&... __args)\n+\t: _M_value{in_place, std::forward<_Args>(__args)...}\n+\t{ }\n+\n+      constexpr _Tp*\n+      begin() noexcept\n+      { return data(); }\n+\n+      constexpr const _Tp*\n+      begin() const noexcept\n+      { return data(); }\n+\n+      constexpr _Tp*\n+      end() noexcept\n+      { return data() + 1; }\n+\n+      constexpr const _Tp*\n+      end() const noexcept\n+      { return data() + 1; }\n+\n+      static constexpr size_t\n+      size() noexcept\n+      { return 1; }\n+\n+      constexpr _Tp*\n+      data() noexcept\n+      { return _M_value.operator->(); }\n+\n+      constexpr const _Tp*\n+      data() const noexcept\n+      { return _M_value.operator->(); }\n+\n+    private:\n+      __detail::__box<_Tp> _M_value;\n+    };\n+\n+  namespace __detail\n+  {\n+#ifdef _GLIBCXX_INTEGER_LIKE_TYPES\n+    class __max_diff_type\n+    {\n+    public:\n+      __max_diff_type() = default;\n+\n+      template<signed_integral _Tp>\n+\tconstexpr\n+\t__max_diff_type(_Tp __i) noexcept\n+\t: _M_val(__i < 0 ? rep(~__i) + rep(1) : __i), _M_sign_bit(__i < 0)\n+\t{ }\n+\n+      template<unsigned_integral _Tp>\n+\tconstexpr\n+\t__max_diff_type(_Tp __i) noexcept\n+\t: _M_val(__i), _M_sign_bit(false)\n+\t{ }\n+\n+      template<signed_integral _Tp>\n+\tconstexpr explicit operator _Tp() const noexcept\n+\t{\n+\t  _Tp __val = _M_val % (sizeof(_Tp) * __CHAR_BIT__);\n+\t  if (_M_sign_bit)\n+\t    return -__val;\n+\t  else\n+\t    return __val;\n+\t}\n+\n+      template<unsigned_integral _Tp>\n+\tconstexpr explicit operator _Tp() const noexcept\n+\t{ return _M_val; }\n+\n+      constexpr explicit\n+      operator bool() const noexcept { return _M_val != 0; }\n+\n+      constexpr __max_diff_type\n+      operator+() const noexcept { return *this; }\n+\n+      constexpr __max_diff_type\n+      operator-() const noexcept\n+      { return __max_diff_type{_M_val, !_M_sign_bit}; }\n+\n+      constexpr __max_diff_type\n+      operator~() const noexcept\n+      { return __max_diff_type{~_M_val, !_M_sign_bit}; }\n+\n+      constexpr __max_diff_type&\n+      operator+=(const __max_diff_type& __r) noexcept\n+      {\n+\tif (_M_sign_bit == __r._M_sign_bit)\n+\t  _M_val += __r._M_val;\n+\telse if (_M_val >= __r._M_val)\n+\t  _M_val -= __r._M_val;\n+\telse\n+\t  {\n+\t    _M_val = __r._M_val - _M_val;\n+\t    _M_sign_bit = !_M_sign_bit;\n+\t  }\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator-=(const __max_diff_type& __r) noexcept\n+      {\n+\tauto __rneg = __r;\n+\t__rneg._M_sign_bit = !__r._M_sign_bit;\n+\treturn *this += __rneg;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator*=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_val *= __r._M_val;\n+\t_M_sign_bit = (_M_sign_bit != __r._M_sign_bit);\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator/=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_val /= __r._M_val;\n+\t_M_sign_bit = (_M_sign_bit != __r._M_sign_bit);\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator%=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_val /= __r._M_val;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator<<=(const __max_diff_type& __r) noexcept\n+      {\n+\t__glibcxx_assert(__r._M_val < numeric_limits<rep>::digits);\n+\t__glibcxx_assert(!__r._M_sign_bit);\n+\t_M_val <<= __r._M_val;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator>>=(const __max_diff_type& __r) noexcept\n+      {\n+\t__glibcxx_assert(__r._M_val < numeric_limits<rep>::digits);\n+\t__glibcxx_assert(!__r._M_sign_bit);\n+\t_M_val >>= __r._M_val;\n+\treturn *this;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator+(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l += __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator-(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l -= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator*(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l *= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator/(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l /= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator%(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l %= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator<<(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l <<= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator>>(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l >>= __r;\n+\treturn __l;\n+      }\n+\n+      // TODO & | ^\n+\n+      friend constexpr bool\n+      operator==(const __max_diff_type& __l, const __max_diff_type& __r)\n+      noexcept\n+      {\n+\treturn __l._M_val == __r._M_val && __l._M_sign_bit == __r._M_sign_bit;\n+      }\n+\n+      friend constexpr bool\n+      operator!=(const __max_diff_type& __l, const __max_diff_type& __r)\n+      noexcept\n+      { return !(__l == __r); }\n+\n+      friend constexpr bool\n+      operator<(const __max_diff_type& __l, const __max_diff_type& __r)\n+      noexcept\n+      {\n+\tif (__l._M_sign_bit)\n+\t  {\n+\t    if (__r._M_sign_bit)\n+\t      return __l._M_val > __r._M_val;\n+\t    else\n+\t      return true;\n+\t  }\n+\telse if (__r._M_sign_bit)\n+\t  return false;\n+\treturn __l._M_val < __r._M_val;\n+      }\n+\n+      friend constexpr bool\n+      operator>(const __max_diff_type& __l, const __max_diff_type& __r)\n+      noexcept\n+      { return __r < __l; }\n+\n+      friend constexpr bool\n+      operator<=(const __max_diff_type& __l, const __max_diff_type& __r)\n+      noexcept\n+      { return !(__r < __l); }\n+\n+      friend constexpr bool\n+      operator>=(const __max_diff_type& __l, const __max_diff_type& __r)\n+      noexcept\n+      { return !(__l < __r); }\n+\n+    private:\n+#ifdef __SIZEOF_INT128__\n+      using rep = unsigned __int128;\n+#else\n+      using rep = unsigned long long;\n+#endif\n+      rep _M_val = 0;\n+      bool _M_sign_bit = false;\n+\n+      constexpr explicit\n+      __max_diff_type(rep __val, bool __sb) noexcept\n+      : _M_val(__val), _M_sign_bit(__sb)\n+      { }\n+\n+      friend class __max_size_type;\n+    };\n+\n+    class __max_size_type\n+    {\n+    public:\n+      __max_size_type() = default;\n+\n+      template<integral _Tp>\n+\tconstexpr\n+\t__max_size_type(_Tp __i) noexcept\n+\t: _M_val(__i), _M_msb(0)\n+\t{ }\n+\n+      constexpr explicit\n+      __max_size_type(const __max_diff_type& __d)\n+      : _M_val(__d._M_val), _M_msb(__d._M_sign_bit)\n+      { }\n+\n+      template<integral _Tp>\n+\tconstexpr explicit operator _Tp() const noexcept\n+\t{ return _M_val; }\n+\n+      constexpr explicit\n+      operator bool() const noexcept { return _M_val != 0; }\n+\n+      constexpr __max_size_type\n+      operator+() const noexcept { return *this; }\n+\n+      constexpr __max_size_type\n+      operator-() const noexcept\n+      { return __max_size_type{_M_val, !_M_sign_bit}; }\n+\n+      constexpr __max_size_type\n+      operator~() const noexcept\n+      { return __max_size_type{~_M_val, !_M_sign_bit}; }\n+\n+      constexpr __max_size_type&\n+      operator+=(const __max_size_type& __r) noexcept\n+      {\n+\tif (_M_sign_bit == __r._M_sign_bit)\n+\t  _M_val += __r._M_val;\n+\telse if (_M_val >= __r._M_val)\n+\t  _M_val -= __r._M_val;\n+\telse\n+\t  {\n+\t    _M_val = __r._M_val - _M_val;\n+\t    _M_sign_bit = !_M_sign_bit;\n+\t  }\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator-=(const __max_size_type& __r) noexcept\n+      {\n+\tauto __rneg = __r;\n+\t__rneg._M_sign_bit = !__r._M_sign_bit;\n+\treturn *this += __rneg;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator*=(const __max_size_type& __r) noexcept\n+      {\n+\t_M_val *= __r._M_val;\n+\t_M_sign_bit ^= __r._M_sign_bit;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator/=(const __max_size_type& __r) noexcept\n+      {\n+\t_M_val /= __r._M_val;\n+\t_M_sign_bit ^= __r._M_sign_bit;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator%=(const __max_size_type& __r) noexcept\n+      {\n+\t_M_val /= __r._M_val;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator<<=(const __max_size_type& __r) noexcept\n+      {\n+\t__glibcxx_assert(__r._M_val < numeric_limits<rep>::digits);\n+\t__glibcxx_assert(__r._M_sign_bit == 0);\n+\t_M_val <<= __r._M_val;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator>>=(const __max_size_type& __r) noexcept\n+      {\n+\t__glibcxx_assert(__r._M_val < numeric_limits<rep>::digits);\n+\t__glibcxx_assert(__r._M_sign_bit == 0);\n+\t_M_val >>= __r._M_val;\n+\treturn *this;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator+(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l += __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator-(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l -= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator*(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l *= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator/(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l /= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator%(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l %= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator<<(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l <<= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator>>(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l >>= __r;\n+\treturn __l;\n+      }\n+\n+      // TODO & | ^ > <= >=\n+\n+      friend constexpr bool\n+      operator==(const __max_size_type& __l, const __max_size_type& __r)\n+      noexcept\n+      {\n+\treturn __l._M_val == __r._M_val && __l._M_msb == __r._M_msb;\n+      }\n+\n+      friend constexpr bool\n+      operator!=(const __max_size_type& __l, const __max_size_type& __r)\n+      noexcept\n+      { return !(__l == __r); }\n+\n+      friend constexpr bool\n+      operator<(const __max_size_type& __l, const __max_size_type& __r)\n+      noexcept\n+      {\n+\tif (__l._M_msb == __r._M_msb)\n+\t  return __l._M_val < __r._M_val;\n+\telse\n+\t  return __r._M_msb;\n+      }\n+\n+      friend constexpr bool\n+      operator>(const __max_size_type& __l, const __max_size_type& __r)\n+      noexcept\n+      { return __r < __l; }\n+\n+    private:\n+#ifdef __SIZEOF_INT128__\n+      using rep = unsigned __int128;\n+#else\n+      using rep = unsigned long long;\n+#endif\n+      rep _M_val = 0;\n+      unsigned _M_msb : 1;\n+\n+      constexpr explicit\n+      __max_size_type(rep __val, int __sb) noexcept\n+      : _M_val(__val), _M_sig_bit(__sb)\n+      { }\n+    };\n+#endif // _GLIBCXX_NO_INTEGER_LIKE_TYPES\n+\n+    template<typename _Wp>\n+      constexpr auto __to_signed_like(_Wp __w) noexcept\n+      {\n+\tif constexpr (!integral<_Wp>)\n+\t  return iter_difference_t<_Wp>();\n+\telse if constexpr (sizeof(iter_difference_t<_Wp>) > sizeof(_Wp))\n+\t  return iter_difference_t<_Wp>(__w);\n+\telse if constexpr (sizeof(ptrdiff_t) > sizeof(_Wp))\n+\t  return ptrdiff_t(__w);\n+\telse if constexpr (sizeof(long long) > sizeof(_Wp))\n+\t  return (long long)(__w);\n+#ifdef __SIZEOF_INT128__\n+\telse if constexpr (__SIZEOF_INT128__ > sizeof(_Wp))\n+\t  return __int128(__w);\n+#endif\n+\telse\n+\t  return __max_diff_type(__w);\n+      }\n+\n+    template<typename _Wp>\n+      using __iota_diff_t = decltype(__to_signed_like(std::declval<_Wp>()));\n+\n+    template<typename _It>\n+      concept __decrementable = incrementable<_It>\n+\t&& requires(_It __i)\n+\t{\n+\t    { --__i } -> same_as<_It&>;\n+\t    { __i-- } -> same_as<_It>;\n+\t};\n+\n+    template<typename _It>\n+      concept __advanceable = __decrementable<_It> && totally_ordered<_It>\n+        && requires( _It __i, const _It __j, const __iota_diff_t<_It> __n)\n+\t{\n+\t  { __i += __n } -> same_as<_It&>;\n+\t  { __i -= __n } -> same_as<_It&>;\n+\t  _It(__j + __n);\n+\t  _It(__n + __j);\n+\t  _It(__j - __n);\n+\t  { __j - __j } -> convertible_to<__iota_diff_t<_It>>;\n+\t};\n+\n+  } // namespace __detail\n+\n+  template<weakly_incrementable _Winc,\n+\t   semiregular _Bound = unreachable_sentinel_t>\n+    requires std::__detail::__weakly_eq_cmp_with<_Winc, _Bound>\n+    class iota_view : public view_interface<iota_view<_Winc, _Bound>>\n+    {\n+    private:\n+      struct _Iterator\n+      {\n+      private:\n+\tstatic auto\n+\t_S_iter_cat()\n+\t{\n+\t  using namespace __detail;\n+\t  if constexpr (__advanceable<_Winc>)\n+\t    return random_access_iterator_tag{};\n+\t  else if constexpr (__decrementable<_Winc>)\n+\t    return bidirectional_iterator_tag{};\n+\t  else if constexpr (incrementable<_Winc>)\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return input_iterator_tag{};\n+\t}\n+\n+      public:\n+\tusing iterator_category = decltype(_S_iter_cat());\n+\tusing value_type = _Winc;\n+\tusing difference_type = __detail::__iota_diff_t<_Winc>;\n+\n+\t_Iterator() = default;\n+\n+\tconstexpr explicit\n+\t_Iterator(_Winc __value)\n+\t: _M_value(__value) { }\n+\n+\tconstexpr _Winc\n+\toperator*() const noexcept(is_nothrow_copy_constructible_v<_Winc>)\n+        { return *_M_value; }\n+\n+\tconstexpr _Iterator&\n+\toperator++()\n+\t{\n+\t  ++_M_value;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr void\n+\toperator++(int)\n+\t{ ++*this; }\n+\n+\tconstexpr _Iterator\n+\toperator++(int) requires incrementable<_Winc>\n+\t{\n+\t  auto __tmp = *this;\n+\t  ++*this;\n+\t  return __tmp;\n+\t}\n+\n+\tconstexpr _Iterator&\n+\toperator--() requires __detail::__decrementable<_Winc>\n+\t{\n+\t  --_M_value;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Iterator\n+\toperator--(int) requires __detail::__decrementable<_Winc>\n+\t{\n+\t  auto __tmp = *this;\n+\t  --*this;\n+\t  return __tmp;\n+\t}\n+\n+\tconstexpr _Iterator&\n+\toperator+=(difference_type __n) requires __detail::__advanceable<_Winc>\n+\t{\n+\t  using namespace __detail;\n+\t  if constexpr (__is_integer_like<_Winc>\n+\t      && !__is_signed_integer_like<_Winc>)\n+\t    {\n+\t      if (__n >= difference_type(0))\n+\t\t_M_value += static_cast<_Winc>(__n);\n+\t      else\n+\t\t_M_value -= static_cast<_Winc>(-__n);\n+\t    }\n+\t  else\n+\t    _M_value += __n;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Iterator&\n+\toperator-=(difference_type __n) requires __detail::__advanceable<_Winc>\n+\t{\n+\t  using namespace __detail;\n+\t  if constexpr (__is_integer_like<_Winc>\n+\t      && !__is_signed_integer_like<_Winc>)\n+\t    {\n+\t      if (__n >= difference_type(0))\n+\t\t_M_value -= static_cast<_Winc>(__n);\n+\t      else\n+\t\t_M_value += static_cast<_Winc>(-__n);\n+\t    }\n+\t  else\n+\t    _M_value -= __n;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Winc\n+\toperator[](difference_type __n) const\n+\trequires __detail::__advanceable<_Winc>\n+\t{ return _Winc(_M_value + __n); }\n+\n+\tfriend constexpr bool\n+\toperator==(const _Iterator& __x, const _Iterator& __y)\n+\trequires equality_comparable<_Winc>\n+\t{ return __x._M_value == __y._M_value; }\n+\n+\tfriend constexpr bool\n+\toperator<(const _Iterator& __x, const _Iterator& __y)\n+\trequires totally_ordered<_Winc>\n+\t{ return __x._M_value < __y._M_value; }\n+\n+\tfriend constexpr bool\n+\toperator>(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc>\n+\t{ return __y < __x; }\n+\n+\tfriend constexpr bool\n+\toperator<=(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc>\n+\t{ return !(__y < __x); }\n+\n+\tfriend constexpr bool\n+\toperator>=(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc>\n+\t{ return !(__x < __y); }\n+\n+#ifdef __cpp_lib_threeway_comparison\n+\tfriend constexpr compare_three_way_result_t<_Winc>\n+\toperator<=>(const _Iterator& __x, const _Iterator& __y)\n+\t  requires totally_ordered<_Winc> && three_way_comparable<_Winc>\n+\t{ return __x._M_value <=> __y._M_value; }\n+#endif\n+\n+\tfriend constexpr _Iterator\n+\toperator+(_Iterator __i, difference_type __n)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{ return __i += __n; }\n+\n+\tfriend constexpr _Iterator\n+\toperator+(difference_type __n, _Iterator __i)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{ return __i += __n; }\n+\n+\tfriend constexpr _Iterator\n+\toperator-(_Iterator __i, difference_type __n)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{ return __i -= __n; }\n+\n+\tfriend constexpr difference_type\n+\toperator-(const _Iterator& __x, const _Iterator& __y)\n+\t  requires __detail::__advanceable<_Winc>\n+\t{\n+\t  using namespace __detail;\n+\t  using _Dt = difference_type;\n+\t  if constexpr (__is_integer_like<_Winc>)\n+\t    {\n+\t      if constexpr (__is_signed_integer_like<_Winc>)\n+\t\treturn _Dt(_Dt(__x._M_value) - _Dt(__y._M_value));\n+\t      else\n+\t\treturn (__y._M_value > __x._M_value)\n+\t\t  ? _Dt(-_Dt(__y._M_value - __x._M_value))\n+\t\t  : _Dt(__x._M_value - __y._M_value);\n+\t    }\n+\t  else\n+\t    return __x._M_value - __y._M_value;\n+\t}\n+\n+      private:\n+\t_Winc _M_value = _Winc();\n+      };\n+\n+      struct _Sentinel\n+      {\n+      private:\n+\t_Bound _M_bound = _Bound();\n+\n+      public:\n+\t_Sentinel() = default;\n+\n+\tconstexpr explicit\n+\t_Sentinel(_Bound __bound)\n+\t: _M_bound(__bound) { }\n+\n+\tfriend constexpr bool\n+\toperator==(const _Iterator& __x, const _Sentinel& __y)\n+\t{ return __x._M_value == __y._M_bound; }\n+\n+\tfriend constexpr iter_difference_t<_Winc>\n+\toperator-(const _Iterator& __x, const _Sentinel& __y)\n+\t  requires sized_sentinel_for<_Bound, _Winc>\n+\t{ return __x._M_value - __y._M_bound; }\n+\n+\tfriend constexpr iter_difference_t<_Winc>\n+\toperator-(const _Sentinel& __x, const _Iterator& __y)\n+\t  requires sized_sentinel_for<_Bound, _Winc>\n+\t{ return -(__y - __x); }\n+      };\n+\n+      _Winc _M_value = _Winc();\n+      _Bound _M_bound = _Bound();\n+\n+    public:\n+      iota_view() = default;\n+\n+      constexpr explicit\n+      iota_view(_Winc __value)\n+      : _M_value(__value)\n+      { }\n+\n+      constexpr\n+      iota_view(type_identity_t<_Winc> __value,\n+\t\ttype_identity_t<_Bound> __bound)\n+      : _M_value(__value), _M_bound(__bound)\n+      {\n+\tif constexpr (totally_ordered_with<_Winc, _Bound>)\n+\t  __glibcxx_assert( bool(__value <= __bound) );\n+      }\n+\n+      constexpr _Iterator\n+      begin() const { return _Iterator{_M_value}; }\n+\n+      constexpr auto\n+      end() const\n+      {\n+\tif constexpr (same_as<_Bound, unreachable_sentinel_t>)\n+\t  return unreachable_sentinel;\n+\telse\n+\t  return _Sentinel{_M_bound};\n+      }\n+\n+      constexpr _Iterator\n+      end() const requires same_as<_Winc, _Bound>\n+      { return _Iterator{_M_bound}; }\n+\n+      constexpr auto\n+      size() const\n+      requires (same_as<_Winc, _Bound> && __detail::__advanceable<_Winc>)\n+      || (integral<_Winc> && integral<_Bound>)\n+      || sized_sentinel_for<_Bound, _Winc>\n+      {\n+\tusing namespace __detail;\n+\tif constexpr (__is_integer_like<_Winc> && __is_integer_like<_Bound>)\n+\t  return (_M_value < 0)\n+\t    ? ((_M_bound < 0)\n+\t\t? __to_unsigned_like(-_M_value) - __to_unsigned_like(-_M_bound)\n+\t\t: __to_unsigned_like(_M_bound) + __to_unsigned_like(-_M_value))\n+\t    : __to_unsigned_like(_M_bound) - __to_unsigned_like(_M_value);\n+\telse\n+\t  return __to_unsigned_like(_M_bound - _M_value);\n+      }\n+    };\n+\n+  template<typename _Winc, typename _Bound>\n+    requires (!__detail::__is_integer_like<_Winc>\n+\t|| !__detail::__is_integer_like<_Bound>\n+\t|| (__detail::__is_signed_integer_like<_Winc>\n+\t    == __detail::__is_signed_integer_like<_Bound>))\n+    iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;\n+\n+namespace views\n+{\n+  template<typename _Tp>\n+    inline constexpr empty_view<_Tp> empty{};\n+\n+  struct _Single\n+  {\n+    template<typename _Tp>\n+      auto\n+      operator()(_Tp&& __e) const\n+      { return single_view{std::forward<_Tp>(__e)}; }\n+  };\n+\n+  inline constexpr _Single single{};\n+\n+  struct _Iota\n+  {\n+    template<typename _Tp>\n+      auto\n+      operator()(_Tp&& __e) const\n+      { return iota_view{std::forward<_Tp>(__e)}; }\n+\n+    template<typename _Tp, typename _Up>\n+      auto\n+      operator()(_Tp&& __e, _Up&& __f) const\n+      { return iota_view{std::forward<_Tp>(__e), std::forward<_Tp>(__f)}; }\n+  };\n+\n+  inline constexpr _Iota iota{};\n+\n+} // namespace views\n } // namespace ranges\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}]}