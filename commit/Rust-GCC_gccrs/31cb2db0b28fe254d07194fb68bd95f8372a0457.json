{"sha": "31cb2db0b28fe254d07194fb68bd95f8372a0457", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFjYjJkYjBiMjhmZTI1NGQwNzE5NGZiNjhiZDk1ZjgzNzJhMDQ1Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-08T06:06:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-08T06:06:42Z"}, "message": "DR 1558\n\n\tDR 1558\n\t* pt.c (dependent_alias_template_spec_p): New.\n\t(dependent_type_p_r): Handle dependent alias template specialization.\n\t(template_args_equal): A dependent alias template specializations\n\tis not equal to its underlying type as a template argument.\n\t* tree.c (strip_typedefs): Don't strip a dependent alias\n\ttemplate-id.\n\nFrom-SVN: r217250", "tree": {"sha": "ab788b854793bedbd2a4f41bebb0a2e56b901e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab788b854793bedbd2a4f41bebb0a2e56b901e73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31cb2db0b28fe254d07194fb68bd95f8372a0457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31cb2db0b28fe254d07194fb68bd95f8372a0457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31cb2db0b28fe254d07194fb68bd95f8372a0457", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31cb2db0b28fe254d07194fb68bd95f8372a0457/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "967064a13f94780b3a573ed953ff6b7968da4361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967064a13f94780b3a573ed953ff6b7968da4361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967064a13f94780b3a573ed953ff6b7968da4361"}], "stats": {"total": 69, "additions": 63, "deletions": 6}, "files": [{"sha": "a831d62d8c2073b3447125572cd384a987019f0c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=31cb2db0b28fe254d07194fb68bd95f8372a0457", "patch": "@@ -1,5 +1,13 @@\n 2014-11-07  Jason Merrill  <jason@redhat.com>\n \n+\tDR 1558\n+\t* pt.c (dependent_alias_template_spec_p): New.\n+\t(dependent_type_p_r): Handle dependent alias template specialization.\n+\t(template_args_equal): A dependent alias template specializations\n+\tis not equal to its underlying type as a template argument.\n+\t* tree.c (strip_typedefs): Don't strip a dependent alias\n+\ttemplate-id.\n+\n \t* parser.c (cp_parser_unqualified_id): Handle __func__ here.\n \t(cp_parser_primary_expression): Not here.\n "}, {"sha": "74636dfbf8f15be10875f703a1251dcb30fe7c4a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=31cb2db0b28fe254d07194fb68bd95f8372a0457", "patch": "@@ -5692,6 +5692,7 @@ extern tree fold_non_dependent_expr\t\t(tree);\n extern tree fold_non_dependent_expr_sfinae\t(tree, tsubst_flags_t);\n extern bool alias_type_or_template_p            (tree);\n extern bool alias_template_specialization_p     (const_tree);\n+extern bool dependent_alias_template_spec_p     (const_tree);\n extern bool explicit_class_specialization_p     (tree);\n extern bool push_tinst_level                    (tree);\n extern bool push_tinst_level_loc                (tree, location_t);"}, {"sha": "fa9652f748c2b7f5744692c1e53624540ed8680a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=31cb2db0b28fe254d07194fb68bd95f8372a0457", "patch": "@@ -5268,7 +5268,7 @@ alias_type_or_template_p (tree t)\n \t  || DECL_ALIAS_TEMPLATE_P (t));\n }\n \n-/* Return TRUE iff is a specialization of an alias template.  */\n+/* Return TRUE iff T is a specialization of an alias template.  */\n \n bool\n alias_template_specialization_p (const_tree t)\n@@ -5282,6 +5282,16 @@ alias_template_specialization_p (const_tree t)\n \t  && DECL_ALIAS_TEMPLATE_P (TYPE_TI_TEMPLATE (t)));\n }\n \n+/* Return TRUE iff T is a specialization of an alias template with\n+   dependent template-arguments.  */\n+\n+bool\n+dependent_alias_template_spec_p (const_tree t)\n+{\n+  return (alias_template_specialization_p (t)\n+\t  && any_dependent_template_arguments_p (TYPE_TI_ARGS (t)));\n+}\n+\n /* Return the number of innermost template parameters in TMPL.  */\n \n static int\n@@ -7217,7 +7227,24 @@ template_args_equal (tree ot, tree nt)\n       return template_args_equal (ot, nt);\n     }\n   else if (TYPE_P (nt))\n-    return TYPE_P (ot) && same_type_p (ot, nt);\n+    {\n+      if (!TYPE_P (ot))\n+\treturn false;\n+      /* Don't treat an alias template specialization with dependent\n+\t arguments as equivalent to its underlying type when used as a\n+\t template argument; we need them to hash differently.  */\n+      bool ndep = dependent_alias_template_spec_p (nt);\n+      ++processing_template_decl;\n+      bool odep = dependent_alias_template_spec_p (ot);\n+      --processing_template_decl;\n+      if (ndep != odep)\n+\treturn false;\n+      else if (ndep)\n+\treturn (TYPE_TI_TEMPLATE (nt) == TYPE_TI_TEMPLATE (ot)\n+\t\t&& template_args_equal (TYPE_TI_ARGS (nt), TYPE_TI_ARGS (ot)));\n+      else\n+\treturn same_type_p (ot, nt);\n+    }\n   else if (TREE_CODE (ot) == TREE_VEC || TYPE_P (ot))\n     return 0;\n   else\n@@ -20719,8 +20746,10 @@ dependent_type_p_r (tree type)\n   if (TREE_CODE (type) == TYPENAME_TYPE)\n     return true;\n   /* -- a cv-qualified type where the cv-unqualified type is\n-\tdependent.  */\n-  type = TYPE_MAIN_VARIANT (type);\n+\tdependent.\n+     No code is necessary for this bullet; the code below handles\n+     cv-qualified types, and we don't want to strip aliases with\n+     TYPE_MAIN_VARIANT because of DR 1558.  */\n   /* -- a compound type constructed from any dependent type.  */\n   if (TYPE_PTRMEM_P (type))\n     return (dependent_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n@@ -20763,9 +20792,9 @@ dependent_type_p_r (tree type)\n     return true;\n   /* ... or any of the template arguments is a dependent type or\n \tan expression that is type-dependent or value-dependent.  */\n-  else if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n+  else if (TYPE_TEMPLATE_INFO (type)\n \t   && (any_dependent_template_arguments_p\n-\t       (INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type)))))\n+\t       (INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (type)))))\n     return true;\n \n   /* All TYPEOF_TYPEs, DECLTYPE_TYPEs, and UNDERLYING_TYPEs are"}, {"sha": "e0c2af1576c5e9c251a2783303a99ab2da4d55b3", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=31cb2db0b28fe254d07194fb68bd95f8372a0457", "patch": "@@ -1244,6 +1244,11 @@ strip_typedefs (tree t)\n   if (t == TYPE_CANONICAL (t))\n     return t;\n \n+  if (dependent_alias_template_spec_p (t))\n+    /* DR 1558: However, if the template-id is dependent, subsequent\n+       template argument substitution still applies to the template-id.  */\n+    return t;\n+\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:"}, {"sha": "2bbb138ec22c386dd1f9c5e47e63b2c6d4d0bade", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-dr1558.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1558.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cb2db0b28fe254d07194fb68bd95f8372a0457/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1558.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1558.C?ref=31cb2db0b28fe254d07194fb68bd95f8372a0457", "patch": "@@ -0,0 +1,14 @@\n+// DR 1558 still applies when using void_t as a template-argument.\n+// { dg-do compile { target c++11 } }\n+\n+template<typename...> using void_t = void;\n+template<class T> struct A { };\n+struct B { typedef int foo; };\n+template<typename T> A<void_t<typename T::foo>> f(); // { dg-error \"int\" }\n+template<typename T> A<void> g();\n+int main()\n+{\n+  f<B>();\n+  g<int>();\n+  f<int>(); // { dg-error \"no match\" }\n+}"}]}