{"sha": "735352d2eede1e412cb89f45a5c3e0846bce39af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM1MzUyZDJlZWRlMWU0MTJjYjg5ZjQ1YTVjM2UwODQ2YmNlMzlhZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-11-28T17:26:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-11-28T17:26:03Z"}, "message": "constraints.md: Add \"C\" constraint for call insns.\n\n\t* config/h8300/constraints.md: Add \"C\" constraint for call insns.\n\t* config/h8300/h8300.md (call, call_value): Turn into a define_expand\n\tand define_insn pair.  Move invalid call targets into a register in\n\tthe expander and fix constraints in the matching pattern.\n\t* config/h8300/predicates.md (call_expander_operand): Renamed from\n\tcall_insn_operand.  Reject things we shouldn't be trying to handle.\n\t(call_insn_operand): New predicate for use by the call/call_value\n\tinsns.\n\t(small_call_insn_operand): Update appropriately.\n\nFrom-SVN: r266571", "tree": {"sha": "113cc356265a9752c29f2b99a0a79db25e5ca7ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/113cc356265a9752c29f2b99a0a79db25e5ca7ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/735352d2eede1e412cb89f45a5c3e0846bce39af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/735352d2eede1e412cb89f45a5c3e0846bce39af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/735352d2eede1e412cb89f45a5c3e0846bce39af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/735352d2eede1e412cb89f45a5c3e0846bce39af/comments", "author": null, "committer": null, "parents": [{"sha": "7185a4ebc2121b9bef7f8697ad432e55a4ab5d25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7185a4ebc2121b9bef7f8697ad432e55a4ab5d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7185a4ebc2121b9bef7f8697ad432e55a4ab5d25"}], "stats": {"total": 110, "additions": 81, "deletions": 29}, "files": [{"sha": "6456facbacbfbf162d2d99b4ca328d568eb71658", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=735352d2eede1e412cb89f45a5c3e0846bce39af", "patch": "@@ -1,7 +1,19 @@\n+2018-11-28  Jeff Law  <law@redhat.com>\n+\n+\t* config/h8300/constraints.md: Add \"C\" constraint for call insns.\n+\t* config/h8300/h8300.md (call, call_value): Turn into a define_expand\n+\tand define_insn pair.  Move invalid call targets into a register in\n+\tthe expander and fix constraints in the matching pattern.\n+\t* config/h8300/predicates.md (call_expander_operand): Renamed from\n+\tcall_insn_operand.  Reject things we shouldn't be trying to handle.\n+\t(call_insn_operand): New predicate for use by the call/call_value\n+\tinsns.\n+\t(small_call_insn_operand): Update appropriately.\n+\n 2018-11-28  Sam Tebbs  <sam.tebbs@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_process_target_attr): Replace\n-\t\tcalls to strtok with strtok_r.\n+\tcalls to strtok with strtok_r.\n \n 2018-11-28  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "4175c832ef39eeb1a6c9214136c15f957bcc27a9", "filename": "gcc/config/h8300/constraints.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fconstraints.md?ref=735352d2eede1e412cb89f45a5c3e0846bce39af", "patch": "@@ -158,6 +158,10 @@\n   (and (match_code \"const_int\")\n        (match_test \"!h8300_shift_needs_scratch_p (ival, QImode)\")))\n \n+(define_constraint \"C\"\n+  \"@internal\"\n+  (match_code \"symbol_ref\"))\n+\n (define_constraint \"S\"\n   \"@internal\"\n   (and (match_code \"const_int\")"}, {"sha": "0686f25d71de857dc46a426de6463850f29382fd", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=735352d2eede1e412cb89f45a5c3e0846bce39af", "patch": "@@ -2064,16 +2064,30 @@\n \n ;; ??? Even though we use HImode here, this works on the H8/300H and H8S.\n \n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"call_insn_operand\" \"or\")\n-\t (match_operand:HI 1 \"general_operand\" \"g\"))]\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"call_expander_operand\" \"\")\n+\t (match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (!register_operand (XEXP (operands[0], 0), Pmode)\n+\t&& GET_CODE (XEXP (operands[0], 0)) != SYMBOL_REF)\n+      XEXP (operands[0], 0) = force_reg (Pmode, XEXP (operands[0], 0));\n+  })\n+\n+(define_insn \"call_insn\"\n+  [(call (mem:QI (match_operand 0 \"call_insn_operand\" \"Cr\"))\n+\t         (match_operand:HI 1 \"general_operand\" \"g\"))]\n   \"\"\n {\n-  if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF\n-      && (SYMBOL_REF_FLAGS (XEXP (operands[0], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n-    return \"jsr\\\\t@%0:8\";\n+  rtx xoperands[1];\n+  xoperands[0] = gen_rtx_MEM (QImode, operands[0]);\n+  gcc_assert (GET_MODE (operands[0]) == Pmode);\n+  if (GET_CODE (XEXP (xoperands[0], 0)) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (XEXP (xoperands[0], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    output_asm_insn (\"jsr\\\\t@%0:8\", xoperands);\n   else\n-    return \"jsr\\\\t%0\";\n+    output_asm_insn (\"jsr\\\\t%0\", xoperands);\n+  return \"\";\n }\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n@@ -2086,17 +2100,33 @@\n \n ;; ??? Even though we use HImode here, this works on the H8/300H and H8S.\n \n-(define_insn \"call_value\"\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:QI 1 \"call_expander_operand\" \"\")\n+\t      (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (!register_operand (XEXP (operands[1], 0), Pmode)\n+\t&& GET_CODE (XEXP (operands[1], 0)) != SYMBOL_REF)\n+      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));\n+  })\n+\n+(define_insn \"call_value_insn\"\n   [(set (match_operand 0 \"\" \"=r\")\n-\t(call (match_operand:QI 1 \"call_insn_operand\" \"or\")\n-\t      (match_operand:HI 2 \"general_operand\" \"g\")))]\n+\t(call (mem:QI (match_operand 1 \"call_insn_operand\" \"Cr\"))\n+\t\t      (match_operand:HI 2 \"general_operand\" \"g\")))]\n   \"\"\n {\n-  if (GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n-      && (SYMBOL_REF_FLAGS (XEXP (operands[1], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n-    return \"jsr\\\\t@%1:8\";\n+  rtx xoperands[2];\n+  gcc_assert (GET_MODE (operands[1]) == Pmode);\n+  xoperands[0] = operands[0];\n+  xoperands[1] = gen_rtx_MEM (QImode, operands[1]);\n+  if (GET_CODE (XEXP (xoperands[1], 0)) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (XEXP (xoperands[1], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    output_asm_insn (\"jsr\\\\t@%1:8\", xoperands);\n   else\n-    return \"jsr\\\\t%1\";\n+    output_asm_insn (\"jsr\\\\t%1\", xoperands);\n+  return \"\";\n }\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")"}, {"sha": "217189ad1f5e504f250f1d0c371ceafe494175ad", "filename": "gcc/config/h8300/predicates.md", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/735352d2eede1e412cb89f45a5c3e0846bce39af/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fpredicates.md?ref=735352d2eede1e412cb89f45a5c3e0846bce39af", "patch": "@@ -216,39 +216,45 @@\n \n ;; Return true if OP is a valid call operand.\n \n-(define_predicate \"call_insn_operand\"\n+(define_predicate \"call_expander_operand\"\n   (match_code \"mem\")\n {\n   if (GET_CODE (op) == MEM)\n     {\n       rtx inside = XEXP (op, 0);\n       if (register_operand (inside, Pmode))\n \treturn 1;\n-      if (CONSTANT_ADDRESS_P (inside))\n+      if (SYMBOL_REF_P (inside))\n \treturn 1;\n     }\n   return 0;\n })\n \n+(define_predicate \"call_insn_operand\"\n+  (match_code \"reg,symbol_ref\")\n+{\n+  if (register_operand (op, Pmode))\n+    return 1;\n+  if (SYMBOL_REF_P (op))\n+    return 1;\n+  return 0;\n+})\n+\n ;; Return true if OP is a valid call operand, and OP represents an\n ;; operand for a small call (4 bytes instead of 6 bytes).\n \n (define_predicate \"small_call_insn_operand\"\n-  (match_code \"mem\")\n+  (match_code \"reg,symbol_ref\")\n {\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx inside = XEXP (op, 0);\n+  /* Register indirect is a small call.  */\n+  if (register_operand (op, Pmode))\n+    return 1;\n \n-      /* Register indirect is a small call.  */\n-      if (register_operand (inside, Pmode))\n-\treturn 1;\n+  /* A call through the function vector is a small call too.  */\n+  if (GET_CODE (op) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    return 1;\n \n-      /* A call through the function vector is a small call too.  */\n-      if (GET_CODE (inside) == SYMBOL_REF\n-\t  && (SYMBOL_REF_FLAGS (inside) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n-\treturn 1;\n-    }\n   /* Otherwise it's a large call.  */\n   return 0;\n })"}]}