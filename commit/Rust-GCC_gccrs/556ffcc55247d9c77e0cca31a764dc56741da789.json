{"sha": "556ffcc55247d9c77e0cca31a764dc56741da789", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU2ZmZjYzU1MjQ3ZDljNzdlMGNjYTMxYTc2NGRjNTY3NDFkYTc4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-15T01:52:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-15T01:52:29Z"}, "message": "recog.c (pmode_register_operand): New.\n\n        * recog.c (pmode_register_operand): New.\n        * recog.h: Declare it.\n        * genrecog.c (pred_codes): Likewise.\n        (special_mode_pred_table): Likewise.\n        (validate_pattern): Don't warn no mode for address_operand.\n\n        * print-rtl.c (print_rtx) [LABEL_REF]: Only do full subexpression\n        if the operand is not insn-like.\n\nFrom-SVN: r29995", "tree": {"sha": "a2c9bf0ce2a7fd8466de760ea4c4fdc8aa203a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2c9bf0ce2a7fd8466de760ea4c4fdc8aa203a22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/556ffcc55247d9c77e0cca31a764dc56741da789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556ffcc55247d9c77e0cca31a764dc56741da789", "html_url": "https://github.com/Rust-GCC/gccrs/commit/556ffcc55247d9c77e0cca31a764dc56741da789", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556ffcc55247d9c77e0cca31a764dc56741da789/comments", "author": null, "committer": null, "parents": [{"sha": "104140890ae1b03e68e58122aeb64177ac37f544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104140890ae1b03e68e58122aeb64177ac37f544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/104140890ae1b03e68e58122aeb64177ac37f544"}], "stats": {"total": 49, "additions": 40, "deletions": 9}, "files": [{"sha": "a796dd260cb44369ac7a438061c87fc2f8a9b1be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=556ffcc55247d9c77e0cca31a764dc56741da789", "patch": "@@ -1,3 +1,14 @@\n+Thu Oct 14 18:48:54 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* recog.c (pmode_register_operand): New.\n+\t* recog.h: Declare it.\n+\t* genrecog.c (pred_codes): Likewise.\n+\t(special_mode_pred_table): Likewise.\n+\t(validate_pattern): Don't warn no mode for address_operand.\n+\n+\t* print-rtl.c (print_rtx) [LABEL_REF]: Only do full subexpression\n+\tif the operand is not insn-like.\n+\n Thu Oct 14 19:38:42 1999  Jeffrey A Law  (law@cygnus.com)\n \t\t\t  Sylvian Pion <Sylvain.Pion@sophia.inria.fr>\n "}, {"sha": "d12d7c6ff7047de68b09fe8b2aeeb349b2e7681e", "filename": "gcc/genrecog.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=556ffcc55247d9c77e0cca31a764dc56741da789", "patch": "@@ -197,6 +197,7 @@ static struct pred_table\n   {\"address_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n \t\t       LABEL_REF, SUBREG, REG, MEM, PLUS, MINUS, MULT}},\n   {\"register_operand\", {SUBREG, REG}},\n+  {\"pmode_register_operand\", {SUBREG, REG}},\n   {\"scratch_operand\", {SCRATCH, REG}},\n   {\"immediate_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n \t\t\t LABEL_REF}},\n@@ -220,11 +221,11 @@ static const char * special_mode_pred_table[] = {\n #ifdef SPECIAL_MODE_PREDICATES\n   SPECIAL_MODE_PREDICATES\n #endif\n-  NULL\n+  \"pmode_register_operand\"\n };\n \n #define NUM_SPECIAL_MODE_PREDS \\\n-  (sizeof (special_mode_pred_table) / sizeof (const char *) - 1)\n+  (sizeof (special_mode_pred_table) / sizeof (special_mode_pred_table[0]))\n \n static struct decision *new_decision\n   PROTO((const char *, struct decision_head *));\n@@ -516,15 +517,18 @@ validate_pattern (pattern, insn, set_dest)\n \t/* A modeless MATCH_OPERAND can be handy when we can\n \t   check for multiple modes in the c_test.  In most other cases,\n \t   it is a mistake.  Only DEFINE_INSN is eligible, since SPLIT\n-\t   and PEEP2 can FAIL within the output pattern.  */\n+\t   and PEEP2 can FAIL within the output pattern.  Exclude \n+\t   address_operand, since its mode is related to the mode of\n+\t   the memory not the operand.  */\n \n \tif (GET_MODE (pattern) == VOIDmode\n \t    && code == MATCH_OPERAND\n-\t    && pred_name[0] != '\\0'\n+\t    && GET_CODE (insn) == DEFINE_INSN\n \t    && allows_non_const\n \t    && ! special_mode_pred\n-\t    && strstr (c_test, \"operands\") == NULL\n-\t    && GET_CODE (insn) == DEFINE_INSN)\n+\t    && pred_name[0] != '\\0'\n+\t    && strcmp (pred_name, \"address_operand\") != 0\n+\t    && strstr (c_test, \"operands\") == NULL)\n \t  {\n \t    message_with_line (pattern_lineno,\n \t\t\t       \"warning: operand %d missing mode?\","}, {"sha": "8521b3c638141727e3daa078fc01a9513b759263", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=556ffcc55247d9c77e0cca31a764dc56741da789", "patch": "@@ -299,16 +299,21 @@ print_rtx (in_rtx)\n       case 'u':\n \tif (XEXP (in_rtx, i) != NULL)\n \t  {\n-\t    if (GET_CODE (XEXP (in_rtx, i)) != CODE_LABEL)\n+\t    rtx sub = XEXP (in_rtx, i);\n+\t    enum rtx_code subc = GET_CODE (sub);\n+\n+\t    if (subc != CODE_LABEL\n+\t\t&& subc != NOTE\n+\t\t&& GET_RTX_CLASS (subc) != 'i')\n \t      goto do_e;\n \n \t    if (flag_dump_unnumbered)\n \t      fputc ('#', outfile);\n \t    else\n-\t      fprintf (outfile, \" %d\", INSN_UID (XEXP (in_rtx, i)));\n+\t      fprintf (outfile, \" %d\", INSN_UID (sub));\n \t  }\n \telse\n-\t  fputs (\" 0\", outfile);\n+\t  fputs (\" (nil)\", outfile);\n \tsawclose = 0;\n \tbreak;\n "}, {"sha": "3b50b83ab136b043174586218250653d3e420f7a", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=556ffcc55247d9c77e0cca31a764dc56741da789", "patch": "@@ -1027,6 +1027,16 @@ register_operand (op, mode)\n \t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n }\n \n+/* Return 1 for a register in Pmode; ignore the tested mode.  */\n+\n+int\n+pmode_register_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return register_operand (op, Pmode);\n+}\n+\n /* Return 1 if OP should match a MATCH_SCRATCH, i.e., if it is a SCRATCH\n    or a hard register.  */\n "}, {"sha": "b84758cf0d6e357ca5fce7e6bb974f4f119f5ed3", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556ffcc55247d9c77e0cca31a764dc56741da789/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=556ffcc55247d9c77e0cca31a764dc56741da789", "patch": "@@ -91,6 +91,7 @@ extern rtx *find_single_use\t\tPROTO((rtx, rtx, rtx *));\n extern int general_operand\t\tPROTO((rtx, enum machine_mode));\n extern int address_operand\t\tPROTO((rtx, enum machine_mode));\n extern int register_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int pmode_register_operand\tPROTO((rtx, enum machine_mode));\n extern int scratch_operand\t\tPROTO((rtx, enum machine_mode));\n extern int immediate_operand\t\tPROTO((rtx, enum machine_mode));\n extern int const_int_operand\t\tPROTO((rtx, enum machine_mode));"}]}