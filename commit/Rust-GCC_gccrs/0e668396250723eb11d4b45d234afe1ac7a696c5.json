{"sha": "0e668396250723eb11d4b45d234afe1ac7a696c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2NjgzOTYyNTA3MjNlYjExZDRiNDVkMjM0YWZlMWFjN2E2OTZjNQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "2000-01-08T20:15:56Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-01-08T20:15:56Z"}, "message": "Fix bug restoring stack from interrupt handler.\n\nFrom-SVN: r31287", "tree": {"sha": "9e38a7bfe0b5836a99682f9bb6919f71cabbbc0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e38a7bfe0b5836a99682f9bb6919f71cabbbc0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e668396250723eb11d4b45d234afe1ac7a696c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e668396250723eb11d4b45d234afe1ac7a696c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e668396250723eb11d4b45d234afe1ac7a696c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e668396250723eb11d4b45d234afe1ac7a696c5/comments", "author": null, "committer": null, "parents": [{"sha": "69d4f56db177ddbacc02c21a6b69735fa70f7c81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d4f56db177ddbacc02c21a6b69735fa70f7c81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d4f56db177ddbacc02c21a6b69735fa70f7c81"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "f61f6eb4a49d023818aef2ed41618b4231b7a912", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e668396250723eb11d4b45d234afe1ac7a696c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e668396250723eb11d4b45d234afe1ac7a696c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e668396250723eb11d4b45d234afe1ac7a696c5", "patch": "@@ -1,3 +1,8 @@\n+Sat Jan  8 12:12:46 2000  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/v850/v850.c (expand_epilogue): Interrupt functions no\n+\tlonger allocate extra stack for function calls.\n+\n 2000-01-08  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md (*subqf3_set): Fix typo."}, {"sha": "7acd9d9aa86ae63d0d51f1fa31f255818b8a19ad", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e668396250723eb11d4b45d234afe1ac7a696c5/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e668396250723eb11d4b45d234afe1ac7a696c5/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=0e668396250723eb11d4b45d234afe1ac7a696c5", "patch": "@@ -1495,7 +1495,7 @@ expand_prologue ()\n \n   actual_fsize = compute_frame_size (size, &reg_saved);\n \n-  /* Save/setup global registers for interrupt functions right now */\n+  /* Save/setup global registers for interrupt functions right now.  */\n   if (interrupt_handler)\n     {\n \temit_insn (gen_save_interrupt ());\n@@ -1527,7 +1527,7 @@ expand_prologue ()\n \t}\n     }\n \n-  /* Identify all of the saved registers */\n+  /* Identify all of the saved registers.  */\n   num_save = 0;\n   default_stack = 0;\n   for (i = 1; i < 31; i++)\n@@ -1716,7 +1716,7 @@ expand_epilogue ()\n   if (frame_pointer_needed)\n     emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n \n-  /* Identify all of the saved registers */\n+  /* Identify all of the saved registers.  */\n   num_restore = 0;\n   default_stack = 0;\n   for (i = 1; i < 31; i++)\n@@ -1736,7 +1736,9 @@ expand_epilogue ()\n   /* See if we have an insn that restores the particular registers we\n      want to.  */\n   restore_all = NULL_RTX;\n-  if (TARGET_PROLOG_FUNCTION && num_restore > 0\n+  \n+  if (TARGET_PROLOG_FUNCTION\n+      && num_restore > 0\n       && actual_fsize >= default_stack\n       && !interrupt_handler)\n     {\n@@ -1748,7 +1750,7 @@ expand_epilogue ()\n       if (unalloc_stack)\n \trestore_func_len += CONST_OK_FOR_J (unalloc_stack) ? 2 : 4;\n \n-      /* see if we would have used ep to restore the registers */\n+      /* See if we would have used ep to restore the registers.  */\n       if (TARGET_EP && num_restore > 3 && (unsigned)actual_fsize < 255)\n \trestore_normal_len = (3 * 2) + (2 * num_restore);\n       else\n@@ -1781,6 +1783,7 @@ expand_epilogue ()\n \t    }\n \n \t  code = recog (restore_all, NULL_RTX, NULL_PTR);\n+\t  \n \t  if (code >= 0)\n \t    {\n \t      rtx insn;\n@@ -1818,7 +1821,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n     }\n \n   /* If no epilog save function is available, restore the registers the\n-     old fashioned way (one by one). */\n+     old fashioned way (one by one).  */\n   if (!restore_all)\n     {\n       /* If the stack is large, we need to cut it down in 2 pieces.  */\n@@ -1827,15 +1830,13 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n       else\n \tinit_stack_free = actual_fsize;\n \n-      /* Deallocate the rest of the stack if it is > 32K or if extra stack\n-\t was allocated for an interrupt handler that makes a call.  */\n-      if (actual_fsize > init_stack_free\n-\t  || (interrupt_handler && actual_fsize))\n+      /* Deallocate the rest of the stack if it is > 32K.  */\n+      if (actual_fsize > init_stack_free)\n \t{\n \t  int diff;\n \n \t  diff = actual_fsize - ((interrupt_handler) ? 0 : init_stack_free);\n-\t  \n+\n \t  if (CONST_OK_FOR_K (diff))\n \t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t   stack_pointer_rtx,\n@@ -1858,7 +1859,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t}\n       else\n \t{\n-\t  /* Restore registers from the beginning of the stack frame */\n+\t  /* Restore registers from the beginning of the stack frame.  */\n \t  offset = init_stack_free - 4;\n \n \t  /* Restore the return pointer first.  */\n@@ -1879,6 +1880,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t\t\t\t\t   plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t\t  offset)));\n \n+\t      emit_insn (gen_rtx_USE (VOIDmode, restore_regs[i]));\n \t      offset -= 4;\n \t    }\n "}]}