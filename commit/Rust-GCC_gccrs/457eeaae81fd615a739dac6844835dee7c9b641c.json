{"sha": "457eeaae81fd615a739dac6844835dee7c9b641c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU3ZWVhYWU4MWZkNjE1YTczOWRhYzY4NDQ4MzVkZWU3YzliNjQxYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-03-16T10:50:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-16T10:50:42Z"}, "message": "re PR debug/43051 (VTA causes a stack living parameter unavailable in most of the function)\n\n\tPR debug/43051\n\tPR debug/43092\n\t* cselib.c (cselib_preserve_constants,\n\tcfa_base_preserved_val): New static variables.\n\t(preserve_only_constants): New function.\n\t(cselib_reset_table): If cfa_base_preserved_val is non-NULL, don't\n\tclear its REG_VALUES.  If cselib_preserve_constants, don't \n\tempty the whole hash table, but preserve there VALUEs with constants,\n\tcfa_base_preserved_val and cfa_base_preserved_val plus constant.\n\t(cselib_preserve_cfa_base_value): New function.\n\t(cselib_invalidate_regno): Don't invalidate cfa_base_preserved_val.\n\t(cselib_init): Change argument to int bitfield.  Set\n\tcselib_preserve_constants to whether CSELIB_PRESERVE_CONSTANTS\n\tis in it.\n\t(cselib_finish): Clear cselib_preserve_constants and\n\tcfa_base_preserved_val.\n\t* cselib.h (enum cselib_record_what): New enum.\n\t(cselib_init): Change argument to int.\n\t(cselib_preserve_cfa_base_value): New prototype.\n\t* postreload.c (reload_cse_regs_1): Adjust cselib_init caller.\n\t* dse.c (dse_step1): Likewise.\n\t* cfgcleanup.c (thread_jump): Likewise.\n\t* sched-deps.c (sched_analyze): Likewise.\n\t* gcse.c (local_cprop_pass): Likewise.\n\t* simplify-rtx.c (simplify_replace_fn_rtx): Add argument to callback.\n\tIf FN is non-NULL, call the callback always and whenever it returns\n\tnon-NULL just return that.  Only do rtx_equal_p if FN is NULL.\n\t* rtl.h (simplify_replace_fn_rtx): Add argument to callback.\n\t* combine.c (propagate_for_debug_subst): Add old_rtx argument,\n\tcompare from with old_rtx and if it isn't rtx_equal_p, return NULL.\n\t* Makefile.in (var-tracking.o): Depend on $(RECOG_H).\n\t* var-tracking.c: Include recog.h.\n\t(bb_stack_adjust_offset): Remove.\n\t(vt_stack_adjustments): Don't call it, instead just gather the\n\tadjustments using insn_stack_adjust_offset_pre_post on each bb insn.\n\t(adjust_stack_reference): Remove.\n\t(compute_cfa_pointer): New function.\n\t(hard_frame_pointer_adjustment, cfa_base_rtx): New static variables.\n\t(struct adjust_mem_data): New type.\n\t(adjust_mems, adjust_mem_uses, adjust_mem_stores, adjust_insn): New\n\tfunctions.\n\t(get_address_mode): New function.\n\t(replace_expr_with_values): Use it.\n\t(use_type): Don't do cselib_lookup for VAR_LOC_UNKNOWN_P.\n\tUse get_address_mode.  For cfa_base_rtx return MO_CLOBBER.\n\t(adjust_sets): Remove.\n\t(add_uses): Don't add extra MO_VAL_USE for cfa_base_rtx plus constant.\n\tUse get_address_mode.\n\t(get_adjusted_src): Remove.\n\t(add_stores): Don't call it.  Never reuse expr SET.  Don't add extra\n\tMO_VAL_USE for cfa_base_rtx plus constant.  Use get_address_mode.\n\t(add_with_sets): Don't call adjust_sets.\n\t(fp_setter, vt_init_cfa_base): New functions.\n\t(vt_initialize): Change return type to bool.  Move most of pool etc.\n\tinitialization to the beginning of the function from end.  Pass\n\tCSELIB_RECORD_MEMORY | CSELIB_PRESERVE_CONSTANTS to cselib_init.\n\tIf !frame_pointer_needed, call vt_stack_adjustment before mos\n\tvector is filled, call vt_init_cfa_base if argp/framep has been\n\teliminated to sp.  If frame_pointer_needed and argp/framep has\n\tbeen eliminated to hard frame pointer, set\n\thard_frame_pointer_adjustment and call vt_init_cfa_base after\n\tencountering fp setter in the prologue.  For MO_ADJUST, call\n\tlog_op_type before pusing the op into mos vector, not afterwards.\n\tCall adjust_insn before cselib_process_insn/add_with_sets,\n\tcall cancel_changes (0) afterwards.\n\t(variable_tracking_main_1): Adjust for vt_initialize calling\n\tvt_stack_adjustments and returning whether it succeeded or not.\n\n\t* gcc.dg/guality/pr43051-1.c: New test.\n\nFrom-SVN: r157476", "tree": {"sha": "597667654769fc455fccebf8f723c1871062cb36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/597667654769fc455fccebf8f723c1871062cb36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/457eeaae81fd615a739dac6844835dee7c9b641c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457eeaae81fd615a739dac6844835dee7c9b641c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457eeaae81fd615a739dac6844835dee7c9b641c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457eeaae81fd615a739dac6844835dee7c9b641c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31b2eb0f1effc6d7ea72c75bdf19f9fb416e77e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31b2eb0f1effc6d7ea72c75bdf19f9fb416e77e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31b2eb0f1effc6d7ea72c75bdf19f9fb416e77e3"}], "stats": {"total": 925, "additions": 710, "deletions": 215}, "files": [{"sha": "f35a7a7b6bfb8eae68bdbeeb1975d55a2230e455", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,3 +1,73 @@\n+2010-03-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43051\n+\tPR debug/43092\n+\t* cselib.c (cselib_preserve_constants,\n+\tcfa_base_preserved_val): New static variables.\n+\t(preserve_only_constants): New function.\n+\t(cselib_reset_table): If cfa_base_preserved_val is non-NULL, don't\n+\tclear its REG_VALUES.  If cselib_preserve_constants, don't \n+\tempty the whole hash table, but preserve there VALUEs with constants,\n+\tcfa_base_preserved_val and cfa_base_preserved_val plus constant.\n+\t(cselib_preserve_cfa_base_value): New function.\n+\t(cselib_invalidate_regno): Don't invalidate cfa_base_preserved_val.\n+\t(cselib_init): Change argument to int bitfield.  Set\n+\tcselib_preserve_constants to whether CSELIB_PRESERVE_CONSTANTS\n+\tis in it.\n+\t(cselib_finish): Clear cselib_preserve_constants and\n+\tcfa_base_preserved_val.\n+\t* cselib.h (enum cselib_record_what): New enum.\n+\t(cselib_init): Change argument to int.\n+\t(cselib_preserve_cfa_base_value): New prototype.\n+\t* postreload.c (reload_cse_regs_1): Adjust cselib_init caller.\n+\t* dse.c (dse_step1): Likewise.\n+\t* cfgcleanup.c (thread_jump): Likewise.\n+\t* sched-deps.c (sched_analyze): Likewise.\n+\t* gcse.c (local_cprop_pass): Likewise.\n+\t* simplify-rtx.c (simplify_replace_fn_rtx): Add argument to callback.\n+\tIf FN is non-NULL, call the callback always and whenever it returns\n+\tnon-NULL just return that.  Only do rtx_equal_p if FN is NULL.\n+\t* rtl.h (simplify_replace_fn_rtx): Add argument to callback.\n+\t* combine.c (propagate_for_debug_subst): Add old_rtx argument,\n+\tcompare from with old_rtx and if it isn't rtx_equal_p, return NULL.\n+\t* Makefile.in (var-tracking.o): Depend on $(RECOG_H).\n+\t* var-tracking.c: Include recog.h.\n+\t(bb_stack_adjust_offset): Remove.\n+\t(vt_stack_adjustments): Don't call it, instead just gather the\n+\tadjustments using insn_stack_adjust_offset_pre_post on each bb insn.\n+\t(adjust_stack_reference): Remove.\n+\t(compute_cfa_pointer): New function.\n+\t(hard_frame_pointer_adjustment, cfa_base_rtx): New static variables.\n+\t(struct adjust_mem_data): New type.\n+\t(adjust_mems, adjust_mem_uses, adjust_mem_stores, adjust_insn): New\n+\tfunctions.\n+\t(get_address_mode): New function.\n+\t(replace_expr_with_values): Use it.\n+\t(use_type): Don't do cselib_lookup for VAR_LOC_UNKNOWN_P.\n+\tUse get_address_mode.  For cfa_base_rtx return MO_CLOBBER.\n+\t(adjust_sets): Remove.\n+\t(add_uses): Don't add extra MO_VAL_USE for cfa_base_rtx plus constant.\n+\tUse get_address_mode.\n+\t(get_adjusted_src): Remove.\n+\t(add_stores): Don't call it.  Never reuse expr SET.  Don't add extra\n+\tMO_VAL_USE for cfa_base_rtx plus constant.  Use get_address_mode.\n+\t(add_with_sets): Don't call adjust_sets.\n+\t(fp_setter, vt_init_cfa_base): New functions.\n+\t(vt_initialize): Change return type to bool.  Move most of pool etc.\n+\tinitialization to the beginning of the function from end.  Pass\n+\tCSELIB_RECORD_MEMORY | CSELIB_PRESERVE_CONSTANTS to cselib_init.\n+\tIf !frame_pointer_needed, call vt_stack_adjustment before mos\n+\tvector is filled, call vt_init_cfa_base if argp/framep has been\n+\teliminated to sp.  If frame_pointer_needed and argp/framep has\n+\tbeen eliminated to hard frame pointer, set\n+\thard_frame_pointer_adjustment and call vt_init_cfa_base after\n+\tencountering fp setter in the prologue.  For MO_ADJUST, call\n+\tlog_op_type before pusing the op into mos vector, not afterwards.\n+\tCall adjust_insn before cselib_process_insn/add_with_sets,\n+\tcall cancel_changes (0) afterwards.\n+\t(variable_tracking_main_1): Adjust for vt_initialize calling\n+\tvt_stack_adjustments and returning whether it succeeded or not.\n+\n 2010-03-15  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* graphite-sese-to-poly.c (rewrite_cross_bb_scalar_deps): Skip"}, {"sha": "448050576e58376d769e4d6e05c8cb1233e4d74f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -3032,7 +3032,8 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n    $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n-   cselib.h $(TARGET_H) $(TOPLEV_H) $(PARAMS_H) $(DIAGNOSTIC_H) pointer-set.h\n+   cselib.h $(TARGET_H) $(TOPLEV_H) $(PARAMS_H) $(DIAGNOSTIC_H) pointer-set.h \\\n+   $(RECOG_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) \\\n    $(TOPLEV_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\"}, {"sha": "01b165a701a65c2fd8bb39b5d07b1fec54e30dda", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,6 +1,6 @@\n /* Control flow optimization code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -337,7 +337,7 @@ thread_jump (edge e, basic_block b)\n \treturn NULL;\n       }\n \n-  cselib_init (false);\n+  cselib_init (0);\n \n   /* First process all values computed in the source basic block.  */\n   for (insn = NEXT_INSN (BB_HEAD (e->src));"}, {"sha": "f4f2fa06fdb28b54712a5ad2efb2057032e4590f", "filename": "gcc/combine.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,6 +1,6 @@\n /* Optimize by combining instructions for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -2286,10 +2286,12 @@ struct rtx_subst_pair\n    substituted.  */\n \n static rtx\n-propagate_for_debug_subst (rtx from ATTRIBUTE_UNUSED, void *data)\n+propagate_for_debug_subst (rtx from, const_rtx old_rtx, void *data)\n {\n   struct rtx_subst_pair *pair = (struct rtx_subst_pair *)data;\n \n+  if (!rtx_equal_p (from, old_rtx))\n+    return NULL_RTX;\n   if (!pair->adjusted)\n     {\n       pair->adjusted = true;"}, {"sha": "9073b9928beb26705f15d9b4abb56d81c5e7ae9a", "filename": "gcc/cselib.c", "status": "modified", "additions": 81, "deletions": 9, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n \n static bool cselib_record_memory;\n+static bool cselib_preserve_constants;\n static int entry_and_rtx_equal_p (const void *, const void *);\n static hashval_t get_value_hash (const void *);\n static struct elt_list *new_elt_list (struct elt_list *, cselib_val *);\n@@ -135,6 +136,11 @@ static int values_became_useless;\n    presence in the list by checking the next pointer.  */\n static cselib_val dummy_val;\n \n+/* If non-NULL, value of the eliminated arg_pointer_rtx or frame_pointer_rtx\n+   that is constant through the whole function and should never be\n+   eliminated.  */\n+static cselib_val *cfa_base_preserved_val;\n+\n /* Used to list all values that contain memory reference.\n    May or may not contain the useless values - the list is compacted\n    each time memory is invalidated.  */\n@@ -229,6 +235,35 @@ cselib_clear_table (void)\n   cselib_reset_table (1);\n }\n \n+/* Remove from hash table all VALUEs except constants.  */\n+\n+static int\n+preserve_only_constants (void **x, void *info ATTRIBUTE_UNUSED)\n+{\n+  cselib_val *v = (cselib_val *)*x;\n+\n+  if (v->locs != NULL\n+      && v->locs->next == NULL)\n+    {\n+      if (CONSTANT_P (v->locs->loc)\n+\t  && (GET_CODE (v->locs->loc) != CONST\n+\t      || !references_value_p (v->locs->loc, 0)))\n+\treturn 1;\n+      if (cfa_base_preserved_val)\n+\t{\n+\t  if (v == cfa_base_preserved_val)\n+\t    return 1;\n+\t  if (GET_CODE (v->locs->loc) == PLUS\n+\t      && CONST_INT_P (XEXP (v->locs->loc, 1))\n+\t      && XEXP (v->locs->loc, 0) == cfa_base_preserved_val->val_rtx)\n+\t    return 1;\n+\t}\n+    }\n+\n+  htab_clear_slot (cselib_hash_table, x);\n+  return 1;\n+}\n+\n /* Remove all entries from the hash table, arranging for the next\n    value to be numbered NUM.  */\n \n@@ -237,15 +272,37 @@ cselib_reset_table (unsigned int num)\n {\n   unsigned int i;\n \n-  for (i = 0; i < n_used_regs; i++)\n-    REG_VALUES (used_regs[i]) = 0;\n-\n   max_value_regs = 0;\n \n-  n_used_regs = 0;\n+  if (cfa_base_preserved_val)\n+    {\n+      unsigned int regno = REGNO (cfa_base_preserved_val->locs->loc);\n+      unsigned int new_used_regs = 0;\n+      for (i = 0; i < n_used_regs; i++)\n+\tif (used_regs[i] == regno)\n+\t  {\n+\t    new_used_regs = 1;\n+\t    continue;\n+\t  }\n+\telse\n+\t  REG_VALUES (used_regs[i]) = 0;\n+      gcc_assert (new_used_regs == 1);\n+      n_used_regs = new_used_regs;\n+      used_regs[0] = regno;\n+      max_value_regs\n+\t= hard_regno_nregs[regno][GET_MODE (cfa_base_preserved_val->locs->loc)];\n+    }\n+  else\n+    {\n+      for (i = 0; i < n_used_regs; i++)\n+\tREG_VALUES (used_regs[i]) = 0;\n+      n_used_regs = 0;\n+    }\n \n-  /* ??? Preserve constants?  */\n-  htab_empty (cselib_hash_table);\n+  if (cselib_preserve_constants)\n+    htab_traverse (cselib_hash_table, preserve_only_constants, NULL);\n+  else\n+    htab_empty (cselib_hash_table);\n \n   n_useless_values = 0;\n \n@@ -434,6 +491,18 @@ cselib_preserved_value_p (cselib_val *v)\n   return PRESERVED_VALUE_P (v->val_rtx);\n }\n \n+/* Arrange for a REG value to be assumed constant through the whole function,\n+   never invalidated and preserved across cselib_reset_table calls.  */\n+\n+void\n+cselib_preserve_cfa_base_value (cselib_val *v)\n+{\n+  if (cselib_preserve_constants\n+      && v->locs\n+      && REG_P (v->locs->loc))\n+    cfa_base_preserved_val = v;\n+}\n+\n /* Clean all non-constant expressions in the hash table, but retain\n    their values.  */\n \n@@ -1600,7 +1669,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t  if (i < FIRST_PSEUDO_REGISTER && v != NULL)\n \t    this_last = end_hard_regno (GET_MODE (v->val_rtx), i) - 1;\n \n-\t  if (this_last < regno || v == NULL)\n+\t  if (this_last < regno || v == NULL || v == cfa_base_preserved_val)\n \t    {\n \t      l = &(*l)->next;\n \t      continue;\n@@ -2018,7 +2087,7 @@ cselib_process_insn (rtx insn)\n    init_alias_analysis.  */\n \n void\n-cselib_init (bool record_memory)\n+cselib_init (int record_what)\n {\n   elt_list_pool = create_alloc_pool (\"elt_list\",\n \t\t\t\t     sizeof (struct elt_list), 10);\n@@ -2027,7 +2096,8 @@ cselib_init (bool record_memory)\n   cselib_val_pool = create_alloc_pool (\"cselib_val_list\",\n \t\t\t\t       sizeof (cselib_val), 10);\n   value_pool = create_alloc_pool (\"value\", RTX_CODE_SIZE (VALUE), 100);\n-  cselib_record_memory = record_memory;\n+  cselib_record_memory = record_what & CSELIB_RECORD_MEMORY;\n+  cselib_preserve_constants = record_what & CSELIB_PRESERVE_CONSTANTS;\n \n   /* (mem:BLK (scratch)) is a special mechanism to conflict with everything,\n      see canon_true_dependence.  This is only created once.  */\n@@ -2061,6 +2131,8 @@ void\n cselib_finish (void)\n {\n   cselib_discard_hook = NULL;\n+  cselib_preserve_constants = false;\n+  cfa_base_preserved_val = NULL;\n   free_alloc_pool (elt_list_pool);\n   free_alloc_pool (elt_loc_list_pool);\n   free_alloc_pool (cselib_val_pool);"}, {"sha": "015d628bf9e0ab3a59f87987a093bbf94c33f65c", "filename": "gcc/cselib.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -66,12 +66,18 @@ struct cselib_set\n   cselib_val *dest_addr_elt;\n };\n \n+enum cselib_record_what\n+{\n+  CSELIB_RECORD_MEMORY = 1,\n+  CSELIB_PRESERVE_CONSTANTS = 2\n+};\n+\n extern void (*cselib_discard_hook) (cselib_val *);\n extern void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,\n \t\t\t\t\tint n_sets);\n \n extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n-extern void cselib_init (bool record_memory);\n+extern void cselib_init (int);\n extern void cselib_clear_table (void);\n extern void cselib_finish (void);\n extern void cselib_process_insn (rtx);\n@@ -92,5 +98,6 @@ extern unsigned int cselib_get_next_uid (void);\n extern void cselib_preserve_value (cselib_val *);\n extern bool cselib_preserved_value_p (cselib_val *);\n extern void cselib_preserve_only_values (void);\n+extern void cselib_preserve_cfa_base_value (cselib_val *);\n \n extern void dump_cselib_table (FILE *);"}, {"sha": "2be8a942c75fe3749bdc7007aae4fb08395beaa0", "filename": "gcc/dse.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,5 +1,6 @@\n /* RTL dead store elimination.\n-   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n \n    Contributed by Richard Sandiford <rsandifor@codesourcery.com>\n    and Kenneth Zadeck <zadeck@naturalbridge.com>\n@@ -2616,7 +2617,7 @@ dse_step1 (void)\n   basic_block bb;\n   bitmap regs_live = BITMAP_ALLOC (NULL);\n \n-  cselib_init (false);\n+  cselib_init (0);\n   all_blocks = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (all_blocks, ENTRY_BLOCK);\n   bitmap_set_bit (all_blocks, EXIT_BLOCK);"}, {"sha": "8e31ee11a589cfe5e39262ffd34db6f2064aa2b6", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,7 +1,7 @@\n /* Global common subexpression elimination/Partial redundancy elimination\n    and global constant/copy propagation for GNU compiler.\n    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2724,7 +2724,7 @@ local_cprop_pass (void)\n   struct reg_use *reg_used;\n   bool changed = false;\n \n-  cselib_init (false);\n+  cselib_init (0);\n   FOR_EACH_BB (bb)\n     {\n       FOR_BB_INSNS (bb, insn)"}, {"sha": "8b622a7365a38740263cd1f7c30eaf31404bad3f", "filename": "gcc/postreload.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,7 +1,7 @@\n /* Perform simple optimizations to clean up the result of reload.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n-   Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -198,7 +198,7 @@ reload_cse_regs_1 (rtx first)\n   rtx insn;\n   rtx testreg = gen_rtx_REG (VOIDmode, -1);\n \n-  cselib_init (true);\n+  cselib_init (CSELIB_RECORD_MEMORY);\n   init_alias_analysis ();\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))"}, {"sha": "b8563b33d16fd6b1e735baf2802e8da956f0a740", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1778,7 +1778,7 @@ extern rtx simplify_subreg (enum machine_mode, rtx, enum machine_mode,\n extern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t\tunsigned int);\n extern rtx simplify_replace_fn_rtx (rtx, const_rtx,\n-\t\t\t\t    rtx (*fn) (rtx, void *), void *);\n+\t\t\t\t    rtx (*fn) (rtx, const_rtx, void *), void *);\n extern rtx simplify_replace_rtx (rtx, const_rtx, rtx);\n extern rtx simplify_rtx (const_rtx);\n extern rtx avoid_constant_pool_reference (rtx);"}, {"sha": "40ebc5654defa84dbea039b6cd3b5dd0d5e25eeb", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,7 +1,7 @@\n /* Instruction scheduling pass.  This file computes dependencies between\n    instructions.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n@@ -3383,7 +3383,7 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n   rtx insn;\n \n   if (sched_deps_info->use_cselib)\n-    cselib_init (true);\n+    cselib_init (CSELIB_RECORD_MEMORY);\n \n   deps_start_bb (deps, head);\n "}, {"sha": "d189d7066f21ebd3aaf33159994e850ae3178807", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -350,15 +350,14 @@ simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n-/* Replace all occurrences of OLD_RTX in X with FN (X', DATA), where X'\n-   is an expression in X that is equal to OLD_RTX.  Canonicalize and\n-   simplify the result.\n-\n-   If FN is null, assume FN (X', DATA) == copy_rtx (DATA).  */\n+/* If FN is NULL, replace all occurrences of OLD_RTX in X with copy_rtx (DATA)\n+   and simplify the result.  If FN is non-NULL, call this callback on each\n+   X, if it returns non-NULL, replace X with its return value and simplify the\n+   result.  */\n \n rtx\n simplify_replace_fn_rtx (rtx x, const_rtx old_rtx,\n-\t\t\t rtx (*fn) (rtx, void *), void *data)\n+\t\t\t rtx (*fn) (rtx, const_rtx, void *), void *data)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -368,17 +367,14 @@ simplify_replace_fn_rtx (rtx x, const_rtx old_rtx,\n   rtvec vec, newvec;\n   int i, j;\n \n-  /* If X is OLD_RTX, return FN (X, DATA), with a null FN.  Otherwise,\n-     if this is an expression, try to build a new expression, substituting\n-     recursively.  If we can't do anything, return our input.  */\n-\n-  if (rtx_equal_p (x, old_rtx))\n+  if (__builtin_expect (fn != NULL, 0))\n     {\n-      if (fn)\n-\treturn fn (x, data);\n-      else\n-\treturn copy_rtx ((rtx) data);\n+      newx = fn (x, old_rtx, data);\n+      if (newx)\n+\treturn newx;\n     }\n+  else if (rtx_equal_p (x, old_rtx))\n+    return copy_rtx ((rtx) data);\n \n   switch (GET_RTX_CLASS (code))\n     {"}, {"sha": "dfe0246adb9b119deac745ec3ad9f6e255f11f98", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -1,3 +1,8 @@\n+2010-03-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43051\n+\t* gcc.dg/guality/pr43051-1.c: New test.\n+\n 2010-03-15  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR testsuite/43363"}, {"sha": "77325c97e268658d842c849f180fb37edb3f096d", "filename": "gcc/testsuite/gcc.dg/guality/pr43051-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43051-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43051-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43051-1.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -0,0 +1,57 @@\n+/* PR debug/43051 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+extern void abort (void);\n+\n+static void __attribute__ ((noinline))\n+foo (const char *x, long long y, int z)\n+{\n+  asm volatile (\"\" : : \"r\" (x), \"r\" ((int) y), \"r\" (z) : \"memory\");\n+}\n+\n+struct S\n+{\n+  struct S *n;\n+  int v;\n+};\n+\n+struct S a[10];\n+\n+struct S * __attribute__ ((noinline))\n+bar (struct S *c, int v, struct S *e)\n+{\n+#ifdef __i386__\n+  register int si asm (\"esi\"), di asm (\"edi\"), bx\n+# if !defined (__pic__) && !defined (__APPLE__)\n+    asm (\"ebx\")\n+# endif\n+    ;\n+  asm volatile (\"\" : \"=r\" (si), \"=r\" (di), \"=r\" (bx));\n+#endif\n+  while (c < e)\n+    {\n+      foo (\"c\", (__UINTPTR_TYPE__) c, 0);\t/* { dg-final { gdb-test 34 \"c\" \"\\&a\\[0\\]\" } } */\n+      foo (\"v\", v, 1);\t\t\t\t/* { dg-final { gdb-test 35 \"v\" \"1\" } } */\n+      foo (\"e\", (__UINTPTR_TYPE__) e, 2);\t/* { dg-final { gdb-test 36 \"e\" \"\\&a\\[1\\]\" } } */\n+      if (c->v == v)\n+\treturn c;\n+      foo (\"c\", (__UINTPTR_TYPE__) c, 3);\t/* { dg-final { gdb-test 39 \"c\" \"\\&a\\[0\\]\" } } */\n+      foo (\"v\", v, 4);\t\t\t\t/* { dg-final { gdb-test 40 \"v\" \"1\" } } */\n+      foo (\"e\", (__UINTPTR_TYPE__) e, 5);\t/* { dg-final { gdb-test 41 \"e\" \"\\&a\\[1\\]\" } } */\n+      c++;\n+    }\n+#ifdef __i386__\n+  asm volatile (\"\" : : \"r\" (si), \"r\" (di), \"r\" (bx));\n+#endif\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  asm volatile (\"\" : : \"r\" (&a[0]) : \"memory\");\n+  if (bar (&a[a[0].v], a[0].v + 1, &a[a[0].v + 1]))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "362a881517482268bac8a6c6dcd631ad48a890c2", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 459, "deletions": 175, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457eeaae81fd615a739dac6844835dee7c9b641c/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=457eeaae81fd615a739dac6844835dee7c9b641c", "patch": "@@ -113,6 +113,7 @@\n #include \"params.h\"\n #include \"diagnostic.h\"\n #include \"pointer-set.h\"\n+#include \"recog.h\"\n \n /* var-tracking.c assumes that tree code with the same value as VALUE rtx code\n    has no chance to appear in REG_EXPR/MEM_EXPRs and isn't a decl.\n@@ -405,9 +406,8 @@ static void stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n \t\t\t\t\t  HOST_WIDE_INT *);\n static void insn_stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n \t\t\t\t\t       HOST_WIDE_INT *);\n-static void bb_stack_adjust_offset (basic_block);\n static bool vt_stack_adjustments (void);\n-static rtx adjust_stack_reference (rtx, HOST_WIDE_INT);\n+static rtx compute_cfa_pointer (HOST_WIDE_INT);\n static hashval_t variable_htab_hash (const void *);\n static int variable_htab_eq (const void *, const void *);\n static void variable_htab_free (void *);\n@@ -490,7 +490,7 @@ static void vt_emit_notes (void);\n \n static bool vt_get_decl_and_offset (rtx, tree *, HOST_WIDE_INT *);\n static void vt_add_function_parameters (void);\n-static void vt_initialize (void);\n+static bool vt_initialize (void);\n static void vt_finalize (void);\n \n /* Given a SET, calculate the amount of stack adjustment it contains\n@@ -617,29 +617,6 @@ insn_stack_adjust_offset_pre_post (rtx insn, HOST_WIDE_INT *pre,\n     }\n }\n \n-/* Compute stack adjustment in basic block BB.  */\n-\n-static void\n-bb_stack_adjust_offset (basic_block bb)\n-{\n-  HOST_WIDE_INT offset;\n-  unsigned int i;\n-  micro_operation *mo;\n-\n-  offset = VTI (bb)->in.stack_adjust;\n-  for (i = 0; VEC_iterate (micro_operation, VTI (bb)->mos, i, mo); i++)\n-    {\n-      if (mo->type == MO_ADJUST)\n-\toffset += mo->u.adjust;\n-      else if (mo->type != MO_CALL)\n-\t{\n-\t  if (MEM_P (mo->u.loc))\n-\t    mo->u.loc = adjust_stack_reference (mo->u.loc, -offset);\n-\t}\n-    }\n-  VTI (bb)->out.stack_adjust = offset;\n-}\n-\n /* Compute stack adjustments for all blocks by traversing DFS tree.\n    Return true when the adjustments on all incoming edges are consistent.\n    Heavily borrowed from pre_and_rev_post_order_compute.  */\n@@ -652,6 +629,7 @@ vt_stack_adjustments (void)\n \n   /* Initialize entry block.  */\n   VTI (ENTRY_BLOCK_PTR)->visited = true;\n+  VTI (ENTRY_BLOCK_PTR)->in.stack_adjust = INCOMING_FRAME_SP_OFFSET;\n   VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = INCOMING_FRAME_SP_OFFSET;\n \n   /* Allocate stack for back-tracking up CFG.  */\n@@ -675,9 +653,22 @@ vt_stack_adjustments (void)\n       /* Check if the edge destination has been visited yet.  */\n       if (!VTI (dest)->visited)\n \t{\n+\t  rtx insn;\n+\t  HOST_WIDE_INT pre, post, offset;\n \t  VTI (dest)->visited = true;\n-\t  VTI (dest)->in.stack_adjust = VTI (src)->out.stack_adjust;\n-\t  bb_stack_adjust_offset (dest);\n+\t  VTI (dest)->in.stack_adjust = offset = VTI (src)->out.stack_adjust;\n+\n+\t  if (dest != EXIT_BLOCK_PTR)\n+\t    for (insn = BB_HEAD (dest);\n+\t\t insn != NEXT_INSN (BB_END (dest));\n+\t\t insn = NEXT_INSN (insn))\n+\t      if (INSN_P (insn))\n+\t\t{\n+\t\t  insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n+\t\t  offset += pre + post;\n+\t\t}\n+\n+\t  VTI (dest)->out.stack_adjust = offset;\n \n \t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n@@ -706,13 +697,12 @@ vt_stack_adjustments (void)\n   return true;\n }\n \n-/* Adjust stack reference MEM by ADJUSTMENT bytes and make it relative\n-   to the argument pointer.  Return the new rtx.  */\n+/* Compute a CFA-based value for the stack pointer.  */\n \n static rtx\n-adjust_stack_reference (rtx mem, HOST_WIDE_INT adjustment)\n+compute_cfa_pointer (HOST_WIDE_INT adjustment)\n {\n-  rtx addr, cfa, tmp;\n+  rtx cfa;\n \n #ifdef FRAME_POINTER_CFA_OFFSET\n   adjustment -= FRAME_POINTER_CFA_OFFSET (current_function_decl);\n@@ -722,12 +712,216 @@ adjust_stack_reference (rtx mem, HOST_WIDE_INT adjustment)\n   cfa = plus_constant (arg_pointer_rtx, adjustment);\n #endif\n \n-  addr = replace_rtx (copy_rtx (XEXP (mem, 0)), stack_pointer_rtx, cfa);\n-  tmp = simplify_rtx (addr);\n-  if (tmp)\n-    addr = tmp;\n+  return cfa;\n+}\n+\n+/* Adjustment for hard_frame_pointer_rtx to cfa base reg,\n+   or -1 if the replacement shouldn't be done.  */\n+static HOST_WIDE_INT hard_frame_pointer_adjustment = -1;\n+\n+/* Data for adjust_mems callback.  */\n+\n+struct adjust_mem_data\n+{\n+  bool store;\n+  enum machine_mode mem_mode;\n+  HOST_WIDE_INT stack_adjust;\n+  rtx side_effects;\n+};\n+\n+/* Helper function for adjusting used MEMs.  */\n+\n+static rtx\n+adjust_mems (rtx loc, const_rtx old_rtx, void *data)\n+{\n+  struct adjust_mem_data *amd = (struct adjust_mem_data *) data;\n+  rtx mem, addr = loc, tem;\n+  enum machine_mode mem_mode_save;\n+  bool store_save;\n+  switch (GET_CODE (loc))\n+    {\n+    case REG:\n+      /* Don't do any sp or fp replacements outside of MEM addresses.  */\n+      if (amd->mem_mode == VOIDmode)\n+\treturn loc;\n+      if (loc == stack_pointer_rtx\n+\t  && !frame_pointer_needed)\n+\treturn compute_cfa_pointer (amd->stack_adjust);\n+      else if (loc == hard_frame_pointer_rtx\n+\t       && frame_pointer_needed\n+\t       && hard_frame_pointer_adjustment != -1)\n+\treturn compute_cfa_pointer (hard_frame_pointer_adjustment);\n+      return loc;\n+    case MEM:\n+      mem = loc;\n+      if (!amd->store)\n+\t{\n+\t  mem = targetm.delegitimize_address (mem);\n+\t  if (mem != loc && !MEM_P (mem))\n+\t    return simplify_replace_fn_rtx (mem, old_rtx, adjust_mems, data);\n+\t}\n+\n+      addr = XEXP (mem, 0);\n+      mem_mode_save = amd->mem_mode;\n+      amd->mem_mode = GET_MODE (mem);\n+      store_save = amd->store;\n+      amd->store = false;\n+      addr = simplify_replace_fn_rtx (addr, old_rtx, adjust_mems, data);\n+      amd->store = store_save;\n+      amd->mem_mode = mem_mode_save;\n+      if (mem == loc)\n+\taddr = targetm.delegitimize_address (addr);\n+      if (addr != XEXP (mem, 0))\n+\tmem = replace_equiv_address_nv (mem, addr);\n+      if (!amd->store)\n+\tmem = avoid_constant_pool_reference (mem);\n+      return mem;\n+    case PRE_INC:\n+    case PRE_DEC:\n+      addr = gen_rtx_PLUS (GET_MODE (loc), XEXP (loc, 0),\n+\t\t\t   GEN_INT (GET_CODE (loc) == PRE_INC\n+\t\t\t\t    ? GET_MODE_SIZE (amd->mem_mode)\n+\t\t\t\t    : -GET_MODE_SIZE (amd->mem_mode)));\n+    case POST_INC:\n+    case POST_DEC:\n+      if (addr == loc)\n+\taddr = XEXP (loc, 0);\n+      gcc_assert (amd->mem_mode != VOIDmode && amd->mem_mode != BLKmode);\n+      addr = simplify_replace_fn_rtx (addr, old_rtx, adjust_mems, data);\n+      tem = gen_rtx_PLUS (GET_MODE (loc), XEXP (loc, 0),\n+\t\t\t   GEN_INT ((GET_CODE (loc) == PRE_INC\n+\t\t\t\t     || GET_CODE (loc) == POST_INC)\n+\t\t\t\t    ? GET_MODE_SIZE (amd->mem_mode)\n+\t\t\t\t    : -GET_MODE_SIZE (amd->mem_mode)));\n+      amd->side_effects = alloc_EXPR_LIST (0,\n+\t\t\t\t\t   gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\t\tXEXP (loc, 0),\n+\t\t\t\t\t\t\ttem),\n+\t\t\t\t\t   amd->side_effects);\n+      return addr;\n+    case PRE_MODIFY:\n+      addr = XEXP (loc, 1);\n+    case POST_MODIFY:\n+      if (addr == loc)\n+\taddr = XEXP (loc, 0);\n+      gcc_assert (amd->mem_mode != VOIDmode && amd->mem_mode != BLKmode);\n+      addr = simplify_replace_fn_rtx (addr, old_rtx, adjust_mems, data);\n+      amd->side_effects = alloc_EXPR_LIST (0,\n+\t\t\t\t\t   gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\t\tXEXP (loc, 0),\n+\t\t\t\t\t\t\tXEXP (loc, 1)),\n+\t\t\t\t\t   amd->side_effects);\n+      return addr;\n+    case SUBREG:\n+      /* First try without delegitimization of whole MEMs and\n+\t avoid_constant_pool_reference, which is more likely to succeed.  */\n+      store_save = amd->store;\n+      amd->store = true;\n+      addr = simplify_replace_fn_rtx (SUBREG_REG (loc), old_rtx, adjust_mems,\n+\t\t\t\t      data);\n+      amd->store = store_save;\n+      mem = simplify_replace_fn_rtx (addr, old_rtx, adjust_mems, data);\n+      if (mem == SUBREG_REG (loc))\n+\treturn loc;\n+      tem = simplify_gen_subreg (GET_MODE (loc), mem,\n+\t\t\t\t GET_MODE (SUBREG_REG (loc)),\n+\t\t\t\t SUBREG_BYTE (loc));\n+      if (tem)\n+\treturn tem;\n+      tem = simplify_gen_subreg (GET_MODE (loc), addr,\n+\t\t\t\t GET_MODE (SUBREG_REG (loc)),\n+\t\t\t\t SUBREG_BYTE (loc));\n+      if (tem)\n+\treturn tem;\n+      return gen_rtx_raw_SUBREG (GET_MODE (loc), addr, SUBREG_BYTE (loc));\n+    default:\n+      break;\n+    }\n+  return NULL_RTX;\n+}\n+\n+/* Helper function for replacement of uses.  */\n+\n+static void\n+adjust_mem_uses (rtx *x, void *data)\n+{\n+  rtx new_x = simplify_replace_fn_rtx (*x, NULL_RTX, adjust_mems, data);\n+  if (new_x != *x)\n+    validate_change (NULL_RTX, x, new_x, true);\n+}\n+\n+/* Helper function for replacement of stores.  */\n+\n+static void\n+adjust_mem_stores (rtx loc, const_rtx expr, void *data)\n+{\n+  if (MEM_P (loc))\n+    {\n+      rtx new_dest = simplify_replace_fn_rtx (SET_DEST (expr), NULL_RTX,\n+\t\t\t\t\t      adjust_mems, data);\n+      if (new_dest != SET_DEST (expr))\n+\t{\n+\t  rtx xexpr = CONST_CAST_RTX (expr);\n+\t  validate_change (NULL_RTX, &SET_DEST (xexpr), new_dest, true);\n+\t}\n+    }\n+}\n+\n+/* Simplify INSN.  Remove all {PRE,POST}_{INC,DEC,MODIFY} rtxes,\n+   replace them with their value in the insn and add the side-effects\n+   as other sets to the insn.  */\n+\n+static void\n+adjust_insn (basic_block bb, rtx insn)\n+{\n+  struct adjust_mem_data amd;\n+  rtx set;\n+  amd.mem_mode = VOIDmode;\n+  amd.stack_adjust = -VTI (bb)->out.stack_adjust;\n+  amd.side_effects = NULL_RTX;\n+\n+  amd.store = true;\n+  note_stores (PATTERN (insn), adjust_mem_stores, &amd);\n+\n+  amd.store = false;\n+  note_uses (&PATTERN (insn), adjust_mem_uses, &amd);\n+\n+  /* For read-only MEMs containing some constant, prefer those\n+     constants.  */\n+  set = single_set (insn);\n+  if (set && MEM_P (SET_SRC (set)) && MEM_READONLY_P (SET_SRC (set)))\n+    {\n+      rtx note = find_reg_equal_equiv_note (insn);\n+\n+      if (note && CONSTANT_P (XEXP (note, 0)))\n+\tvalidate_change (NULL_RTX, &SET_SRC (set), XEXP (note, 0), true);\n+    }\n+\n+  if (amd.side_effects)\n+    {\n+      rtx *pat, new_pat, s;\n+      int i, oldn, newn;\n \n-  return replace_equiv_address_nv (mem, addr);\n+      pat = &PATTERN (insn);\n+      if (GET_CODE (*pat) == COND_EXEC)\n+\tpat = &COND_EXEC_CODE (*pat);\n+      if (GET_CODE (*pat) == PARALLEL)\n+\toldn = XVECLEN (*pat, 0);\n+      else\n+\toldn = 1;\n+      for (s = amd.side_effects, newn = 0; s; newn++)\n+\ts = XEXP (s, 1);\n+      new_pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (oldn + newn));\n+      if (GET_CODE (*pat) == PARALLEL)\n+\tfor (i = 0; i < oldn; i++)\n+\t  XVECEXP (new_pat, 0, i) = XVECEXP (*pat, 0, i);\n+      else\n+\tXVECEXP (new_pat, 0, 0) = *pat;\n+      for (s = amd.side_effects, i = oldn; i < oldn + newn; i++, s = XEXP (s, 1))\n+\tXVECEXP (new_pat, 0, i) = XEXP (s, 0);\n+      free_EXPR_LIST_list (&amd.side_effects);\n+      validate_change (NULL_RTX, pat, new_pat, true);\n+    }\n }\n \n /* Return true if a decl_or_value DV is a DECL or NULL.  */\n@@ -4326,6 +4520,10 @@ var_lowpart (enum machine_mode mode, rtx loc)\n   return gen_rtx_REG_offset (loc, mode, regno, offset);\n }\n \n+/* arg_pointer_rtx resp. frame_pointer_rtx if stack_pointer_rtx or\n+   hard_frame_pointer_rtx is being mapped to it.  */\n+static rtx cfa_base_rtx;\n+\n /* Carry information about uses and stores while walking rtx.  */\n \n struct count_use_info\n@@ -4371,6 +4569,17 @@ find_use_val (rtx x, enum machine_mode mode, struct count_use_info *cui)\n   return NULL;\n }\n \n+/* Helper function to get mode of MEM's address.  */\n+\n+static inline enum machine_mode\n+get_address_mode (rtx mem)\n+{\n+  enum machine_mode mode = GET_MODE (XEXP (mem, 0));\n+  if (mode != VOIDmode)\n+    return mode;\n+  return targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+}\n+\n /* Replace all registers and addresses in an expression with VALUE\n    expressions that map back to them, unless the expression is a\n    register.  If no mapping is or can be performed, returns NULL.  */\n@@ -4382,9 +4591,8 @@ replace_expr_with_values (rtx loc)\n     return NULL;\n   else if (MEM_P (loc))\n     {\n-      enum machine_mode address_mode\n-\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (loc));\n-      cselib_val *addr = cselib_lookup (XEXP (loc, 0), address_mode, 0);\n+      cselib_val *addr = cselib_lookup (XEXP (loc, 0),\n+\t\t\t\t\tget_address_mode (loc), 0);\n       if (addr)\n \treturn replace_equiv_address_nv (loc, addr->val_rtx);\n       else\n@@ -4409,12 +4617,15 @@ use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n \t  if (track_expr_p (PAT_VAR_LOCATION_DECL (loc), false))\n \t    {\n \t      rtx ploc = PAT_VAR_LOCATION_LOC (loc);\n-\t      cselib_val *val = cselib_lookup (ploc, GET_MODE (loc), 1);\n+\t      if (! VAR_LOC_UNKNOWN_P (ploc))\n+\t\t{\n+\t\t  cselib_val *val = cselib_lookup (ploc, GET_MODE (loc), 1);\n \n-\t      /* ??? flag_float_store and volatile mems are never\n-\t\t given values, but we could in theory use them for\n-\t\t locations.  */\n-\t      gcc_assert (val || 1);\n+\t\t  /* ??? flag_float_store and volatile mems are never\n+\t\t     given values, but we could in theory use them for\n+\t\t     locations.  */\n+\t\t  gcc_assert (val || 1);\n+\t\t}\n \t      return MO_VAL_LOC;\n \t    }\n \t  else\n@@ -4429,7 +4640,8 @@ use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n \t    {\n \t      if (REG_P (loc)\n \t\t  || (find_use_val (loc, GET_MODE (loc), cui)\n-\t\t      && cselib_lookup (XEXP (loc, 0), GET_MODE (loc), 0)))\n+\t\t      && cselib_lookup (XEXP (loc, 0),\n+\t\t\t\t\tget_address_mode (loc), 0)))\n \t\treturn MO_VAL_SET;\n \t    }\n \t  else\n@@ -4446,6 +4658,8 @@ use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n     {\n       gcc_assert (REGNO (loc) < FIRST_PSEUDO_REGISTER);\n \n+      if (loc == cfa_base_rtx)\n+\treturn MO_CLOBBER;\n       expr = REG_EXPR (loc);\n \n       if (!expr)\n@@ -4490,30 +4704,6 @@ log_op_type (rtx x, basic_block bb, rtx insn,\n   fputc ('\\n', out);\n }\n \n-/* Adjust sets if needed.  Currently this optimizes read-only MEM loads\n-   if REG_EQUAL/REG_EQUIV note is present.  */\n-\n-static void\n-adjust_sets (rtx insn, struct cselib_set *sets, int n_sets)\n-{\n-  if (n_sets == 1 && MEM_P (sets[0].src) && MEM_READONLY_P (sets[0].src))\n-    {\n-      /* For read-only MEMs containing some constant, prefer those\n-\t constants.  */\n-      rtx note = find_reg_equal_equiv_note (insn), src;\n-\n-      if (note && CONSTANT_P (XEXP (note, 0)))\n-\t{\n-\t  sets[0].src = src = XEXP (note, 0);\n-\t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n-\t    src = gen_rtx_IF_THEN_ELSE (GET_MODE (sets[0].dest),\n-\t\t\t\t\tCOND_EXEC_TEST (PATTERN (insn)),\n-\t\t\t\t\tsrc, sets[0].dest);\n-\t  sets[0].src_elt = cselib_lookup (src, GET_MODE (sets[0].dest), 1);\n-\t}\n-    }\n-}\n-\n /* Tell whether the CONCAT used to holds a VALUE and its location\n    needs value resolution, i.e., an attempt of mapping the location\n    back to other incoming values.  */\n@@ -4577,11 +4767,14 @@ add_uses (rtx *ploc, void *data)\n \t  gcc_assert (cui->sets);\n \n \t  if (MEM_P (vloc)\n-\t      && !REG_P (XEXP (vloc, 0)) && !MEM_P (XEXP (vloc, 0)))\n+\t      && !REG_P (XEXP (vloc, 0))\n+\t      && !MEM_P (XEXP (vloc, 0))\n+\t      && (GET_CODE (XEXP (vloc, 0)) != PLUS\n+\t\t  || XEXP (XEXP (vloc, 0), 0) != cfa_base_rtx\n+\t\t  || !CONST_INT_P (XEXP (XEXP (vloc, 0), 1))))\n \t    {\n \t      rtx mloc = vloc;\n-\t      enum machine_mode address_mode\n-\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (mloc));\n+\t      enum machine_mode address_mode = get_address_mode (mloc);\n \t      cselib_val *val\n \t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n \n@@ -4646,11 +4839,14 @@ add_uses (rtx *ploc, void *data)\n \t  gcc_assert (cui->sets);\n \n \t  if (MEM_P (oloc)\n-\t      && !REG_P (XEXP (oloc, 0)) && !MEM_P (XEXP (oloc, 0)))\n+\t      && !REG_P (XEXP (oloc, 0))\n+\t      && !MEM_P (XEXP (oloc, 0))\n+\t      && (GET_CODE (XEXP (oloc, 0)) != PLUS\n+\t\t  || XEXP (XEXP (oloc, 0), 0) != cfa_base_rtx\n+\t\t  || !CONST_INT_P (XEXP (XEXP (oloc, 0), 1))))\n \t    {\n \t      rtx mloc = oloc;\n-\t      enum machine_mode address_mode\n-\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (mloc));\n+\t      enum machine_mode address_mode = get_address_mode (mloc);\n \t      cselib_val *val\n \t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n \n@@ -4814,21 +5010,6 @@ reverse_op (rtx val, const_rtx expr)\n   return gen_rtx_CONCAT (GET_MODE (v->val_rtx), v->val_rtx, ret);\n }\n \n-/* Return SRC, or, if it is a read-only MEM for which adjust_sets\n-   replated it with a constant from REG_EQUIV/REG_EQUAL note,\n-   that constant.  */\n-\n-static inline rtx\n-get_adjusted_src (struct count_use_info *cui, rtx src)\n-{\n-  if (cui->n_sets == 1\n-      && MEM_P (src)\n-      && MEM_READONLY_P (src)\n-      && CONSTANT_P (cui->sets[0].src))\n-    return cui->sets[0].src;\n-  return src;\n-}\n-\n /* Add stores (register and memory references) LOC which will be tracked\n    to VTI (bb)->mos.  EXPR is the RTL expression containing the store.\n    CUIP->insn is instruction which the LOC is part of.  */\n@@ -4854,6 +5035,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n   if (REG_P (loc))\n     {\n+      gcc_assert (loc != cfa_base_rtx);\n       if ((GET_CODE (expr) == CLOBBER && type != MO_VAL_SET)\n \t  || !(track_p = use_type (loc, NULL, &mode2) == MO_USE)\n \t  || GET_CODE (expr) == CLOBBER)\n@@ -4864,10 +5046,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n       else\n \t{\n \t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n-\t    {\n-\t      src = get_adjusted_src (cui, SET_SRC (expr));\n-\t      src = var_lowpart (mode2, src);\n-\t    }\n+\t    src = var_lowpart (mode2, SET_SRC (expr));\n \t  loc = var_lowpart (mode2, loc);\n \n \t  if (src == NULL)\n@@ -4877,10 +5056,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t    }\n \t  else\n \t    {\n-\t      rtx xexpr = CONST_CAST_RTX (expr);\n-\n-\t      if (SET_SRC (expr) != src)\n-\t\txexpr = gen_rtx_SET (VOIDmode, loc, src);\n+\t      rtx xexpr = gen_rtx_SET (VOIDmode, loc, src);\n \t      if (same_variable_part_p (src, REG_EXPR (loc), REG_OFFSET (loc)))\n \t\tmo.type = MO_COPY;\n \t      else\n@@ -4895,12 +5071,16 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t       || cui->sets))\n     {\n       if (MEM_P (loc) && type == MO_VAL_SET\n-\t  && !REG_P (XEXP (loc, 0)) && !MEM_P (XEXP (loc, 0)))\n+\t  && !REG_P (XEXP (loc, 0))\n+\t  && !MEM_P (XEXP (loc, 0))\n+\t  && (GET_CODE (XEXP (loc, 0)) != PLUS\n+\t      || XEXP (XEXP (loc, 0), 0) != cfa_base_rtx\n+\t      || !CONST_INT_P (XEXP (XEXP (loc, 0), 1))))\n \t{\n \t  rtx mloc = loc;\n-\t  enum machine_mode address_mode\n-\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mloc));\n-\t  cselib_val *val = cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n+\t  enum machine_mode address_mode = get_address_mode (mloc);\n+\t  cselib_val *val = cselib_lookup (XEXP (mloc, 0),\n+\t\t\t\t\t   address_mode, 0);\n \n \t  if (val && !cselib_preserved_value_p (val))\n \t    {\n@@ -4924,10 +5104,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n       else\n \t{\n \t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n-\t    {\n-\t      src = get_adjusted_src (cui, SET_SRC (expr));\n-\t      src = var_lowpart (mode2, src);\n-\t    }\n+\t    src = var_lowpart (mode2, SET_SRC (expr));\n \t  loc = var_lowpart (mode2, loc);\n \n \t  if (src == NULL)\n@@ -4937,10 +5114,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t    }\n \t  else\n \t    {\n-\t      rtx xexpr = CONST_CAST_RTX (expr);\n-\n-\t      if (SET_SRC (expr) != src)\n-\t\txexpr = gen_rtx_SET (VOIDmode, loc, src);\n+\t      rtx xexpr = gen_rtx_SET (VOIDmode, loc, src);\n \t      if (same_variable_part_p (SET_SRC (xexpr),\n \t\t\t\t\tMEM_EXPR (loc),\n \t\t\t\t\tINT_MEM_OFFSET (loc)))\n@@ -4997,13 +5171,12 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n     }\n   else if (resolve && GET_CODE (mo.u.loc) == SET)\n     {\n-      src = get_adjusted_src (cui, SET_SRC (expr));\n-      nloc = replace_expr_with_values (src);\n+      nloc = replace_expr_with_values (SET_SRC (expr));\n \n       /* Avoid the mode mismatch between oexpr and expr.  */\n       if (!nloc && mode != mode2)\n \t{\n-\t  nloc = src;\n+\t  nloc = SET_SRC (expr);\n \t  gcc_assert (oloc == SET_DEST (expr));\n \t}\n \n@@ -5102,8 +5275,6 @@ add_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n \n   cselib_hook_called = true;\n \n-  adjust_sets (insn, sets, n_sets);\n-\n   cui.insn = insn;\n   cui.bb = bb;\n   cui.sets = sets;\n@@ -6690,7 +6861,7 @@ emit_note_insn_var_location (void **varp, void *data)\n   complete = true;\n   last_limit = 0;\n   n_var_parts = 0;\n-  if (!MAY_HAVE_DEBUG_STMTS)\n+  if (!MAY_HAVE_DEBUG_INSNS)\n     {\n       for (i = 0; i < var->n_var_parts; i++)\n \tif (var->var_part[i].cur_loc == NULL && var->var_part[i].loc_chain)\n@@ -7688,19 +7859,109 @@ vt_add_function_parameters (void)\n \n }\n \n+/* Return true if INSN in the prologue initializes hard_frame_pointer_rtx.  */\n+\n+static bool\n+fp_setter (rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  if (RTX_FRAME_RELATED_P (insn))\n+    {\n+      rtx expr = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n+      if (expr)\n+\tpat = XEXP (expr, 0);\n+    }\n+  if (GET_CODE (pat) == SET)\n+    return SET_DEST (pat) == hard_frame_pointer_rtx;\n+  else if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int i;\n+      for (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n+\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET\n+\t    && SET_DEST (XVECEXP (pat, 0, i)) == hard_frame_pointer_rtx)\n+\t  return true;\n+    }\n+  return false;\n+}\n+\n+/* Initialize cfa_base_rtx, create a preserved VALUE for it and\n+   ensure it isn't flushed during cselib_reset_table.\n+   Can be called only if frame_pointer_rtx resp. arg_pointer_rtx\n+   has been eliminated.  */\n+\n+static void\n+vt_init_cfa_base (void)\n+{\n+  cselib_val *val;\n+\n+#ifdef FRAME_POINTER_CFA_OFFSET\n+  cfa_base_rtx = frame_pointer_rtx;\n+#else\n+  cfa_base_rtx = arg_pointer_rtx;\n+#endif\n+  if (!MAY_HAVE_DEBUG_INSNS)\n+    return;\n+\n+  val = cselib_lookup (cfa_base_rtx, GET_MODE (cfa_base_rtx), 1);\n+  preserve_value (val);\n+  cselib_preserve_cfa_base_value (val);\n+  val->locs->setting_insn = get_insns ();\n+  var_reg_decl_set (&VTI (ENTRY_BLOCK_PTR)->out, cfa_base_rtx,\n+\t\t    VAR_INIT_STATUS_INITIALIZED, dv_from_value (val->val_rtx),\n+\t\t    0, NULL_RTX, INSERT);\n+}\n+\n /* Allocate and initialize the data structures for variable tracking\n    and parse the RTL to get the micro operations.  */\n \n-static void\n+static bool\n vt_initialize (void)\n {\n-  basic_block bb;\n+  basic_block bb, prologue_bb = NULL;\n+  HOST_WIDE_INT fp_cfa_offset = -1;\n \n   alloc_aux_for_blocks (sizeof (struct variable_tracking_info_def));\n \n+  attrs_pool = create_alloc_pool (\"attrs_def pool\",\n+\t\t\t\t  sizeof (struct attrs_def), 1024);\n+  var_pool = create_alloc_pool (\"variable_def pool\",\n+\t\t\t\tsizeof (struct variable_def)\n+\t\t\t\t+ (MAX_VAR_PARTS - 1)\n+\t\t\t\t* sizeof (((variable)NULL)->var_part[0]), 64);\n+  loc_chain_pool = create_alloc_pool (\"location_chain_def pool\",\n+\t\t\t\t      sizeof (struct location_chain_def),\n+\t\t\t\t      1024);\n+  shared_hash_pool = create_alloc_pool (\"shared_hash_def pool\",\n+\t\t\t\t\tsizeof (struct shared_hash_def), 256);\n+  empty_shared_hash = (shared_hash) pool_alloc (shared_hash_pool);\n+  empty_shared_hash->refcount = 1;\n+  empty_shared_hash->htab\n+    = htab_create (1, variable_htab_hash, variable_htab_eq,\n+\t\t   variable_htab_free);\n+  changed_variables = htab_create (10, variable_htab_hash, variable_htab_eq,\n+\t\t\t\t   variable_htab_free);\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n-      cselib_init (true);\n+      value_chain_pool = create_alloc_pool (\"value_chain_def pool\",\n+\t\t\t\t\t    sizeof (struct value_chain_def),\n+\t\t\t\t\t    1024);\n+      value_chains = htab_create (32, value_chain_htab_hash,\n+\t\t\t\t  value_chain_htab_eq, NULL);\n+    }\n+\n+  /* Init the IN and OUT sets.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      VTI (bb)->visited = false;\n+      VTI (bb)->flooded = false;\n+      dataflow_set_init (&VTI (bb)->in);\n+      dataflow_set_init (&VTI (bb)->out);\n+      VTI (bb)->permp = NULL;\n+    }\n+\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      cselib_init (CSELIB_RECORD_MEMORY | CSELIB_PRESERVE_CONSTANTS);\n       scratch_regs = BITMAP_ALLOC (NULL);\n       valvar_pool = create_alloc_pool (\"small variable_def pool\",\n \t\t\t\t       sizeof (struct variable_def), 256);\n@@ -7712,6 +7973,55 @@ vt_initialize (void)\n       valvar_pool = NULL;\n     }\n \n+  if (!frame_pointer_needed)\n+    {\n+      rtx reg, elim;\n+\n+      if (!vt_stack_adjustments ())\n+\treturn false;\n+\n+#ifdef FRAME_POINTER_CFA_OFFSET\n+      reg = frame_pointer_rtx;\n+#else\n+      reg = arg_pointer_rtx;\n+#endif\n+      elim = eliminate_regs (reg, VOIDmode, NULL_RTX);\n+      if (elim != reg)\n+\t{\n+\t  if (GET_CODE (elim) == PLUS)\n+\t    elim = XEXP (elim, 0);\n+\t  if (elim == stack_pointer_rtx)\n+\t    vt_init_cfa_base ();\n+\t}\n+    }\n+  else if (!crtl->stack_realign_tried)\n+    {\n+      rtx reg, elim;\n+\n+#ifdef FRAME_POINTER_CFA_OFFSET\n+      reg = frame_pointer_rtx;\n+      fp_cfa_offset = FRAME_POINTER_CFA_OFFSET (current_function_decl);\n+#else\n+      reg = arg_pointer_rtx;\n+      fp_cfa_offset = ARG_POINTER_CFA_OFFSET (current_function_decl);\n+#endif\n+      elim = eliminate_regs (reg, VOIDmode, NULL_RTX);\n+      if (elim != reg)\n+\t{\n+\t  if (GET_CODE (elim) == PLUS)\n+\t    {\n+\t      fp_cfa_offset -= INTVAL (XEXP (elim, 1));\n+\t      elim = XEXP (elim, 0);\n+\t    }\n+\t  if (elim != hard_frame_pointer_rtx)\n+\t    fp_cfa_offset = -1;\n+\t  else\n+\t    prologue_bb = single_succ (ENTRY_BLOCK_PTR);\n+\t}\n+    }\n+\n+  hard_frame_pointer_adjustment = -1;\n+\n   FOR_EACH_BB (bb)\n     {\n       rtx insn;\n@@ -7743,6 +8053,8 @@ vt_initialize (void)\n       /* Add the micro-operations to the vector.  */\n       FOR_BB_BETWEEN (bb, first_bb, last_bb->next_bb, next_bb)\n \t{\n+\t  HOST_WIDE_INT offset = VTI (bb)->out.stack_adjust;\n+\t  VTI (bb)->out.stack_adjust = VTI (bb)->in.stack_adjust;\n \t  for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n \t       insn = NEXT_INSN (insn))\n \t    {\n@@ -7757,16 +8069,17 @@ vt_initialize (void)\n \t\t\t  mo.type = MO_ADJUST;\n \t\t\t  mo.u.adjust = pre;\n \t\t\t  mo.insn = insn;\n-\t\t\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n-\t\t\t\t\t &mo);\n-\n \t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t    log_op_type (PATTERN (insn), bb, insn,\n \t\t\t\t\t MO_ADJUST, dump_file);\n+\t\t\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n+\t\t\t\t\t &mo);\n+\t\t\t  VTI (bb)->out.stack_adjust += pre;\n \t\t\t}\n \t\t    }\n \n \t\t  cselib_hook_called = false;\n+\t\t  adjust_insn (bb, insn);\n \t\t  if (MAY_HAVE_DEBUG_INSNS)\n \t\t    {\n \t\t      cselib_process_insn (insn);\n@@ -7778,22 +8091,33 @@ vt_initialize (void)\n \t\t    }\n \t\t  if (!cselib_hook_called)\n \t\t    add_with_sets (insn, 0, 0);\n+\t\t  cancel_changes (0);\n \n \t\t  if (!frame_pointer_needed && post)\n \t\t    {\n \t\t      micro_operation mo;\n \t\t      mo.type = MO_ADJUST;\n \t\t      mo.u.adjust = post;\n \t\t      mo.insn = insn;\n-\t\t      VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n-\t\t\t\t     &mo);\n-\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\tlog_op_type (PATTERN (insn), bb, insn,\n \t\t\t\t     MO_ADJUST, dump_file);\n+\t\t      VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n+\t\t\t\t     &mo);\n+\t\t      VTI (bb)->out.stack_adjust += post;\n+\t\t    }\n+\n+\t\t  if (bb == prologue_bb\n+\t\t      && hard_frame_pointer_adjustment == -1\n+\t\t      && RTX_FRAME_RELATED_P (insn)\n+\t\t      && fp_setter (insn))\n+\t\t    {\n+\t\t      vt_init_cfa_base ();\n+\t\t      hard_frame_pointer_adjustment = fp_cfa_offset;\n \t\t    }\n \t\t}\n \t    }\n+\t  gcc_assert (offset == VTI (bb)->out.stack_adjust);\n \t}\n \n       bb = last_bb;\n@@ -7806,45 +8130,11 @@ vt_initialize (void)\n \t}\n     }\n \n-  attrs_pool = create_alloc_pool (\"attrs_def pool\",\n-\t\t\t\t  sizeof (struct attrs_def), 1024);\n-  var_pool = create_alloc_pool (\"variable_def pool\",\n-\t\t\t\tsizeof (struct variable_def)\n-\t\t\t\t+ (MAX_VAR_PARTS - 1)\n-\t\t\t\t* sizeof (((variable)NULL)->var_part[0]), 64);\n-  loc_chain_pool = create_alloc_pool (\"location_chain_def pool\",\n-\t\t\t\t      sizeof (struct location_chain_def),\n-\t\t\t\t      1024);\n-  shared_hash_pool = create_alloc_pool (\"shared_hash_def pool\",\n-\t\t\t\t\tsizeof (struct shared_hash_def), 256);\n-  empty_shared_hash = (shared_hash) pool_alloc (shared_hash_pool);\n-  empty_shared_hash->refcount = 1;\n-  empty_shared_hash->htab\n-    = htab_create (1, variable_htab_hash, variable_htab_eq,\n-\t\t   variable_htab_free);\n-  changed_variables = htab_create (10, variable_htab_hash, variable_htab_eq,\n-\t\t\t\t   variable_htab_free);\n-  if (MAY_HAVE_DEBUG_INSNS)\n-    {\n-      value_chain_pool = create_alloc_pool (\"value_chain_def pool\",\n-\t\t\t\t\t    sizeof (struct value_chain_def),\n-\t\t\t\t\t    1024);\n-      value_chains = htab_create (32, value_chain_htab_hash,\n-\t\t\t\t  value_chain_htab_eq, NULL);\n-    }\n-\n-  /* Init the IN and OUT sets.  */\n-  FOR_ALL_BB (bb)\n-    {\n-      VTI (bb)->visited = false;\n-      VTI (bb)->flooded = false;\n-      dataflow_set_init (&VTI (bb)->in);\n-      dataflow_set_init (&VTI (bb)->out);\n-      VTI (bb)->permp = NULL;\n-    }\n-\n+  hard_frame_pointer_adjustment = -1;\n   VTI (ENTRY_BLOCK_PTR)->flooded = true;\n   vt_add_function_parameters ();\n+  cfa_base_rtx = NULL_RTX;\n+  return true;\n }\n \n /* Get rid of all debug insns from the insn stream.  */\n@@ -7946,15 +8236,11 @@ variable_tracking_main_1 (void)\n     }\n \n   mark_dfs_back_edges ();\n-  vt_initialize ();\n-  if (!frame_pointer_needed)\n+  if (!vt_initialize ())\n     {\n-      if (!vt_stack_adjustments ())\n-\t{\n-\t  vt_finalize ();\n-\t  vt_debug_insns_local (true);\n-\t  return 0;\n-\t}\n+      vt_finalize ();\n+      vt_debug_insns_local (true);\n+      return 0;\n     }\n \n   success = vt_find_locations ();\n@@ -7968,10 +8254,8 @@ variable_tracking_main_1 (void)\n       /* This is later restored by our caller.  */\n       flag_var_tracking_assignments = 0;\n \n-      vt_initialize ();\n-\n-      if (!frame_pointer_needed && !vt_stack_adjustments ())\n-\tgcc_unreachable ();\n+      success = vt_initialize ();\n+      gcc_assert (success);\n \n       success = vt_find_locations ();\n     }"}]}