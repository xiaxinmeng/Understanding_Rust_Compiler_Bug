{"sha": "40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiZDRiZjk1ZTY4ZTI1MmFmZGY4NjNmMWMzZDVmMjJlMzBmODE5ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-05-12T08:30:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-05-12T08:30:25Z"}, "message": "constraints.md (Yv): New constraint.\n\n\t* config/i386/constraints.md (Yv): New constraint.\n\t* config/i386/i386.h (VALID_AVX512VL_128_REG_MODE): Allow\n\tTFmode and V1TImode in xmm16+ registers for TARGET_AVX512VL.\n\t* config/i386/i386.md (avx512fvecmode): New mode attr.\n\t(*pushtf): Use v constraint instead of x.\n\t(*movtf_internal): Likewise.  For TARGET_AVX512VL and\n\txmm16+ registers, use vmovdqu64 or vmovdqa64 instructions.\n\t(*absneg<mode>2): Use Yv constraint instead of x constraint.\n\t(*absnegtf2_sse): Likewise.\n\t(copysign<mode>3_const, copysign<mode>3_var): Likewise.\n\t* config/i386/sse.md (*andnot<mode>3): Add avx512vl and\n\tavx512f alternatives.\n\t(*andnottf3, *<code><mode>3, *<code>tf3): Likewise.\n\n\t* gcc.target/i386/avx512dq-abs-copysign-1.c: New test.\n\t* gcc.target/i386/avx512vl-abs-copysign-1.c: New test.\n\t* gcc.target/i386/avx512vl-abs-copysign-2.c: New test.\n\nFrom-SVN: r236161", "tree": {"sha": "8f4584bb4783a5fd7ed9dd04545b2e2aabd63dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f4584bb4783a5fd7ed9dd04545b2e2aabd63dd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb09cdcb1a8b55b9c9257119053b0f6f7b24edd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb09cdcb1a8b55b9c9257119053b0f6f7b24edd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb09cdcb1a8b55b9c9257119053b0f6f7b24edd9"}], "stats": {"total": 391, "additions": 346, "deletions": 45}, "files": [{"sha": "b053bfd717e5b1050c251be7871db24e1d0fc99e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -1,3 +1,19 @@\n+2016-05-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/i386/constraints.md (Yv): New constraint.\n+\t* config/i386/i386.h (VALID_AVX512VL_128_REG_MODE): Allow\n+\tTFmode and V1TImode in xmm16+ registers for TARGET_AVX512VL.\n+\t* config/i386/i386.md (avx512fvecmode): New mode attr.\n+\t(*pushtf): Use v constraint instead of x.\n+\t(*movtf_internal): Likewise.  For TARGET_AVX512VL and\n+\txmm16+ registers, use vmovdqu64 or vmovdqa64 instructions.\n+\t(*absneg<mode>2): Use Yv constraint instead of x constraint.\n+\t(*absnegtf2_sse): Likewise.\n+\t(copysign<mode>3_const, copysign<mode>3_var): Likewise.\n+\t* config/i386/sse.md (*andnot<mode>3): Add avx512vl and\n+\tavx512f alternatives.\n+\t(*andnottf3, *<code><mode>3, *<code>tf3): Likewise.\n+\n 2016-05-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71060"}, {"sha": "44f2d33fc423ce0dfb94d9b058e7cfd16d1985ca", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -145,6 +145,10 @@\n  \"TARGET_SSE ? (X86_TUNE_AVOID_4BYTE_PREFIXES ? NO_REX_SSE_REGS : ALL_SSE_REGS) : NO_REGS\"\n  \"@internal Lower SSE register when avoiding REX prefix and all SSE registers otherwise.\")\n \n+(define_register_constraint \"Yv\"\n+ \"TARGET_AVX512VL ? ALL_SSE_REGS : TARGET_SSE ? SSE_REGS : NO_REGS\"\n+ \"@internal For AVX512VL, any EVEX encodable SSE register (@code{%xmm0-%xmm31}), otherwise any SSE register.\")\n+\n ;; We use the B prefix to denote any number of internal operands:\n ;;  f  FLAGS_REG\n ;;  g  GOT memory operand."}, {"sha": "b70a8c653e0e38efddcb7c2d2ae4c5a1dd71071a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -1126,7 +1126,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define VALID_AVX512VL_128_REG_MODE(MODE)\t\t\t\t\\\n   ((MODE) == V2DImode || (MODE) == V2DFmode || (MODE) == V16QImode\t\\\n-   || (MODE) == V4SImode || (MODE) == V4SFmode || (MODE) == V8HImode)\n+   || (MODE) == V4SImode || (MODE) == V4SFmode || (MODE) == V8HImode\t\\\n+   || (MODE) == TFmode || (MODE) == V1TImode)\n \n #define VALID_SSE2_REG_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode\t\\"}, {"sha": "9e0b47d3b8bca1b4b64137c22cd693869da24379", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -1168,6 +1168,10 @@\n (define_mode_attr ssevecmodelower\n   [(QI \"v16qi\") (HI \"v8hi\") (SI \"v4si\") (DI \"v2di\") (SF \"v4sf\") (DF \"v2df\")])\n \n+;; AVX512F vector mode corresponding to a scalar mode\n+(define_mode_attr avx512fvecmode\n+  [(QI \"V64QI\") (HI \"V32HI\") (SI \"V16SI\") (DI \"V8DI\") (SF \"V16SF\") (DF \"V8DF\")])\n+\n ;; Instruction suffix for REX 64bit operators.\n (define_mode_attr rex64suffix [(SI \"\") (DI \"{q}\")])\n \n@@ -2928,7 +2932,7 @@\n \n (define_insn \"*pushtf\"\n   [(set (match_operand:TF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:TF 1 \"general_no_elim_operand\" \"x,*roF\"))]\n+\t(match_operand:TF 1 \"general_no_elim_operand\" \"v,*roF\"))]\n   \"TARGET_64BIT || TARGET_SSE\"\n {\n   /* This insn should be already split before reg-stack.  */\n@@ -3103,8 +3107,8 @@\n   \"ix86_expand_move (<MODE>mode, operands); DONE;\")\n \n (define_insn \"*movtf_internal\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,x ,m,?*r ,!o\")\n-\t(match_operand:TF 1 \"general_operand\"\t   \"C ,xm,x,*roF,*rC\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=v,v ,m,?*r ,!o\")\n+\t(match_operand:TF 1 \"general_operand\"\t   \"C ,vm,v,*roF,*rC\"))]\n   \"(TARGET_64BIT || TARGET_SSE)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n@@ -3129,13 +3133,21 @@\n \t{\n \t  if (get_attr_mode (insn) == MODE_V4SF)\n \t    return \"%vmovups\\t{%1, %0|%0, %1}\";\n+\t  else if (TARGET_AVX512VL\n+\t\t   && (EXT_REX_SSE_REG_P (operands[0])\n+\t\t       || EXT_REX_SSE_REG_P (operands[1])))\n+\t    return \"vmovdqu64\\t{%1, %0|%0, %1}\";\n \t  else\n \t    return \"%vmovdqu\\t{%1, %0|%0, %1}\";\n \t}\n       else\n \t{\n \t  if (get_attr_mode (insn) == MODE_V4SF)\n \t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\t  else if (TARGET_AVX512VL\n+\t\t   && (EXT_REX_SSE_REG_P (operands[0])\n+\t\t       || EXT_REX_SSE_REG_P (operands[1])))\n+\t    return \"vmovdqa64\\t{%1, %0|%0, %1}\";\n \t  else\n \t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n \t}\n@@ -9228,10 +9240,10 @@\n   \"ix86_expand_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n (define_insn \"*absneg<mode>2\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x,f,!r\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=Yv,Yv,f,!r\")\n \t(match_operator:MODEF 3 \"absneg_operator\"\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"0,x,0,0\")]))\n-   (use (match_operand:<ssevecmode> 2 \"nonimmediate_operand\" \"xm,0,X,X\"))\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0,Yv,0,0\")]))\n+   (use (match_operand:<ssevecmode> 2 \"nonimmediate_operand\" \"Yvm,0,X,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n   \"#\"\n@@ -9263,10 +9275,10 @@\n   \"ix86_expand_fp_absneg_operator (<CODE>, TFmode, operands); DONE;\")\n \n (define_insn \"*absnegtf2_sse\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:TF 0 \"register_operand\" \"=Yv,Yv\")\n \t(match_operator:TF 3 \"absneg_operator\"\n-\t  [(match_operand:TF 1 \"register_operand\" \"0,x\")]))\n-   (use (match_operand:TF 2 \"nonimmediate_operand\" \"xm,0\"))\n+\t  [(match_operand:TF 1 \"register_operand\" \"0,Yv\")]))\n+   (use (match_operand:TF 2 \"nonimmediate_operand\" \"Yvm,0\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_SSE\"\n   \"#\")\n@@ -9446,11 +9458,11 @@\n   \"ix86_expand_copysign (operands); DONE;\")\n \n (define_insn_and_split \"copysign<mode>3_const\"\n-  [(set (match_operand:CSGNMODE 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:CSGNMODE 0 \"register_operand\" \"=Yv\")\n \t(unspec:CSGNMODE\n-\t  [(match_operand:<CSGNVMODE> 1 \"vector_move_operand\" \"xmC\")\n+\t  [(match_operand:<CSGNVMODE> 1 \"vector_move_operand\" \"YvmC\")\n \t   (match_operand:CSGNMODE 2 \"register_operand\" \"0\")\n-\t   (match_operand:<CSGNVMODE> 3 \"nonimmediate_operand\" \"xm\")]\n+\t   (match_operand:<CSGNVMODE> 3 \"nonimmediate_operand\" \"Yvm\")]\n \t  UNSPEC_COPYSIGN))]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n    || (TARGET_SSE && (<MODE>mode == TFmode))\"\n@@ -9460,14 +9472,16 @@\n   \"ix86_split_copysign_const (operands); DONE;\")\n \n (define_insn \"copysign<mode>3_var\"\n-  [(set (match_operand:CSGNMODE 0 \"register_operand\" \"=x,x,x,x,x\")\n+  [(set (match_operand:CSGNMODE 0 \"register_operand\" \"=Yv,Yv,Yv,Yv,Yv\")\n \t(unspec:CSGNMODE\n-\t  [(match_operand:CSGNMODE 2 \"register_operand\"\t\"x,0,0,x,x\")\n-\t   (match_operand:CSGNMODE 3 \"register_operand\"\t\"1,1,x,1,x\")\n-\t   (match_operand:<CSGNVMODE> 4 \"nonimmediate_operand\" \"X,xm,xm,0,0\")\n-\t   (match_operand:<CSGNVMODE> 5 \"nonimmediate_operand\" \"0,xm,1,xm,1\")]\n+\t  [(match_operand:CSGNMODE 2 \"register_operand\"\t\"Yv,0,0,Yv,Yv\")\n+\t   (match_operand:CSGNMODE 3 \"register_operand\"\t\"1,1,Yv,1,Yv\")\n+\t   (match_operand:<CSGNVMODE> 4\n+\t     \"nonimmediate_operand\" \"X,Yvm,Yvm,0,0\")\n+\t   (match_operand:<CSGNVMODE> 5\n+\t     \"nonimmediate_operand\" \"0,Yvm,1,Yvm,1\")]\n \t  UNSPEC_COPYSIGN))\n-   (clobber (match_scratch:<CSGNVMODE> 1 \"=x,x,x,x,x\"))]\n+   (clobber (match_scratch:<CSGNVMODE> 1 \"=Yv,Yv,Yv,Yv,Yv\"))]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n    || (TARGET_SSE && (<MODE>mode == TFmode))\"\n   \"#\")"}, {"sha": "a8092cb0500fd1ce0b45b8afae6526066d841727", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 95, "deletions": 26, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -3020,11 +3020,11 @@\n ;; because the native instructions read the full 128-bits.\n \n (define_insn \"*andnot<mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x,v,v\")\n \t(and:MODEF\n \t  (not:MODEF\n-\t    (match_operand:MODEF 1 \"register_operand\" \"0,x\"))\n-\t    (match_operand:MODEF 2 \"register_operand\" \"x,x\")))]\n+\t    (match_operand:MODEF 1 \"register_operand\" \"0,x,v,v\"))\n+\t    (match_operand:MODEF 2 \"register_operand\" \"x,x,v,v\")))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode)\"\n {\n   static char buf[32];\n@@ -3040,18 +3040,44 @@\n     case 1:\n       ops = \"vandn%s\\t{%%2, %%1, %%0|%%0, %%1, %%2}\";\n       break;\n+    case 2:\n+      if (TARGET_AVX512DQ)\n+\tops = \"vandn%s\\t{%%2, %%1, %%0|%%0, %%1, %%2}\";\n+      else\n+\t{\n+\t  suffix = <MODE>mode == DFmode ? \"q\" : \"d\";\n+\t  ops = \"vpandn%s\\t{%%2, %%1, %%0|%%0, %%1, %%2}\";\n+\t}\n+      break;\n+    case 3:\n+      if (TARGET_AVX512DQ)\n+\tops = \"vandn%s\\t{%%g2, %%g1, %%g0|%%g0, %%g1, %%g2}\";\n+      else\n+\t{\n+\t  suffix = <MODE>mode == DFmode ? \"q\" : \"d\";\n+\t  ops = \"vpandn%s\\t{%%g2, %%g1, %%g0|%%g0, %%g1, %%g2}\";\n+\t}\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n \n   snprintf (buf, sizeof (buf), ops, suffix);\n   return buf;\n }\n-  [(set_attr \"isa\" \"noavx,avx\")\n+  [(set_attr \"isa\" \"noavx,avx,avx512vl,avx512f\")\n    (set_attr \"type\" \"sselog\")\n-   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"prefix\" \"orig,vex,evex,evex\")\n    (set (attr \"mode\")\n-\t(cond [(and (match_test \"<MODE_SIZE> == 16\")\n+\t(cond [(eq_attr \"alternative\" \"2\")\n+\t\t (if_then_else (match_test \"TARGET_AVX512DQ\")\n+\t\t\t       (const_string \"<ssevecmode>\")\n+\t\t\t       (const_string \"TI\"))\n+\t       (eq_attr \"alternative\" \"3\")\n+\t\t (if_then_else (match_test \"TARGET_AVX512DQ\")\n+\t\t\t       (const_string \"<avx512fvecmode>\")\n+\t\t\t       (const_string \"XI\"))\n+\t       (and (match_test \"<MODE_SIZE> == 16\")\n \t\t    (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t (const_string \"V4SF\")\n \t       (match_test \"TARGET_AVX\")\n@@ -3062,43 +3088,52 @@\n \t       (const_string \"<ssevecmode>\")))])\n \n (define_insn \"*andnottf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:TF 0 \"register_operand\" \"=x,x,v,v\")\n \t(and:TF\n-\t  (not:TF (match_operand:TF 1 \"register_operand\" \"0,x\"))\n-\t  (match_operand:TF 2 \"vector_operand\" \"xBm,xm\")))]\n+\t  (not:TF (match_operand:TF 1 \"register_operand\" \"0,x,v,v\"))\n+\t  (match_operand:TF 2 \"vector_operand\" \"xBm,xm,vm,v\")))]\n   \"TARGET_SSE\"\n {\n   static char buf[32];\n   const char *ops;\n   const char *tmp\n-    = (get_attr_mode (insn) == MODE_V4SF) ? \"andnps\" : \"pandn\";\n+    = (which_alternative >= 2 ? \"pandnq\"\n+       : get_attr_mode (insn) == MODE_V4SF ? \"andnps\" : \"pandn\");\n \n   switch (which_alternative)\n     {\n     case 0:\n       ops = \"%s\\t{%%2, %%0|%%0, %%2}\";\n       break;\n     case 1:\n+    case 2:\n       ops = \"v%s\\t{%%2, %%1, %%0|%%0, %%1, %%2}\";\n       break;\n+    case 3:\n+      ops = \"v%s\\t{%%g2, %%g1, %%g0|%%g0, %%g1, %%g2}\";\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n \n   snprintf (buf, sizeof (buf), ops, tmp);\n   return buf;\n }\n-  [(set_attr \"isa\" \"noavx,avx\")\n+  [(set_attr \"isa\" \"noavx,avx,avx512vl,avx512f\")\n    (set_attr \"type\" \"sselog\")\n    (set (attr \"prefix_data16\")\n      (if_then_else\n        (and (eq_attr \"alternative\" \"0\")\n \t    (eq_attr \"mode\" \"TI\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n-   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"prefix\" \"orig,vex,evex,evex\")\n    (set (attr \"mode\")\n-\t(cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n+\t(cond [(eq_attr \"alternative\" \"2\")\n+\t\t (const_string \"TI\")\n+\t       (eq_attr \"alternative\" \"3\")\n+\t\t (const_string \"XI\")\n+\t       (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n \t\t (const_string \"V4SF\")\n \t       (match_test \"TARGET_AVX\")\n \t\t (const_string \"TI\")\n@@ -3109,10 +3144,10 @@\n \t       (const_string \"TI\")))])\n \n (define_insn \"*<code><mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x,v,v\")\n \t(any_logic:MODEF\n-\t  (match_operand:MODEF 1 \"register_operand\" \"%0,x\")\n-\t  (match_operand:MODEF 2 \"register_operand\" \"x,x\")))]\n+\t  (match_operand:MODEF 1 \"register_operand\" \"%0,x,v,v\")\n+\t  (match_operand:MODEF 2 \"register_operand\" \"x,x,v,v\")))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode)\"\n {\n   static char buf[32];\n@@ -3125,21 +3160,46 @@\n     case 0:\n       ops = \"<logic>%s\\t{%%2, %%0|%%0, %%2}\";\n       break;\n+    case 2:\n+      if (!TARGET_AVX512DQ)\n+\t{\n+\t  suffix = <MODE>mode == DFmode ? \"q\" : \"d\";\n+\t  ops = \"vp<logic>%s\\t{%%2, %%1, %%0|%%0, %%1, %%2}\";\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n     case 1:\n       ops = \"v<logic>%s\\t{%%2, %%1, %%0|%%0, %%1, %%2}\";\n       break;\n+    case 3:\n+      if (TARGET_AVX512DQ)\n+\tops = \"v<logic>%s\\t{%%g2, %%g1, %%g0|%%g0, %%g1, %%g2}\";\n+      else\n+\t{\n+\t  suffix = <MODE>mode == DFmode ? \"q\" : \"d\";\n+\t  ops = \"vp<logic>%s\\t{%%g2, %%g1, %%g0|%%g0, %%g1, %%g2}\";\n+\t}\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n \n   snprintf (buf, sizeof (buf), ops, suffix);\n   return buf;\n }\n-  [(set_attr \"isa\" \"noavx,avx\")\n+  [(set_attr \"isa\" \"noavx,avx,avx512vl,avx512f\")\n    (set_attr \"type\" \"sselog\")\n-   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"prefix\" \"orig,vex,evex,evex\")\n    (set (attr \"mode\")\n-\t(cond [(and (match_test \"<MODE_SIZE> == 16\")\n+\t(cond [(eq_attr \"alternative\" \"2\")\n+\t\t (if_then_else (match_test \"TARGET_AVX512DQ\")\n+\t\t\t       (const_string \"<ssevecmode>\")\n+\t\t\t       (const_string \"TI\"))\n+\t       (eq_attr \"alternative\" \"3\")\n+\t\t (if_then_else (match_test \"TARGET_AVX512DQ\")\n+\t\t\t       (const_string \"<avx512fvecmode>\")\n+\t\t\t       (const_string \"XI\"))\n+\t       (and (match_test \"<MODE_SIZE> == 16\")\n \t\t    (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t (const_string \"V4SF\")\n \t       (match_test \"TARGET_AVX\")\n@@ -3158,44 +3218,53 @@\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, TFmode, operands);\")\n \n (define_insn \"*<code>tf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:TF 0 \"register_operand\" \"=x,x,v,v\")\n \t(any_logic:TF\n-\t  (match_operand:TF 1 \"vector_operand\" \"%0,x\")\n-\t  (match_operand:TF 2 \"vector_operand\" \"xBm,xm\")))]\n+\t  (match_operand:TF 1 \"vector_operand\" \"%0,x,v,v\")\n+\t  (match_operand:TF 2 \"vector_operand\" \"xBm,xm,vm,v\")))]\n   \"TARGET_SSE\n    && ix86_binary_operator_ok (<CODE>, TFmode, operands)\"\n {\n   static char buf[32];\n   const char *ops;\n   const char *tmp\n-    = (get_attr_mode (insn) == MODE_V4SF) ? \"<logic>ps\" : \"p<logic>\";\n+    = (which_alternative >= 2 ? \"p<logic>q\"\n+       : get_attr_mode (insn) == MODE_V4SF ? \"<logic>ps\" : \"p<logic>\");\n \n   switch (which_alternative)\n     {\n     case 0:\n       ops = \"%s\\t{%%2, %%0|%%0, %%2}\";\n       break;\n     case 1:\n+    case 2:\n       ops = \"v%s\\t{%%2, %%1, %%0|%%0, %%1, %%2}\";\n       break;\n+    case 3:\n+      ops = \"v%s\\t{%%g2, %%g1, %%g0|%%g0, %%g1, %%g2}\";\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n \n   snprintf (buf, sizeof (buf), ops, tmp);\n   return buf;\n }\n-  [(set_attr \"isa\" \"noavx,avx\")\n+  [(set_attr \"isa\" \"noavx,avx,avx512vl,avx512f\")\n    (set_attr \"type\" \"sselog\")\n    (set (attr \"prefix_data16\")\n      (if_then_else\n        (and (eq_attr \"alternative\" \"0\")\n \t    (eq_attr \"mode\" \"TI\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n-   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"prefix\" \"orig,vex,evex,evex\")\n    (set (attr \"mode\")\n-\t(cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n+\t(cond [(eq_attr \"alternative\" \"2\")\n+\t\t (const_string \"TI\")\n+\t       (eq_attr \"alternative\" \"3\")\n+\t\t (const_string \"QI\")\n+\t       (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n \t\t (const_string \"V4SF\")\n \t       (match_test \"TARGET_AVX\")\n \t\t (const_string \"TI\")"}, {"sha": "fa2c1231a7009862b78a138012fca24d2302d4ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -1,3 +1,9 @@\n+2016-05-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.target/i386/avx512dq-abs-copysign-1.c: New test.\n+\t* gcc.target/i386/avx512vl-abs-copysign-1.c: New test.\n+\t* gcc.target/i386/avx512vl-abs-copysign-2.c: New test.\n+\n 2016-05-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/70986"}, {"sha": "cb542d090582853ba9a2781a5b7a6fee23f0ad1a", "filename": "gcc/testsuite/gcc.target/i386/avx512dq-abs-copysign-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512dq-abs-copysign-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512dq-abs-copysign-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512dq-abs-copysign-1.c?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-Ofast -mavx512vl -mavx512dq\" } */\n+\n+void\n+f1 (float x)\n+{\n+  register float a __asm (\"xmm16\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = __builtin_fabsf (a);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f2 (float x, float y)\n+{\n+  register float a __asm (\"xmm16\"), b __asm (\"xmm17\");\n+  a = x;\n+  b = y;\n+  asm volatile (\"\" : \"+v\" (a), \"+v\" (b));\n+  a = __builtin_copysignf (a, b);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f3 (float x)\n+{\n+  register float a __asm (\"xmm16\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = -a;\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f4 (double x)\n+{\n+  register double a __asm (\"xmm18\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = __builtin_fabs (a);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f5 (double x, double y)\n+{\n+  register double a __asm (\"xmm18\"), b __asm (\"xmm19\");\n+  a = x;\n+  b = y;\n+  asm volatile (\"\" : \"+v\" (a), \"+v\" (b));\n+  a = __builtin_copysign (a, b);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f6 (double x)\n+{\n+  register double a __asm (\"xmm18\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = -a;\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+/* { dg-final { scan-assembler \"vandps\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vorps\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vxorps\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vandpd\\[^\\n\\r\\]*xmm18\" } } */\n+/* { dg-final { scan-assembler \"vorpd\\[^\\n\\r\\]*xmm18\" } } */\n+/* { dg-final { scan-assembler \"vxorpd\\[^\\n\\r\\]*xmm18\" } } */"}, {"sha": "b375c5fad801aa36c4d70b79429657fabc28b6ab", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-abs-copysign-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-abs-copysign-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-abs-copysign-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-abs-copysign-1.c?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-Ofast -mavx512vl -mno-avx512dq\" } */\n+\n+void\n+f1 (float x)\n+{\n+  register float a __asm (\"xmm16\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = __builtin_fabsf (a);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f2 (float x, float y)\n+{\n+  register float a __asm (\"xmm16\"), b __asm (\"xmm17\");\n+  a = x;\n+  b = y;\n+  asm volatile (\"\" : \"+v\" (a), \"+v\" (b));\n+  a = __builtin_copysignf (a, b);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f3 (float x)\n+{\n+  register float a __asm (\"xmm16\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = -a;\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f4 (double x)\n+{\n+  register double a __asm (\"xmm18\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = __builtin_fabs (a);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f5 (double x, double y)\n+{\n+  register double a __asm (\"xmm18\"), b __asm (\"xmm19\");\n+  a = x;\n+  b = y;\n+  asm volatile (\"\" : \"+v\" (a), \"+v\" (b));\n+  a = __builtin_copysign (a, b);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f6 (double x)\n+{\n+  register double a __asm (\"xmm18\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = -a;\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+/* { dg-final { scan-assembler \"vpandd\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vpord\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vpxord\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vpandq\\[^\\n\\r\\]*xmm18\" } } */\n+/* { dg-final { scan-assembler \"vporq\\[^\\n\\r\\]*xmm18\" } } */\n+/* { dg-final { scan-assembler \"vpxorq\\[^\\n\\r\\]*xmm18\" } } */"}, {"sha": "9082cdb5dbaf72e9aa24cdcba5b4768bf68aa60c", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-abs-copysign-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-abs-copysign-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bd4bf95e68e252afdf863f1c3d5f22e30f819e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-abs-copysign-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-abs-copysign-2.c?ref=40bd4bf95e68e252afdf863f1c3d5f22e30f819e", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-Ofast -mavx512vl\" } */\n+\n+void\n+f1 (__float128 x)\n+{\n+  register __float128 a __asm (\"xmm16\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = __builtin_fabsq (a);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f2 (__float128 x, __float128 y)\n+{\n+  register __float128 a __asm (\"xmm16\"), b __asm (\"xmm17\");\n+  a = x;\n+  b = y;\n+  asm volatile (\"\" : \"+v\" (a), \"+v\" (b));\n+  a = __builtin_copysignq (a, b);\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+void\n+f3 (__float128 x)\n+{\n+  register __float128 a __asm (\"xmm16\");\n+  a = x;\n+  asm volatile (\"\" : \"+v\" (a));\n+  a = -a;\n+  asm volatile (\"\" : \"+v\" (a));\n+}\n+\n+__int128_t\n+f4 (void)\n+{\n+  register __int128_t a __asm (\"xmm16\");\n+  register __int128_t __attribute__((vector_size (16))) b __asm (\"xmm17\");\n+  a = 1;\n+  asm volatile (\"\" : \"+v\" (a));\n+  b[0] = a;\n+  asm volatile (\"\" : \"+v\" (b));\n+  return b[0];\n+}\n+\n+/* { dg-final { scan-assembler \"vpandq\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vporq\\[^\\n\\r\\]*xmm16\" } } */\n+/* { dg-final { scan-assembler \"vpxorq\\[^\\n\\r\\]*xmm16\" } } */"}]}