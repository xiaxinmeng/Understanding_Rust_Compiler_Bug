{"sha": "3070ac15039fa513f3d40ee3c5838c36f71054b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA3MGFjMTUwMzlmYTUxM2YzZDQwZWUzYzU4MzhjMzZmNzEwNTRiOA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-02-06T17:41:09Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-02-06T17:41:09Z"}, "message": "Clarify comments and use build_pddr.\n\n2010-01-20  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-dependences.c: Clarify comments.\n\t(build_pddr): Add an extra parameter direction.\n\t(graphite_legal_transform_dr): Use build_pddr.\n\t(dot_original_deps_stmt_1): Update use of build_pddr.\n\t(dot_transformed_deps_stmt_1): Same.\n\t(dot_original_deps): Same.\n\t(dot_transformed_deps): Same.\n\n\t* testsuite/gcc.dg/graphite/interchange-12.c: New.\n\t* gcc/testsuite/gcc.dg/graphite/block-7.c: New.\n\nFrom-SVN: r156545", "tree": {"sha": "eb8eac6a068216193273f4d0bc8dc82bdd0b3af2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb8eac6a068216193273f4d0bc8dc82bdd0b3af2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3070ac15039fa513f3d40ee3c5838c36f71054b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3070ac15039fa513f3d40ee3c5838c36f71054b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3070ac15039fa513f3d40ee3c5838c36f71054b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3070ac15039fa513f3d40ee3c5838c36f71054b8/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7ed6c90a44ad420c4c71fdd088316a24c54d6e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7ed6c90a44ad420c4c71fdd088316a24c54d6e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7ed6c90a44ad420c4c71fdd088316a24c54d6e3"}], "stats": {"total": 103, "additions": 84, "deletions": 19}, "files": [{"sha": "03009a9ec99fb296b3fcdc6bcddcacd785981e61", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=3070ac15039fa513f3d40ee3c5838c36f71054b8", "patch": "@@ -1,3 +1,16 @@\n+2010-01-20  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-dependences.c: Clarify comments.\n+\t(build_pddr): Add an extra parameter direction.\n+\t(graphite_legal_transform_dr): Use build_pddr.\n+\t(dot_original_deps_stmt_1): Update use of build_pddr.\n+\t(dot_transformed_deps_stmt_1): Same.\n+\t(dot_original_deps): Same.\n+\t(dot_transformed_deps): Same.\n+\n+\t* testsuite/gcc.dg/graphite/interchange-12.c: New.\n+\t* testsuite/gcc.dg/graphite/block-7.c: New.\n+\n 2010-01-20  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-dependences.c (pddr_original_scattering): Renamed build_pddr."}, {"sha": "7b462f731fd655bde665916809d99e0e1f5df975", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=3070ac15039fa513f3d40ee3c5838c36f71054b8", "patch": "@@ -296,9 +296,10 @@ lexicographically_gt_p (ppl_Pointset_Powerset_C_Polyhedron_t res,\n    compared lexicographically, i.e. the number of loops containing\n    both statements.  OFFSET is the number of dimensions needed to\n    represent the first statement, i.e. dimT1 + dimI1 in the layout of\n-   the RES polyhedron: T1|I1|T2|I2|S1|S2|G.  DIRECTION is equal to 1\n-   when statement 1 is after statement 2, equal to -1 when statement 1\n-   is before statement 2.  */\n+   the RES polyhedron: T1|I1|T2|I2|S1|S2|G.  When DIRECTION is set to\n+   1, compute the direct dependence from PDR1 to PDR2, and when\n+   DIRECTION is -1, compute the reversed dependence relation, from\n+   PDR2 to PDR1.  */\n \n static void\n build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res,\n@@ -351,8 +352,9 @@ build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res\n    SCAT1 and SCAT2 correspond to the original scattering of the\n    program, otherwise they correspond to the transformed scattering.\n \n-   DIRECTION is equal to 1 when statement 1 is after statement 2,\n-   equal to -1 when statement 1 is before statement 2.  */\n+   When DIRECTION is set to 1, compute the direct dependence from PDR1\n+   to PDR2, and when DIRECTION is -1, compute the reversed dependence\n+   relation, from PDR2 to PDR1.  */\n \n static poly_ddr_p\n dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n@@ -439,8 +441,9 @@ dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n    SCAT1 and SCAT2 correspond to the original scattering of the\n    program, otherwise they correspond to the transformed scattering.\n \n-   DIRECTION is equal to 1 when statement 1 is after statement 2,\n-   equal to -1 when statement 1 is before statement 2.  */\n+   When DIRECTION is set to 1, compute the direct dependence from PDR1\n+   to PDR2, and when DIRECTION is -1, compute the reversed dependence\n+   relation, from PDR2 to PDR1.  */\n \n static poly_ddr_p\n dependence_polyhedron (poly_bb_p pbb1, poly_bb_p pbb2,\n@@ -481,11 +484,13 @@ dependence_polyhedron (poly_bb_p pbb1, poly_bb_p pbb2,\n    ORIGINAL_SCATTERING_P is true, return the PDDR corresponding to the\n    original scattering, or NULL if the dependence relation is empty.\n    When ORIGINAL_SCATTERING_P is false, return the PDDR corresponding\n-   to the transformed scattering.  */\n+   to the transformed scattering.  When DIRECTION is set to 1, compute\n+   the direct dependence from PDR1 to PDR2, and when DIRECTION is -1,\n+   compute the reversed dependence relation, from PDR2 to PDR1.  */\n \n static poly_ddr_p\n build_pddr (poly_bb_p pbb1, poly_bb_p pbb2, poly_dr_p pdr1, poly_dr_p pdr2,\n-\t    bool original_scattering_p)\n+\t    int direction, bool original_scattering_p)\n {\n   poly_ddr_p pddr;\n   ppl_Pointset_Powerset_C_Polyhedron_t d1 = PBB_DOMAIN (pbb1);\n@@ -501,7 +506,7 @@ build_pddr (poly_bb_p pbb1, poly_bb_p pbb2, poly_dr_p pdr1, poly_dr_p pdr2,\n     return NULL;\n \n   pddr = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, scat1, scat2,\n-\t\t\t\t1, original_scattering_p);\n+\t\t\t\tdirection, original_scattering_p);\n   if (pddr_is_empty (pddr))\n     return NULL;\n \n@@ -557,14 +562,14 @@ graphite_legal_transform_dr (poly_bb_p pbb1, poly_bb_p pbb2,\n   ppl_dimension_type pdim;\n   bool is_empty_p;\n   poly_ddr_p pddr;\n-  ppl_Pointset_Powerset_C_Polyhedron_t d1 = PBB_DOMAIN (pbb1);\n-  ppl_Pointset_Powerset_C_Polyhedron_t d2 = PBB_DOMAIN (pbb2);\n \n   if (reduction_dr_p (pbb1, pbb2, pdr1, pdr2))\n     return true;\n \n-  pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, true);\n+  pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, 1, true);\n   if (!pddr)\n+    /* There are no dependences between PDR1 and PDR2 in the original\n+       version of the program, so the transform is legal.  */\n     return true;\n \n   po = PDDR_DDP (pddr);\n@@ -587,8 +592,17 @@ graphite_legal_transform_dr (poly_bb_p pbb1, poly_bb_p pbb2,\n   ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (&temp, pdim, 0);\n   ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (temp, po);\n \n-  pddr = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, st1, st2,\n-\t\t\t\t-1, false);\n+  /* We build the reverse dependence relation for the transformed\n+     scattering, such that when we intersect it with the original PO,\n+     we get an empty intersection when the transform is legal:\n+     i.e. the transform should reverse no dependences, and so PT, the\n+     reversed transformed PDDR, should have no constraint from PO.  */\n+  pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, -1, false);\n+  if (!pddr)\n+    /* There are no dependences after the transform, so the transform\n+       is legal.  */\n+    return true;\n+\n   pt = PDDR_DDP (pddr);\n \n   /* Extend PO and PT to have the same dimensions.  */\n@@ -811,7 +825,7 @@ dot_original_deps_stmt_1 (FILE *file, scop_p scop)\n       {\n \tfor (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \t  for (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t    if (build_pddr (pbb1, pbb2, pdr1, pdr2, true))\n+\t    if (build_pddr (pbb1, pbb2, pdr1, pdr2, 1, true))\n \t      {\n \t\tfprintf (file, \"OS%d -> OS%d\\n\",\n \t\t\t pbb_index (pbb1), pbb_index (pbb2));\n@@ -837,7 +851,7 @@ dot_transformed_deps_stmt_1 (FILE *file, scop_p scop)\n       {\n \tfor (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \t  for (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t    if ((pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, false)))\n+\t    if ((pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, 1, false)))\n \t      {\n \t\tfprintf (file, \"TS%d -> TS%d\\n\",\n \t\t\t pbb_index (pbb1), pbb_index (pbb2));\n@@ -877,7 +891,7 @@ dot_original_deps (FILE *file, scop_p scop)\n     for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n       for (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \tfor (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t  if (build_pddr (pbb1, pbb2, pdr1, pdr2, true))\n+\t  if (build_pddr (pbb1, pbb2, pdr1, pdr2, 1, true))\n \t    fprintf (file, \"OS%d_D%d -> OS%d_D%d\\n\",\n \t\t     pbb_index (pbb1), PDR_ID (pdr1),\n \t\t     pbb_index (pbb2), PDR_ID (pdr2));\n@@ -898,7 +912,7 @@ dot_transformed_deps (FILE *file, scop_p scop)\n     for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n       for (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \tfor (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t  if ((pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, false)))\n+\t  if ((pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, 1, false)))\n \t    {\n \t      fprintf (file, \"TS%d_D%d -> TS%d_D%d\\n\",\n \t\t       pbb_index (pbb1), PDR_ID (pdr1),"}, {"sha": "994a55a1a4344d0efeef72035fe81394742ceccd", "filename": "gcc/testsuite/gcc.dg/graphite/block-7.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c?ref=3070ac15039fa513f3d40ee3c5838c36f71054b8", "patch": "@@ -0,0 +1,19 @@\n+#define N 1000\n+\n+float A[N][N], B[N][N], C[N][N];\n+\n+void matmult ()\n+{\n+  int i, j, k;\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      {\n+        A[i][j] = 0;\n+        for (k = 0; k < N; k++)\n+          A[i][j] += B[i][k] * C[k][j];\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"SCoP will be loop blocked\" 1 \"graphite\" } } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "73c9c8c6d8fcb3b650005c3df27e78bc53158cb0", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-12.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070ac15039fa513f3d40ee3c5838c36f71054b8/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c?ref=3070ac15039fa513f3d40ee3c5838c36f71054b8", "patch": "@@ -0,0 +1,19 @@\n+#define N 1000\n+\n+float A[N][N], B[N][N], C[N][N];\n+\n+void matmult ()\n+{\n+  int i, j, k;\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      {\n+        A[i][j] = 0;\n+        for (k = 0; k < N; k++)\n+          A[i][j] += B[i][k] * C[k][j];\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}]}