{"sha": "582b56dfd023077e9210a3adce478dd73d96d340", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgyYjU2ZGZkMDIzMDc3ZTkyMTBhM2FkY2U0NzhkZDczZDk2ZDM0MA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T12:39:37Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T17:49:28Z"}, "message": "rs6000: Parsing of overload input file\n\n2021-06-07  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c (ovld_stanza): New struct.\n\t(MAXOVLDSTANZAS): New macro.\n\t(ovld_stanzas): New variable.\n\t(curr_ovld_stanza): Likewise.\n\t(MAXOVLDS): New macro.\n\t(ovlddata): New struct.\n\t(ovlds): New variable.\n\t(curr_ovld): Likewise.\n\t(max_ovld_args): Likewise.\n\t(parse_ovld_entry): New function.\n\t(parse_ovld_stanza): Likewise.\n\t(parse_ovld): Implement.", "tree": {"sha": "820699fddd7fe44ba95d9f208adb52f814d788c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/820699fddd7fe44ba95d9f208adb52f814d788c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/582b56dfd023077e9210a3adce478dd73d96d340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582b56dfd023077e9210a3adce478dd73d96d340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/582b56dfd023077e9210a3adce478dd73d96d340", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582b56dfd023077e9210a3adce478dd73d96d340/comments", "author": null, "committer": null, "parents": [{"sha": "63c334f286e764349f2961c6a4c2492ec0394d01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63c334f286e764349f2961c6a4c2492ec0394d01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63c334f286e764349f2961c6a4c2492ec0394d01"}], "stats": {"total": 235, "additions": 234, "deletions": 1}, "files": [{"sha": "ddeb39e442ea885c8e409a9a5d0891fe796891a2", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 234, "deletions": 1, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/582b56dfd023077e9210a3adce478dd73d96d340/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/582b56dfd023077e9210a3adce478dd73d96d340/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=582b56dfd023077e9210a3adce478dd73d96d340", "patch": "@@ -415,8 +415,35 @@ static int curr_bif;\n static int *bif_order;\n static int bif_index = 0;\n \n+/* Stanzas are groupings of built-in functions and overloads by some\n+   common feature/attribute.  These definitions are for overload stanzas.  */\n+struct ovld_stanza\n+{\n+  char *stanza_id;\n+  char *extern_name;\n+  char *intern_name;\n+  char *ifdef;\n+};\n+\n+#define MAXOVLDSTANZAS 512\n+static ovld_stanza ovld_stanzas[MAXOVLDSTANZAS];\n static int num_ovld_stanzas;\n+static int curr_ovld_stanza;\n+\n+#define MAXOVLDS 16384\n+struct ovlddata\n+{\n+  int stanza;\n+  prototype proto;\n+  char *bif_id_name;\n+  char *ovld_id_name;\n+  char *fndecl;\n+};\n+\n+static ovlddata ovlds[MAXOVLDS];\n static int num_ovlds;\n+static int curr_ovld;\n+static int max_ovld_args = 0;\n \n /* Return codes for parsing routines.  */\n enum parse_codes\n@@ -1527,11 +1554,217 @@ create_bif_order (void)\n   rbt_inorder_callback (&bifo_rbt, bifo_rbt.rbt_root, set_bif_order);\n }\n \n+/* Parse one two-line entry in the overload file.  */\n+static parse_codes\n+parse_ovld_entry (void)\n+{\n+  /* Check for end of stanza.  */\n+  pos = 0;\n+  consume_whitespace ();\n+  if (linebuf[pos] == '[')\n+    return PC_EOSTANZA;\n+\n+  /* Allocate an entry in the overload table.  */\n+  if (num_ovlds >= MAXOVLDS - 1)\n+    {\n+      (*diag) (\"too many overloads.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  curr_ovld = num_ovlds++;\n+  ovlds[curr_ovld].stanza = curr_ovld_stanza;\n+\n+  if (parse_prototype (&ovlds[curr_ovld].proto) == PC_PARSEFAIL)\n+    return PC_PARSEFAIL;\n+\n+  if (ovlds[curr_ovld].proto.nargs > max_ovld_args)\n+    max_ovld_args = ovlds[curr_ovld].proto.nargs;\n+\n+  /* Now process line 2, which just contains the builtin id and an\n+     optional overload id.  */\n+  if (!advance_line (ovld_file))\n+    {\n+      (*diag) (\"unexpected EOF.\\n\");\n+      return PC_EOFILE;\n+    }\n+\n+  pos = 0;\n+  consume_whitespace ();\n+  int oldpos = pos;\n+  char *id = match_identifier ();\n+  ovlds[curr_ovld].bif_id_name = id;\n+  ovlds[curr_ovld].ovld_id_name = id;\n+  if (!id)\n+    {\n+      (*diag) (\"missing overload id at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+#ifdef DEBUG\n+  (*diag) (\"ID name is '%s'.\\n\", id);\n+#endif\n+\n+  /* The builtin id has to match one from the bif file.  */\n+  if (!rbt_find (&bif_rbt, id))\n+    {\n+      (*diag) (\"builtin ID '%s' not found in bif file.\\n\", id);\n+      return PC_PARSEFAIL;\n+    }\n+\n+  /* Check for an optional overload id.  Usually we use the builtin\n+     function id for that purpose, but sometimes we need multiple\n+     overload entries for the same builtin id, and it needs to be unique.  */\n+  consume_whitespace ();\n+  if (linebuf[pos] != '\\n')\n+    {\n+      id = match_identifier ();\n+      ovlds[curr_ovld].ovld_id_name = id;\n+      consume_whitespace ();\n+    }\n+\n+ /* Save the overload ID in a lookup structure.  */\n+  if (!rbt_insert (&ovld_rbt, id))\n+    {\n+      (*diag) (\"duplicate overload ID '%s' at column %d.\\n\", id, oldpos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+  if (linebuf[pos] != '\\n')\n+    {\n+      (*diag) (\"garbage at end of line at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  return PC_OK;\n+}\n+\n+/* Parse one stanza of the input overload file.  linebuf already contains the\n+   first line to parse.  */\n+static parse_codes\n+parse_ovld_stanza (void)\n+{\n+  /* Parse the stanza header.  */\n+  pos = 0;\n+  consume_whitespace ();\n+\n+  if (linebuf[pos] != '[')\n+    {\n+      (*diag) (\"ill-formed stanza header at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+\n+  char *stanza_name = match_identifier ();\n+  if (!stanza_name)\n+    {\n+      (*diag) (\"no identifier found in stanza header.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  /* Add the identifier to a table and set the number to be recorded\n+     with subsequent overload entries.  */\n+  if (num_ovld_stanzas >= MAXOVLDSTANZAS)\n+    {\n+      (*diag) (\"too many stanza headers.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  curr_ovld_stanza = num_ovld_stanzas++;\n+  ovld_stanza *stanza = &ovld_stanzas[curr_ovld_stanza];\n+  stanza->stanza_id = stanza_name;\n+\n+  consume_whitespace ();\n+  if (linebuf[pos] != ',')\n+    {\n+      (*diag) (\"missing comma at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+\n+  consume_whitespace ();\n+  stanza->extern_name = match_identifier ();\n+  if (!stanza->extern_name)\n+    {\n+      (*diag) (\"missing external name at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+  consume_whitespace ();\n+  if (linebuf[pos] != ',')\n+    {\n+      (*diag) (\"missing comma at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+\n+  consume_whitespace ();\n+  stanza->intern_name = match_identifier ();\n+  if (!stanza->intern_name)\n+    {\n+      (*diag) (\"missing internal name at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+  consume_whitespace ();\n+  if (linebuf[pos] == ',')\n+    {\n+      safe_inc_pos ();\n+      consume_whitespace ();\n+      stanza->ifdef = match_identifier ();\n+      if (!stanza->ifdef)\n+\t{\n+\t  (*diag) (\"missing ifdef token at column %d.\\n\", pos + 1);\n+\t  return PC_PARSEFAIL;\n+\t}\n+      consume_whitespace ();\n+    }\n+  else\n+    stanza->ifdef = 0;\n+\n+  if (linebuf[pos] != ']')\n+    {\n+      (*diag) (\"ill-formed stanza header at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+\n+  consume_whitespace ();\n+  if (linebuf[pos] != '\\n' && pos != LINELEN - 1)\n+    {\n+      (*diag) (\"garbage after stanza header.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  parse_codes result = PC_OK;\n+\n+  while (result != PC_EOSTANZA)\n+    {\n+      if (!advance_line (ovld_file))\n+\treturn PC_EOFILE;\n+\n+      result = parse_ovld_entry ();\n+      if (result == PC_EOFILE || result == PC_PARSEFAIL)\n+\treturn result;\n+    }\n+\n+  return PC_OK;\n+}\n+\n /* Parse the overload file.  */\n static parse_codes\n parse_ovld (void)\n {\n-  return PC_OK;\n+  parse_codes result = PC_OK;\n+  diag = &ovld_diag;\n+\n+  if (!advance_line (ovld_file))\n+    return PC_OK;\n+\n+  while (result == PC_OK)\n+    result = parse_ovld_stanza ();\n+\n+  if (result == PC_EOFILE)\n+    return PC_OK;\n+  return result;\n }\n \n /* Write everything to the header file (rs6000-builtins.h).  Return"}]}