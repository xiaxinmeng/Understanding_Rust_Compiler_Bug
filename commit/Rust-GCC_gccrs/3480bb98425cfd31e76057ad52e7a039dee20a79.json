{"sha": "3480bb98425cfd31e76057ad52e7a039dee20a79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ4MGJiOTg0MjVjZmQzMWU3NjA1N2FkNTJlN2EwMzlkZWUyMGE3OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-06-14T19:18:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-06-14T19:18:43Z"}, "message": "jump.c (condjump_in_parallel_p): New function to detect conditional jumps within PARALLEL insns.\n\n        * jump.c (condjump_in_parallel_p): New function to detect\n        conditional jumps within PARALLEL insns.\n        (jump_optimize): Allow for some simple optimizations involving\n        conditional jumps within PARALLEL insns.\n        * reorg.c (get_jump_flags): Handle conditional jumps in PARALLEL\n        insns.\n        (get_branch_condition, fill_simple_delay_slots): Likewise.\n        (fill_eager_delay_slots, relax_delay_slots, dbr_schedule): Likewise.\n\nFrom-SVN: r7452", "tree": {"sha": "9ada8dc73a09377ab6597e86279771aff5a63b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ada8dc73a09377ab6597e86279771aff5a63b15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3480bb98425cfd31e76057ad52e7a039dee20a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3480bb98425cfd31e76057ad52e7a039dee20a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3480bb98425cfd31e76057ad52e7a039dee20a79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3480bb98425cfd31e76057ad52e7a039dee20a79/comments", "author": null, "committer": null, "parents": [{"sha": "36e2f858ba48aa9230e081ac48f69ae11fd623f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36e2f858ba48aa9230e081ac48f69ae11fd623f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36e2f858ba48aa9230e081ac48f69ae11fd623f1"}], "stats": {"total": 67, "additions": 56, "deletions": 11}, "files": [{"sha": "05938d2aba1f6d0caf306bf8a1a5740408a1de89", "filename": "gcc/jump.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3480bb98425cfd31e76057ad52e7a039dee20a79/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3480bb98425cfd31e76057ad52e7a039dee20a79/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=3480bb98425cfd31e76057ad52e7a039dee20a79", "patch": "@@ -566,6 +566,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t  rtx temp, temp1, temp2, temp3, temp4, temp5, temp6;\n \t  rtx nlabel;\n \t  int this_is_simplejump, this_is_condjump, reversep;\n+\t  int this_is_condjump_in_parallel;\n #if 0\n \t  /* If NOT the first iteration, if this is the last jump pass\n \t     (just before final), do the special peephole optimizations.\n@@ -605,6 +606,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t  this_is_simplejump = simplejump_p (insn);\n \t  this_is_condjump = condjump_p (insn);\n+\t  this_is_condjump_in_parallel = condjump_in_parallel_p (insn);\n \n \t  /* Tension the labels in dispatch tables.  */\n \n@@ -1644,7 +1646,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t    }\n \t  /* Detect a conditional jump jumping over an unconditional jump.  */\n \n-\t  else if (this_is_condjump && ! this_is_simplejump\n+\t  else if ((this_is_condjump || this_is_condjump_in_parallel)\n+\t\t   && ! this_is_simplejump\n \t\t   && reallabelprev != 0\n \t\t   && GET_CODE (reallabelprev) == JUMP_INSN\n \t\t   && prev_active_insn (reallabelprev) == insn\n@@ -2830,6 +2833,39 @@ condjump_p (insn)\n   return 0;\n }\n \n+/* Return nonzero if INSN is a (possibly) conditional jump\n+   and nothing more.  */\n+\n+int\n+condjump_in_parallel_p (insn)\n+     rtx insn;\n+{\n+  register rtx x = PATTERN (insn);\n+\n+  if (GET_CODE (x) != PARALLEL)\n+    return 0;\n+  else\n+    x = XVECEXP (x, 0, 0);\n+\n+  if (GET_CODE (x) != SET)\n+    return 0;\n+  if (GET_CODE (SET_DEST (x)) != PC)\n+    return 0;\n+  if (GET_CODE (SET_SRC (x)) == LABEL_REF)\n+    return 1;\n+  if (GET_CODE (SET_SRC (x)) != IF_THEN_ELSE)\n+    return 0;\n+  if (XEXP (SET_SRC (x), 2) == pc_rtx\n+      && (GET_CODE (XEXP (SET_SRC (x), 1)) == LABEL_REF\n+\t  || GET_CODE (XEXP (SET_SRC (x), 1)) == RETURN))\n+    return 1;\n+  if (XEXP (SET_SRC (x), 1) == pc_rtx\n+      && (GET_CODE (XEXP (SET_SRC (x), 2)) == LABEL_REF\n+\t  || GET_CODE (XEXP (SET_SRC (x), 2)) == RETURN))\n+    return 1;\n+  return 0;\n+}\n+\n /* Return 1 if X is an RTX that does nothing but set the condition codes\n    and CLOBBER or USE registers.\n    Return -1 if X does explicitly set the condition codes,"}, {"sha": "343f4b7035d6a6dafd997560ccfbf5c6eb7da800", "filename": "gcc/reorg.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3480bb98425cfd31e76057ad52e7a039dee20a79/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3480bb98425cfd31e76057ad52e7a039dee20a79/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=3480bb98425cfd31e76057ad52e7a039dee20a79", "patch": "@@ -1194,7 +1194,7 @@ get_jump_flags (insn, label)\n      If LABEL is zero, then there is no way to determine the branch\n      direction.  */\n   if (GET_CODE (insn) == JUMP_INSN\n-      && condjump_p (insn)\n+      && (condjump_p (insn) || condjump_in_parallel_p (insn))\n       && INSN_UID (insn) <= max_uid\n       && label != 0\n       && INSN_UID (label) <= max_uid)\n@@ -1210,7 +1210,7 @@ get_jump_flags (insn, label)\n \n      Non conditional branches are predicted as very likely taken.  */\n   if (GET_CODE (insn) == JUMP_INSN\n-      && condjump_p (insn))\n+      && (condjump_p (insn) || condjump_in_parallel_p (insn)))\n     {\n       int prediction;\n \n@@ -1403,6 +1403,9 @@ get_branch_condition (insn, target)\n   rtx pat = PATTERN (insn);\n   rtx src;\n   \n+  if (condjump_in_parallel_p (insn))\n+    pat = XVECEXP (pat, 0, 0);\n+\n   if (GET_CODE (pat) == RETURN)\n     return target == 0 ? const_true_rtx : 0;\n \n@@ -2868,7 +2871,8 @@ fill_simple_delay_slots (first, non_jumps_p)\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n       if (slots_filled != slots_to_fill\n \t  && delay_list == 0\n-\t  && GET_CODE (insn) == JUMP_INSN && condjump_p (insn))\n+\t  && GET_CODE (insn) == JUMP_INSN \n+\t  && (condjump_p (insn) || condjump_in_parallel_p (insn)))\n \t{\n \t  delay_list = optimize_skip (insn);\n \t  if (delay_list)\n@@ -2893,7 +2897,8 @@ fill_simple_delay_slots (first, non_jumps_p)\n \n       if (slots_filled != slots_to_fill\n           && (GET_CODE (insn) != JUMP_INSN\n-\t      || (condjump_p (insn) && ! simplejump_p (insn)\n+\t      || ((condjump_p (insn) || condjump_in_parallel_p (insn))\n+\t\t   && ! simplejump_p (insn)\n \t\t   && JUMP_LABEL (insn) != 0)))\n \t{\n \t  rtx target = 0;\n@@ -3546,7 +3551,7 @@ fill_eager_delay_slots (first)\n       if (insn == 0\n \t  || INSN_DELETED_P (insn)\n \t  || GET_CODE (insn) != JUMP_INSN\n-\t  || ! condjump_p (insn))\n+\t  || ! (condjump_p (insn) || condjump_in_parallel_p (insn)))\n \tcontinue;\n \n       slots_to_fill = num_delay_slots (insn);\n@@ -3659,7 +3664,7 @@ relax_delay_slots (first)\n \t the next insn, or jumps to a label that is not the last of a\n \t group of consecutive labels.  */\n       if (GET_CODE (insn) == JUMP_INSN\n-\t  && condjump_p (insn)\n+\t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && (target_label = JUMP_LABEL (insn)) != 0)\n \t{\n \t  target_label = follow_jumps (target_label);\n@@ -3668,7 +3673,8 @@ relax_delay_slots (first)\n \t  if (target_label == 0)\n \t    target_label = find_end_label ();\n \n-\t  if (next_active_insn (target_label) == next)\n+\t  if (next_active_insn (target_label) == next\n+\t      && ! condjump_in_parallel_p (insn))\n \t    {\n \t      delete_jump (insn);\n \t      continue;\n@@ -3725,7 +3731,7 @@ relax_delay_slots (first)\n       if (GET_CODE (insn) == JUMP_INSN\n \t  && (simplejump_p (insn) || GET_CODE (PATTERN (insn)) == RETURN)\n \t  && (other = prev_active_insn (insn)) != 0\n-\t  && condjump_p (other)\n+\t  && (condjump_p (other) || condjump_in_parallel_p (other))\n \t  && no_labels_between_p (other, insn)\n \t  && 0 < mostly_true_jump (other,\n \t\t\t\t   get_branch_condition (other,\n@@ -3766,7 +3772,8 @@ relax_delay_slots (first)\n \n       /* Now look only at the cases where we have a filled JUMP_INSN.  */\n       if (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) != JUMP_INSN\n-\t  || ! condjump_p (XVECEXP (PATTERN (insn), 0, 0)))\n+\t  || ! (condjump_p (XVECEXP (PATTERN (insn), 0, 0))\n+\t\t|| condjump_in_parallel_p (XVECEXP (PATTERN (insn), 0, 0))))\n \tcontinue;\n \n       target_label = JUMP_LABEL (delay_insn);\n@@ -3828,6 +3835,7 @@ relax_delay_slots (first)\n \n       if (! INSN_ANNULLED_BRANCH_P (delay_insn)\n \t  && prev_active_insn (target_label) == insn\n+\t  && ! condjump_in_parallel_p (delay_insn)\n #ifdef HAVE_cc0\n \t  /* If the last insn in the delay slot sets CC0 for some insn,\n \t     various code assumes that it is in a delay slot.  We could\n@@ -4110,7 +4118,8 @@ dbr_schedule (first, file)\n \tobstack_ptr_grow (&unfilled_slots_obstack, insn);\n \n       /* Ensure all jumps go to the last of a set of consecutive labels.  */\n-      if (GET_CODE (insn) == JUMP_INSN && condjump_p (insn)\n+      if (GET_CODE (insn) == JUMP_INSN \n+\t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && JUMP_LABEL (insn) != 0\n \t  && ((target = prev_label (next_active_insn (JUMP_LABEL (insn))))\n \t      != JUMP_LABEL (insn)))"}]}