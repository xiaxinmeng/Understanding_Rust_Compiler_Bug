{"sha": "04dd734b52de121853e1ea6b3c197a598b294e23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRkZDczNGI1MmRlMTIxODUzZTFlYTZiM2MxOTdhNTk4YjI5NGUyMw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gmail.com", "date": "2020-03-27T16:07:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-03-27T16:08:18Z"}, "message": "c++: avoid -Wredundant-tags on a first declaration in use [PR 93824]\n\n-Wredundant-tags doesn't consider type declarations that are also\nthe first uses of the type, such as in 'void f (struct S);' and\nissues false positives for those.  According to the reported that's\nmaking it harder to use the warning to clean up LibreOffice.\n\nThe attached patch extends -Wredundant-tags to avoid these false\npositives by relying on the same class_decl_loc_t::class2loc mapping\nas -Wmismatched-tags.  The patch also improves the detection\nof both issues in template declarations.\n\ngcc/cp/ChangeLog\n2020-03-27  Martin Sebor  <msebor@redhat.com>\n\n\tPR c++/94078\n\tPR c++/93824\n\tPR c++/93810\n\t* cp-tree.h (most_specialized_partial_spec): Declare.\n\t* parser.c (cp_parser_elaborated_type_specifier): Distinguish alias\n\tfrom declarations.\n\t(specialization_of): New function.\n\t(cp_parser_check_class_key): Move code...\n\t(class_decl_loc_t::add): ...to here.  Add parameters.  Avoid issuing\n\t-Wredundant-tags on first-time declarations in other declarators.\n\tCorrect handling of template specializations.\n\t(class_decl_loc_t::diag_mismatched_tags): Also expect to be called\n\twhen -Wredundant-tags is enabled.  Use primary template or partial\n\tspecialization as the guide for uses of implicit instantiations.\n\t* pt.c (most_specialized_partial_spec): Declare extern.\n\ngcc/testsuite/ChangeLog\n2020-03-27  Martin Sebor  <msebor@redhat.com>\n\n\tPR c++/94078\n\tPR c++/93824\n\tPR c++/93810\n\t* g++.dg/warn/Wmismatched-tags-3.C: New test.\n\t* g++.dg/warn/Wmismatched-tags-4.C: New test.\n\t* g++.dg/warn/Wmismatched-tags-5.C: New test.\n\t* g++.dg/warn/Wmismatched-tags-6.C: New test.\n\t* g++.dg/warn/Wredundant-tags-3.C: Remove xfails.\n\t* g++.dg/warn/Wredundant-tags-6.C: New test.\n\t* g++.dg/warn/Wredundant-tags-7.C: New test.", "tree": {"sha": "a616c0615d955949ed65701bfa024982698473f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a616c0615d955949ed65701bfa024982698473f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04dd734b52de121853e1ea6b3c197a598b294e23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04dd734b52de121853e1ea6b3c197a598b294e23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04dd734b52de121853e1ea6b3c197a598b294e23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04dd734b52de121853e1ea6b3c197a598b294e23/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dba60130dc3ebf7cce8716a36672281688693f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dba60130dc3ebf7cce8716a36672281688693f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dba60130dc3ebf7cce8716a36672281688693f7"}], "stats": {"total": 691, "additions": 614, "deletions": 77}, "files": [{"sha": "2a2e6eac7bf681ccb766afa434248d6e15f52648", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -1,3 +1,21 @@\n+2020-03-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/94078\n+\tPR c++/93824\n+\tPR c++/93810\n+\t* cp-tree.h (most_specialized_partial_spec): Declare.\n+\t* parser.c (cp_parser_elaborated_type_specifier): Distinguish alias\n+\tfrom declarations.\n+\t(specialization_of): New function.\n+\t(cp_parser_check_class_key): Move code...\n+\t(class_decl_loc_t::add): ...to here.  Add parameters.  Avoid issuing\n+\t-Wredundant-tags on first-time declarations in other declarators.\n+\tCorrect handling of template specializations.\n+\t(class_decl_loc_t::diag_mismatched_tags): Also expect to be called\n+\twhen -Wredundant-tags is enabled.  Use primary template or partial\n+\tspecialization as the guide for uses of implicit instantiations.\n+\t* pt.c (most_specialized_partial_spec): Declare extern.\n+\n 2020-03-27  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/94257"}, {"sha": "af7734584136a926f8bec5026b194b2919ef2cac", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -6947,6 +6947,7 @@ extern int comp_template_args\t\t\t(tree, tree, tree * = NULL,\n extern int template_args_equal                  (tree, tree, bool = false);\n extern tree maybe_process_partial_specialization (tree);\n extern tree most_specialized_instantiation\t(tree);\n+extern tree most_specialized_partial_spec       (tree, tsubst_flags_t);\n extern void print_candidates\t\t\t(tree);\n extern void instantiate_pending_templates\t(int);\n extern tree tsubst_default_argument\t\t(tree, int, tree, tree,"}, {"sha": "3ca8eb9baf8b5249ec107f88fbe88b9e9f33f33d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 160, "deletions": 72, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -19006,9 +19006,12 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n     cp_parser_maybe_warn_enum_key (parser, key_loc, type, scoped_key);\n   else\n     {\n-      /* Diagnose class/struct/union mismatches.  */\n+      /* Diagnose class/struct/union mismatches.  IS_DECLARATION is false\n+\t for alias definition.  */\n+      bool decl_class = (is_declaration\n+\t\t\t && cp_parser_declares_only_class_p (parser));\n       cp_parser_check_class_key (parser, key_loc, tag_type, type, false,\n-\t\t\t\t cp_parser_declares_only_class_p (parser));\n+\t\t\t\t decl_class);\n \n       /* Indicate whether this class was declared as a `class' or as a\n \t `struct'.  */\n@@ -30991,8 +30994,9 @@ class class_decl_loc_t\n   /* Issues -Wmismatched-tags for all classes.  */\n   static void diag_mismatched_tags ();\n \n-  /* Adds TYPE_DECL to the collection of class decls.  */\n-  static void add (tree, tag_types, bool, bool);\n+  /* Adds TYPE_DECL to the collection of class decls and diagnoses\n+     redundant tags (if -Wredundant-tags is enabled).  */\n+  static void add (cp_parser *, location_t, tag_types, tree, bool, bool);\n \n   /* Either adds this decl to the collection of class decls\n      or diagnoses it, whichever is appropriate.  */\n@@ -31020,12 +31024,19 @@ class class_decl_loc_t\n     return locvec[i].class_key;\n   }\n \n+  /* True if a definition for the class has been seen.  */\n+  bool def_p () const\n+  {\n+    return idxdef < locvec.length ();\n+  }\n+\n   /* The location of a single mention of a class type with the given\n      class-key.  */\n   struct class_key_loc_t\n   {\n     class_key_loc_t (tree func, location_t loc, tag_types key, bool redundant)\n-      : func (func), loc (loc), class_key (key), key_redundant (redundant) { }\n+      : func (func), loc (loc), class_key (key), key_redundant (redundant)\n+    { }\n \n     /* The function the type is mentioned in.  */\n     tree func;\n@@ -31088,6 +31099,40 @@ cp_parser_check_class_key (cp_parser *parser, location_t key_loc,\n       && class_key != union_type)\n     return;\n \n+  class_decl_loc_t::add (parser, key_loc, class_key, type, def_p, decl_p);\n+}\n+\n+/* Returns the template or specialization of one to which the RECORD_TYPE\n+   TYPE corresponds.  */\n+\n+static tree\n+specialization_of (tree type)\n+{\n+  tree ret = type;\n+\n+  /* Determine the template or its partial specialization to which TYPE\n+     corresponds.  */\n+  if (tree spec = most_specialized_partial_spec (type, tf_none))\n+    if (spec != error_mark_node)\n+      ret = TREE_TYPE (TREE_VALUE (spec));\n+\n+  if (ret == type)\n+    ret = CLASSTYPE_PRIMARY_TEMPLATE_TYPE (type);\n+\n+  return TYPE_MAIN_DECL (ret);\n+}\n+\n+\n+/* Adds the class TYPE to the collection of class decls and diagnoses\n+   redundant tags (if -Wredundant-tags is enabled).\n+   DEF_P is expected to be set for a definition of class TYPE.  DECL_P\n+   is set for a (likely, based on syntactic context) declaration of class\n+   TYPE and clear for a reference to it that is not a declaration of it.  */\n+\n+void\n+class_decl_loc_t::add (cp_parser *parser, location_t key_loc,\n+\t\t       tag_types class_key, tree type, bool def_p, bool decl_p)\n+{\n   tree type_decl = TYPE_MAIN_DECL (type);\n   tree name = DECL_NAME (type_decl);\n   /* Look up the NAME to see if it unambiguously refers to the TYPE\n@@ -31099,7 +31144,10 @@ cp_parser_check_class_key (cp_parser *parser, location_t key_loc,\n   /* The class-key is redundant for uses of the CLASS_TYPE that are\n      neither definitions of it nor declarations, and for which name\n      lookup returns just the type itself.  */\n-  bool key_redundant = !def_p && !decl_p && decl == type_decl;\n+  bool key_redundant = (!def_p && !decl_p\n+\t\t\t&& (decl == type_decl\n+\t\t\t    || TREE_CODE (decl) == TEMPLATE_DECL\n+\t\t\t    || TYPE_BEING_DEFINED (type)));\n \n   if (key_redundant\n       && class_key != class_type\n@@ -31117,29 +31165,8 @@ cp_parser_check_class_key (cp_parser *parser, location_t key_loc,\n \tkey_redundant = false;\n     }\n \n-  if (key_redundant)\n-    {\n-      gcc_rich_location richloc (key_loc);\n-      richloc.add_fixit_remove (key_loc);\n-      warning_at (&richloc, OPT_Wredundant_tags,\n-\t\t  \"redundant class-key %qs in reference to %q#T\",\n-\t\t  class_key == union_type ? \"union\"\n-\t\t  : class_key == record_type ? \"struct\" : \"class\",\n-\t\t  type);\n-    }\n-\n-  if (seen_as_union || !warn_mismatched_tags)\n-    return;\n-\n-  class_decl_loc_t::add (type_decl, class_key, key_redundant, def_p);\n-}\n-\n-/* Adds TYPE_DECL to the collection of class decls.  */\n-\n-void\n-class_decl_loc_t::add (tree type_decl, tag_types class_key, bool redundant,\n-\t\t       bool def_p)\n-{\n+  /* Set if a declaration of TYPE has previously been seen or if it must\n+     exist in a precompiled header.  */\n   bool exist;\n   class_decl_loc_t *rdl = &class2loc.get_or_insert (type_decl, &exist);\n   if (!exist)\n@@ -31149,30 +31176,52 @@ class_decl_loc_t::add (tree type_decl, tag_types class_key, bool redundant,\n \t{\n \t  /* TYPE_DECL is the first declaration or definition of the type\n \t     (outside precompiled headers -- see below).  Just create\n-\t     a new entry for it.  */\n+\t     a new entry for it and return unless it's a declaration\n+\t     involving a template that may need to be diagnosed by\n+\t     -Wredundant-tags.  */\n \t  *rdl = class_decl_loc_t (class_key, false, def_p);\n-\t  return;\n+\t  if (TREE_CODE (decl) != TEMPLATE_DECL)\n+\t    return;\n+\t}\n+      else\n+\t{\n+\t  /* TYPE was previously defined in some unknown precompiled hdeader.\n+\t     Simply add a record of its definition at an unknown location and\n+\t     proceed below to add a reference to it at the current location.\n+\t     (Declarations in precompiled headers that are not definitions\n+\t     are ignored.)  */\n+\t  tag_types def_key\n+\t    = CLASSTYPE_DECLARED_CLASS (type) ? class_type : record_type;\n+\t  location_t def_loc = DECL_SOURCE_LOCATION (type_decl);\n+\t  *rdl = class_decl_loc_t (def_key, false, true, def_loc);\n+\t  exist = true;\n \t}\n-\n-      /* TYPE was previously defined in some unknown precompiled hdeader.\n-\t Simply add a record of its definition at an unknown location and\n-\t proceed below to add a reference to it at the current location.\n-\t (Declarations in precompiled headers that are not definitions\n-\t are ignored.)  */\n-      tag_types def_key\n-\t= CLASSTYPE_DECLARED_CLASS (type) ? class_type : record_type;\n-      location_t def_loc = DECL_SOURCE_LOCATION (type_decl);\n-      *rdl = class_decl_loc_t (def_key, false, true, def_loc);\n     }\n \n   /* A prior declaration of TYPE_DECL has been seen.  */\n \n+  if (key_redundant)\n+    {\n+      gcc_rich_location richloc (key_loc);\n+      richloc.add_fixit_remove (key_loc);\n+      warning_at (&richloc, OPT_Wredundant_tags,\n+\t\t  \"redundant class-key %qs in reference to %q#T\",\n+\t\t  class_key == union_type ? \"union\"\n+\t\t  : class_key == record_type ? \"struct\" : \"class\",\n+\t\t  type);\n+    }\n+\n+  if (!exist)\n+    /* Do nothing if this is the first declaration of the type.  */\n+    return;\n+\n   if (rdl->idxdef != UINT_MAX && rdl->def_class_key == class_key)\n     /* Do nothing if the class-key in this declaration matches\n        the definition.  */\n     return;\n \n-  rdl->add_or_diag_mismatched_tag (type_decl, class_key, redundant, def_p);\n+  rdl->add_or_diag_mismatched_tag (type_decl, class_key, key_redundant,\n+\t\t\t\t   def_p);\n }\n \n /* Either adds this DECL corresponding to the TYPE_DECL to the collection\n@@ -31225,35 +31274,70 @@ class_decl_loc_t::add_or_diag_mismatched_tag (tree type_decl,\n void\n class_decl_loc_t::diag_mismatched_tags (tree type_decl)\n {\n-  unsigned ndecls = locvec.length ();\n-\n-  /* Skip a declaration that consistently uses the same class-key\n-     or one with just a solitary declaration (i.e., TYPE_DECL).  */\n-  if (def_class_key != none_type || ndecls < 2)\n+  if (!warn_mismatched_tags)\n     return;\n \n-  /* Save the current function before changing it below.  */\n-  tree save_func = current_function_decl;\n-  /* Set if a class definition for RECLOC has been seen.  */\n-  bool def_p = idxdef < ndecls;\n-  unsigned idxguide = def_p ? idxdef : 0;\n+  /* Number of uses of the class.  */\n+  const unsigned ndecls = locvec.length ();\n+\n+  /* The class (or template) declaration guiding the decisions about\n+     the diagnostic.  For ordinary classes it's the same as THIS.  For\n+     uses of instantiations of templates other than their declarations\n+     it points to the record for the declaration of the corresponding\n+     primary template or partial specialization.  */\n+  class_decl_loc_t *cdlguide = this;\n+\n+  tree type = TREE_TYPE (type_decl);\n+  if (CLASSTYPE_IMPLICIT_INSTANTIATION (type))\n+    {\n+      /* For implicit instantiations of a primary template look up\n+\t the primary or partial specialization and use it as\n+\t the expected class-key rather than using the class-key of\n+\t the first reference to the instantiation.  The primary must\n+\t be (and inevitably is) at index zero.  */\n+      tree spec = specialization_of (type);\n+      cdlguide = class2loc.get (spec);\n+      gcc_assert (cdlguide != NULL);\n+    }\n+  else\n+    {\n+      /* Skip declarations that consistently use the same class-key.  */\n+      if (def_class_key != none_type)\n+\treturn;\n+    }\n+\n+  /* Set if a definition for the class has been seen.  */\n+  const bool def_p = cdlguide->def_p ();\n+\n+  /* The index of the declaration whose class-key this declaration\n+     is expected to match.  It's either the class-key of the class\n+     definition if one exists or the first declaration otherwise.  */\n+  const unsigned idxguide = def_p ? cdlguide->idxdef : 0;\n+\n+  /* The class-key the class is expected to be declared with: it's\n+     either the key used in its definition or the first declaration\n+     if no definition has been provided.\n+     For implicit instantiations of a primary template it's\n+     the class-key used to declare the primary with.  The primary\n+     must be at index zero.  */\n+  const tag_types xpect_key = cdlguide->class_key (idxguide);\n+\n   unsigned idx = 0;\n   /* Advance IDX to the first declaration that either is not\n      a definition or that doesn't match the first declaration\n      if no definition is provided.  */\n-  while (class_key (idx) == class_key (idxguide))\n+  while (class_key (idx) == xpect_key)\n     if (++idx == ndecls)\n       return;\n \n-  /* The class-key the class is expected to be declared with: it's\n-     either the key used in its definition or the first declaration\n-     if no definition has been provided.  */\n-  tag_types xpect_key = class_key (def_p ? idxguide : 0);\n-  const char *xmatchkstr = xpect_key == record_type ? \"class\" : \"struct\";\n-  const char *xpectkstr = xpect_key == record_type ? \"struct\" : \"class\";\n+  /* Save the current function before changing it below.  */\n+  tree save_func = current_function_decl;\n   /* Set the function declaration to print in diagnostic context.  */\n   current_function_decl = function (idx);\n \n+  const char *xmatchkstr = xpect_key == record_type ? \"class\" : \"struct\";\n+  const char *xpectkstr = xpect_key == record_type ? \"struct\" : \"class\";\n+\n   location_t loc = location (idx);\n   bool key_redundant_p = key_redundant (idx);\n   auto_diagnostic_group d;\n@@ -31274,7 +31358,7 @@ class_decl_loc_t::diag_mismatched_tags (tree type_decl)\n \n   /* Also point to the first declaration or definition that guided\n      the decision to issue the warning above.  */\n-  inform (location (idxguide),\n+  inform (cdlguide->location (idxguide),\n \t  (def_p\n \t   ? G_(\"%qT defined as %qs here\")\n \t   : G_(\"%qT first declared as %qs here\")),\n@@ -31316,25 +31400,29 @@ class_decl_loc_t::diag_mismatched_tags (tree type_decl)\n void\n class_decl_loc_t::diag_mismatched_tags ()\n {\n-  /* CLASS2LOC should be empty if -Wmismatched-tags is disabled.  */\n-  gcc_assert (warn_mismatched_tags || class2loc.is_empty ());\n+  /* CLASS2LOC should be empty if both -Wmismatched-tags and\n+     -Wredundant-tags are disabled.  */\n+  gcc_assert (warn_mismatched_tags\n+\t      || warn_redundant_tags\n+\t      || class2loc.is_empty ());\n \n-  /* Save the current function before changing it below.  It should\n+  /* Save the current function before changing on return.  It should\n      be null at this point.  */\n-  tree save_func = current_function_decl;\n+  temp_override<tree> cleanup (current_function_decl);\n \n-  /* Iterate over the collected class/struct declarations.  */\n-  typedef class_to_loc_map_t::iterator iter_t;\n-  for (iter_t it = class2loc.begin (); it != class2loc.end (); ++it)\n+  if (warn_mismatched_tags)\n     {\n-      tree type_decl = (*it).first;\n-      class_decl_loc_t &recloc = (*it).second;\n-      recloc.diag_mismatched_tags (type_decl);\n+      /* Iterate over the collected class/struct/template declarations.  */\n+      typedef class_to_loc_map_t::iterator iter_t;\n+      for (iter_t it = class2loc.begin (); it != class2loc.end (); ++it)\n+\t{\n+\t  tree type_decl = (*it).first;\n+\t  class_decl_loc_t &recloc = (*it).second;\n+\t  recloc.diag_mismatched_tags (type_decl);\n+\t}\n     }\n \n   class2loc.empty ();\n-  /* Restore the current function.  */\n-  current_function_decl = save_func;\n }\n \n /* Issue an error message if DECL is redeclared with different"}, {"sha": "15b54396ed3103d941038a2e74ce623be6a73054", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -185,7 +185,7 @@ static int unify_pack_expansion (tree, tree, tree,\n \t\t\t\t tree, unification_kind_t, bool, bool);\n static tree copy_template_args (tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n-static tree most_specialized_partial_spec (tree, tsubst_flags_t);\n+tree most_specialized_partial_spec (tree, tsubst_flags_t);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n static tree tsubst_arg_types (tree, tree, tree, tsubst_flags_t, tree);\n static tree tsubst_function_type (tree, tree, tsubst_flags_t, tree);\n@@ -24332,7 +24332,7 @@ most_general_template (tree decl)\n    partial specializations matching TARGET, then NULL_TREE is\n    returned, indicating that the primary template should be used.  */\n \n-static tree\n+tree\n most_specialized_partial_spec (tree target, tsubst_flags_t complain)\n {\n   tree list = NULL_TREE;"}, {"sha": "1de6c7ab2351491afd5266066af81b0d2405e287", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -1,3 +1,16 @@\n+2020-03-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/94078\n+\tPR c++/93824\n+\tPR c++/93810\n+\t* g++.dg/warn/Wmismatched-tags-3.C: New test.\n+\t* g++.dg/warn/Wmismatched-tags-4.C: New test.\n+\t* g++.dg/warn/Wmismatched-tags-5.C: New test.\n+\t* g++.dg/warn/Wmismatched-tags-6.C: New test.\n+\t* g++.dg/warn/Wredundant-tags-3.C: Remove xfails.\n+\t* g++.dg/warn/Wredundant-tags-6.C: New test.\n+\t* g++.dg/warn/Wredundant-tags-7.C: New test.\n+\n 2020-03-27  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/analyzer/data-model-5b.c: Add xfail for new false"}, {"sha": "ecbe66d037ebf9981c3d049ec1e8cad61c33e7d5", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-tags-3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-3.C?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile }\n+   { dg-options \"-Wall -Wmismatched-tags\" } */\n+\n+extern class C1 c1;             // { dg-message \"declared as 'class'\" }\n+extern struct C1 c1;            // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+void fs1 (struct S1);           // { dg-message \"declared as 'struct'\" }\n+void fs1 (class S1);            // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+enum\n+{\n+  ec2 = sizeof (struct C2*),    // { dg-message \"declared as 'struct'\" }\n+  fc2 = sizeof (class C2*)      // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+};"}, {"sha": "7570264b1d33b5228a17b29dbbec4774bdef5aa1", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-tags-4.C", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-4.C?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -0,0 +1,141 @@\n+/* PR c++/94078 - bogus and missing -Wmismatched-tags on an instance\n+   of a template\n+   Verify that -Wmismatched-tags is issued for redeclarations and\n+   instances of the appropriate primary template or specialization.\n+  { dg-do compile }\n+  { dg-options \"-Wmismatched-tags\" } */\n+\n+// Exercise explicit specialization.\n+template <class> class S1;\n+template <>      struct S1<int>;\n+\n+template <class> class S1;\n+template <class> struct S1;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+template <>      class S1<char>;\n+template <>      struct S1<char>;     // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+template <>      class S1<int>;       // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+template <>      struct S1<int>;\n+\n+extern        S1<void> s1v;\n+extern class  S1<void> s1v;\n+extern struct S1<void> s1v;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+extern        S1<int> s1i;\n+extern class  S1<int> s1i;            // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S1<int> s1i;\n+\n+extern        S1<char> s1c;\n+extern class  S1<char> s1c;\n+extern struct S1<char> s1c;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+\n+// Exercise partial specialization.\n+template <class>   struct S2;\n+template <class T> class S2<const T>;\n+\n+template <class>   class S2;          // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+template <class>   struct S2;\n+\n+template <class T> class S2<const T>;\n+template <class T> struct S2<const T>;// { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+extern        S2<int> s2i;\n+extern class  S2<int> s2i;            // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S2<int> s2i;\n+\n+extern        S2<const int> s2ci;\n+extern class  S2<const int> s2ci;\n+extern struct S2<const int> s2ci;     // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+\n+template <class>   struct S3;\n+template <class T> class S3<T*>;\n+template <class T> struct S3<T&>;\n+\n+template <class>   class S3;          // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+template <class>   struct S3;\n+\n+template <class T> class S3<T*>;\n+template <class T> struct S3<T*>;     // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+template <class T> class S3<T&>;      // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+template <class T> struct S3<T&>;\n+\n+extern        S3<int> s3i;\n+extern class  S3<int> s3i;            // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S3<int> s3i;\n+\n+extern        S3<int*> s3p;\n+extern class  S3<int*> s3p;\n+extern struct S3<int*> s3p;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+extern        S3<int&> s3r;\n+extern class  S3<int&> s3r;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S3<int&> s3r;\n+\n+// Repeat exactly the same as above.\n+extern        S3<int> s3i;\n+extern class  S3<int> s3i;            // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S3<int> s3i;\n+\n+extern        S3<int*> s3p;\n+extern class  S3<int*> s3p;\n+extern struct S3<int*> s3p;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+extern        S3<int&> s3r;\n+extern class  S3<int&> s3r;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S3<int&> s3r;\n+\n+// Repeat the same as above just with different type.\n+extern        S3<long> s3l;\n+extern class  S3<long> s3l;           // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S3<long> s3l;\n+\n+extern        S3<long*> s3lp;\n+extern class  S3<long*> s3lp;\n+extern struct S3<long*> s3lp;         // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+extern        S3<long&> s3lr;\n+extern class  S3<long&> s3lr;         // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct S3<long&> s3lr;\n+\n+// Repeat with the class-keys swapped.\n+extern        S3<long> s3l;\n+extern struct S3<long> s3l;\n+extern class  S3<long> s3l;          // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+extern        S3<long*> s3lp;\n+extern struct S3<long*> s3lp;        // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern class  S3<long*> s3lp;\n+\n+extern        S3<long&> s3lr;\n+extern struct S3<long&> s3lr;\n+extern class  S3<long&> s3lr;        // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+\n+namespace N\n+{\n+template <class> struct A;\n+\n+extern class A<int> ai;               // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct A<int> ai;\n+\n+typedef class A<int> AI;              // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+typedef struct A<int> AI;\n+\n+template <class> struct B;\n+template <> class B<int>;\n+template <> struct B<char>;\n+\n+extern class B<int> bi;\n+extern struct B<int> bi;              // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+\n+extern class B<char> bc;              // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+extern struct B<char> bc;\n+\n+typedef class B<char> BC;             // { dg-warning \"\\\\\\[-Wmismatched-tags\" }\n+typedef struct B<char> BC;\n+\n+}"}, {"sha": "622b9e386ab9c3c0d42337393a6ff2c22e01f899", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-tags-5.C", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-5.C?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -0,0 +1,117 @@\n+/* PR c++/93810 - missing -Wmismatched-tags and -Wredundant-tags on a typedef\n+   of an implicit class template specialization\n+  { dg-do compile }\n+  { dg-options \"-Wall -Wmismatched-tags\" }\n+  { dg-require-effective-target c++11 } */\n+\n+class A;                                // { dg-message \"declared as 'class'\" }\n+typedef        A A0;\n+typedef class  A A0;\n+typedef struct A A0;                    // { dg-warning \"-Wmismatched-tags\" }\n+\n+template <int> struct B;                // { dg-message \"declared as 'struct'\" }\n+typedef        B<0> B0;\n+typedef class  B<0> B0;                 // { dg-warning \"-Wmismatched-tags\" }\n+typedef struct B<0> B0;\n+\n+\n+// Exercise member types of templates with non-type arguments.\n+template <int> struct CN;               // { dg-message \"declared as 'struct'\" }\n+\n+template <int N>\n+struct X_CNp1 {\n+  typedef CN<N + 1> CNp1;\n+};\n+\n+template <int N>\n+struct X_class_CNp1 {\n+  typedef class CN<N + 1> CNp1;         // { dg-warning \"-Wmismatched-tags\" }\n+};\n+\n+template <int N>\n+struct X_struct_CNp1 {\n+  typedef struct CN<N + 1> CNp1;\n+};\n+\n+\n+// Exercise partial specialization of templates with member types.\n+template <class> class CT1;\n+template <class T> struct CT1<T*> { };\n+template <class T> struct CT1<T**> { };\n+template <class T> class  CT1<T***> { };\n+\n+template <class> struct CT2;\n+template <class T> struct CT2<T*> {\n+  // Expect class-key to match the primary.\n+         CT1<T> ct1_0;\n+  class  CT1<T> ct1_1;\n+  struct CT1<T> ct1_2;                  // { dg-warning \"-Wmismatched-tags\" }\n+\n+  // Expect class-key to match the CT1<T*> partial specialization.\n+         CT1<T*> ct1p1_0;\n+  class  CT1<T*> ct1p1_1;               // { dg-warning \"-Wmismatched-tags\" }\n+  struct CT1<T*> ct1p1_2;\n+\n+  // Expect class-key to match the CT1<T**> partial specialization.\n+         CT1<T**> ct1p2_0;\n+  class  CT1<T**> ct1p2_1;              // { dg-warning \"-Wmismatched-tags\" }\n+  struct CT1<T**> ct1p2_2;\n+\n+  // Expect class-key to match the CT1<T***> partial specialization.\n+         CT1<T***> ct1p3_0;\n+  class  CT1<T***> ct1p3_1;\n+  struct CT1<T***> ct1p3_2;             // { dg-warning \"-Wmismatched-tags\" }\n+\n+  // Expect class-key to still match the CT1<T***> partial specialization.\n+         CT1<T****> ct1p4_0;\n+  class  CT1<T****> ct1p4_1;\n+  struct CT1<T****> ct1p4_2;            // { dg-warning \"-Wmismatched-tags\" }\n+};\n+\n+// Exercise many partial specializations (since the class-key for each\n+// must be tracked separately from the others).\n+template <class>   class  D;\n+template <class T> struct D<T*>;\n+template <class T> class  D<T&>;\n+template <class T> struct D<const T*>;\n+template <class T> class  D<const T&>;\n+template <class T> struct D<volatile T*>;\n+template <class T> class  D<volatile T&>;\n+template <class T> struct D<const volatile T*>;\n+template <class T> class  D<const volatile T&>;\n+\n+typedef class  D<int*> DIP;             // { dg-warning \"-Wmismatched-tags\" }\n+typedef struct D<int*> DIP;\n+typedef class  D<int*> DIP;             // { dg-warning \"-Wmismatched-tags\" }\n+typedef struct D<int*> DIP;\n+\n+typedef class  D<int&>  DIR;\n+typedef struct D<int&> DIR;             // { dg-warning \"-Wmismatched-tags\" }\n+typedef class  D<int&>  DIR;\n+\n+\n+typedef struct D<const int*> DCIP;\n+typedef class  D<const int*> DCIP;      // { dg-warning \"-Wmismatched-tags\" }\n+typedef struct D<const int*> DCIP;\n+\n+typedef struct D<const int&> DCIR;      // { dg-warning \"-Wmismatched-tags\" }\n+typedef class  D<const int&>  DCIR;\n+typedef struct D<const int&> DCIR;      // { dg-warning \"-Wmismatched-tags\" }\n+\n+\n+typedef struct D<volatile int*> DVIP;\n+typedef class  D<volatile int*> DVIP;   // { dg-warning \"-Wmismatched-tags\" }\n+typedef struct D<volatile int*> DVIP;\n+\n+typedef struct D<volatile int&> DVIR;   // { dg-warning \"-Wmismatched-tags\" }\n+typedef class  D<volatile int&> DVIR;\n+typedef struct D<volatile int&> DVIR;   // { dg-warning \"-Wmismatched-tags\" }\n+\n+\n+typedef struct D<const volatile int*> DCVIP;\n+typedef class  D<const volatile int*> DCVIP;    // { dg-warning \"-Wmismatched-tags\" }\n+typedef struct D<const volatile int*> DCVIP;\n+\n+typedef struct D<const volatile int&> DCVIR;    // { dg-warning \"-Wmismatched-tags\" }\n+typedef class  D<const volatile int&> DCVIR;\n+typedef struct D<const volatile int&> DCVIR;    // { dg-warning \"-Wmismatched-tags\" }"}, {"sha": "d9d644c4226a5de25269a31a1cdc2a605dcd8aa7", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-tags-6.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-6.C?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -0,0 +1,29 @@\n+/* Verify -Wmismatched-tags on alias definitions.\n+   { dg-do compile { target c++11 } }\n+   { dg-options \"-Wall -Wmismatched-tags\" } */\n+\n+class A;                      // { dg-message \"declared as 'class'\" }\n+using AA =        A;\n+using AA = class  A;\n+using AA = struct A;          // { dg-warning \"-Wmismatched-tags\" }\n+\n+\n+template <class> class B;     // { dg-message \"declared as 'class'\" }\n+\n+using Bi =        B<int>;\n+using Bi = class  B<int>;\n+using Bi = struct B<int>;     // { dg-warning \"-Wmismatched-tags\" }\n+using Bi = class  B<int>;\n+using Bi = struct B<int>;     // { dg-warning \"-Wmismatched-tags\" }\n+\n+\n+template <class> class C;     // { dg-message \"declared as 'class'\" }\n+\n+template <class T> using Cp = C<T*>;\n+template <class T> using Cp = class C<T*>;\n+template <class T>\n+using Cp = struct C<T*>;      // { dg-warning \"-Wmismatched-tags\" }\n+\n+template <class T> using Cp = class  C<T*>;\n+template <class T>\n+using Cp = struct C<T*>;      // { dg-warning \"-Wmismatched-tags\" }"}, {"sha": "0eeee34dae7525f8d818788ca9e408239e022328", "filename": "gcc/testsuite/g++.dg/warn/Wredundant-tags-3.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-3.C?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -34,12 +34,12 @@ union N::U u3;        // { dg-warning \"-Wredundant-tags\" }\n \n typedef N::TC<0> TC0;\n typedef typename N::TC<0> TC0;\n-typedef class N::TC<0> TC0;   // { dg-warning \"-Wredundant-tags\" \"pr93809\" { xfail *-*-*} .-1 }\n+typedef class N::TC<0> TC0;   // { dg-warning \"-Wredundant-tags\" }\n \n typedef N::TS<0> TS0;\n typedef typename N::TS<0> TS0;\n-typedef struct N::TS<0> TS0;  // { dg-warning \"-Wredundant-tags\" \"pr93809\" { xfail *-*-*} .-1 }\n+typedef struct N::TS<0> TS0;  // { dg-warning \"-Wredundant-tags\" }\n \n typedef N::TS<0> TS0;\n typedef typename N::TS<0> TS0;\n-typedef struct N::TS<0> TS0;  // { dg-warning \"-Wredundant-tags\" \"pr93809\" { xfail *-*-*} .-1 }\n+typedef struct N::TS<0> TS0;  // { dg-warning \"-Wredundant-tags\" }"}, {"sha": "ce5cb967b795b7ab93b69878d702e4709e1b505a", "filename": "gcc/testsuite/g++.dg/warn/Wredundant-tags-6.C", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-6.C?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -0,0 +1,91 @@\n+/* PR c++/93824 - bogus -Wredundant-tags on a first declaration in use\n+   { dg-do compile }\n+   { dg-options \"-Wredundant-tags\" } */\n+\n+extern class C1 &c1;              // { dg-bogus \"\\\\\\[-Wredundant-tags\" }\n+extern class C1 &c1;              // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+void fc2 (class C2);              // { dg-bogus \"\\\\\\[-Wredundant-tags\" }\n+void fc2 (class C2);              // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+const int\n+npc3 = sizeof (class C3*);        // { dg-bogus \"\\\\\\[-Wredundant-tags\" }\n+const int\n+nppc3 = sizeof (class C3**);      // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+extern struct S1 *s1p;            // { dg-bogus \"\\\\\\[-Wredundant-tags\" }\n+extern struct S1 s1a[];           // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+struct S3\n+{\n+  struct S3 *p1s3;                // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+  S3 *p2s3;\n+\n+  union U1 *p1u1;                 // { dg-bogus \"\\\\\\[-Wredundant-tags\" }\n+  union U1 *p2u1;                 // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+} s3;\n+\n+typedef struct S3 T_S3;           // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+typedef struct S4 T_S4;\n+\n+struct S5\n+{\n+  struct S6\n+  {\n+  private:\n+    // 'struct' is redundant in a declaration of a pointer to ::S5;\n+    struct S5 *ps5;               // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+    // 'struct' is required in a definition of a new type.\n+    struct S5 { } *ps5_2;\n+    struct S5 *p2s5_2;            // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+  };\n+};\n+\n+\n+template <int> struct TS1;\n+\n+// Verify redeclaration with no definition.\n+template <> struct TS1<0>;\n+template <> struct TS1<0>;\n+\n+// Verify definition after a declaration and vice versa.\n+template <> struct TS1<1>;\n+template <> struct TS1<1> { };\n+template <> struct TS1<1>;\n+\n+// Verify typedefs of an explicit specialization with a definition.\n+typedef struct TS1<1> TS1_1;      // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+typedef        TS1<1> TS1_1;\n+typedef struct TS1<1> TS1_1;      // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+// Verify object declarations of an expplicit specialization.\n+extern struct TS1<1> ts1_1;      // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+extern        TS1<1> ts1_1;\n+extern struct TS1<1> ts1_1;      // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+// Verify typedefs of an implicit specialization without a definition.\n+typedef struct TS1<2> TS1_2;      // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+typedef        TS1<2> TS1_2;\n+typedef struct TS1<2> TS1_2;      // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+// Verify object declarations of an implicit specialization.\n+extern struct TS1<2> ts1_2;       // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+extern        TS1<2> ts1_2;\n+extern struct TS1<2> ts1_2;       // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+\n+\n+// Verify partial template specialization.\n+template <class> struct TS2;\n+template <class T> struct TS2<const T>;\n+template <class T> struct TS2<volatile T>;\n+\n+template <class T>\n+struct TS4\n+{\n+  typedef struct TS2<const T> TS2_CT1;   // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+  typedef        TS2<const T> TS2_CT2;\n+\n+  typedef struct TS2<T> TS2_T1;   // { dg-warning \"\\\\\\[-Wredundant-tags\" }\n+  typedef        TS2<T> TS2_T2;\n+};"}, {"sha": "872535b922143d786f78e5f5c234ed96e935f365", "filename": "gcc/testsuite/g++.dg/warn/Wredundant-tags-7.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04dd734b52de121853e1ea6b3c197a598b294e23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWredundant-tags-7.C?ref=04dd734b52de121853e1ea6b3c197a598b294e23", "patch": "@@ -0,0 +1,25 @@\n+/* Verify -Wmismatched-tags on alias definitions.\n+   { dg-do compile { target c++11 } }\n+   { dg-options \"-Wall -Wredundant-tags\" } */\n+\n+class A;\n+using AA =        A;\n+using AA = class  A;          // { dg-warning \"-Wredundant-tags\" }\n+using AA = struct A;          // { dg-warning \"-Wredundant-tags\" }\n+\n+\n+template <class> class B;\n+\n+using Bi =        B<int>;\n+using Bi = class  B<int>;     // { dg-warning \"-Wredundant-tags\" }\n+using Bi = struct B<int>;     // { dg-warning \"-Wredundant-tags\" }\n+\n+\n+template <class> class C;\n+\n+template <class T>\n+using Cp = C<T*>;\n+template <class T>\n+using Cp = class C<T*>;       // { dg-warning \"-Wredundant-tags\" }\n+template <class T>\n+using Cp = struct C<T*>;      // { dg-warning \"-Wredundant-tags\" }"}]}