{"sha": "ab10383aaebf2feebd2b6d68247f2520eff48f79", "node_id": "C_kwDOANBUbNoAKGFiMTAzODNhYWViZjJmZWViZDJiNmQ2ODI0N2YyNTIwZWZmNDhmNzk", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-10-26T17:50:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-10-26T23:11:26Z"}, "message": "compiler: permit compiler directives in parenthesized groups\n\nThe original compiler directive support was only for //line at the\nstart of a line and for //go: comments before function declarations.\nWhen support was added for //go:notinheap for types and //go:embed for\nvariables the code did not adapt to permit spaces before the comment\nor to permit the comments in var() or type() groups.  This change\ncorrects those omissions.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/358699", "tree": {"sha": "b7296e54620d4fbe3fef6d4ebad91a9bbe7065ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7296e54620d4fbe3fef6d4ebad91a9bbe7065ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab10383aaebf2feebd2b6d68247f2520eff48f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab10383aaebf2feebd2b6d68247f2520eff48f79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab10383aaebf2feebd2b6d68247f2520eff48f79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab10383aaebf2feebd2b6d68247f2520eff48f79/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "e7ff670556378283e4bf4277b767e41bee484934", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=ab10383aaebf2feebd2b6d68247f2520eff48f79", "patch": "@@ -1,4 +1,4 @@\n-925ace70ac7426c3f8b5c0bfb75aa9601f071de4\n+128ea3dce9b8753167f33d0a96bd093a6cbd58b8\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d6909b840a8e06d3e271cfa8d37931168e6c2555", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=ab10383aaebf2feebd2b6d68247f2520eff48f79", "patch": "@@ -1909,14 +1909,13 @@ Lex::skip_cpp_comment()\n   if (saw_error)\n     return;\n \n-  // Recognize various magic comments at the start of a line.\n+  // Recognize various magic comments at the start of a line, preceded\n+  // only by spaces or tabs.\n \n-  if (lineoff != 2)\n-    {\n-      // Not at the start of the line.  (lineoff == 2 because of the\n-      // two characters in \"//\").\n+  // \"- 2\" for the \"//\" at the start of the comment.\n+  for (const char* psp = this->linebuf_; psp < p - 2; psp++)\n+    if (*psp != ' ' && *psp != '\\t')\n       return;\n-    }\n \n   while (pend > p\n \t && (pend[-1] == ' ' || pend[-1] == '\\t'"}, {"sha": "1c4cc5bd2a1323a1f1329789dcaae8fbbd22c504", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=ab10383aaebf2feebd2b6d68247f2520eff48f79", "patch": "@@ -420,6 +420,12 @@ class Lex\n     std::swap(*embeds, this->embeds_);\n   }\n \n+  // Clear any go:embed patterns seen so far.  This is used for\n+  // erroneous cases.\n+  void\n+  clear_embeds()\n+  { this->embeds_.clear(); }\n+\n   // Return whether the identifier NAME should be exported.  NAME is a\n   // mangled name which includes only ASCII characters.\n   static bool"}, {"sha": "cc197e5eb359a6a3de4dc7b9169911d3bae84b56", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=ab10383aaebf2feebd2b6d68247f2520eff48f79", "patch": "@@ -1307,46 +1307,14 @@ void\n Parse::declaration()\n {\n   const Token* token = this->peek_token();\n-\n-  unsigned int pragmas = this->lex_->get_and_clear_pragmas();\n-  if (pragmas != 0\n-      && !token->is_keyword(KEYWORD_FUNC)\n-      && !token->is_keyword(KEYWORD_TYPE))\n-    go_warning_at(token->location(), 0,\n-\t\t  \"ignoring magic comment before non-function\");\n-\n-  std::vector<std::string>* embeds = NULL;\n-  if (this->lex_->has_embeds())\n-    {\n-      embeds = new(std::vector<std::string>);\n-      this->lex_->get_and_clear_embeds(embeds);\n-\n-      if (!this->gogo_->current_file_imported_embed())\n-\t{\n-\t  go_error_at(token->location(),\n-\t\t      \"invalid go:embed: missing import %<embed%>\");\n-\t  delete embeds;\n-\t  embeds = NULL;\n-\t}\n-      if (!token->is_keyword(KEYWORD_VAR))\n-\t{\n-\t  go_error_at(token->location(), \"misplaced go:embed directive\");\n-\t  if (embeds != NULL)\n-\t    {\n-\t      delete embeds;\n-\t      embeds = NULL;\n-\t    }\n-\t}\n-    }\n-\n   if (token->is_keyword(KEYWORD_CONST))\n     this->const_decl();\n   else if (token->is_keyword(KEYWORD_TYPE))\n-    this->type_decl(pragmas);\n+    this->type_decl();\n   else if (token->is_keyword(KEYWORD_VAR))\n-    this->var_decl(embeds);\n+    this->var_decl();\n   else if (token->is_keyword(KEYWORD_FUNC))\n-    this->function_decl(pragmas);\n+    this->function_decl();\n   else\n     {\n       go_error_at(this->location(), \"expected declaration\");\n@@ -1367,8 +1335,7 @@ Parse::declaration_may_start_here()\n // Decl<P> = P | \"(\" [ List<P> ] \")\" .\n \n void\n-Parse::decl(void (Parse::*pfn)(unsigned int, std::vector<std::string>*),\n-\t    unsigned int pragmas, std::vector<std::string>* embeds)\n+Parse::decl(void (Parse::*pfn)())\n {\n   if (this->peek_token()->is_eof())\n     {\n@@ -1378,15 +1345,18 @@ Parse::decl(void (Parse::*pfn)(unsigned int, std::vector<std::string>*),\n     }\n \n   if (!this->peek_token()->is_op(OPERATOR_LPAREN))\n-    (this->*pfn)(pragmas, embeds);\n+    (this->*pfn)();\n   else\n     {\n-      if (pragmas != 0)\n-\tgo_warning_at(this->location(), 0,\n-\t\t      \"ignoring magic %<//go:...%> comment before group\");\n-      if (embeds != NULL)\n+      if (this->lex_->get_and_clear_pragmas() != 0)\n \tgo_error_at(this->location(),\n-\t\t    \"ignoring %<//go:embed%> comment before group\");\n+\t\t    \"ignoring compiler directive before group\");\n+      if (this->lex_->has_embeds())\n+\t{\n+\t  this->lex_->clear_embeds();\n+\t  go_error_at(this->location(),\n+\t\t      \"ignoring %<//go:embed%> comment before group\");\n+\t}\n       if (!this->advance_token()->is_op(OPERATOR_RPAREN))\n \t{\n \t  this->list(pfn, true);\n@@ -1410,10 +1380,9 @@ Parse::decl(void (Parse::*pfn)(unsigned int, std::vector<std::string>*),\n // might follow.  This is either a '}' or a ')'.\n \n void\n-Parse::list(void (Parse::*pfn)(unsigned int, std::vector<std::string>*),\n-\t    bool follow_is_paren)\n+Parse::list(void (Parse::*pfn)(), bool follow_is_paren)\n {\n-  (this->*pfn)(0, NULL);\n+  (this->*pfn)();\n   Operator follow = follow_is_paren ? OPERATOR_RPAREN : OPERATOR_RCURLY;\n   while (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t || this->peek_token()->is_op(OPERATOR_COMMA))\n@@ -1422,7 +1391,7 @@ Parse::list(void (Parse::*pfn)(unsigned int, std::vector<std::string>*),\n \tgo_error_at(this->location(), \"unexpected comma\");\n       if (this->advance_token()->is_op(follow))\n \tbreak;\n-      (this->*pfn)(0, NULL);\n+      (this->*pfn)();\n     }\n }\n \n@@ -1469,6 +1438,8 @@ Parse::const_decl()\n void\n Parse::const_spec(int iota, Type** last_type, Expression_list** last_expr_list)\n {\n+  this->check_directives();\n+\n   Location loc = this->location();\n   Typed_identifier_list til;\n   this->identifier_list(&til);\n@@ -1545,18 +1516,21 @@ Parse::const_spec(int iota, Type** last_type, Expression_list** last_expr_list)\n // TypeDecl = \"type\" Decl<TypeSpec> .\n \n void\n-Parse::type_decl(unsigned int pragmas)\n+Parse::type_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_TYPE));\n   this->advance_token();\n-  this->decl(&Parse::type_spec, pragmas, NULL);\n+  this->decl(&Parse::type_spec);\n }\n \n // TypeSpec = identifier [\"=\"] Type .\n \n void\n-Parse::type_spec(unsigned int pragmas, std::vector<std::string>*)\n+Parse::type_spec()\n {\n+  unsigned int pragmas = this->lex_->get_and_clear_pragmas();\n+  this->check_directives();\n+\n   const Token* token = this->peek_token();\n   if (!token->is_identifier())\n     {\n@@ -1649,23 +1623,34 @@ Parse::type_spec(unsigned int pragmas, std::vector<std::string>*)\n // VarDecl = \"var\" Decl<VarSpec> .\n \n void\n-Parse::var_decl(std::vector<std::string>* embeds)\n+Parse::var_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_VAR));\n   this->advance_token();\n-  this->decl(&Parse::var_spec, 0, embeds);\n+  this->decl(&Parse::var_spec);\n }\n \n // VarSpec = IdentifierList\n //             ( CompleteType [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n \n void\n-Parse::var_spec(unsigned int pragmas, std::vector<std::string>* embeds)\n+Parse::var_spec()\n {\n   Location loc = this->location();\n \n-  if (pragmas != 0)\n-    go_warning_at(loc, 0, \"ignoring magic %<//go:...%> comment before var\");\n+  std::vector<std::string>* embeds = NULL;\n+  if (this->lex_->has_embeds())\n+    {\n+      if (!this->gogo_->current_file_imported_embed())\n+\tgo_error_at(loc, \"invalid go:embed: missing import %<embed%>\");\n+      else\n+\t{\n+\t  embeds = new(std::vector<std::string>);\n+\t  this->lex_->get_and_clear_embeds(embeds);\n+\t}\n+    }\n+\n+  this->check_directives();\n \n   // Get the variable names.\n   Typed_identifier_list til;\n@@ -2339,9 +2324,13 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n // PRAGMAS is a bitset of magic comments.\n \n void\n-Parse::function_decl(unsigned int pragmas)\n+Parse::function_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n+\n+  unsigned int pragmas = this->lex_->get_and_clear_pragmas();\n+  this->check_directives();\n+\n   Location location = this->location();\n   std::string extern_name = this->lex_->extern_name();\n   const Token* token = this->advance_token();\n@@ -5370,7 +5359,7 @@ Parse::for_stat(Label* label)\n \t{\n \t  go_error_at(this->location(),\n                       \"var declaration not allowed in for initializer\");\n-\t  this->var_decl(NULL);\n+\t  this->var_decl();\n \t}\n \n       if (token->is_op(OPERATOR_SEMICOLON))\n@@ -5815,17 +5804,15 @@ Parse::import_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_IMPORT));\n   this->advance_token();\n-  this->decl(&Parse::import_spec, 0, NULL);\n+  this->decl(&Parse::import_spec);\n }\n \n // ImportSpec = [ \".\" | PackageName ] PackageFileName .\n \n void\n-Parse::import_spec(unsigned int pragmas, std::vector<std::string>*)\n+Parse::import_spec()\n {\n-  if (pragmas != 0)\n-    go_warning_at(this->location(), 0,\n-\t\t  \"ignoring magic %<//go:...%> comment before import\");\n+  this->check_directives();\n \n   const Token* token = this->peek_token();\n   Location location = token->location();\n@@ -5916,6 +5903,23 @@ Parse::program()\n \t  this->skip_past_error(OPERATOR_INVALID);\n \t}\n     }\n+\n+  this->check_directives();\n+}\n+\n+// If there are any pending compiler directives, clear them and give\n+// an error.  This is called when directives are not permitted.\n+\n+void\n+Parse::check_directives()\n+{\n+  if (this->lex_->get_and_clear_pragmas() != 0)\n+    go_error_at(this->location(), \"misplaced compiler directive\");\n+  if (this->lex_->has_embeds())\n+    {\n+      this->lex_->clear_embeds();\n+      go_error_at(this->location(), \"misplaced go:embed directive\");\n+    }\n }\n \n // Skip forward to a semicolon or OP.  OP will normally be"}, {"sha": "6e300ef800c647093204d0d5c23094c62c94cf23", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab10383aaebf2feebd2b6d68247f2520eff48f79/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=ab10383aaebf2feebd2b6d68247f2520eff48f79", "patch": "@@ -181,15 +181,14 @@ class Parse\n   void method_spec(Typed_identifier_list*);\n   void declaration();\n   bool declaration_may_start_here();\n-  void decl(void (Parse::*)(unsigned int, std::vector<std::string>*),\n-\t    unsigned int pragmas, std::vector<std::string>* embeds);\n-  void list(void (Parse::*)(unsigned int, std::vector<std::string>*), bool);\n+  void decl(void (Parse::*)());\n+  void list(void (Parse::*)(), bool);\n   void const_decl();\n   void const_spec(int, Type**, Expression_list**);\n-  void type_decl(unsigned int pragmas);\n-  void type_spec(unsigned int pragmas, std::vector<std::string>*);\n-  void var_decl(std::vector<std::string>* embeds);\n-  void var_spec(unsigned int pragmas, std::vector<std::string>*);\n+  void type_decl();\n+  void type_spec();\n+  void var_decl();\n+  void var_spec();\n   void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n \t\t bool is_coloneq, std::vector<std::string>*, Location);\n   bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n@@ -210,7 +209,7 @@ class Parse\n   void simple_var_decl_or_assignment(const std::string&, Location,\n \t\t\t\t     bool may_be_composite_lit,\n \t\t\t\t     Range_clause*, Type_switch*);\n-  void function_decl(unsigned int pragmas);\n+  void function_decl();\n   Typed_identifier* receiver();\n   Expression* operand(bool may_be_sink, bool *is_parenthesized);\n   Expression* enclosing_var_reference(Named_object*, Named_object*,\n@@ -278,7 +277,10 @@ class Parse\n   void goto_stat();\n   void package_clause();\n   void import_decl();\n-  void import_spec(unsigned int pragmas, std::vector<std::string>*);\n+  void import_spec();\n+\n+  // Check for unused compiler directives.\n+  void check_directives();\n \n   // Skip past an error looking for a semicolon or OP.  Return true if\n   // all is well, false if we found EOF."}]}