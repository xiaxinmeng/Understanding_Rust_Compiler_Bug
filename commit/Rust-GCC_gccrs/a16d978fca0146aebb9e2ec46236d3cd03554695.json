{"sha": "a16d978fca0146aebb9e2ec46236d3cd03554695", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE2ZDk3OGZjYTAxNDZhZWJiOWUyZWM0NjIzNmQzY2QwMzU1NDY5NQ==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2009-06-07T16:35:06Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-06-07T16:35:06Z"}, "message": "re PR fortran/25104 ([F2003] Non-initialization expr. as case-selector)\n\n2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/25104\n        PR fortran/29962\n        * check.c (gfc_check_all_any): Check rank of DIM.\n        (gfc_check_count): Likewise.\n        * intrinsic.h (gfc_simplify_all): New prototype.\n        (gfc_simplify_any): Likewise.\n        (gfc_simplify_count): Likewise.\n        (gfc_simplify_sum): Likewise.\n        (gfc_simplify_product): Likewise.\n        * intrinsic.c (add_functions): Added new simplifier callbacks.\n        * simplify.c (transformational_result): New.\n        (simplify_transformation_to_scalar): New.\n        (simplify_transformation_to_array): New.\n        (gfc_count): New.\n        (gfc_simplify_all): New.\n        (gfc_simplify_any): New.\n        (gfc_simplify_count): New.\n        (gfc_simplify_sum): New.\n        (gfc_simplify_product): New.\n        * expr.c (check_transformational): Allow additional\n        * transformational\n        intrinsics in initialization expression.\n\n2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/25104\n        PR fortran/29962\n        * gfortran.dg/count_init_expr.f03\n        * gfortran.dg/product_init_expr.f03\n        * gfortran.dg/sum_init_expr.f03\n\nFrom-SVN: r148249", "tree": {"sha": "145c95b21aadf45f1cc3b40990eeebb7721a684f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/145c95b21aadf45f1cc3b40990eeebb7721a684f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a16d978fca0146aebb9e2ec46236d3cd03554695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16d978fca0146aebb9e2ec46236d3cd03554695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16d978fca0146aebb9e2ec46236d3cd03554695", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16d978fca0146aebb9e2ec46236d3cd03554695/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca8a87956aacfb2f74687734de9a5f20f86bf4fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8a87956aacfb2f74687734de9a5f20f86bf4fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8a87956aacfb2f74687734de9a5f20f86bf4fe"}], "stats": {"total": 557, "additions": 549, "deletions": 8}, "files": [{"sha": "638a9b876105a4faf05b4f881841f6cbccca85f9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -1,3 +1,27 @@\n+2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/25104\n+\tPR fortran/29962\n+\t* check.c (gfc_check_all_any): Check rank of DIM.\n+\t(gfc_check_count): Likewise.\n+\t* intrinsic.h (gfc_simplify_all): New prototype.\n+\t(gfc_simplify_any): Likewise.\n+\t(gfc_simplify_count): Likewise.\n+\t(gfc_simplify_sum): Likewise.\n+\t(gfc_simplify_product): Likewise.\n+\t* intrinsic.c (add_functions): Added new simplifier callbacks.\n+\t* simplify.c (transformational_result): New.\n+\t(simplify_transformation_to_scalar): New.\n+\t(simplify_transformation_to_array): New.\n+\t(gfc_count): New.\n+\t(gfc_simplify_all): New.\n+\t(gfc_simplify_any): New.\n+\t(gfc_simplify_count): New.\n+\t(gfc_simplify_sum): New.\n+\t(gfc_simplify_product): New.\n+\t* expr.c (check_transformational): Allow additional transformational\n+\tintrinsics in initialization expression.\n+\n 2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* check.c (dim_rank_check): Return SUCCESS if DIM=NULL."}, {"sha": "c45d5db6b05ab9ac74be13367ff22db0a49dfa6c", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -522,6 +522,9 @@ gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)\n   if (dim_check (dim, 1, false) == FAILURE)\n     return FAILURE;\n \n+  if (dim_rank_check (dim, mask, 0) == FAILURE)\n+    return FAILURE;\n+\n   return SUCCESS;\n }\n \n@@ -859,6 +862,8 @@ gfc_check_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n     return FAILURE;\n   if (dim_check (dim, 1, false) == FAILURE)\n     return FAILURE;\n+  if (dim_rank_check (dim, mask, 0) == FAILURE)\n+    return FAILURE;\n   if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n   if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \""}, {"sha": "a6a3a3b4ee3ab62500f2401beb0bb7f2f5342c1a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -2128,9 +2128,9 @@ check_transformational (gfc_expr *e)\n   };\n \n   static const char * const trans_func_f2003[] =  {\n-    \"dot_product\", \"matmul\", \"null\", \"pack\", \"repeat\",\n-    \"reshape\", \"selected_char_kind\", \"selected_int_kind\",\n-    \"selected_real_kind\", \"transfer\", \"transpose\", \"trim\", NULL\n+    \"all\", \"any\", \"count\", \"dot_product\", \"matmul\", \"null\", \"pack\",\n+    \"product\", \"repeat\", \"reshape\", \"selected_char_kind\", \"selected_int_kind\",\n+    \"selected_real_kind\", \"sum\", \"transfer\", \"transpose\", \"trim\", NULL\n   };\n \n   int i;"}, {"sha": "2dbb0cf14149f9be822378b610e935c8afb2855c", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -1189,7 +1189,7 @@ add_functions (void)\n   make_generic (\"aint\", GFC_ISYM_AINT, GFC_STD_F77);\n \n   add_sym_2 (\"all\", GFC_ISYM_ALL, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F95,\n-\t     gfc_check_all_any, NULL, gfc_resolve_all,\n+\t     gfc_check_all_any, gfc_simplify_all, gfc_resolve_all,\n \t     msk, BT_LOGICAL, dl, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL);\n \n   make_generic (\"all\", GFC_ISYM_ALL, GFC_STD_F95);\n@@ -1211,7 +1211,7 @@ add_functions (void)\n   make_generic (\"anint\", GFC_ISYM_ANINT, GFC_STD_F77);\n \n   add_sym_2 (\"any\", GFC_ISYM_ANY, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F95,\n-\t     gfc_check_all_any, NULL, gfc_resolve_any,\n+\t     gfc_check_all_any, gfc_simplify_any, gfc_resolve_any,\n \t     msk, BT_LOGICAL, dl, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL);\n \n   make_generic (\"any\", GFC_ISYM_ANY, GFC_STD_F95);\n@@ -1451,7 +1451,7 @@ add_functions (void)\n \n   add_sym_3 (\"count\", GFC_ISYM_COUNT, CLASS_TRANSFORMATIONAL, ACTUAL_NO,\n \t     BT_INTEGER, di, GFC_STD_F95,\n-\t     gfc_check_count, NULL, gfc_resolve_count,\n+\t     gfc_check_count, gfc_simplify_count, gfc_resolve_count,\n \t     msk, BT_LOGICAL, dl, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t     kind, BT_INTEGER, di, OPTIONAL);\n \n@@ -2228,7 +2228,7 @@ add_functions (void)\n   make_generic (\"present\", GFC_ISYM_PRESENT, GFC_STD_F95);\n \n   add_sym_3red (\"product\", GFC_ISYM_PRODUCT, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t\tgfc_check_product_sum, NULL, gfc_resolve_product,\n+\t\tgfc_check_product_sum, gfc_simplify_product, gfc_resolve_product,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n \n@@ -2466,7 +2466,7 @@ add_functions (void)\n   make_generic (\"stat\", GFC_ISYM_STAT, GFC_STD_GNU);\n \n   add_sym_3red (\"sum\", GFC_ISYM_SUM, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t\tgfc_check_product_sum, NULL, gfc_resolve_sum,\n+\t\tgfc_check_product_sum, gfc_simplify_sum, gfc_resolve_sum,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n "}, {"sha": "b483b11fe984266871e6934bb3c6daabfcf40120", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -200,10 +200,12 @@ gfc_expr *gfc_simplify_adjustl (gfc_expr *);\n gfc_expr *gfc_simplify_adjustr (gfc_expr *);\n gfc_expr *gfc_simplify_aimag (gfc_expr *);\n gfc_expr *gfc_simplify_aint (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_all (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dint (gfc_expr *);\n gfc_expr *gfc_simplify_anint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dnint (gfc_expr *);\n gfc_expr *gfc_simplify_and (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_any (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_asin (gfc_expr *);\n gfc_expr *gfc_simplify_asinh (gfc_expr *);\n gfc_expr *gfc_simplify_atan (gfc_expr *);\n@@ -224,6 +226,7 @@ gfc_expr *gfc_simplify_complex (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_conjg (gfc_expr *);\n gfc_expr *gfc_simplify_cos (gfc_expr *);\n gfc_expr *gfc_simplify_cosh (gfc_expr *);\n+gfc_expr *gfc_simplify_count (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dcmplx (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dble (gfc_expr *);\n gfc_expr *gfc_simplify_digits (gfc_expr *);\n@@ -293,6 +296,7 @@ gfc_expr *gfc_simplify_not (gfc_expr *);\n gfc_expr *gfc_simplify_or (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_pack (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_precision (gfc_expr *);\n+gfc_expr *gfc_simplify_product (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_radix (gfc_expr *);\n gfc_expr *gfc_simplify_range (gfc_expr *);\n gfc_expr *gfc_simplify_real (gfc_expr *, gfc_expr *);\n@@ -315,6 +319,7 @@ gfc_expr *gfc_simplify_size (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sngl (gfc_expr *);\n gfc_expr *gfc_simplify_spacing (gfc_expr *);\n gfc_expr *gfc_simplify_sqrt (gfc_expr *);\n+gfc_expr *gfc_simplify_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_tan (gfc_expr *);\n gfc_expr *gfc_simplify_tanh (gfc_expr *);\n gfc_expr *gfc_simplify_tiny (gfc_expr *);"}, {"sha": "dbd7f3d6309eddd3771fccd1ff317c924058d163", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -387,6 +387,246 @@ compute_dot_product (gfc_constructor *ctor_a, int stride_a,\n   return result;\n }\n \n+\n+/* Build a result expression for transformational intrinsics, \n+   depending on DIM. */\n+\n+static gfc_expr *\n+transformational_result (gfc_expr *array, gfc_expr *dim, bt type,\n+\t\t\t int kind, locus* where)\n+{\n+  gfc_expr *result;\n+  int i, nelem;\n+\n+  if (!dim || array->rank == 1)\n+    return gfc_constant_result (type, kind, where);\n+\n+  result = gfc_start_constructor (type, kind, where);\n+  result->shape = gfc_copy_shape_excluding (array->shape, array->rank, dim);\n+  result->rank = array->rank - 1;\n+\n+  /* gfc_array_size() would count the number of elements in the constructor,\n+     we have not built those yet.  */\n+  nelem = 1;\n+  for  (i = 0; i < result->rank; ++i)\n+    nelem *= mpz_get_ui (result->shape[i]);\n+\n+  for (i = 0; i < nelem; ++i)\n+    {\n+      gfc_expr *e = gfc_constant_result (type, kind, where);\n+      gfc_append_constructor (result, e);\n+    }\n+\n+  return result;\n+}\n+\n+\n+typedef gfc_expr* (*transformational_op)(gfc_expr*, gfc_expr*);\n+\n+/* Wrapper function, implements 'op1 += 1'. Only called if MASK\n+   of COUNT intrinsic is .TRUE..\n+\n+   Interface and implimentation mimics arith functions as\n+   gfc_add, gfc_multiply, etc.  */\n+\n+static gfc_expr* gfc_count (gfc_expr *op1, gfc_expr *op2)\n+{\n+  gfc_expr *result;\n+\n+  gcc_assert (op1->ts.type == BT_INTEGER);\n+  gcc_assert (op2->ts.type == BT_LOGICAL);\n+  gcc_assert (op2->value.logical);\n+\n+  result = gfc_copy_expr (op1);\n+  mpz_add_ui (result->value.integer, result->value.integer, 1);\n+\n+  gfc_free_expr (op1);\n+  gfc_free_expr (op2);\n+  return result;\n+}\n+\n+\n+/* Transforms an ARRAY with operation OP, according to MASK, to a\n+   scalar RESULT. E.g. called if\n+\n+     REAL, PARAMETER :: array(n, m) = ...\n+     REAL, PARAMETER :: s = SUM(array)\n+\n+  where OP == gfc_add().  */\n+\n+static gfc_expr *\n+simplify_transformation_to_scalar (gfc_expr *result, gfc_expr *array, gfc_expr *mask,\n+\t\t\t\t   transformational_op op)\n+{\n+  gfc_expr *a, *m;\n+  gfc_constructor *array_ctor, *mask_ctor;\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    return result;\n+\n+  array_ctor = array->value.constructor;\n+  mask_ctor = NULL;\n+  if (mask && mask->expr_type == EXPR_ARRAY)\n+    mask_ctor = mask->value.constructor;\n+\n+  while (array_ctor)\n+    {\n+      a = array_ctor->expr;\n+      array_ctor = array_ctor->next;\n+\n+      /* A constant MASK equals .TRUE. here and can be ignored.  */\n+      if (mask_ctor)\n+\t{\n+\t  m = mask_ctor->expr;\n+\t  mask_ctor = mask_ctor->next;\n+\t  if (!m->value.logical)\n+\t    continue;\n+\t}\n+\n+      result = op (result, gfc_copy_expr (a));\n+    }\n+\n+  return result;\n+}\n+\n+/* Transforms an ARRAY with operation OP, according to MASK, to an\n+   array RESULT. E.g. called if\n+\n+     REAL, PARAMETER :: array(n, m) = ...\n+     REAL, PARAMETER :: s(n) = PROD(array, DIM=1)\n+\n+  where OP == gfc_multiply().  */\n+\n+static gfc_expr *\n+simplify_transformation_to_array (gfc_expr *result, gfc_expr *array, gfc_expr *dim,\n+\t\t\t\t  gfc_expr *mask, transformational_op op)\n+{\n+  mpz_t size;\n+  int done, i, n, arraysize, resultsize, dim_index, dim_extent, dim_stride;\n+  gfc_expr **arrayvec, **resultvec, **base, **src, **dest;\n+  gfc_constructor *array_ctor, *mask_ctor, *result_ctor;\n+\n+  int count[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS],\n+      sstride[GFC_MAX_DIMENSIONS], dstride[GFC_MAX_DIMENSIONS],\n+      tmpstride[GFC_MAX_DIMENSIONS];\n+\n+  /* Shortcut for constant .FALSE. MASK.  */\n+  if (mask\n+      && mask->expr_type == EXPR_CONSTANT\n+      && !mask->value.logical)\n+    return result;\n+\n+  /* Build an indexed table for array element expressions to minimize\n+     linked-list traversal. Masked elements are set to NULL.  */\n+  gfc_array_size (array, &size);\n+  arraysize = mpz_get_ui (size);\n+\n+  arrayvec = (gfc_expr**) gfc_getmem (sizeof (gfc_expr*) * arraysize);\n+\n+  array_ctor = array->value.constructor;\n+  mask_ctor = NULL;\n+  if (mask && mask->expr_type == EXPR_ARRAY)\n+    mask_ctor = mask->value.constructor;\n+\n+  for (i = 0; i < arraysize; ++i)\n+    {\n+      arrayvec[i] = array_ctor->expr;\n+      array_ctor = array_ctor->next;\n+\n+      if (mask_ctor)\n+\t{\n+\t  if (!mask_ctor->expr->value.logical)\n+\t    arrayvec[i] = NULL;\n+\n+\t  mask_ctor = mask_ctor->next;\n+\t}\n+    }\n+\n+  /* Same for the result expression.  */\n+  gfc_array_size (result, &size);\n+  resultsize = mpz_get_ui (size);\n+  mpz_clear (size);\n+\n+  resultvec = (gfc_expr**) gfc_getmem (sizeof (gfc_expr*) * resultsize);\n+  result_ctor = result->value.constructor;\n+  for (i = 0; i < resultsize; ++i)\n+    {\n+      resultvec[i] = result_ctor->expr;\n+      result_ctor = result_ctor->next;\n+    }\n+\n+  gfc_extract_int (dim, &dim_index);\n+  dim_index -= 1;               /* zero-base index */\n+  dim_extent = 0;\n+  dim_stride = 0;\n+\n+  for (i = 0, n = 0; i < array->rank; ++i)\n+    {\n+      count[i] = 0;\n+      tmpstride[i] = (i == 0) ? 1 : tmpstride[i-1] * mpz_get_si (array->shape[i-1]);\n+      if (i == dim_index)\n+\t{\n+\t  dim_extent = mpz_get_si (array->shape[i]);\n+\t  dim_stride = tmpstride[i];\n+\t  continue;\n+\t}\n+\n+      extent[n] = mpz_get_si (array->shape[i]);\n+      sstride[n] = tmpstride[i];\n+      dstride[n] = (n == 0) ? 1 : dstride[n-1] * extent[n-1];\n+      n += 1;\n+    }\n+\n+  done = false;\n+  base = arrayvec;\n+  dest = resultvec;\n+  while (!done)\n+    {\n+      for (src = base, n = 0; n < dim_extent; src += dim_stride, ++n)\n+\tif (*src)\n+\t  *dest = op (*dest, gfc_copy_expr (*src));\n+\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+\n+      n = 0;\n+      while (!done && count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\n+\t  n++;\n+\t  if (n < result->rank)\n+\t    {\n+\t      count [n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t  else\n+\t    done = true;\n+       }\n+    }\n+\n+  /* Place updated expression in result constructor.  */\n+  result_ctor = result->value.constructor;\n+  for (i = 0; i < resultsize; ++i)\n+    {\n+      result_ctor->expr = resultvec[i];\n+      result_ctor = result_ctor->next;\n+    }\n+\n+  gfc_free (arrayvec);\n+  gfc_free (resultvec);\n+  return result;\n+}\n+\n+\n+\n /********************** Simplification functions *****************************/\n \n gfc_expr *\n@@ -657,6 +897,25 @@ gfc_simplify_aint (gfc_expr *e, gfc_expr *k)\n }\n \n \n+gfc_expr *\n+gfc_simplify_all (gfc_expr *mask, gfc_expr *dim)\n+{\n+  gfc_expr *result;\n+\n+  if (!is_constant_array_expr (mask)\n+      || !gfc_is_constant_expr (dim))\n+    return NULL;\n+\n+  result = transformational_result (mask, dim, mask->ts.type,\n+\t\t\t\t    mask->ts.kind, &mask->where);\n+  init_result_expr (result, true, NULL);\n+\n+  return !dim || mask->rank == 1 ?\n+    simplify_transformation_to_scalar (result, mask, NULL, gfc_and) :\n+    simplify_transformation_to_array (result, mask, dim, NULL, gfc_and);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_dint (gfc_expr *e)\n {\n@@ -722,6 +981,25 @@ gfc_simplify_and (gfc_expr *x, gfc_expr *y)\n }\n \n \n+gfc_expr *\n+gfc_simplify_any (gfc_expr *mask, gfc_expr *dim)\n+{\n+  gfc_expr *result;\n+\n+  if (!is_constant_array_expr (mask)\n+      || !gfc_is_constant_expr (dim))\n+    return NULL;\n+\n+  result = transformational_result (mask, dim, mask->ts.type,\n+\t\t\t\t    mask->ts.kind, &mask->where);\n+  init_result_expr (result, false, NULL);\n+\n+  return !dim || mask->rank == 1 ?\n+    simplify_transformation_to_scalar (result, mask, NULL, gfc_or) :\n+    simplify_transformation_to_array (result, mask, dim, NULL, gfc_or);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_dnint (gfc_expr *e)\n {\n@@ -1221,6 +1499,32 @@ gfc_simplify_cosh (gfc_expr *x)\n }\n \n \n+gfc_expr *\n+gfc_simplify_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n+{\n+  gfc_expr *result;\n+\n+  if (!is_constant_array_expr (mask)\n+      || !gfc_is_constant_expr (dim)\n+      || !gfc_is_constant_expr (kind))\n+    return NULL;\n+\n+  result = transformational_result (mask, dim,\n+\t\t\t\t    BT_INTEGER,\n+\t\t\t\t    get_kind (BT_INTEGER, kind, \"COUNT\",\n+\t\t\t\t\t      gfc_default_integer_kind),\n+\t\t\t\t    &mask->where);\n+\n+  init_result_expr (result, 0, NULL);\n+\n+  /* Passing MASK twice, once as data array, once as mask.\n+     Whenever gfc_count is called, '1' is added to the result.  */\n+  return !dim || mask->rank == 1 ?\n+    simplify_transformation_to_scalar (result, mask, mask, gfc_count) :\n+    simplify_transformation_to_array (result, mask, dim, mask, gfc_count);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_dcmplx (gfc_expr *x, gfc_expr *y)\n {\n@@ -3705,6 +4009,30 @@ gfc_simplify_precision (gfc_expr *e)\n }\n \n \n+gfc_expr *\n+gfc_simplify_product (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  gfc_expr *result;\n+\n+  if (!is_constant_array_expr (array)\n+      || !gfc_is_constant_expr (dim))\n+    return NULL;\n+\n+  if (mask\n+      && !is_constant_array_expr (mask)\n+      && mask->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  result = transformational_result (array, dim, array->ts.type,\n+\t\t\t\t    array->ts.kind, &array->where);\n+  init_result_expr (result, 1, NULL);\n+\n+  return !dim || array->rank == 1 ?\n+    simplify_transformation_to_scalar (result, array, mask, gfc_multiply) :\n+    simplify_transformation_to_array (result, array, dim, mask, gfc_multiply);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_radix (gfc_expr *e)\n {\n@@ -4827,6 +5155,30 @@ gfc_simplify_sqrt (gfc_expr *e)\n }\n \n \n+gfc_expr *\n+gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  gfc_expr *result;\n+\n+  if (!is_constant_array_expr (array)\n+      || !gfc_is_constant_expr (dim))\n+    return NULL;\n+\n+  if (mask\n+      && !is_constant_array_expr (mask)\n+      && mask->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  result = transformational_result (array, dim, array->ts.type,\n+\t\t\t\t    array->ts.kind, &array->where);\n+  init_result_expr (result, 0, NULL);\n+\n+  return !dim || array->rank == 1 ?\n+    simplify_transformation_to_scalar (result, array, mask, gfc_add) :\n+    simplify_transformation_to_array (result, array, dim, mask, gfc_add);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_tan (gfc_expr *x)\n {"}, {"sha": "78cd329f95a5a327557614a6173a40cb7f142ad2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -1,3 +1,11 @@\n+2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/25104\n+\tPR fortran/29962\n+\t* gfortran.dg/count_init_expr.f03\n+\t* gfortran.dg/product_init_expr.f03\n+\t* gfortran.dg/sum_init_expr.f03\n+\n 2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/36874"}, {"sha": "73a8efa95658fb7336b09c6084e34e02a59d4ff0", "filename": "gcc/testsuite/gfortran.dg/count_init_expr.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2Fgfortran.dg%2Fcount_init_expr.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2Fgfortran.dg%2Fcount_init_expr.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcount_init_expr.f03?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do \"run\" }\n+\n+  INTEGER            :: i\n+  INTEGER, PARAMETER :: m(4,4) = RESHAPE([ (i, i=1, 16) ], [4, 4] )\n+  INTEGER, PARAMETER :: sevens = COUNT (m == 7)\n+  INTEGER, PARAMETER :: odd(4) = COUNT (MOD(m, 2) == 1, dim=1)\n+  INTEGER, PARAMETER :: even = COUNT (MOD(m, 2) == 0)\n+\n+  IF (sevens /= 1) CALL abort()\n+  IF (ANY(odd /= [ 2,2,2,2 ])) CALL abort()\n+  IF (even /= 8) CALL abort()\n+\n+  ! check the kind parameter\n+  IF (KIND(COUNT (m == 7, KIND=2)) /= 2) CALL abort()\n+END"}, {"sha": "6724eb719f6b45d7b477150ba6d61b8fb4cc75fc", "filename": "gcc/testsuite/gfortran.dg/product_init_expr.f03", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2Fgfortran.dg%2Fproduct_init_expr.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2Fgfortran.dg%2Fproduct_init_expr.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproduct_init_expr.f03?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do \"run\" }\n+! { dg-options \"-fno-inline\" }\n+!\n+! PRODUCT as initialization expression.\n+!\n+! This test compares results of simplifier of PRODUCT\n+! with the corresponding inlined or library routine(s).\n+!\n+\n+  IMPLICIT NONE\n+\n+  INTEGER, PARAMETER :: imatrix(2,4) = RESHAPE ([ 1, 2, 3, 4, 5, 6, 7, 8 ], [2, 4] )\n+  INTEGER, PARAMETER :: imatrix_prod = PRODUCT (imatrix)\n+  INTEGER, PARAMETER :: imatrix_prod_d1(4) = PRODUCT (imatrix, dim=1)\n+  INTEGER, PARAMETER :: imatrix_prod_d2(2) = PRODUCT (imatrix, dim=2)\n+  LOGICAL, PARAMETER :: i_equal_prod = ALL ([PRODUCT( imatrix_prod_d1 ) ==  PRODUCT ( imatrix_prod_d2 ), &\n+                                             PRODUCT( imatrix_prod_d1 ) == imatrix_prod])\n+  LOGICAL, PARAMETER :: i_empty_prod = PRODUCT(imatrix, mask=.FALSE.) == 1\n+\n+  REAL, PARAMETER :: rmatrix(2,4) = RESHAPE ([ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ], [2, 4] )\n+  REAL, PARAMETER :: rmatrix_prod = PRODUCT (rmatrix)\n+  REAL, PARAMETER :: rmatrix_prod_d1(4) = PRODUCT (rmatrix, dim=1)\n+  REAL, PARAMETER :: rmatrix_prod_d2(2) = PRODUCT (rmatrix, dim=2)\n+  LOGICAL, PARAMETER :: r_equal_prod = ALL ([PRODUCT( rmatrix_prod_d1 ) ==  PRODUCT ( rmatrix_prod_d2 ), &\n+                                             PRODUCT( rmatrix_prod_d1 ) == rmatrix_prod])\n+  LOGICAL, PARAMETER :: r_empty_prod = PRODUCT(rmatrix, mask=.FALSE.) == 1.0\n+\n+  IF (.NOT. ALL ([i_equal_prod, i_empty_prod])) CALL abort()\n+  IF (.NOT. ALL ([r_equal_prod, r_empty_prod])) CALL abort()\n+\n+  CALL ilib (imatrix, imatrix_prod)\n+  CALL ilib_with_dim (imatrix, 1, imatrix_prod_d1)\n+  CALL ilib_with_dim (imatrix, 2, imatrix_prod_d2)\n+  CALL rlib (rmatrix, rmatrix_prod)\n+  CALL rlib_with_dim (rmatrix, 1, rmatrix_prod_d1)\n+  CALL rlib_with_dim (rmatrix, 2, rmatrix_prod_d2)\n+\n+CONTAINS\n+  SUBROUTINE ilib (array, result)\n+    INTEGER, DIMENSION(:,:), INTENT(in) :: array\n+    INTEGER, INTENT(in) :: result\n+    IF (PRODUCT(array) /= result) CALL abort()\n+  END SUBROUTINE\n+\n+  SUBROUTINE ilib_with_dim (array, dim, result)\n+    INTEGER, DIMENSION(:,:), INTENT(in) :: array\n+    INTEGER, INTENT(iN)                 :: dim\n+    INTEGER, DIMENSION(:), INTENT(in)   :: result\n+    IF (ANY (PRODUCT (array, dim=dim) /= result)) CALL abort()\n+  END SUBROUTINE\n+\n+  SUBROUTINE rlib (array, result)\n+    REAL, DIMENSION(:,:), INTENT(in) :: array\n+    REAL, INTENT(in) :: result\n+    IF (ABS(PRODUCT(array) - result) > 2e-6) CALL abort()\n+  END SUBROUTINE\n+\n+  SUBROUTINE rlib_with_dim (array, dim, result)\n+    REAL, DIMENSION(:,:), INTENT(in) :: array\n+    INTEGER, INTENT(iN)              :: dim\n+    REAL, DIMENSION(:), INTENT(in)   :: result\n+    IF (ANY (ABS(PRODUCT (array, dim=dim) - result) > 2e-6)) CALL abort()\n+  END SUBROUTINE\n+END\n+\n+"}, {"sha": "fc9701ce86d373d30fb7ef19533f0d6839fba649", "filename": "gcc/testsuite/gfortran.dg/sum_init_expr.f03", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2Fgfortran.dg%2Fsum_init_expr.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16d978fca0146aebb9e2ec46236d3cd03554695/gcc%2Ftestsuite%2Fgfortran.dg%2Fsum_init_expr.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsum_init_expr.f03?ref=a16d978fca0146aebb9e2ec46236d3cd03554695", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do \"run\" }\n+! { dg-options \"-fno-inline\" }\n+!\n+! SUM as initialization expression.\n+!\n+! This test compares results of simplifier of SUM \n+! with the corresponding inlined or library routine(s).\n+!\n+\n+  IMPLICIT NONE\n+\n+  INTEGER, PARAMETER :: imatrix(2,4) = RESHAPE ([ 1, 2, 3, 4, 5, 6, 7, 8 ], [2, 4] )\n+  INTEGER, PARAMETER :: imatrix_sum = SUM (imatrix)\n+  INTEGER, PARAMETER :: imatrix_sum_d1(4) = SUM (imatrix, dim=1)\n+  INTEGER, PARAMETER :: imatrix_sum_d2(2) = SUM (imatrix, dim=2)\n+  LOGICAL, PARAMETER :: i_equal_sum = ALL ([SUM( imatrix_sum_d1 ) ==  SUM ( imatrix_sum_d2 ), &\n+                                            SUM( imatrix_sum_d1 ) == imatrix_sum])\n+  LOGICAL, PARAMETER :: i_empty_sum = SUM(imatrix, mask=.FALSE.) == 0\n+\n+  REAL, PARAMETER :: rmatrix(2,4) = RESHAPE ([ 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8 ], [2, 4] )\n+  REAL, PARAMETER :: rmatrix_sum = SUM (rmatrix)\n+  REAL, PARAMETER :: rmatrix_sum_d1(4) = SUM (rmatrix, dim=1)\n+  REAL, PARAMETER :: rmatrix_sum_d2(2) = SUM (rmatrix, dim=2)\n+  LOGICAL, PARAMETER :: r_equal_sum = ALL ([SUM( rmatrix_sum_d1 ) ==  SUM ( rmatrix_sum_d2 ), &\n+                                            SUM( rmatrix_sum_d1 ) == rmatrix_sum])\n+  LOGICAL, PARAMETER :: r_empty_sum = SUM(rmatrix, mask=.FALSE.) == 0.0\n+\n+  IF (.NOT. ALL ([i_equal_sum, i_empty_sum])) CALL abort()\n+  IF (.NOT. ALL ([r_equal_sum, r_empty_sum])) CALL abort()\n+\n+  CALL ilib (imatrix, imatrix_sum)\n+  CALL ilib_with_dim (imatrix, 1, imatrix_sum_d1)\n+  CALL ilib_with_dim (imatrix, 2, imatrix_sum_d2)\n+  CALL rlib (rmatrix, rmatrix_sum)\n+  CALL rlib_with_dim (rmatrix, 1, rmatrix_sum_d1)\n+  CALL rlib_with_dim (rmatrix, 2, rmatrix_sum_d2)\n+\n+CONTAINS\n+  SUBROUTINE ilib (array, result)\n+    INTEGER, DIMENSION(:,:), INTENT(in) :: array\n+    INTEGER, INTENT(in) :: result\n+    IF (SUM(array) /= result) CALL abort()\n+  END SUBROUTINE\n+\n+  SUBROUTINE ilib_with_dim (array, dim, result)\n+    INTEGER, DIMENSION(:,:), INTENT(in) :: array\n+    INTEGER, INTENT(iN)                 :: dim\n+    INTEGER, DIMENSION(:), INTENT(in)   :: result\n+    IF (ANY (SUM (array, dim=dim) /= result)) CALL abort()\n+  END SUBROUTINE\n+\n+  SUBROUTINE rlib (array, result)\n+    REAL, DIMENSION(:,:), INTENT(in) :: array\n+    REAL, INTENT(in) :: result\n+    IF (ABS(SUM(array) - result) > 2e-6) CALL abort()\n+  END SUBROUTINE\n+\n+  SUBROUTINE rlib_with_dim (array, dim, result)\n+    REAL, DIMENSION(:,:), INTENT(in) :: array\n+    INTEGER, INTENT(iN)              :: dim\n+    REAL, DIMENSION(:), INTENT(in)   :: result\n+    IF (ANY (ABS(SUM (array, dim=dim) - result) > 2e-6)) CALL abort()\n+  END SUBROUTINE\n+END\n+\n+"}]}