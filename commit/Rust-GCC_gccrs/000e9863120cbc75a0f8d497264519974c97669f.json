{"sha": "000e9863120cbc75a0f8d497264519974c97669f", "node_id": "C_kwDOANBUbNoAKDAwMGU5ODYzMTIwY2JjNzVhMGY4ZDQ5NzI2NDUxOTk3NGM5NzY2OWY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-30T00:25:37Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-30T00:25:37Z"}, "message": "c++: ICE with <=> of incompatible pointers [PR107542]\n\nIn a SFINAE context composite_pointer_type returns error_mark_node if\nthe given pointer types are incompatible.  But the SPACESHIP_EXPR case\nof cp_build_binary_op wasn't prepared for this error_mark_node result,\nwhich led to an ICE (from spaceship_comp_cat) for the below testcase.\n(In a non-SFINAE context composite_pointer_type issues a permerror and\nreturns cv void* in this case, so this ICE seems specific to SFINAE.)\n\n\tPR c++/107542\n\ngcc/cp/ChangeLog:\n\n\t* typeck.cc (cp_build_binary_op): In the SPACESHIP_EXPR case,\n\thandle an error_mark_node result type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/spaceship-sfinae2.C: New test.", "tree": {"sha": "e5389b1fcb398cbdb2016d312642d4ec7d8e3910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5389b1fcb398cbdb2016d312642d4ec7d8e3910"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/000e9863120cbc75a0f8d497264519974c97669f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/000e9863120cbc75a0f8d497264519974c97669f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/000e9863120cbc75a0f8d497264519974c97669f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/000e9863120cbc75a0f8d497264519974c97669f/comments", "author": null, "committer": null, "parents": [{"sha": "9b377463856c8ca985c0a8c95de8712ffa4b5ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b377463856c8ca985c0a8c95de8712ffa4b5ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b377463856c8ca985c0a8c95de8712ffa4b5ef6"}], "stats": {"total": 34, "additions": 32, "deletions": 2}, "files": [{"sha": "7dfe5acc67e86422fc448903befa5ad0967f528e", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/000e9863120cbc75a0f8d497264519974c97669f/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/000e9863120cbc75a0f8d497264519974c97669f/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=000e9863120cbc75a0f8d497264519974c97669f", "patch": "@@ -6215,8 +6215,9 @@ cp_build_binary_op (const op_location_t &location,\n       tree_code orig_code0 = TREE_CODE (orig_type0);\n       tree orig_type1 = TREE_TYPE (orig_op1);\n       tree_code orig_code1 = TREE_CODE (orig_type1);\n-      if (!result_type)\n-\t/* Nope.  */;\n+      if (!result_type || result_type == error_mark_node)\n+\t/* Nope.  */\n+\tresult_type = NULL_TREE;\n       else if ((orig_code0 == BOOLEAN_TYPE) != (orig_code1 == BOOLEAN_TYPE))\n \t/* \"If one of the operands is of type bool and the other is not, the\n \t   program is ill-formed.\"  */"}, {"sha": "7105a2c7f2a61bc9b209f6f84999669dcb125091", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-sfinae2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/000e9863120cbc75a0f8d497264519974c97669f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-sfinae2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/000e9863120cbc75a0f8d497264519974c97669f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-sfinae2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-sfinae2.C?ref=000e9863120cbc75a0f8d497264519974c97669f", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/107542\n+// { dg-do compile { target c++20 } }\n+\n+#include <compare>\n+\n+template<class T, class U>\n+concept same_as = __is_same(T, U);\n+\n+template<class Lhs, class Rhs>\n+concept Ord = requires(Lhs lhs, Rhs rhs) {\n+  { lhs <=> rhs } -> same_as<std::strong_ordering>;\n+};\n+\n+static_assert(Ord<int*, int*>);   // Works.\n+static_assert(!Ord<int*, char*>); // ICE.\n+\n+template<class T>\n+struct S {\n+  T* p;\n+};\n+\n+template<class T, class U>\n+  requires(Ord<const T*, const U*>)\n+constexpr inline auto operator<=>(const S<T>& l, const S<U>& r) noexcept {\n+  return l.p <=> r.p;\n+}\n+\n+static_assert(Ord<S<int>, S<int>>);   // Works.\n+static_assert(!Ord<S<int>, S<char>>); // ICE."}]}