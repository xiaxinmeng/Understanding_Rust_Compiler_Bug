{"sha": "d3e80850694a714e4e3ea4ef449fecfb53c4a274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNlODA4NTA2OTRhNzE0ZTRlM2VhNGVmNDQ5ZmVjZmI1M2M0YTI3NA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-08-25T10:12:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-08-25T10:12:35Z"}, "message": "regrename.c (struct du_head): Remove member terminated.\n\n\t* regrename.c (struct du_head): Remove member terminated.\n\t(create_new_chain): Don't initialize it.\n\t(scan_rtx_reg): Don't set or test it, test the open_chains_set\n\tbitmap instead.\n\t(tick, this_tick): New global variables, moved out of\n\tregrename_optimize.\n\t(current_id, open_chains, closed_chains, open_chains_set,\n\tlive_in_chains, live_hard_regs): Reorder declarations.\n\t(dump_def_use_chain): Move function earlier in the file.\n\t(rename_chains): New static function, broken out of\n\tregrename_optimize.\n\t(regrename_optimize): Use it.  Remove #if 0'ed code.\n\nFrom-SVN: r178057", "tree": {"sha": "d4c1192606ddc5d9136cc98fbd259b5a09289c91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4c1192606ddc5d9136cc98fbd259b5a09289c91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3e80850694a714e4e3ea4ef449fecfb53c4a274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e80850694a714e4e3ea4ef449fecfb53c4a274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e80850694a714e4e3ea4ef449fecfb53c4a274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e80850694a714e4e3ea4ef449fecfb53c4a274/comments", "author": null, "committer": null, "parents": [{"sha": "39b75e51ecf427f4d40ba33367ae0887d25a0a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39b75e51ecf427f4d40ba33367ae0887d25a0a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39b75e51ecf427f4d40ba33367ae0887d25a0a28"}], "stats": {"total": 413, "additions": 210, "deletions": 203}, "files": [{"sha": "91e0d7c742b92f09beda0a2ba32d83a188a0575d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3e80850694a714e4e3ea4ef449fecfb53c4a274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3e80850694a714e4e3ea4ef449fecfb53c4a274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3e80850694a714e4e3ea4ef449fecfb53c4a274", "patch": "@@ -1,3 +1,18 @@\n+2011-08-25  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* regrename.c (struct du_head): Remove member terminated.\n+\t(create_new_chain): Don't initialize it.\n+\t(scan_rtx_reg): Don't set or test it, test the open_chains_set\n+\tbitmap instead.\n+\t(tick, this_tick): New global variables, moved out of\n+\tregrename_optimize.\n+\t(current_id, open_chains, closed_chains, open_chains_set,\n+\tlive_in_chains, live_hard_regs): Reorder declarations.\n+\t(dump_def_use_chain): Move function earlier in the file.\n+\t(rename_chains): New static function, broken out of\n+\tregrename_optimize.\n+\t(regrename_optimize): Use it.  Remove #if 0'ed code.\n+\n 2011-08-25  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n \n \t* varasm.c: (default_binds_local_p_1): Commentary typo fix."}, {"sha": "830019cf053fe7882df3a0d6e5578243f04e31c8", "filename": "gcc/regrename.c", "status": "modified", "additions": 195, "deletions": 203, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3e80850694a714e4e3ea4ef449fecfb53c4a274/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3e80850694a714e4e3ea4ef449fecfb53c4a274/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=d3e80850694a714e4e3ea4ef449fecfb53c4a274", "patch": "@@ -85,8 +85,6 @@ struct du_head\n   /* Conflicts with untracked hard registers.  */\n   HARD_REG_SET hard_conflicts;\n \n-  /* Nonzero if the chain is finished; zero if it is still open.  */\n-  unsigned int terminated:1;\n   /* Nonzero if the chain crosses a call.  */\n   unsigned int need_caller_save_reg:1;\n   /* Nonzero if the register is used in a way that prevents renaming,\n@@ -132,6 +130,11 @@ static const char * const scan_actions_name[] =\n   \"mark_access\"\n };\n \n+/* TICK and THIS_TICK are used to record the last time we saw each\n+   register.  */\n+static int tick[FIRST_PSEUDO_REGISTER];\n+static int this_tick = 0;\n+\n static struct obstack rename_obstack;\n \n static void do_replace (struct du_head *, int);\n@@ -147,8 +150,49 @@ static void dump_def_use_chain (struct du_head *);\n typedef struct du_head *du_head_p;\n DEF_VEC_P (du_head_p);\n DEF_VEC_ALLOC_P (du_head_p, heap);\n+\n+/* The id to be given to the next opened chain.  */\n+static unsigned current_id;\n+\n+/* A mapping of unique id numbers to chains.  */\n static VEC(du_head_p, heap) *id_to_chain;\n \n+/* List of currently open chains, and closed chains that can be renamed.  */\n+static struct du_head *open_chains;\n+static struct du_head *closed_chains;\n+\n+/* Bitmap of open chains.  The bits set always match the list found in\n+   open_chains.  */\n+static bitmap_head open_chains_set;\n+\n+/* Record the registers being tracked in open_chains.  */\n+static HARD_REG_SET live_in_chains;\n+\n+/* Record the registers that are live but not tracked.  The intersection\n+   between this and live_in_chains is empty.  */\n+static HARD_REG_SET live_hard_regs;\n+\n+/* Dump all def/use chains in CHAINS to DUMP_FILE.  */\n+\n+static void\n+dump_def_use_chain (struct du_head *head)\n+{\n+  while (head)\n+    {\n+      struct du_chain *this_du = head->first;\n+      fprintf (dump_file, \"Register %s (%d):\",\n+\t       reg_names[head->regno], head->nregs);\n+      while (this_du)\n+\t{\n+\t  fprintf (dump_file, \" %d [%s]\", INSN_UID (this_du->insn),\n+\t\t   reg_class_names[this_du->cl]);\n+\t  this_du = this_du->next_use;\n+\t}\n+      fprintf (dump_file, \"\\n\");\n+      head = head->next_chain;\n+    }\n+}\n+\n static void\n free_chain_data (void)\n {\n@@ -225,13 +269,158 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n   return true;\n }\n \n+/* Process the closed chains starting with ALL_CHAINS and rename\n+   registers if possible.  */\n+static void\n+rename_chains (du_head_p all_chains)\n+{\n+  HARD_REG_SET unavailable;\n+\n+  CLEAR_HARD_REG_SET (unavailable);\n+  /* Don't clobber traceback for noreturn functions.  */\n+  if (frame_pointer_needed)\n+    {\n+      add_to_hard_reg_set (&unavailable, Pmode, FRAME_POINTER_REGNUM);\n+#if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n+      add_to_hard_reg_set (&unavailable, Pmode, HARD_FRAME_POINTER_REGNUM);\n+#endif\n+    }\n+\n+  while (all_chains)\n+    {\n+      int new_reg, best_new_reg, best_nregs;\n+      int n_uses;\n+      struct du_head *this_head = all_chains;\n+      struct du_chain *tmp;\n+      HARD_REG_SET this_unavailable;\n+      int reg = this_head->regno;\n+      int pass;\n+      enum reg_class super_class = NO_REGS;\n+      enum reg_class preferred_class;\n+      bool has_preferred_class;\n+\n+      all_chains = this_head->next_chain;\n+\n+      if (this_head->cannot_rename)\n+\tcontinue;\n+\n+      best_new_reg = reg;\n+      best_nregs = this_head->nregs;\n+\n+      if (fixed_regs[reg] || global_regs[reg]\n+#if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n+\t  || (frame_pointer_needed && reg == HARD_FRAME_POINTER_REGNUM)\n+#else\n+\t  || (frame_pointer_needed && reg == FRAME_POINTER_REGNUM)\n+#endif\n+\t  )\n+\tcontinue;\n+\n+      COPY_HARD_REG_SET (this_unavailable, unavailable);\n+\n+      /* Iterate over elements in the chain in order to:\n+\t 1. Count number of uses, and narrow the set of registers we can\n+\t    use for renaming.\n+\t 2. Compute the superunion of register classes in this chain.  */\n+      n_uses = 0;\n+      super_class = NO_REGS;\n+      for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n+\t{\n+\t  if (DEBUG_INSN_P (tmp->insn))\n+\t    continue;\n+\t  n_uses++;\n+\t  IOR_COMPL_HARD_REG_SET (this_unavailable,\n+\t\t\t\t  reg_class_contents[tmp->cl]);\n+\t  super_class\n+\t    = reg_class_superunion[(int) super_class][(int) tmp->cl];\n+\t}\n+\n+      if (n_uses < 2)\n+\tcontinue;\n+\n+      /* Further narrow the set of registers we can use for renaming.\n+\t If the chain needs a call-saved register, mark the call-used\n+\t registers as unavailable.  */\n+      if (this_head->need_caller_save_reg)\n+\tIOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n+\n+      /* And mark registers that overlap its lifetime as unavailable.  */\n+      merge_overlapping_regs (&this_unavailable, this_head);\n+\n+      /* Compute preferred rename class of super union of all the classes\n+\t in the chain.  */\n+      preferred_class\n+\t= (enum reg_class) targetm.preferred_rename_class (super_class);\n+\n+      /* If PREFERRED_CLASS is not NO_REGS, we iterate in the first pass\n+\t over registers that belong to PREFERRED_CLASS and try to find the\n+\t best register within the class.  If that failed, we iterate in\n+\t the second pass over registers that don't belong to the class.\n+\t If PREFERRED_CLASS is NO_REGS, we iterate over all registers in\n+\t ascending order without any preference.  */\n+      has_preferred_class = (preferred_class != NO_REGS);\n+      for (pass = (has_preferred_class ? 0 : 1); pass < 2; pass++)\n+\t{\n+\t  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n+\t    {\n+\t      if (has_preferred_class\n+\t\t  && ((pass == 0) != TEST_HARD_REG_BIT\n+\t\t      (reg_class_contents[preferred_class], new_reg)))\n+\t\tcontinue;\n+\n+\t      /* In the first pass, we force the renaming of registers that\n+\t\t don't belong to PREFERRED_CLASS to registers that do, even\n+\t\t though the latters were used not very long ago.  */\n+\t      if (check_new_reg_p (reg, new_reg, this_head,\n+\t\t\t\t   this_unavailable)\n+\t\t  && ((pass == 0\n+\t\t       && (!TEST_HARD_REG_BIT\n+\t\t\t   (reg_class_contents[preferred_class],\n+\t\t\t    best_new_reg)))\n+\t\t      || tick[best_new_reg] > tick[new_reg]))\n+\t\t{\n+\t\t  enum machine_mode mode\n+\t\t    = GET_MODE (*this_head->first->loc);\n+\t\t  best_new_reg = new_reg;\n+\t\t  best_nregs = hard_regno_nregs[new_reg][mode];\n+\t\t}\n+\t    }\n+\t  if (pass == 0 && best_new_reg != reg)\n+\t    break;\n+\t}\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Register %s in insn %d\",\n+\t\t   reg_names[reg], INSN_UID (this_head->first->insn));\n+\t  if (this_head->need_caller_save_reg)\n+\t    fprintf (dump_file, \" crosses a call\");\n+\t}\n+\n+      if (best_new_reg == reg)\n+\t{\n+\t  tick[reg] = ++this_tick;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"; no available better choice\\n\");\n+\t  continue;\n+\t}\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n+\n+      do_replace (this_head, best_new_reg);\n+      this_head->regno = best_new_reg;\n+      this_head->nregs = best_nregs;\n+      tick[best_new_reg] = ++this_tick;\n+      df_set_regs_ever_live (best_new_reg, true);\n+    }\n+}\n+\n /* Perform register renaming on the current function.  */\n \n static unsigned int\n regrename_optimize (void)\n {\n-  int tick[FIRST_PSEUDO_REGISTER];\n-  int this_tick = 0;\n   basic_block bb;\n   char *first_obj;\n \n@@ -248,16 +437,9 @@ regrename_optimize (void)\n   FOR_EACH_BB (bb)\n     {\n       struct du_head *all_chains = 0;\n-      HARD_REG_SET unavailable;\n-#if 0\n-      HARD_REG_SET regs_seen;\n-      CLEAR_HARD_REG_SET (regs_seen);\n-#endif\n \n       id_to_chain = VEC_alloc (du_head_p, heap, 0);\n \n-      CLEAR_HARD_REG_SET (unavailable);\n-\n       if (dump_file)\n \tfprintf (dump_file, \"\\nBasic block %d:\\n\", bb->index);\n \n@@ -266,154 +448,7 @@ regrename_optimize (void)\n       if (dump_file)\n \tdump_def_use_chain (all_chains);\n \n-      CLEAR_HARD_REG_SET (unavailable);\n-      /* Don't clobber traceback for noreturn functions.  */\n-      if (frame_pointer_needed)\n-\t{\n-\t  add_to_hard_reg_set (&unavailable, Pmode, FRAME_POINTER_REGNUM);\n-#if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n-\t  add_to_hard_reg_set (&unavailable, Pmode, HARD_FRAME_POINTER_REGNUM);\n-#endif\n-\t}\n-\n-      while (all_chains)\n-\t{\n-\t  int new_reg, best_new_reg, best_nregs;\n-\t  int n_uses;\n-\t  struct du_head *this_head = all_chains;\n-\t  struct du_chain *tmp;\n-\t  HARD_REG_SET this_unavailable;\n-\t  int reg = this_head->regno;\n-\t  int pass;\n-\t  enum reg_class super_class = NO_REGS;\n-\t  enum reg_class preferred_class;\n-\t  bool has_preferred_class;\n-\n-\t  all_chains = this_head->next_chain;\n-\n-\t  if (this_head->cannot_rename)\n-\t    continue;\n-\n-\t  best_new_reg = reg;\n-\t  best_nregs = this_head->nregs;\n-\n-#if 0 /* This just disables optimization opportunities.  */\n-\t  /* Only rename once we've seen the reg more than once.  */\n-\t  if (! TEST_HARD_REG_BIT (regs_seen, reg))\n-\t    {\n-\t      SET_HARD_REG_BIT (regs_seen, reg);\n-\t      continue;\n-\t    }\n-#endif\n-\n-\t  if (fixed_regs[reg] || global_regs[reg]\n-#if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n-\t      || (frame_pointer_needed && reg == HARD_FRAME_POINTER_REGNUM)\n-#else\n-\t      || (frame_pointer_needed && reg == FRAME_POINTER_REGNUM)\n-#endif\n-\t      )\n-\t    continue;\n-\n-\t  COPY_HARD_REG_SET (this_unavailable, unavailable);\n-\n-\t  /* Iterate over elements in the chain in order to:\n-\t     1. Count number of uses, and narrow the set of registers we can\n-\t\tuse for renaming.\n-\t     2. Compute the superunion of register classes in this chain.  */\n-\t  n_uses = 0;\n-\t  super_class = NO_REGS;\n-\t  for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n-\t    {\n-\t      if (DEBUG_INSN_P (tmp->insn))\n-\t\tcontinue;\n-\t      n_uses++;\n-\t      IOR_COMPL_HARD_REG_SET (this_unavailable,\n-\t\t\t\t      reg_class_contents[tmp->cl]);\n-\t      super_class\n-\t\t= reg_class_superunion[(int) super_class][(int) tmp->cl];\n-\t    }\n-\n-\t  if (n_uses < 2)\n-\t    continue;\n-\n-\t  /* Further narrow the set of registers we can use for renaming.\n-\t     If the chain needs a call-saved register, mark the call-used\n-\t     registers as unavailable.  */\n-\t  if (this_head->need_caller_save_reg)\n-\t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n-\n-\t  /* And mark registers that overlap its lifetime as unavailable.  */\n-\t  merge_overlapping_regs (&this_unavailable, this_head);\n-\n-\t  /* Compute preferred rename class of super union of all the classes\n-\t     in the chain.  */\n-\t  preferred_class\n-\t    = (enum reg_class) targetm.preferred_rename_class (super_class);\n-\n-\t  /* If PREFERRED_CLASS is not NO_REGS, we iterate in the first pass\n-\t     over registers that belong to PREFERRED_CLASS and try to find the\n-\t     best register within the class.  If that failed, we iterate in\n-\t     the second pass over registers that don't belong to the class.\n-\t     If PREFERRED_CLASS is NO_REGS, we iterate over all registers in\n-\t     ascending order without any preference.  */\n-\t  has_preferred_class = (preferred_class != NO_REGS);\n-\t  for (pass = (has_preferred_class ? 0 : 1); pass < 2; pass++)\n-\t    {\n-\t      for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n-\t\t{\n-\t\t  if (has_preferred_class\n-\t\t      && (pass == 0)\n-\t\t\t != TEST_HARD_REG_BIT\n-\t\t\t    (reg_class_contents[preferred_class], new_reg))\n-\t\t    continue;\n-\n-\t\t  /* In the first pass, we force the renaming of registers that\n-\t\t     don't belong to PREFERRED_CLASS to registers that do, even\n-\t\t     though the latters were used not very long ago.  */\n-\t\t  if (check_new_reg_p (reg, new_reg, this_head,\n-\t\t\t\t       this_unavailable)\n-\t\t      && ((pass == 0\n-\t\t\t   && !TEST_HARD_REG_BIT\n-\t\t\t       (reg_class_contents[preferred_class],\n-\t\t\t        best_new_reg))\n-\t\t\t  || tick[best_new_reg] > tick[new_reg]))\n-\t\t    {\n-\t\t      enum machine_mode mode\n-\t\t\t= GET_MODE (*this_head->first->loc);\n-\t\t      best_new_reg = new_reg;\n-\t\t      best_nregs = hard_regno_nregs[new_reg][mode];\n-\t\t    }\n-\t\t}\n-\t      if (pass == 0 && best_new_reg != reg)\n-\t\tbreak;\n-\t    }\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Register %s in insn %d\",\n-\t\t       reg_names[reg], INSN_UID (this_head->first->insn));\n-\t      if (this_head->need_caller_save_reg)\n-\t\tfprintf (dump_file, \" crosses a call\");\n-\t    }\n-\n-\t  if (best_new_reg == reg)\n-\t    {\n-\t      tick[reg] = ++this_tick;\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"; no available better choice\\n\");\n-\t      continue;\n-\t    }\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n-\n-\t  do_replace (this_head, best_new_reg);\n-\t  this_head->regno = best_new_reg;\n-\t  this_head->nregs = best_nregs;\n-\t  tick[best_new_reg] = ++this_tick;\n-\t  df_set_regs_ever_live (best_new_reg, true);\n-\t}\n+      rename_chains (all_chains);\n \n       free_chain_data ();\n       obstack_free (&rename_obstack, first_obj);\n@@ -475,24 +510,6 @@ mark_conflict (struct du_head *chains, unsigned id)\n    without renaming.  */\n static bool fail_current_block;\n \n-/* The id to be given to the next opened chain.  */\n-static unsigned current_id;\n-\n-/* List of currently open chains, and closed chains that can be renamed.  */\n-static struct du_head *open_chains;\n-static struct du_head *closed_chains;\n-\n-/* Bitmap of open chains.  The bits set always match the list found in\n-   open_chains.  */\n-static bitmap_head open_chains_set;\n-\n-/* Record the registers being tracked in open_chains.  */\n-static HARD_REG_SET live_in_chains;\n-\n-/* Record the registers that are live but not tracked.  The intersection\n-   between this and live_in_chains is empty.  */\n-static HARD_REG_SET live_hard_regs;\n-\n /* Return true if OP is a reg for which all bits are set in PSET, false\n    if all bits are clear.\n    In other cases, set fail_current_block and return false.  */\n@@ -571,7 +588,6 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   head->nregs = this_nregs;\n   head->need_caller_save_reg = 0;\n   head->cannot_rename = 0;\n-  head->terminated = 0;\n \n   VEC_safe_push (du_head_p, heap, id_to_chain, head);\n   head->id = current_id++;\n@@ -650,7 +666,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n       int subset = (this_regno >= head->regno\n \t\t      && this_regno + this_nregs <= head->regno + head->nregs);\n \n-      if (head->terminated\n+      if (!bitmap_bit_p (&open_chains_set, head->id)\n \t  || head->regno + head->nregs <= this_regno\n \t  || this_regno + this_nregs <= head->regno)\n \t{\n@@ -725,7 +741,6 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t{\n \t  unsigned nregs;\n \n-\t  head->terminated = 1;\n \t  if (subset && !superset)\n \t    head->cannot_rename = 1;\n \t  head->next_chain = closed_chains;\n@@ -1384,29 +1399,6 @@ build_def_use (basic_block bb)\n      is still open lives past the basic block, so it can't be renamed.  */\n   return closed_chains;\n }\n-\n-/* Dump all def/use chains in CHAINS to DUMP_FILE.  They are\n-   printed in reverse order as that's how we build them.  */\n-\n-static void\n-dump_def_use_chain (struct du_head *head)\n-{\n-  while (head)\n-    {\n-      struct du_chain *this_du = head->first;\n-      fprintf (dump_file, \"Register %s (%d):\",\n-\t       reg_names[head->regno], head->nregs);\n-      while (this_du)\n-\t{\n-\t  fprintf (dump_file, \" %d [%s]\", INSN_UID (this_du->insn),\n-\t\t   reg_class_names[this_du->cl]);\n-\t  this_du = this_du->next_use;\n-\t}\n-      fprintf (dump_file, \"\\n\");\n-      head = head->next_chain;\n-    }\n-}\n-\n \f\n static bool\n gate_handle_regrename (void)"}]}