{"sha": "51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiMGUwNWFlNGEwYzVhNGVmMzdlNTJmOGUxNzAyYjAyZTZkOGY3Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T14:00:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T14:00:29Z"}, "message": "[multiple changes]\n\n2014-01-20  Tristan Gingold  <gingold@adacore.com>\n\n\t* raise-gcc.c (exception_class_eq): New function.\n\t(is_handled_by): Use it to compare exception classes.\n\t(PERSONALITY_STORAGE): Define.\t(continue_unwind): New function to\n\tbe called to return URC_CONTINUE_UNWIND.\n\t(personality_body): New function, extracted from PERSONALITY_ROUTINE.\n\t(PERSONALITY_ROUTINE): Add an implementation for the ARM unwinder.\n\n2014-01-20  Robert Dewar  <dewar@adacore.com>\n\n\t* opt.ads: Minor comment update.\n\nFrom-SVN: r206815", "tree": {"sha": "eaacabf5dfb722e9027b148fe423cbed60052d8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaacabf5dfb722e9027b148fe423cbed60052d8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72/comments", "author": null, "committer": null, "parents": [{"sha": "5ff90f08f4ccef07ca580c63a7ee5aa896d45527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ff90f08f4ccef07ca580c63a7ee5aa896d45527", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ff90f08f4ccef07ca580c63a7ee5aa896d45527"}], "stats": {"total": 258, "additions": 190, "deletions": 68}, "files": [{"sha": "c5c209b02b12e2d1435fbb21519294692fcd6ef9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "patch": "@@ -1,3 +1,16 @@\n+2014-01-20  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* raise-gcc.c (exception_class_eq): New function.\n+\t(is_handled_by): Use it to compare exception classes.\n+\t(PERSONALITY_STORAGE): Define.\t(continue_unwind): New function to\n+\tbe called to return URC_CONTINUE_UNWIND.\n+\t(personality_body): New function, extracted from PERSONALITY_ROUTINE.\n+\t(PERSONALITY_ROUTINE): Add an implementation for the ARM unwinder.\n+\n+2014-01-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* opt.ads: Minor comment update.\n+\n 2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Slice): Relocate some variables and"}, {"sha": "ba486809a89b34f261faece56847767938a5d729", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "patch": "@@ -1404,7 +1404,9 @@ package Opt is\n    Treat_Categorization_Errors_As_Warnings : Boolean := False;\n    --  Normally categorization errors are true illegalities. If this switch\n    --  is set, then such errors result in warning messages rather than error\n-   --  messages. Set True by -gnateP (P for Pure/Preelaborate).\n+   --  messages. Set True by -gnateP (P for Pure/Preelaborate). Also set in\n+   --  Relaxed_RM_Semantics mode since some old Ada 83 compilers treated\n+   --  pragma Preelaborate differently.\n \n    Treat_Restrictions_As_Warnings : Boolean := False;\n    --  GNAT"}, {"sha": "53fc070caa135908c5ca5de9e3b568a015604355", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 174, "deletions": 67, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "patch": "@@ -212,7 +212,7 @@ db_phases (int phases)\n {\n   const phase_descriptor *a = phase_descriptors;\n \n-  if (! (db_accepted_codes() & DB_PHASES))\n+  if (! (db_accepted_codes () & DB_PHASES))\n     return;\n \n   db (DB_PHASES, \"\\n\");\n@@ -860,15 +860,33 @@ extern struct Exception_Data Foreign_Exception;\n extern struct Exception_Data Non_Ada_Error;\n #endif\n \n+/* Return true iff the exception class of EXCEPT is EC.  */\n+\n+static int\n+exception_class_eq (const _GNAT_Exception *except, unsigned long long ec)\n+{\n+#ifdef __ARM_EABI_UNWINDER__\n+  union {\n+    char exception_class[8];\n+    unsigned long long ec;\n+  } u;\n+\n+  u.ec = ec;\n+  return memcmp (except->common.exception_class, u.exception_class, 8) == 0;\n+#else\n+  return except->common.exception_class == ec;\n+#endif\n+}\n+\n static enum action_kind\n-is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n+is_handled_by (_Unwind_Ptr choice, _GNAT_Exception *propagated_exception)\n {\n   /* All others choice match everything.  */\n   if (choice == GNAT_ALL_OTHERS)\n     return handler;\n \n   /* GNAT exception occurrence.  */\n-  if (propagated_exception->common.exception_class == GNAT_EXCEPTION_CLASS)\n+  if (exception_class_eq (propagated_exception, GNAT_EXCEPTION_CLASS))\n     {\n       /* Pointer to the GNAT exception data corresponding to the propagated\n          occurrence.  */\n@@ -913,7 +931,7 @@ is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n     return handler;\n \n   /* C++ exception occurrences.  */\n-  if (propagated_exception->common.exception_class == CXX_EXCEPTION_CLASS\n+  if (exception_class_eq (propagated_exception, CXX_EXCEPTION_CLASS)\n       && Language_For (choice) == 'C')\n     {\n       void *choice_typeinfo = Foreign_Data_For (choice);\n@@ -1070,14 +1088,120 @@ extern void __gnat_notify_unhandled_exception (struct Exception_Occurrence *);\n /* Below is the eh personality routine per se. We currently assume that only\n    GNU-Ada exceptions are met.  */\n \n+/* By default, the personality routine is public.  */\n+#define PERSONALITY_STORAGE\n+\n #ifdef __USING_SJLJ_EXCEPTIONS__\n #define PERSONALITY_FUNCTION    __gnat_personality_sj0\n #elif defined (__SEH__)\n #define PERSONALITY_FUNCTION    __gnat_personality_imp\n+/* The public personality routine for seh is __gnat_personality_seh0, defined\n+   below using the SEH convention. This is a wrapper around the GNU routine,\n+   which is static.  */\n+#undef PERSONALITY_STORAGE\n+#define PERSONALITY_STORAGE static\n #else\n #define PERSONALITY_FUNCTION    __gnat_personality_v0\n #endif\n \n+/* Code executed to continue unwinding.  With the ARM unwinder, the\n+   personality routine must unwind one frame.  */\n+\n+static _Unwind_Reason_Code\n+continue_unwind (struct _Unwind_Exception* ue_header,\n+\t\t struct _Unwind_Context* uw_context)\n+{\n+#ifdef __ARM_EABI_UNWINDER__\n+  if (__gnu_unwind_frame (ue_header, uw_context) != _URC_OK)\n+    return _URC_FAILURE;\n+#endif\n+  return _URC_CONTINUE_UNWIND;\n+}\n+\n+/* Common code for the body of GNAT personality routine.  This code is shared\n+   between all unwinders.  */\n+\n+static _Unwind_Reason_Code\n+personality_body (_Unwind_Action uw_phases,\n+\t\t  _Unwind_Exception *uw_exception,\n+\t\t  _Unwind_Context *uw_context)\n+{\n+  region_descriptor region;\n+  action_descriptor action;\n+  _Unwind_Ptr ip;\n+\n+  /* Debug traces.  */\n+  db_indent (DB_INDENT_RESET);\n+  db_phases (uw_phases);\n+  db_indent (DB_INDENT_INCREASE);\n+\n+  /* Get the region description for the context we were provided with. This\n+     will tell us if there is some lsda, call_site, action and/or ttype data\n+     for the associated ip.  */\n+  get_region_description_for (uw_context, &region);\n+\n+  /* No LSDA => no handlers or cleanups => we shall unwind further up.  */\n+  if (! region.lsda)\n+    return continue_unwind (uw_exception, uw_context);\n+\n+  /* Get the instruction pointer.  */\n+  ip = get_ip_from_context (uw_context);\n+  db_region_for (&region, ip);\n+\n+  /* Search the call-site and action-record tables for the action associated\n+     with this IP.  */\n+  get_action_description_for (ip, uw_exception, uw_phases, &region, &action);\n+  db_action_for (&action, ip);\n+\n+  /* Whatever the phase, if there is nothing relevant in this frame,\n+     unwinding should just go on.  */\n+  if (action.kind == nothing)\n+    return continue_unwind (uw_exception, uw_context);\n+\n+  /* If we found something in search phase, we should return a code indicating\n+     what to do next depending on what we found. If we only have cleanups\n+     around, we shall try to unwind further up to find a handler, otherwise,\n+     tell we have a handler, which will trigger the second phase.  */\n+  if (uw_phases & _UA_SEARCH_PHASE)\n+    {\n+      if (action.kind == cleanup)\n+\t{\n+\t  return continue_unwind (uw_exception, uw_context);\n+\t}\n+      else\n+\t{\n+\t  struct Exception_Occurrence *excep;\n+\n+\t  /* Trigger the appropriate notification routines before the second\n+\t     phase starts, which ensures the stack is still intact.\n+             First, setup the Ada occurrence.  */\n+          excep = __gnat_setup_current_excep (uw_exception);\n+\t  if (action.kind == unhandler)\n+\t    __gnat_notify_unhandled_exception (excep);\n+\t  else\n+\t    __gnat_notify_handled_exception (excep);\n+\n+\t  return _URC_HANDLER_FOUND;\n+\t}\n+    }\n+\n+  /* We found something in cleanup/handler phase, which might be the handler\n+     or a cleanup for a handled occurrence, or a cleanup for an unhandled\n+     occurrence (we are in a FORCED_UNWIND phase in this case). Install the\n+     context to get there.  */\n+\n+  setup_to_install\n+    (uw_context, uw_exception, action.landing_pad, action.ttype_filter);\n+\n+  /* Write current exception, so that it can be retrieved from Ada.  It was\n+     already done during phase 1 (just above), but in between, one or several\n+     exceptions may have been raised (in cleanup handlers).  */\n+  __gnat_setup_current_excep (uw_exception);\n+\n+  return _URC_INSTALL_CONTEXT;\n+}\n+\n+#ifndef __ARM_EABI_UNWINDER__\n /* Major tweak for ia64-vms : the CHF propagation phase calls this personality\n    routine with sigargs/mechargs arguments and has very specific expectations\n    on possible return values.\n@@ -1109,15 +1233,12 @@ typedef int version_arg_t;\n typedef _Unwind_Action phases_arg_t;\n #endif\n \n-#if defined (__SEH__) && !defined (__USING_SJLJ_EXCEPTIONS__)\n-static\n-#endif\n-_Unwind_Reason_Code\n+PERSONALITY_STORAGE _Unwind_Reason_Code\n PERSONALITY_FUNCTION (version_arg_t, phases_arg_t,\n                       _Unwind_Exception_Class, _Unwind_Exception *,\n                       _Unwind_Context *);\n \n-_Unwind_Reason_Code\n+PERSONALITY_STORAGE _Unwind_Reason_Code\n PERSONALITY_FUNCTION (version_arg_t version_arg,\n                       phases_arg_t phases_arg,\n                       _Unwind_Exception_Class uw_exception_class\n@@ -1157,73 +1278,59 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n       return _URC_FATAL_PHASE1_ERROR;\n     }\n \n-  db_indent (DB_INDENT_RESET);\n-  db_phases (uw_phases);\n-  db_indent (DB_INDENT_INCREASE);\n-\n-  /* Get the region description for the context we were provided with. This\n-     will tell us if there is some lsda, call_site, action and/or ttype data\n-     for the associated ip.  */\n-  get_region_description_for (uw_context, &region);\n-  ip = get_ip_from_context (uw_context);\n-  db_region_for (&region, ip);\n+  return personality_body (uw_phases, uw_exception, uw_context);\n+}\n \n-  /* No LSDA => no handlers or cleanups => we shall unwind further up.  */\n-  if (! region.lsda)\n-    return _URC_CONTINUE_UNWIND;\n+#else /* __ARM_EABI_UNWINDER__ */\n \n-  /* Search the call-site and action-record tables for the action associated\n-     with this IP.  */\n-  get_action_description_for (ip, uw_exception, uw_phases, &region, &action);\n-  db_action_for (&action, ip);\n+PERSONALITY_STORAGE _Unwind_Reason_Code\n+PERSONALITY_FUNCTION (_Unwind_State state,\n+\t\t      struct _Unwind_Exception* ue_header,\n+\t\t      struct _Unwind_Context* uw_context);\n \n-  /* Whatever the phase, if there is nothing relevant in this frame,\n-     unwinding should just go on.  */\n-  if (action.kind == nothing)\n-    return _URC_CONTINUE_UNWIND;\n+PERSONALITY_STORAGE _Unwind_Reason_Code\n+PERSONALITY_FUNCTION (_Unwind_State state,\n+\t\t      struct _Unwind_Exception* uw_exception,\n+\t\t      struct _Unwind_Context* uw_context)\n+{\n+  _Unwind_Action uw_phases;\n+  region_descriptor region;\n+  action_descriptor action;\n+  _Unwind_Ptr ip;\n \n-  /* If we found something in search phase, we should return a code indicating\n-     what to do next depending on what we found. If we only have cleanups\n-     around, we shall try to unwind further up to find a handler, otherwise,\n-     tell we have a handler, which will trigger the second phase.  */\n-  if (uw_phases & _UA_SEARCH_PHASE)\n+  switch (state & _US_ACTION_MASK)\n     {\n-      if (action.kind == cleanup)\n-\t{\n-\t  return _URC_CONTINUE_UNWIND;\n-\t}\n-      else\n-\t{\n-\t  struct Exception_Occurrence *excep;\n-\n-\t  /* Trigger the appropriate notification routines before the second\n-\t     phase starts, which ensures the stack is still intact.\n-             First, setup the Ada occurrence.  */\n-          excep = __gnat_setup_current_excep (uw_exception);\n-\t  if (action.kind == unhandler)\n-\t    __gnat_notify_unhandled_exception (excep);\n-\t  else\n-\t    __gnat_notify_handled_exception (excep);\n-\n-\t  return _URC_HANDLER_FOUND;\n-\t}\n+    case _US_VIRTUAL_UNWIND_FRAME:\n+      /* Phase 1.  */\n+      uw_phases = _UA_SEARCH_PHASE;\n+      break;\n+\n+    case _US_UNWIND_FRAME_STARTING:\n+      uw_phases = _UA_CLEANUP_PHASE;\n+      if (!(state & _US_FORCE_UNWIND)\n+\t  && (uw_exception->barrier_cache.sp\n+\t      == _Unwind_GetGR (uw_context, UNWIND_STACK_REG)))\n+\tuw_phases |= _UA_HANDLER_FRAME;\n+      break;\n+\n+    case _US_UNWIND_FRAME_RESUME:\n+      return continue_unwind (uw_exception, uw_context);\n+\n+    default:\n+      return _URC_FAILURE;\n     }\n+  uw_phases |= (state & _US_FORCE_UNWIND);\n \n-  /* We found something in cleanup/handler phase, which might be the handler\n-     or a cleanup for a handled occurrence, or a cleanup for an unhandled\n-     occurrence (we are in a FORCED_UNWIND phase in this case). Install the\n-     context to get there.  */\n+  /* The dwarf unwinder assumes the context structure holds things like the\n+     function and LSDA pointers.  The ARM implementation caches these in\n+     the exception header (UCB).  To avoid rewriting everything we make a\n+     virtual scratch register point at the UCB.  This is a GNU specific\n+     requirement.  */\n+  _Unwind_SetGR (uw_context, UNWIND_POINTER_REG, (_Unwind_Ptr) uw_exception);\n \n-  setup_to_install\n-    (uw_context, uw_exception, action.landing_pad, action.ttype_filter);\n-\n-  /* Write current exception, so that it can be retrieved from Ada.  It was\n-     already done during phase 1 (just above), but in between, one or several\n-     exceptions may have been raised (in cleanup handlers).  */\n-  __gnat_setup_current_excep (uw_exception);\n-\n-  return _URC_INSTALL_CONTEXT;\n+  return personality_body (uw_phases, uw_exception, uw_context);\n }\n+#endif /* __ARM_EABI_UNWINDER__ */\n \n /* Callback routine called by Unwind_ForcedUnwind to execute all the cleanup\n    before exiting the task.  */"}]}