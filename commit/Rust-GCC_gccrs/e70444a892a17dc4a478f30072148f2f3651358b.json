{"sha": "e70444a892a17dc4a478f30072148f2f3651358b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcwNDQ0YTg5MmExN2RjNGE0NzhmMzAwNzIxNDhmMmYzNjUxMzU4Yg==", "commit": {"author": {"name": "Harsha Jagasia", "email": "harsha.jagasia@amd.com", "date": "2007-09-11T00:13:47Z"}, "committer": {"name": "Harsha Jagasia", "email": "hjagasia@gcc.gnu.org", "date": "2007-09-11T00:13:47Z"}, "message": "rsha Jagasia <harsha.jagasia@amd.com>\n            Jan Sjodin <jan.sjodin@amd.com>\n        \n        * tree-vect-analyze.c (vect_analyze_operations): Change\n        comparison of loop iterations with threshold to less than\n        or equal to instead of less than. Reduce\n        min_scalar_loop_bound by one.\n        * tree-vect-transform.c (vect_estimate_min_profitable_iters): \n        Change prologue and epilogue iterations estimate to vf/2,\n        when unknown at compile-time. Change versioning guard\n        cost to taken_branch_cost. If peeling for alignment is\n        unknown at compile-time, change peel guard costs to one\n        taken branch and one not-taken branch per peeled loop.\n        If peeling for alignment is known but number of scalar loop\n        iterations is unknown at compile-time, change peel guard\n        costs to one taken branch per peeled loop. Change the cost\n        model equation to consider vector iterations as the loop\n        iterations less the prologue and epilogue iterations.\n        Change outside vector cost check to less than or equal to\n        zero instead of equal to zero.\n        (vect_do_peeling_for_loop_bound): Reduce\n        min_scalar_loop_bound by one.\n        * tree-vectorizer.h: Add TARG_COND_TAKEN_BRANCH_COST and\n        TARG_COND_NOT_TAKEN_BRANCH_COST.        \n        * config/i386/i386.h (processor_costs): Add\n        scalar_stmt_cost, scalar_load_cost, scalar_store_cost,\n        vec_stmt_cost, vec_to_scalar_cost, scalar_to_vec_cost,\n        vec_align_load_cost, vect_unalign_load_cost,\n        vec_store_cost, cond_taken_branch_cost,\n        cond_not_taken_branch_cost.\n        Define macros for x86 costs.\n        * config/i386/i386.c:\n        (size_cost): Set scalar_stmt_cost, scalar_load_cost,\n        scalar_store_cost, vec_stmt_cost, vec_to_scalar_cost,\n        scalar_to_vec_cost, vec_align_load_cost, \n        vect_unalign_load_cost, vec_store_cost,\n        cond_taken_branch_cost, cond_not_taken_branch_cost to one. \n        (i386_cost, i486_cost, pentium_cost, pentiumpro_cost,\n        geode_cost, k6_cost, athlon_cost, pentium4_cost, nocona_cost, \n        core2_cost, generic64_cost, generic32_cost): Set to default\n        untuned costs.\n        (k8_cost, amdfam10_cost): Costs for vectorization tuned.\n        (x86_builtin_vectorization_cost): New.\n\n2007-09-10  Harsha Jagasia <harsha.jagasia@amd.com>\n\n        * gcc.dg/vect/costmodel/i386/costmodel-vect-31.c: \n        Change dg-final to expect 1 non-profitable loop and\n        3 profitable loops.\n        * gcc.dg/vect/costmodel/x86-64/costmodel-vect-31.c:\n        Change dg-final to expect 1 non-profitable loop and\n        3 profitable loops.\n        * gcc.dg/vect/costmodel/x86-64/costmodel-fast-math-vect-pr29925.c:\n        Change dg-final to expect 1 profitable loop.\n        * gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c:\n        Change dg-final to expect 1 profitable loop.\n\n\nCo-Authored-By: Jan Sjodin <jan.sjodin@amd.com>\n\nFrom-SVN: r128353", "tree": {"sha": "ac4783aa576a9af7b40d78f139e042b91e781996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac4783aa576a9af7b40d78f139e042b91e781996"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e70444a892a17dc4a478f30072148f2f3651358b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70444a892a17dc4a478f30072148f2f3651358b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e70444a892a17dc4a478f30072148f2f3651358b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70444a892a17dc4a478f30072148f2f3651358b/comments", "author": null, "committer": null, "parents": [{"sha": "2533577ff6607c4fe093acb0fb711a003a4b3eeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2533577ff6607c4fe093acb0fb711a003a4b3eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2533577ff6607c4fe093acb0fb711a003a4b3eeb"}], "stats": {"total": 450, "additions": 384, "deletions": 66}, "files": [{"sha": "ab75d14b9122ee9f840e2f69d42f9f8427c1c63d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -1,3 +1,47 @@\n+2007-09-10  Harsha Jagasia <harsha.jagasia@amd.com>\n+            Jan Sjodin <jan.sjodin@amd.com>\n+\t\n+\t* tree-vect-analyze.c (vect_analyze_operations): Change\n+\tcomparison of loop iterations with threshold to less than\n+\tor equal to instead of less than. Reduce\n+\tmin_scalar_loop_bound by one.\n+\t* tree-vect-transform.c (vect_estimate_min_profitable_iters): \n+\tChange prologue and epilogue iterations estimate to vf/2,\n+\twhen unknown at compile-time. Change versioning guard\n+\tcost to taken_branch_cost. If peeling for alignment is\n+\tunknown at compile-time, change peel guard costs to one\n+\ttaken branch and one not-taken branch per peeled loop.\n+\tIf peeling for alignment is known but number of scalar loop\n+\titerations is unknown at compile-time, change peel guard\n+\tcosts to one taken branch per peeled loop. Change the cost\n+\tmodel equation to consider vector iterations as the loop\n+\titerations less the prologue and epilogue iterations.\n+\tChange outside vector cost check to less than or equal to\n+\tzero instead of equal to zero.\n+\t(vect_do_peeling_for_loop_bound): Reduce\n+\tmin_scalar_loop_bound by one.\n+\t* tree-vectorizer.h: Add TARG_COND_TAKEN_BRANCH_COST and\n+\tTARG_COND_NOT_TAKEN_BRANCH_COST.\t\n+\t* config/i386/i386.h (processor_costs): Add\n+\tscalar_stmt_cost, scalar_load_cost, scalar_store_cost,\n+\tvec_stmt_cost, vec_to_scalar_cost, scalar_to_vec_cost,\n+\tvec_align_load_cost, vect_unalign_load_cost,\n+\tvec_store_cost, cond_taken_branch_cost,\n+\tcond_not_taken_branch_cost.\n+\tDefine macros for x86 costs.\n+\t* config/i386/i386.c:\n+\t(size_cost): Set scalar_stmt_cost, scalar_load_cost,\n+\tscalar_store_cost, vec_stmt_cost, vec_to_scalar_cost,\n+\tscalar_to_vec_cost, vec_align_load_cost, \n+\tvect_unalign_load_cost, vec_store_cost,\n+\tcond_taken_branch_cost, cond_not_taken_branch_cost to one. \n+\t(i386_cost, i486_cost, pentium_cost, pentiumpro_cost,\n+\tgeode_cost, k6_cost, athlon_cost, pentium4_cost, nocona_cost, \n+\tcore2_cost, generic64_cost, generic32_cost): Set to default\n+\tuntuned costs.\n+\t(k8_cost, amdfam10_cost): Costs for vectorization tuned.\n+\t(x86_builtin_vectorization_cost): New.\n+\n 2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n \t    Ben Elliston  <bje@au.ibm.com>\n "}, {"sha": "ce7c19b46ec59ecbd5b6eb77e4558f0c64d289cd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 206, "deletions": 12, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -52,6 +52,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm-constrs.h\"\n #include \"params.h\"\n \n+static int x86_builtin_vectorization_cost (bool);\n+\n #ifndef CHECK_STACK_LIMIT\n #define CHECK_STACK_LIMIT (-1)\n #endif\n@@ -126,7 +128,18 @@ struct processor_costs size_cost = {\t/* costs for tuning for size */\n   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n-   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}}\n+   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  1,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  1,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n /* Processor costs (relative to an add) */\n@@ -187,6 +200,17 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n    DUMMY_STRINGOP_ALGS},\n   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -247,7 +271,18 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n   {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n-   DUMMY_STRINGOP_ALGS}\n+   DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -306,7 +341,18 @@ struct processor_costs pentium_cost = {\n   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{-1, rep_prefix_4_byte}}},\n-   DUMMY_STRINGOP_ALGS}\n+   DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -372,7 +418,18 @@ struct processor_costs pentiumpro_cost = {\n    DUMMY_STRINGOP_ALGS},\n   {{rep_prefix_4_byte, {{1024, unrolled_loop},\n   \t\t        {8192, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}\n+   DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -432,7 +489,18 @@ struct processor_costs geode_cost = {\n   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}\n+   DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -494,7 +562,18 @@ struct processor_costs k6_cost = {\n   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}\n+   DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -556,7 +635,18 @@ struct processor_costs athlon_cost = {\n   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}\n+   DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -624,7 +714,18 @@ struct processor_costs k8_cost = {\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  4,                                    /* scalar_stmt_cost.  */\n+  2,                                    /* scalar load_cost.  */\n+  2,                                    /* scalar_store_cost.  */\n+  5,                                    /* vec_stmt_cost.  */\n+  0,                                    /* vec_to_scalar_cost.  */\n+  2,                                    /* scalar_to_vec_cost.  */\n+  2,                                    /* vec_align_load_cost.  */\n+  3,                                    /* vec_unalign_load_cost.  */\n+  3,                                    /* vec_store_cost.  */\n+  6,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n struct processor_costs amdfam10_cost = {\n@@ -700,7 +801,18 @@ struct processor_costs amdfam10_cost = {\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  4,                                    /* scalar_stmt_cost.  */\n+  2,                                    /* scalar load_cost.  */\n+  2,                                    /* scalar_store_cost.  */\n+  6,                                    /* vec_stmt_cost.  */\n+  0,                                    /* vec_to_scalar_cost.  */\n+  2,                                    /* scalar_to_vec_cost.  */\n+  2,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  2,                                    /* vec_store_cost.  */\n+  6,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -761,6 +873,17 @@ struct processor_costs pentium4_cost = {\n   {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n    {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -822,7 +945,18 @@ struct processor_costs nocona_cost = {\n   {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n    {-1, libcall}}},\n    {libcall, {{24, loop}, {64, unrolled_loop},\n-\t      {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n+\t      {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -883,7 +1017,18 @@ struct processor_costs core2_cost = {\n   {{libcall, {{8, loop}, {15, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{24, loop}, {32, unrolled_loop},\n-\t      {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n+\t      {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n /* Generic64 should produce code tuned for Nocona and K8.  */\n@@ -949,7 +1094,18 @@ struct processor_costs generic64_cost = {\n   {DUMMY_STRINGOP_ALGS,\n    {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {DUMMY_STRINGOP_ALGS,\n-   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n+   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n /* Generic32 should produce code tuned for Athlon, PPro, Pentium4, Nocona and K8.  */\n@@ -1010,6 +1166,17 @@ struct processor_costs generic32_cost = {\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n+  1,                                    /* scalar_stmt_cost.  */\n+  1,                                    /* scalar load_cost.  */\n+  1,                                    /* scalar_store_cost.  */\n+  1,                                    /* vec_stmt_cost.  */\n+  1,                                    /* vec_to_scalar_cost.  */\n+  1,                                    /* scalar_to_vec_cost.  */\n+  1,                                    /* vec_align_load_cost.  */\n+  2,                                    /* vec_unalign_load_cost.  */\n+  1,                                    /* vec_store_cost.  */\n+  3,                                    /* cond_taken_branch_cost.  */\n+  1,                                    /* cond_not_taken_branch_cost.  */\n };\n \n const struct processor_costs *ix86_cost = &pentium_cost;\n@@ -23615,6 +23782,30 @@ static const struct attribute_spec ix86_attribute_table[] =\n   { NULL,        0, 0, false, false, false, NULL }\n };\n \n+/* Implement targetm.vectorize.builtin_vectorization_cost.  */\n+static int \n+x86_builtin_vectorization_cost (bool runtime_test)\n+{\n+  /* If the branch of the runtime test is taken - i.e. - the vectorized\n+     version is skipped - this incurs a misprediction cost (because the\n+     vectorized version is expected to be the fall-through).  So we subtract\n+     the latency of a mispredicted branch from the costs that are incured\n+     when the vectorized version is executed.\n+\n+     TODO: The values in individual target tables have to be tuned or new\n+     fields may be needed. For eg. on K8, the default branch path is the\n+     not-taken path. If the taken path is predicted correctly, the minimum\n+     penalty of going down the taken-path is 1 cycle. If the taken-path is\n+     not predicted correctly, then the minimum penalty is 10 cycles.  */\n+\n+  if (runtime_test)\n+    {\n+      return (-(ix86_cost->cond_taken_branch_cost));\n+    }\n+  else\n+    return 0;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE ix86_attribute_table\n@@ -23791,6 +23982,9 @@ static const struct attribute_spec ix86_attribute_table[] =\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE ix86_function_value\n \n+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST x86_builtin_vectorization_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "a14c74b101d583c3bfa3e6c5730f1b3666a3eb3d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -138,6 +138,22 @@ struct processor_costs {\n \t\t\t\t/* Specify what algorithm\n \t\t\t\t   to use for stringops on unknown size.  */\n   struct stringop_algs memcpy[2], memset[2];\n+  const int scalar_stmt_cost;   /* Cost of any scalar operation, excluding\n+\t\t\t\t   load and store.  */\n+  const int scalar_load_cost;   /* Cost of scalar load.  */\n+  const int scalar_store_cost;  /* Cost of scalar store.  */\n+  const int vec_stmt_cost;      /* Cost of any vector operation, excluding\n+                                   load, store, vector-to-scalar and\n+                                   scalar-to-vector operation.  */\n+  const int vec_to_scalar_cost;    /* Cost of vect-to-scalar operation.  */\n+  const int scalar_to_vec_cost;    /* Cost of scalar-to-vector operation.  */\n+  const int vec_align_load_cost;   /* Cost of aligned vector load.  */ \n+  const int vec_unalign_load_cost; /* Cost of unaligned vector load.  */\n+  const int vec_store_cost;        /* Cost of vector store.  */\n+  const int cond_taken_branch_cost;    /* Cost of taken branch for vectorizer\n+\t\t\t\t\t  cost model.  */\n+  const int cond_not_taken_branch_cost;/* Cost of not taken branch for\n+\t\t\t\t\t  vectorizer cost model.  */\n };\n \n extern const struct processor_costs *ix86_cost;\n@@ -2460,6 +2476,57 @@ struct machine_function GTY(())\n #define SYMBOL_REF_DLLEXPORT_P(X) \\\n \t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_DLLEXPORT) != 0)\n \n+/* Model costs for vectorizer.  */\n+\n+/* Cost of conditional branch.  */\n+#undef TARG_COND_BRANCH_COST\n+#define TARG_COND_BRANCH_COST           ix86_cost->branch_cost\n+\n+/* Cost of any scalar operation, excluding load and store.  */\n+#undef TARG_SCALAR_STMT_COST\n+#define TARG_SCALAR_STMT_COST           ix86_cost->scalar_stmt_cost\n+\n+/* Cost of scalar load.  */\n+#undef TARG_SCALAR_LOAD_COST\n+#define TARG_SCALAR_LOAD_COST           ix86_cost->scalar_load_cost\n+\n+/* Cost of scalar store.  */\n+#undef TARG_SCALAR_STORE_COST\n+#define TARG_SCALAR_STORE_COST          ix86_cost->scalar_store_cost\n+\n+/* Cost of any vector operation, excluding load, store or vector to scalar\n+   operation.  */ \n+#undef TARG_VEC_STMT_COST\n+#define TARG_VEC_STMT_COST              ix86_cost->vec_stmt_cost\n+\n+/* Cost of vector to scalar operation.  */\n+#undef TARG_VEC_TO_SCALAR_COST\n+#define TARG_VEC_TO_SCALAR_COST         ix86_cost->vec_to_scalar_cost\n+\n+/* Cost of scalar to vector operation.  */\n+#undef TARG_SCALAR_TO_VEC_COST\n+#define TARG_SCALAR_TO_VEC_COST         ix86_cost->scalar_to_vec_cost\n+\n+/* Cost of aligned vector load.  */\n+#undef TARG_VEC_LOAD_COST\n+#define TARG_VEC_LOAD_COST              ix86_cost->vec_align_load_cost\n+\n+/* Cost of misaligned vector load.  */\n+#undef TARG_VEC_UNALIGNED_LOAD_COST\n+#define TARG_VEC_UNALIGNED_LOAD_COST    ix86_cost->vec_unalign_load_cost\n+\n+/* Cost of vector store.  */\n+#undef TARG_VEC_STORE_COST\n+#define TARG_VEC_STORE_COST             ix86_cost->vec_store_cost\n+\n+/* Cost of conditional taken branch for vectorizer cost model.  */\n+#undef TARG_COND_TAKEN_BRANCH_COST\n+#define TARG_COND_TAKEN_BRANCH_COST     ix86_cost->cond_taken_branch_cost\n+\n+/* Cost of conditional not taken branch for vectorizer cost model.  */\n+#undef TARG_COND_NOT_TAKEN_BRANCH_COST\n+#define TARG_COND_NOT_TAKEN_BRANCH_COST ix86_cost->cond_not_taken_branch_cost\n+\n /*\n Local variables:\n version-control: t"}, {"sha": "aca143371ff4cad73110b0582d365ad9e027cda6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -1,3 +1,16 @@\n+2007-09-10  Harsha Jagasia <harsha.jagasia@amd.com>\n+\n+        * gcc.dg/vect/costmodel/i386/costmodel-vect-31.c: \n+\tChange dg-final to expect 1 non-profitable loop and\n+\t3 profitable loops.\n+        * gcc.dg/vect/costmodel/x86-64/costmodel-vect-31.c:\n+\tChange dg-final to expect 1 non-profitable loop and\n+\t3 profitable loops.\n+        * gcc.dg/vect/costmodel/x86-64/costmodel-fast-math-vect-pr29925.c:\n+\tChange dg-final to expect 1 profitable loop.\n+        * gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c:\n+\tChange dg-final to expect 1 profitable loop.\t\n+\t\n 2007-09-10  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gcc.target/mips/call-saved-1.c: New test."}, {"sha": "2766ced28715ed0be2f12a8e3e077c569b16389a", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-fast-math-vect-pr29925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-fast-math-vect-pr29925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-fast-math-vect-pr29925.c?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -35,6 +35,6 @@ int main()\n    return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "efab30d4ac6c5a08c7d9766f996b100c5518d444", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-31.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -85,7 +85,7 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" } }\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } }\n  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0bc09f6da32eed09e0105e9a5f6888e2795186d8", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-fast-math-vect-pr29925.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-fast-math-vect-pr29925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-fast-math-vect-pr29925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-fast-math-vect-pr29925.c?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -35,6 +35,6 @@ int main()\n    return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "efab30d4ac6c5a08c7d9766f996b100c5518d444", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -85,7 +85,7 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" } }\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } }\n  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "557bf2fb47046bee375b2f573e16210915ac5518", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -596,8 +596,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-  min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND))\n-                          * vectorization_factor;\n+  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t\t\t    * vectorization_factor) - 1);\n \n   /* Use the cost model only if it is more conservative than user specified\n      threshold.  */\n@@ -609,7 +609,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n     th = (unsigned) min_profitable_iters;\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && LOOP_VINFO_INT_NITERS (loop_vinfo) < th)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\t      \n         fprintf (vect_dump, \"not vectorized: vectorization not \""}, {"sha": "e2ee92b0d0e541fb8f00309bbebb4e60c95971b4", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -124,6 +124,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n   int byte_misalign;\n+  int peel_guard_costs = 0;\n   int innerloop_iters = 0, factor;\n   VEC (slp_instance, heap) *slp_instances;\n   slp_instance instance;\n@@ -141,7 +142,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n     {\n-      vec_outside_cost += TARG_COND_BRANCH_COST;\n+      vec_outside_cost += TARG_COND_TAKEN_BRANCH_COST;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n                  \"versioning.\\n\");\n@@ -188,7 +189,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      loop.\n \n      FORNOW: If we dont know the value of peel_iters for prologue or epilogue\n-     at compile-time - we assume it's (vf-1)/2 (the worst would be vf-1).\n+     at compile-time - we assume it's vf/2 (the worst would be vf-1).\n \n      TODO: Build an expression that represents peel_iters for prologue and\n      epilogue to be used in a run-time test.  */\n@@ -197,18 +198,26 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   if (byte_misalign < 0)\n     {\n-      peel_iters_prologue = (vf - 1)/2;\n+      peel_iters_prologue = vf/2;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: \"\n-                 \"prologue peel iters set to (vf-1)/2.\");\n+                 \"prologue peel iters set to vf/2.\");\n \n       /* If peeling for alignment is unknown, loop bound of main loop becomes\n          unknown.  */\n-      peel_iters_epilogue = (vf - 1)/2;\n+      peel_iters_epilogue = vf/2;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: \"\n-                 \"epilogue peel iters set to (vf-1)/2 because \"\n+                 \"epilogue peel iters set to vf/2 because \"\n                  \"peeling for alignment is unknown .\");\n+\n+      /* If peeled iterations are unknown, count a taken branch and a not taken\n+\t branch per peeled loop. Even if scalar loop iterations are known, \n+\t vector iterations are not known since peeled prologue iterations are\n+\t not known. Hence guards remain the same.  */\n+      peel_guard_costs +=  2 * (TARG_COND_TAKEN_BRANCH_COST\n+\t\t\t       + TARG_COND_NOT_TAKEN_BRANCH_COST);\n+\n     }\n   else \n     {\n@@ -226,11 +235,16 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n       if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n         {\n-          peel_iters_epilogue = (vf - 1)/2;\n+          peel_iters_epilogue = vf/2;\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"cost model: \"\n-                     \"epilogue peel iters set to (vf-1)/2 because \"\n+                     \"epilogue peel iters set to vf/2 because \"\n                      \"loop iterations are unknown .\");\n+\n+\t  /* If peeled iterations are known but number of scalar loop\n+\t     iterations are unknown, count a taken branch per peeled loop.  */\n+\t  peel_guard_costs +=  2 * TARG_COND_TAKEN_BRANCH_COST;\n+\n         }\n       else      \n \t{\n@@ -241,33 +255,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t}\n     }\n \n-  /* Requires a prologue loop when peeling to handle misalignment. Add cost of\n-     two guards, one for the peeled loop and one for the vector loop.  */\n-\n-  if (peel_iters_prologue)\n-    {\n-      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"cost model: Adding cost of checks for \"\n-                 \"prologue.\\n\");\n-    }\n-\n- /* Requires an epilogue loop to finish up remaining iterations after vector\n-    loop. Add cost of two guards, one for the peeled loop and one for the\n-    vector loop.  */\n-\n-  if (peel_iters_epilogue\n-      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vf)\n-    {\n-      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"cost model : Adding cost of checks for \"\n-                 \"epilogue.\\n\");\n-    }\n-\n   vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n-                      + (peel_iters_epilogue * scalar_single_iter_cost);\n+                      + (peel_iters_epilogue * scalar_single_iter_cost)\n+                      + peel_guard_costs;\n \n   /* Allow targets add additional (outside-of-loop) costs. FORNOW, the only\n      information we provide for the target is whether testing against the\n@@ -305,11 +295,13 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   if ((scalar_single_iter_cost * vf) > vec_inside_cost)\n     {\n-      if (vec_outside_cost == 0)\n+      if (vec_outside_cost <= 0)\n         min_profitable_iters = 1;\n       else\n         {\n-          min_profitable_iters = (vec_outside_cost * vf)\n+          min_profitable_iters = (vec_outside_cost * vf \n+                                  - vec_inside_cost * peel_iters_prologue\n+                                  - vec_inside_cost * peel_iters_epilogue)\n                                  / ((scalar_single_iter_cost * vf)\n                                     - vec_inside_cost);\n \n@@ -344,8 +336,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                peel_iters_epilogue);\n       fprintf (vect_dump, \"  Calculated minimum iters for profitability: %d\\n\",\n \t       min_profitable_iters);\n-      fprintf (vect_dump, \"  Actual minimum iters for profitability: %d\\n\",\n-\t       min_profitable_iters < vf ? vf : min_profitable_iters);\n     }\n \n   min_profitable_iters = \n@@ -355,6 +345,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      if (niters <= min_profitable_iters)\n        then skip the vectorized loop.  */\n   min_profitable_iters--;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"  Profitability threshold = %d\\n\",\n+\t     min_profitable_iters);\n+    \n   return min_profitable_iters;\n }\n \n@@ -6452,8 +6447,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n \n   /* Analyze cost to set threshhold for vectorized loop.  */\n   min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n-  min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND))\n-                          * LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t\t\t    * LOOP_VINFO_VECT_FACTOR (loop_vinfo)) - 1);\n \n   /* Use the cost model only if it is more conservative than user specified\n      threshold.  */\n@@ -6464,8 +6459,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n           || min_profitable_iters > min_scalar_loop_bound))\n     th = (unsigned) min_profitable_iters;\n \n-  if (min_profitable_iters\n-      && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+  if (((LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n+      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n       && vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vectorization may not be profitable.\");\n "}, {"sha": "49ee045237841a1451da04ab8ecf17cfcfc44db9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70444a892a17dc4a478f30072148f2f3651358b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e70444a892a17dc4a478f30072148f2f3651358b", "patch": "@@ -469,9 +469,14 @@ typedef struct _stmt_vec_info {\n /* These are some defines for the initial implementation of the vectorizer's\n    cost model.  These will later be target specific hooks.  */\n \n-/* Cost of conditional branch.  */\n-#ifndef TARG_COND_BRANCH_COST\n-#define TARG_COND_BRANCH_COST        3\n+/* Cost of conditional taken branch.  */\n+#ifndef TARG_COND_TAKEN_BRANCH_COST\n+#define TARG_COND_TAKEN_BRANCH_COST        3\n+#endif\n+\n+/* Cost of conditional not taken branch.  */\n+#ifndef TARG_COND_NOT_TAKEN_BRANCH_COST\n+#define TARG_COND_NOT_TAKEN_BRANCH_COST        1\n #endif\n \n /* Cost of any scalar operation, excluding load and store.  */"}]}