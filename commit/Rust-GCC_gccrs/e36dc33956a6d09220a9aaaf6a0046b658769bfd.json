{"sha": "e36dc33956a6d09220a9aaaf6a0046b658769bfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM2ZGMzMzk1NmE2ZDA5MjIwYTlhYWFmNmEwMDQ2YjY1ODc2OWJmZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2009-05-20T00:33:54Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2009-05-20T00:33:54Z"}, "message": "re PR tree-optimization/40087 (Number of iterations analysis wrong)\n\n\tPR tree-optimization/40087\n\t* tree-ssa-loop-niter.c (number_of_iterations_ne_max,\n\tnumber_of_iterations_ne): Rename never_infinite argument.\n\t(number_of_iterations_lt_to_ne, number_of_iterations_lt,\n\tnumber_of_iterations_le): Handle pointer-type ivs when\n\texit_must_be_taken is false.\n\t(number_of_iterations_cond):  Do not always assume that\n\texit_must_be_taken if the control variable is a pointer.\n\n\t* gcc.dg/tree-ssa/pr40087.c: New test.\n\nFrom-SVN: r147727", "tree": {"sha": "5414a0754638d6785e86a48ddc4976bc02d58a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5414a0754638d6785e86a48ddc4976bc02d58a20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e36dc33956a6d09220a9aaaf6a0046b658769bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36dc33956a6d09220a9aaaf6a0046b658769bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e36dc33956a6d09220a9aaaf6a0046b658769bfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36dc33956a6d09220a9aaaf6a0046b658769bfd/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03d33c2a449faa40b0a3cc55c6def7f5f17bd3f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d33c2a449faa40b0a3cc55c6def7f5f17bd3f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d33c2a449faa40b0a3cc55c6def7f5f17bd3f1"}], "stats": {"total": 155, "additions": 102, "deletions": 53}, "files": [{"sha": "82f00ebfe91a4b22c692fdd90e3214e729a7465d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e36dc33956a6d09220a9aaaf6a0046b658769bfd", "patch": "@@ -1,3 +1,14 @@\n+2009-05-19  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/40087\n+\t* tree-ssa-loop-niter.c (number_of_iterations_ne_max,\n+\tnumber_of_iterations_ne): Rename never_infinite argument.\n+\t(number_of_iterations_lt_to_ne, number_of_iterations_lt,\n+\tnumber_of_iterations_le): Handle pointer-type ivs when\n+\texit_must_be_taken is false.\n+\t(number_of_iterations_cond):  Do not always assume that\n+\texit_must_be_taken if the control variable is a pointer.\n+\n 2009-05-19  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* c-typeck.c (build_binary_op): Allow % on integal vectors."}, {"sha": "6b462b668ca50a1647d0dfd9a33ff454a753533d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e36dc33956a6d09220a9aaaf6a0046b658769bfd", "patch": "@@ -1,3 +1,8 @@\n+2009-05-19  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/40087\n+\t* gcc.dg/tree-ssa/pr40087.c: New test.\n+\n 2009-05-19  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* gcc.dg/vector-4.c: New testcase."}, {"sha": "22e2b629ed79f8a818469b90956605eb457c2a91", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr40087.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr40087.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr40087.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr40087.c?ref=e36dc33956a6d09220a9aaaf6a0046b658769bfd", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O1 \" } */\n+\n+extern void abort (void);\n+\n+static void __attribute__((always_inline))\n+reverse(int *first, int *last)\n+{\n+  if (first == last--) \n+    return;\n+  while (first != last)\n+    {\n+      int t = *first;\n+      *first = *last;\n+      *last = t;\n+      if (++first == last--)\n+        break;\n+    }\n+}\n+\n+int main()\n+{\n+  int seq[] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n+\n+  reverse(seq, seq + 8);\n+  if (seq[3] != 5 || seq[4] != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "18fd6b26e4a83be5fb434cdfabf2e0086789677a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36dc33956a6d09220a9aaaf6a0046b658769bfd/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=e36dc33956a6d09220a9aaaf6a0046b658769bfd", "patch": "@@ -534,7 +534,7 @@ inverse (tree x, tree mask)\n }\n \n /* Derives the upper bound BND on the number of executions of loop with exit\n-   condition S * i <> C, assuming that the loop is not infinite.  If\n+   condition S * i <> C, assuming that this exit is taken.  If\n    NO_OVERFLOW is true, then the control variable of the loop does not\n    overflow.  If NO_OVERFLOW is true or BNDS.below >= 0, then BNDS.up\n    contains the upper bound on the value of C.  */\n@@ -574,15 +574,15 @@ number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n \n /* Determines number of iterations of loop whose ending condition\n    is IV <> FINAL.  TYPE is the type of the iv.  The number of\n-   iterations is stored to NITER.  NEVER_INFINITE is true if\n+   iterations is stored to NITER.  EXIT_MUST_BE_TAKEN is true if\n    we know that the exit must be taken eventually, i.e., that the IV\n    ever reaches the value FINAL (we derived this earlier, and possibly set\n    NITER->assumptions to make sure this is the case).  BNDS contains the\n    bounds on the difference FINAL - IV->base.  */\n \n static bool\n number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n-\t\t\t struct tree_niter_desc *niter, bool never_infinite,\n+\t\t\t struct tree_niter_desc *niter, bool exit_must_be_taken,\n \t\t\t bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n@@ -639,9 +639,9 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n \t\t\t       build_int_cst (niter_type, 1), bits);\n   s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, s, bits);\n \n-  if (!never_infinite)\n+  if (!exit_must_be_taken)\n     {\n-      /* If we cannot assume that the loop is not infinite, record the\n+      /* If we cannot assume that the exit is taken eventually, record the\n \t assumptions for divisibility of c.  */\n       assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, c, d);\n       assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n@@ -664,20 +664,21 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n    of the final value does not overflow are recorded in NITER.  If we\n    find the final value, we adjust DELTA and return TRUE.  Otherwise\n    we return false.  BNDS bounds the value of IV1->base - IV0->base,\n-   and will be updated by the same amount as DELTA.  */\n+   and will be updated by the same amount as DELTA.  EXIT_MUST_BE_TAKEN is\n+   true if we know that the exit must be taken eventually.  */\n \n static bool\n number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t       struct tree_niter_desc *niter,\n \t\t\t       tree *delta, tree step,\n-\t\t\t       bounds *bnds)\n+\t\t\t       bool exit_must_be_taken, bounds *bnds)\n {\n   tree niter_type = TREE_TYPE (step);\n   tree mod = fold_build2 (FLOOR_MOD_EXPR, niter_type, *delta, step);\n   tree tmod;\n   mpz_t mmod;\n   tree assumption = boolean_true_node, bound, noloop;\n-  bool ret = false;\n+  bool ret = false, fv_comp_no_overflow;\n   tree type1 = type;\n   if (POINTER_TYPE_P (type))\n     type1 = sizetype;\n@@ -692,17 +693,31 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n   mpz_set_double_int (mmod, tree_to_double_int (mod), true);\n   mpz_neg (mmod, mmod);\n \n+  /* If the induction variable does not overflow and the exit is taken,\n+     then the computation of the final value does not overflow.  This is\n+     also obviously the case if the new final value is equal to the\n+     current one.  Finally, we postulate this for pointer type variables,\n+     as the code cannot rely on the object to that the pointer points being\n+     placed at the end of the address space (and more pragmatically,\n+     TYPE_{MIN,MAX}_VALUE is not defined for pointers).  */\n+  if (integer_zerop (mod) || POINTER_TYPE_P (type))\n+    fv_comp_no_overflow = true;\n+  else if (!exit_must_be_taken)\n+    fv_comp_no_overflow = false;\n+  else\n+    fv_comp_no_overflow =\n+\t    (iv0->no_overflow && integer_nonzerop (iv0->step))\n+\t    || (iv1->no_overflow && integer_nonzerop (iv1->step));\n+\n   if (integer_nonzerop (iv0->step))\n     {\n       /* The final value of the iv is iv1->base + MOD, assuming that this\n \t computation does not overflow, and that\n \t iv0->base <= iv1->base + MOD.  */\n-      if (!iv0->no_overflow && !integer_zerop (mod))\n+      if (!fv_comp_no_overflow)\n \t{\n \t  bound = fold_build2 (MINUS_EXPR, type1,\n \t\t\t       TYPE_MAX_VALUE (type1), tmod);\n-\t  if (POINTER_TYPE_P (type))\n-\t    bound = fold_convert (type, bound);\n \t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t    iv1->base, bound);\n \t  if (integer_zerop (assumption))\n@@ -726,12 +741,10 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n       /* The final value of the iv is iv0->base - MOD, assuming that this\n \t computation does not overflow, and that\n \t iv0->base - MOD <= iv1->base. */\n-      if (!iv1->no_overflow && !integer_zerop (mod))\n+      if (!fv_comp_no_overflow)\n \t{\n \t  bound = fold_build2 (PLUS_EXPR, type1,\n \t\t\t       TYPE_MIN_VALUE (type1), tmod);\n-\t  if (POINTER_TYPE_P (type))\n-\t    bound = fold_convert (type, bound);\n \t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t    iv0->base, bound);\n \t  if (integer_zerop (assumption))\n@@ -969,13 +982,13 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n /* Determines number of iterations of loop whose ending condition\n    is IV0 < IV1.  TYPE is the type of the iv.  The number of\n    iterations is stored to NITER.  BNDS bounds the difference\n-   IV1->base - IV0->base.  */\n+   IV1->base - IV0->base.  EXIT_MUST_BE_TAKEN is true if we know\n+   that the exit must be taken eventually.  */\n \n static bool\n number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t struct tree_niter_desc *niter,\n-\t\t\t bool never_infinite ATTRIBUTE_UNUSED,\n-\t\t\t bounds *bnds)\n+\t\t\t bool exit_must_be_taken, bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n   tree delta, step, s;\n@@ -1034,7 +1047,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n      transform the condition to != comparison.  In particular, this will be\n      the case if DELTA is constant.  */\n   if (number_of_iterations_lt_to_ne (type, iv0, iv1, niter, &delta, step,\n-\t\t\t\t     bnds))\n+\t\t\t\t     exit_must_be_taken, bnds))\n     {\n       affine_iv zps;\n \n@@ -1076,14 +1089,14 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \n /* Determines number of iterations of loop whose ending condition\n    is IV0 <= IV1.  TYPE is the type of the iv.  The number of\n-   iterations is stored to NITER.  NEVER_INFINITE is true if\n+   iterations is stored to NITER.  EXIT_MUST_BE_TAKEN is true if\n    we know that this condition must eventually become false (we derived this\n    earlier, and possibly set NITER->assumptions to make sure this\n    is the case).  BNDS bounds the difference IV1->base - IV0->base.  */\n \n static bool\n number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t\t struct tree_niter_desc *niter, bool never_infinite,\n+\t\t\t struct tree_niter_desc *niter, bool exit_must_be_taken,\n \t\t\t bounds *bnds)\n {\n   tree assumption;\n@@ -1094,9 +1107,13 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n   /* Say that IV0 is the control variable.  Then IV0 <= IV1 iff\n      IV0 < IV1 + 1, assuming that IV1 is not equal to the greatest\n      value of the type.  This we must know anyway, since if it is\n-     equal to this value, the loop rolls forever.  */\n+     equal to this value, the loop rolls forever.  We do not check\n+     this condition for pointer type ivs, as the code cannot rely on \n+     the object to that the pointer points being placed at the end of\n+     the address space (and more pragmatically, TYPE_{MIN,MAX}_VALUE is\n+     not defined for pointers).  */\n \n-  if (!never_infinite)\n+  if (!exit_must_be_taken && !POINTER_TYPE_P (type))\n     {\n       if (integer_nonzerop (iv0->step))\n \tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n@@ -1131,7 +1148,8 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   bounds_add (bnds, double_int_one, type1);\n \n-  return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite, bnds);\n+  return number_of_iterations_lt (type, iv0, iv1, niter, exit_must_be_taken,\n+\t\t\t\t  bnds);\n }\n \n /* Dumps description of affine induction variable IV to FILE.  */\n@@ -1177,7 +1195,7 @@ number_of_iterations_cond (struct loop *loop,\n \t\t\t   affine_iv *iv1, struct tree_niter_desc *niter,\n \t\t\t   bool only_exit)\n {\n-  bool never_infinite, ret;\n+  bool exit_must_be_taken = false, ret;\n   bounds bnds;\n \n   /* The meaning of these assumptions is this:\n@@ -1202,42 +1220,27 @@ number_of_iterations_cond (struct loop *loop,\n       code = swap_tree_comparison (code);\n     }\n \n-  if (!only_exit)\n-    {\n-      /* If this is not the only possible exit from the loop, the information\n-\t that the induction variables cannot overflow as derived from\n-\t signedness analysis cannot be relied upon.  We use them e.g. in the\n-\t following way:  given loop for (i = 0; i <= n; i++), if i is\n-\t signed, it cannot overflow, thus this loop is equivalent to\n-\t for (i = 0; i < n + 1; i++);  however, if n == MAX, but the loop\n-\t is exited in some other way before i overflows, this transformation\n-\t is incorrect (the new loop exits immediately).  */\n-      iv0->no_overflow = false;\n-      iv1->no_overflow = false;\n-    }\n-\n   if (POINTER_TYPE_P (type))\n     {\n       /* Comparison of pointers is undefined unless both iv0 and iv1 point\n \t to the same object.  If they do, the control variable cannot wrap\n \t (as wrap around the bounds of memory will never return a pointer\n \t that would be guaranteed to point to the same object, even if we\n-\t avoid undefined behavior by casting to size_t and back).  The\n-\t restrictions on pointer arithmetics and comparisons of pointers\n-\t ensure that using the no-overflow assumptions is correct in this\n-\t case even if ONLY_EXIT is false.  */\n+\t avoid undefined behavior by casting to size_t and back).  */\n       iv0->no_overflow = true;\n       iv1->no_overflow = true;\n     }\n \n-  /* If the control induction variable does not overflow, the loop obviously\n-     cannot be infinite.  */\n-  if (!integer_zerop (iv0->step) && iv0->no_overflow)\n-    never_infinite = true;\n-  else if (!integer_zerop (iv1->step) && iv1->no_overflow)\n-    never_infinite = true;\n-  else\n-    never_infinite = false;\n+  /* If the control induction variable does not overflow and the only exit\n+     from the loop is the one that we analyze, we know it must be taken\n+     eventually.  */\n+  if (only_exit)\n+    {\n+      if (!integer_zerop (iv0->step) && iv0->no_overflow)\n+\texit_must_be_taken = true;\n+      else if (!integer_zerop (iv1->step) && iv1->no_overflow)\n+\texit_must_be_taken = true;\n+    }\n \n   /* We can handle the case when neither of the sides of the comparison is\n      invariant, provided that the test is NE_EXPR.  This rarely occurs in\n@@ -1308,16 +1311,16 @@ number_of_iterations_cond (struct loop *loop,\n     case NE_EXPR:\n       gcc_assert (integer_zerop (iv1->step));\n       ret = number_of_iterations_ne (type, iv0, iv1->base, niter,\n-\t\t\t\t     never_infinite, &bnds);\n+\t\t\t\t     exit_must_be_taken, &bnds);\n       break;\n \n     case LT_EXPR:\n-      ret = number_of_iterations_lt (type, iv0, iv1, niter, never_infinite,\n+      ret = number_of_iterations_lt (type, iv0, iv1, niter, exit_must_be_taken,\n \t\t\t\t     &bnds);\n       break;\n \n     case LE_EXPR:\n-      ret = number_of_iterations_le (type, iv0, iv1, niter, never_infinite,\n+      ret = number_of_iterations_le (type, iv0, iv1, niter, exit_must_be_taken,\n \t\t\t\t     &bnds);\n       break;\n "}]}