{"sha": "69ba6af33edee3f85b3e10b5838d7af24bf8dd9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjliYTZhZjMzZWRlZTNmODViM2UxMGI1ODM4ZDdhZjI0YmY4ZGQ5YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-10T15:50:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-10T15:50:22Z"}, "message": "loop.c (basic_induction_var): Typo NULL_RTX -> NULL.\n\n        * loop.c (basic_induction_var): Typo NULL_RTX -> NULL.\n        (strength_reduce): Release the varrays from the no-bivs early exit.\n\n        * reload1.c (order_regs_for_reload): Init hard_reg_n_uses before\n        the loop over the registers.\n\n        * tree.c (save_tree_status): Set maybepermanent_firstobj NULL\n        for a new obstack.\n        (restore_tree_status): Check that instead when freeing the obstack.\n\nFrom-SVN: r29270", "tree": {"sha": "24e119b58e889caff12306c5a6f38931e8993941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24e119b58e889caff12306c5a6f38931e8993941"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a/comments", "author": null, "committer": null, "parents": [{"sha": "a0d8bee96e17f6c63da6f2c33ccbe7392f6a120c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d8bee96e17f6c63da6f2c33ccbe7392f6a120c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0d8bee96e17f6c63da6f2c33ccbe7392f6a120c"}], "stats": {"total": 22, "additions": 13, "deletions": 9}, "files": [{"sha": "4025f7c67d555b05232af863c38d6b0dbad0a64e", "filename": "gcc/loop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=69ba6af33edee3f85b3e10b5838d7af24bf8dd9a", "patch": "@@ -3926,7 +3926,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \tunroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\t     loop_info, 0);\n \n-      return;\n+      goto egress;\n     }\n \n   /* Find initial value for each biv by searching backwards from loop_start,\n@@ -5225,6 +5225,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"\\n\");\n+\n+egress:\n   VARRAY_FREE (reg_iv_type);\n   VARRAY_FREE (reg_iv_info);\n }\n@@ -6000,7 +6002,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n   rtx insn, set = 0;\n \n   code = GET_CODE (x);\n-  *location = NULL_RTX;\n+  *location = NULL;\n   switch (code)\n     {\n     case PLUS:"}, {"sha": "915a9a0342f7033766e39cb2e3fa26dbb0217eb8", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=69ba6af33edee3f85b3e10b5838d7af24bf8dd9a", "patch": "@@ -4109,16 +4109,19 @@ order_regs_for_reload (chain)\n \n   COPY_HARD_REG_SET (bad_spill_regs, bad_spill_regs_global);\n \n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      hard_reg_n_uses[i].regno = i;\n+      hard_reg_n_uses[i].uses = 0;\n+    }\n+\n   /* Count number of uses of each hard reg by pseudo regs allocated to it\n      and then order them by decreasing use.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       int j;\n \n-      hard_reg_n_uses[i].regno = i;\n-      hard_reg_n_uses[i].uses = 0;\n-\n       /* Test the various reasons why we can't use a register for\n \t spilling in this insn.  */\n       if (fixed_regs[i]"}, {"sha": "2dc6361d0ac6c99d5c804ce39a58c9b547d713d9", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ba6af33edee3f85b3e10b5838d7af24bf8dd9a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=69ba6af33edee3f85b3e10b5838d7af24bf8dd9a", "patch": "@@ -365,8 +365,7 @@ save_tree_status (p)\n   function_maybepermanent_obstack\n     = (struct obstack *) xmalloc (sizeof (struct obstack));\n   gcc_obstack_init (function_maybepermanent_obstack);\n-  maybepermanent_firstobj\n-    = (char *) obstack_finish (function_maybepermanent_obstack);\n+  maybepermanent_firstobj = NULL;\n \n   function_obstack = (struct obstack *) xmalloc (sizeof (struct obstack));\n   gcc_obstack_init (function_obstack);\n@@ -399,9 +398,9 @@ restore_tree_status (p)\n   obstack_free (&temporary_obstack, temporary_firstobj);\n   obstack_free (&momentary_obstack, momentary_function_firstobj);\n \n-  obstack_free (function_obstack, 0);\n+  obstack_free (function_obstack, NULL);\n \n-  if (obstack_empty_p (function_maybepermanent_obstack))\n+  if (maybepermanent_firstobj == NULL)\n     free (function_maybepermanent_obstack);\n   free (function_obstack);\n "}]}