{"sha": "54ffdb125c287b527a97b05f83bd942249a91446", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRmZmRiMTI1YzI4N2I1MjdhOTdiMDVmODNiZDk0MjI0OWE5MTQ0Ng==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-04-23T02:04:58Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-04-23T02:04:58Z"}, "message": "re PR libfortran/20257 (Fortran runtime error: End of record occurs when writing large arrays)\n\n2006-04-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/20257\n\t* io/io.h: Add prototypes for get_internal_unit and free_internal_unit.\n\t* io/unit.c (get_internal_unit): Initialize unit number, not zero.\n\t(free_internal_unit): New function to consolidate freeing memory.\n\t(get_unit): Initialize internal_unit_desc to NULL when unit is\n\texternal.\n\t* io/unix.c (mem_close): Check for not NULL before freeing memory.\n\t* io/transfer.c (read_block): Reset bytes_left and skip error if unit\n\tis preconnected and default record length is reached.\n\t(read_block_direct): Ditto.\n\t(write_block): Ditto.\n\t(write_buf): Ditto.\n\t(data_transfer_init): Only flush if not internal unit.\n\t(finalize_transfer): Ditto and delete code to free memory used by\n\tinternal units.\n\t(st_read_done): Use new function - free_internal_unit.\n\t(st_write_done): Use new function - free_internal unit.\n\nFrom-SVN: r113190", "tree": {"sha": "56765ca4fae2a288923031b5cf63053bc3ecf2ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56765ca4fae2a288923031b5cf63053bc3ecf2ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54ffdb125c287b527a97b05f83bd942249a91446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ffdb125c287b527a97b05f83bd942249a91446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54ffdb125c287b527a97b05f83bd942249a91446", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ffdb125c287b527a97b05f83bd942249a91446/comments", "author": null, "committer": null, "parents": [{"sha": "e8bbccd6439e18fa693a7bee5e659dcd20f4c80f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8bbccd6439e18fa693a7bee5e659dcd20f4c80f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8bbccd6439e18fa693a7bee5e659dcd20f4c80f"}], "stats": {"total": 141, "additions": 111, "deletions": 30}, "files": [{"sha": "00acecfd0e360c464670011843945ae3abaa073b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=54ffdb125c287b527a97b05f83bd942249a91446", "patch": "@@ -1,3 +1,23 @@\n+2006-04-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/20257\n+\t* io/io.h: Add prototypes for get_internal_unit and free_internal_unit.\n+\t* io/unit.c (get_internal_unit): Initialize unit number, not zero.\n+\t(free_internal_unit): New function to consolidate freeing memory.\n+\t(get_unit): Initialize internal_unit_desc to NULL when unit is\n+\texternal.\n+\t* io/unix.c (mem_close): Check for not NULL before freeing memory.\n+\t* io/transfer.c (read_block): Reset bytes_left and skip error if unit\n+\tis preconnected and default record length is reached.\n+\t(read_block_direct): Ditto.\n+\t(write_block): Ditto.\n+\t(write_buf): Ditto.\n+\t(data_transfer_init): Only flush if not internal unit.\n+\t(finalize_transfer): Ditto and delete code to free memory used by\n+\tinternal units.\n+\t(st_read_done): Use new function - free_internal_unit.\n+\t(st_write_done): Use new function - free_internal unit.\n+\n 2006-04-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/26769"}, {"sha": "e7581a6da0b979993fe2d2e8eee26b042efad029", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=54ffdb125c287b527a97b05f83bd942249a91446", "patch": "@@ -702,6 +702,12 @@ internal_proto(unit_lock);\n extern int close_unit (gfc_unit *);\n internal_proto(close_unit);\n \n+extern gfc_unit *get_internal_unit (st_parameter_dt *);\n+internal_proto(get_internal_unit);\n+\n+extern void free_internal_unit (st_parameter_dt *);\n+internal_proto(free_internal_unit);\n+\n extern int is_internal_unit (st_parameter_dt *);\n internal_proto(is_internal_unit);\n "}, {"sha": "743840102dbd957b947dc8b73d0727139065f9b3", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=54ffdb125c287b527a97b05f83bd942249a91446", "patch": "@@ -257,11 +257,19 @@ read_block (st_parameter_dt *dtp, int *length)\n \n   if (dtp->u.p.current_unit->bytes_left < *length)\n     {\n-      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+      /* For preconnected units with default record length, set bytes left\n+\t to unit record length and proceed, otherwise error.  */\n+      if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n+\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+      else\n \t{\n-\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n-\t  /* Not enough data left.  */\n-\t  return NULL;\n+\t  if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+\t    {\n+\t      /* Not enough data left.  */\n+\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      return NULL;\n+\t    }\n \t}\n \n       *length = dtp->u.p.current_unit->bytes_left;\n@@ -305,11 +313,19 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n   if (dtp->u.p.current_unit->bytes_left < *nbytes)\n     {\n-      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+      /* For preconnected units with default record length, set bytes left\n+\t to unit record length and proceed, otherwise error.  */\n+      if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n+\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+      else\n \t{\n-\t  /* Not enough data left.  */\n-\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n-\t  return;\n+\t  if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n+\t    {\n+\t      /* Not enough data left.  */\n+\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      return;\n+\t    }\n \t}\n \n       *nbytes = dtp->u.p.current_unit->bytes_left;\n@@ -358,11 +374,20 @@ void *\n write_block (st_parameter_dt *dtp, int length)\n {\n   char *dest;\n-  \n+\n   if (dtp->u.p.current_unit->bytes_left < length)\n     {\n-      generate_error (&dtp->common, ERROR_EOR, NULL);\n-      return NULL;\n+      /* For preconnected units with default record length, set bytes left\n+\t to unit record length and proceed, otherwise error.  */\n+      if ((dtp->u.p.current_unit->unit_number == options.stdout_unit\n+\t  || dtp->u.p.current_unit->unit_number == options.stderr_unit)\n+\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+      else\n+\t{\n+\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t  return NULL;\n+\t}\n     }\n \n   dtp->u.p.current_unit->bytes_left -= (gfc_offset) length;\n@@ -388,11 +413,20 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n   if (dtp->u.p.current_unit->bytes_left < nbytes)\n     {\n-      if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n-\tgenerate_error (&dtp->common, ERROR_DIRECT_EOR, NULL);\n+      /* For preconnected units with default record length, set bytes left\n+\t to unit record length and proceed, otherwise error.  */\n+      if ((dtp->u.p.current_unit->unit_number == options.stdout_unit\n+\t  || dtp->u.p.current_unit->unit_number == options.stderr_unit)\n+\t  && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n+        dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n       else\n-\tgenerate_error (&dtp->common, ERROR_EOR, NULL);\n-      return FAILURE;\n+\t{\n+\t  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n+\t    generate_error (&dtp->common, ERROR_DIRECT_EOR, NULL);\n+\t  else\n+\t    generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t  return FAILURE;\n+\t}\n     }\n \n   dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n@@ -1592,7 +1626,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n       /* Check to see if we might be reading what we wrote before  */\n \n-      if (dtp->u.p.mode == READING && dtp->u.p.current_unit->mode  == WRITING)\n+      if (dtp->u.p.mode == READING\n+\t  && dtp->u.p.current_unit->mode == WRITING\n+\t  && !is_internal_unit (dtp))\n \t flush(dtp->u.p.current_unit->s);\n \n       /* Check whether the record exists to be read.  Only\n@@ -2186,7 +2222,8 @@ finalize_transfer (st_parameter_dt *dtp)\n \t{\n \t  /* Most systems buffer lines, so force the partial record\n \t     to be written out.  */\n-\t  flush (dtp->u.p.current_unit->s);\n+\t  if (!is_internal_unit (dtp))\n+\t    flush (dtp->u.p.current_unit->s);\n \t  dtp->u.p.seen_dollar = 0;\n \t  return;\n \t}\n@@ -2195,16 +2232,8 @@ finalize_transfer (st_parameter_dt *dtp)\n     }\n \n   sfree (dtp->u.p.current_unit->s);\n-\n-  if (is_internal_unit (dtp))\n-    {\n-      if (is_array_io (dtp) && dtp->u.p.current_unit->ls != NULL)\n-\tfree_mem (dtp->u.p.current_unit->ls);\n-      sclose (dtp->u.p.current_unit->s);\n-    }\n }\n \n-\n /* Transfer function for IOLENGTH. It doesn't actually do any\n    data transfer, it just updates the length counter.  */\n \n@@ -2318,8 +2347,9 @@ st_read_done (st_parameter_dt *dtp)\n     free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n-  if (is_internal_unit (dtp) && dtp->u.p.current_unit != NULL)\n-    free_mem (dtp->u.p.current_unit);\n+\n+  free_internal_unit (dtp);\n+  \n   library_end ();\n }\n \n@@ -2372,8 +2402,9 @@ st_write_done (st_parameter_dt *dtp)\n     free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n-  if (is_internal_unit (dtp) && dtp->u.p.current_unit != NULL)\n-    free_mem (dtp->u.p.current_unit);\n+  \n+  free_internal_unit (dtp);\n+\n   library_end ();\n }\n "}, {"sha": "14438f84c825537ca4368302cd352f91f6a3cbfa", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=54ffdb125c287b527a97b05f83bd942249a91446", "patch": "@@ -378,6 +378,11 @@ get_internal_unit (st_parameter_dt *dtp)\n   memset (iunit, '\\0', sizeof (gfc_unit));\n \n   iunit->recl = dtp->internal_unit_len;\n+  \n+  /* For internal units we set the unit number to -1.\n+     Otherwise internal units can be mistaken for a pre-connected unit or\n+     some other file I/O unit.  */\n+  iunit->unit_number = -1;\n \n   /* Set up the looping specification from the array descriptor, if any.  */\n \n@@ -424,6 +429,23 @@ get_internal_unit (st_parameter_dt *dtp)\n }\n \n \n+/* free_internal_unit()-- Free memory allocated for internal units if any.  */\n+void\n+free_internal_unit (st_parameter_dt *dtp)\n+{\n+  if (!is_internal_unit (dtp))\n+    return;\n+\n+  if (dtp->u.p.current_unit->ls != NULL)\n+      free_mem (dtp->u.p.current_unit->ls);\n+  \n+  sclose (dtp->u.p.current_unit->s);\n+\n+  if (dtp->u.p.current_unit != NULL)\n+    free_mem (dtp->u.p.current_unit);\n+}\n+\n+\n /* get_unit()-- Returns the unit structure associated with the integer\n  * unit or the internal file. */\n \n@@ -437,6 +459,7 @@ get_unit (st_parameter_dt *dtp, int do_create)\n   /* Has to be an external unit */\n \n   dtp->u.p.unit_is_internal = 0;\n+  dtp->internal_unit_desc = NULL;\n \n   return get_external_unit (dtp->common.unit, do_create);\n }"}, {"sha": "93f4ea692d3d9f4966f2c4f547f5d7a67d07a09c", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ffdb125c287b527a97b05f83bd942249a91446/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=54ffdb125c287b527a97b05f83bd942249a91446", "patch": "@@ -928,7 +928,8 @@ mem_truncate (unix_stream * s __attribute__ ((unused)))\n static try\n mem_close (unix_stream * s)\n {\n-  free_mem (s);\n+  if (s != NULL)\n+    free_mem (s);\n \n   return SUCCESS;\n }"}]}