{"sha": "25e42e9d5a7263e8b8f1842bf967f9606df88c8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlNDJlOWQ1YTcyNjNlOGI4ZjE4NDJiZjk2N2Y5NjA2ZGY4OGM4YQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-01-18T03:07:26Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-01-18T03:07:26Z"}, "message": "* ra-build.c (undef_to_size_word): Avoid `switch' warning.\n\nFrom-SVN: r61464", "tree": {"sha": "01d9759d7f5033bd1b2db4f636cfc6c46b152574", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01d9759d7f5033bd1b2db4f636cfc6c46b152574"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e42e9d5a7263e8b8f1842bf967f9606df88c8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e42e9d5a7263e8b8f1842bf967f9606df88c8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e42e9d5a7263e8b8f1842bf967f9606df88c8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e42e9d5a7263e8b8f1842bf967f9606df88c8a/comments", "author": null, "committer": null, "parents": [{"sha": "6f9c81f53fac37310d6ec13bdd275910addb4aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9c81f53fac37310d6ec13bdd275910addb4aa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f9c81f53fac37310d6ec13bdd275910addb4aa4"}], "stats": {"total": 49, "additions": 25, "deletions": 24}, "files": [{"sha": "fc72b01231271599a0f14694a615f96280da70c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e42e9d5a7263e8b8f1842bf967f9606df88c8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e42e9d5a7263e8b8f1842bf967f9606df88c8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25e42e9d5a7263e8b8f1842bf967f9606df88c8a", "patch": "@@ -1,3 +1,7 @@\n+2003-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* ra-build.c (undef_to_size_word): Avoid `switch' warning.\n+\n 2003-01-17  Dale Johannesen  <dalej@apple.com>\n \n         * config/rs6000/rs6000.md (*floatsidf2_internal):  Add earlyclobbers."}, {"sha": "91bc0145ba2d0460b176056bdcc79687c50d15e7", "filename": "gcc/ra-build.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e42e9d5a7263e8b8f1842bf967f9606df88c8a/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e42e9d5a7263e8b8f1842bf967f9606df88c8a/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=25e42e9d5a7263e8b8f1842bf967f9606df88c8a", "patch": "@@ -398,8 +398,9 @@ undef_to_size_word (reg, undefined)\n     }\n \n   /* Otherwise we handle certain cases directly.  */\n-  switch (*undefined)\n-    {\n+  if (*undefined <= 0xffff)\n+    switch ((int) *undefined)\n+      {\n       case 0x00f0 : *undefined = 0; return BL_TO_WORD (4, 4);\n       case 0x00ff : *undefined = 0; return BL_TO_WORD (0, 8);\n       case 0x0f00 : *undefined = 0; return BL_TO_WORD (8, 4);\n@@ -413,29 +414,25 @@ undef_to_size_word (reg, undefined)\n       case 0xff00 : *undefined = 0; return BL_TO_WORD (8, 8);\n       case 0xfff0 : *undefined = 0xf0; return BL_TO_WORD (8, 8);\n       case 0xffff : *undefined = 0; return BL_TO_WORD (0, 16);\n+      }\n \n-      /* And if nothing matched fall back to the general solution.\n-\t For now unknown undefined bytes are converted to sequences\n-\t of maximal length 4 bytes.  We could make this larger if\n-\t necessary.  */\n-      default :\n-\t{\n-\t  unsigned HOST_WIDE_INT u = *undefined;\n-\t  int word;\n-\t  struct undef_table_s tab;\n-\t  for (word = 0; (u & 15) == 0; word += 4)\n-\t    u >>= 4;\n-\t  u = u & 15;\n-\t  tab = undef_table[u];\n-\t  u = tab.new_undef;\n-\t  u = (*undefined & ~((unsigned HOST_WIDE_INT)15 << word))\n-\t      | (u << word);\n-\t  *undefined = u;\n-\t  /* Size remains the same, only the begin is moved up move bytes.  */\n-\t  return tab.size_word + BL_TO_WORD (word, 0);\n-\t}\n-\tbreak;\n-    }\n+  /* And if nothing matched fall back to the general solution.  For\n+     now unknown undefined bytes are converted to sequences of maximal\n+     length 4 bytes.  We could make this larger if necessary.  */\n+  {\n+    unsigned HOST_WIDE_INT u = *undefined;\n+    int word;\n+    struct undef_table_s tab;\n+    for (word = 0; (u & 15) == 0; word += 4)\n+      u >>= 4;\n+    u = u & 15;\n+    tab = undef_table[u];\n+    u = tab.new_undef;\n+    u = (*undefined & ~((unsigned HOST_WIDE_INT)15 << word)) | (u << word);\n+    *undefined = u;\n+    /* Size remains the same, only the begin is moved up move bytes.  */\n+    return tab.size_word + BL_TO_WORD (word, 0);\n+  }\n }\n \n /* Put the above three functions together.  For a set of undefined bytes"}]}