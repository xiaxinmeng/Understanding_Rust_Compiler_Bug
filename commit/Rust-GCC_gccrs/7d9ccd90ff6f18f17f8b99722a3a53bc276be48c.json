{"sha": "7d9ccd90ff6f18f17f8b99722a3a53bc276be48c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q5Y2NkOTBmZjZmMThmMTdmOGI5OTcyMmEzYTUzYmMyNzZiZTQ4Yw==", "commit": {"author": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-03-31T11:51:29Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-03-31T11:51:29Z"}, "message": "Reworked method for traversing sym-linked directory hierarchies\n\nFrom-SVN: r26086", "tree": {"sha": "f097eb4ea097c6372d95a21b6098cc55031077d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f097eb4ea097c6372d95a21b6098cc55031077d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c/comments", "author": null, "committer": null, "parents": [{"sha": "5877286edf40476fffde9b05dfaaa382cd304c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5877286edf40476fffde9b05dfaaa382cd304c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5877286edf40476fffde9b05dfaaa382cd304c5a"}], "stats": {"total": 367, "additions": 215, "deletions": 152}, "files": [{"sha": "36a86a70c6d55db1d6f8b2b2cacebf6a705cb424", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=7d9ccd90ff6f18f17f8b99722a3a53bc276be48c", "patch": "@@ -139,6 +139,8 @@ struct fix_desc\n char *pz_dest_dir = NULL;\n char *pz_src_dir = NULL;\n char *pz_machine = NULL;\n+char *pz_find_base = NULL;\n+int find_base_len = 0;\n \n pid_t process_chain_head = (pid_t) -1;\n \n@@ -240,6 +242,17 @@ main (argc, argv)\n       }\n   }\n \n+  {\n+    static const char var[] = \"FIND_BASE\";\n+    pz_find_base = getenv (var);\n+    if (pz_find_base == (char *) NULL)\n+      {\n+        fprintf (stderr, var_not_found, var);\n+        exit (EXIT_FAILURE);\n+      }\n+    find_base_len = strlen( pz_find_base );\n+  }\n+\n   /*  Compile all the regular expressions now.\n       That way, it is done only once for the whole run.\n       */\n@@ -298,28 +311,34 @@ main (argc, argv)\n                    errno, strerror (errno));\n           exit (EXIT_FAILURE);\n         }\n-#ifdef DEBUG\n+#ifndef DEBUG\n+      {\n+        int status;\n+        (void)wait (&status);\n+      }\n+#else\n       fprintf (stderr, \"Waiting for %d to complete %d files\\n\",\n                child, file_name_ct);\n-#endif\n+\n       {\n         int status;\n         pid_t dead_kid = wait (&status);\n \n         if (dead_kid != child)\n           fprintf (stderr, \"fixincl woke up from a strange child %d (not %d)\\n\",\n                    dead_kid, child);\n-#ifdef DEBUG\n         else\n           fprintf (stderr, \"child finished %d files %s\\n\", file_name_ct,\n                    status ? strerror (status & 0xFF) : \"ok\");\n-#endif\n       }\n+#endif\n     }\n #else\n #error \"NON-BOGUS LIMITS NOT SUPPORTED?!?!\"\n #endif\n \n+  signal (SIGCLD,  SIG_IGN);\n+\n #ifdef DEBUG\n   fprintf (stderr, \"Child start  --  processing %d files\\n\",\n            file_name_ct);\n@@ -411,8 +430,10 @@ load_file (pz_file_name)\n \n             if (ferror (fp))\n               {\n-                fprintf (stderr, \"error %d (%s) reading %s\\n\", errno,\n-                         strerror (errno), pz_file_name);\n+                int err = errno;\n+                if (err != EISDIR)\n+                  fprintf (stderr, \"error %d (%s) reading %s\\n\", err,\n+                           strerror (err), pz_file_name);\n                 free ((void *) pz_data);\n                 fclose (fp);\n                 return (char *) NULL;\n@@ -596,7 +617,16 @@ create_file (pz_file_name)\n   FILE *pf;\n   char fname[MAXPATHLEN];\n \n-  sprintf (fname, \"%s/%s\", pz_dest_dir, pz_file_name);\n+#ifdef DEBUG\n+  if (strncmp( pz_file_name, pz_find_base, find_base_len ) != 0)\n+    {\n+      fprintf (stderr, \"Error:  input file %s does not match %s/*\\n\",\n+\t       pz_file_name, pz_find_base );\n+      exit (1);\n+    }\n+#endif\n+\n+  sprintf (fname, \"%s/%s\", pz_dest_dir, pz_file_name + find_base_len);\n \n   fd = open (fname, O_WRONLY | O_CREAT | O_TRUNC, S_IRALL);\n \n@@ -911,7 +941,7 @@ process (pz_data, pz_file_name)\n             }\n         }\n \n-      fprintf (stderr, \"Applying %-32s to %s\\n\",\n+      fprintf (stderr, \"Applying %-24s to %s\\n\",\n                p_fixd->fix_name, pz_file_name);\n \n       /*  IF we do not have a read pointer,"}, {"sha": "aaa75d0660142fe6e9f5478fce161d4fc93f2ecc", "filename": "gcc/fixinc/hackshell.tpl", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c/gcc%2Ffixinc%2Fhackshell.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c/gcc%2Ffixinc%2Fhackshell.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fhackshell.tpl?ref=7d9ccd90ff6f18f17f8b99722a3a53bc276be48c", "patch": "@@ -5,19 +5,15 @@\n #  fixincl program.  It is the repetitive guts of the fixincludes logic.\n #\n =]\n-  if $LINKS; then\n-    files=`find . -name '*.h' \\( -type f -o -type l \\) -print`\n-  else\n-    files=`find . -name '*.h' -type f -print`\n-  fi\n   echo Checking header files\n   for file in $files; do\n \n-    if ( test ! -r $file -o \\\n-    -n \"`fgrep 'This file is part of the GNU C Library' $file`\" )\n+    if ( test ! -r ${file} -o \\\n+    -n \"`fgrep 'This file is part of the GNU C Library' ${file}`\" )\n     then continue ; fi\n \n     fixlist=\"\"\n+    DESTFILE=${DESTDIR}/`echo ${file} | sed \"s;${FIND_BASE}/;;\" `\n [=\n #\n #  FOR  every fix description,\n@@ -30,7 +26,7 @@ _FOR fix \"\\n\\n\" =]\n     # Fix [=_eval _index 1 + #%3d _printf=]:  [=hackname _Cap=]\n     #[=\n     _IF files _exist=]\n-    case \"$file\" in [=_FOR files \" | \\\\\\n\\t\"=]./[=files=][=/files=] )[=\n+    case \"${file}\" in [=_FOR files \" | \\\\\\n\\t\"=]./[=files=][=/files=] )[=\n     _ENDIF=][=\n \n     _IF mach _exist=]\n@@ -52,8 +48,8 @@ _FOR fix \"\\n\\n\" =]\n        true or false.  It is enclosed in parenthesis to avoid\n        precedence problems.  The output looks like this:\n \n-       if ( test -n \"`egrep 'find-expr' $file`\" -a\n-                 -z \"`egrep 'not-find'  $file`\" -a\n+       if ( test -n \"`egrep 'find-expr' ${file}`\" -a\n+                 -z \"`egrep 'not-find'  ${file}`\" -a\n                  '(' <some-test-expression> ')'\n           ) > /dev/null 2>&1 ; then\n \n@@ -62,13 +58,13 @@ _FOR fix \"\\n\\n\" =]\n     _IF select _exist =]\n     if ( test [=\n         _FOR select \" -a \\\\\\n              \"\n-              =]-n [=select _shrstr \"#`egrep %s $file`\"\n+              =]-n [=select _shrstr \"#`egrep %s ${file}`\"\n                             _printf _shstr =][=\n         /select=][=\n \n         _IF bypass _exist =][=\n             _FOR bypass=] -a \\\n-              -z [=bypass _shrstr \"#`egrep %s $file`\"\n+              -z [=bypass _shrstr \"#`egrep %s ${file}`\"\n                             _printf _shstr =][=\n             /bypass=][=\n         _ENDIF=][=\n@@ -89,7 +85,7 @@ _FOR fix \"\\n\\n\" =]\n \n         _IF bypass _exist=][=\n             _FOR bypass=] -a \\\n-              -z [=bypass _shrstr \"#`egrep %s $file`\"\n+              -z [=bypass _shrstr \"#`egrep %s ${file}`\"\n                             _printf _shstr=][=\n             /bypass=][=\n         _ENDIF=]\n@@ -98,16 +94,16 @@ _FOR fix \"\\n\\n\" =]\n \n     _ELIF bypass _exist =]\n     if ( test [=_FOR bypass \" -a \\\\\\n              \"\n-              =]-z [=bypass _shrstr \"#`egrep %s $file`\"\n+              =]-z [=bypass _shrstr \"#`egrep %s ${file}`\"\n                             _printf _shstr=][=/bypass=]\n        ) > /dev/null 2>&1 ; then[=\n \n       _ENDIF=]\n     fixlist=\"${fixlist}\n       [=hackname=]\"\n-    if [ ! -r ${DESTDIR}/$file ]\n-    then infile=$file\n-    else infile=${DESTDIR}/$file ; fi [=\n+    if [ ! -r ${DESTFILE} ]\n+    then infile=${file}\n+    else infile=${DESTFILE} ; fi [=\n \n     _IF sed _exist=][=\n         _IF shell _exist =][=\n@@ -118,25 +114,25 @@ _FOR fix \"\\n\\n\" =]\n     sed [=\n         _FOR sed =]-e [=sed _shrstr=] \\\n         [=\n-        /sed=]  < $infile > ${DESTDIR}/$file.[=\n+        /sed=]  < $infile > ${DESTFILE}.[=\n \n \n     _ELIF shell _exist =]\n-    ( [=shell=] ) < $infile > ${DESTDIR}/$file.\n+    ( [=shell=] ) < $infile > ${DESTDIR}/FIXINC.tmp\n \n     #  Shell scripts have the potential of removing the output\n     #  We interpret that to mean the file is not to be altered\n     #\n-    if test ! -f ${DESTDIR}/$file.\n+    if test ! -f ${DESTDIR}/fixinc.tmp\n     then continue ; fi [=\n \n \n     _ELSE=][=\n         _ERROR hackname _get \"ERROR:  %s has no fixup\" _printf=][=\n \n     _ENDIF=]\n-    \n-    mv -f ${DESTDIR}/$file. ${DESTDIR}/$file[=\n+    rm -f ${DESTFILE}\n+    mv -f ${DESTDIR}/fixinc.tmp ${DESTFILE}[=\n \n     #  Close off any opened \"if\" or \"case\" statements in reverse order\n \n@@ -165,21 +161,23 @@ _FOR fix \"\\n\\n\" =]\n     #  THEN ensure the output is gone\n     #  ELSE look for local directory include syntax\n     #\n-    if ( test ! -f ${DESTDIR}/$file || \\\n-         cmp $file ${DESTDIR}/$file ) > /dev/null 2>&1\n+    if ( test ! -f ${DESTFILE} || \\\n+         cmp ${file} ${DESTFILE} ) > /dev/null 2>&1\n     then\n-      rm -f ${DESTDIR}/$file\n+      rm -f ${DESTFILE}\n     else\n-      echo \"Fixed $file:${fixlist}\"\n+      echo \"Fixed ${file}:${fixlist}\"\n \n       # Find any include directives that use \"file\".\n       #\n+      dir=`echo ${file} | sed -e s';/[^/]*$;;'`\n+      ddir=`echo ${DESTDIR} | sed 's;/[^/]*$;;'`/$dir\n+\n       for include in `\n-         egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' ${DESTDIR}/$file |\n-     sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n+         egrep '^[      ]*#[    ]*include[      ]*\"[^/]' ${DESTFILE} |\n+         sed -e 's/^[   ]*#[    ]*include[      ]*\"\\([^\"]*\\)\".*$/\\1/'`\n       do\n-    dir=`echo $file | sed -e s'|/[^/]*$||'`\n-    required=\"$required ${SRCDIR} $dir/$include ${DESTDIR}/$dir/$include\"\n+        required=\"$required ${SRCDIR} $dir/$include ${ddir}/$include\"\n       done\n     fi\n   done # for file in $files"}, {"sha": "7a30402f78613721db25338a3f14957e25b9f307", "filename": "gcc/fixinc/inclhack.tpl", "status": "modified", "additions": 149, "deletions": 114, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c/gcc%2Ffixinc%2Finclhack.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9ccd90ff6f18f17f8b99722a3a53bc276be48c/gcc%2Ffixinc%2Finclhack.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.tpl?ref=7d9ccd90ff6f18f17f8b99722a3a53bc276be48c", "patch": "@@ -87,7 +87,7 @@ case $LIB in\n esac\n \n echo Fixing headers into ${LIB} for ${target_canonical} target\n- \n+\n # Determine whether this system has symbolic links.\n if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n   rm -f $LIB/ShouldNotExist\n@@ -98,7 +98,7 @@ elif ln -s X /tmp/ShouldNotExist 2>/dev/null; then\n else\n   LINKS=false\n fi\n- \n+\n # # # # # # # # # # # # # # # # # # # # #\n #\n #  Search each input directory for broken header files.\n@@ -116,31 +116,35 @@ for INPUT in ${INPUTLIST} ; do\n cd ${ORIGDIR}\n \n cd ${INPUT} || continue\n+INPUT=`${PWDCMD}`\n \n #\n # # # # # # # # # # # # # # # # # # # # #\n #\n echo Finding directories and links to directories\n \n # Find all directories and all symlinks that point to directories.\n-# Put the list in $files.\n+# Put the list in $all_dirs.\n # Each time we find a symlink, add it to newdirs\n # so that we do another find within the dir the link points to.\n-# Note that $files may have duplicates in it;\n+# Note that $all_dirs may have duplicates in it;\n # later parts of this file are supposed to ignore them.\n dirs=\".\"\n levels=2\n+all_dirs=\"\"\n+search_dirs=\"\"\n+\n while [ -n \"$dirs\" ] && [ $levels -gt 0 ]\n do\n-    levels=`expr $levels - 1`\n-    newdirs=\n-    for d in $dirs\n-    do\n+  levels=`expr $levels - 1`\n+  newdirs=\n+  for d in $dirs\n+  do\n     echo \" Searching $INPUT/$d\"\n- \n+\n     # Find all directories under $d, relative to $d, excluding $d itself.\n     # (The /. is needed after $d in case $d is a symlink.)\n-    files=\"$files `find $d/. -type d -print | \\\n+    all_dirs=\"$all_dirs `find $d/. -type d -print | \\\n                sed -e '/\\/\\.$/d' -e 's@/./@/@g'`\"\n     # Find all links to directories.\n     # Using `-exec test -d' in find fails on some systems,\n@@ -152,131 +156,151 @@ do\n       theselinks=`find $d/. -type l -print | sed -e 's@/./@/@g'`\n     for d1 in $theselinks --dummy--\n     do\n-        # If the link points to a directory,\n-        # add that dir to $newdirs\n-        if [ -d $d1 ]\n-        then\n-        files=\"$files $d1\"\n+      # If the link points to a directory,\n+      # add that dir to $newdirs\n+      if [ -d $d1 ]\n+      then\n+        all_dirs=\"$all_dirs $d1\"\n         if [ \"`ls -ld $d1 | sed -n 's/.*-> //p'`\" != \".\" ]\n         then\n-            newdirs=\"$newdirs $d1\"\n-        fi\n+          newdirs=\"$newdirs $d1\"\n+          search_dirs=\"$search_dirs $d1\"\n         fi\n+      fi\n     done\n-    done\n- \n-    dirs=\"$newdirs\"\n+  done\n+\n+  dirs=\"$newdirs\"\n done\n- \n+\n # # # # # # # # # # # # # # # # # # # # #\n #\n dirs=\n echo \"All directories (including links to directories):\"\n-echo $files\n- \n-for file in $files; do\n+echo $all_dirs\n+\n+for file in $all_dirs; do\n   rm -rf $LIB/$file\n   if [ ! -d $LIB/$file ]\n   then mkdir $LIB/$file\n   fi\n done\n mkdir $LIB/root\n- \n+\n # # # # # # # # # # # # # # # # # # # # #\n #\n # treetops gets an alternating list\n # of old directories to copy\n # and the new directories to copy to.\n-treetops=\"${INPUT} ${LIB}\"\n- \n+treetops=\". ${LIB}\"\n+\n if $LINKS; then\n   echo 'Making symbolic directory links'\n-  for file in $files; do\n-    dest=`ls -ld $file | sed -n 's/.*-> //p'`\n-    if [ \"$dest\" ]; then\n-      cwd=`${PWDCMD}`\n-      # In case $dest is relative, get to $file's dir first.\n-      cd ${INPUT}\n-      cd `echo ./$file | sed -n 's&[^/]*$&&p'`\n-      # Check that the target directory exists.\n-      # Redirections changed to avoid bug in sh on Ultrix.\n-      (cd $dest) > /dev/null 2>&1\n-      if [ $? = 0 ]; then\n-    cd $dest\n-    # X gets the dir that the link actually leads to.\n-    x=`${PWDCMD}`\n-    # Canonicalize ${INPUT} now to minimize the time an\n-    # automounter has to change the result of ${PWDCMD}.\n-    cinput=`cd ${INPUT}; ${PWDCMD}`\n-    # If a link points to ., make a similar link to .\n-    if [ $x = ${cinput} ]; then\n-      echo $file '->' . ': Making link'\n-      rm -fr ${LIB}/$file > /dev/null 2>&1\n-      ln -s . ${LIB}/$file > /dev/null 2>&1\n-    # If link leads back into ${INPUT},\n-    # make a similar link here.\n-    elif expr $x : \"${cinput}/.*\" > /dev/null; then\n-      # Y gets the actual target dir name, relative to ${INPUT}.\n-      y=`echo $x | sed -n \"s&${cinput}/&&p\"`\n-      # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n-      dots=`echo \"$file\" |\n-        sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n-      echo $file '->' $dots$y ': Making link'\n-      rm -fr ${LIB}/$file > /dev/null 2>&1\n-      ln -s $dots$y ${LIB}/$file > /dev/null 2>&1\n-    else\n-      # If the link is to a dir $target outside ${INPUT},\n-      # repoint the link at ${INPUT}/root$target\n-      # and process $target into ${INPUT}/root$target\n-      # treat this directory as if it actually contained the files.\n-      echo $file '->' root$x ': Making link'\n-      if [ -d $LIB/root$x ]\n-      then true\n+  cwd=`${PWDCMD}`\n+\n+  for sym_link in $search_dirs; do\n+    cd ${INPUT}\n+    dest=`ls -ld ${sym_link} | sed -n 's/.*-> //p'`\n+\n+    # In case $dest is relative, get to ${sym_link}'s dir first.\n+    #\n+    cd ./`echo ${sym_link} | sed 's;/[^/]*$;;'`\n+\n+    # Check that the target directory exists.\n+    # Redirections changed to avoid bug in sh on Ultrix.\n+    #\n+    (cd $dest) > /dev/null 2>&1\n+    if [ $? = 0 ]; then\n+      cd $dest\n+\n+      # full_dest_dir gets the dir that the link actually leads to.\n+      #\n+      full_dest_dir=`${PWDCMD}`\n+\n+      # Canonicalize ${INPUT} now to minimize the time an\n+      # automounter has to change the result of ${PWDCMD}.\n+      #\n+      cinput=`cd ${INPUT}; ${PWDCMD}`\n+\n+      # If a link points to ., make a similar link to .\n+      #\n+      if [ ${full_dest_dir} = ${cinput} ]; then\n+        echo ${sym_link} '->' . ': Making self link'\n+        rm -fr ${LIB}/${sym_link} > /dev/null 2>&1\n+        ln -s . ${LIB}/${sym_link} > /dev/null 2>&1\n+\n+      # If link leads back into ${INPUT},\n+      # make a similar link here.\n+      #\n+      elif expr ${full_dest_dir} : \"${cinput}/.*\" > /dev/null; then\n+        # Y gets the actual target dir name, relative to ${INPUT}.\n+        y=`echo ${full_dest_dir} | sed -n \"s&${cinput}/&&p\"`\n+        # DOTS is the relative path from ${LIB}/${sym_link} back to ${LIB}.\n+        dots=`echo \"${sym_link}\" |\n+          sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n+        echo ${sym_link} '->' $dots$y ': Making local link'\n+        rm -fr ${LIB}/${sym_link} > /dev/null 2>&1\n+        ln -s $dots$y ${LIB}/${sym_link} > /dev/null 2>&1\n+\n       else\n-        dirname=root$x/\n-        dirmade=.\n-        cd $LIB\n-        while [ x$dirname != x ]; do\n-          component=`echo $dirname | sed -e 's|/.*$||'`\n-          mkdir $component >/dev/null 2>&1\n-          cd $component\n-          dirmade=$dirmade/$component\n-          dirname=`echo $dirname | sed -e 's|[^/]*/||'`\n-        done\n-      fi\n-      # Duplicate directory structure created in ${LIB}/$file in new\n-      # root area.\n-      for file2 in $files; do\n-        case $file2 in\n-          $file/*)\n-        dupdir=${LIB}/root$x/`echo $file2 | sed -n \"s|^${file}/||p\"`\n-        echo \"Duplicating ${file}'s ${dupdir}\"\n-        if [ -d ${dupdir} ]\n+        # If the link is to a dir $target outside ${INPUT},\n+        # repoint the link at ${INPUT}/root$target\n+        # and process $target into ${INPUT}/root$target\n+        # treat this directory as if it actually contained the files.\n+        #\n+        echo ${sym_link} '->' root${full_dest_dir} ': Making rooted link'\n+        if [ -d $LIB/root${full_dest_dir} ]\n         then true\n         else\n-          mkdir ${dupdir}\n-        fi\n-        ;;\n-          *)\n-        ;;\n-        esac\n+          dirname=root${full_dest_dir}/\n+          dirmade=.\n+          cd $LIB\n+          while [ x$dirname != x ]; do\n+            component=`echo $dirname | sed -e 's|/.*$||'`\n+            mkdir $component >/dev/null 2>&1\n+            cd $component\n+            dirmade=$dirmade/$component\n+            dirname=`echo $dirname | sed -e 's|[^/]*/||'`\n           done\n-      # Get the path from ${LIB} to $file, accounting for symlinks.\n-      parent=`echo \"$file\" | sed -e 's@/[^/]*$@@'`\n-      libabs=`cd ${LIB}; ${PWDCMD}`\n-      file2=`cd ${LIB}; cd $parent; ${PWDCMD} | sed -e \"s@^${libabs}@@\"`\n-      # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.\n-      dots=`echo \"$file2\" | sed -e 's@/[^/]*@../@g'`\n-      rm -fr ${LIB}/$file > /dev/null 2>&1\n-      ln -s ${dots}root$x ${LIB}/$file > /dev/null 2>&1\n-      treetops=\"$treetops $x ${LIB}/root$x\"\n-    fi\n+        fi\n+\n+        # Duplicate directory structure created in ${LIB}/${sym_link} in new\n+        # root area.\n+        #\n+        for file2 in $all_dirs; do\n+          case $file2 in\n+            ${sym_link}/*)\n+              dupdir=${LIB}/root${full_dest_dir}/`echo $file2 |\n+                      sed -n \"s|^${sym_link}/||p\"`\n+              echo \"Duplicating ${sym_link}'s ${dupdir}\"\n+              if [ -d ${dupdir} ]\n+              then true\n+              else\n+                mkdir ${dupdir}\n+              fi\n+              ;;\n+            *)\n+              ;;\n+          esac\n+        done\n+\n+        # Get the path from ${LIB} to ${sym_link}, accounting for symlinks.\n+        #\n+        parent=`echo \"${sym_link}\" | sed -e 's@/[^/]*$@@'`\n+        libabs=`cd ${LIB}; ${PWDCMD}`\n+        file2=`cd ${LIB}; cd $parent; ${PWDCMD} | sed -e \"s@^${libabs}@@\"`\n+\n+        # DOTS is the relative path from ${LIB}/${sym_link} back to ${LIB}.\n+        #\n+        dots=`echo \"$file2\" | sed -e 's@/[^/]*@../@g'`\n+        rm -fr ${LIB}/${sym_link} > /dev/null 2>&1\n+        ln -s ${dots}root${full_dest_dir} ${LIB}/${sym_link} > /dev/null 2>&1\n+        treetops=\"$treetops ${sym_link} ${LIB}/root${full_dest_dir}\"\n       fi\n-      cd $cwd\n     fi\n   done\n fi\n- \n+\n # # # # # # # # # # # # # # # # # # # # #\n #\n required=\n@@ -287,6 +311,9 @@ while [ $# != 0 ]; do\n   #\n   SRCDIR=`cd ${INPUT} ; cd $1 ; ${PWDCMD}`\n   export SRCDIR\n+\n+  FIND_BASE=$1\n+  export FIND_BASE\n   shift\n \n   DESTDIR=`cd $1;${PWDCMD}`\n@@ -302,22 +329,30 @@ while [ $# != 0 ]; do\n   touch ${DESTDIR}/DONE\n   echo Fixing directory ${SRCDIR} into ${DESTDIR}\n \n-  # Check .h files which are symlinks as well as those which are files.\n-  # A link to a header file will not be processed by anything but this.\n+  # Check files which are symlinks as well as those which are files.\n   #\n-  cd ${SRCDIR}\n-[=_IF PROGRAM _env ! =][=\n+  cd ${INPUT}[=\n+_IF PROGRAM _env ! =]\n+  files=`if $LINKS; then\n+    find ${FIND_BASE}/. \\( -type f -o -type l \\) -print\n+  else\n+    find ${FIND_BASE}/. -type f -print\n+  fi | \\\n+    sed -e's;/\\./;/;g' -e's;//*;/;g' `\n+[=\n \n     _include hackshell =][=\n \n   _ELSE\n \n =]\n   required=\"$required `if $LINKS; then\n-    find . -name '*.h' \\( -type f -o -type l \\) -print\n+    find ${FIND_BASE}/. \\( -type f -o -type l \\) -print\n   else\n-    find . -name '*.h' -type f -print\n-  fi | ${FIXINCL}`\"[=\n+    find ${FIND_BASE}/. -type f -print\n+  fi | \\\n+    sed -e's;/\\./;/;g' -e's;//*;/;g' | \\\n+    ${FIXINCL}`\"[=\n \n \n   _ENDIF =]\n@@ -365,8 +400,8 @@ find . -name DONE -exec rm -f '{}' ';'\n \n echo 'Removing unneeded directories:'\n cd $LIB\n-files=`find . -type d -print | sort -r`\n-for file in $files; do\n+all_dirs=`find . -type d -print | sort -r`\n+for file in $all_dirs; do\n   rmdir $LIB/$file > /dev/null 2>&1 | :\n done\n "}]}