{"sha": "1f397f45b3db18687d9445e6e3895f34f09daa38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYzOTdmNDViM2RiMTg2ODdkOTQ0NWU2ZTM4OTVmMzRmMDlkYWEzOA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-13T10:04:09Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-13T10:04:09Z"}, "message": "emit-rtl.c (remove_insn): Do not call df_insn_delete here.\n\n\n\t* emit-rtl.c (remove_insn): Do not call df_insn_delete here.\n\t* cfgrtl.c (delete_insn): Call it here instead.\n\t* lra-spills.c (lra_final_code_change): Use delete_insn.\n\t* haifa-sched.c (sched_remove_insn): Likewise.\n\t* sel-sched-ir.c (return_nop_to_pool): Clear INSN_DELETED_P for nops\n\treturning to the nop pool.\n\t(sel_remove_insn): Simplify the only_disconnect case via remove_insn,\n\tuse delete_insn for definitive removal.  Clear BLOCK_FOR_INSN.\n\nFrom-SVN: r197942", "tree": {"sha": "b1ba97001acf76353646714998e7e1ece2891d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1ba97001acf76353646714998e7e1ece2891d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f397f45b3db18687d9445e6e3895f34f09daa38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f397f45b3db18687d9445e6e3895f34f09daa38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f397f45b3db18687d9445e6e3895f34f09daa38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f397f45b3db18687d9445e6e3895f34f09daa38/comments", "author": null, "committer": null, "parents": [{"sha": "0e50ab072aab4f319bf0d50f6fe559b28bb3ae97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e50ab072aab4f319bf0d50f6fe559b28bb3ae97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e50ab072aab4f319bf0d50f6fe559b28bb3ae97"}], "stats": {"total": 65, "additions": 39, "deletions": 26}, "files": [{"sha": "f61412c5b69f09d6992d42e3d5d612195ef884dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f397f45b3db18687d9445e6e3895f34f09daa38", "patch": "@@ -1,3 +1,14 @@\n+2013-04-13  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* emit-rtl.c (remove_insn): Do not call df_insn_delete here.\n+\t* cfgrtl.c (delete_insn): Call it here instead.\n+\t* lra-spills.c (lra_final_code_change): Use delete_insn.\n+\t* haifa-sched.c (sched_remove_insn): Likewise.\n+\t* sel-sched-ir.c (return_nop_to_pool): Clear INSN_DELETED_P for nops\n+\treturning to the nop pool.\n+\t(sel_remove_insn): Simplify the only_disconnect case via remove_insn,\n+\tuse delete_insn for definitive removal.  Clear BLOCK_FOR_INSN.\n+\n 2013-04-12  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* doc/tm.texi.in (LOOP_ALIGN): Remove loop note references."}, {"sha": "f59051daab5b2f3d280eead675463555209794b4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=1f397f45b3db18687d9445e6e3895f34f09daa38", "patch": "@@ -164,6 +164,8 @@ delete_insn (rtx insn)\n     {\n       /* If this insn has already been deleted, something is very wrong.  */\n       gcc_assert (!INSN_DELETED_P (insn));\n+      if (INSN_P (insn))\n+\tdf_insn_delete (insn);\n       remove_insn (insn);\n       INSN_DELETED_P (insn) = 1;\n     }"}, {"sha": "82e476683ca4351a57637aa74ed384a0fdad2bf5", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1f397f45b3db18687d9445e6e3895f34f09daa38", "patch": "@@ -3908,8 +3908,21 @@ set_insn_deleted (rtx insn)\n }\n \n \n-/* Remove an insn from its doubly-linked list.  This function knows how\n-   to handle sequences.  */\n+/* Unlink INSN from the insn chain.\n+\n+   This function knows how to handle sequences.\n+   \n+   This function does not invalidate data flow information associated with\n+   INSN (i.e. does not call df_insn_delete).  That makes this function\n+   usable for only disconnecting an insn from the chain, and re-emit it\n+   elsewhere later.\n+\n+   To later insert INSN elsewhere in the insn chain via add_insn and\n+   similar functions, PREV_INSN and NEXT_INSN must be nullified by\n+   the caller.  Nullifying them here breaks many insn chain walks.\n+\n+   To really delete an insn and related DF information, use delete_insn.  */\n+\n void\n remove_insn (rtx insn)\n {\n@@ -3968,10 +3981,6 @@ remove_insn (rtx insn)\n       gcc_assert (stack);\n     }\n \n-  /* Invalidate data flow information associated with INSN.  */\n-  if (INSN_P (insn))\n-    df_insn_delete (insn);\n-\n   /* Fix up basic block boundaries, if necessary.  */\n   if (!BARRIER_P (insn)\n       && (bb = BLOCK_FOR_INSN (insn)))"}, {"sha": "16094b231b2092ba7c9c0b6f358c57e1d94c67c8", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=1f397f45b3db18687d9445e6e3895f34f09daa38", "patch": "@@ -8198,7 +8198,7 @@ sched_remove_insn (rtx insn)\n \n   change_queue_index (insn, QUEUE_NOWHERE);\n   current_sched_info->add_remove_insn (insn, 1);\n-  remove_insn (insn);\n+  delete_insn (insn);\n }\n \n /* Clear priorities of all instructions, that are forward dependent on INSN."}, {"sha": "60e51eec0c52f45dc1ea68090ba91d556f4a2dae", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=1f397f45b3db18687d9445e6e3895f34f09daa38", "patch": "@@ -639,7 +639,7 @@ lra_final_code_change (void)\n \t\t need them anymore and don't want to waste compiler\n \t\t time processing them in a few subsequent passes.  */\n \t      lra_invalidate_insn_data (insn);\n-\t      remove_insn (insn);\n+\t      delete_insn (insn);\n \t      continue;\n \t    }\n "}, {"sha": "47e769534dbf5509b9e335a5ec9fa2dcb7edd85c", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f397f45b3db18687d9445e6e3895f34f09daa38/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=1f397f45b3db18687d9445e6e3895f34f09daa38", "patch": "@@ -1065,6 +1065,9 @@ return_nop_to_pool (insn_t nop, bool full_tidying)\n   gcc_assert (INSN_IN_STREAM_P (nop));\n   sel_remove_insn (nop, false, full_tidying);\n \n+  /* We'll recycle this nop.  */\n+  INSN_DELETED_P (nop) = 0;\n+\n   if (nop_pool.n == nop_pool.s)\n     nop_pool.v = XRESIZEVEC (rtx, nop_pool.v,\n                              (nop_pool.s = 2 * nop_pool.s + 1));\n@@ -3929,31 +3932,19 @@ sel_remove_insn (insn_t insn, bool only_disconnect, bool full_tidying)\n     }\n \n   if (only_disconnect)\n-    {\n-      insn_t prev = PREV_INSN (insn);\n-      insn_t next = NEXT_INSN (insn);\n-      basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-      NEXT_INSN (prev) = next;\n-      PREV_INSN (next) = prev;\n-\n-      if (BB_HEAD (bb) == insn)\n-        {\n-          gcc_assert (BLOCK_FOR_INSN (prev) == bb);\n-          BB_HEAD (bb) = prev;\n-        }\n-      if (BB_END (bb) == insn)\n-        BB_END (bb) = prev;\n-    }\n+    remove_insn (insn);\n   else\n     {\n-      remove_insn (insn);\n+      delete_insn (insn);\n       clear_expr (INSN_EXPR (insn));\n     }\n \n-  /* It is necessary to null this fields before calling add_insn ().  */\n+  /* It is necessary to NULL these fields in case we are going to re-insert\n+     INSN into the insns stream, as will usually happen in the ONLY_DISCONNECT\n+     case, but also for NOPs that we will return to the nop pool.  */\n   PREV_INSN (insn) = NULL_RTX;\n   NEXT_INSN (insn) = NULL_RTX;\n+  set_block_for_insn (insn, NULL);\n \n   return tidy_control_flow (bb, full_tidying);\n }"}]}