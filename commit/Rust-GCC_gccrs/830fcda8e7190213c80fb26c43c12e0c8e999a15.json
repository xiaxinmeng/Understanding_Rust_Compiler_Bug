{"sha": "830fcda8e7190213c80fb26c43c12e0c8e999a15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMwZmNkYThlNzE5MDIxM2M4MGZiMjZjNDNjMTJlMGM4ZTk5OWExNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-09-01T11:51:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-01T11:51:41Z"}, "message": "decl.c (lookup_name_real): Also do implicit typename thing for artificial TYPE_DECLs.\n\n\t* decl.c (lookup_name_real): Also do implicit typename thing for\n\tartificial TYPE_DECLs.\n\t* search.c (lookup_field): Likewise.\n\t(lookup_fnfields, lookup_field): Adjust for implicit typename kludge.\n\t* semantics.c (begin_constructor_declarator): Use enter_scope_of.\n\t(enter_scope_of): Extract type from implicit typename.\n\t(begin_class_definition): Likewise.\n\t* lex.c (identifier_type): Handle implicit typename when checking\n\tfor SELFNAME.\n\t* cp-tree.h: Declare flag_strict_prototype.\n\t* lex.c (do_scoped_id, do_identifier): Don't implicitly_declare if\n\t-fstrict-prototype.\n\t* decl.c (init_decl_processing): If -f{no,-}strict-prototype wasn't\n\tspecified, set it to the value of pedantic.\n\nFrom-SVN: r22158", "tree": {"sha": "400b9f9fd8b41251123a9243ffd11612ec74dd55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/400b9f9fd8b41251123a9243ffd11612ec74dd55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/830fcda8e7190213c80fb26c43c12e0c8e999a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830fcda8e7190213c80fb26c43c12e0c8e999a15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830fcda8e7190213c80fb26c43c12e0c8e999a15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830fcda8e7190213c80fb26c43c12e0c8e999a15/comments", "author": null, "committer": null, "parents": [{"sha": "3d6ed3ef45722af4d8a53928ac429a4a95c774ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6ed3ef45722af4d8a53928ac429a4a95c774ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6ed3ef45722af4d8a53928ac429a4a95c774ed"}], "stats": {"total": 116, "additions": 76, "deletions": 40}, "files": [{"sha": "665f35d01559b0ff9cf0c75409da1f730441a498", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -1,3 +1,21 @@\n+1998-09-01  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (lookup_name_real): Also do implicit typename thing for\n+\tartificial TYPE_DECLs.\n+\t* search.c (lookup_field): Likewise.\n+\t(lookup_fnfields, lookup_field): Adjust for implicit typename kludge.\n+\t* semantics.c (begin_constructor_declarator): Use enter_scope_of.\n+\t(enter_scope_of): Extract type from implicit typename.\n+\t(begin_class_definition): Likewise.\n+\t* lex.c (identifier_type): Handle implicit typename when checking\n+\tfor SELFNAME.\n+\n+\t* cp-tree.h: Declare flag_strict_prototype.\n+\t* lex.c (do_scoped_id, do_identifier): Don't implicitly_declare if\n+\t-fstrict-prototype.\n+\t* decl.c (init_decl_processing): If -f{no,-}strict-prototype wasn't\n+\tspecified, set it to the value of pedantic.\n+\n 1998-09-01  Mark Mitchell  <mark@markmitchell.com>\n \n \t* decl2.c (arg_assoc): Handle template-id expressions as arguments."}, {"sha": "096617a5aa4c2b44b43054dac29acae9b478beaa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -477,6 +477,11 @@ extern int flag_do_squangling;\n    required.  */\n extern int flag_optional_diags;\n \n+/* Nonzero means do not consider empty argument prototype to mean function\n+   takes no arguments.  */\n+\n+extern int flag_strict_prototype;\n+\n /* Nonzero means output .vtable_{entry,inherit} for use in doing vtable gc.  */\n extern int flag_vtable_gc;\n \f"}, {"sha": "2abcd1ac1807f233349d572721868f198a53dc9f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -5091,8 +5091,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       else if (processing_template_decl\n \t       && classval && TREE_CODE (classval) == TYPE_DECL\n \t       && ! currently_open_class (DECL_CONTEXT (classval))\n-\t       && uses_template_parms (current_class_type)\n-\t       && ! DECL_ARTIFICIAL (classval))\n+\t       && uses_template_parms (current_class_type))\n \tclassval = lookup_field (current_class_type, name, 0, 1);\n \n       /* yylex() calls this with -2, since we should never start digging for\n@@ -5470,7 +5469,6 @@ init_decl_processing ()\n   int wchar_type_size;\n   tree temp;\n   tree array_domain_type;\n-  extern int flag_strict_prototype;\n   tree vb_off_identifier = NULL_TREE;\n   /* Function type `char *(char *, char *)' and similar ones */\n   tree string_ftype_ptr_ptr, int_ftype_string_string;\n@@ -5492,12 +5490,9 @@ init_decl_processing ()\n   current_lang_name = NULL_TREE;\n \n   if (flag_strict_prototype == 2)\n-    {\n-      if (pedantic)\n-\tstrict_prototypes_lang_c = strict_prototypes_lang_cplusplus;\n-    }\n-  else\n-    strict_prototypes_lang_c = flag_strict_prototype;\n+    flag_strict_prototype = pedantic;\n+\n+  strict_prototypes_lang_c = flag_strict_prototype;\n \n   /* Initially, C.  */\n   current_lang_name = lang_name_c;"}, {"sha": "69315beba39d3995198a8e438b1693708a700f14", "filename": "gcc/cp/except.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -826,7 +826,6 @@ process_start_catch_block (declspecs, declarator)\n }\n \n \n-\n /* Call this to end a catch block.  Its responsible for emitting the\n    code to handle jumping back to the correct place, and for emitting\n    the label to jump to if this catch block didn't match.  */"}, {"sha": "e6ad6595b100761e97c22f435a635a366eaf9bc3", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for switches for C++.\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "b789b28438b3e2a6af030992effceb3557e3d2b6", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -2754,6 +2754,7 @@ int\n identifier_type (decl)\n      tree decl;\n {\n+  tree t;\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n       if (TREE_CODE (DECL_RESULT (decl)) == TYPE_DECL)\n@@ -2763,7 +2764,6 @@ identifier_type (decl)\n     }\n   if (looking_for_template && really_overloaded_fn (decl))\n     {\n-      tree t;\n       for (t = decl; t != NULL_TREE; t = OVL_CHAIN (t))\n \tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t))) \n \t  return PFUNCNAME;\n@@ -2772,10 +2772,20 @@ identifier_type (decl)\n     return NSNAME;\n   if (TREE_CODE (decl) != TYPE_DECL)\n     return IDENTIFIER;\n-  if (((got_scope && TREE_TYPE (decl) == got_scope)\n-       || TREE_TYPE (decl) == current_class_type)\n-      && DECL_ARTIFICIAL (decl))\n+  if (DECL_ARTIFICIAL (decl) && TREE_TYPE (decl) == current_class_type)\n+    return SELFNAME;\n+\n+  /* A constructor declarator for a template type will get here as an\n+     implicit typename, a TYPENAME_TYPE with a type.  */\n+  t = got_scope;\n+  if (t && TREE_CODE (t) == TYPENAME_TYPE)\n+    t = TREE_TYPE (t);\n+  decl = TREE_TYPE (decl);\n+  if (TREE_CODE (decl) == TYPENAME_TYPE)\n+    decl = TREE_TYPE (decl);\n+  if (t && t == decl)\n     return SELFNAME;\n+\n   return TYPENAME;\n }\n \n@@ -2902,7 +2912,7 @@ do_identifier (token, parsing, args)\n \t    cp_error (\"`%D' not defined\", token);\n \t  id = error_mark_node;\n \t}\n-      else if (in_call)\n+      else if (in_call && ! flag_strict_prototype)\n \t{\n \t  id = implicitly_declare (token);\n \t}\n@@ -3054,7 +3064,8 @@ do_scoped_id (token, parsing)\n \t  LOOKUP_EXPR_GLOBAL (id) = 1;\n \t  return id;\n \t}\n-      if (parsing && (yychar == '(' || yychar == LEFT_RIGHT))\n+      if (parsing && (yychar == '(' || yychar == LEFT_RIGHT)\n+\t  && ! flag_strict_prototype)\n \tid = implicitly_declare (token);\n       else\n \t{"}, {"sha": "aadd36d6c715f960bd492d333343689b3c55d547", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -2598,7 +2598,6 @@ coerce_template_template_parms (parm_parms, arg_parms, in_decl, outer_args)\n   return 1;\n }\n \n-\n /* Convert the indicated template ARG as necessary to match the\n    indicated template PARM.  Returns the converted ARG, or\n    error_mark_node if the conversion was unsuccessful.  Error messages"}, {"sha": "1c3a187abeb245ba922927f3750aef5d980dfd3a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -1030,9 +1030,12 @@ lookup_field (xbasetype, name, protect, want_type)\n       basetype_chain = TREE_CHAIN (basetype_chain);\n       basetype_path = TREE_VALUE (basetype_chain);\n       if (TREE_CHAIN (basetype_chain))\n-\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n-\t\t\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)),\n-\t\t\t    980827);\n+\tmy_friendly_assert\n+\t  ((BINFO_INHERITANCE_CHAIN (basetype_path)\n+\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)))\n+\t   /* We only approximate base info for partial instantiations.  */ \n+\t   || current_template_parms,\n+\t   980827);\n       else\n \tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n \t\t\t    == NULL_TREE, 980827);\n@@ -1187,7 +1190,6 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   /* Do implicit typename stuff.  */\n   if (rval && TREE_CODE (rval) == TYPE_DECL\n-      && ! DECL_ARTIFICIAL (rval)\n       && processing_template_decl\n       && ! currently_open_class (BINFO_TYPE (rval_binfo))\n       && uses_template_parms (type))\n@@ -1480,9 +1482,12 @@ lookup_fnfields (basetype_path, name, complain)\n       basetype_chain = TREE_CHAIN (basetype_chain);\n       basetype_path = TREE_VALUE (basetype_chain);\n       if (TREE_CHAIN (basetype_chain))\n-\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n-\t\t\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)),\n-\t\t\t    980827);\n+\tmy_friendly_assert\n+\t  ((BINFO_INHERITANCE_CHAIN (basetype_path)\n+\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)))\n+\t   /* We only approximate base info for partial instantiations.  */ \n+\t   || current_template_parms,\n+\t   980827);\n       else\n \tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n \t\t\t    == NULL_TREE, 980827);"}, {"sha": "10ffe1987bfa573349aa8b4c1b51cb3eea345af3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830fcda8e7190213c80fb26c43c12e0c8e999a15/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=830fcda8e7190213c80fb26c43c12e0c8e999a15", "patch": "@@ -1114,13 +1114,7 @@ begin_constructor_declarator (scope, name)\n      tree name;\n {\n   tree result = build_parse_node (SCOPE_REF, scope, name);\n-\n-  if (scope != current_class_type)\n-    {\n-      push_nested_class (scope, 3);\n-      TREE_COMPLEXITY (result) = current_class_depth;\n-    }\n-\n+  enter_scope_of (result);\n   return result;\n }\n \n@@ -1214,24 +1208,27 @@ tree\n begin_class_definition (t)\n      tree t;\n {\n-  tree new_type = t;\n-\n   push_obstacks_nochange ();\n   end_temporary_allocation ();\n   \n   if (t == error_mark_node\n       || ! IS_AGGR_TYPE (t))\n     {\n-      t = new_type = make_lang_type (RECORD_TYPE);\n+      t = make_lang_type (RECORD_TYPE);\n       pushtag (make_anon_name (), t, 0);\n     }\n+\n+  /* In a definition of a member class template, we will get here with an\n+     implicit typename, a TYPENAME_TYPE with a type.  */\n+  if (TREE_CODE (t) == TYPENAME_TYPE)\n+    t = TREE_TYPE (t);\n+\n   if (TYPE_SIZE (t))\n     duplicate_tag_error (t);\n   if (TYPE_SIZE (t) || TYPE_BEING_DEFINED (t))\n     {\n       t = make_lang_type (TREE_CODE (t));\n       pushtag (TYPE_IDENTIFIER (t), t, 0);\n-      new_type = t;\n     }\n   if (processing_template_decl && TYPE_CONTEXT (t)\n       && TREE_CODE (TYPE_CONTEXT (t)) != NAMESPACE_DECL\n@@ -1267,9 +1264,9 @@ begin_class_definition (t)\n       CLASSTYPE_VTABLE_NEEDS_WRITING (t) = needs_writing;\n     }\n #if 0\n-  t = TYPE_IDENTIFIER ($<ttype>0);\n-  if (t && IDENTIFIER_TEMPLATE (t))\n-    overload_template_name (t, 1);\n+  tmp = TYPE_IDENTIFIER ($<ttype>0);\n+  if (tmp && IDENTIFIER_TEMPLATE (tmp))\n+    overload_template_name (tmp, 1);\n #endif\n   reset_specialization();\n   \n@@ -1278,7 +1275,7 @@ begin_class_definition (t)\n      that we can get it back later.  */\n   begin_tree ();\n \n-  return new_type;\n+  return t;\n }\n \n /* Finish a class definition T, with the indicated COMPONENTS, and\n@@ -1432,6 +1429,13 @@ enter_scope_of (sr)\n     }\n   else if (scope != current_class_type)\n     {\n+      if (TREE_CODE (scope) == TYPENAME_TYPE)\n+\t{\n+\t  /* In a declarator for a template class member, the scope will\n+\t     get here as an implicit typename, a TYPENAME_TYPE with a type.  */\n+\t  scope = TREE_TYPE (scope);\n+\t  TREE_OPERAND (sr, 0) = scope;\n+\t}\n       push_nested_class (scope, 3);\n       TREE_COMPLEXITY (sr) = current_class_depth;\n     }"}]}