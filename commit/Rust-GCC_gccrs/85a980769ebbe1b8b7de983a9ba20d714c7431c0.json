{"sha": "85a980769ebbe1b8b7de983a9ba20d714c7431c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVhOTgwNzY5ZWJiZTFiOGI3ZGU5ODNhOWJhMjBkNzE0Yzc0MzFjMA==", "commit": {"author": {"name": "Kuan-Lin Chen", "email": "kuanlinchentw@gmail.com", "date": "2018-05-19T08:57:57Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-05-19T08:57:57Z"}, "message": "[NDS32] Implment indirect funciton call attribute.\n\n\t* config/nds32/constants.md (unspec_element): Add UNSPEC_ICT.\n\t* config/nds32/nds32-md-auxiliary.c\n\t(symbolic_reference_mentioned_p): New.\n\t(nds32_legitimize_ict_address): New.\n\t(nds32_expand_ict_move): New.\n\t(nds32_indirect_call_referenced_p): New.\n\t(nds32_symbol_binds_local_p): Delete.\n\t(nds32_long_call_p): Modify.\n\t* config/nds32/nds32-opts.h (nds32_ict_model_type): New enum type.\n\t* config/nds32/nds32-protos.h\n\t(symbolic_reference_mentioned_p): Declare.\n\t(nds32_legitimize_ict_address): Declare.\n\t(nds32_expand_ict_move): Declare.\n\t(nds32_indirect_call_referenced_p): Declare.\n\t* config/nds32/nds32-relax-opt.c (nds32_ict_const_p): New.\n\t(nds32_relax_group): Use nds32_ict_const_p as condition.\n\t* config/nds32/nds32.c (nds32_attribute_table): Add \"indirect_call\".\n\t(nds32_asm_file_start): Output ict_model directive in asm code.\n\t(nds32_legitimate_address_p): Consider indirect call.\n\t(nds32_print_operand): Consider indirect call.\n\t(nds32_print_operand_address): Consider indirect call.\n\t(nds32_insert_attributes): Handle \"indirect_call\" attribute.\n\t(TARGET_LEGITIMATE_ADDRESS_P): Define.\n\t(TARGET_LEGITIMATE_CONSTANT_P): Define.\n\t(TARGET_CANNOT_FORCE_CONST_MEM): Define.\n\t(TARGET_DELEGITIMIZE_ADDRESS): Define.\n\t(TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA): Define.\n\t* config/nds32/nds32.h (SYMBOLIC_CONST_P): Define.\n\t(TARGET_ICT_MODEL_SMALL): Define.\n\t(TARGET_ICT_MODEL_LARGE): Define.\n\t* config/nds32/nds32.md (movsi): Consider ict model.\n\t(call, call_value): Consider ict model.\n\t(sibcall, sibcall_value): Consider ict model.\n\t* config/nds32/nds32.opt (mict-model): New option.\n\t* config/nds32/predicates.md (nds32_symbolic_operand): Consider ict\n\tmodel.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r260390", "tree": {"sha": "8181124edca780d039889214a3cb55fb651ecd9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8181124edca780d039889214a3cb55fb651ecd9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85a980769ebbe1b8b7de983a9ba20d714c7431c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a980769ebbe1b8b7de983a9ba20d714c7431c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a980769ebbe1b8b7de983a9ba20d714c7431c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a980769ebbe1b8b7de983a9ba20d714c7431c0/comments", "author": {"login": "kuanlinchentw", "id": 24240991, "node_id": "MDQ6VXNlcjI0MjQwOTkx", "avatar_url": "https://avatars.githubusercontent.com/u/24240991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kuanlinchentw", "html_url": "https://github.com/kuanlinchentw", "followers_url": "https://api.github.com/users/kuanlinchentw/followers", "following_url": "https://api.github.com/users/kuanlinchentw/following{/other_user}", "gists_url": "https://api.github.com/users/kuanlinchentw/gists{/gist_id}", "starred_url": "https://api.github.com/users/kuanlinchentw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kuanlinchentw/subscriptions", "organizations_url": "https://api.github.com/users/kuanlinchentw/orgs", "repos_url": "https://api.github.com/users/kuanlinchentw/repos", "events_url": "https://api.github.com/users/kuanlinchentw/events{/privacy}", "received_events_url": "https://api.github.com/users/kuanlinchentw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a76400f4e68030bf91bc20b39ed585e596e18ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a76400f4e68030bf91bc20b39ed585e596e18ea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a76400f4e68030bf91bc20b39ed585e596e18ea5"}], "stats": {"total": 526, "additions": 501, "deletions": 25}, "files": [{"sha": "ceabfc19b628c7c5e9fc4d91df344d302a5f591f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -1,3 +1,43 @@\n+2018-05-19  Kuan-Lin Chen <kuanlinchentw@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/constants.md (unspec_element): Add UNSPEC_ICT.\n+\t* config/nds32/nds32-md-auxiliary.c\n+\t(symbolic_reference_mentioned_p): New.\n+\t(nds32_legitimize_ict_address): New.\n+\t(nds32_expand_ict_move): New.\n+\t(nds32_indirect_call_referenced_p): New.\n+\t(nds32_symbol_binds_local_p): Delete.\n+\t(nds32_long_call_p): Modify.\n+\t* config/nds32/nds32-opts.h (nds32_ict_model_type): New enum type.\n+\t* config/nds32/nds32-protos.h\n+\t(symbolic_reference_mentioned_p): Declare.\n+\t(nds32_legitimize_ict_address): Declare.\n+\t(nds32_expand_ict_move): Declare.\n+\t(nds32_indirect_call_referenced_p): Declare.\n+\t* config/nds32/nds32-relax-opt.c (nds32_ict_const_p): New.\n+\t(nds32_relax_group): Use nds32_ict_const_p as condition.\n+\t* config/nds32/nds32.c (nds32_attribute_table): Add \"indirect_call\".\n+\t(nds32_asm_file_start): Output ict_model directive in asm code.\n+\t(nds32_legitimate_address_p): Consider indirect call.\n+\t(nds32_print_operand): Consider indirect call.\n+\t(nds32_print_operand_address): Consider indirect call.\n+\t(nds32_insert_attributes): Handle \"indirect_call\" attribute.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): Define.\n+\t(TARGET_LEGITIMATE_CONSTANT_P): Define.\n+\t(TARGET_CANNOT_FORCE_CONST_MEM): Define.\n+\t(TARGET_DELEGITIMIZE_ADDRESS): Define.\n+\t(TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA): Define.\n+\t* config/nds32/nds32.h (SYMBOLIC_CONST_P): Define.\n+\t(TARGET_ICT_MODEL_SMALL): Define.\n+\t(TARGET_ICT_MODEL_LARGE): Define.\n+\t* config/nds32/nds32.md (movsi): Consider ict model.\n+\t(call, call_value): Consider ict model.\n+\t(sibcall, sibcall_value): Consider ict model.\n+\t* config/nds32/nds32.opt (mict-model): New option.\n+\t* config/nds32/predicates.md (nds32_symbolic_operand): Consider ict\n+\tmodel.\n+\n 2018-05-18  Kito Cheng  <kito.cheng@gmail.com>\n \t    Monk Chiang  <sh.chiang04@gmail.com>\n \t    Jim Wilson <jimw@sifive.com>"}, {"sha": "c4cde8d7ebe3eebf259d8bbb9792179854a5c41d", "filename": "gcc/config/nds32/constants.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fconstants.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fconstants.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstants.md?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -83,6 +83,7 @@\n   UNSPEC_LOOP_END\n   UNSPEC_TLS_DESC\n   UNSPEC_TLS_IE\n+  UNSPEC_ICT\n   UNSPEC_KADDH\n   UNSPEC_KSUBH\n ])"}, {"sha": "99beff6d8288c29cc5af14ee7c8828000cc76cb2", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 93, "deletions": 11, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -39,6 +39,9 @@\n #include \"expr.h\"\n #include \"emit-rtl.h\"\n #include \"explow.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+\n \n /* ------------------------------------------------------------------------ */\n \n@@ -2970,16 +2973,6 @@ nds32_output_unpkd8 (rtx output, rtx input,\n   return \"\";\n }\n \n-/* Return true if SYMBOL_REF X binds locally.  */\n-\n-static bool\n-nds32_symbol_binds_local_p (const_rtx x)\n-{\n-  return (SYMBOL_REF_DECL (x)\n-\t  ? targetm.binds_local_p (SYMBOL_REF_DECL (x))\n-\t  : SYMBOL_REF_LOCAL_P (x));\n-}\n-\n const char *\n nds32_output_call (rtx insn, rtx *operands, rtx symbol, const char *long_call,\n \t\t   const char *call, bool align_p)\n@@ -3400,11 +3393,100 @@ nds32_split_rotatertdi3 (rtx dst, rtx src, rtx shiftamount)\n   emit_insn (gen_cmovnsi (dst_high_part, select_reg,\n \t\t\t  dst_high_part_l32, dst_high_part_g32));\n }\n+\n+/* Return true if OP contains a symbol reference.  */\n+bool\n+symbolic_reference_mentioned_p (rtx op)\n+{\n+  const char *fmt;\n+  int i;\n+\n+  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n+    return true;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (op));\n+  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n+\t    if (symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n+\t      return true;\n+\t}\n+\n+      else if (fmt[i] == 'e' && symbolic_reference_mentioned_p (XEXP (op, i)))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Expand ICT symbol.\n+    Example for @ICT and ICT model=large:\n+\n+    la $r0, symbol@ICT\n+      -> sethi $rt, hi20(symbol@ICT)\n+\t lwi $r0, [$rt + lo12(symbol@ICT)]\n+\n+*/\n+rtx\n+nds32_legitimize_ict_address (rtx x)\n+{\n+  rtx symbol = x;\n+  rtx addr = x;\n+  rtx reg = gen_reg_rtx (Pmode);\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF\n+\t      && nds32_indirect_call_referenced_p (x));\n+\n+  addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, symbol), UNSPEC_ICT);\n+  addr = gen_rtx_CONST (SImode, addr);\n+  emit_insn (gen_sethi (reg, addr));\n+\n+  x = gen_const_mem (SImode, gen_rtx_LO_SUM (Pmode, reg, addr));\n+\n+  return x;\n+}\n+\n+void\n+nds32_expand_ict_move (rtx *operands)\n+{\n+  rtx src = operands[1];\n+\n+  src = nds32_legitimize_ict_address (src);\n+\n+  emit_move_insn (operands[0], src);\n+}\n+\n+/* Return true X is a indirect call symbol.  */\n+bool\n+nds32_indirect_call_referenced_p (rtx x)\n+{\n+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_ICT)\n+    x = XVECEXP (x, 0, 0);\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      tree decl = SYMBOL_REF_DECL (x);\n+\n+      return decl\n+\t     && (lookup_attribute(\"indirect_call\",\n+\t\t\t\t  DECL_ATTRIBUTES(decl))\n+\t\t != NULL);\n+    }\n+\n+  return false;\n+}\n+\n /* Return true X is need use long call.  */\n bool\n nds32_long_call_p (rtx symbol)\n {\n-  return TARGET_CMODEL_LARGE;\n+  if (nds32_indirect_call_referenced_p (symbol))\n+    return TARGET_ICT_MODEL_LARGE;\n+  else\n+    return TARGET_CMODEL_LARGE;\n }\n \n void"}, {"sha": "e75e75f433282d56263186692dc059aebf002542", "filename": "gcc/config/nds32/nds32-opts.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -57,6 +57,13 @@ enum nds32_cmodel_type\n   CMODEL_LARGE\n };\n \n+/* The code model defines the address generation strategy.  */\n+enum nds32_ict_model_type\n+{\n+  ICT_MODEL_SMALL,\n+  ICT_MODEL_LARGE\n+};\n+\n /* Multiply instruction configuration.  */\n enum nds32_mul_type\n {"}, {"sha": "4bf82f1f723d96002a4ec42843a6cebb4d8663cd", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -183,9 +183,25 @@ extern void nds32_expand_float_movcc (rtx *);\n extern enum nds32_expand_result_type nds32_expand_extv (rtx *);\n extern enum nds32_expand_result_type nds32_expand_insv (rtx *);\n \n+/* Auxiliary functions for expand ICT instruction.  */\n+\n+extern void nds32_expand_ict_move (rtx *);\n+\n+/* Auxiliary functions to legitimize address for indirect-call symbol.  */\n+\n+extern rtx nds32_legitimize_ict_address (rtx);\n+\n+/* Auxiliary functions to identify indirect-call symbol.  */\n+\n+extern bool nds32_indirect_call_referenced_p (rtx);\n+\n /* Auxiliary functions to identify long-call symbol.  */\n extern bool nds32_long_call_p (rtx);\n \n+/* Auxiliary functions to identify SYMBOL_REF and LABEL_REF pattern.  */\n+\n+extern bool symbolic_reference_mentioned_p (rtx);\n+\n /* Auxiliary functions to identify conditional move comparison operand.  */\n \n extern int nds32_cond_move_p (rtx);"}, {"sha": "0a878aaff9fb11f0bd146f31cb44c718f5922466", "filename": "gcc/config/nds32/nds32-relax-opt.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-relax-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32-relax-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-relax-opt.c?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -185,6 +185,17 @@ nds32_plus_reg_load_store_p (rtx_insn *insn)\n   return false;\n }\n \n+/* Return true if x is const and the referance is ict symbol.  */\n+static bool\n+nds32_ict_const_p (rtx x)\n+{\n+  if (GET_CODE (x) == CONST)\n+    {\n+      x = XEXP (x, 0);\n+      return nds32_indirect_call_referenced_p (x);\n+    }\n+  return FALSE;\n+}\n /* Group the relax candidates with group id.  */\n static void\n nds32_group_insns (rtx sethi)\n@@ -271,7 +282,8 @@ nds32_relax_group (void)\n \t  /* Find sethi ra, symbol  instruction.  */\n \t  if (recog_memoized (insn) == CODE_FOR_sethi\n \t      && nds32_symbolic_operand (XEXP (SET_SRC (PATTERN (insn)), 0),\n-\t\t\t\t\t SImode))\n+\t\t\t\t\t SImode)\n+\t      && !nds32_ict_const_p (XEXP (SET_SRC (PATTERN (insn)), 0)))\n \t    nds32_group_insns (insn);\n \t}\n     }"}, {"sha": "fe97854fe739ccad1afcf089aada719d547ddcb9", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 226, "deletions": 8, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -317,6 +317,9 @@ static const struct attribute_spec nds32_attribute_table[] =\n   /* The attribute telling no prologue/epilogue.  */\n   { \"naked\",        0,  0, false, false, false, false, NULL, NULL },\n \n+  /* The attribute is used to tell this function to be ROM patch.  */\n+  { \"indirect_call\",0,  0, false, false, false, false, NULL, NULL },\n+\n   /* The last attribute spec is set to be NULL.  */\n   { NULL,           0,  0, false, false, false, false, NULL, NULL }\n };\n@@ -2576,6 +2579,9 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \n     case SYMBOL_REF:\n       /* (mem (symbol_ref A)) => [symbol_ref] */\n+      if (TARGET_ICT_MODEL_LARGE && nds32_indirect_call_referenced_p (x))\n+\treturn false;\n+\n       /* If -mcmodel=large, the 'symbol_ref' is not a valid address\n \t during or after LRA/reload phase.  */\n       if (TARGET_CMODEL_LARGE\n@@ -2685,19 +2691,124 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \n     case LO_SUM:\n       /* (mem (lo_sum (reg) (symbol_ref))) */\n-      /* (mem (lo_sum (reg) (const))) */\n-      gcc_assert (REG_P (XEXP (x, 0)));\n-      if (GET_CODE (XEXP (x, 1)) == SYMBOL_REF\n-\t  || GET_CODE (XEXP (x, 1)) == CONST)\n-\treturn nds32_legitimate_address_p (mode, XEXP (x, 1), strict);\n-      else\n-\treturn false;\n+      /* (mem (lo_sum (reg) (const (plus (symbol_ref) (reg)))) */\n+      {\n+\trtx sym = NULL_RTX;\n+\n+\tif (!REG_P (XEXP (x, 0)))\n+\t  return false;\n+\n+\tif (GET_CODE (XEXP (x, 1)) == SYMBOL_REF)\n+\t  sym = XEXP (x, 1);\n+\telse if (GET_CODE (XEXP (x, 1)) == CONST)\n+\t  {\n+\t    rtx plus = XEXP(XEXP (x, 1), 0);\n+\t    if (GET_CODE (plus) == PLUS)\n+\t      sym = XEXP (plus, 0);\n+\t    else if (GET_CODE (plus) == UNSPEC)\n+\t      sym = XVECEXP (plus, 0, 0);\n+\t  }\n+\telse\n+\t  return false;\n+\n+\tgcc_assert (GET_CODE (sym) == SYMBOL_REF);\n+\n+\tif (TARGET_ICT_MODEL_LARGE\n+\t    && nds32_indirect_call_referenced_p (sym))\n+\t  return true;\n+\n+\tif (TARGET_CMODEL_LARGE)\n+\t  return true;\n+\telse if (TARGET_CMODEL_MEDIUM\n+\t\t && NDS32_SYMBOL_REF_RODATA_P (sym))\n+\t  return true;\n+\telse\n+\t  return false;\n+      }\n \n     default:\n       return false;\n     }\n }\n \n+static rtx\n+nds32_legitimize_address (rtx x,\n+\t\t\t  rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t  machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_ICT_MODEL_LARGE && nds32_indirect_call_referenced_p (x))\n+    x = nds32_legitimize_ict_address (x);\n+\n+  return x;\n+}\n+\n+static bool\n+nds32_legitimate_constant_p (machine_mode mode, rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_DOUBLE:\n+      if ((TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+\t  && (mode == DFmode || mode == SFmode))\n+\treturn false;\n+      break;\n+    case CONST:\n+      x = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == PLUS)\n+\t{\n+\t  if (!CONST_INT_P (XEXP (x, 1)))\n+\t    return false;\n+\t  x = XEXP (x, 0);\n+\t}\n+\n+      if (GET_CODE (x) == UNSPEC)\n+\t{\n+\t  switch (XINT (x, 1))\n+\t    {\n+\t    case UNSPEC_ICT:\n+\t      return false;\n+\t    default:\n+\t      return true;\n+\t    }\n+\t}\n+      break;\n+    default:\n+      return true;\n+    }\n+\n+  return true;\n+}\n+\n+/* Reorgnize the UNSPEC CONST and return its direct symbol.  */\n+static rtx\n+nds32_delegitimize_address (rtx x)\n+{\n+  x = delegitimize_mem_from_attrs (x);\n+\n+  if (GET_CODE(x) == CONST)\n+    {\n+      rtx inner = XEXP (x, 0);\n+\n+      /* Handle for GOTOFF.  */\n+      if (GET_CODE (inner) == PLUS)\n+\tinner = XEXP (inner, 0);\n+\n+      if (GET_CODE (inner) == UNSPEC)\n+\t{\n+\t  switch (XINT (inner, 1))\n+\t    {\n+\t    case UNSPEC_ICT:\n+\t      x = XVECEXP (inner, 0, 0);\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return x;\n+}\n+\n static machine_mode\n nds32_vectorize_preferred_simd_mode (scalar_mode mode)\n {\n@@ -2715,6 +2826,29 @@ nds32_vectorize_preferred_simd_mode (scalar_mode mode)\n     }\n }\n \n+static bool\n+nds32_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+      return !nds32_legitimate_constant_p (mode, x);\n+    case SYMBOL_REF:\n+      /* All symbols have to be accessed through gp-relative in PIC mode.  */\n+      /* We don't want to force symbol as constant pool in .text section,\n+\t because we use the gp-relatived instruction to load in small\n+\t or medium model.  */\n+      if (SYMBOL_REF_TLS_MODEL (x)\n+\t  || TARGET_CMODEL_SMALL\n+\t  || TARGET_CMODEL_MEDIUM)\n+\treturn true;\n+      break;\n+    default:\n+      return false;\n+    }\n+  return false;\n+}\n+\n \f\n /* Condition Code Status.  */\n \n@@ -2862,6 +2996,11 @@ nds32_asm_file_start (void)\n   /* Tell assembler that this asm code is generated by compiler.  */\n   fprintf (asm_out_file, \"\\t! This asm file is generated by compiler\\n\");\n   fprintf (asm_out_file, \"\\t.flag\\tverbatim\\n\");\n+\n+  if (TARGET_ICT_MODEL_LARGE)\n+    fprintf (asm_out_file, \"\\t.ict_model\\tlarge\\n\");\n+  else\n+    fprintf (asm_out_file, \"\\t.ict_model\\tsmall\\n\");\n   /* Give assembler the size of each vector for interrupt handler.  */\n   fprintf (asm_out_file, \"\\t! This vector size directive is required \"\n \t\t\t \"for checking inconsistency on interrupt handler\\n\");\n@@ -2956,6 +3095,26 @@ nds32_asm_file_end (void)\n   fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n }\n \n+static bool\n+nds32_asm_output_addr_const_extra (FILE *file, rtx x)\n+{\n+  if (GET_CODE (x) == UNSPEC)\n+    {\n+      switch (XINT (x, 1))\n+\t{\n+\tcase UNSPEC_ICT:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@ICT\", file);\n+\t  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n /* -- Output and Generation of Labels.  */\n \n static void\n@@ -3123,8 +3282,15 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n   switch (GET_CODE (x))\n     {\n     case LABEL_REF:\n+      output_addr_const (stream, x);\n+      break;\n+\n     case SYMBOL_REF:\n       output_addr_const (stream, x);\n+\n+      if (nds32_indirect_call_referenced_p (x))\n+\tfprintf (stream, \"@ICT\");\n+\n       break;\n \n     case REG:\n@@ -3211,6 +3377,13 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n       fprintf (stream, HOST_WIDE_INT_PRINT_HEX, const_vector_to_hwint (x));\n       break;\n \n+    case LO_SUM:\n+      /* This is a special case for inline assembly using memory address 'p'.\n+\t The inline assembly code is expected to use pesudo instruction\n+\t for the operand.  EX: la  */\n+      output_addr_const (stream, XEXP(x, 1));\n+      break;\n+\n     default:\n       /* Generally, output_addr_const () is able to handle most cases.\n \t We want to see what CODE could appear,\n@@ -3222,7 +3395,9 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n }\n \n static void\n-nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n+nds32_print_operand_address (FILE *stream,\n+\t\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     rtx x)\n {\n   rtx op0, op1;\n \n@@ -3237,6 +3412,16 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n       fputs (\"]\", stream);\n       break;\n \n+    case LO_SUM:\n+      /* This is a special case for inline assembly using memory operand 'm'.\n+\t The inline assembly code is expected to use pesudo instruction\n+\t for the operand.  EX: [ls].[bhw]  */\n+      fputs (\"[ + \", stream);\n+      op1 = XEXP (x, 1);\n+      output_addr_const (stream, op1);\n+      fputs (\"]\", stream);\n+      break;\n+\n     case REG:\n       /* Forbid using static chain register ($r16)\n \t on reduced-set registers configuration.  */\n@@ -3511,6 +3696,24 @@ nds32_merge_decl_attributes (tree olddecl, tree newdecl)\n static void\n nds32_insert_attributes (tree decl, tree *attributes)\n {\n+  /* A \"indirect_call\" function attribute implies \"noinline\" and \"noclone\"\n+     for elf toolchain to support ROM patch mechanism.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && lookup_attribute (\"indirect_call\", *attributes) != NULL)\n+    {\n+      tree new_attrs = *attributes;\n+\n+      if (lookup_attribute (\"noinline\", new_attrs) == NULL)\n+\tnew_attrs = tree_cons (get_identifier (\"noinline\"), NULL, new_attrs);\n+      if (lookup_attribute (\"noclone\", new_attrs) == NULL)\n+\tnew_attrs = tree_cons (get_identifier (\"noclone\"), NULL, new_attrs);\n+\n+      if (!TREE_PUBLIC (decl))\n+\terror(\"indirect_call attribute can't apply for static function\");\n+\n+      *attributes = new_attrs;\n+    }\n+\n   /* For function declaration, we need to check isr-specific attributes:\n        1. Call nds32_check_isr_attrs_conflict() to check any conflict.\n        2. Check valid integer value for interrupt/exception.\n@@ -5149,9 +5352,21 @@ nds32_use_blocks_for_constant_p (machine_mode mode,\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P nds32_legitimate_address_p\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS nds32_legitimize_address\n+\n+#undef TARGET_LEGITIMATE_CONSTANT_P\n+#define TARGET_LEGITIMATE_CONSTANT_P nds32_legitimate_constant_p\n+\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE nds32_vectorize_preferred_simd_mode\n \n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM nds32_cannot_force_const_mem\n+\n+#undef TARGET_DELEGITIMIZE_ADDRESS\n+#define TARGET_DELEGITIMIZE_ADDRESS nds32_delegitimize_address\n+\n \f\n /* Anchored Addresses.  */\n \n@@ -5212,6 +5427,9 @@ nds32_use_blocks_for_constant_p (machine_mode mode,\n #undef TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n \n+#undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA\n+#define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA nds32_asm_output_addr_const_extra\n+\n /* -- Output of Uninitialized Variables.  */\n \n /* -- Output and Generation of Labels.  */"}, {"sha": "481c196e30cdc0009918b8dd558565a3c989c961", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -855,6 +855,12 @@ enum nds32_builtins\n #define TARGET_CMODEL_LARGE \\\n    (nds32_cmodel_option == CMODEL_LARGE)\n \n+#define TARGET_ICT_MODEL_SMALL \\\n+   (nds32_ict_model == ICT_MODEL_SMALL)\n+\n+#define TARGET_ICT_MODEL_LARGE \\\n+   (nds32_ict_model == ICT_MODEL_LARGE)\n+\n /* When -mcmodel=small or -mcmodel=medium,\n    compiler may generate gp-base instruction directly.  */\n #define TARGET_GP_DIRECT \\\n@@ -1461,6 +1467,11 @@ enum reg_class\n \n #define PIC_OFFSET_TABLE_REGNUM GP_REGNUM\n \n+#define SYMBOLIC_CONST_P(X)\t\\\n+(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n+ || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+ || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+\n \f\n /* Defining the Output Assembler Language.  */\n "}, {"sha": "a4f204b0ed24e301c5325da1e0358c7ab13348ad", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -215,6 +215,17 @@\n \t\t\t\t\t\t  low12_int));\n       DONE;\n     }\n+\n+  if ((REG_P (operands[0]) || GET_CODE (operands[0]) == SUBREG)\n+       && SYMBOLIC_CONST_P (operands[1]))\n+    {\n+      if (TARGET_ICT_MODEL_LARGE\n+\t  && nds32_indirect_call_referenced_p (operands[1]))\n+\t{\n+\t  nds32_expand_ict_move (operands);\n+\t  DONE;\n+\t}\n+    }\n })\n \n (define_insn \"*mov<mode>\"\n@@ -1479,7 +1490,26 @@\n \t      (clobber (reg:SI LP_REGNUM))\n \t      (clobber (reg:SI TA_REGNUM))])]\n   \"\"\n-  \"\"\n+  {\n+    rtx insn;\n+    rtx sym = XEXP (operands[0], 0);\n+\n+    if (TARGET_ICT_MODEL_LARGE\n+\t&& nds32_indirect_call_referenced_p (sym))\n+      {\n+\trtx reg = gen_reg_rtx (Pmode);\n+\temit_move_insn (reg, sym);\n+\toperands[0] = gen_const_mem (Pmode, reg);\n+      }\n+\n+    if (flag_pic)\n+      {\n+\tinsn = emit_call_insn (gen_call_internal\n+\t\t\t       (XEXP (operands[0], 0), GEN_INT (0)));\n+\tuse_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+\tDONE;\n+      }\n+  }\n )\n \n (define_insn \"call_internal\"\n@@ -1543,7 +1573,29 @@\n \t\t         (match_operand 2)))\n \t      (clobber (reg:SI LP_REGNUM))\n \t      (clobber (reg:SI TA_REGNUM))])]\n-  \"\")\n+  \"\"\n+  {\n+    rtx insn;\n+    rtx sym = XEXP (operands[1], 0);\n+\n+    if (TARGET_ICT_MODEL_LARGE\n+\t&& nds32_indirect_call_referenced_p (sym))\n+      {\n+\trtx reg = gen_reg_rtx (Pmode);\n+\temit_move_insn (reg, sym);\n+\toperands[1] = gen_const_mem (Pmode, reg);\n+      }\n+\n+    if (flag_pic)\n+      {\n+\tinsn =\n+\t  emit_call_insn (gen_call_value_internal\n+\t\t\t  (operands[0], XEXP (operands[1], 0), GEN_INT (0)));\n+\tuse_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+\tDONE;\n+      }\n+  }\n+)\n \n (define_insn \"call_value_internal\"\n   [(parallel [(set (match_operand 0)\n@@ -1634,7 +1686,18 @@\n \t\t    (const_int 0))\n \t      (clobber (reg:SI TA_REGNUM))\n \t      (return)])]\n-  \"\")\n+  \"\"\n+{\n+    rtx sym = XEXP (operands[0], 0);\n+\n+    if (TARGET_ICT_MODEL_LARGE\n+\t&& nds32_indirect_call_referenced_p (sym))\n+      {\n+\trtx reg = gen_reg_rtx (Pmode);\n+\temit_move_insn (reg, sym);\n+\toperands[0] = gen_const_mem (Pmode, reg);\n+      }\n+})\n \n (define_insn \"sibcall_internal\"\n   [(parallel [(call (mem (match_operand:SI 0 \"nds32_call_address_operand\" \"r, i\"))\n@@ -1684,7 +1747,18 @@\n \t\t\t (const_int 0)))\n \t      (clobber (reg:SI TA_REGNUM))\n \t      (return)])]\n-  \"\")\n+  \"\"\n+{\n+    rtx sym = XEXP (operands[1], 0);\n+\n+    if (TARGET_ICT_MODEL_LARGE\n+\t&& nds32_indirect_call_referenced_p (sym))\n+      {\n+\trtx reg = gen_reg_rtx (Pmode);\n+\temit_move_insn (reg, sym);\n+\toperands[1] = gen_const_mem (Pmode, reg);\n+      }\n+})\n \n (define_insn \"sibcall_value_internal\"\n   [(parallel [(set (match_operand 0)"}, {"sha": "9e481549d9dbb0d34bbecae6e9ab9699de7e2f8c", "filename": "gcc/config/nds32/nds32.opt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.opt?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -85,6 +85,19 @@ mlittle-endian\n Target Undocumented RejectNegative Negative(mbig-endian) InverseMask(BIG_ENDIAN)\n Generate code in little-endian mode.\n \n+mict-model=\n+Target Undocumented RejectNegative Joined Enum(nds32_ict_model_type) Var(nds32_ict_model) Init(ICT_MODEL_SMALL)\n+Specify the address generation strategy for ICT call's code model.\n+\n+Enum\n+Name(nds32_ict_model_type) Type(enum nds32_ict_model_type)\n+Known cmodel types (for use with the -mict-model= option):\n+\n+EnumValue\n+Enum(nds32_ict_model_type) String(small) Value(ICT_MODEL_SMALL)\n+\n+EnumValue\n+Enum(nds32_ict_model_type) String(large) Value(ICT_MODEL_LARGE)\n \n mcmov\n Target Report Mask(CMOV)"}, {"sha": "59292da8328814418387cdc8e06920730cefb7fd", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a980769ebbe1b8b7de983a9ba20d714c7431c0/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=85a980769ebbe1b8b7de983a9ba20d714c7431c0", "patch": "@@ -40,7 +40,9 @@\n   (match_code \"mult,and,ior,xor\"))\n \n (define_predicate \"nds32_symbolic_operand\"\n-  (match_code \"const,symbol_ref,label_ref\"))\n+  (and (match_code \"const,symbol_ref,label_ref\")\n+       (match_test \"!(TARGET_ICT_MODEL_LARGE\n+\t\t      && nds32_indirect_call_referenced_p (op))\")))\n \n (define_predicate \"nds32_reg_constant_operand\"\n   (ior (match_operand 0 \"register_operand\")"}]}