{"sha": "d84e64d416af881a3dbc9eed8dd0212cc473baf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg0ZTY0ZDQxNmFmODgxYTNkYmM5ZWVkOGRkMDIxMmNjNDczYmFmOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-10-26T19:54:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-26T19:54:42Z"}, "message": "dwarf2out.c (output_call_frame_info): The CIE pointer is now a 32 bit PC-relative offset.\n\n\t* dwarf2out.c (output_call_frame_info): The CIE pointer is now a 32\n \tbit PC-relative offset.  The exception range table pointer is now in\n \tthe CIE.\n\t* frame.c (dwarf_cie, dwarf_fde): Rename CIE_pointer to CIE_delta.\n\t(count_fdes, add_fdes, get_cie): Adjust.\n\t(cie_info, extract_cie_info, __frame_state_for): Adjust eh_ptr uses.\n\n\tFrom H.J. Lu:\n\t* frame.c (count_fdes, add_fdes): Skip linked once FDE entries.\n\nFrom-SVN: r16192", "tree": {"sha": "4e1082dba15dedf1e0cf5b5116ab52cddd4e3511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e1082dba15dedf1e0cf5b5116ab52cddd4e3511"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d84e64d416af881a3dbc9eed8dd0212cc473baf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84e64d416af881a3dbc9eed8dd0212cc473baf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d84e64d416af881a3dbc9eed8dd0212cc473baf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84e64d416af881a3dbc9eed8dd0212cc473baf8/comments", "author": null, "committer": null, "parents": [{"sha": "bd123dc9f223f452d5dd6937dd6076d762bca564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd123dc9f223f452d5dd6937dd6076d762bca564", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd123dc9f223f452d5dd6937dd6076d762bca564"}], "stats": {"total": 94, "additions": 61, "deletions": 33}, "files": [{"sha": "88005429c9c3bf36504b1feba26c1d2808680ea9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84e64d416af881a3dbc9eed8dd0212cc473baf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84e64d416af881a3dbc9eed8dd0212cc473baf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d84e64d416af881a3dbc9eed8dd0212cc473baf8", "patch": "@@ -1,3 +1,15 @@\n+Sun Oct 26 11:41:49 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* dwarf2out.c (output_call_frame_info): The CIE pointer is now a 32\n+ \tbit PC-relative offset.  The exception range table pointer is now in\n+ \tthe CIE.\n+\t* frame.c (dwarf_cie, dwarf_fde): Rename CIE_pointer to CIE_delta.\n+\t(count_fdes, add_fdes, get_cie): Adjust.\n+\t(cie_info, extract_cie_info, __frame_state_for): Adjust eh_ptr uses.\n+\n+\tFrom H.J. Lu:\n+\t* frame.c (count_fdes, add_fdes): Skip linked once FDE entries.\n+\n Sun Oct 26 11:52:01 1997  Richard Henderson  <rth@cygnus.com>\n \n \t* alias.c (memrefs_conflict_p): Treat arg_pointer_rtx just"}, {"sha": "45b60d6e11b1c01c617ab996e5211b2499223869", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84e64d416af881a3dbc9eed8dd0212cc473baf8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84e64d416af881a3dbc9eed8dd0212cc473baf8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d84e64d416af881a3dbc9eed8dd0212cc473baf8", "patch": "@@ -1532,12 +1532,18 @@ output_call_frame_info (for_eh)\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DW_CIE_ID);\n+  if (for_eh)\n+    /* Now that the CIE pointer is PC-relative for EH,\n+       use 0 to identify the CIE.  */\n+    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n+  else\n+    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DW_CIE_ID);\n+\n   if (flag_debug_asm)\n     fprintf (asm_out_file, \"\\t%s CIE Identifier Tag\", ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n-  if (for_eh ? PTR_SIZE == 8 : DWARF_OFFSET_SIZE == 8)\n+  if (! for_eh && DWARF_OFFSET_SIZE == 8)\n     {\n       ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DW_CIE_ID);\n       fputc ('\\n', asm_out_file);\n@@ -1550,11 +1556,19 @@ output_call_frame_info (for_eh)\n   fputc ('\\n', asm_out_file);\n   if (eh_ptr)\n     {\n-      /* The FDE contains a pointer\n-\t to the exception region info for the frame.  */\n-      ASM_OUTPUT_DWARF_STRING (asm_out_file, \"e\");\n+      /* The CIE contains a pointer to the exception region info for the\n+         frame.  Make the augmentation string three bytes (including the\n+         trailing null) so the pointer is 4-byte aligned.  The Solaris ld\n+         can't handle unaligned relocs.  */\n+      ASM_OUTPUT_DWARF_STRING (asm_out_file, \"eh\");\n       if (flag_debug_asm)\n \tfprintf (asm_out_file, \"\\t%s CIE Augmentation\", ASM_COMMENT_START);\n+      fputc ('\\n', asm_out_file);\n+\n+      ASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__EXCEPTION_TABLE__\");\n+      if (flag_debug_asm)\n+\tfprintf (asm_out_file, \"\\t%s pointer to exception region info\",\n+\t\t ASM_COMMENT_START);\n     }\n   else\n     {\n@@ -1605,7 +1619,7 @@ output_call_frame_info (for_eh)\n       ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n       if (for_eh)\n-\tASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__FRAME_BEGIN__\");\n+\tASM_OUTPUT_DWARF_DELTA (asm_out_file, \".\", \"__FRAME_BEGIN__\");\n       else\n \tASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (FRAME_SECTION));\n       if (flag_debug_asm)\n@@ -1623,16 +1637,6 @@ output_call_frame_info (for_eh)\n \tfprintf (asm_out_file, \"\\t%s FDE address range\", ASM_COMMENT_START);\n \n       fputc ('\\n', asm_out_file);\n-      if (eh_ptr)\n-\t{\n-\t  /* For now, a pointer to the translation unit's info will do.\n-\t     ??? Eventually this should point to the function's info.  */\n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__EXCEPTION_TABLE__\");\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s pointer to exception region info\",\n-\t\t     ASM_COMMENT_START);\n-\t  fputc ('\\n', asm_out_file);\n-\t}\n \n       /* Loop through the Call Frame Instructions associated with\n \t this FDE.  */"}, {"sha": "ca0bb39de80221de1bcbd88fc74db34fa4245cf4", "filename": "gcc/frame.c", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84e64d416af881a3dbc9eed8dd0212cc473baf8/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84e64d416af881a3dbc9eed8dd0212cc473baf8/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=d84e64d416af881a3dbc9eed8dd0212cc473baf8", "patch": "@@ -46,9 +46,10 @@ Boston, MA 02111-1307, USA.  */\n \n /* Some types used by the DWARF 2 spec.  */\n \n-typedef unsigned int uword __attribute__ ((mode (SI)));\n-typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n-typedef int saddr __attribute__ ((mode (pointer)));\n+typedef          int  sword __attribute__ ((mode (SI)));\n+typedef unsigned int  uword __attribute__ ((mode (SI)));\n+typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n+typedef          int  saddr __attribute__ ((mode (pointer)));\n typedef unsigned char ubyte;\n \n /* The first few fields of a CIE.  The CIE_id field is 0xffffffff for a CIE,\n@@ -57,7 +58,7 @@ typedef unsigned char ubyte;\n \n struct dwarf_cie {\n   uword length;\n-  uaddr CIE_id;\n+  sword CIE_id;\n   ubyte version;\n   char augmentation[0];\n } __attribute__ ((packed, aligned (__alignof__ (void *))));\n@@ -66,7 +67,7 @@ struct dwarf_cie {\n \n struct dwarf_fde {\n   uword length;\n-  struct dwarf_cie* CIE_pointer;\n+  sword CIE_delta;\n   void* pc_begin;\n   uaddr pc_range;\n } __attribute__ ((packed, aligned (__alignof__ (void *))));\n@@ -92,6 +93,7 @@ static struct object *objects;\n \n struct cie_info {\n   char *augmentation;\n+  void *eh_ptr;\n   int code_align;\n   int data_align;\n   unsigned ra_regno;\n@@ -217,8 +219,8 @@ count_fdes (fde *this_fde)\n \n   for (count = 0; this_fde->length != 0; this_fde = next_fde (this_fde))\n     {\n-      /* Skip CIEs.  */\n-      if ((uaddr)(this_fde->CIE_pointer) == (uaddr)-1)\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_range == 0)\n \tcontinue;\n \n       ++count;\n@@ -237,8 +239,8 @@ add_fdes (fde *this_fde, fde **array, size_t *i_ptr,\n \n   for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n     {\n-      /* Skip CIEs.  */\n-      if ((uaddr)(this_fde->CIE_pointer) == (uaddr)-1)\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_range == 0)\n \tcontinue;\n \n       fde_insert (array, i++, this_fde);\n@@ -332,6 +334,12 @@ find_fde (void *pc)\n   return 0;\n }\n \f\n+static inline struct dwarf_cie *\n+get_cie (fde *f)\n+{\n+  return ((void *)&f->CIE_delta) - f->CIE_delta;\n+}\n+\n /* Extract any interesting information from the CIE for the translation\n    unit F belongs to.  */\n \n@@ -341,15 +349,23 @@ extract_cie_info (fde *f, struct cie_info *c)\n   void *p;\n   int i;\n \n-  c->augmentation = f->CIE_pointer->augmentation;\n+  c->augmentation = get_cie (f)->augmentation;\n \n   if (strcmp (c->augmentation, \"\") != 0\n-      && strcmp (c->augmentation, \"e\") != 0\n+      && strcmp (c->augmentation, \"eh\") != 0\n       && c->augmentation[0] != 'z')\n     return 0;\n \n   p = c->augmentation + strlen (c->augmentation) + 1;\n \n+  if (strcmp (c->augmentation, \"eh\") == 0)\n+    {\n+      c->eh_ptr = read_pointer (p);\n+      p += sizeof (void *);\n+    }\n+  else\n+    c->eh_ptr = 0;\n+\n   p = decode_uleb128 (p, &c->code_align);\n   p = decode_sleb128 (p, &c->data_align);\n   c->ra_regno = *(unsigned char *)p++;\n@@ -576,9 +592,10 @@ __frame_state_for (void *pc_target, struct frame_state *state_in)\n \n   memset (&state, 0, sizeof (state));\n   state.s.retaddr_column = info.ra_regno;\n+  state.s.eh_ptr = info.eh_ptr;\n \n   /* First decode all the insns in the CIE.  */\n-  end = next_fde ((fde*) f->CIE_pointer);\n+  end = next_fde ((fde*) get_cie (f));\n   while (insn < end)\n     insn = execute_cfa_insn (insn, &state, &info, 0);\n \n@@ -590,11 +607,6 @@ __frame_state_for (void *pc_target, struct frame_state *state_in)\n       insn = decode_uleb128 (insn, &i);\n       insn += i;\n     }\n-  else if (strcmp (info.augmentation, \"e\") == 0)\n-    {\n-      state.s.eh_ptr = read_pointer (insn);\n-      insn += sizeof (void *);\n-    }\n \n   /* Then the insns in the FDE up to our target PC.  */\n   end = next_fde (f);"}]}