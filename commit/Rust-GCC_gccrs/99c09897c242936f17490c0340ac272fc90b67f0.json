{"sha": "99c09897c242936f17490c0340ac272fc90b67f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTljMDk4OTdjMjQyOTM2ZjE3NDkwYzAzNDBhYzI3MmZjOTBiNjdmMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-09-19T09:02:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-09-19T09:02:23Z"}, "message": "tree-flow.h (merge_alias_info): Declare.\n\n        * tree-flow.h (merge_alias_info): Declare.\n        * tree-ssa-copy.c (merge_alias_info): Export.\n        * tree-vect-transform.c (vect_create_index_for_vector_ref): Remove.\n        (vect_create_data_ref_ptr): Use create_iv directly.\n        (vectorizable_load): Use correct types for integer constants.\n        (vect_generate_tmps_on_preheader): Likewise.\n        (vect_gen_niters_for_prolog_loop): Likewise.\n\nFrom-SVN: r104418", "tree": {"sha": "db3402f5e04f2e7db9f2e2948eba825bee448002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db3402f5e04f2e7db9f2e2948eba825bee448002"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99c09897c242936f17490c0340ac272fc90b67f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c09897c242936f17490c0340ac272fc90b67f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c09897c242936f17490c0340ac272fc90b67f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c09897c242936f17490c0340ac272fc90b67f0/comments", "author": null, "committer": null, "parents": [{"sha": "31c304baef95db414d5429ede8767f469a253945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c304baef95db414d5429ede8767f469a253945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c304baef95db414d5429ede8767f469a253945"}], "stats": {"total": 173, "additions": 55, "deletions": 118}, "files": [{"sha": "242cda2f3d16181c1e5327957b08f60c1a6b49cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99c09897c242936f17490c0340ac272fc90b67f0", "patch": "@@ -1,3 +1,13 @@\n+2005-09-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-flow.h (merge_alias_info): Declare.\n+\t* tree-ssa-copy.c (merge_alias_info): Export.\n+\t* tree-vect-transform.c (vect_create_index_for_vector_ref): Remove.\n+\t(vect_create_data_ref_ptr): Use create_iv directly.\n+\t(vectorizable_load): Use correct types for integer constants.\n+\t(vect_generate_tmps_on_preheader): Likewise.\n+\t(vect_gen_niters_for_prolog_loop): Likewise.\n+\n 2005-09-19  Steven Bosscher  <stevenb@suse.de>\n \n \tPR rtl-optimization/23943"}, {"sha": "40a9b540c4e613aff8069aea5a28085fa7b7fe9d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=99c09897c242936f17490c0340ac272fc90b67f0", "patch": "@@ -669,6 +669,7 @@ extern void debug_dominator_optimization_stats (void);\n int loop_depth_of_name (tree);\n \n /* In tree-ssa-copy.c  */\n+extern void merge_alias_info (tree, tree);\n extern void propagate_value (use_operand_p, tree);\n extern void propagate_tree_value (tree *, tree);\n extern void replace_exp (use_operand_p, tree);"}, {"sha": "47ac55f3b5fad14f347c6c560be12905c8fd2933", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=99c09897c242936f17490c0340ac272fc90b67f0", "patch": "@@ -165,7 +165,7 @@ may_propagate_copy_into_asm (tree dest)\n    propagating NEW into ORIG, consolidate aliasing information so that\n    they both share the same memory tags.  */\n \n-static void\n+void\n merge_alias_info (tree orig, tree new)\n {\n   tree new_sym = SSA_NAME_VAR (new);"}, {"sha": "bbac6fed52ed52ee52e7df0135ca6193c9492a18", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 43, "deletions": 117, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c09897c242936f17490c0340ac272fc90b67f0/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=99c09897c242936f17490c0340ac272fc90b67f0", "patch": "@@ -51,7 +51,6 @@ static void vect_align_data_ref (tree);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n   (tree, block_stmt_iterator *, tree, tree *, bool); \n-static tree vect_create_index_for_vector_ref (loop_vec_info);\n static tree vect_create_addr_base_for_vector_ref (tree, tree *, tree);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree, tree *);\n@@ -113,58 +112,6 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n }\n \n \n-/* Function vect_create_index_for_vector_ref.\n-\n-   Create (and return) an index variable, along with it's update chain in the\n-   loop. This variable will be used to access a memory location in a vector\n-   operation.\n-\n-   Input:\n-   LOOP: The loop being vectorized.\n-   BSI: The block_stmt_iterator where STMT is. Any new stmts created by this\n-        function can be added here, or in the loop pre-header.\n-\n-   Output:\n-   Return an index that will be used to index a vector array.  It is expected\n-   that a pointer to the first vector will be used as the base address for the\n-   indexed reference.\n-\n-   FORNOW: we are not trying to be efficient, just creating a new index each\n-   time from scratch.  At this time all vector references could use the same\n-   index.\n-\n-   TODO: create only one index to be used by all vector references.  Record\n-   the index in the LOOP_VINFO the first time this procedure is called and\n-   return it on subsequent calls.  The increment of this index must be placed\n-   just before the conditional expression that ends the single block loop.  */\n-\n-static tree\n-vect_create_index_for_vector_ref (loop_vec_info loop_vinfo)\n-{\n-  tree init, step;\n-  block_stmt_iterator incr_bsi;\n-  bool insert_after;\n-  tree indx_before_incr, indx_after_incr;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree incr;\n-\n-  /* It is assumed that the base pointer used for vectorized access contains\n-     the address of the first vector.  Therefore the index used for vectorized\n-     access must be initialized to zero and incremented by 1.  */\n-\n-  init = integer_zero_node;\n-  step = integer_one_node;\n-\n-  standard_iv_increment_position (loop, &incr_bsi, &insert_after);\n-  create_iv (init, step, NULL_TREE, loop, &incr_bsi, insert_after,\n-\t&indx_before_incr, &indx_after_incr);\n-  incr = bsi_stmt (incr_bsi);\n-  set_stmt_info ((tree_ann_t)stmt_ann (incr), new_stmt_vec_info (incr, loop_vinfo));\n-\n-  return indx_before_incr;\n-}\n-\n-\n /* Function vect_create_addr_base_for_vector_ref.\n \n    Create an expression that computes the address of the first memory location\n@@ -292,24 +239,17 @@ vect_align_data_ref (tree stmt)\n \n       Return the initial_address in INITIAL_ADDRESS.\n \n-   2. Create a data-reference in the loop based on the new vector pointer vp,\n-      and using a new index variable 'idx' as follows:\n-\n-      vp' = vp + update\n-\n-      where if ONLY_INIT is true:\n-         update = zero\n-      and otherwise\n-         update = idx + vector_type_size\n-\n-      Return the pointer vp'.\n-\n+   2. If ONLY_INIT is true, return the initial pointer.  Otherwise, create\n+      a data-reference in the loop based on the new vector pointer vp.  This\n+      new data reference will by some means be updated each iteration of\n+      the loop.  Return the pointer vp'.\n \n    FORNOW: handle only aligned and consecutive accesses.  */\n \n static tree\n-vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n-                          tree *initial_address, bool only_init)\n+vect_create_data_ref_ptr (tree stmt,\n+\t\t\t  block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n+\t\t\t  tree offset, tree *initial_address, bool only_init)\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -322,14 +262,9 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tree new_temp;\n   tree vec_stmt;\n   tree new_stmt_list = NULL_TREE;\n-  tree idx;\n   edge pe = loop_preheader_edge (loop);\n   basic_block new_bb;\n   tree vect_ptr_init;\n-  tree vectype_size;\n-  tree ptr_update;\n-  tree data_ref_ptr;\n-  tree type, tmp, size;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n \n   base_name =  build_fold_indirect_ref (unshare_expr (DR_BASE_ADDRESS (dr)));\n@@ -387,11 +322,10 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   /* Create: p = (vectype *) initial_base  */\n   vec_stmt = fold_convert (vect_ptr_type, new_temp);\n   vec_stmt = build2 (MODIFY_EXPR, void_type_node, vect_ptr, vec_stmt);\n-  new_temp = make_ssa_name (vect_ptr, vec_stmt);\n-  TREE_OPERAND (vec_stmt, 0) = new_temp;\n+  vect_ptr_init = make_ssa_name (vect_ptr, vec_stmt);\n+  TREE_OPERAND (vec_stmt, 0) = vect_ptr_init;\n   new_bb = bsi_insert_on_edge_immediate (pe, vec_stmt);\n   gcc_assert (!new_bb);\n-  vect_ptr_init = TREE_OPERAND (vec_stmt, 0);\n \n \n   /** (4) Handle the updating of the vector-pointer inside the loop: **/\n@@ -403,40 +337,33 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n         duplicate_ssa_name_ptr_info (vect_ptr_init, DR_PTR_INFO (dr));\n       return vect_ptr_init;\n     }\n+  else\n+    {\n+      block_stmt_iterator incr_bsi;\n+      bool insert_after;\n+      tree indx_before_incr, indx_after_incr;\n+      tree incr;\n+\n+      standard_iv_increment_position (loop, &incr_bsi, &insert_after);\n+      create_iv (vect_ptr_init,\n+\t\t fold_convert (vect_ptr_type, TYPE_SIZE_UNIT (vectype)),\n+\t\t NULL_TREE, loop, &incr_bsi, insert_after,\n+\t\t &indx_before_incr, &indx_after_incr);\n+      incr = bsi_stmt (incr_bsi);\n+      set_stmt_info ((tree_ann_t)stmt_ann (incr),\n+\t\t     new_stmt_vec_info (incr, loop_vinfo));\n \n-  idx = vect_create_index_for_vector_ref (loop_vinfo);\n-\n-  /* Create: update = idx * vectype_size  */\n-  tmp = create_tmp_var (integer_type_node, \"update\");\n-  add_referenced_tmp_var (tmp);\n-  size = TYPE_SIZE (vect_ptr_type); \n-  type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n-  ptr_update = create_tmp_var (type, \"update\");\n-  add_referenced_tmp_var (ptr_update);\n-  vectype_size = TYPE_SIZE_UNIT (vectype);\n-  vec_stmt = build2 (MULT_EXPR, integer_type_node, idx, vectype_size);\n-  vec_stmt = build2 (MODIFY_EXPR, void_type_node, tmp, vec_stmt);\n-  new_temp = make_ssa_name (tmp, vec_stmt);\n-  TREE_OPERAND (vec_stmt, 0) = new_temp;\n-  bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n-  vec_stmt = fold_convert (type, new_temp);\n-  vec_stmt = build2 (MODIFY_EXPR, void_type_node, ptr_update, vec_stmt);\n-  new_temp = make_ssa_name (ptr_update, vec_stmt);\n-  TREE_OPERAND (vec_stmt, 0) = new_temp;\n-  bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n-\n-  /* Create: data_ref_ptr = vect_ptr_init + update  */\n-  vec_stmt = build2 (PLUS_EXPR, vect_ptr_type, vect_ptr_init, new_temp);\n-  vec_stmt = build2 (MODIFY_EXPR, void_type_node, vect_ptr, vec_stmt);\n-  new_temp = make_ssa_name (vect_ptr, vec_stmt);\n-  TREE_OPERAND (vec_stmt, 0) = new_temp;\n-  bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n-  data_ref_ptr = TREE_OPERAND (vec_stmt, 0);\n+      /* Copy the points-to information if it exists. */\n+      if (DR_PTR_INFO (dr))\n+\t{\n+\t  duplicate_ssa_name_ptr_info (indx_before_incr, DR_PTR_INFO (dr));\n+\t  duplicate_ssa_name_ptr_info (indx_after_incr, DR_PTR_INFO (dr));\n+\t}\n+      merge_alias_info (vect_ptr_init, indx_before_incr);\n+      merge_alias_info (vect_ptr_init, indx_after_incr);\n \n-  /* Copy the points-to information if it exists. */\n-  if (DR_PTR_INFO (dr))\n-    duplicate_ssa_name_ptr_info (data_ref_ptr, DR_PTR_INFO (dr));\n-  return data_ref_ptr;\n+      return indx_before_incr;\n+    }\n }\n \n \n@@ -1822,9 +1749,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n \n       /* <2> Create lsq = *(floor(p2')) in the loop  */ \n-      offset = build_int_cst (integer_type_node, \n-\t\t\t      TYPE_VECTOR_SUBPARTS (vectype));\n-      offset = int_const_binop (MINUS_EXPR, offset, integer_one_node, 1);\n+      offset = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       dataref_ptr = vect_create_data_ref_ptr (stmt, bsi, offset, &dummy, false);\n       data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n@@ -2231,14 +2156,15 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree ni = LOOP_VINFO_NITERS (loop_vinfo);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  tree log_vf = build_int_cst (unsigned_type_node, exact_log2 (vf));\n+  tree log_vf;\n \n   pe = loop_preheader_edge (loop);\n \n   /* Generate temporary variable that contains \n      number of iterations loop executes.  */\n \n   ni_name = vect_build_loop_niters (loop_vinfo);\n+  log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));\n \n   /* Create: ratio = ni >> log2(vf) */\n \n@@ -2572,7 +2498,6 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n-  tree vf_minus_1 = build_int_cst (unsigned_type_node, vf - 1);\n   tree niters_type = TREE_TYPE (loop_niters);\n \n   pe = loop_preheader_edge (loop); \n@@ -2597,8 +2522,9 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n       tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n       tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);\n       tree elem_size_log =\n-        build_int_cst (unsigned_type_node, exact_log2 (vectype_align/vf));\n-      tree vf_tree = build_int_cst (unsigned_type_node, vf);\n+        build_int_cst (type, exact_log2 (vectype_align/vf));\n+      tree vf_minus_1 = build_int_cst (type, vf - 1);\n+      tree vf_tree = build_int_cst (type, vf);\n       tree byte_misalign;\n       tree elem_misalign;\n \n@@ -2611,11 +2537,11 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   \n       /* Create:  elem_misalign = byte_misalign / element_size  */\n       elem_misalign =\n-        build2 (RSHIFT_EXPR, unsigned_type_node, byte_misalign, elem_size_log);\n+        build2 (RSHIFT_EXPR, type, byte_misalign, elem_size_log);\n \n       /* Create:  (niters_type) (VF - elem_misalign)&(VF - 1)  */\n-      iters = build2 (MINUS_EXPR, unsigned_type_node, vf_tree, elem_misalign);\n-      iters = build2 (BIT_AND_EXPR, unsigned_type_node, iters, vf_minus_1);\n+      iters = build2 (MINUS_EXPR, type, vf_tree, elem_misalign);\n+      iters = build2 (BIT_AND_EXPR, type, iters, vf_minus_1);\n       iters = fold_convert (niters_type, iters);\n     }\n "}]}