{"sha": "b544c348e13ad33d55f0d954370ab1fb0f2bf683", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0NGMzNDhlMTNhZDMzZDU1ZjBkOTU0MzcwYWIxZmIwZjJiZjY4Mw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-01T21:44:51Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-01T21:44:51Z"}, "message": "input.c: move file caching globals to a new file_cache class\n\nThis moves some global state from input.c to a new file_cache class,\nof which an instance is owned by global_dc.  Various state is also\nmade private.\n\nNo functional change intended.\n\ngcc/ChangeLog:\n\t* diagnostic.h (diagnostic_context::m_file_cache): New field.\n\t* input.c (class fcache): Rename to...\n\t(class file_cache_slot): ...this, making most members private and\n\tprefixing fields with \"m_\".\n\t(file_cache_slot::get_file_path): New accessor.\n\t(file_cache_slot::get_use_count): New accessor.\n\t(file_cache_slot::missing_trailing_newline_p): New accessor.\n\t(file_cache_slot::inc_use_count): New.\n\t(fcache_buffer_size): Move to...\n\t(file_cache_slot::buffer_size): ...here.\n\t(fcache_line_record_size): Move to...\n\t(file_cache_slot::line_record_size): ...here.\n\t(fcache_tab): Delete, in favor of global_dc->m_file_cache.\n\t(fcache_tab_size): Move to file_cache::num_file_slots.\n\t(diagnostic_file_cache_init): Update for move of fcache_tab\n\tto global_dc->m_file_cache.\n\t(diagnostic_file_cache_fini): Likewise.\n\t(lookup_file_in_cache_tab): Convert to...\n\t(file_cache::lookup_file): ...this.\n\t(diagnostics_file_cache_forcibly_evict_file): Update for move of\n\tfcache_tab to global_dc->m_file_cache, moving most of\n\timplementation to...\n\t(file_cache::forcibly_evict_file): ...this new function and...\n\t(file_cache_slot::evict): ...this new function.\n\t(evicted_cache_tab_entry): Convert to...\n\t(file_cache::evicted_cache_tab_entry): ...this.\n\t(add_file_to_cache_tab): Convert to...\n\t(file_cache::add_file): ...this, moving bulk of implementation\n\tto...\n\t(file_cache_slot::create): ..this new function.\n\t(file_cache::file_cache): New.\n\t(file_cache::~file_cache): New.\n\t(lookup_or_add_file_to_cache_tab): Convert to...\n\t(file_cache::lookup_or_add_file): ..this new function.\n\t(fcache::fcache): Rename to...\n\t(file_cache_slot::file_cache_slot): ...this, adding \"m_\" prefixes\n\tto fields.\n\t(fcache::~fcache): Rename to...\n\t(file_cache_slot::~file_cache_slot): ...this, adding \"m_\" prefixes\n\tto fields.\n\t(needs_read): Convert to...\n\t(file_cache_slot::needs_read_p): ...this.\n\t(needs_grow): Convert to...\n\t(file_cache_slot::needs_grow_p): ...this.\n\t(maybe_grow): Convert to...\n\t(file_cache_slot::maybe_grow): ...this.\n\t(read_data): Convert to...\n\t(file_cache_slot::read_data): ...this.\n\t(maybe_read_data): Convert to...\n\t(file_cache_slot::maybe_read_data): ...this.\n\t(get_next_line): Convert to...\n\t(file_cache_slot::get_next_line): ...this.\n\t(goto_next_line): Convert to...\n\t(file_cache_slot::goto_next_line): ...this.\n\t(read_line_num): Convert to...\n\t(file_cache_slot::read_line_num): ...this.\n\t(location_get_source_line): Update for moving of globals to\n\tglobal_dc->m_file_cache.\n\t(location_missing_trailing_newline): Likewise.\n\t* input.h (class file_cache_slot): New forward decl.\n\t(class file_cache): New.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "3a30b3a50f0c137816db64cb1f07a171a63278d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a30b3a50f0c137816db64cb1f07a171a63278d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b544c348e13ad33d55f0d954370ab1fb0f2bf683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b544c348e13ad33d55f0d954370ab1fb0f2bf683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b544c348e13ad33d55f0d954370ab1fb0f2bf683", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b544c348e13ad33d55f0d954370ab1fb0f2bf683/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b735b70b03884052c80ac032df90eed7059f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b735b70b03884052c80ac032df90eed7059f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b735b70b03884052c80ac032df90eed7059f8d"}], "stats": {"total": 495, "additions": 301, "deletions": 194}, "files": [{"sha": "086bc4f903fd74b5c46b55441d7b484ed4ac27b6", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b544c348e13ad33d55f0d954370ab1fb0f2bf683/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b544c348e13ad33d55f0d954370ab1fb0f2bf683/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=b544c348e13ad33d55f0d954370ab1fb0f2bf683", "patch": "@@ -136,6 +136,9 @@ struct diagnostic_context\n   /* Where most of the diagnostic formatting work is done.  */\n   pretty_printer *printer;\n \n+  /* Cache of source code.  */\n+  file_cache *m_file_cache;\n+\n   /* The number of times we have issued diagnostics.  */\n   int diagnostic_count[DK_LAST_DIAGNOSTIC_KIND];\n "}, {"sha": "de20d983d2c4f7d2f4f86522ba8db44ca019789c", "filename": "gcc/input.c", "status": "modified", "additions": 265, "deletions": 194, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b544c348e13ad33d55f0d954370ab1fb0f2bf683/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b544c348e13ad33d55f0d954370ab1fb0f2bf683/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=b544c348e13ad33d55f0d954370ab1fb0f2bf683", "patch": "@@ -32,9 +32,29 @@ along with GCC; see the file COPYING3.  If not see\n \n /* This is a cache used by get_next_line to store the content of a\n    file to be searched for file lines.  */\n-class fcache\n+class file_cache_slot\n {\n public:\n+  file_cache_slot ();\n+  ~file_cache_slot ();\n+\n+  bool read_line_num (size_t line_num,\n+\t\t      char ** line, ssize_t *line_len);\n+\n+  /* Accessors.  */\n+  const char *get_file_path () const { return m_file_path; }\n+  unsigned get_use_count () const { return m_use_count; }\n+  bool missing_trailing_newline_p () const\n+  {\n+    return m_missing_trailing_newline;\n+  }\n+\n+  void inc_use_count () { m_use_count++; }\n+\n+  void create (const char *file_path, FILE *fp, unsigned highest_use_count);\n+  void evict ();\n+\n+ private:\n   /* These are information used to store a line boundary.  */\n   class line_info\n   {\n@@ -61,36 +81,48 @@ class fcache\n     {}\n   };\n \n+  bool needs_read_p () const;\n+  bool needs_grow_p () const;\n+  void maybe_grow ();\n+  bool read_data ();\n+  bool maybe_read_data ();\n+  bool get_next_line (char **line, ssize_t *line_len);\n+  bool read_next_line (char ** line, ssize_t *line_len);\n+  bool goto_next_line ();\n+\n+  static const size_t buffer_size = 4 * 1024;\n+  static const size_t line_record_size = 100;\n+\n   /* The number of time this file has been accessed.  This is used\n      to designate which file cache to evict from the cache\n      array.  */\n-  unsigned use_count;\n+  unsigned m_use_count;\n \n   /* The file_path is the key for identifying a particular file in\n      the cache.\n      For libcpp-using code, the underlying buffer for this field is\n      owned by the corresponding _cpp_file within the cpp_reader.  */\n-  const char *file_path;\n+  const char *m_file_path;\n \n-  FILE *fp;\n+  FILE *m_fp;\n \n   /* This points to the content of the file that we've read so\n      far.  */\n-  char *data;\n+  char *m_data;\n \n   /*  The size of the DATA array above.*/\n-  size_t size;\n+  size_t m_size;\n \n   /* The number of bytes read from the underlying file so far.  This\n      must be less (or equal) than SIZE above.  */\n-  size_t nb_read;\n+  size_t m_nb_read;\n \n   /* The index of the beginning of the current line.  */\n-  size_t line_start_idx;\n+  size_t m_line_start_idx;\n \n   /* The number of the previous line read.  This starts at 1.  Zero\n      means we've read no line so far.  */\n-  size_t line_num;\n+  size_t m_line_num;\n \n   /* This is the total number of lines of the current file.  At the\n      moment, we try to get this information from the line map\n@@ -100,24 +132,21 @@ class fcache\n      the number of lines before compilation really starts.  For e.g,\n      the C front-end, it can happen that we start emitting diagnostics\n      before the line map has seen the end of the file.  */\n-  size_t total_lines;\n+  size_t m_total_lines;\n \n   /* Could this file be missing a trailing newline on its final line?\n      Initially true (to cope with empty files), set to true/false\n      as each line is read.  */\n-  bool missing_trailing_newline;\n+  bool m_missing_trailing_newline;\n \n   /* This is a record of the beginning and end of the lines we've seen\n      while reading the file.  This is useful to avoid walking the data\n      from the beginning when we are asked to read a line that is\n      before LINE_START_IDX above.  Note that the maximum size of this\n-     record is fcache_line_record_size, so that the memory consumption\n+     record is line_record_size, so that the memory consumption\n      doesn't explode.  We thus scale total_lines down to\n-     fcache_line_record_size.  */\n-  vec<line_info, va_heap> line_record;\n-\n-  fcache ();\n-  ~fcache ();\n+     line_record_size.  */\n+  vec<line_info, va_heap> m_line_record;\n };\n \n /* Current position in real source file.  */\n@@ -133,11 +162,6 @@ class line_maps *line_table;\n \n class line_maps *saved_line_table;\n \n-static fcache *fcache_tab;\n-static const size_t fcache_tab_size = 16;\n-static const size_t fcache_buffer_size = 4 * 1024;\n-static const size_t fcache_line_record_size = 100;\n-\n /* Expand the source location LOC into a human readable location.  If\n    LOC resolves to a builtin location, the file name of the readable\n    location is set to the string \"<built-in>\". If EXPANSION_POINT_P is\n@@ -233,8 +257,9 @@ expand_location_1 (location_t loc,\n static void\n diagnostic_file_cache_init (void)\n {\n-  if (fcache_tab == NULL)\n-    fcache_tab = new fcache[fcache_tab_size];\n+  gcc_assert (global_dc);\n+  if (global_dc->m_file_cache == NULL)\n+    global_dc->m_file_cache = new file_cache ();\n }\n \n /* Free the resources used by the set of cache used for files accessed\n@@ -243,10 +268,10 @@ diagnostic_file_cache_init (void)\n void\n diagnostic_file_cache_fini (void)\n {\n-  if (fcache_tab)\n+  if (global_dc->m_file_cache)\n     {\n-      delete [] (fcache_tab);\n-      fcache_tab = NULL;\n+      delete global_dc->m_file_cache;\n+      global_dc->m_file_cache = NULL;\n     }\n }\n \n@@ -273,28 +298,25 @@ total_lines_num (const char *file_path)\n    caret diagnostic.  Return the found cached file, or NULL if no\n    cached file was found.  */\n \n-static fcache*\n-lookup_file_in_cache_tab (const char *file_path)\n+file_cache_slot *\n+file_cache::lookup_file (const char *file_path)\n {\n-  if (file_path == NULL)\n-    return NULL;\n-\n-  diagnostic_file_cache_init ();\n+  gcc_assert (file_path);\n \n   /* This will contain the found cached file.  */\n-  fcache *r = NULL;\n-  for (unsigned i = 0; i < fcache_tab_size; ++i)\n+  file_cache_slot *r = NULL;\n+  for (unsigned i = 0; i < num_file_slots; ++i)\n     {\n-      fcache *c = &fcache_tab[i];\n-      if (c->file_path && !strcmp (c->file_path, file_path))\n+      file_cache_slot *c = &m_file_slots[i];\n+      if (c->get_file_path () && !strcmp (c->get_file_path (), file_path))\n \t{\n-\t  ++c->use_count;\n+\t  c->inc_use_count ();\n \t  r = c;\n \t}\n     }\n \n   if (r)\n-    ++r->use_count;\n+    r->inc_use_count ();\n \n   return r;\n }\n@@ -308,49 +330,66 @@ diagnostics_file_cache_forcibly_evict_file (const char *file_path)\n {\n   gcc_assert (file_path);\n \n-  fcache *r = lookup_file_in_cache_tab (file_path);\n+  if (!global_dc->m_file_cache)\n+    return;\n+\n+  global_dc->m_file_cache->forcibly_evict_file (file_path);\n+}\n+\n+void\n+file_cache::forcibly_evict_file (const char *file_path)\n+{\n+  gcc_assert (file_path);\n+\n+  file_cache_slot *r = lookup_file (file_path);\n   if (!r)\n     /* Not found.  */\n     return;\n \n-  r->file_path = NULL;\n-  if (r->fp)\n-    fclose (r->fp);\n-  r->fp = NULL;\n-  r->nb_read = 0;\n-  r->line_start_idx = 0;\n-  r->line_num = 0;\n-  r->line_record.truncate (0);\n-  r->use_count = 0;\n-  r->total_lines = 0;\n-  r->missing_trailing_newline = true;\n+  r->evict ();\n+}\n+\n+void\n+file_cache_slot::evict ()\n+{\n+  m_file_path = NULL;\n+  if (m_fp)\n+    fclose (m_fp);\n+  m_fp = NULL;\n+  m_nb_read = 0;\n+  m_line_start_idx = 0;\n+  m_line_num = 0;\n+  m_line_record.truncate (0);\n+  m_use_count = 0;\n+  m_total_lines = 0;\n+  m_missing_trailing_newline = true;\n }\n \n /* Return the file cache that has been less used, recently, or the\n    first empty one.  If HIGHEST_USE_COUNT is non-null,\n    *HIGHEST_USE_COUNT is set to the highest use count of the entries\n    in the cache table.  */\n \n-static fcache*\n-evicted_cache_tab_entry (unsigned *highest_use_count)\n+file_cache_slot*\n+file_cache::evicted_cache_tab_entry (unsigned *highest_use_count)\n {\n   diagnostic_file_cache_init ();\n \n-  fcache *to_evict = &fcache_tab[0];\n-  unsigned huc = to_evict->use_count;\n-  for (unsigned i = 1; i < fcache_tab_size; ++i)\n+  file_cache_slot *to_evict = &m_file_slots[0];\n+  unsigned huc = to_evict->get_use_count ();\n+  for (unsigned i = 1; i < num_file_slots; ++i)\n     {\n-      fcache *c = &fcache_tab[i];\n-      bool c_is_empty = (c->file_path == NULL);\n+      file_cache_slot *c = &m_file_slots[i];\n+      bool c_is_empty = (c->get_file_path () == NULL);\n \n-      if (c->use_count < to_evict->use_count\n-\t  || (to_evict->file_path && c_is_empty))\n+      if (c->get_use_count () < to_evict->get_use_count ()\n+\t  || (to_evict->get_file_path () && c_is_empty))\n \t/* We evict C because it's either an entry with a lower use\n \t   count or one that is empty.  */\n \tto_evict = c;\n \n-      if (huc < c->use_count)\n-\thuc = c->use_count;\n+      if (huc < c->get_use_count ())\n+\thuc = c->get_use_count ();\n \n       if (c_is_empty)\n \t/* We've reached the end of the cache; subsequent elements are\n@@ -368,144 +407,167 @@ evicted_cache_tab_entry (unsigned *highest_use_count)\n    accessed by caret diagnostic.  This cache is added to an array of\n    cache and can be retrieved by lookup_file_in_cache_tab.  This\n    function returns the created cache.  Note that only the last\n-   fcache_tab_size files are cached.  */\n+   num_file_slots files are cached.  */\n \n-static fcache*\n-add_file_to_cache_tab (const char *file_path)\n+file_cache_slot*\n+file_cache::add_file (const char *file_path)\n {\n \n   FILE *fp = fopen (file_path, \"r\");\n   if (fp == NULL)\n     return NULL;\n \n   unsigned highest_use_count = 0;\n-  fcache *r = evicted_cache_tab_entry (&highest_use_count);\n-  r->file_path = file_path;\n-  if (r->fp)\n-    fclose (r->fp);\n-  r->fp = fp;\n-  r->nb_read = 0;\n-  r->line_start_idx = 0;\n-  r->line_num = 0;\n-  r->line_record.truncate (0);\n+  file_cache_slot *r = evicted_cache_tab_entry (&highest_use_count);\n+  r->create (file_path, fp, highest_use_count);\n+  return r;\n+}\n+\n+/* Populate this slot for use on FILE_PATH and FP, dropping any\n+   existing cached content within it.  */\n+\n+void\n+file_cache_slot::create (const char *file_path, FILE *fp,\n+\t\t\t unsigned highest_use_count)\n+{\n+  m_file_path = file_path;\n+  if (m_fp)\n+    fclose (m_fp);\n+  m_fp = fp;\n+  m_nb_read = 0;\n+  m_line_start_idx = 0;\n+  m_line_num = 0;\n+  m_line_record.truncate (0);\n   /* Ensure that this cache entry doesn't get evicted next time\n      add_file_to_cache_tab is called.  */\n-  r->use_count = ++highest_use_count;\n-  r->total_lines = total_lines_num (file_path);\n-  r->missing_trailing_newline = true;\n+  m_use_count = ++highest_use_count;\n+  m_total_lines = total_lines_num (file_path);\n+  m_missing_trailing_newline = true;\n+}\n \n-  return r;\n+/* file_cache's ctor.  */\n+\n+file_cache::file_cache ()\n+: m_file_slots (new file_cache_slot[num_file_slots])\n+{\n+}\n+\n+/* file_cache's dtor.  */\n+\n+file_cache::~file_cache ()\n+{\n+  delete[] m_file_slots;\n }\n \n /* Lookup the cache used for the content of a given file accessed by\n    caret diagnostic.  If no cached file was found, create a new cache\n    for this file, add it to the array of cached file and return\n    it.  */\n \n-static fcache*\n-lookup_or_add_file_to_cache_tab (const char *file_path)\n+file_cache_slot*\n+file_cache::lookup_or_add_file (const char *file_path)\n {\n-  fcache *r = lookup_file_in_cache_tab (file_path);\n+  file_cache_slot *r = lookup_file (file_path);\n   if (r == NULL)\n-    r = add_file_to_cache_tab (file_path);\n+    r = add_file (file_path);\n   return r;\n }\n \n /* Default constructor for a cache of file used by caret\n    diagnostic.  */\n \n-fcache::fcache ()\n-: use_count (0), file_path (NULL), fp (NULL), data (0),\n-  size (0), nb_read (0), line_start_idx (0), line_num (0),\n-  total_lines (0), missing_trailing_newline (true)\n+file_cache_slot::file_cache_slot ()\n+: m_use_count (0), m_file_path (NULL), m_fp (NULL), m_data (0),\n+  m_size (0), m_nb_read (0), m_line_start_idx (0), m_line_num (0),\n+  m_total_lines (0), m_missing_trailing_newline (true)\n {\n-  line_record.create (0);\n+  m_line_record.create (0);\n }\n \n /* Destructor for a cache of file used by caret diagnostic.  */\n \n-fcache::~fcache ()\n+file_cache_slot::~file_cache_slot ()\n {\n-  if (fp)\n+  if (m_fp)\n     {\n-      fclose (fp);\n-      fp = NULL;\n+      fclose (m_fp);\n+      m_fp = NULL;\n     }\n-  if (data)\n+  if (m_data)\n     {\n-      XDELETEVEC (data);\n-      data = 0;\n+      XDELETEVEC (m_data);\n+      m_data = 0;\n     }\n-  line_record.release ();\n+  m_line_record.release ();\n }\n \n /* Returns TRUE iff the cache would need to be filled with data coming\n    from the file.  That is, either the cache is empty or full or the\n    current line is empty.  Note that if the cache is full, it would\n    need to be extended and filled again.  */\n \n-static bool\n-needs_read (fcache *c)\n+bool\n+file_cache_slot::needs_read_p () const\n {\n-  return (c->nb_read == 0\n-\t  || c->nb_read == c->size\n-\t  || (c->line_start_idx >= c->nb_read - 1));\n+  return (m_nb_read == 0\n+\t  || m_nb_read == m_size\n+\t  || (m_line_start_idx >= m_nb_read - 1));\n }\n \n /*  Return TRUE iff the cache is full and thus needs to be\n     extended.  */\n \n-static bool\n-needs_grow (fcache *c)\n+bool\n+file_cache_slot::needs_grow_p () const\n {\n-  return c->nb_read == c->size;\n+  return m_nb_read == m_size;\n }\n \n /* Grow the cache if it needs to be extended.  */\n \n-static void\n-maybe_grow (fcache *c)\n+void\n+file_cache_slot::maybe_grow ()\n {\n-  if (!needs_grow (c))\n+  if (!needs_grow_p ())\n     return;\n \n-  size_t size = c->size == 0 ? fcache_buffer_size : c->size * 2;\n-  c->data = XRESIZEVEC (char, c->data, size);\n-  c->size = size;\n+  size_t size = m_size == 0 ? buffer_size : m_size * 2;\n+  m_data = XRESIZEVEC (char, m_data, size);\n+  m_size = size;\n }\n \n /*  Read more data into the cache.  Extends the cache if need be.\n     Returns TRUE iff new data could be read.  */\n \n-static bool\n-read_data (fcache *c)\n+bool\n+file_cache_slot::read_data ()\n {\n-  if (feof (c->fp) || ferror (c->fp))\n+  if (feof (m_fp) || ferror (m_fp))\n     return false;\n \n-  maybe_grow (c);\n+  maybe_grow ();\n \n-  char * from = c->data + c->nb_read;\n-  size_t to_read = c->size - c->nb_read;\n-  size_t nb_read = fread (from, 1, to_read, c->fp);\n+  char * from = m_data + m_nb_read;\n+  size_t to_read = m_size - m_nb_read;\n+  size_t nb_read = fread (from, 1, to_read, m_fp);\n \n-  if (ferror (c->fp))\n+  if (ferror (m_fp))\n     return false;\n \n-  c->nb_read += nb_read;\n+  m_nb_read += nb_read;\n   return !!nb_read;\n }\n \n /* Read new data iff the cache needs to be filled with more data\n    coming from the file FP.  Return TRUE iff the cache was filled with\n    mode data.  */\n \n-static bool\n-maybe_read_data (fcache *c)\n+bool\n+file_cache_slot::maybe_read_data ()\n {\n-  if (!needs_read (c))\n+  if (!needs_read_p ())\n     return false;\n-  return read_data (c);\n+  return read_data ();\n }\n \n /* Read a new line from file FP, using C as a cache for the data\n@@ -518,18 +580,18 @@ maybe_read_data (fcache *c)\n    otherwise.  Note that subsequent calls to get_next_line might\n    make the content of *LINE invalid.  */\n \n-static bool\n-get_next_line (fcache *c, char **line, ssize_t *line_len)\n+bool\n+file_cache_slot::get_next_line (char **line, ssize_t *line_len)\n {\n   /* Fill the cache with data to process.  */\n-  maybe_read_data (c);\n+  maybe_read_data ();\n \n-  size_t remaining_size = c->nb_read - c->line_start_idx;\n+  size_t remaining_size = m_nb_read - m_line_start_idx;\n   if (remaining_size == 0)\n     /* There is no more data to process.  */\n     return false;\n \n-  char *line_start = c->data + c->line_start_idx;\n+  char *line_start = m_data + m_line_start_idx;\n \n   char *next_line_start = NULL;\n   size_t len = 0;\n@@ -539,10 +601,10 @@ get_next_line (fcache *c, char **line, ssize_t *line_len)\n       /* We haven't found the end-of-line delimiter in the cache.\n \t Fill the cache with more data from the file and look for the\n \t '\\n'.  */\n-      while (maybe_read_data (c))\n+      while (maybe_read_data ())\n \t{\n-\t  line_start = c->data + c->line_start_idx;\n-\t  remaining_size = c->nb_read - c->line_start_idx;\n+\t  line_start = m_data + m_line_start_idx;\n+\t  remaining_size = m_nb_read - m_line_start_idx;\n \t  line_end = (char *) memchr (line_start, '\\n', remaining_size);\n \t  if (line_end != NULL)\n \t    {\n@@ -558,19 +620,19 @@ get_next_line (fcache *c, char **line, ssize_t *line_len)\n \t     of when the line ends up with a '\\n' and line_end points to\n \t     that terminal '\\n'.  That consistency is useful below in\n \t     the len calculation.  */\n-\t  line_end = c->data + c->nb_read ;\n-\t  c->missing_trailing_newline = true;\n+\t  line_end = m_data + m_nb_read ;\n+\t  m_missing_trailing_newline = true;\n \t}\n       else\n-\tc->missing_trailing_newline = false;\n+\tm_missing_trailing_newline = false;\n     }\n   else\n     {\n       next_line_start = line_end + 1;\n-      c->missing_trailing_newline = false;\n+      m_missing_trailing_newline = false;\n     }\n \n-  if (ferror (c->fp))\n+  if (ferror (m_fp))\n     return false;\n \n   /* At this point, we've found the end of the of line.  It either\n@@ -580,54 +642,56 @@ get_next_line (fcache *c, char **line, ssize_t *line_len)\n \n   len = line_end - line_start;\n \n-  if (c->line_start_idx < c->nb_read)\n+  if (m_line_start_idx < m_nb_read)\n     *line = line_start;\n \n-  ++c->line_num;\n+  ++m_line_num;\n \n   /* Before we update our line record, make sure the hint about the\n      total number of lines of the file is correct.  If it's not, then\n      we give up recording line boundaries from now on.  */\n   bool update_line_record = true;\n-  if (c->line_num > c->total_lines)\n+  if (m_line_num > m_total_lines)\n     update_line_record = false;\n \n     /* Now update our line record so that re-reading lines from the\n-     before c->line_start_idx is faster.  */\n+     before m_line_start_idx is faster.  */\n   if (update_line_record\n-      && c->line_record.length () < fcache_line_record_size)\n+      && m_line_record.length () < line_record_size)\n     {\n       /* If the file lines fits in the line record, we just record all\n \t its lines ...*/\n-      if (c->total_lines <= fcache_line_record_size\n-\t  && c->line_num > c->line_record.length ())\n-\tc->line_record.safe_push (fcache::line_info (c->line_num,\n-\t\t\t\t\t\t c->line_start_idx,\n-\t\t\t\t\t\t line_end - c->data));\n-      else if (c->total_lines > fcache_line_record_size)\n+      if (m_total_lines <= line_record_size\n+\t  && m_line_num > m_line_record.length ())\n+\tm_line_record.safe_push\n+\t  (file_cache_slot::line_info (m_line_num,\n+\t\t\t\t       m_line_start_idx,\n+\t\t\t\t       line_end - m_data));\n+      else if (m_total_lines > line_record_size)\n \t{\n \t  /* ... otherwise, we just scale total_lines down to\n-\t     (fcache_line_record_size lines.  */\n-\t  size_t n = (c->line_num * fcache_line_record_size) / c->total_lines;\n-\t  if (c->line_record.length () == 0\n-\t      || n >= c->line_record.length ())\n-\t    c->line_record.safe_push (fcache::line_info (c->line_num,\n-\t\t\t\t\t\t     c->line_start_idx,\n-\t\t\t\t\t\t     line_end - c->data));\n+\t     (line_record_size lines.  */\n+\t  size_t n = (m_line_num * line_record_size) / m_total_lines;\n+\t  if (m_line_record.length () == 0\n+\t      || n >= m_line_record.length ())\n+\t    m_line_record.safe_push\n+\t      (file_cache_slot::line_info (m_line_num,\n+\t\t\t\t\t   m_line_start_idx,\n+\t\t\t\t\t   line_end - m_data));\n \t}\n     }\n \n-  /* Update c->line_start_idx so that it points to the next line to be\n+  /* Update m_line_start_idx so that it points to the next line to be\n      read.  */\n   if (next_line_start)\n-    c->line_start_idx = next_line_start - c->data;\n+    m_line_start_idx = next_line_start - m_data;\n   else\n     /* We didn't find any terminal '\\n'.  Let's consider that the end\n        of line is the end of the data in the cache.  The next\n        invocation of get_next_line will either read more data from the\n        underlying file or return false early because we've reached the\n        end of the file.  */\n-    c->line_start_idx = c->nb_read;\n+    m_line_start_idx = m_nb_read;\n \n   *line_len = len;\n \n@@ -640,13 +704,13 @@ get_next_line (fcache *c, char **line, ssize_t *line_len)\n    copying from the cache involved.  Return TRUE upon successful\n    completion.  */\n \n-static bool\n-goto_next_line (fcache *cache)\n+bool\n+file_cache_slot::goto_next_line ()\n {\n   char *l;\n   ssize_t len;\n \n-  return get_next_line (cache, &l, &len);\n+  return get_next_line (&l, &len);\n }\n \n /* Read an arbitrary line number LINE_NUM from the file cached in C.\n@@ -656,88 +720,88 @@ goto_next_line (fcache *cache)\n    *LINE is only valid until the next call of read_line_num.\n    This function returns bool if a line was read.  */\n \n-static bool\n-read_line_num (fcache *c, size_t line_num,\n-\t       char **line, ssize_t *line_len)\n+bool\n+file_cache_slot::read_line_num (size_t line_num,\n+\t\t       char ** line, ssize_t *line_len)\n {\n   gcc_assert (line_num > 0);\n \n-  if (line_num <= c->line_num)\n+  if (line_num <= m_line_num)\n     {\n-      /* We've been asked to read lines that are before c->line_num.\n+      /* We've been asked to read lines that are before m_line_num.\n \t So lets use our line record (if it's not empty) to try to\n \t avoid re-reading the file from the beginning again.  */\n \n-      if (c->line_record.is_empty ())\n+      if (m_line_record.is_empty ())\n \t{\n-\t  c->line_start_idx = 0;\n-\t  c->line_num = 0;\n+\t  m_line_start_idx = 0;\n+\t  m_line_num = 0;\n \t}\n       else\n \t{\n-\t  fcache::line_info *i = NULL;\n-\t  if (c->total_lines <= fcache_line_record_size)\n+\t  file_cache_slot::line_info *i = NULL;\n+\t  if (m_total_lines <= line_record_size)\n \t    {\n \t      /* In languages where the input file is not totally\n-\t\t preprocessed up front, the c->total_lines hint\n+\t\t preprocessed up front, the m_total_lines hint\n \t\t can be smaller than the number of lines of the\n \t\t file.  In that case, only the first\n-\t\t c->total_lines have been recorded.\n+\t\t m_total_lines have been recorded.\n \n-\t\t Otherwise, the first c->total_lines we've read have\n+\t\t Otherwise, the first m_total_lines we've read have\n \t\t their start/end recorded here.  */\n-\t      i = (line_num <= c->total_lines)\n-\t\t? &c->line_record[line_num - 1]\n-\t\t: &c->line_record[c->total_lines - 1];\n+\t      i = (line_num <= m_total_lines)\n+\t\t? &m_line_record[line_num - 1]\n+\t\t: &m_line_record[m_total_lines - 1];\n \t      gcc_assert (i->line_num <= line_num);\n \t    }\n \t  else\n \t    {\n \t      /*  So the file had more lines than our line record\n \t\t  size.  Thus the number of lines we've recorded has\n-\t\t  been scaled down to fcache_line_reacord_size.  Let's\n+\t\t  been scaled down to line_record_size.  Let's\n \t\t  pick the start/end of the recorded line that is\n \t\t  closest to line_num.  */\n-\t      size_t n = (line_num <= c->total_lines)\n-\t\t? line_num * fcache_line_record_size / c->total_lines\n-\t\t: c ->line_record.length () - 1;\n-\t      if (n < c->line_record.length ())\n+\t      size_t n = (line_num <= m_total_lines)\n+\t\t? line_num * line_record_size / m_total_lines\n+\t\t: m_line_record.length () - 1;\n+\t      if (n < m_line_record.length ())\n \t\t{\n-\t\t  i = &c->line_record[n];\n+\t\t  i = &m_line_record[n];\n \t\t  gcc_assert (i->line_num <= line_num);\n \t\t}\n \t    }\n \n \t  if (i && i->line_num == line_num)\n \t    {\n \t      /* We have the start/end of the line.  */\n-\t      *line = c->data + i->start_pos;\n+\t      *line = m_data + i->start_pos;\n \t      *line_len = i->end_pos - i->start_pos;\n \t      return true;\n \t    }\n \n \t  if (i)\n \t    {\n-\t      c->line_start_idx = i->start_pos;\n-\t      c->line_num = i->line_num - 1;\n+\t      m_line_start_idx = i->start_pos;\n+\t      m_line_num = i->line_num - 1;\n \t    }\n \t  else\n \t    {\n-\t      c->line_start_idx = 0;\n-\t      c->line_num = 0;\n+\t      m_line_start_idx = 0;\n+\t      m_line_num = 0;\n \t    }\n \t}\n     }\n \n-  /*  Let's walk from line c->line_num up to line_num - 1, without\n+  /*  Let's walk from line m_line_num up to line_num - 1, without\n       copying any line.  */\n-  while (c->line_num < line_num - 1)\n-    if (!goto_next_line (c))\n+  while (m_line_num < line_num - 1)\n+    if (!goto_next_line ())\n       return false;\n \n   /* The line we want is the next one.  Let's read and copy it back to\n      the caller.  */\n-  return get_next_line (c, line, line_len);\n+  return get_next_line (line, line_len);\n }\n \n /* Return the physical source line that corresponds to FILE_PATH/LINE.\n@@ -756,11 +820,16 @@ location_get_source_line (const char *file_path, int line)\n   if (line == 0)\n     return char_span (NULL, 0);\n \n-  fcache *c = lookup_or_add_file_to_cache_tab (file_path);\n+  if (file_path == NULL)\n+    return char_span (NULL, 0);\n+\n+  diagnostic_file_cache_init ();\n+\n+  file_cache_slot *c = global_dc->m_file_cache->lookup_or_add_file (file_path);\n   if (c == NULL)\n     return char_span (NULL, 0);\n \n-  bool read = read_line_num (c, line, &buffer, &len);\n+  bool read = c->read_line_num (line, &buffer, &len);\n   if (!read)\n     return char_span (NULL, 0);\n \n@@ -774,11 +843,13 @@ location_get_source_line (const char *file_path, int line)\n bool\n location_missing_trailing_newline (const char *file_path)\n {\n-  fcache *c = lookup_or_add_file_to_cache_tab (file_path);\n+  diagnostic_file_cache_init ();\n+\n+  file_cache_slot *c = global_dc->m_file_cache->lookup_or_add_file (file_path);\n   if (c == NULL)\n     return false;\n \n-  return c->missing_trailing_newline;\n+  return c->missing_trailing_newline_p ();\n }\n \n /* Test if the location originates from the spelling location of a"}, {"sha": "bbcec84c521d50f73eace0a03d14af337072aa8b", "filename": "gcc/input.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b544c348e13ad33d55f0d954370ab1fb0f2bf683/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b544c348e13ad33d55f0d954370ab1fb0f2bf683/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=b544c348e13ad33d55f0d954370ab1fb0f2bf683", "patch": "@@ -88,6 +88,39 @@ class char_span\n extern char_span location_get_source_line (const char *file_path, int line);\n \n extern bool location_missing_trailing_newline (const char *file_path);\n+\n+/* Forward decl of slot within file_cache, so that the definition doesn't\n+   need to be in this header.  */\n+class file_cache_slot;\n+\n+/* A cache of source files for use when emitting diagnostics\n+   (and in a few places in the C/C++ frontends).\n+\n+   Results are only valid until the next call to the cache, as\n+   slots can be evicted.\n+\n+   Filenames are stored by pointer, and so must outlive the cache\n+   instance.  */\n+\n+class file_cache\n+{\n+ public:\n+  file_cache ();\n+  ~file_cache ();\n+\n+  file_cache_slot *lookup_or_add_file (const char *file_path);\n+  void forcibly_evict_file (const char *file_path);\n+\n+ private:\n+  file_cache_slot *evicted_cache_tab_entry (unsigned *highest_use_count);\n+  file_cache_slot *add_file (const char *file_path);\n+  file_cache_slot *lookup_file (const char *file_path);\n+\n+ private:\n+  static const size_t num_file_slots = 16;\n+  file_cache_slot *m_file_slots;\n+};\n+\n extern expanded_location\n expand_location_to_spelling_point (location_t,\n \t\t\t\t   enum location_aspect aspect"}]}