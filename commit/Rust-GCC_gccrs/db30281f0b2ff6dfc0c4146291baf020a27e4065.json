{"sha": "db30281f0b2ff6dfc0c4146291baf020a27e4065", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzMDI4MWYwYjJmZjZkZmMwYzQxNDYyOTFiYWYwMjBhMjdlNDA2NQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-02-18T08:21:23Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-02-18T08:21:23Z"}, "message": "Come up with fast {function,call}_summary classes (PR ipa/89306).\n\n2019-02-18  Martin Liska  <mliska@suse.cz>\n\n\tPR ipa/89306\n\t* cgraph.c (symbol_table::create_edge): Set m_summary_id to -1\n\tby default.\n\t(symbol_table::free_edge): Recycle m_summary_id.\n\t* cgraph.h (get_summary_id): New.\n\t(symbol_table::release_symbol): Set m_summary_id to -1\n\tby default.\n\t(symbol_table::allocate_cgraph_symbol): Recycle m_summary_id.\n\t* ipa-fnsummary.c (ipa_fn_summary_t): Switch from\n\tfunction_summary to fast_function_summary.\n\t* ipa-fnsummary.h (ipa_fn_summary_t): Likewise.\n\t* ipa-pure-const.c (class funct_state_summary_t):\n\tSwitch from function_summary to fast_function_summary.\n\t* ipa-reference.c (class ipa_ref_var_info_summary_t): Likewise.\n\t(class ipa_ref_opt_summary_t): Switch from function_summary\n\tto fast_function_summary.\n\t* symbol-summary.h (class function_summary_base): New class\n\tthat is created from base of former function_summary.\n\t(function_summary_base::unregister_hooks): New.\n\t(class function_summary): Inherit from function_summary_base.\n\t(class call_summary_base): New class\n\tthat is created from base of former call_summary.\n\t(class call_summary): Inherit from call_summary_base.\n\t(struct is_same): New.\n\t(class fast_function_summary): New summary class.\n\t(class fast_call_summary): New summary class.\n\t* vec.h (vec_safe_grow_cleared): New function.\n\nFrom-SVN: r268979", "tree": {"sha": "419ecfa282d86cfaa3d74625e4883e4a619573c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/419ecfa282d86cfaa3d74625e4883e4a619573c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db30281f0b2ff6dfc0c4146291baf020a27e4065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db30281f0b2ff6dfc0c4146291baf020a27e4065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db30281f0b2ff6dfc0c4146291baf020a27e4065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db30281f0b2ff6dfc0c4146291baf020a27e4065/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e8cecccc2e5abb5d753291892968bf72533a7045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8cecccc2e5abb5d753291892968bf72533a7045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8cecccc2e5abb5d753291892968bf72533a7045"}], "stats": {"total": 976, "additions": 765, "deletions": 211}, "files": [{"sha": "9370f013f07fd02780c88026389a51fe7a37e37c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -1,3 +1,33 @@\n+2019-02-18  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/89306\n+\t* cgraph.c (symbol_table::create_edge): Set m_summary_id to -1\n+\tby default.\n+\t(symbol_table::free_edge): Recycle m_summary_id.\n+\t* cgraph.h (get_summary_id): New.\n+\t(symbol_table::release_symbol): Set m_summary_id to -1\n+\tby default.\n+\t(symbol_table::allocate_cgraph_symbol): Recycle m_summary_id.\n+\t* ipa-fnsummary.c (ipa_fn_summary_t): Switch from\n+\tfunction_summary to fast_function_summary.\n+\t* ipa-fnsummary.h (ipa_fn_summary_t): Likewise.\n+\t* ipa-pure-const.c (class funct_state_summary_t):\n+\tSwitch from function_summary to fast_function_summary.\n+\t* ipa-reference.c (class ipa_ref_var_info_summary_t): Likewise.\n+\t(class ipa_ref_opt_summary_t): Switch from function_summary\n+\tto fast_function_summary.\n+\t* symbol-summary.h (class function_summary_base): New class\n+\tthat is created from base of former function_summary.\n+\t(function_summary_base::unregister_hooks): New.\n+\t(class function_summary): Inherit from function_summary_base.\n+\t(class call_summary_base): New class\n+\tthat is created from base of former call_summary.\n+\t(class call_summary): Inherit from call_summary_base.\n+\t(struct is_same): New.\n+\t(class fast_function_summary): New summary class.\n+\t(class fast_call_summary): New summary class.\n+\t* vec.h (vec_safe_grow_cleared): New function.\n+\n 2019-02-18  Martin Liska  <mliska@suse.cz>\n \n \t* config/i386/i386.c (ix86_get_multilib_abi_name): New function."}, {"sha": "de82316d4b1957e713763c32f4eb8d099bac67e9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -852,7 +852,10 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n       free_edges = NEXT_FREE_EDGE (edge);\n     }\n   else\n-    edge = ggc_alloc<cgraph_edge> ();\n+    {\n+      edge = ggc_alloc<cgraph_edge> ();\n+      edge->m_summary_id = -1;\n+    }\n \n   edges_count++;\n \n@@ -1014,7 +1017,9 @@ symbol_table::free_edge (cgraph_edge *e)\n     ggc_free (e->indirect_info);\n \n   /* Clear out the edge so we do not dangle pointers.  */\n+  int summary_id = e->m_summary_id;\n   memset (e, 0, sizeof (*e));\n+  e->m_summary_id = summary_id;\n   NEXT_FREE_EDGE (e) = free_edges;\n   free_edges = e;\n   edges_count--;"}, {"sha": "c294602d7624b4f6aa9f1bec2eb44b736a667d2c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -1302,6 +1302,12 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n     return m_uid;\n   }\n \n+  /* Get summary id of the node.  */\n+  inline int get_summary_id ()\n+  {\n+    return m_summary_id;\n+  }\n+\n   /* Record that DECL1 and DECL2 are semantically identical function\n      versions.  */\n   static void record_function_versions (tree decl1, tree decl2);\n@@ -1470,6 +1476,9 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* Unique id of the node.  */\n   int m_uid;\n \n+  /* Summary id that is recycled.  */\n+  int m_summary_id;\n+\n   /* Worker for call_for_symbol_and_aliases.  */\n   bool call_for_symbol_and_aliases_1 (bool (*callback) (cgraph_node *,\n \t\t\t\t\t\t        void *),\n@@ -1728,6 +1737,12 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n     return m_uid;\n   }\n \n+  /* Get summary id of the edge.  */\n+  inline int get_summary_id ()\n+  {\n+    return m_summary_id;\n+  }\n+\n   /* Rebuild cgraph edges for current function node.  This needs to be run after\n      passes that don't update the cgraph.  */\n   static unsigned int rebuild_edges (void);\n@@ -1805,6 +1820,9 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Unique id of the edge.  */\n   int m_uid;\n \n+  /* Summary id that is recycled.  */\n+  int m_summary_id;\n+\n   /* Remove the edge from the list of the callers of the callee.  */\n   void remove_caller (void);\n \n@@ -2051,7 +2069,8 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   friend class cgraph_node;\n   friend class cgraph_edge;\n \n-  symbol_table (): cgraph_max_uid (1), edges_max_uid (1)\n+  symbol_table (): cgraph_max_uid (1), cgraph_max_summary_id (0),\n+  edges_max_uid (1), edges_max_summary_id (0)\n   {\n   }\n \n@@ -2254,15 +2273,31 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Dump symbol table to stderr.  */\n   void DEBUG_FUNCTION debug (void);\n \n+  /* Assign a new summary ID for the callgraph NODE.  */\n+  inline int assign_summary_id (cgraph_node *node)\n+  {\n+    node->m_summary_id = cgraph_max_summary_id++;\n+    return node->m_summary_id;\n+  }\n+\n+  /* Assign a new summary ID for the callgraph EDGE.  */\n+  inline int assign_summary_id (cgraph_edge *edge)\n+  {\n+    edge->m_summary_id = edges_max_summary_id++;\n+    return edge->m_summary_id;\n+  }\n+\n   /* Return true if assembler names NAME1 and NAME2 leads to the same symbol\n      name.  */\n   static bool assembler_names_equal_p (const char *name1, const char *name2);\n \n   int cgraph_count;\n   int cgraph_max_uid;\n+  int cgraph_max_summary_id;\n \n   int edges_count;\n   int edges_max_uid;\n+  int edges_max_summary_id;\n \n   symtab_node* GTY(()) nodes;\n   asm_node* GTY(()) asmnodes;\n@@ -2634,8 +2669,10 @@ symbol_table::release_symbol (cgraph_node *node)\n \n   /* Clear out the node to NULL all pointers and add the node to the free\n      list.  */\n+  int summary_id = node->m_summary_id;\n   memset (node, 0, sizeof (*node));\n   node->type = SYMTAB_FUNCTION;\n+  node->m_summary_id = summary_id;\n   SET_NEXT_FREE_NODE (node, free_nodes);\n   free_nodes = node;\n }\n@@ -2653,7 +2690,10 @@ symbol_table::allocate_cgraph_symbol (void)\n       free_nodes = NEXT_FREE_NODE (node);\n     }\n   else\n-    node = ggc_cleared_alloc<cgraph_node> ();\n+    {\n+      node = ggc_cleared_alloc<cgraph_node> ();\n+      node->m_summary_id = -1;\n+    }\n \n   node->m_uid = cgraph_max_uid++;\n   return node;"}, {"sha": "160261d34c9e665c60d6218c3de61fc83f74b0c5", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -85,8 +85,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n \n /* Summaries.  */\n-function_summary <ipa_fn_summary *> *ipa_fn_summaries;\n-call_summary <ipa_call_summary *> *ipa_call_summaries;\n+fast_function_summary <ipa_fn_summary *, va_gc> *ipa_fn_summaries;\n+fast_call_summary <ipa_call_summary *, va_heap> *ipa_call_summaries;\n \n /* Edge predicates goes here.  */\n static object_allocator<predicate> edge_predicate_pool (\"edge predicates\");\n@@ -532,7 +532,7 @@ ipa_fn_summary_alloc (void)\n {\n   gcc_checking_assert (!ipa_fn_summaries);\n   ipa_fn_summaries = ipa_fn_summary_t::create_ggc (symtab);\n-  ipa_call_summaries = new ipa_call_summary_t (symtab, false);\n+  ipa_call_summaries = new ipa_call_summary_t (symtab);\n }\n \n ipa_call_summary::~ipa_call_summary ()"}, {"sha": "0f08e84ed535c95256c75a638611c82a82280e25", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -173,16 +173,17 @@ struct GTY(()) ipa_fn_summary\n   static const int size_scale = 2;\n };\n \n-class GTY((user)) ipa_fn_summary_t: public function_summary <ipa_fn_summary *>\n+class GTY((user)) ipa_fn_summary_t:\n+  public fast_function_summary <ipa_fn_summary *, va_gc>\n {\n public:\n-  ipa_fn_summary_t (symbol_table *symtab, bool ggc):\n-    function_summary <ipa_fn_summary *> (symtab, ggc) {}\n+  ipa_fn_summary_t (symbol_table *symtab):\n+    fast_function_summary <ipa_fn_summary *, va_gc> (symtab) {}\n \n   static ipa_fn_summary_t *create_ggc (symbol_table *symtab)\n   {\n     struct ipa_fn_summary_t *summary = new (ggc_alloc <ipa_fn_summary_t> ())\n-      ipa_fn_summary_t(symtab, true);\n+      ipa_fn_summary_t (symtab);\n     summary->disable_insertion_hook ();\n     return summary;\n   }\n@@ -200,7 +201,8 @@ class GTY((user)) ipa_fn_summary_t: public function_summary <ipa_fn_summary *>\n \t\t\t  ipa_fn_summary *src_data, ipa_fn_summary *dst_data);\n };\n \n-extern GTY(()) function_summary <ipa_fn_summary *> *ipa_fn_summaries;\n+extern GTY(()) fast_function_summary <ipa_fn_summary *, va_gc>\n+  *ipa_fn_summaries;\n \n /* Information kept about callgraph edges.  */\n struct ipa_call_summary\n@@ -236,19 +238,19 @@ struct ipa_call_summary\n   bool is_return_callee_uncaptured;\n };\n \n-class ipa_call_summary_t: public call_summary <ipa_call_summary *>\n+class ipa_call_summary_t: public fast_call_summary <ipa_call_summary *, va_heap>\n {\n public:\n-  ipa_call_summary_t (symbol_table *symtab, bool ggc):\n-    call_summary <ipa_call_summary *> (symtab, ggc) {}\n+  ipa_call_summary_t (symbol_table *symtab):\n+    fast_call_summary <ipa_call_summary *, va_heap> (symtab) {}\n \n   /* Hook that is called by summary when an edge is duplicated.  */\n   virtual void duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t\t\t  ipa_call_summary *src_data,\n \t\t\t  ipa_call_summary *dst_data);\n };\n \n-extern call_summary <ipa_call_summary *> *ipa_call_summaries;\n+extern fast_call_summary <ipa_call_summary *, va_heap> *ipa_call_summaries;\n \n /* In ipa-fnsummary.c  */\n void ipa_debug_fn_summary (struct cgraph_node *);"}, {"sha": "bb561d00853f5d148d37b5cecd30a5f2e8db38ef", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -128,11 +128,12 @@ typedef struct funct_state_d * funct_state;\n    possibility that it may be desirable to move this to the cgraph\n    local info.  */\n \n-class funct_state_summary_t: public function_summary <funct_state_d *>\n+class funct_state_summary_t:\n+  public fast_function_summary <funct_state_d *, va_heap>\n {\n public:\n   funct_state_summary_t (symbol_table *symtab):\n-    function_summary <funct_state_d *> (symtab) {}\n+    fast_function_summary <funct_state_d *, va_heap> (symtab) {}\n \n   virtual void insert (cgraph_node *, funct_state_d *state);\n   virtual void duplicate (cgraph_node *src_node, cgraph_node *dst_node,"}, {"sha": "9ef03c2505bfccde8138806c8660843ea4e4fa84", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -110,23 +110,22 @@ static bitmap_obstack local_info_obstack;\n /* Obstack holding global analysis live forever.  */\n static bitmap_obstack optimization_summary_obstack;\n \n-class ipa_ref_var_info_summary_t: public function_summary\n-\t\t\t  <ipa_reference_vars_info_d *>\n+class ipa_ref_var_info_summary_t: public fast_function_summary\n+\t\t\t  <ipa_reference_vars_info_d *, va_heap>\n {\n public:\n   ipa_ref_var_info_summary_t (symbol_table *symtab):\n-    function_summary <ipa_reference_vars_info_d *> (symtab) {}\n+    fast_function_summary <ipa_reference_vars_info_d *, va_heap> (symtab) {}\n };\n \n static ipa_ref_var_info_summary_t *ipa_ref_var_info_summaries = NULL;\n \n-class ipa_ref_opt_summary_t: public function_summary\n-\t\t\t     <ipa_reference_optimization_summary_d *>\n+class ipa_ref_opt_summary_t: public fast_function_summary\n+\t\t\t     <ipa_reference_optimization_summary_d *, va_heap>\n {\n public:\n   ipa_ref_opt_summary_t (symbol_table *symtab):\n-    function_summary <ipa_reference_optimization_summary_d *> (symtab) {}\n-\n+    fast_function_summary <ipa_reference_optimization_summary_d *, va_heap> (symtab) {}\n \n   virtual void remove (cgraph_node *src_node,\n \t\t       ipa_reference_optimization_summary_d *data);"}, {"sha": "0219f3a81eac56bea237b10f4ed8effe5fe0653b", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 653, "deletions": 187, "changes": 840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -21,6 +21,90 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_SYMBOL_SUMMARY_H\n #define GCC_SYMBOL_SUMMARY_H\n \n+/* Base class for function_summary and fast_function_summary classes.  */\n+\n+template <class T>\n+class function_summary_base\n+{\n+public:\n+  /* Default construction takes SYMTAB as an argument.  */\n+  function_summary_base (symbol_table *symtab): m_symtab (symtab),\n+  m_insertion_enabled (true), m_released (false)\n+  {}\n+\n+  /* Basic implementation of insert operation.  */\n+  virtual void insert (cgraph_node *, T *) {}\n+\n+  /* Basic implementation of removal operation.  */\n+  virtual void remove (cgraph_node *, T *) {}\n+\n+  /* Basic implementation of duplication operation.  */\n+  virtual void duplicate (cgraph_node *, cgraph_node *, T *, T *) {}\n+\n+  /* Enable insertion hook invocation.  */\n+  void enable_insertion_hook ()\n+  {\n+    m_insertion_enabled = true;\n+  }\n+\n+  /* Enable insertion hook invocation.  */\n+  void disable_insertion_hook ()\n+  {\n+    m_insertion_enabled = false;\n+  }\n+\n+protected:\n+  /* Allocates new data that are stored within map.  */\n+  T* allocate_new ()\n+  {\n+    /* Call gcc_internal_because we do not want to call finalizer for\n+       a type T.  We call dtor explicitly.  */\n+    return is_ggc () ? new (ggc_internal_alloc (sizeof (T))) T () : new T () ;\n+  }\n+\n+  /* Release an item that is stored within map.  */\n+  void release (T *item)\n+  {\n+    if (is_ggc ())\n+      {\n+\titem->~T ();\n+\tggc_free (item);\n+      }\n+    else\n+      delete item;\n+  }\n+\n+  /* Unregister all call-graph hooks.  */\n+  void unregister_hooks ();\n+\n+  /* Internal summary insertion hook pointer.  */\n+  cgraph_node_hook_list *m_symtab_insertion_hook;\n+  /* Internal summary removal hook pointer.  */\n+  cgraph_node_hook_list *m_symtab_removal_hook;\n+  /* Internal summary duplication hook pointer.  */\n+  cgraph_2node_hook_list *m_symtab_duplication_hook;\n+  /* Symbol table the summary is registered to.  */\n+  symbol_table *m_symtab;\n+\n+  /* Indicates if insertion hook is enabled.  */\n+  bool m_insertion_enabled;\n+  /* Indicates if the summary is released.  */\n+  bool m_released;\n+\n+private:\n+  /* Return true when the summary uses GGC memory for allocation.  */\n+  virtual bool is_ggc () = 0;\n+};\n+\n+template <typename T>\n+void\n+function_summary_base<T>::unregister_hooks ()\n+{\n+  m_symtab->remove_cgraph_insertion_hook (m_symtab_insertion_hook);\n+  m_symtab->remove_cgraph_removal_hook (m_symtab_removal_hook);\n+  m_symtab->remove_cgraph_duplication_hook (m_symtab_duplication_hook);\n+}\n+\n /* We want to pass just pointer types as argument for function_summary\n    template class.  */\n \n@@ -43,7 +127,7 @@ class function_summary\n    a memory gained by garbage collected memory.  */\n \n template <class T>\n-class GTY((user)) function_summary <T *>\n+class GTY((user)) function_summary <T *>: public function_summary_base<T>\n {\n public:\n   /* Default construction takes SYMTAB as an argument.  */\n@@ -55,7 +139,8 @@ class GTY((user)) function_summary <T *>\n     release ();\n   }\n \n-  /* Destruction method that can be called for GGT purpose.  */\n+  /* Destruction method that can be called for GGC purpose.  */\n+  using function_summary_base<T>::release;\n   void release ();\n \n   /* Traverses all summarys with a function F called with\n@@ -66,34 +151,14 @@ class GTY((user)) function_summary <T *>\n     m_map.traverse <f> (a);\n   }\n \n-  /* Basic implementation of insert operation.  */\n-  virtual void insert (cgraph_node *, T *) {}\n-\n-  /* Basic implementation of removal operation.  */\n-  virtual void remove (cgraph_node *, T *) {}\n-\n-  /* Basic implementation of duplication operation.  */\n-  virtual void duplicate (cgraph_node *, cgraph_node *, T *, T *) {}\n-\n-  /* Allocates new data that are stored within map.  */\n-  T* allocate_new ()\n-  {\n-    /* Call gcc_internal_because we do not want to call finalizer for\n-       a type T.  We call dtor explicitly.  */\n-    return m_ggc ? new (ggc_internal_alloc (sizeof (T))) T () : new T () ;\n-  }\n-\n-  /* Release an item that is stored within map.  */\n-  void release (T *item);\n-\n   /* Getter for summary callgraph node pointer.  If a summary for a node\n      does not exist it will be created.  */\n   T* get_create (cgraph_node *node)\n   {\n     bool existed;\n     T **v = &m_map.get_or_insert (node->get_uid (), &existed);\n     if (!existed)\n-      *v = allocate_new ();\n+      *v = this->allocate_new ();\n \n     return *v;\n   }\n@@ -106,41 +171,24 @@ class GTY((user)) function_summary <T *>\n   }\n \n   /* Remove node from summary.  */\n+  using function_summary_base<T>::remove;\n   void remove (cgraph_node *node)\n   {\n     int uid = node->get_uid ();\n     T **v = m_map.get (uid);\n     if (v)\n       {\n \tm_map.remove (uid);\n-\trelease (*v);\n+\tthis->release (*v);\n       }\n   }\n \n-  /* Return number of elements handled by data structure.  */\n-  size_t elements ()\n-  {\n-    return m_map.elements ();\n-  }\n-\n   /* Return true if a summary for the given NODE already exists.  */\n   bool exists (cgraph_node *node)\n   {\n     return m_map.get (node->get_uid ()) != NULL;\n   }\n \n-  /* Enable insertion hook invocation.  */\n-  void enable_insertion_hook ()\n-  {\n-    m_insertion_enabled = true;\n-  }\n-\n-  /* Enable insertion hook invocation.  */\n-  void disable_insertion_hook ()\n-  {\n-    m_insertion_enabled = false;\n-  }\n-\n   /* Symbol insertion hook that is registered to symbol table.  */\n   static void symtab_insertion (cgraph_node *node, void *data);\n \n@@ -156,22 +204,16 @@ class GTY((user)) function_summary <T *>\n   bool m_ggc;\n \n private:\n+  /* Indication if we use ggc summary.  */\n+  virtual bool is_ggc ()\n+  {\n+    return m_ggc;\n+  }\n+\n   typedef int_hash <int, 0, -1> map_hash;\n \n-  /* Indicates if insertion hook is enabled.  */\n-  bool m_insertion_enabled;\n-  /* Indicates if the summary is released.  */\n-  bool m_released;\n   /* Main summary store, where summary ID is used as key.  */\n   hash_map <map_hash, T *> m_map;\n-  /* Internal summary insertion hook pointer.  */\n-  cgraph_node_hook_list *m_symtab_insertion_hook;\n-  /* Internal summary removal hook pointer.  */\n-  cgraph_node_hook_list *m_symtab_removal_hook;\n-  /* Internal summary duplication hook pointer.  */\n-  cgraph_2node_hook_list *m_symtab_duplication_hook;\n-  /* Symbol table the summary is registered to.  */\n-  symbol_table *m_symtab;\n \n   template <typename U> friend void gt_ggc_mx (function_summary <U *> * const &);\n   template <typename U> friend void gt_pch_nx (function_summary <U *> * const &);\n@@ -181,50 +223,34 @@ class GTY((user)) function_summary <T *>\n \n template <typename T>\n function_summary<T *>::function_summary (symbol_table *symtab, bool ggc):\n-  m_ggc (ggc), m_insertion_enabled (true), m_released (false), m_map (13, ggc),\n-  m_symtab (symtab)\n+  function_summary_base<T> (symtab), m_ggc (ggc), m_map (13, ggc)\n {\n-  m_symtab_insertion_hook\n-    = symtab->add_cgraph_insertion_hook (function_summary::symtab_insertion,\n-\t\t\t\t\t this);\n-\n-  m_symtab_removal_hook\n-    = symtab->add_cgraph_removal_hook (function_summary::symtab_removal, this);\n-  m_symtab_duplication_hook\n-    = symtab->add_cgraph_duplication_hook (function_summary::symtab_duplication,\n-\t\t\t\t\t   this);\n+  this->m_symtab_insertion_hook\n+    = this->m_symtab->add_cgraph_insertion_hook (function_summary::symtab_insertion,\n+\t\t\t\t\t\t this);\n+  this->m_symtab_removal_hook\n+    = this->m_symtab->add_cgraph_removal_hook (function_summary::symtab_removal,\n+\t\t\t\t\t       this);\n+  this->m_symtab_duplication_hook\n+    = this->m_symtab->add_cgraph_duplication_hook (function_summary::symtab_duplication,\n+\t\t\t\t\t\t   this);\n }\n \n template <typename T>\n void\n function_summary<T *>::release ()\n {\n-  if (m_released)\n+  if (this->m_released)\n     return;\n \n-  m_symtab->remove_cgraph_insertion_hook (m_symtab_insertion_hook);\n-  m_symtab->remove_cgraph_removal_hook (m_symtab_removal_hook);\n-  m_symtab->remove_cgraph_duplication_hook (m_symtab_duplication_hook);\n+  this->unregister_hooks ();\n \n   /* Release all summaries.  */\n   typedef typename hash_map <map_hash, T *>::iterator map_iterator;\n   for (map_iterator it = m_map.begin (); it != m_map.end (); ++it)\n-    release ((*it).second);\n+    this->release ((*it).second);\n \n-  m_released = true;\n-}\n-\n-template <typename T>\n-void\n-function_summary<T *>::release (T *item)\n-{\n-  if (m_ggc)\n-    {\n-      item->~T ();\n-      ggc_free (item);\n-    }\n-  else\n-    delete item;\n+  this->m_released = true;\n }\n \n template <typename T>\n@@ -244,19 +270,7 @@ function_summary<T *>::symtab_removal (cgraph_node *node, void *data)\n {\n   gcc_checking_assert (node->get_uid ());\n   function_summary *summary = (function_summary <T *> *) (data);\n-\n-  int uid = node->get_uid ();\n-  T **v = summary->m_map.get (uid);\n-\n-  if (v)\n-    {\n-      summary->remove (node, *v);\n-\n-      if (!summary->m_ggc)\n-\tdelete (*v);\n-\n-      summary->m_map.remove (uid);\n-    }\n+  summary->remove (node);\n }\n \n template <typename T>\n@@ -268,12 +282,7 @@ function_summary<T *>::symtab_duplication (cgraph_node *node,\n   T *v = summary->get (node);\n \n   if (v)\n-    {\n-      /* This load is necessary, because we insert a new value!  */\n-      T *duplicate = summary->allocate_new ();\n-      summary->m_map.put (node2->get_uid (), duplicate);\n-      summary->duplicate (node, node2, v, duplicate);\n-    }\n+    summary->duplicate (node, node2, v, summary->get_create (node2));\n }\n \n template <typename T>\n@@ -301,68 +310,359 @@ gt_pch_nx(function_summary<T *>* const& summary, gt_pointer_operator op,\n   gt_pch_nx (&summary->m_map, op, cookie);\n }\n \n-/* An impossible class templated by non-pointers so, which makes sure that only\n-   summaries gathering pointers can be created.  */\n+/* Help template from std c++11.  */\n \n-template <class T>\n-class call_summary\n+template<typename T, typename U>\n+struct is_same\n+{\n+    static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T,T>  //specialization\n+{\n+   static const bool value = true;\n+};\n+\n+/* We want to pass just pointer types as argument for fast_function_summary\n+   template class.  */\n+\n+template <class T, class V>\n+class fast_function_summary\n {\n private:\n-  call_summary();\n+  fast_function_summary ();\n };\n \n-/* Class to store auxiliary information about call graph edges.  */\n+/* Function vector summary is a fast implementation of function_summary that\n+   utilizes vector as primary storage of summaries.  */\n \n-template <class T>\n-class GTY((user)) call_summary <T *>\n+template <class T, class V>\n+class GTY((user)) fast_function_summary <T *, V>\n+  : public function_summary_base<T>\n {\n public:\n   /* Default construction takes SYMTAB as an argument.  */\n-  call_summary (symbol_table *symtab, bool ggc = false): m_ggc (ggc),\n-    m_initialize_when_cloning (false), m_map (13, ggc), m_released (false),\n-    m_symtab (symtab)\n-  {\n-    m_symtab_removal_hook =\n-      symtab->add_edge_removal_hook\n-      (call_summary::symtab_removal, this);\n-    m_symtab_duplication_hook =\n-      symtab->add_edge_duplication_hook\n-      (call_summary::symtab_duplication, this);\n-  }\n+  fast_function_summary (symbol_table *symtab);\n \n   /* Destructor.  */\n-  virtual ~call_summary ()\n+  virtual ~fast_function_summary ()\n   {\n     release ();\n   }\n \n-  /* Destruction method that can be called for GGT purpose.  */\n+  /* Destruction method that can be called for GGC purpose.  */\n+  using function_summary_base<T>::release;\n   void release ();\n \n   /* Traverses all summarys with a function F called with\n      ARG as argument.  */\n   template<typename Arg, bool (*f)(const T &, Arg)>\n   void traverse (Arg a) const\n   {\n-    m_map.traverse <f> (a);\n+    for (unsigned i = 0; i < m_vector->length (); i++)\n+      if ((*m_vector[i]) != NULL)\n+\tf ((*m_vector)[i]);\n+  }\n+\n+  /* Getter for summary callgraph node pointer.  If a summary for a node\n+     does not exist it will be created.  */\n+  T* get_create (cgraph_node *node)\n+  {\n+    int id = node->get_summary_id ();\n+    if (id == -1)\n+      id = this->m_symtab->assign_summary_id (node);\n+\n+    if ((unsigned int)id >= m_vector->length ())\n+      vec_safe_grow_cleared (m_vector,\n+\t\t\t     this->m_symtab->cgraph_max_summary_id);\n+\n+    if ((*m_vector)[id] == NULL)\n+      (*m_vector)[id] = this->allocate_new ();\n+\n+    return (*m_vector)[id];\n+  }\n+\n+  /* Getter for summary callgraph node pointer.  */\n+  T* get (cgraph_node *node) ATTRIBUTE_PURE\n+  {\n+    return exists (node) ? (*m_vector)[node->get_summary_id ()] : NULL;\n   }\n \n+  using function_summary_base<T>::remove;\n+  void remove (cgraph_node *node)\n+  {\n+    if (exists (node))\n+      {\n+\tint id = node->get_summary_id ();\n+\tthis->release ((*m_vector)[id]);\n+\t(*m_vector)[id] = NULL;\n+      }\n+  }\n+\n+  /* Return true if a summary for the given NODE already exists.  */\n+  bool exists (cgraph_node *node)\n+  {\n+    int id = node->get_summary_id ();\n+    return (id != -1\n+\t    && (unsigned int)id < m_vector->length ()\n+\t    && (*m_vector)[id] != NULL);\n+  }\n+\n+  /* Symbol insertion hook that is registered to symbol table.  */\n+  static void symtab_insertion (cgraph_node *node, void *data);\n+\n+  /* Symbol removal hook that is registered to symbol table.  */\n+  static void symtab_removal (cgraph_node *node, void *data);\n+\n+  /* Symbol duplication hook that is registered to symbol table.  */\n+  static void symtab_duplication (cgraph_node *node, cgraph_node *node2,\n+\t\t\t\t  void *data);\n+\n+private:\n+  virtual bool is_ggc ();\n+\n+  /* Summary is stored in the vector.  */\n+  vec <T *, V> *m_vector;\n+\n+  template <typename U> friend void gt_ggc_mx (fast_function_summary <U *, va_gc> * const &);\n+  template <typename U> friend void gt_pch_nx (fast_function_summary <U *, va_gc> * const &);\n+  template <typename U> friend void gt_pch_nx (fast_function_summary <U *, va_gc> * const &,\n+      gt_pointer_operator, void *);\n+};\n+\n+template <typename T, typename V>\n+fast_function_summary<T *, V>::fast_function_summary (symbol_table *symtab):\n+  function_summary_base<T> (symtab), m_vector (NULL)\n+{\n+  vec_alloc (m_vector, 13);\n+  this->m_symtab_insertion_hook\n+    = this->m_symtab->add_cgraph_insertion_hook (fast_function_summary::symtab_insertion,\n+\t\t\t\t\t\t this);\n+  this->m_symtab_removal_hook\n+    = this->m_symtab->add_cgraph_removal_hook (fast_function_summary::symtab_removal,\n+\t\t\t\t\t       this);\n+  this->m_symtab_duplication_hook\n+    = this->m_symtab->add_cgraph_duplication_hook (fast_function_summary::symtab_duplication,\n+\t\t\t\t\t\t   this);\n+}\n+\n+template <typename T, typename V>\n+void\n+fast_function_summary<T *, V>::release ()\n+{\n+  if (this->m_released)\n+    return;\n+\n+  this->unregister_hooks ();\n+\n+  /* Release all summaries.  */\n+  for (unsigned i = 0; i < m_vector->length (); i++)\n+    if ((*m_vector)[i] != NULL)\n+      this->release ((*m_vector)[i]);\n+\n+  this->m_released = true;\n+}\n+\n+template <typename T, typename V>\n+void\n+fast_function_summary<T *, V>::symtab_insertion (cgraph_node *node, void *data)\n+{\n+  gcc_checking_assert (node->get_uid ());\n+  fast_function_summary *summary = (fast_function_summary <T *, V> *) (data);\n+\n+  if (summary->m_insertion_enabled)\n+    summary->insert (node, summary->get_create (node));\n+}\n+\n+template <typename T, typename V>\n+void\n+fast_function_summary<T *, V>::symtab_removal (cgraph_node *node, void *data)\n+{\n+  gcc_checking_assert (node->get_uid ());\n+  fast_function_summary *summary = (fast_function_summary <T *, V> *) (data);\n+\n+  if (summary->exists (node))\n+    summary->remove (node);\n+}\n+\n+template <typename T, typename V>\n+void\n+fast_function_summary<T *, V>::symtab_duplication (cgraph_node *node,\n+\t\t\t\t\t\t   cgraph_node *node2,\n+\t\t\t\t\t\t   void *data)\n+{\n+  fast_function_summary *summary = (fast_function_summary <T *, V> *) (data);\n+  T *v = summary->get (node);\n+\n+  if (v)\n+    {\n+      T *duplicate = summary->get_create (node2);\n+      summary->duplicate (node, node2, v, duplicate);\n+    }\n+}\n+\n+template <typename T, typename V>\n+inline bool\n+fast_function_summary<T *, V>::is_ggc ()\n+{\n+  return is_same<V, va_gc>::value;\n+}\n+\n+template <typename T>\n+void\n+gt_ggc_mx (fast_function_summary<T *, va_heap>* const &)\n+{\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_function_summary<T *, va_heap>* const &)\n+{\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_function_summary<T *, va_heap>* const&, gt_pointer_operator,\n+\t   void *)\n+{\n+}\n+\n+template <typename T>\n+void\n+gt_ggc_mx (fast_function_summary<T *, va_gc>* const &summary)\n+{\n+  ggc_test_and_set_mark (summary->m_vector);\n+  gt_ggc_mx (summary->m_vector);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_function_summary<T *, va_gc>* const &summary)\n+{\n+  gt_pch_nx (summary->m_vector);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_function_summary<T *, va_gc>* const& summary,\n+\t   gt_pointer_operator op,\n+\t   void *cookie)\n+{\n+  gt_pch_nx (summary->m_vector, op, cookie);\n+}\n+\n+/* Base class for call_summary and fast_call_summary classes.  */\n+\n+template <class T>\n+class call_summary_base\n+{\n+public:\n+  /* Default construction takes SYMTAB as an argument.  */\n+  call_summary_base (symbol_table *symtab): m_symtab (symtab),\n+  m_initialize_when_cloning (true), m_released (false)\n+  {}\n+\n   /* Basic implementation of removal operation.  */\n   virtual void remove (cgraph_edge *, T *) {}\n \n   /* Basic implementation of duplication operation.  */\n   virtual void duplicate (cgraph_edge *, cgraph_edge *, T *, T *) {}\n \n+protected:\n   /* Allocates new data that are stored within map.  */\n   T* allocate_new ()\n   {\n     /* Call gcc_internal_because we do not want to call finalizer for\n        a type T.  We call dtor explicitly.  */\n-    return m_ggc ? new (ggc_internal_alloc (sizeof (T))) T () : new T () ;\n+    return is_ggc () ? new (ggc_internal_alloc (sizeof (T))) T () : new T () ;\n   }\n \n   /* Release an item that is stored within map.  */\n-  void release (T *item);\n+  void release (T *item)\n+  {\n+    if (is_ggc ())\n+      {\n+\titem->~T ();\n+\tggc_free (item);\n+      }\n+    else\n+      delete item;\n+  }\n+\n+  /* Unregister all call-graph hooks.  */\n+  void unregister_hooks ();\n+\n+  /* Symbol table the summary is registered to.  */\n+  symbol_table *m_symtab;\n+\n+  /* Internal summary removal hook pointer.  */\n+  cgraph_edge_hook_list *m_symtab_removal_hook;\n+  /* Internal summary duplication hook pointer.  */\n+  cgraph_2edge_hook_list *m_symtab_duplication_hook;\n+  /* Initialize summary for an edge that is cloned.  */\n+  bool m_initialize_when_cloning;\n+  /* Indicates if the summary is released.  */\n+  bool m_released;\n+\n+private:\n+  /* Return true when the summary uses GGC memory for allocation.  */\n+  virtual bool is_ggc () = 0;\n+};\n+\n+template <typename T>\n+void\n+call_summary_base<T>::unregister_hooks ()\n+{\n+  m_symtab->remove_edge_removal_hook (m_symtab_removal_hook);\n+  m_symtab->remove_edge_duplication_hook (m_symtab_duplication_hook);\n+}\n+\n+/* An impossible class templated by non-pointers so, which makes sure that only\n+   summaries gathering pointers can be created.  */\n+\n+template <class T>\n+class call_summary\n+{\n+private:\n+  call_summary ();\n+};\n+\n+/* Class to store auxiliary information about call graph edges.  */\n+\n+template <class T>\n+class GTY((user)) call_summary <T *>: public call_summary_base<T>\n+{\n+public:\n+  /* Default construction takes SYMTAB as an argument.  */\n+  call_summary (symbol_table *symtab, bool ggc = false)\n+  : call_summary_base<T> (symtab), m_ggc (ggc), m_map (13, ggc)\n+  {\n+    this->m_symtab_removal_hook\n+      = this->m_symtab->add_edge_removal_hook (call_summary::symtab_removal,\n+\t\t\t\t\t       this);\n+    this->m_symtab_duplication_hook\n+      = this->m_symtab->add_edge_duplication_hook (call_summary::symtab_duplication,\n+\t\t\t\t\t\t   this);\n+  }\n+\n+  /* Destructor.  */\n+  virtual ~call_summary ()\n+  {\n+    release ();\n+  }\n+\n+  /* Destruction method that can be called for GGC purpose.  */\n+  using call_summary_base<T>::release;\n+  void release ();\n+\n+  /* Traverses all summarys with an edge E called with\n+     ARG as argument.  */\n+  template<typename Arg, bool (*f)(const T &, Arg)>\n+  void traverse (Arg a) const\n+  {\n+    m_map.traverse <f> (a);\n+  }\n \n   /* Getter for summary callgraph edge pointer.\n      If a summary for an edge does not exist, it will be created.  */\n@@ -371,7 +671,7 @@ class GTY((user)) call_summary <T *>\n     bool existed;\n     T **v = &m_map.get_or_insert (edge->get_uid (), &existed);\n     if (!existed)\n-      *v = allocate_new ();\n+      *v = this->allocate_new ();\n \n     return *v;\n   }\n@@ -384,23 +684,18 @@ class GTY((user)) call_summary <T *>\n   }\n \n   /* Remove edge from summary.  */\n+  using call_summary_base<T>::remove;\n   void remove (cgraph_edge *edge)\n   {\n     int uid = edge->get_uid ();\n     T **v = m_map.get (uid);\n     if (v)\n       {\n \tm_map.remove (uid);\n-\trelease (*v);\n+\tthis->release (*v);\n       }\n   }\n \n-  /* Return number of elements handled by data structure.  */\n-  size_t elements ()\n-  {\n-    return m_map.elements ();\n-  }\n-\n   /* Return true if a summary for the given EDGE already exists.  */\n   bool exists (cgraph_edge *edge)\n   {\n@@ -418,22 +713,17 @@ class GTY((user)) call_summary <T *>\n   /* Indication if we use ggc summary.  */\n   bool m_ggc;\n \n-  /* Initialize summary for an edge that is cloned.  */\n-  bool m_initialize_when_cloning;\n-\n private:\n+  /* Indication if we use ggc summary.  */\n+  virtual bool is_ggc ()\n+  {\n+    return m_ggc;\n+  }\n+\n   typedef int_hash <int, 0, -1> map_hash;\n \n   /* Main summary store, where summary ID is used as key.  */\n   hash_map <map_hash, T *> m_map;\n-  /* Internal summary removal hook pointer.  */\n-  cgraph_edge_hook_list *m_symtab_removal_hook;\n-  /* Internal summary duplication hook pointer.  */\n-  cgraph_2edge_hook_list *m_symtab_duplication_hook;\n-  /* Indicates if the summary is released.  */\n-  bool m_released;\n-  /* Symbol table the summary is registered to.  */\n-  symbol_table *m_symtab;\n \n   template <typename U> friend void gt_ggc_mx (call_summary <U *> * const &);\n   template <typename U> friend void gt_pch_nx (call_summary <U *> * const &);\n@@ -445,48 +735,25 @@ template <typename T>\n void\n call_summary<T *>::release ()\n {\n-  if (m_released)\n+  if (this->m_released)\n     return;\n \n-  m_symtab->remove_edge_removal_hook (m_symtab_removal_hook);\n-  m_symtab->remove_edge_duplication_hook (m_symtab_duplication_hook);\n+  this->unregister_hooks ();\n \n   /* Release all summaries.  */\n   typedef typename hash_map <map_hash, T *>::iterator map_iterator;\n   for (map_iterator it = m_map.begin (); it != m_map.end (); ++it)\n-    release ((*it).second);\n+    this->release ((*it).second);\n \n-  m_released = true;\n-}\n-\n-template <typename T>\n-void\n-call_summary<T *>::release (T *item)\n-{\n-  if (m_ggc)\n-    {\n-      item->~T ();\n-      ggc_free (item);\n-    }\n-  else\n-    delete item;\n+  this->m_released = true;\n }\n \n template <typename T>\n void\n call_summary<T *>::symtab_removal (cgraph_edge *edge, void *data)\n {\n   call_summary *summary = (call_summary <T *> *) (data);\n-\n-  int h_uid = edge->get_uid ();\n-  T **v = summary->m_map.get (h_uid);\n-\n-  if (v)\n-    {\n-      summary->remove (edge, *v);\n-      summary->release (*v);\n-      summary->m_map.remove (h_uid);\n-    }\n+  summary->remove (edge);\n }\n \n template <typename T>\n@@ -500,21 +767,11 @@ call_summary<T *>::symtab_duplication (cgraph_edge *edge1,\n   if (summary->m_initialize_when_cloning)\n     edge1_summary = summary->get_create (edge1);\n   else\n-    {\n-      T **v = summary->m_map.get (edge1->get_uid ());\n-      if (v)\n-\t{\n-\t  /* This load is necessary, because we insert a new value!  */\n-\t  edge1_summary = *v;\n-\t}\n-    }\n+    edge1_summary = summary->get (edge1);\n \n   if (edge1_summary)\n-    {\n-      T *duplicate = summary->allocate_new ();\n-      summary->m_map.put (edge2->get_uid (), duplicate);\n-      summary->duplicate (edge1, edge2, edge1_summary, duplicate);\n-    }\n+    summary->duplicate (edge1, edge2, edge1_summary,\n+\t\t\tsummary->get_create (edge2));\n }\n \n template <typename T>\n@@ -542,4 +799,213 @@ gt_pch_nx(call_summary<T *>* const& summary, gt_pointer_operator op,\n   gt_pch_nx (&summary->m_map, op, cookie);\n }\n \n+/* We want to pass just pointer types as argument for fast_call_summary\n+   template class.  */\n+\n+template <class T, class V>\n+class fast_call_summary\n+{\n+private:\n+  fast_call_summary ();\n+};\n+\n+/* Call vector summary is a fast implementation of call_summary that\n+   utilizes vector as primary storage of summaries.  */\n+\n+template <class T, class V>\n+class GTY((user)) fast_call_summary <T *, V>: public call_summary_base<T>\n+{\n+public:\n+  /* Default construction takes SYMTAB as an argument.  */\n+  fast_call_summary (symbol_table *symtab)\n+  : call_summary_base<T> (symtab), m_vector (NULL)\n+  {\n+    vec_alloc (m_vector, 13);\n+    this->m_symtab_removal_hook\n+      = this->m_symtab->add_edge_removal_hook (fast_call_summary::symtab_removal,\n+\t\t\t\t\t       this);\n+    this->m_symtab_duplication_hook\n+      = this->m_symtab->add_edge_duplication_hook (fast_call_summary::symtab_duplication,\n+\t\t\t\t\t\t   this);\n+  }\n+\n+  /* Destructor.  */\n+  virtual ~fast_call_summary ()\n+  {\n+    release ();\n+  }\n+\n+  /* Destruction method that can be called for GGC purpose.  */\n+  using call_summary_base<T>::release;\n+  void release ();\n+\n+  /* Traverses all summarys with an edge F called with\n+     ARG as argument.  */\n+  template<typename Arg, bool (*f)(const T &, Arg)>\n+  void traverse (Arg a) const\n+  {\n+    for (unsigned i = 0; i < m_vector->length (); i++)\n+      if ((*m_vector[i]) != NULL)\n+\tf ((*m_vector)[i]);\n+  }\n+\n+  /* Getter for summary callgraph edge pointer.\n+     If a summary for an edge does not exist, it will be created.  */\n+  T* get_create (cgraph_edge *edge)\n+  {\n+    int id = edge->get_summary_id ();\n+    if (id == -1)\n+      id = this->m_symtab->assign_summary_id (edge);\n+\n+    if ((unsigned)id >= m_vector->length ())\n+      vec_safe_grow_cleared (m_vector, this->m_symtab->edges_max_summary_id);\n+\n+    if ((*m_vector)[id] == NULL)\n+      (*m_vector)[id] = this->allocate_new ();\n+\n+    return (*m_vector)[id];\n+  }\n+\n+  /* Getter for summary callgraph edge pointer.  */\n+  T* get (cgraph_edge *edge) ATTRIBUTE_PURE\n+  {\n+    return exists (edge) ? (*m_vector)[edge->get_summary_id ()] : NULL;\n+  }\n+\n+  /* Remove edge from summary.  */\n+  using call_summary_base<T>::remove;\n+  void remove (cgraph_edge *edge)\n+  {\n+    if (exists (edge))\n+      {\n+\tint id = edge->get_summary_id ();\n+\tthis->release ((*m_vector)[id]);\n+\t(*m_vector)[id] = NULL;\n+      }\n+  }\n+\n+  /* Return true if a summary for the given EDGE already exists.  */\n+  bool exists (cgraph_edge *edge)\n+  {\n+    int id = edge->get_summary_id ();\n+    return (id != -1\n+\t    && (unsigned)id < m_vector->length ()\n+\t    && (*m_vector)[id] != NULL);\n+  }\n+\n+  /* Symbol removal hook that is registered to symbol table.  */\n+  static void symtab_removal (cgraph_edge *edge, void *data);\n+\n+  /* Symbol duplication hook that is registered to symbol table.  */\n+  static void symtab_duplication (cgraph_edge *edge1, cgraph_edge *edge2,\n+\t\t\t\t  void *data);\n+\n+private:\n+  virtual bool is_ggc ();\n+\n+  /* Summary is stored in the vector.  */\n+  vec <T *, V> *m_vector;\n+\n+  template <typename U> friend void gt_ggc_mx (fast_call_summary <U *, va_gc> * const &);\n+  template <typename U> friend void gt_pch_nx (fast_call_summary <U *, va_gc> * const &);\n+  template <typename U> friend void gt_pch_nx (fast_call_summary <U *, va_gc> * const &,\n+      gt_pointer_operator, void *);\n+};\n+\n+template <typename T, typename V>\n+void\n+fast_call_summary<T *, V>::release ()\n+{\n+  if (this->m_released)\n+    return;\n+\n+  this->unregister_hooks ();\n+\n+  /* Release all summaries.  */\n+  for (unsigned i = 0; i < m_vector->length (); i++)\n+    if ((*m_vector)[i] != NULL)\n+      this->release ((*m_vector)[i]);\n+\n+  this->m_released = true;\n+}\n+\n+template <typename T, typename V>\n+void\n+fast_call_summary<T *, V>::symtab_removal (cgraph_edge *edge, void *data)\n+{\n+  fast_call_summary *summary = (fast_call_summary <T *, V> *) (data);\n+  summary->remove (edge);\n+}\n+\n+template <typename T, typename V>\n+void\n+fast_call_summary<T *, V>::symtab_duplication (cgraph_edge *edge1,\n+\t\t\t\t\t\t cgraph_edge *edge2, void *data)\n+{\n+  fast_call_summary *summary = (fast_call_summary <T *, V> *) (data);\n+  T *edge1_summary = NULL;\n+\n+  if (summary->m_initialize_when_cloning)\n+    edge1_summary = summary->get_create (edge1);\n+  else\n+    edge1_summary = summary->get (edge1);\n+\n+  if (edge1_summary)\n+    {\n+      T *duplicate = summary->get_create (edge2);\n+      summary->duplicate (edge1, edge2, edge1_summary, duplicate);\n+    }\n+}\n+\n+template <typename T, typename V>\n+inline bool\n+fast_call_summary<T *, V>::is_ggc ()\n+{\n+  return is_same<V, va_gc>::value;\n+}\n+\n+template <typename T>\n+void\n+gt_ggc_mx (fast_call_summary<T *, va_heap>* const &summary)\n+{\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_call_summary<T *, va_heap>* const &summary)\n+{\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_call_summary<T *, va_heap>* const& summary,\n+\t   gt_pointer_operator op,\n+\t   void *cookie)\n+{\n+}\n+\n+template <typename T>\n+void\n+gt_ggc_mx (fast_call_summary<T *, va_gc>* const &summary)\n+{\n+  ggc_test_and_set_mark (summary->m_vector);\n+  gt_ggc_mx (&summary->m_vector);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_call_summary<T *, va_gc>* const &summary)\n+{\n+  gt_pch_nx (&summary->m_vector);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx (fast_call_summary<T *, va_gc>* const& summary,\n+\t   gt_pointer_operator op,\n+\t   void *cookie)\n+{\n+  gt_pch_nx (&summary->m_vector, op, cookie);\n+}\n+\n #endif  /* GCC_SYMBOL_SUMMARY_H  */"}, {"sha": "4bd9df9aba54220adf162d2125c36fc5798f5ac9", "filename": "gcc/vec.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30281f0b2ff6dfc0c4146291baf020a27e4065/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=db30281f0b2ff6dfc0c4146291baf020a27e4065", "patch": "@@ -732,6 +732,17 @@ vec_safe_grow_cleared (vec<T, A, vl_embed> *&v, unsigned len CXX_MEM_STAT_INFO)\n }\n \n \n+/* Assume V is not NULL.  */\n+\n+template<typename T>\n+inline void\n+vec_safe_grow_cleared (vec<T, va_heap, vl_ptr> *&v,\n+\t\t       unsigned len CXX_MEM_STAT_INFO)\n+{\n+  v->safe_grow_cleared (len);\n+}\n+\n+\n /* If V is NULL return false, otherwise return V->iterate(IX, PTR).  */\n template<typename T, typename A>\n inline bool"}]}