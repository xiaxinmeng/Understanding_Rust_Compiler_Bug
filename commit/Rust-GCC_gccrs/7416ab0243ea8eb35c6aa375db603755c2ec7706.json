{"sha": "7416ab0243ea8eb35c6aa375db603755c2ec7706", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQxNmFiMDI0M2VhOGViMzVjNmFhMzc1ZGI2MDM3NTVjMmVjNzcwNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-03-17T13:26:39Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-03-17T13:26:39Z"}, "message": "re PR c++/20186 (ICE with static_cast and type dependent variable (templates))\n\ncp:\n\tPR c++/20186\n\t* pt.c (contains_dependent_cast_p): Remove.\n\t(fold_non_dependent_expr): Don't use it.\n\t(value_dependent_expression_p): Use a switch statement.\n\treference_exprs can be dependent.\n\nFrom-SVN: r96605", "tree": {"sha": "df86f7cc60ab0585497a20e9ed5a196ba7a7bf69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df86f7cc60ab0585497a20e9ed5a196ba7a7bf69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7416ab0243ea8eb35c6aa375db603755c2ec7706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7416ab0243ea8eb35c6aa375db603755c2ec7706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7416ab0243ea8eb35c6aa375db603755c2ec7706", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7416ab0243ea8eb35c6aa375db603755c2ec7706/comments", "author": null, "committer": null, "parents": [{"sha": "52eb57dfb1a459af58f87e8dc71206d7c2ba36a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52eb57dfb1a459af58f87e8dc71206d7c2ba36a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52eb57dfb1a459af58f87e8dc71206d7c2ba36a8"}], "stats": {"total": 252, "additions": 111, "deletions": 141}, "files": [{"sha": "411d81ca760749b3c1ea9295c46156a5d1c8b241", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7416ab0243ea8eb35c6aa375db603755c2ec7706/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7416ab0243ea8eb35c6aa375db603755c2ec7706/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7416ab0243ea8eb35c6aa375db603755c2ec7706", "patch": "@@ -1,3 +1,11 @@\n+2005-03-17  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/20186\n+\t* pt.c (contains_dependent_cast_p): Remove.\n+\t(fold_non_dependent_expr): Don't use it.\n+\t(value_dependent_expression_p): Use a switch statement.\n+\treference_exprs can be dependent.\n+\n 2005-03-14  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/4403"}, {"sha": "77ca2b9fc046877a0b915556ab40c0e09ecca7da", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 103, "deletions": 141, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7416ab0243ea8eb35c6aa375db603755c2ec7706/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7416ab0243ea8eb35c6aa375db603755c2ec7706/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7416ab0243ea8eb35c6aa375db603755c2ec7706", "patch": "@@ -3273,52 +3273,6 @@ redeclare_class_template (tree type, tree parms)\n     }\n }\n \n-/* Return true if non-dependent expressions EXPR contains within it a\n-   cast expression with a dependent argument.  */\n-\n-static bool\n-contains_dependent_cast_p (tree expr)\n-{\n-  switch (TREE_CODE (expr))\n-    {\n-    case CAST_EXPR:\n-    case REINTERPRET_CAST_EXPR:\n-    case STATIC_CAST_EXPR:\n-    case DYNAMIC_CAST_EXPR:\n-    case CONST_CAST_EXPR:\n-      {\n-\ttree op = TREE_OPERAND (expr, 0);\n-\n-\tif (op && (type_dependent_expression_p (op)\n-\t\t   || value_dependent_expression_p (op)))\n-\t  return true;\n-      }\n-      break;\n-\n-    case TREE_LIST:\n-      /* The operands of a CALL_EXPR are held as a list.  */\n-      for (; expr; expr = TREE_CHAIN (expr))\n-\tif (contains_dependent_cast_p (TREE_VALUE (expr)))\n-\t  return true;\n-      return false;\n-\n-    default:\n-      break;\n-    }\n-\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expr))))\n-    {\n-      int ix;\n-  \n-      for (ix = TREE_CODE_LENGTH (TREE_CODE (expr)); ix--;)\n-\tif (TREE_OPERAND (expr, ix)\n-\t    && contains_dependent_cast_p (TREE_OPERAND (expr, ix)))\n-\t  return true;\n-    }\n-  \n-  return false;\n-}\n-\n /* Simplify EXPR if it is a non-dependent expression.  Returns the\n    (possibly simplified) expression.  */\n \n@@ -3334,8 +3288,7 @@ fold_non_dependent_expr (tree expr)\n      as two declarations of the same function, for example.  */\n   if (processing_template_decl\n       && !type_dependent_expression_p (expr)\n-      && !value_dependent_expression_p (expr)\n-      && !contains_dependent_cast_p (expr))\n+      && !value_dependent_expression_p (expr))\n     {\n       HOST_WIDE_INT saved_processing_template_decl;\n \n@@ -12018,119 +11971,132 @@ value_dependent_expression_p (tree expression)\n     return false;\n \n   /* A name declared with a dependent type.  */\n-  if (TREE_CODE (expression) == IDENTIFIER_NODE\n-      || (DECL_P (expression) \n-\t  && type_dependent_expression_p (expression)))\n+  if (DECL_P (expression) && type_dependent_expression_p (expression))\n     return true;\n-  /* A non-type template parameter.  */\n-  if ((TREE_CODE (expression) == CONST_DECL\n-       && DECL_TEMPLATE_PARM_P (expression))\n-      || TREE_CODE (expression) == TEMPLATE_PARM_INDEX)\n-    return true;\n-  /* A constant with integral or enumeration type and is initialized \n-     with an expression that is value-dependent.  */\n-  if (TREE_CODE (expression) == VAR_DECL\n-      && DECL_INITIAL (expression)\n-      && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (expression))\n-      && value_dependent_expression_p (DECL_INITIAL (expression)))\n-    return true;\n-  /* These expressions are value-dependent if the type to which the\n-     cast occurs is dependent or the expression being casted is\n-     value-dependent.  */\n-  if (TREE_CODE (expression) == DYNAMIC_CAST_EXPR\n-      || TREE_CODE (expression) == STATIC_CAST_EXPR\n-      || TREE_CODE (expression) == CONST_CAST_EXPR\n-      || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n-      || TREE_CODE (expression) == CAST_EXPR)\n+  \n+  switch (TREE_CODE (expression))\n     {\n-      tree type = TREE_TYPE (expression);\n-      if (dependent_type_p (type))\n+    case IDENTIFIER_NODE:\n+      /* A name that has not been looked up -- must be dependent.  */\n+      return true;\n+\n+    case TEMPLATE_PARM_INDEX:\n+      /* A non-type template parm.  */\n+      return true;\n+\n+    case CONST_DECL:\n+      /* A non-type template parm.  */\n+      if (DECL_TEMPLATE_PARM_P (expression))\n \treturn true;\n-      /* A functional cast has a list of operands.  */\n-      expression = TREE_OPERAND (expression, 0);\n-      if (!expression)\n-\t{\n-\t  /* If there are no operands, it must be an expression such\n-\t     as \"int()\". This should not happen for aggregate types\n-\t     because it would form non-constant expressions.  */\n-\t  gcc_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n+      return false;\n \n-\t  return false;\n-\t}\n-      if (TREE_CODE (expression) == TREE_LIST)\n-\t{\n-\t  do\n-\t    {\n+    case VAR_DECL:\n+       /* A constant with integral or enumeration type and is initialized \n+     \t  with an expression that is value-dependent.  */\n+      if (DECL_INITIAL (expression)\n+\t  && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (expression))\n+\t  && value_dependent_expression_p (DECL_INITIAL (expression)))\n+\treturn true;\n+      return false;\n+\n+    case DYNAMIC_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+    case CAST_EXPR:\n+      /* These expressions are value-dependent if the type to which\n+     \t the cast occurs is dependent or the expression being casted\n+     \t is value-dependent.  */\n+      {\n+\ttree type = TREE_TYPE (expression);\n+\t\n+\tif (dependent_type_p (type))\n+\t  return true;\n+\t\n+\t/* A functional cast has a list of operands.  */\n+\texpression = TREE_OPERAND (expression, 0);\n+\tif (!expression)\n+\t  {\n+\t    /* If there are no operands, it must be an expression such\n+\t       as \"int()\". This should not happen for aggregate types\n+\t       because it would form non-constant expressions.  */\n+\t    gcc_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n+\t    \n+\t    return false;\n+\t  }\n+\t\n+\tif (TREE_CODE (expression) == TREE_LIST)\n+\t  {\n+\t    for (; expression; expression = TREE_CHAIN (expression))\n \t      if (value_dependent_expression_p (TREE_VALUE (expression)))\n \t\treturn true;\n-\t      expression = TREE_CHAIN (expression);\n-\t    }\n-\t  while (expression);\n-\t  return false;\n-\t}\n-      else\n+\t    return false;\n+\t  }\n+\t\n \treturn value_dependent_expression_p (expression);\n-    }\n-  /* A `sizeof' expression is value-dependent if the operand is\n-     type-dependent.  */\n-  if (TREE_CODE (expression) == SIZEOF_EXPR\n-      || TREE_CODE (expression) == ALIGNOF_EXPR)\n-    {\n+      }\n+      \n+    case SIZEOF_EXPR:\n+    case ALIGNOF_EXPR:\n+      /* A `sizeof' expression is value-dependent if the operand is\n+     \t type-dependent.  */\n       expression = TREE_OPERAND (expression, 0);\n       if (TYPE_P (expression))\n \treturn dependent_type_p (expression);\n       return type_dependent_expression_p (expression);\n-    }\n-  if (TREE_CODE (expression) == SCOPE_REF)\n-    return dependent_scope_ref_p (expression, value_dependent_expression_p);\n-  if (TREE_CODE (expression) == COMPONENT_REF)\n-    return (value_dependent_expression_p (TREE_OPERAND (expression, 0))\n-\t    || value_dependent_expression_p (TREE_OPERAND (expression, 1)));\n \n-  /* A CALL_EXPR is value-dependent if any argument is\n-     value-dependent.  Why do we have to handle CALL_EXPRs in this\n-     function at all?  First, some function calls, those for which\n-     value_dependent_expression_p is true, man appear in constant\n-     expressions.  Second, there appear to be bugs which result in\n-     other CALL_EXPRs reaching this point. */\n-  if (TREE_CODE (expression) == CALL_EXPR)\n-    {\n-      tree function = TREE_OPERAND (expression, 0);\n-      tree args = TREE_OPERAND (expression, 1);\n+    case SCOPE_REF:\n+      return dependent_scope_ref_p (expression, value_dependent_expression_p);\n \n-      if (value_dependent_expression_p (function))\n-\treturn true;\n-      else if (! args)\n-\treturn false;\n-      else if (TREE_CODE (args) == TREE_LIST)\n-\t{\n-\t  do\n-\t    {\n+    case COMPONENT_REF:\n+      return (value_dependent_expression_p (TREE_OPERAND (expression, 0))\n+\t      || value_dependent_expression_p (TREE_OPERAND (expression, 1)));\n+\n+    case CALL_EXPR:\n+      /* A CALL_EXPR is value-dependent if any argument is\n+     \t value-dependent.  Why do we have to handle CALL_EXPRs in this\n+     \t function at all?  First, some function calls, those for which\n+     \t value_dependent_expression_p is true, man appear in constant\n+     \t expressions.  Second, there appear to be bugs which result in\n+     \t other CALL_EXPRs reaching this point. */\n+      {\n+\ttree function = TREE_OPERAND (expression, 0);\n+\ttree args = TREE_OPERAND (expression, 1);\n+\t\n+\tif (value_dependent_expression_p (function))\n+\t  return true;\n+\t\n+\tif (! args)\n+\t  return false;\n+\t\n+\tif (TREE_CODE (args) == TREE_LIST)\n+\t  {\n+\t    for (; args; args = TREE_CHAIN (args))\n \t      if (value_dependent_expression_p (TREE_VALUE (args)))\n \t\treturn true;\n-\t      args = TREE_CHAIN (args);\n-\t    }\n-\t  while (args);\n-\t  return false;\n-\t}\n-      else\n+\t    return false;\n+\t  }\n+\t\n \treturn value_dependent_expression_p (args);\n-    }\n-  /* A constant expression is value-dependent if any subexpression is\n-     value-dependent.  */\n-  if (EXPR_P (expression))\n-    {\n+      }\n+\n+    default:\n+      /* A constant expression is value-dependent if any subexpression is\n+     \t value-dependent.  */\n       switch (TREE_CODE_CLASS (TREE_CODE (expression)))\n \t{\n+\tcase tcc_reference:\n \tcase tcc_unary:\n \t  return (value_dependent_expression_p \n \t\t  (TREE_OPERAND (expression, 0)));\n+\t  \n \tcase tcc_comparison:\n \tcase tcc_binary:\n \t  return ((value_dependent_expression_p \n \t\t   (TREE_OPERAND (expression, 0)))\n \t\t  || (value_dependent_expression_p \n \t\t      (TREE_OPERAND (expression, 1))));\n+\t  \n \tcase tcc_expression:\n \t  {\n \t    int i;\n@@ -12145,16 +12111,12 @@ value_dependent_expression_p (tree expression)\n \t\treturn true;\n \t    return false;\n \t  }\n-\tcase tcc_reference:\n-\tcase tcc_statement:\n-\t  /* These cannot be value dependent.  */\n-\t  return false;\n-\n+\t      \n \tdefault:\n-\t  gcc_unreachable ();\n+\t  break;\n \t}\n     }\n-\n+  \n   /* The expression is not value-dependent.  */\n   return false;\n }"}]}