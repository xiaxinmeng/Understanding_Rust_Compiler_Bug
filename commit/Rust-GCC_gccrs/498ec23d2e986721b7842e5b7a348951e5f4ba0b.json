{"sha": "498ec23d2e986721b7842e5b7a348951e5f4ba0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk4ZWMyM2QyZTk4NjcyMWI3ODQyZTViN2EzNDg5NTFlNWY0YmEwYg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2003-12-10T16:22:32Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-12-10T16:22:32Z"}, "message": "README.Portability: Remove K+R section.\n\n2003-12-10  Steven Bosscher  <stevenb@suse.de>\n\n\t* README.Portability: Remove K+R section.\n\n\t* gengtype-lex.l: Teach about \"void**\" pointers and\n\t\"void*\" function types.\n\nFrom-SVN: r74501", "tree": {"sha": "f36390eb1c6e083198317c53b31f86287dede4c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f36390eb1c6e083198317c53b31f86287dede4c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/498ec23d2e986721b7842e5b7a348951e5f4ba0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ec23d2e986721b7842e5b7a348951e5f4ba0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498ec23d2e986721b7842e5b7a348951e5f4ba0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ec23d2e986721b7842e5b7a348951e5f4ba0b/comments", "author": null, "committer": null, "parents": [{"sha": "ed1fe82954ec95687de9ecc0351b8a3c32e1937c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1fe82954ec95687de9ecc0351b8a3c32e1937c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed1fe82954ec95687de9ecc0351b8a3c32e1937c"}], "stats": {"total": 225, "additions": 14, "deletions": 211}, "files": [{"sha": "7627718c34ef3c626d3a50290d7674c80b5aaade", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ec23d2e986721b7842e5b7a348951e5f4ba0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ec23d2e986721b7842e5b7a348951e5f4ba0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=498ec23d2e986721b7842e5b7a348951e5f4ba0b", "patch": "@@ -1,3 +1,10 @@\n+2003-12-10  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* README.Portability: Remove K+R section.\n+\n+\t* gengtype-lex.l: Teach about \"void**\" pointers and\n+\t\"void*\" function types.\n+\n 2003-12-10  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR target/13354"}, {"sha": "2724f2a53fd65ccf8db1c04e96b31017b6d36e81", "filename": "gcc/README.Portability", "status": "modified", "additions": 5, "deletions": 209, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ec23d2e986721b7842e5b7a348951e5f4ba0b/gcc%2FREADME.Portability", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ec23d2e986721b7842e5b7a348951e5f4ba0b/gcc%2FREADME.Portability", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.Portability?ref=498ec23d2e986721b7842e5b7a348951e5f4ba0b", "patch": "@@ -14,18 +14,15 @@ I'm going to start from a base of the ISO C89 standard, since that is\n probably what most people code to naturally.  Obviously using\n constructs introduced after that is not a good idea.\n \n-The first section of this file deals strictly with portability issues,\n-the second with common coding pitfalls, and the third with obsolete\n-K+R portability issues.\n+For the complete coding style conventions used in GCC, please read\n+http://gcc.gnu.org/codingconventions.html\n \n \n-\t\t\tPortability Issues\n-\t\t\t==================\n-\n String literals\n ---------------\n \n-Some SGI compilers choke on the parentheses in:-\n+Irix6 \"cc -n32\" and OSF4 \"cc\" have problems with constant string\n+initializers with parens around it, e.g.\n \n const char string[] = (\"A string\");\n \n@@ -176,7 +173,7 @@ WITH UMLAUT.\n Other common pitfalls\n ---------------------\n \n-o Expecting 'plain' char to be either sign or unsigned extending\n+o Expecting 'plain' char to be either sign or unsigned extending.\n \n o Shifting an item by a negative amount or by greater than or equal to\n   the number of bits in a type (expecting shifts by 32 to be sensible\n@@ -198,204 +195,3 @@ o Passing incorrect types to fprintf and friends.\n o Adding a function declaration for a module declared in another file to\n   a .c file instead of to a .h file.\n \n-\n-\t\t\tK+R Portability Issues\n-\t\t\t======================\n-\n-Unary +\n--------\n-\n-K+R C compilers and preprocessors have no notion of unary '+'.  Thus\n-the following code snippet contained 2 portability problems.\n-\n-int x = +2;  /* int x = 2;  */\n-#if +1       /* #if 1  */\n-#endif\n-\n-\n-Pointers to void\n-----------------\n-\n-K+R C compilers did not have a void pointer, and used char * as the\n-pointer to anything.  The macro PTR is defined as either void * or\n-char * depending on whether you have a standards compliant compiler or\n-a K+R one.  Thus\n-\n-  free ((void *) h->value.expansion);\n-\n-should have been written\n-\n-  free ((PTR) h->value.expansion);\n-\n-Further, an initial investigation indicates that pointers to functions\n-returning void were okay.  Thus the example given by \"Calling\n-functions through pointers to functions\" below appeared not to cause a\n-problem.\n-\n-\n-String literals\n----------------\n-\n-K+R C did not allow concatenation of string literals like\n-\n-  \"This is a \" \"single string literal\".\n-\n-\n-signed keyword\n---------------\n-\n-The signed keyword did not exist in K+R compilers; it was introduced\n-in ISO C89, so you could not use it.  In both K+R and standard C,\n-unqualified char and bitfields may be signed or unsigned.  There is no\n-way to portably declare signed chars or signed bitfields.\n-\n-All other arithmetic types are signed unless you use the 'unsigned'\n-qualifier.  For instance, it was safe to write\n-\n-  short paramc;\n-\n-instead of\n-\n-  signed short paramc;\n-\n-If you have an algorithm that depends on signed char or signed\n-bitfields, you had to find another way to write it before it could be\n-integrated into GCC.\n-\n-\n-Function prototypes\n--------------------\n-\n-You need to provide a function prototype for every function before you\n-use it, and functions had to be defined K+R style.  The function\n-prototype should have used the PARAMS macro, which takes a single\n-argument.  Therefore the parameter list had to be enclosed in\n-parentheses.  For example,\n-\n-int myfunc PARAMS ((double, int *));\n-\n-int\n-myfunc (var1, var2)\n-     double var1;\n-     int *var2;\n-{\n-  ...\n-}\n-\n-This implies that if the function takes no arguments, it had to be\n-declared and defined as follows:\n-\n-int myfunc PARAMS ((void));\n-\n-int\n-myfunc ()\n-{\n-  ...\n-}\n-\n-You also had to use PARAMS when referring to function protypes in\n-other circumstances, for example see \"Calling functions through\n-pointers to functions\" below.\n-\n-Variable-argument functions are best described by example:-\n-\n-void cpp_ice PARAMS ((cpp_reader *, const char *msgid, ...));\n-\n-void\n-cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n-{\n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, const char *, msgid);\n-\n-  ...\n-  VA_CLOSE (ap);\n-}\n-\n-See ansidecl.h for the definitions of the above macros and more.\n-\n-One aspect of using K+R style function declarations, is you could not\n-have arguments whose types are char, short, or float, since without\n-prototypes (ie, K+R rules), these types are promoted to int, int, and\n-double respectively.\n-\n-Calling functions through pointers to functions\n------------------------------------------------\n-\n-K+R C compilers require parentheses around the dereferenced function\n-pointer expression in the call, whereas ISO C relaxes the syntax.  For\n-example\n-\n-typedef void (* cl_directive_handler) PARAMS ((cpp_reader *, const char *));\n-      *p->handler (pfile, p->arg);\n-\n-had to become\n-\n-      (*p->handler) (pfile, p->arg);\n-\n-\n-Macros\n-------\n-\n-The rules under K+R C and ISO C for achieving stringification and\n-token pasting are quite different.  Therefore some macros have been\n-defined which will get it right depending upon the compiler.\n-\n-  CONCAT2(a,b) CONCAT3(a,b,c) and CONCAT4(a,b,c,d)\n-\n-will paste the tokens passed as arguments.  You must not leave any\n-space around the commas.  Also,\n-\n-  STRINGX(x)\n-\n-will stringify an argument; to get the same result on K+R and ISO\n-compilers x should not have spaces around it.\n-\n-\n-Passing structures by value\n----------------------------\n-\n-You had to avoid passing structures by value, either to or from\n-functions.  It seems some K+R compilers handle this differently or not\n-at all.\n-\n-\n-Enums\n------\n-\n-In K+R C, you had to cast enum types to use them as integers, and some\n-compilers in particular give lots of warnings for using an enum as an\n-array index.\n-\n-\n-Bitfields\n----------\n-\n-See also \"signed keyword\" above.  In K+R C only unsigned int bitfields\n-were defined (i.e. unsigned char, unsigned short, unsigned long.\n-Using plain int/short/long was not allowed).\n-\n-\n-Reserved Keywords\n------------------\n-\n-K+R C has \"entry\" as a reserved keyword, so you had to not use it for\n-your variable names.\n-\n-\n-Type promotions\n----------------\n-\n-K+R used unsigned-preserving rules for arithmetic expresssions, while\n-ISO uses value-preserving.  This means an unsigned char compared to an\n-int is done as an unsigned comparison in K+R (since unsigned char\n-promotes to unsigned) while it is signed in ISO (since all of the\n-values in unsigned char fit in an int, it promotes to int).\n-\n-\n-Suffixes on Integer Constants\n------------------------------\n-\n-K+R C did not accept a 'u' suffix on integer constants.  If you wanted\n-to declare a constant to be be unsigned, you had to use an explicit\n-cast."}, {"sha": "2f52659968598738d4165fa9c953b9644a82334f", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ec23d2e986721b7842e5b7a348951e5f4ba0b/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ec23d2e986721b7842e5b7a348951e5f4ba0b/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=498ec23d2e986721b7842e5b7a348951e5f4ba0b", "patch": "@@ -146,7 +146,7 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   update_lineno (yytext, yyleng);\n }\n \n-[^[:alnum:]_]typedef{WS}{ID}{WS}?\"(\"{WS}?\"*\"{WS}?{ID}{WS}?\")\"{WS}?PARAMS {\n+[^[:alnum:]_]typedef{WS}{ID}{WS}?\"*\"?{WS}?\"(\"{WS}?\"*\"{WS}?{ID}{WS}?\")\"{WS}?PARAMS {\n   char *namestart;\n   size_t namelen;\n   struct type *t;\n@@ -162,7 +162,7 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   update_lineno (yytext, yyleng);\n }\n \n-[^[:alnum:]_]typedef{WS}{ID}{WS}?\"(\"{WS}?\"*\"{WS}?{ID}{WS}?\")\"{WS}?\"(\" {\n+[^[:alnum:]_]typedef{WS}{ID}{WS}?\"*\"?{WS}?\"(\"{WS}?\"*\"{WS}?{ID}{WS}?\")\"{WS}?\"(\" {\n   char *namestart;\n   size_t namelen;\n   struct type *t;"}]}