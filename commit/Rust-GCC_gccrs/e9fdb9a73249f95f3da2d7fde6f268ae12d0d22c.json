{"sha": "e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlmZGI5YTczMjQ5Zjk1ZjNkYTJkN2ZkZTZmMjY4YWUxMmQwZDIyYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-14T16:42:29Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-14T16:45:24Z"}, "message": "c++: local externs in templates do not get template head\n\nNow we consistently mark local externs with DECL_LOCAL_DECL_P, we can\nteach the template machinery not to give them a TEMPLATE_DECL head,\nand the instantiation machinery treat them as the local specialiations\nthey are.  (openmp UDRs also fall into this category, and are dealt\nwith similarly.)\n\n\tgcc/cp/\n\t* pt.c (push_template_decl_real): Don't attach a template head to\n\tlocal externs.\n\t(tsubst_function_decl): Add support for headless local extern\n\tdecls.\n\t(tsubst_decl): Add support for headless local extern decls.", "tree": {"sha": "bc6b255876ccd75fd7e03e5d271d7b929305ce96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc6b255876ccd75fd7e03e5d271d7b929305ce96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05ab8befe1230c46116aae37d44f2ce0933e8dae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05ab8befe1230c46116aae37d44f2ce0933e8dae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05ab8befe1230c46116aae37d44f2ce0933e8dae"}], "stats": {"total": 47, "additions": 27, "deletions": 20}, "files": [{"sha": "8124efcbe243466e71b17d2f3ce5ae18b54b50cb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e9fdb9a73249f95f3da2d7fde6f268ae12d0d22c", "patch": "@@ -6071,7 +6071,11 @@ push_template_decl_real (tree decl, bool is_friend)\n     {\n       if (is_primary)\n \tretrofit_lang_decl (decl);\n-      if (DECL_LANG_SPECIFIC (decl))\n+      if (DECL_LANG_SPECIFIC (decl)\n+\t  && ((TREE_CODE (decl) != VAR_DECL\n+\t       && TREE_CODE (decl) != FUNCTION_DECL)\n+\t      || !ctx\n+\t      || !DECL_LOCAL_DECL_P (decl)))\n \tDECL_TEMPLATE_INFO (decl) = info;\n     }\n \n@@ -13701,14 +13705,20 @@ static tree\n tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n \t\t      tree lambda_fntype)\n {\n-  tree gen_tmpl, argvec;\n+  tree gen_tmpl = NULL_TREE, argvec = NULL_TREE;\n   hashval_t hash = 0;\n   tree in_decl = t;\n \n   /* Nobody should be tsubst'ing into non-template functions.  */\n-  gcc_assert (DECL_TEMPLATE_INFO (t) != NULL_TREE);\n+  gcc_assert (DECL_TEMPLATE_INFO (t) != NULL_TREE\n+\t      || DECL_LOCAL_DECL_P (t));\n \n-  if (TREE_CODE (DECL_TI_TEMPLATE (t)) == TEMPLATE_DECL)\n+  if (DECL_LOCAL_DECL_P (t))\n+    {\n+      if (tree spec = retrieve_local_specialization (t))\n+\treturn spec;\n+    }\n+  else if (TREE_CODE (DECL_TI_TEMPLATE (t)) == TEMPLATE_DECL)\n     {\n       /* If T is not dependent, just return it.  */\n       if (!uses_template_parms (DECL_TI_ARGS (t))\n@@ -13958,6 +13968,11 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n \t  && !uses_template_parms (argvec))\n \ttsubst_default_arguments (r, complain);\n     }\n+  else if (DECL_LOCAL_DECL_P (r))\n+    {\n+      if (!cp_unevaluated_operand)\n+\tregister_local_specialization (r, t);\n+    }\n   else\n     DECL_TEMPLATE_INFO (r) = NULL_TREE;\n \n@@ -14503,11 +14518,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n       {\n \ttree argvec = NULL_TREE;\n \ttree gen_tmpl = NULL_TREE;\n-\ttree spec;\n \ttree tmpl = NULL_TREE;\n-\ttree ctx;\n \ttree type = NULL_TREE;\n-\tbool local_p;\n \n \tif (TREE_TYPE (t) == error_mark_node)\n \t  RETURN (error_mark_node);\n@@ -14529,19 +14541,13 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n \t/* Check to see if we already have the specialization we\n \t   need.  */\n-\tspec = NULL_TREE;\n-\tif (DECL_CLASS_SCOPE_P (t) || DECL_NAMESPACE_SCOPE_P (t))\n+\ttree spec = NULL_TREE;\n+\tbool local_p = false;\n+\ttree ctx = DECL_CONTEXT (t);\n+\tif (!(VAR_P (t) && DECL_LOCAL_DECL_P (t))\n+\t    && (DECL_CLASS_SCOPE_P (t) || DECL_NAMESPACE_SCOPE_P (t)))\n \t  {\n-\t    /* T is a static data member or namespace-scope entity.\n-\t       We have to substitute into namespace-scope variables\n-\t       (not just variable templates) because of cases like:\n-\n-\t         template <class T> void f() { extern T t; }\n-\n-\t       where the entity referenced is not known until\n-\t       instantiation time.  */\n \t    local_p = false;\n-\t    ctx = DECL_CONTEXT (t);\n \t    if (DECL_CLASS_SCOPE_P (t))\n \t      {\n \t\tctx = tsubst_aggr_type (ctx, args,\n@@ -14581,10 +14587,11 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  }\n \telse\n \t  {\n+\t    if (!(VAR_P (t) && DECL_LOCAL_DECL_P (t)))\n+\t      /* Subsequent calls to pushdecl will fill this in.  */\n+\t      ctx = NULL_TREE;\n \t    /* A local variable.  */\n \t    local_p = true;\n-\t    /* Subsequent calls to pushdecl will fill this in.  */\n-\t    ctx = NULL_TREE;\n \t    /* Unless this is a reference to a static variable from an\n \t       enclosing function, in which case we need to fill it in now.  */\n \t    if (TREE_STATIC (t))"}]}