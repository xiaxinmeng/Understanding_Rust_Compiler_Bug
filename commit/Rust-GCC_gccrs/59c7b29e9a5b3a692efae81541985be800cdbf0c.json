{"sha": "59c7b29e9a5b3a692efae81541985be800cdbf0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTljN2IyOWU5YTViM2E2OTJlZmFlODE1NDE5ODViZTgwMGNkYmYwYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-12-10T17:54:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-12-10T17:54:41Z"}, "message": "Turn tp_first_run counts back to 32bit values.\n\n\t* cgraph.c (cgraph_node::verify_node): Verify tp_first_run.\n\t* cgraph.h (cgrpah_node): Turn tp_first_run back to int.\n\t* cgraphunit.c (tp_first_run_node_cmp): Do not watch for overflows.\n\t(expand_all_functions): First expand ordered section and then\n\tunordered.\n\t* lto-partition.c (lto_balanced_map): Fix printing of tp_first_run.\n\t* profile.c (compute_value_histograms): Error on out of range\n\ttp_first_runs.\n\nFrom-SVN: r279178", "tree": {"sha": "f2bb1ec7b0e6ac6ba92cb44f3193d2a12f761625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2bb1ec7b0e6ac6ba92cb44f3193d2a12f761625"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59c7b29e9a5b3a692efae81541985be800cdbf0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c7b29e9a5b3a692efae81541985be800cdbf0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c7b29e9a5b3a692efae81541985be800cdbf0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c7b29e9a5b3a692efae81541985be800cdbf0c/comments", "author": null, "committer": null, "parents": [{"sha": "066564270000d608114fdea89cfbf58c69f68845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066564270000d608114fdea89cfbf58c69f68845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066564270000d608114fdea89cfbf58c69f68845"}], "stats": {"total": 93, "additions": 54, "deletions": 39}, "files": [{"sha": "ba5f2767e4b0573a2ef73068ecdaaf44f383b4e0", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=59c7b29e9a5b3a692efae81541985be800cdbf0c", "patch": "@@ -3066,6 +3066,11 @@ cgraph_node::verify_node (void)\n       inlined_to->count.debug ();\n       error_found = true;\n     }\n+  if (tp_first_run < 0)\n+    {\n+      error (\"tp_first_run must be non-negative\");\n+      error_found = true;\n+    }\n   if (!definition && !in_other_partition && local)\n     {\n       error (\"local symbols must be defined\");"}, {"sha": "e96cb51d80338e8aca507a220c8697861666f0da", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=59c7b29e9a5b3a692efae81541985be800cdbf0c", "patch": "@@ -926,9 +926,9 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n       clone_of (NULL), call_site_hash (NULL), former_clone_of (NULL),\n       simdclone (NULL), simd_clones (NULL), ipa_transforms_to_apply (vNULL),\n       inlined_to (NULL), rtl (NULL), clone (), thunk (),\n-      count (profile_count::uninitialized ()), tp_first_run (false),\n+      count (profile_count::uninitialized ()),\n       count_materialization_scale (REG_BR_PROB_BASE), profile_id (0),\n-      unit_id (0), used_as_abstract_origin (false),\n+      unit_id (0), tp_first_run (0), used_as_abstract_origin (false),\n       lowered (false), process (false), frequency (NODE_FREQUENCY_NORMAL),\n       only_called_at_startup (false), only_called_at_exit (false),\n       tm_clone (false), dispatcher_function (false), calls_comdat_local (false),\n@@ -1469,15 +1469,15 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \n   /* Expected number of executions: calculated in profile.c.  */\n   profile_count count;\n-  /* Time profiler: first run of function.  */\n-  gcov_type tp_first_run;\n   /* How to scale counts at materialization time; used to merge\n      LTO units with different number of profile runs.  */\n   int count_materialization_scale;\n   /* ID assigned by the profiling.  */\n   unsigned int profile_id;\n   /* ID of the translation unit.  */\n   int unit_id;\n+  /* Time profiler: first run of function.  */\n+  int tp_first_run;\n \n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */"}, {"sha": "6b8a466eecb0e75a375e8b77177f8273ebf773da", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=59c7b29e9a5b3a692efae81541985be800cdbf0c", "patch": "@@ -2364,8 +2364,8 @@ tp_first_run_node_cmp (const void *pa, const void *pb)\n {\n   const cgraph_node *a = *(const cgraph_node * const *) pa;\n   const cgraph_node *b = *(const cgraph_node * const *) pb;\n-  gcov_type tp_first_run_a = a->tp_first_run;\n-  gcov_type tp_first_run_b = b->tp_first_run;\n+  unsigned int tp_first_run_a = a->tp_first_run;\n+  unsigned int tp_first_run_b = b->tp_first_run;\n \n   if (!opt_for_fn (a->decl, flag_profile_reorder_functions)\n       || a->no_reorder)\n@@ -2378,14 +2378,10 @@ tp_first_run_node_cmp (const void *pa, const void *pb)\n     return a->order - b->order;\n \n   /* Functions with time profile must be before these without profile.  */\n-  if (!tp_first_run_a || !tp_first_run_b)\n-    return tp_first_run_b ? 1 : -1;\n+  tp_first_run_a = (tp_first_run_a - 1) & INT_MAX;\n+  tp_first_run_b = (tp_first_run_b - 1) & INT_MAX;\n \n-  /* Watch for overlflow - tp_first_run is 64bit.  */\n-  if (tp_first_run_a > tp_first_run_b)\n-    return 1;\n-  else\n-    return -1;\n+  return tp_first_run_a - tp_first_run_b;\n }\n \n /* Expand all functions that must be output.\n@@ -2425,43 +2421,45 @@ expand_all_functions (void)\n           order[new_order_pos++] = order[i];\n       }\n \n-  /* Output functions in RPO so callers get optimized before callees.  This\n-     makes ipa-ra and other propagators to work.\n-     FIXME: This is far from optimal code layout.  */\n-  for (i = new_order_pos - 1; i >= 0; i--)\n+  /* First output functions with time profile in specified order.  */\n+  qsort (tp_first_run_order, tp_first_run_order_pos,\n+\t sizeof (cgraph_node *), tp_first_run_node_cmp);\n+  for (i = 0; i < tp_first_run_order_pos; i++)\n     {\n-      node = order[i];\n+      node = tp_first_run_order[i];\n \n       if (node->process)\n \t{\n \t  expanded_func_count++;\n+\t  profiled_func_count++;\n+\n+\t  if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file,\n+\t\t     \"Time profile order in expand_all_functions:%s:%d\\n\",\n+\t\t     node->asm_name (), node->tp_first_run);\n \t  node->process = 0;\n \t  node->expand ();\n \t}\n     }\n-  qsort (tp_first_run_order, tp_first_run_order_pos,\n-\t sizeof (cgraph_node *), tp_first_run_node_cmp);\n-  for (i = 0; i < tp_first_run_order_pos; i++)\n+\n+  /* Output functions in RPO so callees get optimized before callers.  This\n+     makes ipa-ra and other propagators to work.\n+     FIXME: This is far from optimal code layout.  */\n+  for (i = new_order_pos - 1; i >= 0; i--)\n     {\n-      node = tp_first_run_order[i];\n+      node = order[i];\n \n       if (node->process)\n \t{\n \t  expanded_func_count++;\n-\t  profiled_func_count++;\n-\n-\t  if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file,\n-\t\t     \"Time profile order in expand_all_functions:%s:%\" PRId64\n-\t\t     \"\\n\", node->asm_name (), (int64_t) node->tp_first_run);\n \t  node->process = 0;\n \t  node->expand ();\n \t}\n     }\n \n-    if (dump_file)\n-      fprintf (dump_file, \"Expanded functions with time profile (%s):%u/%u\\n\",\n-               main_input_filename, profiled_func_count, expanded_func_count);\n+  if (dump_file)\n+    fprintf (dump_file, \"Expanded functions with time profile (%s):%u/%u\\n\",\n+\t     main_input_filename, profiled_func_count, expanded_func_count);\n \n   if (symtab->dump_file && tp_first_run_order_pos)\n     fprintf (symtab->dump_file, \"Expanded functions with time profile:%u/%u\\n\","}, {"sha": "9f974afb123dd13c08f1875608b19dc0bc161e67", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=59c7b29e9a5b3a692efae81541985be800cdbf0c", "patch": "@@ -1,11 +1,16 @@\n 2019-12-07  Jan Hubicka  <hubicka@ucw.cz>\n \n+\t* lto-partition.c (lto_balanced_map): Fix printing of tp_first_run.\n+\n+2019-12-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n \t* lto-partition.c (node_cmp): Turn into simple order comparsions.\n \t(varpool_node_cmp): Remove.\n \t(add_sorted_nodes): Use node_cmp.\n \t(lto_balanced_map): Use tp_first_run_node_cmp.\n \n-/bin/bash: :q: command not found\n+2019-11-25  Joseph Myers  <joseph@codesourcery.com>\n+\n \tPR c/91985\n \t* lto-lang.c (lto_type_for_mode): Handle decimal floating-point\n \ttypes being NULL_TREE."}, {"sha": "3c67b8a94359f148dea191ee708a5662db01fe2d", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=59c7b29e9a5b3a692efae81541985be800cdbf0c", "patch": "@@ -514,11 +514,11 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n   if (dump_file)\n     {\n       for (unsigned i = 0; i < order.length (); i++)\n-\tfprintf (dump_file, \"Balanced map symbol order:%s:%\" PRId64 \"\\n\",\n-\t\t order[i]->name (), (int64_t) order[i]->tp_first_run);\n+\tfprintf (dump_file, \"Balanced map symbol order:%s:%u\\n\",\n+\t\t order[i]->name (), order[i]->tp_first_run);\n       for (unsigned i = 0; i < noreorder.length (); i++)\n-\tfprintf (dump_file, \"Balanced map symbol no_reorder:%s:%\" PRId64 \"\\n\",\n-\t\t noreorder[i]->name (), (int64_t) noreorder[i]->tp_first_run);\n+\tfprintf (dump_file, \"Balanced map symbol no_reorder:%s:%u\\n\",\n+\t\t noreorder[i]->name (), noreorder[i]->tp_first_run);\n     }\n \n   /* Collect all variables that should not be reordered.  */"}, {"sha": "e300ba6d58932a6a1b2ca851003608f71460ac5c", "filename": "gcc/profile.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c7b29e9a5b3a692efae81541985be800cdbf0c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=59c7b29e9a5b3a692efae81541985be800cdbf0c", "patch": "@@ -871,11 +871,18 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n       if (hist->type == HIST_TYPE_TIME_PROFILE)\n         {\n \t  node = cgraph_node::get (hist->fun->decl);\n-\t  node->tp_first_run = hist->hvalue.counters[0];\n+\t  if (hist->hvalue.counters[0] >= 0\n+\t      && hist->hvalue.counters[0] < INT_MAX / 2)\n+\t    node->tp_first_run = hist->hvalue.counters[0];\n+\t  else\n+\t    {\n+\t      if (flag_profile_correction)\n+\t\terror (\"corrupted profile info: invalid time profile\");\n+\t      node->tp_first_run = 0;\n+\t    }\n \n           if (dump_file)\n-            fprintf (dump_file, \"Read tp_first_run: %\" PRId64 \"\\n\",\n-\t\t     (int64_t) node->tp_first_run);\n+            fprintf (dump_file, \"Read tp_first_run: %d\\n\", node->tp_first_run);\n         }\n     }\n "}]}