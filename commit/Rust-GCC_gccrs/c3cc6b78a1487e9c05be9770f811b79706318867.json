{"sha": "c3cc6b78a1487e9c05be9770f811b79706318867", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNjYzZiNzhhMTQ4N2U5YzA1YmU5NzcwZjgxMWI3OTcwNjMxODg2Nw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-08-26T18:18:19Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-08-26T18:18:19Z"}, "message": "s390-protos.h (s390_function_prologue, [...]): Remove.\n\n\t* config/s390/s390-protos.h (s390_function_prologue,\n\ts390_function_epilogue): Remove.\n\tconfig/s390/s390.c (s390_function_prologue, s390_function_epilogue,\n\tTARGET_ASM_FUNCTION_PROLOGUE, TARGET_ASM_FUNCTION_EPILOGUE): Remove.\n\n\tconfig/s390/s390.c (s390_machine_dependent_recorg): New function.\n\tconfig/s390/s390-protos.h (s390_machine_dependent_reorg): Declare it.\n\tconfig/s390/s390.h (MACHINE_DEPENDENT_REORG): Call it.\n\tconfig/s390/s390.c (s390_split_branches, s390_chunkify_pool): Adapt\n\tto being called from MACHINE_DEPENDENT_REORG.  Update regs_ever_live.\n\n\tconfig/s390/s390.c (s390_frame_info): Inline save_fprs_p.  Always\n\tassume BASE_REGISTER and RETURN_REGNUM need to be saved.\n\t(s390_emit_prologue): Assume RETURN_REGNUM to be saved iff\n\tfunction is not a leaf function.  Use save_gprs and restore_gprs.\n\t(s390_emit_epilogue): Likewise.\n\t(save_gprs, restore_gprs): New functions.\n\t(struct s390_frame): Remove return_reg_saved_p member.\n\t(save_fprs_p): Remove.\n\t(s390_optimize_prolog): New function.\n\t(s390_legitimate_reload_constant): Remove now unnecessary check.\n\n\t(s390_function_count): Remove.\n\t(s390_output_symbolic_const): Replace s390_function_count by\n\tcurrent_function_funcdef_no.\n\t(s390_output_constant_pool): Likewise.\n\n\t(legitimize_pic_address): Use regs_ever_live to track PIC register\n\tinstead of current_function_uses_pic_offset_table.\n\t(s390_emit_prologue): Likewise.\n\tconfig/s390/s390.md (\"call\", \"call_value\"): Likewise.\n\nFrom-SVN: r56584", "tree": {"sha": "9c119df126330ad4a35fad49d9f309abceb20145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c119df126330ad4a35fad49d9f309abceb20145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3cc6b78a1487e9c05be9770f811b79706318867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3cc6b78a1487e9c05be9770f811b79706318867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3cc6b78a1487e9c05be9770f811b79706318867", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3cc6b78a1487e9c05be9770f811b79706318867/comments", "author": null, "committer": null, "parents": [{"sha": "3f66218653d7905c186e050208545d9f8d0b020f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f66218653d7905c186e050208545d9f8d0b020f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f66218653d7905c186e050208545d9f8d0b020f"}], "stats": {"total": 569, "additions": 363, "deletions": 206}, "files": [{"sha": "4192aad6bc7ea8a62db5703e6bd307a359425bc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3cc6b78a1487e9c05be9770f811b79706318867", "patch": "@@ -1,3 +1,37 @@\n+2002-08-26  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_function_prologue, \n+\ts390_function_epilogue): Remove.\n+\tconfig/s390/s390.c (s390_function_prologue, s390_function_epilogue,\n+\tTARGET_ASM_FUNCTION_PROLOGUE, TARGET_ASM_FUNCTION_EPILOGUE): Remove.\n+\n+\tconfig/s390/s390.c (s390_machine_dependent_recorg): New function.\n+\tconfig/s390/s390-protos.h (s390_machine_dependent_reorg): Declare it.\n+\tconfig/s390/s390.h (MACHINE_DEPENDENT_REORG): Call it.\n+\tconfig/s390/s390.c (s390_split_branches, s390_chunkify_pool): Adapt\n+\tto being called from MACHINE_DEPENDENT_REORG.  Update regs_ever_live.\n+\n+\tconfig/s390/s390.c (s390_frame_info): Inline save_fprs_p.  Always \n+\tassume BASE_REGISTER and RETURN_REGNUM need to be saved.\n+\t(s390_emit_prologue): Assume RETURN_REGNUM to be saved iff\n+\tfunction is not a leaf function.  Use save_gprs and restore_gprs.\n+\t(s390_emit_epilogue): Likewise.\n+\t(save_gprs, restore_gprs): New functions.\n+\t(struct s390_frame): Remove return_reg_saved_p member.\n+\t(save_fprs_p): Remove.\n+\t(s390_optimize_prolog): New function.\n+\t(s390_legitimate_reload_constant): Remove now unnecessary check.\n+\n+\t(s390_function_count): Remove.\n+\t(s390_output_symbolic_const): Replace s390_function_count by\n+\tcurrent_function_funcdef_no.\n+\t(s390_output_constant_pool): Likewise.\n+\n+\t(legitimize_pic_address): Use regs_ever_live to track PIC register\n+\tinstead of current_function_uses_pic_offset_table.\n+\t(s390_emit_prologue): Likewise.\n+\tconfig/s390/s390.md (\"call\", \"call_value\"): Likewise.\n+\n 2002-08-26  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* c-opts.c (find_opt): Don't complain about wrong languages"}, {"sha": "c44ffb33234d20d23efb1a4a6ed94625fcbf1584", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=c3cc6b78a1487e9c05be9770f811b79706318867", "patch": "@@ -24,8 +24,6 @@ Boston, MA 02111-1307, USA.  */\n extern void optimization_options PARAMS ((int, int));\n extern void override_options PARAMS ((void));\n extern int s390_arg_frame_offset PARAMS ((void));\n-extern void s390_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-extern void s390_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n extern void s390_emit_prologue PARAMS ((void));\n extern void s390_emit_epilogue PARAMS ((void));\n extern void s390_function_profiler PARAMS ((FILE *, int));\n@@ -72,6 +70,7 @@ extern void s390_trampoline_template PARAMS ((FILE *));\n extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern rtx s390_gen_rtx_const_DI PARAMS ((int, int));\n extern rtx s390_simplify_dwarf_addr PARAMS ((rtx));\n+extern void s390_machine_dependent_reorg PARAMS ((rtx));\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "6ee09c542d0ff99f2538af4898113732498617f3", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 319, "deletions": 192, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=c3cc6b78a1487e9c05be9770f811b79706318867", "patch": "@@ -61,12 +61,6 @@ static void s390_encode_section_info PARAMS ((tree, int));\n #undef  TARGET_ASM_INTEGER\n #define TARGET_ASM_INTEGER s390_assemble_integer\n \n-#undef  TARGET_ASM_FUNCTION_PROLOGUE \n-#define TARGET_ASM_FUNCTION_PROLOGUE s390_function_prologue\n-\n-#undef  TARGET_ASM_FUNCTION_EPILOGUE \n-#define TARGET_ASM_FUNCTION_EPILOGUE s390_function_epilogue\n-\n #undef  TARGET_ASM_OPEN_PAREN\n #define TARGET_ASM_OPEN_PAREN \"\"\n \n@@ -92,9 +86,6 @@ extern int reload_completed;\n /* The alias set for prologue/epilogue register save/restore.  */\n static int s390_sr_alias_set = 0;\n \n-/* Function count for creating unique internal labels in a compile unit.  */\n-int  s390_function_count = 0;\n-\n /* Save information from a \"cmpxx\" operation until the branch or scc is\n    emitted.  */\n rtx s390_compare_op0, s390_compare_op1;\n@@ -121,7 +112,6 @@ struct s390_address\n struct s390_frame\n {\n   int frame_pointer_p;\n-  int return_reg_saved_p;\n   int save_fprs_p;\n   int first_save_gpr;\n   int first_restore_gpr;\n@@ -143,11 +133,13 @@ static void s390_split_branches PARAMS ((void));\n static void find_constant_pool_ref PARAMS ((rtx, rtx *));\n static void replace_constant_pool_ref PARAMS ((rtx *, rtx, rtx));\n static void s390_chunkify_pool PARAMS ((void));\n-static int save_fprs_p PARAMS ((void));\n+static void s390_optimize_prolog PARAMS ((void));\n static int find_unused_clobbered_reg PARAMS ((void));\n static void s390_frame_info PARAMS ((struct s390_frame *));\n static rtx save_fpr PARAMS ((rtx, int, int));\n static rtx restore_fpr PARAMS ((rtx, int, int));\n+static rtx save_gprs PARAMS ((rtx, int, int, int));\n+static rtx restore_gprs PARAMS ((rtx, int, int, int));\n static int s390_function_arg_size PARAMS ((enum machine_mode, tree));\n \n  \n@@ -1269,15 +1261,6 @@ legitimate_reload_constant_p (op)\n       && larl_operand (op, VOIDmode))\n     return 1;\n \n-  /* If reload is completed, and we do not already have a\n-     literal pool, and OP must be forced to the literal \n-     pool, then something must have gone wrong earlier.\n-     We *cannot* force the constant any more, because the\n-     prolog generation already decided we don't need to \n-     set up the base register.  */\n-  if (reload_completed && !regs_ever_live[BASE_REGISTER])\n-    abort ();\n-\n   /* Everything else cannot be handled without reload.  */\n   return 0;\n }\n@@ -1826,7 +1809,8 @@ legitimize_pic_address (orig, reg)\n           /* Assume GOT offset < 4k.  This is handled the same way\n              in both 31- and 64-bit code (@GOT12).  */\n \n-          current_function_uses_pic_offset_table = 1;\n+\t  if (reload_in_progress || reload_completed)\n+\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n           new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 110);\n           new = gen_rtx_CONST (Pmode, new);\n@@ -1859,7 +1843,8 @@ legitimize_pic_address (orig, reg)\n \n           rtx temp = gen_reg_rtx (Pmode);\n \n-          current_function_uses_pic_offset_table = 1;\n+\t  if (reload_in_progress || reload_completed)\n+\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n           addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, addr), 112);\n           addr = gen_rtx_CONST (SImode, addr);\n@@ -2218,7 +2203,7 @@ s390_output_symbolic_const (file, x)\n         {\n         case 100:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"-.LT%X\", s390_function_count);\n+          fprintf (file, \"-.LT%d\", current_function_funcdef_no);\n \t  break;\n \tcase 110:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n@@ -2238,7 +2223,7 @@ s390_output_symbolic_const (file, x)\n \t  break;\n \tcase 114:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"@PLT-.LT%X\", s390_function_count);\n+          fprintf (file, \"@PLT-.LT%d\", current_function_funcdef_no);\n \t  break;\n \tdefault:\n \t  output_operand_lossage (\"invalid UNSPEC as operand (2)\");\n@@ -2638,6 +2623,10 @@ s390_split_branches ()\n   if (TARGET_64BIT)\n     return;\n \n+  /* We need correct insn addresses.  */\n+\n+  shorten_branches (get_insns ());\n+\n   /* Find all branches that exceed 64KB, and split them.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -2668,6 +2657,8 @@ s390_split_branches ()\n       if (get_attr_length (insn) == 4)\n \tcontinue;\n \n+      regs_ever_live[RETURN_REGNUM] = 1;\n+\n       if (flag_pic)\n \t{\n \t  target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, label), 100);\n@@ -3061,6 +3052,14 @@ s390_chunkify_pool ()\n   if (get_pool_size () < S390_POOL_CHUNK_MAX)\n     return;\n \n+  if (!TARGET_64BIT)\n+    regs_ever_live[RETURN_REGNUM] = 1;\n+\n+  /* We need correct insn addresses.  */\n+\n+  shorten_branches (get_insns ());\n+\n+\n   /* Scan all insns and move literals to pool chunks.\n      Replace all occurrances of literal pool references\n      by explicit references to pool chunk entries.  */\n@@ -3352,17 +3351,17 @@ s390_output_constant_pool (file)\n     {\n       if (TARGET_64BIT)\n \t{\n-\t  fprintf (file, \"\\tlarl\\t%s,.LT%X\\n\", reg_names[BASE_REGISTER],\n-\t\t   s390_function_count);\n+\t  fprintf (file, \"\\tlarl\\t%s,.LT%d\\n\", reg_names[BASE_REGISTER],\n+\t\t   current_function_funcdef_no);\n \t  readonly_data_section ();\n \t  ASM_OUTPUT_ALIGN (file, 3);\n \t}\n       else\n \t{\n-\t  fprintf (file, \"\\tbras\\t%s,.LTN%X\\n\", reg_names[BASE_REGISTER],\n-\t\t   s390_function_count);\n+\t  fprintf (file, \"\\tbras\\t%s,.LTN%d\\n\", reg_names[BASE_REGISTER],\n+\t\t   current_function_funcdef_no);\n \t}\n-      fprintf (file, \".LT%X:\\n\", s390_function_count);\n+      fprintf (file, \".LT%d:\\n\", current_function_funcdef_no);\n \n       s390_pool_count = 0;\n       output_constant_pool (current_function_name, current_function_decl);\n@@ -3371,27 +3370,159 @@ s390_output_constant_pool (file)\n       if (TARGET_64BIT)\n \tfunction_section (current_function_decl);\n       else\n-        fprintf (file, \".LTN%X:\\n\", s390_function_count);\n+        fprintf (file, \".LTN%d:\\n\", current_function_funcdef_no);\n     }\n }\n \n \n-/* Return true if floating point registers need to be saved.  */\n+/* Rework the prolog/epilog to avoid saving/restoring\n+   registers unnecessarily.  */\n \n-static int \n-save_fprs_p ()\n+static void\n+s390_optimize_prolog ()\n {\n-  int i;\n-  if (!TARGET_64BIT)\n-    return 0;\n-  for (i=24; i<=31; i++) \n+  int save_first, save_last, restore_first, restore_last;\n+  int i, j;\n+  rtx insn, new_insn, next_insn;\n+\n+  /* Find first and last gpr to be saved.  */\n+  \n+  for (i = 6; i < 16; i++)\n+    if (regs_ever_live[i])\n+      break;\n+\n+  for (j = 15; j > i; j--)\n+    if (regs_ever_live[j])\n+      break;\n+\n+  if (i == 16)\n     {\n-      if (regs_ever_live[i] == 1)\n-\treturn 1;\n+      /* Nothing to save/restore.  */\n+      save_first = restore_first = -1;\n+      save_last = restore_last = -1;\n     }\n-  return 0;\n+  else\n+    {\n+      /* Save/restore from i to j.  */\n+      save_first = restore_first = i;\n+      save_last = restore_last = j;\n+    }\n+\n+  /* Varargs functions need to save gprs 2 to 6.  */\n+  if (current_function_stdarg)\n+    {\n+      save_first = 2;\n+      if (save_last < 6)\n+        save_last = 6;\n+    }\n+\n+\n+  /* If all special registers are in fact used, there's nothing we\n+     can do, so no point in walking the insn list.  */\n+  if (i <= BASE_REGISTER && j >= BASE_REGISTER\n+      && i <= RETURN_REGNUM && j >= RETURN_REGNUM)\n+    return;\n+\n+\n+  /* Search for prolog/epilog insns and replace them.  */\n+\n+  for (insn = get_insns (); insn; insn = next_insn)\n+    {\n+      int first, last, off;\n+      rtx set, base, offset;\n+\n+      next_insn = NEXT_INSN (insn);\n+\n+      if (GET_CODE (insn) != INSN)\n+\tcontinue;\n+      if (GET_CODE (PATTERN (insn)) != PARALLEL)\n+\tcontinue;\n+\n+      if (store_multiple_operation (PATTERN (insn), VOIDmode))\n+\t{\n+\t  set = XVECEXP (PATTERN (insn), 0, 0);\n+\t  first = REGNO (SET_SRC (set));\n+\t  last = first + XVECLEN (PATTERN (insn), 0) - 1;\n+\t  offset = const0_rtx;\n+\t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n+\t  off = INTVAL (offset) - first * UNITS_PER_WORD;\n+\n+\t  if (GET_CODE (base) != REG || off < 0)\n+\t    continue;\n+\t  if (first > BASE_REGISTER && first > RETURN_REGNUM)\n+\t    continue;\n+\t  if (last < BASE_REGISTER && last < RETURN_REGNUM)\n+\t    continue;\n+\n+\t  if (save_first != -1)\n+\t    {\n+\t      new_insn = save_gprs (base, off, save_first, save_last);\n+\t      new_insn = emit_insn_before (new_insn, insn);\n+\t      INSN_ADDRESSES_NEW (new_insn, -1);\n+\t    }\n+\n+\t  remove_insn (insn);\n+\t}\n+\n+      if (load_multiple_operation (PATTERN (insn), VOIDmode))\n+\t{\n+\t  set = XVECEXP (PATTERN (insn), 0, 0);\n+\t  first = REGNO (SET_DEST (set));\n+\t  last = first + XVECLEN (PATTERN (insn), 0) - 1;\n+\t  offset = const0_rtx;\n+\t  base = eliminate_constant_term (XEXP (SET_SRC (set), 0), &offset);\n+\t  off = INTVAL (offset) - first * UNITS_PER_WORD;\n+\n+\t  if (GET_CODE (base) != REG || off < 0)\n+\t    continue;\n+\t  if (first > BASE_REGISTER && first > RETURN_REGNUM)\n+\t    continue;\n+\t  if (last < BASE_REGISTER && last < RETURN_REGNUM)\n+\t    continue;\n+\n+\t  if (restore_first != -1)\n+\t    {\n+\t      new_insn = restore_gprs (base, off, restore_first, restore_last);\n+\t      new_insn = emit_insn_before (new_insn, insn);\n+\t      INSN_ADDRESSES_NEW (new_insn, -1);\n+\t    }\n+\n+\t  remove_insn (insn);\n+\t}\n+    }\n+}\n+\n+/* Perform machine-dependent processing.  */\n+\n+void\n+s390_machine_dependent_reorg (first)\n+     rtx first ATTRIBUTE_UNUSED;\n+{\n+  struct s390_frame frame;\n+  s390_frame_info (&frame);\n+\n+  /* Recompute regs_ever_live data for special registers.  */\n+  regs_ever_live[BASE_REGISTER] = 0;\n+  regs_ever_live[RETURN_REGNUM] = 0;\n+  regs_ever_live[STACK_POINTER_REGNUM] = frame.frame_size > 0;\n+\n+  /* If there is (possibly) any pool entry, we need to\n+     load the base register.  \n+     ??? FIXME: this should be more precise.  */\n+  if (get_pool_size ())\n+    regs_ever_live[BASE_REGISTER] = 1;\n+\n+  /* In non-leaf functions, the prolog/epilog code relies \n+     on RETURN_REGNUM being saved in any case.  */\n+  if (!current_function_is_leaf)\n+    regs_ever_live[RETURN_REGNUM] = 1;\n+\n+  s390_chunkify_pool ();\n+  s390_split_branches ();\n+  s390_optimize_prolog ();\n }\n \n+\n /* Find first call clobbered register unsused in a function.\n    This could be used as base register in a leaf function\n    or for holding the return address before epilogue.  */\n@@ -3412,14 +3543,22 @@ static void\n s390_frame_info (frame)\n      struct s390_frame *frame;\n {\n+  char gprs_ever_live[16];\n   int i, j;\n   HOST_WIDE_INT fsize = get_frame_size ();\n \n   if (fsize > 0x7fff0000)\n     fatal_error (\"Total size of local variables exceeds architecture limit.\");\n \n   /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n-  frame->save_fprs_p = save_fprs_p ();\n+  frame->save_fprs_p = 0;\n+  if (TARGET_64BIT)\n+    for (i = 24; i < 32; i++) \n+      if (regs_ever_live[i])\n+\t{\n+          frame->save_fprs_p = 1;\n+\t  break;\n+\t}\n \n   frame->frame_size = fsize + frame->save_fprs_p * 64;\n \n@@ -3431,66 +3570,41 @@ s390_frame_info (frame)\n       || current_function_stdarg)\n     frame->frame_size += STARTING_FRAME_OFFSET;\n \n-  /* If we need to allocate a frame, the stack pointer is changed.  */ \n-\n-  if (frame->frame_size > 0)\n-    regs_ever_live[STACK_POINTER_REGNUM] = 1;\n-\n-  /* If the literal pool might overflow, the return register might\n-     be used as temp literal pointer.  */\n-\n-  if (!TARGET_64BIT && get_pool_size () >= S390_POOL_CHUNK_MAX / 2)\n-    regs_ever_live[RETURN_REGNUM] = 1;\n-\n-  /* If there is (possibly) any pool entry, we need to \n-     load base register.  */\n-\n-  if (get_pool_size () \n-      || !CONST_OK_FOR_LETTER_P (frame->frame_size, 'K')\n-      || (!TARGET_64BIT && current_function_uses_pic_offset_table))\n-    regs_ever_live[BASE_REGISTER] = 1; \n-\n-  /* If we need the GOT pointer, remember to save/restore it.  */\n-\n-  if (current_function_uses_pic_offset_table)\n-    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n-\n   /* Frame pointer needed.   */\n     \n   frame->frame_pointer_p = frame_pointer_needed;\n \n-  /* Find first and last gpr to be saved.  */\n+  /* Find first and last gpr to be saved.  Note that at this point,\n+     we assume the return register and the base register always\n+     need to be saved.  This is done because the usage of these\n+     register might change even after the prolog was emitted.\n+     If it turns out later that we really don't need them, the\n+     prolog/epilog code is modified again.  */\n+\n+  for (i = 0; i < 16; i++)\n+    gprs_ever_live[i] = regs_ever_live[i];\n+\n+  gprs_ever_live[BASE_REGISTER] = 1;\n+  gprs_ever_live[RETURN_REGNUM] = 1;\n+  gprs_ever_live[STACK_POINTER_REGNUM] = frame->frame_size > 0;\n   \n   for (i = 6; i < 16; i++)\n-    if (regs_ever_live[i])\n+    if (gprs_ever_live[i])\n       break;\n \n   for (j = 15; j > i; j--)\n-    if (regs_ever_live[j])\n+    if (gprs_ever_live[j])\n       break;\n-  \n-  if (i == 16)\n-    {\n-      /* Nothing to save / restore.  */ \n-      frame->first_save_gpr = -1;\n-      frame->first_restore_gpr = -1;\n-      frame->last_save_gpr = -1;\n-      frame->return_reg_saved_p = 0;\n-    }\n-  else\n-    {\n-      /* Save / Restore from gpr i to j.  */\n-      frame->first_save_gpr = i;\n-      frame->first_restore_gpr = i;\n-      frame->last_save_gpr  = j;\n-      frame->return_reg_saved_p = (j >= RETURN_REGNUM && i <= RETURN_REGNUM);\n-    }\n \n+\n+  /* Save / Restore from gpr i to j.  */\n+  frame->first_save_gpr = i;\n+  frame->first_restore_gpr = i;\n+  frame->last_save_gpr  = j;\n+\n+  /* Varargs functions need to save gprs 2 to 6.  */\n   if (current_function_stdarg)\n-    {\n-      /* Varargs function need to save from gpr 2 to gpr 15.  */\n-      frame->first_save_gpr = 2;\n-    }\n+    frame->first_save_gpr = 2;\n }\n \n /* Return offset between argument pointer and frame pointer \n@@ -3540,30 +3654,118 @@ restore_fpr (base, offset, regnum)\n   return emit_move_insn (gen_rtx_REG (DFmode, regnum), addr);\n }\n \n-/* Output the function prologue assembly code to the \n-   stdio stream FILE.  The local frame size is passed\n-   in LSIZE.  */\n+/* Generate insn to save registers FIRST to LAST into\n+   the register save area located at offset OFFSET \n+   relative to register BASE.  */\n \n-void\n-s390_function_prologue (file, lsize)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT lsize ATTRIBUTE_UNUSED;\n+static rtx\n+save_gprs (base, offset, first, last)\n+     rtx base;\n+     int offset;\n+     int first;\n+     int last;\n {\n-  s390_chunkify_pool ();\n-  s390_split_branches ();\n+  rtx addr, insn, note;\n+  int i;\n+\n+  addr = plus_constant (base, offset + first * UNITS_PER_WORD);\n+  addr = gen_rtx_MEM (Pmode, addr);\n+  set_mem_alias_set (addr, s390_sr_alias_set);\n+\n+  /* Special-case single register.  */\n+  if (first == last)\n+    {\n+      if (TARGET_64BIT)\n+        insn = gen_movdi (addr, gen_rtx_REG (Pmode, first));\n+      else\n+        insn = gen_movsi (addr, gen_rtx_REG (Pmode, first));\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      return insn;\n+    }\n+\n+\n+  insn = gen_store_multiple (addr,\n+\t\t\t     gen_rtx_REG (Pmode, first),\n+\t\t\t     GEN_INT (last - first + 1));\n+\n+\n+  /* We need to set the FRAME_RELATED flag on all SETs\n+     inside the store-multiple pattern.\n+\n+     However, we must not emit DWARF records for registers 2..5\n+     if they are stored for use by variable arguments ...  \n+\n+     ??? Unfortunately, it is not enough to simply not the the\n+     FRAME_RELATED flags for those SETs, because the first SET\n+     of the PARALLEL is always treated as if it had the flag\n+     set, even if it does not.  Therefore we emit a new pattern\n+     without those registers as REG_FRAME_RELATED_EXPR note.  */\n+\n+  if (first >= 6)\n+    {\n+      rtx pat = PATTERN (insn);\n+\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n+\t  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else if (last >= 6)\n+    {\n+      addr = plus_constant (base, offset + 6 * UNITS_PER_WORD);\n+      note = gen_store_multiple (gen_rtx_MEM (Pmode, addr), \n+\t\t\t\t gen_rtx_REG (Pmode, 6),\n+\t\t\t\t GEN_INT (last - 6 + 1));\n+      note = PATTERN (note);\n+\n+      REG_NOTES (insn) =\n+\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, \n+\t\t\t   note, REG_NOTES (insn));\n+\n+      for (i = 0; i < XVECLEN (note, 0); i++)\n+\tif (GET_CODE (XVECEXP (note, 0, i)) == SET)\n+\t  RTX_FRAME_RELATED_P (XVECEXP (note, 0, i)) = 1;\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  return insn;\n }\n \n-/* Output the function epilogue assembly code to the \n-   stdio stream FILE.  The local frame size is passed\n-   in LSIZE.  */\n+/* Generate insn to restore registers FIRST to LAST from\n+   the register save area located at offset OFFSET \n+   relative to register BASE.  */\n \n-void\n-s390_function_epilogue (file, lsize)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT lsize ATTRIBUTE_UNUSED;\n+static rtx\n+restore_gprs (base, offset, first, last)\n+     rtx base;\n+     int offset;\n+     int first;\n+     int last;\n {\n-  current_function_uses_pic_offset_table = 0;\n-  s390_function_count++;\n+  rtx addr, insn;\n+\n+  addr = plus_constant (base, offset + first * UNITS_PER_WORD);\n+  addr = gen_rtx_MEM (Pmode, addr);\n+  set_mem_alias_set (addr, s390_sr_alias_set);\n+\n+  /* Special-case single register.  */\n+  if (first == last)\n+    {\n+      if (TARGET_64BIT)\n+        insn = gen_movdi (gen_rtx_REG (Pmode, first), addr);\n+      else\n+        insn = gen_movsi (gen_rtx_REG (Pmode, first), addr);\n+\n+      return insn;\n+    }\n+\n+  insn = gen_load_multiple (gen_rtx_REG (Pmode, first),\n+\t\t\t    addr,\n+\t\t\t    GEN_INT (last - first + 1));\n+  return insn;\n }\n \n /* Expand the prologue into a bunch of separate insns.  */\n@@ -3582,7 +3784,7 @@ s390_emit_prologue ()\n \n   /* Choose best register to use for temp use within prologue.  */\n   \n-  if (frame.return_reg_saved_p\n+  if (!current_function_is_leaf\n       && !has_hard_reg_initial_val (Pmode, RETURN_REGNUM)\n       && get_pool_size () < S390_POOL_CHUNK_MAX / 2)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n@@ -3591,69 +3793,9 @@ s390_emit_prologue ()\n \n   /* Save call saved gprs.  */\n \n-  if (frame.first_save_gpr != -1)\n-    {\n-      addr = plus_constant (stack_pointer_rtx, \n-\t\t\t    frame.first_save_gpr * UNITS_PER_WORD);\n-      addr = gen_rtx_MEM (Pmode, addr);\n-      set_mem_alias_set (addr, s390_sr_alias_set);\n-\n-      if (frame.first_save_gpr != frame.last_save_gpr )\n-\t{\n-\t  insn = emit_insn (gen_store_multiple (addr,\n-\t\t\t      gen_rtx_REG (Pmode, frame.first_save_gpr),\n-\t\t\t      GEN_INT (frame.last_save_gpr \n-\t\t\t\t       - frame.first_save_gpr + 1)));\n-\n-\t  /* We need to set the FRAME_RELATED flag on all SETs\n-\t     inside the store-multiple pattern.\n-\n-\t     However, we must not emit DWARF records for registers 2..5\n-\t     if they are stored for use by variable arguments ...  \n-\n-\t     ??? Unfortunately, it is not enough to simply not the the\n-\t     FRAME_RELATED flags for those SETs, because the first SET\n-\t     of the PARALLEL is always treated as if it had the flag\n-\t     set, even if it does not.  Therefore we emit a new pattern\n-\t     without those registers as REG_FRAME_RELATED_EXPR note.  */\n-\n-\t  if (frame.first_save_gpr >= 6)\n-\t    {\n-\t      rtx pat = PATTERN (insn);\n-\n-\t      for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n-\t\t  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n-\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\t  else if (frame.last_save_gpr >= 6)\n-\t    {\n-\t      rtx note, naddr;\n-\t      naddr = plus_constant (stack_pointer_rtx, 6 * UNITS_PER_WORD);\n-\t      note = gen_store_multiple (gen_rtx_MEM (Pmode, naddr), \n-\t\t\t\t\t gen_rtx_REG (Pmode, 6),\n-\t\t\t\t\t GEN_INT (frame.last_save_gpr - 6 + 1));\n-\t      note = PATTERN (note);\n-\n-\t      REG_NOTES (insn) =\n-\t\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, \n-\t\t\t\t   note, REG_NOTES (insn));\n-\n-\t      for (i = 0; i < XVECLEN (note, 0); i++)\n-\t\tif (GET_CODE (XVECEXP (note, 0, i)) == SET)\n-\t\t  RTX_FRAME_RELATED_P (XVECEXP (note, 0, i)) = 1;\n-\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  insn = emit_move_insn (addr, \n-\t\t\t\t gen_rtx_REG (Pmode, frame.first_save_gpr));\n-          RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n-    }\n+  insn = save_gprs (stack_pointer_rtx, 0, \n+\t\t    frame.first_save_gpr, frame.last_save_gpr);\n+  emit_insn (insn);\n \n   /* Dump constant pool and set constant pool register (13).  */\n  \n@@ -3765,7 +3907,7 @@ s390_emit_prologue ()\n \n   /* Set up got pointer, if needed.  */\n   \n-  if (current_function_uses_pic_offset_table)\n+  if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     {\n       rtx got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n       SYMBOL_REF_FLAG (got_symbol) = 1;\n@@ -3912,7 +4054,7 @@ s390_emit_epilogue ()\n \n   if (frame.first_restore_gpr != -1)\n     {\n-      rtx addr;\n+      rtx insn, addr;\n       int i;\n \n       /* Check for global register and save them \n@@ -3943,8 +4085,7 @@ s390_emit_epilogue ()\n       /* Fetch return address from stack before load multiple,\n \t this will do good for scheduling.  */\n \n-      if (frame.last_save_gpr >= RETURN_REGNUM \n-\t  && frame.first_restore_gpr < RETURN_REGNUM)\n+      if (!current_function_is_leaf)\n \t{\n \t  int return_regnum = find_unused_clobbered_reg();\n \t  if (!return_regnum)\n@@ -3964,23 +4105,9 @@ s390_emit_epilogue ()\n \n       emit_insn (gen_blockage());      \n \n-      addr = plus_constant (frame_pointer, \n-\t\t\t    offset + frame.first_restore_gpr * UNITS_PER_WORD);\n-      addr = gen_rtx_MEM (Pmode, addr);\n-      set_mem_alias_set (addr, s390_sr_alias_set);\n-\n-      if (frame.first_restore_gpr != frame.last_save_gpr)\n-\t{\n-\t  emit_insn (gen_load_multiple (\n-\t\t       gen_rtx_REG (Pmode, frame.first_restore_gpr),\n-                       addr,\n-\t\t       GEN_INT (frame.last_save_gpr - frame.first_restore_gpr + 1)));\n-\t}\n-      else\n-\t{\n-\t  emit_move_insn (gen_rtx_REG (Pmode, frame.first_restore_gpr),\n-\t\t \t  addr); \n-\t}\n+      insn = restore_gprs (frame_pointer, offset, \n+\t\t\t   frame.first_restore_gpr, frame.last_save_gpr);\n+      emit_insn (insn);\n     }\n \n   /* Return to caller.  */"}, {"sha": "781dc2ea7e42ee15e3140d2804660f96b41bc064", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=c3cc6b78a1487e9c05be9770f811b79706318867", "patch": "@@ -94,10 +94,6 @@ extern int target_flags;\n #define TARGET_IBM_FLOAT           0\n #define TARGET_IEEE_FLOAT          1 \n \n-/* The current function count for create unique internal labels.  */\n-\n-extern int s390_function_count;\n-\n /* The amount of space used for outgoing arguments.  */\n \n extern int current_function_outgoing_args_size;\n@@ -1349,4 +1345,11 @@ extern int s390_pool_overflow;\n   goto WIN;\t\t\t\t\t\t\t\t    \\\n }\n \n+/* In rare cases, correct code generation requires extra machine dependent\n+   processing between the second jump optimization pass and delayed branch\n+   scheduling.  On those machines, define this macro as a C statement to act on\n+   the code starting at INSN.  */\n+ \n+#define MACHINE_DEPENDENT_REORG(INSN) s390_machine_dependent_reorg (INSN)\n+\n #endif "}, {"sha": "e1612dd1312cfbe82d7ee146aa4fdff5e803c636", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3cc6b78a1487e9c05be9770f811b79706318867/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=c3cc6b78a1487e9c05be9770f811b79706318867", "patch": "@@ -6228,10 +6228,7 @@\n      compiler doesn't know about it, because the PLT glue \n      code uses it.  In 64-bit, this is not necessary.  */\n   if (plt_call && !TARGET_64BIT)\n-    {\n-      current_function_uses_pic_offset_table = 1;\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-    }\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n \n   DONE;\n }\")\n@@ -6353,10 +6350,7 @@\n      compiler doesn't know about it, because the PLT glue \n      code uses it.  In 64-bit, this is not necessary.  */\n   if (plt_call && !TARGET_64BIT)\n-    {\n-      current_function_uses_pic_offset_table = 1;\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-    }\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n \n   DONE;\n }\")"}]}