{"sha": "dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJmZTIxMjQxZjJjZDRhMzliMzVlZjM5MzcxMDE2NmFkM2M0YjQyYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-26T13:55:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-26T13:55:47Z"}, "message": "cp-tree.h (finish_enum): Change prototype.\n\n\t* cp-tree.h (finish_enum): Change prototype.\n\t* decl.c (finish_enum): Use TYPE_VALUES, rather than taking a\n\tVALUES parameter.  Don't try to compute mins/maxs if\n\tprocessing_template_decl.\n\t* parse.y (structsp): Use new calling sequence for finish_enum.\n\t* pt.c (tsubst_enum): Likewise.  Take the new type as input.\n\t(lookup_template_class): Remove unused variables.  Tweak.\n\tRegister enums on instantiation list before substituting\n\tenumeration constants.\n\t(tsubst_decl): Remove unused variables.\n\t(regenerate_decl_from_template): Likewise.\n\t* decl.c (duplicate_decls): Don't obliterate the\n\tDECL_TEMPLATE_INFO for a template if we're not replacing it with\n\tanything.\n\nFrom-SVN: r22004", "tree": {"sha": "a402af812796414725c2ac344772fbca8a82f397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a402af812796414725c2ac344772fbca8a82f397"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/comments", "author": null, "committer": null, "parents": [{"sha": "c0a483c70ac5593f35658f8f6ed541b45f027dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0a483c70ac5593f35658f8f6ed541b45f027dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0a483c70ac5593f35658f8f6ed541b45f027dab"}], "stats": {"total": 157, "additions": 110, "deletions": 47}, "files": [{"sha": "366f352c4caf49158081d19e0dcfae85d3060255", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "patch": "@@ -1,5 +1,21 @@\n 1998-08-26  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* cp-tree.h (finish_enum): Change prototype.\n+\t* decl.c (finish_enum): Use TYPE_VALUES, rather than taking a\n+\tVALUES parameter.  Don't try to compute mins/maxs if\n+\tprocessing_template_decl. \n+\t* parse.y (structsp): Use new calling sequence for finish_enum.\n+\t* pt.c (tsubst_enum): Likewise.  Take the new type as input.  \n+\t(lookup_template_class): Remove unused variables.  Tweak.\n+\tRegister enums on instantiation list before substituting\n+\tenumeration constants.\n+\t(tsubst_decl): Remove unused variables.\n+\t(regenerate_decl_from_template): Likewise.\n+\t\n+\t* decl.c (duplicate_decls): Don't obliterate the\n+\tDECL_TEMPLATE_INFO for a template if we're not replacing it with\n+\tanything. \n+\n \t* lex.c (do_identifier): Fix typo in comment.\n \n Wed Aug 26 10:54:51 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>"}, {"sha": "bf91f830c8d59440340b43b1f4f58bfccf1bc172", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "patch": "@@ -2562,7 +2562,7 @@ extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n extern tree xref_tag_from_type\t\t\tPROTO((tree, tree, int));\n extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n-extern tree finish_enum\t\t\t\tPROTO((tree, tree));\n+extern tree finish_enum\t\t\t\tPROTO((tree));\n extern tree build_enumerator\t\t\tPROTO((tree, tree));\n extern tree grok_enum_decls\t\t\tPROTO((tree));\n extern int start_function\t\t\tPROTO((tree, tree, tree, int));"}, {"sha": "995207d7cc39d116391ce9cf5e68930422cf06fa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "patch": "@@ -2982,7 +2982,8 @@ duplicate_decls (newdecl, olddecl)\n \tcp_error (\"invalid redeclaration of %D\", newdecl);\n       TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n       DECL_TEMPLATE_PARMS (olddecl) = DECL_TEMPLATE_PARMS (newdecl);\n-      DECL_TEMPLATE_INFO (olddecl) = DECL_TEMPLATE_INFO (newdecl);\n+      if (DECL_TEMPLATE_INFO (newdecl))\n+\tDECL_TEMPLATE_INFO (olddecl) = DECL_TEMPLATE_INFO (newdecl);\n       DECL_TEMPLATE_SPECIALIZATIONS (olddecl) \n \t= chainon (DECL_TEMPLATE_SPECIALIZATIONS (olddecl),\n \t\t   DECL_TEMPLATE_SPECIALIZATIONS (newdecl));\n@@ -11861,12 +11862,13 @@ start_enum (name)\n    Returns ENUMTYPE.  */\n \n tree\n-finish_enum (enumtype, values)\n-     register tree enumtype, values;\n+finish_enum (enumtype)\n+     tree enumtype;\n {\n   register tree minnode = NULL_TREE, maxnode = NULL_TREE;\n   /* Calculate the maximum value of any enumerator in this type.  */\n \n+  tree values = TYPE_VALUES (enumtype);\n   if (values)\n     {\n       tree pair;\n@@ -11899,12 +11901,15 @@ finish_enum (enumtype, values)\n \t\t  = build1 (NOP_EXPR, enumtype, value);\n \t      TREE_TYPE (value) = enumtype;\n \n-\t      if (!minnode)\n-\t\tminnode = maxnode = value;\n-\t      else if (tree_int_cst_lt (maxnode, value))\n-\t\tmaxnode = value;\n-\t      else if (tree_int_cst_lt (value, minnode))\n-\t\tminnode = value;\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  if (!minnode)\n+\t\t    minnode = maxnode = value;\n+\t\t  else if (tree_int_cst_lt (maxnode, value))\n+\t\t    maxnode = value;\n+\t\t  else if (tree_int_cst_lt (value, minnode))\n+\t\t    minnode = value;\n+\t\t}\n \t    }\n \n \t  /* In the list we're building up, we want the enumeration"}, {"sha": "c9842f9546fbae1febd90a61389c5745282c53d9", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "patch": "@@ -2060,24 +2060,26 @@ structsp:\n \t\t{ $<itype>3 = suspend_momentary ();\n \t\t  $<ttype>$ = start_enum ($2); }\n \t  enumlist maybecomma_warn '}'\n-\t\t{ $$.t = finish_enum ($<ttype>4, $5);\n+\t\t{ TYPE_VALUES ($<ttype>4) = $5;\n+\t\t  $$.t = finish_enum ($<ttype>4);\n \t\t  $$.new_type_flag = 1;\n \t\t  resume_momentary ((int) $<itype>3);\n \t\t  check_for_missing_semicolon ($<ttype>4); }\n \t| ENUM identifier '{' '}'\n-\t\t{ $$.t = finish_enum (start_enum ($2), NULL_TREE);\n+\t\t{ $$.t = finish_enum (start_enum ($2));\n \t\t  $$.new_type_flag = 1;\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM '{'\n \t\t{ $<itype>2 = suspend_momentary ();\n \t\t  $<ttype>$ = start_enum (make_anon_name ()); }\n \t  enumlist maybecomma_warn '}'\n-\t\t{ $$.t = finish_enum ($<ttype>3, $4);\n+                { TYPE_VALUES ($<ttype>3) = $4;\n+\t\t  $$.t = finish_enum ($<ttype>3);\n \t\t  resume_momentary ((int) $<itype>1);\n \t\t  check_for_missing_semicolon ($<ttype>3);\n \t\t  $$.new_type_flag = 1; }\n \t| ENUM '{' '}'\n-\t\t{ $$.t = finish_enum (start_enum (make_anon_name()), NULL_TREE);\n+\t\t{ $$.t = finish_enum (start_enum (make_anon_name()));\n \t\t  $$.new_type_flag = 1;\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM identifier"}, {"sha": "ddaf5fecb7a4a396cedb585fd395b7fc989312e2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "patch": "@@ -85,7 +85,7 @@ static tree tsubst_expr_values PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int));\n-static tree tsubst_enum\tPROTO((tree, tree));\n+static void tsubst_enum\tPROTO((tree, tree, tree));\n static tree add_to_template_args PROTO((tree, tree));\n static tree add_outermost_template_args PROTO((tree, tree));\n static void maybe_adjust_types_for_deduction PROTO((unification_kind_t, tree*,\n@@ -3152,8 +3152,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n      int entering_scope;\n {\n   tree template = NULL_TREE, parmlist;\n-  char *mangled_name;\n-  tree id, t;\n+  tree t;\n \n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n@@ -3242,11 +3241,14 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n     }\n   else \n     {\n+      extern tree current_local_enum;\n       tree template_type = TREE_TYPE (template);\n       tree type_decl;\n       tree found = NULL_TREE;\n       int arg_depth;\n       int parm_depth;\n+      int is_partial_instantiation;\n+      tree prev_local_enum;\n \n       template = most_general_template (template);\n       parmlist = DECL_TEMPLATE_PARMS (template);\n@@ -3398,13 +3400,20 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t DECL_TEMPLATE_INSTANTIATIONS list, it must be permanent.  */\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n       \n+      /* This type is a \"partial instantiation\" if any of the template\n+\t arguments still inolve template parameters.  */\n+      is_partial_instantiation = uses_template_parms (arglist);\n+\n       /* Create the type.  */\n       if (TREE_CODE (template_type) == ENUMERAL_TYPE)\n \t{\n-\t  if (!uses_template_parms (arglist))\n-\t    t = tsubst_enum (template_type, arglist);\n+\t  if (!is_partial_instantiation)\n+\t    {\n+\t      prev_local_enum = current_local_enum;\n+\t      t = start_enum (TYPE_IDENTIFIER (template_type));\n+\t    }\n \t  else\n-\t    /* We don't want to call tsubst_enum for this type, since\n+\t    /* We don't want to call start_enum for this type, since\n \t       the values for the enumeration constants may involve\n \t       template parameters.  And, no one should be interested\n \t       in the enumeration constants for such a type.  */\n@@ -3439,22 +3448,37 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       else\n \ttype_decl = TYPE_NAME (t);\n \n-      /* We're done with the permanent obstack, now.  */\n-      pop_obstacks ();\n-\n       /* Set up the template information.  */\n       arglist = copy_to_permanent (arglist);\n       SET_TYPE_TEMPLATE_INFO (t,\n-\t\t\t      perm_tree_cons (template, arglist, NULL_TREE));\n-      DECL_TEMPLATE_INSTANTIATIONS (template) = perm_tree_cons\n-\t(arglist, t, DECL_TEMPLATE_INSTANTIATIONS (template));\n+\t\t\t      tree_cons (template, arglist, NULL_TREE));\n+      DECL_TEMPLATE_INSTANTIATIONS (template) \n+\t= tree_cons (arglist, t, \n+\t\t     DECL_TEMPLATE_INSTANTIATIONS (template));\n+\n+      if (TREE_CODE (t) == ENUMERAL_TYPE \n+\t  && !is_partial_instantiation)\n+\t{\n+\t  /* Now that the type has been registered on the\n+\t     instantiations list, we set up the enumerators.  Because\n+\t     the enumeration constants may involve the enumeration\n+\t     type itself, we make sure to register the type first, and\n+\t     then create the constants.  That way, doing tsubst_expr\n+\t     for the enumeration constants won't result in recursive\n+\t     calls here; we'll find the instantiation and exit above.  */\n+\t  tsubst_enum (template_type, t, arglist);\n+\t  current_local_enum = prev_local_enum;\n+\t}\n+\n+      /* We're done with the permanent obstack, now.  */\n+      pop_obstacks ();\n \n       /* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO\n \t is set up.  */\n       if (TREE_CODE (t) != ENUMERAL_TYPE)\n \tDECL_NAME (type_decl) = classtype_mangled_name (t);\n       DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n-      if (! uses_template_parms (arglist))\n+      if (!is_partial_instantiation)\n \t{\n \t  DECL_ASSEMBLER_NAME (type_decl)\n \t    = get_identifier (build_overload_name (t, 1, 1));\n@@ -4708,8 +4732,6 @@ tsubst_decl (t, args, type, in_decl)\n \t/* We can get here when processing a member template function\n \t   of a template class.  */\n \ttree decl = DECL_TEMPLATE_RESULT (t);\n-\ttree parms;\n-\ttree* new_parms;\n \ttree spec;\n \tint is_template_template_parm = DECL_TEMPLATE_TEMPLATE_PARM_P (t);\n \n@@ -7781,7 +7803,6 @@ regenerate_decl_from_template (decl, tmpl)\n      tree tmpl;\n {\n   tree args;\n-  tree save_ti;\n   tree code_pattern;\n   tree new_decl;\n   tree gen_tmpl;\n@@ -8172,17 +8193,17 @@ add_maybe_template (d, fns)\n   DECL_MAYBE_TEMPLATE (d) = 1;\n }\n \n-/* Instantiate an enumerated type.  */\n+/* Instantiate an enumerated type.  TAG is the template type, NEWTAG\n+   is the instantiation (which should have been created with\n+   start_enum) and ARGS are the template arguments to use.  */\n \n-static tree\n-tsubst_enum (tag, args)\n-     tree tag, args;\n+static void\n+tsubst_enum (tag, newtag, args)\n+     tree tag;\n+     tree newtag;\n+     tree args;\n {\n-  extern tree current_local_enum;\n-  tree prev_local_enum = current_local_enum;\n-\n-  tree newtag = start_enum (TYPE_IDENTIFIER (tag));\n-  tree e, values = NULL_TREE;\n+  tree e;\n \n   for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n     {\n@@ -8194,21 +8215,22 @@ tsubst_enum (tag, args)\n \t{\n \t  if (TREE_CODE (value) == NOP_EXPR)\n \t    /* This is the special case where the value is really a\n-\t   TEMPLATE_PARM_INDEX.  See finish_enum.  */\n+\t       TEMPLATE_PARM_INDEX.  See finish_enum.  */\n \t    value = TREE_OPERAND (value, 0);\n \t  value = tsubst_expr (value, args, NULL_TREE);\n \t}\n \n       elt = build_enumerator (TREE_PURPOSE (e), value);\n-      TREE_CHAIN (elt) = values;\n-      values = elt;\n-    }\n \n-  finish_enum (newtag, values);\n-\n-  current_local_enum = prev_local_enum;\n+      /* We save the enumerators we have built so far in the\n+\t TYPE_VALUES so that if the enumeration constants for\n+\t subsequent enumerators involve those for previous ones,\n+\t tsubst_copy will be able to find them.  */\n+      TREE_CHAIN (elt) = TYPE_VALUES (newtag);\n+      TYPE_VALUES (newtag) = elt;\n+    }\n \n-  return newtag;\n+  finish_enum (newtag);\n }\n \n /* Set the DECL_ASSEMBLER_NAME for DECL, which is a FUNCTION_DECL that"}, {"sha": "e5cc58a4a2d4248a544ed4254c9239a38ba1fe70", "filename": "gcc/testsuite/g++.old-deja/g++.pt/enum8.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfe21241f2cd4a39b35ef393710166ad3c4b42b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum8.C?ref=dbfe21241f2cd4a39b35ef393710166ad3c4b42b", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+template <int I>\n+void f();\n+\n+template <>\n+void f<4>() {}\n+\n+template <class T>\n+struct S\n+{\n+  enum E { a = 1, b = a + 3 };\n+};\n+\n+int main()\n+{\n+  f<S<int>::b>();\n+}"}]}