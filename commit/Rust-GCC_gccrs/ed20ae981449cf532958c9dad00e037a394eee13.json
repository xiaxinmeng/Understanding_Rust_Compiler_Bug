{"sha": "ed20ae981449cf532958c9dad00e037a394eee13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQyMGFlOTgxNDQ5Y2Y1MzI5NThjOWRhZDAwZTAzN2EzOTRlZWUxMw==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2014-05-23T11:39:35Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2014-05-23T11:39:35Z"}, "message": "Make it easier to diff expand_omp_for_* functions.\n\n\tgcc/\n\t* omp-low.c (expand_omp_for_static_chunk): Rename variable si to\n\tgsi, and variables v_* to v*.\n\nFrom-SVN: r210858", "tree": {"sha": "fca4303ba3032d66addac57a6c10f1d8a4eb4cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fca4303ba3032d66addac57a6c10f1d8a4eb4cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed20ae981449cf532958c9dad00e037a394eee13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed20ae981449cf532958c9dad00e037a394eee13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed20ae981449cf532958c9dad00e037a394eee13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed20ae981449cf532958c9dad00e037a394eee13/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6842efc758243dd39a1148a470906aebfe84d92c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6842efc758243dd39a1148a470906aebfe84d92c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6842efc758243dd39a1148a470906aebfe84d92c"}], "stats": {"total": 123, "additions": 64, "deletions": 59}, "files": [{"sha": "3d74b6f97c20206d6b5604c911572f144bfac2cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed20ae981449cf532958c9dad00e037a394eee13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed20ae981449cf532958c9dad00e037a394eee13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed20ae981449cf532958c9dad00e037a394eee13", "patch": "@@ -1,3 +1,8 @@\n+2014-05-23  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* omp-low.c (expand_omp_for_static_chunk): Rename variable si to\n+\tgsi, and variables v_* to v*.\n+\n 2014-05-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* varasm.c (output_constructor_bitfield): Fix thinkos in latest change."}, {"sha": "129d513d12c7917b3b5294d0cddb559ed596a424", "filename": "gcc/omp-low.c", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed20ae981449cf532958c9dad00e037a394eee13/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed20ae981449cf532958c9dad00e037a394eee13/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=ed20ae981449cf532958c9dad00e037a394eee13", "patch": "@@ -6166,10 +6166,10 @@ expand_omp_for_static_chunk (struct omp_region *region,\n {\n   tree n, s0, e0, e, t;\n   tree trip_var, trip_init, trip_main, trip_back, nthreads, threadid;\n-  tree type, itype, v_main, v_back, v_extra;\n+  tree type, itype, vmain, vback, vextra;\n   basic_block entry_bb, exit_bb, body_bb, seq_start_bb, iter_part_bb;\n   basic_block trip_update_bb = NULL, cont_bb, collapse_bb = NULL, fin_bb;\n-  gimple_stmt_iterator si;\n+  gimple_stmt_iterator gsi;\n   gimple stmt;\n   edge se;\n   enum built_in_function get_num_threads = BUILT_IN_OMP_GET_NUM_THREADS;\n@@ -6202,8 +6202,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   exit_bb = region->exit;\n \n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n-  si = gsi_last_bb (entry_bb);\n-  gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_FOR);\n+  gsi = gsi_last_bb (entry_bb);\n+  gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n     {\n@@ -6217,7 +6217,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       basic_block l2_dom_bb = NULL;\n \n       counts = XALLOCAVEC (tree, fd->collapse);\n-      expand_omp_for_init_counts (fd, &si, entry_bb, counts,\n+      expand_omp_for_init_counts (fd, &gsi, entry_bb, counts,\n \t\t\t\t  fin_bb, first_zero_iter,\n \t\t\t\t  l2_dom_bb);\n       t = NULL_TREE;\n@@ -6233,21 +6233,21 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       && (t == NULL_TREE || !integer_onep (t)))\n     {\n       n1 = fold_convert (type, unshare_expr (fd->loop.n1));\n-      n1 = force_gimple_operand_gsi (&si, n1, true, NULL_TREE,\n+      n1 = force_gimple_operand_gsi (&gsi, n1, true, NULL_TREE,\n \t\t\t\t     true, GSI_SAME_STMT);\n       n2 = fold_convert (type, unshare_expr (fd->loop.n2));\n-      n2 = force_gimple_operand_gsi (&si, n2, true, NULL_TREE,\n+      n2 = force_gimple_operand_gsi (&gsi, n2, true, NULL_TREE,\n \t\t\t\t     true, GSI_SAME_STMT);\n       stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n \t\t\t\tNULL_TREE, NULL_TREE);\n-      gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n+      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n       if (walk_tree (gimple_cond_lhs_ptr (stmt),\n \t\t     expand_omp_regimplify_p, NULL, NULL)\n \t  || walk_tree (gimple_cond_rhs_ptr (stmt),\n \t\t\texpand_omp_regimplify_p, NULL, NULL))\n \t{\n-\t  si = gsi_for_stmt (stmt);\n-\t  gimple_regimplify_operands (stmt, &si);\n+\t  gsi = gsi_for_stmt (stmt);\n+\t  gimple_regimplify_operands (stmt, &gsi);\n \t}\n       se = split_block (entry_bb, stmt);\n       se->flags = EDGE_TRUE_VALUE;\n@@ -6258,25 +6258,25 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       if (gimple_in_ssa_p (cfun))\n \t{\n \t  int dest_idx = find_edge (entry_bb, fin_bb)->dest_idx;\n-\t  for (si = gsi_start_phis (fin_bb);\n-\t       !gsi_end_p (si); gsi_next (&si))\n+\t  for (gsi = gsi_start_phis (fin_bb);\n+\t       !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      gimple phi = gsi_stmt (si);\n+\t      gimple phi = gsi_stmt (gsi);\n \t      add_phi_arg (phi, gimple_phi_arg_def (phi, dest_idx),\n \t\t\t   se, UNKNOWN_LOCATION);\n \t    }\n \t}\n-      si = gsi_last_bb (entry_bb);\n+      gsi = gsi_last_bb (entry_bb);\n     }\n \n   t = build_call_expr (builtin_decl_explicit (get_num_threads), 0);\n   t = fold_convert (itype, t);\n-  nthreads = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n+  nthreads = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n \n   t = build_call_expr (builtin_decl_explicit (get_thread_num), 0);\n   t = fold_convert (itype, t);\n-  threadid = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n+  threadid = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n \n   n1 = fd->loop.n1;\n@@ -6293,14 +6293,14 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       gcc_assert (innerc);\n       n2 = OMP_CLAUSE_DECL (innerc);\n     }\n-  n1 = force_gimple_operand_gsi (&si, fold_convert (type, n1),\n+  n1 = force_gimple_operand_gsi (&gsi, fold_convert (type, n1),\n \t\t\t\t true, NULL_TREE, true, GSI_SAME_STMT);\n-  n2 = force_gimple_operand_gsi (&si, fold_convert (itype, n2),\n+  n2 = force_gimple_operand_gsi (&gsi, fold_convert (itype, n2),\n \t\t\t\t true, NULL_TREE, true, GSI_SAME_STMT);\n-  step = force_gimple_operand_gsi (&si, fold_convert (itype, step),\n+  step = force_gimple_operand_gsi (&gsi, fold_convert (itype, step),\n \t\t\t\t   true, NULL_TREE, true, GSI_SAME_STMT);\n   fd->chunk_size\n-    = force_gimple_operand_gsi (&si, fold_convert (itype, fd->chunk_size),\n+    = force_gimple_operand_gsi (&gsi, fold_convert (itype, fd->chunk_size),\n \t\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n \n   t = build_int_cst (itype, (fd->loop.cond_code == LT_EXPR ? -1 : 1));\n@@ -6314,7 +6314,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   else\n     t = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n   t = fold_convert (itype, t);\n-  n = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n+  n = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\ttrue, GSI_SAME_STMT);\n \n   trip_var = create_tmp_reg (itype, \".trip\");\n@@ -6332,39 +6332,39 @@ expand_omp_for_static_chunk (struct omp_region *region,\n     }\n \n   stmt = gimple_build_assign (trip_init, build_int_cst (itype, 0));\n-  gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n+  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n \n   t = fold_build2 (MULT_EXPR, itype, threadid, fd->chunk_size);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n   if (POINTER_TYPE_P (type))\n     t = fold_build_pointer_plus (n1, t);\n   else\n     t = fold_build2 (PLUS_EXPR, type, t, n1);\n-  v_extra = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n-\t\t\t\t      true, GSI_SAME_STMT);\n+  vextra = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t\t     true, GSI_SAME_STMT);\n \n   /* Remove the GIMPLE_OMP_FOR.  */\n-  gsi_remove (&si, true);\n+  gsi_remove (&gsi, true);\n \n   /* Iteration space partitioning goes in ITER_PART_BB.  */\n-  si = gsi_last_bb (iter_part_bb);\n+  gsi = gsi_last_bb (iter_part_bb);\n \n   t = fold_build2 (MULT_EXPR, itype, trip_main, nthreads);\n   t = fold_build2 (PLUS_EXPR, itype, t, threadid);\n   t = fold_build2 (MULT_EXPR, itype, t, fd->chunk_size);\n-  s0 = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n+  s0 = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t false, GSI_CONTINUE_LINKING);\n \n   t = fold_build2 (PLUS_EXPR, itype, s0, fd->chunk_size);\n   t = fold_build2 (MIN_EXPR, itype, t, n);\n-  e0 = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n+  e0 = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t false, GSI_CONTINUE_LINKING);\n \n   t = build2 (LT_EXPR, boolean_type_node, s0, n);\n-  gsi_insert_after (&si, gimple_build_cond_empty (t), GSI_CONTINUE_LINKING);\n+  gsi_insert_after (&gsi, gimple_build_cond_empty (t), GSI_CONTINUE_LINKING);\n \n   /* Setup code for sequential iteration goes in SEQ_START_BB.  */\n-  si = gsi_start_bb (seq_start_bb);\n+  gsi = gsi_start_bb (seq_start_bb);\n \n   tree startvar = fd->loop.v;\n   tree endvar = NULL_TREE;\n@@ -6390,12 +6390,12 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   else\n     t = fold_build2 (PLUS_EXPR, type, t, n1);\n   t = fold_convert (TREE_TYPE (startvar), t);\n-  t = force_gimple_operand_gsi (&si, t,\n+  t = force_gimple_operand_gsi (&gsi, t,\n \t\t\t\tDECL_P (startvar)\n \t\t\t\t&& TREE_ADDRESSABLE (startvar),\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n   stmt = gimple_build_assign (startvar, t);\n-  gsi_insert_after (&si, stmt, GSI_CONTINUE_LINKING);\n+  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n   t = fold_convert (itype, e0);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n@@ -6404,73 +6404,73 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   else\n     t = fold_build2 (PLUS_EXPR, type, t, n1);\n   t = fold_convert (TREE_TYPE (startvar), t);\n-  e = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n+  e = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\tfalse, GSI_CONTINUE_LINKING);\n   if (endvar)\n     {\n       stmt = gimple_build_assign (endvar, e);\n-      gsi_insert_after (&si, stmt, GSI_CONTINUE_LINKING);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n       if (useless_type_conversion_p (TREE_TYPE (fd->loop.v), TREE_TYPE (e)))\n \tstmt = gimple_build_assign (fd->loop.v, e);\n       else\n \tstmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, e,\n \t\t\t\t\t     NULL_TREE);\n-      gsi_insert_after (&si, stmt, GSI_CONTINUE_LINKING);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n-    expand_omp_for_init_vars (fd, &si, counts, inner_stmt, startvar);\n+    expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n \n   if (!broken_loop)\n     {\n       /* The code controlling the sequential loop goes in CONT_BB,\n \t replacing the GIMPLE_OMP_CONTINUE.  */\n-      si = gsi_last_bb (cont_bb);\n-      stmt = gsi_stmt (si);\n+      gsi = gsi_last_bb (cont_bb);\n+      stmt = gsi_stmt (gsi);\n       gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n-      v_main = gimple_omp_continue_control_use (stmt);\n-      v_back = gimple_omp_continue_control_def (stmt);\n+      vmain = gimple_omp_continue_control_use (stmt);\n+      vback = gimple_omp_continue_control_def (stmt);\n \n       if (!gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n \t  if (POINTER_TYPE_P (type))\n-\t    t = fold_build_pointer_plus (v_main, step);\n+\t    t = fold_build_pointer_plus (vmain, step);\n \t  else\n-\t    t = fold_build2 (PLUS_EXPR, type, v_main, step);\n-\t  if (DECL_P (v_back) && TREE_ADDRESSABLE (v_back))\n-\t    t = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n+\t    t = fold_build2 (PLUS_EXPR, type, vmain, step);\n+\t  if (DECL_P (vback) && TREE_ADDRESSABLE (vback))\n+\t    t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t\t  true, GSI_SAME_STMT);\n-\t  stmt = gimple_build_assign (v_back, t);\n-\t  gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n+\t  stmt = gimple_build_assign (vback, t);\n+\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n \n \t  t = build2 (fd->loop.cond_code, boolean_type_node,\n-\t\t      DECL_P (v_back) && TREE_ADDRESSABLE (v_back)\n-\t\t      ? t : v_back, e);\n-\t  gsi_insert_before (&si, gimple_build_cond_empty (t), GSI_SAME_STMT);\n+\t\t      DECL_P (vback) && TREE_ADDRESSABLE (vback)\n+\t\t      ? t : vback, e);\n+\t  gsi_insert_before (&gsi, gimple_build_cond_empty (t), GSI_SAME_STMT);\n \t}\n \n       /* Remove GIMPLE_OMP_CONTINUE.  */\n-      gsi_remove (&si, true);\n+      gsi_remove (&gsi, true);\n \n       if (fd->collapse > 1 && !gimple_omp_for_combined_p (fd->for_stmt))\n \tcollapse_bb = extract_omp_for_update_vars (fd, cont_bb, body_bb);\n \n       /* Trip update code goes into TRIP_UPDATE_BB.  */\n-      si = gsi_start_bb (trip_update_bb);\n+      gsi = gsi_start_bb (trip_update_bb);\n \n       t = build_int_cst (itype, 1);\n       t = build2 (PLUS_EXPR, itype, trip_main, t);\n       stmt = gimple_build_assign (trip_back, t);\n-      gsi_insert_after (&si, stmt, GSI_CONTINUE_LINKING);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n     }\n \n   /* Replace the GIMPLE_OMP_RETURN with a barrier, or nothing.  */\n-  si = gsi_last_bb (exit_bb);\n-  if (!gimple_omp_return_nowait_p (gsi_stmt (si)))\n+  gsi = gsi_last_bb (exit_bb);\n+  if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n-      t = gimple_omp_return_lhs (gsi_stmt (si));\n-      gsi_insert_after (&si, build_omp_barrier (t), GSI_SAME_STMT);\n+      t = gimple_omp_return_lhs (gsi_stmt (gsi));\n+      gsi_insert_after (&gsi, build_omp_barrier (t), GSI_SAME_STMT);\n     }\n-  gsi_remove (&si, true);\n+  gsi_remove (&gsi, true);\n \n   /* Connect the new blocks.  */\n   find_edge (iter_part_bb, seq_start_bb)->flags = EDGE_TRUE_VALUE;\n@@ -6532,9 +6532,9 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t  locus = gimple_phi_arg_location_from_edge (phi, se);\n \n \t  /* A special case -- fd->loop.v is not yet computed in\n-\t     iter_part_bb, we need to use v_extra instead.  */\n+\t     iter_part_bb, we need to use vextra instead.  */\n \t  if (t == fd->loop.v)\n-\t    t = v_extra;\n+\t    t = vextra;\n \t  add_phi_arg (nphi, t, ene, locus);\n \t  locus = redirect_edge_var_map_location (vm);\n \t  add_phi_arg (nphi, redirect_edge_var_map_def (vm), re, locus);"}]}