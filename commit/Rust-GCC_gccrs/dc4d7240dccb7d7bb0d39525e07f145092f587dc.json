{"sha": "dc4d7240dccb7d7bb0d39525e07f145092f587dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM0ZDcyNDBkY2NiN2Q3YmIwZDM5NTI1ZTA3ZjE0NTA5MmY1ODdkYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-03-06T16:38:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-03-06T16:38:43Z"}, "message": "reg-stack.c (reg_to_stack): Large models don't allow NAN to be loaded for constant large models.\n\n\n\t* reg-stack.c (reg_to_stack): Large models don't allow NAN to be\n\tloaded for constant large models.  Non-large 64bit PIC can do.\n\t* i386.h (CASE_VECTOR_MODE): Large PIC cases are 64bit.\n\t* cmodel.h: Add LARGE PIC.\n\t* i386.md (UNSPEC_PLTOFF): New.\n\t(UNSPEC_SET_RIP, UNSPEC_SET_GOT_OFFSET): New; renumber other unspecs as\n\tneeded.\n\t(*call_1_rex64): Disable for large models.\n\t(*call_1_rex64_large): New.\n\t(*call_value_1_rex64): Disable for large models.\n\t(*call_value_1_rex64_large): New.\n\t(set_rip_rex4): New.\n\t(set_got_offset_rex64): New.\n\t* predicates.md (constant_call_address_operand): For large model\n\tconstant calls are not possible.\n\t* i386-protos.h (construct_plt_address): Declare.\n\t* i386.c (override_options): Accept large models.\n\t(ix86_expand_prologue): Expand large PIC GOT pointer load.\n\t(legitimate_constant_p): Add new UNSPECs.\n\t(legitimate_pic_operand_p): Likewise.\n\t(legitimate_pic_address_disp_p): Disallow local symbols for large PICs.\n\t(legitimize_pic_address): Do easy RIP relative way for TLS only for\n\tnon-large model.\n\t(output_pic_addr_const): Add PLTOFF.\n\t(ix86_output_addr_diff_elt): Output 64bit tables when needed.\n\t(ix86_expand_move): Legitimize pic address when in PIC mode.\n\t(construct_plt_address): New function.\n\t(ix86_expand_call): Offload the address to register and use GOT pointer\n\tfor large model.\n\t* invoke.texi (mcmodel=large): Update documentation.\n\nFrom-SVN: r122623", "tree": {"sha": "f70d17a85450e10da77bd234ac14b80b870a2903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f70d17a85450e10da77bd234ac14b80b870a2903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc4d7240dccb7d7bb0d39525e07f145092f587dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4d7240dccb7d7bb0d39525e07f145092f587dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc4d7240dccb7d7bb0d39525e07f145092f587dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4d7240dccb7d7bb0d39525e07f145092f587dc/comments", "author": null, "committer": null, "parents": [{"sha": "80fd744fdae18292b5cb67cebceea8b750656c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80fd744fdae18292b5cb67cebceea8b750656c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80fd744fdae18292b5cb67cebceea8b750656c40"}], "stats": {"total": 223, "additions": 176, "deletions": 47}, "files": [{"sha": "a9a0565b4532321ffd9c1c72c56b7d0289c4ce71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -1,3 +1,36 @@\n+2007-03-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* reg-stack.c (reg_to_stack): Large models don't allow NAN to be\n+\tloaded for constant large models.  Non-large 64bit PIC can do.\n+\t* i386.h (CASE_VECTOR_MODE): Large PIC cases are 64bit.\n+\t* cmodel.h: Add LARGE PIC.\n+\t* i386.md (UNSPEC_PLTOFF): New.\n+\t(UNSPEC_SET_RIP, UNSPEC_SET_GOT_OFFSET): New; renumber other unspecs as\n+\tneeded.\n+\t(*call_1_rex64): Disable for large models.\n+\t(*call_1_rex64_large): New.\n+\t(*call_value_1_rex64): Disable for large models.\n+\t(*call_value_1_rex64_large): New.\n+\t(set_rip_rex4): New.\n+\t(set_got_offset_rex64): New.\n+\t* predicates.md (constant_call_address_operand): For large model\n+\tconstant calls are not possible.\n+\t* i386-protos.h (construct_plt_address): Declare.\n+\t* i386.c (override_options): Accept large models.\n+\t(ix86_expand_prologue): Expand large PIC GOT pointer load.\n+\t(legitimate_constant_p): Add new UNSPECs.\n+\t(legitimate_pic_operand_p): Likewise.\n+\t(legitimate_pic_address_disp_p): Disallow local symbols for large PICs.\n+\t(legitimize_pic_address): Do easy RIP relative way for TLS only for\n+\tnon-large model.\n+\t(output_pic_addr_const): Add PLTOFF.\n+\t(ix86_output_addr_diff_elt): Output 64bit tables when needed.\n+\t(ix86_expand_move): Legitimize pic address when in PIC mode.\n+\t(construct_plt_address): New function.\n+\t(ix86_expand_call): Offload the address to register and use GOT pointer\n+\tfor large model.\n+\t* invoke.texi (mcmodel=large): Update documentation.\n+\n 2007-03-06  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (x86_use_leave, x86_push_memory,"}, {"sha": "a3a0f66488214dde433e26e0514320678b610c0a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -249,5 +249,6 @@ extern void x86_elf_aligned_common (FILE *, const char *,\n extern void ix86_fp_comparison_codes (enum rtx_code code, enum rtx_code *,\n \t\t\t\t      enum rtx_code *, enum rtx_code *);\n extern enum rtx_code ix86_fp_compare_code_to_integer (enum rtx_code);\n+extern rtx construct_plt_address (rtx);\n #endif\n extern int asm_preferred_eh_data_format (int, int);"}, {"sha": "9cc214454c91f3c58a5dfcd7daba72c564726e5b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 70, "deletions": 14, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -2072,14 +2072,14 @@ override_options (void)\n \tix86_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n       else if (!strcmp (ix86_cmodel_string, \"medium\"))\n \tix86_cmodel = flag_pic ? CM_MEDIUM_PIC : CM_MEDIUM;\n+      else if (!strcmp (ix86_cmodel_string, \"large\"))\n+\tix86_cmodel = flag_pic ? CM_LARGE_PIC : CM_LARGE;\n       else if (flag_pic)\n-\tsorry (\"code model %s not supported in PIC mode\", ix86_cmodel_string);\n+\terror (\"code model %s does not support PIC mode\", ix86_cmodel_string);\n       else if (!strcmp (ix86_cmodel_string, \"32\"))\n \tix86_cmodel = CM_32;\n       else if (!strcmp (ix86_cmodel_string, \"kernel\") && !flag_pic)\n \tix86_cmodel = CM_KERNEL;\n-      else if (!strcmp (ix86_cmodel_string, \"large\") && !flag_pic)\n-\tix86_cmodel = CM_LARGE;\n       else\n \terror (\"bad value (%s) for -mcmodel= switch\", ix86_cmodel_string);\n     }\n@@ -2102,8 +2102,6 @@ override_options (void)\n   if ((TARGET_64BIT == 0) != (ix86_cmodel == CM_32))\n     error (\"code model %qs not supported in the %s bit mode\",\n \t   ix86_cmodel_string, TARGET_64BIT ? \"64\" : \"32\");\n-  if (ix86_cmodel == CM_LARGE)\n-    sorry (\"code model %<large%> not supported yet\");\n   if ((TARGET_64BIT != 0) != ((target_flags & MASK_64BIT) != 0))\n     sorry (\"%i-bit mode not compiled in\",\n \t   (target_flags & MASK_64BIT) ? 64 : 32);\n@@ -5982,7 +5980,25 @@ ix86_expand_prologue (void)\n   if (pic_reg_used)\n     {\n       if (TARGET_64BIT)\n-        insn = emit_insn (gen_set_got_rex64 (pic_offset_table_rtx));\n+\t{\n+\t  if (ix86_cmodel == CM_LARGE_PIC)\n+\t    {\n+              rtx tmp_reg = gen_rtx_REG (DImode,\n+\t\t\t\t\t FIRST_REX_INT_REG + 3 /* R11 */);\n+\t      rtx label = gen_label_rtx ();\n+\t      emit_label (label);\n+\t      LABEL_PRESERVE_P (label) = 1;\n+\t      gcc_assert (REGNO (pic_offset_table_rtx) != REGNO (tmp_reg));\n+\t      insn = emit_insn (gen_set_rip_rex64 (pic_offset_table_rtx, label));\n+              REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n+\t      insn = emit_insn (gen_set_got_offset_rex64 (tmp_reg, label));\n+              REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n+\t      insn = emit_insn (gen_adddi3 (pic_offset_table_rtx,\n+\t\t\t\t\t    pic_offset_table_rtx, tmp_reg));\n+\t    }\n+\t  else\n+            insn = emit_insn (gen_set_got_rex64 (pic_offset_table_rtx));\n+\t}\n       else\n         insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n \n@@ -6537,7 +6553,9 @@ legitimate_constant_p (rtx x)\n       if (GET_CODE (x) == UNSPEC)\n \tswitch (XINT (x, 1))\n \t  {\n+\t  case UNSPEC_GOT:\n \t  case UNSPEC_GOTOFF:\n+\t  case UNSPEC_PLTOFF:\n \t    return TARGET_64BIT;\n \t  case UNSPEC_TPOFF:\n \t  case UNSPEC_NTPOFF:\n@@ -6635,7 +6653,9 @@ legitimate_pic_operand_p (rtx x)\n       if (GET_CODE (inner) == UNSPEC)\n \tswitch (XINT (inner, 1))\n \t  {\n+\t  case UNSPEC_GOT:\n \t  case UNSPEC_GOTOFF:\n+\t  case UNSPEC_PLTOFF:\n \t    return TARGET_64BIT;\n \t  case UNSPEC_TPOFF:\n \t    x = XVECEXP (inner, 0, 0);\n@@ -6693,7 +6713,8 @@ legitimate_pic_address_disp_p (rtx disp)\n \t  /* TLS references should always be enclosed in UNSPEC.  */\n \t  if (SYMBOL_REF_TLS_MODEL (op0))\n \t    return false;\n-\t  if (!SYMBOL_REF_FAR_ADDR_P (op0) && SYMBOL_REF_LOCAL_P (op0))\n+\t  if (!SYMBOL_REF_FAR_ADDR_P (op0) && SYMBOL_REF_LOCAL_P (op0)\n+\t      && ix86_cmodel != CM_LARGE_PIC)\n \t    return true;\n \t  break;\n \n@@ -6711,7 +6732,8 @@ legitimate_pic_address_disp_p (rtx disp)\n          of GOT tables.  We should not need these anyway.  */\n       if (GET_CODE (disp) != UNSPEC\n \t  || (XINT (disp, 1) != UNSPEC_GOTPCREL\n-\t      && XINT (disp, 1) != UNSPEC_GOTOFF))\n+\t      && XINT (disp, 1) != UNSPEC_GOTOFF\n+\t      && XINT (disp, 1) != UNSPEC_PLTOFF))\n \treturn 0;\n \n       if (GET_CODE (XVECEXP (disp, 0, 0)) != SYMBOL_REF\n@@ -7128,7 +7150,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n     }\n   else if (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (addr) == 0)\n     {\n-      if (TARGET_64BIT)\n+      if (TARGET_64BIT && ix86_cmodel != CM_LARGE_PIC)\n \t{\n \t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTPCREL);\n \t  new = gen_rtx_CONST (Pmode, new);\n@@ -7152,6 +7174,8 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n \t  new = gen_rtx_CONST (Pmode, new);\n+\t  if (TARGET_64BIT)\n+\t    new = force_reg (Pmode, new);\n \t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \t  new = gen_const_mem (Pmode, new);\n \t  set_mem_alias_set (new, ix86_GOT_alias_set ());\n@@ -7730,6 +7754,9 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n \tcase UNSPEC_GOTOFF:\n \t  fputs (\"@GOTOFF\", file);\n \t  break;\n+\tcase UNSPEC_PLTOFF:\n+\t  fputs (\"@PLTOFF\", file);\n+\t  break;\n \tcase UNSPEC_GOTPCREL:\n \t  fputs (\"@GOTPCREL(%rip)\", file);\n \t  break;\n@@ -9344,9 +9371,17 @@ ix86_output_addr_vec_elt (FILE *file, int value)\n void\n ix86_output_addr_diff_elt (FILE *file, int value, int rel)\n {\n+  const char *directive = ASM_LONG;\n+\n+#ifdef ASM_QUAD\n+  if (TARGET_64BIT && CASE_VECTOR_MODE == DImode)\n+    directive = ASM_QUAD;\n+#else\n+  gcc_assert (!TARGET_64BIT);\n+#endif\n   if (TARGET_64BIT)\n     fprintf (file, \"%s%s%d-%s%d\\n\",\n-\t     ASM_LONG, LPREFIX, value, LPREFIX, rel);\n+\t     directive, LPREFIX, value, LPREFIX, rel);\n   else if (HAVE_AS_GOTOFF_IN_DATA)\n     fprintf (file, \"%s%s%d@GOTOFF\\n\", ASM_LONG, LPREFIX, value);\n #if TARGET_MACHO\n@@ -9466,8 +9501,8 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n \t{\n \t  if (MEM_P (op0))\n \t    op1 = force_reg (Pmode, op1);\n-\t  else\n-\t    op1 = legitimize_address (op1, op1, Pmode);\n+\t  else if (!TARGET_64BIT || !x86_64_movabs_operand (op1, Pmode))\n+\t    op1 = legitimize_pic_address (op1, op0);\n \t}\n     }\n   else\n@@ -14958,6 +14993,22 @@ ix86_expand_strlensi_unroll_1 (rtx out, rtx src, rtx align_rtx)\n   emit_label (end_0_label);\n }\n \n+/* For given symbol (function) construct code to compute address of it's PLT\n+   entry in large x86-64 PIC model.  */\n+rtx\n+construct_plt_address (rtx symbol)\n+{\n+  rtx tmp = gen_reg_rtx (Pmode);\n+  rtx unspec = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, symbol), UNSPEC_PLTOFF);\n+\n+  gcc_assert (GET_CODE (symbol) == SYMBOL_REF);\n+  gcc_assert (ix86_cmodel == CM_LARGE_PIC);\n+\n+  emit_move_insn (tmp, gen_rtx_CONST (Pmode, unspec));\n+  emit_insn (gen_adddi3 (tmp, tmp, pic_offset_table_rtx));\n+  return tmp;\n+}\n+\n void\n ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t\t  rtx callarg2 ATTRIBUTE_UNUSED,\n@@ -14979,7 +15030,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   else\n     {\n       /* Static functions and indirect calls don't need the pic register.  */\n-      if (! TARGET_64BIT && flag_pic\n+      if (flag_pic && (!TARGET_64BIT || ix86_cmodel == CM_LARGE_PIC)\n \t  && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n \t  && ! SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))\n \tuse_reg (&use, pic_offset_table_rtx);\n@@ -14992,7 +15043,12 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       use_reg (&use, al);\n     }\n \n-  if (! call_insn_operand (XEXP (fnaddr, 0), Pmode))\n+  if (ix86_cmodel == CM_LARGE_PIC\n+      && GET_CODE (fnaddr) == MEM\n+      && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n+      && !local_symbolic_operand (XEXP (fnaddr, 0), VOIDmode))\n+    fnaddr = gen_rtx_MEM (QImode, construct_plt_address (XEXP (fnaddr, 0)));\n+  else if (! call_insn_operand (XEXP (fnaddr, 0), Pmode))\n     {\n       fnaddr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));\n       fnaddr = gen_rtx_MEM (QImode, fnaddr);"}, {"sha": "4c322bc8730646865da34acf201dee8f98d96d14", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -1851,7 +1851,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE (!TARGET_64BIT || flag_pic ? SImode : DImode)\n+#define CASE_VECTOR_MODE \\\n+ (!TARGET_64BIT || (flag_pic && ix86_cmodel != CM_LARGE_PIC) ? SImode : DImode)\n \n /* Define this as 1 if `char' should by default be signed; else as 0.  */\n #define DEFAULT_SIGNED_CHAR 1\n@@ -2213,7 +2214,8 @@ enum cmodel {\n   CM_MEDIUM,\t/* Assumes code fits in the low 31 bits; data unlimited.  */\n   CM_LARGE,\t/* No assumptions.  */\n   CM_SMALL_PIC,\t/* Assumes code+data+got/plt fits in a 31 bit region.  */\n-  CM_MEDIUM_PIC\t/* Assumes code+got/plt fits in a 31 bit region.  */\n+  CM_MEDIUM_PIC,/* Assumes code+got/plt fits in a 31 bit region.  */\n+  CM_LARGE_PIC\t/* No assumptions.  */\n };\n \n extern enum cmodel ix86_cmodel;"}, {"sha": "f66318b86eb67570bab13cecab2f5c1edd8913e4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -58,43 +58,46 @@\n    (UNSPEC_DTPOFF\t\t6)\n    (UNSPEC_GOTNTPOFF\t\t7)\n    (UNSPEC_INDNTPOFF\t\t8)\n+   (UNSPEC_PLTOFF\t\t9)\n \n    ; Prologue support\n    (UNSPEC_STACK_ALLOC\t\t11)\n    (UNSPEC_SET_GOT\t\t12)\n    (UNSPEC_SSE_PROLOGUE_SAVE\t13)\n    (UNSPEC_REG_SAVE\t\t14)\n    (UNSPEC_DEF_CFA\t\t15)\n+   (UNSPEC_SET_RIP\t\t16)\n+   (UNSPEC_SET_GOT_OFFSET\t17)\n \n    ; TLS support\n-   (UNSPEC_TP\t\t\t16)\n-   (UNSPEC_TLS_GD\t\t17)\n-   (UNSPEC_TLS_LD_BASE\t\t18)\n-   (UNSPEC_TLSDESC\t\t19)\n+   (UNSPEC_TP\t\t\t18)\n+   (UNSPEC_TLS_GD\t\t19)\n+   (UNSPEC_TLS_LD_BASE\t\t20)\n+   (UNSPEC_TLSDESC\t\t21)\n \n    ; Other random patterns\n-   (UNSPEC_SCAS\t\t\t20)\n-   (UNSPEC_FNSTSW\t\t21)\n-   (UNSPEC_SAHF\t\t\t22)\n-   (UNSPEC_FSTCW\t\t23)\n-   (UNSPEC_ADD_CARRY\t\t24)\n-   (UNSPEC_FLDCW\t\t25)\n-   (UNSPEC_REP\t\t\t26)\n-   (UNSPEC_EH_RETURN\t\t27)\n-   (UNSPEC_LD_MPIC\t\t28)\t; load_macho_picbase\n-   (UNSPEC_TRUNC_NOOP\t\t29)\n+   (UNSPEC_SCAS\t\t\t30)\n+   (UNSPEC_FNSTSW\t\t31)\n+   (UNSPEC_SAHF\t\t\t32)\n+   (UNSPEC_FSTCW\t\t33)\n+   (UNSPEC_ADD_CARRY\t\t34)\n+   (UNSPEC_FLDCW\t\t35)\n+   (UNSPEC_REP\t\t\t36)\n+   (UNSPEC_EH_RETURN\t\t37)\n+   (UNSPEC_LD_MPIC\t\t38)\t; load_macho_picbase\n+   (UNSPEC_TRUNC_NOOP\t\t39)\n \n    ; For SSE/MMX support:\n-   (UNSPEC_FIX_NOTRUNC\t\t30)\n-   (UNSPEC_MASKMOV\t\t31)\n-   (UNSPEC_MOVMSK\t\t32)\n-   (UNSPEC_MOVNT\t\t33)\n-   (UNSPEC_MOVU\t\t\t34)\n-   (UNSPEC_RCP\t\t\t35)\n-   (UNSPEC_RSQRT\t\t36)\n-   (UNSPEC_SFENCE\t\t37)\n-   (UNSPEC_NOP\t\t\t38)\t; prevents combiner cleverness\n-   (UNSPEC_PFRCP\t\t39)\n+   (UNSPEC_FIX_NOTRUNC\t\t40)\n+   (UNSPEC_MASKMOV\t\t41)\n+   (UNSPEC_MOVMSK\t\t42)\n+   (UNSPEC_MOVNT\t\t43)\n+   (UNSPEC_MOVU\t\t\t44)\n+   (UNSPEC_RCP\t\t\t45)\n+   (UNSPEC_RSQRT\t\t46)\n+   (UNSPEC_SFENCE\t\t47)\n+   (UNSPEC_NOP\t\t\t48)\t; prevents combiner cleverness\n+   (UNSPEC_PFRCP\t\t49)\n    (UNSPEC_PFRCPIT1\t\t40)\n    (UNSPEC_PFRCPIT2\t\t41)\n    (UNSPEC_PFRSQRT\t\t42)\n@@ -14545,14 +14548,22 @@\n (define_insn \"*call_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\n+   && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n {\n   if (constant_call_address_operand (operands[0], Pmode))\n     return \"call\\t%P0\";\n   return \"call\\t%A0\";\n }\n   [(set_attr \"type\" \"call\")])\n \n+(define_insn \"*call_1_rex64_large\"\n+  [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rm\"))\n+\t (match_operand 1 \"\" \"\"))]\n+  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"call\\t%A0\"\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*sibcall_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"constant_call_address_operand\" \"\"))\n \t (match_operand 1 \"\" \"\"))]\n@@ -14769,6 +14780,22 @@\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"length\" \"6\")])\n \n+(define_insn \"set_rip_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"\" \"\")] UNSPEC_SET_RIP))]\n+  \"TARGET_64BIT\"\n+  \"lea{q}\\t%l1(%%rip), %0\"\n+  [(set_attr \"type\" \"lea\")\n+   (set_attr \"length\" \"6\")])\n+\n+(define_insn \"set_got_offset_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"\" \"\")] UNSPEC_SET_GOT_OFFSET))]\n+  \"TARGET_64BIT\"\n+  \"movabs{q}\\t$_GLOBAL_OFFSET_TABLE_-%l1, %0\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"length\" \"11\")])\n+\n (define_expand \"epilogue\"\n   [(const_int 1)]\n   \"\"\n@@ -20941,14 +20968,23 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rsm\"))\n \t      (match_operand:DI 2 \"\" \"\")))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\n+   && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n {\n   if (constant_call_address_operand (operands[1], Pmode))\n     return \"call\\t%P1\";\n   return \"call\\t%A1\";\n }\n   [(set_attr \"type\" \"callv\")])\n \n+(define_insn \"*call_value_1_rex64_large\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rm\"))\n+\t      (match_operand:DI 2 \"\" \"\")))]\n+  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"call\\t%A1\"\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*sibcall_value_1_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))"}, {"sha": "6ac3622ebfe5afaf0ce752479307d3ab99e8746e", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -472,8 +472,9 @@\n \n ;; Test for a pc-relative call operand\n (define_predicate \"constant_call_address_operand\"\n-  (ior (match_code \"symbol_ref\")\n-       (match_operand 0 \"local_symbolic_operand\")))\n+  (and (ior (match_code \"symbol_ref\")\n+            (match_operand 0 \"local_symbolic_operand\"))\n+       (match_test \"ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\")))\n \n ;; True for any non-virtual or eliminable register.  Used in places where\n ;; instantiation of such a register may cause the pattern to not be recognized."}, {"sha": "7e15dbfd0620b3c46ee9fa2a7ce1b469149b81f3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -10142,8 +10142,7 @@ building of shared libraries are not supported with the medium model.\n @item -mcmodel=large\n @opindex mcmodel=large\n Generate code for the large model: This model makes no assumptions\n-about addresses and sizes of sections.  Currently GCC does not implement\n-this model.\n+about addresses and sizes of sections.  \n @end table\n \n @node IA-64 Options"}, {"sha": "e6802b1e8efbd7b838a601dd6bae2f8fb2243f15", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4d7240dccb7d7bb0d39525e07f145092f587dc/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=dc4d7240dccb7d7bb0d39525e07f145092f587dc", "patch": "@@ -3141,7 +3141,8 @@ reg_to_stack (void)\n      the PIC register hasn't been set up.  In that case, fall back\n      on zero, which we can get from `ldz'.  */\n \n-  if (flag_pic && !TARGET_64BIT)\n+  if ((flag_pic && !TARGET_64BIT)\n+      || ix86_cmodel == CM_LARGE || ix86_cmodel == CM_LARGE_PIC)\n     not_a_num = CONST0_RTX (SFmode);\n   else\n     {"}]}