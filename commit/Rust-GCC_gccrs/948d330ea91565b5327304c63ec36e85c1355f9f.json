{"sha": "948d330ea91565b5327304c63ec36e85c1355f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ4ZDMzMGVhOTE1NjViNTMyNzMwNGM2M2VjMzZlODVjMTM1NWY5Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-09T20:56:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-09T20:56:42Z"}, "message": "dwarf2: Move CFI output routines to dwarf2cfi.c.\n\n        * defaults.h (DWARF2_ADDR_SIZE, DWARF_OFFSET_SIZE,\n        DWARF_TYPE_SIGNATURE_SIZE): Move from ...\n        * dwarf2out.c: ... here.\n        (output_all_cfis): Remove.\n        (dwarf2out_switch_text_section): Use output_cfis directly.\n        (size_of_locs): Export.\n        (output_loc_sequence, output_loc_sequence_raw): Export.\n        (div_data_align, need_data_align_sf_opcode, dwarf_cfi_name, output_cfi,\n        output_cfi_directive, dwarf2out_emit_cfi, output_cfis, output_cfa_loc,\n        output_cfa_loc_raw): Move to ...\n        * dwarfcfi.c: ... here.\n        * dwarf2out.h: Update decls.\n\nFrom-SVN: r176107", "tree": {"sha": "4baceac6414ef64f1eefc2424d41690c58980991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4baceac6414ef64f1eefc2424d41690c58980991"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/948d330ea91565b5327304c63ec36e85c1355f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948d330ea91565b5327304c63ec36e85c1355f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948d330ea91565b5327304c63ec36e85c1355f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948d330ea91565b5327304c63ec36e85c1355f9f/comments", "author": null, "committer": null, "parents": [{"sha": "db42e39d8102e057c24ef240294982ed857605b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db42e39d8102e057c24ef240294982ed857605b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db42e39d8102e057c24ef240294982ed857605b5"}], "stats": {"total": 1249, "additions": 619, "deletions": 630}, "files": [{"sha": "436e037cb3637d8bc29a47d6f5db9c1243ffe171", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=948d330ea91565b5327304c63ec36e85c1355f9f", "patch": "@@ -1,3 +1,18 @@\n+2011-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* defaults.h (DWARF2_ADDR_SIZE, DWARF_OFFSET_SIZE,\n+\tDWARF_TYPE_SIGNATURE_SIZE): Move from ...\n+\t* dwarf2out.c: ... here.\n+\t(output_all_cfis): Remove.\n+\t(dwarf2out_switch_text_section): Use output_cfis directly.\n+\t(size_of_locs): Export.\n+\t(output_loc_sequence, output_loc_sequence_raw): Export.\n+\t(div_data_align, need_data_align_sf_opcode, dwarf_cfi_name, output_cfi,\n+\toutput_cfi_directive, dwarf2out_emit_cfi, output_cfis, output_cfa_loc,\n+\toutput_cfa_loc_raw): Move to ...\n+\t* dwarfcfi.c: ... here.\n+\t* dwarf2out.h: Update decls.\n+\n 2011-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* defaults.h (DWARF_CIE_DATA_ALIGNMENT, DWARF_FRAME_RETURN_COLUMN,"}, {"sha": "70c63cecc31e5a84ce9d6e9489599f3047920241", "filename": "gcc/defaults.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=948d330ea91565b5327304c63ec36e85c1355f9f", "patch": "@@ -453,6 +453,28 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define DWARF2_FRAME_REG_OUT(REGNO, FOR_EH) (REGNO)\n #endif\n \n+/* The size of addresses as they appear in the Dwarf 2 data.\n+   Some architectures use word addresses to refer to code locations,\n+   but Dwarf 2 info always uses byte addresses.  On such machines,\n+   Dwarf 2 addresses need to be larger than the architecture's\n+   pointers.  */\n+#ifndef DWARF2_ADDR_SIZE\n+#define DWARF2_ADDR_SIZE (POINTER_SIZE / BITS_PER_UNIT)\n+#endif\n+\n+/* The size in bytes of a DWARF field indicating an offset or length\n+   relative to a debug info section, specified to be 4 bytes in the\n+   DWARF-2 specification.  The SGI/MIPS ABI defines it to be the same\n+   as PTR_SIZE.  */\n+#ifndef DWARF_OFFSET_SIZE\n+#define DWARF_OFFSET_SIZE 4\n+#endif\n+\n+/* The size in bytes of a DWARF 4 type signature.  */\n+#ifndef DWARF_TYPE_SIGNATURE_SIZE\n+#define DWARF_TYPE_SIGNATURE_SIZE 8\n+#endif\n+\n /* Default sizes for base C types.  If the sizes are different for\n    your target, you should override these values by defining the\n    appropriate symbols in your tm.h file.  */"}, {"sha": "5b8420e8f85bb18b70808bc41a78f7cdc03d6e2a", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 567, "deletions": 0, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=948d330ea91565b5327304c63ec36e85c1355f9f", "patch": "@@ -2553,6 +2553,573 @@ execute_dwarf2_frame (void)\n   return 0;\n }\n \f\n+/* Convert a DWARF call frame info. operation to its string name */\n+\n+static const char *\n+dwarf_cfi_name (unsigned int cfi_opc)\n+{\n+  switch (cfi_opc)\n+    {\n+    case DW_CFA_advance_loc:\n+      return \"DW_CFA_advance_loc\";\n+    case DW_CFA_offset:\n+      return \"DW_CFA_offset\";\n+    case DW_CFA_restore:\n+      return \"DW_CFA_restore\";\n+    case DW_CFA_nop:\n+      return \"DW_CFA_nop\";\n+    case DW_CFA_set_loc:\n+      return \"DW_CFA_set_loc\";\n+    case DW_CFA_advance_loc1:\n+      return \"DW_CFA_advance_loc1\";\n+    case DW_CFA_advance_loc2:\n+      return \"DW_CFA_advance_loc2\";\n+    case DW_CFA_advance_loc4:\n+      return \"DW_CFA_advance_loc4\";\n+    case DW_CFA_offset_extended:\n+      return \"DW_CFA_offset_extended\";\n+    case DW_CFA_restore_extended:\n+      return \"DW_CFA_restore_extended\";\n+    case DW_CFA_undefined:\n+      return \"DW_CFA_undefined\";\n+    case DW_CFA_same_value:\n+      return \"DW_CFA_same_value\";\n+    case DW_CFA_register:\n+      return \"DW_CFA_register\";\n+    case DW_CFA_remember_state:\n+      return \"DW_CFA_remember_state\";\n+    case DW_CFA_restore_state:\n+      return \"DW_CFA_restore_state\";\n+    case DW_CFA_def_cfa:\n+      return \"DW_CFA_def_cfa\";\n+    case DW_CFA_def_cfa_register:\n+      return \"DW_CFA_def_cfa_register\";\n+    case DW_CFA_def_cfa_offset:\n+      return \"DW_CFA_def_cfa_offset\";\n+\n+    /* DWARF 3 */\n+    case DW_CFA_def_cfa_expression:\n+      return \"DW_CFA_def_cfa_expression\";\n+    case DW_CFA_expression:\n+      return \"DW_CFA_expression\";\n+    case DW_CFA_offset_extended_sf:\n+      return \"DW_CFA_offset_extended_sf\";\n+    case DW_CFA_def_cfa_sf:\n+      return \"DW_CFA_def_cfa_sf\";\n+    case DW_CFA_def_cfa_offset_sf:\n+      return \"DW_CFA_def_cfa_offset_sf\";\n+\n+    /* SGI/MIPS specific */\n+    case DW_CFA_MIPS_advance_loc8:\n+      return \"DW_CFA_MIPS_advance_loc8\";\n+\n+    /* GNU extensions */\n+    case DW_CFA_GNU_window_save:\n+      return \"DW_CFA_GNU_window_save\";\n+    case DW_CFA_GNU_args_size:\n+      return \"DW_CFA_GNU_args_size\";\n+    case DW_CFA_GNU_negative_offset_extended:\n+      return \"DW_CFA_GNU_negative_offset_extended\";\n+\n+    default:\n+      return \"DW_CFA_<unknown>\";\n+    }\n+}\n+\n+/* This routine will generate the correct assembly data for a location\n+   description based on a cfi entry with a complex address.  */\n+\n+static void\n+output_cfa_loc (dw_cfi_ref cfi, int for_eh)\n+{\n+  dw_loc_descr_ref loc;\n+  unsigned long size;\n+\n+  if (cfi->dw_cfi_opc == DW_CFA_expression)\n+    {\n+      unsigned r = \n+\tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+      dw2_asm_output_data (1, r, NULL);\n+      loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;\n+    }\n+  else\n+    loc = cfi->dw_cfi_oprnd1.dw_cfi_loc;\n+\n+  /* Output the size of the block.  */\n+  size = size_of_locs (loc);\n+  dw2_asm_output_data_uleb128 (size, NULL);\n+\n+  /* Now output the operations themselves.  */\n+  output_loc_sequence (loc, for_eh);\n+}\n+\n+/* Similar, but used for .cfi_escape.  */\n+\n+static void\n+output_cfa_loc_raw (dw_cfi_ref cfi)\n+{\n+  dw_loc_descr_ref loc;\n+  unsigned long size;\n+\n+  if (cfi->dw_cfi_opc == DW_CFA_expression)\n+    {\n+      unsigned r = \n+\tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (asm_out_file, \"%#x,\", r);\n+      loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;\n+    }\n+  else\n+    loc = cfi->dw_cfi_oprnd1.dw_cfi_loc;\n+\n+  /* Output the size of the block.  */\n+  size = size_of_locs (loc);\n+  dw2_asm_output_data_uleb128_raw (size);\n+  fputc (',', asm_out_file);\n+\n+  /* Now output the operations themselves.  */\n+  output_loc_sequence_raw (loc);\n+}\n+\n+/* Output a Call Frame Information opcode and its operand(s).  */\n+\n+void\n+output_cfi (dw_cfi_ref cfi, dw_fde_ref fde, int for_eh)\n+{\n+  unsigned long r;\n+  HOST_WIDE_INT off;\n+\n+  if (cfi->dw_cfi_opc == DW_CFA_advance_loc)\n+    dw2_asm_output_data (1, (cfi->dw_cfi_opc\n+\t\t\t     | (cfi->dw_cfi_oprnd1.dw_cfi_offset & 0x3f)),\n+\t\t\t \"DW_CFA_advance_loc \" HOST_WIDE_INT_PRINT_HEX,\n+\t\t\t ((unsigned HOST_WIDE_INT)\n+\t\t\t  cfi->dw_cfi_oprnd1.dw_cfi_offset));\n+  else if (cfi->dw_cfi_opc == DW_CFA_offset)\n+    {\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+      dw2_asm_output_data (1, (cfi->dw_cfi_opc | (r & 0x3f)),\n+\t\t\t   \"DW_CFA_offset, column %#lx\", r);\n+      off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n+      dw2_asm_output_data_uleb128 (off, NULL);\n+    }\n+  else if (cfi->dw_cfi_opc == DW_CFA_restore)\n+    {\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+      dw2_asm_output_data (1, (cfi->dw_cfi_opc | (r & 0x3f)),\n+\t\t\t   \"DW_CFA_restore, column %#lx\", r);\n+    }\n+  else\n+    {\n+      dw2_asm_output_data (1, cfi->dw_cfi_opc,\n+\t\t\t   \"%s\", dwarf_cfi_name (cfi->dw_cfi_opc));\n+\n+      switch (cfi->dw_cfi_opc)\n+\t{\n+\tcase DW_CFA_set_loc:\n+\t  if (for_eh)\n+\t    dw2_asm_output_encoded_addr_rtx (\n+\t\tASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1, /*global=*/0),\n+\t\tgen_rtx_SYMBOL_REF (Pmode, cfi->dw_cfi_oprnd1.dw_cfi_addr),\n+\t\tfalse, NULL);\n+\t  else\n+\t    dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n+\t\t\t\t cfi->dw_cfi_oprnd1.dw_cfi_addr, NULL);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n+\t  break;\n+\n+\tcase DW_CFA_advance_loc1:\n+\t  dw2_asm_output_delta (1, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n+\t  break;\n+\n+\tcase DW_CFA_advance_loc2:\n+\t  dw2_asm_output_delta (2, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n+\t  break;\n+\n+\tcase DW_CFA_advance_loc4:\n+\t  dw2_asm_output_delta (4, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n+\t  break;\n+\n+\tcase DW_CFA_MIPS_advance_loc8:\n+\t  dw2_asm_output_delta (8, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n+\t  break;\n+\n+\tcase DW_CFA_offset_extended:\n+\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+\t  dw2_asm_output_data_uleb128 (r, NULL);\n+\t  off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n+\t  dw2_asm_output_data_uleb128 (off, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa:\n+\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+\t  dw2_asm_output_data_uleb128 (r, NULL);\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_offset_extended_sf:\n+\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+\t  dw2_asm_output_data_uleb128 (r, NULL);\n+\t  off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n+\t  dw2_asm_output_data_sleb128 (off, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_sf:\n+\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+\t  dw2_asm_output_data_uleb128 (r, NULL);\n+\t  off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n+\t  dw2_asm_output_data_sleb128 (off, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_restore_extended:\n+\tcase DW_CFA_undefined:\n+\tcase DW_CFA_same_value:\n+\tcase DW_CFA_def_cfa_register:\n+\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+\t  dw2_asm_output_data_uleb128 (r, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_register:\n+\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n+\t  dw2_asm_output_data_uleb128 (r, NULL);\n+\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, for_eh);\n+\t  dw2_asm_output_data_uleb128 (r, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_offset:\n+\tcase DW_CFA_GNU_args_size:\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_offset_sf:\n+\t  off = div_data_align (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+\t  dw2_asm_output_data_sleb128 (off, NULL);\n+\t  break;\n+\n+\tcase DW_CFA_GNU_window_save:\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_expression:\n+\tcase DW_CFA_expression:\n+\t  output_cfa_loc (cfi, for_eh);\n+\t  break;\n+\n+\tcase DW_CFA_GNU_negative_offset_extended:\n+\t  /* Obsoleted by DW_CFA_offset_extended_sf.  */\n+\t  gcc_unreachable ();\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Similar, but do it via assembler directives instead.  */\n+\n+void\n+output_cfi_directive (FILE *f, dw_cfi_ref cfi)\n+{\n+  unsigned long r, r2;\n+\n+  switch (cfi->dw_cfi_opc)\n+    {\n+    case DW_CFA_advance_loc:\n+    case DW_CFA_advance_loc1:\n+    case DW_CFA_advance_loc2:\n+    case DW_CFA_advance_loc4:\n+    case DW_CFA_MIPS_advance_loc8:\n+    case DW_CFA_set_loc:\n+      /* Should only be created in a code path not followed when emitting\n+\t via directives.  The assembler is going to take care of this for\n+\t us.  But this routines is also used for debugging dumps, so\n+\t print something.  */\n+      gcc_assert (f != asm_out_file);\n+      fprintf (f, \"\\t.cfi_advance_loc\\n\");\n+      break;\n+\n+    case DW_CFA_offset:\n+    case DW_CFA_offset_extended:\n+    case DW_CFA_offset_extended_sf:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (f, \"\\t.cfi_offset %lu, \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       r, cfi->dw_cfi_oprnd2.dw_cfi_offset);\n+      break;\n+\n+    case DW_CFA_restore:\n+    case DW_CFA_restore_extended:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (f, \"\\t.cfi_restore %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_undefined:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (f, \"\\t.cfi_undefined %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_same_value:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (f, \"\\t.cfi_same_value %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_def_cfa:\n+    case DW_CFA_def_cfa_sf:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (f, \"\\t.cfi_def_cfa %lu, \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       r, cfi->dw_cfi_oprnd2.dw_cfi_offset);\n+      break;\n+\n+    case DW_CFA_def_cfa_register:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      fprintf (f, \"\\t.cfi_def_cfa_register %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_register:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n+      r2 = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, 1);\n+      fprintf (f, \"\\t.cfi_register %lu, %lu\\n\", r, r2);\n+      break;\n+\n+    case DW_CFA_def_cfa_offset:\n+    case DW_CFA_def_cfa_offset_sf:\n+      fprintf (f, \"\\t.cfi_def_cfa_offset \"\n+\t       HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+      break;\n+\n+    case DW_CFA_remember_state:\n+      fprintf (f, \"\\t.cfi_remember_state\\n\");\n+      break;\n+    case DW_CFA_restore_state:\n+      fprintf (f, \"\\t.cfi_restore_state\\n\");\n+      break;\n+\n+    case DW_CFA_GNU_args_size:\n+      if (f == asm_out_file)\n+\t{\n+\t  fprintf (f, \"\\t.cfi_escape %#x,\", DW_CFA_GNU_args_size);\n+\t  dw2_asm_output_data_uleb128_raw (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+\t  if (flag_debug_asm)\n+\t    fprintf (f, \"\\t%s args_size \"HOST_WIDE_INT_PRINT_DEC,\n+\t\t     ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+\t  fputc ('\\n', f);\n+\t}\n+      else\n+\t{\n+\t  fprintf (f, \"\\t.cfi_GNU_args_size \"HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t   cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+\t}\n+      break;\n+\n+    case DW_CFA_GNU_window_save:\n+      fprintf (f, \"\\t.cfi_window_save\\n\");\n+      break;\n+\n+    case DW_CFA_def_cfa_expression:\n+      if (f != asm_out_file)\n+\t{\n+\t  fprintf (f, \"\\t.cfi_def_cfa_expression ...\\n\");\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n+    case DW_CFA_expression:\n+      if (f != asm_out_file)\n+\t{\n+\t  fprintf (f, \"\\t.cfi_cfa_expression ...\\n\");\n+\t  break;\n+\t}\n+      fprintf (f, \"\\t.cfi_escape %#x,\", cfi->dw_cfi_opc);\n+      output_cfa_loc_raw (cfi);\n+      fputc ('\\n', f);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+void\n+dwarf2out_emit_cfi (dw_cfi_ref cfi)\n+{\n+  if (dwarf2out_do_cfi_asm ())\n+    output_cfi_directive (asm_out_file, cfi);\n+}\n+\n+/* Output CFIs from VEC, up to index UPTO, to bring current FDE to the\n+   same state as after executing CFIs in CFI chain.  DO_CFI_ASM is\n+   true if .cfi_* directives shall be emitted, false otherwise.  If it\n+   is false, FDE and FOR_EH are the other arguments to pass to\n+   output_cfi.  */\n+\n+void\n+output_cfis (cfi_vec vec, int upto, bool do_cfi_asm,\n+\t     dw_fde_ref fde, bool for_eh)\n+{\n+  int ix;\n+  struct dw_cfi_struct cfi_buf;\n+  dw_cfi_ref cfi2;\n+  dw_cfi_ref cfi_args_size = NULL, cfi_cfa = NULL, cfi_cfa_offset = NULL;\n+  VEC(dw_cfi_ref, heap) *regs = VEC_alloc (dw_cfi_ref, heap, 32);\n+  unsigned int len, idx;\n+\n+  for (ix = 0; ix < upto + 1; ix++)\n+    {\n+      dw_cfi_ref cfi = ix < upto ? VEC_index (dw_cfi_ref, vec, ix) : NULL;\n+      switch (cfi ? cfi->dw_cfi_opc : DW_CFA_nop)\n+\t{\n+\tcase DW_CFA_advance_loc:\n+\tcase DW_CFA_advance_loc1:\n+\tcase DW_CFA_advance_loc2:\n+\tcase DW_CFA_advance_loc4:\n+\tcase DW_CFA_MIPS_advance_loc8:\n+\tcase DW_CFA_set_loc:\n+\t  /* All advances should be ignored.  */\n+\t  break;\n+\tcase DW_CFA_remember_state:\n+\t  {\n+\t    dw_cfi_ref args_size = cfi_args_size;\n+\n+\t    /* Skip everything between .cfi_remember_state and\n+\t       .cfi_restore_state.  */\n+\t    ix++;\n+\t    if (ix == upto)\n+\t      goto flush_all;\n+\n+\t    for (; ix < upto; ix++)\n+\t      {\n+\t\tcfi2 = VEC_index (dw_cfi_ref, vec, ix);\n+\t\tif (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n+\t\t  break;\n+\t\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n+\t\t  args_size = cfi2;\n+\t\telse\n+\t\t  gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n+\t      }\n+\n+\t    cfi_args_size = args_size;\n+\t    break;\n+\t  }\n+\tcase DW_CFA_GNU_args_size:\n+\t  cfi_args_size = cfi;\n+\t  break;\n+\tcase DW_CFA_GNU_window_save:\n+\t  goto flush_all;\n+\tcase DW_CFA_offset:\n+\tcase DW_CFA_offset_extended:\n+\tcase DW_CFA_offset_extended_sf:\n+\tcase DW_CFA_restore:\n+\tcase DW_CFA_restore_extended:\n+\tcase DW_CFA_undefined:\n+\tcase DW_CFA_same_value:\n+\tcase DW_CFA_register:\n+\tcase DW_CFA_val_offset:\n+\tcase DW_CFA_val_offset_sf:\n+\tcase DW_CFA_expression:\n+\tcase DW_CFA_val_expression:\n+\tcase DW_CFA_GNU_negative_offset_extended:\n+\t  if (VEC_length (dw_cfi_ref, regs)\n+\t      <= cfi->dw_cfi_oprnd1.dw_cfi_reg_num)\n+\t    VEC_safe_grow_cleared (dw_cfi_ref, heap, regs,\n+\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_reg_num + 1);\n+\t  VEC_replace (dw_cfi_ref, regs, cfi->dw_cfi_oprnd1.dw_cfi_reg_num,\n+\t\t       cfi);\n+\t  break;\n+\tcase DW_CFA_def_cfa:\n+\tcase DW_CFA_def_cfa_sf:\n+\tcase DW_CFA_def_cfa_expression:\n+\t  cfi_cfa = cfi;\n+\t  cfi_cfa_offset = cfi;\n+\t  break;\n+\tcase DW_CFA_def_cfa_register:\n+\t  cfi_cfa = cfi;\n+\t  break;\n+\tcase DW_CFA_def_cfa_offset:\n+\tcase DW_CFA_def_cfa_offset_sf:\n+\t  cfi_cfa_offset = cfi;\n+\t  break;\n+\tcase DW_CFA_nop:\n+\t  gcc_assert (cfi == NULL);\n+\tflush_all:\n+\t  len = VEC_length (dw_cfi_ref, regs);\n+\t  for (idx = 0; idx < len; idx++)\n+\t    {\n+\t      cfi2 = VEC_replace (dw_cfi_ref, regs, idx, NULL);\n+\t      if (cfi2 != NULL\n+\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore\n+\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore_extended)\n+\t\t{\n+\t\t  if (do_cfi_asm)\n+\t\t    output_cfi_directive (asm_out_file, cfi2);\n+\t\t  else\n+\t\t    output_cfi (cfi2, fde, for_eh);\n+\t\t}\n+\t    }\n+\t  if (cfi_cfa && cfi_cfa_offset && cfi_cfa_offset != cfi_cfa)\n+\t    {\n+\t      gcc_assert (cfi_cfa->dw_cfi_opc != DW_CFA_def_cfa_expression);\n+\t      cfi_buf = *cfi_cfa;\n+\t      switch (cfi_cfa_offset->dw_cfi_opc)\n+\t\t{\n+\t\tcase DW_CFA_def_cfa_offset:\n+\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa;\n+\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n+\t\t  break;\n+\t\tcase DW_CFA_def_cfa_offset_sf:\n+\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa_sf;\n+\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n+\t\t  break;\n+\t\tcase DW_CFA_def_cfa:\n+\t\tcase DW_CFA_def_cfa_sf:\n+\t\t  cfi_buf.dw_cfi_opc = cfi_cfa_offset->dw_cfi_opc;\n+\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd2;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      cfi_cfa = &cfi_buf;\n+\t    }\n+\t  else if (cfi_cfa_offset)\n+\t    cfi_cfa = cfi_cfa_offset;\n+\t  if (cfi_cfa)\n+\t    {\n+\t      if (do_cfi_asm)\n+\t\toutput_cfi_directive (asm_out_file, cfi_cfa);\n+\t      else\n+\t\toutput_cfi (cfi_cfa, fde, for_eh);\n+\t    }\n+\t  cfi_cfa = NULL;\n+\t  cfi_cfa_offset = NULL;\n+\t  if (cfi_args_size\n+\t      && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n+\t    {\n+\t      if (do_cfi_asm)\n+\t\toutput_cfi_directive (asm_out_file, cfi_args_size);\n+\t      else\n+\t\toutput_cfi (cfi_args_size, fde, for_eh);\n+\t    }\n+\t  cfi_args_size = NULL;\n+\t  if (cfi == NULL)\n+\t    {\n+\t      VEC_free (dw_cfi_ref, heap, regs);\n+\t      return;\n+\t    }\n+\t  else if (do_cfi_asm)\n+\t    output_cfi_directive (asm_out_file, cfi);\n+\t  else\n+\t    output_cfi (cfi, fde, for_eh);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\f\n \n /* Save the result of dwarf2out_do_frame across PCH.\n    This variable is tri-state, with 0 unset, >0 true, <0 false.  */"}, {"sha": "64695060c3b0a9b18c1b81601bdde01dab47a43c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 630, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=948d330ea91565b5327304c63ec36e85c1355f9f", "patch": "@@ -160,30 +160,6 @@ static GTY(()) section *debug_frame_section;\n /* Maximum size (in bytes) of an artificially generated label.  */\n #define MAX_ARTIFICIAL_LABEL_BYTES\t30\n \n-/* The size of addresses as they appear in the Dwarf 2 data.\n-   Some architectures use word addresses to refer to code locations,\n-   but Dwarf 2 info always uses byte addresses.  On such machines,\n-   Dwarf 2 addresses need to be larger than the architecture's\n-   pointers.  */\n-#ifndef DWARF2_ADDR_SIZE\n-#define DWARF2_ADDR_SIZE (POINTER_SIZE / BITS_PER_UNIT)\n-#endif\n-\n-/* The size in bytes of a DWARF field indicating an offset or length\n-   relative to a debug info section, specified to be 4 bytes in the\n-   DWARF-2 specification.  The SGI/MIPS ABI defines it to be the same\n-   as PTR_SIZE.  */\n-\n-#ifndef DWARF_OFFSET_SIZE\n-#define DWARF_OFFSET_SIZE 4\n-#endif\n-\n-/* The size in bytes of a DWARF 4 type signature.  */\n-\n-#ifndef DWARF_TYPE_SIGNATURE_SIZE\n-#define DWARF_TYPE_SIGNATURE_SIZE 8\n-#endif\n-\n /* According to the (draft) DWARF 3 specification, the initial length\n    should either be 4 or 12 bytes.  When it's 12 bytes, the first 4\n    bytes are 0xffffffff, followed by the length stored in the next 8\n@@ -240,14 +216,9 @@ static GTY(()) section *cold_text_section;\n /* Forward declarations for functions defined in this file.  */\n \n static char *stripattributes (const char *);\n-static void output_cfi (dw_cfi_ref, dw_fde_ref, int);\n static void output_call_frame_info (int);\n static void dwarf2out_note_section_used (void);\n \n-/* Support for complex CFA locations.  */\n-static void output_cfa_loc (dw_cfi_ref, int);\n-static void output_cfa_loc_raw (dw_cfi_ref);\n-\n /* Personality decl of current unit.  Used only when assembler does not support\n    personality CFI.  */\n static GTY(()) rtx current_unit_personality;\n@@ -391,98 +362,6 @@ stripattributes (const char *s)\n   return stripped;\n }\n \n-/* Divide OFF by DWARF_CIE_DATA_ALIGNMENT, asserting no remainder.  */\n-\n-static inline HOST_WIDE_INT\n-div_data_align (HOST_WIDE_INT off)\n-{\n-  HOST_WIDE_INT r = off / DWARF_CIE_DATA_ALIGNMENT;\n-  gcc_assert (r * DWARF_CIE_DATA_ALIGNMENT == off);\n-  return r;\n-}\n-\n-/* Return true if we need a signed version of a given opcode\n-   (e.g. DW_CFA_offset_extended_sf vs DW_CFA_offset_extended).  */\n-\n-static inline bool\n-need_data_align_sf_opcode (HOST_WIDE_INT off)\n-{\n-  return DWARF_CIE_DATA_ALIGNMENT < 0 ? off > 0 : off < 0;\n-}\n-\n-/* Convert a DWARF call frame info. operation to its string name */\n-\n-static const char *\n-dwarf_cfi_name (unsigned int cfi_opc)\n-{\n-  switch (cfi_opc)\n-    {\n-    case DW_CFA_advance_loc:\n-      return \"DW_CFA_advance_loc\";\n-    case DW_CFA_offset:\n-      return \"DW_CFA_offset\";\n-    case DW_CFA_restore:\n-      return \"DW_CFA_restore\";\n-    case DW_CFA_nop:\n-      return \"DW_CFA_nop\";\n-    case DW_CFA_set_loc:\n-      return \"DW_CFA_set_loc\";\n-    case DW_CFA_advance_loc1:\n-      return \"DW_CFA_advance_loc1\";\n-    case DW_CFA_advance_loc2:\n-      return \"DW_CFA_advance_loc2\";\n-    case DW_CFA_advance_loc4:\n-      return \"DW_CFA_advance_loc4\";\n-    case DW_CFA_offset_extended:\n-      return \"DW_CFA_offset_extended\";\n-    case DW_CFA_restore_extended:\n-      return \"DW_CFA_restore_extended\";\n-    case DW_CFA_undefined:\n-      return \"DW_CFA_undefined\";\n-    case DW_CFA_same_value:\n-      return \"DW_CFA_same_value\";\n-    case DW_CFA_register:\n-      return \"DW_CFA_register\";\n-    case DW_CFA_remember_state:\n-      return \"DW_CFA_remember_state\";\n-    case DW_CFA_restore_state:\n-      return \"DW_CFA_restore_state\";\n-    case DW_CFA_def_cfa:\n-      return \"DW_CFA_def_cfa\";\n-    case DW_CFA_def_cfa_register:\n-      return \"DW_CFA_def_cfa_register\";\n-    case DW_CFA_def_cfa_offset:\n-      return \"DW_CFA_def_cfa_offset\";\n-\n-    /* DWARF 3 */\n-    case DW_CFA_def_cfa_expression:\n-      return \"DW_CFA_def_cfa_expression\";\n-    case DW_CFA_expression:\n-      return \"DW_CFA_expression\";\n-    case DW_CFA_offset_extended_sf:\n-      return \"DW_CFA_offset_extended_sf\";\n-    case DW_CFA_def_cfa_sf:\n-      return \"DW_CFA_def_cfa_sf\";\n-    case DW_CFA_def_cfa_offset_sf:\n-      return \"DW_CFA_def_cfa_offset_sf\";\n-\n-    /* SGI/MIPS specific */\n-    case DW_CFA_MIPS_advance_loc8:\n-      return \"DW_CFA_MIPS_advance_loc8\";\n-\n-    /* GNU extensions */\n-    case DW_CFA_GNU_window_save:\n-      return \"DW_CFA_GNU_window_save\";\n-    case DW_CFA_GNU_args_size:\n-      return \"DW_CFA_GNU_args_size\";\n-    case DW_CFA_GNU_negative_offset_extended:\n-      return \"DW_CFA_GNU_negative_offset_extended\";\n-\n-    default:\n-      return \"DW_CFA_<unknown>\";\n-    }\n-}\n-\n /* Switch [BACK] to eh_frame_section.  If we don't have an eh_frame_section,\n    switch to the data section instead, and write out a synthetic start label\n    for collect2 the first time around.  */\n@@ -632,454 +511,6 @@ dw_cfi_oprnd2_desc (enum dwarf_call_frame_info cfi)\n     }\n }\n \n-/* Output a Call Frame Information opcode and its operand(s).  */\n-\n-static void\n-output_cfi (dw_cfi_ref cfi, dw_fde_ref fde, int for_eh)\n-{\n-  unsigned long r;\n-  HOST_WIDE_INT off;\n-\n-  if (cfi->dw_cfi_opc == DW_CFA_advance_loc)\n-    dw2_asm_output_data (1, (cfi->dw_cfi_opc\n-\t\t\t     | (cfi->dw_cfi_oprnd1.dw_cfi_offset & 0x3f)),\n-\t\t\t \"DW_CFA_advance_loc \" HOST_WIDE_INT_PRINT_HEX,\n-\t\t\t ((unsigned HOST_WIDE_INT)\n-\t\t\t  cfi->dw_cfi_oprnd1.dw_cfi_offset));\n-  else if (cfi->dw_cfi_opc == DW_CFA_offset)\n-    {\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-      dw2_asm_output_data (1, (cfi->dw_cfi_opc | (r & 0x3f)),\n-\t\t\t   \"DW_CFA_offset, column %#lx\", r);\n-      off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-      dw2_asm_output_data_uleb128 (off, NULL);\n-    }\n-  else if (cfi->dw_cfi_opc == DW_CFA_restore)\n-    {\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-      dw2_asm_output_data (1, (cfi->dw_cfi_opc | (r & 0x3f)),\n-\t\t\t   \"DW_CFA_restore, column %#lx\", r);\n-    }\n-  else\n-    {\n-      dw2_asm_output_data (1, cfi->dw_cfi_opc,\n-\t\t\t   \"%s\", dwarf_cfi_name (cfi->dw_cfi_opc));\n-\n-      switch (cfi->dw_cfi_opc)\n-\t{\n-\tcase DW_CFA_set_loc:\n-\t  if (for_eh)\n-\t    dw2_asm_output_encoded_addr_rtx (\n-\t\tASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1, /*global=*/0),\n-\t\tgen_rtx_SYMBOL_REF (Pmode, cfi->dw_cfi_oprnd1.dw_cfi_addr),\n-\t\tfalse, NULL);\n-\t  else\n-\t    dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n-\t\t\t\t cfi->dw_cfi_oprnd1.dw_cfi_addr, NULL);\n-\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n-\t  break;\n-\n-\tcase DW_CFA_advance_loc1:\n-\t  dw2_asm_output_delta (1, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-\t\t\t\tfde->dw_fde_current_label, NULL);\n-\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n-\t  break;\n-\n-\tcase DW_CFA_advance_loc2:\n-\t  dw2_asm_output_delta (2, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-\t\t\t\tfde->dw_fde_current_label, NULL);\n-\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n-\t  break;\n-\n-\tcase DW_CFA_advance_loc4:\n-\t  dw2_asm_output_delta (4, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-\t\t\t\tfde->dw_fde_current_label, NULL);\n-\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n-\t  break;\n-\n-\tcase DW_CFA_MIPS_advance_loc8:\n-\t  dw2_asm_output_delta (8, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-\t\t\t\tfde->dw_fde_current_label, NULL);\n-\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n-\t  break;\n-\n-\tcase DW_CFA_offset_extended:\n-\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-\t  dw2_asm_output_data_uleb128 (r, NULL);\n-\t  off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-\t  dw2_asm_output_data_uleb128 (off, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_def_cfa:\n-\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-\t  dw2_asm_output_data_uleb128 (r, NULL);\n-\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_offset_extended_sf:\n-\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-\t  dw2_asm_output_data_uleb128 (r, NULL);\n-\t  off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-\t  dw2_asm_output_data_sleb128 (off, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_def_cfa_sf:\n-\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-\t  dw2_asm_output_data_uleb128 (r, NULL);\n-\t  off = div_data_align (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-\t  dw2_asm_output_data_sleb128 (off, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_restore_extended:\n-\tcase DW_CFA_undefined:\n-\tcase DW_CFA_same_value:\n-\tcase DW_CFA_def_cfa_register:\n-\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-\t  dw2_asm_output_data_uleb128 (r, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_register:\n-\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-\t  dw2_asm_output_data_uleb128 (r, NULL);\n-\t  r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, for_eh);\n-\t  dw2_asm_output_data_uleb128 (r, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_def_cfa_offset:\n-\tcase DW_CFA_GNU_args_size:\n-\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_def_cfa_offset_sf:\n-\t  off = div_data_align (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-\t  dw2_asm_output_data_sleb128 (off, NULL);\n-\t  break;\n-\n-\tcase DW_CFA_GNU_window_save:\n-\t  break;\n-\n-\tcase DW_CFA_def_cfa_expression:\n-\tcase DW_CFA_expression:\n-\t  output_cfa_loc (cfi, for_eh);\n-\t  break;\n-\n-\tcase DW_CFA_GNU_negative_offset_extended:\n-\t  /* Obsoleted by DW_CFA_offset_extended_sf.  */\n-\t  gcc_unreachable ();\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Similar, but do it via assembler directives instead.  */\n-\n-void\n-output_cfi_directive (FILE *f, dw_cfi_ref cfi)\n-{\n-  unsigned long r, r2;\n-\n-  switch (cfi->dw_cfi_opc)\n-    {\n-    case DW_CFA_advance_loc:\n-    case DW_CFA_advance_loc1:\n-    case DW_CFA_advance_loc2:\n-    case DW_CFA_advance_loc4:\n-    case DW_CFA_MIPS_advance_loc8:\n-    case DW_CFA_set_loc:\n-      /* Should only be created in a code path not followed when emitting\n-\t via directives.  The assembler is going to take care of this for\n-\t us.  But this routines is also used for debugging dumps, so\n-\t print something.  */\n-      gcc_assert (f != asm_out_file);\n-      fprintf (f, \"\\t.cfi_advance_loc\\n\");\n-      break;\n-\n-    case DW_CFA_offset:\n-    case DW_CFA_offset_extended:\n-    case DW_CFA_offset_extended_sf:\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      fprintf (f, \"\\t.cfi_offset %lu, \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n-\t       r, cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-      break;\n-\n-    case DW_CFA_restore:\n-    case DW_CFA_restore_extended:\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      fprintf (f, \"\\t.cfi_restore %lu\\n\", r);\n-      break;\n-\n-    case DW_CFA_undefined:\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      fprintf (f, \"\\t.cfi_undefined %lu\\n\", r);\n-      break;\n-\n-    case DW_CFA_same_value:\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      fprintf (f, \"\\t.cfi_same_value %lu\\n\", r);\n-      break;\n-\n-    case DW_CFA_def_cfa:\n-    case DW_CFA_def_cfa_sf:\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      fprintf (f, \"\\t.cfi_def_cfa %lu, \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n-\t       r, cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-      break;\n-\n-    case DW_CFA_def_cfa_register:\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      fprintf (f, \"\\t.cfi_def_cfa_register %lu\\n\", r);\n-      break;\n-\n-    case DW_CFA_register:\n-      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      r2 = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, 1);\n-      fprintf (f, \"\\t.cfi_register %lu, %lu\\n\", r, r2);\n-      break;\n-\n-    case DW_CFA_def_cfa_offset:\n-    case DW_CFA_def_cfa_offset_sf:\n-      fprintf (f, \"\\t.cfi_def_cfa_offset \"\n-\t       HOST_WIDE_INT_PRINT_DEC\"\\n\",\n-\t       cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-      break;\n-\n-    case DW_CFA_remember_state:\n-      fprintf (f, \"\\t.cfi_remember_state\\n\");\n-      break;\n-    case DW_CFA_restore_state:\n-      fprintf (f, \"\\t.cfi_restore_state\\n\");\n-      break;\n-\n-    case DW_CFA_GNU_args_size:\n-      if (f == asm_out_file)\n-\t{\n-\t  fprintf (f, \"\\t.cfi_escape %#x,\", DW_CFA_GNU_args_size);\n-\t  dw2_asm_output_data_uleb128_raw (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-\t  if (flag_debug_asm)\n-\t    fprintf (f, \"\\t%s args_size \"HOST_WIDE_INT_PRINT_DEC,\n-\t\t     ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-\t  fputc ('\\n', f);\n-\t}\n-      else\n-\t{\n-\t  fprintf (f, \"\\t.cfi_GNU_args_size \"HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t   cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-\t}\n-      break;\n-\n-    case DW_CFA_GNU_window_save:\n-      fprintf (f, \"\\t.cfi_window_save\\n\");\n-      break;\n-\n-    case DW_CFA_def_cfa_expression:\n-      if (f != asm_out_file)\n-\t{\n-\t  fprintf (f, \"\\t.cfi_def_cfa_expression ...\\n\");\n-\t  break;\n-\t}\n-      /* FALLTHRU */\n-    case DW_CFA_expression:\n-      if (f != asm_out_file)\n-\t{\n-\t  fprintf (f, \"\\t.cfi_cfa_expression ...\\n\");\n-\t  break;\n-\t}\n-      fprintf (f, \"\\t.cfi_escape %#x,\", cfi->dw_cfi_opc);\n-      output_cfa_loc_raw (cfi);\n-      fputc ('\\n', f);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-void\n-dwarf2out_emit_cfi (dw_cfi_ref cfi)\n-{\n-  if (dwarf2out_do_cfi_asm ())\n-    output_cfi_directive (asm_out_file, cfi);\n-}\n-\n-/* Output CFIs from VEC, up to index UPTO, to bring current FDE to the\n-   same state as after executing CFIs in CFI chain.  DO_CFI_ASM is\n-   true if .cfi_* directives shall be emitted, false otherwise.  If it\n-   is false, FDE and FOR_EH are the other arguments to pass to\n-   output_cfi.  */\n-\n-static void\n-output_cfis (cfi_vec vec, int upto, bool do_cfi_asm,\n-\t     dw_fde_ref fde, bool for_eh)\n-{\n-  int ix;\n-  struct dw_cfi_struct cfi_buf;\n-  dw_cfi_ref cfi2;\n-  dw_cfi_ref cfi_args_size = NULL, cfi_cfa = NULL, cfi_cfa_offset = NULL;\n-  VEC(dw_cfi_ref, heap) *regs = VEC_alloc (dw_cfi_ref, heap, 32);\n-  unsigned int len, idx;\n-\n-  for (ix = 0; ix < upto + 1; ix++)\n-    {\n-      dw_cfi_ref cfi = ix < upto ? VEC_index (dw_cfi_ref, vec, ix) : NULL;\n-      switch (cfi ? cfi->dw_cfi_opc : DW_CFA_nop)\n-\t{\n-\tcase DW_CFA_advance_loc:\n-\tcase DW_CFA_advance_loc1:\n-\tcase DW_CFA_advance_loc2:\n-\tcase DW_CFA_advance_loc4:\n-\tcase DW_CFA_MIPS_advance_loc8:\n-\tcase DW_CFA_set_loc:\n-\t  /* All advances should be ignored.  */\n-\t  break;\n-\tcase DW_CFA_remember_state:\n-\t  {\n-\t    dw_cfi_ref args_size = cfi_args_size;\n-\n-\t    /* Skip everything between .cfi_remember_state and\n-\t       .cfi_restore_state.  */\n-\t    ix++;\n-\t    if (ix == upto)\n-\t      goto flush_all;\n-\n-\t    for (; ix < upto; ix++)\n-\t      {\n-\t\tcfi2 = VEC_index (dw_cfi_ref, vec, ix);\n-\t\tif (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n-\t\t  break;\n-\t\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n-\t\t  args_size = cfi2;\n-\t\telse\n-\t\t  gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n-\t      }\n-\n-\t    cfi_args_size = args_size;\n-\t    break;\n-\t  }\n-\tcase DW_CFA_GNU_args_size:\n-\t  cfi_args_size = cfi;\n-\t  break;\n-\tcase DW_CFA_GNU_window_save:\n-\t  goto flush_all;\n-\tcase DW_CFA_offset:\n-\tcase DW_CFA_offset_extended:\n-\tcase DW_CFA_offset_extended_sf:\n-\tcase DW_CFA_restore:\n-\tcase DW_CFA_restore_extended:\n-\tcase DW_CFA_undefined:\n-\tcase DW_CFA_same_value:\n-\tcase DW_CFA_register:\n-\tcase DW_CFA_val_offset:\n-\tcase DW_CFA_val_offset_sf:\n-\tcase DW_CFA_expression:\n-\tcase DW_CFA_val_expression:\n-\tcase DW_CFA_GNU_negative_offset_extended:\n-\t  if (VEC_length (dw_cfi_ref, regs)\n-\t      <= cfi->dw_cfi_oprnd1.dw_cfi_reg_num)\n-\t    VEC_safe_grow_cleared (dw_cfi_ref, heap, regs,\n-\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_reg_num + 1);\n-\t  VEC_replace (dw_cfi_ref, regs, cfi->dw_cfi_oprnd1.dw_cfi_reg_num,\n-\t\t       cfi);\n-\t  break;\n-\tcase DW_CFA_def_cfa:\n-\tcase DW_CFA_def_cfa_sf:\n-\tcase DW_CFA_def_cfa_expression:\n-\t  cfi_cfa = cfi;\n-\t  cfi_cfa_offset = cfi;\n-\t  break;\n-\tcase DW_CFA_def_cfa_register:\n-\t  cfi_cfa = cfi;\n-\t  break;\n-\tcase DW_CFA_def_cfa_offset:\n-\tcase DW_CFA_def_cfa_offset_sf:\n-\t  cfi_cfa_offset = cfi;\n-\t  break;\n-\tcase DW_CFA_nop:\n-\t  gcc_assert (cfi == NULL);\n-\tflush_all:\n-\t  len = VEC_length (dw_cfi_ref, regs);\n-\t  for (idx = 0; idx < len; idx++)\n-\t    {\n-\t      cfi2 = VEC_replace (dw_cfi_ref, regs, idx, NULL);\n-\t      if (cfi2 != NULL\n-\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore\n-\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore_extended)\n-\t\t{\n-\t\t  if (do_cfi_asm)\n-\t\t    output_cfi_directive (asm_out_file, cfi2);\n-\t\t  else\n-\t\t    output_cfi (cfi2, fde, for_eh);\n-\t\t}\n-\t    }\n-\t  if (cfi_cfa && cfi_cfa_offset && cfi_cfa_offset != cfi_cfa)\n-\t    {\n-\t      gcc_assert (cfi_cfa->dw_cfi_opc != DW_CFA_def_cfa_expression);\n-\t      cfi_buf = *cfi_cfa;\n-\t      switch (cfi_cfa_offset->dw_cfi_opc)\n-\t\t{\n-\t\tcase DW_CFA_def_cfa_offset:\n-\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa;\n-\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n-\t\t  break;\n-\t\tcase DW_CFA_def_cfa_offset_sf:\n-\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa_sf;\n-\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n-\t\t  break;\n-\t\tcase DW_CFA_def_cfa:\n-\t\tcase DW_CFA_def_cfa_sf:\n-\t\t  cfi_buf.dw_cfi_opc = cfi_cfa_offset->dw_cfi_opc;\n-\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd2;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n-\t      cfi_cfa = &cfi_buf;\n-\t    }\n-\t  else if (cfi_cfa_offset)\n-\t    cfi_cfa = cfi_cfa_offset;\n-\t  if (cfi_cfa)\n-\t    {\n-\t      if (do_cfi_asm)\n-\t\toutput_cfi_directive (asm_out_file, cfi_cfa);\n-\t      else\n-\t\toutput_cfi (cfi_cfa, fde, for_eh);\n-\t    }\n-\t  cfi_cfa = NULL;\n-\t  cfi_cfa_offset = NULL;\n-\t  if (cfi_args_size\n-\t      && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n-\t    {\n-\t      if (do_cfi_asm)\n-\t\toutput_cfi_directive (asm_out_file, cfi_args_size);\n-\t      else\n-\t\toutput_cfi (cfi_args_size, fde, for_eh);\n-\t    }\n-\t  cfi_args_size = NULL;\n-\t  if (cfi == NULL)\n-\t    {\n-\t      VEC_free (dw_cfi_ref, heap, regs);\n-\t      return;\n-\t    }\n-\t  else if (do_cfi_asm)\n-\t    output_cfi_directive (asm_out_file, cfi);\n-\t  else\n-\t    output_cfi (cfi, fde, for_eh);\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-}\n-\n-/* Like output_cfis, but emit all CFIs in the vector.  */\n-static void\n-output_all_cfis (cfi_vec vec, bool do_cfi_asm,\n-\t\t dw_fde_ref fde, bool for_eh)\n-{\n-  output_cfis (vec, VEC_length (dw_cfi_ref, vec), do_cfi_asm, fde, for_eh);\n-}\n-\n /* Output one FDE.  */\n \n static void\n@@ -1752,14 +1183,17 @@ dwarf2out_switch_text_section (void)\n     = (sect == text_section\n        || (cold_text_section && sect == cold_text_section));\n \n+  fde->dw_fde_switch_cfi_index = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n+\n   if (dwarf2out_do_cfi_asm ())\n     {\n       dwarf2out_do_cfi_startproc (true);\n       /* As this is a different FDE, insert all current CFI instructions\n \t again.  */\n-      output_all_cfis (fde->dw_fde_cfi, true, fde, true);\n+      output_cfis (fde->dw_fde_cfi, fde->dw_fde_switch_cfi_index,\n+\t\t   true, fde, true);\n     }\n-  fde->dw_fde_switch_cfi_index = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n+\n   var_location_switch_text_section ();\n \n   set_cur_line_info_table (sect);\n@@ -2258,7 +1692,6 @@ loc_list_plus_const (dw_loc_list_ref list_head, HOST_WIDE_INT offset)\n #define DWARF_REF_SIZE\t\\\n   (dwarf_version == 2 ? DWARF2_ADDR_SIZE : DWARF_OFFSET_SIZE)\n \n-static unsigned long size_of_locs (dw_loc_descr_ref);\n static unsigned long int get_base_type_offset (dw_die_ref);\n \n /* Return the size of a location descriptor.  */\n@@ -2442,7 +1875,7 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n \n /* Return the size of a series of location descriptors.  */\n \n-static unsigned long\n+unsigned long\n size_of_locs (dw_loc_descr_ref loc)\n {\n   dw_loc_descr_ref l;\n@@ -2471,7 +1904,6 @@ size_of_locs (dw_loc_descr_ref loc)\n static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n static void get_ref_die_offset_label (char *, dw_die_ref);\n static unsigned long int get_ref_die_offset (dw_die_ref);\n-static void output_loc_sequence (dw_loc_descr_ref, int);\n \n /* Output location description stack opcode's operands (if any).\n    The for_eh_or_skip parameter controls whether register numbers are\n@@ -2841,7 +2273,7 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n    info).  This should be suppressed for the cases that have not been converted\n    (i.e. symbolic debug info), by setting the parameter < 0.  See PR47324.  */\n \n-static void\n+void\n output_loc_sequence (dw_loc_descr_ref loc, int for_eh_or_skip)\n {\n   for (; loc != NULL; loc = loc->dw_loc_next)\n@@ -3020,7 +2452,7 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n     }\n }\n \n-static void\n+void\n output_loc_sequence_raw (dw_loc_descr_ref loc)\n {\n   while (1)\n@@ -3053,60 +2485,6 @@ output_loc_sequence_raw (dw_loc_descr_ref loc)\n     }\n }\n \n-/* This routine will generate the correct assembly data for a location\n-   description based on a cfi entry with a complex address.  */\n-\n-static void\n-output_cfa_loc (dw_cfi_ref cfi, int for_eh)\n-{\n-  dw_loc_descr_ref loc;\n-  unsigned long size;\n-\n-  if (cfi->dw_cfi_opc == DW_CFA_expression)\n-    {\n-      unsigned r = \n-\tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, for_eh);\n-      dw2_asm_output_data (1, r, NULL);\n-      loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;\n-    }\n-  else\n-    loc = cfi->dw_cfi_oprnd1.dw_cfi_loc;\n-\n-  /* Output the size of the block.  */\n-  size = size_of_locs (loc);\n-  dw2_asm_output_data_uleb128 (size, NULL);\n-\n-  /* Now output the operations themselves.  */\n-  output_loc_sequence (loc, for_eh);\n-}\n-\n-/* Similar, but used for .cfi_escape.  */\n-\n-static void\n-output_cfa_loc_raw (dw_cfi_ref cfi)\n-{\n-  dw_loc_descr_ref loc;\n-  unsigned long size;\n-\n-  if (cfi->dw_cfi_opc == DW_CFA_expression)\n-    {\n-      unsigned r = \n-\tDWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 1);\n-      fprintf (asm_out_file, \"%#x,\", r);\n-      loc = cfi->dw_cfi_oprnd2.dw_cfi_loc;\n-    }\n-  else\n-    loc = cfi->dw_cfi_oprnd1.dw_cfi_loc;\n-\n-  /* Output the size of the block.  */\n-  size = size_of_locs (loc);\n-  dw2_asm_output_data_uleb128_raw (size);\n-  fputc (',', asm_out_file);\n-\n-  /* Now output the operations themselves.  */\n-  output_loc_sequence_raw (loc);\n-}\n-\n /* This function builds a dwarf location descriptor sequence from a\n    dw_cfa_location, adding the given OFFSET to the result of the\n    expression.  */"}, {"sha": "d41453baceabd86c1edf38aec4d9b0f6fd688aa6", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948d330ea91565b5327304c63ec36e85c1355f9f/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=948d330ea91565b5327304c63ec36e85c1355f9f", "patch": "@@ -228,11 +228,18 @@ extern struct dw_loc_descr_struct *mem_loc_descriptor\n extern enum machine_mode get_address_mode (rtx mem);\n extern dw_fde_ref dwarf2out_alloc_current_fde (void);\n \n+extern unsigned long size_of_locs (dw_loc_descr_ref);\n+extern void output_loc_sequence (dw_loc_descr_ref, int);\n+extern void output_loc_sequence_raw (dw_loc_descr_ref);\n+\n /* Interface from dwarf2cfi.c to dwarf2out.c.  */\n extern void lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc,\n \t\t\t  dw_cfa_location *remember);\n extern bool cfa_equal_p (const dw_cfa_location *, const dw_cfa_location *);\n \n+extern void output_cfi (dw_cfi_ref, dw_fde_ref, int);\n+extern void output_cfis (cfi_vec, int, bool, dw_fde_ref, bool);\n+\n extern GTY(()) cfi_vec cie_cfi_vec;\n \n /* Interface from dwarf2*.c to the rest of the compiler.  */"}]}