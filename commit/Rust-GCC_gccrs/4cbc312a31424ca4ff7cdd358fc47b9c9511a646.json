{"sha": "4cbc312a31424ca4ff7cdd358fc47b9c9511a646", "node_id": "C_kwDOANBUbNoAKDRjYmMzMTJhMzE0MjRjYTRmZjdjZGQzNThmYzQ3YjljOTUxMWE2NDY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-10T12:56:01Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-11T13:52:24Z"}, "message": "Share common ordered comparison code with UN*_EXPR.\n\nMost unordered comparisons can use the result from the ordered\nversion, if the operands are known not to be NAN or if the result is\ntrue.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (class foperator_unordered_lt): New.\n\t(class foperator_relop_unknown): Remove\n\t(class foperator_unordered_le): New.\n\t(class foperator_unordered_gt): New.\n\t(class foperator_unordered_ge): New.\n\t(class foperator_unordered_equal): New.\n\t(floating_op_table::floating_op_table): Replace all UN_EXPR\n\tentries with their appropriate fop_unordered_* counterpart.", "tree": {"sha": "016da7d1463e4d7c36f8be01d843e4bd5121d3a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/016da7d1463e4d7c36f8be01d843e4bd5121d3a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cbc312a31424ca4ff7cdd358fc47b9c9511a646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbc312a31424ca4ff7cdd358fc47b9c9511a646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cbc312a31424ca4ff7cdd358fc47b9c9511a646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbc312a31424ca4ff7cdd358fc47b9c9511a646/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad7cff63de618ed723e5df68f0cc9e950d5769e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7cff63de618ed723e5df68f0cc9e950d5769e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad7cff63de618ed723e5df68f0cc9e950d5769e3"}], "stats": {"total": 140, "additions": 128, "deletions": 12}, "files": [{"sha": "8dd4bcc70c00fb784c99488e9e05609df3e9e057", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 128, "deletions": 12, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc312a31424ca4ff7cdd358fc47b9c9511a646/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc312a31424ca4ff7cdd358fc47b9c9511a646/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=4cbc312a31424ca4ff7cdd358fc47b9c9511a646", "patch": "@@ -1132,24 +1132,140 @@ foperator_ordered::op1_range (frange &r, tree type,\n   return true;\n }\n \n-// Placeholder for unimplemented relational operators.\n+class foperator_unordered_lt : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    if (op1.known_isnan () || op2.known_isnan ())\n+      {\n+\tr = range_true (type);\n+\treturn true;\n+      }\n+    if (!fop_lt.fold_range (r, type, op1, op2, rel))\n+      return false;\n+    // The result is the same as the ordered version when the\n+    // comparison is true or when the operands cannot be NANs.\n+    if (finite_operands_p (op1, op2) || r == range_true (type))\n+      return true;\n+    else\n+      {\n+\tr = range_true_and_false (type);\n+\treturn true;\n+      }\n+  }\n+} fop_unordered_lt;\n \n-class foperator_relop_unknown : public range_operator_float\n+class foperator_unordered_le : public range_operator_float\n {\n   using range_operator_float::fold_range;\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    if (op1.known_isnan () || op2.known_isnan ())\n+      {\n+\tr = range_true (type);\n+\treturn true;\n+      }\n+    if (!fop_le.fold_range (r, type, op1, op2, rel))\n+      return false;\n+    // The result is the same as the ordered version when the\n+    // comparison is true or when the operands cannot be NANs.\n+    if (finite_operands_p (op1, op2) || r == range_true (type))\n+      return true;\n+    else\n+      {\n+\tr = range_true_and_false (type);\n+\treturn true;\n+      }\n+  }\n+} fop_unordered_le;\n \n+class foperator_unordered_gt : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n public:\n   bool fold_range (irange &r, tree type,\n \t\t   const frange &op1, const frange &op2,\n-\t\t   relation_kind) const final override\n+\t\t   relation_kind rel) const final override\n   {\n     if (op1.known_isnan () || op2.known_isnan ())\n-      r = range_true (type);\n+      {\n+\tr = range_true (type);\n+\treturn true;\n+      }\n+    if (!fop_gt.fold_range (r, type, op1, op2, rel))\n+      return false;\n+    // The result is the same as the ordered version when the\n+    // comparison is true or when the operands cannot be NANs.\n+    if (finite_operands_p (op1, op2) || r == range_true (type))\n+      return true;\n     else\n-      r.set_varying (type);\n-    return true;\n+      {\n+\tr = range_true_and_false (type);\n+\treturn true;\n+      }\n+  }\n+} fop_unordered_gt;\n+\n+class foperator_unordered_ge : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    if (op1.known_isnan () || op2.known_isnan ())\n+      {\n+\tr = range_true (type);\n+\treturn true;\n+      }\n+    if (!fop_ge.fold_range (r, type, op1, op2, rel))\n+      return false;\n+    // The result is the same as the ordered version when the\n+    // comparison is true or when the operands cannot be NANs.\n+    if (finite_operands_p (op1, op2) || r == range_true (type))\n+      return true;\n+    else\n+      {\n+\tr = range_true_and_false (type);\n+\treturn true;\n+      }\n+  }\n+} fop_unordered_ge;\n+\n+class foperator_unordered_equal : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    if (op1.known_isnan () || op2.known_isnan ())\n+      {\n+\tr = range_true (type);\n+\treturn true;\n+      }\n+    if (!fop_equal.fold_range (r, type, op1, op2, rel))\n+      return false;\n+    // The result is the same as the ordered version when the\n+    // comparison is true or when the operands cannot be NANs.\n+    if (finite_operands_p (op1, op2) || r == range_true (type))\n+      return true;\n+    else\n+      {\n+\tr = range_true_and_false (type);\n+\treturn true;\n+      }\n   }\n-} fop_unordered_relop_unknown;\n+} fop_unordered_equal;\n \n \n // Instantiate a range_op_table for floating point operations.\n@@ -1174,11 +1290,11 @@ floating_op_table::floating_op_table ()\n   set (LE_EXPR, fop_le);\n   set (GT_EXPR, fop_gt);\n   set (GE_EXPR, fop_ge);\n-  set (UNLE_EXPR, fop_unordered_relop_unknown);\n-  set (UNLT_EXPR, fop_unordered_relop_unknown);\n-  set (UNGE_EXPR, fop_unordered_relop_unknown);\n-  set (UNGT_EXPR, fop_unordered_relop_unknown);\n-  set (UNEQ_EXPR, fop_unordered_relop_unknown);\n+  set (UNLE_EXPR, fop_unordered_le);\n+  set (UNLT_EXPR, fop_unordered_lt);\n+  set (UNGE_EXPR, fop_unordered_ge);\n+  set (UNGT_EXPR, fop_unordered_gt);\n+  set (UNEQ_EXPR, fop_unordered_equal);\n   set (ORDERED_EXPR, fop_ordered);\n   set (UNORDERED_EXPR, fop_unordered);\n }"}]}