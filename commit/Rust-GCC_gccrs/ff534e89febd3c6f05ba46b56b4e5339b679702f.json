{"sha": "ff534e89febd3c6f05ba46b56b4e5339b679702f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY1MzRlODlmZWJkM2M2ZjA1YmE0NmI1NmI0ZTUzMzliNjc5NzAyZg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2010-06-10T16:00:31Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2010-06-10T16:00:31Z"}, "message": "Revert the part of r160394 to fix bootstap with --with-arch=atom.\n\n2010-06-10  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR boostrap/44470\n\t* config/i386/i386.md (*add<mode>_1): Revert revision 160394.\n\t(*addsi_1_zext) <TYPE_LEA>: Likewise.\n\t(add lea splitter): Likewise.\n\t(add_zext lea splitter): Likewise.\n\nFrom-SVN: r160557", "tree": {"sha": "e3732e6fcf01dd17d0d9749321bc0f7643bf320a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3732e6fcf01dd17d0d9749321bc0f7643bf320a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff534e89febd3c6f05ba46b56b4e5339b679702f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff534e89febd3c6f05ba46b56b4e5339b679702f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff534e89febd3c6f05ba46b56b4e5339b679702f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff534e89febd3c6f05ba46b56b4e5339b679702f/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c4d7e5294648dd5cd34652e8f132d7f1ec25f4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4d7e5294648dd5cd34652e8f132d7f1ec25f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c4d7e5294648dd5cd34652e8f132d7f1ec25f4e"}], "stats": {"total": 141, "additions": 77, "deletions": 64}, "files": [{"sha": "725a52d6b9ce4cf5bb6bbee99fbdee1dec4c0515", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff534e89febd3c6f05ba46b56b4e5339b679702f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff534e89febd3c6f05ba46b56b4e5339b679702f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff534e89febd3c6f05ba46b56b4e5339b679702f", "patch": "@@ -1,3 +1,11 @@\n+2010-06-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR boostrap/44470\n+\t* config/i386/i386.md (*add<mode>_1): Revert revision 160394.\n+\t(*addsi_1_zext) <TYPE_LEA>: Likewise.\n+\t(add lea splitter): Likewise.\n+\t(add_zext lea splitter): Likewise.\n+\n 2010-06-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* common.opt (fshow-column): Don't mark as C ObjC C++ ObjC++."}, {"sha": "af9c113f8656b59411d6bfb89476899fff4c2ed3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 69, "deletions": 64, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff534e89febd3c6f05ba46b56b4e5339b679702f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff534e89febd3c6f05ba46b56b4e5339b679702f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ff534e89febd3c6f05ba46b56b4e5339b679702f", "patch": "@@ -6077,17 +6077,18 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*add<mode>_1\"\n-  [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=r,rm,r\")\n+  [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n \t(plus:SWI48\n-\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"%0,0,r\")\n-\t  (match_operand:SWI48 2 \"<general_operand>\" \"<g>,r<i>,l<i>\")))\n+\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"%0,0,r,r\")\n+\t  (match_operand:SWI48 2 \"<general_operand>\" \"<g>,r<i>,0,l<i>\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_LEA:\n-      return \"#\";\n+      operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+      return \"lea{<imodesuffix>}\\t{%a2, %0|%0, %a2}\";\n \n     case TYPE_INCDEC:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n@@ -6100,6 +6101,10 @@\n \t}\n \n     default:\n+      /* Use add as much as possible to replace lea for AGU optimization. */\n+      if (which_alternative == 2 && TARGET_OPT_AGU)\n+        return \"add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+        \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n         return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n@@ -6108,8 +6113,11 @@\n     }\n }\n   [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"2\") \n+     (cond [(and (eq_attr \"alternative\" \"2\") \n+                 (eq (symbol_ref \"TARGET_OPT_AGU\") (const_int 0)))\n \t      (const_string \"lea\")\n+            (eq_attr \"alternative\" \"3\")\n+              (const_string \"lea\")\n \t    (match_operand:SWI48 2 \"incdec_operand\" \"\")\n \t      (const_string \"incdec\")\n \t   ]\n@@ -6138,7 +6146,8 @@\n   switch (get_attr_type (insn))\n     {\n     case TYPE_LEA:\n-      return \"#\";\n+      operands[2] = XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 0);\n+      return \"lea{l}\\t{%a2, %k0|%k0, %a2}\";\n \n     case TYPE_INCDEC:\n       if (operands[2] == const1_rtx)\n@@ -6389,64 +6398,6 @@\n         (const_string \"none\")))\n    (set_attr \"mode\" \"QI\")])\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (match_operand:DI 2 \"x86_64_nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && reload_completed \n-   && ix86_lea_for_add_ok (PLUS, insn, operands)\"\n-  [(set (match_dup 0)\n-\t(plus:DI (match_dup 1)\n-\t\t (match_dup 2)))]\n-  \"\")\n-\n-;; Convert lea to the lea pattern to avoid flags dependency.\n-(define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(plus (match_operand 1 \"register_operand\" \"\")\n-              (match_operand 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && ix86_lea_for_add_ok (PLUS, insn, operands)\n-   && GET_MODE_SIZE (GET_MODE (operands[0])) <= 4\"\n-  [(const_int 0)]\n-{\n-  rtx pat;\n-  enum machine_mode mode = GET_MODE (operands[0]);\n-\n-  if (GET_MODE_SIZE (mode) < 4)\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-  if (mode != Pmode)\n-    {\n-      operands[1] = gen_lowpart (Pmode, operands[1]);\n-      operands[2] = gen_lowpart (Pmode, operands[2]);\n-    }\n-\n-  pat = gen_rtx_PLUS (Pmode, operands[1], operands[2]);\n-  if (Pmode != SImode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n-  DONE;\n-})\n-\n-;; Convert lea to the lea pattern to avoid flags dependency.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(zero_extend:DI\n-\t  (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && reload_completed\n-   && ix86_lea_for_add_ok (PLUS, insn, operands)\"\n-  [(set (match_dup 0)\n-\t(zero_extend:DI (subreg:SI (plus:DI (match_dup 1) (match_dup 2)) 0)))]\n-{\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = gen_lowpart (Pmode, operands[2]);\n-})\n-\n (define_insn \"*add<mode>_2\"\n   [(set (reg FLAGS_REG)\n \t(compare\n@@ -6988,6 +6939,60 @@\n }\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n+\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"x86_64_nonmemory_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed \n+   && ix86_lea_for_add_ok (PLUS, insn, operands)\"\n+  [(set (match_dup 0)\n+\t(plus:DI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"\")\n+\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(plus (match_operand 1 \"register_operand\" \"\")\n+              (match_operand 2 \"nonmemory_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"reload_completed && ix86_lea_for_add_ok (PLUS, insn, operands)\" \n+  [(const_int 0)]\n+{\n+  rtx pat;\n+  /* In -fPIC mode the constructs like (const (unspec [symbol_ref]))\n+     may confuse gen_lowpart.  */\n+  if (GET_MODE (operands[0]) != Pmode)\n+    {\n+      operands[1] = gen_lowpart (Pmode, operands[1]);\n+      operands[2] = gen_lowpart (Pmode, operands[2]);\n+    }\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+  pat = gen_rtx_PLUS (Pmode, operands[1], operands[2]);\n+  if (Pmode != SImode)\n+    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n+  DONE;\n+})\n+\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI\n+\t  (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(set (match_dup 0)\n+\t(zero_extend:DI (subreg:SI (plus:DI (match_dup 1) (match_dup 2)) 0)))]\n+{\n+  operands[1] = gen_lowpart (Pmode, operands[1]);\n+  operands[2] = gen_lowpart (Pmode, operands[2]);\n+})\n \f\n ;; Subtract instructions\n "}]}