{"sha": "db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIwYmYxNGY2YjJhZTllM2ExNTgxNTIyYTljNGI5MGFjNTQ1M2EwNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-12-04T19:35:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-12-04T19:35:23Z"}, "message": "re PR driver/46760 (LTO bootstrap doesn't work with FDO)\n\n\n\tPR tree-optimization/46760\n\t* cgraph.c (cgraph_create_node): Initialize count_materialization_scale.\n\t* cgraph.h (struct cgraph_node): Add count_materialization_scale.\n\t* lto-cgraph.c (lto_output_edge): Fix assert.\n\t(lto_output_node): Output count_materialization_scale.\n\t(output_profile_summary): Output only runs and sum_max.\n\t(input_node): Input count_materialization_scale.\n\t(input_profile_summary): Read data into file specific gcov summary.\n\t(merge_profile_summaries): New function.\n\t(input_cgraph): Update call of input_profile_summary;\n\tcall merge_profile_summaries.\n\t* lto-streamer-in.c (input_cfg): Add count_materialization_scale arg;\n\trescale counts at read in.\n\t(intput_bb): Likewise.\n\t(input_function): Update call of input_bb.\n\t(lto_read_body): Update call of input_cfg.\n\t* lto-streamer.h: Inlclude gcov-io.h\n\t(lto_file_decl_data): Add gcov_ctr_summary.\n\nFrom-SVN: r167458", "tree": {"sha": "b3887b2fc44cec55b580768f354ae76eeb37fa87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3887b2fc44cec55b580768f354ae76eeb37fa87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/comments", "author": null, "committer": null, "parents": [{"sha": "f3007348c3fdb811969f942a6b3466f372067fda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3007348c3fdb811969f942a6b3466f372067fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3007348c3fdb811969f942a6b3466f372067fda"}], "stats": {"total": 175, "additions": 145, "deletions": 30}, "files": [{"sha": "d697ad1b104f59172a69bb5542164b0e87b9f13d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "patch": "@@ -1,3 +1,24 @@\n+2010-12-03  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/46760\n+\t* cgraph.c (cgraph_create_node): Initialize count_materialization_scale.\n+\t* cgraph.h (struct cgraph_node): Add count_materialization_scale.\n+\t* lto-cgraph.c (lto_output_edge): Fix assert.\n+\t(lto_output_node): Output count_materialization_scale.\n+\t(output_profile_summary): Output only runs and sum_max.\n+\t(input_node): Input count_materialization_scale.\n+\t(input_profile_summary): Read data into file specific gcov summary.\n+\t(merge_profile_summaries): New function.\n+\t(input_cgraph): Update call of input_profile_summary;\n+\tcall merge_profile_summaries.\n+\t* lto-streamer-in.c (input_cfg): Add count_materialization_scale arg;\n+\trescale counts at read in.\n+\t(intput_bb): Likewise.\n+\t(input_function): Update call of input_bb.\n+\t(lto_read_body): Update call of input_cfg.\n+\t* lto-streamer.h: Inlclude gcov-io.h\n+\t(lto_file_decl_data): Add gcov_ctr_summary.\n+\n 2010-12-03  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \t* doc/tm.texi.in (Cond. Exec. Macros): Rename node from this ..."}, {"sha": "3ffc38463efa0dfc2236e91e9b5bade97c903807", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "patch": "@@ -478,6 +478,7 @@ cgraph_create_node (void)\n   node->previous = NULL;\n   node->global.estimated_growth = INT_MIN;\n   node->frequency = NODE_FREQUENCY_NORMAL;\n+  node->count_materialization_scale = REG_BR_PROB_BASE;\n   ipa_empty_ref_list (&node->ref_list);\n   cgraph_nodes = node;\n   cgraph_n_nodes++;"}, {"sha": "57a7e3bed221f08b73de7acd68e83b67c6c1276d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "patch": "@@ -233,6 +233,9 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n \n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n+  /* How to scale counts at materialization time; used to merge\n+     LTO units with different number of profile runs.  */\n+  int count_materialization_scale;\n   /* Unique id of the node.  */\n   int uid;\n   /* Ordering of all cgraph nodes.  */"}, {"sha": "140a926909ae6a1144a8e3079d222044a0ec0a35", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 104, "deletions": 23, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "patch": "@@ -302,6 +302,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n       gcc_assert (!(flags & (ECF_LOOPING_CONST_OR_PURE\n \t\t\t     | ECF_MAY_BE_ALLOCA\n \t\t\t     | ECF_SIBCALL\n+\t\t\t     | ECF_LEAF\n \t\t\t     | ECF_NOVOPS)));\n     }\n   lto_output_bitpack (&bp);\n@@ -462,6 +463,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n   lto_output_sleb128_stream (ob->main_stream, node->count);\n+  lto_output_sleb128_stream (ob->main_stream, node->count_materialization_scale);\n \n   if (tag == LTO_cgraph_analyzed_node)\n     {\n@@ -661,12 +663,12 @@ output_profile_summary (struct lto_simple_output_block *ob)\n {\n   if (profile_info)\n     {\n-      /* We do not output num, it is not terribly useful.  */\n+      /* We do not output num, sum_all and run_max, they are not used by\n+\t GCC profile feedback and they are difficult to merge from multiple\n+\t units.  */\n       gcc_assert (profile_info->runs);\n       lto_output_uleb128_stream (ob->main_stream, profile_info->runs);\n-      lto_output_sleb128_stream (ob->main_stream, profile_info->sum_all);\n-      lto_output_sleb128_stream (ob->main_stream, profile_info->run_max);\n-      lto_output_sleb128_stream (ob->main_stream, profile_info->sum_max);\n+      lto_output_uleb128_stream (ob->main_stream, profile_info->sum_max);\n     }\n   else\n     lto_output_uleb128_stream (ob->main_stream, 0);\n@@ -1045,6 +1047,7 @@ input_node (struct lto_file_decl_data *file_data,\n     node = cgraph_node (fn_decl);\n \n   node->count = lto_input_sleb128 (ib);\n+  node->count_materialization_scale = lto_input_sleb128 (ib);\n \n   if (tag == LTO_cgraph_analyzed_node)\n     {\n@@ -1424,32 +1427,108 @@ static struct gcov_ctr_summary lto_gcov_summary;\n \n /* Input profile_info from IB.  */\n static void\n-input_profile_summary (struct lto_input_block *ib)\n+input_profile_summary (struct lto_input_block *ib,\n+\t\t       struct lto_file_decl_data *file_data)\n {\n   unsigned int runs = lto_input_uleb128 (ib);\n   if (runs)\n     {\n-      if (!profile_info)\n-        {\n-\t  profile_info = &lto_gcov_summary;\n-\t  lto_gcov_summary.runs = runs;\n-\t  lto_gcov_summary.sum_all = lto_input_sleb128 (ib);\n-\t  lto_gcov_summary.run_max = lto_input_sleb128 (ib);\n-\t  lto_gcov_summary.sum_max = lto_input_sleb128 (ib);\n-\t}\n-      /* We can support this by scaling all counts to nearest common multiple\n-         of all different runs, but it is perhaps not worth the effort.  */\n-      else if (profile_info->runs != runs\n-\t       || profile_info->sum_all != lto_input_sleb128 (ib)\n-\t       || profile_info->run_max != lto_input_sleb128 (ib)\n-\t       || profile_info->sum_max != lto_input_sleb128 (ib))\n-\tsorry (\"combining units with different profiles is not supported\");\n-      /* We allow some units to have profile and other to not have one.  This will\n-         just make unprofiled units to be size optimized that is sane.  */\n+      file_data->profile_info.runs = runs;\n+      file_data->profile_info.sum_max = lto_input_uleb128 (ib);\n+      if (runs > file_data->profile_info.sum_max)\n+\tfatal_error (\"Corrupted profile info in %s: sum_max is smaller than runs\",\n+\t\t     file_data->file_name);\n     }\n \n }\n \n+/* Rescale profile summaries to the same number of runs in the whole unit.  */\n+\n+static void\n+merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n+{\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j;\n+  gcov_unsigned_t max_runs = 0;\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge;\n+\n+  /* Find unit with maximal number of runs.  If we ever get serious about\n+     roundoff errors, we might also consider computing smallest common\n+     multiply.  */\n+  for (j = 0; (file_data = file_data_vec[j]) != NULL; j++)\n+    if (max_runs < file_data->profile_info.runs)\n+      max_runs = file_data->profile_info.runs;\n+\n+  if (!max_runs)\n+    return;\n+\n+  /* Simple overflow check.  We probably don't need to support that many train\n+     runs. Such a large value probably imply data corruption anyway.  */\n+  if (max_runs > INT_MAX / REG_BR_PROB_BASE)\n+    {\n+      sorry (\"At most %i profile runs is supported. Perhaps corrupted profile?\",\n+\t     INT_MAX / REG_BR_PROB_BASE);\n+      return;\n+    }\n+\n+  profile_info = &lto_gcov_summary;\n+  lto_gcov_summary.runs = max_runs;\n+  lto_gcov_summary.sum_max = 0;\n+\n+  /* Rescale all units to the maximal number of runs.\n+     sum_max can not be easily merged, as we have no idea what files come from\n+     the same run.  We do not use the info anyway, so leave it 0.  */\n+  for (j = 0; (file_data = file_data_vec[j]) != NULL; j++)\n+    if (file_data->profile_info.runs)\n+      {\n+\tint scale = ((REG_BR_PROB_BASE * max_runs\n+\t\t      + file_data->profile_info.runs / 2)\n+\t\t     / file_data->profile_info.runs);\n+\tlto_gcov_summary.sum_max = MAX (lto_gcov_summary.sum_max,\n+\t\t\t\t\t(file_data->profile_info.sum_max\n+\t\t\t\t\t * scale\n+\t\t\t\t\t + REG_BR_PROB_BASE / 2)\n+\t\t\t\t\t/ REG_BR_PROB_BASE);\n+      }\n+\n+  /* Watch roundoff errors.  */\n+  if (lto_gcov_summary.sum_max < max_runs)\n+    lto_gcov_summary.sum_max = max_runs;\n+\n+  /* If merging already happent at WPA time, we are done.  */\n+  if (flag_ltrans)\n+    return;\n+\n+  /* Now compute count_materialization_scale of each node.\n+     During LTRANS we already have values of count_materialization_scale\n+     computed, so just update them.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->local.lto_file_data->profile_info.run_max)\n+      {\n+\tint scale;\n+\tif (node->local.lto_file_data->profile_info.runs)\n+\t  scale =\n+\t     ((node->count_materialization_scale * max_runs\n+\t       + node->local.lto_file_data->profile_info.run_max / 2)\n+\t      / node->local.lto_file_data->profile_info.run_max);\n+\telse\n+\t  scale = node->count_materialization_scale;\n+\tnode->count_materialization_scale = scale;\n+\tif (scale < 0)\n+\t  fatal_error (\"Profile information in %s corrupted\",\n+\t\t       file_data->file_name);\n+\n+\tif (scale == REG_BR_PROB_BASE)\n+\t  continue;\n+\tfor (edge = node->callees; edge; edge = edge->next_callee)\n+\t  edge->count = ((edge->count * scale + REG_BR_PROB_BASE / 2)\n+\t\t\t / REG_BR_PROB_BASE);\n+\tnode->count = ((node->count * scale + REG_BR_PROB_BASE / 2)\n+\t\t       / REG_BR_PROB_BASE);\n+      }\n+}\n+\n /* Input and merge the cgraph from each of the .o files passed to\n    lto1.  */\n \n@@ -1473,7 +1552,7 @@ input_cgraph (void)\n \t\t\t\t\t  &data, &len);\n       if (!ib) \n \tfatal_error (\"cannot find LTO cgraph in %s\", file_data->file_name);\n-      input_profile_summary (ib);\n+      input_profile_summary (ib, file_data);\n       file_data->cgraph_node_encoder = lto_cgraph_encoder_new ();\n       nodes = input_cgraph_1 (file_data, ib);\n       lto_destroy_simple_input_block (file_data, LTO_section_cgraph,\n@@ -1499,6 +1578,8 @@ input_cgraph (void)\n       VEC_free (cgraph_node_ptr, heap, nodes);\n       VEC_free (varpool_node_ptr, heap, varpool);\n     }\n+  merge_profile_summaries (file_data_vec);\n+    \n \n   /* Clear out the aux field that was used to store enough state to\n      tell which nodes should be overwritten.  */"}, {"sha": "fb201449c4f45a1aa5fd2533943554c0a9af1255", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "patch": "@@ -719,7 +719,8 @@ make_new_block (struct function *fn, unsigned int index)\n /* Read the CFG for function FN from input block IB.  */\n \n static void\n-input_cfg (struct lto_input_block *ib, struct function *fn)\n+input_cfg (struct lto_input_block *ib, struct function *fn,\n+\t   int count_materialization_scale)\n {\n   unsigned int bb_count;\n   basic_block p_bb;\n@@ -752,7 +753,8 @@ input_cfg (struct lto_input_block *ib, struct function *fn)\n       if (bb == NULL)\n \tbb = make_new_block (fn, index);\n \n-      edge_count = lto_input_uleb128 (ib);\n+      edge_count = (lto_input_uleb128 (ib) * count_materialization_scale\n+\t\t    + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n \n       /* Connect up the CFG.  */\n       for (i = 0; i < edge_count; i++)\n@@ -1066,7 +1068,8 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \n static void\n input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n-\t  struct data_in *data_in, struct function *fn)\n+\t  struct data_in *data_in, struct function *fn,\n+\t  int count_materialization_scale)\n {\n   unsigned int index;\n   basic_block bb;\n@@ -1079,7 +1082,8 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n   index = lto_input_uleb128 (ib);\n   bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n \n-  bb->count = lto_input_sleb128 (ib);\n+  bb->count = (lto_input_sleb128 (ib) * count_materialization_scale\n+\t       + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n   bb->loop_depth = lto_input_sleb128 (ib);\n   bb->frequency = lto_input_sleb128 (ib);\n   bb->flags = lto_input_sleb128 (ib);\n@@ -1253,12 +1257,14 @@ input_function (tree fn_decl, struct data_in *data_in,\n   DECL_INITIAL (fn_decl) = lto_input_tree (ib, data_in);\n   gcc_assert (DECL_INITIAL (fn_decl));\n   DECL_SAVED_TREE (fn_decl) = NULL_TREE;\n+  node = cgraph_node (fn_decl);\n \n   /* Read all the basic blocks.  */\n   tag = input_record_start (ib);\n   while (tag)\n     {\n-      input_bb (ib, tag, data_in, fn);\n+      input_bb (ib, tag, data_in, fn,\n+\t\tnode->count_materialization_scale);\n       tag = input_record_start (ib);\n     }\n \n@@ -1300,7 +1306,6 @@ input_function (tree fn_decl, struct data_in *data_in,\n     gimple_set_body (fn_decl, bb_seq (ei_edge (ei)->dest));\n   }\n \n-  node = cgraph_node (fn_decl);\n   fixup_call_stmt_edges (node, stmts);\n   execute_all_ipa_stmt_fixups (node, stmts);\n \n@@ -1393,6 +1398,7 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n     {\n       struct function *fn = DECL_STRUCT_FUNCTION (fn_decl);\n       struct lto_in_decl_state *decl_state;\n+      struct cgraph_node *node = cgraph_node (fn_decl);\n \n       push_cfun (fn);\n       init_tree_ssa (fn);\n@@ -1402,7 +1408,7 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n       gcc_assert (decl_state);\n       file_data->current_decl_state = decl_state;\n \n-      input_cfg (&ib_cfg, fn);\n+      input_cfg (&ib_cfg, fn, node->count_materialization_scale);\n \n       /* Set up the struct function.  */\n       input_function (fn_decl, data_in, &ib_main);"}, {"sha": "b82c54ede1cb91bd65a0243b927aeb98dea785cc", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=db0bf14f6b2ae9e3a1581522a9c4b90ac5453a06", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"vecprim.h\"\n #include \"alloc-pool.h\"\n+#include \"gcov-io.h\"\n \n /* Define when debugging the LTO streamer.  This causes the writer\n    to output the numeric value for the memory address of the tree node\n@@ -610,6 +611,8 @@ struct GTY(()) lto_file_decl_data\n \n   /* Symbol resolutions for this file */\n   VEC(ld_plugin_symbol_resolution_t,heap) * GTY((skip)) resolutions;\n+\n+  struct gcov_ctr_summary GTY((skip)) profile_info;\n };\n \n typedef struct lto_file_decl_data *lto_file_decl_data_ptr;"}]}