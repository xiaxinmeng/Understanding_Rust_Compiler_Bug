{"sha": "432f982f5c2f65daa1d65a9af2fbfc585c88f114", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyZjk4MmY1YzJmNjVkYWExZDY1YTlhZjJmYmZjNTg1Yzg4ZjExNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-12T16:32:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-12T16:32:12Z"}, "message": "re PR rtl-optimization/12826 (Optimizer removes reference through volatile pointer)\n\n\tPR opt/12826\n\t* loop.c (insert_loop_mem): Preffer VOLATILE memory references to be\n\tstored.\n\n\tPR opt/12863\n\t* cfgcleanup.c (label_is_jump_target_p): Move to...\n\t* rtlanal.c (label_is_jump_target_p): ... here.\n\t* cfgrtl.c (cfg_layout_redirect_edge_and_branch):  Fix redirecting of fallthru\n\tedges unified with branch edges.\n\nFrom-SVN: r75733", "tree": {"sha": "7bcdf745057a80c4e44eb2fff2033e874e50eea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bcdf745057a80c4e44eb2fff2033e874e50eea6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/432f982f5c2f65daa1d65a9af2fbfc585c88f114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432f982f5c2f65daa1d65a9af2fbfc585c88f114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432f982f5c2f65daa1d65a9af2fbfc585c88f114", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432f982f5c2f65daa1d65a9af2fbfc585c88f114/comments", "author": null, "committer": null, "parents": [{"sha": "9a249c79b355459f3623cfbf8c0f2f6925d1a280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a249c79b355459f3623cfbf8c0f2f6925d1a280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a249c79b355459f3623cfbf8c0f2f6925d1a280"}], "stats": {"total": 83, "additions": 53, "deletions": 30}, "files": [{"sha": "da3258f66b1ad7cf8b03becbf4821e254201a6e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=432f982f5c2f65daa1d65a9af2fbfc585c88f114", "patch": "@@ -1,3 +1,15 @@\n+2004-01-12  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR opt/12826\n+\t* loop.c (insert_loop_mem): Preffer VOLATILE memory references to be\n+\tstored.\n+\n+\tPR opt/12863\n+\t* cfgcleanup.c (label_is_jump_target_p): Move to...\n+\t* rtlanal.c (label_is_jump_target_p): ... here.\n+\t* cfgrtl.c (cfg_layout_redirect_edge_and_branch):  Fix redirecting of fallthru\n+\tedges unified with branch edges.\n+\n 2004-01-12  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* simplify-rtx.c (simplify_immed_subreg): Correctly extract the"}, {"sha": "3e68cbe3a173d170fe71abb11542d46ee2e879a4", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=432f982f5c2f65daa1d65a9af2fbfc585c88f114", "patch": "@@ -73,7 +73,6 @@ static bool outgoing_edges_match (int, basic_block, basic_block);\n static int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n static bool insns_match_p (int, rtx, rtx);\n \n-static bool label_is_jump_target_p (rtx, rtx);\n static bool tail_recursion_label_p (rtx);\n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n@@ -646,33 +645,6 @@ try_forward_edges (int mode, basic_block b)\n   return changed;\n }\n \f\n-/* Return true if LABEL is a target of JUMP_INSN.  This applies only\n-   to non-complex jumps.  That is, direct unconditional, conditional,\n-   and tablejumps, but not computed jumps or returns.  It also does\n-   not apply to the fallthru case of a conditional jump.  */\n-\n-static bool\n-label_is_jump_target_p (rtx label, rtx jump_insn)\n-{\n-  rtx tmp = JUMP_LABEL (jump_insn);\n-\n-  if (label == tmp)\n-    return true;\n-\n-  if (tablejump_p (jump_insn, NULL, &tmp))\n-    {\n-      rtvec vec = XVEC (PATTERN (tmp),\n-\t\t\tGET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC);\n-      int i, veclen = GET_NUM_ELEM (vec);\n-\n-      for (i = 0; i < veclen; ++i)\n-\tif (XEXP (RTVEC_ELT (vec, i), 0) == label)\n-\t  return true;\n-    }\n-\n-  return false;\n-}\n-\n /* Return true if LABEL is used for tail recursion.  */\n \n static bool"}, {"sha": "7839d5bf75097ed027d9ee887919073dc314c139", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=432f982f5c2f65daa1d65a9af2fbfc585c88f114", "patch": "@@ -2463,10 +2463,18 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n     {\n       /* Redirect any branch edges unified with the fallthru one.  */\n       if (GET_CODE (BB_END (src)) == JUMP_INSN\n-\t  && JUMP_LABEL (BB_END (src)) == BB_HEAD (e->dest))\n+\t  && label_is_jump_target_p (BB_HEAD (e->dest),\n+\t\t\t\t     BB_END (src)))\n \t{\n-          if (!redirect_jump (BB_END (src), block_label (dest), 0))\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Fallthru edge unified with branch \"\n+\t\t     \"%i->%i redirected to %i\\n\",\n+\t\t     e->src->index, e->dest->index, dest->index);\n+\t  e->flags &= ~EDGE_FALLTHRU;\n+\t  if (!redirect_branch_edge (e, dest))\n \t    abort ();\n+\t  e->flags |= EDGE_FALLTHRU;\n+\t  return true;\n \t}\n       /* In case we are redirecting fallthru edge to the branch edge\n          of conditional jump, remove it.  */"}, {"sha": "21369dec22e16f6e9ec715a8a350ab79ac786283", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=432f982f5c2f65daa1d65a9af2fbfc585c88f114", "patch": "@@ -9561,6 +9561,8 @@ insert_loop_mem (rtx *mem, void *data ATTRIBUTE_UNUSED)\n   for (i = 0; i < loop_info->mems_idx; ++i)\n     if (rtx_equal_p (m, loop_info->mems[i].mem))\n       {\n+\tif (MEM_VOLATILE_P (m) && !MEM_VOLATILE_P (loop_info->mems[i].mem))\n+\t  loop_info->mems[i].mem = m;\n \tif (GET_MODE (m) != GET_MODE (loop_info->mems[i].mem))\n \t  /* The modes of the two memory accesses are different.  If\n \t     this happens, something tricky is going on, and we just"}, {"sha": "efd0e8b4d861f0c792bbb2557994b8e93f0b0dc2", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=432f982f5c2f65daa1d65a9af2fbfc585c88f114", "patch": "@@ -1725,6 +1725,7 @@ extern int insns_safe_to_move_p (rtx, rtx, rtx *);\n extern int loc_mentioned_in_p (rtx *, rtx);\n extern rtx find_first_parameter_load (rtx, rtx);\n extern bool keep_with_call_p (rtx);\n+extern bool label_is_jump_target_p (rtx, rtx);\n \n /* flow.c */\n "}, {"sha": "15c4879eb0b272e9d7ecdeb0875af23d7e507115", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432f982f5c2f65daa1d65a9af2fbfc585c88f114/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=432f982f5c2f65daa1d65a9af2fbfc585c88f114", "patch": "@@ -3709,3 +3709,31 @@ hoist_insn_to_edge (rtx insn, edge e, rtx val, rtx new)\n   end_sequence ();\n   return new_insn;\n }\n+\n+/* Return true if LABEL is a target of JUMP_INSN.  This applies only\n+   to non-complex jumps.  That is, direct unconditional, conditional,\n+   and tablejumps, but not computed jumps or returns.  It also does\n+   not apply to the fallthru case of a conditional jump.  */\n+\n+bool\n+label_is_jump_target_p (rtx label, rtx jump_insn)\n+{\n+  rtx tmp = JUMP_LABEL (jump_insn);\n+\n+  if (label == tmp)\n+    return true;\n+\n+  if (tablejump_p (jump_insn, NULL, &tmp))\n+    {\n+      rtvec vec = XVEC (PATTERN (tmp),\n+\t\t\tGET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC);\n+      int i, veclen = GET_NUM_ELEM (vec);\n+\n+      for (i = 0; i < veclen; ++i)\n+\tif (XEXP (RTVEC_ELT (vec, i), 0) == label)\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+"}]}