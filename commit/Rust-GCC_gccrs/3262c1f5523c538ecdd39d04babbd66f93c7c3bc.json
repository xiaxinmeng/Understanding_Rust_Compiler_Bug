{"sha": "3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI2MmMxZjU1MjNjNTM4ZWNkZDM5ZDA0YmFiYmQ2NmY5M2M3YzNiYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-07T00:48:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-07T00:48:53Z"}, "message": "rtl.def (DEFINE_COND_EXEC): New.\n\n\t* rtl.def (DEFINE_COND_EXEC): New.\n\t* md.texi: Document it.\n\n\t* gensupport.c (input_file): Remove.\n\t(struct queue_elem): Add lineno.\n\t(rtx_ready_queue): Remove.\n\t(errors): New.\n\t(predicable_default): New.\n\t(predicable_true, predicable_false): New.\n\t(define_attr_queue, define_attr_tail): New.\n\t(define_insn_queue, define_insn_tail): New.\n\t(define_cond_exec_queue, define_cond_exec_tail): New.\n\t(other_queue, other_tail): New.\n\t(queue_pattern): New.\n\t(process_rtx): Add patterns to the appropriate queues.\n\t(is_predicable, identify_predicable_attribute): New.\n\t(n_alternatives, collect_insn_data): New.\n\t(alter_predicate_for_insn, alter_test_for_insn): New.\n\t(shift_output_template, alter_output_for_insn): New.\n\t(process_one_cond_exec, process_define_cond_exec): New.\n\t(init_md_reader): Read the entire file.  Process define_cond_exec.\n\t(read_md_rtx): Return elements from the queues.\n\nFrom-SVN: r33751", "tree": {"sha": "3b0e97f95773667e75f99846a5ed03bc396e5a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b0e97f95773667e75f99846a5ed03bc396e5a12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/comments", "author": null, "committer": null, "parents": [{"sha": "9444af72b4d9a9b5cb9289e13a624ff5731b2797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9444af72b4d9a9b5cb9289e13a624ff5731b2797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9444af72b4d9a9b5cb9289e13a624ff5731b2797"}], "stats": {"total": 920, "additions": 830, "deletions": 90}, "files": [{"sha": "928ccf7da67880a81feb77b94de83c04c93a2e10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "patch": "@@ -1,3 +1,28 @@\n+2000-05-06  Richard Henderson  <rth@cygnus.com>\n+\n+\t* rtl.def (DEFINE_COND_EXEC): New.\n+\t* md.texi: Document it.\n+\n+\t* gensupport.c (input_file): Remove.\n+\t(struct queue_elem): Add lineno.\n+\t(rtx_ready_queue): Remove.\n+\t(errors): New.\n+\t(predicable_default): New.\n+\t(predicable_true, predicable_false): New.\n+\t(define_attr_queue, define_attr_tail): New.\n+\t(define_insn_queue, define_insn_tail): New.\n+\t(define_cond_exec_queue, define_cond_exec_tail): New.\n+\t(other_queue, other_tail): New.\n+\t(queue_pattern): New.\n+\t(process_rtx): Add patterns to the appropriate queues.\n+\t(is_predicable, identify_predicable_attribute): New.\n+\t(n_alternatives, collect_insn_data): New.\n+\t(alter_predicate_for_insn, alter_test_for_insn): New.\n+\t(shift_output_template, alter_output_for_insn): New.\n+\t(process_one_cond_exec, process_define_cond_exec): New.\n+\t(init_md_reader): Read the entire file.  Process define_cond_exec.\n+\t(read_md_rtx): Return elements from the queues.\n+\n 2000-05-06  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (mark_set_1): Don't update conditional life info"}, {"sha": "317d359b7e719682d631476a04810af9ef5c6353", "filename": "gcc/gensupport.c", "status": "modified", "additions": 710, "deletions": 90, "changes": 800, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "patch": "@@ -32,19 +32,49 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-static FILE *input_file;\n-\n static int sequence_num;\n+static int errors;\n+\n+static int predicable_default;\n+static const char *predicable_true;\n+static const char *predicable_false;\n+\n+/* We initially queue all patterns, process the define_insn and\n+   define_cond_exec patterns, then return them one at a time.  */\n \n-struct queue_elem {\n-    rtx data;\n-    struct queue_elem *next;\n+struct queue_elem\n+{\n+  rtx data;\n+  int lineno;\n+  struct queue_elem *next;\n };\n \n-static struct queue_elem *rtx_ready_queue;\n+static struct queue_elem *define_attr_queue;\n+static struct queue_elem **define_attr_tail = &define_attr_queue;\n+static struct queue_elem *define_insn_queue;\n+static struct queue_elem **define_insn_tail = &define_insn_queue;\n+static struct queue_elem *define_cond_exec_queue;\n+static struct queue_elem **define_cond_exec_tail = &define_cond_exec_queue;\n+static struct queue_elem *other_queue;\n+static struct queue_elem **other_tail = &other_queue;\n \n+static void queue_pattern PARAMS ((rtx, struct queue_elem ***, int));\n static void remove_constraints PARAMS ((rtx));\n-static void process_rtx PARAMS ((rtx *));\n+static void process_rtx PARAMS ((rtx, int));\n+\n+static int is_predicable PARAMS ((struct queue_elem *));\n+static void identify_predicable_attribute PARAMS ((void));\n+static int n_alternatives PARAMS ((const char *));\n+static void collect_insn_data PARAMS ((rtx, int *, int *));\n+static rtx alter_predicate_for_insn PARAMS ((rtx, int, int, int));\n+static const char *alter_test_for_insn PARAMS ((struct queue_elem *,\n+\t\t\t\t\t\tstruct queue_elem *));\n+static char *shift_output_template PARAMS ((char *, const char *, int));\n+static const char *alter_output_for_insn PARAMS ((struct queue_elem *,\n+\t\t\t\t\t\t  struct queue_elem *,\n+\t\t\t\t\t\t  int, int));\n+static void process_one_cond_exec PARAMS ((struct queue_elem *));\n+static void process_define_cond_exec PARAMS ((void));\n \f\n void\n message_with_line VPARAMS ((int lineno, const char *msg, ...))\n@@ -69,6 +99,22 @@ message_with_line VPARAMS ((int lineno, const char *msg, ...))\n   va_end (ap);\n }\n \f\n+/* Queue PATTERN on LIST_TAIL.  */\n+\n+static void\n+queue_pattern (pattern, list_tail, lineno)\n+     rtx pattern;\n+     struct queue_elem ***list_tail;\n+     int lineno;\n+{\n+  struct queue_elem *e = (struct queue_elem *) xmalloc (sizeof (*e));\n+  e->data = pattern;\n+  e->lineno = lineno;\n+  e->next = NULL;\n+  **list_tail = e;\n+  *list_tail = &e->next;\n+}\n+\n /* Recursively remove constraints from an rtx.  */\n \n static void\n@@ -103,64 +149,617 @@ remove_constraints (part)\n       }\n }\n \n-/* Handle any synthetic top level rtx, i.e. anything except:\n-       DEFINE_INSN\n-       DEFINE_EXPAND\n-       DEFINE_SPLIT\n-       DEFINE_PEEPHOLE\n-       DEFINE_PEEPHOLE2\n-       DEFINE_ATTRIBUTE\n-       DEFINE_FUNCTION_UNIT\n-       DEFINE_ASM_ATTRIBUTES */\n+/* Process a top level rtx in some way, queueing as appropriate.  */\n \n static void\n-process_rtx (desc)\n-    rtx* desc;\n-{\n-  if (GET_CODE (*desc) == DEFINE_INSN_AND_SPLIT) \n-    {\n-      struct queue_elem* elem = xmalloc (sizeof (struct queue_elem));\n-      const char *split_cond;\n-  \n-      /* Create a split with values from the insn_and_split. */\n-      rtx split = rtx_alloc (DEFINE_SPLIT);\n-      XEXP (split, 0) = copy_rtx (XEXP (*desc, 1));\n-      remove_constraints (XEXP (split, 0));\n-      split_cond = XSTR (split, 1) = XSTR (*desc, 4);\n-  \n-      /* If the split condition starts with \"&&\", append it to the\n-         insn condition to create the new split condition.  */\n-      if (split_cond[0] == '&' && split_cond[1] == '&')\n-        {\n-\tconst char *insn_cond = XSTR (*desc, 2);\n-  \tchar *combined = \n-  \t    xmalloc (strlen (insn_cond) + strlen (split_cond) + 1);\n-  \tstrcpy (combined, insn_cond);\n-  \tstrcat (combined, split_cond);\n-  \tXSTR (split, 1) = combined;\n-        }\n-  \n-      XVEC (split, 2) = XVEC (*desc, 5);\n-      XSTR (split, 3) = XSTR (*desc, 6);\n-  \n-      /* Fix up the DEFINE_INSN.  */\n-      PUT_CODE (*desc, DEFINE_INSN);\n-      XVEC (*desc, 4) = XVEC (*desc, 7);\n-  \n-      /* Return the DEFINE_INSN part, and put the DEFINE_SPLIT\n-         in the queue.  */\n-      elem->next = rtx_ready_queue;\n-      elem->data = split;\t\n-      rtx_ready_queue = elem;  \n+process_rtx (desc, lineno)\n+     rtx desc;\n+     int lineno;\n+{\n+  switch (GET_CODE (desc))\n+    {\n+    case DEFINE_INSN:\n+      queue_pattern (desc, &define_insn_tail, lineno);\n+      break;\n+\n+    case DEFINE_COND_EXEC:\n+      queue_pattern (desc, &define_cond_exec_tail, lineno);\n+      break;\n+\n+    case DEFINE_ATTR:\n+      queue_pattern (desc, &define_attr_tail, lineno);\n+      break;\n+\n+    case DEFINE_INSN_AND_SPLIT:\n+      {\n+\tconst char *split_cond;\n+\trtx split;\n+\n+\t/* Create a split with values from the insn_and_split. */\n+\tsplit = rtx_alloc (DEFINE_SPLIT);\n+\tXEXP (split, 0) = copy_rtx (XEXP (desc, 1));\n+\tremove_constraints (XEXP (split, 0));\n+\n+\t/* If the split condition starts with \"&&\", append it to the\n+\t   insn condition to create the new split condition.  */\n+\tsplit_cond = XSTR (desc, 4);\n+\tif (split_cond[0] == '&' && split_cond[1] == '&')\n+\t  {\n+\t    const char *insn_cond = XSTR (desc, 2);\n+\t    size_t insn_cond_len = strlen (insn_cond);\n+\t    size_t split_cond_len = strlen (split_cond);\n+\t    char *combined;\n+\n+\t    combined = (char *) xmalloc (insn_cond_len + split_cond_len + 1);\n+\t    memcpy (combined, insn_cond, insn_cond_len);\n+\t    memcpy (combined + insn_cond_len, split_cond, split_cond_len + 1);\n+\n+\t    split_cond = combined;\n+\t  }\n+\tXSTR (split, 1) = split_cond;\n+\tXVEC (split, 2) = XVEC (desc, 5);\n+\tXSTR (split, 3) = XSTR (desc, 6);\n+\n+\t/* Fix up the DEFINE_INSN.  */\n+\tPUT_CODE (desc, DEFINE_INSN);\n+\tXVEC (desc, 4) = XVEC (desc, 7);\n+\n+\t/* Queue them.  */\n+\tqueue_pattern (desc, &define_insn_tail, lineno);\n+\tqueue_pattern (split, &other_tail, lineno);\n+\tbreak;\n+      }\n+\n+    default:\n+      queue_pattern (desc, &other_tail, lineno);\n+      break;\n     }\n }\n \f\n+/* Return true if attribute PREDICABLE is true for ELEM, which holds\n+   a DEFINE_INSN.  */\n+\n+static int\n+is_predicable (elem)\n+     struct queue_elem *elem;\n+{\n+  rtvec vec = XVEC (elem->data, 4);\n+  const char *value;\n+  int i;\n+\n+  if (! vec)\n+    return predicable_default;\n+\n+  for (i = GET_NUM_ELEM (vec) - 1; i >= 0; --i)\n+    {\n+      rtx sub = RTVEC_ELT (vec, i);\n+      switch (GET_CODE (sub))\n+\t{\n+\tcase SET_ATTR:\n+\t  if (strcmp (XSTR (sub, 0), \"predicable\") == 0)\n+\t    {\n+\t      value = XSTR (sub, 1);\n+\t      goto found;\n+\t    }\n+\t  break;\n+\n+\tcase SET_ATTR_ALTERNATIVE:\n+\t  if (strcmp (XSTR (sub, 0), \"predicable\") == 0)\n+\t    {\n+\t      message_with_line (elem->lineno,\n+\t\t\t\t \"multiple alternatives for `predicable'\");\n+\t      errors = 1;\n+\t      return 0;\n+\t    }\n+\t  break;\n+\n+\tcase SET:\n+\t  if (GET_CODE (SET_DEST (sub)) != ATTR\n+\t      || strcmp (XSTR (SET_DEST (sub), 0), \"predicable\") != 0)\n+\t    break;\n+\t  sub = SET_SRC (sub);\n+\t  if (GET_CODE (sub) == CONST_STRING)\n+\t    {\n+\t      value = XSTR (sub, 0);\n+\t      goto found;\n+\t    }\n+\n+\t  /* ??? It would be possible to handle this if we really tried.\n+\t     It's not easy though, and I'm not going to bother until it\n+\t     really proves necessary.  */\n+\t  message_with_line (elem->lineno,\n+\t\t\t     \"non-constant value for `predicable'\");\n+\t  errors = 1;\n+\t  return 0;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  return predicable_default;\n+\n+ found:\n+  /* Verify that predicability does not vary on the alternative.  */\n+  /* ??? It should be possible to handle this by simply eliminating\n+     the non-predicable alternatives from the insn.  FRV would like\n+     to do this.  Delay this until we've got the basics solid.  */\n+  if (strchr (value, ',') != NULL)\n+    {\n+      message_with_line (elem->lineno,\n+\t\t\t \"multiple alternatives for `predicable'\");\n+      errors = 1;\n+      return 0;\n+    }\n+\n+  /* Find out which value we're looking at.  */\n+  if (strcmp (value, predicable_true) == 0)\n+    return 1;\n+  if (strcmp (value, predicable_false) == 0)\n+    return 0;\n+\n+  message_with_line (elem->lineno,\n+\t\t     \"Unknown value `%s' for `predicable' attribute\",\n+\t\t     value);\n+  errors = 1;\n+  return 0;\n+}\n+\n+/* Examine the attribute \"predicable\"; discover its boolean values\n+   and its default.  */\n+\n+static void\n+identify_predicable_attribute ()\n+{\n+  struct queue_elem *elem;\n+  char *true, *false;\n+  const char *value;\n+  size_t len;\n+\n+  /* Look for the DEFINE_ATTR for `predicable', which must exist.  */\n+  for (elem = define_attr_queue; elem ; elem = elem->next)\n+    if (strcmp (XSTR (elem->data, 0), \"predicable\") == 0)\n+      goto found;\n+\n+  message_with_line (define_cond_exec_queue->lineno,\n+\t\t     \"Attribute `predicable' not defined\");\n+  errors = 1;\n+  return;\n+\n+ found:\n+  value = XSTR (elem->data, 1);\n+  len = strlen (value);\n+  false = (char *) xmalloc (len + 1);\n+  memcpy (false, value, len + 1);\n+\n+  true = strchr (false, ',');\n+  if (true == NULL || strchr (++true, ',') != NULL)\n+    {\n+      message_with_line (elem->lineno,\n+\t\t\t \"Attribute `predicable' is not a boolean\");\n+      errors = 1;\n+      return;\n+    }\n+  true[-1] = '\\0';\n+\n+  predicable_true = true;\n+  predicable_false = false;\n+\n+  switch (GET_CODE (XEXP (elem->data, 2)))\n+    {\n+    case CONST_STRING:\n+      value = XSTR (XEXP (elem->data, 2), 0);\n+      break;\n+\n+    case CONST:\n+      message_with_line (elem->lineno,\n+\t\t\t \"Attribute `predicable' cannot be const\");\n+      errors = 1;\n+      return;\n+\n+    default:\n+      message_with_line (elem->lineno,\n+\t\t\t \"Attribute `predicable' must have a constant default\");\n+      errors = 1;\n+      return;\n+    }\n+\n+  if (strcmp (value, true) == 0)\n+    predicable_default = 1;\n+  else if (strcmp (value, false) == 0)\n+    predicable_default = 0;\n+  else\n+    {\n+      message_with_line (elem->lineno,\n+\t\t\t \"Unknown value `%s' for `predicable' attribute\",\n+\t\t\t value);\n+      errors = 1;\n+    }\n+}\n+\n+/* Return the number of alternatives in constraint S.  */\n+\n+static int\n+n_alternatives (s)\n+     const char *s;\n+{\n+  int n = 1;\n+\n+  if (s)\n+    while (*s)\n+      n += (*s++ == ',');\n+\n+  return n;\n+}\n+\n+/* Determine how many alternatives there are in INSN, and how many\n+   operands.  */\n+\n+static void\n+collect_insn_data (pattern, palt, pmax)\n+     rtx pattern;\n+     int *palt, *pmax;\n+{\n+  const char *fmt;\n+  enum rtx_code code;\n+  int i, j, len;\n+\n+  code = GET_CODE (pattern);\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+      *palt = n_alternatives (XSTR (pattern, 2));\n+      /* FALLTHRU */\n+\n+    case MATCH_OPERATOR:\n+    case MATCH_SCRATCH:\n+    case MATCH_PARALLEL:\n+    case MATCH_INSN:\n+      i = XINT (pattern, 0);\n+      if (i > *pmax)\n+\t*pmax = i;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  collect_insn_data (XEXP (pattern, i), palt, pmax);\n+\t  break;\n+\n+\tcase 'V':\n+\t  if (XVEC (pattern, i) == NULL)\n+\t    break;\n+\t  /* FALLTHRU */\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    collect_insn_data (XVECEXP (pattern, i, j), palt, pmax);\n+\t  break;\n+\n+\tcase 'i': case 'w': case '0': case 's': case 'S':\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+}\n+\n+static rtx\n+alter_predicate_for_insn (pattern, alt, max_op, lineno)\n+     rtx pattern;\n+     int alt, max_op, lineno;\n+{\n+  const char *fmt;\n+  enum rtx_code code;\n+  int i, j, len;\n+\n+  code = GET_CODE (pattern);\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+      {\n+\tconst char *c = XSTR (pattern, 2);\n+\n+\tif (n_alternatives (c) != 1)\n+\t  {\n+\t    message_with_line (lineno,\n+\t\t\t       \"Too many alternatives for operand %d\",\n+\t\t\t       XINT (pattern, 0));\n+\t    errors = 1;\n+\t    return NULL;\n+\t  }\n+\n+\t/* Replicate C as needed to fill out ALT alternatives.  */\n+\tif (c && *c && alt > 1)\n+\t  {\n+\t    size_t c_len = strlen (c);\n+\t    size_t len = alt * (c_len + 1);\n+\t    char *new_c = (char *) xmalloc (len);\n+\n+\t    memcpy (new_c, c, c_len);\n+\t    for (i = 1; i < alt; ++i)\n+\t      {\n+\t\tnew_c[i * (c_len + 1) - 1] = ',';\n+\t\tmemcpy (&new_c[i * (c_len + 1)], c, c_len);\n+\t      }\n+\t    new_c[len - 1] = '\\0';\n+\t    XSTR (pattern, 2) = new_c;\n+\t  }\n+      }\n+      /* FALLTHRU */\n+\n+    case MATCH_OPERATOR:\n+    case MATCH_SCRATCH:\n+    case MATCH_PARALLEL:\n+    case MATCH_INSN:\n+      XINT (pattern, 0) += max_op;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      rtx r;\n+\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  r = alter_predicate_for_insn (XEXP (pattern, i), alt,\n+\t\t\t\t\tmax_op, lineno);\n+\t  if (r == NULL)\n+\t    return r;\n+\t  break;\n+\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    {\n+\t      r = alter_predicate_for_insn (XVECEXP (pattern, i, j),\n+\t\t\t\t\t    alt, max_op, lineno);\n+\t      if (r == NULL)\n+\t\treturn r;\n+\t    }\n+\t  break;\n+\n+\tcase 'i': case 'w': case '0': case 's':\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  return pattern;\n+}\n+\n+static const char *\n+alter_test_for_insn (ce_elem, insn_elem)\n+     struct queue_elem *ce_elem, *insn_elem;\n+{\n+  const char *ce_test, *insn_test;\n+  char *new_test;\n+  size_t len, ce_len, insn_len;\n+\n+  ce_test = XSTR (ce_elem->data, 1);\n+  insn_test = XSTR (insn_elem->data, 2);\n+  if (!ce_test || *ce_test == '\\0')\n+    return insn_test;\n+  if (!insn_test || *insn_test == '\\0')\n+    return ce_test;\n+\n+  ce_len = strlen (ce_test);\n+  insn_len = strlen (insn_test);\n+  len = 1 + ce_len + 1 + 4 + 1 + insn_len + 1 + 1;\n+  new_test = (char *) xmalloc (len);\n+\n+  sprintf (new_test, \"(%s) && (%s)\", ce_test, insn_test);\n+\n+  return new_test;\n+}\n+\n+/* Adjust all of the operand numbers in OLD to match the shift they'll\n+   get from an operand displacement of DISP.  Return a pointer after the\n+   adjusted string.  */\n+\n+static char *\n+shift_output_template (new, old, disp)\n+     char *new;\n+     const char *old;\n+     int disp;\n+{\n+  while (*old)\n+    {\n+      char c = *old++;\n+      *new++ = c;\n+      if (c == '%')\n+\t{\n+\t  c = *old++;\n+\t  if (ISDIGIT ((unsigned char) c))\n+\t    c += disp;\n+\t  else if (ISUPPER ((unsigned char) c)\n+\t\t   || ISLOWER ((unsigned char) c))\n+\t    {\n+\t      *new++ = c;\n+\t      c = *old++ + disp;\n+\t    }\n+\t  *new++ = c;\n+\t}\n+    }\n+\n+  return new;\n+}\n+\n+static const char *\n+alter_output_for_insn (ce_elem, insn_elem, alt, max_op)\n+     struct queue_elem *ce_elem, *insn_elem;\n+     int alt, max_op;\n+{\n+  const char *ce_out, *insn_out;\n+  char *new, *p;\n+  size_t len, ce_len, insn_len;\n+\n+  /* ??? Could coordinate with genoutput to not duplicate code here.  */\n+\n+  ce_out = XSTR (ce_elem->data, 2);\n+  insn_out = XSTR (insn_elem->data, 3);\n+  if (!ce_out || *ce_out == '\\0')\n+    return insn_out;\n+\n+  ce_len = strlen (ce_out);\n+  insn_len = strlen (insn_out);\n+\n+  if (*insn_out == '*')\n+    /* You must take care of the predicate yourself.  */\n+    return insn_out;\n+\n+  if (*insn_out == '@')\n+    {\n+      len = (ce_len + 1) * alt + insn_len + 1;\n+      p = new = xmalloc (len);\n+\n+      do\n+\t{\n+\t  do\n+\t    *p++ = *insn_out++;\n+\t  while (ISSPACE ((unsigned char) *insn_out));\n+\n+\t  if (*insn_out != '#')\n+\t    {\n+\t      p = shift_output_template (p, ce_out, max_op);\n+\t      *p++ = ' ';\n+\t    }\n+\n+\t  do\n+\t    *p++ = *insn_out++;\n+\t  while (*insn_out && *insn_out != '\\n');\n+\t}\n+      while (*insn_out);\n+      *p = '\\0';\n+    }\n+  else\n+    {\n+      len = ce_len + 1 + insn_len + 1;\n+      new = xmalloc (len);\n+\n+      p = shift_output_template (new, ce_out, max_op);\n+      *p++ = ' ';\n+      memcpy (p, insn_out, insn_len + 1);\n+    }\n+\n+  return new;\n+}\n+\n+/* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */\n+\n+static void\n+process_one_cond_exec (ce_elem)\n+     struct queue_elem *ce_elem;\n+{\n+  struct queue_elem *insn_elem;\n+  for (insn_elem = define_insn_queue; insn_elem ; insn_elem = insn_elem->next)\n+    {\n+      int alternatives, max_operand;\n+      rtx pred, insn, pattern;\n+\n+      if (! is_predicable (insn_elem))\n+\tcontinue;\n+\n+      alternatives = 1;\n+      max_operand = -1;\n+      collect_insn_data (insn_elem->data, &alternatives, &max_operand);\n+      max_operand += 1;\n+\n+      if (XVECLEN (ce_elem->data, 0) != 1)\n+\t{\n+\t  message_with_line (ce_elem->lineno,\n+\t\t\t     \"too many patterns in predicate\");\n+\t  errors = 1;\n+\t  return;\n+\t}\n+\n+      pred = copy_rtx (XVECEXP (ce_elem->data, 0, 0));\n+      pred = alter_predicate_for_insn (pred, alternatives, max_operand,\n+\t\t\t\t       ce_elem->lineno);\n+      if (pred == NULL)\n+\treturn;\n+\n+      /* Construct a new pattern for the new insn.  */\n+      insn = copy_rtx (insn_elem->data);\n+      XSTR (insn, 0) = \"\";\n+      pattern = rtx_alloc (COND_EXEC);\n+      XEXP (pattern, 0) = pred;\n+      if (XVECLEN (insn, 1) == 1)\n+\t{\n+\t  XEXP (pattern, 1) = XVECEXP (insn, 1, 0);\n+\t  XVECEXP (insn, 1, 0) = pattern;\n+\t  PUT_NUM_ELEM (XVEC (insn, 1), 1);\n+\t}\n+      else\n+\t{\n+\t  XEXP (pattern, 1) = rtx_alloc (PARALLEL);\n+\t  XVEC (XEXP (pattern, 1), 0) = XVEC (insn, 1);\n+\t  XVEC (insn, 1) = rtvec_alloc (1);\n+\t  XVECEXP (insn, 1, 0) = pattern;\n+\t}\n+\n+      XSTR (insn, 2) = alter_test_for_insn (ce_elem, insn_elem);\n+      XSTR (insn, 3) = alter_output_for_insn (ce_elem, insn_elem,\n+\t\t\t\t\t      alternatives, max_operand);\n+\n+      /* ??? Set `predicable' to false.  Not crucial since it's really\n+         only used here, and we won't reprocess this new pattern.  */\n+\n+      /* Put the new pattern on the `other' list so that it\n+\t (a) is not reprocessed by other define_cond_exec patterns\n+\t (b) appears after all normal define_insn patterns.\n+\n+\t ??? B is debatable.  If one has normal insns that match\n+\t cond_exec patterns, they will be preferred over these\n+\t generated patterns.  Whether this matters in practice, or if\n+\t it's a good thing, or whether we should thread these new\n+\t patterns into the define_insn chain just after their generator\n+\t is something we'll have to experiment with.  */\n+\n+      queue_pattern (insn, &other_tail, insn_elem->lineno);\n+    }\n+}\n+\n+/* If we have any DEFINE_COND_EXEC patterns, expand the DEFINE_INSN\n+   patterns appropriately.  */\n+\n+static void\n+process_define_cond_exec ()\n+{\n+  struct queue_elem *elem;\n+\n+  identify_predicable_attribute ();\n+  if (errors)\n+    return;\n+\n+  for (elem = define_cond_exec_queue; elem ; elem = elem->next)\n+    process_one_cond_exec (elem);\n+}\n+\f\n /* The entry point for initializing the reader.  */\n \n-int \n+int\n init_md_reader (filename)\n-    const char *filename;\n+     const char *filename;\n {\n+  FILE *input_file;\n+  int c;\n+\n   read_rtx_filename = filename;\n   input_file = fopen (filename, \"r\");\n   if (input_file == 0)\n@@ -170,52 +769,73 @@ init_md_reader (filename)\n     }\n \n   obstack_init (rtl_obstack);\n+  errors = 0;\n   sequence_num = 0;\n-  rtx_ready_queue = NULL; \n \n-  return SUCCESS_EXIT_CODE;\n-}\n-\n-\n-/* The entry point for reading a single rtx from an md file.  */\n-\n-rtx \n-read_md_rtx (lineno, seqnr)\n-    int *lineno;\n-    int *seqnr;\n-{ \n-  rtx desc;\n-\n-  if (rtx_ready_queue != NULL) \n+  /* Read the entire file.  */\n+  while (1)\n     {\n-      desc = rtx_ready_queue->data;\n-      rtx_ready_queue = rtx_ready_queue->next;\n-    }\n-  else \n-    {\n-      int c;\n+      rtx desc;\n+      int lineno;\n+\n       c = read_skip_spaces (input_file);\n       if (c == EOF)\n-\treturn NULL;\n+\tbreak;\n \n       ungetc (c, input_file);\n+      lineno = read_rtx_lineno;\n       desc = read_rtx (input_file);\n-      process_rtx (&desc);\n+      process_rtx (desc, lineno);\n     }\n-  *lineno = read_rtx_lineno;\n+  fclose (input_file);\n+\n+  /* Process define_cond_exec patterns.  */\n+  if (define_cond_exec_queue != NULL)\n+    process_define_cond_exec ();\n+\n+  return errors ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n+}\n+\n+/* The entry point for reading a single rtx from an md file.  */\n+\n+rtx\n+read_md_rtx (lineno, seqnr)\n+     int *lineno;\n+     int *seqnr;\n+{\n+  struct queue_elem **queue, *elem;\n+  rtx desc;\n+\n+  /* Read all patterns from a given queue before moving on to the next.  */\n+  if (define_attr_queue != NULL)\n+    queue = &define_attr_queue;\n+  else if (define_insn_queue != NULL)\n+    queue = &define_insn_queue;\n+  else if (other_queue != NULL)\n+    queue = &other_queue;\n+  else\n+    return NULL_RTX;\n+\n+  elem = *queue;\n+  *queue = elem->next;\n+  desc = elem->data;\n+  *lineno = elem->lineno;\n   *seqnr = sequence_num;\n+\n+  free (elem);\n+\n   switch (GET_CODE (desc))\n     {\n-      case DEFINE_INSN:\n-      case DEFINE_EXPAND:\n-      case DEFINE_SPLIT:\n-      case DEFINE_PEEPHOLE:\n-      case DEFINE_PEEPHOLE2:\n-\tsequence_num++;\n-\tbreak;\n-\n-      default:\n-\tbreak;\n+    case DEFINE_INSN:\n+    case DEFINE_EXPAND:\n+    case DEFINE_SPLIT:\n+    case DEFINE_PEEPHOLE:\n+    case DEFINE_PEEPHOLE2:\n+      sequence_num++;\n+      break;\n+\n+    default:\n+      break;\n     }\n \n   return desc;"}, {"sha": "e21139ecf6f19d4e195001bc908d9ae23391906a", "filename": "gcc/md.texi", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "patch": "@@ -37,6 +37,8 @@ See the next chapter for information on the C header file.\n * Insn Splitting::      Splitting Instructions into Multiple Instructions.\n * Peephole Definitions::Defining machine-specific peephole optimizations.\n * Insn Attributes::     Specifying the value of attributes for generated insns.\n+* Conditional Execution::Generating @code{define_insn} patterns for\n+                           predication.\n @end menu\n \n @node Patterns\n@@ -4558,3 +4560,83 @@ used during their execution and there is no way of representing that\n conflict.  We welcome any examples of how function unit conflicts work\n in such processors and suggestions for their representation.\n @end ifset\n+\n+@node Conditional Execution\n+@section Conditional Execution\n+@cindex conditional execution\n+@cindex predication\n+\n+A number of architectures provide for some form of conditional\n+execution, or predication.  The hallmark of this feature is the\n+ability to nullify most of the instructions in the instruction set.\n+When the instruction set is large and not entirely symmetric, it\n+can be quite tedious to describe these forms directly in the\n+@file{.md} file.  An alternative is the @code{define_cond_exec} template.\n+\n+@findex define_cond_exec\n+@smallexample\n+(define_cond_exec\n+  [@var{predicate-pattern}]\n+  \"@var{condition}\"\n+  \"@var{output template}\")\n+@end smallexample\n+\n+@var{predicate-pattern} is the condition that must be true for the\n+insn to be executed at runtime and should match a relational operator.\n+One can use @code{match_operator} to match several relational operators\n+at once.  Any @code{match_operand} operands must have no more than one\n+alternative.\n+\n+@var{condition} is a C expression that must be true for the generated\n+pattern to match.\n+\n+@findex current_insn_predicate\n+@var{output template} is a string similar to the @code{define_insn}\n+output template (@pxref{Output Template}), except that the @samp{*}\n+and @samp{@@} special cases do not apply.  This is only useful if the\n+assembly text for the predicate is a simple prefix to the main insn.\n+In order to handle the general case, there is a global variable\n+@code{current_insn_predicate} that will contain the entire predicate\n+if the current insn is predicated, and will otherwise be @code{NULL}.\n+\n+When @code{define_cond_exec} is used, an implicit reference to \n+the @code{predicable} instruction attribute is made. \n+@xref{Insn Attributes}.  This attribute must be boolean (i.e. have\n+exactly two elements in its @var{list-of-values}).  Further, it must\n+not be used with complex expressions.  That is, the default and all\n+uses in the insns must be a simple constant, not dependant on the \n+alternative or anything else.\n+\n+For each @code{define_insn} for which the @code{predicable} \n+attribute is true, a new @code{define_insn} pattern will be\n+generated that matches a predicated version of the instruction.\n+For example,\n+\n+@smallexample\n+(define_insn \"addsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"@var{test1}\"\n+  \"add %2,%1,%0\")\n+\n+(define_cond_exec\n+  [(ne (match_operand:CC 0 \"register_operand\" \"c\")\n+       (const_int 0))]\n+  \"@var{test2}\"\n+  \"(%0)\")\n+@end smallexample\n+\n+@noindent\n+generates a new pattern\n+\n+@smallexample\n+(define_insn \"\"\n+  [(cond_exec\n+     (ne (match_operand:CC 3 \"register_operand\" \"c\") (const_int 0))\n+     (set (match_operand:SI 0 \"register_operand\" \"r\")\n+          (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                   (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"(@var{test2}) && (@var{test1})\"\n+  \"(%3) add %2,%1,%0\")\n+@end smallexample"}, {"sha": "d9a35f58e3f9e9df157bb9398378bf6538ecd793", "filename": "gcc/rtl.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3262c1f5523c538ecdd39d04babbd66f93c7c3bc/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "patch": "@@ -310,6 +310,19 @@ DEF_RTL_EXPR(DEFINE_FUNCTION_UNIT, \"define_function_unit\", \"siieiiV\", 'x')\n /* Define attribute computation for `asm' instructions.  */\n DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", 'x' )\n \n+/* Definition of a conditional execution meta operation.  Automatically\n+   generates new instances of DEFINE_INSN, selected by having attribute\n+   \"predicable\" true.  The new pattern will contain a COND_EXEC and the\n+   predicate at top-level.\n+\n+   Operand:\n+   0: The predicate pattern.  The top-level form should match a\n+      relational operator.  Operands should have only one alternative.\n+   1: A C expression giving an additional condition for recognizing\n+      the generated pattern.\n+   2: A template or C code to produce assembler output.  */\n+DEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", 'x')\n+\n /* SEQUENCE appears in the result of a `gen_...' function\n    for a DEFINE_EXPAND that wants to make several insns.\n    Its elements are the bodies of the insns that should be made."}]}