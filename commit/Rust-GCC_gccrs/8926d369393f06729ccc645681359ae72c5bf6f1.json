{"sha": "8926d369393f06729ccc645681359ae72c5bf6f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkyNmQzNjkzOTNmMDY3MjljY2M2NDU2ODEzNTlhZTcyYzViZjZmMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:37:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:37:17Z"}, "message": "[multiple changes]\n\n2012-07-12  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb, exp_ch9.adb, sem_ch9.adb, exp_aggr.adb: Minor\n\treformatting.\n\n2012-07-12  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_dim.adb (Analyze_Dimension_Function_Call): Reformatting of error\n\tmsgs for elementary functions.\n\n2012-07-12  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_attr.adb (Eval_Attribute): Minor reformatting.\n\n2012-07-12  Pascal Obry  <obry@adacore.com>\n\n\t* prj-nmsc.adb (Check_Library_Attributes): Allow the same library\n\tproject in different project tree (different aggregated projects).\n\n2012-07-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-bytswa.adb, g-bytswa.adb, g-bytswa.ads, s-bytswa.ads: Further\n\treorganization of byte swapping routines.\n\n2012-07-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_disp.adb (Check_Dispatching_Context): Refine legality\n\tchecks on tagg indeterminate calls to abstract operations,\n\tthat appear in the context of other calls.\n\nFrom-SVN: r189436", "tree": {"sha": "3a9936f7e0b21e62376570606f3d5fdb3e85470f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a9936f7e0b21e62376570606f3d5fdb3e85470f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8926d369393f06729ccc645681359ae72c5bf6f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926d369393f06729ccc645681359ae72c5bf6f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8926d369393f06729ccc645681359ae72c5bf6f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926d369393f06729ccc645681359ae72c5bf6f1/comments", "author": null, "committer": null, "parents": [{"sha": "1e4b91fc4f5c6d15955594c01553462a38db97d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4b91fc4f5c6d15955594c01553462a38db97d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4b91fc4f5c6d15955594c01553462a38db97d4"}], "stats": {"total": 799, "additions": 440, "deletions": 359}, "files": [{"sha": "394b1c18f46e36587729c725a8e19c5fb319c755", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -1,3 +1,33 @@\n+2012-07-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb, exp_ch9.adb, sem_ch9.adb, exp_aggr.adb: Minor\n+\treformatting.\n+\n+2012-07-12  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_dim.adb (Analyze_Dimension_Function_Call): Reformatting of error\n+\tmsgs for elementary functions.\n+\n+2012-07-12  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_attr.adb (Eval_Attribute): Minor reformatting.\n+\n+2012-07-12  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_Library_Attributes): Allow the same library\n+\tproject in different project tree (different aggregated projects).\n+\n+2012-07-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-bytswa.adb, g-bytswa.adb, g-bytswa.ads, s-bytswa.ads: Further\n+\treorganization of byte swapping routines.\n+\n+2012-07-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_disp.adb (Check_Dispatching_Context): Refine legality\n+\tchecks on tagg indeterminate calls to abstract operations,\n+\tthat appear in the context of other calls.\n+\n 2012-07-12  Thomas Quinot  <quinot@adacore.com>\n \n \t* s-bytswa.adb (Swapped2.Bswap16): Remove local function,"}, {"sha": "228c37ecce636f95274c5f2c321dee3ee242847e", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -294,8 +294,8 @@ package body Exp_Aggr is\n \n       --  The normal limit is 5000, but we increase this limit to 2**24 (about\n       --  16 million) if Restrictions (No_Elaboration_Code) or Restrictions\n-      --  (No_Implicit_Loops) is specified, since in either case we are at risk\n-      --  of declaring the program illegal because of this limit. We also\n+      --  (No_Implicit_Loops) is specified, since in either case we are at\n+      --  risk of declaring the program illegal because of this limit. We also\n       --  increase the limit when Static_Elaboration_Desired, given that this\n       --  means that objects are intended to be placed in data memory.\n \n@@ -3517,9 +3517,9 @@ package body Exp_Aggr is\n                            --  Check for maximum others replication. Note that\n                            --  we skip this test if either of the restrictions\n                            --  No_Elaboration_Code or No_Implicit_Loops is\n-                           --  active, if this is a preelaborable unit or a\n-                           --  predefined unit, or if the unit must be placed\n-                           --  in data memory. This also ensures that\n+                           --  active, if this is a preelaborable unit or\n+                           --  a predefined unit, or if the unit must be\n+                           --  placed in data memory. This also ensures that\n                            --  predefined units get the same level of constant\n                            --  folding in Ada 95 and Ada 2005, where their\n                            --  categorization has changed.\n@@ -3537,7 +3537,8 @@ package body Exp_Aggr is\n                                 or else\n                                   (Ekind (Current_Scope) = E_Package\n                                     and then\n-                                    Static_Elaboration_Desired (Current_Scope))\n+                                      Static_Elaboration_Desired\n+                                        (Current_Scope))\n                                 or else Is_Preelaborated (P)\n                                 or else (Ekind (P) = E_Package_Body\n                                           and then\n@@ -3746,11 +3747,13 @@ package body Exp_Aggr is\n                         and then Ekind (Entity (Expr)) = E_Enumeration_Literal)\n                   then\n                      null;\n+\n                   else\n-                     Error_Msg_N (\"non-static object \"\n-                       & \" requires elaboration code?\", N);\n+                     Error_Msg_N\n+                       (\"non-static object  requires elaboration code?\", N);\n                      exit;\n                   end if;\n+\n                   Next (Expr);\n                end loop;\n "}, {"sha": "f3a81a8a26c3d364eda67c4b5cd2be0864c96b7e", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -816,9 +816,9 @@ package body Exp_Attr is\n \n       if Is_Protected_Self_Reference (Pref)\n         and then not\n-             (Nkind_In (Parent (N), N_Index_Or_Discriminant_Constraint,\n-                                    N_Discriminant_Association)\n-                and then Nkind (Parent (Parent (Parent (Parent (N))))) =\n+          (Nkind_In (Parent (N), N_Index_Or_Discriminant_Constraint,\n+                                 N_Discriminant_Association)\n+            and then Nkind (Parent (Parent (Parent (Parent (N))))) =\n                                                       N_Component_Definition)\n \n          --  No action needed for these attributes since the current instance"}, {"sha": "bd476112f447a70fbd07b5cabfb2f88301cb57ff", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -3084,7 +3084,7 @@ package body Exp_Ch9 is\n       --  protected component.\n \n       if Present (Comp) then\n-         declare\n+         Protected_Component_Ref : declare\n             Comp_Decl    : constant Node_Id   := Parent (Comp);\n             Comp_Sel_Nam : constant Node_Id   := Name (Comp_Decl);\n             Comp_Type    : constant Entity_Id := Etype (Comp);\n@@ -3220,7 +3220,6 @@ package body Exp_Ch9 is\n \n             procedure Process_Stmts (Stmts : List_Id) is\n                Stmt : Node_Id;\n-\n             begin\n                Stmt := First (Stmts);\n                while Present (Stmt) loop\n@@ -3229,6 +3228,8 @@ package body Exp_Ch9 is\n                end loop;\n             end Process_Stmts;\n \n+         --  Start of processing for Protected_Component_Ref\n+\n          begin\n             --  Get the type size\n \n@@ -3436,23 +3437,24 @@ package body Exp_Ch9 is\n             --    end loop;\n \n             if Is_Procedure then\n-               Stmts := New_List (\n-                 Make_Procedure_Call_Statement (Loc,\n-                    Name =>\n-                      New_Reference_To (RTE (RE_Atomic_Synchronize), Loc)),\n-                 Make_Loop_Statement (Loc,\n-                   Statements => New_List (\n-                     Make_Block_Statement (Loc,\n-                       Declarations               => Block_Decls,\n-                       Handled_Statement_Sequence =>\n-                         Make_Handled_Sequence_Of_Statements (Loc,\n-                           Statements => Stmts))),\n-                   End_Label  => Empty));\n+               Stmts :=\n+                 New_List (\n+                   Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (RTE (RE_Atomic_Synchronize), Loc)),\n+                   Make_Loop_Statement (Loc,\n+                     Statements => New_List (\n+                       Make_Block_Statement (Loc,\n+                         Declarations               => Block_Decls,\n+                         Handled_Statement_Sequence =>\n+                           Make_Handled_Sequence_Of_Statements (Loc,\n+                             Statements => Stmts))),\n+                     End_Label  => Empty));\n             end if;\n \n             Hand_Stmt_Seq :=\n               Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts);\n-         end;\n+         end Protected_Component_Ref;\n       end if;\n \n       --  Make an unprotected version of the subprogram for use within the same"}, {"sha": "9628bbc5da98a221bcff7198e59dd1c6f08eefdb", "filename": "gcc/ada/g-bytswa.adb", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fg-bytswa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fg-bytswa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-bytswa.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                     G N A T . B Y T E _ S W A P P I N G                  --\n+--                    G N A T . B Y T E _ S W A P P I N G                   --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2012, AdaCore                     --\n+--                     Copyright (C) 2006-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,85 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package does not require a body, since it is a package renaming. We\n---  provide a dummy file containing a No_Body pragma so that previous versions\n---  of the body (which did exist) will not interfere.\n+--  This is a general implementation that uses GCC intrinsics to take\n+--  advantage of any machine-specific instructions.\n \n-pragma No_Body;\n+with Ada.Unchecked_Conversion; use Ada;\n+\n+with System.Byte_Swapping; use System.Byte_Swapping;\n+\n+package body GNAT.Byte_Swapping is\n+\n+   --------------\n+   -- Swapped2 --\n+   --------------\n+\n+   function Swapped2 (Input : Item) return Item is\n+      function As_U16 is new Unchecked_Conversion (Item, U16);\n+      function As_Item is new Unchecked_Conversion (U16, Item);\n+      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 2,\n+        \"storage size must be 2 bytes\");\n+   begin\n+      return As_Item (Bswap_16 (As_U16 (Input)));\n+   end Swapped2;\n+\n+   --------------\n+   -- Swapped4 --\n+   --------------\n+\n+   function Swapped4 (Input : Item) return Item is\n+      function As_U32 is new Unchecked_Conversion (Item, U32);\n+      function As_Item is new Unchecked_Conversion (U32, Item);\n+      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 4,\n+        \"storage size must be 4 bytes\");\n+   begin\n+      return As_Item (Bswap_32 (As_U32 (Input)));\n+   end Swapped4;\n+\n+   --------------\n+   -- Swapped8 --\n+   --------------\n+\n+   function Swapped8 (Input : Item) return Item is\n+      function As_U64 is new Unchecked_Conversion (Item, U64);\n+      function As_Item is new Unchecked_Conversion (U64, Item);\n+      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 8,\n+        \"storage size must be 8 bytes\");\n+   begin\n+      return As_Item (Bswap_64 (As_U64 (Input)));\n+   end Swapped8;\n+\n+   -----------\n+   -- Swap2 --\n+   -----------\n+\n+   procedure Swap2 (Location : System.Address) is\n+      X : U16;\n+      for X'Address use Location;\n+   begin\n+      X := Bswap_16 (X);\n+   end Swap2;\n+\n+   -----------\n+   -- Swap4 --\n+   -----------\n+\n+   procedure Swap4 (Location : System.Address) is\n+      X : U32;\n+      for X'Address use Location;\n+   begin\n+      X := Bswap_32 (X);\n+   end Swap4;\n+\n+   -----------\n+   -- Swap8 --\n+   -----------\n+\n+   procedure Swap8 (Location : System.Address) is\n+      X : U64;\n+      for X'Address use Location;\n+   begin\n+      X := Bswap_64 (X);\n+   end Swap8;\n+\n+end GNAT.Byte_Swapping;"}, {"sha": "35656fc8045ce027c17faff87177181ecd29d603", "filename": "gcc/ada/g-bytswa.ads", "status": "modified", "additions": 172, "deletions": 4, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fg-bytswa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fg-bytswa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-bytswa.ads?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                     G N A T . B Y T E _ S W A P P I N G                  --\n+--                    G N A T . B Y T E _ S W A P P I N G                   --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n@@ -31,8 +31,176 @@\n \n --  Simple routines for swapping the bytes of 16-, 32-, and 64-bit objects\n \n---  See file s-bytswa.ads for full documentation of the interface\n+--  The generic functions should be instantiated with types that are of a size\n+--  in bytes corresponding to the name of the generic. For example, a 2-byte\n+--  integer type would be compatible with Swapped2, 4-byte integer with\n+--  Swapped4, and so on. Failure to do so will result in a warning when\n+--  compiling the instantiation; this warning should be heeded. Ignoring this\n+--  warning can result in unexpected results.\n \n-with System.Byte_Swapping;\n+--  An example of proper usage follows:\n \n-package GNAT.Byte_Swapping renames System.Byte_Swapping;\n+--     declare\n+--        type Short_Integer is range -32768 .. 32767;\n+--        for Short_Integer'Size use 16; -- for confirmation\n+\n+--        X : Short_Integer := 16#7FFF#;\n+\n+--        function Swapped is new Byte_Swapping.Swapped2 (Short_Integer);\n+\n+--     begin\n+--        Put_Line (X'Img);\n+--        X := Swapped (X);\n+--        Put_Line (X'Img);\n+--     end;\n+\n+--  Note that the generic actual types need not be scalars, but must be\n+--  'definite' types. They can, for example, be constrained subtypes of\n+--  unconstrained array types as long as the size is correct. For instance,\n+--  a subtype of String with length of 4 would be compatible with the\n+--  Swapped4 generic:\n+\n+--     declare\n+--        subtype String4 is String (1 .. 4);\n+--        function Swapped is new Byte_Swapping.Swapped4 (String4);\n+--        S : String4 := \"ABCD\";\n+--        for S'Alignment use 4;\n+--     begin\n+--        Put_Line (S);\n+--        S := Swapped (S);\n+--        Put_Line (S);\n+--     end;\n+\n+--  Similarly, a constrained array type is also acceptable:\n+\n+--     declare\n+--        type Mask is array (0 .. 15) of Boolean;\n+--        for Mask'Alignment use 2;\n+--        for Mask'Component_Size use Boolean'Size;\n+--        X : Mask := (0 .. 7 => True, others => False);\n+--        function Swapped is new Byte_Swapping.Swapped2 (Mask);\n+--     begin\n+--        ...\n+--        X := Swapped (X);\n+--        ...\n+--     end;\n+\n+--  A properly-sized record type will also be acceptable, and so forth\n+\n+--  However, as described, a size mismatch must be avoided. In the following we\n+--  instantiate one of the generics with a type that is too large. The result\n+--  of the function call is undefined, such that assignment to an object can\n+--  result in garbage values.\n+\n+--     Wrong: declare\n+--        subtype String16 is String (1 .. 16);\n+\n+--        function Swapped is new Byte_Swapping.Swapped8 (String16);\n+--        --  Instantiation generates a compiler warning about\n+--        --  mismatched sizes\n+\n+--        S : String16;\n+\n+--     begin\n+--        S := \"ABCDEFGHDEADBEEF\";\n+--\n+--        Put_Line (S);\n+--\n+--        --  the following assignment results in garbage in S after the\n+--        --  first 8 bytes\n+--\n+--        S := Swapped (S);\n+--\n+--        Put_Line (S);\n+--     end Wrong;\n+\n+--  When the size of the type is larger than 8 bytes, the use of the non-\n+--  generic procedures is an alternative because no function result is\n+--  involved; manipulation of the object is direct.\n+\n+--  The procedures are passed the address of an object to manipulate. They will\n+--  swap the first N bytes of that object corresponding to the name of the\n+--  procedure.  For example:\n+\n+--     declare\n+--        S2 : String := \"AB\";\n+--        for S2'Alignment use 2;\n+--        S4 : String := \"ABCD\";\n+--        for S4'Alignment use 4;\n+--        S8 : String := \"ABCDEFGH\";\n+--        for S8'Alignment use 8;\n+\n+--     begin\n+--        Swap2 (S2'Address);\n+--        Put_Line (S2);\n+\n+--        Swap4 (S4'Address);\n+--        Put_Line (S4);\n+\n+--        Swap8 (S8'Address);\n+--        Put_Line (S8);\n+--     end;\n+\n+--  If an object of a type larger than N is passed, the remaining bytes of the\n+--  object are undisturbed. For example:\n+\n+--     declare\n+--        subtype String16 is String (1 .. 16);\n+\n+--        S : String16;\n+--        for S'Alignment use 8;\n+\n+--     begin\n+--        S  := \"ABCDEFGHDEADBEEF\";\n+--        Put_Line (S);\n+--        Swap8 (S'Address);\n+--        Put_Line (S);\n+--     end;\n+\n+with System;\n+\n+package GNAT.Byte_Swapping is\n+   pragma Pure;\n+\n+   --  NB: all the routines in this package treat the application objects as\n+   --  unsigned (modular) types of a size in bytes corresponding to the routine\n+   --  name. For example, the generic function Swapped2 manipulates the object\n+   --  passed to the formal parameter Input as a value of an unsigned type that\n+   --  is 2 bytes long. Therefore clients are responsible for the compatibility\n+   --  of application types manipulated by these routines and these modular\n+   --  types, in terms of both size and alignment. This requirement applies to\n+   --  the generic actual type passed to the generic formal type Item in the\n+   --  generic functions, as well as to the type of the object implicitly\n+   --  designated by the address passed to the non-generic procedures. Use of\n+   --  incompatible types can result in implementation- defined effects.\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped2 (Input : Item) return Item;\n+   --  Return the 2-byte value of Input with the bytes swapped\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped4 (Input : Item) return Item;\n+   --  Return the 4-byte value of Input with the bytes swapped\n+\n+   generic\n+      type Item is limited private;\n+   function Swapped8 (Input : Item) return Item;\n+   --  Return the 8-byte value of Input with the bytes swapped\n+\n+   procedure Swap2 (Location : System.Address);\n+   --  Swap the first 2 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   procedure Swap4 (Location : System.Address);\n+   --  Swap the first 4 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   procedure Swap8 (Location : System.Address);\n+   --  Swap the first 8 bytes of the object starting at the address specified\n+   --  by Location.\n+\n+   pragma Inline (Swap2, Swap4, Swap8, Swapped2, Swapped4, Swapped8);\n+\n+end GNAT.Byte_Swapping;"}, {"sha": "facf9f9411dcad246d11506bfabdef9886379e90", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -165,6 +165,7 @@ package body Prj.Nmsc is\n    type Lib_Data is record\n       Name : Name_Id;\n       Proj : Project_Id;\n+      Tree : Project_Tree_Ref;\n    end record;\n \n    package Lib_Data_Table is new GNAT.Table\n@@ -3639,7 +3640,9 @@ package body Prj.Nmsc is\n          --  Check if the same library name is used in an other library project\n \n          for J in 1 .. Lib_Data_Table.Last loop\n-            if Lib_Data_Table.Table (J).Name = Project.Library_Name then\n+            if Lib_Data_Table.Table (J).Name = Project.Library_Name\n+              and then Lib_Data_Table.Table (J).Tree = Data.Tree\n+            then\n                Error_Msg_Name_1 := Lib_Data_Table.Table (J).Proj.Name;\n                Error_Msg\n                  (Data.Flags,\n@@ -3656,7 +3659,9 @@ package body Prj.Nmsc is\n          --  Record the library name\n \n          Lib_Data_Table.Append\n-           ((Name => Project.Library_Name, Proj => Project));\n+           ((Name => Project.Library_Name,\n+             Proj => Project,\n+             Tree => Data.Tree));\n       end if;\n    end Check_Library_Attributes;\n "}, {"sha": "e029980c0bcc8fa4d4c05f78ca03d54d3be4f358", "filename": "gcc/ada/s-bytswa.adb", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fs-bytswa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fs-bytswa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bytswa.adb?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -1,124 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                  S Y S T E M . B Y T E _ S W A P P I N G                 --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2006-2012, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a general implementation that uses GCC intrinsics to take\n---  advantage of any machine-specific instructions.\n-\n-with Ada.Unchecked_Conversion; use Ada;\n-\n-package body System.Byte_Swapping is\n-\n-   type U16 is mod 2**16;\n-   type U32 is mod 2**32;\n-   type U64 is mod 2**64;\n-\n-   function Bswap_16 (X : U16) return U16;\n-   pragma Import (Intrinsic, Bswap_16, \"__builtin_bswap16\");\n-\n-   function Bswap_32 (X : U32) return U32;\n-   pragma Import (Intrinsic, Bswap_32, \"__builtin_bswap32\");\n-\n-   function Bswap_64 (X : U64) return U64;\n-   pragma Import (Intrinsic, Bswap_64, \"__builtin_bswap64\");\n-\n-   --------------\n-   -- Swapped2 --\n-   --------------\n-\n-   function Swapped2 (Input : Item) return Item is\n-      function As_U16 is new Unchecked_Conversion (Item, U16);\n-      function As_Item is new Unchecked_Conversion (U16, Item);\n-      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 2,\n-        \"storage size must be 2 bytes\");\n-   begin\n-      return As_Item (Bswap_16 (As_U16 (Input)));\n-   end Swapped2;\n-\n-   --------------\n-   -- Swapped4 --\n-   --------------\n-\n-   function Swapped4 (Input : Item) return Item is\n-      function As_U32 is new Unchecked_Conversion (Item, U32);\n-      function As_Item is new Unchecked_Conversion (U32, Item);\n-      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 4,\n-        \"storage size must be 4 bytes\");\n-   begin\n-      return As_Item (Bswap_32 (As_U32 (Input)));\n-   end Swapped4;\n-\n-   --------------\n-   -- Swapped8 --\n-   --------------\n-\n-   function Swapped8 (Input : Item) return Item is\n-      function As_U64 is new Unchecked_Conversion (Item, U64);\n-      function As_Item is new Unchecked_Conversion (U64, Item);\n-      pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 8,\n-        \"storage size must be 8 bytes\");\n-   begin\n-      return As_Item (Bswap_64 (As_U64 (Input)));\n-   end Swapped8;\n-\n-   -----------\n-   -- Swap2 --\n-   -----------\n-\n-   procedure Swap2 (Location : System.Address) is\n-      X : U16;\n-      for X'Address use Location;\n-   begin\n-      X := Bswap_16 (X);\n-   end Swap2;\n-\n-   -----------\n-   -- Swap4 --\n-   -----------\n-\n-   procedure Swap4 (Location : System.Address) is\n-      X : U32;\n-      for X'Address use Location;\n-   begin\n-      X := Bswap_32 (X);\n-   end Swap4;\n-\n-   -----------\n-   -- Swap8 --\n-   -----------\n-\n-   procedure Swap8 (Location : System.Address) is\n-      X : U64;\n-      for X'Address use Location;\n-   begin\n-      X := Bswap_64 (X);\n-   end Swap8;\n-\n-end System.Byte_Swapping;"}, {"sha": "c011e1e0b3bbc123c8b3f3064316d7b5f87f84b4", "filename": "gcc/ada/s-bytswa.ads", "status": "modified", "additions": 12, "deletions": 166, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fs-bytswa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fs-bytswa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bytswa.ads?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -29,178 +29,24 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Simple routines for swapping the bytes of 16-, 32-, and 64-bit objects\n-\n---  The generic functions should be instantiated with types that are of a size\n---  in bytes corresponding to the name of the generic. For example, a 2-byte\n---  integer type would be compatible with Swapped2, 4-byte integer with\n---  Swapped4, and so on. Failure to do so will result in a warning when\n---  compiling the instantiation; this warning should be heeded. Ignoring this\n---  warning can result in unexpected results.\n-\n---  An example of proper usage follows:\n-\n---     declare\n---        type Short_Integer is range -32768 .. 32767;\n---        for Short_Integer'Size use 16; -- for confirmation\n-\n---        X : Short_Integer := 16#7FFF#;\n-\n---        function Swapped is new Byte_Swapping.Swapped2 (Short_Integer);\n-\n---     begin\n---        Put_Line (X'Img);\n---        X := Swapped (X);\n---        Put_Line (X'Img);\n---     end;\n-\n---  Note that the generic actual types need not be scalars, but must be\n---  'definite' types. They can, for example, be constrained subtypes of\n---  unconstrained array types as long as the size is correct. For instance,\n---  a subtype of String with length of 4 would be compatible with the\n---  Swapped4 generic:\n-\n---     declare\n---        subtype String4 is String (1 .. 4);\n---        function Swapped is new Byte_Swapping.Swapped4 (String4);\n---        S : String4 := \"ABCD\";\n---        for S'Alignment use 4;\n---     begin\n---        Put_Line (S);\n---        S := Swapped (S);\n---        Put_Line (S);\n---     end;\n-\n---  Similarly, a constrained array type is also acceptable:\n-\n---     declare\n---        type Mask is array (0 .. 15) of Boolean;\n---        for Mask'Alignment use 2;\n---        for Mask'Component_Size use Boolean'Size;\n---        X : Mask := (0 .. 7 => True, others => False);\n---        function Swapped is new Byte_Swapping.Swapped2 (Mask);\n---     begin\n---        ...\n---        X := Swapped (X);\n---        ...\n---     end;\n-\n---  A properly-sized record type will also be acceptable, and so forth\n-\n---  However, as described, a size mismatch must be avoided. In the following we\n---  instantiate one of the generics with a type that is too large. The result\n---  of the function call is undefined, such that assignment to an object can\n---  result in garbage values.\n-\n---     Wrong: declare\n---        subtype String16 is String (1 .. 16);\n-\n---        function Swapped is new Byte_Swapping.Swapped8 (String16);\n---        --  Instantiation generates a compiler warning about\n---        --  mismatched sizes\n-\n---        S : String16;\n-\n---     begin\n---        S := \"ABCDEFGHDEADBEEF\";\n---\n---        Put_Line (S);\n---\n---        --  the following assignment results in garbage in S after the\n---        --  first 8 bytes\n---\n---        S := Swapped (S);\n---\n---        Put_Line (S);\n---     end Wrong;\n-\n---  When the size of the type is larger than 8 bytes, the use of the non-\n---  generic procedures is an alternative because no function result is\n---  involved; manipulation of the object is direct.\n-\n---  The procedures are passed the address of an object to manipulate. They will\n---  swap the first N bytes of that object corresponding to the name of the\n---  procedure.  For example:\n-\n---     declare\n---        S2 : String := \"AB\";\n---        for S2'Alignment use 2;\n---        S4 : String := \"ABCD\";\n---        for S4'Alignment use 4;\n---        S8 : String := \"ABCDEFGH\";\n---        for S8'Alignment use 8;\n-\n---     begin\n---        Swap2 (S2'Address);\n---        Put_Line (S2);\n-\n---        Swap4 (S4'Address);\n---        Put_Line (S4);\n-\n---        Swap8 (S8'Address);\n---        Put_Line (S8);\n---     end;\n-\n---  If an object of a type larger than N is passed, the remaining bytes of the\n---  object are undisturbed. For example:\n-\n---     declare\n---        subtype String16 is String (1 .. 16);\n-\n---        S : String16;\n---        for S'Alignment use 8;\n-\n---     begin\n---        S  := \"ABCDEFGHDEADBEEF\";\n---        Put_Line (S);\n---        Swap8 (S'Address);\n---        Put_Line (S);\n---     end;\n-\n-with System;\n+--  Supporting routines for GNAT.Byte_Swapping, also used directly by\n+--  expended code.\n \n package System.Byte_Swapping is\n-   pragma Pure;\n \n-   --  NB: all the routines in this package treat the application objects as\n-   --  unsigned (modular) types of a size in bytes corresponding to the routine\n-   --  name. For example, the generic function Swapped2 manipulates the object\n-   --  passed to the formal parameter Input as a value of an unsigned type that\n-   --  is 2 bytes long. Therefore clients are responsible for the compatibility\n-   --  of application types manipulated by these routines and these modular\n-   --  types, in terms of both size and alignment. This requirement applies to\n-   --  the generic actual type passed to the generic formal type Item in the\n-   --  generic functions, as well as to the type of the object implicitly\n-   --  designated by the address passed to the non-generic procedures. Use of\n-   --  incompatible types can result in implementation- defined effects.\n-\n-   generic\n-      type Item is limited private;\n-   function Swapped2 (Input : Item) return Item;\n-   --  Return the 2-byte value of Input with the bytes swapped\n-\n-   generic\n-      type Item is limited private;\n-   function Swapped4 (Input : Item) return Item;\n-   --  Return the 4-byte value of Input with the bytes swapped\n-\n-   generic\n-      type Item is limited private;\n-   function Swapped8 (Input : Item) return Item;\n-   --  Return the 8-byte value of Input with the bytes swapped\n+   pragma Pure;\n \n-   procedure Swap2 (Location : System.Address);\n-   --  Swap the first 2 bytes of the object starting at the address specified\n-   --  by Location.\n+   type U16 is mod 2**16;\n+   type U32 is mod 2**32;\n+   type U64 is mod 2**64;\n \n-   procedure Swap4 (Location : System.Address);\n-   --  Swap the first 4 bytes of the object starting at the address specified\n-   --  by Location.\n+   function Bswap_16 (X : U16) return U16;\n+   pragma Import (Intrinsic, Bswap_16, \"__builtin_bswap16\");\n \n-   procedure Swap8 (Location : System.Address);\n-   --  Swap the first 8 bytes of the object starting at the address specified\n-   --  by Location.\n+   function Bswap_32 (X : U32) return U32;\n+   pragma Import (Intrinsic, Bswap_32, \"__builtin_bswap32\");\n \n-   pragma Inline (Swap2, Swap4, Swap8, Swapped2, Swapped4, Swapped8);\n+   function Bswap_64 (X : U64) return U64;\n+   pragma Import (Intrinsic, Bswap_64, \"__builtin_bswap64\");\n \n end System.Byte_Swapping;"}, {"sha": "af1a8172ec490245c352a087b7997e4867b104a6", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -6322,11 +6322,12 @@ package body Sem_Attr is\n               Attribute_Iterator_Element     |\n               Attribute_Variable_Indexing    => null;\n \n-         --  Atributes related to Ada 2012 aspects\n+         --  Internal attributes used to deal with Ada 2012 delayed aspects.\n+         --  These were already rejected by the parser. Thus they shouldn't\n+         --  appear here.\n \n-         when Attribute_CPU                |\n-              Attribute_Dispatching_Domain |\n-              Attribute_Interrupt_Priority => null;\n+         when Internal_Attribute_Id =>\n+            raise Program_Error;\n \n       --------------\n       -- Adjacent --"}, {"sha": "49a163b0b52a3fc187ae7fa50a53995bf44719f3", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -175,18 +175,16 @@ package body Sem_Ch9 is\n \n                   begin\n                      Par := First (Par_Specs);\n-\n                      while Present (Par) loop\n                         if Out_Present (Par)\n                           and then not Is_Elementary_Type\n                                          (Etype (Parameter_Type (Par)))\n                         then\n                            if Complain then\n                               Error_Msg_NE\n-                                (\"non-elementary out parameter& not allowed \" &\n-                                 \"when Lock_Free given\",\n-                                 Par,\n-                                 Defining_Identifier (Par));\n+                                (\"non-elementary out parameter& not allowed \"\n+                                 & \"when Lock_Free given\",\n+                                 Par, Defining_Identifier (Par));\n                            end if;\n \n                            return False;"}, {"sha": "1d0307cf330b5f81de5d0355941d145efbd529e8", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -1585,8 +1585,7 @@ package body Sem_Dim is\n                   Dims_Of_Actual := Dimensions_Of (Actual);\n \n                   if Exists (Dims_Of_Actual) then\n-                     Error_Msg_NE (\"parameter should be dimensionless for \" &\n-                                   \"elementary function&\",\n+                     Error_Msg_NE (\"parameter of& must be dimensionless\",\n                                    Actual, Name_Call);\n                      Error_Msg_N (\"\\parameter \" & Dimensions_Msg_Of (Actual),\n                                   Actual);"}, {"sha": "b728c9300ac4c2398037dab8c2967759081f3190", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 96, "deletions": 20, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926d369393f06729ccc645681359ae72c5bf6f1/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=8926d369393f06729ccc645681359ae72c5bf6f1", "patch": "@@ -493,8 +493,34 @@ package body Sem_Disp is\n \n       procedure Check_Dispatching_Context is\n          Subp : constant Entity_Id := Entity (Name (N));\n+         Typ  : constant Entity_Id := Etype (Subp);\n          Par  : Node_Id;\n \n+         procedure Abstract_Context_Error;\n+         --  Indicate that the abstract call that dispatches on result is not\n+         --  dispatching.\n+\n+         -----------------------------\n+         --  Bastract_Context_Error --\n+         -----------------------------\n+\n+         procedure Abstract_Context_Error is\n+         begin\n+            if Ekind (Subp) = E_Function then\n+               Error_Msg_N\n+                 (\"call to abstract function must be dispatching\", N);\n+\n+            --  This error can occur for a procedure in the case of a\n+            --  call to an abstract formal procedure with a statically\n+            --  tagged operand.\n+\n+            else\n+               Error_Msg_N\n+                 (\"call to abstract procedure must be dispatching\",\n+                  N);\n+            end if;\n+         end Abstract_Context_Error;\n+\n       begin\n          if Is_Abstract_Subprogram (Subp)\n            and then No (Controlling_Argument (N))\n@@ -510,38 +536,88 @@ package body Sem_Disp is\n                return;\n \n             else\n+               --  We need to determine whether the context of the call\n+               --  provides a tag to make the call dispatching. This requires\n+               --  the call to be the actual in an enclosing call, and that\n+               --  actual must be controlling.  If the call is an operand of\n+               --  equality, the other operand must not ve abstract.\n+\n+               if not Is_Tagged_Type (Typ)\n+                 and then not\n+                    (Ekind (Typ) = E_Anonymous_Access_Type\n+                      and then Is_Tagged_Type (Designated_Type (Typ)))\n+               then\n+                  Abstract_Context_Error;\n+                  return;\n+               end if;\n+\n                Par := Parent (N);\n+               if Nkind (Par) = N_Parameter_Association then\n+                  Par := Parent (Par);\n+               end if;\n+\n                while Present (Par) loop\n-                  if Nkind_In (Par, N_Function_Call,\n-                                    N_Procedure_Call_Statement,\n-                                    N_Assignment_Statement,\n-                                    N_Op_Eq,\n-                                    N_Op_Ne)\n-                    and then Is_Tagged_Type (Etype (Subp))\n+                  if Nkind_In (Par,\n+                                 N_Function_Call,\n+                                 N_Procedure_Call_Statement)\n+                    and then Is_Entity_Name (Name (Par))\n                   then\n-                     return;\n+                     declare\n+                        A : Node_Id;\n+                        F : Entity_Id;\n \n-                  elsif Nkind (Par) = N_Qualified_Expression\n-                    or else Nkind (Par) = N_Unchecked_Type_Conversion\n-                  then\n-                     Par := Parent (Par);\n+                     begin\n+                        --  Find formal for which call is the actual.\n+\n+                        F := First_Formal (Entity (Name (Par)));\n+                        A := First_Actual (Par);\n+\n+                        while Present (F) loop\n+\n+                           if Is_Controlling_Formal (F)\n+                             and then\n+                               (N = A or else Parent (N) = A)\n+                           then\n+                              return;\n+                           end if;\n+\n+                           Next_Formal (F);\n+                           Next_Actual (A);\n+                        end loop;\n \n-                  else\n-                     if Ekind (Subp) = E_Function then\n                         Error_Msg_N\n                           (\"call to abstract function must be dispatching\", N);\n+                        return;\n+                     end;\n \n-                     --  This error can occur for a procedure in the case of a\n-                     --  call to an abstract formal procedure with a statically\n-                     --  tagged operand.\n+                  --  For equalitiy operators, one of the operands must\n+                  --  be statically or dynamically tagged.\n \n-                     else\n-                        Error_Msg_N\n-                          (\"call to abstract procedure must be dispatching\",\n-                           N);\n+                  elsif Nkind_In (Par, N_Op_Eq, N_Op_Ne) then\n+                     if N = Right_Opnd (Par)\n+                       and then Is_Tag_Indeterminate (Left_Opnd (Par))\n+                     then\n+                        Abstract_Context_Error;\n+\n+                     elsif N = Left_Opnd (Par)\n+                       and then Is_Tag_Indeterminate (Right_Opnd (Par))\n+                     then\n+                        Abstract_Context_Error;\n                      end if;\n \n                      return;\n+\n+                  elsif Nkind (Par) = N_Assignment_Statement then\n+                     return;\n+\n+                  elsif Nkind (Par) = N_Qualified_Expression\n+                    or else Nkind (Par) = N_Unchecked_Type_Conversion\n+                  then\n+                     Par := Parent (Par);\n+\n+                  else\n+                     Abstract_Context_Error;\n+                     return;\n                   end if;\n                end loop;\n             end if;"}]}