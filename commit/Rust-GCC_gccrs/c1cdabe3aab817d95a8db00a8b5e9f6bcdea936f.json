{"sha": "c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFjZGFiZTNhYWI4MTdkOTVhOGRiMDBhOGI1ZTlmNmJjZGVhOTM2Zg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-07-29T10:00:31Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-08-05T11:51:14Z"}, "message": "arm: reorder assembler architecture directives [PR101723]\n\nA change to the way gas interprets the .fpu directive in binutils-2.34\nmeans that issuing .fpu will clear any features set by .arch_extension\nthat apply to the floating point or simd units.  This unfortunately\ncauses problems for more recent versions of the architecture because\nwe currently emit .arch, .arch_extension and .fpu directives at\ndifferent times and try to suppress redundant changes.\n\nThis change addresses this by firstly unifying all the places where we\nemit these directives to a single block of code and secondly\n(re)emitting all the directives if any changes have been made to the\ntarget options.  Whilst this is slightly more than the strict minimum\nit should be enough to catch all cases where a change could have\nhappened.  The new code also emits the directives in the order: .arch,\n.fpu, .arch_extension.  This ensures that the additional architectural\nextensions are not removed by a later .fpu directive.\n\nWhilst writing this patch I also noticed that in the corner case where\nthe last function to be compiled had a non-standard set of\narchitecture flags, the assembler would add an incorrect set of\nderived attributes for the file as a whole.  Instead of reflecting the\ncommand-line options it would reflect the flags from the last file in\nthe function.  To address this I've also added a call to re-emit the\nflags from the asm_file_end callback so the assembler will be in the\ncorrect state when it finishes processing the intput.\n\nThere's some slight churn to the testsuite as a consequence of this,\nbecause previously we had a hack to suppress emitting a .fpu directive\nfor one specific case, but with the new order this is no-longer\nnecessary.\n\ngcc/ChangeLog:\n\n\tPR target/101723\n\t* config/arm/arm-cpus.in (generic-armv7-a): Add quirk to suppress\n\twriting .cpu directive in asm output.\n\t* config/arm/arm.c (arm_identify_fpu_from_isa): New variable.\n\t(arm_last_printed_arch_string): Delete.\n\t(arm_last-printed_fpu_string): Delete.\n\t(arm_configure_build_target): If use of floating-point/SIMD is\n\tdisabled, remove all fp/simd related features from the target ISA.\n\t(last_arm_targ_options): New variable.\n\t(arm_print_asm_arch_directives): Add new parameters.  Change order\n\tof emitted directives and handle all cases here.\n\t(arm_file_start): Always call arm_print_asm_arch_directives, move\n\tall generation of .arch/.arch_extension here.\n\t(arm_file_end): Call arm_print_asm_arch.\n\t(arm_declare_function_name): Call arm_print_asm_arch_directives\n\tinstead of printing .arch/.fpu directives directly.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/101723\n\t* gcc.target/arm/cortex-m55-nofp-flag-hard.c: Update expected output.\n\t* gcc.target/arm/cortex-m55-nofp-flag-softfp.c: Likewise.\n\t* gcc.target/arm/cortex-m55-nofp-nomve-flag-softfp.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_fpu1.c: Convert to dg-do assemble.\n\tAdd a non-no-op function body.\n\t* gcc.target/arm/mve/intrinsics/mve_fpu2.c: Likewise.\n\t* gcc.target/arm/pr98636.c (dg-options): Add -mfloat-abi=softfp.\n\t* gcc.target/arm/attr-neon.c: Tighten scan-assembler tests.\n\t* gcc.target/arm/attr-neon2.c: Use -Ofast, convert test to use\n\tcheck-function-bodies.\n\t* gcc.target/arm/attr-neon3.c: Likewise.\n\t* gcc.target/arm/pr69245.c: Tighten scan-assembler match, but allow\n\tmultiple instances.\n\t* gcc.target/arm/pragma_fpu_attribute.c: Likewise.\n\t* gcc.target/arm/pragma_fpu_attribute_2.c: Likewise.", "tree": {"sha": "2e3b5461af89619f316ecefa9d46564aa7514d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e3b5461af89619f316ecefa9d46564aa7514d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/comments", "author": null, "committer": null, "parents": [{"sha": "6a37d0331c25f23628d4308e5a75624005c223b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a37d0331c25f23628d4308e5a75624005c223b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a37d0331c25f23628d4308e5a75624005c223b2"}], "stats": {"total": 318, "additions": 169, "deletions": 149}, "files": [{"sha": "249995a6bca1e372447823eb18401bcff1ffa85b", "filename": "gcc/config/arm/arm-cpus.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Fconfig%2Farm%2Farm-cpus.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Fconfig%2Farm%2Farm-cpus.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cpus.in?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1080,6 +1080,7 @@ begin cpu generic-armv7-a\n  cname genericv7a\n  tune flags LDSCHED\n  architecture armv7-a+fp\n+ isa quirk_no_asmcpu\n  option mp add mp\n  option sec add sec\n  option vfpv3-d16 add VFPv3 FP_DBL"}, {"sha": "11dafc7006763e684f474ddb99bdd35964e9762d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 77, "deletions": 109, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -79,10 +79,6 @@\n typedef struct minipool_node    Mnode;\n typedef struct minipool_fixup   Mfix;\n \n-/* The last .arch and .fpu assembly strings that we printed.  */\n-static std::string arm_last_printed_arch_string;\n-static std::string arm_last_printed_fpu_string;\n-\n void (*arm_lang_output_object_attributes_hook)(void);\n \n struct four_ints\n@@ -334,6 +330,7 @@ static rtx_insn *thumb1_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n \t\t\t\t       vec<machine_mode> &,\n \t\t\t\t       vec<const char *> &, vec<rtx> &,\n \t\t\t\t       HARD_REG_SET &, location_t);\n+static const char *arm_identify_fpu_from_isa (sbitmap);\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -3411,6 +3408,11 @@ arm_configure_build_target (struct arm_build_target *target,\n       bitmap_ior (target->isa, target->isa, fpu_bits);\n     }\n \n+  /* If we have the soft-float ABI, clear any feature bits relating to use of\n+     floating-point operations.  They'll just confuse things later on.  */\n+  if (arm_float_abi == ARM_FLOAT_ABI_SOFT)\n+    bitmap_and_compl (target->isa, target->isa, isa_all_fpbits);\n+\n   /* There may be implied bits which we still need to enable. These are\n      non-named features which are needed to complete other sets of features,\n      but cannot be enabled from arm-cpus.in due to being shared between\n@@ -28096,20 +28098,65 @@ arm_print_tune_info (void)\n \t       (int) current_tune->sched_autopref);\n }\n \n+/* The last set of target options used to emit .arch directives, etc.  This\n+   could be a function-local static if it were not required to expose it as a\n+   root to the garbage collector.  */\n+static GTY(()) cl_target_option *last_asm_targ_options = NULL;\n+\n /* Print .arch and .arch_extension directives corresponding to the\n    current architecture configuration.  */\n static void\n-arm_print_asm_arch_directives ()\n+arm_print_asm_arch_directives (FILE *stream, cl_target_option *targ_options)\n {\n+  arm_build_target build_target;\n+  /* If the target options haven't changed since the last time we were called\n+     there is nothing to do.  This should be sufficient to suppress the\n+     majority of redundant work.  */\n+  if (last_asm_targ_options == targ_options)\n+    return;\n+\n+  last_asm_targ_options = targ_options;\n+\n+  build_target.isa = sbitmap_alloc (isa_num_bits);\n+  arm_configure_build_target (&build_target, targ_options, false);\n+\n+  if (build_target.core_name\n+      && !bitmap_bit_p (build_target.isa, isa_bit_quirk_no_asmcpu))\n+    {\n+      const char* truncated_name\n+\t= arm_rewrite_selected_cpu (build_target.core_name);\n+      asm_fprintf (stream, \"\\t.cpu %s\\n\", truncated_name);\n+    }\n+\n   const arch_option *arch\n     = arm_parse_arch_option_name (all_architectures, \"-march\",\n-\t\t\t\t  arm_active_target.arch_name);\n+\t\t\t\t  build_target.arch_name);\n   auto_sbitmap opt_bits (isa_num_bits);\n \n   gcc_assert (arch);\n \n-  asm_fprintf (asm_out_file, \"\\t.arch %s\\n\", arm_active_target.arch_name);\n-  arm_last_printed_arch_string = arm_active_target.arch_name;\n+  if (strcmp (build_target.arch_name, \"armv7ve\") == 0)\n+    {\n+      /* Keep backward compatability for assemblers which don't support\n+\t armv7ve.  Fortunately, none of the following extensions are reset\n+\t by a .fpu directive.  */\n+      asm_fprintf (stream, \"\\t.arch armv7-a\\n\");\n+      asm_fprintf (stream, \"\\t.arch_extension virt\\n\");\n+      asm_fprintf (stream, \"\\t.arch_extension idiv\\n\");\n+      asm_fprintf (stream, \"\\t.arch_extension sec\\n\");\n+      asm_fprintf (stream, \"\\t.arch_extension mp\\n\");\n+    }\n+  else\n+    asm_fprintf (stream, \"\\t.arch %s\\n\", build_target.arch_name);\n+\n+  /* The .fpu directive will reset any architecture extensions from the\n+     assembler that relate to the fp/vector extensions.  So put this out before\n+     any .arch_extension directives.  */\n+  const char *fpu_name = (TARGET_SOFT_FLOAT\n+\t\t\t  ? \"softvfp\"\n+\t\t\t  : arm_identify_fpu_from_isa (build_target.isa));\n+  asm_fprintf (stream, \"\\t.fpu %s\\n\", fpu_name);\n+\n   if (!arch->common.extensions)\n     return;\n \n@@ -28135,13 +28182,12 @@ arm_print_asm_arch_directives ()\n \t\t  && !TARGET_HAVE_MVE_FLOAT))\n \t    continue;\n \n-\t  /* If every feature bit of this option is set in the target\n-\t     ISA specification, print out the option name.  However,\n-\t     don't print anything if all the bits are part of the\n-\t     FPU specification.  */\n-\t  if (bitmap_subset_p (opt_bits, arm_active_target.isa)\n+\t  /* If every feature bit of this option is set in the target ISA\n+\t     specification, print out the option name.  However, don't print\n+\t     anything if all the bits are part of the FPU specification.  */\n+\t  if (bitmap_subset_p (opt_bits, build_target.isa)\n \t      && !bitmap_subset_p (opt_bits, isa_all_fpubits_internal))\n-\t    asm_fprintf (asm_out_file, \"\\t.arch_extension %s\\n\", opt->name);\n+\t    asm_fprintf (stream, \"\\t.arch_extension %s\\n\", opt->name);\n \t}\n     }\n }\n@@ -28151,46 +28197,23 @@ arm_file_start (void)\n {\n   int val;\n \n+  arm_print_asm_arch_directives\n+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));\n+\n   if (TARGET_BPABI)\n     {\n-      /* We don't have a specified CPU.  Use the architecture to\n-\t generate the tags.\n-\n-\t Note: it might be better to do this unconditionally, then the\n-\t assembler would not need to know about all new CPU names as\n-\t they are added.  */\n-      if (!arm_active_target.core_name)\n-\t{\n-\t  /* armv7ve doesn't support any extensions.  */\n-\t  if (strcmp (arm_active_target.arch_name, \"armv7ve\") == 0)\n-\t    {\n-\t      /* Keep backward compatability for assemblers\n-\t\t which don't support armv7ve.  */\n-\t      asm_fprintf (asm_out_file, \"\\t.arch armv7-a\\n\");\n-\t      asm_fprintf (asm_out_file, \"\\t.arch_extension virt\\n\");\n-\t      asm_fprintf (asm_out_file, \"\\t.arch_extension idiv\\n\");\n-\t      asm_fprintf (asm_out_file, \"\\t.arch_extension sec\\n\");\n-\t      asm_fprintf (asm_out_file, \"\\t.arch_extension mp\\n\");\n-\t      arm_last_printed_arch_string = \"armv7ve\";\n-\t    }\n-\t  else\n-\t    arm_print_asm_arch_directives ();\n-\t}\n-      else if (startswith (arm_active_target.core_name, \"generic\"))\n-\t{\n-\t  asm_fprintf (asm_out_file, \"\\t.arch %s\\n\",\n-\t\t       arm_active_target.core_name + 8);\n-\t  arm_last_printed_arch_string = arm_active_target.core_name + 8;\n-\t}\n-      else\n+      /* If we have a named cpu, but we the assembler does not support that\n+\t name via .cpu, put out a cpu name attribute; but don't do this if the\n+\t name starts with the fictitious prefix, 'generic'.  */\n+      if (arm_active_target.core_name\n+\t  && bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu)\n+\t  && !startswith (arm_active_target.core_name, \"generic\"))\n \t{\n \t  const char* truncated_name\n \t    = arm_rewrite_selected_cpu (arm_active_target.core_name);\n \t  if (bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu))\n \t    asm_fprintf (asm_out_file, \"\\t.eabi_attribute 5, \\\"%s\\\"\\n\",\n \t\t\t truncated_name);\n-\t  else\n-\t    asm_fprintf (asm_out_file, \"\\t.cpu %s\\n\", truncated_name);\n \t}\n \n       if (print_tune_info)\n@@ -28255,6 +28278,13 @@ arm_file_end (void)\n {\n   int regno;\n \n+  /* Just in case the last function output in the assembler had non-default\n+     architecture directives, we force the assembler state back to the default\n+     set, so that any 'calculated' build attributes are based on the default\n+     options rather than the special options for that function.  */\n+  arm_print_asm_arch_directives\n+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));\n+\n   if (NEED_INDICATE_EXEC_STACK)\n     /* Add .note.GNU-stack.  */\n     file_end_indicate_exec_stack ();\n@@ -33265,58 +33295,7 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)\n     targ_options = TREE_TARGET_OPTION (target_option_current_node);\n   gcc_assert (targ_options);\n \n-  /* Only update the assembler .arch string if it is distinct from the last\n-     such string we printed. arch_to_print is set conditionally in case\n-     targ_options->x_arm_arch_string is NULL which can be the case\n-     when cc1 is invoked directly without passing -march option.  */\n-  std::string arch_to_print;\n-  if (targ_options->x_arm_arch_string)\n-    arch_to_print = targ_options->x_arm_arch_string;\n-\n-  if (arch_to_print != arm_last_printed_arch_string)\n-    {\n-      std::string arch_name\n-\t= arch_to_print.substr (0, arch_to_print.find (\"+\"));\n-      asm_fprintf (asm_out_file, \"\\t.arch %s\\n\", arch_name.c_str ());\n-      const arch_option *arch\n-\t= arm_parse_arch_option_name (all_architectures, \"-march\",\n-\t\t\t\t      targ_options->x_arm_arch_string);\n-      auto_sbitmap opt_bits (isa_num_bits);\n-\n-      gcc_assert (arch);\n-      if (arch->common.extensions)\n-\t{\n-\t  for (const struct cpu_arch_extension *opt = arch->common.extensions;\n-\t       opt->name != NULL;\n-\t       opt++)\n-\t    {\n-\t      if (!opt->remove)\n-\t\t{\n-\t\t  arm_initialize_isa (opt_bits, opt->isa_bits);\n-\t\t  /* For the cases \"-march=armv8.1-m.main+mve -mfloat-abi=soft\"\n-\t\t     and \"-march=armv8.1-m.main+mve.fp -mfloat-abi=soft\" MVE and\n-\t\t     MVE with floating point instructions is disabled.  So the\n-\t\t     following check restricts the printing of \".arch_extension\n-\t\t     mve\" and \".arch_extension fp\" (for mve.fp) in the assembly\n-\t\t     file.    MVE needs this special behaviour because the\n-\t\t     feature bit \"mve\" and \"mve_float\" are not part of\n-\t\t     \"fpu bits\", so they are not cleared when -mfloat-abi=soft\n-\t\t     (i.e nofp) but the marco TARGET_HAVE_MVE and\n-\t\t     TARGET_HAVE_MVE_FLOAT are disabled.  */\n-\t\t  if ((bitmap_bit_p (opt_bits, isa_bit_mve) && !TARGET_HAVE_MVE)\n-\t\t      || (bitmap_bit_p (opt_bits, isa_bit_mve_float)\n-\t\t\t  && !TARGET_HAVE_MVE_FLOAT))\n-\t\t    continue;\n-\t\t  if (bitmap_subset_p (opt_bits, arm_active_target.isa)\n-\t\t      && !bitmap_subset_p (opt_bits, isa_all_fpubits_internal))\n-\t\t    asm_fprintf (asm_out_file, \"\\t.arch_extension %s\\n\",\n-\t\t\t\t opt->name);\n-\t\t}\n-\t     }\n-\t}\n-\n-      arm_last_printed_arch_string = arch_to_print;\n-    }\n+  arm_print_asm_arch_directives (stream, targ_options);\n \n   fprintf (stream, \"\\t.syntax unified\\n\");\n \n@@ -33334,17 +33313,6 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)\n   else\n     fprintf (stream, \"\\t.arm\\n\");\n \n-  std::string fpu_to_print\n-    = TARGET_SOFT_FLOAT\n-\t? \"softvfp\" : arm_identify_fpu_from_isa (arm_active_target.isa);\n-\n-  if (!(!strcmp (fpu_to_print.c_str (), \"softvfp\") && TARGET_VFP_BASE)\n-      && (fpu_to_print != arm_last_printed_arch_string))\n-    {\n-      asm_fprintf (asm_out_file, \"\\t.fpu %s\\n\", fpu_to_print.c_str ());\n-      arm_last_printed_fpu_string = fpu_to_print;\n-    }\n-\n   if (TARGET_POKE_FUNCTION_NAME)\n     arm_poke_function_name (stream, (const char *) name);\n }"}, {"sha": "e8e3086247d2d0b425bafd33e32b183a09d3c0ee", "filename": "gcc/testsuite/gcc.target/arm/attr-neon.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,7 +1,10 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target arm_neon_ok } */\n /* { dg-options \"-O2 -ftree-vectorize\" } */\n-/* { dg-add-options arm_neon arm_v8_vfp } */ /* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any -mfpu= option set by arm_neon, thus ensuring that the attributes below really are checked for correct fpu selection.  */\n+/* { dg-add-options arm_neon arm_v8_vfp } */\n+/* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any\n+   -mfpu= option set by arm_neon, thus ensuring that the attributes below\n+   really are checked for correct fpu selection.  */\n \n /* Verify that neon instructions are emitted once.  */\n void __attribute__ ((target(\"fpu=neon\")))\n@@ -18,6 +21,6 @@ f3(int n, int x[], int y[]) {\n     y[i] = x[i] << 3;\n }\n \n-/* { dg-final { scan-assembler-times \"\\.fpu vfp\" 1 } } */\n-/* { dg-final { scan-assembler-times \"\\.fpu neon\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\.fpu\\\\s+vfp\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\.fpu\\\\s+neon\\n\" 1 } } */\n /* { dg-final { scan-assembler-times \"vshl\" 1 } } */"}, {"sha": "a7a72dac379d26f3dcbb35699f1f0e8a9c16457f", "filename": "gcc/testsuite/gcc.target/arm/attr-neon2.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target arm_neon_ok } */\n /* { dg-require-effective-target arm_fp_ok } */\n-/* { dg-options \"-O2\" } */\n+/* { dg-options \"-Ofast\" } */\n /* { dg-add-options arm_fp } */\n \n /* Reset fpu to a value compatible with the next pragmas.  */\n@@ -12,23 +12,36 @@\n #include <arm_neon.h>\n \n /* Check that pragma target is used.  */\n-int8x8_t \n-my (int8x8_t __a, int8x8_t __b)\n+/*\n+**my:\n+**\t...\n+**\tvadd.f32\td[0-9]+, d[0-9]+, d[0-9]+\n+**\t...\n+**\tbx\tlr\n+*/\n+float32x2_t\n+my (float32x2_t __a, float32x2_t __b)\n {\n   return __a + __b;\n }\n \n #pragma GCC pop_options\n \n-/* Check that command line option is restored.  */\n-int8x8_t \n-my1 (int8x8_t __a, int8x8_t __b)\n+/* Check that fpu=vfp is restored.  */\n+/*\n+**my1:\n+**\t...\n+**\tvadd.f32\ts[0-9]+, s[0-9]+, s[0-9]+\n+**\tvadd.f32\ts[0-9]+, s[0-9]+, s[0-9]+\n+**\t...\n+**\tbx\tlr\n+*/\n+float32x2_t\n+my1 (float32x2_t __a, float32x2_t __b)\n {\n   return __a + __b;\n }\n \n-/* { dg-final { scan-assembler-times \"\\.fpu vfp\" 1 } } */\n-/* { dg-final { scan-assembler-times \"\\.fpu neon\" 1 } } */\n-/* { dg-final { scan-assembler \"vadd\" } } */\n-\n-\n+/* { dg-final { scan-assembler \"\\.fpu\\\\s+vfp\\n\" } } */\n+/* { dg-final { scan-assembler \"\\.fpu\\\\s+neon\\n\" } } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */"}, {"sha": "0fbce6e4cd417f3aa56c78044c284ab27d101e82", "filename": "gcc/testsuite/gcc.target/arm/attr-neon3.c", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon3.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target arm_crypto_ok } */\n /* { dg-require-effective-target arm_fp_ok } */\n-/* { dg-options \"-O2\" } */\n+/* { dg-options \"-Ofast\" } */\n /* { dg-add-options arm_fp } */\n \n /* Reset fpu to a value compatible with the next pragmas.  */\n@@ -11,28 +11,54 @@\n #include <arm_neon.h>\n \n /* Check that neon is used.  */\n-int8x8_t __attribute__ ((target(\"fpu=neon\")))\n-my (int8x8_t __a, int8x8_t __b)\n+/*\n+**my:\n+**\t...\n+**\tvadd.f32\td[0-9]+, d[0-9]+, d[0-9]+\n+**\t...\n+**\tbx\tlr\n+*/\n+float32x2_t __attribute__ ((target(\"fpu=neon\")))\n+my (float32x2_t __a, float32x2_t __b)\n {\n   return __a + __b;\n }\n \n /* Check that crypto builtins are recognized.  */\n+/*\n+**foo:\n+**\t...\n+** (\n+**\tvld1.64\t{d[0-9]+-d[0-9]+}, \\[r[0-9]+:64\\]\n+** |\n+**\tvld1.64\t{d[0-9]+}, \\[r[0-9]+:64\\]!\n+**\tvld1.64\t{d[0-9]+}, \\[r[0-9]+:64\\]\n+** }\n+**\t...\n+**\tbx\tlr\n+*/\n+\n poly128_t __attribute__ ((target(\"fpu=crypto-neon-fp-armv8\")))\n foo (poly128_t* ptr)\n {\n   return vldrq_p128 (ptr);\n }\n \n-/* Check that default mode is restored.  */\n-int8x8_t\n-my1 (int8x8_t __a, int8x8_t __b)\n+/* Check that fpu=vfp is restored.  */\n+/*\n+**my1:\n+**\t...\n+**\tvadd.f32\ts[0-9]+, s[0-9]+, s[0-9]+\n+**\tvadd.f32\ts[0-9]+, s[0-9]+, s[0-9]+\n+**\t...\n+**\tbx\tlr\n+*/float32x2_t\n+my1 (float32x2_t __a, float32x2_t __b)\n {\n   return __a + __b;\n }\n \n-/* { dg-final { scan-assembler-times \"\\.fpu vfp\" 1 } } */\n-/* { dg-final { scan-assembler-times \"\\.fpu neon\" 1 } } */\n-/* { dg-final { scan-assembler-times \"\\.fpu crypto-neon-fp-armv8\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vld1\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vadd\" 1} } */\n+/* { dg-final { scan-assembler \"\\.fpu\\\\s+vfp\\n\" } } */\n+/* { dg-final { scan-assembler \"\\.fpu\\\\s+neon\\n\" } } */\n+/* { dg-final { scan-assembler \"\\.fpu\\\\s+crypto-neon-fp-armv8\\n\" } } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */"}, {"sha": "e0fb307ac30605a1b8a3d0008df4ea46b4fe0ef3", "filename": "gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-hard.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-flag-hard.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-flag-hard.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-flag-hard.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,12 +1,12 @@\n /* { dg-do assemble } */\n /* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n /* { dg-additional-options \"-mcpu=cortex-m55+nofp -mthumb -mfloat-abi=hard -mfpu=auto --save-temps\" } */\n+/* { dg-final { scan-assembler \"\\.fpu softvfp\" } } */\n /* { dg-final { scan-assembler \"\\.arch_extension mve\" } } */\n /* { dg-final { scan-assembler \"\\.arch_extension dsp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension fp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension fp.dp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension mve.fp\" } } */\n-/* { dg-final { scan-assembler-not \"\\.fpu\" } } */\n \n int\n f ()"}, {"sha": "50645e8cd0f88590aa006a5124c5909335c090dd", "filename": "gcc/testsuite/gcc.target/arm/cortex-m55-nofp-flag-softfp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-flag-softfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-flag-softfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-flag-softfp.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,12 +1,12 @@\n /* { dg-do assemble } */\n /* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n /* { dg-additional-options \"-mcpu=cortex-m55+nofp -mthumb -mfloat-abi=softfp -mfpu=auto --save-temps\" } */\n+/* { dg-final { scan-assembler \"\\.fpu softvfp\" } } */\n /* { dg-final { scan-assembler \"\\.arch_extension mve\" } } */\n /* { dg-final { scan-assembler \"\\.arch_extension dsp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension fp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension fp.dp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension mve.fp\" } } */\n-/* { dg-final { scan-assembler-not \"\\.fpu\" } } */\n \n int\n f ()"}, {"sha": "948f622633c285b958454b514b7061a97f6b16dd", "filename": "gcc/testsuite/gcc.target/arm/cortex-m55-nofp-nomve-flag-softfp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-nomve-flag-softfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-nomve-flag-softfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcortex-m55-nofp-nomve-flag-softfp.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,12 +1,12 @@\n /* { dg-do assemble } */\n /* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n /* { dg-additional-options \"-mcpu=cortex-m55+nomve+nofp -mthumb -mfloat-abi=softfp -mfpu=auto --save-temps\" } */\n+/* { dg-final { scan-assembler \"\\.fpu softvfp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension mve\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension mve.fp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension fp\" } } */\n /* { dg-final { scan-assembler-not \"\\.arch_extension fp.dp\" } } */\n /* { dg-final { scan-assembler \"\\.arch_extension dsp\" } } */\n-/* { dg-final { scan-assembler-not \"\\.fpu\" } } */\n \n int\n f ()"}, {"sha": "c5acdb5e4e58cb9bb323b90b3dd866879e24fa33", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu1.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,3 +1,4 @@\n+/* { dg-do assemble } */\n /* { dg-require-effective-target arm_v8_1m_mve_ok } */\n /* { dg-require-effective-target arm_hard_ok } */\n /* { dg-add-options arm_v8_1m_mve } */\n@@ -8,8 +9,6 @@\n int8x16_t\n foo1 (int8x16_t value)\n {\n-  int8x16_t b = value;\n+  int8x16_t b = -value;\n   return b;\n }\n-\n-/* { dg-final { scan-assembler-not \"\\.fpu softvfp\" }  } */"}, {"sha": "907db5e157220004e8bb75200507f6548511b757", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu2.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,3 +1,4 @@\n+/* { dg-do assemble } */\n /* { dg-require-effective-target arm_v8_1m_mve_ok } */\n /* { dg-require-effective-target arm_softfp_ok } */\n /* { dg-add-options arm_v8_1m_mve } */\n@@ -8,8 +9,6 @@\n int8x16_t\n foo1 (int8x16_t value)\n {\n-  int8x16_t b = value;\n+  int8x16_t b = -value;\n   return b;\n }\n-\n-/* { dg-final { scan-assembler-not \"\\.fpu softvfp\" }  } */"}, {"sha": "34b97a22e15f36e1017496c039f7c90200967cfb", "filename": "gcc/testsuite/gcc.target/arm/pr69245.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr69245.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr69245.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr69245.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -23,4 +23,8 @@ void fn2 ()\n   d = b * c + a;\n }\n \n-/* { dg-final { scan-assembler-times \"\\.fpu vfp\" 1 } } */\n+/* Because we don't know the exact command-line options used to invoke the test\n+   we cannot expect these tests to match exactly once.  But they must appear at\n+   least once.  */\n+/* { dg-final { scan-assembler \"\\.fpu\\s+vfp\\n\" } } */\n+/* { dg-final { scan-assembler \"\\.fpu\\s+neon-vfpv4\\n\" } } */"}, {"sha": "559f9a26c1ec3eb949ac3ab64e21e6269e2462a1", "filename": "gcc/testsuite/gcc.target/arm/pr98636.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr98636.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr98636.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr98636.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mfp16-format=alternative\" } */\n+/* { dg-require-effective-target arm_softfp_ok } */\n+/* { dg-options \"-mfp16-format=alternative -mfloat-abi=softfp\" } */\n \n #pragma GCC push_options\n # pragma GCC target (\"arch=armv8.2-a+fp16\") /* { dg-error \"selected fp16 options are incompatible\" } */"}, {"sha": "7e63cf53013847d01794398b4a31f2cb26babdf9", "filename": "gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpragma_fpu_attribute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpragma_fpu_attribute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpragma_fpu_attribute.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -22,5 +22,8 @@ uint32_t restored ()\n   return bar();\n }\n \n-/* { dg-final { scan-assembler-times {\\.fpu\\s+vfpv4} 1 } } */\n-/* { dg-final { scan-assembler-times {\\.fpu\\s+vfpv3-d16} 1 } } */\n+/* We can't tell exactly how many times the following tests will match because\n+   command-line options may cause additional instances to be generated, but\n+   each must be present at least once.  */\n+/* { dg-final { scan-assembler {\\.fpu\\s+vfpv4\\n} } } */\n+/* { dg-final { scan-assembler {\\.fpu\\s+vfpv3-d16\\n} } } */"}, {"sha": "3d33b04b7878a3eb0b66920b1ab9cdd80a247f1a", "filename": "gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpragma_fpu_attribute_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpragma_fpu_attribute_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpragma_fpu_attribute_2.c?ref=c1cdabe3aab817d95a8db00a8b5e9f6bcdea936f", "patch": "@@ -25,5 +25,8 @@ uint32_t restored ()\n   return bar();\n }\n \n-/* { dg-final { scan-assembler-times {\\.fpu\\s+vfpv4} 1 } } */\n-/* { dg-final { scan-assembler-times {\\.fpu\\s+vfpv3-d16} 1 } } */\n+/* We can't tell exactly how many times the following tests will match because\n+   command-line options may cause additional instances to be generated, but\n+   each must be present at least once.  */\n+/* { dg-final { scan-assembler-times {\\.fpu\\s+vfpv4\\n} } } */\n+/* { dg-final { scan-assembler-times {\\.fpu\\s+vfpv3-d16\\n} } } */"}]}