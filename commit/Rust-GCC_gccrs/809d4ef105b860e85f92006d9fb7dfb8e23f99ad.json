{"sha": "809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5ZDRlZjEwNWI4NjBlODVmOTIwMDZkOWZiN2RmYjhlMjNmOTlhZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-07T01:37:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-07T01:37:07Z"}, "message": "c-decl.c: Include \"tm_p.h\".\n\n        * c-decl.c: Include \"tm_p.h\".\n\n        * config/ia64/ia64-protos.h: Rearrange decls to reduce ifdef madness.\n        (fetchadd_operand, ia64_expand_fetch_and_op): Declare.\n        (ia64_expand_op_and_fetch): Declare.\n        * config/ia64/ia64.c: Include \"toplev.h\".  Kill trailing whitespace.\n        (setjmp_operand): Constify variables for XSTR.\n        (ia64_encode_section_info): Likewise.\n        (ia64_print_operand): Use %d for exact_log2; cast 32-bit printed\n        values to int.\n        (ia64_asm_output_external): Constify name.\n        (process_set): Use HOST_WIDE_INT_PRINT_DEC for frame size.\n        (process_for_unwind_directive): Provide switch default.\n        (ia64_expand_compare_and_swap): Remove unused variables.\n        (ia64_expand_builtin): Likewise.\n        * config/ia64/ia64.h (ASM_OUTPUT_BYTE): Mask and cast value to int\n        for printing.\n\nFrom-SVN: r33752", "tree": {"sha": "f11697b02d75b68324e1c94d5dc065e02ddbf17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f11697b02d75b68324e1c94d5dc065e02ddbf17c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/comments", "author": null, "committer": null, "parents": [{"sha": "3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3262c1f5523c538ecdd39d04babbd66f93c7c3bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3262c1f5523c538ecdd39d04babbd66f93c7c3bc"}], "stats": {"total": 285, "additions": 157, "deletions": 128}, "files": [{"sha": "fac1ec681f477ebe3b9832c898a563421bc5a736", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "patch": "@@ -1,3 +1,24 @@\n+2000-05-06  Richard Henderson  <rth@cygnus.com>\n+2000-05-06  Richard Henderson  <rth@cygnus.com>\n+\n+\t* c-decl.c: Include \"tm_p.h\".\n+\n+\t* config/ia64/ia64-protos.h: Rearrange decls to reduce ifdef madness.\n+\t(fetchadd_operand, ia64_expand_fetch_and_op): Declare.\n+\t(ia64_expand_op_and_fetch): Declare.\n+\t* config/ia64/ia64.c: Include \"toplev.h\".  Kill trailing whitespace.\n+\t(setjmp_operand): Constify variables for XSTR.\n+\t(ia64_encode_section_info): Likewise.\n+\t(ia64_print_operand): Use %d for exact_log2; cast 32-bit printed\n+\tvalues to int.\n+\t(ia64_asm_output_external): Constify name.\n+\t(process_set): Use HOST_WIDE_INT_PRINT_DEC for frame size.\n+\t(process_for_unwind_directive): Provide switch default.\n+\t(ia64_expand_compare_and_swap): Remove unused variables.\n+\t(ia64_expand_builtin): Likewise.\n+\t* config/ia64/ia64.h (ASM_OUTPUT_BYTE): Mask and cast value to int\n+\tfor printing.\n+\n 2000-05-06  Richard Henderson  <rth@cygnus.com>\n \n \t* rtl.def (DEFINE_COND_EXEC): New."}, {"sha": "fcf8a7df4b960e3034d76268ddee8e127dbffc32", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"defaults.h\"\n #include \"ggc.h\"\n+#include \"tm_p.h\"\n \n #if USE_CPPLIB\n #include \"cpplib.h\""}, {"sha": "716a92377fbafad6478afdf5375ea6476cae5f92", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "patch": "@@ -43,59 +43,59 @@ extern int reg_or_22bit_operand PARAMS((rtx, enum machine_mode));\n extern int shift_count_operand PARAMS((rtx, enum machine_mode));\n extern int shift_32bit_count_operand PARAMS((rtx, enum machine_mode));\n extern int shladd_operand PARAMS((rtx, enum machine_mode));\n+extern int fetchadd_operand PARAMS((rtx, enum machine_mode));\n extern int reg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n-#endif\n-extern int ia64_rap_fp_offset PARAMS((void));\n-extern unsigned int ia64_compute_frame_size PARAMS((int));\n-extern void save_restore_insns PARAMS((int));\n-extern void ia64_expand_prologue PARAMS((void));\n-extern void ia64_expand_epilogue PARAMS((void));\n-extern void ia64_function_prologue PARAMS((FILE *, int));\n-extern void ia64_funtion_epilogue PARAMS((FILE *, int));\n-extern int ia64_direct_return PARAMS((void));\n+\n+extern void ia64_expand_fetch_and_op PARAMS ((enum fetchop_code,\n+\t\t\t\t\t      enum machine_mode, rtx []));\n+extern void ia64_expand_op_and_fetch PARAMS ((enum fetchop_code,\n+\t\t\t\t\t      enum machine_mode, rtx []));\n+\n+extern void ia64_print_operand_address PARAMS((FILE *, rtx));\n+extern void ia64_print_operand PARAMS((FILE *, rtx, int));\n+extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n+\t\t\t\t\t\t\t  enum machine_mode,\n+\t\t\t\t\t\t\t  rtx));\n+extern void ia64_reorg PARAMS((rtx));\n+#endif /* RTX_CODE */\n+\n #ifdef TREE_CODE\n-extern void ia64_setup_incoming_varargs PARAMS((CUMULATIVE_ARGS, int, tree,\n-\t\t\t\t\t\tint *, int));\n #ifdef RTX_CODE\n extern rtx ia64_function_arg PARAMS((CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t     tree, int, int));\n-extern void ia64_init_builtins PARAMS((void));\n-extern rtx ia64_expand_builtin PARAMS((tree, rtx, rtx, enum machine_mode, int));\n-#endif\n+extern rtx ia64_expand_builtin PARAMS((tree, rtx, rtx,\n+\t\t\t\t       enum machine_mode, int));\n+extern void ia64_va_start PARAMS((int, tree, rtx));\n+extern rtx ia64_va_arg PARAMS((tree, tree));\n+extern rtx ia64_function_value PARAMS((tree, tree));\n+#endif /* RTX_CODE */\n+\n+extern void ia64_setup_incoming_varargs PARAMS((CUMULATIVE_ARGS, int, tree,\n+\t\t\t\t\t\tint *, int));\n extern int ia64_function_arg_partial_nregs PARAMS((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t\t   tree, int));\n extern void ia64_function_arg_advance PARAMS((CUMULATIVE_ARGS *,\n \t\t\t\t\t      enum machine_mode,\n \t\t\t\t\t      tree, int));\n-#ifdef RTX_CODE\n-extern void ia64_va_start PARAMS((int, tree, rtx));\n-extern rtx ia64_va_arg PARAMS((tree, tree));\n-#endif\n extern int ia64_return_in_memory PARAMS((tree));\n-#ifdef RTX_CODE\n-extern rtx ia64_function_value PARAMS((tree, tree));\n-#endif\n-#endif\n-#ifdef RTX_CODE\n-extern void ia64_print_operand_address PARAMS((FILE *, rtx));\n-extern void ia64_print_operand PARAMS((FILE *, rtx, int));\n-extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n-\t\t\t\t\t\t\t  enum machine_mode,\n-\t\t\t\t\t\t\t  rtx));\n-#endif\n-#ifdef TREE_CODE\n-extern void ia64_asm_output_external PARAMS((FILE *, tree, char *));\n-#endif\n-extern void ia64_override_options PARAMS((void));\n-#ifdef RTX_CODE\n-extern void ia64_reorg PARAMS((rtx));\n-#endif\n-extern int ia64_epilogue_uses PARAMS((int));\n-#ifdef TREE_CODE\n+extern void ia64_asm_output_external PARAMS((FILE *, tree, const char *));\n+\n extern int ia64_valid_type_attribute PARAMS((tree, tree, tree, tree));\n extern void ia64_encode_section_info PARAMS((tree));\n-#endif\n+#endif /* TREE_CODE */\n+\n+extern int ia64_epilogue_uses PARAMS((int));\n+extern void ia64_expand_prologue PARAMS((void));\n+extern void ia64_expand_epilogue PARAMS((void));\n+extern int ia64_direct_return PARAMS((void));\n+extern int ia64_rap_fp_offset PARAMS((void));\n+extern void ia64_init_builtins PARAMS((void));\n+extern void ia64_override_options PARAMS((void));\n+extern unsigned int ia64_compute_frame_size PARAMS((int));\n+extern void save_restore_insns PARAMS((int));\n+extern void ia64_function_prologue PARAMS((FILE *, int));\n+extern void ia64_funtion_epilogue PARAMS((FILE *, int));"}, {"sha": "df0dbdca49e6eec411f91d2dc2d864a57440f85d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 95, "deletions": 88, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"ggc.h\"\n #include \"basic-block.h\"\n+#include \"toplev.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n    ASM_OUTPUT_LABELREF.  */\n@@ -199,7 +200,7 @@ setjmp_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  char *name;\n+  const char *name;\n   int retval = 0;\n \n   if (GET_CODE (op) != SYMBOL_REF)\n@@ -415,7 +416,7 @@ normal_comparison_operator (op, mode)\n {\n   enum rtx_code code = GET_CODE (op);\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && (code == EQ || code == NE \n+\t  && (code == EQ || code == NE\n \t      || code == GT || code == LE || code == GTU || code == LEU));\n }\n \n@@ -467,7 +468,7 @@ call_multiple_values_operation (op, mode)\n   return 1;\n }\n \n-\f  \n+\f\n /* Structure to be filled in by ia64_compute_frame_size with register\n    save masks and offsets for the current function.  */\n \n@@ -640,7 +641,7 @@ save_restore_insns (save_p)\n \t\t       + current_frame_info.pretend_pad_size));\n       rtx offset_rtx;\n       int regno;\n-\t\n+\n       /* If there is a frame pointer, then we use it instead of the stack\n \t pointer, so that the stack pointer does not need to be valid when\n \t the epilogue starts.  See EXIT_IGNORE_STACK.  */\n@@ -682,7 +683,7 @@ save_restore_insns (save_p)\n \t      }\n \t    break;\n \t  }\n-\t\t\n+\n       /* Must save/restore ar.unat if any GR is spilled/restored.  */\n       if (current_frame_info.gr_size != 0\n \t  || current_function_varargs || current_function_stdarg)\n@@ -705,7 +706,7 @@ save_restore_insns (save_p)\n \t      /* The restore happens after the last ld8.fill instruction.  */\n \t    }\n \t}\n-\t\n+\n       for (regno = GR_REG (0); regno <= GR_REG (127); regno++)\n \tif (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n \t  {\n@@ -739,7 +740,7 @@ save_restore_insns (save_p)\n \t    if (save_p)\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t  }\n-\t\t     \n+\n       for (regno = BR_REG (0); regno <= BR_REG (7); regno++)\n \tif (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n \t  {\n@@ -912,7 +913,7 @@ ia64_expand_prologue ()\n      local register names are known.  */\n   if (frame_pointer_needed)\n     {\n-      reg_names[FRAME_POINTER_REGNUM] \n+      reg_names[FRAME_POINTER_REGNUM]\n \t= reg_names[LOC_REG (locals - 3)];\n       ia64_fp_regno = LOC_REG (inputs + locals - 3);\n     }\n@@ -1092,7 +1093,7 @@ ia64_function_prologue (file, size)\n \n   /* Emit the .prologue directive. in order to do this, we need to find\n      where the stack pointer is moved toa GR, if it is, and mark it.  */\n-  \n+\n   for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n     {\n       if (RTX_FRAME_RELATED_P (insn) && GET_CODE (insn) == INSN)\n@@ -1403,7 +1404,7 @@ ia64_function_arg (cum, mode, type, named, incoming)\n \t\t\t\t\t\t   (basereg + cum->words\n \t\t\t\t\t\t    + offset)),\n \t\t\t\t      const0_rtx);\n-\t\t\t\t\t\t   \n+\n       return gen_rtx_PARALLEL (mode, gen_rtvec (2, fp_reg, gr_reg));\n     }\n }\n@@ -1572,7 +1573,7 @@ ia64_va_arg (valist, type)\n     {\n       t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n \t\t build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, \n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n \t\t build_int_2 (-2 * UNITS_PER_WORD, -1));\n       t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n@@ -1701,11 +1702,11 @@ ia64_print_operand (file, x, code)\n   switch (code)\n     {\n       /* XXX Add other codes here.  */\n-      \n+\n     case 0:\n       /* Handled below.  */\n       break;\n-      \n+\n     case 'B':\n       if (TARGET_A_STEP)\n \tfputs (\" ;; nop 0 ;; nop 0 ;;\", file);\n@@ -1768,7 +1769,7 @@ ia64_print_operand (file, x, code)\n \n \tif (GET_CODE (XEXP (x, 0)) == POST_DEC)\n \t  value = -value;\n-    \n+\n \tfprintf (file, \"%d\", value);\n \treturn;\n       }\n@@ -1779,13 +1780,13 @@ ia64_print_operand (file, x, code)\n       return;\n \n     case 'S':\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, exact_log2 (INTVAL (x)));\n+      fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n       return;\n \n     case 'T':\n       if (! TARGET_GNU_AS && GET_CODE (x) == CONST_INT)\n \t{\n-\t  fprintf (file, \"0x%x\", INTVAL (x) & 0xffffffff);\n+\t  fprintf (file, \"0x%x\", (int) INTVAL (x) & 0xffffffff);\n \t  return;\n \t}\n       break;\n@@ -1799,11 +1800,11 @@ ia64_print_operand (file, x, code)\n \t      fprintf (file, \"0xffffffff\");\n \t      prefix = \"\";\n \t    }\n-\t  fprintf (file, \"%s%x\", prefix, INTVAL (x) & 0xffffffff);\n+\t  fprintf (file, \"%s%x\", prefix, (int) INTVAL (x) & 0xffffffff);\n \t  return;\n \t}\n       break;\n-      \n+\n     case 'r':\n       /* If this operand is the constant zero, write it as zero.  */\n       if (GET_CODE (x) == REG)\n@@ -1838,7 +1839,7 @@ ia64_print_operand (file, x, code)\n \tfprintf (file, \"[%s]\", reg_names [REGNO (addr)]);\n \tbreak;\n       }\n-      \n+\n     default:\n       output_addr_const (file, x);\n       break;\n@@ -1928,7 +1929,7 @@ void\n ia64_asm_output_external (file, decl, name)\n      FILE *file;\n      tree decl;\n-     char *name;\n+     const char *name;\n {\n   int save_referenced;\n \n@@ -2812,8 +2813,7 @@ ia64_encode_section_info (decl)\n \t\t\t    \".sbss\")))\n     {\n       int size = int_size_in_bytes (TREE_TYPE (decl));\n-      char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n-      int reloc;\n+      const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n \n       /* ??? We should redeclare CTOR_LIST, DTOR_END so that we don't have to\n \t special case them here.  Currently we put them in ctor/dtors sections\n@@ -2827,7 +2827,7 @@ ia64_encode_section_info (decl)\n \t is too late to put it in sdata if it wasn't put there in the first\n \t place.  The test is here rather than above, because if it is already\n \t in sdata, then it can stay there.  */\n-\t \n+\n       else if (TREE_ASM_WRITTEN (decl))\n \t;\n \n@@ -2843,16 +2843,16 @@ ia64_encode_section_info (decl)\n \t  *newstr = SDATA_NAME_FLAG_CHAR;\n \t  XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n \t}\n-    }\t    \n+    }\n   /* This decl is marked as being in small data/bss but it shouldn't\n      be; one likely explanation for this is that the decl has been\n      moved into a different section from the one it was in when\n      ENCODE_SECTION_INFO was first called.  Remove the '@'.*/\n   else if (TREE_CODE (decl) == VAR_DECL\n-\t   && (XSTR (XEXP (DECL_RTL (decl), 0), 0)[0] \n+\t   && (XSTR (XEXP (DECL_RTL (decl), 0), 0)[0]\n \t       == SDATA_NAME_FLAG_CHAR))\n     {\n-      char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+      const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n       int len = strlen (str);\n       char *newstr = obstack_alloc (saveable_obstack, len);\n \n@@ -2887,7 +2887,7 @@ process_set (asm_out_file, pat)\n       && GET_CODE (dest) == REG && GR_REGNO_P (REGNO (dest)))\n     {\n       /* Assume this is a stack allocate insn.  */\n-      fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\", \n+      fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\",\n \t       REGNO (dest) + ia64_input_regs);\n       return 1;\n     }\n@@ -2901,17 +2901,18 @@ process_set (asm_out_file, pat)\n \t  rtx op1 = XEXP (src, 1);\n \t  if (op0 == dest && GET_CODE (op1) == CONST_INT)\n \t    {\n-\t      fprintf (asm_out_file, \"\\t.fframe %d\\n\", -INTVAL (op1));\n+\t      fputs (\"\\t.fframe \", asm_out_file);\n+\t      fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC, -INTVAL (op1));\n+\t      fputc ('\\n', asm_out_file);\n \t      frame_size = INTVAL (op1);\n \t      return 1;\n \t    }\n-\t  else\n-\t    if (op0 == dest && GET_CODE (op1) == REG)\n-\t     {\n-\t\tfprintf (asm_out_file, \"\\t.vframe r%d\\n\", REGNO (op1));\n-\t        frame_size = 0;\n-\t\treturn 1;\n-\t     }\n+\t  else if (op0 == dest && GET_CODE (op1) == REG)\n+\t    {\n+\t      fprintf (asm_out_file, \"\\t.vframe r%d\\n\", REGNO (op1));\n+\t      frame_size = 0;\n+\t      return 1;\n+\t    }\n \t}\n     }\n   /* Look for a frame offset.  */\n@@ -2945,7 +2946,7 @@ process_set (asm_out_file, pat)\n \t  /* Saving return address pointer.  */\n \t  if (regno == BR_REG (0))\n \t    {\n-\t      fprintf (asm_out_file, \"\\t.save rp, r%d\\n\", \n+\t      fprintf (asm_out_file, \"\\t.save rp, r%d\\n\",\n \t\t       REGNO (dest) + ia64_input_regs);\n \t      return 1;\n \t    }\n@@ -2972,13 +2973,13 @@ process_set (asm_out_file, pat)\n \t  return 1;\n \t}\n     }\n-  if (GET_CODE (dest) == MEM && GET_CODE (XEXP (dest, 0)) == POST_INC \n+  if (GET_CODE (dest) == MEM && GET_CODE (XEXP (dest, 0)) == POST_INC\n       && GET_CODE (XEXP (XEXP (dest, 0), 0)) == REG)\n     {\n       int spill_unspec = 0;\n       /* We adjust the spill_offset early, so we dont miss it later.  */\n-      spill_offset += 8;  \n-      sp_offset += 8;  \n+      spill_offset += 8;\n+      sp_offset += 8;\n       if (GET_CODE (src) == UNSPEC)\n \t{\n \t  spill_unspec = XINT (src, 1);\n@@ -2995,7 +2996,7 @@ process_set (asm_out_file, pat)\n \t      regno = REGNO (XVECEXP (src, 0, 0));\n \t      if (!spill_offset_emitted)\n \t        {\n-\t\t  fprintf (asm_out_file, \"\\t.spill %d\\n\", \n+\t\t  fprintf (asm_out_file, \"\\t.spill %d\\n\",\n /*\t\t\t   (frame_size + 16 - spill_offset ) / 4); */\n \t\t\t   (-(spill_offset - 8) + 16) / 4);\n \t\t  spill_offset_emitted = 1;\n@@ -3007,40 +3008,40 @@ process_set (asm_out_file, pat)\n           if (GR_REGNO_P (regno))\n \t    {\n \t      if (regno >= GR_REG (4) && regno <= GR_REG (7))\n-\t\tfprintf (asm_out_file, \"\\t.save.g 0x%x\\n\", \n+\t\tfprintf (asm_out_file, \"\\t.save.g 0x%x\\n\",\n \t\t\t 1 << (regno - GR_REG (4)));\n \t      else if (tmp_reg != NULL_RTX && regno == REGNO (tmp_reg))\n \t        {\n-\t\t  /* We saved a special reg to a temp reg, and now we're \n+\t\t  /* We saved a special reg to a temp reg, and now we're\n \t\t     dumping it to memory.  */\n \t\t  tmp_reg = NULL_RTX;\n \t\t  /* register 9 is ar.unat.  */\n \t\t  if (tmp_saved == 9)\n-\t\t    fprintf (asm_out_file, \"\\t.savesp ar.unat, %d\\n\", \n+\t\t    fprintf (asm_out_file, \"\\t.savesp ar.unat, %d\\n\",\n \t\t\t     (sp_offset - 8) / 4);\n \t\t  else if (tmp_saved == 5)\n \t\t    fprintf (asm_out_file, \"\\t.savesp pr, %d\\n\",\n \t\t\t     (sp_offset - 8) / 4);\n \t\t  else if (tmp_saved >= BR_REG (1) && tmp_saved <= BR_REG (5))\n \t\t    {\n \t\t      /* BR regs are saved this way too.  */\n-\t\t      fprintf (asm_out_file, \"\\t.save.b 0x%x\\n\", \n+\t\t      fprintf (asm_out_file, \"\\t.save.b 0x%x\\n\",\n \t\t\t       1 << (tmp_saved - BR_REG (1)));\n \t\t    }\n \t\t}\n-\t      else \n+\t      else\n \t        return 0;\n \t    }\n \t  if (FR_REGNO_P (regno))\n \t    {\n \t      if (regno >= FR_REG (2) && regno <= FR_REG (5))\n-\t\tfprintf (asm_out_file, \"\\t.save.f 0x%x\\n\", \n+\t\tfprintf (asm_out_file, \"\\t.save.f 0x%x\\n\",\n \t\t\t 1 << (regno - FR_REG (2)));\n \t      else\n \t\tif (regno >= FR_REG (16) && regno <= FR_REG (31))\n-\t\t  fprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\", \n+\t\t  fprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\",\n \t\t\t   1 << (regno - FR_REG (12)));\n-\t\telse \n+\t\telse\n \t\t  return 0;\n \t    }\n \t  return 1;\n@@ -3057,32 +3058,33 @@ process_for_unwind_directive (asm_out_file, insn)\n      FILE *asm_out_file;\n      rtx insn;\n {\n-  if ((flag_unwind_tables \n+  if ((flag_unwind_tables\n        || (flag_exceptions && !exceptions_via_longjmp))\n       && RTX_FRAME_RELATED_P (insn))\n     {\n-      rtx code, pat;\n-      pat = PATTERN (insn);\n+      rtx pat = PATTERN (insn);\n \n       switch (GET_CODE (pat))\n         {\n-\t  case SET:\n-\t    {\n-\t      process_set (asm_out_file, pat);\n-\t      break;\n-\t    }\n-\t  case PARALLEL:\n-\t    {\n-\t      int par_index;\n-\t      int limit = XVECLEN (pat, 0);\n-\t      for (par_index = 0; par_index < limit; par_index++)\n-\t        {\n-\t\t  rtx x = XVECEXP (pat, 0, par_index);\n-\t\t  if (GET_CODE (x) == SET)\n-\t\t    process_set (asm_out_file, x);\n-\t\t}\n-\t      break;\n-\t    }\n+\tcase SET:\n+\t  process_set (asm_out_file, pat);\n+\t  break;\n+\n+\tcase PARALLEL:\n+\t  {\n+\t    int par_index;\n+\t    int limit = XVECLEN (pat, 0);\n+\t    for (par_index = 0; par_index < limit; par_index++)\n+\t      {\n+\t\trtx x = XVECEXP (pat, 0, par_index);\n+\t\tif (GET_CODE (x) == SET)\n+\t\t  process_set (asm_out_file, x);\n+\t      }\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n }\n@@ -3171,7 +3173,7 @@ ia64_init_builtins ()\n \n   /* __sync_lock_test_and_set_di */\n   tree di_ftype_pdi_di\n-    = build_function_type (long_integer_type_node,  \n+    = build_function_type (long_integer_type_node,\n                            tree_cons (NULL_TREE, pdi_type_node,\n                            tree_cons (NULL_TREE, long_integer_type_node, endlink)));\n \n@@ -3267,7 +3269,7 @@ ia64_expand_fetch_and_op (code, mode, operands)\n       rtx reg;\n       if (GET_CODE (operands[2]) == CONST_INT)\n \treg = gen_reg_rtx (mode);\n-      else \n+      else\n         reg = operands[2];\n       if (mode == SImode)\n \t{\n@@ -3314,8 +3316,8 @@ ia64_expand_fetch_and_op (code, mode, operands)\n   default:\n     break;\n   }\n-    \n-  if (mode == SImode) \n+\n+  if (mode == SImode)\n     emit_insn (gen_cmpxchg_acq_si (tmp_reg, operands[1], tmp_reg));\n   else\n     emit_insn (gen_cmpxchg_acq_di (tmp_reg, operands[1], tmp_reg));\n@@ -3406,8 +3408,8 @@ ia64_expand_op_and_fetch (code, mode, operands)\n   default:\n     break;\n   }\n-    \n-  if (mode == SImode) \n+\n+  if (mode == SImode)\n     emit_insn (gen_cmpxchg_acq_si (tmp_reg, operands[1], operands[0]));\n   else\n     emit_insn (gen_cmpxchg_acq_di (tmp_reg, operands[1], operands[0]));\n@@ -3432,9 +3434,9 @@ ia64_expand_compare_and_swap (icode, arglist, target, boolcode)\n      int boolcode;\n {\n   tree arg0, arg1, arg2;\n-  rtx newlabel, newlabel2, op0, op1, op2, pat;\n+  rtx op0, op1, op2, pat;\n   enum machine_mode tmode, mode0, mode1, mode2;\n- \n+\n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n   arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n@@ -3517,29 +3519,35 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n      enum machine_mode mode;\n      int ignore;\n {\n-  rtx op0, op1, op2, op3, pat;\n+  rtx op0, op1, pat;\n   rtx tmp_reg;\n-  rtx newlabel, newlabel2;\n-  tree arg0, arg1, arg2, arg3;\n+  tree arg0, arg1;\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   int fcode = DECL_FUNCTION_CODE (fndecl);\n-  enum machine_mode tmode, mode0, mode1, mode2, mode3;\n+  enum machine_mode tmode, mode0, mode1;\n   enum insn_code icode;\n-  int boolcode = 0;\n   int i;\n   struct builtin_description *d;\n \n   switch (fcode)\n     {\n     case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI:\n-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_si, arglist, target, 1);\n+      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_si,\n+\t\t\t\t\t   arglist, target, 1);\n+\n     case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI:\n-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_si, arglist, target, 0);\n+      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_si,\n+\t\t\t\t\t   arglist, target, 0);\n+\n     case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI:\n-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_di, arglist, target, 1);\n+      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_di,\n+\t\t\t\t\t   arglist, target, 1);\n+\n     case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI:\n-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_di, arglist, target, 0);\n+      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_di,\n+\t\t\t\t\t   arglist, target, 0);\n+\n     case IA64_BUILTIN_SYNCHRONIZE:\n       /* Pass a volatile memory operand. */\n       tmp_reg = gen_rtx_REG (DImode, GR_REG(0));\n@@ -3580,7 +3588,7 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n       mode0 = insn_data[icode].operand[1].mode;\n       mode1 = insn_data[icode].operand[2].mode;\n       op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n-      RTX_UNCHANGING_P (op0) = 1; \n+      RTX_UNCHANGING_P (op0) = 1;\n       if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n         op1 = copy_to_mode_reg (mode1, op1);\n       if (target == 0\n@@ -3623,6 +3631,5 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n     if (d->code == fcode)\n       return ia64_expand_binop_builtin (d->icode, arglist, target);\n \n-  fail:\n-    return 0;\n+  return 0;\n }"}, {"sha": "b8a03c629dad60d69592304629d5ef57bff1ae53", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d4ef105b860e85f92006d9fb7dfb8e23f99ad/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=809d4ef105b860e85f92006d9fb7dfb8e23f99ad", "patch": "@@ -2205,7 +2205,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    to assemble a single byte containing the number VALUE.  */\n \n #define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n-  fprintf (STREAM, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+  fprintf (STREAM, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (int)(VALUE) & 0xff)\n \n /* These macros are defined as C string constant, describing the syntax in the\n    assembler for grouping arithmetic expressions.  */"}]}