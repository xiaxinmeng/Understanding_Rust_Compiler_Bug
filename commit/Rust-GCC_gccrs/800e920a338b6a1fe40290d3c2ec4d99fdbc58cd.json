{"sha": "800e920a338b6a1fe40290d3c2ec4d99fdbc58cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwZTkyMGEzMzhiNmExZmU0MDI5MGQzYzJlYzRkOTlmZGJjNThjZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-28T18:06:12Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-28T18:06:12Z"}, "message": "Initial revision\n\nFrom-SVN: r12354", "tree": {"sha": "b8f6e25b123c856d0e151931adbd5b22b22d4a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f6e25b123c856d0e151931adbd5b22b22d4a0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/800e920a338b6a1fe40290d3c2ec4d99fdbc58cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800e920a338b6a1fe40290d3c2ec4d99fdbc58cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/800e920a338b6a1fe40290d3c2ec4d99fdbc58cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800e920a338b6a1fe40290d3c2ec4d99fdbc58cd/comments", "author": null, "committer": null, "parents": [{"sha": "7aadc7c208ac446095fed7e5f6b2a21d4542210d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aadc7c208ac446095fed7e5f6b2a21d4542210d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aadc7c208ac446095fed7e5f6b2a21d4542210d"}], "stats": {"total": 497, "additions": 497, "deletions": 0}, "files": [{"sha": "abf12bcc22f0b3e28fd58e2830f7f0d37ca05a01", "filename": "gcc/config/alpha/elf.h", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800e920a338b6a1fe40290d3c2ec4d99fdbc58cd/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800e920a338b6a1fe40290d3c2ec4d99fdbc58cd/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=800e920a338b6a1fe40290d3c2ec4d99fdbc58cd", "patch": "@@ -0,0 +1,497 @@\n+/* Definitions of target machine for GNU compiler, for DEC Alpha w/ELF.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson (rth@tamu.edu).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.    */\n+\n+/* This is used on Alpha platforms that use the ELF format.\n+Currently only Linux uses this. */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (Alpha Linux/ELF)\");\n+\n+#undef OBJECT_FORMAT_COFF\n+#undef EXTENDED_COFF\n+#define OBJECT_FORMAT_ELF\n+\n+#define SDB_DEBUGGING_INFO\n+\n+#undef ASM_FINAL_SPEC\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"\\\n+-D__alpha -D__alpha__ -D__linux__ -D__linux -D_LONGLONG -Dlinux -Dunix \\\n+-Asystem(linux) -Acpu(alpha) -Amachine(alpha) -D__ELF__\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"-m elf64_alpha -G 8 %{O*:-O3} %{!O*:-O1}\t\\\n+  %{shared:-shared}\t\t\t\t\t\t\\\n+  %{!shared:\t\t\t\t\t\t\t\\\n+    %{!static:\t\t\t\t\t\t\t\\\n+      %{rdynamic:-export-dynamic}\t\t\t\t\\\n+      %{!dynamic-linker:-dynamic-linker /lib/ld-gnu.so.1}}\t\\\n+    %{static:-static}}\"\n+\n+/* Output at beginning of assembler file.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  alpha_write_verstamp (FILE);\t\t\t\t\t\\\n+  output_file_directive (FILE, main_input_filename);\t\t\\\n+  fprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n+  fprintf (FILE, \"\\t.set noat\\n\");\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE)\t\t\t\t\\\n+  alpha_output_lineno (STREAM, LINE)\n+extern void alpha_output_lineno ();\n+\n+extern void output_file_directive ();\n+\n+/* Attach a special .ident directive to the end of the file to identify\n+   the version of GCC which compiled this code.  The format of the\n+   .ident string is patterned after the ones produced by native svr4\n+   C compilers.  */\n+\n+#define IDENT_ASM_OP \".ident\"\n+\n+#ifdef IDENTIFY_WITH_IDENT\n+#define ASM_IDENTIFY_GCC(FILE) /* nothing */\n+#define ASM_IDENTIFY_LANGUAGE(FILE)\t\t\t\\\n+ fprintf(FILE, \"\\t%s \\\"GCC (%s) %s\\\"\\n\", IDENT_ASM_OP,\t\\\n+\t lang_identify(), version_string)\n+#else\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+do {\t\t\t\t \t\t\t\t\\\n+     fprintf ((FILE), \"\\t%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\t\\\n+\t      IDENT_ASM_OP, version_string);\t\t\t\\\n+   } while (0)\n+#endif\n+\n+/* Allow #sccs in preprocessor.  */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\t%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n+\n+/* This is how to allocate empty space in some section.  The .zero\n+   pseudo-op is used for this on most svr4 assemblers.  */\n+\n+#define SKIP_ASM_OP\t\".zero\"\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n+  fprintf (FILE, \"\\t%s\\t%u\\n\", SKIP_ASM_OP, (SIZE))\n+\n+/* Output the label which precedes a jumptable.  Note that for all svr4\n+   systems where we actually generate jumptables (which is to say every\n+   svr4 target except i386, where we use casesi instead) we put the jump-\n+   tables into the .rodata section and since other stuff could have been\n+   put into the .rodata section prior to any given jumptable, we have to\n+   make sure that the location counter for the .rodata section gets pro-\n+   perly re-aligned prior to the actual beginning of the jump table.  */\n+\n+#define ALIGN_ASM_OP \".align\"\n+\n+#ifndef ASM_OUTPUT_BEFORE_CASE_LABEL\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n+  ASM_OUTPUT_ALIGN ((FILE), 2);\n+#endif\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n+    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n+  } while (0)\n+\n+/* The standard SVR4 assembler seems to require that certain builtin\n+   library routines (e.g. .udiv) be explicitly declared as .globl\n+   in each assembly file where they are referenced.  */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\t\\\n+  ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized external linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#define COMMON_ASM_OP\t\".comm\"\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+} while (0)\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized internal linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#define LOCAL_ASM_OP\t\".local\"\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n+} while (0)\n+\n+/* This is the pseudo-op used to generate a 32-bit word of data with a\n+   specific value in some section.  This is the same for all known svr4\n+   assemblers.  */\n+\n+#define INT_ASM_OP\t\t\".long\"\n+\n+/* This is the pseudo-op used to generate a contiguous sequence of byte\n+   values from a double-quoted string WITHOUT HAVING A TERMINATING NUL\n+   AUTOMATICALLY APPENDED.  This is the same for most svr4 assemblers.  */\n+\n+#undef ASCII_DATA_ASM_OP\n+#define ASCII_DATA_ASM_OP\t\".ascii\"\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n+\n+#define USE_CONST_SECTION\t1\n+\n+#define CONST_SECTION_ASM_OP\t\".section\\t.rodata\"\n+\n+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n+\n+   Note that we want to give these sections the SHF_WRITE attribute\n+   because these sections will actually contain data (i.e. tables of\n+   addresses of functions in the current root executable or shared library\n+   file) and, in the case of a shared library, the relocatable addresses\n+   will have to be properly resolved/relocated (and then written into) by\n+   the dynamic linker when it actually attaches the given shared library\n+   to the executing process.  (Note that on SVR4, you may wish to use the\n+   `-z text' option to the ELF linker, when building a shared library, as\n+   an additional check that you are doing everything right.  But if you do\n+   use the `-z text' option when building a shared library, you will get\n+   errors unless the .ctors and .dtors sections are marked as writable\n+   via the SHF_WRITE attribute.)  */\n+\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"aw\\\"\"\n+\n+/* On svr4, we *do* have support for the .init and .fini sections, and we\n+   can put stuff in there to be executed before and after `main'.  We let\n+   crtstuff.c and other files know this by defining the following symbols.\n+   The definitions say how to change sections to the .init and .fini\n+   sections.  This is the same for all known svr4 assemblers.  */\n+\n+#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n+#define FINI_SECTION_ASM_OP\t\".section\\t.fini\"\n+\n+/* A default list of other sections which we might be \"in\" at any given\n+   time.  For targets that use additional sections (e.g. .tdesc) you\n+   should override this definition in the target-specific file which\n+   includes this file.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n+\n+/* A default list of extra section function definitions.  For targets\n+   that use additional sections (e.g. .tdesc) you should override this\n+   definition in the target-specific file which includes this file.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#undef READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+extern void text_section ();\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch into a generic section.\n+   This is currently only used to support section attributes.\n+\n+   We make the section read-only and executable for a function decl,\n+   read-only for a const data decl, and writable for a non-const data decl.  */\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME) \\\n+  fprintf (FILE, \".section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, \\\n+\t   (DECL) && TREE_CODE (DECL) == FUNCTION_DECL ? \"ax\" : \\\n+\t   (DECL) && TREE_READONLY (DECL) ? \"a\" : \"aw\")\n+\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n+\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n+\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of RTX in mode MODE.  RTX is some kind\n+   of constant in RTL.  The argument MODE is redundant except\n+   in the case of a `const_int' rtx.  Currently, these always\n+   go into the const section.  */\n+\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE,RTX) const_section()\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+\n+/* This is how we tell the assembler that a symbol is weak.  */\n+\n+#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n+  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n+       fputc ('\\n', FILE); } while (0)\n+\n+/* This is how we tell the assembler that two symbols have the same value.  */\n+\n+#define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \\\n+  do { assemble_name(FILE, NAME1); \t \\\n+       fputs(\" = \", FILE);\t\t \\\n+       assemble_name(FILE, NAME2);\t \\\n+       fputc('\\n', FILE); } while (0)\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL))); \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n+/* A table of bytes codes used by the ASM_OUTPUT_ASCII and\n+   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table\n+   corresponds to a particular byte value [0..255].  For any\n+   given byte value, if the value in the corresponding table\n+   position is zero, the given character can be output directly.\n+   If the table value is 1, the byte must be output as a \\ooo\n+   octal escape.  If the tables value is anything else, then the\n+   byte value should be output as a \\ followed by the value\n+   in the table.  Note that we can use standard UN*X escape\n+   sequences for many control characters, but we don't use\n+   \\a to represent BEL because some svr4 assemblers (e.g. on\n+   the i386) don't know about that.  Also, we don't use \\v\n+   since some versions of gas, such as 2.2 did not accept it.  */\n+\n+#define ESCAPES \\\n+\"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n+\n+/* Some svr4 assemblers have a limit on the number of characters which\n+   can appear in the operand of a .string directive.  If your assembler\n+   has such a limitation, you should define STRING_LIMIT to reflect that\n+   limit.  Note that at least some svr4 assemblers have a limit on the\n+   actual number of bytes in the double-quoted string, and that they\n+   count each character in an escape sequence as one byte.  Thus, an\n+   escape sequence like \\377 would count as four bytes.\n+\n+   If your target assembler doesn't support the .string directive, you\n+   should define this to zero.\n+*/\n+\n+#define STRING_LIMIT\t((unsigned) 256)\n+\n+#define STRING_ASM_OP\t\".string\"\n+\n+/*\n+ * We always use gas here, so we don't worry about ECOFF assembler problems.\n+ */\n+#undef TARGET_GAS\n+#define TARGET_GAS\t(1)\n+\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+/* Provide a STARTFILE_SPEC appropriate for Linux.  Here we add\n+   the Linux magical crtbegin.o file (see crtstuff.c) which\n+   provides part of the support for getting C++ file-scope static\n+   object constructed before entering `main'. */\n+   \n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shared: \\\n+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}}\\\n+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}\"\n+\n+/* Provide a ENDFILE_SPEC appropriate for Linux.  Here we tack on\n+   the Linux magical crtend.o file (see crtstuff.c) which\n+   provides part of the support for getting C++ file-scope static\n+   object constructed before entering `main', followed by a normal\n+   Linux \"finalizer\" file, `crtn.o'.  */\n+\n+#undef\tENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+  \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s\""}]}