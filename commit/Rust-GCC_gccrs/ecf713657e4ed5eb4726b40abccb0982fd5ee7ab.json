{"sha": "ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNmNzEzNjU3ZTRlZDVlYjQ3MjZiNDBhYmNjYjA5ODJmZDVlZTdhYg==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2005-03-06T08:42:33Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2005-03-06T08:42:33Z"}, "message": "Remove xref code.\n\n\t* xref.c, xref.h: Remove file.\n\t* Make-lang.in (java/xref.o): Remove.\n\t* java-tree.h (flag_emit_xref, do_not_fold): Remove declaration.\n\t* lang.c (flag_emit_xref): Remove definition.\n\t* parse.h (DECL_END_SOURCE_LINE, DECL_INHERITED_SOURCE_LINE): Remove.\n\t* typeck.c (convert): Remove use of do_not_fold.\n\t* parse.y (do_not_fold): Remove definition.\n\t(parser grammar): Remove xref code.\n\t(maybe_create_class_interface_decl, create_class): Likewise.\n\t(register_fields, method_header, finish_method_declaration): Likewise.\n\t(declare_local_variables, source_end_java_method): Likewise.\n\t(java_complete_expand_classes): Do not set do_not_fold.\n\t(java_complete_expand_method): Remove xref code.\n\t(java_expand_classes, resolve_field_access, patch_invoke): Likewise.\n\t(java_complete_tree, java_complete_lhs, patch_assignment): Likewise.\n\t(patch_binop, build_string_concatenation, patch_array_ref): Likewise.\n\t(patch_synchronized_statement, patch_throw_statement): Likewise.\n\t(maybe_build_class_init_for_field): Likewise.\n\nFrom-SVN: r95965", "tree": {"sha": "5034935021213d0b06bc19205368477097a7e437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5034935021213d0b06bc19205368477097a7e437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/comments", "author": null, "committer": null, "parents": [{"sha": "25910ca462a505549a8d08c21370965cbcea2bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25910ca462a505549a8d08c21370965cbcea2bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25910ca462a505549a8d08c21370965cbcea2bc1"}], "stats": {"total": 269, "additions": 45, "deletions": 224}, "files": [{"sha": "552629e945350043ca63553f0d968a90514ff5b0", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "patch": "@@ -1,3 +1,25 @@\n+2005-03-06  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\tRemove xref code.\n+\t* xref.c, xref.h: Remove file.\n+\t* Make-lang.in (java/xref.o): Remove.\n+\t* java-tree.h (flag_emit_xref, do_not_fold): Remove declaration.\n+\t* lang.c (flag_emit_xref): Remove definition.\n+\t* parse.h (DECL_END_SOURCE_LINE, DECL_INHERITED_SOURCE_LINE): Remove.\n+\t* typeck.c (convert): Remove use of do_not_fold.\n+\t* parse.y (do_not_fold): Remove definition.\n+\t(parser grammar): Remove xref code.\n+\t(maybe_create_class_interface_decl, create_class): Likewise.\n+\t(register_fields, method_header, finish_method_declaration): Likewise.\n+\t(declare_local_variables, source_end_java_method): Likewise.\n+\t(java_complete_expand_classes): Do not set do_not_fold.\n+\t(java_complete_expand_method): Remove xref code.\n+\t(java_expand_classes, resolve_field_access, patch_invoke): Likewise.\n+\t(java_complete_tree, java_complete_lhs, patch_assignment): Likewise.\n+\t(patch_binop, build_string_concatenation, patch_array_ref): Likewise.\n+\t(patch_synchronized_statement, patch_throw_statement): Likewise.\n+\t(maybe_build_class_init_for_field): Likewise.\n+\n 2005-03-05  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* expr.c (build_expr_wfl, expr_add_location): Use TYPE_P"}, {"sha": "d3e63069c76e6c14dfb94780f929d0917c597c39", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "patch": "@@ -106,7 +106,7 @@ JAVA_OBJS = java/parse.o java/class.o java/decl.o java/expr.o \\\n   java/zextract.o java/jcf-io.o java/win32-host.o java/jcf-parse.o java/mangle.o \\\n   java/mangle_name.o java/builtins.o java/resource.o \\\n   java/jcf-write.o java/buffer.o java/check-init.o java/jcf-depend.o \\\n-  java/jcf-path.o java/xref.o java/boehm.o java/java-gimplify.o\n+  java/jcf-path.o java/boehm.o java/java-gimplify.o\n \n GCJH_OBJS = java/gjavah.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \\\n   java/win32-host.o java/zextract.o version.o errors.o ggc-none.o \\\n@@ -345,8 +345,6 @@ java/verify-glue.o: java/verify-glue.c $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H) \\\n   coretypes.h $(TM_H) java/verify.h\n java/verify-impl.o: java/verify-impl.c $(CONFIG_H) java/verify.h $(SYSTEM_H) \\\n   coretypes.h  java/jcf.h $(JAVA_TREE_H)\n-java/xref.o: java/xref.c java/xref.h $(CONFIG_H) $(JAVA_TREE_H) toplev.h \\\n-  $(SYSTEM_H) coretypes.h $(TM_H)\n java/zextract.o: java/zextract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   java/zipfile.h\n java/java-gimplify.o: java/java-gimplify.c $(CONFIG_H) $(SYSTEM_H) \\"}, {"sha": "6a392a8daf9fa8e2f79c250d054ed40fc485c370", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "patch": "@@ -182,14 +182,6 @@ extern int flag_extraneous_semicolon;\n \n extern int flag_force_classes_archive_check;\n \n-/* When nonzero, we emit xref strings. Values of the flag for xref\n-   backends are defined in xref.h.  */\n-\n-extern int flag_emit_xref;\n-\n-/* When doing xrefs, tell when not to fold.   */\n-extern int do_not_fold;\n-\n /* Resource name.  */\n extern const char *resource_name;\n "}, {"sha": "abb7c8be1749bb9f8d3f9dcc11772cf52f8a092b", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "patch": "@@ -39,7 +39,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"flags.h\"\n-#include \"xref.h\"\n #include \"ggc.h\"\n #include \"diagnostic.h\"\n #include \"tree-inline.h\"\n@@ -117,11 +116,6 @@ int compiling_from_source;\n \n const char *resource_name;\n \n-/* When nonzero, we emit xref strings. Values of the flag for xref\n-   backends are defined in xref_flag_table, xref.c.  */\n-\n-int flag_emit_xref = 0;\n-\n /* When nonzero, -Wall was turned on.  */\n int flag_wall = 0;\n "}, {"sha": "f026c909596d11044e82cf207ad8b2ac01cfaac8", "filename": "gcc/java/parse.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "patch": "@@ -739,10 +739,6 @@ typedef struct jdeplist_s jdeplist;\n /* Macro to access the osb (opening square bracket) count */\n #define CURRENT_OSB(C) (C)->osb_number [(C)->osb_depth]\n \n-/* Macro for the xreferencer */\n-#define DECL_END_SOURCE_LINE(DECL)       (DECL_CHECK (DECL)->decl.u1.i)\n-#define DECL_INHERITED_SOURCE_LINE(DECL) (DECL_CHECK (DECL)->decl.u2.i)\n-     \n /* Parser context data structure. */\n struct parser_ctxt GTY(()) {\n   const char *filename;\t\t     /* Current filename */"}, {"sha": "dc70e1207e5728acde57f2c4562b5405a570d973", "filename": "gcc/java/parse.y", "status": "modified", "additions": 22, "deletions": 106, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "patch": "@@ -67,7 +67,6 @@ definitions and other extensions.  */\n #include \"zipfile.h\"\n #include \"convert.h\"\n #include \"buffer.h\"\n-#include \"xref.h\"\n #include \"function.h\"\n #include \"except.h\"\n #include \"ggc.h\"\n@@ -354,8 +353,6 @@ static char *string_convert_int_cst (tree);\n int java_error_count;\n /* Number of warning found so far. */\n int java_warning_count;\n-/* Tell when not to fold, when doing xrefs */\n-int do_not_fold;\n /* Cyclic inheritance report, as it can be set by layout_class */\n const char *cyclic_inheritance_report;\n \n@@ -908,16 +905,10 @@ interface_type_list:\n class_body:\n \tOCB_TK CCB_TK\n \t\t{\n-\t\t  /* Store the location of the `}' when doing xrefs */\n-\t\t  if (flag_emit_xref)\n-\t\t    DECL_END_SOURCE_LINE (GET_CPC ()) = $2.location;\n \t\t  $$ = GET_CPC ();\n \t\t}\n |\tOCB_TK class_body_declarations CCB_TK\n \t\t{\n-\t\t  /* Store the location of the `}' when doing xrefs */\n-\t\t  if (flag_emit_xref)\n-\t\t    DECL_END_SOURCE_LINE (GET_CPC ()) = $3.location;\n \t\t  $$ = GET_CPC ();\n \t\t}\n ;\n@@ -1393,9 +1384,6 @@ block_end:\n \tCCB_TK\n \t\t{\n \t\t  maybe_absorb_scoping_blocks ();\n-\t\t  /* Store the location of the `}' when doing xrefs */\n-\t\t  if (current_function_decl && flag_emit_xref)\n-\t\t    DECL_END_SOURCE_LINE (current_function_decl) = $1.location;\n \t\t  $$ = exit_block ();\n \t\t  if (!BLOCK_SUBBLOCKS ($$))\n \t\t    BLOCK_SUBBLOCKS ($$) = build_java_empty_stmt ();\n@@ -3886,11 +3874,7 @@ maybe_create_class_interface_decl (tree decl, tree raw_name,\n   DECL_SOURCE_LOCATION (decl) = EXPR_LOCATION (cl);\n #else\n   DECL_SOURCE_FILE (decl) = EXPR_WFL_FILENAME (cl);\n-  /* If we're emitting xrefs, store the line/col number information */\n-  if (flag_emit_xref)\n-    DECL_SOURCE_LINE (decl) = EXPR_WFL_LINECOL (cl);\n-  else\n-    DECL_SOURCE_LINE (decl) = EXPR_WFL_LINENO (cl);\n+  DECL_SOURCE_LINE (decl) = EXPR_WFL_LINENO (cl);\n #endif\n   CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) = 1;\n   CLASS_PARSED_P (TREE_TYPE (decl)) = 1;\n@@ -4199,11 +4183,6 @@ create_class (int flags, tree id, tree super, tree interfaces)\n   if (PURE_INNER_CLASS_DECL_P (decl))\n     add_inner_class_fields (decl, current_function_decl);\n \n-  /* If doing xref, store the location at which the inherited class\n-     (if any) was seen. */\n-  if (flag_emit_xref && super)\n-    DECL_INHERITED_SOURCE_LINE (decl) = EXPR_WFL_LINECOL (super);\n-\n   /* Eventually sets the @deprecated tag flag */\n   CHECK_DEPRECATED (decl);\n \n@@ -4495,10 +4474,7 @@ register_fields (int flags, tree type, tree variable_list)\n #ifdef USE_MAPPED_LOCATION\n       input_location = EXPR_LOCATION (cl);\n #else\n-      if (flag_emit_xref)\n-\tinput_line = EXPR_WFL_LINECOL (cl);\n-      else\n-\tinput_line = EXPR_WFL_LINENO (cl);\n+      input_line = EXPR_WFL_LINENO (cl);\n #endif\n       field_decl = add_field (class_type, current_name, real_type, flags);\n       CHECK_DEPRECATED_NO_RESET (field_decl);\n@@ -4895,17 +4871,6 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   /* Eventually set the @deprecated tag flag */\n   CHECK_DEPRECATED (meth);\n \n-  /* If doing xref, store column and line number information instead\n-     of the line number only. */\n-  if (flag_emit_xref)\n-    {\n-#ifdef USE_MAPPED_LOCATION\n-      DECL_SOURCE_LOCATION (meth) = EXPR_LOCATION (id);\n-#else\n-      DECL_SOURCE_LINE (meth) = EXPR_WFL_LINECOL (id);\n-#endif\n-    }\n-\n   return meth;\n }\n \n@@ -4971,8 +4936,7 @@ finish_method_declaration (tree method_body)\n   exit_block ();\n   /* Merge last line of the function with first line, directly in the\n      function decl. It will be used to emit correct debug info. */\n-  if (!flag_emit_xref)\n-    DECL_FUNCTION_LAST_LINE (current_function_decl) = ctxp->last_ccb_indent1;\n+  DECL_FUNCTION_LAST_LINE (current_function_decl) = ctxp->last_ccb_indent1;\n \n   /* Since function's argument's list are shared, reset the\n      ARG_FINAL_P parameter that might have been set on some of this\n@@ -7517,16 +7481,6 @@ declare_local_variables (int modifier, tree type, tree vlist)\n       DECL_FINAL (decl) = final_p;\n       BLOCK_CHAIN_DECL (decl);\n \n-      /* If doing xreferencing, replace the line number with the WFL\n-         compound value */\n-#ifdef USE_MAPPED_LOCATION\n-      if (flag_emit_xref)\n-\tDECL_SOURCE_LOCATION (decl) = EXPR_LOCATION (wfl);\n-#else\n-      if (flag_emit_xref)\n-\tDECL_SOURCE_LINE (decl) = EXPR_WFL_LINECOL (wfl);\n-#endif\n-\n       /* Don't try to use an INIT statement when an error was found */\n       if (init && java_error_count)\n \tinit = NULL_TREE;\n@@ -7707,8 +7661,7 @@ source_end_java_method (void)\n     BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)) = NULL_TREE;\n \n   if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl))\n-      && ! flag_emit_class_files\n-      && ! flag_emit_xref)\n+      && ! flag_emit_class_files)\n     finish_method (fndecl);\n \n   current_function_decl = NULL_TREE;\n@@ -7869,8 +7822,6 @@ java_complete_expand_classes (void)\n {\n   tree current;\n \n-  do_not_fold = flag_emit_xref;\n-\n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     if (!INNER_CLASS_DECL_P (current))\n       java_complete_expand_class (current);\n@@ -8249,7 +8200,7 @@ java_complete_expand_method (tree mdecl)\n       htab_traverse (DECL_FUNCTION_INIT_TEST_TABLE (mdecl),\n \t\t     attach_init_test_initialization_flags, block_body);\n \n-      if (! flag_emit_xref && ! METHOD_NATIVE (mdecl))\n+      if (! METHOD_NATIVE (mdecl))\n \t{\n \t  check_for_initialization (block_body, mdecl);\n \n@@ -8279,8 +8230,7 @@ java_complete_expand_method (tree mdecl)\n      an error_mark_node here. */\n   if (block_body != error_mark_node\n       && (block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE\n-      && !flag_emit_xref)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n     missing_return_error (current_function_decl);\n \n   /* See if we can get rid of <clinit> if MDECL happens to be <clinit> */\n@@ -8296,7 +8246,7 @@ java_complete_expand_method (tree mdecl)\n   if (currently_caught_type_list)\n     abort ();\n \n-  /* Restore the copy of the list of exceptions if emitting xrefs. */\n+  /* Restore the copy of the list of exceptions. */\n   DECL_FUNCTION_THROWS (mdecl) = exception_copy;\n }\n \n@@ -9282,10 +9232,10 @@ java_expand_classes (void)\n #endif\n \n   /* If we've found error at that stage, don't try to generate\n-     anything, unless we're emitting xrefs or checking the syntax only\n+     anything, unless we're checking the syntax only\n      (but not using -fsyntax-only for the purpose of generating\n-     bytecode. */\n-  if (java_error_count && !flag_emit_xref\n+     bytecode).  */\n+  if (java_error_count\n       && (!flag_syntax_only && !flag_emit_class_files))\n     return;\n \n@@ -9331,8 +9281,6 @@ java_expand_classes (void)\n \t  output_class = current_class = TREE_TYPE (TREE_VALUE (current));\n \t  if (flag_emit_class_files)\n \t    write_classfile (current_class);\n-\t  if (flag_emit_xref)\n-\t    expand_xref (current_class);\n \t  else if (! flag_syntax_only)\n \t    java_expand_method_bodies (current_class);\n \t}\n@@ -9619,7 +9567,7 @@ resolve_field_access (tree qual_wfl, tree *field_decl, tree *field_type)\n   /* Resolve the LENGTH field of an array here */\n   if (DECL_P (decl) && DECL_NAME (decl) == length_identifier_node\n       && type_found && TYPE_ARRAY_P (type_found)\n-      && ! flag_emit_class_files && ! flag_emit_xref)\n+      && ! flag_emit_class_files)\n     {\n       tree length = build_java_array_length_access (where_found);\n       field_ref = length;\n@@ -9645,7 +9593,7 @@ resolve_field_access (tree qual_wfl, tree *field_decl, tree *field_type)\n       if (!type_found)\n \ttype_found = DECL_CONTEXT (decl);\n       is_static = FIELD_STATIC (decl);\n-      field_ref = build_field_ref ((is_static && !flag_emit_xref?\n+      field_ref = build_field_ref ((is_static ?\n \t\t\t\t    NULL_TREE : where_found),\n \t\t\t\t   type_found, DECL_NAME (decl));\n       if (field_ref == error_mark_node)\n@@ -9658,7 +9606,6 @@ resolve_field_access (tree qual_wfl, tree *field_decl, tree *field_type)\n \t looks like `field.ref', where `field' is a static field in an\n \t interface we implement.  */\n       if (!flag_emit_class_files\n-\t  && !flag_emit_xref\n \t  && TREE_CODE (where_found) == VAR_DECL\n \t  && FIELD_STATIC (where_found))\n \t{\n@@ -10485,7 +10432,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n       if (TREE_CODE (resolved) == VAR_DECL && FIELD_STATIC (resolved)\n          && FIELD_FINAL (resolved)\n          && !inherits_from_p (DECL_CONTEXT (resolved), current_class)\n-         && !flag_emit_class_files && !flag_emit_xref)\n+         && !flag_emit_class_files)\n        resolved = build_class_init (DECL_CONTEXT (resolved), resolved);\n \n       if (resolved == error_mark_node)\n@@ -10964,7 +10911,7 @@ patch_invoke (tree patch, tree method, tree args)\n   if (TREE_CODE (t) == POINTER_TYPE && !CLASS_LOADED_P (TREE_TYPE (t)))\n     resolve_and_layout (TREE_TYPE (t), NULL);\n \n-  if (flag_emit_class_files || flag_emit_xref)\n+  if (flag_emit_class_files)\n     func = method;\n   else\n     {\n@@ -11030,7 +10977,7 @@ patch_invoke (tree patch, tree method, tree args)\n       tree c1, saved_new, new;\n       tree alloc_node;\n \n-      if (flag_emit_class_files || flag_emit_xref)\n+      if (flag_emit_class_files)\n \t{\n \t  TREE_TYPE (patch) = build_pointer_type (class);\n \t  return patch;\n@@ -11577,8 +11524,7 @@ java_complete_tree (tree node)\n {\n   node = java_complete_lhs (node);\n   if (JDECL_P (node) && CLASS_FINAL_VARIABLE_P (node)\n-      && DECL_INITIAL (node) != NULL_TREE\n-      && !flag_emit_xref)\n+      && DECL_INITIAL (node) != NULL_TREE)\n     {\n       tree value = fold_constant_for_init (node, node);\n       if (value != NULL_TREE)\n@@ -11780,7 +11726,7 @@ java_complete_lhs (tree node)\n \t       && DECL_INITIAL (cn))\n \tcn = fold_constant_for_init (DECL_INITIAL (cn), cn);\n \n-      if (!TREE_CONSTANT (cn) && !flag_emit_xref)\n+      if (!TREE_CONSTANT (cn))\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \t  parse_error_context (node, \"Constant expression required\");\n@@ -11969,13 +11915,6 @@ java_complete_lhs (tree node)\n \t  node = resolve_expression_name (node, NULL);\n \t  if (node == error_mark_node)\n \t    return node;\n-\t  /* Keep line number information somewhere were it doesn't\n-\t     disrupt the completion process. */\n-\t  if (flag_emit_xref && TREE_CODE (node) != CALL_EXPR)\n-\t    {\n-\t      EXPR_WFL_NODE (wfl) = TREE_OPERAND (node, 1);\n-\t      TREE_OPERAND (node, 1) = wfl;\n-\t    }\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n \t}\n       else\n@@ -12291,11 +12230,6 @@ java_complete_lhs (tree node)\n     case INSTANCEOF_EXPR:\n       wfl_op1 = TREE_OPERAND (node, 0);\n       COMPLETE_CHECK_OP_0 (node);\n-      if (flag_emit_xref)\n-\t{\n-\t  TREE_TYPE (node) = boolean_type_node;\n-\t  return node;\n-\t}\n       return patch_binop (node, wfl_op1, TREE_OPERAND (node, 1));\n \n     case UNARY_PLUS_EXPR:\n@@ -12325,14 +12259,14 @@ java_complete_lhs (tree node)\n       TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n-      if (!flag_emit_class_files && !flag_emit_xref)\n+      if (!flag_emit_class_files)\n \tTREE_OPERAND (node, 0) = save_expr (TREE_OPERAND (node, 0));\n       /* The same applies to wfl_op2 */\n       wfl_op2 = TREE_OPERAND (node, 1);\n       TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n       if (TREE_OPERAND (node, 1) == error_mark_node)\n \treturn error_mark_node;\n-      if (!flag_emit_class_files && !flag_emit_xref)\n+      if (!flag_emit_class_files)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n       return patch_array_ref (node);\n \n@@ -12897,7 +12831,6 @@ patch_assignment (tree node, tree wfl_op1)\n \n   /* 10.10: Array Store Exception runtime check */\n   if (!flag_emit_class_files\n-      && !flag_emit_xref\n       && lvalue_from_array\n       && JREFERENCE_TYPE_P (TYPE_ARRAY_ELEMENT (lhs_type)))\n     {\n@@ -13837,9 +13770,6 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n   TREE_TYPE (node) = prom_type;\n   TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n \n-  if (flag_emit_xref)\n-    return node;\n-\n   /* fold does not respect side-effect order as required for Java but not C.\n    * Also, it sometimes create SAVE_EXPRs which are bad when emitting\n    * bytecode.\n@@ -13984,9 +13914,6 @@ build_string_concatenation (tree op1, tree op2)\n   tree result;\n   int side_effects = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n \n-  if (flag_emit_xref)\n-    return build2 (PLUS_EXPR, string_type_node, op1, op2);\n-\n   /* Try to do some static optimization */\n   if ((result = string_constant_concatenation (op1, op2)))\n     return result;\n@@ -14600,7 +14527,7 @@ patch_array_ref (tree node)\n \n   array_type = TYPE_ARRAY_ELEMENT (array_type);\n \n-  if (flag_emit_class_files || flag_emit_xref)\n+  if (flag_emit_class_files)\n     {\n       TREE_OPERAND (node, 0) = array;\n       TREE_OPERAND (node, 1) = index;\n@@ -15763,14 +15690,6 @@ patch_synchronized_statement (tree node, tree wfl_op1)\n       return error_mark_node;\n     }\n \n-  if (flag_emit_xref)\n-    {\n-      TREE_OPERAND (node, 0) = expr;\n-      TREE_OPERAND (node, 1) = java_complete_tree (block);\n-      CAN_COMPLETE_NORMALLY (node) = 1;\n-      return node;\n-    }\n-\n   /* Generate a try-finally for the synchronized statement, except\n      that the handler that catches all throw exception calls\n      _Jv_MonitorExit and then rethrow the exception.\n@@ -15895,12 +15814,9 @@ patch_throw_statement (tree node, tree wfl_op1)\n       return error_mark_node;\n     }\n \n-  if (! flag_emit_class_files && ! flag_emit_xref)\n+  if (! flag_emit_class_files)\n     BUILD_THROW (node, expr);\n \n-  /* If doing xrefs, keep the location where the `throw' was seen. */\n-  if (flag_emit_xref)\n-    EXPR_WFL_LINECOL (node) = EXPR_WFL_LINECOL (wfl_op1);\n   return node;\n }\n \n@@ -16155,7 +16071,7 @@ static tree\n maybe_build_class_init_for_field (tree decl, tree expr)\n {\n   tree clas = DECL_CONTEXT (decl);\n-  if (flag_emit_class_files || flag_emit_xref)\n+  if (flag_emit_class_files)\n     return expr;\n \n   if (TREE_CODE (decl) == VAR_DECL && FIELD_STATIC (decl)"}, {"sha": "170a58de6ba1d59211b9ba0615cc031236e8721e", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf713657e4ed5eb4726b40abccb0982fd5ee7ab/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=ecf713657e4ed5eb4726b40abccb0982fd5ee7ab", "patch": "@@ -119,9 +119,6 @@ convert (tree type, tree expr)\n   if (!expr)\n    return error_mark_node;\n \n-  if (do_not_fold)\n-    return build1 (NOP_EXPR, type, expr);\n-\n   if (type == TREE_TYPE (expr)\n       || TREE_CODE (expr) == ERROR_MARK)\n     return expr;"}, {"sha": "baccc5f3375bafd7846dfd7992962ccdee0a2786", "filename": "gcc/java/xref.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2Fjava%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2Fjava%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fxref.c?ref=25910ca462a505549a8d08c21370965cbcea2bc1", "patch": "@@ -1,59 +0,0 @@\n-/* Write cross reference information extracted from Java(TM)\n-   source and bytecode files, in one of formats documented below.\n-   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"java-tree.h\"\n-#include \"xref.h\"\n-#include \"jcf.h\"\n-#include \"parse.h\"\n-\n-static xref_flag_table xref_table [] = {\n-  {NULL, NULL, NULL, NULL},\n-};\n-\n-/* Branch to the right xref \"back-end\".  */\n-\n-void\n-expand_xref (tree node)\n-{\n-  /* Maintain these two cached. */\n-  static FILE *fp = NULL;\n-  static void (*current_expand) (FILE *, tree) = NULL;\n-\n-  if ( !flag_emit_xref )\n-    return;\n-\n-  if (!fp)\n-    fp = xref_table [flag_emit_xref-1].fp;\n-  if (!current_expand)\n-    current_expand = xref_table [flag_emit_xref-1].expand;\n-\n-  (*current_expand) (fp, node);\n-}"}, {"sha": "d75efa8e2ec49f5879a8bc8aef99b92fa41c244b", "filename": "gcc/java/xref.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2Fjava%2Fxref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2Fjava%2Fxref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fxref.h?ref=25910ca462a505549a8d08c21370965cbcea2bc1", "patch": "@@ -1,35 +0,0 @@\n-/* Definitions for the cross reference backend xref.c\n-   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n-   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Exported functions. */\n-void expand_xref (tree);\n-\n-/* Lookup table to be used with the value of flag_emit_xref */\n-typedef struct {\n-  char *key;\t\t\t         /* Activator in -fxref=<key>  */\n-  void (*expand) (FILE *, tree);         /* Function to write xrefs out */\n-  FILE *fp;\t\t\t         /* fp to use during the call.  */\n-  void *data;\t\t\t         /* Placeholder for additional data */\n-} xref_flag_table;"}]}