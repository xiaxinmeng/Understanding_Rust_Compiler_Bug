{"sha": "0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "node_id": "C_kwDOANBUbNoAKDBiNTIwODNlYTJjMmRkOTg5NzAzMWZkYzM4MDJhNjhmZDRhYTQ1ZWY", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-12-12T21:16:21Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-12-12T21:16:23Z"}, "message": "libgccjit: Add support for setting the link section of global variables [PR100688]\n\n2021-12-12  Antoni Boucher  <bouanto@zoho.com>\n\ngcc/jit/\n\tPR target/100688\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_18): New ABI\n\ttag.\n\t* docs/topics/expressions.rst: Add documentation for the\n\tfunction gcc_jit_lvalue_set_link_section.\n\t* jit-playback.h: New function (set_link_section).\n\t* jit-recording.c: New function (set_link_section) and\n\tsupport for setting the link section.\n\t* jit-recording.h: New function (set_link_section) and new\n\tfield m_link_section.\n\t* libgccjit.c: New function (gcc_jit_lvalue_set_link_section).\n\t* libgccjit.h: New function (gcc_jit_lvalue_set_link_section).\n\t* libgccjit.map (LIBGCCJIT_ABI_18): New ABI tag.\n\ngcc/testsuite/\n\tPR target/100688\n\t* jit.dg/all-non-failing-tests.h: Mention new test\n\tlink-section-assembler.\n\t* jit.dg/test-link-section-assembler.c: New test.\n\t* jit.dg/jit.exp: New helper function to test that the\n\tassembly contains a pattern.", "tree": {"sha": "38c90893498f6f89ee9616f5bbb567240bfc1311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38c90893498f6f89ee9616f5bbb567240bfc1311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeedb00a1ae2ccd10b1a5f00ff466081aeadb54b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeedb00a1ae2ccd10b1a5f00ff466081aeadb54b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeedb00a1ae2ccd10b1a5f00ff466081aeadb54b"}], "stats": {"total": 167, "additions": 163, "deletions": 4}, "files": [{"sha": "c6c14f0a7612fceb6c18bad9f94ddcf09884d4a4", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -293,3 +293,12 @@ entrypoints:\n thread-local storage model of a variable:\n \n   * :func:`gcc_jit_lvalue_set_tls_model`\n+\n+.. _LIBGCCJIT_ABI_18:\n+\n+``LIBGCCJIT_ABI_18``\n+-----------------------\n+``LIBGCCJIT_ABI_18`` covers the addition of an API entrypoint to set the link\n+section of a variable:\n+\n+  * :func:`gcc_jit_lvalue_set_link_section`"}, {"sha": "280e0eaea6806d5001381cc2565a972575a70797", "filename": "gcc/jit/docs/topics/expressions.rst", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -576,6 +576,27 @@ where the rvalue is computed by reading from the storage area.\n \n       #ifdef LIBGCCJIT_HAVE_gcc_jit_lvalue_set_tls_model\n \n+.. function:: void\n+              gcc_jit_lvalue_set_link_section (gcc_jit_lvalue *lvalue,\n+                                               const char *section_name)\n+\n+   Set the link section of a variable.\n+   The parameter ``section_name`` must be non-NULL and must contain the\n+   leading dot. Analogous to:\n+\n+   .. code-block:: c\n+\n+     int variable __attribute__((section(\".section\")));\n+\n+   in C.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_18`; you can test for\n+   its presence using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_gcc_jit_lvalue_set_link_section\n+\n Global variables\n ****************\n "}, {"sha": "21ddffb228ffcbb3388a5a18dd7d781204c1b07a", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -681,6 +681,12 @@ class lvalue : public rvalue\n     set_decl_tls_model (as_tree (), tls_model);\n   }\n \n+  void\n+  set_link_section (const char* name)\n+  {\n+    set_decl_section_name (as_tree (), name);\n+  }\n+\n private:\n   bool mark_addressable (location *loc);\n };"}, {"sha": "b42407909579860caafeae2317c90f6153e1f395", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -3724,6 +3724,11 @@ recording::lvalue::set_tls_model (enum gcc_jit_tls_model model)\n     m_tls_model = model;\n }\n \n+void recording::lvalue::set_link_section (const char *name)\n+{\n+  m_link_section = new_string (name);\n+}\n+\n /* The implementation of class gcc::jit::recording::param.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -4568,22 +4573,26 @@ static const enum tls_model tls_models[] = {\n void\n recording::global::replay_into (replayer *r)\n {\n-    playback::lvalue *global = m_initializer\n-    ? r->new_global_initialized (playback_location (r, m_loc),\n+  playback::lvalue *global = m_initializer\n+  ? r->new_global_initialized (playback_location (r, m_loc),\n \t\t\t\t m_kind,\n \t\t\t\t m_type->playback_type (),\n \t\t\t\t m_type->dereference ()->get_size (),\n \t\t\t\t m_initializer_num_bytes\n \t\t\t\t / m_type->dereference ()->get_size (),\n \t\t\t\t m_initializer,\n \t\t\t\t playback_string (m_name))\n-    : r->new_global (playback_location (r, m_loc),\n+  : r->new_global (playback_location (r, m_loc),\n \t\t     m_kind,\n \t\t     m_type->playback_type (),\n \t\t     playback_string (m_name));\n+\n   if (m_tls_model != GCC_JIT_TLS_MODEL_NONE)\n     global->set_tls_model (recording::tls_models[m_tls_model]);\n \n+  if (m_link_section != NULL)\n+    global->set_link_section (m_link_section->c_str ());\n+\n   set_playback_obj (global);\n }\n \n@@ -4713,6 +4722,12 @@ recording::global::write_reproducer (reproducer &r)\n \t     id,\n \t     tls_model_enum_strings[m_tls_model]);\n \n+  if (m_link_section != NULL)\n+    r.write (\"  gcc_jit_lvalue_set_link_section (%s, /* gcc_jit_lvalue *lvalue */\\n\"\n+\t\"                                  \\\"%s\\\"); /* */\\n\",\n+     id,\n+     m_link_section->c_str ());\n+\n   if (m_initializer)\n     switch (m_type->dereference ()->get_size ())\n       {"}, {"sha": "cedb24720cfdfdf4bf45c212622e70c7035bb224", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -1133,7 +1133,8 @@ class lvalue : public rvalue\n \t  location *loc,\n \t  type *type_)\n     : rvalue (ctxt, loc, type_),\n-    m_tls_model (GCC_JIT_TLS_MODEL_NONE)\n+    m_tls_model (GCC_JIT_TLS_MODEL_NONE),\n+    m_link_section (NULL)\n     {}\n \n   playback::lvalue *\n@@ -1156,9 +1157,11 @@ class lvalue : public rvalue\n   virtual const char *access_as_lvalue (reproducer &r);\n   virtual bool is_global () const { return false; }\n   void set_tls_model (enum gcc_jit_tls_model model);\n+  void set_link_section (const char *name);\n \n protected:\n   enum gcc_jit_tls_model m_tls_model;\n+  string *m_link_section;\n };\n \n class param : public lvalue"}, {"sha": "59cef614d4b7a9f25c60f603725f5e6d53fc87c8", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -2235,6 +2235,19 @@ gcc_jit_lvalue_set_tls_model (gcc_jit_lvalue *lvalue,\n   lvalue->set_tls_model (model);\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::lvalue::set_link_section method in jit-recording.c.  */\n+\n+void\n+gcc_jit_lvalue_set_link_section (gcc_jit_lvalue *lvalue,\n+\t\t\t    const char *section_name)\n+{\n+  RETURN_IF_FAIL (section_name, NULL, NULL, \"NULL section_name\");\n+  lvalue->set_link_section (section_name);\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the"}, {"sha": "024c8d79f4b6bd4c378b32c8b43e6eff7162d4a5", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -1110,6 +1110,20 @@ extern void\n gcc_jit_lvalue_set_tls_model (gcc_jit_lvalue *lvalue,\n \t\t\t    enum gcc_jit_tls_model model);\n \n+#define LIBGCCJIT_HAVE_gcc_jit_lvalue_set_link_section\n+\n+/* Set the link section of a global variable; analogous to:\n+     __attribute__((section(\".section_name\")))\n+   in C.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_18; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_gcc_jit_lvalue_set_link_section\n+*/\n+extern void\n+gcc_jit_lvalue_set_link_section (gcc_jit_lvalue *lvalue,\n+\t\t\t    const char *section_name);\n+\n extern gcc_jit_lvalue *\n gcc_jit_function_new_local (gcc_jit_function *func,\n \t\t\t    gcc_jit_location *loc,"}, {"sha": "b17671163c7ad946606b42f131de54e94df227b8", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -231,3 +231,8 @@ LIBGCCJIT_ABI_17 {\n   global:\n     gcc_jit_lvalue_set_tls_model;\n } LIBGCCJIT_ABI_16;\n+\n+LIBGCCJIT_ABI_18 {\n+  global:\n+    gcc_jit_lvalue_set_link_section;\n+} LIBGCCJIT_ABI_17;"}, {"sha": "3e8ccbca60ea3e9219aec5644b6fea806667bf00", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -209,6 +209,9 @@\n #undef create_code\n #undef verify_code\n \n+/* test-link-section-assembler.c: This can't be in the testcases array as it\n+   doesn't have a verify_code implementation.  */\n+\n /* test-linked-list.c */\n #define create_code create_code_linked_list\n #define verify_code verify_code_linked_list"}, {"sha": "3568dbb9d6334aed3c49d750d335e1034d899c72", "filename": "gcc/testsuite/jit.dg/jit.exp", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -864,6 +864,39 @@ proc jit-verify-assembler { args } {\n     jit-run-executable ${executable_from_asm} ${dg-output-text}\n }\n \n+# Assuming that a .s file has been written out named\n+# OUTPUT_FILENAME, check that the argument matches the\n+# output file.\n+# For use by the test-link-section-assembler.c testcase.\n+proc jit-verify-assembler-output { args } {\n+    verbose \"jit-verify-assembler: $args\"\n+\n+    set dg-output-text [lindex $args 0]\n+    verbose \"dg-output-text: ${dg-output-text}\"\n+\n+    upvar 2 name name\n+    verbose \"name: $name\"\n+\n+    upvar 2 prog prog\n+    verbose \"prog: $prog\"\n+    set asm_filename [jit-get-output-filename $prog]\n+    verbose \"  asm_filename: ${asm_filename}\"\n+\n+    # Read the assembly file.\n+    set f [open $asm_filename r]\n+    set content [read $f]\n+    close $f\n+\n+    # Verify that the assembly matches the regex.\n+    if { ![regexp ${dg-output-text} $content] } {\n+\tfail \"${asm_filename} output pattern test, is ${content}, should match ${dg-output-text}\"\n+\tverbose \"Failed test for output pattern ${dg-output-text}\" 3\n+    } else {\n+\tpass \"${asm_filename} output pattern test, ${dg-output-text}\"\n+\tverbose \"Passed test for output pattern ${dg-output-text}\" 3\n+    }\n+\n+}\n # Assuming that a .o file has been written out named\n # OUTPUT_FILENAME, invoke the driver to try to turn it into\n # an executable, and try to run the result."}, {"sha": "a90b00e9a823162ea22376039af9d3c35a4c0b68", "filename": "gcc/testsuite/jit.dg/test-link-section-assembler.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Ftestsuite%2Fjit.dg%2Ftest-link-section-assembler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Ftestsuite%2Fjit.dg%2Ftest-link-section-assembler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-link-section-assembler.c?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -0,0 +1,37 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#define TEST_COMPILING_TO_FILE\n+#define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_ASSEMBLER\n+#define OUTPUT_FILENAME  \"output-of-test-link-section-assembler.c.s\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     int foo __attribute__((section(\".section\")));\n+  */\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_lvalue *foo =\n+    gcc_jit_context_new_global (\n+      ctxt, NULL, GCC_JIT_GLOBAL_EXPORTED, int_type, \"foo\");\n+  gcc_jit_lvalue_set_link_section(foo, \".my_section\");\n+\n+  gcc_jit_function *func_main =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  int_type,\n+\t\t\t\t  \"main\",\n+\t\t\t\t  0, NULL,\n+\t\t\t\t  0);\n+  gcc_jit_rvalue *zero = gcc_jit_context_zero (ctxt, int_type);\n+  gcc_jit_block *block = gcc_jit_function_new_block (func_main, NULL);\n+  gcc_jit_block_end_with_return (block, NULL, zero);\n+}\n+\n+/* { dg-final { jit-verify-output-file-was-created \"\" } } */\n+/* { dg-final { jit-verify-assembler-output \".section\t.my_section\" } } */"}]}