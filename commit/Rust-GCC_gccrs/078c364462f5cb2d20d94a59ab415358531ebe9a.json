{"sha": "078c364462f5cb2d20d94a59ab415358531ebe9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4YzM2NDQ2MmY1Y2IyZDIwZDk0YTU5YWI0MTUzNTg1MzFlYmU5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-10T15:20:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-10T15:20:27Z"}, "message": "tree-inline.c (delete_unreachable_blocks_update_callgraph): Declare.\n\n\t* tree-inline.c (delete_unreachable_blocks_update_callgraph): Declare.\n\t(estimate_move_cost): Assert that it does not get called for VOID_TYPE_P.\n\t(estimate_num_insns): Skip VOID types in argument handling.\n\t(optimize_inline_calls): Delete unreachable blocks and verify that\n\tcallgraph is valid.\n\nFrom-SVN: r147344", "tree": {"sha": "61b85b391f0c78ef701455d729295c995e219fbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61b85b391f0c78ef701455d729295c995e219fbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/078c364462f5cb2d20d94a59ab415358531ebe9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078c364462f5cb2d20d94a59ab415358531ebe9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078c364462f5cb2d20d94a59ab415358531ebe9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078c364462f5cb2d20d94a59ab415358531ebe9a/comments", "author": null, "committer": null, "parents": [{"sha": "ea5783ee951110121aa7746e1c54749640f16351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5783ee951110121aa7746e1c54749640f16351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea5783ee951110121aa7746e1c54749640f16351"}], "stats": {"total": 27, "additions": 23, "deletions": 4}, "files": [{"sha": "23022ff0c613ffac17d5322d5a5e8a1575a81b5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078c364462f5cb2d20d94a59ab415358531ebe9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078c364462f5cb2d20d94a59ab415358531ebe9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=078c364462f5cb2d20d94a59ab415358531ebe9a", "patch": "@@ -1,3 +1,11 @@\n+2009-05-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-inline.c (delete_unreachable_blocks_update_callgraph): Declare.\n+\t(estimate_move_cost): Assert that it does not get called for VOID_TYPE_P.\n+\t(estimate_num_insns): Skip VOID types in argument handling.\n+\t(optimize_inline_calls): Delete unreachable blocks and verify that\n+\tcallgraph is valid.\n+\n 2009-05-10  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphbuild.c (record_reference): Use cgraph_mark_address_taken_node."}, {"sha": "752766b6c7b67abf7bfabf4bae971484c5549fd0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078c364462f5cb2d20d94a59ab415358531ebe9a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078c364462f5cb2d20d94a59ab415358531ebe9a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=078c364462f5cb2d20d94a59ab415358531ebe9a", "patch": "@@ -132,6 +132,7 @@ static tree copy_decl_to_var (tree, copy_body_data *);\n static tree copy_result_decl_to_var (tree, copy_body_data *);\n static tree copy_decl_maybe_to_var (tree, copy_body_data *);\n static gimple remap_gimple_stmt (gimple, copy_body_data *);\n+static bool delete_unreachable_blocks_update_callgraph (copy_body_data *id);\n \n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n    that the trees should be variables, it is used for more than that.  */\n@@ -2768,6 +2769,8 @@ estimate_move_cost (tree type)\n {\n   HOST_WIDE_INT size;\n \n+  gcc_assert (!VOID_TYPE_P (type));\n+\n   size = int_size_in_bytes (type);\n \n   if (size < 0 || size > MOVE_MAX_PIECES * MOVE_RATIO (!optimize_size))\n@@ -3013,20 +3016,24 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \t  {\n \t    tree arg;\n \t    for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n-\t      cost += estimate_move_cost (TREE_TYPE (arg));\n+\t      if (!VOID_TYPE_P (TREE_TYPE (arg)))\n+\t        cost += estimate_move_cost (TREE_TYPE (arg));\n \t  }\n \telse if (funtype && prototype_p (funtype))\n \t  {\n \t    tree t;\n-\t    for (t = TYPE_ARG_TYPES (funtype); t; t = TREE_CHAIN (t))\n-\t      cost += estimate_move_cost (TREE_VALUE (t));\n+\t    for (t = TYPE_ARG_TYPES (funtype); t && t != void_list_node;\n+\t    \t t = TREE_CHAIN (t))\n+\t      if (!VOID_TYPE_P (TREE_VALUE (t)))\n+\t        cost += estimate_move_cost (TREE_VALUE (t));\n \t  }\n \telse\n \t  {\n \t    for (i = 0; i < gimple_call_num_args (stmt); i++)\n \t      {\n \t\ttree arg = gimple_call_arg (stmt, i);\n-\t\tcost += estimate_move_cost (TREE_TYPE (arg));\n+\t        if (!VOID_TYPE_P (TREE_TYPE (arg)))\n+\t\t  cost += estimate_move_cost (TREE_TYPE (arg));\n \t      }\n \t  }\n \n@@ -3657,6 +3664,10 @@ optimize_inline_calls (tree fn)\n   number_blocks (fn);\n \n   fold_cond_expr_cond ();\n+  delete_unreachable_blocks_update_callgraph (&id);\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph_node (id.dst_node);\n+#endif\n \n   /* It would be nice to check SSA/CFG/statement consistency here, but it is\n      not possible yet - the IPA passes might make various functions to not"}]}