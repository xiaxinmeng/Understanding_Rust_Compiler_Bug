{"sha": "1a93a84b9e01d0dd5156be8d686e8666a6fc45a8", "node_id": "C_kwDOANBUbNoAKDFhOTNhODRiOWUwMWQwZGQ1MTU2YmU4ZDY4NmU4NjY2YTZmYzQ1YTg", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-26T22:59:20Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-26T22:59:20Z"}, "message": "libstdc++: Implement ranges::zip_transform_view from P2321R2\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (zip_view::_Iterator): Befriend\n\tzip_transform_view.\n\t(__detail::__range_iter_cat): Define.\n\t(zip_transform_view): Define.\n\t(zip_transform_view::_Iterator): Define.\n\t(zip_transform_view::_Sentinel): Define.\n\t(views::__detail::__can_zip_transform_view): Define.\n\t(views::_ZipTransform): Define.\n\t(views::zip_transform): Define.\n\t* testsuite/std/ranges/zip_transform/1.cc: New test.", "tree": {"sha": "469f7415092a86bbf9ac465f3fca540d98a2b82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/469f7415092a86bbf9ac465f3fca540d98a2b82f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8/comments", "author": null, "committer": null, "parents": [{"sha": "390f94eee1ae694901f896ac45bfb148f8126baa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390f94eee1ae694901f896ac45bfb148f8126baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390f94eee1ae694901f896ac45bfb148f8126baa"}], "stats": {"total": 449, "additions": 449, "deletions": 0}, "files": [{"sha": "d4e326ad9c6a130dd93fdb787e3aaeac9ab6efca", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=1a93a84b9e01d0dd5156be8d686e8666a6fc45a8", "patch": "@@ -4502,6 +4502,12 @@ namespace views::__adaptor\n \treturn input_iterator_tag{};\n     }\n \n+    template<copy_constructible _Fp, input_range... _Ws>\n+      requires (view<_Ws> && ...) && (sizeof...(_Ws) > 0) && is_object_v<_Fp>\n+\t&& regular_invocable<_Fp&, range_reference_t<_Ws>...>\n+\t&& std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Ws>...>>\n+      friend class zip_transform_view;\n+\n   public:\n     // iterator_category defined in __zip_view_iter_cat\n     using iterator_concept = decltype(_S_iter_concept());\n@@ -4781,6 +4787,341 @@ namespace views::__adaptor\n \n     inline constexpr _Zip zip;\n   }\n+\n+  namespace __detail\n+  {\n+    template<typename _Range, bool _Const>\n+      using __range_iter_cat\n+\t= typename iterator_traits<iterator_t<__maybe_const_t<_Const, _Range>>>::iterator_category;\n+  }\n+\n+  template<copy_constructible _Fp, input_range... _Vs>\n+    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && is_object_v<_Fp>\n+      && regular_invocable<_Fp&, range_reference_t<_Vs>...>\n+      && std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Vs>...>>\n+  class zip_transform_view : public view_interface<zip_transform_view<_Fp, _Vs...>>\n+  {\n+    [[no_unique_address]] __detail::__box<_Fp> _M_fun;\n+    zip_view<_Vs...> _M_zip;\n+\n+    using _InnerView = zip_view<_Vs...>;\n+\n+    template<bool _Const>\n+      using __ziperator = iterator_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n+\n+    template<bool _Const>\n+      using __zentinel = sentinel_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n+\n+    template<bool _Const>\n+      using _Base = __detail::__maybe_const_t<_Const, _InnerView>;\n+\n+    template<bool _Const>\n+      struct __iter_cat\n+      { };\n+\n+    template<bool _Const>\n+      requires forward_range<_Base<_Const>>\n+      struct __iter_cat<_Const>\n+      {\n+      private:\n+\tstatic auto\n+\t_S_iter_cat()\n+\t{\n+\t  using __detail::__maybe_const_t;\n+\t  using __detail::__range_iter_cat;\n+\t  using _Res = invoke_result_t<__maybe_const_t<_Const, _Fp>&,\n+\t\t\t\t       range_reference_t<__maybe_const_t<_Const, _Vs>>...>;\n+\t  if constexpr (!is_lvalue_reference_v<_Res>)\n+\t    return input_iterator_tag{};\n+\t  else if constexpr ((derived_from<__range_iter_cat<_Vs, _Const>,\n+\t\t\t\t\t   random_access_iterator_tag> && ...))\n+\t    return random_access_iterator_tag{};\n+\t  else if constexpr ((derived_from<__range_iter_cat<_Vs, _Const>,\n+\t\t\t\t\t   bidirectional_iterator_tag> && ...))\n+\t    return bidirectional_iterator_tag{};\n+\t  else if constexpr ((derived_from<__range_iter_cat<_Vs, _Const>,\n+\t\t\t\t\t   forward_iterator_tag> && ...))\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return input_iterator_tag{};\n+\t}\n+      public:\n+\tusing iterator_category = decltype(_S_iter_cat());\n+      };\n+\n+    template<bool> class _Iterator;\n+    template<bool> class _Sentinel;\n+\n+  public:\n+    zip_transform_view() = default;\n+\n+    constexpr explicit\n+    zip_transform_view(_Fp __fun, _Vs... __views)\n+      : _M_fun(std::move(__fun)), _M_zip(std::move(__views)...)\n+    { }\n+\n+    constexpr auto\n+    begin()\n+    { return _Iterator<false>(*this, _M_zip.begin()); }\n+\n+    constexpr auto\n+    begin() const\n+      requires range<const _InnerView>\n+\t&& regular_invocable<const _Fp&, range_reference_t<const _Vs>...>\n+    { return _Iterator<true>(*this, _M_zip.begin()); }\n+\n+    constexpr auto\n+    end()\n+    {\n+      if constexpr (common_range<_InnerView>)\n+\treturn _Iterator<false>(*this, _M_zip.end());\n+      else\n+\treturn _Sentinel<false>(_M_zip.end());\n+    }\n+\n+    constexpr auto\n+    end() const\n+      requires range<const _InnerView>\n+\t&& regular_invocable<const _Fp&, range_reference_t<const _Vs>...>\n+    {\n+      if constexpr (common_range<const _InnerView>)\n+\treturn _Iterator<true>(*this, _M_zip.end());\n+      else\n+\treturn _Sentinel<true>(_M_zip.end());\n+    }\n+\n+    constexpr auto\n+    size() requires sized_range<_InnerView>\n+    { return _M_zip.size(); }\n+\n+    constexpr auto\n+    size() const requires sized_range<const _InnerView>\n+    { return _M_zip.size(); }\n+  };\n+\n+  template<class _Fp, class... Rs>\n+    zip_transform_view(_Fp, Rs&&...) -> zip_transform_view<_Fp, views::all_t<Rs>...>;\n+\n+  template<copy_constructible _Fp, input_range... _Vs>\n+    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && is_object_v<_Fp>\n+      && regular_invocable<_Fp&, range_reference_t<_Vs>...>\n+      && std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Vs>...>>\n+  template<bool _Const>\n+  class zip_transform_view<_Fp, _Vs...>::_Iterator : public __iter_cat<_Const>\n+  {\n+    using _Parent = __detail::__maybe_const_t<_Const, zip_transform_view>;\n+\n+    _Parent* _M_parent = nullptr;\n+    __ziperator<_Const> _M_inner;\n+\n+    constexpr\n+    _Iterator(_Parent& __parent, __ziperator<_Const> __inner)\n+      : _M_parent(std::__addressof(__parent)), _M_inner(std::move(__inner))\n+    { }\n+\n+    friend class zip_transform_view;\n+\n+  public:\n+    // iterator_category defined in zip_transform_view::__iter_cat\n+    using iterator_concept = typename __ziperator<_Const>::iterator_concept;\n+    using value_type\n+      = remove_cvref_t<invoke_result_t<__detail::__maybe_const_t<_Const, _Fp>&,\n+\t\t\t\t       range_reference_t<__detail::__maybe_const_t<_Const, _Vs>>...>>;\n+    using difference_type = range_difference_t<_Base<_Const>>;\n+\n+    _Iterator() = default;\n+\n+    constexpr\n+    _Iterator(_Iterator<!_Const> __i)\n+      requires _Const && convertible_to<__ziperator<false>, __ziperator<_Const>>\n+      : _M_parent(__i._M_parent), _M_inner(std::move(__i._M_inner))\n+    { }\n+\n+    constexpr decltype(auto)\n+    operator*() const\n+    {\n+      return std::apply([&](const auto&... __iters) -> decltype(auto) {\n+        return std::__invoke(*_M_parent->_M_fun, *__iters...);\n+      }, _M_inner._M_current);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      ++_M_inner;\n+      return *this;\n+    }\n+\n+    constexpr void\n+    operator++(int)\n+    { ++*this; }\n+\n+    constexpr _Iterator\n+    operator++(int) requires forward_range<_Base<_Const>>\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--() requires bidirectional_range<_Base<_Const>>\n+    {\n+      --_M_inner;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int) requires bidirectional_range<_Base<_Const>>\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator+=(difference_type __x) requires random_access_range<_Base<_Const>>\n+    {\n+      _M_inner += __x;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator&\n+    operator-=(difference_type __x) requires random_access_range<_Base<_Const>>\n+    {\n+      _M_inner -= __x;\n+      return *this;\n+    }\n+\n+    constexpr decltype(auto)\n+    operator[](difference_type __n) const requires random_access_range<_Base<_Const>>\n+    {\n+      return std::apply([&]<typename... _Is>(const _Is&... __iters) -> decltype(auto) {\n+        return std::__invoke(*_M_parent->_M_fun, __iters[iter_difference_t<_Is>(__n)]...);\n+      }, _M_inner._M_current);\n+    }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+      requires equality_comparable<__ziperator<_Const>>\n+    { return __x._M_inner == __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator<(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base<_Const>>\n+    { return __x._M_inner < __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base<_Const>>\n+    { return __x._M_inner > __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator<=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base<_Const>>\n+    { return __x._M_inner <= __y._M_inner; }\n+\n+    friend constexpr bool\n+    operator>=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base<_Const>>\n+    { return __x._M_inner >= __y._M_inner; }\n+\n+    friend constexpr auto\n+    operator<=>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base<_Const>> && three_way_comparable<__ziperator<_Const>>\n+    { return __x._M_inner <=> __y._M_inner; }\n+\n+    friend constexpr _Iterator\n+    operator+(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base<_Const>>\n+    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n+\n+    friend constexpr _Iterator\n+    operator+(difference_type __n, const _Iterator& __i)\n+      requires random_access_range<_Base<_Const>>\n+    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n+\n+    friend constexpr _Iterator\n+    operator-(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base<_Const>>\n+    { return _Iterator(*__i._M_parent, __i._M_inner - __n); }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __x, const _Iterator& __y)\n+      requires sized_sentinel_for<__ziperator<_Const>, __ziperator<_Const>>\n+    { return __x._M_inner - __y._M_inner; }\n+  };\n+\n+  template<copy_constructible _Fp, input_range... _Vs>\n+    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && is_object_v<_Fp>\n+      && regular_invocable<_Fp&, range_reference_t<_Vs>...>\n+      && std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Vs>...>>\n+  template<bool _Const>\n+  class zip_transform_view<_Fp, _Vs...>::_Sentinel\n+  {\n+    __zentinel<_Const> _M_inner;\n+\n+    constexpr explicit\n+    _Sentinel(__zentinel<_Const> __inner)\n+      : _M_inner(__inner)\n+    { }\n+\n+    friend class zip_transform_view;\n+\n+  public:\n+    _Sentinel() = default;\n+\n+    constexpr\n+    _Sentinel(_Sentinel<!_Const> __i)\n+      requires _Const && convertible_to<__zentinel<false>, __zentinel<_Const>>\n+      : _M_inner(std::move(__i._M_inner))\n+    { }\n+\n+    template<bool OtherConst>\n+      requires sentinel_for<__zentinel<_Const>, __ziperator<OtherConst>>\n+    friend constexpr bool\n+    operator==(const _Iterator<OtherConst>& __x, const _Sentinel& __y)\n+    { return __x._M_inner == __y._M_inner; }\n+\n+    template<bool OtherConst>\n+      requires sized_sentinel_for<__zentinel<_Const>, __ziperator<OtherConst>>\n+    friend constexpr range_difference_t<__detail::__maybe_const_t<OtherConst, _InnerView>>\n+    operator-(const _Iterator<OtherConst>& __x, const _Sentinel& __y)\n+    { return __x._M_inner - __y._M_inner; }\n+\n+    template<bool OtherConst>\n+      requires sized_sentinel_for<__zentinel<_Const>, __ziperator<OtherConst>>\n+    friend constexpr range_difference_t<__detail::__maybe_const_t<OtherConst, _InnerView>>\n+    operator-(const _Sentinel& __x, const _Iterator<OtherConst>& __y)\n+    { return __x._M_inner - __y._M_inner; }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename _Fp, typename... _Ts>\n+\tconcept __can_zip_transform_view\n+\t  = requires { zip_transform_view(std::declval<_Fp>(), std::declval<_Ts>()...); };\n+    }\n+\n+    struct _ZipTransform\n+    {\n+      template<typename _Fp, typename... _Ts>\n+\trequires (sizeof...(_Ts) == 0) || __detail::__can_zip_transform_view<_Fp, _Ts...>\n+\t[[nodiscard]]\n+\tconstexpr auto\n+\toperator()(_Fp&& __f, _Ts&&... __ts) const\n+\t{\n+\t  if constexpr (sizeof...(_Ts) == 0)\n+\t    return views::empty<decay_t<invoke_result_t<_Fp>>>;\n+\t  else\n+\t    return zip_transform_view(std::forward<_Fp>(__f), std::forward<_Ts>(__ts)...);\n+\t}\n+    };\n+\n+    inline constexpr _ZipTransform zip_transform;\n+  }\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "5ea24c578a8b0771fe973b37c3bf9d29b0ae0198", "filename": "libstdc++-v3/testsuite/std/ranges/zip_transform/1.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fzip_transform%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a93a84b9e01d0dd5156be8d686e8666a6fc45a8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fzip_transform%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fzip_transform%2F1.cc?ref=1a93a84b9e01d0dd5156be8d686e8666a6fc45a8", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  static_assert(ranges::empty(views::zip_transform([] { return 0; })));\n+\n+  auto z1 = views::zip_transform(std::identity{},\n+\t\t\t\t std::array{1, 2, 3});\n+  VERIFY( ranges::equal(z1, (int[]){1, 2, 3}) );\n+  const auto i0 = z1.begin(), i1 = z1.begin() + 1;\n+  VERIFY( i0 + 1 - 1 == i0 );\n+  VERIFY( i0 < i1 );\n+  VERIFY( i1 < z1.end() );\n+  VERIFY( i1 - i0 == 1 );\n+  VERIFY( i0 - i1 == -1 );\n+  VERIFY( z1.end() - i1 == 2 );\n+  VERIFY( i1 - z1.end() == -2 );\n+  ranges::iter_swap(i0, i1);\n+  VERIFY( ranges::equal(std::move(z1), (int[]){2, 1, 3}) );\n+\n+  auto z2 = views::zip_transform(std::multiplies{},\n+\t\t\t\t std::array{-1, 2},\n+\t\t\t\t std::array{3, 4, 5});\n+  auto i2 = z2.begin();\n+  i2 += 1;\n+  i2 -= -1;\n+  VERIFY( i2 == z2.end() );\n+  VERIFY( ranges::size(z2) == 2 );\n+  VERIFY( ranges::size(std::as_const(z2)) == 2 );\n+  VERIFY( ranges::equal(z2, (int[]){-3, 8}) );\n+\n+  auto z3 = views::zip_transform([] (auto... xs) { return ranges::max({xs...}); },\n+\t\t\t\t std::array{1, 6, 7, 0, 0},\n+\t\t\t\t std::array{2, 5, 9},\n+\t\t\t\t std::array{3, 4, 8, 0});\n+  VERIFY( ranges::size(z3) == 3 );\n+  VERIFY( ranges::equal(z3, (int[]){3, 6, 9}) );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  using __gnu_test::test_input_range;\n+  using __gnu_test::test_forward_range;\n+  using __gnu_test::test_random_access_range;\n+\n+  using ty1 = ranges::zip_transform_view<std::plus<>,\n+\t\t\t\t\t views::all_t<test_forward_range<int>>,\n+\t\t\t\t\t views::all_t<test_random_access_range<int>>>;\n+  static_assert(ranges::forward_range<ty1>);\n+  static_assert(!ranges::random_access_range<ty1>);\n+  static_assert(!ranges::sized_range<ty1>);\n+\n+  using ty2 = ranges::zip_transform_view<decltype([](int, int, int) { return 0; }),\n+\t\t\t\t\t views::all_t<test_forward_range<int>>,\n+\t\t\t\t\t views::all_t<test_input_range<int>>,\n+\t\t\t\t\t views::all_t<test_forward_range<int>>>;\n+  static_assert(ranges::input_range<ty2>);\n+  static_assert(!ranges::forward_range<ty2>);\n+  static_assert(!ranges::sized_range<ty2>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  int u[] = {1, 2, 3, 4}, v[] = {4, 5, 6};\n+  auto z = views::zip_transform(std::plus{},\n+\t\t\t\tu | views::filter([](auto) { return true; }),\n+\t\t\t\tv);\n+  using ty = decltype(z);\n+  static_assert(ranges::forward_range<ty>);\n+  static_assert(!ranges::common_range<ty>);\n+  static_assert(!ranges::sized_range<ty>);\n+  VERIFY( z.begin() == z.begin() );\n+  VERIFY( z.begin() != z.end() );\n+  VERIFY( ranges::next(z.begin(), 3) == z.end() );\n+  auto it = z.begin();\n+  ++it;\n+  it++;\n+  it--;\n+  --it;\n+  VERIFY( it == z.begin() );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(test02());\n+  static_assert(test03());\n+}"}]}