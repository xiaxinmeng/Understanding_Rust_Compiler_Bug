{"sha": "78f2b7ce3aea49818ea97974cb41029f820d0a99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhmMmI3Y2UzYWVhNDk4MThlYTk3OTc0Y2I0MTAyOWY4MjBkMGE5OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T10:52:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T10:52:44Z"}, "message": "[multiple changes]\n\n2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb: copy-paste typo.\n\n2017-04-27  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pre_Post_In_Decl_Part):\n\tUse correct test to detect call in GNATprove mode instead of\n\tcompilation.\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb, a-cfdlli.ads (Formal_Model.M_Elements_In_Union):\n\tNew property function expressing that the element of a\n\tsequence are contained in the union of two sequences.\n\t(Formal_Model.M_Elements_Included): New property function\n\texpressing that the element of a sequence are another sequence.\n\t(Generic_Sorting): Use new property functions to state that\n\telements are preserved by Sort and Merge.\n\t* a-cofove.adb, a-cofove.ads (=): Generic parameter removed to\n\tallow the use of regular equality over elements in contracts.\n\t(Formal_Model): Ghost package containing model functions\n\tthat are used in subprogram contracts.\t(Capacity):\n\tOn unbounded containers, return the maximal capacity.\n\t(Current_To_Last): Removed, model functions should be used instead.\n\t(First_To_Previous): Removed, model functions should be used instead.\n\t(Append): Default parameter value replaced\n\tby new wrapper to allow more precise contracts.\n\t(Insert): Subprogram restored, it seems it was useful to users even if\n\tit is inefficient.\n\t(Delete): Subprogram restored, it seems it was useful to users even if\n\tit is inefficient.\n\t(Prepend): Subprogram restored, it seems it was useful to users even\n\tif it is inefficient.\n\t(Delete_First): Subprogram restored, it seems it\n\twas useful to users even if it is inefficient.\t(Delete_Last):\n\tDefault parameter value replaced by new wrapper to allow more\n\tprecise contracts.\n\t(Generic_Sorting.Merge): Subprogram restored.\n\t* a-cfinve.adb, a-cfinve.ads (=): Generic parameter removed to\n\tallow the use of regular equality over elements in contracts.\n\t(Formal_Model): Ghost package containing model functions\n\tthat are used in subprogram contracts.\t(Capacity):\n\tOn unbounded containers, return the maximal capacity.\n\t(Current_To_Last): Removed, model functions should be used\n\tinstead.\n\t(First_To_Previous): Removed, model functions should be used instead.\n\t(Append): Default parameter value replaced\n\tby new wrapper to allow more precise contracts.\n\t(Insert): Subprogram restored, it seems it was useful to users even if\n\tit is inefficient.\n\t(Delete): Subprogram restored, it seems it was useful to users even if\n\tit is inefficient.\n\t(Prepend): Subprogram restored, it seems it was useful to users even\n\tif it is inefficient.\n\t(Delete_First): Subprogram restored, it seems it\n\twas useful to users even if it is inefficient.\t(Delete_Last):\n\tDefault parameter value replaced by new wrapper to allow more\n\tprecise contracts.\n\t(Generic_Sorting.Merge): Subprogram restored.\n\t(Vector): Do not reuse formal vectors, as it is no longer possible\n\tto supply them with an equality function over elements.\n\n2017-04-27  Bob Duff  <duff@adacore.com>\n\n\t* g-dyntab.adb (Release): When allocating the new\n\ttable, use the correct slice of the old table to initialize it.\n\nFrom-SVN: r247316", "tree": {"sha": "1f8bb9b531cbc68db6e78832f5e9b70fbbf31cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f8bb9b531cbc68db6e78832f5e9b70fbbf31cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78f2b7ce3aea49818ea97974cb41029f820d0a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78f2b7ce3aea49818ea97974cb41029f820d0a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78f2b7ce3aea49818ea97974cb41029f820d0a99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78f2b7ce3aea49818ea97974cb41029f820d0a99/comments", "author": null, "committer": null, "parents": [{"sha": "02848684196a014f8a6cd3c55a32a91de989b0d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02848684196a014f8a6cd3c55a32a91de989b0d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02848684196a014f8a6cd3c55a32a91de989b0d6"}], "stats": {"total": 3984, "additions": 3642, "deletions": 342}, "files": [{"sha": "f06d94eff59b8acdfb1df8d3ddc6bed5b1edbeb1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -1,3 +1,71 @@\n+2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb: copy-paste typo.\n+\n+2017-04-27  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pre_Post_In_Decl_Part):\n+\tUse correct test to detect call in GNATprove mode instead of\n+\tcompilation.\n+\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cfdlli.ads (Formal_Model.M_Elements_In_Union):\n+\tNew property function expressing that the element of a\n+\tsequence are contained in the union of two sequences.\n+\t(Formal_Model.M_Elements_Included): New property function\n+\texpressing that the element of a sequence are another sequence.\n+\t(Generic_Sorting): Use new property functions to state that\n+\telements are preserved by Sort and Merge.\n+\t* a-cofove.adb, a-cofove.ads (=): Generic parameter removed to\n+\tallow the use of regular equality over elements in contracts.\n+\t(Formal_Model): Ghost package containing model functions\n+\tthat are used in subprogram contracts.\t(Capacity):\n+\tOn unbounded containers, return the maximal capacity.\n+\t(Current_To_Last): Removed, model functions should be used instead.\n+\t(First_To_Previous): Removed, model functions should be used instead.\n+\t(Append): Default parameter value replaced\n+\tby new wrapper to allow more precise contracts.\n+\t(Insert): Subprogram restored, it seems it was useful to users even if\n+\tit is inefficient.\n+\t(Delete): Subprogram restored, it seems it was useful to users even if\n+\tit is inefficient.\n+\t(Prepend): Subprogram restored, it seems it was useful to users even\n+\tif it is inefficient.\n+\t(Delete_First): Subprogram restored, it seems it\n+\twas useful to users even if it is inefficient.\t(Delete_Last):\n+\tDefault parameter value replaced by new wrapper to allow more\n+\tprecise contracts.\n+\t(Generic_Sorting.Merge): Subprogram restored.\n+\t* a-cfinve.adb, a-cfinve.ads (=): Generic parameter removed to\n+\tallow the use of regular equality over elements in contracts.\n+\t(Formal_Model): Ghost package containing model functions\n+\tthat are used in subprogram contracts.\t(Capacity):\n+\tOn unbounded containers, return the maximal capacity.\n+\t(Current_To_Last): Removed, model functions should be used\n+\tinstead.\n+\t(First_To_Previous): Removed, model functions should be used instead.\n+\t(Append): Default parameter value replaced\n+\tby new wrapper to allow more precise contracts.\n+\t(Insert): Subprogram restored, it seems it was useful to users even if\n+\tit is inefficient.\n+\t(Delete): Subprogram restored, it seems it was useful to users even if\n+\tit is inefficient.\n+\t(Prepend): Subprogram restored, it seems it was useful to users even\n+\tif it is inefficient.\n+\t(Delete_First): Subprogram restored, it seems it\n+\twas useful to users even if it is inefficient.\t(Delete_Last):\n+\tDefault parameter value replaced by new wrapper to allow more\n+\tprecise contracts.\n+\t(Generic_Sorting.Merge): Subprogram restored.\n+\t(Vector): Do not reuse formal vectors, as it is no longer possible\n+\tto supply them with an equality function over elements.\n+\n+2017-04-27  Bob Duff  <duff@adacore.com>\n+\n+\t* g-dyntab.adb (Release): When allocating the new\n+\ttable, use the correct slice of the old table to initialize it.\n+\n 2017-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* einfo.ads: Minor fixes in comments."}, {"sha": "6c9c0b0f93e50bf42fc6d718d488ef40e4dd0c2b", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 80, "deletions": 39, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -488,54 +488,70 @@ is\n       procedure Lift_Abstraction_Level (Container : List) is null;\n \n       -------------------------\n-      -- M_Elements_Reversed --\n+      -- M_Elements_In_Union --\n       -------------------------\n \n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n       is\n-         L : constant Count_Type := M.Length (Left);\n-\n       begin\n-         if L /= M.Length (Right) then\n-            return False;\n-         end if;\n+         for I in 1 .. M.Length (Container) loop\n+            declare\n+               Found : Boolean := False;\n+               J     : Count_Type := 0;\n \n-         for I in 1 .. L loop\n-            if Element (Left, I) /= Element (Right, L - I + 1)\n-            then\n-               return False;\n-            end if;\n+            begin\n+               while not Found and J < M.Length (Left) loop\n+                  J := J + 1;\n+                  if Element (Container, I) = Element (Left, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               J := 0;\n+\n+               while not Found and J < M.Length (Right) loop\n+                  J := J + 1;\n+                  if Element (Container, I) = Element (Right, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               if not Found then\n+                  return False;\n+               end if;\n+            end;\n          end loop;\n \n          return True;\n-      end M_Elements_Reversed;\n+      end M_Elements_In_Union;\n \n       -------------------------\n-      -- M_Elements_Shuffled --\n+      -- M_Elements_Included --\n       -------------------------\n \n-      function M_Elements_Shuffle\n-        (Left   : M.Sequence;\n-         Right  : M.Sequence;\n-         Fst    : Positive_Count_Type;\n-         Lst    : Count_Type;\n-         Offset : Count_Type'Base) return Boolean\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Positive_Count_Type := 1;\n+         L_Lst : Count_Type;\n+         Right : M.Sequence;\n+         R_Fst : Positive_Count_Type := 1;\n+         R_Lst : Count_Type) return Boolean\n       is\n       begin\n-         for I in Fst .. Lst loop\n+         for I in L_Fst .. L_Lst loop\n             declare\n                Found : Boolean := False;\n-               J     : Count_Type := Fst;\n+               J     : Count_Type := R_Fst - 1;\n \n             begin\n-               while not Found and J <= Lst loop\n-                  if Element (Left, I) = Element (Right, J + Offset) then\n+               while not Found and J < R_Lst loop\n+                  J := J + 1;\n+                  if Element (Left, I) = Element (Right, J) then\n                      Found := True;\n                   end if;\n-\n-                  J := J + 1;\n                end loop;\n \n                if not Found then\n@@ -545,7 +561,32 @@ is\n          end loop;\n \n          return True;\n-      end M_Elements_Shuffle;\n+      end M_Elements_Included;\n+\n+      -------------------------\n+      -- M_Elements_Reversed --\n+      -------------------------\n+\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      is\n+         L : constant Count_Type := M.Length (Left);\n+\n+      begin\n+         if L /= M.Length (Right) then\n+            return False;\n+         end if;\n+\n+         for I in 1 .. L loop\n+            if Element (Left, I) /= Element (Right, L - I + 1)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Reversed;\n \n       ------------------------\n       -- M_Elements_Swapted --\n@@ -892,7 +933,8 @@ is\n \n       begin\n          if Target'Address = Source'Address then\n-            return;\n+            raise Program_Error with\n+              \"Target and Source denote same container\";\n          end if;\n \n          LI := First (Target);\n@@ -1466,7 +1508,7 @@ is\n \n    begin\n       if CFirst = 0 then\n-         CFirst := Container.First;\n+         CFirst := Container.Last;\n       end if;\n \n       if Container.Length = 0 then\n@@ -1497,14 +1539,13 @@ is\n       SN : Node_Array renames Source.Nodes;\n \n    begin\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n+      if Target'Address = Source'Address then\n+         raise Program_Error with\n+           \"Target and Source denote same container\";\n       end if;\n \n-      if Target'Address = Source'Address\n-        or else Source.Length = 0\n-      then\n-         return;\n+      if Before.Node /= 0 then\n+         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n       end if;\n \n       pragma Assert (SN (Source.First).Prev = 0);\n@@ -1535,8 +1576,8 @@ is\n \n    begin\n       if Target'Address = Source'Address then\n-         Splice (Target, Before, Position);\n-         return;\n+         raise Program_Error with\n+           \"Target and Source denote same container\";\n       end if;\n \n       if Position.Node = 0 then"}, {"sha": "5c07c12b4be7bdd4d62addac6af77d1f45837cdb", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 120, "deletions": 60, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -81,25 +81,40 @@ is\n         (Left  : M.Sequence;\n          Right : M.Sequence) return Boolean renames M.\"<=\";\n \n-      function M_Elements_Shuffle\n-        (Left   : M.Sequence;\n-         Right  : M.Sequence;\n-         Fst    : Positive_Count_Type;\n-         Lst    : Count_Type;\n-         Offset : Count_Type'Base) return Boolean\n-      --  The slice from Fst to Lst in Left contains the same elements than the\n-      --  same slide shifted by Offset in Right\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n+      --  The elements of Container are contained in either Left or Right\n       with\n         Global => null,\n-        Pre    =>\n-          Lst <= M.Length (Left)\n-            and Offset in 1 - Fst .. M.Length (Right) - Lst,\n         Post   =>\n-          M_Elements_Shuffle'Result =\n-            (for all J in Fst + Offset .. Lst + Offset =>\n-              (for some I in Fst .. Lst =>\n+          M_Elements_In_Union'Result =\n+            (for all I in 1 .. M.Length (Container) =>\n+              (for some J in 1 .. M.Length (Left) =>\n+                Element (Container, I) = Element (Left, J))\n+              or (for some J in 1 .. M.Length (Right) =>\n+                    Element (Container, I) = Element (Right, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n+\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Positive_Count_Type := 1;\n+         L_Lst : Count_Type;\n+         Right : M.Sequence;\n+         R_Fst : Positive_Count_Type := 1;\n+         R_Lst : Count_Type) return Boolean\n+      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n+      --  in the slide from R_Fst to R_Lst in Right.\n+      with\n+        Global => null,\n+        Pre    => L_Lst <= M.Length (Left) and R_Lst <= M.Length (Right),\n+        Post   =>\n+          M_Elements_Included'Result =\n+            (for all I in L_Fst .. L_Lst =>\n+              (for some J in R_Fst .. R_Lst =>\n                 Element (Left, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Shuffle);\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n \n       function M_Elements_Reversed\n         (Left  : M.Sequence;\n@@ -242,7 +257,7 @@ is\n                      M.Get (M_Right, P.Get (P_Right, C))));\n \n       function Model (Container : List) return M.Sequence with\n-      --  The highlevel model of a list is a sequence of elements. Cursors are\n+      --  The high-level model of a list is a sequence of elements. Cursors are\n       --  not represented in this model.\n \n         Ghost,\n@@ -279,8 +294,8 @@ is\n         --  assume that we can access to the same elements by iterating over\n         --  positions or cursors.\n         --  This information is not generally useful except when switching from\n-        --  a lowlevel, cursor aware view of a container, to a highlevel\n-        --  position based view.\n+        --  a low-level cursor-aware view of a container to a high-level\n+        --  position-based view.\n \n         Ghost,\n         Global => null,\n@@ -466,6 +481,15 @@ is\n \n             --  Container contains Count times New_Item at the end\n \n+            and (if Count > 0 then\n+                   M.Constant_Range\n+                     (Container => Model (Container),\n+                      Fst       => Length (Container)'Old + 1,\n+                      Lst       => Length (Container),\n+                      Item      => New_Item))\n+\n+            --  Container contains Count times New_Item at the end\n+\n             and M.Constant_Range\n                   (Container => Model (Container),\n                    Fst       => Length (Container)'Old + 1,\n@@ -747,11 +771,12 @@ is\n \n          --  Container contains Count times New_Item at the end\n \n-         and M.Constant_Range\n-               (Container => Model (Container),\n-                Fst       => Length (Container)'Old + 1,\n-                Lst       => Length (Container),\n-                Item      => New_Item)\n+         and (if Count > 0 then\n+                M.Constant_Range\n+                  (Container => Model (Container),\n+                    Fst       => Length (Container)'Old + 1,\n+                    Lst       => Length (Container),\n+                    Item      => New_Item))\n \n          --  Count cursors have been inserted at the end of Container\n \n@@ -782,11 +807,11 @@ is\n          --  The elements located after Position are shifted by 1\n \n          and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => P.Get (Positions (Container)'Old, Position'Old) + 1,\n-                Lst    => Length (Container)'Old,\n-                Offset => -1)\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n+                Lst    => Length (Container),\n+                Offset => 1)\n \n          --  Position has been removed from Container\n \n@@ -840,12 +865,11 @@ is\n             --  Other elements are shifted by Count\n \n             and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    =>\n-                     P.Get (Positions (Container)'Old, Position'Old) + Count,\n-                   Lst    => Length (Container)'Old,\n-                   Offset => -Count)\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => P.Get (Positions (Container)'Old, Position'Old),\n+                   Lst    => Length (Container),\n+                   Offset => Count)\n \n             --  Count cursors have been removed from Container at Position\n \n@@ -864,11 +888,11 @@ is\n          --  The elements of Container are shifted by 1\n \n          and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => 2,\n-                Lst    => Length (Container)'Old,\n-                Offset => -1)\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => 1,\n+                Lst    => Length (Container),\n+                Offset => 1)\n \n          --  The first cursor of Container has been removed\n \n@@ -892,11 +916,11 @@ is\n             --  Elements of Container are shifted by Count\n \n             and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => Count + 1,\n-                   Lst    => Length (Container)'Old,\n-                   Offset => -Count)\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => 1,\n+                   Lst    => Length (Container),\n+                   Offset => Count)\n \n             --  The first Count cursors have been removed from Container\n \n@@ -957,7 +981,7 @@ is\n \n    procedure Reverse_Elements (Container : in out List) with\n      Global => null,\n-     Post   => M_Elements_Reversed (Model (Container'Old), Model (Container));\n+     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n \n    procedure Swap\n      (Container : in out List;\n@@ -1017,12 +1041,19 @@ is\n             --  The elements of Source are appended to target, the order is not\n             --  specified.\n \n-            and M_Elements_Shuffle\n+            and M_Elements_Included\n                   (Left   => Model (Source)'Old,\n+                   L_Lst  => Length (Source)'Old,\n                    Right  => Model (Target),\n-                   Fst    => 1,\n-                   Lst    => Length (Source)'Old,\n-                   Offset => Length (Target)'Old)\n+                   R_Fst  => Length (Target)'Old + 1,\n+                   R_Lst  => Length (Target))\n+\n+            and M_Elements_Included\n+                  (Left   => Model (Target),\n+                   L_Fst  => Length (Target)'Old + 1,\n+                   L_Lst  => Length (Target),\n+                   Right  => Model (Source)'Old,\n+                   R_Lst  => Length (Source)'Old)\n \n             --  Cursors have been inserted at the end of Target\n \n@@ -1045,12 +1076,22 @@ is\n             --  The elements of Source are inserted before Before, the order is\n             --  not specified.\n \n-          and M_Elements_Shuffle\n-                (Left   => Model (Source)'Old,\n-                 Right  => Model (Target),\n-                 Fst    => 1,\n-                 Lst    => Length (Source)'Old,\n-                 Offset => P.Get (Positions (Target)'Old, Before) - 1)\n+            and M_Elements_Included\n+                  (Left   => Model (Source)'Old,\n+                   L_Lst  => Length (Source)'Old,\n+                   Right  => Model (Target),\n+                   R_Fst  => P.Get (Positions (Target)'Old, Before),\n+                   R_Lst  =>\n+                     P.Get (Positions (Target)'Old, Before) - 1 +\n+                       Length (Source)'Old)\n+\n+            and M_Elements_Included\n+                  (Left   => Model (Target),\n+                   L_Fst  => P.Get (Positions (Target)'Old, Before),\n+                   L_Lst  => P.Get (Positions (Target)'Old, Before) - 1 +\n+                       Length (Source)'Old,\n+                   Right  => Model (Source)'Old,\n+                   R_Lst  => Length (Source)'Old)\n \n           --  Other elements are shifted by the length of Source\n \n@@ -1390,7 +1431,7 @@ is\n                     P.Get (Positions (Container), Find'Result) >=\n                     P.Get (Positions (Container), Position))\n \n-            --  It is the first occurence of Item in this slice\n+            --  It is the first occurrence of Item in this slice\n \n             and not M.Contains\n                       (Container => Model (Container),\n@@ -1445,7 +1486,7 @@ is\n                     P.Get (Positions (Container), Reverse_Find'Result) <=\n                     P.Get (Positions (Container), Position))\n \n-            --  It is the last occurence of Item in this slice\n+            --  It is the last occurrence of Item in this slice\n \n             and not M.Contains\n                       (Container => Model (Container),\n@@ -1489,7 +1530,7 @@ is\n         Post   =>\n           M_Elements_Sorted'Result =\n             (for all I in 1 .. M.Length (Container) =>\n-              (for all J in I + 1 .. M.Length (Container) =>\n+              (for all J in I .. M.Length (Container) =>\n                  Element (Container, I) = Element (Container, J)\n                    or Element (Container, I) < Element (Container, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n@@ -1502,7 +1543,15 @@ is\n         Global => null,\n         Post   =>\n           Length (Container) = Length (Container)'Old\n-            and M_Elements_Sorted (Model (Container));\n+            and M_Elements_Sorted (Model (Container))\n+            and M_Elements_Included (Left  => Model (Container)'Old,\n+                                     L_Lst => Length (Container),\n+                                     Right => Model (Container),\n+                                     R_Lst => Length (Container))\n+            and M_Elements_Included (Left  => Model (Container),\n+                                     L_Lst => Length (Container),\n+                                     Right => Model (Container)'Old,\n+                                     R_Lst => Length (Container));\n \n       procedure Merge (Target : in out List; Source : in out List) with\n       --  Target and Source should not be aliased\n@@ -1513,7 +1562,18 @@ is\n             and Length (Source) = 0\n             and (if M_Elements_Sorted (Model (Target)'Old)\n                    and M_Elements_Sorted (Model (Source)'Old)\n-                 then M_Elements_Sorted (Model (Target)));\n+                 then M_Elements_Sorted (Model (Target)))\n+            and M_Elements_Included (Left  => Model (Target)'Old,\n+                                     L_Lst => Length (Target)'Old,\n+                                     Right => Model (Target),\n+                                     R_Lst => Length (Target))\n+            and M_Elements_Included (Left  => Model (Source)'Old,\n+                                     L_Lst => Length (Source)'Old,\n+                                     Right => Model (Target),\n+                                     R_Lst => Length (Target))\n+            and M_Elements_In_Union (Model (Target),\n+                                     Model (Source)'Old,\n+                                     Model (Target)'Old);\n    end Generic_Sorting;\n \n private"}, {"sha": "8b29f5e549a4afa77850045e7cd53696b8af4157", "filename": "gcc/ada/a-cfinve.adb", "status": "modified", "additions": 1150, "deletions": 53, "changes": 1203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.adb?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2014-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,60 +25,164 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Containers.Generic_Array_Sort;\n+with Ada.Unchecked_Deallocation;\n+\n+with System; use type System.Address;\n+\n package body Ada.Containers.Formal_Indefinite_Vectors with\n   SPARK_Mode => Off\n is\n \n    function H (New_Item : Element_Type) return Holder renames To_Holder;\n    function E (Container : Holder) return Element_Type renames Get;\n \n+   Growth_Factor : constant := 2;\n+   --  When growing a container, multiply current capacity by this. Doubling\n+   --  leads to amortized linear-time copying.\n+\n+   type Int is range System.Min_Int .. System.Max_Int;\n+\n+   procedure Free is\n+      new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n+\n+   type Maximal_Array_Ptr is access all Elements_Array (Array_Index)\n+     with Storage_Size => 0;\n+   type Maximal_Array_Ptr_Const is access constant Elements_Array (Array_Index)\n+       with Storage_Size => 0;\n+\n+   function Elems (Container : in out Vector) return Maximal_Array_Ptr;\n+   function Elemsc\n+     (Container : Vector) return Maximal_Array_Ptr_Const;\n+   --  Returns a pointer to the Elements array currently in use -- either\n+   --  Container.Elements_Ptr or a pointer to Container.Elements. We work with\n+   --  pointers to a bogus array subtype that is constrained with the maximum\n+   --  possible bounds. This means that the pointer is a thin pointer. This is\n+   --  necessary because 'Unrestricted_Access doesn't work when it produces\n+   --  access-to-unconstrained and is returned from a function.\n+   --\n+   --  Note that this is dangerous: make sure calls to this use an indexed\n+   --  component or slice that is within the bounds 1 .. Length (Container).\n+\n+   function Get_Element\n+     (Container : Vector;\n+      Position  : Capacity_Range) return Element_Type;\n+\n+   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base;\n+\n+   function Current_Capacity (Container : Vector) return Capacity_Range;\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n    ---------\n    -- \"=\" --\n    ---------\n \n    function \"=\" (Left, Right : Vector) return Boolean is\n-      (Left.V = Right.V);\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      for J in 1 .. Length (Left) loop\n+         if Get_Element (Left, J) /= Get_Element (Right, J) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n \n    ------------\n    -- Append --\n    ------------\n \n    procedure Append (Container : in out Vector; New_Item : Vector) is\n    begin\n-      Append (Container.V, New_Item.V);\n+      if Is_Empty (New_Item) then\n+         return;\n+      end if;\n+\n+      if Container.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+      end if;\n+\n+      Insert (Container, Container.Last + 1, New_Item);\n    end Append;\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Element_Type)\n    is\n    begin\n-      Append (Container.V, H (New_Item));\n+      Append (Container, New_Item, 1);\n+   end Append;\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+      end if;\n+\n+      Insert (Container, Container.Last + 1, New_Item, Count);\n    end Append;\n \n    ------------\n    -- Assign --\n    ------------\n \n    procedure Assign (Target : in out Vector; Source : Vector) is\n+      LS : constant Capacity_Range := Length (Source);\n+\n    begin\n-      Assign (Target.V, Source.V);\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Bounded and then Target.Capacity < LS then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Clear (Target);\n+      Append (Target, Source);\n    end Assign;\n \n    --------------\n    -- Capacity --\n    --------------\n \n    function Capacity (Container : Vector) return Capacity_Range is\n-      (Capacity (Container.V));\n+   begin\n+      return (if Bounded then Container.Capacity\n+              else Capacity_Range'Last);\n+   end Capacity;\n \n    -----------\n    -- Clear --\n    -----------\n \n    procedure Clear (Container : in out Vector) is\n    begin\n-      Clear (Container.V);\n+      Container.Last := No_Index;\n+\n+      --  Free element, note that this is OK if Elements_Ptr is null\n+\n+      Free (Container.Elements_Ptr);\n    end Clear;\n \n    --------------\n@@ -89,7 +193,9 @@ is\n      (Container : Vector;\n       Item      : Element_Type) return Boolean\n    is\n-     (Contains (Container.V, H (Item)));\n+   begin\n+      return Find_Index (Container, Item) /= No_Index;\n+   end Contains;\n \n    ----------\n    -- Copy --\n@@ -99,19 +205,173 @@ is\n      (Source   : Vector;\n       Capacity : Capacity_Range := 0) return Vector\n    is\n-     ((if Capacity = 0 then Length (Source) else Capacity),\n-       V => Copy (Source.V, Capacity));\n+      LS : constant Capacity_Range := Length (Source);\n+      C  : Capacity_Range;\n \n-   ---------------------\n-   -- Current_To_Last --\n-   ---------------------\n+   begin\n+      if Capacity = 0 then\n+         C := LS;\n+      elsif Capacity >= LS then\n+         C := Capacity;\n+      else\n+         raise Capacity_Error;\n+      end if;\n \n-   function Current_To_Last\n-     (Container : Vector;\n-      Current   : Index_Type) return Vector is\n+      return Target : Vector (C) do\n+         Elems (Target) (1 .. LS) := Elemsc (Source) (1 .. LS);\n+         Target.Last := Source.Last;\n+      end return;\n+   end Copy;\n+\n+   ----------------------\n+   -- Current_Capacity --\n+   ----------------------\n+\n+   function Current_Capacity (Container : Vector) return Capacity_Range is\n+   begin\n+      return (if Container.Elements_Ptr = null\n+              then Container.Elements'Length\n+              else Container.Elements_Ptr.all'Length);\n+   end Current_Capacity;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index)\n+   is\n+   begin\n+      Delete (Container, Index, 1);\n+   end Delete;\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type)\n+   is\n+      Old_Last : constant Index_Type'Base := Container.Last;\n+      Old_Len  : constant Count_Type := Length (Container);\n+      New_Last : Index_Type'Base;\n+      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last\n+      Off      : Count_Type'Base;  -- Index expressed as offset from IT'First\n+\n+   begin\n+      --  Delete removes items from the vector, the number of which is the\n+      --  minimum of the specified Count and the items (if any) that exist from\n+      --  Index to Container.Last. There are no constraints on the specified\n+      --  value of Count (it can be larger than what's available at this\n+      --  position in the vector, for example), but there are constraints on\n+      --  the allowed values of the Index.\n+\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying which items\n+      --  should be deleted, so we must manually check. (That the user is\n+      --  allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n+      if Index < Index_Type'First then\n+         raise Constraint_Error with \"Index is out of range (too small)\";\n+      end if;\n+\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows the\n+      --  corner case of deleting no items from the back end of the vector to\n+      --  be treated as a no-op. (It is assumed that specifying an index value\n+      --  greater than Last + 1 indicates some deeper flaw in the caller's\n+      --  algorithm, so that case is treated as a proper error.)\n+\n+      if Index > Old_Last then\n+         if Index > Old_Last + 1 then\n+            raise Constraint_Error with \"Index is out of range (too large)\";\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  We first calculate what's available for deletion starting at\n+      --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n+      --  Count_Type'Base as the type for intermediate values. (See function\n+      --  Length for more information.)\n+\n+      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n+         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n+      else\n+         Count2 := Count_Type'Base (Old_Last - Index + 1);\n+      end if;\n+\n+      --  If more elements are requested (Count) for deletion than are\n+      --  available (Count2) for deletion beginning at Index, then everything\n+      --  from Index is deleted. There are no elements to slide down, and so\n+      --  all we need to do is set the value of Container.Last.\n+\n+      if Count >= Count2 then\n+         Container.Last := Index - 1;\n+         return;\n+      end if;\n+\n+      --  There are some elements that aren't being deleted (the requested\n+      --  count was less than the available count), so we must slide them down\n+      --  to Index. We first calculate the index values of the respective array\n+      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the\n+      --  type for intermediate calculations.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Off := Count_Type'Base (Index - Index_Type'First);\n+         New_Last := Old_Last - Index_Type'Base (Count);\n+      else\n+         Off := Count_Type'Base (Index) - Count_Type'Base (Index_Type'First);\n+         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n+      end if;\n+\n+      --  The array index values for each slice have already been determined,\n+      --  so we just slide down to Index the elements that weren't deleted.\n+\n+      declare\n+         EA  : Maximal_Array_Ptr renames Elems (Container);\n+         Idx : constant Count_Type := EA'First + Off;\n+      begin\n+         EA (Idx .. Old_Len - Count) := EA (Idx + Count .. Old_Len);\n+         Container.Last := New_Last;\n+      end;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out Vector)\n+   is\n+   begin\n+      Delete_First (Container, 1);\n+   end Delete_First;\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   is\n    begin\n-      return (Length (Container), Current_To_Last (Container.V, Current));\n-   end Current_To_Last;\n+      if Count = 0 then\n+         return;\n+\n+      elsif Count >= Length (Container) then\n+         Clear (Container);\n+         return;\n+\n+      else\n+         Delete (Container, Index_Type'First, Count);\n+      end if;\n+   end Delete_First;\n \n    -----------------\n    -- Delete_Last --\n@@ -121,7 +381,38 @@ is\n      (Container : in out Vector)\n    is\n    begin\n-      Delete_Last (Container.V);\n+      Delete_Last (Container, 1);\n+   end Delete_Last;\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  There is no restriction on how large Count can be when deleting\n+      --  items. If it is equal or greater than the current length, then this\n+      --  is equivalent to clearing the vector. (In particular, there's no need\n+      --  for us to actually calculate the new value for Last.)\n+\n+      --  If the requested count is less than the current length, then we must\n+      --  calculate the new value for Last. For the type we use the widest of\n+      --  Index_Type'Base and Count_Type'Base for the intermediate values of\n+      --  our calculation.  (See the comments in Length for more information.)\n+\n+      if Count >= Length (Container) then\n+         Container.Last := No_Index;\n+\n+      elsif Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := Container.Last - Index_Type'Base (Count);\n+\n+      else\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (Container.Last) - Count);\n+      end if;\n    end Delete_Last;\n \n    -------------\n@@ -130,8 +421,39 @@ is\n \n    function Element\n      (Container : Vector;\n-      Index     : Index_Type) return Element_Type is\n-     (E (Element (Container.V, Index)));\n+      Index     : Index_Type) return Element_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Capacity_Range := Capacity_Range (II);\n+      begin\n+         return Get_Element (Container, I);\n+      end;\n+   end Element;\n+\n+   --------------\n+   -- Elements --\n+   --------------\n+\n+   function Elems (Container : in out Vector) return Maximal_Array_Ptr is\n+   begin\n+      return (if Container.Elements_Ptr = null\n+              then Container.Elements'Unrestricted_Access\n+              else Container.Elements_Ptr.all'Unrestricted_Access);\n+   end Elems;\n+\n+   function Elemsc\n+     (Container : Vector) return Maximal_Array_Ptr_Const is\n+   begin\n+      return (if Container.Elements_Ptr = null\n+              then Container.Elements'Unrestricted_Access\n+              else Container.Elements_Ptr.all'Unrestricted_Access);\n+   end Elemsc;\n \n    ----------------\n    -- Find_Index --\n@@ -142,98 +464,728 @@ is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n-     (Find_Index (Container.V, H (Item), Index));\n+      K    : Capacity_Range;\n+      Last : constant Index_Type := Last_Index (Container);\n+\n+   begin\n+      K := Capacity_Range (Int (Index) - Int (No_Index));\n+      for Indx in Index .. Last loop\n+         if Get_Element (Container, K) = Item then\n+            return Indx;\n+         end if;\n+\n+         K := K + 1;\n+      end loop;\n+\n+      return No_Index;\n+   end Find_Index;\n \n    -------------------\n    -- First_Element --\n    -------------------\n \n    function First_Element (Container : Vector) return Element_Type is\n-      (E (First_Element (Container.V)));\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"Container is empty\";\n+      else\n+         return Get_Element (Container, 1);\n+      end if;\n+   end First_Element;\n \n    -----------------\n    -- First_Index --\n    -----------------\n \n    function First_Index (Container : Vector) return Index_Type is\n-      (First_Index (Container.V));\n+      pragma Unreferenced (Container);\n+   begin\n+      return Index_Type'First;\n+   end First_Index;\n \n-   -----------------------\n-   -- First_To_Previous --\n-   -----------------------\n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n \n-   function First_To_Previous\n-     (Container : Vector;\n-      Current   : Index_Type) return Vector is\n-   begin\n-      return (Length (Container), First_To_Previous (Container.V, Current));\n-   end First_To_Previous;\n+   package body Formal_Model is\n+\n+      -------------------------\n+      -- M_Elements_In_Union --\n+      -------------------------\n+\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n+      is\n+      begin\n+         for I in Index_Type'First .. M.Last (Container) loop\n+            declare\n+               Found : Boolean := False;\n+               J     : Extended_Index := Extended_Index'First;\n+\n+            begin\n+               while not Found and J < M.Last (Left) loop\n+                  J := J + 1;\n+                  if Element (Container, I) = Element (Left, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               J := Extended_Index'First;\n+\n+               while not Found and J < M.Last (Right) loop\n+                  J := J + 1;\n+                  if Element (Container, I) = Element (Right, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               if not Found then\n+                  return False;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_In_Union;\n+\n+      -------------------------\n+      -- M_Elements_Included --\n+      -------------------------\n+\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Index_Type := Index_Type'First;\n+         L_Lst : Extended_Index;\n+         Right : M.Sequence;\n+         R_Fst : Index_Type := Index_Type'First;\n+         R_Lst : Extended_Index) return Boolean\n+      is\n+      begin\n+         for I in L_Fst .. L_Lst loop\n+            declare\n+               Found : Boolean := False;\n+               J     : Extended_Index := R_Fst - 1;\n+\n+            begin\n+               while not Found and J < R_Lst loop\n+                  J := J + 1;\n+                  if Element (Left, I) = Element (Right, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               if not Found then\n+                  return False;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Included;\n+\n+      -------------------------\n+      -- M_Elements_Reversed --\n+      -------------------------\n+\n+      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean is\n+         L : constant Index_Type := M.Last (Left);\n+      begin\n+         if L /= M.Last (Right) then\n+            return False;\n+         end if;\n+\n+         for I in Index_Type'First .. L loop\n+            if Element (Left, I) /= Element (Right, L - I + 1)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Reversed;\n+\n+      ------------------------\n+      -- M_Elements_Swapted --\n+      ------------------------\n+\n+      function M_Elements_Swapped\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X, Y  : Index_Type) return Boolean\n+      is\n+      begin\n+         if M.Length (Left) /= M.Length (Right)\n+           or else Element (Left, X) /= Element (Right, Y)\n+           or else Element (Left, Y) /= Element (Right, X)\n+         then\n+            return False;\n+         end if;\n+\n+         for I in Index_Type'First .. M.Last (Left) loop\n+            if I /= X and then I /= Y\n+              and then Element (Left, I) /= Element (Right, I)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Swapped;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : Vector) return M.Sequence is\n+         R : M.Sequence;\n+      begin\n+         for Position in 1 .. Length (Container) loop\n+            R := M.Add (R, E (Elemsc (Container) (Position)));\n+         end loop;\n+         return R;\n+      end Model;\n+\n+   end Formal_Model;\n \n    ---------------------\n    -- Generic_Sorting --\n    ---------------------\n \n    package body Generic_Sorting with SPARK_Mode => Off is\n \n-      function \"<\" (X, Y : Holder) return Boolean is (E (X) < E (Y));\n-      package Def_Sorting is new Def.Generic_Sorting (\"<\");\n-      use Def_Sorting;\n-\n       ---------------\n       -- Is_Sorted --\n       ---------------\n \n       function Is_Sorted (Container : Vector) return Boolean is\n-         (Is_Sorted (Container.V));\n+         L : constant Capacity_Range := Length (Container);\n+      begin\n+         for J in 1 .. L - 1 loop\n+            if Get_Element (Container, J + 1) <\n+               Get_Element (Container, J)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------------------\n+      -- M_Elements_Sorted --\n+      -----------------------\n+\n+      function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n+      begin\n+         if M.Length (Container) = 0 then\n+            return True;\n+         end if;\n+\n+         declare\n+            E1 : Element_Type := Element (Container, Index_Type'First);\n+\n+         begin\n+            for I in Index_Type'First + 1 .. M.Last (Container) loop\n+               declare\n+                  E2 : constant Element_Type := Element (Container, I);\n+\n+               begin\n+                  if E2 < E1 then\n+                     return False;\n+                  end if;\n+\n+                  E1 := E2;\n+               end;\n+            end loop;\n+         end;\n+\n+         return True;\n+      end M_Elements_Sorted;\n \n       ----------\n       -- Sort --\n       ----------\n \n-      procedure Sort (Container : in out Vector) is\n+      procedure Sort (Container : in out Vector)\n+      is\n+         function \"<\" (Left : Holder; Right : Holder) return Boolean is\n+           (E (Left) < E (Right));\n+\n+         procedure Sort is\n+           new Generic_Array_Sort\n+             (Index_Type   => Array_Index,\n+              Element_Type => Holder,\n+              Array_Type   => Elements_Array,\n+              \"<\"          => \"<\");\n+\n+         Len : constant Capacity_Range := Length (Container);\n       begin\n-         Sort (Container.V);\n+         if Container.Last <= Index_Type'First then\n+            return;\n+         else\n+            Sort (Elems (Container) (1 .. Len));\n+         end if;\n       end Sort;\n \n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge (Target, Source : in out Vector) is\n+         I, J : Count_Type;\n+\n+      begin\n+         if Target'Address = Source'Address then\n+            raise Program_Error with\n+              \"Target and Source denote same container\";\n+         end if;\n+\n+         if Length (Source) = 0 then\n+            return;\n+         end if;\n+\n+         if Length (Target) = 0 then\n+            Move (Target => Target, Source => Source);\n+            return;\n+         end if;\n+\n+         I := Length (Target);\n+\n+         declare\n+            New_Length : constant Count_Type := I + Length (Source);\n+         begin\n+            if not Bounded and then\n+              Current_Capacity (Target) < Capacity_Range (New_Length)\n+            then\n+               Reserve_Capacity\n+                 (Target,\n+                  Capacity_Range'Max\n+                    (Current_Capacity (Target) * Growth_Factor,\n+                    Capacity_Range (New_Length)));\n+            end if;\n+\n+            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               Target.Last := No_Index + Index_Type'Base (New_Length);\n+\n+            else\n+               Target.Last :=\n+                 Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n+            end if;\n+         end;\n+\n+         declare\n+            TA : Maximal_Array_Ptr renames Elems (Target);\n+            SA : Maximal_Array_Ptr renames Elems (Source);\n+         begin\n+            J := Length (Target);\n+            while Length (Source) /= 0 loop\n+               if I = 0 then\n+                  TA (1 .. J) := SA (1 .. Length (Source));\n+                  Source.Last := No_Index;\n+                  exit;\n+               end if;\n+\n+               if E (SA (Length (Source))) < E (TA (I)) then\n+                  TA (J) := TA (I);\n+                  I := I - 1;\n+\n+               else\n+                  TA (J) := SA (Length (Source));\n+                  Source.Last := Source.Last - 1;\n+               end if;\n+\n+               J := J - 1;\n+            end loop;\n+         end;\n+      end Merge;\n+\n    end Generic_Sorting;\n \n+   -----------------\n+   -- Get_Element --\n+   -----------------\n+\n+   function Get_Element\n+     (Container : Vector;\n+      Position  : Capacity_Range) return Element_Type\n+   is\n+   begin\n+      return E (Elemsc (Container) (Position));\n+   end Get_Element;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n \n    function Has_Element\n-     (Container : Vector;\n-      Position  : Extended_Index) return Boolean\n+     (Container : Vector; Position : Extended_Index) return Boolean is\n+   begin\n+      return Position in First_Index (Container) .. Last_Index (Container);\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Insert (Container, Before, New_Item, 1);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+      J : Count_Type'Base;  -- scratch\n+\n+   begin\n+      --  Use Insert_Space to create the \"hole\" (the destination slice)\n+\n+      Insert_Space (Container, Before, Count);\n+\n+      J := To_Array_Index (Before);\n+\n+      Elems (Container) (J .. J - 1 + Count) := (others => H (New_Item));\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Vector)\n+   is\n+      N : constant Count_Type := Length (New_Item);\n+      B : Count_Type;  -- index Before converted to Count_Type\n+\n+   begin\n+      if Container'Address = New_Item'Address then\n+         raise Program_Error with\n+           \"Container and New_Item denote same container\";\n+      end if;\n+\n+      --  Use Insert_Space to create the \"hole\" (the destination slice) into\n+      --  which we copy the source items.\n+\n+      Insert_Space (Container, Before, Count => N);\n+\n+      if N = 0 then\n+         --  There's nothing else to do here (vetting of parameters was\n+         --  performed already in Insert_Space), so we simply return.\n+\n+         return;\n+      end if;\n+\n+      B := To_Array_Index (Before);\n+\n+      Elems (Container) (B .. B + N - 1) := Elemsc (New_Item) (1 .. N);\n+   end Insert;\n+\n+   ------------------\n+   -- Insert_Space --\n+   ------------------\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1)\n    is\n-     (Has_Element (Container.V, Position));\n+      Old_Length : constant Count_Type := Length (Container);\n+\n+      Max_Length : Count_Type'Base;  -- determined from range of Index_Type\n+      New_Length : Count_Type'Base;  -- sum of current length and Count\n+\n+      Index : Index_Type'Base;  -- scratch for intermediate values\n+      J     : Count_Type'Base;  -- scratch\n+\n+   begin\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying where the new\n+      --  items should be inserted, so we must manually check. (That the user\n+      --  is allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n+      if Before < Index_Type'First then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n+      end if;\n+\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows for the\n+      --  case of appending items to the back end of the vector. (It is assumed\n+      --  that specifying an index value greater than Last + 1 indicates some\n+      --  deeper flaw in the caller's algorithm, so that case is treated as a\n+      --  proper error.)\n+\n+      if Before > Container.Last\n+        and then Before - 1 > Container.Last\n+      then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      --  We treat inserting 0 items into the container as a no-op, so we\n+      --  simply return.\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the current length and the insertion\n+      --  count. Note that we cannot simply add these values, because of the\n+      --  possibility of overflow.\n+\n+      if Old_Length > Count_Type'Last - Count then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n+\n+      New_Length := Old_Length + Count;\n+\n+      --  The second constraint is that the new Last index value cannot exceed\n+      --  Index_Type'Last. In each branch below, we calculate the maximum\n+      --  length (computed from the range of values in Index_Type), and then\n+      --  compare the new length to the maximum length. If the new length is\n+      --  acceptable, then we compute the new last index from that.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n+         --  We have to handle the case when there might be more values in the\n+         --  range of Index_Type than in the range of Count_Type.\n+\n+         if Index_Type'First <= 0 then\n+\n+            --  We know that No_Index (the same as Index_Type'First - 1) is\n+            --  less than 0, so it is safe to compute the following sum without\n+            --  fear of overflow.\n+\n+            Index := No_Index + Index_Type'Base (Count_Type'Last);\n+\n+            if Index <= Index_Type'Last then\n+\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+\n+         else\n+            --  No_Index is equal or greater than 0, so we can safely compute\n+            --  the difference without fear of overflow (which we would have to\n+            --  worry about if No_Index were less than 0, but that case is\n+            --  handled above).\n+\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+\n+         --  We know that No_Index (the same as Index_Type'First - 1) is less\n+         --  than 0, so it is safe to compute the following sum without fear of\n+         --  overflow.\n+\n+         J := Count_Type'Base (No_Index) + Count_Type'Last;\n+\n+         if J <= Count_Type'Base (Index_Type'Last) then\n+\n+            --  We have determined that range of Index_Type has at least as\n+            --  many values as in Count_Type, so Count_Type'Last is the maximum\n+            --  number of items that are allowed.\n+\n+            Max_Length := Count_Type'Last;\n+\n+         else\n+            --  The range of Index_Type has fewer values than Count_Type does,\n+            --  so the maximum number of items is computed from the range of\n+            --  the Index_Type.\n+\n+            Max_Length :=\n+              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+         end if;\n+\n+      else\n+         --  No_Index is equal or greater than 0, so we can safely compute the\n+         --  difference without fear of overflow (which we would have to worry\n+         --  about if No_Index were less than 0, but that case is handled\n+         --  above).\n+\n+         Max_Length :=\n+           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+      end if;\n+\n+      --  We have just computed the maximum length (number of items). We must\n+      --  now compare the requested length to the maximum length, as we do not\n+      --  allow a vector expand beyond the maximum (because that would create\n+      --  an internal array with a last index value greater than\n+      --  Index_Type'Last, with no way to index those elements).\n+\n+      if New_Length > Max_Length then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      J := To_Array_Index (Before);\n+\n+      --  Increase the capacity of container if needed\n+\n+      if not Bounded and then\n+        Current_Capacity (Container) < Capacity_Range (New_Length)\n+      then\n+         Reserve_Capacity\n+           (Container,\n+            Capacity_Range'Max (Current_Capacity (Container) * Growth_Factor,\n+              Capacity_Range (New_Length)));\n+      end if;\n+\n+      declare\n+         EA : Maximal_Array_Ptr renames Elems (Container);\n+      begin\n+         if Before <= Container.Last then\n+\n+            --  The new items are being inserted before some existing\n+            --  elements, so we must slide the existing elements up to their\n+            --  new home.\n+\n+            EA (J + Count .. New_Length) := EA (J .. Old_Length);\n+         end if;\n+      end;\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := No_Index + Index_Type'Base (New_Length);\n+\n+      else\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n+      end if;\n+   end Insert_Space;\n \n    --------------\n    -- Is_Empty --\n    --------------\n \n    function Is_Empty (Container : Vector) return Boolean is\n-      (Is_Empty (Container.V));\n+   begin\n+      return Last_Index (Container) < Index_Type'First;\n+   end Is_Empty;\n \n    ------------------\n    -- Last_Element --\n    ------------------\n \n    function Last_Element (Container : Vector) return Element_Type is\n-      (E (Last_Element (Container.V)));\n+   begin\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"Container is empty\";\n+      else\n+         return Get_Element (Container, Length (Container));\n+      end if;\n+   end Last_Element;\n \n    ----------------\n    -- Last_Index --\n    ----------------\n \n    function Last_Index (Container : Vector) return Extended_Index is\n-      (Last_Index (Container.V));\n+   begin\n+      return Container.Last;\n+   end Last_Index;\n \n    ------------\n    -- Length --\n    ------------\n \n    function Length (Container : Vector) return Capacity_Range is\n-      (Length (Container.V));\n+      L : constant Int := Int (Container.Last);\n+      F : constant Int := Int (Index_Type'First);\n+      N : constant Int'Base := L - F + 1;\n+   begin\n+      return Capacity_Range (N);\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Vector;\n+      Source : in out Vector)\n+   is\n+      LS : constant Capacity_Range := Length (Source);\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Bounded and then Target.Capacity < LS then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Clear (Target);\n+      Append (Target, Source);\n+      Clear (Source);\n+   end Move;\n+\n+   ------------\n+   -- Prepend --\n+   ------------\n+\n+   procedure Prepend (Container : in out Vector; New_Item : Vector) is\n+   begin\n+      Insert (Container, Index_Type'First, New_Item);\n+   end Prepend;\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Prepend (Container, New_Item, 1);\n+   end Prepend;\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      Insert (Container, Index_Type'First, New_Item, Count);\n+   end Prepend;\n \n    ---------------------\n    -- Replace_Element --\n@@ -245,7 +1197,16 @@ is\n       New_Item  : Element_Type)\n    is\n    begin\n-      Replace_Element (Container.V, Index, H (New_Item));\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Capacity_Range := Capacity_Range (II);\n+      begin\n+         Elems (Container) (I) := H (New_Item);\n+      end;\n    end Replace_Element;\n \n    ----------------------\n@@ -257,7 +1218,23 @@ is\n       Capacity  : Capacity_Range)\n    is\n    begin\n-      Reserve_Capacity (Container.V, Capacity);\n+      if Bounded then\n+         if Capacity > Container.Capacity then\n+            raise Constraint_Error with \"Capacity is out of range\";\n+         end if;\n+      else\n+         if Capacity > Current_Capacity (Container) then\n+            declare\n+               New_Elements : constant Elements_Array_Ptr :=\n+                                new Elements_Array (1 .. Capacity);\n+               L            : constant Capacity_Range := Length (Container);\n+            begin\n+               New_Elements (1 .. L) := Elemsc (Container) (1 .. L);\n+               Free (Container.Elements_Ptr);\n+               Container.Elements_Ptr := New_Elements;\n+            end;\n+         end if;\n+      end if;\n    end Reserve_Capacity;\n \n    ----------------------\n@@ -266,7 +1243,30 @@ is\n \n    procedure Reverse_Elements (Container : in out Vector) is\n    begin\n-      Reverse_Elements (Container.V);\n+      if Length (Container) <= 1 then\n+         return;\n+      end if;\n+\n+      declare\n+         I, J : Capacity_Range;\n+         E    : Elements_Array renames\n+                  Elems (Container) (1 .. Length (Container));\n+\n+      begin\n+         I := 1;\n+         J := Length (Container);\n+         while I < J loop\n+            declare\n+               EI : constant Holder := E (I);\n+            begin\n+               E (I) := E (J);\n+               E (J) := EI;\n+            end;\n+\n+            I := I + 1;\n+            J := J - 1;\n+         end loop;\n+      end;\n    end Reverse_Elements;\n \n    ------------------------\n@@ -278,17 +1278,94 @@ is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n-     (Reverse_Find_Index (Container.V, H (Item), Index));\n+      Last : Index_Type'Base;\n+      K    : Capacity_Range;\n+\n+   begin\n+      if Index > Last_Index (Container) then\n+         Last := Last_Index (Container);\n+      else\n+         Last := Index;\n+      end if;\n+\n+      K := Capacity_Range (Int (Last) - Int (No_Index));\n+      for Indx in reverse Index_Type'First .. Last loop\n+         if Get_Element (Container, K) = Item then\n+            return Indx;\n+         end if;\n+\n+         K := K - 1;\n+      end loop;\n+\n+      return No_Index;\n+   end Reverse_Find_Index;\n \n    ----------\n    -- Swap --\n    ----------\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n-      Swap (Container.V, I, J);\n+      if I > Container.Last then\n+         raise Constraint_Error with \"I index is out of range\";\n+      end if;\n+\n+      if J > Container.Last then\n+         raise Constraint_Error with \"J index is out of range\";\n+      end if;\n+\n+      if I = J then\n+         return;\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (I) - Int (No_Index);\n+         JJ : constant Int'Base := Int (J) - Int (No_Index);\n+\n+         EI : Holder renames Elems (Container) (Capacity_Range (II));\n+         EJ : Holder renames Elems (Container) (Capacity_Range (JJ));\n+\n+         EI_Copy : constant Holder := EI;\n+\n+      begin\n+         EI := EJ;\n+         EJ := EI_Copy;\n+      end;\n    end Swap;\n \n+   --------------------\n+   -- To_Array_Index --\n+   --------------------\n+\n+   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base is\n+      Offset : Count_Type'Base;\n+\n+   begin\n+      --  We know that\n+      --    Index >= Index_Type'First\n+      --  hence we also know that\n+      --    Index - Index_Type'First >= 0\n+\n+      --  The issue is that even though 0 is guaranteed to be a value in\n+      --  the type Index_Type'Base, there's no guarantee that the difference\n+      --  is a value in that type. To prevent overflow we use the wider\n+      --  of Count_Type'Base and Index_Type'Base to perform intermediate\n+      --  calculations.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Offset := Count_Type'Base (Index - Index_Type'First);\n+\n+      else\n+         Offset := Count_Type'Base (Index) -\n+                     Count_Type'Base (Index_Type'First);\n+      end if;\n+\n+      --  The array index subtype for all container element arrays\n+      --  always starts with 1.\n+\n+      return 1 + Offset;\n+   end To_Array_Index;\n+\n    ---------------\n    -- To_Vector --\n    ---------------\n@@ -298,7 +1375,27 @@ is\n       Length   : Capacity_Range) return Vector\n    is\n    begin\n-      return (Length, To_Vector (H (New_Item), Length));\n+      if Length = 0 then\n+         return Empty_Vector;\n+      end if;\n+\n+      declare\n+         First       : constant Int := Int (Index_Type'First);\n+         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n+         Last        : Index_Type;\n+\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";  -- ???\n+         end if;\n+\n+         Last := Index_Type (Last_As_Int);\n+\n+         return (Capacity     => Length,\n+                 Last         => Last,\n+                 Elements_Ptr => <>,\n+                 Elements     => (others => H (New_Item)));\n+      end;\n    end To_Vector;\n \n end Ada.Containers.Formal_Indefinite_Vectors;"}, {"sha": "56aee851444d93f0e2f728350f287a426e910651", "filename": "gcc/ada/a-cfinve.ads", "status": "modified", "additions": 720, "deletions": 65, "changes": 785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2014-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2014-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -30,11 +30,10 @@\n ------------------------------------------------------------------------------\n \n --  Similar to Ada.Containers.Formal_Vectors. The main difference is that\n---  Element_Type may be indefinite (but not an unconstrained array). In\n---  addition, this is simplified by removing less-used functionality.\n+--  Element_Type may be indefinite (but not an unconstrained array).\n \n with Ada.Containers.Bounded_Holders;\n-with Ada.Containers.Formal_Vectors;\n+with Ada.Containers.Functional_Vectors;\n \n generic\n    type Index_Type is range <>;\n@@ -48,8 +47,6 @@ generic\n    --  responsibility of clients to calculate the maximum size of all types in\n    --  the class.\n \n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n    Bounded : Boolean := True;\n    --  If True, the containers are bounded; the initial capacity is the maximum\n    --  size, and heap allocation will be avoided. If False, the containers can\n@@ -58,7 +55,6 @@ generic\n package Ada.Containers.Formal_Indefinite_Vectors with\n   SPARK_Mode => On\n is\n-   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    subtype Extended_Index is Index_Type'Base\n@@ -71,163 +67,806 @@ is\n      Count_Type range 0 .. Count_Type (Index_Type'Last - Index_Type'First + 1);\n \n    type Vector (Capacity : Capacity_Range) is limited private with\n-     Default_Initial_Condition;\n+     Default_Initial_Condition => Is_Empty (Vector);\n+   --  In the bounded case, Capacity is the capacity of the container, which\n+   --  never changes. In the unbounded case, Capacity is the initial capacity\n+   --  of the container, and operations such as Reserve_Capacity and Append can\n+   --  increase the capacity. The capacity never shrinks, except in the case of\n+   --  Clear.\n+   --\n+   --  Note that all objects of type Vector are constrained, including in the\n+   --  unbounded case; you can't assign from one object to another if the\n+   --  Capacity is different.\n+\n+   function Length (Container : Vector) return Capacity_Range with\n+     Global => null,\n+     Post   => Length'Result <= Capacity (Container);\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+\n+      package M is new Ada.Containers.Functional_Vectors\n+        (Index_Type   => Index_Type,\n+         Element_Type => Element_Type);\n+\n+      function \"=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"=\";\n+\n+      function \"<\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<\";\n+\n+      function \"<=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<=\";\n+\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n+      --  The elements of Container are contained in either Left or Right\n+      with\n+        Global => null,\n+        Post   =>\n+          M_Elements_In_Union'Result =\n+            (for all I in Index_Type'First .. M.Last (Container) =>\n+              (for some J in Index_Type'First .. M.Last (Left) =>\n+                Element (Container, I) = Element (Left, J))\n+              or (for some J in Index_Type'First .. M.Last (Right) =>\n+                    Element (Container, I) = Element (Right, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n+\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Index_Type := Index_Type'First;\n+         L_Lst : Extended_Index;\n+         Right : M.Sequence;\n+         R_Fst : Index_Type := Index_Type'First;\n+         R_Lst : Extended_Index) return Boolean\n+      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n+      --  in the slide from R_Fst to R_Lst in Right.\n+      with\n+        Global => null,\n+        Pre    => L_Lst <= M.Last (Left) and R_Lst <= M.Last (Right),\n+        Post   =>\n+          M_Elements_Included'Result =\n+            (for all I in L_Fst .. L_Lst =>\n+              (for some J in R_Fst .. R_Lst =>\n+                Element (Left, I) = Element (Right, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n+\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      --  Right is Left in reverse order\n+      with\n+        Global => null,\n+        Post   =>\n+          M_Elements_Reversed'Result =\n+            (M.Length (Left) = M.Length (Right)\n+              and (for all I in Index_Type'First .. M.Last (Left) =>\n+                     Element (Left, I) =\n+                     Element (Right, M.Last (Left) - I + 1))\n+              and (for all I in Index_Type'First .. M.Last (Right) =>\n+                     Element (Right, I) =\n+                     Element (Left, M.Last (Left) - I + 1)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n+\n+      function M_Elements_Swapped\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X     : Index_Type;\n+         Y     : Index_Type) return Boolean\n+      --  Elements stored at X and Y are reversed in Left and Right\n+      with\n+        Global => null,\n+        Pre    => X <= M.Last (Left) and Y <= M.Last (Left),\n+        Post   =>\n+          M_Elements_Swapped'Result =\n+            (M.Length (Left) = M.Length (Right)\n+              and Element (Left, X) = Element (Right, Y)\n+              and Element (Left, Y) = Element (Right, X)\n+              and M.Equal_Except (Left, Right, X, Y));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n+\n+      function Model (Container : Vector) return M.Sequence with\n+      --  The high-level model of a vector is a sequence of elements. The\n+      --  sequence really is similar to the vector itself. However, it is not\n+      --  limited which allows usage of 'Old and 'Loop_Entry attributes.\n+\n+        Ghost,\n+        Global => null,\n+        Post   => M.Length (Model'Result) = Length (Container);\n+\n+      function Element\n+        (S : M.Sequence;\n+         I : Index_Type) return Element_Type renames M.Get;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  access an element in the model to Element.\n+   end Formal_Model;\n+   use Formal_Model;\n \n    function Empty_Vector return Vector with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Empty_Vector'Result) = 0;\n \n    function \"=\" (Left, Right : Vector) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n \n    function To_Vector\n      (New_Item : Element_Type;\n       Length   : Capacity_Range) return Vector\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Formal_Indefinite_Vectors.Length (To_Vector'Result) = Length\n+         and M.Constant_Range (Container => Model (To_Vector'Result),\n+                               Fst       => Index_Type'First,\n+                               Lst       => Last_Index (To_Vector'Result),\n+                               Item      => New_Item);\n \n    function Capacity (Container : Vector) return Capacity_Range with\n      Global => null,\n-     Post   => Capacity'Result >= Container.Capacity;\n+     Post   =>\n+       Capacity'Result = (if Bounded then Container.Capacity\n+                          else Capacity_Range'Last);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Capacity);\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n       Capacity  : Capacity_Range)\n    with\n      Global => null,\n-     Pre    => (if Bounded then Capacity <= Container.Capacity);\n-\n-   function Length (Container : Vector) return Capacity_Range with\n-     Global => null;\n+     Pre    => (if Bounded then Capacity <= Container.Capacity),\n+     Post   => Model (Container) = Model (Container)'Old;\n \n    function Is_Empty (Container : Vector) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n \n    procedure Clear (Container : in out Vector) with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Container) = 0;\n    --  Note that this reclaims storage in the unbounded case. You need to call\n    --  this before a container goes out of scope in order to avoid storage\n-   --  leaks.\n+   --  leaks. In addition, \"X := ...\" can leak unless you Clear(X) first.\n \n    procedure Assign (Target : in out Vector; Source : Vector) with\n      Global => null,\n-     Pre    => (if Bounded then Length (Source) <= Target.Capacity);\n+     Pre    => (if Bounded then Length (Source) <= Target.Capacity),\n+     Post   => Model (Target) = Model (Source);\n \n    function Copy\n      (Source   : Vector;\n       Capacity : Capacity_Range := 0) return Vector\n    with\n      Global => null,\n-     Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity));\n+     Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity)),\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and (if Capacity = 0 then Copy'Result.Capacity = Length (Source)\n+              else Copy'Result.Capacity = Capacity);\n+\n+   procedure Move (Target : in out Vector; Source : in out Vector)\n+   with\n+     Global => null,\n+     Pre    => (if Bounded then Length (Source) <= Capacity (Target)),\n+     Post   => Model (Target) = Model (Source)'Old and Length (Source) = 0;\n \n    function Element\n      (Container : Vector;\n       Index     : Index_Type) return Element_Type\n    with\n      Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   => Element'Result = Element (Model (Container), Index);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Index     : Index_Type;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old\n \n-   procedure Append\n+         --  Container now has New_Item at index Index\n+\n+         and Element (Model (Container), Index) = New_Item\n+\n+         --  All other elements are preserved\n+\n+         and M.Equal_Except\n+               (Left     => Model (Container)'Old,\n+                Right    => Model (Container),\n+                Position => Index);\n+\n+   procedure Insert\n      (Container : in out Vector;\n+      Before    : Extended_Index;\n       New_Item  : Vector)\n    with\n      Global => null,\n-     Pre    => (if Bounded\n-                then Length (Container) + Length (New_Item) <=\n-                                                       Container.Capacity);\n+     Pre    =>\n+       Length (Container) <= Capacity (Container) - Length (New_Item)\n+         and (Before in Index_Type'First .. Last_Index (Container)\n+              or Before - 1 = Last_Index (Container)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Length (New_Item)\n+\n+         --  Elements located before Before in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Before - 1)\n+\n+         --  Elements of New_Item are inserted at position Before\n+\n+         and (if Length (New_Item) > 0 then\n+                M.Range_Shifted\n+                  (Left   => Model (New_Item),\n+                    Right  => Model (Container),\n+                    Fst    => Index_Type'First,\n+                    Lst    => Last_Index (New_Item),\n+                    Offset => Count_Type (Before - Index_Type'First)))\n+\n+         --  Elements located after Before in Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Before,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Length (New_Item));\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type)\n+   with\n+     Global => null,\n+     Pre    =>\n+       Length (Container) < Capacity (Container)\n+         and then (Before in Index_Type'First .. Last_Index (Container) + 1),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Elements located before Before in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Before - 1)\n+\n+         --  Container now has New_Item at index Before\n+\n+         and Element (Model (Container), Before) = New_Item\n+\n+         --  Elements located after Before in Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Before,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    =>\n+       Length (Container) <= Capacity (Container) - Count\n+         and (Before in Index_Type'First .. Last_Index (Container)\n+              or Before - 1 = Last_Index (Container)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  Elements located before Before in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Before - 1)\n+\n+         --  New_Item is inserted Count times at position Before\n+\n+         and (if Count > 0 then\n+                M.Constant_Range\n+                  (Container => Model (Container),\n+                    Fst       => Before,\n+                    Lst       => Before + Index_Type'Base (Count - 1),\n+                    Item      => New_Item))\n+\n+         --  Elements located after Before in Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Before,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Count);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Vector)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Capacity (Container) - Length (New_Item),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Length (New_Item)\n+\n+         --  Elements of New_Item are inserted at the beginning of Container\n+\n+         and M.Range_Equal\n+               (Left  => Model (New_Item),\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Last_Index (New_Item))\n+\n+         --  Elements of Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Length (New_Item));\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) < Capacity (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Container now has New_Item at Index_Type'First\n+\n+         and Element (Model (Container), Index_Type'First) = New_Item\n+\n+         --  Elements of Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => 1);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Capacity (Container) - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  New_Item is inserted Count times at the beginning of Container\n+\n+         and M.Constant_Range\n+               (Container => Model (Container),\n+                Fst       => Index_Type'First,\n+                Lst       => Index_Type'First + Index_Type'Base (Count - 1),\n+                Item      => New_Item)\n+\n+         --  Elements of Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Count);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Vector)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) <= Capacity (Container) - Length (New_Item),\n+     Post           =>\n+       Length (Container) = Length (Container)'Old + Length (New_Item)\n+\n+         --  The elements of Container are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+\n+         --  Elements of New_Item are inserted at the end of Container\n+\n+         and (if Length (New_Item) > 0 then\n+                M.Range_Shifted\n+                 (Left   => Model (New_Item),\n+                   Right  => Model (Container),\n+                   Fst    => Index_Type'First,\n+                   Lst    => Last_Index (New_Item),\n+                   Offset =>\n+                     Count_Type\n+                       (Last_Index (Container)'Old - Index_Type'First + 1)));\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => (if Bounded\n-                then Length (Container) < Container.Capacity);\n+     Pre    => Length (Container) < Capacity (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Elements of Container are preserved\n+\n+         and Model (Container)'Old < Model (Container)\n+\n+         --  Container now has New_Item at the end of Container\n+\n+         and Element\n+               (Model (Container), Last_Index (Container)'Old + 1) = New_Item;\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Capacity (Container) - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  Elements of Container are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+\n+         --  New_Item is inserted Count times at the end of Container\n+\n+         and (if Count > 0 then\n+                M.Constant_Range\n+                  (Container => Model (Container),\n+                    Fst       => Last_Index (Container)'Old + 1,\n+                    Lst       =>\n+                      Last_Index (Container)'Old + Index_Type'Base (Count),\n+                    Item      => New_Item));\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index)\n+   with\n+     Global => null,\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Elements located before Index in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Index - 1)\n+\n+         --  Elements located after Index in Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => Index,\n+                Lst    => Last_Index (Container),\n+                Offset => 1);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Index in First_Index (Container) .. Last_Index (Container),\n+     Post           =>\n+       Length (Container) in\n+         Length (Container)'Old - Count .. Length (Container)'Old\n+\n+         --  The elements of Container located before Index are preserved.\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Index - 1),\n+\n+     Contract_Cases =>\n+\n+       --  All the elements after Position have been erased\n+\n+       (Length (Container) - Count <= Count_Type (Index - Index_Type'First) =>\n+          Length (Container) = Count_Type (Index - Index_Type'First),\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  Other elements are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => Index,\n+                   Lst    => Last_Index (Container),\n+                   Offset => Count));\n+\n+   procedure Delete_First\n+     (Container : in out Vector)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) > 0,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Elements of Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container),\n+                Offset => 1);\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  All the elements of Container have been erased\n+\n+       (Length (Container) <= Count => Length (Container) = 0,\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  Elements of Container are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => Index_Type'First,\n+                   Lst    => Last_Index (Container),\n+                   Offset => Count));\n \n    procedure Delete_Last\n      (Container : in out Vector)\n    with\n-     Global => null;\n+     Global => null,\n+     Pre    => Length (Container) > 0,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Elements of Container are preserved\n+\n+         and Model (Container) < Model (Container)'Old;\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  All the elements after Position have been erased\n+\n+       (Length (Container) <= Count => Length (Container) = 0,\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  The elements of Container are preserved\n+\n+            and Model (Container) <= Model (Container)'Old);\n \n    procedure Reverse_Elements (Container : in out Vector) with\n-     Global => null;\n+     Global => null,\n+     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) with\n      Global => null,\n      Pre    => I in First_Index (Container) .. Last_Index (Container)\n-      and then J in First_Index (Container) .. Last_Index (Container);\n+      and then J in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+       M_Elements_Swapped (Model (Container)'Old, Model (Container), I, J);\n \n    function First_Index (Container : Vector) return Index_Type with\n-     Global => null;\n+     Global => null,\n+     Post   => First_Index'Result = Index_Type'First;\n+   pragma Annotate (GNATprove, Inline_For_Proof, First_Index);\n \n    function First_Element (Container : Vector) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       First_Element'Result = Element (Model (Container), Index_Type'First);\n+   pragma Annotate (GNATprove, Inline_For_Proof, First_Element);\n \n    function Last_Index (Container : Vector) return Extended_Index with\n-     Global => null;\n+     Global => null,\n+     Post   => Last_Index'Result = M.Last (Model (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Last_Index);\n \n    function Last_Element (Container : Vector) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Last_Element'Result =\n+         Element (Model (Container), Last_Index (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Last_Element);\n \n    function Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  If Item is not is not contained in Container after Index, Find_Index\n+       --  returns No_Index.\n+\n+       (Index > Last_Index (Container)\n+        or else not M.Contains\n+                     (Container => Model (Container),\n+                      Fst       => Index,\n+                      Lst       => Last_Index (Container),\n+                      Item      => Item)\n+        =>\n+          Find_Index'Result = No_Index,\n+\n+        --  Otherwise, Find_Index returns a valid index greater than Index\n+\n+        others =>\n+           Find_Index'Result in Index .. Last_Index (Container)\n+\n+            --  The element at this index in Container is Item\n+\n+            and Element (Model (Container), Find_Index'Result) = Item\n+\n+            --  It is the first occurrence of Item after Index in Container\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       => Index,\n+                       Lst       => Find_Index'Result - 1,\n+                       Item      => Item));\n \n    function Reverse_Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  If Item is not is not contained in Container before Index,\n+       --  Reverse_Find_Index returns No_Index.\n+\n+       (not M.Contains\n+              (Container => Model (Container),\n+               Fst       => Index_Type'First,\n+               Lst       => (if Index <= Last_Index (Container) then Index\n+                             else Last_Index (Container)),\n+               Item      => Item)\n+        =>\n+          Reverse_Find_Index'Result = No_Index,\n+\n+        --  Otherwise, Reverse_Find_Index returns a valid index smaller than\n+        --  Index\n+\n+        others =>\n+           Reverse_Find_Index'Result in Index_Type'First .. Index\n+            and Reverse_Find_Index'Result <= Last_Index (Container)\n+\n+            --  The element at this index in Container is Item\n+\n+            and Element (Model (Container), Reverse_Find_Index'Result) = Item\n+\n+            --  It is the last occurrence of Item before Index in Container\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       => Reverse_Find_Index'Result + 1,\n+                       Lst       =>\n+                         (if Index <= Last_Index (Container) then Index\n+                          else Last_Index (Container)),\n+                       Item      => Item));\n \n    function Contains\n      (Container : Vector;\n       Item      : Element_Type) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Contains'Result = M.Contains (Container => Model (Container),\n+                                     Fst       => Index_Type'First,\n+                                     Lst       => Last_Index (Container),\n+                                     Item      => Item);\n \n    function Has_Element\n-     (Container : Vector; Position : Extended_Index) return Boolean with\n-     Global => null;\n+     (Container : Vector;\n+      Position  : Extended_Index) return Boolean\n+   with\n+     Global => null,\n+     Post   =>\n+       Has_Element'Result =\n+         (Position in Index_Type'First .. Last_Index (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting with SPARK_Mode is\n+      function M_Elements_Sorted (Container : M.Sequence) return Boolean with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          M_Elements_Sorted'Result =\n+            (for all I in Index_Type'First .. M.Last (Container) =>\n+              (for all J in I .. M.Last (Container) =>\n+                 Element (Container, I) = Element (Container, J)\n+                   or Element (Container, I) < Element (Container, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       function Is_Sorted (Container : Vector) return Boolean with\n-        Global => null;\n+        Global => null,\n+        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n \n       procedure Sort (Container : in out Vector) with\n-        Global => null;\n-\n+        Global => null,\n+        Post   =>\n+          Length (Container) = Length (Container)'Old\n+            and M_Elements_Sorted (Model (Container))\n+            and M_Elements_Included (Left  => Model (Container)'Old,\n+                                     L_Lst => Last_Index (Container),\n+                                     Right => Model (Container),\n+                                     R_Lst => Last_Index (Container))\n+            and M_Elements_Included (Left  => Model (Container),\n+                                     L_Lst => Last_Index (Container),\n+                                     Right => Model (Container)'Old,\n+                                     R_Lst => Last_Index (Container));\n+\n+      procedure Merge (Target : in out Vector; Source : in out Vector) with\n+      --  Target and Source should not be aliased\n+        Global => null,\n+        Pre    => Length (Source) <= Capacity (Target) - Length (Target),\n+        Post   =>\n+          Length (Target) = Length (Target)'Old + Length (Source)'Old\n+            and Length (Source) = 0\n+            and (if M_Elements_Sorted (Model (Target)'Old)\n+                   and M_Elements_Sorted (Model (Source)'Old)\n+                 then M_Elements_Sorted (Model (Target)))\n+            and M_Elements_Included (Left  => Model (Target)'Old,\n+                                     L_Lst => Last_Index (Target)'Old,\n+                                     Right => Model (Target),\n+                                     R_Lst => Last_Index (Target))\n+            and M_Elements_Included (Left  => Model (Source)'Old,\n+                                     L_Lst => Last_Index (Source)'Old,\n+                                     Right => Model (Target),\n+                                     R_Lst => Last_Index (Target))\n+            and M_Elements_In_Union (Model (Target),\n+                                     Model (Source)'Old,\n+                                     Model (Target)'Old);\n    end Generic_Sorting;\n \n-   function First_To_Previous\n-     (Container : Vector;\n-      Current : Index_Type) return Vector\n-   with\n-     Ghost,\n-     Global => null;\n-\n-   function Current_To_Last\n-     (Container : Vector;\n-      Current : Index_Type) return Vector\n-   with\n-     Ghost,\n-     Global => null;\n-\n private\n    pragma SPARK_Mode (Off);\n \n@@ -240,23 +879,39 @@ private\n    pragma Inline (Contains);\n \n    --  The implementation method is to instantiate Bounded_Holders to get a\n-   --  definite type for Element_Type, and then use that Holder type to\n-   --  instantiate Formal_Vectors. All the operations are just wrappers.\n+   --  definite type for Element_Type.\n \n    package Holders is new Bounded_Holders\n      (Element_Type, Max_Size_In_Storage_Elements, \"=\");\n    use Holders;\n \n-   package Def is new Formal_Vectors (Index_Type, Holder, \"=\", Bounded);\n-   use Def;\n+   subtype Array_Index is Capacity_Range range 1 .. Capacity_Range'Last;\n+   type Elements_Array is array (Array_Index range <>) of Holder;\n+   function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   --  ????Assert that Def subtypes have the same range\n+   type Elements_Array_Ptr is access all Elements_Array;\n \n    type Vector (Capacity : Capacity_Range) is limited record\n-      V : Def.Vector (Capacity);\n+      --  In the bounded case, the elements are stored in Elements. In the\n+      --  unbounded case, the elements are initially stored in Elements, until\n+      --  we run out of room, then we switch to Elements_Ptr.\n+      Last         : Extended_Index := No_Index;\n+      Elements_Ptr : Elements_Array_Ptr := null;\n+      Elements     : aliased Elements_Array (1 .. Capacity);\n    end record;\n \n+   --  The primary reason Vector is limited is that in the unbounded case, once\n+   --  Elements_Ptr is in use, assignment statements won't work. \"X := Y;\" will\n+   --  cause X and Y to share state; that is, X.Elements_Ptr = Y.Elements_Ptr,\n+   --  so for example \"Append (X, ...);\" will modify BOTH X and Y. That would\n+   --  allow SPARK to \"prove\" things that are false. We could fix that by\n+   --  making Vector a controlled type, and override Adjust to make a deep\n+   --  copy, but finalization is not allowed in SPARK.\n+   --\n+   --  Note that (unfortunately) this means that 'Old and 'Loop_Entry are not\n+   --  allowed on Vectors.\n+\n    function Empty_Vector return Vector is\n-     ((Capacity => 0, V => Def.Empty_Vector));\n+     ((Capacity => 0, others => <>));\n \n end Ada.Containers.Formal_Indefinite_Vectors;"}, {"sha": "d1f4b9ce61bcd0bcd3eff4b79023e5e920808c6b", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 807, "deletions": 56, "changes": 863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,6 @@ is\n    --  leads to amortized linear-time copying.\n \n    type Int is range System.Min_Int .. System.Max_Int;\n-   type UInt is mod System.Max_Binary_Modulus;\n \n    procedure Free is\n       new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n@@ -66,6 +65,15 @@ is\n      (Container : Vector;\n       Position  : Capacity_Range) return Element_Type;\n \n+   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base;\n+\n+   function Current_Capacity (Container : Vector) return Capacity_Range;\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n    ---------\n    -- \"=\" --\n    ---------\n@@ -95,34 +103,40 @@ is\n \n    procedure Append (Container : in out Vector; New_Item : Vector) is\n    begin\n-      for X in First_Index (New_Item) .. Last_Index (New_Item) loop\n-         Append (Container, Element (New_Item, X));\n-      end loop;\n+      if Is_Empty (New_Item) then\n+         return;\n+      end if;\n+\n+      if Container.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+      end if;\n+\n+      Insert (Container, Container.Last + 1, New_Item);\n    end Append;\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Element_Type)\n    is\n-      New_Length : constant UInt := UInt (Length (Container) + 1);\n    begin\n-      if not Bounded and then\n-        Capacity (Container) < Capacity_Range (New_Length)\n-      then\n-         Reserve_Capacity\n-           (Container,\n-            Capacity_Range'Max (Capacity (Container) * Growth_Factor,\n-                                Capacity_Range (New_Length)));\n+      Append (Container, New_Item, 1);\n+   end Append;\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      if Count = 0 then\n+         return;\n       end if;\n \n-      if Container.Last = Index_Type'Last then\n+      if Container.Last >= Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n-      --  TODO: should check whether length > max capacity (cnt_t'last) ???\n-\n-      Container.Last := Container.Last + 1;\n-      Elems (Container) (Length (Container)) := New_Item;\n+      Insert (Container, Container.Last + 1, New_Item, Count);\n    end Append;\n \n    ------------\n@@ -151,9 +165,8 @@ is\n \n    function Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return (if Container.Elements_Ptr = null\n-              then Container.Elements'Length\n-              else Container.Elements_Ptr.all'Length);\n+      return (if Bounded then Container.Capacity\n+              else Capacity_Range'Last);\n    end Capacity;\n \n    -----------\n@@ -207,22 +220,155 @@ is\n       end return;\n    end Copy;\n \n-   ---------------------\n-   -- Current_To_Last --\n-   ---------------------\n+   ----------------------\n+   -- Current_Capacity --\n+   ----------------------\n \n-   function Current_To_Last\n-     (Container : Vector;\n-      Current   : Index_Type) return Vector\n+   function Current_Capacity (Container : Vector) return Capacity_Range is\n+   begin\n+      return (if Container.Elements_Ptr = null\n+              then Container.Elements'Length\n+              else Container.Elements_Ptr.all'Length);\n+   end Current_Capacity;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index)\n    is\n    begin\n-      return Result : Vector (Count_Type (Container.Last - Current + 1))\n-      do\n-         for X in Current .. Container.Last loop\n-            Append (Result, Element (Container, X));\n-         end loop;\n-      end return;\n-   end Current_To_Last;\n+      Delete (Container, Index, 1);\n+   end Delete;\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type)\n+   is\n+      Old_Last : constant Index_Type'Base := Container.Last;\n+      Old_Len  : constant Count_Type := Length (Container);\n+      New_Last : Index_Type'Base;\n+      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last\n+      Off      : Count_Type'Base;  -- Index expressed as offset from IT'First\n+\n+   begin\n+      --  Delete removes items from the vector, the number of which is the\n+      --  minimum of the specified Count and the items (if any) that exist from\n+      --  Index to Container.Last. There are no constraints on the specified\n+      --  value of Count (it can be larger than what's available at this\n+      --  position in the vector, for example), but there are constraints on\n+      --  the allowed values of the Index.\n+\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying which items\n+      --  should be deleted, so we must manually check. (That the user is\n+      --  allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n+      if Index < Index_Type'First then\n+         raise Constraint_Error with \"Index is out of range (too small)\";\n+      end if;\n+\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows the\n+      --  corner case of deleting no items from the back end of the vector to\n+      --  be treated as a no-op. (It is assumed that specifying an index value\n+      --  greater than Last + 1 indicates some deeper flaw in the caller's\n+      --  algorithm, so that case is treated as a proper error.)\n+\n+      if Index > Old_Last then\n+         if Index > Old_Last + 1 then\n+            raise Constraint_Error with \"Index is out of range (too large)\";\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  We first calculate what's available for deletion starting at\n+      --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n+      --  Count_Type'Base as the type for intermediate values. (See function\n+      --  Length for more information.)\n+\n+      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n+         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n+      else\n+         Count2 := Count_Type'Base (Old_Last - Index + 1);\n+      end if;\n+\n+      --  If more elements are requested (Count) for deletion than are\n+      --  available (Count2) for deletion beginning at Index, then everything\n+      --  from Index is deleted. There are no elements to slide down, and so\n+      --  all we need to do is set the value of Container.Last.\n+\n+      if Count >= Count2 then\n+         Container.Last := Index - 1;\n+         return;\n+      end if;\n+\n+      --  There are some elements aren't being deleted (the requested count was\n+      --  less than the available count), so we must slide them down to\n+      --  Index. We first calculate the index values of the respective array\n+      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the\n+      --  type for intermediate calculations.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Off := Count_Type'Base (Index - Index_Type'First);\n+         New_Last := Old_Last - Index_Type'Base (Count);\n+      else\n+         Off := Count_Type'Base (Index) - Count_Type'Base (Index_Type'First);\n+         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n+      end if;\n+\n+      --  The array index values for each slice have already been determined,\n+      --  so we just slide down to Index the elements that weren't deleted.\n+\n+      declare\n+         EA  : Maximal_Array_Ptr renames Elems (Container);\n+         Idx : constant Count_Type := EA'First + Off;\n+      begin\n+         EA (Idx .. Old_Len - Count) := EA (Idx + Count .. Old_Len);\n+         Container.Last := New_Last;\n+      end;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out Vector)\n+   is\n+   begin\n+      Delete_First (Container, 1);\n+   end Delete_First;\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      if Count = 0 then\n+         return;\n+\n+      elsif Count >= Length (Container) then\n+         Clear (Container);\n+         return;\n+\n+      else\n+         Delete (Container, Index_Type'First, Count);\n+      end if;\n+   end Delete_First;\n \n    -----------------\n    -- Delete_Last --\n@@ -231,16 +377,38 @@ is\n    procedure Delete_Last\n      (Container : in out Vector)\n    is\n-      Count : constant Capacity_Range := 1;\n-      Index : Int'Base;\n+   begin\n+      Delete_Last (Container, 1);\n+   end Delete_Last;\n \n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   is\n    begin\n-      Index := Int'Base (Container.Last) - Int'Base (Count);\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  There is no restriction on how large Count can be when deleting\n+      --  items. If it is equal or greater than the current length, then this\n+      --  is equivalent to clearing the vector. (In particular, there's no need\n+      --  for us to actually calculate the new value for Last.)\n \n-      if Index < Index_Type'Pos (Index_Type'First) then\n+      --  If the requested count is less than the current length, then we must\n+      --  calculate the new value for Last. For the type we use the widest of\n+      --  Index_Type'Base and Count_Type'Base for the intermediate values of\n+      --  our calculation.  (See the comments in Length for more information.)\n+\n+      if Count >= Length (Container) then\n          Container.Last := No_Index;\n+\n+      elsif Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := Container.Last - Index_Type'Base (Count);\n+\n       else\n-         Container.Last := Index_Type (Index);\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (Container.Last) - Count);\n       end if;\n    end Delete_Last;\n \n@@ -332,23 +500,151 @@ is\n       return Index_Type'First;\n    end First_Index;\n \n-   -----------------------\n-   -- First_To_Previous --\n-   -----------------------\n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n \n-   function First_To_Previous\n-     (Container : Vector;\n-      Current   : Index_Type) return Vector\n-   is\n-   begin\n-      return Result : Vector\n-        (Count_Type (Current - First_Index (Container)))\n-      do\n-         for X in First_Index (Container) .. Current - 1 loop\n-            Append (Result, Element (Container, X));\n+   package body Formal_Model is\n+\n+      -------------------------\n+      -- M_Elements_In_Union --\n+      -------------------------\n+\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n+      is\n+      begin\n+         for I in Index_Type'First .. M.Last (Container) loop\n+            declare\n+               Found : Boolean := False;\n+               J     : Extended_Index := Extended_Index'First;\n+\n+            begin\n+               while not Found and J < M.Last (Left) loop\n+                  J := J + 1;\n+                  if Element (Container, I) = Element (Left, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               J := Extended_Index'First;\n+\n+               while not Found and J < M.Last (Right) loop\n+                  J := J + 1;\n+                  if Element (Container, I) = Element (Right, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               if not Found then\n+                  return False;\n+               end if;\n+            end;\n          end loop;\n-      end return;\n-   end First_To_Previous;\n+\n+         return True;\n+      end M_Elements_In_Union;\n+\n+      -------------------------\n+      -- M_Elements_Included --\n+      -------------------------\n+\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Index_Type := Index_Type'First;\n+         L_Lst : Extended_Index;\n+         Right : M.Sequence;\n+         R_Fst : Index_Type := Index_Type'First;\n+         R_Lst : Extended_Index) return Boolean\n+      is\n+      begin\n+         for I in L_Fst .. L_Lst loop\n+            declare\n+               Found : Boolean := False;\n+               J     : Extended_Index := R_Fst - 1;\n+\n+            begin\n+               while not Found and J < R_Lst loop\n+                  J := J + 1;\n+                  if Element (Left, I) = Element (Right, J) then\n+                     Found := True;\n+                  end if;\n+               end loop;\n+\n+               if not Found then\n+                  return False;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Included;\n+\n+      -------------------------\n+      -- M_Elements_Reversed --\n+      -------------------------\n+\n+      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean is\n+         L : constant Index_Type := M.Last (Left);\n+      begin\n+         if L /= M.Last (Right) then\n+            return False;\n+         end if;\n+\n+         for I in Index_Type'First .. L loop\n+            if Element (Left, I) /= Element (Right, L - I + 1)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Reversed;\n+\n+      ------------------------\n+      -- M_Elements_Swapted --\n+      ------------------------\n+\n+      function M_Elements_Swapped\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X, Y  : Index_Type) return Boolean\n+      is\n+      begin\n+         if M.Length (Left) /= M.Length (Right)\n+           or else Element (Left, X) /= Element (Right, Y)\n+           or else Element (Left, Y) /= Element (Right, X)\n+         then\n+            return False;\n+         end if;\n+\n+         for I in Index_Type'First .. M.Last (Left) loop\n+            if I /= X and then I /= Y\n+              and then Element (Left, I) /= Element (Right, I)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Swapped;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : Vector) return M.Sequence is\n+         R : M.Sequence;\n+      begin\n+         for Position in 1 .. Length (Container) loop\n+            R := M.Add (R, Elemsc (Container) (Position));\n+         end loop;\n+         return R;\n+      end Model;\n+\n+   end Formal_Model;\n \n    ---------------------\n    -- Generic_Sorting --\n@@ -374,6 +670,37 @@ is\n          return True;\n       end Is_Sorted;\n \n+      -----------------------\n+      -- M_Elements_Sorted --\n+      -----------------------\n+\n+      function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n+      begin\n+         if M.Length (Container) = 0 then\n+            return True;\n+         end if;\n+\n+         declare\n+            E1 : Element_Type := Element (Container, Index_Type'First);\n+\n+         begin\n+            for I in Index_Type'First + 1 .. M.Last (Container) loop\n+               declare\n+                  E2 : constant Element_Type := Element (Container, I);\n+\n+               begin\n+                  if E2 < E1 then\n+                     return False;\n+                  end if;\n+\n+                  E1 := E2;\n+               end;\n+            end loop;\n+         end;\n+\n+         return True;\n+      end M_Elements_Sorted;\n+\n       ----------\n       -- Sort --\n       ----------\n@@ -396,6 +723,78 @@ is\n          end if;\n       end Sort;\n \n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge (Target, Source : in out Vector) is\n+         I, J : Count_Type;\n+\n+      begin\n+         if Target'Address = Source'Address then\n+            raise Program_Error with\n+              \"Target and Source denote same container\";\n+         end if;\n+\n+         if Length (Source) = 0 then\n+            return;\n+         end if;\n+\n+         if Length (Target) = 0 then\n+            Move (Target => Target, Source => Source);\n+            return;\n+         end if;\n+\n+         I := Length (Target);\n+\n+         declare\n+            New_Length : constant Count_Type := I + Length (Source);\n+         begin\n+            if not Bounded and then\n+              Current_Capacity (Target) < Capacity_Range (New_Length)\n+            then\n+               Reserve_Capacity\n+                 (Target,\n+                  Capacity_Range'Max\n+                    (Current_Capacity (Target) * Growth_Factor,\n+                    Capacity_Range (New_Length)));\n+            end if;\n+\n+            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               Target.Last := No_Index + Index_Type'Base (New_Length);\n+\n+            else\n+               Target.Last :=\n+                 Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n+            end if;\n+         end;\n+\n+         declare\n+            TA : Maximal_Array_Ptr renames Elems (Target);\n+            SA : Maximal_Array_Ptr renames Elems (Source);\n+         begin\n+            J := Length (Target);\n+            while Length (Source) /= 0 loop\n+               if I = 0 then\n+                  TA (1 .. J) := SA (1 .. Length (Source));\n+                  Source.Last := No_Index;\n+                  exit;\n+               end if;\n+\n+               if SA (Length (Source)) < TA (I) then\n+                  TA (J) := TA (I);\n+                  I := I - 1;\n+\n+               else\n+                  TA (J) := SA (Length (Source));\n+                  Source.Last := Source.Last - 1;\n+               end if;\n+\n+               J := J - 1;\n+            end loop;\n+         end;\n+      end Merge;\n+\n    end Generic_Sorting;\n \n    -----------------\n@@ -420,6 +819,276 @@ is\n       return Position in First_Index (Container) .. Last_Index (Container);\n    end Has_Element;\n \n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Insert (Container, Before, New_Item, 1);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+      J : Count_Type'Base;  -- scratch\n+\n+   begin\n+      --  Use Insert_Space to create the \"hole\" (the destination slice)\n+\n+      Insert_Space (Container, Before, Count);\n+\n+      J := To_Array_Index (Before);\n+\n+      Elems (Container) (J .. J - 1 + Count) := (others => New_Item);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Vector)\n+   is\n+      N : constant Count_Type := Length (New_Item);\n+      B : Count_Type;  -- index Before converted to Count_Type\n+\n+   begin\n+      if Container'Address = New_Item'Address then\n+         raise Program_Error with\n+           \"Container and New_Item denote same container\";\n+      end if;\n+\n+      --  Use Insert_Space to create the \"hole\" (the destination slice) into\n+      --  which we copy the source items.\n+\n+      Insert_Space (Container, Before, Count => N);\n+\n+      if N = 0 then\n+         --  There's nothing else to do here (vetting of parameters was\n+         --  performed already in Insert_Space), so we simply return.\n+\n+         return;\n+      end if;\n+\n+      B := To_Array_Index (Before);\n+\n+      Elems (Container) (B .. B + N - 1) := Elemsc (New_Item) (1 .. N);\n+   end Insert;\n+\n+   ------------------\n+   -- Insert_Space --\n+   ------------------\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+      Old_Length : constant Count_Type := Length (Container);\n+\n+      Max_Length : Count_Type'Base;  -- determined from range of Index_Type\n+      New_Length : Count_Type'Base;  -- sum of current length and Count\n+\n+      Index : Index_Type'Base;  -- scratch for intermediate values\n+      J     : Count_Type'Base;  -- scratch\n+\n+   begin\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying where the new\n+      --  items should be inserted, so we must manually check. (That the user\n+      --  is allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n+      if Before < Index_Type'First then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n+      end if;\n+\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows for the\n+      --  case of appending items to the back end of the vector. (It is assumed\n+      --  that specifying an index value greater than Last + 1 indicates some\n+      --  deeper flaw in the caller's algorithm, so that case is treated as a\n+      --  proper error.)\n+\n+      if Before > Container.Last\n+        and then Before - 1 > Container.Last\n+      then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      --  We treat inserting 0 items into the container as a no-op, so we\n+      --  simply return.\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the current length and the insertion\n+      --  count. Note that we cannot simply add these values, because of the\n+      --  possibility of overflow.\n+\n+      if Old_Length > Count_Type'Last - Count then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n+\n+      New_Length := Old_Length + Count;\n+\n+      --  The second constraint is that the new Last index value cannot exceed\n+      --  Index_Type'Last. In each branch below, we calculate the maximum\n+      --  length (computed from the range of values in Index_Type), and then\n+      --  compare the new length to the maximum length. If the new length is\n+      --  acceptable, then we compute the new last index from that.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n+         --  We have to handle the case when there might be more values in the\n+         --  range of Index_Type than in the range of Count_Type.\n+\n+         if Index_Type'First <= 0 then\n+\n+            --  We know that No_Index (the same as Index_Type'First - 1) is\n+            --  less than 0, so it is safe to compute the following sum without\n+            --  fear of overflow.\n+\n+            Index := No_Index + Index_Type'Base (Count_Type'Last);\n+\n+            if Index <= Index_Type'Last then\n+\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+\n+         else\n+            --  No_Index is equal or greater than 0, so we can safely compute\n+            --  the difference without fear of overflow (which we would have to\n+            --  worry about if No_Index were less than 0, but that case is\n+            --  handled above).\n+\n+            if Index_Type'Last - No_Index >=\n+                 Count_Type'Pos (Count_Type'Last)\n+            then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+\n+         --  We know that No_Index (the same as Index_Type'First - 1) is less\n+         --  than 0, so it is safe to compute the following sum without fear of\n+         --  overflow.\n+\n+         J := Count_Type'Base (No_Index) + Count_Type'Last;\n+\n+         if J <= Count_Type'Base (Index_Type'Last) then\n+\n+            --  We have determined that range of Index_Type has at least as\n+            --  many values as in Count_Type, so Count_Type'Last is the maximum\n+            --  number of items that are allowed.\n+\n+            Max_Length := Count_Type'Last;\n+\n+         else\n+            --  The range of Index_Type has fewer values than Count_Type does,\n+            --  so the maximum number of items is computed from the range of\n+            --  the Index_Type.\n+\n+            Max_Length :=\n+              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+         end if;\n+\n+      else\n+         --  No_Index is equal or greater than 0, so we can safely compute the\n+         --  difference without fear of overflow (which we would have to worry\n+         --  about if No_Index were less than 0, but that case is handled\n+         --  above).\n+\n+         Max_Length :=\n+           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+      end if;\n+\n+      --  We have just computed the maximum length (number of items). We must\n+      --  now compare the requested length to the maximum length, as we do not\n+      --  allow a vector expand beyond the maximum (because that would create\n+      --  an internal array with a last index value greater than\n+      --  Index_Type'Last, with no way to index those elements).\n+\n+      if New_Length > Max_Length then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      J := To_Array_Index (Before);\n+\n+      --  Increase the capacity of container if needed\n+\n+      if not Bounded and then\n+        Current_Capacity (Container) < Capacity_Range (New_Length)\n+      then\n+         Reserve_Capacity\n+           (Container,\n+            Capacity_Range'Max (Current_Capacity (Container) * Growth_Factor,\n+              Capacity_Range (New_Length)));\n+      end if;\n+\n+      declare\n+         EA : Maximal_Array_Ptr renames Elems (Container);\n+      begin\n+         if Before <= Container.Last then\n+\n+            --  The new items are being inserted before some existing\n+            --  elements, so we must slide the existing elements up to their\n+            --  new home.\n+\n+            EA (J + Count .. New_Length) := EA (J .. Old_Length);\n+         end if;\n+      end;\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := No_Index + Index_Type'Base (New_Length);\n+\n+      else\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n+      end if;\n+   end Insert_Space;\n+\n    --------------\n    -- Is_Empty --\n    --------------\n@@ -456,13 +1125,62 @@ is\n    ------------\n \n    function Length (Container : Vector) return Capacity_Range is\n-      L : constant Int := Int (Last_Index (Container));\n+      L : constant Int := Int (Container.Last);\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n    begin\n       return Capacity_Range (N);\n    end Length;\n \n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Vector;\n+      Source : in out Vector)\n+   is\n+      LS : constant Capacity_Range := Length (Source);\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Bounded and then Target.Capacity < LS then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Clear (Target);\n+      Append (Target, Source);\n+      Clear (Source);\n+   end Move;\n+\n+   ------------\n+   -- Prepend --\n+   ------------\n+\n+   procedure Prepend (Container : in out Vector; New_Item : Vector) is\n+   begin\n+      Insert (Container, Index_Type'First, New_Item);\n+   end Prepend;\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Prepend (Container, New_Item, 1);\n+   end Prepend;\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n+   begin\n+      Insert (Container, Index_Type'First, New_Item, Count);\n+   end Prepend;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -499,7 +1217,7 @@ is\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n       else\n-         if Capacity > Formal_Vectors.Capacity (Container) then\n+         if Capacity > Formal_Vectors.Current_Capacity (Container) then\n             declare\n                New_Elements : constant Elements_Array_Ptr :=\n                                 new Elements_Array (1 .. Capacity);\n@@ -609,6 +1327,39 @@ is\n       end;\n    end Swap;\n \n+   --------------------\n+   -- To_Array_Index --\n+   --------------------\n+\n+   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base is\n+      Offset : Count_Type'Base;\n+\n+   begin\n+      --  We know that\n+      --    Index >= Index_Type'First\n+      --  hence we also know that\n+      --    Index - Index_Type'First >= 0\n+\n+      --  The issue is that even though 0 is guaranteed to be a value in\n+      --  the type Index_Type'Base, there's no guarantee that the difference\n+      --  is a value in that type. To prevent overflow we use the wider\n+      --  of Count_Type'Base and Index_Type'Base to perform intermediate\n+      --  calculations.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Offset := Count_Type'Base (Index - Index_Type'First);\n+\n+      else\n+         Offset := Count_Type'Base (Index) -\n+                     Count_Type'Base (Index_Type'First);\n+      end if;\n+\n+      --  The array index subtype for all container element arrays\n+      --  always starts with 1.\n+\n+      return 1 + Offset;\n+   end To_Array_Index;\n+\n    ---------------\n    -- To_Vector --\n    ---------------"}, {"sha": "c7a93dfd15ab99387214ed9bdf10a5d80c8cf015", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 683, "deletions": 60, "changes": 743, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,12 +35,12 @@\n --  unit compatible with SPARK 2014. Note that the API of this unit may be\n --  subject to incompatible changes as SPARK 2014 evolves.\n \n+with Ada.Containers.Functional_Vectors;\n+\n generic\n    type Index_Type is range <>;\n    type Element_Type is private;\n \n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n    Bounded : Boolean := True;\n    --  If True, the containers are bounded; the initial capacity is the maximum\n    --  size, and heap allocation will be avoided. If False, the containers can\n@@ -49,7 +49,6 @@ generic\n package Ada.Containers.Formal_Vectors with\n   SPARK_Mode\n is\n-   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    subtype Extended_Index is Index_Type'Base\n@@ -73,171 +72,795 @@ is\n    --  unbounded case; you can't assign from one object to another if the\n    --  Capacity is different.\n \n+   function Length (Container : Vector) return Capacity_Range with\n+     Global => null,\n+     Post   => Length'Result <= Capacity (Container);\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+\n+      package M is new Ada.Containers.Functional_Vectors\n+        (Index_Type   => Index_Type,\n+         Element_Type => Element_Type);\n+\n+      function \"=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"=\";\n+\n+      function \"<\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<\";\n+\n+      function \"<=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<=\";\n+\n+      function M_Elements_In_Union\n+        (Container : M.Sequence;\n+         Left      : M.Sequence;\n+         Right     : M.Sequence) return Boolean\n+      --  The elements of Container are contained in either Left or Right\n+      with\n+        Global => null,\n+        Post   =>\n+          M_Elements_In_Union'Result =\n+            (for all I in Index_Type'First .. M.Last (Container) =>\n+              (for some J in Index_Type'First .. M.Last (Left) =>\n+                Element (Container, I) = Element (Left, J))\n+              or (for some J in Index_Type'First .. M.Last (Right) =>\n+                    Element (Container, I) = Element (Right, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n+\n+      function M_Elements_Included\n+        (Left  : M.Sequence;\n+         L_Fst : Index_Type := Index_Type'First;\n+         L_Lst : Extended_Index;\n+         Right : M.Sequence;\n+         R_Fst : Index_Type := Index_Type'First;\n+         R_Lst : Extended_Index) return Boolean\n+      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n+      --  in the slide from R_Fst to R_Lst in Right.\n+      with\n+        Global => null,\n+        Pre    => L_Lst <= M.Last (Left) and R_Lst <= M.Last (Right),\n+        Post   =>\n+          M_Elements_Included'Result =\n+            (for all I in L_Fst .. L_Lst =>\n+              (for some J in R_Fst .. R_Lst =>\n+                Element (Left, I) = Element (Right, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n+\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      --  Right is Left in reverse order\n+      with\n+        Global => null,\n+        Post   =>\n+          M_Elements_Reversed'Result =\n+            (M.Length (Left) = M.Length (Right)\n+              and (for all I in Index_Type'First .. M.Last (Left) =>\n+                     Element (Left, I) =\n+                     Element (Right, M.Last (Left) - I + 1))\n+              and (for all I in Index_Type'First .. M.Last (Right) =>\n+                     Element (Right, I) =\n+                     Element (Left, M.Last (Left) - I + 1)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n+\n+      function M_Elements_Swapped\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X     : Index_Type;\n+         Y     : Index_Type) return Boolean\n+      --  Elements stored at X and Y are reversed in Left and Right\n+      with\n+        Global => null,\n+        Pre    => X <= M.Last (Left) and Y <= M.Last (Left),\n+        Post   =>\n+          M_Elements_Swapped'Result =\n+            (M.Length (Left) = M.Length (Right)\n+              and Element (Left, X) = Element (Right, Y)\n+              and Element (Left, Y) = Element (Right, X)\n+              and M.Equal_Except (Left, Right, X, Y));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n+\n+      function Model (Container : Vector) return M.Sequence with\n+      --  The high-level model of a vector is a sequence of elements. The\n+      --  sequence really is similar to the vector itself. However, it is not\n+      --  limited which allows usage of 'Old and 'Loop_Entry attributes.\n+\n+        Ghost,\n+        Global => null,\n+        Post   => M.Length (Model'Result) = Length (Container);\n+\n+      function Element\n+        (S : M.Sequence;\n+         I : Index_Type) return Element_Type renames M.Get;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  access an element in the model to Element.\n+   end Formal_Model;\n+   use Formal_Model;\n+\n    function Empty_Vector return Vector with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Empty_Vector'Result) = 0;\n \n    function \"=\" (Left, Right : Vector) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n \n    function To_Vector\n      (New_Item : Element_Type;\n       Length   : Capacity_Range) return Vector\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Formal_Vectors.Length (To_Vector'Result) = Length\n+         and M.Constant_Range (Container => Model (To_Vector'Result),\n+                               Fst       => Index_Type'First,\n+                               Lst       => Last_Index (To_Vector'Result),\n+                               Item      => New_Item);\n \n    function Capacity (Container : Vector) return Capacity_Range with\n      Global => null,\n-     Post => Capacity'Result >= Container.Capacity;\n+     Post   =>\n+       Capacity'Result = (if Bounded then Container.Capacity\n+                          else Capacity_Range'Last);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Capacity);\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n       Capacity  : Capacity_Range)\n    with\n      Global => null,\n-     Pre    => (if Bounded then Capacity <= Container.Capacity);\n-\n-   function Length (Container : Vector) return Capacity_Range with\n-     Global => null;\n+     Pre    => (if Bounded then Capacity <= Container.Capacity),\n+     Post   => Model (Container) = Model (Container)'Old;\n \n    function Is_Empty (Container : Vector) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n \n    procedure Clear (Container : in out Vector) with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Container) = 0;\n    --  Note that this reclaims storage in the unbounded case. You need to call\n    --  this before a container goes out of scope in order to avoid storage\n    --  leaks. In addition, \"X := ...\" can leak unless you Clear(X) first.\n \n    procedure Assign (Target : in out Vector; Source : Vector) with\n      Global => null,\n-     Pre    => (if Bounded then Length (Source) <= Target.Capacity);\n+     Pre    => (if Bounded then Length (Source) <= Target.Capacity),\n+     Post   => Model (Target) = Model (Source);\n \n    function Copy\n      (Source   : Vector;\n       Capacity : Capacity_Range := 0) return Vector\n    with\n      Global => null,\n-     Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity));\n+     Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity)),\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and (if Capacity = 0 then Copy'Result.Capacity = Length (Source)\n+              else Copy'Result.Capacity = Capacity);\n+\n+   procedure Move (Target : in out Vector; Source : in out Vector)\n+   with\n+     Global => null,\n+     Pre    => (if Bounded then Length (Source) <= Capacity (Target)),\n+     Post   => Model (Target) = Model (Source)'Old and Length (Source) = 0;\n \n    function Element\n      (Container : Vector;\n       Index     : Index_Type) return Element_Type\n    with\n      Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   => Element'Result = Element (Model (Container), Index);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Index     : Index_Type;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old\n \n-   procedure Append\n+         --  Container now has New_Item at index Index\n+\n+         and Element (Model (Container), Index) = New_Item\n+\n+         --  All other elements are preserved\n+\n+         and M.Equal_Except\n+               (Left     => Model (Container)'Old,\n+                Right    => Model (Container),\n+                Position => Index);\n+\n+   procedure Insert\n      (Container : in out Vector;\n+      Before    : Extended_Index;\n       New_Item  : Vector)\n    with\n      Global => null,\n-     Pre    => (if Bounded then\n-                 Length (Container) + Length (New_Item) <= Container.Capacity);\n+     Pre    =>\n+       Length (Container) <= Capacity (Container) - Length (New_Item)\n+         and (Before in Index_Type'First .. Last_Index (Container)\n+              or Before - 1 = Last_Index (Container)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Length (New_Item)\n+\n+         --  Elements located before Before in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Before - 1)\n+\n+         --  Elements of New_Item are inserted at position Before\n+\n+         and (if Length (New_Item) > 0 then\n+                M.Range_Shifted\n+                  (Left   => Model (New_Item),\n+                    Right  => Model (Container),\n+                    Fst    => Index_Type'First,\n+                    Lst    => Last_Index (New_Item),\n+                    Offset => Count_Type (Before - Index_Type'First)))\n+\n+         --  Elements located after Before in Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Before,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Length (New_Item));\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type)\n+   with\n+     Global => null,\n+     Pre    =>\n+       Length (Container) < Capacity (Container)\n+         and then (Before in Index_Type'First .. Last_Index (Container) + 1),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Elements located before Before in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Before - 1)\n+\n+         --  Container now has New_Item at index Before\n+\n+         and Element (Model (Container), Before) = New_Item\n+\n+         --  Elements located after Before in Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Before,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    =>\n+       Length (Container) <= Capacity (Container) - Count\n+         and (Before in Index_Type'First .. Last_Index (Container)\n+              or Before - 1 = Last_Index (Container)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  Elements located before Before in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Before - 1)\n+\n+         --  New_Item is inserted Count times at position Before\n+\n+         and (if Count > 0 then\n+                M.Constant_Range\n+                  (Container => Model (Container),\n+                    Fst       => Before,\n+                    Lst       => Before + Index_Type'Base (Count - 1),\n+                    Item      => New_Item))\n+\n+         --  Elements located after Before in Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Before,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Count);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Vector)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Capacity (Container) - Length (New_Item),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Length (New_Item)\n+\n+         --  Elements of New_Item are inserted at the beginning of Container\n+\n+         and M.Range_Equal\n+               (Left  => Model (New_Item),\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Last_Index (New_Item))\n+\n+         --  Elements of Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Length (New_Item));\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) < Capacity (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Container now has New_Item at Index_Type'First\n+\n+         and Element (Model (Container), Index_Type'First) = New_Item\n+\n+         --  Elements of Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => 1);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Capacity (Container) - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  New_Item is inserted Count times at the beginning of Container\n+\n+         and M.Constant_Range\n+               (Container => Model (Container),\n+                Fst       => Index_Type'First,\n+                Lst       => Index_Type'First + Index_Type'Base (Count - 1),\n+                Item      => New_Item)\n+\n+         --  Elements of Container are shifted\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container)'Old,\n+                Offset => Count);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Vector)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) <= Capacity (Container) - Length (New_Item),\n+     Post           =>\n+       Length (Container) = Length (Container)'Old + Length (New_Item)\n+\n+         --  The elements of Container are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+\n+         --  Elements of New_Item are inserted at the end of Container\n+\n+         and (if Length (New_Item) > 0 then\n+                M.Range_Shifted\n+                 (Left   => Model (New_Item),\n+                   Right  => Model (Container),\n+                   Fst    => Index_Type'First,\n+                   Lst    => Last_Index (New_Item),\n+                   Offset =>\n+                     Count_Type\n+                       (Last_Index (Container)'Old - Index_Type'First + 1)));\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => (if Bounded then\n-                  Length (Container) < Container.Capacity);\n+     Pre    => Length (Container) < Capacity (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+         --  Elements of Container are preserved\n+\n+         and Model (Container)'Old < Model (Container)\n+\n+         --  Container now has New_Item at the end of Container\n+\n+         and Element\n+               (Model (Container), Last_Index (Container)'Old + 1) = New_Item;\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Capacity (Container) - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+         --  Elements of Container are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+\n+         --  New_Item is inserted Count times at the end of Container\n+\n+         and (if Count > 0 then\n+                M.Constant_Range\n+                  (Container => Model (Container),\n+                    Fst       => Last_Index (Container)'Old + 1,\n+                    Lst       =>\n+                      Last_Index (Container)'Old + Index_Type'Base (Count),\n+                    Item      => New_Item));\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index)\n+   with\n+     Global => null,\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Elements located before Index in Container are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Index - 1)\n+\n+         --  Elements located after Index in Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => Index,\n+                Lst    => Last_Index (Container),\n+                Offset => 1);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Pre            =>\n+       Index in First_Index (Container) .. Last_Index (Container),\n+     Post           =>\n+       Length (Container) in\n+         Length (Container)'Old - Count .. Length (Container)'Old\n+\n+         --  The elements of Container located before Index are preserved.\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => Index_Type'First,\n+                Lst   => Index - 1),\n+\n+     Contract_Cases =>\n+\n+       --  All the elements after Position have been erased\n+\n+       (Length (Container) - Count <= Count_Type (Index - Index_Type'First) =>\n+          Length (Container) = Count_Type (Index - Index_Type'First),\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  Other elements are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => Index,\n+                   Lst    => Last_Index (Container),\n+                   Offset => Count));\n+\n+   procedure Delete_First\n+     (Container : in out Vector)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) > 0,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Elements of Container are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container),\n+                Right  => Model (Container)'Old,\n+                Fst    => Index_Type'First,\n+                Lst    => Last_Index (Container),\n+                Offset => 1);\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  All the elements of Container have been erased\n+\n+       (Length (Container) <= Count => Length (Container) = 0,\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  Elements of Container are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container),\n+                   Right  => Model (Container)'Old,\n+                   Fst    => Index_Type'First,\n+                   Lst    => Last_Index (Container),\n+                   Offset => Count));\n \n    procedure Delete_Last\n      (Container : in out Vector)\n    with\n-     Global => null;\n+     Global => null,\n+     Pre    => Length (Container) > 0,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Elements of Container are preserved\n+\n+         and Model (Container) < Model (Container)'Old;\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  All the elements after Position have been erased\n+\n+       (Length (Container) <= Count => Length (Container) = 0,\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+            --  The elements of Container are preserved\n+\n+            and Model (Container) <= Model (Container)'Old);\n \n    procedure Reverse_Elements (Container : in out Vector) with\n-     Global => null;\n+     Global => null,\n+     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) with\n      Global => null,\n      Pre    => I in First_Index (Container) .. Last_Index (Container)\n-      and then J in First_Index (Container) .. Last_Index (Container);\n+      and then J in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+       M_Elements_Swapped (Model (Container)'Old, Model (Container), I, J);\n \n    function First_Index (Container : Vector) return Index_Type with\n-     Global => null;\n+     Global => null,\n+     Post   => First_Index'Result = Index_Type'First;\n+   pragma Annotate (GNATprove, Inline_For_Proof, First_Index);\n \n    function First_Element (Container : Vector) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       First_Element'Result = Element (Model (Container), Index_Type'First);\n+   pragma Annotate (GNATprove, Inline_For_Proof, First_Element);\n \n    function Last_Index (Container : Vector) return Extended_Index with\n-     Global => null;\n+     Global => null,\n+     Post   => Last_Index'Result = M.Last (Model (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Last_Index);\n \n    function Last_Element (Container : Vector) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Last_Element'Result =\n+         Element (Model (Container), Last_Index (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Last_Element);\n \n    function Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  If Item is not is not contained in Container after Index, Find_Index\n+       --  returns No_Index.\n+\n+       (Index > Last_Index (Container)\n+        or else not M.Contains\n+                     (Container => Model (Container),\n+                      Fst       => Index,\n+                      Lst       => Last_Index (Container),\n+                      Item      => Item)\n+        =>\n+          Find_Index'Result = No_Index,\n+\n+        --  Otherwise, Find_Index returns a valid index greater than Index\n+\n+        others =>\n+           Find_Index'Result in Index .. Last_Index (Container)\n+\n+            --  The element at this index in Container is Item\n+\n+            and Element (Model (Container), Find_Index'Result) = Item\n+\n+            --  It is the first occurrence of Item after Index in Container\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       => Index,\n+                       Lst       => Find_Index'Result - 1,\n+                       Item      => Item));\n \n    function Reverse_Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  If Item is not is not contained in Container before Index,\n+       --  Reverse_Find_Index returns No_Index.\n+\n+       (not M.Contains\n+              (Container => Model (Container),\n+               Fst       => Index_Type'First,\n+               Lst       => (if Index <= Last_Index (Container) then Index\n+                             else Last_Index (Container)),\n+               Item      => Item)\n+        =>\n+          Reverse_Find_Index'Result = No_Index,\n+\n+        --  Otherwise, Reverse_Find_Index returns a valid index smaller than\n+        --  Index\n+\n+        others =>\n+           Reverse_Find_Index'Result in Index_Type'First .. Index\n+            and Reverse_Find_Index'Result <= Last_Index (Container)\n+\n+            --  The element at this index in Container is Item\n+\n+            and Element (Model (Container), Reverse_Find_Index'Result) = Item\n+\n+            --  It is the last occurrence of Item before Index in Container\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       => Reverse_Find_Index'Result + 1,\n+                       Lst       =>\n+                         (if Index <= Last_Index (Container) then Index\n+                          else Last_Index (Container)),\n+                       Item      => Item));\n \n    function Contains\n      (Container : Vector;\n       Item      : Element_Type) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Contains'Result = M.Contains (Container => Model (Container),\n+                                     Fst       => Index_Type'First,\n+                                     Lst       => Last_Index (Container),\n+                                     Item      => Item);\n \n    function Has_Element\n      (Container : Vector;\n       Position  : Extended_Index) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Has_Element'Result =\n+         (Position in Index_Type'First .. Last_Index (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting with SPARK_Mode is\n+      function M_Elements_Sorted (Container : M.Sequence) return Boolean with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          M_Elements_Sorted'Result =\n+            (for all I in Index_Type'First .. M.Last (Container) =>\n+              (for all J in I .. M.Last (Container) =>\n+                 Element (Container, I) = Element (Container, J)\n+                   or Element (Container, I) < Element (Container, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       function Is_Sorted (Container : Vector) return Boolean with\n-        Global => null;\n+        Global => null,\n+        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n \n       procedure Sort (Container : in out Vector) with\n-        Global => null;\n-\n+        Global => null,\n+        Post   =>\n+          Length (Container) = Length (Container)'Old\n+            and M_Elements_Sorted (Model (Container))\n+            and M_Elements_Included (Left  => Model (Container)'Old,\n+                                     L_Lst => Last_Index (Container),\n+                                     Right => Model (Container),\n+                                     R_Lst => Last_Index (Container))\n+            and M_Elements_Included (Left  => Model (Container),\n+                                     L_Lst => Last_Index (Container),\n+                                     Right => Model (Container)'Old,\n+                                     R_Lst => Last_Index (Container));\n+\n+      procedure Merge (Target : in out Vector; Source : in out Vector) with\n+      --  Target and Source should not be aliased\n+        Global => null,\n+        Pre    => Length (Source) <= Capacity (Target) - Length (Target),\n+        Post   =>\n+          Length (Target) = Length (Target)'Old + Length (Source)'Old\n+            and Length (Source) = 0\n+            and (if M_Elements_Sorted (Model (Target)'Old)\n+                   and M_Elements_Sorted (Model (Source)'Old)\n+                 then M_Elements_Sorted (Model (Target)))\n+            and M_Elements_Included (Left  => Model (Target)'Old,\n+                                     L_Lst => Last_Index (Target)'Old,\n+                                     Right => Model (Target),\n+                                     R_Lst => Last_Index (Target))\n+            and M_Elements_Included (Left  => Model (Source)'Old,\n+                                     L_Lst => Last_Index (Source)'Old,\n+                                     Right => Model (Target),\n+                                     R_Lst => Last_Index (Target))\n+            and M_Elements_In_Union (Model (Target),\n+                                     Model (Source)'Old,\n+                                     Model (Target)'Old);\n    end Generic_Sorting;\n \n-   function First_To_Previous\n-     (Container : Vector;\n-      Current   : Index_Type) return Vector\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Current in First_Index (Container) .. Last_Index (Container);\n-\n-   function Current_To_Last\n-     (Container : Vector;\n-      Current   : Index_Type) return Vector\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Current in First_Index (Container) .. Last_Index (Container);\n-   --  First_To_Previous returns a container containing all elements preceding\n-   --  Current (excluded) in Container. Current_To_Last returns a container\n-   --  containing all elements following Current (included) in Container.\n-   --  These two new functions can be used to express invariant properties in\n-   --  loops which iterate over containers. First_To_Previous returns the part\n-   --  of the container already scanned and Current_To_Last the part not\n-   --  scanned yet.\n-\n private\n    pragma SPARK_Mode (Off);\n "}, {"sha": "5b0946c358752d18569f4d54b3e2ec37243a3a13", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -1482,7 +1482,7 @@ package body Freeze is\n             A_Post := Get_Pragma (Par_Prim, Pragma_Postcondition);\n \n             if Present (A_Post) and then Class_Present (A_Post) then\n-               New_Prag := New_Copy_Tree (A_Pre);\n+               New_Prag := New_Copy_Tree (A_Post);\n                Build_Class_Wide_Expression\n                  (Prag           => New_Prag,\n                   Subp           => Prim,"}, {"sha": "e011ad849ade579c38bce77eca3604fae348d674", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2016, AdaCore                     --\n+--                     Copyright (C) 2000-2017, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -279,7 +279,8 @@ package body GNAT.Dynamic_Tables is\n               new Ada.Unchecked_Conversion (Alloc_Ptr, Table_Ptr);\n \n             Old_Table : Old_Alloc_Ptr := To_Old_Alloc_Ptr (T.Table);\n-            New_Table : constant Alloc_Ptr := new Alloc_Type'(Old_Table.all);\n+            New_Table : constant Alloc_Ptr :=\n+              new Alloc_Type'(Old_Table (Alloc_Type'Range));\n          begin\n             T.P.Last_Allocated := T.P.Last;\n             Free (Old_Table);"}, {"sha": "e4efaabeb44e587b1a8d32dc862f715124be32bc", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f2b7ce3aea49818ea97974cb41029f820d0a99/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=78f2b7ce3aea49818ea97974cb41029f820d0a99", "patch": "@@ -24007,16 +24007,20 @@ package body Sem_Prag is\n                         & \"of &\", Nod, Disp_Typ);\n                   end if;\n \n-               --  Otherwise we have a call to an overridden primitive, and\n-               --  we will create a common class-wide clone for the body of\n-               --  original operation and its eventual inherited versions.\n-               --  If the original operation dispatches on result it is\n-               --  never inherited and there is no need for a clone.\n+               --  Otherwise we have a call to an overridden primitive, and we\n+               --  will create a common class-wide clone for the body of\n+               --  original operation and its eventual inherited versions.  If\n+               --  the original operation dispatches on result it is never\n+               --  inherited and there is no need for a clone. There is not\n+               --  need for a clone either in GNATprove mode, as cases that\n+               --  would require it are rejected (when an inherited primitive\n+               --  calls an overridden operation in a class-wide contract), and\n+               --  the clone would make proof impossible in some cases.\n \n                elsif not Is_Abstract_Subprogram (Spec_Id)\n                  and then No (Class_Wide_Clone (Spec_Id))\n                  and then not Has_Controlling_Result (Spec_Id)\n-                 and then SPARK_Mode /= On\n+                 and then not GNATprove_Mode\n                then\n                   Build_Class_Wide_Clone_Decl (Spec_Id);\n                end if;"}]}