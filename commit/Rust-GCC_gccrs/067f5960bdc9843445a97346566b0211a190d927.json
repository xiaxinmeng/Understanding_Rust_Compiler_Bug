{"sha": "067f5960bdc9843445a97346566b0211a190d927", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY3ZjU5NjBiZGM5ODQzNDQ1YTk3MzQ2NTY2YjAyMTFhMTkwZDkyNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-05T17:40:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-05T17:40:49Z"}, "message": "Fix lower_vec_shuffle.\n\n1: It can never fail.\n2: It should mask the input indicies.\n\nFrom-SVN: r179563", "tree": {"sha": "d4d64652b59c6ad20377afb612e79c571eeab3c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4d64652b59c6ad20377afb612e79c571eeab3c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/067f5960bdc9843445a97346566b0211a190d927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067f5960bdc9843445a97346566b0211a190d927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/067f5960bdc9843445a97346566b0211a190d927", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067f5960bdc9843445a97346566b0211a190d927/comments", "author": null, "committer": null, "parents": [{"sha": "9fff751c3f50b1b13e40cc25702055561f6cf085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fff751c3f50b1b13e40cc25702055561f6cf085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fff751c3f50b1b13e40cc25702055561f6cf085"}], "stats": {"total": 278, "additions": 104, "deletions": 174}, "files": [{"sha": "b4f9ac2791cb44300c2e6ffea4fdffe31fd4fb3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067f5960bdc9843445a97346566b0211a190d927/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067f5960bdc9843445a97346566b0211a190d927/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=067f5960bdc9843445a97346566b0211a190d927", "patch": "@@ -1,3 +1,11 @@\n+2011-10-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-vect-generic.c (vector_element): Never fail.  Use\n+\tbuild_zero_cst.  Tidy up type references.\n+\t(lower_vec_shuffle): Never fail.  Mask shuffle indicies.  Reduce\n+\tcode duplication.  Do update_stmt here ...\n+\t(expand_vector_operations_1): ... not here.\n+\n 2011-10-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (distance_non_agu_define): Simplify calculation"}, {"sha": "ef03b355f78288897473c2163914232805a31afa", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 96, "deletions": 174, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/067f5960bdc9843445a97346566b0211a190d927/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/067f5960bdc9843445a97346566b0211a190d927/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=067f5960bdc9843445a97346566b0211a190d927", "patch": "@@ -512,22 +512,29 @@ type_for_widest_vector_mode (enum machine_mode inner_mode, optab op, int satp)\n static tree\n vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n {\n-  tree type;\n+  tree vect_type, vect_elt_type;\n   gimple asgn;\n   tree tmpvec;\n   tree arraytype;\n   bool need_asgn = true;\n+  unsigned int elements;\n \n-  gcc_assert (TREE_CODE (TREE_TYPE (vect)) == VECTOR_TYPE);\n+  vect_type = TREE_TYPE (vect);\n+  vect_elt_type = TREE_TYPE (vect_type);\n+  elements = TYPE_VECTOR_SUBPARTS (vect_type);\n \n-  type = TREE_TYPE (vect);\n   if (TREE_CODE (idx) == INTEGER_CST)\n     {\n       unsigned HOST_WIDE_INT index;\n \n-      if (!host_integerp (idx, 1)\n-           || (index = tree_low_cst (idx, 1)) > TYPE_VECTOR_SUBPARTS (type)-1)\n-        return error_mark_node;\n+      /* Given that we're about to compute a binary modulus,\n+\t we don't care about the high bits of the value.  */\n+      index = TREE_INT_CST_LOW (idx);\n+      if (!host_integerp (idx, 1) || index >= elements)\n+\t{\n+\t  index &= elements - 1;\n+\t  idx = build_int_cst (TREE_TYPE (idx), index);\n+\t}\n \n       if (TREE_CODE (vect) == VECTOR_CST)\n         {\n@@ -536,33 +543,30 @@ vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n \t  for (i = 0; vals; vals = TREE_CHAIN (vals), ++i)\n \t    if (i == index)\n \t       return TREE_VALUE (vals);\n-\t  return error_mark_node;\n+\t  return build_zero_cst (vect_elt_type);\n         }\n       else if (TREE_CODE (vect) == CONSTRUCTOR)\n         {\n           unsigned i;\n-          VEC (constructor_elt, gc) *vals = CONSTRUCTOR_ELTS (vect);\n-          constructor_elt *elt;\n+          tree elt_i, elt_v;\n \n-          for (i = 0; VEC_iterate (constructor_elt, vals, i, elt); i++)\n-            if (operand_equal_p (elt->index, idx, 0))\n-              return elt->value;\n-          return fold_convert (TREE_TYPE (type), integer_zero_node);\n+\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (vect), i, elt_i, elt_v)\n+            if (operand_equal_p (elt_i, idx, 0))\n+              return elt_v;\n+          return build_zero_cst (vect_elt_type);\n         }\n-      else if (TREE_CODE (vect) == SSA_NAME)\n+      else\n         {\n-\t  tree size = TYPE_SIZE (TREE_TYPE (type));\n+\t  tree size = TYPE_SIZE (vect_elt_type);\n           tree pos = fold_build2 (MULT_EXPR, TREE_TYPE (idx), idx, size);\n-          return fold_build3 (BIT_FIELD_REF, TREE_TYPE (type), vect, size, pos);\n+          return fold_build3 (BIT_FIELD_REF, vect_elt_type, vect, size, pos);\n         }\n-      else\n-\treturn error_mark_node;\n     }\n \n   if (!ptmpvec)\n-    tmpvec = create_tmp_var (TREE_TYPE (vect), \"vectmp\");\n+    tmpvec = create_tmp_var (vect_type, \"vectmp\");\n   else if (!*ptmpvec)\n-    tmpvec = *ptmpvec = create_tmp_var (TREE_TYPE (vect), \"vectmp\");\n+    tmpvec = *ptmpvec = create_tmp_var (vect_type, \"vectmp\");\n   else\n     {\n       tmpvec = *ptmpvec;\n@@ -576,17 +580,14 @@ vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n       gsi_insert_before (gsi, asgn, GSI_SAME_STMT);\n     }\n \n-  arraytype = build_array_type_nelts (TREE_TYPE (type),\n-\t\t\t\t      TYPE_VECTOR_SUBPARTS (TREE_TYPE (vect)));\n-\n-  return build4 (ARRAY_REF, TREE_TYPE (type),\n+  arraytype = build_array_type_nelts (vect_elt_type, elements);\n+  return build4 (ARRAY_REF, vect_elt_type,\n                  build1 (VIEW_CONVERT_EXPR, arraytype, tmpvec),\n                  idx, NULL_TREE, NULL_TREE);\n }\n \n /* Check if VEC_SHUFFLE_EXPR within the given setting is supported\n-   by hardware, or lower it piecewise.  Function returns false when\n-   the expression must be replaced with TRAP_RETURN, true otherwise.\n+   by hardware, or lower it piecewise.\n \n    When VEC_SHUFFLE_EXPR has the same first and second operands:\n    VEC_SHUFFLE_EXPR <v0, v0, mask> the lowered version would be\n@@ -597,162 +598,96 @@ vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n    {mask[0] < len(v0) ? v0[mask[0]] : v1[mask[0]], ...}\n    V0 and V1 must have the same type.  MASK, V0, V1 must have the\n    same number of arguments.  */\n-static bool\n-lower_vec_shuffle (gimple_stmt_iterator *gsi, location_t loc)\n-{\n \n+static void\n+lower_vec_shuffle (gimple_stmt_iterator *gsi)\n+{\n   gimple stmt = gsi_stmt (*gsi);\n   tree mask = gimple_assign_rhs3 (stmt);\n   tree vec0 = gimple_assign_rhs1 (stmt);\n   tree vec1 = gimple_assign_rhs2 (stmt);\n-  unsigned els = TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask));\n-  tree type0 = TREE_TYPE (TREE_TYPE (vec0));\n-  VEC(constructor_elt,gc) *v = NULL;\n-  tree vectype, constr;\n-  tree vec0tmp = NULL_TREE, masktmp = NULL_TREE;\n-\n-  if (expand_vec_shuffle_expr_p (TYPE_MODE (TREE_TYPE (vec0)), vec0, vec1, mask))\n-    {\n-      tree t;\n+  tree vect_type = TREE_TYPE (vec0);\n+  tree mask_type = TREE_TYPE (mask);\n+  tree vect_elt_type = TREE_TYPE (vect_type);\n+  tree mask_elt_type = TREE_TYPE (mask_type);\n+  unsigned int elements = TYPE_VECTOR_SUBPARTS (vect_type);\n+  VEC(constructor_elt,gc) *v;\n+  tree constr, t, si, i_val;\n+  tree vec0tmp = NULL_TREE, vec1tmp = NULL_TREE, masktmp = NULL_TREE;\n+  bool two_operand_p = !operand_equal_p (vec0, vec1, 0);\n+  unsigned i;\n \n-      t = gimplify_build3 (gsi, VEC_SHUFFLE_EXPR, TREE_TYPE (vec0),\n-\t\t\t   vec0, vec1, mask);\n-      gimple_assign_set_rhs_from_tree (gsi, t);\n-      /* Statement should be updated by callee.  */\n-      return true;\n-    }\n+  if (expand_vec_shuffle_expr_p (TYPE_MODE (vect_type), vec0, vec1, mask))\n+    return;\n \n-  if (operand_equal_p (vec0, vec1, 0))\n+  v = VEC_alloc (constructor_elt, gc, elements);\n+  for (i = 0; i < elements; i++)\n     {\n-      unsigned i;\n-      tree vec0tmp = NULL_TREE;\n+      si = size_int (i);\n+      i_val = vector_element (gsi, mask, si, &masktmp);\n \n-      v = VEC_alloc (constructor_elt, gc, els);\n-      for (i = 0; i < els; i++)\n+      if (TREE_CODE (i_val) == INTEGER_CST)\n         {\n-          tree idxval, vecel, t;\n+\t  unsigned HOST_WIDE_INT index;\n \n-\t  idxval = vector_element (gsi, mask, size_int (i), &masktmp);\n-          if (idxval == error_mark_node)\n-            {\n-              if (warning_at (loc, 0, \"Invalid shuffling mask index %i\", i))\n-\t\tinform (loc, \"if this code is reached the programm will abort\");\n-\t      return false;\n-            }\n+\t  index = TREE_INT_CST_LOW (i_val);\n+\t  if (!host_integerp (i_val, 1) || index >= elements)\n+\t    i_val = build_int_cst (mask_elt_type, index & (elements - 1));\n \n-\t  vecel = vector_element (gsi, vec0, idxval, &vec0tmp);\n-          if (vecel == error_mark_node)\n-            {\n-              if (warning_at (loc, 0, \"Invalid shuffling arguments\"))\n-\t\tinform (loc, \"if this code is reached the programm will abort\");\n-\t      return false;\n-            }\n+          if (two_operand_p && (index & elements) != 0)\n+\t    t = vector_element (gsi, vec1, i_val, &vec1tmp);\n+\t  else\n+\t    t = vector_element (gsi, vec0, i_val, &vec0tmp);\n \n-          t = force_gimple_operand_gsi (gsi, vecel, true,\n-\t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n-          CONSTRUCTOR_APPEND_ELT (v, size_int (i), t);\n+          t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n         }\n-    }\n-  else\n-    {\n-      unsigned i;\n-      tree var = create_tmp_var (type0, \"vecel\");\n-      tree vec1tmp = NULL_TREE;\n-\n-      v = VEC_alloc (constructor_elt, gc, els);\n-      for (i = 0; i < els; i++)\n+      else\n         {\n-          tree idxval, idx1val, cond, elval0, elval1, condexpr, t, ssatmp;\n-          tree vec0el, vec1el;\n-          gimple asgn;\n+\t  tree cond = NULL_TREE, v0_val;\n \n-          idxval = vector_element (gsi, mask, size_int (i), &masktmp);\n-\t  if (idxval == error_mark_node)\n-            {\n-              if (warning_at (loc, 0, \"Invalid shuffling mask index %i\", i))\n-\t\tinform (loc, \"if this code is reached the programm will abort\");\n-\t      return false;\n-            }\n+\t  if (two_operand_p)\n+\t    {\n+\t      cond = fold_build2 (BIT_AND_EXPR, mask_elt_type, i_val,\n+\t\t\t          build_int_cst (mask_elt_type, elements));\n+\t      cond = force_gimple_operand_gsi (gsi, cond, true, NULL_TREE,\n+\t\t\t\t\t       true, GSI_SAME_STMT);\n+\t    }\n \n-          if (TREE_CODE (idxval) == INTEGER_CST)\n-            {\n-              if (tree_int_cst_lt (idxval, size_int (els)))\n-                {\n-                  vec0el = vector_element (gsi, vec0, idxval, &vec0tmp);\n-                  t = force_gimple_operand_gsi (gsi, vec0el,\n-                                    true, NULL_TREE, true, GSI_SAME_STMT);\n-                }\n-              else if (tree_int_cst_lt (idxval, size_int (2*els)))\n-                {\n-                  idx1val = fold_build2 (MINUS_EXPR, TREE_TYPE (idxval),\n-                        idxval, build_int_cst (TREE_TYPE (idxval), els));\n-\n-                  vec1el = vector_element (gsi, vec1, idx1val, &vec1tmp);\n-                  t = force_gimple_operand_gsi (gsi, vec1el, true,\n-\t\t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n-                }\n-              else\n-                {\n-                  if (warning_at (loc, 0, \"Invalid shuffling mask index %i\", i))\n-\t\t    inform (loc, \"if this code is reached the \"\n-\t\t\t\t  \"programm will abort\");\n-\t\t  return false;\n-                }\n-            }\n-          else\n-            {\n+\t  i_val = fold_build2 (BIT_AND_EXPR, mask_elt_type, i_val,\n+\t\t\t       build_int_cst (mask_elt_type, elements - 1));\n+\t  i_val = force_gimple_operand_gsi (gsi, i_val, true, NULL_TREE,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n \n-              idx1val = fold_build2 (MINUS_EXPR, TREE_TYPE (idxval),\n-                            idxval, build_int_cst (TREE_TYPE (idxval), els));\n-              idx1val = force_gimple_operand_gsi (gsi, idx1val,\n-                                true, NULL_TREE, true, GSI_SAME_STMT);\n-              cond = fold_build2 (GT_EXPR, boolean_type_node, \\\n-                             idxval, fold_convert (type0, size_int (els - 1)));\n-\n-\t      vec0el = vector_element (gsi, vec0, idxval, &vec0tmp);\n-              if (vec0el == error_mark_node)\n-                {\n-                  if (warning_at (loc, 0, \"Invalid shuffling arguments\"))\n-\t\t    inform (loc, \"if this code is reached the \"\n-\t\t\t\t \"programm will abort\");\n-\t\t  return false;\n-                }\n-\n-              elval0 = force_gimple_operand_gsi (gsi, vec0el,\n-                                true, NULL_TREE, true, GSI_SAME_STMT);\n-\n-\t      vec1el = vector_element (gsi, vec1, idx1val, &vec1tmp);\n-              if (vec1el == error_mark_node)\n-                {\n-                  if (warning_at (loc, 0, \"Invalid shuffling arguments\"))\n-\t\t    inform (loc, \"if this code is reached the \"\n-\t\t\t\t \"programm will abort\");\n-\t\t  return false;\n-                }\n-\n-              elval1 = force_gimple_operand_gsi (gsi, vec1el,\n-                                true, NULL_TREE, true, GSI_SAME_STMT);\n-\n-              condexpr = fold_build3 (COND_EXPR, type0, cond, \\\n-                                      elval1, elval0);\n-\n-              t = force_gimple_operand_gsi (gsi, condexpr, true, \\\n-                                        NULL_TREE, true, GSI_SAME_STMT);\n-            }\n+\t  v0_val = vector_element (gsi, vec0, i_val, &vec0tmp);\n+\t  v0_val = force_gimple_operand_gsi (gsi, v0_val, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n \n-          asgn = gimple_build_assign (var, t);\n-          ssatmp = make_ssa_name (var, asgn);\n-          gimple_assign_set_lhs (asgn, ssatmp);\n-          gsi_insert_before (gsi, asgn, GSI_SAME_STMT);\n-          CONSTRUCTOR_APPEND_ELT (v, size_int (i), ssatmp);\n+\t  if (two_operand_p)\n+\t    {\n+\t      tree v1_val;\n+\n+\t      v1_val = vector_element (gsi, vec1, i_val, &vec1tmp);\n+\t      v1_val = force_gimple_operand_gsi (gsi, v1_val, true, NULL_TREE,\n+\t\t\t\t\t\t true, GSI_SAME_STMT);\n+\n+\t      cond = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t  cond, build_zero_cst (mask_elt_type));\n+\t      cond = fold_build3 (COND_EXPR, vect_elt_type,\n+\t\t\t\t  cond, v0_val, v1_val);\n+              t = force_gimple_operand_gsi (gsi, cond, true, NULL_TREE,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+            }\n+\t  else\n+\t    t = v0_val;\n         }\n+\n+      CONSTRUCTOR_APPEND_ELT (v, si, t);\n     }\n \n-  vectype = build_vector_type (type0, els);\n-  constr = build_constructor (vectype, v);\n+  constr = build_constructor (vect_type, v);\n   gimple_assign_set_rhs_from_tree (gsi, constr);\n-  /* Statement should be updated by callee.  */\n-  return true;\n+  update_stmt (gsi_stmt (*gsi));\n }\n \n /* Process one statement.  If we identify a vector operation, expand it.  */\n@@ -777,21 +712,8 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \n   if (code == VEC_SHUFFLE_EXPR)\n     {\n-      if (!lower_vec_shuffle (gsi, gimple_location (stmt)))\n-\t{\n-\t  gimple new_stmt;\n-\t  tree vec0;\n-\n-\t  vec0 = gimple_assign_rhs1 (stmt);\n-\t  new_stmt = gimple_build_call (built_in_decls[BUILT_IN_TRAP], 0);\n-\t  gsi_insert_before (gsi, new_stmt,  GSI_SAME_STMT);\n-\t  split_block (gimple_bb (new_stmt), new_stmt);\n-\t  new_stmt = gimple_build_assign (gimple_assign_lhs (stmt), vec0);\n-\t  gsi_replace (gsi, new_stmt, false);\n-\t}\n-\n-      gimple_set_modified (gsi_stmt (*gsi), true);\n-      update_stmt (gsi_stmt (*gsi));\n+      lower_vec_shuffle (gsi);\n+      return;\n     }\n \n   if (rhs_class != GIMPLE_UNARY_RHS && rhs_class != GIMPLE_BINARY_RHS)"}]}