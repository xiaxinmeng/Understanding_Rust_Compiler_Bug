{"sha": "dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRkZWE2ZDRkODFjYWM3NmZmNjRjZGUxNzhlMmQ1ZjdmZTA5ZmI1NQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-07T17:03:33Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-07T17:22:36Z"}, "message": "d: Merge upstream dmd 9038e64c5.\n\nAdds support for using user-defined attributes on function arguments and\nsingle-parameter alias declarations.  These attributes behave analogous\nto existing UDAs.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 9038e64c5.\n\t* d-builtins.cc (build_frontend_type): Update call to\n\tParameter::create.", "tree": {"sha": "f8c2345d5a980c6523798c1388a777e05fdaf500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8c2345d5a980c6523798c1388a777e05fdaf500"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54029179cbe817eaf9b6899339b0151cff3c00e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54029179cbe817eaf9b6899339b0151cff3c00e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54029179cbe817eaf9b6899339b0151cff3c00e"}], "stats": {"total": 506, "additions": 432, "deletions": 74}, "files": [{"sha": "3f1533b592f0ba6313e7cd39699eefea3086ddd4", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -311,7 +311,7 @@ build_frontend_type (tree type)\n \t\t  return NULL;\n \t\t}\n \n-\t      args->push (Parameter::create (sc, targ, NULL, NULL));\n+\t      args->push (Parameter::create (sc, targ, NULL, NULL, NULL));\n \t    }\n \n \t  /* GCC generic and placeholder built-ins are marked as variadic, yet"}, {"sha": "25b2b3ac9651e52d59001cb43da4f57d2f706b06", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -1,4 +1,4 @@\n-a5c86f5b92c4cd3afde910c89881ccaea11de554\n+9038e64c5b67a10763d32893f53bb6c610df3595\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "20cdb6fd1847ea8628db5b1d86f6555217d3ec7b", "filename": "gcc/d/dmd/arrayop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Farrayop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Farrayop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -51,7 +51,7 @@ FuncDeclaration *buildArrayOp(Identifier *ident, BinExp *exp, Scope *sc)\n     Parameter *p = (*fparams)[0];\n     // foreach (i; 0 .. p.length)\n     Statement *s1 = new ForeachRangeStatement(Loc(), TOKforeach,\n-        new Parameter(0, NULL, Id::p, NULL),\n+        new Parameter(0, NULL, Id::p, NULL, NULL),\n         new IntegerExp(Loc(), 0, Type::tsize_t),\n         new ArrayLengthExp(Loc(), new IdentifierExp(Loc(), p->ident)),\n         new ExpStatement(Loc(), loopbody),\n@@ -422,7 +422,7 @@ Expression *buildArrayLoop(Expression *e, Parameters *fparams)\n         void visit(Expression *e)\n         {\n             Identifier *id = Identifier::generateId(\"c\", fparams->length);\n-            Parameter *param = new Parameter(0, e->type, id, NULL);\n+            Parameter *param = new Parameter(0, e->type, id, NULL, NULL);\n             fparams->shift(param);\n             result = new IdentifierExp(Loc(), id);\n         }\n@@ -441,7 +441,7 @@ Expression *buildArrayLoop(Expression *e, Parameters *fparams)\n         void visit(ArrayLiteralExp *e)\n         {\n             Identifier *id = Identifier::generateId(\"p\", fparams->length);\n-            Parameter *param = new Parameter(STCconst, e->type, id, NULL);\n+            Parameter *param = new Parameter(STCconst, e->type, id, NULL, NULL);\n             fparams->shift(param);\n             Expression *ie = new IdentifierExp(Loc(), id);\n             Expression *index = new IdentifierExp(Loc(), Id::p);\n@@ -451,7 +451,7 @@ Expression *buildArrayLoop(Expression *e, Parameters *fparams)\n         void visit(SliceExp *e)\n         {\n             Identifier *id = Identifier::generateId(\"p\", fparams->length);\n-            Parameter *param = new Parameter(STCconst, e->type, id, NULL);\n+            Parameter *param = new Parameter(STCconst, e->type, id, NULL, NULL);\n             fparams->shift(param);\n             Expression *ie = new IdentifierExp(Loc(), id);\n             Expression *index = new IdentifierExp(Loc(), Id::p);"}, {"sha": "73c4a6603680cd60592ca389fffa5c980841a2dd", "filename": "gcc/d/dmd/clone.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fclone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fclone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -244,7 +244,7 @@ FuncDeclaration *buildOpAssign(StructDeclaration *sd, Scope *sc)\n     }\n \n     Parameters *fparams = new Parameters;\n-    fparams->push(new Parameter(STCnodtor, sd->type, Id::p, NULL));\n+    fparams->push(new Parameter(STCnodtor, sd->type, Id::p, NULL, NULL));\n     TypeFunction *tf = new TypeFunction(ParameterList(fparams), sd->handleType(), LINKd, stc | STCref);\n \n     FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), Id::assign, stc, tf);\n@@ -503,7 +503,7 @@ FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n                 /* const bool opEquals(ref const S s);\n                  */\n                 Parameters *parameters = new Parameters;\n-                parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL));\n+                parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL, NULL));\n                 tfeqptr = new TypeFunction(ParameterList(parameters), Type::tbool, LINKd);\n                 tfeqptr->mod = MODconst;\n                 tfeqptr = (TypeFunction *)tfeqptr->semantic(Loc(), &scx);\n@@ -531,8 +531,8 @@ FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n     Loc loc = Loc();        // loc is unnecessary so errors are gagged\n \n     Parameters *parameters = new Parameters;\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL));\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL));\n+    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL, NULL));\n+    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL, NULL));\n     TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::tbool, LINKd);\n \n     Identifier *id = Id::xopEquals;\n@@ -583,7 +583,7 @@ FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n                 /* const int opCmp(ref const S s);\n                  */\n                 Parameters *parameters = new Parameters;\n-                parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL));\n+                parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL, NULL));\n                 tfcmpptr = new TypeFunction(ParameterList(parameters), Type::tint32, LINKd);\n                 tfcmpptr->mod = MODconst;\n                 tfcmpptr = (TypeFunction *)tfcmpptr->semantic(Loc(), &scx);\n@@ -616,8 +616,8 @@ FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n     Loc loc = Loc();        // loc is unnecessary so errors are gagged\n \n     Parameters *parameters = new Parameters;\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL));\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL));\n+    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL, NULL));\n+    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL, NULL));\n     TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::tint32, LINKd);\n \n     Identifier *id = Id::xopCmp;\n@@ -738,7 +738,7 @@ FuncDeclaration *buildXtoHash(StructDeclaration *sd, Scope *sc)\n     Loc loc = Loc();        // internal code should have no loc to prevent coverage\n \n     Parameters *parameters = new Parameters();\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL));\n+    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL, NULL));\n     TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::thash_t,\n                                         LINKd, STCnothrow | STCtrusted);\n "}, {"sha": "2ea3d408155e0a323c9ff89e22515b9f633ddd29", "filename": "gcc/d/dmd/cond.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -257,7 +257,7 @@ static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n         {\n             Parameters *params = pparams[j];\n             Parameter *p = sfe->aggrfe ? (*sfe->aggrfe->parameters)[i] : sfe->rangefe->prm;\n-            params->push(new Parameter(p->storageClass, p->type, p->ident, NULL));\n+            params->push(new Parameter(p->storageClass, p->type, p->ident, NULL, NULL));\n         }\n     }\n     Expression *res[2];"}, {"sha": "f196bc825a2edc0409d8cce523216a90c0e9119a", "filename": "gcc/d/dmd/declaration.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fdeclaration.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fdeclaration.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -224,7 +224,7 @@ Type *TupleDeclaration::getType()\n         {\n             Type *t = (*types)[i];\n             //printf(\"type = %s\\n\", t->toChars());\n-            Parameter *arg = new Parameter(0, t, NULL, NULL);\n+            Parameter *arg = new Parameter(0, t, NULL, NULL, NULL);\n             (*args)[i] = arg;\n             if (!t->deco)\n                 hasdeco = 0;"}, {"sha": "316f105b9e33cc0f27116357ed8e614715ee90a0", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -6805,7 +6805,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n                     for (size_t i = 0; i < dim; i++)\n                     {\n                         Parameter *arg = (*tt->arguments)[i];\n-                        if (flags & 2 && arg->ident)\n+                        if (flags & 2 && (arg->ident || arg->userAttribDecl))\n                             tiargs->insert(j + i, arg);\n                         else\n                             tiargs->insert(j + i, arg->type);"}, {"sha": "a3c3f72d2619bae96c64370baacfc70144425fe9", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -1953,7 +1953,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n         args->setDim(arguments->length - nparams);\n         for (size_t i = 0; i < arguments->length - nparams; i++)\n         {\n-            Parameter *arg = new Parameter(STCin, (*arguments)[nparams + i]->type, NULL, NULL);\n+            Parameter *arg = new Parameter(STCin, (*arguments)[nparams + i]->type, NULL, NULL, NULL);\n             (*args)[i] = arg;\n         }\n "}, {"sha": "f519389571a523a8aa53b64390fdee8d0672b9d8", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -2051,7 +2051,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         for (size_t i = 0; i < cd->baseclasses->length; i++)\n                         {\n                             BaseClass *b = (*cd->baseclasses)[i];\n-                            args->push(new Parameter(STCin, b->type, NULL, NULL));\n+                            args->push(new Parameter(STCin, b->type, NULL, NULL, NULL));\n                         }\n                         tded = new TypeTuple(args);\n                     }\n@@ -2100,7 +2100,8 @@ class ExpressionSemanticVisitor : public Visitor\n                                 return setError();\n                             args->push(new Parameter(arg->storageClass, arg->type,\n                                                      (e->tok2 == TOKparameters) ? arg->ident : NULL,\n-                                                     (e->tok2 == TOKparameters) ? arg->defaultArg : NULL));\n+                                                     (e->tok2 == TOKparameters) ? arg->defaultArg : NULL,\n+                                                     arg->userAttribDecl));\n                         }\n                         tded = new TypeTuple(args);\n                         break;"}, {"sha": "53621adcc41942cf9f14321c7f508cf878787574", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -1221,6 +1221,15 @@ void FuncDeclaration::semantic(Scope *sc)\n         Compiler::genCmain(sc);\n \n     assert(type->ty != Terror || errors);\n+\n+    // semantic for parameters' UDAs\n+    const size_t nparams = f->parameterList.length();\n+    for (size_t i = 0; i < nparams; i++)\n+    {\n+        Parameter *param = f->parameterList[i];\n+        if (param && param->userAttribDecl)\n+            param->userAttribDecl->semantic(sc);\n+    }\n }\n \n void FuncDeclaration::semantic2(Scope *sc)\n@@ -1237,6 +1246,17 @@ void FuncDeclaration::semantic2(Scope *sc)\n     {\n         objc()->checkLinkage(this);\n     }\n+    if (!type || type->ty != Tfunction)\n+        return;\n+    TypeFunction *f = type->toTypeFunction();\n+    const size_t nparams = f->parameterList.length();\n+    // semantic for parameters' UDAs\n+    for (size_t i = 0; i < nparams; i++)\n+    {\n+        Parameter *param = f->parameterList[i];\n+        if (param && param->userAttribDecl)\n+            param->userAttribDecl->semantic2(sc);\n+    }\n }\n \n /****************************************************\n@@ -1317,7 +1337,7 @@ static void buildEnsureRequire(FuncDeclaration *fdx)\n         Parameter *p = NULL;\n         if (fdx->outId)\n         {\n-            p = new Parameter(STCref | STCconst, f->nextOf(), fdx->outId, NULL);\n+            p = new Parameter(STCref | STCconst, f->nextOf(), fdx->outId, NULL, NULL);\n             fparams->push(p);\n         }\n         TypeFunction *tf = new TypeFunction(ParameterList(fparams), Type::tvoid, LINKd);\n@@ -1603,6 +1623,8 @@ void FuncDeclaration::semantic3(Scope *sc)\n                     parameters->push(v);\n                 localsymtab->insert(v);\n                 v->parent = this;\n+                if (fparam->userAttribDecl)\n+                    v->userAttribDecl = fparam->userAttribDecl;\n             }\n         }\n "}, {"sha": "a04a8c523a3bb3b3477653e152eae2b378dbf39a", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -3097,6 +3097,18 @@ class PrettyPrintVisitor : public Visitor\n \n     void visit(Parameter *p)\n     {\n+        if (p->userAttribDecl)\n+        {\n+            buf->writestring(\"@\");\n+            bool isAnonymous = p->userAttribDecl->atts->length > 0\n+                && (*p->userAttribDecl->atts)[0]->op != TOKcall;\n+            if (isAnonymous)\n+                buf->writestring(\"(\");\n+            argsToBuffer(p->userAttribDecl->atts);\n+            if (isAnonymous)\n+                buf->writestring(\")\");\n+            buf->writestring(\" \");\n+        }\n         if (p->storageClass & STCauto)\n             buf->writestring(\"auto \");\n "}, {"sha": "42f90fa9e04e222bdac9d3bfe3ca5ffdf0675227", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -1543,7 +1543,7 @@ Type *stripDefaultArgs(Type *t)\n             {\n                 Parameter *p = (*params)[i];\n                 Type *ta = stripDefaultArgs(p->type);\n-                if (ta != p->type || p->defaultArg || p->ident)\n+                if (ta != p->type || p->defaultArg || p->ident || p->userAttribDecl)\n                 {\n                     if (params == parameters)\n                     {\n@@ -1552,7 +1552,7 @@ Type *stripDefaultArgs(Type *t)\n                         for (size_t j = 0; j < params->length; j++)\n                             (*params)[j] = (*parameters)[j];\n                     }\n-                    (*params)[i] = new Parameter(p->storageClass, ta, NULL, NULL);\n+                    (*params)[i] = new Parameter(p->storageClass, ta, NULL, NULL, NULL);\n                 }\n             }\n         }\n@@ -1996,7 +1996,7 @@ Type *TypeFunction::substWildTo(unsigned)\n             continue;\n         if (params == parameterList.parameters)\n             params = parameterList.parameters->copy();\n-        (*params)[i] = new Parameter(p->storageClass, t, NULL, NULL);\n+        (*params)[i] = new Parameter(p->storageClass, t, NULL, NULL, NULL);\n     }\n     if (next == tret && params == parameterList.parameters)\n         return this;\n@@ -4914,7 +4914,7 @@ Expression *TypeAArray::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         if (fd_aaLen == NULL)\n         {\n             Parameters *fparams = new Parameters();\n-            fparams->push(new Parameter(STCin, this, NULL, NULL));\n+            fparams->push(new Parameter(STCin, this, NULL, NULL, NULL));\n             fd_aaLen = FuncDeclaration::genCfunc(fparams, Type::tsize_t, Id::aaLen);\n             TypeFunction *tf = fd_aaLen->type->toTypeFunction();\n             tf->purity = PUREconst;\n@@ -5821,7 +5821,7 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n                         }\n \n                         (*newparams)[j] = new Parameter(\n-                                stc, narg->type, narg->ident, narg->defaultArg);\n+                                stc, narg->type, narg->ident, narg->defaultArg, narg->userAttribDecl);\n                     }\n                     fparam->type = new TypeTuple(newparams);\n                 }\n@@ -9098,7 +9098,7 @@ TypeTuple::TypeTuple(Expressions *exps)\n         {   Expression *e = (*exps)[i];\n             if (e->type->ty == Ttuple)\n                 e->error(\"cannot form tuple of tuples\");\n-            Parameter *arg = new Parameter(STCundefined, e->type, NULL, NULL);\n+            Parameter *arg = new Parameter(STCundefined, e->type, NULL, NULL, NULL);\n             (*arguments)[i] = arg;\n         }\n     }\n@@ -9124,15 +9124,15 @@ TypeTuple::TypeTuple(Type *t1)\n     : Type(Ttuple)\n {\n     arguments = new Parameters();\n-    arguments->push(new Parameter(0, t1, NULL, NULL));\n+    arguments->push(new Parameter(0, t1, NULL, NULL, NULL));\n }\n \n TypeTuple::TypeTuple(Type *t1, Type *t2)\n     : Type(Ttuple)\n {\n     arguments = new Parameters();\n-    arguments->push(new Parameter(0, t1, NULL, NULL));\n-    arguments->push(new Parameter(0, t2, NULL, NULL));\n+    arguments->push(new Parameter(0, t1, NULL, NULL, NULL));\n+    arguments->push(new Parameter(0, t2, NULL, NULL, NULL));\n }\n \n const char *TypeTuple::kind()\n@@ -9436,25 +9436,29 @@ size_t ParameterList::length()\n \n /***************************** Parameter *****************************/\n \n-Parameter::Parameter(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg)\n+Parameter::Parameter(StorageClass storageClass, Type *type, Identifier *ident,\n+                     Expression *defaultArg, UserAttributeDeclaration *userAttribDecl)\n {\n     this->type = type;\n     this->ident = ident;\n     this->storageClass = storageClass;\n     this->defaultArg = defaultArg;\n+    this->userAttribDecl = userAttribDecl;\n }\n \n-Parameter *Parameter::create(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg)\n+Parameter *Parameter::create(StorageClass storageClass, Type *type, Identifier *ident,\n+                             Expression *defaultArg, UserAttributeDeclaration *userAttribDecl)\n {\n-    return new Parameter(storageClass, type, ident, defaultArg);\n+    return new Parameter(storageClass, type, ident, defaultArg, userAttribDecl);\n }\n \n Parameter *Parameter::syntaxCopy()\n {\n     return new Parameter(storageClass,\n         type ? type->syntaxCopy() : NULL,\n         ident,\n-        defaultArg ? defaultArg->syntaxCopy() : NULL);\n+        defaultArg ? defaultArg->syntaxCopy() : NULL,\n+        userAttribDecl ? (UserAttributeDeclaration *) userAttribDecl->syntaxCopy(NULL) : NULL);\n }\n \n Parameters *Parameter::arraySyntaxCopy(Parameters *parameters)"}, {"sha": "28dba1c250ae46bc8960ed6281ee032bea57282d", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -623,9 +623,12 @@ class Parameter : public ASTNode\n     Type *type;\n     Identifier *ident;\n     Expression *defaultArg;\n+    UserAttributeDeclaration *userAttribDecl;   // user defined attributes\n \n-    Parameter(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg);\n-    static Parameter *create(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg);\n+    Parameter(StorageClass storageClass, Type *type, Identifier *ident,\n+              Expression *defaultArg, UserAttributeDeclaration *userAttribDecl);\n+    static Parameter *create(StorageClass storageClass, Type *type, Identifier *ident,\n+                             Expression *defaultArg, UserAttributeDeclaration *userAttribDecl);\n     Parameter *syntaxCopy();\n     Type *isLazyArray();\n     // kludge for template.isType()"}, {"sha": "e414a4d69c0722696e329c7380a92aa5924909fe", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 97, "deletions": 16, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -1110,7 +1110,7 @@ StorageClass Parser::parsePostfix(StorageClass storageClass, Expressions **pudas\n                         // Disallow:\n                         //      void function() @uda fp;\n                         //      () @uda { return 1; }\n-                        error(\"user defined attributes cannot appear as postfixes\");\n+                        error(\"user-defined attributes cannot appear as postfixes\");\n                     }\n                     continue;\n                 }\n@@ -1979,9 +1979,11 @@ Parameters *Parser::parseParameters(VarArg *pvarargs, TemplateParameters **tpl)\n         StorageClass storageClass = 0;\n         StorageClass stc;\n         Expression *ae;\n+        Expressions *udas = NULL;\n \n         for (;1; nextToken())\n         {\n+        L3:\n             switch (token.value)\n             {\n                 case TOKrparen:\n@@ -2016,6 +2018,28 @@ Parameters *Parser::parseParameters(VarArg *pvarargs, TemplateParameters **tpl)\n                     stc = STCwild;\n                     goto L2;\n \n+                case TOKat:\n+                {\n+                    Expressions *exps = NULL;\n+                    StorageClass stc2 = parseAttribute(&exps);\n+                    if (stc2 == STCproperty || stc2 == STCnogc ||\n+                        stc2 == STCdisable || stc2 == STCsafe ||\n+                        stc2 == STCtrusted || stc2 == STCsystem)\n+                    {\n+                        error(\"`@%s` attribute for function parameter is not supported\", token.toChars());\n+                    }\n+                    else\n+                    {\n+                        udas = UserAttributeDeclaration::concat(udas, exps);\n+                    }\n+                    if (token.value == TOKdotdotdot)\n+                        error(\"variadic parameter cannot have user-defined attributes\");\n+                    if (stc2)\n+                        nextToken();\n+                    goto L3;\n+                    // Don't call nextToken again.\n+                }\n+\n                 case TOKin:        stc = STCin;         goto L2;\n                 case TOKout:       stc = STCout;        goto L2;\n                 case TOKref:       stc = STCref;        goto L2;\n@@ -2068,6 +2092,30 @@ Parameters *Parser::parseParameters(VarArg *pvarargs, TemplateParameters **tpl)\n                             error(\"default argument expected for %s\",\n                                     ai ? ai->toChars() : at->toChars());\n                     }\n+                    Parameter *param = new Parameter(storageClass, at, ai, ae, NULL);\n+                    if (udas)\n+                    {\n+                        Dsymbols *a = new Dsymbols();\n+                        UserAttributeDeclaration *udad = new UserAttributeDeclaration(udas, a);\n+                        param->userAttribDecl = udad;\n+                    }\n+                    if (token.value == TOKat)\n+                    {\n+                        Expressions *exps = NULL;\n+                        StorageClass stc2 = parseAttribute(&exps);\n+                        if (stc2 == STCproperty || stc2 == STCnogc ||\n+                            stc2 == STCdisable || stc2 == STCsafe ||\n+                            stc2 == STCtrusted || stc2 == STCsystem)\n+                        {\n+                            error(\"`@%s` attribute for function parameter is not supported\", token.toChars());\n+                        }\n+                        else\n+                        {\n+                            error(\"user-defined attributes cannot appear as postfixes\", token.toChars());\n+                        }\n+                        if (stc2)\n+                            nextToken();\n+                    }\n                     if (token.value == TOKdotdotdot)\n                     {   /* This is:\n                          *      at ai ...\n@@ -2076,11 +2124,11 @@ Parameters *Parser::parseParameters(VarArg *pvarargs, TemplateParameters **tpl)\n                         if (storageClass & (STCout | STCref))\n                             error(\"variadic argument cannot be out or ref\");\n                         varargs = VARARGtypesafe;\n-                        parameters->push(new Parameter(storageClass, at, ai, ae));\n+                        parameters->push(param);\n                         nextToken();\n                         break;\n                     }\n-                    parameters->push(new Parameter(storageClass, at, ai, ae));\n+                    parameters->push(param);\n                     if (token.value == TOKcomma)\n                     {   nextToken();\n                         goto L1;\n@@ -3779,6 +3827,21 @@ Dsymbols *Parser::parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, con\n                     tpl = parseTemplateParameterList();\n                 check(TOKassign);\n \n+                bool hasParsedAttributes = false;\n+                if (token.value == TOKat)\n+                {\n+                    if (!hasParsedAttributes)\n+                    {\n+                        hasParsedAttributes = true;\n+                        storage_class = STCundefined;\n+                        link = linkage;\n+                        setAlignment = false;\n+                        ealign = NULL;\n+                        udas = NULL;\n+                        parseStorageClasses(storage_class, link, setAlignment, ealign, udas);\n+                    }\n+                }\n+\n                 Declaration *v;\n                 if (token.value == TOKfunction ||\n                     token.value == TOKdelegate ||\n@@ -3796,21 +3859,39 @@ Dsymbols *Parser::parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, con\n                     // identifier => expression\n \n                     Dsymbol *s = parseFunctionLiteral();\n+\n+                    if (udas != NULL)\n+                    {\n+                        if (storage_class != 0)\n+                            error(\"Cannot put a storage-class in an alias declaration.\");\n+                        // shouldn't have set these variables\n+                        assert(link == linkage && !setAlignment && ealign == NULL);\n+                        TemplateDeclaration *tpl_ = (TemplateDeclaration *) s;\n+                        assert(tpl_ != NULL && tpl_->members->length == 1);\n+                        FuncLiteralDeclaration *fd = (FuncLiteralDeclaration *) (*tpl_->members)[0];\n+                        TypeFunction *tf = (TypeFunction *) fd->type;\n+                        assert(tf->parameterList.length() > 0);\n+                        Dsymbols *as = new Dsymbols();\n+                        (*tf->parameterList.parameters)[0]->userAttribDecl = new UserAttributeDeclaration(udas, as);\n+                    }\n                     v = new AliasDeclaration(loc, ident, s);\n                 }\n                 else\n                 {\n                     // StorageClasses type\n-\n-                    storage_class = STCundefined;\n-                    link = linkage;\n-                    setAlignment = false;\n-                    ealign = NULL;\n-                    udas = NULL;\n-                    parseStorageClasses(storage_class, link, setAlignment, ealign, udas);\n+                    if (!hasParsedAttributes)\n+                    {\n+                        hasParsedAttributes = true;\n+                        storage_class = STCundefined;\n+                        link = linkage;\n+                        setAlignment = false;\n+                        ealign = NULL;\n+                        udas = NULL;\n+                        parseStorageClasses(storage_class, link, setAlignment, ealign, udas);\n+                    }\n \n                     if (udas)\n-                        error(\"user defined attributes not allowed for %s declarations\", Token::toChars(tok));\n+                        error(\"user-defined attributes not allowed for %s declarations\", Token::toChars(tok));\n \n                     t = parseType();\n                     v = new AliasDeclaration(loc, ident, t);\n@@ -3991,7 +4072,7 @@ Dsymbols *Parser::parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, con\n              */\n \n             if (udas)\n-                error(\"user defined attributes not allowed for %s declarations\", Token::toChars(tok));\n+                error(\"user-defined attributes not allowed for %s declarations\", Token::toChars(tok));\n \n             if (token.value == TOKassign)\n             {\n@@ -4221,7 +4302,7 @@ Dsymbol *Parser::parseFunctionLiteral()\n             parameters = new Parameters();\n             Identifier *id = Identifier::generateId(\"__T\");\n             Type *t = new TypeIdentifier(loc, id);\n-            parameters->push(new Parameter(0, t, token.ident, NULL));\n+            parameters->push(new Parameter(0, t, token.ident, NULL, NULL));\n \n             tpl = new TemplateParameters();\n             TemplateParameter *tp = new TemplateTypeParameter(loc, id, NULL, NULL);\n@@ -4811,7 +4892,7 @@ Statement *Parser::parseForeach(Loc loc, bool *isRange, bool isDecl)\n         if (!ai)\n             error(\"no identifier for declarator %s\", at->toChars());\n       Larg:\n-        Parameter *p = new Parameter(storageClass, at, ai, NULL);\n+        Parameter *p = new Parameter(storageClass, at, ai, NULL, NULL);\n         parameters->push(p);\n         if (token.value == TOKcomma)\n         {   nextToken();\n@@ -5335,14 +5416,14 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n                 Type *at = NULL;        // infer parameter type\n                 nextToken();\n                 check(TOKassign);\n-                param = new Parameter(storageClass, at, ai, NULL);\n+                param = new Parameter(storageClass, at, ai, NULL, NULL);\n             }\n             else if (isDeclaration(&token, 2, TOKassign, NULL))\n             {\n                 Identifier *ai;\n                 Type *at = parseType(&ai);\n                 check(TOKassign);\n-                param = new Parameter(storageClass, at, ai, NULL);\n+                param = new Parameter(storageClass, at, ai, NULL, NULL);\n             }\n \n             condition = parseExpression();"}, {"sha": "2fe0d9efeea51f7cdf5356c14fff5989e876c4f4", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -1494,7 +1494,7 @@ class StatementSemanticVisitor : public Visitor\n                             s = new ExpStatement(Loc(), v);\n                             fs->_body = new CompoundStatement(loc, s, fs->_body);\n                         }\n-                        params->push(new Parameter(stc, p->type, id, NULL));\n+                        params->push(new Parameter(stc, p->type, id, NULL, NULL));\n                     }\n                     // Bugzilla 13840: Throwable nested function inside nothrow function is acceptable.\n                     StorageClass stc = mergeFuncAttrs(STCsafe | STCpure | STCnogc, fs->func);\n@@ -1570,15 +1570,15 @@ class StatementSemanticVisitor : public Visitor\n                         if (!fdapply[i])\n                         {\n                             params = new Parameters();\n-                            params->push(new Parameter(0, Type::tvoid->pointerTo(), NULL, NULL));\n-                            params->push(new Parameter(STCin, Type::tsize_t, NULL, NULL));\n+                            params->push(new Parameter(0, Type::tvoid->pointerTo(), NULL, NULL, NULL));\n+                            params->push(new Parameter(STCin, Type::tsize_t, NULL, NULL, NULL));\n                             Parameters* dgparams = new Parameters;\n-                            dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n+                            dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL, NULL));\n                             if (dim == 2)\n-                                dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n+                                dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL, NULL));\n                             fldeTy[i] = new TypeDelegate(new TypeFunction(ParameterList(dgparams),\n                                                                           Type::tint32, LINKd));\n-                            params->push(new Parameter(0, fldeTy[i], NULL, NULL));\n+                            params->push(new Parameter(0, fldeTy[i], NULL, NULL, NULL));\n                             fdapply[i] = FuncDeclaration::genCfunc(params, Type::tint32, name[i]);\n                         }\n \n@@ -1637,14 +1637,14 @@ class StatementSemanticVisitor : public Visitor\n                         FuncDeclaration *fdapply;\n                         TypeDelegate *dgty;\n                         params = new Parameters();\n-                        params->push(new Parameter(STCin, tn->arrayOf(), NULL, NULL));\n+                        params->push(new Parameter(STCin, tn->arrayOf(), NULL, NULL, NULL));\n                         Parameters* dgparams = new Parameters;\n-                        dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n+                        dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL, NULL));\n                         if (dim == 2)\n-                            dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n+                            dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL, NULL));\n                         dgty = new TypeDelegate(new TypeFunction(ParameterList(dgparams),\n                                                                  Type::tint32, LINKd));\n-                        params->push(new Parameter(0, dgty, NULL, NULL));\n+                        params->push(new Parameter(0, dgty, NULL, NULL, NULL));\n                         fdapply = FuncDeclaration::genCfunc(params, Type::tint32, fdname);\n \n                         if (tab->ty == Tsarray)\n@@ -3192,7 +3192,7 @@ class StatementSemanticVisitor : public Visitor\n             cs->push(new ExpStatement(ss->loc, tmp));\n \n             Parameters* args = new Parameters;\n-            args->push(new Parameter(0, ClassDeclaration::object->type, NULL, NULL));\n+            args->push(new Parameter(0, ClassDeclaration::object->type, NULL, NULL, NULL));\n \n             FuncDeclaration *fdenter = FuncDeclaration::genCfunc(args, Type::tvoid, Id::monitorenter);\n             Expression *e = new CallExp(ss->loc, new VarExp(ss->loc, fdenter, false), new VarExp(ss->loc, tmp));\n@@ -3234,7 +3234,7 @@ class StatementSemanticVisitor : public Visitor\n             cs->push(new ExpStatement(ss->loc, v));\n \n             Parameters* args = new Parameters;\n-            args->push(new Parameter(0, t->pointerTo(), NULL, NULL));\n+            args->push(new Parameter(0, t->pointerTo(), NULL, NULL, NULL));\n \n             FuncDeclaration *fdenter = FuncDeclaration::genCfunc(args, Type::tvoid, Id::criticalenter, STCnothrow);\n             Expression *e = new AddrExp(ss->loc, tmpExp);"}, {"sha": "2f00c8837068454fdb669686c724eb52bd8b2175", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -658,7 +658,8 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n     if (e->ident != Id::compiles &&\n         e->ident != Id::isSame &&\n         e->ident != Id::identifier &&\n-        e->ident != Id::getProtection && e->ident != Id::getVisibility)\n+        e->ident != Id::getProtection && e->ident != Id::getVisibility &&\n+        e->ident != Id::getAttributes)\n     {\n         // Pretend we're in a deprecated scope so that deprecation messages\n         // aren't triggered when checking if a symbol is deprecated\n@@ -905,8 +906,12 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         Identifier *id = NULL;\n         if (Parameter *po = isParameter(o))\n         {\n+            if (!po->ident)\n+            {\n+                e->error(\"argument `%s` has no identifier\", po->type->toChars());\n+                return new ErrorExp();\n+            }\n             id = po->ident;\n-            assert(id);\n         }\n         else\n         {\n@@ -1245,23 +1250,39 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n     }\n     else if (e->ident == Id::getAttributes)\n     {\n+        /* Specify 0 for bit 0 of the flags argument to semanticTiargs() so that\n+         * a symbol should not be folded to a constant.\n+         * Bit 1 means don't convert Parameter to Type if Parameter has an identifier\n+         */\n+        if (!TemplateInstance::semanticTiargs(e->loc, sc, e->args, 3))\n+            return new ErrorExp();\n+\n         if (dim != 1)\n             return dimError(e, 1, dim);\n \n         RootObject *o = (*e->args)[0];\n+        Parameter *po = isParameter(o);\n         Dsymbol *s = getDsymbolWithoutExpCtx(o);\n-        if (!s)\n+        UserAttributeDeclaration *udad = NULL;\n+        if (po)\n         {\n-            e->error(\"first argument is not a symbol\");\n-            return new ErrorExp();\n+            udad = po->userAttribDecl;\n         }\n-        if (Import *imp = s->isImport())\n+        else if (s)\n         {\n-            s = imp->mod;\n+            if (Import *imp = s->isImport())\n+            {\n+                s = imp->mod;\n+            }\n+            //printf(\"getAttributes %s, attrs = %p, scope = %p\\n\", s->toChars(), s->userAttribDecl, s->_scope);\n+            udad = s->userAttribDecl;\n+        }\n+        else\n+        {\n+            e->error(\"first argument is not a symbol\");\n+            return new ErrorExp();\n         }\n \n-        //printf(\"getAttributes %s, attrs = %p, scope = %p\\n\", s->toChars(), s->userAttribDecl, s->_scope);\n-        UserAttributeDeclaration *udad = s->userAttribDecl;\n         Expressions *exps = udad ? udad->getAttributes() : new Expressions();\n         TupleExp *tup = new TupleExp(e->loc, exps);\n         return semantic(tup, sc);"}, {"sha": "d8221eb882a430aee441a58abfb16127b30d2c3a", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/header1.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -519,3 +519,21 @@ struct Foo3A(T)\n     @disable this(this);\n     @disable this();\n }\n+\n+void test13x(@(10) int a, @(20) int, @(30) @(40) int[] arr...) {}\n+\n+enum Test14UDA1;\n+struct Test14UDA2\n+{\n+    string str;\n+}\n+\n+Test14UDA2 test14uda3(string name)\n+{\n+    return Test14UDA2(name);\n+}\n+struct Test14UDA4(string v){}\n+\n+void test14x(@Test14UDA1 int, @Test14UDA2(\"1\") int, @test14uda3(\"2\") int, @Test14UDA4!\"3\" int) {}\n+\n+void test15x(@(20) void delegate(int) @safe dg){}"}, {"sha": "5ee94868993f55b2da314653c0fcd219871dbdc7", "filename": "gcc/testsuite/gdc.test/compilable/testheaderudamodule.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestheaderudamodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestheaderudamodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestheaderudamodule.d?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -11,3 +11,5 @@ struct UDA\n }\n \n void main() {}\n+\n+void foo(@(1) int bar, @UDA(2) string bebe);"}, {"sha": "3f09a27541a9b9d5524760d547a2b3d53a63b028", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10207.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10207.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10207.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10207.d?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10207.d(7): Error: user defined attributes not allowed for `alias` declarations\n+fail_compilation/fail10207.d(7): Error: user-defined attributes not allowed for `alias` declarations\n ---\n */\n alias @Safe int __externC;"}, {"sha": "38f84e5971d67fd59cf925c3f5ef6a85a36db268", "filename": "gcc/testsuite/gdc.test/runnable/uda.d", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fuda.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dddea6d4d81cac76ff64cde178e2d5f7fe09fb55/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fuda.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fuda.d?ref=dddea6d4d81cac76ff64cde178e2d5f7fe09fb55", "patch": "@@ -467,6 +467,193 @@ static assert(__traits(getAttributes, FileData11844.member)[0](new FileData11844\n \n /************************************************/\n \n+template AliasSeq(T...)\n+{\n+    alias AliasSeq = T;\n+}\n+\n+template ParameterUDA(size_t p_num, func...)\n+if (func.length == 1 && is(typeof(func[0]) PT == __parameters) && PT.length > p_num)\n+{\n+    static if (is(typeof(func[0]) PT == __parameters))\n+    {\n+        template Get(size_t i)\n+        {\n+            static if (//!isFunctionPointer!func && !isDelegate!func\n+                       // Parameters without UDA may yield CT error.\n+                       /*&&*/ is(typeof(__traits(getAttributes, PT[i..i+1]))x))\n+            {\n+                alias Get = AliasSeq!(__traits(getAttributes, PT[i..i+1]));\n+            }\n+            else\n+            {\n+                alias Get = AliasSeq!();\n+            }\n+        }\n+    }\n+    else\n+    {\n+        static assert(0, func[0].stringof ~ \"is not a function\");\n+\n+        // Define dummy entities to avoid pointless errors\n+        template Get(size_t i) { alias Get = AliasSeq!(); }\n+        alias PT = AliasSeq!();\n+    }\n+\n+    alias ParameterUDA = Get!p_num;\n+}\n+\n+void test13x(@(10) int a, @(20) int, @(30) @(40) int[] arr...) {}\n+\n+void test13()\n+{\n+    static assert([ParameterUDA!(0, test13x)] == [10]);\n+    static assert([ParameterUDA!(1, test13x)] == [20]);\n+    static assert([ParameterUDA!(2, test13x)] == [30, 40]);\n+}\n+\n+template Test13t(F)\n+{\n+    static assert(!__traits(compiles, ParameterUDA!(0, F)));\n+    static assert(!__traits(compiles, ParameterUDA!(1, F)));\n+    static assert(!__traits(compiles, ParameterUDA!(2, F)));\n+    enum Test13t = true;\n+}\n+\n+alias test13t = Test13t!(typeof(test13x));\n+\n+enum Test14UDA1;\n+\n+struct Test14UDA2\n+{\n+    string str;\n+}\n+\n+Test14UDA2 test14uda3(string name)\n+{\n+    return Test14UDA2(name);\n+}\n+\n+struct Test14UDA4(string v)\n+{\n+}\n+\n+void test14x(@Test14UDA1 int, @Test14UDA2(\"1\") int, @test14uda3(\"2\") int, @Test14UDA4!\"3\" int) {}\n+void test14()\n+{\n+    static assert(is(ParameterUDA!(0, test14x)[0] == Test14UDA1));\n+    static assert(ParameterUDA!(1, test14x)[0] == Test14UDA2(\"1\"));\n+    static assert(ParameterUDA!(2, test14x)[0] == test14uda3(\"2\"));\n+    static assert(is(ParameterUDA!(3, test14x)[0] == Test14UDA4!\"3\"));\n+}\n+\n+void test15x(@(20) void delegate(int) @safe dg)\n+{\n+    static assert([__traits(getAttributes, dg)] == [20]);\n+    static assert(is(typeof(dg) == void delegate(int) @safe));\n+}\n+\n+template MinimalFunctionTypeOf(func...)\n+if (func.length == 1)\n+{\n+    static if (is(func[0] T) || is(typeof(func[0]) T) && is(T Fdlg == delegate))\n+        alias MinimalFunctionTypeOf = Fdlg; // HIT: delegate\n+    else\n+        static assert(0);\n+}\n+\n+template Parameters(func...)\n+if (func.length == 1)\n+{\n+    static if (is(MinimalFunctionTypeOf!func P == function))\n+        alias Parameters = P;\n+    else\n+        static assert(0, \"argument has no parameters\");\n+}\n+\n+void test15y(@(20) void delegate(@Test14UDA2(\"2\") @(\"test15yUDA\") int) @safe dg)\n+{\n+    static assert([__traits(getAttributes, dg)] == [20]);\n+    static assert(is(typeof(dg) == void delegate(int) @safe));\n+    auto foo = (@(\"myUDA\") int x){\n+        static assert([__traits(getAttributes, x)] == [\"myUDA\"]);\n+    };\n+    static assert(__traits(getAttributes, Parameters!dg)[0] == Test14UDA2(\"2\"));\n+    static assert(__traits(getAttributes, Parameters!dg)[1] == \"test15yUDA\");\n+}\n+\n+void test15z()\n+{\n+    test15y((@(15) @(16) int x){\n+        static assert([__traits(getAttributes, x)] == [15, 16]);\n+    });\n+}\n+\n+void test16x(A)(@(22) A a)\n+{\n+    static assert([__traits(getAttributes, a)] == [22]);\n+}\n+\n+void test16()\n+{\n+    static assert([ParameterUDA!(0, test16x!int)] == [22]);\n+}\n+\n+void test17()\n+{\n+    void test17x(A)(@(23) A a)\n+    {\n+        static assert([__traits(getAttributes, a)] == [23]);\n+    }\n+    static assert([ParameterUDA!(0, test17x!int)] == [23]);\n+}\n+\n+void test18()\n+{\n+    void test18a(@(Tuple!(18, \"a\")) int a)\n+    {\n+        static assert(__traits(getAttributes, a) == Tuple!(18, \"a\"));\n+    }\n+    void test18b(@Tuple!(18, \"b\") int a)\n+    {\n+        static assert(__traits(getAttributes, a) == Tuple!(18, \"b\"));\n+    }\n+\n+    static assert(ParameterUDA!(0, test18a) == Tuple!(18, \"a\"));\n+    static assert(ParameterUDA!(0, test18b) == Tuple!(18, \"b\"));\n+}\n+\n+// Lambdas with parentheses:\n+void test19()\n+{\n+    // lambdas without parentheses\n+    alias test19a = @(3) b => 1 + 2;\n+    alias test19b = @(3) @(4) b => 1 + 2;\n+\n+    alias test19c = (@(3) c, @(5) d) => 1 + 2;\n+    alias test19d = (@(3) @(4) c, @(5) d) => 1 + 2;\n+    auto test19e = (@(3) int c, @(5) int d) => 1 + 2;\n+\n+    // still allow alias function declarations\n+    alias FuncType = @safe void function();\n+    alias FuncType2 = @safe nothrow void function();\n+    alias FuncType3 = nothrow void function();\n+    alias FuncType4 = nothrow @safe void function();\n+}\n+\n+void test20()\n+{\n+    // Using a delegate with inferred parameter type\n+    void test20a(int delegate(int) t){ t(1); }\n+    test20a((@(19) a) {\n+        static assert([__traits(getAttributes, a)] == [19]);\n+        return a + 2;\n+    });\n+}\n+\n+/************************************************/\n+\n+\n int main()\n {\n     test1();\n@@ -482,6 +669,13 @@ int main()\n     test11();\n     test12();\n     test9178();\n+    test13();\n+    test14();\n+    test16();\n+    test17();\n+    test18();\n+    test19();\n+    test20();\n \n     printf(\"Success\\n\");\n     return 0;"}]}