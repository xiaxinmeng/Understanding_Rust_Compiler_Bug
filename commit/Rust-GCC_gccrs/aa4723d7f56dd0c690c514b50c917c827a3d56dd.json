{"sha": "aa4723d7f56dd0c690c514b50c917c827a3d56dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0NzIzZDdmNTZkZDBjNjkwYzUxNGI1MGM5MTdjODI3YTNkNTZkZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-09T20:37:11Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-09T20:37:11Z"}, "message": "* basic-block. (profile_record): New struct, moved from passes.c.\n\n\t* cfghooks.h (struct cfg_hooks) <account_profile_record>: New hook.\n\t(account_profile_record): New prototype.\n\t* cfghooks.c (account_profile_record): New function.\n\t* tree-cfg.c (gimple_account_profile_record): New function\n\t(gimple_cfg_hooks): Add it.\n\t* cfgrtl.c (rtl_account_profile_record): New function\n\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): Add it.\n\t* passes.c (check_profile_consistency): Simplify.  Move IR-dependent\n\tcode around using cfghooks machinery.\n\nFrom-SVN: r192271", "tree": {"sha": "784313dcb1809538918556fac30dbf561f9d8332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/784313dcb1809538918556fac30dbf561f9d8332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4723d7f56dd0c690c514b50c917c827a3d56dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4723d7f56dd0c690c514b50c917c827a3d56dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4723d7f56dd0c690c514b50c917c827a3d56dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4723d7f56dd0c690c514b50c917c827a3d56dd/comments", "author": null, "committer": null, "parents": [{"sha": "ca4277584fa6e046279dd3e75fdaa53881d9eaf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4277584fa6e046279dd3e75fdaa53881d9eaf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4277584fa6e046279dd3e75fdaa53881d9eaf3"}], "stats": {"total": 250, "additions": 158, "deletions": 92}, "files": [{"sha": "e14eb1a913aff30461467710a5e803b555b962e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa4723d7f56dd0c690c514b50c917c827a3d56dd", "patch": "@@ -1,3 +1,16 @@\n+2012-10-09  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* basic-block. (profile_record): New struct, moved from passes.c.\n+\t* cfghooks.h (struct cfg_hooks) <account_profile_record>: New hook.\n+\t(account_profile_record): New prototype.\n+\t* cfghooks.c (account_profile_record): New function.\n+\t* tree-cfg.c (gimple_account_profile_record): New function\n+\t(gimple_cfg_hooks): Add it.\n+\t* cfgrtl.c (rtl_account_profile_record): New function\n+\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): Add it.\n+\t* passes.c (check_profile_consistency): Simplify.  Move IR-dependent\n+\tcode around using cfghooks machinery.\n+\n 2012-10-09  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54760"}, {"sha": "61351fb248de6a393d0176a74b2f7a501c7c6270", "filename": "gcc/basic-block.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=aa4723d7f56dd0c690c514b50c917c827a3d56dd", "patch": "@@ -101,6 +101,37 @@ typedef struct gcov_working_set_info\n   gcov_type min_counter;\n } gcov_working_set_t;\n \n+/* Structure to gather statistic about profile consistency, per pass.\n+   An array of this structure, indexed by pass static number, is allocated\n+   in passes.c.  The structure is defined here so that different CFG modes\n+   can do their book-keeping via CFG hooks.\n+\n+   For every field[2], field[0] is the count before the pass runs, and\n+   field[1] is the post-pass count.  This allows us to monitor the effect\n+   of each individual pass on the profile consistency.\n+   \n+   This structure is not supposed to be used by anything other than passes.c\n+   and one CFG hook per CFG mode.  */\n+struct profile_record\n+{\n+  /* The number of basic blocks where sum(freq) of the block's predecessors\n+     doesn't match reasonably well with the incoming frequency.  */\n+  int num_mismatched_freq_in[2];\n+  /* Likewise for a basic block's successors.  */\n+  int num_mismatched_freq_out[2];\n+  /* The number of basic blocks where sum(count) of the block's predecessors\n+     doesn't match reasonably well with the incoming frequency.  */\n+  int num_mismatched_count_in[2];\n+  /* Likewise for a basic block's successors.  */\n+  int num_mismatched_count_out[2];\n+  /* A weighted cost of the run-time of the function body.  */\n+  gcov_type time[2];\n+  /* A weighted cost of the size of the function body.  */\n+  int size[2];\n+  /* True iff this pass actually was run.  */\n+  bool run;\n+};\n+\n /* Declared in cfgloop.h.  */\n struct loop;\n "}, {"sha": "d54dd469cf4906695922f1b23d2daeade1024817", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=aa4723d7f56dd0c690c514b50c917c827a3d56dd", "patch": "@@ -1324,3 +1324,57 @@ split_block_before_cond_jump (basic_block bb)\n   return cfg_hooks->split_block_before_cond_jump (bb);\n }\n \n+/* Work-horse for passes.c:check_profile_consistency.\n+   Do book-keeping of the CFG for the profile consistency checker.\n+   If AFTER_PASS is 0, do pre-pass accounting, or if AFTER_PASS is 1\n+   then do post-pass accounting.  Store the counting in RECORD.  */\n+\n+void\n+account_profile_record (struct profile_record *record, int after_pass)\n+{\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+  int sum;\n+  gcov_type lsum;\n+\n+  FOR_ALL_BB (bb)\n+   {\n+      if (bb != EXIT_BLOCK_PTR_FOR_FUNCTION (cfun)\n+\t  && profile_status != PROFILE_ABSENT)\n+\t{\n+\t  sum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    sum += e->probability;\n+\t  if (EDGE_COUNT (bb->succs) && abs (sum - REG_BR_PROB_BASE) > 100)\n+\t    record->num_mismatched_freq_out[after_pass]++;\n+\t  lsum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    lsum += e->count;\n+\t  if (EDGE_COUNT (bb->succs)\n+\t      && (lsum - bb->count > 100 || lsum - bb->count < -100))\n+\t    record->num_mismatched_count_out[after_pass]++;\n+\t}\n+      if (bb != ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n+\t  && profile_status != PROFILE_ABSENT)\n+\t{\n+\t  sum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    sum += EDGE_FREQUENCY (e);\n+\t  if (abs (sum - bb->frequency) > 100\n+\t      || (MAX (sum, bb->frequency) > 10\n+\t\t  && abs ((sum - bb->frequency) * 100 / (MAX (sum, bb->frequency) + 1)) > 10))\n+\t    record->num_mismatched_freq_in[after_pass]++;\n+\t  lsum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    lsum += e->count;\n+\t  if (lsum - bb->count > 100 || lsum - bb->count < -100)\n+\t    record->num_mismatched_count_in[after_pass]++;\n+\t}\n+      if (bb == ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n+\t  || bb == EXIT_BLOCK_PTR_FOR_FUNCTION (cfun))\n+\tcontinue;\n+      gcc_assert (cfg_hooks->account_profile_record);\n+      cfg_hooks->account_profile_record(bb, after_pass, record);\n+   }\n+}"}, {"sha": "2806c4f27c50bba69364c57c1a883b91fc24cca8", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=aa4723d7f56dd0c690c514b50c917c827a3d56dd", "patch": "@@ -145,6 +145,9 @@ struct cfg_hooks\n   /* Split a basic block if it ends with a conditional branch and if\n      the other part of the block is not empty.  */\n   basic_block (*split_block_before_cond_jump) (basic_block);\n+\n+  /* Do book-keeping of a basic block for the profile consistency checker.  */\n+  void (*account_profile_record) (basic_block, int, struct profile_record *);\n };\n \n extern void verify_flow_info (void);\n@@ -198,6 +201,8 @@ extern void copy_bbs (basic_block *, unsigned, basic_block *,\n \t\t      edge *, unsigned, edge *, struct loop *,\n \t\t      basic_block);\n \n+void account_profile_record (struct profile_record *, int);\n+\n extern void cfg_layout_initialize (unsigned int);\n extern void cfg_layout_finalize (void);\n "}, {"sha": "1b578d7feeb31fbbe06b4d056e7b7ccdd5798619", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=aa4723d7f56dd0c690c514b50c917c827a3d56dd", "patch": "@@ -4452,6 +4452,28 @@ rtl_duplicate_bb (basic_block bb)\n   return bb;\n }\n \n+/* Do book-keeping of basic block BB for the profile consistency checker.\n+   If AFTER_PASS is 0, do pre-pass accounting, or if AFTER_PASS is 1\n+   then do post-pass accounting.  Store the counting in RECORD.  */\n+static void\n+rtl_account_profile_record (basic_block bb, int after_pass,\n+\t\t\t    struct profile_record *record)\n+{\n+  rtx insn;\n+  FOR_BB_INSNS (bb, insn)\n+    if (INSN_P (insn))\n+      {\n+\trecord->size[after_pass]\n+\t  += insn_rtx_cost (PATTERN (insn), false);\n+\tif (profile_status == PROFILE_READ)\n+\t  record->time[after_pass]\n+\t    += insn_rtx_cost (PATTERN (insn), true) * bb->count;\n+\telse if (profile_status == PROFILE_GUESSED)\n+\t  record->time[after_pass]\n+\t    += insn_rtx_cost (PATTERN (insn), true) * bb->frequency;\n+      }\n+}\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   \"rtl\",\n@@ -4486,6 +4508,7 @@ struct cfg_hooks rtl_cfg_hooks = {\n   NULL, /* flush_pending_stmts */\n   rtl_block_empty_p, /* block_empty_p */\n   rtl_split_block_before_cond_jump, /* split_block_before_cond_jump */\n+  rtl_account_profile_record,\n };\n \n /* Implementation of CFG manipulation for cfg layout RTL, where\n@@ -4526,6 +4549,7 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   NULL, /* flush_pending_stmts */  \n   rtl_block_empty_p, /* block_empty_p */\n   rtl_split_block_before_cond_jump, /* split_block_before_cond_jump */\n+  rtl_account_profile_record,\n };\n \n #include \"gt-cfgrtl.h\""}, {"sha": "7a3d204e0d337da85c71d74010e44098c21ba14a", "filename": "gcc/passes.c", "status": "modified", "additions": 6, "deletions": 92, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=aa4723d7f56dd0c690c514b50c917c827a3d56dd", "patch": "@@ -1778,30 +1778,16 @@ execute_function_dump (void *data ATTRIBUTE_UNUSED)\n     }\n }\n \n-/* Make statistic about profile consistency.  */\n-\n-struct profile_record\n-{\n-  int num_mismatched_freq_in[2];\n-  int num_mismatched_freq_out[2];\n-  int num_mismatched_count_in[2];\n-  int num_mismatched_count_out[2];\n-  bool run;\n-  gcov_type time[2];\n-  int size[2];\n-};\n-\n static struct profile_record *profile_record;\n \n+/* Do profile consistency book-keeping for the pass with static number INDEX.\n+   If SUBPASS is zero, we run _before_ the pass, and if SUBPASS is one, then\n+   we run _after_ the pass.  RUN is true if the pass really runs, or FALSE\n+   if we are only book-keeping on passes that may have selectively disabled\n+   themselves on a given function.  */\n static void\n check_profile_consistency (int index, int subpass, bool run)\n {\n-  basic_block bb;\n-  edge_iterator ei;\n-  edge e;\n-  int sum;\n-  gcov_type lsum;\n-\n   if (index == -1)\n     return;\n   if (!profile_record)\n@@ -1810,79 +1796,7 @@ check_profile_consistency (int index, int subpass, bool run)\n   gcc_assert (index < passes_by_id_size && index >= 0);\n   gcc_assert (subpass < 2);\n   profile_record[index].run |= run;\n-\n-  FOR_ALL_BB (bb)\n-   {\n-      if (bb != EXIT_BLOCK_PTR_FOR_FUNCTION (cfun)\n-\t  && profile_status != PROFILE_ABSENT)\n-\t{\n-\t  sum = 0;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    sum += e->probability;\n-\t  if (EDGE_COUNT (bb->succs) && abs (sum - REG_BR_PROB_BASE) > 100)\n-\t    profile_record[index].num_mismatched_freq_out[subpass]++;\n-\t  lsum = 0;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    lsum += e->count;\n-\t  if (EDGE_COUNT (bb->succs)\n-\t      && (lsum - bb->count > 100 || lsum - bb->count < -100))\n-\t    profile_record[index].num_mismatched_count_out[subpass]++;\n-\t}\n-      if (bb != ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n-\t  && profile_status != PROFILE_ABSENT)\n-\t{\n-\t  sum = 0;\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    sum += EDGE_FREQUENCY (e);\n-\t  if (abs (sum - bb->frequency) > 100\n-\t      || (MAX (sum, bb->frequency) > 10\n-\t\t  && abs ((sum - bb->frequency) * 100 / (MAX (sum, bb->frequency) + 1)) > 10))\n-\t    profile_record[index].num_mismatched_freq_in[subpass]++;\n-\t  lsum = 0;\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    lsum += e->count;\n-\t  if (lsum - bb->count > 100 || lsum - bb->count < -100)\n-\t    profile_record[index].num_mismatched_count_in[subpass]++;\n-\t}\n-      if (bb == ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n-\t  || bb == EXIT_BLOCK_PTR_FOR_FUNCTION (cfun))\n-\tcontinue;\n-      if ((cfun && (cfun->curr_properties & PROP_trees)))\n-\t{\n-\t  gimple_stmt_iterator i;\n-\n-\t  for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n-\t    {\n-\t      profile_record[index].size[subpass]\n-\t\t += estimate_num_insns (gsi_stmt (i), &eni_size_weights);\n-\t      if (profile_status == PROFILE_READ)\n-\t\tprofile_record[index].time[subpass]\n-\t\t   += estimate_num_insns (gsi_stmt (i),\n-\t\t\t\t\t  &eni_time_weights) * bb->count;\n-\t      else if (profile_status == PROFILE_GUESSED)\n-\t\tprofile_record[index].time[subpass]\n-\t\t   += estimate_num_insns (gsi_stmt (i),\n-\t\t\t\t\t  &eni_time_weights) * bb->frequency;\n-\t    }\n-\t}\n-      else if (cfun && (cfun->curr_properties & PROP_rtl))\n-\t{\n-\t  rtx insn;\n-\t  for (insn = NEXT_INSN (BB_HEAD (bb)); insn && insn != NEXT_INSN (BB_END (bb));\n-\t       insn = NEXT_INSN (insn))\n-\t    if (INSN_P (insn))\n-\t      {\n-\t\tprofile_record[index].size[subpass]\n-\t\t   += insn_rtx_cost (PATTERN (insn), false);\n-\t\tif (profile_status == PROFILE_READ)\n-\t\t  profile_record[index].time[subpass]\n-\t\t     += insn_rtx_cost (PATTERN (insn), true) * bb->count;\n-\t\telse if (profile_status == PROFILE_GUESSED)\n-\t\t  profile_record[index].time[subpass]\n-\t\t     += insn_rtx_cost (PATTERN (insn), true) * bb->frequency;\n-\t      }\n-\t}\n-   }\n+  account_profile_record (&profile_record[index], subpass);\n }\n \n /* Output profile consistency.  */"}, {"sha": "7fc5a534dc7cdf67726d3cbb73a2558d6214e508", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4723d7f56dd0c690c514b50c917c827a3d56dd/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=aa4723d7f56dd0c690c514b50c917c827a3d56dd", "patch": "@@ -7591,6 +7591,30 @@ gimple_lv_add_condition_to_bb (basic_block first_head ATTRIBUTE_UNUSED,\n   e0->flags |= EDGE_FALSE_VALUE;\n }\n \n+\n+/* Do book-keeping of basic block BB for the profile consistency checker.\n+   If AFTER_PASS is 0, do pre-pass accounting, or if AFTER_PASS is 1\n+   then do post-pass accounting.  Store the counting in RECORD.  */\n+static void\n+gimple_account_profile_record (basic_block bb, int after_pass,\n+\t\t\t       struct profile_record *record)\n+{\n+  gimple_stmt_iterator i;\n+  for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+    {\n+      record->size[after_pass]\n+\t+= estimate_num_insns (gsi_stmt (i), &eni_size_weights);\n+      if (profile_status == PROFILE_READ)\n+\trecord->time[after_pass]\n+\t  += estimate_num_insns (gsi_stmt (i),\n+\t\t\t\t &eni_time_weights) * bb->count;\n+      else if (profile_status == PROFILE_GUESSED)\n+\trecord->time[after_pass]\n+\t  += estimate_num_insns (gsi_stmt (i),\n+\t\t\t\t &eni_time_weights) * bb->frequency;\n+    }\n+}\n+\n struct cfg_hooks gimple_cfg_hooks = {\n   \"gimple\",\n   gimple_verify_flow_info,\n@@ -7624,6 +7648,7 @@ struct cfg_hooks gimple_cfg_hooks = {\n   flush_pending_stmts, \t\t/* flush_pending_stmts */  \n   gimple_empty_block_p,           /* block_empty_p */\n   gimple_split_block_before_cond_jump, /* split_block_before_cond_jump */\n+  gimple_account_profile_record,\n };\n \n "}]}