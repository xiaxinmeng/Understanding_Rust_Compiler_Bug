{"sha": "e0d0c8a1628270591d59529020231a0bcbbd3347", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkMGM4YTE2MjgyNzA1OTFkNTk1MjkwMjAyMzFhMGJjYmJkMzM0Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:57:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:57:44Z"}, "message": "(__objc_runtime_mutex): Eliminate leading underscore from name of objc\nmutex and thread structures.\n\nFrom-SVN: r13598", "tree": {"sha": "b0ce179afe2c51d0381f688f6ac3d2e743447c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0ce179afe2c51d0381f688f6ac3d2e743447c8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0d0c8a1628270591d59529020231a0bcbbd3347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d0c8a1628270591d59529020231a0bcbbd3347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0d0c8a1628270591d59529020231a0bcbbd3347", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d0c8a1628270591d59529020231a0bcbbd3347/comments", "author": null, "committer": null, "parents": [{"sha": "47a84c97bf074ddbf8299e2bc05e71d2b4edd54d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a84c97bf074ddbf8299e2bc05e71d2b4edd54d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a84c97bf074ddbf8299e2bc05e71d2b4edd54d"}], "stats": {"total": 228, "additions": 114, "deletions": 114}, "files": [{"sha": "b95f38b9fe10d5c1ede03e4ef9773cb646f70e0a", "filename": "gcc/objc/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Finit.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -40,7 +40,7 @@ static struct objc_list* unclaimed_proto_list = 0; \t/* !T:MUTEX */\n static struct objc_list *uninitialized_statics = 0; \t/* !T:MUTEX */\n \n /* Global runtime \"write\" mutex. */\n-_objc_mutex_t __objc_runtime_mutex;\n+objc_mutex_t __objc_runtime_mutex;\n \n /* Number of threads that are alive. */\n int __objc_runtime_threads_alive = 1;\t\t\t/* !T:MUTEX */"}, {"sha": "742e469b1262a7bc82ff59f6cd49c3cd9b8143c2", "filename": "gcc/objc/runtime.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fruntime.h?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -63,7 +63,7 @@ extern BOOL __objc_class_links_resolved;\n extern int __objc_selector_max_index;\n \n /* Mutex locking __objc_selector_max_index and its arrays. */\n-extern _objc_mutex_t __objc_runtime_mutex;\n+extern objc_mutex_t __objc_runtime_mutex;\n \n /* Number of threads which are alive. */\n extern int __objc_runtime_threads_alive;"}, {"sha": "fa432aa28cb5c2cd47175992b5a9535a3436d194", "filename": "gcc/objc/thr-decosf1.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-decosf1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-decosf1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-decosf1.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Interface\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n \n This file is part of GNU CC.\n@@ -34,9 +34,9 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile objc_thread_t      owner;          /* Id of thread that owns.  */\n     volatile int                depth;          /* # of acquires.           */\n     pthread_mutex_t             lock;           /* pthread mutex.           */\n };\n@@ -72,18 +72,18 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n-    _objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n+    objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n     pthread_t           new_thread_handle;      /* DCE thread handle.       */\n \n     objc_mutex_lock(__objc_runtime_mutex);\n     \n     if (pthread_create(&new_thread_handle, pthread_attr_default,\n                        (void *)func, arg) == 0) {\n       /* ??? May not work! (64bit)*/\n-        thread_id = *(_objc_thread_t *)&new_thread_handle; \n+        thread_id = *(objc_thread_t *)&new_thread_handle; \n         pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n \t__objc_runtime_threads_alive++;\n     }\n@@ -167,12 +167,12 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  -1 which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n   pthread_t self = pthread_self();\n \n-  return (_objc_thread_t) pthread_getuniqe_np (&self);\n+  return (objc_thread_t) pthread_getuniqe_np (&self);\n }\n \n /********\n@@ -205,13 +205,13 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n  *  the allocation fails for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    _objc_mutex_t mutex;\n+    objc_mutex_t mutex;\n     int         err = 0;\n     \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n     \n     err = pthread_mutex_init(&mutex->lock, pthread_mutexattr_default);\n@@ -220,7 +220,7 @@ objc_mutex_allocate(void)\n         objc_free(mutex);                       /* Yes, free local memory.  */\n         return NULL;                            /* Abort.                   */\n     }\n-    mutex->owner = (_objc_thread_t) -1;         /* No owner.                */\n+    mutex->owner = (objc_thread_t) -1;         /* No owner.                */\n     mutex->depth = 0;                           /* No locks.                */\n     return mutex;                               /* Return mutex handle.     */\n }\n@@ -233,7 +233,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -255,9 +255,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t thread_id;                   /* Cache our thread id.     */\n+    objc_thread_t thread_id;                   /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -278,9 +278,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t thread_id;                   /* Cache our thread id.     */\n+    objc_thread_t thread_id;                   /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -303,9 +303,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t thread_id;                   /* Cache our thread id.     */\n+    objc_thread_t thread_id;                   /* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -315,7 +315,7 @@ objc_mutex_unlock(_objc_mutex_t mutex)\n     if (mutex->depth > 1)                       /* Released last lock?      */\n         return --mutex->depth;                  /* No, Decrement depth, end.*/\n     mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = (_objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n+    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n     \n     if (pthread_mutex_unlock(&mutex->lock) != 0)  /* Unlock system mutex.   */\n         return -1;                              /* Failed, abort.           */"}, {"sha": "6ea883e257c8edccc1fe074fa8f19fff7d6fbc63", "filename": "gcc/objc/thr-irix.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-irix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-irix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-irix.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Interface - SGI IRIX Implementation\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n \n This file is part of GNU CC.\n@@ -38,9 +38,9 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n     volatile int                depth;          /* # of acquires.           */\n     ulock_t                     lock;           /* Irix lock.               */\n };\n@@ -79,15 +79,15 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n-    _objc_thread_t      thread_id = NULL;\n+    objc_thread_t      thread_id = NULL;\n     int                 sys_id;\n     \n     objc_mutex_lock(__objc_runtime_mutex);\n     if ((sys_id = sproc((void *)func, PR_SALL, arg)) >= 0) {\n-        thread_id = (_objc_thread_t)sys_id;\n+        thread_id = (objc_thread_t)sys_id;\n         __objc_runtime_threads_alive++;\n     }\n     objc_mutex_unlock(__objc_runtime_mutex);\n@@ -154,10 +154,10 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  NULL which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n-    return (_objc_thread_t)get_pid();           /* Threads are processes.   */\n+    return (objc_thread_t)get_pid();           /* Threads are processes.   */\n }\n \n /********\n@@ -185,13 +185,13 @@ objc_thread_get_data(void)\n  *  Return the mutex pointer if successful or NULL if the allocation failed\n  *  for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    _objc_mutex_t       mutex;\n+    objc_mutex_t       mutex;\n     int                 err = 0;\n     \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n     \n     if (!(mutex->lock = usnewlock(__objc_shared_arena_handle)))\n@@ -214,7 +214,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -235,9 +235,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -263,9 +263,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -289,9 +289,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  */\n \n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t     thread_id;               /* Cache our thread id.     */\n+    objc_thread_t     thread_id;               /* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */"}, {"sha": "422d53ec3c190c05ba3fdb8927dae925411d79c4", "filename": "gcc/objc/thr-os2.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-os2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-os2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-os2.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Interface - OS/2 emx Implementation\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Thomas Baier (baier@ci.tuwien.ac.at)\n \n This file is part of GNU CC.\n@@ -50,9 +50,9 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-  volatile _objc_thread_t owner;          /* Id of thread that owns.  */\n+  volatile objc_thread_t owner;          /* Id of thread that owns.  */\n   volatile int            depth;          /* # of acquires.           */\n   HMTX                    handle;         /* OS/2 mutex HANDLE.      */\n };\n@@ -86,7 +86,7 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n   int thread_id = 0;  /* id of the newly created thread */\n@@ -101,7 +101,7 @@ objc_thread_create(void (*func)(void *arg), void *arg)\n   \n   objc_mutex_unlock(__objc_runtime_mutex);\n   \n-  return (_objc_thread_t)thread_id;\n+  return (objc_thread_t)thread_id;\n }\n \n /********\n@@ -191,10 +191,10 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  -1 which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n-  return (_objc_thread_t) *_threadid;  /* Return thread id.        */\n+  return (objc_thread_t) *_threadid;  /* Return thread id.        */\n }\n \n /********\n@@ -222,17 +222,17 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n  *  the allocation fails for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    _objc_mutex_t mutex;\n+    objc_mutex_t mutex;\n     int         err = 0;\n \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n \n     if (DosCreateMutexSem (NULL,&(mutex->handle),0L,0) > 0) {\n-      free (mutex);\n+      objc_free(mutex);\n       return NULL;\n     }\n \n@@ -249,7 +249,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -270,9 +270,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -295,9 +295,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -320,9 +320,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */"}, {"sha": "987f8a81b01010cfb3251fd75b5358acee7d9455", "filename": "gcc/objc/thr-posix.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-posix.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Interface for POSIX compliant threads\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n    Modified for Linux/Pthreads by Kai-Uwe Sattler (kus@iti.cs.uni-magdeburg.de)\n \n@@ -35,9 +35,9 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n     volatile int                depth;          /* # of acquires.           */\n     pthread_mutex_t             lock;           /* pthread mutex.           */\n };\n@@ -71,17 +71,17 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n-    _objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n+    objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n     pthread_t           new_thread_handle;      /* DCE thread handle.       */\n \n     objc_mutex_lock(__objc_runtime_mutex);\n \n     if (pthread_create(&new_thread_handle, NULL,\n                        (void *)func, arg) == 0) {\n-        thread_id = (_objc_thread_t) new_thread_handle;\n+        thread_id = (objc_thread_t) new_thread_handle;\n         pthread_detach(new_thread_handle);     /* Fully detach thread.     */\n \t__objc_runtime_threads_alive++;\n     }\n@@ -170,12 +170,12 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  -1 which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n   pthread_t self = pthread_self();\n \n-  return (_objc_thread_t) self;               /* Return thread handle.    */\n+  return (objc_thread_t) self;               /* Return thread handle.    */\n }\n \n /********\n@@ -203,13 +203,13 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n  *  the allocation fails for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    _objc_mutex_t mutex;\n+    objc_mutex_t mutex;\n     int         err = 0;\n     \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n \n     err = pthread_mutex_init(&mutex->lock, NULL);\n@@ -231,7 +231,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -253,9 +253,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t     thread_id;                /* Cache our thread id. */\n+    objc_thread_t     thread_id;                /* Cache our thread id. */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -276,9 +276,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t    thread_id;                 /* Cache our thread id. */\n+    objc_thread_t    thread_id;                 /* Cache our thread id. */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -301,9 +301,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t   thread_id;                 /* Cache our thread id.     */\n+    objc_thread_t   thread_id;                 /* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */"}, {"sha": "45b7b73fe2a540ef14f61673ec9b41d0bae167f4", "filename": "gcc/objc/thr-single.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-single.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-single.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-single.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Implementation\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n \n This file is part of GNU CC.\n@@ -33,9 +33,9 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n     volatile int                depth;          /* # of acquires.           */\n };\n \n@@ -54,7 +54,7 @@ __objc_init_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n   return NULL;\t\t\t\t   \t/* We can't start threads.  */\n@@ -104,10 +104,10 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  NULL which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n-  return (_objc_thread_t)1;                     /* No thread support, use 1.*/\n+  return (objc_thread_t)1;                     /* No thread support, use 1.*/\n }\n \n /********\n@@ -137,12 +137,12 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n  *  allocation failed for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    _objc_mutex_t mutex;\n+    objc_mutex_t mutex;\n     \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n     \n     mutex->owner = NULL;                        /* No owner.                */\n@@ -158,7 +158,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -177,9 +177,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -198,9 +198,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -220,9 +220,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t  thread_id;\t\t\t/* Cache our thread id.     */\n+    objc_thread_t  thread_id;\t\t\t/* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */"}, {"sha": "520a91d6ced70284c0fb5e5aca44dedda9e7fbff", "filename": "gcc/objc/thr-win32.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-win32.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Interface - Win32 Implementation\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n \n This file is part of GNU CC.\n@@ -38,9 +38,9 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-  volatile _objc_thread_t       owner;        \t/* Id of thread that owns.  */\n+  volatile objc_thread_t       owner;        \t/* Id of thread that owns.  */\n   volatile int                  depth;          /* # of acquires.           */\n   HANDLE                        handle;         /* Win32 mutex HANDLE.      */\n };\n@@ -79,7 +79,7 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n   DWORD        \tthread_id = 0;                  /* Detached thread id.      */\n@@ -96,7 +96,7 @@ objc_thread_create(void (*func)(void *arg), void *arg)\n   \n   objc_mutex_unlock(__objc_runtime_mutex);\n   \n-  return (_objc_thread_t)thread_id;\n+  return (objc_thread_t)thread_id;\n }\n \n /********\n@@ -183,10 +183,10 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  -1 which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n-  return (_objc_thread_t)GetCurrentThreadId();  /* Return thread id.        */\n+  return (objc_thread_t)GetCurrentThreadId();  /* Return thread id.        */\n }\n \n /********\n@@ -214,13 +214,13 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n  *  the allocation fails for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    _objc_mutex_t mutex;\n+    objc_mutex_t mutex;\n     int         err = 0;\n \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n \n     if ((mutex->handle = CreateMutex(NULL, 0, NULL)) == NULL) {\n@@ -240,7 +240,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -261,9 +261,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n     int                 status;\n \n     if (!mutex)                                 /* Is argument bad?         */\n@@ -287,9 +287,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n     DWORD               status;                 /* Return status from Win32.*/\n \n     if (!mutex)                                 /* Is argument bad?         */\n@@ -314,9 +314,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+    objc_thread_t      thread_id;              /* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */"}, {"sha": "2770b7de1abd35796078b8e257539f5ceb42158c", "filename": "gcc/objc/thr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d0c8a1628270591d59529020231a0bcbbd3347/gcc%2Fobjc%2Fthr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr.c?ref=e0d0c8a1628270591d59529020231a0bcbbd3347", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Interface\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n \n This file is part of GNU CC.\n@@ -110,11 +110,11 @@ __objc_thread_detach_function(struct __objc_thread_start_state *istate)\n  *  Thread is started by sending message with selector to object.  Message\n  *  takes a single argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_detach(SEL selector, id object, id argument)\n {\n   struct __objc_thread_start_state *istate;   /* Initialial thread state. */\n-  _objc_thread_t        thread_id = NULL;     /* Detached thread id.      */\n+  objc_thread_t        thread_id = NULL;     /* Detached thread id.      */\n \n   if (!(istate = (struct __objc_thread_start_state *)\n \tobjc_malloc(sizeof(*istate))))     /* Can we allocate state?   */\n@@ -137,14 +137,14 @@ objc_thread_detach(SEL selector, id object, id argument)\n #undef objc_mutex_unlock()\n \n int\n-objc_mutex_unlock_x(_objc_mutex_t mutex, const char *f, int l)\n+objc_mutex_unlock_x(objc_mutex_t mutex, const char *f, int l)\n {\n     printf(\"%16.16s#%4d < unlock\", f, l);\n     return objc_mutex_unlock(mutex);\n }\n \n int\n-objc_mutex_lock_x(_objc_mutex_t mutex, const char *f, int l)\n+objc_mutex_lock_x(objc_mutex_t mutex, const char *f, int l)\n {\n     printf(\"%16.16s#%4d < lock\", f, l);\n     return objc_mutex_lock(mutex);"}]}