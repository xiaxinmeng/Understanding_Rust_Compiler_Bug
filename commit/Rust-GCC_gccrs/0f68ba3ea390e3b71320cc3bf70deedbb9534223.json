{"sha": "0f68ba3ea390e3b71320cc3bf70deedbb9534223", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY2OGJhM2VhMzkwZTNiNzEzMjBjYzNiZjcwZGVlZGJiOTUzNDIyMw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-03-01T16:58:11Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-03-01T16:58:11Z"}, "message": "re PR debug/52001 (Huge compile-time regression with var-tracking)\n\nPR debug/52001\nPR rtl-optimization/52417\n* cselib.c (cselib_any_perm_equivs): New variable.\n(cselib_reset_table): Check that it's not set when not\npreserving constants.\n(cselib_add_permanent_equiv): Set it.\n(cselib_have_permanent_equivalences): New.\n(cselib_init, cselib_finish): Reset it.\n* cselib.h (cselib_have_permanent_equivalences): Declare.\n* alias.c (get_addr): Restore earlier behavior when there\naren't permanent equivalences.\n\nFrom-SVN: r184750", "tree": {"sha": "c2c1bae2d077b418073a5806f3512ee632e4b466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2c1bae2d077b418073a5806f3512ee632e4b466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f68ba3ea390e3b71320cc3bf70deedbb9534223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f68ba3ea390e3b71320cc3bf70deedbb9534223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f68ba3ea390e3b71320cc3bf70deedbb9534223", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f68ba3ea390e3b71320cc3bf70deedbb9534223/comments", "author": null, "committer": null, "parents": [{"sha": "2aceddd8fc0fa80fffd5a6eca0745895b95011e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aceddd8fc0fa80fffd5a6eca0745895b95011e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aceddd8fc0fa80fffd5a6eca0745895b95011e1"}], "stats": {"total": 65, "additions": 55, "deletions": 10}, "files": [{"sha": "805e359e819857bcfa9340854bec6afda574037b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f68ba3ea390e3b71320cc3bf70deedbb9534223", "patch": "@@ -1,3 +1,17 @@\n+2012-03-01  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/52001\n+\tPR rtl-optimization/52417\n+\t* cselib.c (cselib_any_perm_equivs): New variable.\n+\t(cselib_reset_table): Check that it's not set when not\n+\tpreserving constants.\n+\t(cselib_add_permanent_equiv): Set it.\n+\t(cselib_have_permanent_equivalences): New.\n+\t(cselib_init, cselib_finish): Reset it.\n+\t* cselib.h (cselib_have_permanent_equivalences): Declare.\n+\t* alias.c (get_addr): Restore earlier behavior when there\n+\taren't permanent equivalences.\n+\n 2012-03-01  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* config/mn10300/mn10300-modes.def: Fix copyright notice."}, {"sha": "e9d701f96362e55852d929e012fc5670f5a698ba", "filename": "gcc/alias.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0f68ba3ea390e3b71320cc3bf70deedbb9534223", "patch": "@@ -1811,20 +1811,34 @@ get_addr (rtx x)\n   v = CSELIB_VAL_PTR (x);\n   if (v)\n     {\n-      v = canonical_cselib_val (v);\n+      bool have_equivs = cselib_have_permanent_equivalences ();\n+      if (have_equivs)\n+\tv = canonical_cselib_val (v);\n       for (l = v->locs; l; l = l->next)\n \tif (CONSTANT_P (l->loc))\n \t  return l->loc;\n       for (l = v->locs; l; l = l->next)\n-\tif (!REG_P (l->loc) && !MEM_P (l->loc) && GET_CODE (l->loc) != VALUE\n-\t    && !refs_newer_value_p (l->loc, x))\n+\tif (!REG_P (l->loc) && !MEM_P (l->loc)\n+\t    /* Avoid infinite recursion when potentially dealing with\n+\t       var-tracking artificial equivalences, by skipping the\n+\t       equivalences themselves, and not choosing expressions\n+\t       that refer to newer VALUEs.  */\n+\t    && (!have_equivs\n+\t\t|| (GET_CODE (l->loc) != VALUE\n+\t\t    && !refs_newer_value_p (l->loc, x))))\n \t  return l->loc;\n-      for (l = v->locs; l; l = l->next)\n-\tif (REG_P (l->loc) || (GET_CODE (l->loc) != VALUE\n-\t\t\t       && !refs_newer_value_p (l->loc, x)))\n-\t  return l->loc;\n-      /* Return the canonical value.  */\n-      return v->val_rtx;\n+      if (have_equivs)\n+\t{\n+\t  for (l = v->locs; l; l = l->next)\n+\t    if (REG_P (l->loc)\n+\t\t|| (GET_CODE (l->loc) != VALUE\n+\t\t    && !refs_newer_value_p (l->loc, x)))\n+\t      return l->loc;\n+\t  /* Return the canonical value.  */\n+\t  return v->val_rtx;\n+\t}\n+      if (v->locs)\n+\treturn v->locs->loc;\n     }\n   return x;\n }"}, {"sha": "56f2b7f9ffe3a2c0edc2e1dcfd15450b424181b0", "filename": "gcc/cselib.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0f68ba3ea390e3b71320cc3bf70deedbb9534223", "patch": "@@ -52,6 +52,7 @@ struct elt_list {\n \n static bool cselib_record_memory;\n static bool cselib_preserve_constants;\n+static bool cselib_any_perm_equivs;\n static int entry_and_rtx_equal_p (const void *, const void *);\n static hashval_t get_value_hash (const void *);\n static struct elt_list *new_elt_list (struct elt_list *, cselib_val *);\n@@ -477,7 +478,10 @@ cselib_reset_table (unsigned int num)\n   if (cselib_preserve_constants)\n     htab_traverse (cselib_hash_table, preserve_constants_and_equivs, NULL);\n   else\n-    htab_empty (cselib_hash_table);\n+    {\n+      htab_empty (cselib_hash_table);\n+      gcc_checking_assert (!cselib_any_perm_equivs);\n+    }\n \n   n_useless_values = 0;\n   n_useless_debug_values = 0;\n@@ -2388,6 +2392,8 @@ cselib_add_permanent_equiv (cselib_val *elt, rtx x, rtx insn)\n \n   if (nelt != elt)\n     {\n+      cselib_any_perm_equivs = true;\n+\n       if (!PRESERVED_VALUE_P (nelt->val_rtx))\n \tcselib_preserve_value (nelt);\n \n@@ -2397,6 +2403,14 @@ cselib_add_permanent_equiv (cselib_val *elt, rtx x, rtx insn)\n   cselib_current_insn = save_cselib_current_insn;\n }\n \n+/* Return TRUE if any permanent equivalences have been recorded since\n+   the table was last initialized.  */\n+bool\n+cselib_have_permanent_equivalences (void)\n+{\n+  return cselib_any_perm_equivs;\n+}\n+\n /* There is no good way to determine how many elements there can be\n    in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n #define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)\n@@ -2651,6 +2665,7 @@ cselib_init (int record_what)\n   value_pool = create_alloc_pool (\"value\", RTX_CODE_SIZE (VALUE), 100);\n   cselib_record_memory = record_what & CSELIB_RECORD_MEMORY;\n   cselib_preserve_constants = record_what & CSELIB_PRESERVE_CONSTANTS;\n+  cselib_any_perm_equivs = false;\n \n   /* (mem:BLK (scratch)) is a special mechanism to conflict with everything,\n      see canon_true_dependence.  This is only created once.  */\n@@ -2684,6 +2699,7 @@ cselib_finish (void)\n {\n   cselib_discard_hook = NULL;\n   cselib_preserve_constants = false;\n+  cselib_any_perm_equivs = false;\n   cfa_base_preserved_val = NULL;\n   cfa_base_preserved_regno = INVALID_REGNUM;\n   free_alloc_pool (elt_list_pool);"}, {"sha": "96575f985e085d0d6c0b66f1810a1814c839d2af", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f68ba3ea390e3b71320cc3bf70deedbb9534223/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=0f68ba3ea390e3b71320cc3bf70deedbb9534223", "patch": "@@ -98,6 +98,7 @@ extern bool cselib_preserved_value_p (cselib_val *);\n extern void cselib_preserve_only_values (void);\n extern void cselib_preserve_cfa_base_value (cselib_val *, unsigned int);\n extern void cselib_add_permanent_equiv (cselib_val *, rtx, rtx);\n+extern bool cselib_have_permanent_equivalences (void);\n \n extern void dump_cselib_table (FILE *);\n "}]}