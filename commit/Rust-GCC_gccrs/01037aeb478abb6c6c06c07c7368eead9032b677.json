{"sha": "01037aeb478abb6c6c06c07c7368eead9032b677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEwMzdhZWI0NzhhYmI2YzZjMDZjMDdjNzM2OGVlYWQ5MDMyYjY3Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-06-06T18:30:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-06-06T18:30:02Z"}, "message": "arm.c (arm_r3_live_at_start_p): New predicate.\n\n\t* config/arm/arm.c (arm_r3_live_at_start_p): New predicate.\n\t(arm_compute_static_chain_stack_bytes): Use it.  Tidy up.\n\t(arm_expand_prologue): Likewise.\n\nFrom-SVN: r199752", "tree": {"sha": "b5302c18ff020e5becd4865f62fc25e1f2c27f62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5302c18ff020e5becd4865f62fc25e1f2c27f62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01037aeb478abb6c6c06c07c7368eead9032b677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01037aeb478abb6c6c06c07c7368eead9032b677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01037aeb478abb6c6c06c07c7368eead9032b677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01037aeb478abb6c6c06c07c7368eead9032b677/comments", "author": null, "committer": null, "parents": [{"sha": "a5aef1da0052e24721b35eb4581940fa01557b92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5aef1da0052e24721b35eb4581940fa01557b92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5aef1da0052e24721b35eb4581940fa01557b92"}], "stats": {"total": 50, "additions": 32, "deletions": 18}, "files": [{"sha": "787da6fbd031b68f97c5741a57296d6c2fb82f1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01037aeb478abb6c6c06c07c7368eead9032b677/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01037aeb478abb6c6c06c07c7368eead9032b677/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01037aeb478abb6c6c06c07c7368eead9032b677", "patch": "@@ -1,3 +1,9 @@\n+2013-06-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/arm/arm.c (arm_r3_live_at_start_p): New predicate.\n+\t(arm_compute_static_chain_stack_bytes): Use it.  Tidy up.\n+\t(arm_expand_prologue): Likewise.\n+\n 2013-06-06  Teresa Johnson  <tejohnson@google.com>\n \n \tPR c++/53743"}, {"sha": "033e8bf0f3c5316391a93aca92d183360ab0bf61", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01037aeb478abb6c6c06c07c7368eead9032b677/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01037aeb478abb6c6c06c07c7368eead9032b677/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=01037aeb478abb6c6c06c07c7368eead9032b677", "patch": "@@ -16178,25 +16178,34 @@ arm_compute_save_reg0_reg12_mask (void)\n   return save_reg_mask;\n }\n \n+/* Return true if r3 is live at the start of the function.  */\n+\n+static bool\n+arm_r3_live_at_start_p (void)\n+{\n+  /* Just look at cfg info, which is still close enough to correct at this\n+     point.  This gives false positives for broken functions that might use\n+     uninitialized data that happens to be allocated in r3, but who cares?  */\n+  return REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR), 3);\n+}\n \n /* Compute the number of bytes used to store the static chain register on the\n-   stack, above the stack frame. We need to know this accurately to get the\n-   alignment of the rest of the stack frame correct. */\n+   stack, above the stack frame.  We need to know this accurately to get the\n+   alignment of the rest of the stack frame correct.  */\n \n-static int arm_compute_static_chain_stack_bytes (void)\n+static int\n+arm_compute_static_chain_stack_bytes (void)\n {\n-  unsigned long func_type = arm_current_func_type ();\n-  int static_chain_stack_bytes = 0;\n-\n-  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM &&\n-      IS_NESTED (func_type) &&\n-      df_regs_ever_live_p (3) && crtl->args.pretend_args_size == 0)\n-    static_chain_stack_bytes = 4;\n+  /* See the defining assertion in arm_expand_prologue.  */\n+  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM\n+      && IS_NESTED (arm_current_func_type ())\n+      && arm_r3_live_at_start_p ()\n+      && crtl->args.pretend_args_size == 0)\n+    return 4;\n \n-  return static_chain_stack_bytes;\n+  return 0;\n }\n \n-\n /* Compute a bit mask of which registers need to be\n    saved on the stack for the current function.\n    This is used by arm_get_frame_offsets, which may add extra registers.  */\n@@ -18151,24 +18160,24 @@ arm_expand_prologue (void)\n \t}\n       else if (IS_NESTED (func_type))\n \t{\n-\t  /* The Static chain register is the same as the IP register\n+\t  /* The static chain register is the same as the IP register\n \t     used as a scratch register during stack frame creation.\n \t     To get around this need to find somewhere to store IP\n \t     whilst the frame is being created.  We try the following\n \t     places in order:\n \n-\t       1. The last argument register.\n+\t       1. The last argument register r3.\n \t       2. A slot on the stack above the frame.  (This only\n \t          works if the function is not a varargs function).\n-\t       3. Register r3, after pushing the argument registers\n+\t       3. Register r3 again, after pushing the argument registers\n \t          onto the stack.\n \n \t     Note - we only need to tell the dwarf2 backend about the SP\n \t     adjustment in the second variant; the static chain register\n \t     doesn't need to be unwound, as it doesn't contain a value\n \t     inherited from the caller.  */\n \n-\t  if (df_regs_ever_live_p (3) == false)\n+\t  if (!arm_r3_live_at_start_p ())\n \t    insn = emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n \t  else if (args_to_push == 0)\n \t    {\n@@ -18309,8 +18318,7 @@ arm_expand_prologue (void)\n \t  if (IS_NESTED (func_type))\n \t    {\n \t      /* Recover the static chain register.  */\n-\t      if (!df_regs_ever_live_p (3)\n-\t\t  || saved_pretend_args)\n+\t      if (!arm_r3_live_at_start_p () || saved_pretend_args)\n \t\tinsn = gen_rtx_REG (SImode, 3);\n \t      else /* if (crtl->args.pretend_args_size == 0) */\n \t\t{"}]}