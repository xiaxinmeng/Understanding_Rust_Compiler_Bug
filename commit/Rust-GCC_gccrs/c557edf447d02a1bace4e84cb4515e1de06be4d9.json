{"sha": "c557edf447d02a1bace4e84cb4515e1de06be4d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU1N2VkZjQ0N2QwMmExYmFjZTRlODRjYjQ1MTVlMWRlMDZiZTRkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-09-09T06:33:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-09-09T06:33:58Z"}, "message": "* config/frv/frv-protos.h (FRV_CPU_FR550, FRV_CPU_FR450)\n\t(FRV_CPU_FR405): New processor enums.\n\t(frv_issue_rate, frv_acc_group): Declare.\n\t* config/frv/frv.h (CPP_SPEC, CPP_FRV_SPEC, CPP_FR500_SPEC): Delete.\n\t(CPP_FR400_SPEC, CPP_SIMPLE_SPEC): Delete.\n\t(MASK_DEFAULT_FR550, MASK_DEFAULT_FR450): New macros.\n\t(SUBTARGET_EXTRA_SPECS, EXTRA_SPECS, CPP_CPU_DEFAULT_SPEC): Delete.\n\t(TARGET_CPU_CPP_BUILTINS): Define the macros that were previously\n\thandled by CPP_SPEC.\n\t(MASK_LONG_CALLS, TARGET_LONG_CALLS): New macros.\n\t(MASK_ALIGN_LABELS, TARGET_ALIGN_LABELS): New macros.\n\t(ACC_MASK): New macro.\n\t(TARGET_MEDIA_REV2): Include FRV_CPU_{FR405,FR450,FR550}.\n\t(TARGET_MEDIA_FR450): New macro.\n\t(TARGET_FR500_FR550_BUILTINS, TARGET_FR405_BUILTINS): New macros.\n\t(TARGET_SWITCHES): Add -m{no-,}align-labels and -m{no-,}long-calls.\n\t(LABEL_ALIGN_AFTER_BARRIER): Define.\n\t(ACC_LAST, ACCG_LAST): Add four new accumulator registers.\n\t(IACC_FIRST, IACC_LAST): New pair of SPRs.\n\t(ACCG_FIRST, AP_FIRST, SPR_FIRST, SPR_LAST): Adjust accordingly.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER)\n\t(REGISTER_NAMES): Add entries for new registers.\n\t(REG_CLASS_CONTENTS): Update for new register ranges.\n\t(EXTRA_CONSTRAINT_FOR_S): Redefine in terms of call_operand.\n\t(ISSUE_RATE, CLEAR_VLIW_START, SET_VLIW_START): Delete.\n\t(PACKING_FLAG_USED_P): Delete.\n\t(FRV_BUILTIN_MQLCLRHS, FRV_BUILTIN_MQLMTHS, FRV_BUILTIN_MQSLLHI)\n\t(FRV_BUILTIN_MQSRAHI, FRV_BUILTIN_SMUL, FRV_BUILTIN_UMUL)\n\t(FRV_BUILTIN_PREFETCH0, FRV_BUILTIN_PREFETCH, FRV_BUILTIN_SMASS)\n\t(FRV_BUILTIN_SMSSS, FRV_BUILTIN_SMU, FRV_BUILTIN_SCUTSS)\n\t(FRV_BUILTIN_ADDSS, FRV_BUILTIN_SUBSS, FRV_BUILTIN_SLASS)\n\t(FRV_BUILTIN_IACCread{l,ll}, FRV_BUILTIN_IACCset{ll,l})\n\t(FRV_BUILTIN_SCAN): New members of frv_builtin_enum.\n\t(FRV_BUILTIN_FIRST_NONMEDIA): New macro.\n\t(CPU_UNITS_QUERY): Define to 1.\n\t* config/frv/frv.c: Include gt-frv.h\n\t(NUM_NOP_PATTERNS, NTH_UNIT, UNIT_NUMBER, PACKING_FLAG_P): New macros.\n\t(SET_PACKING_FLAG, CLEAR_PACKING_FLAG, FOR_EACH_REGNO): New macros.\n\t(frv_insn_group): New enumeration.\n\t(frv_unit_names, frv_unit_groups, frv_unit_codes): New variables.\n\t(frv_type_to_unit, frv_nops, frv_num_nops): New variables.\n\t(REGSTATE_DEAD, REGSTATE_LIVE, REGSTATE_UNUSED, REGSTATE_MASK)\n\t(REGSTATE_CONDJUMP): Delete.  Shuffle other numbers to cover the\n\tgap left by REGSTATE_LIVE.\n\t(regstate_t): New typedef.\n\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(frv_default_flags_for_cpu): Handle FRV_CPU_{FR550,FR450,FR405}.\n\t(frv_override_options): Check for -mcpu={fr550,fr450,fr405}.\n\tInitialize frv_unit_codes[] and frv_type_to_unit[].\n\t(frv_conditional_register_usage): Remove redundant fixing of\n\taccumulator registers.\n\t(frv_insn_packing_flag): Update specification.\n\t(frv_function_prologue): Don't set frv_insn_packing_flag here.\n\tZero out frv_nops[].\n\t(frv_expand_epilogue): Remove comments about the no-longer-present\n\tSIBCALL_P argument.\n\t(frv_asm_output_mi_thunk): Check frv_issue_rate() rather than\n\tPACKING_FLAG_USED_P() when deciding whether to pack instructions.\n\t(frv_asm_output_opcode, frv_final_prescan_insn): Simplify in light\n\tof the new meaning of frv_insn_packing_flag.  Emit an mnop.p if\n\tpacking is disabled and if INSN can only issue to M1.\n\t(call_operand): Check TARGET_LONG_CALLS.\n\t(acc_operand, even_acc_operand, quad_acc_operand)\n\t(accg_operand): Simplify.  Don't accept pseudo registers.\n\t(output_move_single): Handle SPR<-zero moves.\n\t(frv_issue_rate): Make non-static.  Handle FRV_CPU_{FR550,FR450,FR405}.\n\t(frv_registers_update, frv_registers_used_p): Delete.\n\t(frv_registers_set_p): Delete.\n\t(frv_acc_group_1, frv_acc_group, frv_insn_unit): New functions.\n\t(frv_issues_to_branch_unit_p): New function.\n\t(frv_packet): New structure.\n\t(frv_cond_flags, frv_regstate_conflict_p): New functions.\n\t(frv_registers_conflict_p_1, frv_registers_conflict_p): New functions.\n\t(frv_registers_update_1, frv_registers_update): New functions.\n\t(frv_start_packet, frv_start_packet_block, frv_finish_packet)\n\t(frv_pack_insn_p, frv_add_insn_to_packet, frv_insert_nop_in_packet)\n\t(frv_for_each_packet, frv_sort_insn_group_1, frv_compare_insns)\n\t(frv_sort_insn_group, frv_reorder_packet): New functions.\n\t(frv_pack_insns): Use frv_reorder_packet.\n\t(frv_packet_address): New variable.\n\t(frv_fill_unused_units, frv_align_label, frv_reorg_packet)\n\t(frv_register_nop, frv_reorg): New functions.\n\t(bdesc_1arg): Add __SCUTSS.\n\t(bdesc_2arg): Add __MQLCLRHS, __MQLMTHS, __SMUL, __UMUL, __ADDSS,\n\t__SUBSS, __SLASS and __SCAN.\n\t(bdesc_2argimm): Add __MQSLLHI and __MQSRAHI.\n\t(bdesc_int_void2arg, bdesc_prefetches): New arrays.\n\t(frv_init_builtins): Register the above builtins.\n\t(frv_int_to_acc): Use ACC_MASK to check for valid accumulator\n\tregisters.  Turn the referenced accumulators into global registers.\n\t(frv_read_iacc_argument): New function.\n\t(frv_expand_int_void2arg, frv_expand_prefetches): New functions.\n\t(frv_split_iacc_move): New function.\n\t(frv_expand_builtin): Handle the new builtins.\n\t* config/frv/frv.md: Replace old schedulers with new order-independent\n\tones.  Add schedulers for the FR405, FR450 and FR550.  Describe new\n\tpacking algorithm.\n\t(cpu): Add fr550, fr450 and fr405.\n\t(type): Add macc, scan, cut, fnop, fscmp, fdcmp, mnop, mqlimh and\n\tmqshift.  Replace fmas with fsmadd and fmad with fdmadd.  Delete m7.\n\t(*muladd[sd]f4, *mulsub[sd]f4): Fix types.\n\t(*cmp[sd]f_cc_fp): Use new f[sd]cmp types.\n\t(fnop, mnop): New patterns.\n\t(UNSPEC_MQLCLRHS, UNSPEC_MQLMTHS, UNSPEC_MQSLLHI, UNSPEC_MQSRAHI):\n\tNew constants.\n\t(mexpdhw, *cond_exec_mexpdhw): Fix destination operands.\n\t(mclracca8): Use ACC_MASK to determine the upper set of accumulator\n\tregisters.\n\t(mqlclrhs, mqlmths, mqsllhi, mqsrahi): New patterns.\n\t(UNSPEC_SMUL, UNSPEC_UMUL, UNSPEC_SMU, UNSPEC_ADDSS, UNSPEC_SUBSS)\n\t(UNSPEC_SLASS, UNSPEC_SCAN, UNSPEC_INTSS, UNSPEC_SCUTSS)\n\t(UNSPEC_PREFETCH0, UNSPEC_PREFETCH, UNSPEC_IACCreadll)\n\t(UNSPEC_IACCreadl, UNSPEC_IACCsetll, UNSPEC_IACCsetl, UNSPEC_SMASS)\n\t(UNSPEC_SMSSS, UNSPEC_IMUL, IACC0_REG): New constants.\n\t(smul, umul, smass, smsss, smu, addss, subss, slass, scan, scutss)\n\t(frv_prefetch0, frv_prefetch): New patterns.\n\t* config/frv/t-frv (MULTILIB_OPTIONS): Remove -mcpu=frv and\n\t-mcpu=simple.  Add -mcpu=fr550.\n\t(MULTILIB_DIRNAMES): Update accordingly.\n\t(MULTILIB_MATCHES): Use the fr400 multilibs for -mcpu=fr405 and\n\t-mcpu=fr450.\n\t* doc/invoke.texi: Document the new -mcpu={fr550,fr450,fr405},\n\t-mlong-calls and -malign-labels options for FR-V.\n\nCo-Authored-By: Catherine Moore <clm@redhat.com>\n\nFrom-SVN: r87222", "tree": {"sha": "cef58160af1ba13e909e56331bfe92e878822cf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cef58160af1ba13e909e56331bfe92e878822cf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c557edf447d02a1bace4e84cb4515e1de06be4d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c557edf447d02a1bace4e84cb4515e1de06be4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c557edf447d02a1bace4e84cb4515e1de06be4d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c557edf447d02a1bace4e84cb4515e1de06be4d9/comments", "author": null, "committer": null, "parents": [{"sha": "5f070bc759432417ea6bb27d743b6f95ae034c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f070bc759432417ea6bb27d743b6f95ae034c68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f070bc759432417ea6bb27d743b6f95ae034c68"}], "stats": {"total": 3782, "additions": 2456, "deletions": 1326}, "files": [{"sha": "e5160856792da0a1a9f596313364bfe81bf9cc88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c557edf447d02a1bace4e84cb4515e1de06be4d9", "patch": "@@ -1,3 +1,130 @@\n+2004-09-09  Richard Sandiford  <rsandifo@redhat.com>\n+\t    Catherine Moore  <clm@redhat.com>\n+\n+\t* config/frv/frv-protos.h (FRV_CPU_FR550, FRV_CPU_FR450)\n+\t(FRV_CPU_FR405): New processor enums.\n+\t(frv_issue_rate, frv_acc_group): Declare.\n+\t* config/frv/frv.h (CPP_SPEC, CPP_FRV_SPEC, CPP_FR500_SPEC): Delete.\n+\t(CPP_FR400_SPEC, CPP_SIMPLE_SPEC): Delete.\n+\t(MASK_DEFAULT_FR550, MASK_DEFAULT_FR450): New macros.\n+\t(SUBTARGET_EXTRA_SPECS, EXTRA_SPECS, CPP_CPU_DEFAULT_SPEC): Delete.\n+\t(TARGET_CPU_CPP_BUILTINS): Define the macros that were previously\n+\thandled by CPP_SPEC.\n+\t(MASK_LONG_CALLS, TARGET_LONG_CALLS): New macros.\n+\t(MASK_ALIGN_LABELS, TARGET_ALIGN_LABELS): New macros.\n+\t(ACC_MASK): New macro.\n+\t(TARGET_MEDIA_REV2): Include FRV_CPU_{FR405,FR450,FR550}.\n+\t(TARGET_MEDIA_FR450): New macro.\n+\t(TARGET_FR500_FR550_BUILTINS, TARGET_FR405_BUILTINS): New macros.\n+\t(TARGET_SWITCHES): Add -m{no-,}align-labels and -m{no-,}long-calls.\n+\t(LABEL_ALIGN_AFTER_BARRIER): Define.\n+\t(ACC_LAST, ACCG_LAST): Add four new accumulator registers.\n+\t(IACC_FIRST, IACC_LAST): New pair of SPRs.\n+\t(ACCG_FIRST, AP_FIRST, SPR_FIRST, SPR_LAST): Adjust accordingly.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER)\n+\t(REGISTER_NAMES): Add entries for new registers.\n+\t(REG_CLASS_CONTENTS): Update for new register ranges.\n+\t(EXTRA_CONSTRAINT_FOR_S): Redefine in terms of call_operand.\n+\t(ISSUE_RATE, CLEAR_VLIW_START, SET_VLIW_START): Delete.\n+\t(PACKING_FLAG_USED_P): Delete.\n+\t(FRV_BUILTIN_MQLCLRHS, FRV_BUILTIN_MQLMTHS, FRV_BUILTIN_MQSLLHI)\n+\t(FRV_BUILTIN_MQSRAHI, FRV_BUILTIN_SMUL, FRV_BUILTIN_UMUL)\n+\t(FRV_BUILTIN_PREFETCH0, FRV_BUILTIN_PREFETCH, FRV_BUILTIN_SMASS)\n+\t(FRV_BUILTIN_SMSSS, FRV_BUILTIN_SMU, FRV_BUILTIN_SCUTSS)\n+\t(FRV_BUILTIN_ADDSS, FRV_BUILTIN_SUBSS, FRV_BUILTIN_SLASS)\n+\t(FRV_BUILTIN_IACCread{l,ll}, FRV_BUILTIN_IACCset{ll,l})\n+\t(FRV_BUILTIN_SCAN): New members of frv_builtin_enum.\n+\t(FRV_BUILTIN_FIRST_NONMEDIA): New macro.\n+\t(CPU_UNITS_QUERY): Define to 1.\n+\t* config/frv/frv.c: Include gt-frv.h\n+\t(NUM_NOP_PATTERNS, NTH_UNIT, UNIT_NUMBER, PACKING_FLAG_P): New macros.\n+\t(SET_PACKING_FLAG, CLEAR_PACKING_FLAG, FOR_EACH_REGNO): New macros.\n+\t(frv_insn_group): New enumeration.\n+\t(frv_unit_names, frv_unit_groups, frv_unit_codes): New variables.\n+\t(frv_type_to_unit, frv_nops, frv_num_nops): New variables.\n+\t(REGSTATE_DEAD, REGSTATE_LIVE, REGSTATE_UNUSED, REGSTATE_MASK)\n+\t(REGSTATE_CONDJUMP): Delete.  Shuffle other numbers to cover the\n+\tgap left by REGSTATE_LIVE.\n+\t(regstate_t): New typedef.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Define.\n+\t(frv_default_flags_for_cpu): Handle FRV_CPU_{FR550,FR450,FR405}.\n+\t(frv_override_options): Check for -mcpu={fr550,fr450,fr405}.\n+\tInitialize frv_unit_codes[] and frv_type_to_unit[].\n+\t(frv_conditional_register_usage): Remove redundant fixing of\n+\taccumulator registers.\n+\t(frv_insn_packing_flag): Update specification.\n+\t(frv_function_prologue): Don't set frv_insn_packing_flag here.\n+\tZero out frv_nops[].\n+\t(frv_expand_epilogue): Remove comments about the no-longer-present\n+\tSIBCALL_P argument.\n+\t(frv_asm_output_mi_thunk): Check frv_issue_rate() rather than\n+\tPACKING_FLAG_USED_P() when deciding whether to pack instructions.\n+\t(frv_asm_output_opcode, frv_final_prescan_insn): Simplify in light\n+\tof the new meaning of frv_insn_packing_flag.  Emit an mnop.p if\n+\tpacking is disabled and if INSN can only issue to M1.\n+\t(call_operand): Check TARGET_LONG_CALLS.\n+\t(acc_operand, even_acc_operand, quad_acc_operand)\n+\t(accg_operand): Simplify.  Don't accept pseudo registers.\n+\t(output_move_single): Handle SPR<-zero moves.\n+\t(frv_issue_rate): Make non-static.  Handle FRV_CPU_{FR550,FR450,FR405}.\n+\t(frv_registers_update, frv_registers_used_p): Delete.\n+\t(frv_registers_set_p): Delete.\n+\t(frv_acc_group_1, frv_acc_group, frv_insn_unit): New functions.\n+\t(frv_issues_to_branch_unit_p): New function.\n+\t(frv_packet): New structure.\n+\t(frv_cond_flags, frv_regstate_conflict_p): New functions.\n+\t(frv_registers_conflict_p_1, frv_registers_conflict_p): New functions.\n+\t(frv_registers_update_1, frv_registers_update): New functions.\n+\t(frv_start_packet, frv_start_packet_block, frv_finish_packet)\n+\t(frv_pack_insn_p, frv_add_insn_to_packet, frv_insert_nop_in_packet)\n+\t(frv_for_each_packet, frv_sort_insn_group_1, frv_compare_insns)\n+\t(frv_sort_insn_group, frv_reorder_packet): New functions.\n+\t(frv_pack_insns): Use frv_reorder_packet.\n+\t(frv_packet_address): New variable.\n+\t(frv_fill_unused_units, frv_align_label, frv_reorg_packet)\n+\t(frv_register_nop, frv_reorg): New functions.\n+\t(bdesc_1arg): Add __SCUTSS.\n+\t(bdesc_2arg): Add __MQLCLRHS, __MQLMTHS, __SMUL, __UMUL, __ADDSS,\n+\t__SUBSS, __SLASS and __SCAN.\n+\t(bdesc_2argimm): Add __MQSLLHI and __MQSRAHI.\n+\t(bdesc_int_void2arg, bdesc_prefetches): New arrays.\n+\t(frv_init_builtins): Register the above builtins.\n+\t(frv_int_to_acc): Use ACC_MASK to check for valid accumulator\n+\tregisters.  Turn the referenced accumulators into global registers.  \n+\t(frv_read_iacc_argument): New function.\n+\t(frv_expand_int_void2arg, frv_expand_prefetches): New functions.\n+\t(frv_split_iacc_move): New function.\n+\t(frv_expand_builtin): Handle the new builtins.\n+\t* config/frv/frv.md: Replace old schedulers with new order-independent\n+\tones.  Add schedulers for the FR405, FR450 and FR550.  Describe new\n+\tpacking algorithm.\n+\t(cpu): Add fr550, fr450 and fr405.\n+\t(type): Add macc, scan, cut, fnop, fscmp, fdcmp, mnop, mqlimh and\n+\tmqshift.  Replace fmas with fsmadd and fmad with fdmadd.  Delete m7.\n+\t(*muladd[sd]f4, *mulsub[sd]f4): Fix types.\n+\t(*cmp[sd]f_cc_fp): Use new f[sd]cmp types.\n+\t(fnop, mnop): New patterns.\n+\t(UNSPEC_MQLCLRHS, UNSPEC_MQLMTHS, UNSPEC_MQSLLHI, UNSPEC_MQSRAHI):\n+\tNew constants.\n+\t(mexpdhw, *cond_exec_mexpdhw): Fix destination operands.\n+\t(mclracca8): Use ACC_MASK to determine the upper set of accumulator\n+\tregisters.\n+\t(mqlclrhs, mqlmths, mqsllhi, mqsrahi): New patterns.\n+\t(UNSPEC_SMUL, UNSPEC_UMUL, UNSPEC_SMU, UNSPEC_ADDSS, UNSPEC_SUBSS)\n+\t(UNSPEC_SLASS, UNSPEC_SCAN, UNSPEC_INTSS, UNSPEC_SCUTSS)\n+\t(UNSPEC_PREFETCH0, UNSPEC_PREFETCH, UNSPEC_IACCreadll)\n+\t(UNSPEC_IACCreadl, UNSPEC_IACCsetll, UNSPEC_IACCsetl, UNSPEC_SMASS)\n+\t(UNSPEC_SMSSS, UNSPEC_IMUL, IACC0_REG): New constants.\n+\t(smul, umul, smass, smsss, smu, addss, subss, slass, scan, scutss)\n+\t(frv_prefetch0, frv_prefetch): New patterns.\n+\t* config/frv/t-frv (MULTILIB_OPTIONS): Remove -mcpu=frv and\n+\t-mcpu=simple.  Add -mcpu=fr550.\n+\t(MULTILIB_DIRNAMES): Update accordingly.\n+\t(MULTILIB_MATCHES): Use the fr400 multilibs for -mcpu=fr405 and\n+\t-mcpu=fr450.\n+\t* doc/invoke.texi: Document the new -mcpu={fr550,fr450,fr405},\n+\t-mlong-calls and -malign-labels options for FR-V.\n+\n 2004-09-09  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/8420"}, {"sha": "cf6c859d9a7cd448227b5ff0a36910eb94e855fb", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=c557edf447d02a1bace4e84cb4515e1de06be4d9", "patch": "@@ -42,7 +42,10 @@ extern int frv_sched_lookahead;\t\t\t/* value -msched-lookahead= */\n typedef enum frv_cpu\n {\n   FRV_CPU_GENERIC,\n+  FRV_CPU_FR550,\n   FRV_CPU_FR500,\n+  FRV_CPU_FR450,\n+  FRV_CPU_FR405,\n   FRV_CPU_FR400,\n   FRV_CPU_FR300,\n   FRV_CPU_SIMPLE,\n@@ -137,6 +140,8 @@ extern int frv_legitimate_constant_p\t(rtx);\n \n extern int direct_return_p\t\t(void);\n extern int frv_register_move_cost\t(enum reg_class, enum reg_class);\n+extern int frv_issue_rate\t\t(void);\n+extern int frv_acc_group\t\t(rtx);\n \n #ifdef TREE_CODE\n extern int frv_adjust_field_align\t(tree, int);"}, {"sha": "1845cc485d95ac818c2513df70e2f5cb351fe04e", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1134, "deletions": 632, "changes": 1766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=c557edf447d02a1bace4e84cb4515e1de06be4d9", "patch": "@@ -56,6 +56,73 @@ Boston, MA 02111-1307, USA.  */\n #define FRV_INLINE inline\n #endif\n \n+/* The maximum number of distinct NOP patterns.  There are three:\n+   nop, fnop and mnop.  */\n+#define NUM_NOP_PATTERNS 3\n+\n+/* Classification of instructions and units: integer, floating-point/media,\n+   branch and control.  */\n+enum frv_insn_group { GROUP_I, GROUP_FM, GROUP_B, GROUP_C, NUM_GROUPS };\n+\n+/* The DFA names of the units, in packet order.  */\n+static const char *const frv_unit_names[] =\n+{\n+  \"c\",\n+  \"i0\", \"f0\",\n+  \"i1\", \"f1\",\n+  \"i2\", \"f2\",\n+  \"i3\", \"f3\",\n+  \"b0\", \"b1\"\n+};\n+\n+/* The classification of each unit in frv_unit_names[].  */\n+static const enum frv_insn_group frv_unit_groups[ARRAY_SIZE (frv_unit_names)] =\n+{\n+  GROUP_C,\n+  GROUP_I, GROUP_FM,\n+  GROUP_I, GROUP_FM,\n+  GROUP_I, GROUP_FM,\n+  GROUP_I, GROUP_FM,\n+  GROUP_B, GROUP_B\n+};\n+\n+/* Return the DFA unit code associated with the Nth unit of integer\n+   or floating-point group GROUP,  */\n+#define NTH_UNIT(GROUP, N) frv_unit_codes[(GROUP) + (N) * 2 + 1]\n+\n+/* Return the number of integer or floating-point unit UNIT\n+   (1 for I1, 2 for F2, etc.).  */\n+#define UNIT_NUMBER(UNIT) (((UNIT) - 1) / 2)\n+\n+/* The DFA unit number for each unit in frv_unit_names[].  */\n+static int frv_unit_codes[ARRAY_SIZE (frv_unit_names)];\n+\n+/* FRV_TYPE_TO_UNIT[T] is the last unit in frv_unit_names[] that can issue\n+   an instruction of type T.  The value is ARRAY_SIZE (frv_unit_names) if\n+   no instruction of type T has been seen.  */\n+static unsigned int frv_type_to_unit[TYPE_UNKNOWN + 1];\n+\n+/* An array of dummy nop INSNs, one for each type of nop that the\n+   target supports.  */\n+static GTY(()) rtx frv_nops[NUM_NOP_PATTERNS];\n+\n+/* The number of nop instructions in frv_nops[].  */\n+static unsigned int frv_num_nops;\n+\n+/* Return true if instruction INSN should be packed with the following\n+   instruction.  */\n+#define PACKING_FLAG_P(INSN) (GET_MODE (INSN) == TImode)\n+\n+/* Set the value of PACKING_FLAG_P(INSN).  */\n+#define SET_PACKING_FLAG(INSN) PUT_MODE (INSN, TImode)\n+#define CLEAR_PACKING_FLAG(INSN) PUT_MODE (INSN, VOIDmode)\n+\n+/* Loop with REG set to each hard register in rtx X.  */\n+#define FOR_EACH_REGNO(REG, X)\t\t\t\t\t\t\\\n+  for (REG = REGNO (X);\t\t\t\t\t\t\t\\\n+       REG < REGNO (X) + HARD_REGNO_NREGS (REGNO (X), GET_MODE (X));\t\\\n+       REG++)\n+\n /* Information about a relocation unspec.  SYMBOL is the relocation symbol\n    (a SYMBOL_REF or LABEL_REF), RELOC is the type of relocation and OFFSET\n    is the constant addend.  */\n@@ -73,23 +140,15 @@ typedef struct frv_tmp_reg_struct\n   }\n frv_tmp_reg_t;\n \n-/* Register state information for VLIW re-packing phase.  These values must fit\n-   within an unsigned char.  */\n-#define REGSTATE_DEAD\t\t0x00\t/* register is currently dead */\n+/* Register state information for VLIW re-packing phase.  */\n #define REGSTATE_CC_MASK\t0x07\t/* Mask to isolate CCn for cond exec */\n-#define REGSTATE_LIVE\t\t0x08\t/* register is live */\n-#define REGSTATE_MODIFIED\t0x10\t/* reg modified in current VLIW insn */\n-#define REGSTATE_IF_TRUE\t0x20\t/* reg modified in cond exec true */\n-#define REGSTATE_IF_FALSE\t0x40\t/* reg modified in cond exec false */\n-#define REGSTATE_UNUSED\t\t0x80\t/* bit for hire */\n-#define REGSTATE_MASK\t\t0xff\t/* mask for the bits to set */\n-\n-\t\t\t\t\t/* conditional expression used */\n+#define REGSTATE_MODIFIED\t0x08\t/* reg modified in current VLIW insn */\n+#define REGSTATE_IF_TRUE\t0x10\t/* reg modified in cond exec true */\n+#define REGSTATE_IF_FALSE\t0x20\t/* reg modified in cond exec false */\n+\n #define REGSTATE_IF_EITHER\t(REGSTATE_IF_TRUE | REGSTATE_IF_FALSE)\n \n-/* The following is not sure in the reg_state bytes, so can have a larger value\n-   than 0xff.  */\n-#define REGSTATE_CONDJUMP\t0x100\t/* conditional jump done in VLIW insn */\n+typedef unsigned char regstate_t;\n \n /* Used in frv_frame_accessor_t to indicate the direction of a register-to-\n    memory move.  */\n@@ -239,6 +298,7 @@ static int frv_legitimate_memory_operand\t(rtx, enum machine_mode, int);\n static rtx frv_int_to_acc\t\t\t(enum insn_code, int, rtx);\n static enum machine_mode frv_matching_accg_mode\t(enum machine_mode);\n static rtx frv_read_argument\t\t\t(tree *);\n+static rtx frv_read_iacc_argument\t\t(enum machine_mode, tree *);\n static int frv_check_constant_argument\t\t(enum insn_code, int, rtx);\n static rtx frv_legitimize_target\t\t(enum insn_code, rtx);\n static rtx frv_legitimize_argument\t\t(enum insn_code, int, rtx);\n@@ -248,22 +308,48 @@ static rtx frv_expand_binop_builtin\t\t(enum insn_code, tree, rtx);\n static rtx frv_expand_cut_builtin\t\t(enum insn_code, tree, rtx);\n static rtx frv_expand_binopimm_builtin\t\t(enum insn_code, tree, rtx);\n static rtx frv_expand_voidbinop_builtin\t\t(enum insn_code, tree);\n+static rtx frv_expand_int_void2arg\t\t(enum insn_code, tree);\n+static rtx frv_expand_prefetches\t\t(enum insn_code, tree);\n static rtx frv_expand_voidtriop_builtin\t\t(enum insn_code, tree);\n static rtx frv_expand_voidaccop_builtin\t\t(enum insn_code, tree);\n static rtx frv_expand_mclracc_builtin\t\t(tree);\n static rtx frv_expand_mrdacc_builtin\t\t(enum insn_code, tree);\n static rtx frv_expand_mwtacc_builtin\t\t(enum insn_code, tree);\n static rtx frv_expand_noargs_builtin\t\t(enum insn_code);\n+static void frv_split_iacc_move\t\t\t(rtx, rtx);\n static rtx frv_emit_comparison\t\t\t(enum rtx_code, rtx, rtx);\n static int frv_clear_registers_used\t\t(rtx *, void *);\n static void frv_ifcvt_add_insn\t\t\t(rtx, rtx, int);\n static rtx frv_ifcvt_rewrite_mem\t\t(rtx, enum machine_mode, rtx);\n static rtx frv_ifcvt_load_value\t\t\t(rtx, rtx);\n-static void frv_registers_update\t\t(rtx, unsigned char [],\n-\t\t\t\t\t\t int [], int *, int);\n-static int frv_registers_used_p\t\t\t(rtx, unsigned char [], int);\n-static int frv_registers_set_p\t\t\t(rtx, unsigned char [], int);\n-static int frv_issue_rate\t\t\t(void);\n+static int frv_acc_group_1\t\t\t(rtx *, void *);\n+static unsigned int frv_insn_unit\t\t(rtx);\n+static bool frv_issues_to_branch_unit_p\t\t(rtx);\n+static int frv_cond_flags \t\t\t(rtx);\n+static bool frv_regstate_conflict_p \t\t(regstate_t, regstate_t);\n+static int frv_registers_conflict_p_1 \t\t(rtx *, void *);\n+static bool frv_registers_conflict_p \t\t(rtx);\n+static void frv_registers_update_1 \t\t(rtx, rtx, void *);\n+static void frv_registers_update \t\t(rtx);\n+static void frv_start_packet \t\t\t(void);\n+static void frv_start_packet_block \t\t(void);\n+static void frv_finish_packet \t\t\t(void (*) (void));\n+static bool frv_pack_insn_p \t\t\t(rtx);\n+static void frv_add_insn_to_packet\t\t(rtx);\n+static void frv_insert_nop_in_packet\t\t(rtx);\n+static bool frv_for_each_packet \t\t(void (*) (void));\n+static bool frv_sort_insn_group_1\t\t(enum frv_insn_group,\n+\t\t\t\t\t\t unsigned int, unsigned int,\n+\t\t\t\t\t\t unsigned int, unsigned int,\n+\t\t\t\t\t\t state_t);\n+static int frv_compare_insns\t\t\t(const void *, const void *);\n+static void frv_sort_insn_group\t\t\t(enum frv_insn_group);\n+static void frv_reorder_packet \t\t\t(void);\n+static void frv_fill_unused_units\t\t(enum frv_insn_group);\n+static void frv_align_label \t\t\t(void);\n+static void frv_reorg_packet \t\t\t(void);\n+static void frv_register_nop\t\t\t(rtx);\n+static void frv_reorg \t\t\t\t(void);\n static void frv_pack_insns\t\t\t(void);\n static void frv_function_prologue\t\t(FILE *, HOST_WIDE_INT);\n static void frv_function_epilogue\t\t(FILE *, HOST_WIDE_INT);\n@@ -336,6 +422,8 @@ static bool frv_must_pass_in_stack (enum machine_mode mode, tree type);\n #define TARGET_EXPAND_BUILTIN_SAVEREGS frv_expand_builtin_saveregs\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS frv_setup_incoming_varargs\n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG frv_reorg\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -426,10 +514,17 @@ frv_default_flags_for_cpu (void)\n     case FRV_CPU_GENERIC:\n       return MASK_DEFAULT_FRV;\n \n+    case FRV_CPU_FR550:\n+      return MASK_DEFAULT_FR550;\n+\n     case FRV_CPU_FR500:\n     case FRV_CPU_TOMCAT:\n       return MASK_DEFAULT_FR500;\n \n+    case FRV_CPU_FR450:\n+      return MASK_DEFAULT_FR450;\n+\n+    case FRV_CPU_FR405:\n     case FRV_CPU_FR400:\n       return MASK_DEFAULT_FR400;\n \n@@ -452,7 +547,8 @@ frv_default_flags_for_cpu (void)\n void\n frv_override_options (void)\n {\n-  int regno, i;\n+  int regno;\n+  unsigned int i;\n \n   /* Set the cpu type.  */\n   if (frv_cpu_string)\n@@ -469,9 +565,18 @@ frv_override_options (void)\n       else\n \t{\n \t  const char *p = frv_cpu_string + sizeof (\"fr\") - 1;\n-\t  if (strcmp (p, \"500\") == 0)\n+\t  if (strcmp (p, \"550\") == 0)\n+\t    frv_cpu_type = FRV_CPU_FR550;\n+\n+\t  else if (strcmp (p, \"500\") == 0)\n \t    frv_cpu_type = FRV_CPU_FR500;\n \n+\t  else if (strcmp (p, \"450\") == 0)\n+\t    frv_cpu_type = FRV_CPU_FR450;\n+\n+\t  else if (strcmp (p, \"405\") == 0)\n+\t    frv_cpu_type = FRV_CPU_FR405;\n+\n \t  else if (strcmp (p, \"400\") == 0)\n \t    frv_cpu_type = FRV_CPU_FR400;\n \n@@ -646,6 +751,12 @@ frv_override_options (void)\n   if ((target_flags_explicit & MASK_LINKED_FP) == 0)\n     target_flags |= MASK_LINKED_FP;\n \n+  for (i = 0; i < ARRAY_SIZE (frv_unit_names); i++)\n+    frv_unit_codes[i] = get_cpu_unit_code (frv_unit_names[i]);\n+\n+  for (i = 0; i < ARRAY_SIZE (frv_type_to_unit); i++)\n+    frv_type_to_unit[i] = ARRAY_SIZE (frv_unit_codes);\n+\n   init_machine_status = frv_init_machine_status;\n }\n \n@@ -729,12 +840,6 @@ frv_conditional_register_usage (void)\n   for (i = FPR_FIRST + NUM_FPRS; i <= FPR_LAST; i++)\n     fixed_regs[i] = call_used_regs[i] = 1;\n \n-  for (i = ACC_FIRST + NUM_ACCS; i <= ACC_LAST; i++)\n-    fixed_regs[i] = call_used_regs[i] = 1;\n-\n-  for (i = ACCG_FIRST + NUM_ACCS; i <= ACCG_LAST; i++)\n-    fixed_regs[i] = call_used_regs[i] = 1;\n-\n   /* Reserve the registers used for conditional execution.  At present, we need\n      1 ICC and 1 ICR register.  */\n   fixed_regs[ICC_TEMP] = call_used_regs[ICC_TEMP] = 1;\n@@ -1321,9 +1426,9 @@ frv_debug_stack (frv_stack_t *info)\n \n \f\n \n-/* The following variable value is TRUE if the next output insn should\n-   finish cpu cycle.  In order words the insn will have packing bit\n-   (which means absence of asm code suffix `.p' on assembler.  */\n+/* Used during final to control the packing of insns.  The value is\n+   1 if the current instruction should be packed with the next one,\n+   0 if it shouldn't or -1 if packing is disabled altogether.  */\n \n static int frv_insn_packing_flag;\n \n@@ -1387,7 +1492,9 @@ frv_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n     }\n \n   frv_pack_insns ();\n-  frv_insn_packing_flag = TRUE;\n+\n+  /* Allow the garbage collector to free the nops created by frv_reorg.  */\n+  memset (frv_nops, 0, sizeof (frv_nops));\n }\n \n \f\n@@ -1753,12 +1860,7 @@ frv_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n    it allows the scheduler to intermix instructions with the saves of\n    the caller saved registers.  In some cases, it might be necessary\n    to emit a barrier instruction as the last insn to prevent such\n-   scheduling.\n-\n-   If SIBCALL_P is true, the final branch back to the calling function is\n-   omitted, and is used for sibling call (aka tail call) sites.  For sibcalls,\n-   we must not clobber any arguments used for parameter passing or any stack\n-   slots for arguments passed to the current function.  */\n+   scheduling.  */\n \n void\n frv_expand_epilogue (bool emit_return)\n@@ -1853,7 +1955,7 @@ frv_asm_output_mi_thunk (FILE *file,\n   const char *name_func = XSTR (XEXP (DECL_RTL (function), 0), 0);\n   const char *name_arg0 = reg_names[FIRST_ARG_REGNUM];\n   const char *name_jmp = reg_names[JUMP_REGNO];\n-  const char *parallel = ((PACKING_FLAG_USED_P ()) ? \".p\" : \"\");\n+  const char *parallel = (frv_issue_rate () > 1 ? \".p\" : \"\");\n \n   /* Do the add using an addi if possible.  */\n   if (IN_RANGE_P (delta, -2048, 2047))\n@@ -2274,7 +2376,7 @@ frv_asm_output_opcode (FILE *f, const char *ptr)\n {\n   int c;\n \n-  if (! PACKING_FLAG_USED_P())\n+  if (frv_insn_packing_flag <= 0)\n     return ptr;\n \n   for (; *ptr && *ptr != ' ' && *ptr != '\\t';)\n@@ -2294,53 +2396,31 @@ frv_asm_output_opcode (FILE *f, const char *ptr)\n \tfputc (c, f);\n     }\n \n-  if (!frv_insn_packing_flag)\n-    fprintf (f, \".p\");\n+  fprintf (f, \".p\");\n \n   return ptr;\n }\n \n-/* The following function sets up the packing bit for the current\n-   output insn.  Remember that the function is not called for asm\n-   insns.  */\n+/* Set up the packing bit for the current output insn.  Note that this\n+   function is not called for asm insns.  */\n \n void\n-frv_final_prescan_insn (rtx insn, rtx *opvec, int noperands ATTRIBUTE_UNUSED)\n+frv_final_prescan_insn (rtx insn, rtx *opvec,\n+\t\t\tint noperands ATTRIBUTE_UNUSED)\n {\n-  if (! PACKING_FLAG_USED_P())\n-    return;\n-\n-  if (!INSN_P (insn))\n-    return;\n-\n-  frv_insn_operands = opvec;\n-\n-  /* Look for the next printable instruction.  frv_pack_insns () has set\n-     things up so that any printable instruction will have TImode if it\n-     starts a new packet and VOIDmode if it should be packed with the\n-     previous instruction.\n-\n-     Printable instructions will be asm_operands or match one of the .md\n-     patterns.  Since asm instructions cannot be packed -- and will\n-     therefore have TImode -- this loop terminates on any recognizable\n-     instruction, and on any unrecognizable instruction with TImode.  */\n-  for (insn = NEXT_INSN (insn); insn; insn = NEXT_INSN (insn))\n+  if (INSN_P (insn))\n     {\n-      if (NOTE_P (insn))\n-\tcontinue;\n-      else if (!INSN_P (insn))\n-\tbreak;\n-      else if (GET_MODE (insn) == TImode || INSN_CODE (insn) != -1)\n-\tbreak;\n+      if (frv_insn_packing_flag >= 0)\n+\t{\n+\t  frv_insn_operands = opvec;\n+\t  frv_insn_packing_flag = PACKING_FLAG_P (insn);\n+\t}\n+      else if (recog_memoized (insn) >= 0\n+\t       && get_attr_acc_group (insn) == ACC_GROUP_ODD)\n+\t/* Packing optimizations have been disabled, but INSN can only\n+\t   be issued in M1.  Insert an mnop in M0.  */\n+\tfprintf (asm_out_file, \"\\tmnop.p\\n\");\n     }\n-\n-  /* Set frv_insn_packing_flag to FALSE if the next instruction should\n-     be packed with this one.  Set it to TRUE otherwise.  If the next\n-     instruction is an asm instruction, this statement will set the\n-     flag to TRUE, and that value will still hold when the asm operands\n-     themselves are printed.  */\n-  frv_insn_packing_flag = ! (insn && INSN_P (insn)\n-\t\t\t     && GET_MODE (insn) != TImode);\n }\n \n \n@@ -4685,7 +4765,7 @@ call_operand (rtx op, enum machine_mode mode)\n     return FALSE;\n \n   if (GET_CODE (op) == SYMBOL_REF)\n-    return TRUE;\n+    return !TARGET_LONG_CALLS || SYMBOL_REF_LOCAL_P (op);\n \n   /* Note this doesn't allow reg+reg or reg+imm12 addressing (which should\n      never occur anyway), but prevents reload from not handling the case\n@@ -5214,96 +5294,35 @@ condexec_intop_cmp_operator (rtx op, enum machine_mode mode)\n int\n acc_operand (rtx op, enum machine_mode mode)\n {\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  return ACC_OR_PSEUDO_P (regno);\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && REG_P (op) && ACC_P (REGNO (op))\n+\t  && ((INTVAL (op) - ACC_FIRST) & ~ACC_MASK) == 0);\n }\n \n /* Return 1 if operand is a valid even ACC register number.  */\n \n int\n even_acc_operand (rtx op, enum machine_mode mode)\n {\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  return (ACC_OR_PSEUDO_P (regno) && ((regno - ACC_FIRST) & 1) == 0);\n+  return acc_operand (op, mode) && ((REGNO (op) - ACC_FIRST) & 1) == 0;\n }\n \n /* Return 1 if operand is zero or four.  */\n \n int\n quad_acc_operand (rtx op, enum machine_mode mode)\n {\n-  int regno;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op);\n-  return (ACC_OR_PSEUDO_P (regno) && ((regno - ACC_FIRST) & 3) == 0);\n+  return acc_operand (op, mode) && ((REGNO (op) - ACC_FIRST) & 3) == 0;\n }\n \n /* Return 1 if operand is a valid ACCG register number.  */\n \n int\n accg_operand (rtx op, enum machine_mode mode)\n {\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_CODE (SUBREG_REG (op)) != REG)\n-\treturn register_operand (op, mode);\n-\n-      op = SUBREG_REG (op);\n-    }\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  return ACCG_OR_PSEUDO_P (REGNO (op));\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && REG_P (op) && ACCG_P (REGNO (op))\n+\t  && ((INTVAL (op) - ACCG_FIRST) & ~ACC_MASK) == 0);\n }\n \n \f\n@@ -5706,6 +5725,8 @@ output_move_single (rtx operands[], rtx insn)\n \t      if (GPR_P (src_regno))\n \t\treturn \"movgs %1, %0\";\n \t    }\n+\t  else if (ZERO_P (src))\n+\t    return \"movgs %., %0\";\n \t}\n     }\n \n@@ -8256,7 +8277,7 @@ frv_init_machine_status (void)\n \f\n /* Implement TARGET_SCHED_ISSUE_RATE.  */\n \n-static int\n+int\n frv_issue_rate (void)\n {\n   if (!TARGET_PACK)\n@@ -8270,597 +8291,854 @@ frv_issue_rate (void)\n       return 1;\n \n     case FRV_CPU_FR400:\n+    case FRV_CPU_FR405:\n+    case FRV_CPU_FR450:\n       return 2;\n \n     case FRV_CPU_GENERIC:\n     case FRV_CPU_FR500:\n     case FRV_CPU_TOMCAT:\n       return 4;\n+\n+    case FRV_CPU_FR550:\n+      return 8;\n     }\n }\n \f\n-/* Update the register state information, to know about which registers are set\n-   or clobbered.  */\n+/* A for_each_rtx callback.  If X refers to an accumulator, return\n+   ACC_GROUP_ODD if the bit 2 of the register number is set and\n+   ACC_GROUP_EVEN if it is clear.  Return 0 (ACC_GROUP_NONE)\n+   otherwise.  */\n \n-static void\n-frv_registers_update (rtx x,\n-                      unsigned char reg_state[],\n-                      int modified[],\n-                      int *p_num_mod,\n-                      int flag)\n+static int\n+frv_acc_group_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n {\n-  int regno, reg_max;\n-  rtx reg;\n-  rtx cond;\n-  const char *format;\n-  int length;\n-  int j;\n-\n-  switch (GET_CODE (x))\n+  if (REG_P (*x))\n     {\n-    default:\n-      break;\n-\n-      /* Clobber just modifies a register, it doesn't make it live.  */\n-    case CLOBBER:\n-      frv_registers_update (XEXP (x, 0), reg_state, modified, p_num_mod,\n-\t\t\t    flag | REGSTATE_MODIFIED);\n-      return;\n+      if (ACC_P (REGNO (*x)))\n+\treturn (REGNO (*x) - ACC_FIRST) & 4 ? ACC_GROUP_ODD : ACC_GROUP_EVEN;\n+      if (ACCG_P (REGNO (*x)))\n+\treturn (REGNO (*x) - ACCG_FIRST) & 4 ? ACC_GROUP_ODD : ACC_GROUP_EVEN;\n+    }\n+  return 0;\n+}\n \n-      /* Pre modify updates the first argument, just references the second.  */\n-    case PRE_MODIFY:\n-    case SET:\n-      frv_registers_update (XEXP (x, 0), reg_state, modified, p_num_mod,\n-\t\t\t    flag | REGSTATE_MODIFIED | REGSTATE_LIVE);\n-      frv_registers_update (XEXP (x, 1), reg_state, modified, p_num_mod, flag);\n-      return;\n+/* Return the value of INSN's acc_group attribute.  */\n \n-      /* For COND_EXEC, pass the appropriate flag to evaluate the conditional\n-         statement, but just to be sure, make sure it is the type of cond_exec\n-         we expect.  */\n-    case COND_EXEC:\n-      cond = XEXP (x, 0);\n-      if ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n-\t  && GET_CODE (XEXP (cond, 0)) == REG\n-\t  && CR_P (REGNO (XEXP (cond, 0)))\n-\t  && GET_CODE (XEXP (cond, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (cond, 1)) == 0\n-\t  && (flag & (REGSTATE_MODIFIED | REGSTATE_IF_EITHER)) == 0)\n-\t{\n-\t  frv_registers_update (cond, reg_state, modified, p_num_mod, flag);\n-\t  flag |= ((REGNO (XEXP (cond, 0)) - CR_FIRST)\n-\t\t   | ((GET_CODE (cond) == NE)\n-\t\t      ? REGSTATE_IF_TRUE\n-\t\t      : REGSTATE_IF_FALSE));\n-\n-\t  frv_registers_update (XEXP (x, 1), reg_state, modified, p_num_mod,\n-\t\t\t\tflag);\n-\t  return;\n-\t}\n-      else\n-\tfatal_insn (\"frv_registers_update\", x);\n+int\n+frv_acc_group (rtx insn)\n+{\n+  /* This distinction only applies to the FR550 packing constraints.  */\n+  if (frv_cpu_type != FRV_CPU_FR550)\n+    return ACC_GROUP_NONE;\n+  return for_each_rtx (&PATTERN (insn), frv_acc_group_1, 0);\n+}\n \n-      /* MEM resets the modification bits.  */\n-    case MEM:\n-      flag &= ~REGSTATE_MODIFIED;\n-      break;\n+/* Return the index of the DFA unit in FRV_UNIT_NAMES[] that instruction\n+   INSN will try to claim first.  Since this value depends only on the\n+   type attribute, we can cache the results in FRV_TYPE_TO_UNIT[].  */\n \n-      /* See if we need to set the modified flag.  */\n-    case SUBREG:\n-      reg = SUBREG_REG (x);\n-      if (GET_CODE (reg) == REG)\n-\t{\n-\t  regno = subreg_regno (x);\n-\t  reg_max = REGNO (reg) + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t  goto reg_common;\n-\t}\n-      break;\n+static unsigned int\n+frv_insn_unit (rtx insn)\n+{\n+  enum attr_type type;\n \n-    case REG:\n-      regno = REGNO (x);\n-      reg_max = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n-      /* Fall through.  */\n+  type = get_attr_type (insn);\n+  if (frv_type_to_unit[type] == ARRAY_SIZE (frv_unit_codes))\n+    {\n+      /* We haven't seen this type of instruction before.  */\n+      state_t state;\n+      unsigned int unit;\n \n-    reg_common:\n-      if (flag & REGSTATE_MODIFIED)\n-\t{\n-\t  flag &= REGSTATE_MASK;\n-\t  while (regno < reg_max)\n-\t    {\n-\t      int rs = reg_state[regno];\n+      /* Issue the instruction on its own to see which unit it prefers.  */\n+      state = alloca (state_size ());\n+      state_reset (state);\n+      state_transition (state, insn);\n \n-\t      if (flag != rs)\n-\t\t{\n-\t\t  if ((rs & REGSTATE_MODIFIED) == 0)\n-\t\t    {\n-\t\t      modified[ *p_num_mod ] = regno;\n-\t\t      (*p_num_mod)++;\n-\t\t    }\n+      /* Find out which unit was taken.  */\n+      for (unit = 0; unit < ARRAY_SIZE (frv_unit_codes); unit++)\n+\tif (cpu_unit_reservation_p (state, frv_unit_codes[unit]))\n+\t  break;\n \n-\t\t  /* If the previous register state had the register as\n-                     modified, possibly in some conditional execution context,\n-                     and the current insn modifies in some other context, or\n-                     outside of conditional execution, just mark the variable\n-                     as modified.  */\n-\t\t  else\n-\t\t    flag &= ~(REGSTATE_IF_EITHER | REGSTATE_CC_MASK);\n+      if (unit == ARRAY_SIZE (frv_unit_codes))\n+\tabort ();\n \n-\t\t  reg_state[regno] = (rs | flag);\n-\t\t}\n-\t      regno++;\n-\t    }\n-\t}\n-      return;\n+      frv_type_to_unit[type] = unit;\n     }\n+  return frv_type_to_unit[type];\n+}\n \n+/* Return true if INSN issues to a branch unit.  */\n \n-  length = GET_RTX_LENGTH (GET_CODE (x));\n-  format = GET_RTX_FORMAT (GET_CODE (x));\n+static bool\n+frv_issues_to_branch_unit_p (rtx insn)\n+{\n+  return frv_unit_groups[frv_insn_unit (insn)] == GROUP_B;\n+}\n+\f\n+/* The current state of the packing pass, implemented by frv_pack_insns.  */\n+static struct {\n+  /* The state of the pipeline DFA.  */\n+  state_t dfa_state;\n+\n+  /* Which hardware registers are set within the current packet,\n+     and the conditions under which they are set.  */\n+  regstate_t regstate[FIRST_PSEUDO_REGISTER];\n+\n+  /* The memory locations that have been modified so far in this\n+     packet.  MEM is the memref and COND is the regstate_t condition\n+     under which it is set.  */\n+  struct {\n+    rtx mem;\n+    regstate_t cond;\n+  } mems[2];\n+\n+  /* The number of valid entries in MEMS.  The value is larger than\n+     ARRAY_SIZE (mems) if there were too many mems to record.  */\n+  unsigned int num_mems;\n+\n+  /* The maximum number of instructions that can be packed together.  */\n+  unsigned int issue_rate;\n+\n+  /* The instructions in the packet, partitioned into groups.  */\n+  struct frv_packet_group {\n+    /* How many instructions in the packet belong to this group.  */\n+    unsigned int num_insns;\n+\n+    /* A list of the instructions that belong to this group, in the order\n+       they appear in the rtl stream.  */\n+    rtx insns[ARRAY_SIZE (frv_unit_codes)];\n+\n+    /* The contents of INSNS after they have been sorted into the correct\n+       assembly-language order.  Element X issues to unit X.  The list may\n+       contain extra nops.  */\n+    rtx sorted[ARRAY_SIZE (frv_unit_codes)];\n+\n+    /* The member of frv_nops[] to use in sorted[].  */\n+    rtx nop;\n+  } groups[NUM_GROUPS];\n+\n+  /* The instructions that make up the current packet.  */\n+  rtx insns[ARRAY_SIZE (frv_unit_codes)];\n+  unsigned int num_insns;\n+} frv_packet;\n+\n+/* Return the regstate_t flags for the given COND_EXEC condition.\n+   Abort if the condition isn't in the right form.  */\n \n-  for (j = 0; j < length; ++j)\n-    {\n-      switch (format[j])\n-\t{\n-\tcase 'e':\n-\t  frv_registers_update (XEXP (x, j), reg_state, modified, p_num_mod,\n-\t\t\t\tflag);\n-\t  break;\n+static int\n+frv_cond_flags (rtx cond)\n+{\n+  if ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n+      && GET_CODE (XEXP (cond, 0)) == REG\n+      && CR_P (REGNO (XEXP (cond, 0)))\n+      && XEXP (cond, 1) == const0_rtx)\n+    return ((REGNO (XEXP (cond, 0)) - CR_FIRST)\n+\t    | (GET_CODE (cond) == NE\n+\t       ? REGSTATE_IF_TRUE\n+\t       : REGSTATE_IF_FALSE));\n+  abort ();\n+}\n \n-\tcase 'V':\n-\tcase 'E':\n-\t  if (XVEC (x, j) != 0)\n-\t    {\n-\t      int k;\n-\t      for (k = 0; k < XVECLEN (x, j); ++k)\n-\t\tfrv_registers_update (XVECEXP (x, j, k), reg_state, modified,\n-\t\t\t\t      p_num_mod, flag);\n-\t    }\n-\t  break;\n \n-\tdefault:\n-\t  /* Nothing to do.  */\n-\t  break;\n-\t}\n-    }\n+/* Return true if something accessed under condition COND2 can\n+   conflict with something written under condition COND1.  */\n \n-  return;\n+static bool\n+frv_regstate_conflict_p (regstate_t cond1, regstate_t cond2)\n+{\n+  /* If either reference was unconditional, we have a conflict.  */\n+  if ((cond1 & REGSTATE_IF_EITHER) == 0\n+      || (cond2 & REGSTATE_IF_EITHER) == 0)\n+    return true;\n+\n+  /* The references might conflict if they were controlled by\n+     different CRs.  */\n+  if ((cond1 & REGSTATE_CC_MASK) != (cond2 & REGSTATE_CC_MASK))\n+    return true;\n+\n+  /* They definitely conflict if they are controlled by the\n+     same condition.  */\n+  if ((cond1 & cond2 & REGSTATE_IF_EITHER) != 0)\n+    return true;\n+\n+  return false;\n }\n \n-\f\n-/* Return if any registers in a hard register set were used an insn.  */\n+\n+/* A for_each_rtx callback.  Return 1 if *X depends on an instruction in\n+   the current packet.  DATA points to a regstate_t that describes the\n+   condition under which *X might be set or used.  */\n \n static int\n-frv_registers_used_p (rtx x, unsigned char reg_state[], int flag)\n+frv_registers_conflict_p_1 (rtx *x, void *data)\n {\n-  int regno, reg_max;\n-  rtx reg;\n-  rtx cond;\n-  rtx dest;\n-  const char *format;\n-  int result;\n-  int length;\n-  int j;\n+  unsigned int regno, i;\n+  regstate_t cond;\n \n-  switch (GET_CODE (x))\n-    {\n-    default:\n-      break;\n+  cond = *(regstate_t *) data;\n \n-      /* Skip clobber, that doesn't use the previous value.  */\n-    case CLOBBER:\n-      return FALSE;\n+  if (GET_CODE (*x) == REG)\n+    FOR_EACH_REGNO (regno, *x)\n+      if ((frv_packet.regstate[regno] & REGSTATE_MODIFIED) != 0)\n+\tif (frv_regstate_conflict_p (frv_packet.regstate[regno], cond))\n+\t  return 1;\n \n-      /* For SET, if a conditional jump has occurred in the same insn, only\n-\t allow a set of a CR register if that register is not currently live.\n-\t This is because on the FR-V, B0/B1 instructions are always last.\n-\t Otherwise, don't look at the result, except within a MEM, but do look\n-\t at the source.  */\n-    case SET:\n-      dest = SET_DEST (x);\n-      if (flag & REGSTATE_CONDJUMP\n-\t  && GET_CODE (dest) == REG && CR_P (REGNO (dest))\n-\t  && (reg_state[ REGNO (dest) ] & REGSTATE_LIVE) != 0)\n-\treturn TRUE;\n+  if (GET_CODE (*x) == MEM)\n+    {\n+      /* If we ran out of memory slots, assume a conflict.  */\n+      if (frv_packet.num_mems > ARRAY_SIZE (frv_packet.mems))\n+\treturn 1;\n \n-      if (GET_CODE (dest) == MEM)\n-\t{\n-\t  result = frv_registers_used_p (XEXP (dest, 0), reg_state, flag);\n-\t  if (result)\n-\t    return result;\n-\t}\n+      /* Check for output or true dependencies with earlier MEMs.  */\n+      for (i = 0; i < frv_packet.num_mems; i++)\n+\tif (frv_regstate_conflict_p (frv_packet.mems[i].cond, cond))\n+\t  {\n+\t    if (true_dependence (frv_packet.mems[i].mem, VOIDmode,\n+\t\t\t\t *x, rtx_varies_p))\n+\t      return 1;\n \n-      return frv_registers_used_p (SET_SRC (x), reg_state, flag);\n-\n-      /* For COND_EXEC, pass the appropriate flag to evaluate the conditional\n-         statement, but just to be sure, make sure it is the type of cond_exec\n-         we expect.  */\n-    case COND_EXEC:\n-      cond = XEXP (x, 0);\n-      if ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n-\t  && GET_CODE (XEXP (cond, 0)) == REG\n-\t  && CR_P (REGNO (XEXP (cond, 0)))\n-\t  && GET_CODE (XEXP (cond, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (cond, 1)) == 0\n-\t  && (flag & (REGSTATE_MODIFIED | REGSTATE_IF_EITHER)) == 0)\n-\t{\n-\t  result = frv_registers_used_p (cond, reg_state, flag);\n-\t  if (result)\n-\t    return result;\n+\t    if (output_dependence (frv_packet.mems[i].mem, *x))\n+\t      return 1;\n+\t  }\n+    }\n \n-\t  flag |= ((REGNO (XEXP (cond, 0)) - CR_FIRST)\n-\t\t   | ((GET_CODE (cond) == NE)\n-\t\t      ? REGSTATE_IF_TRUE\n-\t\t      : REGSTATE_IF_FALSE));\n+  /* The return values of calls aren't significant: they describe\n+     the effect of the call as a whole, not of the insn itself.  */\n+  if (GET_CODE (*x) == SET && GET_CODE (SET_SRC (*x)) == CALL)\n+    {\n+      if (for_each_rtx (&SET_SRC (*x), frv_registers_conflict_p_1, data))\n+\treturn 1;\n+      return -1;\n+    }\n \n-\t  return frv_registers_used_p (XEXP (x, 1), reg_state, flag);\n-\t}\n-      else\n-\tfatal_insn (\"frv_registers_used_p\", x);\n+  /* Check subexpressions.  */\n+  return 0;\n+}\n \n-      /* See if a register or subreg was modified in the same VLIW insn.  */\n-    case SUBREG:\n-      reg = SUBREG_REG (x);\n-      if (GET_CODE (reg) == REG)\n-\t{\n-\t  regno = subreg_regno (x);\n-\t  reg_max = REGNO (reg) + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t  goto reg_common;\n-\t}\n-      break;\n \n-    case REG:\n-      regno = REGNO (x);\n-      reg_max = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n-      /* Fall through.  */\n+/* Return true if something in X might depend on an instruction\n+   in the current packet.  */\n \n-    reg_common:\n-      while (regno < reg_max)\n-\t{\n-\t  int rs = reg_state[regno];\n+static bool\n+frv_registers_conflict_p (rtx x)\n+{\n+  regstate_t flags;\n \n-\t  if (rs & REGSTATE_MODIFIED)\n-\t    {\n-\t      int rs_if = rs & REGSTATE_IF_EITHER;\n-\t      int flag_if = flag & REGSTATE_IF_EITHER;\n-\n-\t      /* Simple modification, no conditional execution */\n-\t      if ((rs & REGSTATE_IF_EITHER) == 0)\n-\t\treturn TRUE;\n-\n-\t      /* See if the variable is only modified in a conditional\n-\t\t execution expression opposite to the conditional execution\n-\t\t expression that governs this expression (ie, true vs. false\n-\t\t for the same CC register).  If this isn't two halves of the\n-\t\t same conditional expression, consider the register\n-\t\t modified.  */\n-\t      if (((rs_if == REGSTATE_IF_TRUE && flag_if == REGSTATE_IF_FALSE)\n-\t\t   || (rs_if == REGSTATE_IF_FALSE && flag_if == REGSTATE_IF_TRUE))\n-\t\t  && ((rs & REGSTATE_CC_MASK) == (flag & REGSTATE_CC_MASK)))\n-\t\t;\n-\t      else\n-\t\treturn TRUE;\n-\t    }\n+  flags = 0;\n+  if (GET_CODE (x) == COND_EXEC)\n+    {\n+      if (for_each_rtx (&XEXP (x, 0), frv_registers_conflict_p_1, &flags))\n+\treturn true;\n \n-\t  regno++;\n-\t}\n-      return FALSE;\n+      flags |= frv_cond_flags (XEXP (x, 0));\n+      x = XEXP (x, 1);\n     }\n+  return for_each_rtx (&x, frv_registers_conflict_p_1, &flags);\n+}\n \n \n-  length = GET_RTX_LENGTH (GET_CODE (x));\n-  format = GET_RTX_FORMAT (GET_CODE (x));\n+/* A note_stores callback.  DATA points to the regstate_t condition\n+   under which X is modified.  Update FRV_PACKET accordingly.  */\n \n-  for (j = 0; j < length; ++j)\n+static void\n+frv_registers_update_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  unsigned int regno;\n+\n+  if (GET_CODE (x) == REG)\n+    FOR_EACH_REGNO (regno, x)\n+      frv_packet.regstate[regno] |= *(regstate_t *) data;\n+\n+  if (GET_CODE (x) == MEM)\n     {\n-      switch (format[j])\n+      if (frv_packet.num_mems < ARRAY_SIZE (frv_packet.mems))\n \t{\n-\tcase 'e':\n-\t  result = frv_registers_used_p (XEXP (x, j), reg_state, flag);\n-\t  if (result != 0)\n-\t    return result;\n-\t  break;\n+\t  frv_packet.mems[frv_packet.num_mems].mem = x;\n+\t  frv_packet.mems[frv_packet.num_mems].cond = *(regstate_t *) data;\n+\t}\n+      frv_packet.num_mems++;\n+    }\n+}\n \n-\tcase 'V':\n-\tcase 'E':\n-\t  if (XVEC (x, j) != 0)\n-\t    {\n-\t      int k;\n-\t      for (k = 0; k < XVECLEN (x, j); ++k)\n-\t\t{\n-\t\t  result = frv_registers_used_p (XVECEXP (x, j, k), reg_state,\n-\t\t\t\t\t\t flag);\n-\t\t  if (result != 0)\n-\t\t    return result;\n-\t\t}\n-\t    }\n-\t  break;\n \n-\tdefault:\n-\t  /* Nothing to do.  */\n-\t  break;\n-\t}\n+/* Update the register state information for an instruction whose\n+   body is X.  */\n+\n+static void\n+frv_registers_update (rtx x)\n+{\n+  regstate_t flags;\n+\n+  flags = REGSTATE_MODIFIED;\n+  if (GET_CODE (x) == COND_EXEC)\n+    {\n+      flags |= frv_cond_flags (XEXP (x, 0));\n+      x = XEXP (x, 1);\n     }\n+  note_stores (x, frv_registers_update_1, &flags);\n+}\n \n-  return 0;\n+\n+/* Initialize frv_packet for the start of a new packet.  */\n+\n+static void\n+frv_start_packet (void)\n+{\n+  enum frv_insn_group group;\n+\n+  memset (frv_packet.regstate, 0, sizeof (frv_packet.regstate));\n+  frv_packet.num_mems = 0;\n+  frv_packet.num_insns = 0;\n+  for (group = 0; group < NUM_GROUPS; group++)\n+    frv_packet.groups[group].num_insns = 0;\n }\n \n-/* Return if any registers in a hard register set were set in an insn.  */\n \n-static int\n-frv_registers_set_p (rtx x, unsigned char reg_state[], int modify_p)\n+/* Likewise for the start of a new basic block.  */\n+\n+static void\n+frv_start_packet_block (void)\n {\n-  int regno, reg_max;\n-  rtx reg;\n-  rtx cond;\n-  const char *format;\n-  int length;\n-  int j;\n+  state_reset (frv_packet.dfa_state);\n+  frv_start_packet ();\n+}\n \n-  switch (GET_CODE (x))\n+\n+/* Finish the current packet, if any, and start a new one.  Call\n+   HANDLE_PACKET with FRV_PACKET describing the completed packet.  */\n+\n+static void\n+frv_finish_packet (void (*handle_packet) (void))\n+{\n+  if (frv_packet.num_insns > 0)\n     {\n-    default:\n-      break;\n+      handle_packet ();\n+      state_transition (frv_packet.dfa_state, 0);\n+      frv_start_packet ();\n+    }\n+}\n \n-    case CLOBBER:\n-      return frv_registers_set_p (XEXP (x, 0), reg_state, TRUE);\n \n-    case PRE_MODIFY:\n-    case SET:\n-      return (frv_registers_set_p (XEXP (x, 0), reg_state, TRUE)\n-\t      || frv_registers_set_p (XEXP (x, 1), reg_state, FALSE));\n-\n-    case COND_EXEC:\n-      cond = XEXP (x, 0);\n-      /* Just to be sure, make sure it is the type of cond_exec we\n-         expect.  */\n-      if ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n-\t  && GET_CODE (XEXP (cond, 0)) == REG\n-\t  && CR_P (REGNO (XEXP (cond, 0)))\n-\t  && GET_CODE (XEXP (cond, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (cond, 1)) == 0\n-\t  && !modify_p)\n-\treturn frv_registers_set_p (XEXP (x, 1), reg_state, modify_p);\n-      else\n-\tfatal_insn (\"frv_registers_set_p\", x);\n+/* Return true if INSN can be added to the current packet.  Update\n+   the DFA state on success.  */\n \n-      /* MEM resets the modification bits.  */\n-    case MEM:\n-      modify_p = FALSE;\n-      break;\n+static bool\n+frv_pack_insn_p (rtx insn)\n+{\n+  /* See if the packet is already as long as it can be.  */\n+  if (frv_packet.num_insns == frv_packet.issue_rate)\n+    return false;\n \n-      /* See if we need to set the modified modify_p.  */\n-    case SUBREG:\n-      reg = SUBREG_REG (x);\n-      if (GET_CODE (reg) == REG)\n-\t{\n-\t  regno = subreg_regno (x);\n-\t  reg_max = REGNO (reg) + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t  goto reg_common;\n-\t}\n-      break;\n+  /* If the scheduler thought that an instruction should start a packet,\n+     it's usually a good idea to believe it.  It knows much more about\n+     the latencies than we do.\n \n-    case REG:\n-      regno = REGNO (x);\n-      reg_max = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n-      /* Fall through.  */\n+     There are some exceptions though:\n \n-    reg_common:\n-      if (modify_p)\n-\twhile (regno < reg_max)\n-\t  {\n-\t    int rs = reg_state[regno];\n+       - Conditional instructions are scheduled on the assumption that\n+\t they will be executed.  This is usually a good thing, since it\n+\t tends to avoid unncessary stalls in the conditional code.\n+\t But we want to pack conditional instructions as tightly as\n+\t possible, in order to optimize the case where they aren't\n+\t executed.\n \n-\t    if (rs & REGSTATE_MODIFIED)\n-\t      return TRUE;\n-\t    regno++;\n-\t  }\n-      return FALSE;\n-    }\n+       - The scheduler will always put branches on their own, even\n+\t if there's no real dependency.\n \n+       - There's no point putting a call in its own packet unless\n+\t we have to.  */\n+  if (frv_packet.num_insns > 0\n+      && GET_CODE (insn) == INSN\n+      && GET_MODE (insn) == TImode\n+      && GET_CODE (PATTERN (insn)) != COND_EXEC)\n+    return false;\n \n-  length = GET_RTX_LENGTH (GET_CODE (x));\n-  format = GET_RTX_FORMAT (GET_CODE (x));\n+  /* Check for register conflicts.  Don't do this for setlo since any\n+     conflict will be with the partnering sethi, with which it can\n+     be packed.  */\n+  if (get_attr_type (insn) != TYPE_SETLO)\n+    if (frv_registers_conflict_p (PATTERN (insn)))\n+      return false;\n \n-  for (j = 0; j < length; ++j)\n-    {\n-      switch (format[j])\n-\t{\n-\tcase 'e':\n-\t  if (frv_registers_set_p (XEXP (x, j), reg_state, modify_p))\n-\t    return TRUE;\n-\t  break;\n+  return state_transition (frv_packet.dfa_state, insn) < 0;\n+}\n \n-\tcase 'V':\n-\tcase 'E':\n-\t  if (XVEC (x, j) != 0)\n-\t    {\n-\t      int k;\n-\t      for (k = 0; k < XVECLEN (x, j); ++k)\n-\t\tif (frv_registers_set_p (XVECEXP (x, j, k), reg_state,\n-\t\t\t\t\t modify_p))\n-\t\t  return TRUE;\n-\t    }\n-\t  break;\n \n-\tdefault:\n-\t  /* Nothing to do.  */\n-\t  break;\n-\t}\n-    }\n+/* Add instruction INSN to the current packet.  */\n \n-  return FALSE;\n+static void\n+frv_add_insn_to_packet (rtx insn)\n+{\n+  struct frv_packet_group *packet_group;\n+\n+  packet_group = &frv_packet.groups[frv_unit_groups[frv_insn_unit (insn)]];\n+  packet_group->insns[packet_group->num_insns++] = insn;\n+  frv_packet.insns[frv_packet.num_insns++] = insn;\n+\n+  frv_registers_update (PATTERN (insn));\n }\n \n-\f\n-/* On the FR-V, this pass is used to rescan the insn chain, and pack\n-   conditional branches/calls/jumps, etc. with previous insns where it can.  It\n-   does not reorder the instructions.  We assume the scheduler left the flow\n-   information in a reasonable state.  */\n+\n+/* Insert INSN (a member of frv_nops[]) into the current packet.  If the\n+   packet ends in a branch or call, insert the nop before it, otherwise\n+   add to the end.  */\n \n static void\n-frv_pack_insns (void)\n+frv_insert_nop_in_packet (rtx insn)\n {\n-  state_t frv_state;\t\t\t/* frv state machine */\n-  int cur_start_vliw_p;\t\t\t/* current insn starts a VLIW insn */\n-  int next_start_vliw_p;\t\t/* next insn starts a VLIW insn */\n-  int cur_condjump_p;\t\t\t/* flag if current insn is a cond jump*/\n-  int next_condjump_p;\t\t\t/* flag if next insn is a cond jump */\n-  rtx insn;\n-  rtx link;\n-  int j;\n-  int num_mod = 0;\t\t\t/* # of modified registers */\n-  int modified[FIRST_PSEUDO_REGISTER];\t/* registers modified in current VLIW */\n-\t\t\t\t\t/* register state information */\n-  unsigned char reg_state[FIRST_PSEUDO_REGISTER];\n+  struct frv_packet_group *packet_group;\n+  rtx last;\n+\n+  packet_group = &frv_packet.groups[frv_unit_groups[frv_insn_unit (insn)]];\n+  last = frv_packet.insns[frv_packet.num_insns - 1];\n+  if (GET_CODE (last) != INSN)\n+    {\n+      insn = emit_insn_before (PATTERN (insn), last);\n+      frv_packet.insns[frv_packet.num_insns - 1] = insn;\n+      frv_packet.insns[frv_packet.num_insns++] = last;\n+    }\n+  else\n+    {\n+      insn = emit_insn_after (PATTERN (insn), last);\n+      frv_packet.insns[frv_packet.num_insns++] = insn;\n+    }\n+  packet_group->insns[packet_group->num_insns++] = insn;\n+}\n+\n \n-  /* If we weren't going to pack the insns, don't bother with this pass.  */\n+/* If packing is enabled, divide the instructions into packets and\n+   return true.  Call HANDLE_PACKET for each complete packet.  */\n+\n+static bool\n+frv_for_each_packet (void (*handle_packet) (void))\n+{\n+  rtx insn, next_insn;\n+\n+  frv_packet.issue_rate = frv_issue_rate ();\n+\n+  /* Early exit if we don't want to pack insns.  */\n   if (!optimize\n       || !flag_schedule_insns_after_reload\n       || TARGET_NO_VLIW_BRANCH\n-      || frv_issue_rate () == 1)\n-    return;\n+      || frv_packet.issue_rate == 1)\n+    return false;\n \n-  /* Set up the instruction and register states.  */\n+  /* Set up the initial packing state.  */\n   dfa_start ();\n-  frv_state = (state_t) xmalloc (state_size ());\n-  memset (reg_state, REGSTATE_DEAD, sizeof (reg_state));\n-\n-  /* Go through the insns, and repack the insns.  */\n-  state_reset (frv_state);\n-  cur_start_vliw_p = FALSE;\n-  next_start_vliw_p = TRUE;\n-  cur_condjump_p = 0;\n-  next_condjump_p = 0;\n+  frv_packet.dfa_state = alloca (state_size ());\n \n-  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+  frv_start_packet_block ();\n+  for (insn = get_insns (); insn != 0; insn = next_insn)\n     {\n-      enum rtx_code code = GET_CODE (insn);\n-      enum rtx_code pattern_code;\n+      enum rtx_code code;\n+      bool eh_insn_p;\n \n-      /* For basic block begin notes redo the live information, and skip other\n-         notes.  */\n-      if (code == NOTE)\n+      code = GET_CODE (insn);\n+      next_insn = NEXT_INSN (insn);\n+\n+      if (code == CODE_LABEL)\n \t{\n-\t  if (NOTE_LINE_NUMBER (insn) == (int)NOTE_INSN_BASIC_BLOCK)\n-\t    {\n-\t      regset live;\n+\t  frv_finish_packet (handle_packet);\n+\t  frv_start_packet_block ();\n+\t}\n \n-\t      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\t\treg_state[j] &= ~ REGSTATE_LIVE;\n+      if (INSN_P (insn))\n+\tswitch (GET_CODE (PATTERN (insn)))\n+\t  {\n+\t  case USE:\n+\t  case CLOBBER:\n+\t  case ADDR_VEC:\n+\t  case ADDR_DIFF_VEC:\n+\t    break;\n \n-\t      live = NOTE_BASIC_BLOCK (insn)->global_live_at_start;\n-\t      EXECUTE_IF_SET_IN_REG_SET(live, 0, j,\n-\t\t\t\t\t{\n-\t\t\t\t\t  reg_state[j] |= REGSTATE_LIVE;\n-\t\t\t\t\t});\n-\t    }\n+\t  default:\n+\t    /* Calls mustn't be packed on a TOMCAT.  */\n+\t    if (GET_CODE (insn) == CALL_INSN && frv_cpu_type == FRV_CPU_TOMCAT)\n+\t      frv_finish_packet (handle_packet);\n+\n+\t    /* Since the last instruction in a packet determines the EH\n+\t       region, any exception-throwing instruction must come at\n+\t       the end of reordered packet.  Insns that issue to a\n+\t       branch unit are bound to come last; for others it's\n+\t       too hard to predict.  */\n+\t    eh_insn_p = (find_reg_note (insn, REG_EH_REGION, NULL) != NULL);\n+\t    if (eh_insn_p && !frv_issues_to_branch_unit_p (insn))\n+\t      frv_finish_packet (handle_packet);\n+\n+\t    /* Finish the current packet if we can't add INSN to it.\n+\t       Simulate cycles until INSN is ready to issue.  */\n+\t    if (!frv_pack_insn_p (insn))\n+\t      {\n+\t\tfrv_finish_packet (handle_packet);\n+\t\twhile (!frv_pack_insn_p (insn))\n+\t\t  state_transition (frv_packet.dfa_state, 0);\n+\t      }\n \n-\t  continue;\n-\t}\n+\t    /* Add the instruction to the packet.  */\n+\t    frv_add_insn_to_packet (insn);\n+\n+\t    /* Calls and jumps end a packet, as do insns that throw\n+\t       an exception.  */\n+\t    if (code == CALL_INSN || code == JUMP_INSN || eh_insn_p)\n+\t      frv_finish_packet (handle_packet);\n+\t    break;\n+\t  }\n+    }\n+  frv_finish_packet (handle_packet);\n+  dfa_finish ();\n+  return true;\n+}\n+\f\n+/* Subroutine of frv_sort_insn_group.  We are trying to sort\n+   frv_packet.groups[GROUP].sorted[0...NUM_INSNS-1] into assembly\n+   language order.  We have already picked a new position for\n+   frv_packet.groups[GROUP].sorted[X] if bit X of ISSUED is set.\n+   These instructions will occupy elements [0, LOWER_SLOT) and\n+   [UPPER_SLOT, NUM_INSNS) of the final (sorted) array.  STATE is\n+   the DFA state after issuing these instructions.\n+\n+   Try filling elements [LOWER_SLOT, UPPER_SLOT) with every permutation\n+   of the unused instructions.  Return true if one such permutation gives\n+   a valid ordering, leaving the successful permutation in sorted[].\n+   Do not modify sorted[] until a valid permutation is found.  */\n+\n+static bool\n+frv_sort_insn_group_1 (enum frv_insn_group group,\n+\t\t       unsigned int lower_slot, unsigned int upper_slot,\n+\t\t       unsigned int issued, unsigned int num_insns,\n+\t\t       state_t state)\n+{\n+  struct frv_packet_group *packet_group;\n+  unsigned int i;\n+  state_t test_state;\n+  size_t dfa_size;\n+  rtx insn;\n+\n+  /* Early success if we've filled all the slots.  */\n+  if (lower_slot == upper_slot)\n+    return true;\n+\n+  packet_group = &frv_packet.groups[group];\n+  dfa_size = state_size ();\n+  test_state = alloca (dfa_size);\n+\n+  /* Try issuing each unused instruction.  */\n+  for (i = num_insns - 1; i + 1 != 0; i--)\n+    if (~issued & (1 << i))\n+      {\n+\tinsn = packet_group->sorted[i];\n+\tmemcpy (test_state, state, dfa_size);\n+\tif (state_transition (test_state, insn) < 0\n+\t    && cpu_unit_reservation_p (test_state,\n+\t\t\t\t       NTH_UNIT (group, upper_slot - 1))\n+\t    && frv_sort_insn_group_1 (group, lower_slot, upper_slot - 1,\n+\t\t\t\t      issued | (1 << i), num_insns,\n+\t\t\t\t      test_state))\n+\t  {\n+\t    packet_group->sorted[upper_slot - 1] = insn;\n+\t    return true;\n+\t  }\n+      }\n+\n+  return false;\n+}\n+\n+/* Compare two instructions by their frv_insn_unit.  */\n+\n+static int\n+frv_compare_insns (const void *first, const void *second)\n+{\n+  const rtx *insn1 = first, *insn2 = second;\n+  return frv_insn_unit (*insn1) - frv_insn_unit (*insn2);\n+}\n+\n+/* Copy frv_packet.groups[GROUP].insns[] to frv_packet.groups[GROUP].sorted[]\n+   and sort it into assembly language order.  See frv.md for a description of\n+   the algorithm.  */\n+\n+static void\n+frv_sort_insn_group (enum frv_insn_group group)\n+{\n+  struct frv_packet_group *packet_group;\n+  unsigned int first, i, nop, max_unit, num_slots;\n+  state_t state, test_state;\n+  size_t dfa_size;\n+\n+  packet_group = &frv_packet.groups[group];\n+  if (packet_group->num_insns == 0)\n+    return;\n+\n+  /* Copy insns[] to sorted[].  */\n+  memcpy (packet_group->sorted, packet_group->insns,\n+\t  sizeof (rtx) * packet_group->num_insns);\n+\n+  /* Sort sorted[] by the unit that each insn tries to take first.  */\n+  if (packet_group->num_insns > 1)\n+    qsort (packet_group->sorted, packet_group->num_insns,\n+\t   sizeof (rtx), frv_compare_insns);\n+\n+  /* That's always enough for branch and control insns.  */\n+  if (group == GROUP_B || group == GROUP_C)\n+    return;\n+\n+  dfa_size = state_size ();\n+  state = alloca (dfa_size);\n+  test_state = alloca (dfa_size);\n+\n+  /* Find the highest FIRST such that sorted[0...FIRST-1] can issue\n+     consecutively and such that the DFA takes unit X when sorted[X]\n+     is added.  Set STATE to the new DFA state.  */\n+  state_reset (test_state);\n+  for (first = 0; first < packet_group->num_insns; first++)\n+    {\n+      memcpy (state, test_state, dfa_size);\n+      if (state_transition (test_state, packet_group->sorted[first]) >= 0\n+\t  || !cpu_unit_reservation_p (test_state, NTH_UNIT (group, first)))\n+\tbreak;\n+    }\n+\n+  /* If all the instructions issued in ascending order, we're done.  */\n+  if (first == packet_group->num_insns)\n+    return;\n \n-      /* Things like labels reset everything.  */\n-      if (!INSN_P (insn))\n+  /* Add nops to the end of sorted[] and try each permutation until\n+     we find one that works.  */\n+  for (nop = 0; nop < frv_num_nops; nop++)\n+    {\n+      max_unit = frv_insn_unit (frv_nops[nop]);\n+      if (frv_unit_groups[max_unit] == group)\n \t{\n-\t  next_start_vliw_p = TRUE;\n-\t  continue;\n+\t  packet_group->nop = frv_nops[nop];\n+\t  num_slots = UNIT_NUMBER (max_unit) + 1;\n+\t  for (i = packet_group->num_insns; i < num_slots; i++)\n+\t    packet_group->sorted[i] = frv_nops[nop];\n+\t  if (frv_sort_insn_group_1 (group, first, num_slots,\n+\t\t\t\t     (1 << first) - 1, num_slots, state))\n+\t    return;\n \t}\n+    }\n+  abort ();\n+}\n+\f\n+/* Sort the current packet into assembly-language order.  Set packing\n+   flags as appropriate.  */\n \n-      /* Clear the VLIW start flag on random USE and CLOBBER insns, which is\n-         set on the USE insn that precedes the return, and potentially on\n-         CLOBBERs for setting multiword variables.  Also skip the ADDR_VEC\n-         holding the case table labels.  */\n-      pattern_code = GET_CODE (PATTERN (insn));\n-      if (pattern_code == USE || pattern_code == CLOBBER\n-\t  || pattern_code == ADDR_VEC || pattern_code == ADDR_DIFF_VEC)\n+static void\n+frv_reorder_packet (void)\n+{\n+  unsigned int cursor[NUM_GROUPS];\n+  rtx insns[ARRAY_SIZE (frv_unit_groups)];\n+  unsigned int unit, to, from;\n+  enum frv_insn_group group;\n+  struct frv_packet_group *packet_group;\n+\n+  /* First sort each group individually.  */\n+  for (group = 0; group < NUM_GROUPS; group++)\n+    {\n+      cursor[group] = 0;\n+      frv_sort_insn_group (group);\n+    }\n+\n+  /* Go through the unit template and try add an instruction from\n+     that unit's group.  */\n+  to = 0;\n+  for (unit = 0; unit < ARRAY_SIZE (frv_unit_groups); unit++)\n+    {\n+      group = frv_unit_groups[unit];\n+      packet_group = &frv_packet.groups[group];\n+      if (cursor[group] < packet_group->num_insns)\n \t{\n-\t  CLEAR_VLIW_START (insn);\n-\t  continue;\n+\t  /* frv_reorg should have added nops for us.  */\n+\t  if (packet_group->sorted[cursor[group]] == packet_group->nop)\n+\t    abort ();\n+\t  insns[to++] = packet_group->sorted[cursor[group]++];\n \t}\n+    }\n \n-      cur_start_vliw_p = next_start_vliw_p;\n-      next_start_vliw_p = FALSE;\n+  if (to != frv_packet.num_insns)\n+    abort ();\n \n-      cur_condjump_p |= next_condjump_p;\n-      next_condjump_p = 0;\n+  /* Clear the last instruction's packing flag, thus marking the end of\n+     a packet.  Reorder the other instructions relative to it.  */\n+  CLEAR_PACKING_FLAG (insns[to - 1]);\n+  for (from = 0; from < to - 1; from++)\n+    {\n+      remove_insn (insns[from]);\n+      add_insn_before (insns[from], insns[to - 1]);\n+      SET_PACKING_FLAG (insns[from]);\n+    }\n+}\n \n-      /* Unconditional branches and calls end the current VLIW insn.  */\n-      if (code == CALL_INSN)\n-\t{\n-\t  next_start_vliw_p = TRUE;\n \n-\t  /* On a TOMCAT, calls must be alone in the VLIW insns.  */\n-\t  if (frv_cpu_type == FRV_CPU_TOMCAT)\n-\t    cur_start_vliw_p = TRUE;\n-\t}\n-      else if (code == JUMP_INSN)\n-\t{\n-\t  if (any_condjump_p (insn))\n-\t    next_condjump_p = REGSTATE_CONDJUMP;\n-\t  else\n-\t    next_start_vliw_p = TRUE;\n-\t}\n+/* Divide instructions into packets.  Reorder the contents of each\n+   packet so that they are in the correct assembly-language order.\n+\n+   Since this pass can change the raw meaning of the rtl stream, it must\n+   only be called at the last minute, just before the instructions are\n+   written out.  */\n+\n+static void\n+frv_pack_insns (void)\n+{\n+  if (frv_for_each_packet (frv_reorder_packet))\n+    frv_insn_packing_flag = 0;\n+  else\n+    frv_insn_packing_flag = -1;\n+}\n+\f\n+/* See whether we need to add nops to group GROUP in order to\n+   make a valid packet.  */\n+\n+static void\n+frv_fill_unused_units (enum frv_insn_group group)\n+{\n+  unsigned int non_nops, nops, i;\n+  struct frv_packet_group *packet_group;\n+\n+  packet_group = &frv_packet.groups[group];\n+\n+  /* Sort the instructions into assembly-language order.\n+     Use nops to fill slots that are otherwise unused.  */\n+  frv_sort_insn_group (group);\n+\n+  /* See how many nops are needed before the final useful instruction.  */\n+  i = nops = 0;\n+  for (non_nops = 0; non_nops < packet_group->num_insns; non_nops++)\n+    while (packet_group->sorted[i++] == packet_group->nop)\n+      nops++;\n+\n+  /* Insert that many nops into the instruction stream.  */\n+  while (nops-- > 0)\n+    frv_insert_nop_in_packet (packet_group->nop);\n+}\n+\n+/* Used by frv_reorg to keep track of the current packet's address.  */\n+static unsigned int frv_packet_address;\n \n-      /* Only allow setting a CCR register after a conditional branch.  */\n-      else if (((cur_condjump_p & REGSTATE_CONDJUMP) != 0)\n-\t       && get_attr_type (insn) != TYPE_CCR)\n-\tcur_start_vliw_p = TRUE;\n-\n-      /* Determine if we need to start a new VLIW instruction.  */\n-      if (cur_start_vliw_p\n-\t  /* Do not check for register conflicts in a setlo instruction\n-\t     because any output or true dependencies will be with the\n-\t     partnering sethi instruction, with which it can be packed.\n-\n-\t     Although output dependencies are rare they are still\n-\t     possible.  So check output dependencies in VLIW insn.  */\n-\t  || (get_attr_type (insn) != TYPE_SETLO\n-\t      && (frv_registers_used_p (PATTERN (insn),\n-\t\t\t\t\treg_state,\n-\t\t\t\t\tcur_condjump_p)\n-\t\t  || frv_registers_set_p (PATTERN (insn), reg_state, FALSE)))\n-\t  || state_transition (frv_state, insn) >= 0)\n+/* If the current packet falls through to a label, try to pad the packet\n+   with nops in order to fit the label's alignment requirements.  */\n+\n+static void\n+frv_align_label (void)\n+{\n+  unsigned int alignment, target, nop;\n+  rtx x, last, barrier, label;\n+\n+  /* Walk forward to the start of the next packet.  Set ALIGNMENT to the\n+     maximum alignment of that packet, LABEL to the last label between\n+     the packets, and BARRIER to the last barrier.  */\n+  last = frv_packet.insns[frv_packet.num_insns - 1];\n+  label = barrier = 0;\n+  alignment = 4;\n+  for (x = NEXT_INSN (last); x != 0 && !INSN_P (x); x = NEXT_INSN (x))\n+    {\n+      if (LABEL_P (x))\n \t{\n-\t  SET_VLIW_START (insn);\n-\t  state_reset (frv_state);\n-\t  state_transition (frv_state, insn);\n-\t  cur_condjump_p = 0;\n-\n-\t  /* Update the modified registers.  */\n-\t  for (j = 0; j < num_mod; j++)\n-\t    reg_state[ modified[j] ] &= ~(REGSTATE_CC_MASK\n-\t\t\t\t\t  | REGSTATE_IF_EITHER\n-\t\t\t\t\t  | REGSTATE_MODIFIED);\n-\n-\t  num_mod = 0;\n+\t  unsigned int subalign = 1 << label_to_alignment (x);\n+\t  alignment = MAX (alignment, subalign);\n+\t  label = x;\n \t}\n-      else\n-\tCLEAR_VLIW_START (insn);\n+      if (BARRIER_P (x))\n+\tbarrier = x;\n+    }\n \n-      /* Record which registers are modified.  */\n-      frv_registers_update (PATTERN (insn), reg_state, modified, &num_mod, 0);\n+  /* If -malign-labels, and the packet falls through to an unaligned\n+     label, try introducing a nop to align that label to 8 bytes.  */\n+  if (TARGET_ALIGN_LABELS\n+      && label != 0\n+      && barrier == 0\n+      && frv_packet.num_insns < frv_packet.issue_rate)\n+    alignment = MAX (alignment, 8);\n \n-      /* Process the death notices.  */\n-      for (link = REG_NOTES (insn);\n-\t   link != NULL_RTX;\n-\t   link = XEXP (link, 1))\n-\t{\n-\t  rtx reg = XEXP (link, 0);\n+  /* Advance the address to the end of the current packet.  */\n+  frv_packet_address += frv_packet.num_insns * 4;\n \n-\t  if (REG_NOTE_KIND (link) == REG_DEAD && GET_CODE (reg) == REG)\n-\t    {\n-\t      int regno = REGNO (reg);\n-\t      int n = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t      for (; regno < n; regno++)\n-\t\treg_state[regno] &= ~REGSTATE_LIVE;\n-\t    }\n+  /* Work out the target address, after alignment.  */\n+  target = (frv_packet_address + alignment - 1) & -alignment;\n+\n+  /* If the packet falls through to the label, try to find an efficient\n+     padding sequence.  */\n+  if (barrier == 0)\n+    {\n+      /* First try adding nops to the current packet.  */\n+      for (nop = 0; nop < frv_num_nops; nop++)\n+\twhile (frv_packet_address < target && frv_pack_insn_p (frv_nops[nop]))\n+\t  {\n+\t    frv_insert_nop_in_packet (frv_nops[nop]);\n+\t    frv_packet_address += 4;\n+\t  }\n+\n+      /* If we still haven't reached the target, add some new packets that\n+\t contain only nops.  If there are two types of nop, insert an\n+\t alternating sequence of frv_nops[0] and frv_nops[1], which will\n+\t lead to packets like:\n+\n+\t\tnop.p\n+\t\tmnop.p/fnop.p\n+\t\tnop.p\n+\t\tmnop/fnop\n+\n+\t etc.  Just emit frv_nops[0] if that's the only nop we have.  */\n+      last = frv_packet.insns[frv_packet.num_insns - 1];\n+      nop = 0;\n+      while (frv_packet_address < target)\n+\t{\n+\t  last = emit_insn_after (PATTERN (frv_nops[nop]), last);\n+\t  frv_packet_address += 4;\n+\t  if (frv_num_nops > 1)\n+\t    nop ^= 1;\n \t}\n     }\n \n-  free (frv_state);\n-  dfa_finish ();\n-  return;\n+  frv_packet_address = target;\n }\n \n+/* Subroutine of frv_reorg, called after each packet has been constructed\n+   in frv_packet.  */\n+\n+static void\n+frv_reorg_packet (void)\n+{\n+  frv_fill_unused_units (GROUP_I);\n+  frv_fill_unused_units (GROUP_FM);\n+  frv_align_label ();\n+}\n+\n+/* Add an instruction with pattern NOP to frv_nops[].  */\n+\n+static void\n+frv_register_nop (rtx nop)\n+{\n+  nop = make_insn_raw (nop);\n+  NEXT_INSN (nop) = 0;\n+  PREV_INSN (nop) = 0;\n+  frv_nops[frv_num_nops++] = nop;\n+}\n+\n+/* Implement TARGET_MACHINE_DEPENDENT_REORG.  Divide the instructions\n+   into packets and check whether we need to insert nops in order to\n+   fulfill the processor's issue requirements.  Also, if the user has\n+   requested a certain alignment for a label, try to meet that alignment\n+   by inserting nops in the previous packet.  */\n+\n+static void\n+frv_reorg (void)\n+{\n+  frv_num_nops = 0;\n+  frv_register_nop (gen_nop ());\n+  if (TARGET_MEDIA)\n+    frv_register_nop (gen_mnop ());\n+  if (TARGET_HARD_FLOAT)\n+    frv_register_nop (gen_fnop ());\n+\n+  /* Estimate the length of each branch.  Although this may change after\n+     we've inserted nops, it will only do so in big functions.  */\n+  shorten_branches (get_insns ());\n+\n+  frv_packet_address = 0;\n+  frv_for_each_packet (frv_reorg_packet);\n+}\n \f\n #define def_builtin(name, type, code) \\\n   lang_hooks.builtin_function ((name), (type), (code), BUILT_IN_MD, NULL, NULL)\n@@ -8889,7 +9167,8 @@ static struct builtin_description bdesc_1arg[] =\n   { CODE_FOR_munpackh, \"__MUNPACKH\", FRV_BUILTIN_MUNPACKH, 0, 0 },\n   { CODE_FOR_mbtoh, \"__MBTOH\", FRV_BUILTIN_MBTOH, 0, 0 },\n   { CODE_FOR_mhtob, \"__MHTOB\", FRV_BUILTIN_MHTOB, 0, 0 },\n-  { CODE_FOR_mabshs, \"__MABSHS\", FRV_BUILTIN_MABSHS, 0, 0 }\n+  { CODE_FOR_mabshs, \"__MABSHS\", FRV_BUILTIN_MABSHS, 0, 0 },\n+  { CODE_FOR_scutss, \"__SCUTSS\", FRV_BUILTIN_SCUTSS, 0, 0 }\n };\n \n /* Media intrinsics that take two arguments.  */\n@@ -8915,7 +9194,30 @@ static struct builtin_description bdesc_2arg[] =\n   { CODE_FOR_mcop1, \"__Mcop1\", FRV_BUILTIN_MCOP1, 0, 0 },\n   { CODE_FOR_mcop2, \"__Mcop2\", FRV_BUILTIN_MCOP2, 0, 0 },\n   { CODE_FOR_mwcut, \"__MWCUT\", FRV_BUILTIN_MWCUT, 0, 0 },\n-  { CODE_FOR_mqsaths, \"__MQSATHS\", FRV_BUILTIN_MQSATHS, 0, 0 }\n+  { CODE_FOR_mqsaths, \"__MQSATHS\", FRV_BUILTIN_MQSATHS, 0, 0 },\n+  { CODE_FOR_mqlclrhs, \"__MQLCLRHS\", FRV_BUILTIN_MQLCLRHS, 0, 0 },\n+  { CODE_FOR_mqlmths, \"__MQLMTHS\", FRV_BUILTIN_MQLMTHS, 0, 0 },\n+  { CODE_FOR_smul, \"__SMUL\", FRV_BUILTIN_SMUL, 0, 0 },\n+  { CODE_FOR_umul, \"__UMUL\", FRV_BUILTIN_UMUL, 0, 0 },\n+  { CODE_FOR_addss, \"__ADDSS\", FRV_BUILTIN_ADDSS, 0, 0 },\n+  { CODE_FOR_subss, \"__SUBSS\", FRV_BUILTIN_SUBSS, 0, 0 },\n+  { CODE_FOR_slass, \"__SLASS\", FRV_BUILTIN_SLASS, 0, 0 },\n+  { CODE_FOR_scan, \"__SCAN\", FRV_BUILTIN_SCAN, 0, 0 }\n+};\n+\n+/* Integer intrinsics that take two arguments and have no return value.  */\n+\n+static struct builtin_description bdesc_int_void2arg[] =\n+{\n+  { CODE_FOR_smass, \"__SMASS\", FRV_BUILTIN_SMASS, 0, 0 },\n+  { CODE_FOR_smsss, \"__SMSSS\", FRV_BUILTIN_SMSSS, 0, 0 },\n+  { CODE_FOR_smu, \"__SMU\", FRV_BUILTIN_SMU, 0, 0 }\n+};\n+\n+static struct builtin_description bdesc_prefetches[] =\n+{\n+  { CODE_FOR_frv_prefetch0, \"__data_prefetch0\", FRV_BUILTIN_PREFETCH0, 0, 0 },\n+  { CODE_FOR_frv_prefetch, \"__data_prefetch\", FRV_BUILTIN_PREFETCH, 0, 0 }\n };\n \n /* Media intrinsics that take two arguments, the first being an ACC number.  */\n@@ -8945,7 +9247,9 @@ static struct builtin_description bdesc_2argimm[] =\n   { CODE_FOR_mhsetloh, \"__MHSETLOH\", FRV_BUILTIN_MHSETLOH, 0, 0 },\n   { CODE_FOR_mhsethis, \"__MHSETHIS\", FRV_BUILTIN_MHSETHIS, 0, 0 },\n   { CODE_FOR_mhsethih, \"__MHSETHIH\", FRV_BUILTIN_MHSETHIH, 0, 0 },\n-  { CODE_FOR_mhdseth, \"__MHDSETH\", FRV_BUILTIN_MHDSETH, 0, 0 }\n+  { CODE_FOR_mhdseth, \"__MHDSETH\", FRV_BUILTIN_MHDSETH, 0, 0 },\n+  { CODE_FOR_mqsllhi, \"__MQSLLHI\", FRV_BUILTIN_MQSLLHI, 0, 0 },\n+  { CODE_FOR_mqsrahi, \"__MQSRAHI\", FRV_BUILTIN_MQSRAHI, 0, 0 }\n };\n \n /* Media intrinsics that take two arguments and return void, the first argument\n@@ -9017,6 +9321,7 @@ frv_init_builtins (void)\n   tree sword2 = long_long_integer_type_node;\n   tree uword2 = long_long_unsigned_type_node;\n   tree uword4 = build_pointer_type (uword1);\n+  tree iacc   = integer_type_node;\n \n #define UNARY(RET, T1) \\\n   build_function_type (RET, tree_cons (NULL_TREE, T1, endlink))\n@@ -9065,6 +9370,16 @@ frv_init_builtins (void)\n   tree uw2_ftype_acc_int = BINARY (uword2, accumulator, integer);\n \n   tree sw2_ftype_sw2_sw2 = BINARY (sword2, sword2, sword2);\n+  tree sw2_ftype_sw2_int   = BINARY (sword2, sword2, integer);\n+  tree uw2_ftype_uw1_uw1   = BINARY (uword2, uword1, uword1);\n+  tree sw2_ftype_sw1_sw1   = BINARY (sword2, sword1, sword1);\n+  tree void_ftype_sw1_sw1  = BINARY (voidt, sword1, sword1);\n+  tree void_ftype_iacc_sw2 = BINARY (voidt, iacc, sword2);\n+  tree void_ftype_iacc_sw1 = BINARY (voidt, iacc, sword1);\n+  tree sw1_ftype_sw1       = UNARY (sword1, sword1);\n+  tree sw2_ftype_iacc      = UNARY (sword2, iacc);\n+  tree sw1_ftype_iacc      = UNARY (sword1, iacc);\n+  tree void_ftype_ptr      = UNARY (voidt, const_ptr_type_node);\n \n   def_builtin (\"__MAND\", uw1_ftype_uw1_uw1, FRV_BUILTIN_MAND);\n   def_builtin (\"__MOR\", uw1_ftype_uw1_uw1, FRV_BUILTIN_MOR);\n@@ -9150,6 +9465,26 @@ frv_init_builtins (void)\n   def_builtin (\"__MHSETLOH\", uw1_ftype_uw1_int, FRV_BUILTIN_MHSETLOH);\n   def_builtin (\"__MHSETHIH\", uw1_ftype_uw1_int, FRV_BUILTIN_MHSETHIH);\n   def_builtin (\"__MHDSETH\", uw1_ftype_uw1_int, FRV_BUILTIN_MHDSETH);\n+  def_builtin (\"__MQLCLRHS\", sw2_ftype_sw2_sw2, FRV_BUILTIN_MQLCLRHS);\n+  def_builtin (\"__MQLMTHS\", sw2_ftype_sw2_sw2, FRV_BUILTIN_MQLMTHS);\n+  def_builtin (\"__MQSLLHI\", uw2_ftype_uw2_int, FRV_BUILTIN_MQSLLHI);\n+  def_builtin (\"__MQSRAHI\", sw2_ftype_sw2_int, FRV_BUILTIN_MQSRAHI);\n+  def_builtin (\"__SMUL\", sw2_ftype_sw1_sw1, FRV_BUILTIN_SMUL);\n+  def_builtin (\"__UMUL\", uw2_ftype_uw1_uw1, FRV_BUILTIN_UMUL);\n+  def_builtin (\"__SMASS\", void_ftype_sw1_sw1, FRV_BUILTIN_SMASS);\n+  def_builtin (\"__SMSSS\", void_ftype_sw1_sw1, FRV_BUILTIN_SMSSS);\n+  def_builtin (\"__SMU\", void_ftype_sw1_sw1, FRV_BUILTIN_SMU);\n+  def_builtin (\"__ADDSS\", sw1_ftype_sw1_sw1, FRV_BUILTIN_ADDSS);\n+  def_builtin (\"__SUBSS\", sw1_ftype_sw1_sw1, FRV_BUILTIN_SUBSS);\n+  def_builtin (\"__SLASS\", sw1_ftype_sw1_sw1, FRV_BUILTIN_SLASS);\n+  def_builtin (\"__SCAN\", sw1_ftype_sw1_sw1, FRV_BUILTIN_SCAN);\n+  def_builtin (\"__SCUTSS\", sw1_ftype_sw1, FRV_BUILTIN_SCUTSS);\n+  def_builtin (\"__IACCreadll\", sw2_ftype_iacc, FRV_BUILTIN_IACCreadll);\n+  def_builtin (\"__IACCreadl\", sw1_ftype_iacc, FRV_BUILTIN_IACCreadl);\n+  def_builtin (\"__IACCsetll\", void_ftype_iacc_sw2, FRV_BUILTIN_IACCsetll);\n+  def_builtin (\"__IACCsetl\", void_ftype_iacc_sw1, FRV_BUILTIN_IACCsetl);\n+  def_builtin (\"__data_prefetch0\", void_ftype_ptr, FRV_BUILTIN_PREFETCH0);\n+  def_builtin (\"__data_prefetch\", void_ftype_ptr, FRV_BUILTIN_PREFETCH);\n \n #undef UNARY\n #undef BINARY\n@@ -9214,13 +9549,21 @@ static rtx\n frv_int_to_acc (enum insn_code icode, int opnum, rtx opval)\n {\n   rtx reg;\n+  int i;\n+\n+  /* ACCs and ACCGs are implicity global registers if media instrinsics\n+     are being used.  We set up this lazily to avoid creating lots of\n+     unncessary call_insn rtl in non-media code.  */\n+  for (i = 0; i <= ACC_MASK; i++)\n+    if ((i & ACC_MASK) == i)\n+      global_regs[i + ACC_FIRST] = global_regs[i + ACCG_FIRST] = 1;\n \n   if (GET_CODE (opval) != CONST_INT)\n     {\n       error (\"accumulator is not a constant integer\");\n       return NULL_RTX;\n     }\n-  if (! IN_RANGE_P (INTVAL (opval), 0, NUM_ACCS - 1))\n+  if ((INTVAL (opval) & ~ACC_MASK) != 0)\n     {\n       error (\"accumulator number is out of bounds\");\n       return NULL_RTX;\n@@ -9284,6 +9627,35 @@ frv_read_argument (tree *arglistptr)\n   return expand_expr (next, NULL_RTX, VOIDmode, 0);\n }\n \n+/* Like frv_read_argument, but interpret the argument as the number\n+   of an IACC register and return a (reg:MODE ...) rtx for it.  */\n+\n+static rtx\n+frv_read_iacc_argument (enum machine_mode mode, tree *arglistptr)\n+{\n+  int i, regno;\n+  rtx op;\n+\n+  op = frv_read_argument (arglistptr);\n+  if (GET_CODE (op) != CONST_INT\n+      || INTVAL (op) < 0\n+      || INTVAL (op) > IACC_LAST - IACC_FIRST\n+      || ((INTVAL (op) * 4) & (GET_MODE_SIZE (mode) - 1)) != 0)\n+    {\n+      error (\"invalid IACC argument\");\n+      op = const0_rtx;\n+    }\n+\n+  /* IACCs are implicity global registers.  We set up this lazily to\n+     avoid creating lots of unncessary call_insn rtl when IACCs aren't\n+     being used.  */\n+  regno = INTVAL (op) + IACC_FIRST;\n+  for (i = 0; i < HARD_REGNO_NREGS (regno, mode); i++)\n+    global_regs[regno + i] = 1;\n+\n+  return gen_rtx_REG (mode, regno);\n+}\n+\n /* Return true if OPVAL can be used for operand OPNUM of instruction ICODE.\n    The instruction should require a constant operand of some sort.  The\n    function prints an error if OPVAL is not valid.  */\n@@ -9490,6 +9862,41 @@ frv_expand_voidbinop_builtin (enum insn_code icode, tree arglist)\n   return 0;\n }\n \n+/* Expand builtins that take two long operands and return void.  */\n+\n+static rtx\n+frv_expand_int_void2arg (enum insn_code icode, tree arglist)\n+{\n+  rtx pat;\n+  rtx op0 = frv_read_argument (&arglist);\n+  rtx op1 = frv_read_argument (&arglist);\n+\n+  op0 = frv_legitimize_argument (icode, 1, op0);\n+  op1 = frv_legitimize_argument (icode, 1, op1);\n+  pat = GEN_FCN (icode) (op0, op1);\n+  if (! pat)\n+    return NULL_RTX;\n+\n+  emit_insn (pat);\n+  return NULL_RTX;\n+}\n+\n+/* Expand prefetch builtins.  These take a single address as argument.  */\n+\n+static rtx\n+frv_expand_prefetches (enum insn_code icode, tree arglist)\n+{\n+  rtx pat;\n+  rtx op0 = frv_read_argument (&arglist);\n+\n+  pat = GEN_FCN (icode) (force_reg (Pmode, op0));\n+  if (! pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+  return 0;\n+}\n+\n /* Expand builtins that take three operands and return void.  The first\n    argument must be a constant that describes a pair or quad accumulators.  A\n    fourth argument is created that is the accumulator guard register that\n@@ -9628,6 +10035,21 @@ frv_expand_mwtacc_builtin (enum insn_code icode, tree arglist)\n   return NULL_RTX;\n }\n \n+/* Emit a move from SRC to DEST in SImode chunks.  This can be used\n+   to move DImode values into and out of IACC0.  */\n+\n+static void\n+frv_split_iacc_move (rtx dest, rtx src)\n+{\n+  enum machine_mode inner;\n+  int i;\n+\n+  inner = GET_MODE (dest);\n+  for (i = 0; i < GET_MODE_SIZE (inner); i += GET_MODE_SIZE (SImode))\n+    emit_move_insn (simplify_gen_subreg (SImode, dest, inner, i),\n+\t\t    simplify_gen_subreg (SImode, src, inner, i));\n+}\n+\n /* Expand builtins.  */\n \n static rtx\n@@ -9643,7 +10065,7 @@ frv_expand_builtin (tree exp,\n   unsigned i;\n   struct builtin_description *d;\n \n-  if (! TARGET_MEDIA)\n+  if (fcode < FRV_BUILTIN_FIRST_NONMEDIA && !TARGET_MEDIA)\n     {\n       error (\"media functions are not available unless -mmedia is used\");\n       return NULL_RTX;\n@@ -9685,7 +10107,47 @@ frv_expand_builtin (tree exp,\n     case FRV_BUILTIN_MHDSETH:\n       if (! TARGET_MEDIA_REV2)\n \t{\n-\t  error (\"this media function is only available on the fr400\");\n+\t  error (\"this media function is only available on the fr400\"\n+\t\t \" and fr550\");\n+\t  return NULL_RTX;\n+\t}\n+      break;\n+\n+    case FRV_BUILTIN_SMASS:\n+    case FRV_BUILTIN_SMSSS:\n+    case FRV_BUILTIN_SMU:\n+    case FRV_BUILTIN_ADDSS:\n+    case FRV_BUILTIN_SUBSS:\n+    case FRV_BUILTIN_SLASS:\n+    case FRV_BUILTIN_SCUTSS:\n+    case FRV_BUILTIN_IACCreadll:\n+    case FRV_BUILTIN_IACCreadl:\n+    case FRV_BUILTIN_IACCsetll:\n+    case FRV_BUILTIN_IACCsetl:\n+      if (!TARGET_FR405_BUILTINS)\n+\t{\n+\t  error (\"this builtin function is only available\"\n+\t\t \" on the fr405 and fr450\");\n+\t  return NULL_RTX;\n+\t}\n+      break;\n+\n+    case FRV_BUILTIN_PREFETCH:\n+      if (!TARGET_FR500_FR550_BUILTINS)\n+\t{\n+\t  error (\"this builtin function is only available on the fr500\"\n+\t\t \" and fr550\");\n+\t  return NULL_RTX;\n+\t}\n+      break;\n+\n+    case FRV_BUILTIN_MQLCLRHS:\n+    case FRV_BUILTIN_MQLMTHS:\n+    case FRV_BUILTIN_MQSLLHI:\n+    case FRV_BUILTIN_MQSRAHI:\n+      if (!TARGET_MEDIA_FR450)\n+\t{\n+\t  error (\"this builtin function is only available on the fr450\");\n \t  return NULL_RTX;\n \t}\n       break;\n@@ -9722,6 +10184,34 @@ frv_expand_builtin (tree exp,\n     case FRV_BUILTIN_MWTACCG:\n       return frv_expand_mwtacc_builtin (CODE_FOR_mwtaccg, arglist);\n \n+    case FRV_BUILTIN_IACCreadll:\n+      {\n+\trtx src = frv_read_iacc_argument (DImode, &arglist);\n+\tif (target == 0 || !REG_P (target))\n+\t  target = gen_reg_rtx (DImode);\n+\tfrv_split_iacc_move (target, src);\n+\treturn target;\n+      }\n+\n+    case FRV_BUILTIN_IACCreadl:\n+      return frv_read_iacc_argument (SImode, &arglist);\n+\n+    case FRV_BUILTIN_IACCsetll:\n+      {\n+\trtx dest = frv_read_iacc_argument (DImode, &arglist);\n+\trtx src = frv_read_argument (&arglist);\n+\tfrv_split_iacc_move (dest, force_reg (DImode, src));\n+\treturn 0;\n+      }\n+\n+    case FRV_BUILTIN_IACCsetl:\n+      {\n+\trtx dest = frv_read_iacc_argument (SImode, &arglist);\n+\trtx src = frv_read_argument (&arglist);\n+\temit_move_insn (dest, force_reg (SImode, src));\n+\treturn 0;\n+      }\n+\n     default:\n       break;\n     }\n@@ -9760,6 +10250,16 @@ frv_expand_builtin (tree exp,\n     if (d->code == fcode)\n       return frv_expand_voidaccop_builtin (d->icode, arglist);\n \n+  for (i = 0, d = bdesc_int_void2arg;\n+       i < ARRAY_SIZE (bdesc_int_void2arg); i++, d++)\n+    if (d->code == fcode)\n+      return frv_expand_int_void2arg (d->icode, arglist);\n+\n+  for (i = 0, d = bdesc_prefetches;\n+       i < ARRAY_SIZE (bdesc_prefetches); i++, d++)\n+    if (d->code == fcode)\n+      return frv_expand_prefetches (d->icode, arglist);\n+\n   return 0;\n }\n \n@@ -9907,3 +10407,5 @@ frv_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n {\n   return gen_rtx_REG (Pmode, FRV_STRUCT_VALUE_REGNUM);\n }\n+\n+#include \"gt-frv.h\""}, {"sha": "91acc3d09a3fe36f7aa1b6a6220ee49ca1759966", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 159, "deletions": 149, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=c557edf447d02a1bace4e84cb4515e1de06be4d9", "patch": "@@ -133,78 +133,6 @@\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"frvend%O%s\"\n \n-/* A C string constant that tells the GCC driver program options to pass to\n-   CPP.  It can also specify how to translate options you give to GCC into\n-   options for GCC to pass to the CPP.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-\n-/* The idea here is to use the -mcpu option to define macros based on the\n-   processor's features, using the features of the default processor if\n-   no -mcpu option is given.  These macros can then be overridden by\n-   other -m options.  */\n-#define CPP_SPEC \"\\\n-%{mcpu=frv: %(cpp_frv)} \\\n-%{mcpu=fr500: %(cpp_fr500)} \\\n-%{mcpu=fr400: %(cpp_fr400)} \\\n-%{mcpu=fr300: %(cpp_simple)} \\\n-%{mcpu=tomcat: %(cpp_fr500)} \\\n-%{mcpu=simple: %(cpp_simple)} \\\n-%{!mcpu*: %(cpp_cpu_default)} \\\n-%{mno-media: -U__FRV_ACC__ -D__FRV_ACC__=0 %{msoft-float: -U__FRV_FPR__ -D__FRV_FPR__=0}} \\\n-%{mhard-float: -D__FRV_HARD_FLOAT__} \\\n-%{msoft-float: -U__FRV_HARD_FLOAT__} \\\n-%{mgpr-32: -U__FRV_GPR__ -D__FRV_GPR__=32} \\\n-%{mgpr-64: -U__FRV_GPR__ -D__FRV_GPR__=64} \\\n-%{mfpr-32: -U__FRV_FPR__ -D__FRV_FPR__=32} \\\n-%{mfpr-64: -U__FRV_FPR__ -D__FRV_FPR__=64} \\\n-%{macc-4: -U__FRV_ACC__ -D__FRV_ACC__=4} \\\n-%{macc-8: -U__FRV_ACC__ -D__FRV_ACC__=8} \\\n-%{mdword: -D__FRV_DWORD__} \\\n-%{mno-dword: -U__FRV_DWORD__} \\\n-%{mno-pack: -U__FRV_VLIW__} \\\n-%{fleading-underscore: -D__FRV_UNDERSCORE__}\"\n-\n-/* CPU defaults.  Each CPU has its own CPP spec that defines the default\n-   macros for that CPU.  Each CPU also has its own default target mask.\n-\n-   CPU\t\tGPRs\tFPRs\tACCs\tFPU\tMulAdd  ldd/std  Issue rate\n-   ---\t\t----    ----    ----    ---\t------  -------  ----------\n-   FRV\t\t64\t64\t8\tdouble\tyes\tyes      4\n-   FR500\t64\t64\t8\tsingle\tno\tyes      4\n-   FR400\t32\t32\t4\tnone\tno\tyes      2\n-   Simple\t32\t0\t0\tnone\tno\tno       1 */\n-\n-\n-#define CPP_FRV_SPEC \"\\\n--D__FRV_GPR__=64 \\\n--D__FRV_FPR__=64 \\\n--D__FRV_ACC__=8 \\\n--D__FRV_HARD_FLOAT__ \\\n--D__FRV_DWORD__ \\\n--D__FRV_VLIW__=4\"\n-\n-#define CPP_FR500_SPEC \"\\\n--D__FRV_GPR__=64 \\\n--D__FRV_FPR__=64 \\\n--D__FRV_ACC__=8 \\\n--D__FRV_HARD_FLOAT__ \\\n--D__FRV_DWORD__ \\\n--D__FRV_VLIW__=4\"\n-\n-#define CPP_FR400_SPEC \"\\\n--D__FRV_GPR__=32 \\\n--D__FRV_FPR__=32 \\\n--D__FRV_ACC__=4 \\\n--D__FRV_DWORD__ \\\n--D__FRV_VLIW__=2\"\n-\n-#define CPP_SIMPLE_SPEC \"\\\n--D__FRV_GPR__=32 \\\n--D__FRV_FPR__=0 \\\n--D__FRV_ACC__=0 \\\n-%{mmedia: -U__FRV_ACC__ -D__FRV_ACC__=8} \\\n-%{mhard-float|mmedia: -D__FRV_FPR__=64}\"\n \n #define MASK_DEFAULT_FRV\t\\\n   (MASK_MEDIA\t\t\t\\\n@@ -216,6 +144,17 @@\n #define MASK_DEFAULT_FR500 \\\n   (MASK_MEDIA | MASK_DWORD | MASK_PACK)\n \n+#define MASK_DEFAULT_FR550 \\\n+  (MASK_MEDIA | MASK_DWORD | MASK_PACK)\n+\n+#define MASK_DEFAULT_FR450\t\\\n+  (MASK_GPR_32\t\t\t\\\n+   | MASK_FPR_32\t\t\\\n+   | MASK_MEDIA\t\t\t\\\n+   | MASK_SOFT_FLOAT\t\t\\\n+   | MASK_DWORD\t\t\t\\\n+   | MASK_PACK)\n+\n #define MASK_DEFAULT_FR400\t\\\n   (MASK_GPR_32\t\t\t\\\n    | MASK_FPR_32\t\t\\\n@@ -269,30 +208,7 @@\n #undef  LIB_SPEC\n #define LIB_SPEC \"--start-group -lc -lsim --end-group\"\n \n-/* This macro defines names of additional specifications to put in the specs\n-   that can be used in various specifications like CC1_SPEC.  Its definition\n-   is an initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   specification name, and a string constant that used by the GCC driver\n-   program.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-\n-#ifndef SUBTARGET_EXTRA_SPECS\n-#define SUBTARGET_EXTRA_SPECS\n-#endif\n-\n-#define EXTRA_SPECS\t\t\t\t\t\t\t\\\n-  { \"cpp_frv\",\t\tCPP_FRV_SPEC },\t\t\t\t\t\\\n-  { \"cpp_fr500\",\tCPP_FR500_SPEC },\t\t\t\t\\\n-  { \"cpp_fr400\",\tCPP_FR400_SPEC },\t\t\t\t\\\n-  { \"cpp_simple\",\tCPP_SIMPLE_SPEC },\t\t\t\t\\\n-  { \"cpp_cpu_default\",\tCPP_CPU_DEFAULT_SPEC },\t\t\t\t\\\n-  SUBTARGET_EXTRA_SPECS\n-\n-#ifndef CPP_CPU_DEFAULT_SPEC\n-#define CPP_CPU_DEFAULT_SPEC\tCPP_FR500_SPEC\n+#ifndef CPU_TYPE\n #define CPU_TYPE\t\tFRV_CPU_FR500\n #endif\n \n@@ -305,15 +221,57 @@\n \n /* Run-time target specifications */\n \n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define (\"__frv__\");\t\t\\\n-      builtin_assert (\"machine=frv\");\t\t\\\n-\t\t\t\t\t\t\\\n-      if (TARGET_FDPIC)\t\t\t\t\\\n-\tbuiltin_define (\"__FRV_FDPIC__\");\t\\\n-    }\t\t\t\t\t\t\\\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int issue_rate;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      builtin_define (\"__frv__\");\t\t\t\t\t\\\n+      builtin_assert (\"machine=frv\");\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      issue_rate = frv_issue_rate ();\t\t\t\t\t\\\n+      if (issue_rate > 1)\t\t\t\t\t\t\\\n+\tbuiltin_define_with_int_value (\"__FRV_VLIW__\", issue_rate);\t\\\n+      builtin_define_with_int_value (\"__FRV_GPR__\", NUM_GPRS);\t\t\\\n+      builtin_define_with_int_value (\"__FRV_FPR__\", NUM_FPRS);\t\t\\\n+      builtin_define_with_int_value (\"__FRV_ACC__\", NUM_ACCS);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      switch (frv_cpu_type)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase FRV_CPU_GENERIC:\t\t\t\t\t\t\\\n+\t  builtin_define (\"__CPU_GENERIC__\");\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase FRV_CPU_FR550:\t\t\t\t\t\t\\\n+\t  builtin_define (\"__CPU_FR550__\");\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase FRV_CPU_FR500:\t\t\t\t\t\t\\\n+\tcase FRV_CPU_TOMCAT:\t\t\t\t\t\t\\\n+\t  builtin_define (\"__CPU_FR500__\");\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase FRV_CPU_FR450:\t\t\t\t\t\t\\\n+\t  builtin_define (\"__CPU_FR450__\");\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase FRV_CPU_FR405:\t\t\t\t\t\t\\\n+\t  builtin_define (\"__CPU_FR405__\");\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase FRV_CPU_FR400:\t\t\t\t\t\t\\\n+\t  builtin_define (\"__CPU_FR400__\");\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase FRV_CPU_FR300:\t\t\t\t\t\t\\\n+\tcase FRV_CPU_SIMPLE:\t\t\t\t\t\t\\\n+\t  builtin_define (\"__CPU_FR300__\");\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_HARD_FLOAT)\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__FRV_HARD_FLOAT__\");\t\t\t\t\\\n+      if (TARGET_DWORD)\t\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__FRV_DWORD__\");\t\t\t\t\\\n+      if (TARGET_FDPIC)\t\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__FRV_FDPIC__\");\t\t\t\t\\\n+      if (flag_leading_underscore > 0)\t\t\t\t\t\\\n+\tbuiltin_define (\"__FRV_UNDERSCORE__\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n \f\n@@ -348,6 +306,8 @@ extern int target_flags;\n #define MASK_LIBPIC\t     0x00000100\t/* -fpic that can be linked w/o pic */\n #define MASK_ACC_4\t     0x00000200\t/* Only use four media accumulators */\n #define MASK_PACK\t     0x00000400 /* Set to enable packed output */\n+#define MASK_LONG_CALLS\t     0x00000800 /* Use indirect calls */\n+#define MASK_ALIGN_LABELS    0x00001000 /* Optimize label alignments */\n #define MASK_LINKED_FP\t     0x00002000 /* Follow ABI linkage requirements.  */\n \n \t\t\t \t\t/* put debug masks up high */\n@@ -395,6 +355,8 @@ extern int target_flags;\n #define TARGET_INLINE_PLT\t((target_flags & MASK_INLINE_PLT) != 0)\n #define TARGET_GPREL_RO\t\t((target_flags & MASK_GPREL_RO) != 0)\n #define TARGET_PACK\t\t((target_flags & MASK_PACK) != 0)\n+#define TARGET_LONG_CALLS\t((target_flags & MASK_LONG_CALLS) != 0)\n+#define TARGET_ALIGN_LABELS\t((target_flags & MASK_ALIGN_LABELS) != 0)\n #define TARGET_LINKED_FP\t((target_flags & MASK_LINKED_FP) != 0)\n \n #define TARGET_GPR_64\t\t(! TARGET_GPR_32)\n@@ -415,6 +377,13 @@ extern int target_flags;\n #define NUM_FPRS\t\t(!TARGET_HAS_FPRS? 0 : TARGET_FPR_32? 32 : 64)\n #define NUM_ACCS\t\t(!TARGET_MEDIA? 0 : TARGET_ACC_4? 4 : 8)\n \n+/* X is a valid accumulator number if (X & ACC_MASK) == X.  */\n+#define ACC_MASK\t\t\t\t\t\t\\\n+  (!TARGET_MEDIA ? 0\t\t\t\t\t\t\\\n+   : TARGET_ACC_4 ? 3\t\t\t\t\t\t\\\n+   : frv_cpu_type == FRV_CPU_FR450 ? 11\t\t\t\t\\\n+   : 7)\n+\n /* Macros to identify the blend of media instructions available.  Revision 1\n    is the one found on the FR500.  Revision 2 includes the changes made for\n    the FR400.\n@@ -428,7 +397,22 @@ extern int target_flags;\n        || frv_cpu_type == FRV_CPU_FR500))\n \n #define TARGET_MEDIA_REV2\t\t\t\t\t\\\n-  (TARGET_MEDIA && frv_cpu_type == FRV_CPU_FR400)\n+  (TARGET_MEDIA\t\t\t\t\t\t\t\\\n+   && (frv_cpu_type == FRV_CPU_FR400\t\t\t\t\\\n+       || frv_cpu_type == FRV_CPU_FR405\t\t\t\t\\\n+       || frv_cpu_type == FRV_CPU_FR450\t\t\t\t\\\n+       || frv_cpu_type == FRV_CPU_FR550))\n+\n+#define TARGET_MEDIA_FR450\t\t\t\t\t\\\n+  (frv_cpu_type == FRV_CPU_FR450)\n+\n+#define TARGET_FR500_FR550_BUILTINS\t\t\t\t\\\n+   (frv_cpu_type == FRV_CPU_FR500\t\t\t\t\\\n+    || frv_cpu_type == FRV_CPU_FR550)\n+\n+#define TARGET_FR405_BUILTINS\t\t\t\t\t\\\n+  (frv_cpu_type == FRV_CPU_FR405\t\t\t\t\\\n+   || frv_cpu_type == FRV_CPU_FR450)\n \n /* This macro defines names of command options to set and clear bits in\n    `target_flags'.  Its definition is an initializer with a subgrouping for\n@@ -488,6 +472,8 @@ extern int target_flags;\n  { \"debug\",\t\t  MASK_DEBUG,\t\t\"Internal debug switch\" },  \\\n  { \"debug-cond-exec\",\t  MASK_DEBUG_COND_EXEC,\t\"Internal debug switch\" },  \\\n  { \"debug-loc\",\t\t  MASK_DEBUG_LOC,\t\"Internal debug switch\" },  \\\n+ { \"align-labels\",\t  MASK_ALIGN_LABELS,\t\"Enable label alignment optimizations\" }, \\\n+ { \"no-align-labels\",\t -MASK_ALIGN_LABELS,\t\"Disable label alignment optimizations\" }, \\\n  { \"cond-move\",\t\t -MASK_NO_COND_MOVE,\t\"Enable conditional moves\" },  \\\n  { \"no-cond-move\",\t  MASK_NO_COND_MOVE,\t\"Disable conditional moves\" },  \\\n  { \"scc\",\t\t -MASK_NO_SCC,\t\t\"Enable setting gprs to the result of comparisons\" },  \\\n@@ -500,6 +486,8 @@ extern int target_flags;\n  { \"no-multi-cond-exec\",  MASK_NO_MULTI_CE,\t\"Enable optimizing &&/|| in conditional execution\" }, \\\n  { \"nested-cond-exec\",\t -MASK_NO_NESTED_CE,\t\"Enable nested conditional execution optimizations\" }, \\\n  { \"no-nested-cond-exec\" ,MASK_NO_NESTED_CE,\t\"Disable nested conditional execution optimizations\" }, \\\n+ { \"long-calls\",\t  MASK_LONG_CALLS,\t\"Disallow direct calls to global functions\" }, \\\n+ { \"no-long-calls\",\t -MASK_LONG_CALLS,\t\"Allow direct calls to global functions\" }, \\\n  { \"linked-fp\",\t\t  MASK_LINKED_FP,\t\"Follow the EABI linkage requirements\" }, \\\n  { \"no-linked-fp\",\t -MASK_LINKED_FP,\t\"Don't follow the EABI linkage requirements\" }, \\\n  { \"fdpic\",\t          MASK_FDPIC,\t\t\"Enable file descriptor PIC mode\" }, \\\n@@ -591,6 +579,7 @@ extern int target_flags;\n \n #define CAN_DEBUG_WITHOUT_FP\n \n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (TARGET_ALIGN_LABELS ? 3 : 0)\n \f\n /* Small Data Area Support.  */\n /* Maximum size of variables that go in .sdata/.sbss.\n@@ -879,17 +868,19 @@ extern int target_flags;\n #define CR_MASK\t\t0x3\n \n #define ACC_FIRST\t144\t\t\t/* First acc register */\n-#define ACC_LAST\t151\t\t\t/* Last  acc register */\n+#define ACC_LAST\t155\t\t\t/* Last  acc register */\n \n-#define ACCG_FIRST\t152\t\t\t/* First accg register */\n-#define ACCG_LAST\t159\t\t\t/* Last  accg register */\n+#define ACCG_FIRST\t156\t\t\t/* First accg register */\n+#define ACCG_LAST\t167\t\t\t/* Last  accg register */\n \n-#define AP_FIRST\t160\t\t\t/* fake argument pointer */\n+#define AP_FIRST\t168\t\t\t/* fake argument pointer */\n \n-#define SPR_FIRST\t161\n-#define SPR_LAST\t162\n+#define SPR_FIRST\t169\n+#define SPR_LAST\t172\n #define LR_REGNO\t(SPR_FIRST)\n #define LCR_REGNO\t(SPR_FIRST + 1)\n+#define IACC_FIRST\t(SPR_FIRST + 2)\n+#define IACC_LAST\t(SPR_FIRST + 3)\n \n #define GPR_P(R)\tIN_RANGE_P (R, GPR_FIRST, GPR_LAST)\n #define GPR_OR_AP_P(R)\t(GPR_P (R) || (R) == ARG_POINTER_REGNUM)\n@@ -1016,11 +1007,14 @@ extern int target_flags;\n \t0, 0, 0, 0, 0, 0, 0, 1,\t\t/* 136-143, cr0 - cr7 */\t\\\n \t/* Accumulators */\t\t\t\t\t\t\\\n \t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 144-151, acc0  - acc7 */\t\\\n-\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 152-159, accg0 - accg7 */\t\\\n+\t1, 1, 1, 1,\t\t\t/* 152-155, acc8  - acc11 */\t\\\n+\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 156-163, accg0 - accg7 */\t\\\n+\t1, 1, 1, 1,\t\t\t/* 164-167, accg8 - accg11 */\t\\\n \t/* Other registers */\t\t\t\t\t\t\\\n-\t1,\t\t\t\t/* 160, AP   - fake arg ptr */\t\\\n-\t0,\t\t\t\t/* 161, LR   - Link register*/\t\\\n-\t0,\t\t\t\t/* 162, LCR  - Loop count reg*/\t\\\n+\t1,\t\t\t\t/* 168, AP   - fake arg ptr */\t\\\n+\t0,\t\t\t\t/* 169, LR   - Link register*/\t\\\n+\t0,\t\t\t\t/* 170, LCR  - Loop count reg*/\t\\\n+\t1, 1\t\t\t\t/* 171-172, iacc0 */\t\t\\\n }\n \n /* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in\n@@ -1057,11 +1051,14 @@ extern int target_flags;\n \t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 136-143, cr0 - cr7 */\t\\\n \t/* Accumulators */\t\t\t\t\t\t\\\n \t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 144-151, acc0 - acc7 */\t\\\n-\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 152-159, accg0 - accg7 */\t\\\n+\t1, 1, 1, 1,\t\t\t/* 152-155, acc8 - acc11 */\t\\\n+\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 156-163, accg0 - accg7 */\t\\\n+\t1, 1, 1, 1,\t\t\t/* 164-167, accg8 - accg11 */\t\\\n \t/* Other registers */\t\t\t\t\t\t\\\n-\t1,\t\t\t\t/* 160, AP  - fake arg ptr */\t\\\n-\t1,\t\t\t\t/* 161, LR  - Link register*/\t\\\n-\t1,\t\t\t\t/* 162, LCR - Loop count reg */\t\\\n+\t1,\t\t\t\t/* 168, AP  - fake arg ptr */\t\\\n+\t1,\t\t\t\t/* 169, LR  - Link register*/\t\\\n+\t1,\t\t\t\t/* 170, LCR - Loop count reg */\t\\\n+\t1, 1\t\t\t\t/* 171-172, iacc0 */\t\t\\\n }\n \n /* Zero or more C statements that may conditionally modify two variables\n@@ -1154,9 +1151,12 @@ extern int target_flags;\n   GPR_FIRST  + 28, GPR_FIRST  + 29, GPR_FIRST  + 30, GPR_FIRST \t+ 31,\t\\\n   ACC_FIRST  +  0, ACC_FIRST  +  1, ACC_FIRST  +  2, ACC_FIRST \t+  3,\t\\\n   ACC_FIRST  +  4, ACC_FIRST  +  5, ACC_FIRST  +  6, ACC_FIRST \t+  7,\t\\\n+  ACC_FIRST  +  8, ACC_FIRST  +  9, ACC_FIRST  + 10, ACC_FIRST \t+ 11,\t\\\n   ACCG_FIRST +  0, ACCG_FIRST +  1, ACCG_FIRST +  2, ACCG_FIRST\t+  3,\t\\\n   ACCG_FIRST +  4, ACCG_FIRST +  5, ACCG_FIRST +  6, ACCG_FIRST\t+  7,\t\\\n-  AP_FIRST, \t   LR_REGNO,       LCR_REGNO\t\t\t\t\\\n+  ACCG_FIRST +  8, ACCG_FIRST +  9, ACCG_FIRST + 10, ACCG_FIRST\t+ 11,\t\\\n+  AP_FIRST, \t   LR_REGNO,       LCR_REGNO,\t\t\t\t\\\n+  IACC_FIRST +  0, IACC_FIRST +  1\t\t\t\t\t\\\n }\n \n \f\n@@ -1340,23 +1340,23 @@ enum reg_class\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x0000f000,0x0}, /* ICR_REGS */\\\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000f00,0x0}, /* FCR_REGS */\\\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x0000ff00,0x0}, /* CR_REGS  */\\\n-  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x4}, /* LCR_REGS */\\\n-  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x2}, /* LR_REGS  */\\\n+  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x400}, /* LCR_REGS */\\\n+  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x200}, /* LR_REGS  */\\\n   { 0x00008000,0x00000000,0x00000000,0x00000000,0x00000000,0x0}, /* FDPIC_REGS */\\\n   { 0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x0}, /* FDPIC_FPTR_REGS */\\\n   { 0x0000c000,0x00000000,0x00000000,0x00000000,0x00000000,0x0}, /* FDPIC_CALL_REGS */\\\n-  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x6}, /* SPR_REGS */\\\n-  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00ff0000,0x0}, /* QUAD_ACC */\\\n-  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00ff0000,0x0}, /* EVEN_ACC */\\\n-  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00ff0000,0x0}, /* ACC_REGS */\\\n-  { 0x00000000,0x00000000,0x00000000,0x00000000,0xff000000,0x0}, /* ACCG_REGS*/\\\n+  { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x1e00}, /* SPR_REGS */\\\n+  { 0x00000000,0x00000000,0x00000000,0x00000000,0x0fff0000,0x0}, /* QUAD_ACC */\\\n+  { 0x00000000,0x00000000,0x00000000,0x00000000,0x0fff0000,0x0}, /* EVEN_ACC */\\\n+  { 0x00000000,0x00000000,0x00000000,0x00000000,0x0fff0000,0x0}, /* ACC_REGS */\\\n+  { 0x00000000,0x00000000,0x00000000,0x00000000,0xf0000000,0xff}, /* ACCG_REGS*/\\\n   { 0x00000000,0x00000000,0xffffffff,0xffffffff,0x00000000,0x0}, /* QUAD_FPR */\\\n   { 0x00000000,0x00000000,0xffffffff,0xffffffff,0x00000000,0x0}, /* FEVEN_REG*/\\\n   { 0x00000000,0x00000000,0xffffffff,0xffffffff,0x00000000,0x0}, /* FPR_REGS */\\\n   { 0x0ffffffc,0xffffffff,0x00000000,0x00000000,0x00000000,0x0}, /* QUAD_REGS*/\\\n   { 0xfffffffc,0xffffffff,0x00000000,0x00000000,0x00000000,0x0}, /* EVEN_REGS*/\\\n-  { 0xffffffff,0xffffffff,0x00000000,0x00000000,0x00000000,0x1}, /* GPR_REGS */\\\n-  { 0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0x7}, /* ALL_REGS */\\\n+  { 0xffffffff,0xffffffff,0x00000000,0x00000000,0x00000000,0x100}, /* GPR_REGS */\\\n+  { 0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0x1fff}, /* ALL_REGS */\\\n }\n \n /* A C expression whose value is a register class containing hard register\n@@ -1562,7 +1562,8 @@ extern enum reg_class reg_class_from_letter[];\n   (dbl_memory_one_insn_operand (VALUE, GET_MODE (VALUE)))\n \n /* SYMBOL_REF */\n-#define EXTRA_CONSTRAINT_FOR_S(VALUE) (GET_CODE (VALUE) == SYMBOL_REF)\n+#define EXTRA_CONSTRAINT_FOR_S(VALUE) \\\n+  (CONSTANT_P (VALUE) && call_operand (VALUE, VOIDmode))\n \n /* Double word memory ops that take two instructions.  */\n #define EXTRA_CONSTRAINT_FOR_T(VALUE)\t\t\t\t\t\\\n@@ -2723,8 +2724,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n   \"fcc0\", \"fcc1\", \"fcc2\", \"fcc3\", \"icc0\", \"icc1\", \"icc2\", \"icc3\",\t\\\n   \"cc0\",  \"cc1\",  \"cc2\",  \"cc3\",  \"cc4\",  \"cc5\",  \"cc6\",  \"cc7\",\t\\\n   \"acc0\", \"acc1\", \"acc2\", \"acc3\", \"acc4\", \"acc5\", \"acc6\", \"acc7\",\t\\\n+  \"acc8\", \"acc9\", \"acc10\", \"acc11\",\t\t\t\t\t\\\n   \"accg0\",\"accg1\",\"accg2\",\"accg3\",\"accg4\",\"accg5\",\"accg6\",\"accg7\",\t\\\n-  \"ap\",   \"lr\",   \"lcr\"\t\t\t\t\t\t\t\\\n+  \"accg8\", \"accg9\", \"accg10\", \"accg11\",\t\t\t\t\t\\\n+  \"ap\",   \"lr\",   \"lcr\",  \"iacc0h\", \"iacc0l\"\t\t\t\t\\\n }\n \n /* Define this macro if you are using an unusual assembler that\n@@ -3176,18 +3179,6 @@ frv_ifcvt_modify_multiple_tests (CE_INFO, BB, &TRUE_EXPR, &FALSE_EXPR)\n /* Initialize the extra fields provided by IFCVT_EXTRA_FIELDS.  */\n #define IFCVT_INIT_EXTRA_FIELDS(CE_INFO) frv_ifcvt_init_extra_fields (CE_INFO)\n \n-/* Indicate how many instructions can be issued at the same time.  */\n-#define ISSUE_RATE\t\t\t\t\t\t\t\\\n-(! TARGET_PACK ? 1\t\t\t\t\t\t\t\\\n- : (frv_cpu_type == FRV_CPU_GENERIC\t\t\t\t\t\\\n-    || frv_cpu_type == FRV_CPU_FR500\t\t\t\t\t\\\n-    || frv_cpu_type == FRV_CPU_TOMCAT) ? 4\t\t\t\t\\\n- : frv_cpu_type == FRV_CPU_FR400 ? 2 : 1)\n-\n-/* Set and clear whether this insn begins a VLIW insn.  */\n-#define CLEAR_VLIW_START(INSN) PUT_MODE (INSN, VOIDmode)\n-#define SET_VLIW_START(INSN) PUT_MODE (INSN, TImode)\n-\n /* The definition of the following macro results in that the 2nd jump\n    optimization (after the 2nd insn scheduling) is minimal.  It is\n    necessary to define when start cycle marks of insns (TImode is used\n@@ -3201,10 +3192,6 @@ frv_ifcvt_modify_multiple_tests (CE_INFO, BB, &TRUE_EXPR, &FALSE_EXPR)\n \n #define MINIMAL_SECOND_JUMP_OPTIMIZATION\n \n-/* Return true if parallel operations are expected to be emitted via the\n-   packing flag.  */\n-#define PACKING_FLAG_USED_P() \\\n-(optimize && flag_schedule_insns_after_reload && ISSUE_RATE > 1)\n \n /* If the following macro is defined and nonzero and deterministic\n    finite state automata are used for pipeline hazard recognition, the\n@@ -3304,20 +3291,43 @@ enum frv_builtins\n   FRV_BUILTIN_MCPLI,\n   FRV_BUILTIN_MDCUTSSI,\n   FRV_BUILTIN_MQSATHS,\n+  FRV_BUILTIN_MQLCLRHS,\n+  FRV_BUILTIN_MQLMTHS,\n+  FRV_BUILTIN_MQSLLHI,\n+  FRV_BUILTIN_MQSRAHI,\n   FRV_BUILTIN_MHSETLOS,\n   FRV_BUILTIN_MHSETLOH,\n   FRV_BUILTIN_MHSETHIS,\n   FRV_BUILTIN_MHSETHIH,\n   FRV_BUILTIN_MHDSETS,\n-  FRV_BUILTIN_MHDSETH\n+  FRV_BUILTIN_MHDSETH,\n+  FRV_BUILTIN_SMUL,\n+  FRV_BUILTIN_UMUL,\n+  FRV_BUILTIN_PREFETCH0,\n+  FRV_BUILTIN_PREFETCH,\n+  FRV_BUILTIN_SMASS,\n+  FRV_BUILTIN_SMSSS,\n+  FRV_BUILTIN_SMU,\n+  FRV_BUILTIN_SCUTSS,\n+  FRV_BUILTIN_ADDSS,\n+  FRV_BUILTIN_SUBSS,\n+  FRV_BUILTIN_SLASS,\n+  FRV_BUILTIN_IACCreadll,\n+  FRV_BUILTIN_IACCreadl,\n+  FRV_BUILTIN_IACCsetll,\n+  FRV_BUILTIN_IACCsetl,\n+  FRV_BUILTIN_SCAN\n };\n+#define FRV_BUILTIN_FIRST_NONMEDIA FRV_BUILTIN_SMUL\n \n /* Enable prototypes on the call rtl functions.  */\n #define MD_CALL_PROTOTYPES 1\n \n extern GTY(()) rtx frv_compare_op0;\t\t\t/* operand save for */\n extern GTY(()) rtx frv_compare_op1;\t\t\t/* comparison generation */\n \n+#define CPU_UNITS_QUERY 1\n+\n #ifdef __FRV_FDPIC__\n #define CRT_GET_RFIB_DATA(dbase) \\\n   ({ extern void *_GLOBAL_OFFSET_TABLE_; (dbase) = &_GLOBAL_OFFSET_TABLE_; })"}, {"sha": "02dce0dcfa021cb9c7b87c0f14aeaa294c716cc6", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1006, "deletions": 538, "changes": 1544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=c557edf447d02a1bace4e84cb4515e1de06be4d9", "patch": "@@ -318,7 +318,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in frv-protos.h.\n \n-(define_attr \"cpu\" \"generic,fr500,fr400,fr300,simple,tomcat\"\n+(define_attr \"cpu\" \"generic,fr550,fr500,fr450,fr405,fr400,fr300,simple,tomcat\"\n   (const (symbol_ref \"frv_cpu_type\")))\n \n ;; Attribute is \"yes\" for branches and jumps that span too great a distance\n@@ -328,520 +328,383 @@\n (define_attr \"far_jump\" \"yes,no\" (const_string \"no\"))\n \n ;; Instruction type\n-\n-;; The table below summarizes the types of media instruction and their\n-;; scheduling classification.  Headings are:\n-\n-;; Type:\tthe name of the define_attr type\n-;; Conditions:\t\"yes\" if conditional variants are available\n-;; FR500:\tFujitsu's categorization for the FR500\n-;; FR400:\tFujitsu's categorization for the FR400 (but see below).\n-\n-;; On the FR400, media instructions are divided into 2 broad categories.\n-;; Category 1 instructions can execute in either the M0 or M1 unit and can\n-;; execute in parallel with other category 1 instructions.  Category 2\n-;; instructions must use the M0 unit, and therefore cannot run in parallel\n-;; with other media instructions.\n-\n-;; The FR400 documentation also divides media instructions into one of seven\n-;; categories (m1 to m7).  m1 to m4 contain both Category 1 and Category 2\n-;; instructions, so we use a combination of the categories here.\n-\n-;; Type\t\tConditional\tFR500\tFR400\n-;; ----\t\t----------\t-----\t-----\n-;; mlogic\tyes\t\tm1\tm1:1\n-;; mrdacc\tno\t\tm2\tm4:1\n-;; mwtacc\tno\t\tm3\tm5:1\n-;; maveh\tno\t\tm1\tm1:1\n-;; msath\tno\t\tm1\tm1:1\n-;; maddh\tyes\t\tm1\tm1:1\n-;; mqaddh\tyes\t\tm1\tm1:2\n-;; mpackh\tno\t\tm2\tm3:1\n-;; munpackh\tno\t\tm2\tm3:2\n-;; mdpackh\tno\t\tm5\tm3:2\n-;; mbhconv\tyes\t\tm2\tm3:2\n-;; mrot\t\tno\t\tm2\tm3:1\n-;; mshift\tno\t\tm2\tm3:1\n-;; mexpdhw\tyes\t\tm2\tm3:1\n-;; mexpdhd\tyes\t\tm2\tm3:2\n-;; mwcut\tno\t\tm2\tm3:2\n-;; mmulh\tyes\t\tm4\tm2:1\n-;; mmulxh\tno\t\tm4\tm2:1\n-;; mmach\tyes\t\tm4\tm2:1\n-;; mmrdh\tno\t\tm4\tm2:1\n-;; mqmulh\tyes\t\tm4\tm2:2\n-;; mqmulxh\tno\t\tm4\tm2:2\n-;; mqmach\tyes\t\tm4\tm2:2\n-;; mcpx\t\tyes\t\tm4\tm2:1\n-;; mqcpx\tyes\t\tm4\tm2:2\n-;; mcut\t\tno\t\tm2\tm4:1\n-;; mclracc\tno\t\tm3\tm4:1\n-;; mclracca\tno\t\tm6\tm4:2\n-;; mdunpackh\tno\t\tm2\tn/a\n-;; mbhconve\tno\t\tm2\tn/a\n-;; maddacc\tno\t\tn/a\tm2:1\n-;; mdaddacc\tno\t\tn/a\tm2:2\n-;; mabsh\tno\t\tn/a\tm1:1\n-;; mdrot\tno\t\tn/a\tm3:2\n-;; mcpl\t\tno\t\tn/a\tm3:2\n-;; mdcut\tno\t\tn/a\tm4:2\n-;; mqsath\tno\t\tn/a\tm1:2\n-;; mset\t\tno\t\tn/a\tm1:1\n-\n+;; \"unknown\" must come last.\n (define_attr \"type\"\n-  \"int,sethi,setlo,mul,div,gload,gstore,fload,fstore,movfg,movgf,branch,jump,jumpl,call,spr,trap,fsconv,fsadd,fsmul,fmas,fsdiv,sqrt_single,fdconv,fdadd,fdmul,fddiv,sqrt_double,mlogic,maveh,msath,maddh,mqaddh,mpackh,munpackh,mdpackh,mbhconv,mrot,mshift,mexpdhw,mexpdhd,mwcut,mmulh,mmulxh,mmach,mmrdh,mqmulh,mqmulxh,mqmach,mcpx,mqcpx,mcut,mclracc,mclracca,mdunpackh,mbhconve,mrdacc,mwtacc,maddacc,mdaddacc,mabsh,mdrot,mcpl,mdcut,mqsath,mset,m7,ccr,multi,unknown\"\n+  \"int,sethi,setlo,mul,div,gload,gstore,fload,fstore,movfg,movgf,macc,scan,cut,branch,jump,jumpl,call,spr,trap,fnop,fsconv,fsadd,fscmp,fsmul,fsmadd,fsdiv,sqrt_single,fdconv,fdadd,fdcmp,fdmul,fdmadd,fddiv,sqrt_double,mnop,mlogic,maveh,msath,maddh,mqaddh,mpackh,munpackh,mdpackh,mbhconv,mrot,mshift,mexpdhw,mexpdhd,mwcut,mmulh,mmulxh,mmach,mmrdh,mqmulh,mqmulxh,mqmach,mcpx,mqcpx,mcut,mclracc,mclracca,mdunpackh,mbhconve,mrdacc,mwtacc,maddacc,mdaddacc,mabsh,mdrot,mcpl,mdcut,mqsath,mqlimh,mqshift,mset,ccr,multi,unknown\"\n   (const_string \"unknown\"))\n \n+(define_attr \"acc_group\" \"none,even,odd\"\n+  (symbol_ref \"frv_acc_group (insn)\"))\n \f\n-\n-/* This is description of pipeline hazards based on DFA.  The\n-   following constructions can be used for this:\n-\n-   o define_cpu_unit string [string]) describes a cpu functional unit\n-     (separated by comma).\n-\n-     1st operand: Names of cpu function units.\n-     2nd operand: Name of automaton (see comments for\n-     DEFINE_AUTOMATON).\n-\n-     All define_reservations and define_cpu_units should have unique\n-     names which cannot be \"nothing\".\n-\n-   o (exclusion_set string string) means that each CPU function unit\n-     in the first string cannot be reserved simultaneously with each\n-     unit whose name is in the second string and vise versa.  CPU\n-     units in the string are separated by commas. For example, it is\n-     useful for description CPU with fully pipelined floating point\n-     functional unit which can execute simultaneously only single\n-     floating point insns or only double floating point insns.\n-\n-   o (presence_set string string) means that each CPU function unit in\n-     the first string cannot be reserved unless at least one of units\n-     whose names are in the second string is reserved.  This is an\n-     asymmetric relation.  CPU units in the string are separated by\n-     commas.  For example, it is useful for description that slot1 is\n-     reserved after slot0 reservation for a VLIW processor.\n-\n-   o (absence_set string string) means that each CPU function unit in\n-     the first string cannot be reserved only if each unit whose name\n-     is in the second string is not reserved.  This is an asymmetric\n-     relation (actually exclusion set is analogous to this one but it\n-     is symmetric).  CPU units in the string are separated by commas.\n-     For example, it is useful for description that slot0 cannot be\n-     reserved after slot1 or slot2 reservation for a VLIW processor.\n-\n-   o (define_bypass number out_insn_names in_insn_names) names bypass with\n-     given latency (the first number) from insns given by the first\n-     string (see define_insn_reservation) into insns given by the\n-     second string.  Insn names in the strings are separated by\n-     commas.\n-\n-   o (define_automaton string) describes names of an automaton\n-     generated and used for pipeline hazards recognition.  The names\n-     are separated by comma.  Actually it is possibly to generate the\n-     single automaton but unfortunately it can be very large.  If we\n-     use more one automata, the summary size of the automata usually\n-     is less than the single one.  The automaton name is used in\n-     define_cpu_unit.  All automata should have unique names.\n-\n-   o (define_reservation string string) names reservation (the first\n-     string) of cpu functional units (the 2nd string).  Sometimes unit\n-     reservations for different insns contain common parts.  In such\n-     case, you describe common part and use one its name (the 1st\n-     parameter) in regular expression in define_insn_reservation.  All\n-     define_reservations, define results and define_cpu_units should\n-     have unique names which cannot be \"nothing\".\n-\n-   o (define_insn_reservation name default_latency condition regexpr)\n-     describes reservation of cpu functional units (the 3nd operand)\n-     for instruction which is selected by the condition (the 2nd\n-     parameter).  The first parameter is used for output of debugging\n-     information.  The reservations are described by a regular\n-     expression according the following syntax:\n-\n-       regexp = regexp \",\" oneof\n-              | oneof\n-\n-       oneof = oneof \"|\" allof\n-             | allof\n-\n-       allof = allof \"+\" repeat\n-             | repeat\n-\n-       repeat = element \"*\" number\n-              | element\n-\n-       element = cpu_function_name\n-               | reservation_name\n-               | result_name\n-               | \"nothing\"\n-               | \"(\" regexp \")\"\n-\n-       1. \",\" is used for describing start of the next cycle in\n-          reservation.\n-\n-       2. \"|\" is used for describing the reservation described by the\n-          first regular expression *or* the reservation described by\n-          the second regular expression *or* etc.\n-\n-       3. \"+\" is used for describing the reservation described by the\n-          first regular expression *and* the reservation described by\n-          the second regular expression *and* etc.\n-\n-       4. \"*\" is used for convenience and simply means sequence in\n-          which the regular expression are repeated NUMBER times with\n-          cycle advancing (see \",\").\n-\n-       5. cpu function unit name which means reservation.\n-\n-       6. reservation name -- see define_reservation.\n-\n-       7. string \"nothing\" means no units reservation.\n-\n-*/\n-\n-(define_automaton \"nodiv, idiv, div\")\n-\n-;; An FR500 packet can contain a single control instruction or a sequence\n-;; of up to four operations matching the regular expression:\n-\n-;;\t(I FM? I? FM? | FM? FM?) B? B?\n-\n-;; where I denotes an integer operation, FM a floating-point or media\n-;; operation, and B a branch operation.  There are two units for each type\n-;; of instruction: I0 and I1, FM0 and FM1, and B0 and B1.  Units are\n-;; allocated left-to-right: the first integer instruction uses I0, the\n-;; second uses I1, and so on.\n-\n-;; The FR400 is similar to the FR500 except that it allows only 2 operations\n-;; per packet and has only one branch unit.  We can use the FR500 conflict\n-;; description for the FR400, but need to define different cpu_units\n-;; later.\n-\n-;; Slot/unit combinations available on the FR400 and above:\n-(define_cpu_unit \"sl0_i0, sl0_fm0, sl0_b0, sl0_c\" \"nodiv\")\n-(define_cpu_unit \"sl1_fm0, sl1_i1, sl1_fm1, sl1_b0\" \"nodiv\")\n-\n-;; These are available on the FR500 and above:\n-(define_cpu_unit \"sl1_b1\" \"nodiv\")\n-(define_cpu_unit \"sl2_i1, sl2_fm1, sl2_b0, sl2_b1\" \"nodiv\")\n-(define_cpu_unit \"sl3_fm1, sl3_b0, sl3_b1\"  \"nodiv\")\n-\n-;; The following describes conflicts by slots\n-;; slot0\n-(exclusion_set \"sl0_i0\"  \"sl0_fm0,sl0_b0,sl0_c\")\n-(exclusion_set \"sl0_fm0\" \"sl0_b0,sl0_c\")\n-(exclusion_set \"sl0_b0\"  \"sl0_c\")\n-\n-;; slot1\n-(exclusion_set \"sl1_fm0\" \"sl1_i1,sl1_fm1,sl1_b0,sl1_b1\")\n-(exclusion_set \"sl1_i1\"  \"sl1_fm1,sl1_b0,sl1_b1\")\n-(exclusion_set \"sl1_fm1\" \"sl1_b0,sl1_b1\")\n-(exclusion_set \"sl1_b0\"  \"sl1_b1\")\n-\n-;; slot2\n-(exclusion_set \"sl2_i1\"  \"sl2_fm1,sl2_b0,sl2_b1\")\n-(exclusion_set \"sl2_fm1\" \"sl2_b0,sl2_b1\")\n-(exclusion_set \"sl2_b0\"  \"sl2_b1\")\n-\n-;; slot3\n-(exclusion_set \"sl3_fm1\" \"sl3_b0,sl3_b1\")\n-(exclusion_set \"sl3_b0\"  \"sl3_b1\")\n-\n-;; The following describes conflicts by units\n-;; fm0\n-(exclusion_set \"sl0_fm0\" \"sl1_fm0\")\n-\n-;; b0\n-(exclusion_set \"sl0_b0\"  \"sl1_b0,sl2_b0,sl3_b0\")\n-(exclusion_set \"sl1_b0\"  \"sl2_b0,sl3_b0\")\n-(exclusion_set \"sl2_b0\"  \"sl3_b0\")\n-\n-;; i1\n-(exclusion_set \"sl1_i1\"  \"sl2_i1\")\n-\n-;; fm1\n-(exclusion_set \"sl1_fm1\" \"sl2_fm1,sl3_fm1\")\n-(exclusion_set \"sl2_fm1\" \"sl3_fm1\")\n-\n-;; b1\n-(exclusion_set \"sl1_b1\"  \"sl2_b1,sl3_b1\")\n-(exclusion_set \"sl2_b1\"  \"sl3_b1\")\n-\n-;; The following describes remaining combinations of conflicts\n-;; slot0\n-(exclusion_set \"sl0_i0\"  \"sl1_fm1,sl1_b1\")\n-(exclusion_set \"sl0_fm0\" \"sl1_i1,sl1_b1,sl2_i1,sl2_fm1,sl3_fm1,sl3_b0\")\n-(exclusion_set \"sl0_b0\"  \"sl1_fm0,sl1_i1,sl1_fm1,sl2_i1,sl2_fm1,sl2_b1,\\\n-                          sl3_fm1,sl3_b1\")\n-(exclusion_set \"sl0_c\"   \"sl1_fm0,sl1_i1,sl1_fm1,sl1_b0,sl1_b1,sl2_i1,sl2_fm1,\\\n-                          sl2_b0,sl2_b1,sl3_fm1,sl3_b0,sl3_b1\")\n-\n-\n-;; slot1\n-(exclusion_set \"sl1_fm0\" \"sl2_b1\")\n-(exclusion_set \"sl1_i1\"  \"sl2_fm1,sl2_b1,sl3_fm1,sl3_b0\")\n-(exclusion_set \"sl1_fm1\" \"sl2_i1,sl2_b1,sl3_b0\")\n-(exclusion_set \"sl1_b0\"  \"sl2_i1,sl2_fm1,sl3_fm1,sl3_b1\")\n-(exclusion_set \"sl1_b1\"  \"sl2_i1,sl2_fm1,sl2_b0,sl3_fm1,sl3_b0\")\n-\n-;; slot2\n-(exclusion_set \"sl2_i1\"  \"sl3_b1\")\n-(exclusion_set \"sl2_fm1\" \"sl3_b1\")\n-(exclusion_set \"sl2_b0\"  \"sl3_fm1\")\n-(exclusion_set \"sl2_b1\"  \"sl3_fm1,sl3_b0\")\n-\n-;; slot3\n-(exclusion_set \"sl1_fm0\" \"sl2_i1,sl2_fm1,sl2_b0,sl2_b1,sl3_fm1,sl3_b0,sl3_b1\")\n-(exclusion_set \"sl3_fm1\" \"sl2_i1,sl2_fm1,sl2_b0,sl2_b1,sl3_b0,sl3_b1\")\n+;; Scheduling and Packing Overview\n+;; -------------------------------\n+;;\n+;; FR-V instructions are divided into five groups: integer, floating-point,\n+;; media, branch and control.  Each group is associated with a separate set\n+;; of processing units, the number and behavior of which depend on the target\n+;; target processor.  Integer units have names like I0 and I1, floating-point\n+;; units have names like F0 and F1, and so on.\n+;;\n+;; Each member of the FR-V family has its own restrictions on which\n+;; instructions can issue to which units.  For example, some processors\n+;; allow loads to issue to I0 or I1 while others only allow them to issue\n+;; to I0.  As well as these processor-specific restrictions, there is a\n+;; general rule that an instruction can only issue to unit X + 1 if an\n+;; instruction in the same packet issued to unit X.\n+;;\n+;; Sometimes the only way to honor these restrictions is by adding nops\n+;; to a packet.  For example, on the fr550, media instructions that access\n+;; ACC4-7 can only issue to M1 or M3.  It is therefore only possible to\n+;; execute these instructions by packing them with something that issues\n+;; to M0.  When no useful M0 instruction exists, an \"mnop\" can be used\n+;; instead.\n+;;\n+;; Having decided which instructions should issue to which units, the packet\n+;; should be ordered according to the following template:\n+;;\n+;;     I0 F0/M0 I1 F1/M1 .... B0 B1 ...\n+;;\n+;; Note that VLIW packets execute strictly in parallel.  Every instruction\n+;; in the packet will stall until all input operands are ready.  These\n+;; operands are then read simultaneously before any registers are modified.\n+;; This means that it's OK to have write-after-read hazards between\n+;; instructions in the same packet, even if the write is listed earlier\n+;; than the read.\n+;;\n+;; Three gcc passes are involved in generating VLIW packets:\n+;;\n+;;    (1) The scheduler.  This pass uses the standard scheduling code and\n+;;\t  behaves in much the same way as it would for a superscalar RISC\n+;;\t  architecture.\n+;;\n+;;    (2) frv_reorg.  This pass inserts nops into packets in order to meet\n+;;\t  the processor's issue requirements.  It also has code to optimize\n+;;\t  the type of padding used to align labels.\n+;;\n+;;    (3) frv_pack_insns.  The final packing phase, which puts the\n+;;\t  instructions into assembly language order according to the\n+;;\t  \"I0 F0/M0 ...\" template above.\n+;;\n+;; In the ideal case, these three passes will agree on which instructions\n+;; should be packed together, but this won't always happen.  In particular:\n+;;\n+;;    (a) (2) might not pack predicated instructions in the same way as (1).\n+;;\t  The scheduler tries to schedule predicated instructions for the\n+;;\t  worst case, assuming the predicate is true.  However, if we have\n+;;\t  something like a predicated load, it isn't always possible to\n+;;\t  fill the load delay with useful instructions.  (2) should then\n+;;\t  pack the user of the loaded value as aggressively as possible,\n+;;\t  in order to optimize the case when the predicate is false.\n+;;\t  See frv_pack_insn_p for more details.\n+;;\n+;;    (b) The final shorten_branches pass runs between (2) and (3).\n+;;\t  Since (2) inserts nops, it is possible that some branches\n+;;\t  that were thought to be in range during (2) turned out to\n+;;\t  out-of-range in (3).\n+;;\n+;; All three passes use DFAs to model issue restrictions.  The main\n+;; question that the DFAs are supposed to answer is simply: can these\n+;; instructions be packed together?  The DFAs are not responsible for\n+;; assigning instructions to execution units; that's the job of\n+;; frv_sort_insn_group, see below for details.\n+;;\n+;; To get the best results, the DFAs should try to allow packets to\n+;; be built in every possible order.  This gives the scheduler more\n+;; flexibility, removing the need for things like multipass lookahead.\n+;; It also means we can take more advantage of inter-packet dependencies.\n+;;\n+;; For example, suppose we're compiling for the fr400 and we have:\n+;;\n+;;\taddi\tgr4,#1,gr5\n+;;\tldi\t@(gr6,gr0),gr4\n+;;\n+;; We can pack these instructions together by assigning the load to I0 and\n+;; the addition to I1.  However, because of the anti dependence between the\n+;; two instructions, the scheduler must schedule the addition first.\n+;; We should generally get better schedules if the DFA allows both\n+;; (ldi, addi) and (addi, ldi), leaving the final packing pass to\n+;; reorder the packet where appropriate.\n+;;\n+;; Almost all integer instructions can issue to any unit in the range I0\n+;; to Ix, where the value of \"x\" depends on the type of instruction and\n+;; on the target processor.  The rules for other instruction groups are\n+;; usually similar.\n+;;\n+;; When the restrictions are as regular as this, we can get the desired\n+;; behavior by claiming the DFA unit associated with the highest unused\n+;; execution unit.  For example, if an instruction can issue to I0 or I1,\n+;; the DFA first tries to take the DFA unit associated with I1, and will\n+;; only take I0's unit if I1 isn't free.  (Note that, as mentioned above,\n+;; the DFA does not assign instructions to units.  An instruction that\n+;; claims DFA unit I1 will not necessarily issue to I1 in the final packet.)\n+;;\n+;; There are some cases, such as the fr550 media restriction mentioned\n+;; above, where the rule is not as simple as \"any unit between 0 and X\".\n+;; Even so, allocating higher units first brings us close to the ideal.\n+;;\n+;; Having divided instructions into packets, passes (2) and (3) must\n+;; assign instructions to specific execution units.  They do this using\n+;; the following algorithm:\n+;;\n+;;    1. Partition the instructions into groups (integer, float/media, etc.)\n+;;\n+;;    2. For each group of instructions:\n+;;\n+;;\t (a) Issue each instruction in the reset DFA state and use the\n+;;\t     DFA cpu_unit_query interface to find out which unit it picks\n+;;\t     first.\n+;;\n+;;\t (b) Sort the instructions into ascending order of picked units.\n+;;\t     Instructions that pick I1 first come after those that pick\n+;;\t     I0 first, and so on.  Let S be the sorted sequence and S[i]\n+;;\t     be the ith element of it (counting from zero).\n+;;\n+;;\t (c) If this is the control or branch group, goto (i)\n+;;\n+;;\t (d) Find the largest L such that S[0]...S[L-1] can be issued\n+;;\t     consecutively from the reset state and such that the DFA\n+;;\t     claims unit X when S[X] is added.  Let D be the DFA state\n+;;\t     after instructions S[0]...S[L-1] have been issued.\n+;;\n+;;\t (e) If L is the length of S, goto (i)\n+;;\n+;;\t (f) Let U be the number of units belonging to this group and #S be\n+;;\t     the length of S.  Create a new sequence S' by concatenating\n+;;\t     S[L]...S[#S-1] and (U - #S) nops.\n+;;\n+;;\t (g) For each permutation S'' of S', try issuing S'' from last to\n+;;\t     first, starting with state D.  See if the DFA claims unit\n+;;\t     X + L when each S''[X] is added.  If so, set S to the\n+;;\t     concatenation of S[0]...S[L-1] and S'', then goto (i).\n+;;\n+;;\t (h) If (g) found no permuation, abort.\n+;;\n+;;\t (i) S is now the sorted sequence for this group, meaning that S[X]\n+;;\t     issues to unit X.  Trim any unwanted nops from the end of S.\n+;;\n+;; The sequence calculated by (b) is trivially correct for control\n+;; instructions since they can't be packed.  It is also correct for branch\n+;; instructions due to their simple issue requirements.  For integer and\n+;; floating-point/media instructions, the sequence calculated by (b) is\n+;; often the correct answer; the rest of the algorithm is optimized for\n+;; the case in which it is correct.\n+;;\n+;; If there were no irregularities in the issue restrictions then step\n+;; (d) would not be needed.  It is mainly there to cope with the fr550\n+;; integer restrictions, where a store can issue to I1, but only if a store\n+;; also issues to I0.  (Note that if a packet has two stores, they will be\n+;; at the beginning of the sequence calculated by (b).)  It also copes\n+;; with fr400 M-2 instructions, which must issue to M0, and which cannot\n+;; be issued together with an mnop in M1.\n+;;\n+;; Step (g) is the main one for integer and float/media instructions.\n+;; The first permutation it tries is S' itself (because, as noted above,\n+;; the sequence calculated by (b) is often correct).  If S' doesn't work,\n+;; the implementation tries varying the beginning of the sequence first.\n+;; Thus the nops towards the end of the sequence will only move to lower\n+;; positions if absolutely necessary.\n+;;\n+;; The algorithm is theoretically exponential in the number of instructions\n+;; in a group, although it's only O(n log(n)) if the sequence calculated by\n+;; (b) is acceptable.  In practice, the algorithm completes quickly even\n+;; in the rare cases where (g) needs to try other permutations.\n+(define_automaton \"integer, float_media, branch, control, idiv, div\")\n+\n+;; The main issue units.  Note that not all units are available on\n+;; all processors.\n+(define_query_cpu_unit \"i0,i1,i2,i3\" \"integer\")\n+(define_query_cpu_unit \"f0,f1,f2,f3\" \"float_media\")\n+(define_query_cpu_unit \"b0,b1\" \"branch\")\n+(define_query_cpu_unit \"c\" \"control\")\n+\n+;; Division units.\n+(define_cpu_unit \"idiv1,idiv2\" \"idiv\")\n+(define_cpu_unit \"div1,div2,root\" \"div\")\n+\n+;; Control instructions cannot be packed with others.\n+(define_reservation \"control\" \"i0+i1+i2+i3+f0+f1+f2+f3+b0+b1\")\n+\n+;; Generic reservation for control insns\n+(define_insn_reservation \"control\" 1\n+  (eq_attr \"type\" \"trap,spr,unknown,multi\")\n+  \"c + control\")\n \n ;; ::::::::::::::::::::\n ;; ::\n ;; :: Generic/FR500 scheduler description\n ;; ::\n ;; ::::::::::::::::::::\n \n-;; Define reservation in order to describe only in terms of units.\n-\n-(define_reservation \"i0\" \"sl0_i0\")\n-(define_reservation \"f0\" \"sl0_fm0|sl1_fm0\")\n-(define_reservation \"m0\" \"f0\")\n-(define_reservation \"b0\" \"sl0_b0|sl1_b0|sl2_b0|sl3_b0\")\n-(define_reservation \"c\"  \"sl0_c\")\n-(define_reservation \"i1\" \"sl1_i1|sl2_i1\")\n-(define_reservation \"f1\" \"sl1_fm1|sl2_fm1|sl3_fm1\")\n-(define_reservation \"m1\" \"f1\")\n-(define_reservation \"b1\" \"sl1_b1|sl2_b1|sl3_b1\")\n-\n ;; Integer insns\n-;; It is not possibly to issue load & store in one VLIW insn.\n-(define_cpu_unit \"idiv1\" \"idiv\")\n-(define_cpu_unit \"idiv2\" \"idiv\")\n-(define_cpu_unit \"l0\"    \"nodiv\")\n-(define_cpu_unit \"l1\"    \"nodiv\")\n-(define_cpu_unit \"s0\"    \"nodiv\")\n-\n-(exclusion_set \"l1,l0\" \"s0\")\n-\n-;; We set the default_latency of sethi to be 0 to allow sethi and setlo to be\n-;; combined in the same VLIW instruction as allowed by the architecture.  This\n-;; assumes the only use of sethi is always followed by a setlo of the same\n-;; register.\n-(define_insn_reservation \"i1_sethi\" 0\n+;; Synthetic units used to describe issue restrictions.\n+(define_automaton \"fr500_integer\")\n+(define_cpu_unit \"fr500_load0,fr500_load1,fr500_store0\" \"fr500_integer\")\n+(exclusion_set \"fr500_load0,fr500_load1\" \"fr500_store0\")\n+\n+(define_bypass 0 \"fr500_i1_sethi\" \"fr500_i1_setlo\")\n+(define_insn_reservation \"fr500_i1_sethi\" 1\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"sethi\"))\n-  \"i0|i1\")\n+  \"i1|i0\")\n \n-(define_insn_reservation \"i1_setlo\" 1\n+(define_insn_reservation \"fr500_i1_setlo\" 1\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"setlo\"))\n-  \"i0|i1\")\n+  \"i1|i0\")\n \n-(define_insn_reservation \"i1_int\" 1\n+(define_insn_reservation \"fr500_i1_int\" 1\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"int\"))\n-  \"i0|i1\")\n+  \"i1|i0\")\n \n-(define_insn_reservation \"i1_mul\" 3\n+(define_insn_reservation \"fr500_i1_mul\" 3\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"mul\"))\n-  \"i0|i1\")\n+  \"i1|i0\")\n \n-(define_insn_reservation \"i1_div\" 19\n+(define_insn_reservation \"fr500_i1_div\" 19\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"div\"))\n-  \"(i0|i1),(idiv1*18|idiv2*18)\")\n-\n-(define_insn_reservation \"i2_gload\" 4\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"gload\"))\n-  \"(i0|i1)+(l0|l1)\")\n-\n-(define_insn_reservation \"i2_fload\" 4\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"fload\"))\n-  \"(i0|i1)+(l0|l1)\")\n+  \"(i1|i0),(idiv1*18|idiv2*18)\")\n \n-(define_insn_reservation \"i3_gstore\" 0\n+(define_insn_reservation \"fr500_i2\" 4\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"gstore\"))\n-  \"i0+s0\")\n+       (eq_attr \"type\" \"gload,fload\"))\n+  \"(i1|i0) + (fr500_load0|fr500_load1)\")\n \n-(define_insn_reservation \"i3_fstore\" 0\n+(define_insn_reservation \"fr500_i3\" 0\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"fstore\"))\n-  \"i0+s0\")\n+       (eq_attr \"type\" \"gstore,fstore\"))\n+  \"i0 + fr500_store0\")\n \n-(define_insn_reservation \"i4_move_gf\" 3\n+(define_insn_reservation \"fr500_i4\" 3\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"movgf\"))\n+       (eq_attr \"type\" \"movgf,movfg\"))\n   \"i0\")\n \n-(define_insn_reservation \"i4_move_fg\" 3 \n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"movfg\"))\n-  \"i0\")\n-\n-(define_insn_reservation \"i5\" 0\n+(define_insn_reservation \"fr500_i5\" 0\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"jumpl\"))\n   \"i0\")\n \n-;; Clear/commit is not generated now:\n-(define_insn_reservation \"i6\" 0 (const_int 0) \"i0|i1\")\n-\n ;;\n ;; Branch-instructions\n ;;\n-(define_insn_reservation \"b1/b3\" 0\n+(define_insn_reservation \"fr500_branch\" 0\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"jump,branch,ccr\"))\n-  \"b0|b1\")\n-\n-;; The following insn is not generated now.\n+  \"b1|b0\")\n \n-(define_insn_reservation \"b2\" 0 (const_int 0) \"b0\")\n-\n-(define_insn_reservation \"b4\" 0\n+(define_insn_reservation \"fr500_call\" 0\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"call\"))\n   \"b0\")\n \n-;; The following insns are not generated now.\n-(define_insn_reservation \"b5\" 0 (const_int 0) \"b0|b1\")\n-(define_insn_reservation \"b6\" 0 (const_int 0) \"b0|b1\")\n-\n-;; Control insns\n-(define_insn_reservation \"trap\" 0\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"trap\"))\n-  \"c\")\n+;; Floating point insns.  The default latencies are for non-media\n+;; instructions; media instructions incur an extra cycle.\n \n-(define_insn_reservation \"control\" 0\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"spr\"))\n-  \"c\")\n-\n-;; Floating point insns\n-(define_cpu_unit \"add0\" \"nodiv\")\n-(define_cpu_unit \"add1\" \"nodiv\")\n-(define_cpu_unit \"mul0\" \"nodiv\")\n-(define_cpu_unit \"mul1\" \"nodiv\")\n-(define_cpu_unit \"div1\" \"div\")\n-(define_cpu_unit \"div2\" \"div\")\n-(define_cpu_unit \"root\" \"div\")\n-\n-(define_bypass 4 \"f1\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_insn_reservation \"f1\" 3\n+(define_bypass 4 \"fr500_farith\" \"fr500_m1,fr500_m2,fr500_m3,\n+\t\t\t         fr500_m4,fr500_m5,fr500_m6\")\n+(define_insn_reservation \"fr500_farith\" 3\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"fsconv,fdconv\"))\n-  \"(f0|f1)\")\n+       (eq_attr \"type\" \"fnop,fsconv,fsadd,fsmul,fsmadd,fdconv,fdadd,fdmul,fdmadd\"))\n+  \"(f1|f0)\")\n \n-(define_bypass 4 \"f2\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_insn_reservation \"f2\" 3\n+(define_insn_reservation \"fr500_fcmp\" 4\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"fsadd,fdadd\"))\n-  \"(f0|f1)+(add0|add1)\")\n+       (eq_attr \"type\" \"fscmp,fdcmp\"))\n+  \"(f1|f0)\")\n \n-(define_bypass 4 \"f3\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_insn_reservation \"f3\" 3\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"fsmul,fdmul\"))\n-  \"(f0|f1)+(mul0|mul1)\")\n-\n-(define_bypass 11 \"f4_div\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_insn_reservation \"f4_div\" 10\n+(define_bypass 11 \"fr500_fdiv\" \"fr500_m1,fr500_m2,fr500_m3,\n+\t\t\t        fr500_m4,fr500_m5,fr500_m6\")\n+(define_insn_reservation \"fr500_fdiv\" 10\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"fsdiv,fddiv\"))\n-  \"(f0|f1),(div1*9|div2*9)\")\n+  \"(f1|f0),(div1*9 | div2*9)\")\n \n-(define_bypass 16 \"f4_root\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_insn_reservation \"f4_root\" 15\n+(define_bypass 16 \"fr500_froot\" \"fr500_m1,fr500_m2,fr500_m3,\n+\t\t\t\t fr500_m4,fr500_m5,fr500_m6\")\n+(define_insn_reservation \"fr500_froot\" 15\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"sqrt_single,sqrt_double\"))\n-  \"(f0|f1)+root*15\")\n+  \"(f1|f0) + root*15\")\n \n-(define_bypass 4 \"f5\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_insn_reservation \"f5\" 3\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"fmas\"))\n-  \"(f0|f1)+(add0|add1)+(mul0|mul1)\")\n-\n-;; The following insns are not generated by gcc now:\n-(define_insn_reservation \"f6\" 0 (const_int 0) \"(f0|f1)+add0+add1\")\n-(define_insn_reservation \"f7\" 0 (const_int 0) \"(f0|f1)+mul0+mul1\")\n-\n-;; Media insns.  Now they are all not generated now.\n-(define_cpu_unit \"m1_0\" \"nodiv\")\n-(define_cpu_unit \"m1_1\" \"nodiv\")\n-(define_cpu_unit \"m2_0\" \"nodiv\")\n-(define_cpu_unit \"m2_1\" \"nodiv\")\n-(define_cpu_unit \"m3_0\" \"nodiv\")\n-(define_cpu_unit \"m3_1\" \"nodiv\")\n-(define_cpu_unit \"m4_0\" \"nodiv\")\n-(define_cpu_unit \"m4_1\" \"nodiv\")\n-(define_cpu_unit \"m5\"   \"nodiv\")\n-(define_cpu_unit \"m6\"   \"nodiv\")\n-(define_cpu_unit \"m7\"   \"nodiv\")\n-\n-(exclusion_set \"m5,m6,m7\" \"m2_0,m2_1,m3_0,m3_1\")\n-(exclusion_set \"m5\"       \"m6,m7\")\n-(exclusion_set \"m6\"       \"m4_0,m4_1,m7\")\n-(exclusion_set \"m7\"       \"m1_0,m1_1,add0,add1,mul0,mul1\")\n-\n-(define_bypass 2 \"m1\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_bypass 4 \"m1\" \"f1,f2,f3,f4_div,f4_root,f5,f6,f7\")\n-(define_insn_reservation \"m1\" 3\n+;; Media insns.  Conflict table is as follows:\n+;;\n+;;           M1  M2  M3  M4  M5  M6\n+;;        M1  -   -   -   -   -   -\n+;;        M2  -   -   -   -   X   X\n+;;        M3  -   -   -   -   X   X\n+;;        M4  -   -   -   -   -   X\n+;;        M5  -   X   X   -   X   X\n+;;        M6  -   X   X   X   X   X\n+;;\n+;; where X indicates an invalid combination.\n+;;\n+;; Target registers are as follows:\n+;;\n+;;\t  M1 : FPRs\n+;;\t  M2 : FPRs\n+;;\t  M3 : ACCs\n+;;\t  M4 : ACCs\n+;;\t  M5 : FPRs\n+;;\t  M6 : ACCs\n+;;\n+;; The default FPR latencies are for integer instructions.\n+;; Floating-point instructions need one cycle more and media\n+;; instructions need one cycle less.\n+(define_automaton \"fr500_media\")\n+(define_cpu_unit \"fr500_m2_0,fr500_m2_1\" \"fr500_media\")\n+(define_cpu_unit \"fr500_m3_0,fr500_m3_1\" \"fr500_media\")\n+(define_cpu_unit \"fr500_m4_0,fr500_m4_1\" \"fr500_media\")\n+(define_cpu_unit \"fr500_m5\" \"fr500_media\")\n+(define_cpu_unit \"fr500_m6\" \"fr500_media\")\n+\n+(exclusion_set \"fr500_m5,fr500_m6\" \"fr500_m2_0,fr500_m2_1,\n+\t\t\t\t    fr500_m3_0,fr500_m3_1\")\n+(exclusion_set \"fr500_m6\" \"fr500_m4_0,fr500_m4_1,fr500_m5\")\n+\n+(define_bypass 2 \"fr500_m1\" \"fr500_m1,fr500_m2,fr500_m3,\n+\t\t\t     fr500_m4,fr500_m5,fr500_m6\")\n+(define_bypass 4 \"fr500_m1\" \"fr500_farith,fr500_fcmp,fr500_fdiv,fr500_froot\")\n+(define_insn_reservation \"fr500_m1\" 3\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"mlogic,maveh,msath,maddh,mqaddh\"))\n-  \"(m0|m1)+(m1_0|m1_1)\")\n+       (eq_attr \"type\" \"mnop,mlogic,maveh,msath,maddh,mqaddh\"))\n+  \"(f1|f0)\")\n \n-(define_bypass 2 \"m2\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_bypass 4 \"m2\" \"f1,f2,f3,f4_div,f4_root,f5,f6,f7\")\n-(define_insn_reservation \"m2\" 3\n+(define_bypass 2 \"fr500_m2\" \"fr500_m1,fr500_m2,fr500_m3,\n+\t\t\t     fr500_m4,fr500_m5,fr500_m6\")\n+(define_bypass 4 \"fr500_m2\" \"fr500_farith,fr500_fcmp,fr500_fdiv,fr500_froot\")\n+(define_insn_reservation \"fr500_m2\" 3\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"mrdacc,mpackh,munpackh,mbhconv,mrot,mshift,mexpdhw,mexpdhd,mwcut,mcut,mdunpackh,mbhconve\"))\n-  \"(m0|m1)+(m2_0|m2_1)\")\n+  \"(f1|f0) + (fr500_m2_0|fr500_m2_1)\")\n \n-(define_bypass 1 \"m3\" \"m4\")\n-(define_insn_reservation \"m3\" 2\n+(define_bypass 1 \"fr500_m3\" \"fr500_m4\")\n+(define_insn_reservation \"fr500_m3\" 2\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"mclracc,mwtacc\"))\n-  \"(m0|m1)+(m3_0|m3_1)\")\n+  \"(f1|f0) + (fr500_m3_0|fr500_m3_1)\")\n \n-(define_bypass 1 \"m4\" \"m4\")\n-(define_insn_reservation \"m4\" 2\n+(define_bypass 1 \"fr500_m4\" \"fr500_m4\")\n+(define_insn_reservation \"fr500_m4\" 2\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"mmulh,mmulxh,mmach,mmrdh,mqmulh,mqmulxh,mqmach,mcpx,mqcpx\"))\n-  \"(m0|m1)+(m4_0|m4_1)\")\n+  \"(f1|f0) + (fr500_m4_0|fr500_m4_1)\")\n \n-(define_bypass 2 \"m5\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_bypass 4 \"m5\" \"f1,f2,f3,f4_div,f4_root,f5,f6,f7\")\n-(define_insn_reservation \"m5\" 3\n+(define_bypass 2 \"fr500_m5\" \"fr500_m1,fr500_m2,fr500_m3,\n+\t\t\t     fr500_m4,fr500_m5,fr500_m6\")\n+(define_bypass 4 \"fr500_m5\" \"fr500_farith,fr500_fcmp,fr500_fdiv,fr500_froot\")\n+(define_insn_reservation \"fr500_m5\" 3\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"mdpackh\"))\n-  \"(m0|m1)+m5\")\n+  \"(f1|f0) + fr500_m5\")\n \n-(define_bypass 1 \"m6\" \"m4\")\n-(define_insn_reservation \"m6\" 2\n+(define_bypass 1 \"fr500_m6\" \"fr500_m4\")\n+(define_insn_reservation \"fr500_m6\" 2\n   (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n        (eq_attr \"type\" \"mclracca\"))\n-  \"(m0|m1)+m6\")\n-\n-(define_bypass 2 \"m7\" \"m1,m2,m3,m4,m5,m6,m7\")\n-(define_bypass 4 \"m7\" \"f1,f2,f3,f4_div,f4_root,f5,f6,f7\")\n-\n-(define_insn_reservation \"m7\" 3\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"m7\"))\n-  \"(m0|m1)+m7\")\n-\n-;; Unknown & multi insns starts on new cycle and the next insn starts\n-;; on new cycle.  To describe this we consider as a control insn.\n-(define_insn_reservation \"unknown\" 1\n-  (and (eq_attr \"cpu\" \"generic,fr500,tomcat\")\n-       (eq_attr \"type\" \"unknown,multi\"))\n-  \"c\")\n+  \"(f1|f0) + fr500_m6\")\n \n ;; ::::::::::::::::::::\n ;; ::\n@@ -853,17 +716,6 @@\n ;; with non-media instructions.  Use fr400_m1unit to claim the M1 unit\n ;; without claiming a slot.\n \n-(define_cpu_unit \"fr400_m1unit\" \"nodiv\")\n-\n-(define_reservation \"fr400_i0\"      \"sl0_i0\")\n-(define_reservation \"fr400_i1\"      \"sl1_i1\")\n-(define_reservation \"fr400_m0\"      \"sl0_fm0|sl1_fm0\")\n-(define_reservation \"fr400_m1\"      \"sl1_fm1\")\n-(define_reservation \"fr400_meither\" \"fr400_m0|(fr400_m1+fr400_m1unit)\")\n-(define_reservation \"fr400_mboth\"   \"fr400_m0+fr400_m1unit\")\n-(define_reservation \"fr400_b\"       \"sl0_b0|sl1_b0\")\n-(define_reservation \"fr400_c\"       \"sl0_c\")\n-\n ;; Name\t\tClass\tUnits\tLatency\n ;; ====\t        =====\t=====\t=======\n ;; int\t\tI1\tI0/I1\t1\n@@ -888,69 +740,107 @@\n ;; unit too.\n \n (define_insn_reservation \"fr400_i1_int\" 1\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405,fr450\")\n        (eq_attr \"type\" \"int\"))\n-  \"fr400_i0|fr400_i1\")\n+  \"i1|i0\")\n \n-(define_insn_reservation \"fr400_i1_sethi\" 0\n-  (and (eq_attr \"cpu\" \"fr400\")\n+(define_bypass 0 \"fr400_i1_sethi\" \"fr400_i1_setlo\")\n+(define_insn_reservation \"fr400_i1_sethi\" 1\n+  (and (eq_attr \"cpu\" \"fr400,fr405,fr450\")\n        (eq_attr \"type\" \"sethi\"))\n-  \"fr400_i0|fr400_i1\")\n+  \"i1|i0\")\n \n (define_insn_reservation \"fr400_i1_setlo\" 1\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405,fr450\")\n        (eq_attr \"type\" \"setlo\"))\n-  \"fr400_i0|fr400_i1\")\n+  \"i1|i0\")\n \n+;; 3 is the worst case (write-after-write hazard).\n (define_insn_reservation \"fr400_i1_mul\" 3\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n+       (eq_attr \"type\" \"mul\"))\n+  \"i0\")\n+\n+(define_insn_reservation \"fr450_i1_mul\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n        (eq_attr \"type\" \"mul\"))\n-  \"fr400_i0\")\n+  \"i0\")\n+\n+(define_bypass 1 \"fr400_i1_macc\" \"fr400_i1_macc\")\n+(define_insn_reservation \"fr400_i1_macc\" 2\n+  (and (eq_attr \"cpu\" \"fr405,fr450\")\n+       (eq_attr \"type\" \"macc\"))\n+  \"i0|i1\")\n+\n+(define_insn_reservation \"fr400_i1_scan\" 1\n+  (and (eq_attr \"cpu\" \"fr400,fr405,fr450\")\n+       (eq_attr \"type\" \"scan\"))\n+  \"i0\")\n+\n+(define_insn_reservation \"fr400_i1_cut\" 2\n+  (and (eq_attr \"cpu\" \"fr405,fr450\")\n+       (eq_attr \"type\" \"cut\"))\n+  \"i0\")\n \n+;; 20 is for a write-after-write hazard.\n (define_insn_reservation \"fr400_i1_div\" 20\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n+       (eq_attr \"type\" \"div\"))\n+  \"i0 + idiv1*19\")\n+\n+(define_insn_reservation \"fr450_i1_div\" 19\n+  (and (eq_attr \"cpu\" \"fr450\")\n        (eq_attr \"type\" \"div\"))\n-  \"fr400_i0+idiv1*19\")\n+  \"i0 + idiv1*19\")\n \n-(define_insn_reservation \"fr400_i2_gload\" 4\n-  (and (eq_attr \"cpu\" \"fr400\")\n+;; 4 is for a write-after-write hazard.\n+(define_insn_reservation \"fr400_i2\" 4\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n+       (eq_attr \"type\" \"gload,fload\"))\n+  \"i0\")\n+\n+(define_insn_reservation \"fr450_i2_gload\" 3\n+  (and (eq_attr \"cpu\" \"fr450\")\n        (eq_attr \"type\" \"gload\"))\n-  \"fr400_i0\")\n+  \"i0\")\n \n-(define_insn_reservation \"fr400_i2_fload\" 4\n-  (and (eq_attr \"cpu\" \"fr400\")\n+;; 4 is for a write-after-write hazard.\n+(define_insn_reservation \"fr450_i2_fload\" 4\n+  (and (eq_attr \"cpu\" \"fr450\")\n        (eq_attr \"type\" \"fload\"))\n-  \"fr400_i0\")\n+  \"i0\")\n \n-(define_insn_reservation \"fr400_i3_gstore\" 0\n-  (and (eq_attr \"cpu\" \"fr400\")\n-       (eq_attr \"type\" \"gstore\"))\n-  \"fr400_i0\")\n+(define_insn_reservation \"fr400_i3\" 0\n+  (and (eq_attr \"cpu\" \"fr400,fr405,fr450\")\n+       (eq_attr \"type\" \"gstore,fstore\"))\n+  \"i0\")\n \n-(define_insn_reservation \"fr400_i3_fstore\" 0\n-  (and (eq_attr \"cpu\" \"fr400\")\n-       (eq_attr \"type\" \"fstore\"))\n-  \"fr400_i0\")\n+;; 3 is for a write-after-write hazard.\n+(define_insn_reservation \"fr400_i4\" 3\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n+       (eq_attr \"type\" \"movfg,movgf\"))\n+  \"i0\")\n \n-(define_insn_reservation \"fr400_i4_movfg\" 3\n-  (and (eq_attr \"cpu\" \"fr400\")\n+(define_insn_reservation \"fr450_i4_movfg\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n        (eq_attr \"type\" \"movfg\"))\n-  \"fr400_i0\")\n+  \"i0\")\n \n-(define_insn_reservation \"fr400_i4_movgf\" 3\n-  (and (eq_attr \"cpu\" \"fr400\")\n+;; 3 is for a write-after-write hazard.\n+(define_insn_reservation \"fr450_i4_movgf\" 3\n+  (and (eq_attr \"cpu\" \"fr450\")\n        (eq_attr \"type\" \"movgf\"))\n-  \"fr400_i0\")\n+  \"i0\")\n \n-(define_insn_reservation \"fr400_i5_jumpl\" 0\n-  (and (eq_attr \"cpu\" \"fr400\")\n+(define_insn_reservation \"fr400_i5\" 0\n+  (and (eq_attr \"cpu\" \"fr400,fr405,fr450\")\n        (eq_attr \"type\" \"jumpl\"))\n-  \"fr400_i0\")\n+  \"i0\")\n \n ;; The bypass between FPR loads and media instructions, described above.\n \n (define_bypass 3\n-  \"fr400_i2_fload\"\n+  \"fr400_i2\"\n   \"fr400_m1_1,fr400_m1_2,\\\n    fr400_m2_1,fr400_m2_2,\\\n    fr400_m3_1,fr400_m3_2,\\\n@@ -960,24 +850,9 @@\n ;; The branch instructions all use the B unit and produce no result.\n \n (define_insn_reservation \"fr400_b\" 0\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405,fr450\")\n        (eq_attr \"type\" \"jump,branch,ccr,call\"))\n-  \"fr400_b\")\n-\n-;; Control instructions use the C unit, which excludes all the others.\n-\n-(define_insn_reservation \"fr400_c\" 0\n-  (and (eq_attr \"cpu\" \"fr400\")\n-       (eq_attr \"type\" \"spr,trap\"))\n-  \"fr400_c\")\n-\n-;; Unknown instructions use the C unit, since it requires single-operation\n-;; packets.\n-\n-(define_insn_reservation \"fr400_unknown\" 1\n-  (and (eq_attr \"cpu\" \"fr400\")\n-       (eq_attr \"type\" \"unknown,multi\"))\n-  \"fr400_c\")\n+  \"b0\")\n \n ;; FP->FP moves are marked as \"fsconv\" instructions in the define_insns\n ;; below, but are implemented on the FR400 using \"mlogic\" instructions.\n@@ -987,15 +862,22 @@\n ;; M1 instructions store their results in FPRs.  Any instruction can read\n ;; the result in the following cycle, so no penalty occurs.\n \n+(define_automaton \"fr400_media\")\n+(define_cpu_unit \"fr400_m1a,fr400_m1b,fr400_m2a\" \"fr400_media\")\n+(exclusion_set \"fr400_m1a,fr400_m1b\" \"fr400_m2a\")\n+\n+(define_reservation \"fr400_m1\" \"(f1|f0) + (fr400_m1a|fr400_m1b)\")\n+(define_reservation \"fr400_m2\" \"f0 + fr400_m2a\")\n+\n (define_insn_reservation \"fr400_m1_1\" 1\n-  (and (eq_attr \"cpu\" \"fr400\")\n-       (eq_attr \"type\" \"fsconv,mlogic,maveh,msath,maddh,mabsh,mset\"))\n-  \"fr400_meither\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n+       (eq_attr \"type\" \"fsconv,mnop,mlogic,maveh,msath,maddh,mabsh,mset\"))\n+  \"fr400_m1\")\n \n (define_insn_reservation \"fr400_m1_2\" 1\n-  (and (eq_attr \"cpu\" \"fr400\")\n-       (eq_attr \"type\" \"mqaddh,mqsath\"))\n-  \"fr400_mboth\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n+       (eq_attr \"type\" \"mqaddh,mqsath,mqlimh,mqshift\"))\n+  \"fr400_m2\")\n \n ;; M2 instructions store their results in accumulators, which are read\n ;; by M2 or M4 media commands.  M2 instructions can read the results in\n@@ -1006,53 +888,435 @@\n   \"fr400_m2_1,fr400_m2_2\")\n \n (define_insn_reservation \"fr400_m2_1\" 2\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n        (eq_attr \"type\" \"mmulh,mmulxh,mmach,mmrdh,mcpx,maddacc\"))\n-  \"fr400_meither\")\n+  \"fr400_m1\")\n \n (define_insn_reservation \"fr400_m2_2\" 2\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n        (eq_attr \"type\" \"mqmulh,mqmulxh,mqmach,mqcpx,mdaddacc\"))\n-  \"fr400_mboth\")\n+  \"fr400_m2\")\n \n ;; For our purposes, there seems to be little real difference between\n ;; M1 and M3 instructions.  Keep them separate anyway in case the distinction\n ;; is needed later.\n \n (define_insn_reservation \"fr400_m3_1\" 1\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n        (eq_attr \"type\" \"mpackh,mrot,mshift,mexpdhw\"))\n-  \"fr400_meither\")\n+  \"fr400_m1\")\n \n (define_insn_reservation \"fr400_m3_2\" 1\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n        (eq_attr \"type\" \"munpackh,mdpackh,mbhconv,mexpdhd,mwcut,mdrot,mcpl\"))\n-  \"fr400_mboth\")\n+  \"fr400_m2\")\n \n ;; M4 instructions write to accumulators or FPRs.  MOVFG and STF\n ;; instructions can read an FPR result in the following cycle, but\n ;; M-unit instructions must wait a cycle more for either kind of result.\n \n-(define_bypass 1\n-  \"fr400_m4_1,fr400_m4_2\"\n-  \"fr400_i3_fstore,fr400_i4_movfg\")\n+(define_bypass 1 \"fr400_m4_1,fr400_m4_2\" \"fr400_i3,fr400_i4\")\n \n (define_insn_reservation \"fr400_m4_1\" 2\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n        (eq_attr \"type\" \"mrdacc,mcut,mclracc\"))\n-  \"fr400_meither\")\n+  \"fr400_m1\")\n \n (define_insn_reservation \"fr400_m4_2\" 2\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n        (eq_attr \"type\" \"mclracca,mdcut\"))\n-  \"fr400_mboth\")\n+  \"fr400_m2\")\n \n ;; M5 instructions always incur a 1-cycle penalty.\n \n (define_insn_reservation \"fr400_m5\" 2\n-  (and (eq_attr \"cpu\" \"fr400\")\n+  (and (eq_attr \"cpu\" \"fr400,fr405\")\n        (eq_attr \"type\" \"mwtacc\"))\n-  \"fr400_mboth\")\n+  \"fr400_m2\")\n+\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: FR450 media scheduler description\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; The FR451 media restrictions are similar to the FR400's, but not as\n+;; strict and not as regular.  There are 6 categories with the following\n+;; restrictions:\n+;;\n+;;\t\t          M1\n+;;\t      M-1  M-2  M-3  M-4  M-5  M-6\n+;;\tM-1:         x         x         x\n+;;\tM-2:    x    x    x    x    x    x\n+;;  M0\tM-3:         x         x         x\n+;;\tM-4:    x    x    x    x\n+;;\tM-5:         x         x         x\n+;;\tM-6:    x    x    x    x    x    x\n+;;\n+;; where \"x\" indicates a conflict.\n+;;\n+;; There is no difference between M-1 and M-3 as far as issue\n+;; restrictions are concerned, so they are combined as \"m13\".\n+\n+;; Units for odd-numbered categories.  There can be two of these\n+;; in a packet.\n+(define_cpu_unit \"fr450_m13a,fr450_m13b\" \"float_media\")\n+(define_cpu_unit \"fr450_m5a,fr450_m5b\" \"float_media\")\n+\n+;; Units for even-numbered categories.  There can only be one per packet.\n+(define_cpu_unit \"fr450_m2a,fr450_m4a,fr450_m6a\" \"float_media\")\n+\n+;; Enforce the restriction matrix above.\n+(exclusion_set \"fr450_m2a,fr450_m4a,fr450_m6a\" \"fr450_m13a,fr450_m13b\")\n+(exclusion_set \"fr450_m2a,fr450_m6a\" \"fr450_m5a,fr450_m5b\")\n+(exclusion_set \"fr450_m4a,fr450_m6a\" \"fr450_m2a\")\n+\n+(define_reservation \"fr450_m13\" \"(f1|f0) + (fr450_m13a|fr450_m13b)\")\n+(define_reservation \"fr450_m2\" \"f0 + fr450_m2a\")\n+(define_reservation \"fr450_m4\" \"f0 + fr450_m4a\")\n+(define_reservation \"fr450_m5\" \"(f1|f0) + (fr450_m5a|fr450_m5b)\")\n+(define_reservation \"fr450_m6\" \"(f0|f1) + fr450_m6a\")\n+\n+;; MD-1, MD-3 and MD-8 instructions, which are the same as far\n+;; as scheduling is concerned.  The inputs and outputs are FPRs.\n+;; Instructions that have 32-bit inputs and outputs belong to M-1 while\n+;; the rest belong to M-2.\n+;;\n+;; ??? Arithmetic shifts (MD-6) have an extra cycle latency, but we don't\n+;; make the distinction between them and logical shifts.\n+(define_insn_reservation \"fr450_md138_1\" 1\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"fsconv,mnop,mlogic,maveh,msath,maddh,mabsh,mset,\n+\t\t\tmrot,mshift,mexpdhw,mpackh\"))\n+  \"fr450_m13\")\n+\n+(define_insn_reservation \"fr450_md138_2\" 1\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mqaddh,mqsath,mqlimh,\n+\t\t\tmdrot,mwcut,mqshift,mexpdhd,\n+\t\t\tmunpackh,mdpackh,mbhconv,mcpl\"))\n+  \"fr450_m2\")\n+\n+;; MD-2 instructions.  These take FPR or ACC inputs and produce an ACC output.\n+;; Instructions that write to double ACCs belong to M-3 while those that write\n+;; to quad ACCs belong to M-4.\n+(define_insn_reservation \"fr450_md2_3\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mmulh,mmach,mcpx,mmulxh,mmrdh,maddacc\"))\n+  \"fr450_m13\")\n+\n+(define_insn_reservation \"fr450_md2_4\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mqmulh,mqmach,mqcpx,mqmulxh,mdaddacc\"))\n+  \"fr450_m4\")\n+\n+;; Another MD-2 instruction can use the result on the following cycle.\n+(define_bypass 1 \"fr450_md2_3,fr450_md2_4\" \"fr450_md2_3,fr450_md2_4\")\n+\n+;; MD-4 instructions that write to ACCs.\n+(define_insn_reservation \"fr450_md4_3\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mclracc\"))\n+  \"fr450_m13\")\n+\n+(define_insn_reservation \"fr450_md4_4\" 3\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mclracca\"))\n+  \"fr450_m4\")\n+\n+;; MD-4 instructions that write to FPRs.\n+(define_insn_reservation \"fr450_md4_1\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mcut\"))\n+  \"fr450_m13\")\n+\n+(define_insn_reservation \"fr450_md4_5\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mrdacc\"))\n+  \"fr450_m5\")\n+\n+(define_insn_reservation \"fr450_md4_6\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mdcut\"))\n+  \"fr450_m6\")\n+\n+;; Integer instructions can read the FPR result of an MD-4 instruction on\n+;; the following cycle.\n+(define_bypass 1 \"fr450_md4_1,fr450_md4_5,fr450_md4_6\"\n+\t\t \"fr400_i3,fr450_i4_movfg\")\n+\n+;; MD-5 instructions, which belong to M-3.  They take FPR inputs and\n+;; write to ACCs.\n+(define_insn_reservation \"fr450_md5_3\" 2\n+  (and (eq_attr \"cpu\" \"fr450\")\n+       (eq_attr \"type\" \"mwtacc\"))\n+  \"fr450_m13\")\n+\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: FR550 scheduler description\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Prevent loads and stores from being issued in the same packet.\n+;; These units must go into the generic \"integer\" reservation because\n+;; of the constraints on fr550_store0 and fr550_store1.\n+(define_cpu_unit \"fr550_load0,fr550_load1\" \"integer\")\n+(define_cpu_unit \"fr550_store0,fr550_store1\" \"integer\")\n+(exclusion_set \"fr550_load0,fr550_load1\" \"fr550_store0,fr550_store1\")\n+\n+;; A store can only issue to I1 if one has also been issued to I0.\n+(presence_set \"fr550_store1\" \"fr550_store0\")\n+\n+(define_bypass 0 \"fr550_sethi\" \"fr550_setlo\")\n+(define_insn_reservation \"fr550_sethi\" 1\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"sethi\"))\n+  \"i3|i2|i1|i0\")\n+\n+(define_insn_reservation \"fr550_setlo\" 1\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"setlo\"))\n+  \"i3|i2|i1|i0\")\n+\n+(define_insn_reservation \"fr550_int\" 1\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"int\"))\n+  \"i3|i2|i1|i0\")\n+\n+(define_insn_reservation \"fr550_mul\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"mul\"))\n+  \"i1|i0\")\n+\n+(define_insn_reservation \"fr550_div\" 19\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"div\"))\n+  \"(i1|i0),(idiv1*18 | idiv2*18)\")\n+\n+(define_insn_reservation \"fr550_load\" 3\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"gload,fload\"))\n+  \"(i1|i0)+(fr550_load0|fr550_load1)\")\n+\n+;; We can only issue a store to I1 if one was also issued to I0.\n+;; This means that, as far as frv_reorder_packet is concerned,\n+;; the instruction has the same priority as an I0-only instruction.\n+(define_insn_reservation \"fr550_store\" 1\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"gstore,fstore\"))\n+  \"(i0+fr550_store0)|(i1+fr550_store1)\")\n+\n+(define_insn_reservation \"fr550_transfer\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"movgf,movfg\"))\n+  \"i0\")\n+\n+(define_insn_reservation \"fr550_jumpl\" 0\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"jumpl\"))\n+  \"i0\")\n+\n+(define_cpu_unit \"fr550_ccr0,fr550_ccr1\" \"float_media\")\n+\n+(define_insn_reservation \"fr550_branch\" 0\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"jump,branch\"))\n+  \"b1|b0\")\n+\n+(define_insn_reservation \"fr550_ccr\" 0\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"ccr\"))\n+  \"(b1|b0) + (fr550_ccr1|fr550_ccr0)\")\n+\n+(define_insn_reservation \"fr550_call\" 0\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"call\"))\n+  \"b0\")\n+\n+(define_automaton \"fr550_float_media\")\n+(define_cpu_unit \"fr550_add0,fr550_add1\" \"fr550_float_media\")\n+\n+;; There are three possible combinations of floating-point/media instructions:\n+;;\n+;;    - one media and one float\n+;;    - up to four float, no media\n+;;    - up to four media, no float\n+(define_cpu_unit \"fr550_f0,fr550_f1,fr550_f2,fr550_f3\" \"fr550_float_media\")\n+(define_cpu_unit \"fr550_m0,fr550_m1,fr550_m2,fr550_m3\" \"fr550_float_media\")\n+(exclusion_set \"fr550_f1,fr550_f2,fr550_f3\" \"fr550_m1,fr550_m2,fr550_m3\")\n+\n+(define_reservation \"fr550_float\" \"fr550_f0|fr550_f1|fr550_f2|fr550_f3\")\n+(define_reservation \"fr550_media\" \"fr550_m0|fr550_m1|fr550_m2|fr550_m3\")\n+\n+(define_insn_reservation \"fr550_f1\" 0\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"fnop\"))\n+  \"(f3|f2|f1|f0) + fr550_float\")\n+\n+(define_insn_reservation \"fr550_f2\" 3\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"fsconv,fsadd,fscmp\"))\n+  \"(f3|f2|f1|f0) + (fr550_add0|fr550_add1) + fr550_float\")\n+\n+(define_insn_reservation \"fr550_f3_mul\" 3\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"fsmul\"))\n+  \"(f1|f0) + fr550_float\")\n+\n+(define_insn_reservation \"fr550_f3_div\" 10\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"fsdiv\"))\n+  \"(f1|f0) + fr550_float\")\n+\n+(define_insn_reservation \"fr550_f3_sqrt\" 15\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"sqrt_single\"))\n+  \"(f1|f0) + fr550_float\")\n+\n+;; Synthetic units for enforcing media issue restructions.  Certain types\n+;; of insn in M2 conflict with certain types in M0:\n+;;\n+;;\t\t\t     M2\n+;;               MNOP   MALU   MSFT   MMAC   MSET\n+;;         MNOP     -      -      x      -      -\n+;;         MALU     -      x      x      -      -\n+;;   M0    MSFT     -      -      x      -      x\n+;;         MMAC     -      -      x      x      -\n+;;         MSET     -      -      x      -      -\n+;;\n+;; where \"x\" indicates a conflict.  The same restrictions apply to\n+;; M3 and M1.\n+;;\n+;; In addition -- and this is the awkward bit! -- instructions that\n+;; access ACC0-3 can only issue to M0 or M2.  Those that access ACC4-7\n+;; can only issue to M1 or M3.  We refer to such instructions as \"even\"\n+;; and \"odd\" respectively.\n+(define_cpu_unit \"fr550_malu0,fr550_malu1\" \"float_media\")\n+(define_cpu_unit \"fr550_malu2,fr550_malu3\" \"float_media\")\n+(define_cpu_unit \"fr550_msft0,fr550_msft1\" \"float_media\")\n+(define_cpu_unit \"fr550_mmac0,fr550_mmac1\" \"float_media\")\n+(define_cpu_unit \"fr550_mmac2,fr550_mmac3\" \"float_media\")\n+(define_cpu_unit \"fr550_mset0,fr550_mset1\" \"float_media\")\n+(define_cpu_unit \"fr550_mset2,fr550_mset3\" \"float_media\")\n+\n+(exclusion_set \"fr550_malu0\" \"fr550_malu2\")\n+(exclusion_set \"fr550_malu1\" \"fr550_malu3\")\n+\n+(exclusion_set \"fr550_msft0\" \"fr550_mset2\")\n+(exclusion_set \"fr550_msft1\" \"fr550_mset3\")\n+\n+(exclusion_set \"fr550_mmac0\" \"fr550_mmac2\")\n+(exclusion_set \"fr550_mmac1\" \"fr550_mmac3\")\n+\n+;; If an MSFT or MMAC instruction issues to a unit other than M0, we may\n+;; need to insert some nops.  In the worst case, the packet will end up\n+;; having 4 integer instructions and 4 media instructions, leaving no\n+;; room for any branch instructions that the DFA might have accepted.\n+;;\n+;; This doesn't matter for JUMP_INSNs and CALL_INSNs because they are\n+;; always the last instructions to be passed to the DFA, and could be\n+;; pushed out to a separate packet once the nops have been added.\n+;; However, it does cause problems for ccr instructions since they\n+;; can occur anywhere in the unordered packet.\n+(exclusion_set \"fr550_msft1,fr550_mmac1,fr550_mmac2,fr550_mmac3\"\n+\t       \"fr550_ccr0,fr550_ccr1\")\n+\n+(define_reservation \"fr550_malu\"\n+  \"(f3 + fr550_malu3) | (f2 + fr550_malu2)\n+   | (f1 + fr550_malu1) | (f0 + fr550_malu0)\")\n+\n+(define_reservation \"fr550_msft_even\"\n+  \"f0 + fr550_msft0\")\n+\n+(define_reservation \"fr550_msft_odd\"\n+  \"f1 + fr550_msft1\")\n+\n+(define_reservation \"fr550_msft_either\"\n+  \"(f1 + fr550_msft1) | (f0 + fr550_msft0)\")\n+\n+(define_reservation \"fr550_mmac_even\"\n+  \"(f2 + fr550_mmac2) | (f0 + fr550_mmac0)\")\n+\n+(define_reservation \"fr550_mmac_odd\"\n+  \"(f3 + fr550_mmac3) | (f1 + fr550_mmac1)\")\n+\n+(define_reservation \"fr550_mset\"\n+  \"(f3 + fr550_mset3) | (f2 + fr550_mset2)\n+    | (f1 + fr550_mset1) | (f0 + fr550_mset0)\")\n+\n+(define_insn_reservation \"fr550_mnop\" 0\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"mnop\"))\n+  \"fr550_media + (f3|f2|f1|f0)\")\n+\n+(define_insn_reservation \"fr550_malu\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"mlogic,maveh,msath,mabsh,maddh,mqaddh,mqsath\"))\n+  \"fr550_media + fr550_malu\")\n+\n+;; These insns only operate on FPRs and so don't need to be classified\n+;; as even/odd.\n+(define_insn_reservation \"fr550_msft_1_either\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"mrot,mwcut,mshift,mexpdhw,mexpdhd,mpackh,\n+\t\t\tmunpackh,mdpackh,mbhconv,mdrot,mcpl\"))\n+  \"fr550_media + fr550_msft_either\")\n+\n+;; These insns read from ACC0-3.\n+(define_insn_reservation \"fr550_msft_1_even\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (and (eq_attr \"type\" \"mcut,mrdacc,mdcut\")\n+\t    (eq_attr \"acc_group\" \"even\")))\n+  \"fr550_media + fr550_msft_even\")\n+\n+;; These insns read from ACC4-7.\n+(define_insn_reservation \"fr550_msft_1_odd\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (and (eq_attr \"type\" \"mcut,mrdacc,mdcut\")\n+\t    (eq_attr \"acc_group\" \"odd\")))\n+  \"fr550_media + fr550_msft_odd\")\n+\n+;; MCLRACC with A=1 can issue to either M0 or M1.\n+(define_insn_reservation \"fr550_msft_2_either\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"mclracca\"))\n+  \"fr550_media + fr550_msft_either\")\n+\n+;; These insns write to ACC0-3.\n+(define_insn_reservation \"fr550_msft_2_even\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (and (eq_attr \"type\" \"mclracc,mwtacc\")\n+\t    (eq_attr \"acc_group\" \"even\")))\n+  \"fr550_media + fr550_msft_even\")\n+\n+;; These insns write to ACC4-7.\n+(define_insn_reservation \"fr550_msft_2_odd\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (and (eq_attr \"type\" \"mclracc,mwtacc\")\n+\t    (eq_attr \"acc_group\" \"odd\")))\n+  \"fr550_media + fr550_msft_odd\")\n+\n+;; These insns read from and write to ACC0-3.\n+(define_insn_reservation \"fr550_mmac_even\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (and (eq_attr \"type\" \"mmulh,mmulxh,mmach,mmrdh,mqmulh,mqmulxh,mqmach,\n+\t\t\t     maddacc,mdaddacc,mcpx,mqcpx\")\n+\t    (eq_attr \"acc_group\" \"even\")))\n+  \"fr550_media + fr550_mmac_even\")\n+\n+;; These insns read from and write to ACC4-7.\n+(define_insn_reservation \"fr550_mmac_odd\" 2\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (and (eq_attr \"type\" \"mmulh,mmulxh,mmach,mmrdh,mqmulh,mqmulxh,mqmach,\n+\t\t\t     maddacc,mdaddacc,mcpx,mqcpx\")\n+\t    (eq_attr \"acc_group\" \"odd\")))\n+  \"fr550_media + fr550_mmac_odd\")\n+\n+(define_insn_reservation \"fr550_mset\" 1\n+  (and (eq_attr \"cpu\" \"fr550\")\n+       (eq_attr \"type\" \"mset\"))\n+  \"fr550_media + fr550_mset\")\n \n ;; ::::::::::::::::::::\n ;; ::\n@@ -1066,12 +1330,12 @@\n (define_insn_reservation \"fr300_lat1\" 1\n   (and (eq_attr \"cpu\" \"fr300,simple\")\n        (eq_attr \"type\" \"!gload,fload,movfg,movgf\"))\n-  \"c\")\n+  \"c + control\")\n \n (define_insn_reservation \"fr300_lat2\" 2\n   (and (eq_attr \"cpu\" \"fr300,simple\")\n        (eq_attr \"type\" \"gload,fload,movfg,movgf\"))\n-  \"c\")\n+  \"c + control\")\n \n \f\n ;; ::::::::::::::::::::\n@@ -2961,7 +3225,7 @@\n   \"TARGET_HARD_FLOAT && TARGET_MULADD\"\n   \"fmadds %1,%2,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"fmas\")])\n+   (set_attr \"type\" \"fsmadd\")])\n \n (define_insn \"*mulsubsf4\"\n   [(set (match_operand:SF 0 \"fpr_operand\" \"=f\")\n@@ -2971,7 +3235,7 @@\n   \"TARGET_HARD_FLOAT && TARGET_MULADD\"\n   \"fmsubs %1,%2,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"fmas\")])\n+   (set_attr \"type\" \"fsmadd\")])\n \n ;; Division\n (define_insn \"divsf3\"\n@@ -3056,7 +3320,7 @@\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE && TARGET_MULADD\"\n   \"fmaddd %1,%2,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"fmas\")])\n+   (set_attr \"type\" \"fdmadd\")])\n \n (define_insn \"*mulsubdf4\"\n   [(set (match_operand:DF 0 \"fpr_operand\" \"=f\")\n@@ -3066,7 +3330,7 @@\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE && TARGET_MULADD\"\n   \"fmsubd %1,%2,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"fmas\")])\n+   (set_attr \"type\" \"fdmadd\")])\n \n ;; Division\n (define_insn \"divdf3\"\n@@ -3515,7 +3779,7 @@\n   \"TARGET_HARD_FLOAT\"\n   \"fcmps %1,%2,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"fsadd\")])\n+   (set_attr \"type\" \"fscmp\")])\n \n (define_insn \"*cmpdf_cc_fp\"\n   [(set (match_operand:CC_FP 0 \"fcc_operand\" \"=u\")\n@@ -3524,7 +3788,7 @@\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE\"\n   \"fcmpd %1,%2,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"fdadd\")])\n+   (set_attr \"type\" \"fdcmp\")])\n \n \f\n ;; ::::::::::::::::::::\n@@ -5850,6 +6114,20 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"int\")])\n \n+(define_insn \"fnop\"\n+  [(const_int 1)]\n+  \"\"\n+  \"fnop\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"fnop\")])\n+\n+(define_insn \"mnop\"\n+  [(const_int 2)]\n+  \"\"\n+  \"mnop\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"mnop\")])\n+\n ;; Pseudo instruction that prevents the scheduler from moving code above this\n ;; point.  Note, type unknown is used to make sure the VLIW instructions are\n ;; not continued past this point.\n@@ -5926,6 +6204,10 @@\n    (UNSPEC_MHSETHIH\t\t151)\n    (UNSPEC_MHDSETS\t\t152)\n    (UNSPEC_MHDSETH\t\t153)\n+   (UNSPEC_MQLCLRHS\t\t154)\n+   (UNSPEC_MQLMTHS\t\t155)\n+   (UNSPEC_MQSLLHI\t\t156)\n+   (UNSPEC_MQSRAHI\t\t157)\n ])\n \n ;; Logic operations: type \"mlogic\"\n@@ -6432,7 +6714,7 @@\n ;; Expand halfword to word: type \"mexpdhw\"\n \n (define_insn \"mexpdhw\"\n-  [(set (match_operand:SI 0 \"even_fpr_operand\" \"=h\")\n+  [(set (match_operand:SI 0 \"fpr_operand\" \"=f\")\n         (unspec:SI [(match_operand:SI 1 \"fpr_operand\" \"f\")\n                     (match_operand:SI 2 \"uint1_operand\" \"I\")]\n \t\t   UNSPEC_MEXPDHW))]\n@@ -6446,7 +6728,7 @@\n     (match_operator 0 \"ccr_eqne_operator\"\n \t\t    [(match_operand 1 \"cr_operand\" \"C\")\n \t\t     (const_int 0)])\n-    (set (match_operand:SI 2 \"even_fpr_operand\" \"=h\")\n+    (set (match_operand:SI 2 \"fpr_operand\" \"=f\")\n \t (unspec:SI [(match_operand:SI 3 \"fpr_operand\" \"f\")\n \t\t     (match_operand:SI 4 \"uint1_operand\" \"I\")]\n \t\t    UNSPEC_MEXPDHW)))]\n@@ -7272,9 +7554,9 @@\n   \"\n {\n   operands[0] = gen_rtx_REG (V4SImode, ACC_FIRST);\n-  operands[1] = gen_rtx_REG (V4SImode, ACC_FIRST + 4);\n+  operands[1] = gen_rtx_REG (V4SImode, ACC_FIRST + (~3 & ACC_MASK));\n   operands[2] = gen_rtx_REG (V4QImode, ACCG_FIRST);\n-  operands[3] = gen_rtx_REG (V4QImode, ACCG_FIRST + 4);\n+  operands[3] = gen_rtx_REG (V4QImode, ACCG_FIRST + (~3 & ACC_MASK));\n }\")\n \n (define_expand \"mclracca4\"\n@@ -7644,6 +7926,48 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"mqsath\")])\n \n+;; Quad limit instructions: type \"mqlimh\"\n+\n+(define_insn \"mqlclrhs\"\n+  [(set (match_operand:DI 0 \"even_fpr_operand\" \"=h\")\n+        (unspec:DI [(match_operand:DI 1 \"even_fpr_operand\" \"h\")\n+\t\t    (match_operand:DI 2 \"even_fpr_operand\" \"h\")]\n+\t\t   UNSPEC_MQLCLRHS))]\n+  \"TARGET_MEDIA_FR450\"\n+  \"mqlclrhs %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"mqlimh\")])\n+\n+(define_insn \"mqlmths\"\n+  [(set (match_operand:DI 0 \"even_fpr_operand\" \"=h\")\n+        (unspec:DI [(match_operand:DI 1 \"even_fpr_operand\" \"h\")\n+\t\t    (match_operand:DI 2 \"even_fpr_operand\" \"h\")]\n+\t\t   UNSPEC_MQLMTHS))]\n+  \"TARGET_MEDIA_FR450\"\n+  \"mqlmths %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"mqlimh\")])\n+\n+(define_insn \"mqsllhi\"\n+  [(set (match_operand:DI 0 \"even_fpr_operand\" \"=h\")\n+        (unspec:DI [(match_operand:DI 1 \"even_fpr_operand\" \"h\")\n+\t\t    (match_operand:SI 2 \"int6_operand\" \"I\")]\n+\t\t   UNSPEC_MQSLLHI))]\n+  \"TARGET_MEDIA_FR450\"\n+  \"mqsllhi %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"mqshift\")])\n+\n+(define_insn \"mqsrahi\"\n+  [(set (match_operand:DI 0 \"even_fpr_operand\" \"=h\")\n+        (unspec:DI [(match_operand:DI 1 \"even_fpr_operand\" \"h\")\n+\t\t    (match_operand:SI 2 \"int6_operand\" \"I\")]\n+\t\t   UNSPEC_MQSRAHI))]\n+  \"TARGET_MEDIA_FR450\"\n+  \"mqsrahi %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"mqshift\")])\n+\n ;; Set hi/lo instructions: type \"mset\"\n \n (define_insn \"mhsetlos\"\n@@ -7875,3 +8199,147 @@\n \n   DONE;\n }\")\n+\f\n+(define_constants\n+  [\n+   (UNSPEC_SMUL\t\t\t154)\n+   (UNSPEC_UMUL\t\t\t155)\n+   (UNSPEC_SMU\t\t\t156)\n+   (UNSPEC_ADDSS\t\t157)\n+   (UNSPEC_SUBSS\t\t158)\n+   (UNSPEC_SLASS\t\t159)\n+   (UNSPEC_SCAN\t\t\t160)\n+   (UNSPEC_INTSS                161)\n+   (UNSPEC_SCUTSS\t\t162)\n+   (UNSPEC_PREFETCH0\t\t163)\n+   (UNSPEC_PREFETCH\t\t164)\n+   (UNSPEC_IACCreadll\t\t165)\n+   (UNSPEC_IACCreadl\t\t166)\n+   (UNSPEC_IACCsetll\t\t167)\n+   (UNSPEC_IACCsetl\t\t168)\n+   (UNSPEC_SMASS\t\t169)\n+   (UNSPEC_SMSSS\t\t170)\n+   (UNSPEC_IMUL\t\t\t171)\n+\n+   (IACC0_REG\t\t\t171)\n+])\n+\n+(define_insn \"smul\"\n+  [(set (match_operand:DI 0 \"integer_register_operand\" \"=d\")\n+        (unspec:DI [(match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"integer_register_operand\" \"d\")]\n+\t\t   UNSPEC_SMUL))]\n+  \"\"\n+  \"smul %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"mul\")])\n+\n+(define_insn \"umul\"\n+  [(set (match_operand:DI 0 \"integer_register_operand\" \"=d\")\n+        (unspec:DI [(match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"integer_register_operand\" \"d\")]\n+\t\t   UNSPEC_UMUL))]\n+  \"\"\n+  \"umul %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"mul\")])\n+\n+(define_insn \"smass\"\n+  [(set (reg:DI IACC0_REG)\n+\t(unspec:DI [(match_operand:SI 0 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (reg:DI IACC0_REG)]\n+\t\t   UNSPEC_SMASS))]\n+  \"TARGET_FR405_BUILTINS\"\n+  \"smass %1, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"macc\")])\n+\n+(define_insn \"smsss\"\n+  [(set (reg:DI IACC0_REG)\n+\t(unspec:DI [(match_operand:SI 0 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (reg:DI IACC0_REG)]\n+\t\t   UNSPEC_SMSSS))]\n+  \"TARGET_FR405_BUILTINS\"\n+  \"smsss %1, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"macc\")])\n+\n+(define_insn \"smu\"\n+  [(set (reg:DI IACC0_REG)\n+\t(unspec:DI [(match_operand:SI 0 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 1 \"integer_register_operand\" \"d\")]\n+\t\t   UNSPEC_SMU))]\n+  \"TARGET_FR405_BUILTINS\"\n+  \"smu %1, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"macc\")])\n+\n+(define_insn \"addss\"\n+  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n+        (unspec:SI [(match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"integer_register_operand\" \"d\")]\n+\t\t   UNSPEC_ADDSS))]\n+  \"TARGET_FR405_BUILTINS\"\n+  \"addss %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"int\")])\n+\n+(define_insn \"subss\"\n+  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n+        (unspec:SI [(match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"integer_register_operand\" \"d\")]\n+\t\t   UNSPEC_SUBSS))]\n+  \"TARGET_FR405_BUILTINS\"\n+  \"subss %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"int\")])\n+\n+(define_insn \"slass\"\n+  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n+        (unspec:SI [(match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"integer_register_operand\" \"d\")]\n+\t\t   UNSPEC_SLASS))]\n+  \"TARGET_FR405_BUILTINS\"\n+  \"slass %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"int\")])\n+\n+(define_insn \"scan\"\n+  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n+        (unspec:SI [(match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"integer_register_operand\" \"d\")]\n+\t\t   UNSPEC_SCAN))]\n+  \"\"\n+  \"scan %1, %2, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"scan\")])\n+\n+(define_insn \"scutss\"\n+  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:SI 1 \"integer_register_operand\" \"d\")\n+\t\t    (reg:DI IACC0_REG)]\n+\t\t   UNSPEC_SCUTSS))]\n+  \"TARGET_FR405_BUILTINS\"\n+  \"scutss %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"cut\")])\n+\n+(define_insn \"frv_prefetch0\"\n+  [(prefetch (unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t\tUNSPEC_PREFETCH0)\n+\t     (const_int 0)\n+\t     (const_int 0))]\n+  \"\"\n+  \"dcpl %0, gr0, #0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"frv_prefetch\"\n+  [(prefetch (unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t\tUNSPEC_PREFETCH)\n+\t     (const_int 0)\n+\t     (const_int 0))]\n+  \"TARGET_FR500_FR550_BUILTINS\"\n+  \"nop.p\\\\n\\\\tnldub @(%0, gr0), gr0\"\n+  [(set_attr \"length\" \"8\")])"}, {"sha": "c9593977043f9da84cdcfb08348f2888711234e2", "filename": "gcc/config/frv/t-frv", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ft-frv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fconfig%2Ffrv%2Ft-frv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ft-frv?ref=c557edf447d02a1bace4e84cb4515e1de06be4d9", "patch": "@@ -82,9 +82,11 @@ $(T)frvend$(objext): $(srcdir)/config/frv/frvend.c $(GCC_PASSES) \\\n #MULTILIB_EXCEPTIONS\t= *mcpu=simple/*msoft-float* *mcpu=frv/*msoft-float*\n #MULTILIB_EXTRA_OPTS\t= mlibrary-pic\n \n-MULTILIB_OPTIONS\t= mcpu=frv/mcpu=fr400/mcpu=simple mno-pack mlibrary-pic/mfdpic\n-MULTILIB_DIRNAMES\t= frv fr400 simple unpacked pic fdpic\n-MULTILIB_MATCHES\t= mcpu?simple=mcpu?fr300 mlibrary-pic=multilib-library-pic\n+MULTILIB_OPTIONS\t= mcpu=fr400/mcpu=fr550 mno-pack mlibrary-pic/mfdpic\n+MULTILIB_DIRNAMES\t= fr400 fr550 unpacked pic fdpic\n+MULTILIB_MATCHES\t= mcpu?simple=mcpu?fr300 \\\n+\t\t\t  mlibrary-pic=multilib-library-pic \\\n+\t\t\t  mcpu?fr400=mcpu?fr405 mcpu?fr400=mcpu?fr450\n MULTILIB_EXCEPTIONS\t= mcpu=frv/mno-pack* mcpu=simple/mno-pack*\n \n LIBGCC = stmp-multilib"}, {"sha": "bee642c8323826269e41be034bfdf760a09e5f9f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c557edf447d02a1bace4e84cb4515e1de06be4d9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c557edf447d02a1bace4e84cb4515e1de06be4d9", "patch": "@@ -451,8 +451,9 @@ Objective-C and Objective-C++ Dialects}.\n -malloc-cc  -mfixed-cc  -mdword  -mno-dword @gol\n -mdouble  -mno-double @gol\n -mmedia  -mno-media  -mmuladd  -mno-muladd @gol\n--mfdpic -minline-plt -mgprel-ro -multilib-library-pic -mlinked-fp @gol\n--mlibrary-pic  -macc-4 -macc-8 @gol\n+-mfdpic  -minline-plt -mgprel-ro  -multilib-library-pic @gol\n+-mlinked-fp  -mlong-calls  -malign-labels @gol\n+-mlibrary-pic  -macc-4  -macc-8 @gol\n -mpack  -mno-pack  -mno-eflags  -mcond-move  -mno-cond-move @gol\n -mscc  -mno-scc  -mcond-exec  -mno-cond-exec @gol\n -mvliw-branch  -mno-vliw-branch @gol\n@@ -7821,6 +7822,21 @@ Follow the EABI requirement of always creating a frame pointer whenever\n a stack frame is allocated.  This option is enabled by default and can\n be disabled with @option{-mno-linked-fp}.\n \n+@item -mlong-calls\n+@opindex mlong-calls\n+\n+Use indirect addressing to call functions outside the current\n+compilation unit.  This allows the functions to be placed anywhere\n+within the 32-bit address space.\n+\n+@item -malign-labels\n+@opindex malign-labels\n+\n+Try to align labels to an 8-byte boundary by inserting nops into the\n+previous packet.  This option only has an effect when VLIW packing\n+is enabled.  It doesn't create new packets; it merely adds nops to\n+existing ones.\n+\n @item -mlibrary-pic\n @opindex mlibrary-pic\n \n@@ -7957,8 +7973,8 @@ Cause gas to print out tomcat statistics.\n @opindex mcpu\n \n Select the processor type for which to generate code.  Possible values are\n-@samp{simple}, @samp{tomcat}, @samp{fr500}, @samp{fr400}, @samp{fr300},\n-@samp{frv}.\n+@samp{frv}, @samp{fr550}, @samp{tomcat}, @samp{fr500}, @samp{fr450},\n+@samp{fr405}, @samp{fr400}, @samp{fr300} and @samp{simple}.\n \n @end table\n "}]}