{"sha": "a6a69fc2ad1062fab2801e42aca04af23470365b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhNjlmYzJhZDEwNjJmYWIyODAxZTQyYWNhMDRhZjIzNDcwMzY1Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-23T21:50:59Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-23T21:50:59Z"}, "message": "cpphash.c (collect_objlike_expansion): Add sanity check.\n\n\t* cpphash.c (collect_objlike_expansion): Add sanity check.\n\t(special_symbol): Remove case T_CONST, T_XCONST, T_MCONST.  If\n\tthe buffer is the empty string, return.  Mark __DATE__ and\n\t__TIME__ as XCONST nodes, not MCONST.\n\t(_cpp_macroexpand): Avoid pushing an empty buffer.\n\t(funlike_macroexpand): Don't pop token_buffer here.\n\nFrom-SVN: r33360", "tree": {"sha": "364540efe12aff30a3743eae6f22789045b08e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/364540efe12aff30a3743eae6f22789045b08e5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a69fc2ad1062fab2801e42aca04af23470365b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a69fc2ad1062fab2801e42aca04af23470365b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a69fc2ad1062fab2801e42aca04af23470365b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a69fc2ad1062fab2801e42aca04af23470365b/comments", "author": null, "committer": null, "parents": [{"sha": "a204fec0cbb0097002847875e64c0850defcfe5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a204fec0cbb0097002847875e64c0850defcfe5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a204fec0cbb0097002847875e64c0850defcfe5e"}], "stats": {"total": 74, "additions": 51, "deletions": 23}, "files": [{"sha": "3b03137e573379dd7ad04f0dd123555056e15c4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a69fc2ad1062fab2801e42aca04af23470365b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a69fc2ad1062fab2801e42aca04af23470365b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6a69fc2ad1062fab2801e42aca04af23470365b", "patch": "@@ -1,3 +1,12 @@\n+2000-04-23  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.c (collect_objlike_expansion): Add sanity check.\n+\t(special_symbol): Remove case T_CONST, T_XCONST, T_MCONST.  If\n+\tthe buffer is the empty string, return.  Mark __DATE__ and\n+\t__TIME__ as XCONST nodes, not MCONST.\n+\t(_cpp_macroexpand): Avoid pushing an empty buffer.\n+\t(funlike_macroexpand): Don't pop token_buffer here.\n+\n Sun Apr 23 18:37:53 2000  Alexandre Oliva  <aoliva@cygnus.com>\n \n \t* config/mn10300/mn10300.h (REGNO_IN_RANGE_P): New macro."}, {"sha": "5817e9644262915fd53d3a1e62e837112fddc28d", "filename": "gcc/cpphash.c", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a69fc2ad1062fab2801e42aca04af23470365b/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a69fc2ad1062fab2801e42aca04af23470365b/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=a6a69fc2ad1062fab2801e42aca04af23470365b", "patch": "@@ -476,6 +476,9 @@ collect_objlike_expansion (pfile, list)\n   len = CPP_WRITTEN (pfile) - start;\n   CPP_SET_WRITTEN (pfile, start);\n \n+  if (len <= 4)\n+    cpp_ice (pfile, \"empty object-like macro went through full #define\");\n+\n   exp = (U_CHAR *) xmalloc (len + 1);\n   memcpy (exp, pfile->token_buffer + start, len);\n   exp[len] = '\\0';\n@@ -1101,16 +1104,10 @@ special_symbol (pfile, hp)\n \t  return;\n \t}\n #endif\n-      /* else fall through */\n-    case T_CONST:\n-    case T_MCONST:\n-    case T_XCONST:\n     constant:\n       buf = hp->value.cpval;\n-      if (!buf)\n+      if (!buf || *buf == '\\0')\n \treturn;\n-      if (*buf == '\\0')\n-\tbuf = \"\\r \\r \";\n \n       CPP_PUTS (pfile, buf, strlen (buf));\n       return;\n@@ -1130,7 +1127,7 @@ special_symbol (pfile, hp)\n     case T_DATE:\n     case T_TIME:\n       /* Generate both __DATE__ and __TIME__, stuff them into their\n-\t respective hash nodes, and mark the nodes T_MCONST so we\n+\t respective hash nodes, and mark the nodes T_XCONST so we\n \t don't have to do this again.  We don't generate these strings\n \t at init time because time() and localtime() are very slow on\n \t some systems.  */\n@@ -1147,12 +1144,12 @@ special_symbol (pfile, hp)\n \td->value.cpval = xmalloc (sizeof \"'Oct 11 1347'\");\n \tsprintf ((char *)d->value.cpval, \"\\\"%s %2d %4d\\\"\",\n \t\t monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n-\td->type = T_MCONST;\n+\td->type = T_XCONST;\n \n \tt->value.cpval = xmalloc (sizeof \"'12:34:56'\");\n \tsprintf ((char *)t->value.cpval, \"\\\"%02d:%02d:%02d\\\"\",\n \t\t tb->tm_hour, tb->tm_min, tb->tm_sec);\n-\tt->type = T_MCONST;\n+\tt->type = T_XCONST;\n \tgoto constant;\n       }\n \n@@ -1198,9 +1195,8 @@ _cpp_macroexpand (pfile, hp)\n   if (hp->type == T_MCONST || hp->type == T_CONST || hp->type == T_XCONST)\n     {\n       const U_CHAR *cpval = hp->value.cpval;\n-      if (!cpval || *cpval == '\\0')\n-\tcpval = (const U_CHAR *) \"\\r \\r \";\n-      push_macro_expansion (pfile, cpval, strlen (cpval), hp);\n+      if (cpval && *cpval != '\\0')\n+\tpush_macro_expansion (pfile, cpval, strlen (cpval), hp);\n       return;\n     }\n \n@@ -1213,6 +1209,9 @@ _cpp_macroexpand (pfile, hp)\n       special_symbol (pfile, hp);\n       len = CPP_WRITTEN (pfile) - old_written;\n       CPP_SET_WRITTEN (pfile, old_written);\n+      if (len == 0)\n+\treturn;\n+\n       xbuf = (U_CHAR *) xmalloc (len + 1);\n       memcpy (xbuf, CPP_PWRITTEN (pfile), len);\n       xbuf[len] = '\\0';\n@@ -1239,13 +1238,14 @@ _cpp_macroexpand (pfile, hp)\n      Read directly from the macro definition.  */\n   if (defn->nargs == 0 || defn->pattern == 0)\n     {\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      pfile->output_escapes--;\n-      push_macro_expansion (pfile, defn->expansion, defn->length, hp);\n-      return;\n+      /* If the defn is the empty string, don't bother pushing it.  */\n+      if (defn->length > 4)\n+\tpush_macro_expansion (pfile, defn->expansion, defn->length, hp);\n     }\n+  else\n+    funlike_macroexpand (pfile, hp, args);\n \n-  funlike_macroexpand (pfile, hp, args);\n+  CPP_SET_WRITTEN (pfile, old_written);\n   pfile->output_escapes--;\n }\n \n@@ -1433,7 +1433,6 @@ funlike_macroexpand (pfile, hp, args)\n   DEFINITION *defn = hp->value.defn;\n   register U_CHAR *xbuf;\n   int xbuf_len;\n-  long old_written = CPP_WRITTEN (pfile);\n   U_CHAR *exp = defn->expansion;\n   int offset;\t/* offset in expansion, copied a piece at a time */\n   int totlen;\t/* total amount of exp buffer filled so far */\n@@ -1601,9 +1600,6 @@ funlike_macroexpand (pfile, hp, args)\n   /* Now put the expansion on the input stack\n      so our caller will commence reading from it.  */\n   push_macro_expansion (pfile, xbuf, totlen, hp);\n-\n-  /* Pop the space we've used in the token_buffer for argument expansion.  */\n-  CPP_SET_WRITTEN (pfile, old_written);\n }\n \n /* Return 1 iff a token ending in C1 followed directly by a token C2\n@@ -1703,7 +1699,7 @@ push_macro_expansion (pfile, xbuf, len, hp)\n       && !unsafe_chars (pfile, xbuf[len-3], CPP_BUF_PEEK (CPP_BUFFER (pfile))))\n     len -= 2;\n \n-  /* If the total expansion is \"\\r \\r\", we must not trim both escapes.  */\n+  /* If the total expansion is \"\\r \\r \", we must not trim both escapes.  */\n   if (len == 2 && advance_cur)\n     advance_cur = 0;\n "}, {"sha": "3ecfb6e9b6df47c3f1e21af53a2568b1b774a35a", "filename": "gcc/testsuite/gcc.dg/undef-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a69fc2ad1062fab2801e42aca04af23470365b/gcc%2Ftestsuite%2Fgcc.dg%2Fundef-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a69fc2ad1062fab2801e42aca04af23470365b/gcc%2Ftestsuite%2Fgcc.dg%2Fundef-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fundef-2.c?ref=a6a69fc2ad1062fab2801e42aca04af23470365b", "patch": "@@ -0,0 +1,23 @@\n+/* C99 6.10.8 para 4: None of [the predefined macro names] shall be the\n+   subject of a #define or an #undef preprocessing directive.  */\n+\n+/* { dg-do preprocess } */\n+\n+#undef __DATE__\t\t/* { dg-warning \"undefining\" \"__DATE__\" } */\n+#undef __TIME__\t\t/* { dg-warning \"undefining\" \"__TIME__\" } */\n+#undef __FILE__\t\t/* { dg-warning \"undefining\" \"__FILE__\" } */\n+#undef __LINE__\t\t/* { dg-warning \"undefining\" \"__LINE__\" } */\n+#undef __STDC__\t\t/* { dg-warning \"undefining\" \"__STDC__\" } */\n+\n+/* These should be protected from #undef, but aren't, because they\n+   are set with normal #define commands - and on top of that, some\n+   of them are library properties, outside our control.  To consider:\n+   warn about undefining/redefining any identifier beginning with\n+   __STDC_ .\n+\n+   __STDC_HOSTED__\n+   __STDC_VERSION__\n+   __STDC_IEC_559__\n+   __STDC_IEC_559_COMPLEX__\n+   __STDC_ISO_10646__\n+ */"}]}