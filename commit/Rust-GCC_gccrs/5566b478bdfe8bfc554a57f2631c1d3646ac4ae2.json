{"sha": "5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU2NmI0NzhiZGZlOGJmYzU1NGE1N2YyNjMxYzFkMzY0NmFjNGFlMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-28T22:01:56Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-28T22:01:56Z"}, "message": "83rd Cygnus<->FSF merge\n\nFrom-SVN: r11362", "tree": {"sha": "7e6683aeddf5dd90371df24d386ca3fd7048ee5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e6683aeddf5dd90371df24d386ca3fd7048ee5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/comments", "author": null, "committer": null, "parents": [{"sha": "8bd04c565300c201dca9307a5a9173ed31d02494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bd04c565300c201dca9307a5a9173ed31d02494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bd04c565300c201dca9307a5a9173ed31d02494"}], "stats": {"total": 8420, "additions": 5045, "deletions": 3375}, "files": [{"sha": "49b3e9a83f60538d2fc9e3939273f2a500b46623", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -1,3 +1,433 @@\n+Wed Feb 28 09:28:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (do_identifier): Check for DECL_INITIAL before using it.\n+\n+Tue Feb 27 16:35:32 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck2.c (build_x_arrow): Call complete_type.\n+\n+\t* pt.c (add_pending_template): Broken out.\n+  \t(lookup_template_class): If -fexternal-templates, call it for all\n+ \tthe methods of implemented types.\n+\t(instantiate_class_template): Instead of instantiating them here.\n+\t(instantiate_decl): Handle -fexternal-templates earlier.\n+\n+Tue Feb 27 15:51:32 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* search.c, lex.c, decl.c, class.c, cp-tree.h: Don't wrap the\n+\tmemoized lookup stuff inside GATHER_STATISTICS.\n+\n+Tue Feb 27 10:38:08 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (start_decl): Complain about array of incomplete type\n+\there.\n+\t(grokdeclarator): Not here.\n+\n+\t* parse.y (template_parm): Expand full_parm inline so we can set\n+ \tthe rule's precedence.\n+\n+\t* pt.c (tsubst_expr): If we're in a template, just do tsubst_copy.\n+\t(tsubst): tsubst_expr the DECL_INITIAL of FIELD_DECLs.\n+\t* decl2.c (grokbitfield): Don't check for integer constant here.\n+\t* class.c (finish_struct_1): Check here.\n+\n+\t* decl.c (define_label): Make the min decl go on permanent_obstack.\n+\n+\t* pt.c (unify): Don't handle CONST_DECLs.\n+\t(uses_template_parms): Don't check DECL_INITIAL on a CONST_DECL.\n+\t(tsubst_copy): Ditto.\n+\n+\t* lex.c (do_identifier): Do pull the DECL_INITIAL out of a\n+ \tCONST_DECL for a template parm.\n+\n+Mon Feb 26 12:48:18 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Complain about array of incomplete type\n+\there.\n+\t(start_decl_1): Not here.\n+\n+\t* pt.c (tsubst): Handle pointer-to-function declarators.\n+\n+\t* method.c (hack_identifier): If pedantic, diagnose local class\n+ \tmethods that require a static chain.\n+\n+\t* decl.c (grok_op_properties): No longer static.\n+\t* cp-tree.h: Declare it.\n+\t* pt.c (tsubst): Call it for operators.\n+\tUse tsubst_copy for TREE_VECs.\n+\n+\t* parse.y (template_arg): The expr has precedence like '>'.\n+\n+Fri Feb 23 14:51:52 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (coerce_template_parms): Don't coerce an expression using\n+ \ttemplate parms.\n+\t(uses_template_parms): Also check DECL_INITIAL in CONST_DECLs.\n+\t(tsubst): Don't use build_index_2_type if the max_value uses template\n+\tparms.\n+\t* method.c (build_overload_int): Emit something arbitrary for an\n+ \texpression using template parms.\n+\n+\t* parse.y (template_close_bracket): New non-terminal to catch use\n+ \tof '>>' instead of '> >' in template class names.\n+\t(template_type): Use it.\n+\t* Makefile.in (CONFLICTS): Causes one more r/r conflict.\n+\n+\t* tree.def: Add CAST_EXPR.\n+\t* typeck2.c (build_functional_cast): Use CAST_EXPR instead of\n+ \tCONVERT_EXPR for minimal_parse_mode.\n+\t* typeck.c (build_c_cast): Ditto.\n+\t* pt.c (tsubst_copy): Ditto.\n+\t* decl2.c (build_expr_from_tree): Ditto.\n+\t* error.c (dump_expr): Ditto.\n+\n+Fri Feb 23 10:36:46 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* except.c (SetTerminate, SetUnexpected): Put back global vars.\n+\t(init_exception_processing): Put back decl/init of\n+\tset_unexpected_fndecl and set_terminate_fndecl, needed to get the\n+\tfns from libstdc++.\n+\n+\t* decl.c (struct binding_level): Delete ACCEPT_ANY bitfield.\n+\t(declare_uninstantiated_type_level, uninstantiated_type_level_p):\n+\tDelete unused fns.\n+\t* cp-tree.h (declare_uninstantiated_type_level,\n+\tuninstantiated_type_level_p): Delete prototypes.\n+\n+Thu Feb 22 19:36:15 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst_expr): Add default return.\n+\n+Thu Feb 22 16:47:24 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* error.c (fndecl_as_string): Delete unused arg CNAME.\n+\t* sig.c (build_signature_table_constructor,\n+\tbuild_signature_method_call): Fix calls.\n+\n+\t* class.c (the_null_vtable_entry): Delete var definition.\n+\t(init_class_processing): Delete tree the_null_vtable_entry init.\n+\t* decl.c (no_print_{functions, builtins}): Declare as static.\n+\t(__tp_desc_type_node): #if 0 var definition.\n+\t(init_type_desc): #if 0 init of __tp_desc_type_node.\n+\t(vb_off_identifier): Move var decl into init_decl_processing.\n+\t(current_function_assigns_this): Declare as static.\n+\t(int_ftype_ptr_ptr_int, void_ftype_ptr_int_int): Delete var decls.\n+\t(init_decl_processing): Delete init of void_ftype_ptr_ptr_int.\n+\tMove decls of string_ftype_ptr_ptr and int_ftype_string_string here.\n+\t* decl2.c (delete_sanity): Delete definition/mod of local var ELT_SIZE.\n+\t* init.c (BI_header_type, BI_header_size): Declare as static.\n+\t* pt.c (template_classes): Delete unused var.\n+\t(add_pending_template): Delete decl for non-existent fn.\n+\t(lookup_template_class): Delete vars CODE and TAG_CODE.\n+\t(instantiate_template): Delete unused var TARGS.\n+\t* cp-tree.h (vb_off_identifier, current_function_assigns_this):\n+\tDelete decls.\n+\t(__tp_desc_type_node): #if 0 var decl.\n+\t(fndecl_as_string): Fix prototype.\n+\n+Thu Feb 22 15:56:19 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.def: Add GOTO_STMT.\n+\t* pt.c (tsubst_expr): Support goto and labels.\n+\t* decl.c (define_label): Support minimal parsing.\n+\t* parse.y (simple_stmt): Ditto.\n+\n+Thu Feb 22 15:30:12 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* xref.c (GNU_xref_member): Only define/set var I if\n+\tXREF_SHORT_MEMBER_NAMES is defined, to match when it's actually\n+\tused.\n+\t(GNU_xref_end_scope): Delete unused fifth arg TRNS.\n+\t(GNU_xref_end): Fix call.\n+\t* decl.c (poplevel, poplevel_class, finish_method): Fix calls.\n+\t* cp-tree.h (GNU_xref_end_scope): Fix prototype.\n+\n+\t* tree.c (build_exception_variant): Delete unused vars I, A, T,\n+\tT2, and CNAME.\n+\t(layout_vbasetypes): Delete unused var NONVIRTUAL_VAR_SIZE.\n+\t(mapcar): Delete unused var CODE.\n+\t(build_cplus_new): Delete unused arg WITH_CLEANUP_P.\n+\t(break_out_cleanups): Fix call.\n+\t(bot_manip): Likewise.\n+\t* call.c (build_method_call): Likewise.\n+\t* cvt.c (build_up_reference, convert_to_reference, cp_convert):\n+\tLikewise.\n+\t* typeck.c (unary_complex_lvalue, build_modify_expr,\n+\tconvert_for_initialization): Likewise.\n+\t* typeck2.c (build_functional_cast): Likewise.\n+\t* cp-tree.h (build_cplus_new): Fix prototype.\n+\n+\t* repo.c (open_repo_file): Delete unused var Q.\n+\t(repo_compile_flags, repo_template_declared,\n+\trepo_template_defined, repo_class_defined, repo_inline_used,\n+\trepo_vtable_used, repo_tinfo_used): #if 0 unused fns.\n+\t(repo_get_id, repo_vtable_used): Declare as static. \n+\t* cp-tree.h (mark_{decl,class}_instantiated, finish_repo): Add\n+\tprototypes.\n+\n+Thu Feb 22 14:53:35 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (pending_inlines): Add function_try_block case.\n+\n+\t* pt.c (unify): Fix for template const parms.\n+\n+Thu Feb 22 13:24:15 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* lex.c (extract_interface_info): Delete forward decl.\n+\t(default_copy_constructor_body, default_assign_ref_body): Delete\n+\tdecls for non-existent functions.\n+\t(synth_firstobj, inline_text_firstobjs): Delete unused vars.\n+\t(init_lex): Delete setting them.\n+\t(cons_up_default_function): Delete unused vars FUNC_BUF,\n+\tFUNC_LEN, and COMPLEX.  Delete code setting COMPLEX.  Delete old\n+\t#if 0'd synth code.\n+\t(toplevel, expression_obstack): Delete unused extern decls.\n+\t(tree_node_kind): Delete unused enum.\n+\t(tree_node_counts, tree_node_sizes): Wrap with #ifdef\n+\tGATHER_STATISTICS.\n+\t(tree_node_kind_names): Delete unused extern decl.\n+\t(synth_obstack): Delete unused var.\n+\t(init_lex): Don't set it.\n+\t(init_parse): Add decl before use.\n+\t(reduce_count): Only define #ifdef GATHER_STATISTICS && REDUCE_LENGTH.\n+\t(current_unit_{name, language}): Delete unused vars. \n+\t(check_newline): Don't bother setting them, just accept the #pragma.\n+\t* cp-tree.h (init_repo, peek_yylex): Add prototypes.\n+\t(current_unit_{name, language}): Delete decls.\n+\n+\t* search.c: Wrap all of the memoized functions, macros, and\n+\tvariables inside #ifdef GATHER_STATISTICS.\n+\t(lookup_field, lookup_fnfields): Likewise.\n+\t(init_search_processing): Likewise.\n+\t(reinit_search_statistics): Wrap whole function.\n+\t* lex.c (reinit_lang_specific): Wrap call to reinit_search_statistics.\n+\n+\t* decl.c (finish_function): Only call pop_memoized_context if\n+\tGATHER_STATISTICS is defined.\n+\t(start_function): Likewise for push_memoized_context.\n+\t* class.c (pushclass, popclass): Likewise.\n+\n+\t* cp-tree.h (CLASSTYPE_MTABLE_ENTRY): Move definition from here...\n+\t* search.c (CLASSTYPE_MTABLE_ENTRY): ... to here.\n+\n+\t* cvt.c (cp_convert): Delete unused local var FORM.\n+\t* cp-tree.h (can_convert, can_convert_arg, real_lvalue_p): Add\n+\tprototypes.\n+\n+Thu Feb 22 13:19:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (do_poplevel): Oops; really return what we get from\n+ \tpoplevel this time.\n+\n+Thu Feb 22 11:41:44 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cp-tree.h (is_aggr_type): Add prototype.\n+\n+\t* cp-tree.h ({push,pop}_cp_function_context): Add decls.\n+\t* method.c ({push,pop}_cp_function_context): Delete decls.\n+\t* except.c (start_eh_unwinder, end_eh_unwinder): Declare as void.\n+\t(SetUnexpected, SetTerminate): Delete unused vars.\n+\t(init_exception_processing): Don't set SetUnexpected or\n+\tSetTerminate.  Don't set SET_UNEXPECTED_FNDECL or SET_TERMINATE_FNDECL.\n+\t(output_exception_table_entry): Delete unused array LABEL.\n+\t(expand_internal_throw): Delete unused var PARAMS.\n+\t(expand_start_catch_block): Delete unused var CLEANUP.\n+\t(emit_exception_table): Delete unused var EH_NODE_DECL.\n+\t(expand_builtin_throw): Delete unused vars UNWIND_AND_THROW and\n+\tGOTO_UNWIND_AND_THROW.  Don't set them.\n+\t(end_eh_unwinder): Add top decl.\n+\t(pop_rtl_from_perm): Delete unused decl of PERMANENT_OBSTACK.\n+\t(exception_section, push_rtl_perm, do_function_call,\n+\tlang_interim_eh, push_eh_cleanup, eh_outer_context,\n+\texpand_end_eh_spec, end_eh_unwinder): Declare as static.\n+\t(saved_pc, saved_throw_type, saved_throw_value, saved_cleanup,\n+\tthrow_used): Likewise.\n+\t* cp-tree.h (expand_end_eh_spec): Delete prototype.\n+\n+\t* search.c (dfs_mark, dfs_mark_vtable_path,\n+\tdfs_unmark_vtable_path, dfs_mark_new_vtable,\n+\tdfs_unmark_new_vtable, dfs_clear_search_slot,\n+\tdfs_search_slot_nonempty_p, bfs_markedp, bfs_unmarkedp,\n+\tbfs_marked_vtable_pathp, bfs_unmarked_vtable_pathp,\n+\tbfs_marked_new_vtablep, bfs_unmarked_new_vtablep): #if 0 unused\n+\tfunctions.\n+\t(n_fields_searched, n_calls_lookup_field, n_calls_lookup_field_1,\n+\tn_calls_lookup_fnfields, n_calls_lookup_fnfields_1,\n+\tn_calls_get_base_type, n_outer_fields_searched, n_contexts_saved):\n+\tOnly define #ifdef GATHER_STATISTICS.\n+\t(reinit_search_statistics): Only init some vars if GATHER_STATISTICS\n+\tis defined.\n+\t(vbase_decl): Delete var definition.\n+\t(init_search): Delete old decl.\n+\t(init_vbase_pointers): Delete building of VBASE_DECL, since it's\n+\tnever actually used.\n+\t(expand_indirect_vtbls_init): Delete init of VBASE_DECL.\n+\t(get_base_distance_recursive): Delete unused fourth arg\n+\tBASETYPE_PATH.  Fix call .\n+\t(get_base_distance): Fix call.\n+\t(push_class_decls): Delete unused var ID.\n+\t(make_memoized_table_entry): Declare as static.\n+\t(breadth_first_search): Declare as static.\n+\t(tree_has_any_destructor_p): Declare as static.\n+\t(pop_class_decls): Delete unused arg pop_class_decls.\n+\t* class.c (popclass): Fix call to pop_class_decls.\n+\t* cp-tree.h (make_memoized_table_entry, breadth_first_search,\n+\ttree_has_any_destructor_p): Delete prototypes.\n+\n+\t* rtti.c (build_ptmf_desc): Delete unused arg TYPE.\n+\t(build_t_desc): Fix call.  Delete unused vars ELEMS and TT.\n+\t(build_dynamic_cast): Delete unused local vars TMP1 and RETVAL.\n+\t(build_user_desc): Delete unused var T.\n+\t(build_class_desc): Delete unused vars T and OFF.\n+\t(build_t_desc): Delete unused var NAME_STRING.\n+\t(build_headof): Make static.\n+\t(get_bad_cast_node): Likewise.\n+\t(get_def_to_follow): Likewise.\n+\t* cp-tree.h (init_type_desc): Add prototype.\n+\t(build_headof): Remove prototype.\n+\n+Thu Feb 22 00:54:22 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst): Only look for matching decls at file scope for\n+ \tnon-member functions.\n+\n+\t* call.c (build_scoped_method_call): Handle scoped destructor\n+ \tcalls in templates.\n+\n+\t* decl.c (*_top_level): Also save previous_class_values.\n+\n+\t* pt.c (tsubst_expr): Support do {} while loops.\n+\t* parse.y (simple_stmt): Ditto.\n+\t* tree.def: Ditto.\n+\n+\t* method.c (build_overload_identifier): For a class nested in a\n+ \ttemplate class, don't mangle in the template parms from our\n+ \tcontext.\n+\n+\t* lex.c, cp-tree.h: Remove support for template instantiations in\n+ \tthe pending_inlines code.\n+\t* pt.c: Remove dead functions and unused arguments.\n+\t(uses_template_parms): TYPENAME_TYPEs always use template parms.\n+\t* parse.y: Stop passing anything to end_template_decl.\n+\t* tree.c (print_lang_statistics): Only print tinst info #ifdef\n+ \tGATHER_STATISTICS.\n+\n+Wed Feb 21 16:57:33 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* init.c (expand_recursive_init{,_1}): Delete decls. \n+\t(sort_member_init): Delete unused var INIT.\n+\t(emit_base_init): Delete unused var X.\n+\t(build_offset_ref): Delete unused var CNAME.\n+\t(sort_member_init): Delete unused var FIELDS_TO_UNMARK.\n+\t(emit_base_init): Delete unused local var BASE.  Delete extern\n+\tdecl of IN_CHARGE_IDENTIFIER.\n+\t(build_delete): Delete unused local var VIRTUAL_SIZE.\n+\n+\t* init.c (build_vec_delete): Delete unused third arg ELT_SIZE.\n+\t(build_delete): Fix call.\n+\t* decl2.c (delete_sanity): Likewise.\n+\t* cp-tree.h (build_vec_delete): Update prototype.\n+\n+\t* typeck.c (common_base_type): Delete unused var TMP.\n+\t(build_binary_op): Delete local var ARGS_SAVE.\n+\t(build_array_ref): Delete unused var ITYPE.\n+\t(c_expand_return): Delete unused var USE_TEMP.\n+\n+\t* typeck.c (compexcepttypes): Delete unused arg STRICT.\n+\t(comptypes): Fix calls.\n+\t* decl.c (duplicate_decls): Likewise.\n+\t* cp-tree.h (compexcepttypes): Delete extra arg.\n+\n+\t* decl2.c (check_classfn): Delete unused second arg CNAME.\n+\t* decl.c (start_decl, grokfndecl): Fix calls.\n+\t* init.c (do_friend): Likewise.\n+\t* cp-tree.h (check_classfn): Update prototype.\n+\n+\t* cp-tree.h (signature_error, import_export_vtable,\n+\tappend_signature_fields, id_in_current_class, mark_used,\n+\tcopy_assignment_arg_p): Add decls.\n+\t* decl2.c (mark_used): Delete decl.\n+\n+\t* class.c (n_*): Wrap with #ifdef GATHER_STATISTICS.\n+\n+\t* class.c (get_vtable_entry): Diable unused function.\n+\t(doing_hard_virtuals): Delete unused static global var.\n+\t(finish_struct_1): Don't init DOING_HARD_VIRTUALS.\n+\t(prepare_fresh_vtable): Delete unused vars PATH and RESULT.\n+\t(overrides): Delete unused vars RETTYPE and BASE_RETTYPE.\n+\t(modify_one_vtable): Delete unused var OLD_RTTI.\n+\t(finish_struct_anon): Delete unused vars OFFSET and X.\n+\t(finish_struct_bits): Delete unused var METHOD_VEC.\n+\t(get_basefndecls): Delete unused var PURPOSE.  Delete unused\n+\tfor-scope local variable METHODS.\n+\n+\t* call.c (user_harshness): Delete unused/unneeded arg PARM.\n+\t(ideal_candidate): Delete unused args BASETYPE and PARMS.\n+\t(build_method_call): Delete unused args passed into ideal_candidate.\n+\t(build_overload_call_real): Likewise.  Delete unused var OVERLOAD_NAME.\n+\t* cp-tree.h (synthesize_method): Add decl.\n+\n+\t* decl.c (note_level_for_for): Give void return type.\n+\t(pushdecl_nonclass_level): Likewise.\n+\t(finish_function): Delete unused vars VFIELDS and ALLOCATED_THIS.\n+\t(poplevel): Delete unused var IMPLICIT_TRY_BLOCK.\n+\t(suspend_binding_level): Delete unused var LEVEL.\n+\t(duplicate_decls): Delete unused var CTYPE.\n+\t(duplicate_decls): Delete unused var PREVIOUS_C_DECL.\n+\t(init_decl_processing): Delete unused vars FLOAT_ENDLINK and\n+\tPTR_ENDLINK.\n+\t(grokdeclarator): Delete unused var C.\n+\t(grokdeclarator): Delete unused var SIZE_VARIES.\n+\t(grokparms): Delete unused var SAW_VOID.\n+\t(start_function): Delete unused var OLDDECL.\n+\t(cplus_expand_expr_stmt): Delete unused var\n+\tREMOVE_IMPLICIT_IMMEDIATELY. \n+\n+\t* cp-tree.h (pushdecl_nonclass_level): Fix prototype.\n+\n+\t* Makefile.in (CONFLICTS): Update to 12 shift/reduce.\n+\n+Wed Feb 21 00:06:17 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (build_min): Set TREE_COMPLEXITY to lineno.\n+\t(build_min_nt): Ditto.\n+\t* pt.c (do_pushlevel): Emit line note.\n+\t(do_poplevel): Return what we get from poplevel.\n+\t(tsubst_expr): Set lineno from TREE_COMPLEXITY in stmt nodes.\n+\t* parse.y: Use do_pushlevel and do_poplevel.\n+\t* cp-tree.h: Declare do_poplevel.\n+\t\n+\t* cp-tree.h: Declare at_eof.\n+\t* decl.c (cp_finish_decl): Pass it to rest_of_decl_compilation.\n+\t* decl2.c (import_export_decl): Renamed from import_export_inline.\n+\t(finish_file): Call it to do interface handling for statics.\n+\t* pt.c (tsubst_copy): Call mark_used on variables and functions\n+ \tused here.\n+\n+\t* decl2.c (finish_file): Don't emit statics we can't generate.\n+\t* pt.c (instantiate_decl): Don't set interface on instantiations\n+ \twe can't generate.\n+\n+\t* cp-tree.h (struct tinst_level): Change 'classname' to 'decl'.\n+\t* tree.c (print_lang_statistics): Print max template depth.\n+\t* pt.c (push_tinst_level): Dump entire instantiation context.\n+\t(instantiate_class_template): Use it and pop_tinst_level.\n+\t(instantiate_decl): Ditto.\n+\n+\t* call.c class.c cp-tree.h decl.c decl2.c error.c lex.c method.c\n+ \tpt.c ptree.c tree.def: Remove all traces of UNINSTANTIATED_P_TYPE.\n+\n+Tue Feb 20 18:21:51 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c class.c cp-tree.h cvt.c decl.c decl2.c error.c expr.c\n+ \tinit.c lex.c method.c parse.y pt.c repo.c search.c spew.c tree.c\n+ \ttree.def typeck.c typeck2.c xref.c: Massive, systemic changes for\n+ \tthe new template implementation.\n+\n+Tue Feb 20 17:14:29 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl2.c (check_cp_case_value): Use STRIP_TYPE_NOPS.\n+\n Thu Feb 15 18:44:42 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* decl.c (cp_finish_decl): Delay emitting the debug information for"}, {"sha": "37ccc18930a7292fbbc6e1908c4712d6ef68274e", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -168,7 +168,6 @@ OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o\n \n compiler: ../cc1plus\n ../cc1plus: $(P) $(CXX_OBJS) $(OBJDEPS) $(LIBDEPS)\n-\trm -f ../cc1plus$(exeext)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n \t      $(CXX_OBJS) $(OBJS) $(LIBS)\n \n@@ -196,7 +195,7 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n-CONFLICTS = expect 7 shift/reduce conflicts and 38 reduce/reduce conflicts.\n+CONFLICTS = expect 12 shift/reduce conflicts and 39 reduce/reduce conflicts.\n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n \t@echo $(CONFLICTS)"}, {"sha": "570c02077e291dfa839ca8dfd02dfbad210e84d6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -175,8 +175,8 @@ convert_harshness (type, parmtype, parm)\n       if (! lvalue && ! (parm && TYPE_READONLY (ttl)))\n \treturn EVIL_RETURN (h);\n \n-      if (TYPE_READONLY (ttl) < constp\n-\t  || TYPE_VOLATILE (ttl) < volatilep)\n+      if ((TYPE_READONLY (ttl) < constp)\n+\t  || (TYPE_VOLATILE (ttl) < volatilep))\n \treturn EVIL_RETURN (h);\n \n       /* When passing a non-const argument into a const reference, dig it a\n@@ -646,9 +646,8 @@ convert_harshness (type, parmtype, parm)\n    overload resolution.  */\n \n int\n-user_harshness (type, parmtype, parm)\n+user_harshness (type, parmtype)\n      register tree type, parmtype;\n-     tree parm;\n {\n   tree conv;\n   tree winner = NULL_TREE;\n@@ -668,7 +667,7 @@ user_harshness (type, parmtype, parm)\n \tcontinue;\n \n       if (tmp = convert_harshness (type, TREE_VALUE (conv), NULL_TREE),\n-\t  tmp.code < USER_CODE && tmp.distance >= 0)\n+\t  (tmp.code < USER_CODE) && (tmp.distance >= 0))\n \t{\n \t  if (winner)\n \t    return EVIL_CODE;\n@@ -692,7 +691,7 @@ can_convert (to, from)\n {\n   struct harshness_code h;\n   h = convert_harshness (to, from, NULL_TREE);\n-  return h.code < USER_CODE && h.distance >= 0;\n+  return (h.code < USER_CODE) && (h.distance >= 0);\n }\n \n int\n@@ -701,7 +700,7 @@ can_convert_arg (to, from, arg)\n {\n   struct harshness_code h;\n   h = convert_harshness (to, from, arg);\n-  return h.code < USER_CODE && h.distance >= 0;\n+  return (h.code < USER_CODE) && (h.distance >= 0);\n }\n \n #ifdef DEBUG_MATCHING\n@@ -1091,11 +1090,9 @@ strictly_better (x, y)\n    LEN is the length of the parameter list.  */\n \n static struct candidate *\n-ideal_candidate (basetype, candidates, n_candidates, parms, len)\n-     tree basetype;\n+ideal_candidate (candidates, n_candidates, len)\n      struct candidate *candidates;\n      int n_candidates;\n-     tree parms;\n      int len;\n {\n   struct candidate *cp = candidates+n_candidates;\n@@ -1347,15 +1344,6 @@ find_scoped_type (type, inner_name, inner_types)\n       tags = TREE_CHAIN (tags);\n     }\n \n-#if 0\n-  /* XXX This needs to be fixed better.  */\n-  if (TREE_CODE (type) == UNINSTANTIATED_P_TYPE)\n-    {\n-      sorry (\"nested class lookup in template type\");\n-      return NULL_TREE;\n-    }\n-#endif\n-\n   /* Look for a TYPE_DECL.  */\n   for (tags = TYPE_FIELDS (type); tags; tags = TREE_CHAIN (tags))\n     if (TREE_CODE (tags) == TYPE_DECL && DECL_NAME (tags) == inner_name)\n@@ -1477,6 +1465,17 @@ build_scoped_method_call (exp, basetype, name, parms)\n       || basetype == error_mark_node)\n     return error_mark_node;\n \n+  if (current_template_parms)\n+    {\n+      if (TREE_CODE (name) == BIT_NOT_EXPR)\n+\t{\n+\t  tree type = get_aggr_from_typedef (TREE_OPERAND (name, 0), 1);\n+\t  name = build_min_nt (BIT_NOT_EXPR, type);\n+\t}\n+      name = build_min_nt (SCOPE_REF, basetype, name);\n+      return build_min_nt (METHOD_CALL_EXPR, name, exp, parms, 0);\n+    }\n+\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n@@ -1489,7 +1488,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n \tcp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t  exp, basetype, type);\n       name = TREE_OPERAND (name, 0);\n-      if (basetype != get_type_value (name))\n+      if (basetype != name && basetype != get_type_value (name))\n \tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  basetype, name);\n       return convert (void_type_node, exp);\n@@ -1520,7 +1519,8 @@ build_scoped_method_call (exp, basetype, name, parms)\n \t{\n \t  /* Explicit call to destructor.  */\n \t  name = TREE_OPERAND (name, 0);\n-\t  if (! (name == constructor_name (TREE_TYPE (decl))\n+\t  if (! (name == TYPE_MAIN_VARIANT (TREE_TYPE (decl))\n+\t\t || name == constructor_name (TREE_TYPE (decl))\n \t\t || TREE_TYPE (decl) == get_type_value (name)))\n \t    {\n \t      cp_error\n@@ -1607,7 +1607,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n {\n   register tree function, fntype, value_type;\n   register tree basetype, save_basetype;\n-  register tree baselink, result, method_name, parmtypes, parm;\n+  register tree baselink, result, parmtypes, parm;\n+#if 0\n+  register tree method_name;\n+#endif\n   tree last;\n   int pass;\n   tree access = access_public_node;\n@@ -1636,6 +1639,17 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       || (instance != NULL_TREE && TREE_TYPE (instance) == error_mark_node))\n     return error_mark_node;\n \n+  if (current_template_parms)\n+    {\n+      if (TREE_CODE (name) == BIT_NOT_EXPR)\n+\t{\n+\t  tree type = get_aggr_from_typedef (TREE_OPERAND (name, 0), 1);\n+\t  name = build_min_nt (BIT_NOT_EXPR, type);\n+\t}\n+\n+      return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, 0);\n+    }\n+\n   /* This is the logic that magically deletes the second argument to\n      operator delete, if it is not needed. */\n   if (name == ansi_opname[(int) DELETE_EXPR] && list_length (parms)==2)\n@@ -1668,8 +1682,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       basetype = TREE_TYPE (instance);\n       if (TREE_CODE (basetype) == REFERENCE_TYPE)\n \tbasetype = TREE_TYPE (basetype);\n-      if (! ((IS_AGGR_TYPE (basetype)\n-\t      && name == constructor_name (basetype))\n+      if (! (name == basetype\n+\t     || (IS_AGGR_TYPE (basetype)\n+\t\t && name == constructor_name (basetype))\n \t     || basetype == get_type_value (name)))\n \t{\n \t  cp_error (\"destructor name `~%D' does not match type `%T' of expression\",\n@@ -1734,7 +1749,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n \t{\n \t  basetype = IDENTIFIER_TYPE_VALUE (name);\n-\t  name = constructor_name_full (basetype);\n+\t  name = constructor_name (basetype);\n \t}\n       else\n \t{\n@@ -1884,7 +1899,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      if (TREE_CODE (instance) != CALL_EXPR)\n \t\tmy_friendly_abort (125);\n \t      if (TYPE_NEEDS_CONSTRUCTING (basetype))\n-\t\tinstance = build_cplus_new (basetype, instance, 0);\n+\t\tinstance = build_cplus_new (basetype, instance);\n \t      else\n \t\t{\n \t\t  instance = get_temp_name (basetype, 0);\n@@ -1942,7 +1957,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t}\n     }\n \n-  if (TYPE_SIZE (basetype) == 0)\n+  if (TYPE_SIZE (complete_type (basetype)) == 0)\n     {\n       /* This is worth complaining about, I think.  */\n       cp_error (\"cannot lookup method in incomplete type `%T'\", basetype);\n@@ -2033,8 +2048,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   if ((IDENTIFIER_HAS_TYPE_VALUE (name)\n        && ! IDENTIFIER_OPNAME_P (name)\n-       && IS_AGGR_TYPE (IDENTIFIER_TYPE_VALUE (name))\n-       && TREE_CODE (IDENTIFIER_TYPE_VALUE (name)) != UNINSTANTIATED_P_TYPE)\n+       && IS_AGGR_TYPE (IDENTIFIER_TYPE_VALUE (name)))\n       || name == constructor_name (basetype))\n     {\n       tree tmp = NULL_TREE;\n@@ -2301,8 +2315,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      int n_candidates = cp - candidates;\n \t      extern int warn_synth;\n \t      TREE_VALUE (parms) = instance_ptr;\n-\t      cp = ideal_candidate (save_basetype, candidates,\n-\t\t\t\t    n_candidates, parms, len);\n+\t      cp = ideal_candidate (candidates, n_candidates, len);\n \t      if (cp == (struct candidate *)0)\n \t\t{\n \t\t  if (flags & LOOKUP_COMPLAIN)\n@@ -2529,7 +2542,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   value_type = TREE_TYPE (fntype) ? TREE_TYPE (fntype) : void_type_node;\n \n-  if (TYPE_SIZE (value_type) == 0)\n+  if (TYPE_SIZE (complete_type (value_type)) == 0)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \tincomplete_type_error (0, value_type);\n@@ -2710,7 +2723,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n      int buildxxx;\n {\n   /* must check for overloading here */\n-  tree overload_name, functions, function, parm;\n+  tree functions, function, parm;\n   tree parmtypes = NULL_TREE, last = NULL_TREE;\n   register tree outer;\n   int length;\n@@ -2831,7 +2844,6 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       function = outer;\n       if (TREE_CODE (function) != FUNCTION_DECL\n \t  && ! (TREE_CODE (function) == TEMPLATE_DECL\n-\t\t&& ! DECL_TEMPLATE_IS_CLASS (function)\n \t\t&& TREE_CODE (DECL_TEMPLATE_RESULT (function)) == FUNCTION_DECL))\n \t{\n \t  enum tree_code code = TREE_CODE (function);\n@@ -2869,7 +2881,11 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (function)),\n \t\t\t\tparms, &template_cost, 0);\n \t  if (i == 0)\n-\t    function = instantiate_template (function, targs);\n+\t    {\n+\t      function = instantiate_template (function, targs);\n+\t      if (function == error_mark_node)\n+\t\treturn function;\n+\t    }\n \t}\n \n       if (TREE_CODE (function) == TEMPLATE_DECL)\n@@ -2924,8 +2940,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n       if (cp - candidates > 1)\n \t{\n \t  struct candidate *best_cp\n-\t    = ideal_candidate (NULL_TREE, candidates,\n-\t\t\t       cp - candidates, parms, parmlength);\n+\t    = ideal_candidate (candidates, cp - candidates, parmlength);\n \t  if (best_cp == (struct candidate *)0)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)"}, {"sha": "4bceaa16310da8e1c1cb68b8e06c919906ebdb60", "filename": "gcc/cp/class.c", "status": "modified", "additions": 125, "deletions": 77, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -81,7 +81,6 @@ tree previous_class_type;\t/* _TYPE: the previous type that was a class */\n tree previous_class_values;\t\t/* TREE_LIST: copy of the class_shadowed list\n \t\t\t\t   when leaving an outermost class scope.  */\n static tree get_vfield_name PROTO((tree));\n-tree the_null_vtable_entry;\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n@@ -109,6 +108,7 @@ tree access_private_virtual_node; /* 6 */\n \n /* Variables shared between class.c and call.c.  */\n \n+#ifdef GATHER_STATISTICS\n int n_vtables = 0;\n int n_vtable_entries = 0;\n int n_vtable_searches = 0;\n@@ -117,6 +117,7 @@ int n_convert_harshness = 0;\n int n_compute_conversion_costs = 0;\n int n_build_method_call = 0;\n int n_inner_fields_searched = 0;\n+#endif\n \n /* Virtual baseclass things.  */\n tree\n@@ -362,7 +363,6 @@ build_vbase_path (code, type, expr, path, alias_this)\n    classes.  We do all overrides after we layout virtual base classes.\n    */\n static tree pending_hard_virtuals;\n-static int doing_hard_virtuals;\n \n /* Build an entry in the virtual function table.\n    DELTA is the offset for the `this' pointer.\n@@ -698,8 +698,7 @@ prepare_fresh_vtable (binfo, for_type)\n      for_type, and we really want different names.  (mrs) */\n   tree name = build_type_pathname (VTABLE_NAME_FORMAT, basetype, for_type);\n   tree new_decl = build_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n-  tree path, offset;\n-  int result;\n+  tree offset;\n \n   /* Remember which class this vtable is really for.  */\n   DECL_CONTEXT (new_decl) = for_type;\n@@ -741,6 +740,7 @@ prepare_fresh_vtable (binfo, for_type)\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n }\n \n+#if 0\n /* Access the virtual function table entry that logically\n    contains BASE_FNDECL.  VIRTUALS is the virtual function table's\n    initializer.  We can run off the end, when dealing with virtual\n@@ -765,6 +765,7 @@ get_vtable_entry (virtuals, base_fndecl)\n     }\n   return virtuals;\n }\n+#endif\n \n /* Put new entry ENTRY into virtual function table initializer\n    VIRTUALS.\n@@ -913,7 +914,7 @@ add_method (type, fields, method)\n     decl = copy_node (method);\n     if (DECL_RTL (decl) == 0\n         && (!processing_template_decl\n-            || !uses_template_parms (decl)))\n+\t    || !uses_template_parms (decl)))\n       {\n \tmake_function_rtl (decl);\n \tDECL_RTL (method) = DECL_RTL (decl);\n@@ -1087,8 +1088,16 @@ delete_duplicate_fields_1 (field, fields)\n \t\t    cp_error_at (\"duplicate nested type `%D'\", x);\n \t\t  else if (TREE_CODE (field) == TYPE_DECL\n \t\t\t   || TREE_CODE (x) == TYPE_DECL)\n-\t\t    cp_error_at (\"duplicate field `%D' (as type and non-type)\",\n-\t\t\t\tx);\n+\t\t    {\n+\t\t      /* Hide tag decls.  */\n+\t\t      if ((TREE_CODE (field) == TYPE_DECL\n+\t\t\t   && DECL_ARTIFICIAL (field))\n+\t\t\t  || (TREE_CODE (x) == TYPE_DECL\n+\t\t\t      && DECL_ARTIFICIAL (x)))\n+\t\t\tcontinue;\n+\t\t      cp_error_at (\"duplicate field `%D' (as type and non-type)\",\n+\t\t\t\t   x);\n+\t\t    }\n \t\t  else\n \t\t    cp_error_at (\"duplicate member `%D'\", x);\n \t\t  if (prev == 0)\n@@ -1658,7 +1667,6 @@ finish_struct_bits (t, max_has_virtual)\n      int max_has_virtual;\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n-  tree method_vec = CLASSTYPE_METHOD_VEC (t);\n \n   /* Fix up variants (if any).  */\n   tree variants = TYPE_NEXT_VARIANT (t);\n@@ -1677,6 +1685,7 @@ finish_struct_bits (t, max_has_virtual)\n       /* Copy whatever these are holding today.  */\n       TYPE_MIN_VALUE (variants) = TYPE_MIN_VALUE (t);\n       TYPE_MAX_VALUE (variants) = TYPE_MAX_VALUE (t);\n+      TYPE_FIELDS (variants) = TYPE_FIELDS (t);\n       variants = TYPE_NEXT_VARIANT (variants);\n     }\n \n@@ -2167,7 +2176,7 @@ overrides (fndecl, base_fndecl)\n     return 0;\n   if (DECL_NAME (fndecl) == DECL_NAME (base_fndecl))\n     {\n-      tree rettype, base_rettype, types, base_types;\n+      tree types, base_types;\n #if 0\n       retypes = TREE_TYPE (TREE_TYPE (fndecl));\n       base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));\n@@ -2291,7 +2300,6 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n      tree binfo, t, fndecl, pfn;\n {\n   tree virtuals = BINFO_VIRTUALS (binfo);\n-  tree old_rtti;\n   unsigned HOST_WIDE_INT n;\n   \n   /* update rtti entry */\n@@ -2711,8 +2719,6 @@ get_basefndecls (fndecl, t)\n \n   while (methods)\n     {\n-      tree purpose = NULL_TREE;\n-\n       if (TREE_CODE (methods) == FUNCTION_DECL\n \t  && DECL_VINDEX (methods) != NULL_TREE\n \t  && DECL_NAME (fndecl) == DECL_NAME (methods))\n@@ -2728,7 +2734,6 @@ get_basefndecls (fndecl, t)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       tree basetype = BINFO_TYPE (base_binfo);\n-      tree methods = TYPE_METHODS (basetype);\n \n       base_fndecls = chainon (get_basefndecls (fndecl, basetype),\n \t\t\t      base_fndecls);\n@@ -2913,8 +2918,6 @@ finish_struct_anon (t)\n \t  tree* uelt = &TYPE_FIELDS (TREE_TYPE (field));\n \t  for (; *uelt; uelt = &TREE_CHAIN (*uelt))\n \t    {\n-\t      tree offset, x;\n-\n \t      if (TREE_CODE (*uelt) != FIELD_DECL)\n \t\tcontinue;\n \n@@ -3190,8 +3193,11 @@ finish_struct_1 (t, attributes, warn_anon)\n \t\t\t\t\t\t   &has_virtual, x, t);\n \t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n \t    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n+#if 0\n+\t  /* XXX Why did I comment this out?  (jason) */\n \t  else\n \t    TREE_USED (x) = 1;\n+#endif\n \t}\n     }\n \n@@ -3377,9 +3383,26 @@ finish_struct_1 (t, attributes, warn_anon)\n \t  /* Detect and ignore out of range field width.  */\n \t  if (DECL_INITIAL (x))\n \t    {\n-\t      register int width = TREE_INT_CST_LOW (DECL_INITIAL (x));\n+\t      tree w = DECL_INITIAL (x);\n+\t      register int width;\n \n-\t      if (width < 0)\n+\t      /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n+\t      STRIP_NOPS (w);\n+\n+\t      /* detect invalid field size.  */\n+\t      if (TREE_CODE (w) == CONST_DECL)\n+\t\tw = DECL_INITIAL (w);\n+\t      else if (TREE_READONLY_DECL_P (w))\n+\t\tw = decl_constant_value (w);\n+\n+\t      if (TREE_CODE (w) != INTEGER_CST)\n+\t\t{\n+\t\t  cp_error_at (\"bit-field `%D' width not an integer constant\",\n+\t\t\t       x);\n+\t\t  DECL_INITIAL (x) = NULL_TREE;\n+\t\t}\n+\t      else if (width = TREE_INT_CST_LOW (w),\n+\t\t       width < 0)\n \t\t{\n \t\t  DECL_INITIAL (x) = NULL;\n \t\t  cp_error_at (\"negative width in bit-field `%D'\", x);\n@@ -3789,6 +3812,8 @@ finish_struct_1 (t, attributes, warn_anon)\n \t{\n \t  tree name = DECL_NAME (x);\n \t  int i = /*TREE_VEC_ELT (method_vec, 0) ? 0 : */ 1;\n+\t  if (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x))\n+\t    continue;\n \t  for (; i < n_methods; ++i)\n \t    if (DECL_NAME (TREE_VEC_ELT (method_vec, i)) == name)\n \t      {\n@@ -3842,7 +3867,6 @@ finish_struct_1 (t, attributes, warn_anon)\n   /* Now fix up any virtual base class types that we left lying\n      around.  We must get these done before we try to lay out the\n      virtual function table.  */\n-  doing_hard_virtuals = 1;\n   pending_hard_virtuals = nreverse (pending_hard_virtuals);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n@@ -3949,8 +3973,6 @@ finish_struct_1 (t, attributes, warn_anon)\n \t}\n     }\n \n-  doing_hard_virtuals = 0;\n-\n   /* Under our model of GC, every C++ class gets its own virtual\n      function table, at least virtually.  */\n   if (pending_virtuals || (flag_rtti && TYPE_VIRTUAL_P (t)))\n@@ -4090,42 +4112,6 @@ finish_struct_1 (t, attributes, warn_anon)\n \t}\n     }\n \n-  /* Now add the tags, if any, to the list of TYPE_DECLs\n-     defined for this type.  */\n-  if (CLASSTYPE_TAGS (t))\n-    {\n-      x = CLASSTYPE_TAGS (t);\n-      last_x = tree_last (TYPE_FIELDS (t));\n-      while (x)\n-\t{\n-\t  tree tag = TYPE_NAME (TREE_VALUE (x));\n-\n-\t  /* Check to see if it is already there.  This will be the case if\n-\t     was do enum { red; } color; */\n-\t  if (chain_member (tag, TYPE_FIELDS (t)))\n-\t      {\n-\t\tx = TREE_CHAIN (x);\n-\t\tcontinue;\n-\t      }\n-\n-#ifdef DWARF_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF_DEBUG)\n-\t    {\n-\t      /* Notify dwarfout.c that this TYPE_DECL node represent a\n-\t\t gratuitous typedef.  */\n-\t      DECL_IGNORED_P (tag) = 1;\n-\t    }\n-#endif /* DWARF_DEBUGGING_INFO */\n-\n-\t  TREE_NONLOCAL_FLAG (TREE_VALUE (x)) = 0;\n-\t  x = TREE_CHAIN (x);\n-\t  last_x = chainon (last_x, tag);\n-\t}\n-      if (TYPE_FIELDS (t) == NULL_TREE)\n-\tTYPE_FIELDS (t) = last_x;\n-      CLASSTYPE_LOCAL_TYPEDECLS (t) = 1;\n-    }\n-\n   if (TYPE_HAS_CONSTRUCTOR (t))\n     {\n       tree vfields = CLASSTYPE_VFIELDS (t);\n@@ -4185,17 +4171,12 @@ finish_struct_1 (t, attributes, warn_anon)\n   /* Make the rtl for any new vtables we have created, and unmark\n      the base types we marked.  */\n   finish_vtbls (TYPE_BINFO (t), 1, t);\n-  TYPE_BEING_DEFINED (t) = 0;\n   hack_incomplete_structures (t);\n \n #if 0\n   if (TYPE_NAME (t) && TYPE_IDENTIFIER (t))\n     undo_template_name_overload (TYPE_IDENTIFIER (t), 1);\n #endif\n-  if (current_class_type)\n-    popclass (0);\n-  else\n-    error (\"trying to finish struct, but kicked out due to previous parse errors.\");\n \n   resume_momentary (old);\n \n@@ -4235,9 +4216,12 @@ finish_struct_1 (t, attributes, warn_anon)\n \t      = (value_member (TYPE_IDENTIFIER (t), pending_vtables) == 0);\n \t  else if (CLASSTYPE_INTERFACE_ONLY (t))\n \t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n+#if 0\n+\t  /* XXX do something about this.  */\n \t  else if (CLASSTYPE_INTERFACE_UNKNOWN (t))\n \t    /* Only a first approximation!  */\n \t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n+#endif\n \t}\n       else if (CLASSTYPE_INTERFACE_ONLY (t))\n \tTYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n@@ -4336,6 +4320,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \n \t  if (TREE_CODE (x) == FUNCTION_DECL)\n \t    {\n+\t      DECL_CLASS_CONTEXT (x) = t;\n \t      if (last_x)\n \t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n \t      /* Link x onto end of TYPE_METHODS. */\n@@ -4354,6 +4339,8 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t      DECL_RESULT (x) = n;\n \t    }\n #endif\n+\t  if (TREE_CODE (x) != TYPE_DECL)\n+\t    DECL_FIELD_CONTEXT (x) = t;\n \n \t  if (! fields)\n \t    fields = x;\n@@ -4372,17 +4359,79 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t}\n     }\n \n+  /* Now add the tags, if any, to the list of TYPE_DECLs\n+     defined for this type.  */\n+  if (CLASSTYPE_TAGS (t))\n+    {\n+      x = CLASSTYPE_TAGS (t);\n+      while (x)\n+\t{\n+\t  tree tag = TYPE_NAME (TREE_VALUE (x));\n+\n+\t  /* Check to see if it is already there.  This will be the case if\n+\t     was do enum { red; } color; */\n+\t  if (chain_member (tag, fields))\n+\t      {\n+\t\tx = TREE_CHAIN (x);\n+\t\tcontinue;\n+\t      }\n+\n+#ifdef DWARF_DEBUGGING_INFO\n+\t  if (write_symbols == DWARF_DEBUG)\n+\t    {\n+\t      /* Notify dwarfout.c that this TYPE_DECL node represent a\n+\t\t gratuitous typedef.  */\n+\t      DECL_IGNORED_P (tag) = 1;\n+\t    }\n+#endif /* DWARF_DEBUGGING_INFO */\n+\n+\t  TREE_NONLOCAL_FLAG (TREE_VALUE (x)) = 0;\n+\t  x = TREE_CHAIN (x);\n+\t  last_x = chainon (last_x, tag);\n+\t}\n+      if (fields == NULL_TREE)\n+\tfields = last_x;\n+      CLASSTYPE_LOCAL_TYPEDECLS (t) = 1;\n+    }\n+\n   *tail = NULL_TREE;\n   TYPE_FIELDS (t) = fields;\n \n-  if (0 && processing_template_defn)\n+  if (processing_template_decl)\n     {\n+      tree d = getdecls ();\n+      for (; d; d = TREE_CHAIN (d))\n+\t{\n+\t  /* If this is the decl for the class or one of the template\n+             parms, we've seen all the injected decls.  */\n+\t  if ((TREE_CODE (d) == TYPE_DECL\n+\t       && (TREE_TYPE (d) == t\n+\t\t   || TREE_CODE (TREE_TYPE (d)) == TEMPLATE_TYPE_PARM))\n+\t      || TREE_CODE (d) == CONST_DECL)\n+\t    break;\n+\t  /* Don't inject TYPE_NESTED_NAMEs.  */\n+\t  else if (TREE_MANGLED (DECL_NAME (d))\n+\t\t   || IDENTIFIER_TEMPLATE (DECL_NAME (d)))\n+\t    continue;\n+\t  DECL_TEMPLATE_INJECT (CLASSTYPE_TI_TEMPLATE (t))\n+\t    = tree_cons (NULL_TREE, d,\n+\t\t\t DECL_TEMPLATE_INJECT (CLASSTYPE_TI_TEMPLATE (t)));\n+\t}\n       CLASSTYPE_METHOD_VEC (t)\n \t= finish_struct_methods (t, TYPE_METHODS (t), 1);\n-      return t;\n-    }\n+      TYPE_SIZE (t) = integer_zero_node;\n+    }      \n   else\n-    return finish_struct_1 (t, attributes, warn_anon);\n+    t = finish_struct_1 (t, attributes, warn_anon);\n+\n+  TYPE_BEING_DEFINED (t) = 0;\n+\n+  if (current_class_type)\n+    popclass (0);\n+  else\n+    error (\"trying to finish struct, but kicked out due to previous parse errors.\");\n+\n+  return t;\n }\n \f\n /* Return non-zero if the effective type of INSTANCE is static.\n@@ -4516,7 +4565,6 @@ init_class_processing ()\n   access_private_virtual_node = build_int_2 (6, 0);\n \n   /* Keep these values lying around.  */\n-  the_null_vtable_entry = build_vtable_entry (integer_zero_node, integer_zero_node);\n   base_layout_decl = build_lang_field_decl (FIELD_DECL, NULL_TREE, error_mark_node);\n   TREE_TYPE (base_layout_decl) = make_node (RECORD_TYPE);\n \n@@ -4592,6 +4640,9 @@ pushclass (type, modify)\n \n   pushlevel_class ();\n \n+  if (CLASSTYPE_TEMPLATE_INFO (type))\n+    overload_template_name (type);\n+\n   if (modify)\n     {\n       tree tags;\n@@ -4604,9 +4655,7 @@ pushclass (type, modify)\n       else\n \tcurrent_function_decl = NULL_TREE;\n \n-      if (TREE_CODE (type) == UNINSTANTIATED_P_TYPE)\n-\tdeclare_uninstantiated_type_level ();\n-      else if (type != previous_class_type || current_class_depth > 1)\n+      if (type != previous_class_type || current_class_depth > 1)\n \t{\n \t  build_mi_matrix (type);\n \t  push_class_decls (type);\n@@ -4633,9 +4682,6 @@ pushclass (type, modify)\n \t  unuse_fields (type);\n \t}\n \n-      if (IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (type)))\n-\toverload_template_name (current_class_name, 0);\n-\n       for (tags = CLASSTYPE_TAGS (type); tags; tags = TREE_CHAIN (tags))\n \t{\n \t  TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 1;\n@@ -4686,8 +4732,6 @@ popclass (modify)\n \t  TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 0;\n \t  tags = TREE_CHAIN (tags);\n \t}\n-      if (IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (current_class_type)))\n-\tundo_template_name_overload (current_class_name, 0);\n     }\n \n   /* Force clearing of IDENTIFIER_CLASS_VALUEs after a class definition,\n@@ -4698,7 +4742,7 @@ popclass (modify)\n      this really only frees the obstack used for these decls.\n      That's why it had to be moved down here.  */\n   if (modify)\n-    pop_class_decls (current_class_type);\n+    pop_class_decls ();\n \n   current_class_depth--;\n   current_class_type = *--current_class_stack;\n@@ -4724,7 +4768,8 @@ push_nested_class (type, modify)\n {\n   tree context;\n \n-  if (type == NULL_TREE || type == error_mark_node || ! IS_AGGR_TYPE (type))\n+  if (type == NULL_TREE || type == error_mark_node || ! IS_AGGR_TYPE (type)\n+      || TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n     return;\n   \n   context = DECL_CONTEXT (TYPE_NAME (type));\n@@ -4992,7 +5037,10 @@ instantiate_type (lhstype, rhs, complain)\n \t\t      }\n \t\t  }\n \t      if (save_elem)\n-\t\treturn save_elem;\n+\t\t{\n+\t\t  mark_used (save_elem);\n+\t\t  return save_elem;\n+\t\t}\n \t    }\n \n \t    /* No match found, look for a compatible function.  */"}, {"sha": "51edcb00a07cd2a8962f0e99463ad35097583781", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -90,18 +90,13 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", \"d\", 0)\n    Use TYPE_FIELDS to find parmlist and index.  */\n DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", \"t\", 0)\n \n+/* A type designated by 'typename T::t'. */\n+DEFTREECODE (TYPENAME_TYPE, \"typename_type\", \"t\", 0)\n+\n /* Index into a template parameter list.  This parameter must not be a\n    type.  */\n DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", \"c\", 2)\n \n-/* For uninstantiated parameterized types.\n-        TYPE_VALUES     tree list:\n-                TREE_PURPOSE    template decl\n-                TREE_VALUE      parm vector\n-                TREE_CHAIN      null\n-   Other useful fields to be defined later.  */\n-DEFTREECODE (UNINSTANTIATED_P_TYPE, \"uninstantiated_p_type\", \"t\", 0)\n-\n /* A thunk is a stub function.\n \n    Thunks are used to implement multiple inheritance:\n@@ -118,3 +113,27 @@ DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", \"d\", 0)\n /* A using declaration.  DECL_INITIAL contains the specified scope.  \n    This is not an alias, but is later expanded into multiple aliases.  */\n DEFTREECODE (USING_DECL, \"using_decl\", \"d\", 0)\n+\n+DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", \"e\", 2)\n+DEFTREECODE (MODOP_EXPR, \"modop_expr\", \"e\", 3)\n+DEFTREECODE (CAST_EXPR, \"cast_expr\", \"e\", 1)\n+DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", \"e\", 1)\n+DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", \"e\", 1)\n+DEFTREECODE (ARROW_EXPR, \"arrow_expr\", \"e\", 1)\n+DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", \"e\", 2)\n+\n+DEFTREECODE (EXPR_STMT, \"expr_stmt\", \"e\", 1)\n+DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", \"e\", 1)\n+DEFTREECODE (DECL_STMT, \"decl_stmt\", \"e\", 4)\n+DEFTREECODE (IF_STMT, \"if_stmt\", \"e\", 3)\n+DEFTREECODE (FOR_STMT, \"for_stmt\", \"e\", 4)\n+DEFTREECODE (WHILE_STMT, \"while_stmt\", \"e\", 2)\n+DEFTREECODE (DO_STMT, \"do_stmt\", \"e\", 2)\n+DEFTREECODE (RETURN_STMT, \"return_stmt\", \"e\", 1)\n+DEFTREECODE (BREAK_STMT, \"break_stmt\", \"e\", 0)\n+DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", \"e\", 0)\n+DEFTREECODE (SWITCH_STMT, \"switch_stmt\", \"e\", 2)\n+DEFTREECODE (GOTO_STMT, \"goto_stmt\", \"e\", 1)\n+\n+DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", \"e\", 2)\n+DEFTREECODE (CASE_LABEL, \"case_label\", \"e\", 2)"}, {"sha": "83df18527311a2f035e11b2b22e58debad1135e7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 109, "deletions": 76, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -330,7 +330,7 @@ enum languages { lang_c, lang_cplusplus };\n #define TYPE_MAIN_DECL(NODE) (TYPE_NAME (NODE))\n \n #define IS_AGGR_TYPE(t)\t\t(TYPE_LANG_FLAG_5 (t))\n-#define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE || t == UNINSTANTIATED_P_TYPE)\n+#define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE)\n #define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n   (TREE_CODE (TYPE1) == TREE_CODE (TYPE2)\t\\\n    && IS_AGGR_TYPE (TYPE1)&IS_AGGR_TYPE (TYPE2))\n@@ -507,6 +507,8 @@ struct lang_type\n   union tree_node *signature_pointer_to;\n   union tree_node *signature_reference_to;\n \n+  union tree_node *template_info;\n+\n   int linenum;\n };\n \n@@ -834,9 +836,6 @@ struct lang_type\n \n /* Nonzero if a _DECL node requires us to output debug info for this class.  */\n #define CLASSTYPE_DEBUG_REQUESTED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.debug_requested)\n-\n-#define TYPE_INCOMPLETE(NODE) \\\n-  (TYPE_SIZE (NODE) == NULL_TREE && TREE_CODE (NODE) != TEMPLATE_TYPE_PARM)\n \f\n /* Additional macros for inheritance information.  */\n \n@@ -956,14 +955,14 @@ struct lang_decl_flags\n   tree access;\n   tree context;\n   tree memfunc_pointer_to;\n+  tree template_info;\n   struct binding_level *level;\n };\n \n struct lang_decl\n {\n   struct lang_decl_flags decl_flags;\n \n-  struct template_info *template_info;\n   tree main_decl_variant;\n   struct pending_inline *pending_inline_info;\n   tree chain;\n@@ -1064,8 +1063,8 @@ struct lang_decl\n    ? DECL_CLASS_CONTEXT (NODE) : DECL_CONTEXT (NODE))\n \n /* For a FUNCTION_DECL: the chain through which the next method\n-   in the method chain is found.  We now use TREE_CHAIN to\n-   link into the FIELD_DECL chain.  */\n+   with the same name is found.  We now use TREE_CHAIN to\n+   walk through the methods in order of declaration.  */\n #if 1\n #define DECL_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->chain)\n #else\n@@ -1097,8 +1096,23 @@ struct lang_decl\n    which this signature member function pointer was created.  */\n #define DECL_MEMFUNC_POINTING_TO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.memfunc_pointer_to)\n \n-/* For a TEMPLATE_DECL: template-specific information.  */\n-#define DECL_TEMPLATE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->template_info)\n+/* For a VAR_DECL or FUNCTION_DECL: template-specific information.  */\n+#define DECL_TEMPLATE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.template_info)\n+#define CLASSTYPE_TEMPLATE_INFO(NODE) (TYPE_LANG_SPECIFIC(NODE)->template_info)\n+#define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n+#define TI_ARGS(NODE) (TREE_VALUE (NODE))\n+#define TI_USES_TEMPLATE_PARMS(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n+#define DECL_TI_ARGS(NODE)          TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n+#define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n+#define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n+\n+#define DECL_SAVED_TREE(NODE)\t\tDECL_MEMFUNC_POINTER_TO (NODE)\n+#define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n+#define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n+#define DELETE_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n+#define DELETE_EXPR_USE_VEC(NODE)\tTREE_LANG_FLAG_1 (NODE)\n+#define LOOKUP_EXPR_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n /* Nonzero in INT_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n@@ -1321,13 +1335,23 @@ extern int flag_new_for_scope;\n #define SET_DECL_REFERENCE_SLOT(NODE,VAL) ((NODE)->decl.arguments=VAL)\n \n /* Accessor macros for C++ template decl nodes.  */\n-#define DECL_TEMPLATE_IS_CLASS(NODE)    (DECL_RESULT(NODE) == NULL_TREE)\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n /* For class templates.  */\n #define DECL_TEMPLATE_MEMBERS(NODE)     DECL_SIZE(NODE)\n /* For function, method, class-data templates.  */\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n+#define DECL_TEMPLATE_INJECT(NODE)\tDECL_INITIAL(NODE)\n+\n+#define DECL_FUNCTION_TEMPLATE_P(NODE)  \\\n+  (TREE_CODE (NODE) == TEMPLATE_DECL \\\n+   && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n+\n+#define PRIMARY_TEMPLATE_P(NODE) \\\n+  (TREE_TYPE (DECL_TEMPLATE_PARMS (NODE)) == (NODE))\n+\n+#define CLASSTYPE_TEMPLATE_LEVEL(NODE) \\\n+  (TREE_INT_CST_HIGH (TREE_PURPOSE (CLASSTYPE_TI_TEMPLATE (NODE))))\n \n /* Indicates whether or not (and how) a template was expanded for this\n    FUNCTION_DECL or VAR_DECL.\n@@ -1456,7 +1480,9 @@ extern tree default_function_type;\n extern tree vtable_entry_type;\n extern tree sigtable_entry_type;\n extern tree __t_desc_type_node;\n+#if 0\n extern tree __tp_desc_type_node;\n+#endif\n extern tree __access_mode_type_node;\n extern tree __bltn_desc_type_node, __user_desc_type_node;\n extern tree __class_desc_type_node, __attr_desc_type_node;\n@@ -1471,7 +1497,6 @@ extern tree delta_identifier;\n extern tree delta2_identifier;\n extern tree pfn_or_delta2_identifier;\n extern tree tag_identifier;\n-extern tree vb_off_identifier;\n extern tree vt_off_identifier;\n \n /* A node that is a list (length 1) of error_mark_nodes.  */\n@@ -1497,37 +1522,22 @@ extern tree integer_two_node, integer_three_node;\n extern tree boolean_type_node, boolean_true_node, boolean_false_node;\n \n /* in pt.c  */\n-/* PARM_VEC is a vector of template parameters, either IDENTIFIER_NODEs or\n-   PARM_DECLs.  BINDINGS, if non-null, is a vector of bindings for those\n-   parameters.  */\n-struct template_info {\n-  /* Vector of template parameters, either PARM_DECLs or IDENTIFIER_NODEs.  */\n-  tree parm_vec;\n-  /* If non-null, a vector of bindings for the template parms.  */\n-  tree bindings;\n-\n-  /* Text of template, and length.  */\n-  char *text;\n-  int length;\n-  /* Where it came from.  */\n-  char *filename;\n-  int lineno;\n-\n-  /* What kind of aggregate -- struct, class, or null.  */\n-  tree aggr;\n-};\n-extern int processing_template_decl, processing_template_defn;\n+\n+extern tree current_template_parms;\n+extern HOST_WIDE_INT processing_template_decl;\n \n /* The template currently being instantiated, and where the instantiation\n    was triggered.  */\n struct tinst_level\n {\n-  tree classname;\n+  tree decl;\n   int line;\n   char *file;\n   struct tinst_level *next;\n };\n \n+extern int minimal_parse_mode;\n+\n /* in class.c */\n extern tree current_class_name;\n extern tree current_class_type;\n@@ -1545,7 +1555,6 @@ extern tree current_class_name, current_class_type, current_class_decl, C_C_D;\n extern tree global_base_init_list;\n extern tree current_base_init_list, current_member_init_list;\n \n-extern int current_function_assigns_this;\n extern int current_function_just_assigned_this;\n extern int current_function_parms_stored;\n \f\n@@ -1735,9 +1744,6 @@ extern tree access_default_virtual_node; /* 4 */\n extern tree access_public_virtual_node; /* 5 */\n extern tree access_private_virtual_node; /* 6 */\n \n-/* in lex.c  */\n-extern tree current_unit_name, current_unit_language;\n-\n /* Things for handling inline functions.  */\n \n struct pending_inline\n@@ -1751,7 +1757,6 @@ struct pending_inline\n \n   char *buf;\t\t\t/* pointer to character stream */\n   int len;\t\t\t/* length of stream */\n-  tree parm_vec, bindings;\t/* in case this is derived from a template */\n   unsigned int can_free : 1;\t/* free this after we're done with it? */\n   unsigned int deja_vu : 1;\t/* set iff we don't want to see it again.  */\n   unsigned int interface : 2;\t/* 0=interface 1=unknown 2=implementation */\n@@ -1805,6 +1810,10 @@ extern int flag_implicit_templates;\n \n extern int flag_weak;\n \n+/* Nonzero if we're done parsing and into end-of-file activities.  */\n+\n+extern int at_eof;\n+\n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n extern tree current_class_decl, C_C_D;\t/* PARM_DECL: the class instance variable */\n@@ -1897,15 +1906,14 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))\n \n /* These macros are for accessing the fields of TEMPLATE...PARM nodes.  */\n-#define TEMPLATE_TYPE_TPARMLIST(NODE) TREE_PURPOSE (TYPE_FIELDS (NODE))\n-#define TEMPLATE_TYPE_IDX(NODE) TREE_INT_CST_LOW (TREE_VALUE (TYPE_FIELDS (NODE)))\n-#define TEMPLATE_TYPE_SET_INFO(NODE,P,I) \\\n-  (TYPE_FIELDS (NODE) = build_tree_list (P, build_int_2 (I, 0)))\n-#define TEMPLATE_CONST_TPARMLIST(NODE) (*(tree*)&TREE_INT_CST_LOW(NODE))\n-#define TEMPLATE_CONST_IDX(NODE) (TREE_INT_CST_HIGH(NODE))\n-#define TEMPLATE_CONST_SET_INFO(NODE,P,I) \\\n-  (TEMPLATE_CONST_TPARMLIST (NODE) = saved_parmlist, \\\n-   TEMPLATE_CONST_IDX (NODE) = I)\n+#define TEMPLATE_TYPE_IDX(NODE) TREE_INT_CST_LOW (TYPE_FIELDS (NODE))\n+#define TEMPLATE_TYPE_LEVEL(NODE) TREE_INT_CST_HIGH (TYPE_FIELDS (NODE))\n+#define TEMPLATE_TYPE_SET_INFO(NODE,I,L) \\\n+  (TYPE_FIELDS (NODE) = build_int_2 (I, L))\n+#define TEMPLATE_CONST_IDX(NODE) (TREE_INT_CST_LOW(NODE))\n+#define TEMPLATE_CONST_LEVEL(NODE) (TREE_INT_CST_HIGH(NODE))\n+#define TEMPLATE_CONST_SET_INFO(NODE,I,L) \\\n+  (TEMPLATE_CONST_IDX (NODE) = I, TEMPLATE_CONST_LEVEL (NODE) = L)\n \n /* in lex.c  */\n /* Indexed by TREE_CODE, these tables give C-looking names to\n@@ -1922,6 +1930,8 @@ extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n extern struct candidate *ansi_c_bullshit;\n \n extern int rank_for_overload\t\t\tPROTO((struct candidate *, struct candidate *));\n+extern int can_convert\t\t\t\tPROTO((tree, tree));\n+extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n extern void compute_conversion_costs\t\tPROTO((tree, tree, struct candidate *, int));\n extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n extern tree build_vfield_ref\t\t\tPROTO((tree, tree));\n@@ -1943,6 +1953,8 @@ extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n extern tree get_vfield_offset\t\t\tPROTO((tree));\n extern void duplicate_tag_error\t\t\tPROTO((tree));\n extern tree finish_struct\t\t\tPROTO((tree, tree, tree, int));\n+extern tree finish_struct_1\t\t\tPROTO((tree, tree, int));\n+extern tree finish_struct_methods\t\tPROTO((tree, tree, int));\n extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n extern void init_class_processing\t\tPROTO((void));\n extern void pushclass\t\t\t\tPROTO((tree, int));\n@@ -1980,8 +1992,6 @@ extern int kept_level_p\t\t\t\tPROTO((void));\n extern void declare_parm_level\t\t\tPROTO((void));\n extern void declare_implicit_exception\t\tPROTO((void));\n extern int have_exceptions_p\t\t\tPROTO((void));\n-extern void declare_uninstantiated_type_level\tPROTO((void));\n-extern int uninstantiated_type_level_p\t\tPROTO((void));\n extern void declare_pseudo_global_level\t\tPROTO((void));\n extern int pseudo_global_level_p\t\tPROTO((void));\n extern void pushlevel\t\t\t\tPROTO((int));\n@@ -2008,7 +2018,7 @@ extern tree pushdecl_top_level\t\t\tPROTO((tree));\n extern void push_class_level_binding\t\tPROTO((tree, tree));\n extern void push_overloaded_decl_top_level\tPROTO((tree, int));\n extern tree pushdecl_class_level\t\tPROTO((tree));\n-extern tree pushdecl_nonclass_level\t\tPROTO((tree));\n+extern void pushdecl_nonclass_level\t\tPROTO((tree));\n extern int overloaded_globals_p\t\t\tPROTO((tree));\n extern tree push_overloaded_decl\t\tPROTO((tree, int));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n@@ -2024,6 +2034,7 @@ extern tree lookup_name\t\t\t\tPROTO((tree, int));\n extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n extern tree lookup_name_current_level\t\tPROTO((tree));\n extern void init_decl_processing\t\tPROTO((void));\n+extern int init_type_desc\t\t\tPROTO((void));\n /* skipped define_function */\n extern void shadow_tag\t\t\t\tPROTO((tree));\n extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n@@ -2056,6 +2067,10 @@ extern void finish_stmt\t\t\t\tPROTO((void));\n extern void pop_implicit_try_blocks\t\tPROTO((tree));\n extern void push_exception_cleanup\t\tPROTO((tree));\n extern void revert_static_member_fn\t\tPROTO((tree *, tree *, tree *));\n+extern int id_in_current_class\t\t\tPROTO((tree));\n+extern void push_cp_function_context\t\tPROTO((tree));\n+extern void pop_cp_function_context\t\tPROTO((tree));\n+extern void grok_op_properties\t\t\tPROTO((tree, int, int));\n \n /* in decl2.c */\n extern int lang_decode_option\t\t\tPROTO((char *));\n@@ -2064,11 +2079,12 @@ extern void grokclassfn\t\t\t\tPROTO((tree, tree, tree, enum overload_flags, tree));\n extern tree grok_alignof\t\t\tPROTO((tree));\n extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n extern tree delete_sanity\t\t\tPROTO((tree, tree, int, int));\n-extern tree check_classfn\t\t\tPROTO((tree, tree, tree));\n+extern tree check_classfn\t\t\tPROTO((tree, tree));\n extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree, tree));\n extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n extern tree groktypefield\t\t\tPROTO((tree, tree));\n extern tree grokoptypename\t\t\tPROTO((tree, tree));\n+extern int copy_assignment_arg_p\t\tPROTO((tree, int));\n extern void cplus_decl_attributes\t\tPROTO((tree, tree, tree)); \n extern tree constructor_name_full\t\tPROTO((tree));\n extern tree constructor_name\t\t\tPROTO((tree));\n@@ -2082,13 +2098,15 @@ extern tree finish_table\t\t\tPROTO((tree, tree, tree, int));\n extern void finish_builtin_type\t\t\tPROTO((tree, char *, tree *, int, tree));\n extern tree coerce_new_type\t\t\tPROTO((tree));\n extern tree coerce_delete_type\t\t\tPROTO((tree));\n+extern void import_export_vtable\t\tPROTO((tree, tree, int));\n extern void walk_vtables\t\t\tPROTO((void (*)(), void (*)()));\n extern void walk_sigtables\t\t\tPROTO((void (*)(), void (*)()));\n extern void finish_file\t\t\t\tPROTO((void));\n extern void warn_if_unknown_interface\t\tPROTO((tree));\n extern tree grok_x_components\t\t\tPROTO((tree, tree));\n extern tree reparse_absdcl_as_expr\t\tPROTO((tree, tree));\n extern tree reparse_absdcl_as_casts\t\tPROTO((tree, tree));\n+extern tree build_expr_from_tree\t\tPROTO((tree));\n extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n@@ -2098,6 +2116,7 @@ extern tree do_class_using_decl\t\t\tPROTO((tree));\n extern tree current_namespace_id\t\tPROTO((tree));\n extern tree get_namespace_id\t\t\tPROTO((void));\n extern void check_default_args\t\t\tPROTO((tree));\n+extern void mark_used\t\t\t\tPROTO((tree));\n \n /* in except.c */\n extern tree protect_list;\n@@ -2118,7 +2137,6 @@ extern tree build_throw\t\t\t\tPROTO((tree));\n extern void init_exception_processing\t\tPROTO((void));\n extern void expand_builtin_throw\t\tPROTO((void));\n extern void expand_start_eh_spec\t\tPROTO((void));\n-extern void expand_end_eh_spec\t\t\tPROTO((tree));\n extern tree build_cleanup\t\t\tPROTO((tree));\n extern tree start_anon_func\t\t\tPROTO((void));\n \n@@ -2128,8 +2146,11 @@ extern void init_cplus_expand\t\t\tPROTO((void));\n extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n extern tree unsave_expr_now\t\t\tPROTO((tree));\n \n+/* in repo.c */\n+extern void init_repo\t\t\t\tPROTO((char*));\n+extern void finish_repo\t\t\t\tPROTO((void));\n+\n /* in rtti.c */\n-extern tree build_headof\t\t\tPROTO((tree));\n extern tree build_classof\t\t\tPROTO((tree));\n extern tree build_t_desc\t\t\tPROTO((tree, int));\n extern tree build_i_desc\t\t\tPROTO((tree));\n@@ -2146,6 +2167,7 @@ extern void do_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_aggr_init\t\t\tPROTO((tree, tree, int, int));\n extern int is_aggr_typedef\t\t\tPROTO((tree, int));\n+extern int is_aggr_type\t\t\t\tPROTO((tree, int));\n extern tree get_aggr_from_typedef\t\tPROTO((tree, int));\n extern tree get_type_value\t\t\tPROTO((tree));\n extern tree build_member_call\t\t\tPROTO((tree, tree, tree));\n@@ -2156,15 +2178,15 @@ extern tree decl_constant_value\t\t\tPROTO((tree));\n extern int is_friend_type\t\t\tPROTO((tree, tree));\n extern int is_friend\t\t\t\tPROTO((tree, tree));\n extern void make_friend_class\t\t\tPROTO((tree, tree));\n-extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, enum overload_flags, tree));\n+extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, enum overload_flags, tree, int));\n extern void embrace_waiting_friends\t\tPROTO((tree));\n extern tree build_builtin_call\t\t\tPROTO((tree, tree, tree));\n extern tree build_new\t\t\t\tPROTO((tree, tree, tree, int));\n extern tree expand_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_x_delete\t\t\tPROTO((tree, tree, int, tree));\n extern tree build_delete\t\t\tPROTO((tree, tree, tree, int, int));\n extern tree build_vbase_delete\t\t\tPROTO((tree, tree));\n-extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, tree, int));\n+extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, int));\n \n /* in input.c */\n \n@@ -2198,7 +2220,8 @@ extern int check_newline\t\t\tPROTO((void));\n extern void dont_see_typename\t\t\tPROTO((void));\n extern int identifier_type\t\t\tPROTO((tree));\n extern void see_typename\t\t\tPROTO((void));\n-extern tree do_identifier\t\t\tPROTO((tree));\n+extern tree do_identifier\t\t\tPROTO((tree, int));\n+extern tree do_scoped_id\t\t\tPROTO((tree, int));\n extern tree identifier_typedecl_value\t\tPROTO((tree));\n extern int real_yylex\t\t\t\tPROTO((void));\n extern tree build_lang_decl\t\t\tPROTO((enum tree_code, tree, tree));\n@@ -2223,7 +2246,7 @@ extern void cp_sprintf\t\t\t\t();\n \n /* in error.c */\n extern void init_error\t\t\t\tPROTO((void));\n-extern char *fndecl_as_string\t\t\tPROTO((tree, tree, int));\n+extern char *fndecl_as_string\t\t\tPROTO((tree, int));\n extern char *type_as_string\t\t\tPROTO((tree, int));\n extern char *args_as_string\t\t\tPROTO((tree, int));\n extern char *decl_as_string\t\t\tPROTO((tree, int));\n@@ -2251,36 +2274,37 @@ extern void declare_overloaded\t\t\tPROTO((tree));\n extern int is_overloaded\t\t\tPROTO((tree));\n #endif\n extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n-extern tree hack_identifier\t\t\tPROTO((tree, tree, int));\n+extern tree hack_identifier\t\t\tPROTO((tree, tree));\n extern tree build_component_type_expr\t\tPROTO((tree, tree, tree, int));\n+extern void synthesize_method\t\t\tPROTO((tree));\n \n /* in pt.c */\n extern tree tsubst\t\t\t\tPROTO ((tree, tree*, int, tree));\n+extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree*, int, tree));\n+extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree*, int, tree));\n+extern tree tsubst_chain\t\t\tPROTO((tree, tree));\n extern void begin_template_parm_list\t\tPROTO((void));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n-extern void end_template_decl\t\t\tPROTO((tree, tree, tree, int));\n+extern void end_template_decl\t\t\tPROTO((void));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n-extern void push_template_decls\t\t\tPROTO((tree, tree, int));\n-extern void pop_template_decls\t\t\tPROTO((tree, tree, int));\n extern int uses_template_parms\t\t\tPROTO((tree));\n-extern void instantiate_member_templates\tPROTO((tree));\n-extern tree instantiate_class_template\t\tPROTO((tree, int));\n+extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree *));\n-extern void undo_template_name_overload\t\tPROTO((tree, int));\n-extern void overload_template_name\t\tPROTO((tree, int));\n-extern void end_template_instantiation\t\tPROTO((tree));\n-extern void reinit_parse_for_template\t\tPROTO((int, tree, tree));\n+extern void overload_template_name\t\tPROTO((tree));\n extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int));\n-extern int do_pending_expansions\t\tPROTO((void));\n-extern void do_pending_templates\t\tPROTO((void));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n+extern void mark_decl_instantiated\t\tPROTO((tree, int));\n+extern void mark_class_instantiated\t\tPROTO((tree, int));\n extern void do_function_instantiation\t\tPROTO((tree, tree, tree));\n extern void do_type_instantiation\t\tPROTO((tree, tree));\n-extern tree create_nested_upt\t\t\tPROTO((tree, tree));\n+extern tree make_typename_type\t\t\tPROTO((tree, tree));\n+extern tree instantiate_decl\t\t\tPROTO((tree));\n+extern tree classtype_mangled_name\t\tPROTO((tree));\n+extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));\n+extern tree do_poplevel\t\t\t\tPROTO((void));\n \n /* in search.c */\n-extern tree make_memoized_table_entry\t\tPROTO((tree, tree, int));\n extern void push_memoized_context\t\tPROTO((tree, int));\n extern void pop_memoized_context\t\tPROTO((int));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n@@ -2290,8 +2314,6 @@ extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n extern tree lookup_nested_tag\t\t\tPROTO((tree, tree));\n-extern HOST_WIDE_INT breadth_first_search\tPROTO((tree, int (*)(), int (*)()));\n-extern int tree_has_any_destructor_p\t\tPROTO((tree, int));\n extern tree get_matching_virtual\t\tPROTO((tree, tree, int));\n extern tree get_abstract_virtuals\t\tPROTO((tree));\n extern tree get_baselinks\t\t\tPROTO((tree, tree, tree));\n@@ -2307,7 +2329,7 @@ extern void add_mi_virtuals\t\t\tPROTO((int, tree));\n extern void report_ambiguous_mi_virtuals\tPROTO((int, tree));\n extern void note_debug_info_needed\t\tPROTO((tree));\n extern void push_class_decls\t\t\tPROTO((tree));\n-extern void pop_class_decls\t\t\tPROTO((tree));\n+extern void pop_class_decls\t\t\tPROTO(());\n extern void unuse_fields\t\t\tPROTO((tree));\n extern void unmark_finished_struct\t\tPROTO((tree));\n extern void print_search_statistics\t\tPROTO((void));\n@@ -2323,16 +2345,22 @@ extern tree build_signature_pointer_constructor\tPROTO((tree, tree));\n extern tree build_signature_method_call\t\tPROTO((tree, tree, tree, tree));\n extern tree build_optr_ref\t\t\tPROTO((tree));\n extern tree build_sptr_ref\t\t\tPROTO((tree));\n+extern void append_signature_fields\t\tPROTO((tree));\n \n /* in spew.c */\n extern void init_spew\t\t\t\tPROTO((void));\n+extern int peek_yylex\t\t\t\tPROTO((void));\n extern int yylex\t\t\t\tPROTO((void));\n extern tree arbitrate_lookup\t\t\tPROTO((tree, tree, tree));\n \n /* in tree.c */\n+extern int real_lvalue_p\t\t\tPROTO((tree));\n+extern tree build_min\t\t\t\tPVPROTO((enum tree_code, tree, ...));\n+extern tree build_min_nt\t\t\tPVPROTO((enum tree_code, ...));\n+extern tree min_tree_cons\t\t\tPROTO((tree, tree, tree));\n extern int lvalue_p\t\t\t\tPROTO((tree));\n extern int lvalue_or_else\t\t\tPROTO((tree, char *));\n-extern tree build_cplus_new\t\t\tPROTO((tree, tree, int));\n+extern tree build_cplus_new\t\t\tPROTO((tree, tree));\n extern tree break_out_cleanups\t\t\tPROTO((tree));\n extern tree break_out_calls\t\t\tPROTO((tree));\n extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));\n@@ -2373,17 +2401,19 @@ extern tree break_out_target_exprs\t\tPROTO((tree));\n extern tree build_unsave_expr\t\t\tPROTO((tree));\n extern tree unsave_expr\t\t\t\tPROTO((tree));\n extern int cp_expand_decl_cleanup\t\tPROTO((tree, tree));\n+extern tree get_type_decl\t\t\tPROTO((tree));\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));\n extern tree target_type\t\t\t\tPROTO((tree));\n extern tree require_complete_type\t\tPROTO((tree));\n+extern tree complete_type\t\t\tPROTO((tree));\n extern int type_unknown_p\t\t\tPROTO((tree));\n extern int fntype_p\t\t\t\tPROTO((tree));\n extern tree require_instantiated_type\t\tPROTO((tree, tree, tree));\n extern tree commonparms\t\t\t\tPROTO((tree, tree));\n extern tree common_type\t\t\t\tPROTO((tree, tree));\n-extern int compexcepttypes\t\t\tPROTO((tree, tree, int));\n+extern int compexcepttypes\t\t\tPROTO((tree, tree));\n extern int comptypes\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n extern tree common_base_types\t\t\tPROTO((tree, tree));\n@@ -2393,6 +2423,7 @@ extern int self_promoting_args_p\t\tPROTO((tree));\n extern tree unsigned_type\t\t\tPROTO((tree));\n extern tree signed_type\t\t\t\tPROTO((tree));\n extern tree signed_or_unsigned_type\t\tPROTO((int, tree));\n+extern tree expr_sizeof\t\t\t\tPROTO((tree));\n extern tree c_sizeof\t\t\t\tPROTO((tree));\n extern tree c_sizeof_nowarn\t\t\tPROTO((tree));\n extern tree c_alignof\t\t\t\tPROTO((tree));\n@@ -2426,6 +2457,7 @@ extern tree build_static_cast\t\t\tPROTO((tree, tree));\n extern tree build_reinterpret_cast\t\tPROTO((tree, tree));\n extern tree build_const_cast\t\t\tPROTO((tree, tree));\n extern tree build_c_cast\t\t\tPROTO((tree, tree, int));\n+extern tree build_x_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern int language_lvalue_valid\t\tPROTO((tree));\n extern void warn_for_assignment\t\t\tPROTO((char *, char *, char *, tree, int, int));\n@@ -2442,6 +2474,7 @@ extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n extern void error_with_aggr_type\t\t(); /* PROTO((tree, char *, HOST_WIDE_INT)); */\n extern void readonly_error\t\t\tPROTO((tree, char *, int));\n extern void abstract_virtuals_error\t\tPROTO((tree, tree));\n+extern void signature_error\t\t\tPROTO((tree, tree));\n extern void incomplete_type_error\t\tPROTO((tree, tree));\n extern void my_friendly_abort\t\t\tPROTO((int));\n extern void my_friendly_assert\t\t\tPROTO((int, int));\n@@ -2459,7 +2492,7 @@ extern void GNU_xref_begin\t\t\tPROTO((char *));\n extern void GNU_xref_end\t\t\tPROTO((int));\n extern void GNU_xref_file\t\t\tPROTO((char *));\n extern void GNU_xref_start_scope\t\tPROTO((HOST_WIDE_INT));\n-extern void GNU_xref_end_scope\t\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, int, int, int));\n+extern void GNU_xref_end_scope\t\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, int, int));\n extern void GNU_xref_ref\t\t\tPROTO((tree, char *));\n extern void GNU_xref_decl\t\t\tPROTO((tree, tree));\n extern void GNU_xref_call\t\t\tPROTO((tree, char *));"}, {"sha": "b537fdfc1a5bd81e41aaa4abfcefb66ebaa76866", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -356,7 +356,7 @@ build_up_reference (type, arg, flags, checkconst)\n \t initializing until now: it needs to initialize a temporary.  */\n       if (TREE_HAS_CONSTRUCTOR (targ))\n \t{\n-\t  tree temp = build_cplus_new (argtype, TREE_OPERAND (targ, 0), 1);\n+\t  tree temp = build_cplus_new (argtype, TREE_OPERAND (targ, 0));\n \t  TREE_HAS_CONSTRUCTOR (targ) = 0;\n \t  return build_up_reference (type, temp, flags, 1);\n \t}\n@@ -586,7 +586,7 @@ build_up_reference (type, arg, flags, checkconst)\n \n       if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n \t{\n-\t  temp = build_cplus_new (argtype, targ, 1);\n+\t  temp = build_cplus_new (argtype, targ);\n \t  rval = build1 (ADDR_EXPR, type, temp);\n \t  goto done;\n \t}\n@@ -809,7 +809,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t      if (init == error_mark_node)\n \t\treturn error_mark_node;\n \n-\t      rval = build_cplus_new (type, init, 1);\n+\t      rval = build_cplus_new (type, init);\n \t      rval = build_up_reference (reftype, rval, flags, 1);\n \t    }\n \t  rval_as_ctor = rval;\n@@ -888,7 +888,11 @@ convert_to_aggr (type, expr, msgp, protect)\n   tree basetype = type;\n   tree name = TYPE_IDENTIFIER (basetype);\n   tree function, fndecl, fntype, parmtypes, parmlist, result;\n-  tree method_name, access;\n+#if 0\n+  /* See code below that used this.  */\n+  tree method_name;\n+#endif\n+  tree access;\n   int can_be_private, can_be_protected;\n \n   if (! TYPE_HAS_CONSTRUCTOR (basetype))\n@@ -1229,7 +1233,6 @@ cp_convert (type, expr, convtype, flags)\n   if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (e);\n-      enum tree_code form = TREE_CODE (intype);\n       /* enum = enum, enum = int, enum = float are all errors. */\n       if (flag_int_enum_equivalence == 0\n \t  && TREE_CODE (type) == ENUMERAL_TYPE\n@@ -1328,7 +1331,7 @@ cp_convert (type, expr, convtype, flags)\n \t  return conversion;\n \t}\n \n-      if (TYPE_HAS_CONSTRUCTOR (type))\n+      if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n \tctor = build_method_call (NULL_TREE, constructor_name_full (type),\n \t\t\t\t  build_tree_list (NULL_TREE, e),\n \t\t\t\t  TYPE_BINFO (type),\n@@ -1357,7 +1360,7 @@ cp_convert (type, expr, convtype, flags)\n \treturn conversion;\n       else if (ctor)\n \t{\n-\t  ctor = build_cplus_new (type, ctor, 0);\n+\t  ctor = build_cplus_new (type, ctor);\n \t  return ctor;\n \t}\n     }"}, {"sha": "2dd92e5661091661b7b824b4bdb5f8844bd42f7a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1047, "deletions": 887, "changes": 1934, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2"}, {"sha": "e137f7e6acbc9835b9e4ee459220d182139c3a97", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 295, "deletions": 88, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n extern tree get_file_function_name ();\n extern tree cleanups_this_call;\n static void grok_function_init ();\n+void import_export_decl ();\n extern int current_class_depth;\n \n /* A list of virtual function tables we must make sure to write out.  */\n@@ -67,6 +68,10 @@ static int global_temp_name_counter;\n \n extern int spew_debug;\n \n+/* Nonzero if we're done parsing and into end-of-file activities.  */\n+\n+int at_eof;\n+\n /* Functions called along with real static constructors and destructors.  */\n \n tree static_ctors, static_dtors;\n@@ -1043,6 +1048,10 @@ grok_array_decl (array_expr, index_exp)\n \n   if (type == error_mark_node || index_exp == error_mark_node)\n     return error_mark_node;\n+  if (current_template_parms)\n+    return build_min (ARRAY_REF, type ? TREE_TYPE (type) : NULL_TREE,\n+\t\t      array_expr, index_exp);\n+\n   if (type == NULL_TREE)\n     {\n       /* Something has gone very wrong.  Assume we are mistakenly reducing\n@@ -1057,7 +1066,7 @@ grok_array_decl (array_expr, index_exp)\n \n   /* If they have an `operator[]', use that.  */\n   if (TYPE_LANG_SPECIFIC (type)\n-      && TYPE_OVERLOADS_ARRAY_REF (type))\n+      && TYPE_OVERLOADS_ARRAY_REF (complete_type (type)))\n     return build_opfncall (ARRAY_REF, LOOKUP_NORMAL,\n \t\t\t   array_expr, index_exp, NULL_TREE);\n \n@@ -1108,14 +1117,24 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n      tree exp, size;\n      int doing_vec, use_global_delete;\n {\n-  tree t = stabilize_reference (convert_from_reference (exp));\n-  tree type = TREE_TYPE (t);\n-  enum tree_code code = TREE_CODE (type);\n+  tree t;\n+  tree type;\n+  enum tree_code code;\n   /* For a regular vector delete (aka, no size argument) we will pass\n      this down as a NULL_TREE into build_vec_delete.  */\n   tree maxindex = NULL_TREE;\n-  /* This is used for deleting arrays.  */\n-  tree elt_size;\n+\n+  if (current_template_parms)\n+    {\n+      t = build_min (DELETE_EXPR, void_type_node, exp, size);\n+      DELETE_EXPR_USE_GLOBAL (t) = use_global_delete;\n+      DELETE_EXPR_USE_VEC (t) = doing_vec;\n+      return t;\n+    }\n+\n+  t = stabilize_reference (convert_from_reference (exp));\n+  type = TREE_TYPE (t);\n+  code = TREE_CODE (type);\n \n   switch (doing_vec)\n     {\n@@ -1125,7 +1144,6 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \tpedwarn (\"anachronistic use of array size in vector delete\");\n       /* Fall through.  */\n     case 1:\n-      elt_size = c_sizeof (type);\n       break;\n     default:\n       if (code != POINTER_TYPE)\n@@ -1174,7 +1192,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n #endif\n \n   if (doing_vec)\n-    return build_vec_delete (t, maxindex, elt_size, integer_one_node,\n+    return build_vec_delete (t, maxindex, integer_one_node,\n \t\t\t     integer_two_node, use_global_delete);\n   else\n     {\n@@ -1200,12 +1218,12 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n    CNAME is the same here as it is for grokclassfn above.  */\n \n tree\n-check_classfn (ctype, cname, function)\n-     tree ctype, cname, function;\n+check_classfn (ctype, function)\n+     tree ctype, function;\n {\n   tree fn_name = DECL_NAME (function);\n   tree fndecl;\n-  tree method_vec = CLASSTYPE_METHOD_VEC (ctype);\n+  tree method_vec = CLASSTYPE_METHOD_VEC (complete_type (ctype));\n   tree *methods = 0;\n   tree *end = 0;\n \n@@ -1229,8 +1247,8 @@ check_classfn (ctype, cname, function)\n \t\t  if (DECL_ASSEMBLER_NAME (function) == DECL_ASSEMBLER_NAME (fndecl))\n \t\t    return fndecl;\n #if 0\n-\t\t  /* This should work, but causes libg++ to fail\n-\t\t     make check-tFix. */\n+\t\t  /* This doesn't work for static member functions that are\n+                     pretending to be methods. */\n \t\t  /* We have to do more extensive argument checking here, as\n \t\t     the name may have been changed by asm(\"new_name\"). */\n \t\t  if (decls_match (function, fndecl))\n@@ -1250,12 +1268,7 @@ check_classfn (ctype, cname, function)\n \t\t      if (comptypes (TREE_TYPE (TREE_TYPE (function)),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)), 1)\n \t\t\t  && compparms (p1, p2, 3))\n-\t\t\t{\n-\t\t\t  if (DECL_STATIC_FUNCTION_P (fndecl)\n-\t\t\t      && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n-\t\t\t    revert_static_member_fn (&function, NULL, NULL);\n-\t\t\t  return fndecl;\n-\t\t\t}\n+\t\t\treturn fndecl;\n \t\t    }\n #endif\n \t\t  fndecl = DECL_CHAIN (fndecl);\n@@ -1333,7 +1346,9 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n       && TREE_CODE (declarator) == SCOPE_REF)\n     {\n       /* Access declaration */\n-      if (TREE_COMPLEXITY (declarator) == current_class_depth)\n+      if (! IS_AGGR_TYPE_CODE (TREE_CODE (TREE_OPERAND (declarator, 0))))\n+\t;\n+      else if (TREE_COMPLEXITY (declarator) == current_class_depth)\n \tpop_nested_class (1);\n       return do_class_using_decl (declarator);\n     }\n@@ -1437,6 +1452,8 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n \t       because `decl_const_value' would mis-interpret it\n \t       as only meaning that this VAR_DECL is defined.  */\n \t    init = build1 (NOP_EXPR, TREE_TYPE (value), init);\n+\t  else if (current_template_parms)\n+\t    ;\n \t  else if (! TREE_CONSTANT (init))\n \t    {\n \t      /* We can allow references to things that are effectively\n@@ -1456,6 +1473,10 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n   /* The corresponding pop_obstacks is in cp_finish_decl.  */\n   push_obstacks_nochange ();\n \n+  if (current_template_parms && ! current_function_decl\n+      && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))\n+    push_template_decl (value);\n+\n   if (attrlist)\n     cplus_decl_attributes (value, TREE_PURPOSE (attrlist),\n \t\t\t   TREE_VALUE (attrlist));\n@@ -1476,7 +1497,8 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n \t      DECL_ASSEMBLER_NAME (value)\n \t\t= build_static_name (current_class_type, DECL_NAME (value));\n \t    }\n-\t  pending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n+\t  if (! current_template_parms)\n+\t    pending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n \n \t  /* Static consts need not be initialized in the class definition.  */\n \t  if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (value)))\n@@ -1495,6 +1517,8 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n \t}\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;\n+      DECL_CONTEXT (value) = current_class_type;\n+      DECL_CLASS_CONTEXT (value) = current_class_type;\n \n       cp_finish_decl (value, init, asmspec_tree, 1, flags);\n       pushdecl_class_level (value);\n@@ -1600,26 +1624,9 @@ grokbitfield (declarator, declspecs, width)\n \n   if (width != error_mark_node)\n     {\n-      /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n-      STRIP_NOPS (width);\n-\n-      /* detect invalid field size.  */\n-      if (TREE_CODE (width) == CONST_DECL)\n-\twidth = DECL_INITIAL (width);\n-      else if (TREE_READONLY_DECL_P (width))\n-\twidth = decl_constant_value (width);\n-      if (TREE_CODE (width) != INTEGER_CST)\n-\t{\n-\t  cp_error (\"structure field `%D' width not an integer constant\",\n-\t\t      value);\n-\t  DECL_INITIAL (value) = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  constant_expression_warning (width);\n-\t  DECL_INITIAL (value) = width;\n-\t  DECL_BIT_FIELD (value) = 1;\n-\t}\n+      constant_expression_warning (width);\n+      DECL_INITIAL (value) = width;\n+      DECL_BIT_FIELD (value) = 1;\n     }\n \n   DECL_IN_AGGR_P (value) = 1;\n@@ -1963,9 +1970,7 @@ tree\n constructor_name_full (thing)\n      tree thing;\n {\n-  if (TREE_CODE (thing) == UNINSTANTIATED_P_TYPE)\n-    return DECL_NAME (UPT_TEMPLATE (thing));\n-  else if (TREE_CODE (thing) == TEMPLATE_TYPE_PARM)\n+  if (TREE_CODE (thing) == TEMPLATE_TYPE_PARM)\n     thing = TYPE_NAME (thing);\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n     {\n@@ -1976,7 +1981,7 @@ constructor_name_full (thing)\n     }\n   if (TREE_CODE (thing) == TYPE_DECL\n       || (TREE_CODE (thing) == TEMPLATE_DECL\n-\t  && DECL_TEMPLATE_IS_CLASS (thing)))\n+\t  && TREE_CODE (DECL_TEMPLATE_RESULT (thing)) == TYPE_DECL))\n     thing = DECL_NAME (thing);\n   my_friendly_assert (TREE_CODE (thing) == IDENTIFIER_NODE, 197);\n   return thing;\n@@ -1996,8 +2001,7 @@ constructor_name (thing)\n   t = IDENTIFIER_TEMPLATE (thing);\n   if (!t)\n     return thing;\n-  t = TREE_PURPOSE (t);\n-  return DECL_NAME (t);\n+  return t;\n }\n \f\n /* Cache the value of this class's main virtual function table pointer\n@@ -2010,7 +2014,14 @@ setup_vtbl_ptr ()\n \n   if (base_init_expr == 0\n       && DECL_CONSTRUCTOR_P (current_function_decl))\n-    emit_base_init (current_class_type, 0);\n+    {\n+      if (current_template_parms)\n+\tadd_tree (build_min_nt\n+\t\t  (CTOR_INITIALIZER,\n+\t\t   current_member_init_list, current_base_init_list));\n+      else\n+\temit_base_init (current_class_type, 0);\n+    }\n }\n \n /* Record the existence of an addressable inline function.  */\n@@ -2431,7 +2442,7 @@ mark_vtable_entries (decl)\n       TREE_ADDRESSABLE (fn) = 1;\n       if (DECL_LANG_SPECIFIC (fn) && DECL_ABSTRACT_VIRTUAL_P (fn))\n \tTREE_OPERAND (fnaddr, 0) = fn = abort_fndecl;\n-      assemble_external (fn);\n+      mark_used (fn);\n     }\n }\n \n@@ -2701,23 +2712,28 @@ walk_sigtables (typedecl_fn, vardecl_fn)\n }\n \n /* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an\n-   inline function at end-of-file.  */\n+   inline function or template instantiation at end-of-file.  */\n \n void\n-import_export_inline (decl)\n+import_export_decl (decl)\n      tree decl;\n {\n   if (DECL_INTERFACE_KNOWN (decl))\n     return;\n \n   if (DECL_TEMPLATE_INSTANTIATION (decl))\n     {\n+      DECL_NOT_REALLY_EXTERN (decl) = 1;\n       if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n \t{\n-\t  if (flag_weak)\n-\t    DECL_WEAK (decl) = 1;\n-\t  else\n-\t    TREE_PUBLIC (decl) = 0;\n+\t  /* For now, leave vars public so multiple defs will break.  */\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    {\n+\t      if (flag_weak)\n+\t\tDECL_WEAK (decl) = 1;\n+\t      else\n+\t\tTREE_PUBLIC (decl) = 0;\n+\t    }\n \t}\n       else\n \tDECL_NOT_REALLY_EXTERN (decl) = 0;\n@@ -2767,6 +2783,7 @@ build_cleanup (decl)\n }\n \n extern int parse_time, varconst_time;\n+extern tree pending_templates;\n \n #define TIMEVAR(VAR, BODY)    \\\n do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)\n@@ -2786,6 +2803,8 @@ finish_file ()\n   tree vars;\n   int needs_cleaning = 0, needs_messing_up = 0;\n \n+  at_eof = 1;\n+\n   if (flag_detailed_statistics)\n     dump_tree_statistics ();\n \n@@ -3027,10 +3046,21 @@ finish_file ()\n   while (pending_statics)\n     {\n       tree decl = TREE_VALUE (pending_statics);\n+\n+      if (DECL_TEMPLATE_INSTANTIATION (decl)\n+\t  && ! DECL_IN_AGGR_P (decl))\n+\t{\n+\t  import_export_decl (decl);\n+\t  DECL_EXTERNAL (decl) = ! DECL_NOT_REALLY_EXTERN (decl);\n+\t}\n+\n       if (TREE_USED (decl) == 1\n \t  || TREE_READONLY (decl) == 0\n \t  || DECL_INITIAL (decl) == 0)\n-\trest_of_decl_compilation (decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), 1, 1);\n+\t{\n+\t  DECL_DEFER_OUTPUT (decl) = 0;\n+\t  rest_of_decl_compilation (decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), 1, 1);\n+\t}\n       pending_statics = TREE_CHAIN (pending_statics);\n     }\n \n@@ -3043,10 +3073,15 @@ finish_file ()\n   if (flag_handle_signatures)\n     walk_sigtables ((void (*)())0, finish_sigtable_vardecl);\n \n+  for (fnname = pending_templates; fnname; fnname = TREE_CHAIN (fnname))\n+    {\n+      tree decl = TREE_VALUE (fnname);\n+      instantiate_decl (decl);\n+    }\n   for (fnname = saved_inlines; fnname; fnname = TREE_CHAIN (fnname))\n     {\n       tree decl = TREE_VALUE (fnname);\n-      import_export_inline (decl);\n+      import_export_decl (decl);\n       if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n \t  && TREE_PUBLIC (decl) && ! DECL_WEAK (decl)\n \t  && DECL_NOT_REALLY_EXTERN (decl))\n@@ -3229,47 +3264,222 @@ reparse_absdcl_as_casts (decl, expr)\n   return expr;\n }\n \n-/* Recursive helper function for reparse_decl_as_expr.  It may be a good\n-   idea to reimplement this using an explicit stack, rather than recursion. */\n-static tree\n-reparse_decl_as_expr1 (decl)\n-     tree decl;\n+/* Given plain tree nodes for an expression, build up the full semantics. */\n+\n+tree\n+build_expr_from_tree (t)\n+     tree t;\n {\n-  switch (TREE_CODE (decl))\n+  if (t == NULL_TREE || t == error_mark_node)\n+    return t;\n+\n+  switch (TREE_CODE (t))\n     {\n     case IDENTIFIER_NODE:\n-      return do_identifier (decl);\n+      return do_identifier (t, 0);\n+\n+    case LOOKUP_EXPR:\n+      if (LOOKUP_EXPR_GLOBAL (t))\n+\treturn do_scoped_id (TREE_OPERAND (t, 0), 0);\n+      else\n+\treturn do_identifier (TREE_OPERAND (t, 0), 0);\n+\n     case INDIRECT_REF:\n       return build_x_indirect_ref\n-\t(reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)), \"unary *\");\n-    case ADDR_EXPR:\n-      return build_x_unary_op (ADDR_EXPR,\n-\t\t\t       reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)));\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)), \"unary *\");\n+\n+    case CAST_EXPR:\n+      return build_functional_cast\n+\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n+    case REINTERPRET_CAST_EXPR:\n+      return build_reinterpret_cast\n+\t(TREE_TYPE (t), build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case NEGATE_EXPR:\n     case BIT_NOT_EXPR:\n-      return build_x_unary_op (BIT_NOT_EXPR,\n-\t\t\t       reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)));\n+    case ABS_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case ADDR_EXPR:\n+    case CONVERT_EXPR:      /* Unary + */\n+      return build_x_unary_op (TREE_CODE (t),\n+\t\t\t       build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_ANDTC_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case RSHIFT_EXPR:\n+    case LSHIFT_EXPR:\n+    case RROTATE_EXPR:\n+    case LROTATE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case MEMBER_REF:\n+      return build_x_binary_op\n+\t(TREE_CODE (t), \n+\t build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 1)));\n+\n+    case DOTSTAR_EXPR:\n+      return build_m_component_ref\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 1)));\n+\n     case SCOPE_REF:\n-      return build_offset_ref (TREE_OPERAND (decl, 0), TREE_OPERAND (decl, 1));\n+      return build_offset_ref (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1));\n+\n     case ARRAY_REF:\n-      return grok_array_decl (reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)),\n-\t\t\t      TREE_OPERAND (decl, 1));\n+      if (TREE_OPERAND (t, 0) == NULL_TREE)\n+\t/* new-type-id */\n+\treturn build_parse_node (ARRAY_REF, NULL_TREE,\n+\t\t\t\t build_expr_from_tree (TREE_OPERAND (t, 1)));\n+      return grok_array_decl (build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t\t\t      build_expr_from_tree (TREE_OPERAND (t, 1)));\n+\n+    case SIZEOF_EXPR:\n+      {\n+\ttree r = build_expr_from_tree (TREE_OPERAND (t, 0));\n+\tif (TREE_CODE_CLASS (TREE_CODE (r)) != 't')\n+\t  r = TREE_TYPE (r);\n+\treturn c_sizeof (r);\n+      }\n+\n+    case MODOP_EXPR:\n+      return build_x_modify_expr\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t TREE_CODE (TREE_OPERAND (t, 1)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 2)));\n+\n+    case ARROW_EXPR:\n+      return build_x_arrow\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n+    case NEW_EXPR:\n+      return build_new\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 1)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 2)),\n+\t NEW_EXPR_USE_GLOBAL (t));\n+\n+    case DELETE_EXPR:\n+      return delete_sanity\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 1)),\n+\t DELETE_EXPR_USE_VEC (t), DELETE_EXPR_USE_GLOBAL (t));\n+\n+    case COMPOUND_EXPR:\n+      if (TREE_OPERAND (t, 1) == NULL_TREE)\n+\treturn build_x_compound_expr\n+\t  (build_expr_from_tree (TREE_OPERAND (t, 0)));\n+      else\n+\tmy_friendly_abort (42);\n+\n+    case METHOD_CALL_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == SCOPE_REF)\n+\t{\n+\t  tree ref = TREE_OPERAND (t, 0);\n+\t  return build_scoped_method_call\n+\t    (build_expr_from_tree (TREE_OPERAND (t, 1)),\n+\t     build_expr_from_tree (TREE_OPERAND (ref, 0)),\n+\t     TREE_OPERAND (ref, 1),\n+\t     build_expr_from_tree (TREE_OPERAND (t, 2)));\n+\t}\n+      return build_method_call\n+\t(build_expr_from_tree (TREE_OPERAND (t, 1)),\n+\t TREE_OPERAND (t, 0),\n+\t build_expr_from_tree (TREE_OPERAND (t, 2)),\n+\t NULL_TREE, LOOKUP_NORMAL);\n+\n+    case CALL_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == SCOPE_REF)\n+\t{\n+\t  tree ref = TREE_OPERAND (t, 0);\n+\t  return build_member_call\n+\t    (build_expr_from_tree (TREE_OPERAND (ref, 0)),\n+\t     TREE_OPERAND (ref, 1),\n+\t     build_expr_from_tree (TREE_OPERAND (t, 1)));\n+\t}\n+      else\n+\t{\n+\t  tree name = TREE_OPERAND (t, 0);\n+\t  if (! really_overloaded_fn (name))\n+\t    name = build_expr_from_tree (name);\n+\t  return build_x_function_call\n+\t    (name, build_expr_from_tree (TREE_OPERAND (t, 1)),\n+\t     current_class_decl);\n+\t}\n+\n+    case COND_EXPR:\n+      return build_x_conditional_expr\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 1)),\n+\t build_expr_from_tree (TREE_OPERAND (t, 2)));\n+\n+    case TREE_LIST:\n+      {\n+\ttree purpose, value, chain;\n+\n+\tif (t == void_list_node)\n+\t  return t;\n+\n+\tpurpose = TREE_PURPOSE (t);\n+\tif (purpose)\n+\t  purpose = build_expr_from_tree (purpose);\n+\tvalue = TREE_VALUE (t);\n+\tif (value)\n+\t  value = build_expr_from_tree (value);\n+\tchain = TREE_CHAIN (t);\n+\tif (chain && chain != void_type_node)\n+\t  chain = build_expr_from_tree (chain);\n+\treturn tree_cons (purpose, value, chain);\n+      }\n+\n+    case COMPONENT_REF:\n+      return build_component_ref\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t TREE_OPERAND (t, 1), NULL_TREE, 1);\n+\n     default:\n-      my_friendly_abort (5);\n-      return NULL_TREE;\n+      return t;\n     }\n }\n \n /* This is something of the form `int (*a)++' that has turned out to be an\n    expr.  It was only converted into parse nodes, so we need to go through\n    and build up the semantics.  Most of the work is done by\n-   reparse_decl_as_expr1, above.\n+   build_expr_from_tree, above.\n \n    In the above example, TYPE is `int' and DECL is `*a'.  */\n tree\n reparse_decl_as_expr (type, decl)\n      tree type, decl;\n {\n-  decl = reparse_decl_as_expr1 (decl);\n+  decl = build_expr_from_tree (decl);\n   if (type)\n     return build_functional_cast (type, build_tree_list (NULL_TREE, decl));\n   else\n@@ -3319,20 +3529,13 @@ check_cp_case_value (value)\n   if (value == NULL_TREE)\n     return value;\n \n-  /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-     Strip such NOP_EXPRs.  */\n-  if (TREE_CODE (value) == NOP_EXPR\n-      && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n-    value = TREE_OPERAND (value, 0);\n+  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n+  STRIP_TYPE_NOPS (value);\n \n   if (TREE_READONLY_DECL_P (value))\n     {\n       value = decl_constant_value (value);\n-      /* build_c_cast puts on a NOP_EXPR to make a non-lvalue.\n-\t Strip such NOP_EXPRs.  */\n-      if (TREE_CODE (value) == NOP_EXPR\n-\t  && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n-\tvalue = TREE_OPERAND (value, 0);\n+      STRIP_TYPE_NOPS (value);\n     }\n   value = fold (value);\n \n@@ -3431,7 +3634,7 @@ do_class_using_decl (decl)\n       return NULL_TREE;\n     }\n \n-  value = build_lang_field_decl (USING_DECL, name, unknown_type_node);\n+  value = build_lang_field_decl (USING_DECL, name, void_type_node);\n   DECL_INITIAL (value) = TREE_OPERAND (decl, 0);\n   return value;\n }\n@@ -3466,5 +3669,9 @@ mark_used (decl)\n      tree decl;\n {\n   TREE_USED (decl) = 1;\n+  if (current_template_parms)\n+    return;\n   assemble_external (decl);\n+  if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n+    instantiate_decl (decl);\n }"}, {"sha": "3c1d9a2e959bd1c6b85c9260303e326232887666", "filename": "gcc/cp/error.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -212,11 +212,6 @@ dump_type (t, v)\n       OB_PUTID (TYPE_IDENTIFIER (t));\n       break;\n \n-    case UNINSTANTIATED_P_TYPE:\n-      OB_PUTID (DECL_NAME (UPT_TEMPLATE (t)));\n-      OB_PUTS (\"<...>\");\n-      break;\n-\n       /* This is not always necessary for pointers and such, but doing this\n \t reduces code size.  */\n     case ARRAY_TYPE:\n@@ -230,6 +225,13 @@ dump_type (t, v)\n       dump_type_suffix (t, v);\n       break;\n \n+    case TYPENAME_TYPE:\n+      OB_PUTS (\"typename \");\n+      dump_type (TYPE_CONTEXT (t), 0);\n+      OB_PUTS (\"::\");\n+      OB_PUTID (TYPE_IDENTIFIER (t));\n+      break;\n+\n     default:\n       sorry (\"`%s' not supported by dump_type\",\n \t     tree_code_name[(int) TREE_CODE (t)]);\n@@ -422,10 +424,10 @@ dump_type_prefix (t, v)\n     case TREE_LIST:\n     case TYPE_DECL:\n     case TREE_VEC:\n-    case UNINSTANTIATED_P_TYPE:\n     case UNION_TYPE:\n     case UNKNOWN_TYPE:\n     case VOID_TYPE:\n+    case TYPENAME_TYPE:\n       dump_type (t, v);\n       break;\n       \n@@ -494,10 +496,10 @@ dump_type_suffix (t, v)\n     case TREE_LIST:\n     case TYPE_DECL:\n     case TREE_VEC:\n-    case UNINSTANTIATED_P_TYPE:\n     case UNION_TYPE:\n     case UNKNOWN_TYPE:\n     case VOID_TYPE:\n+    case TYPENAME_TYPE:\n       break;\n \n     default:\n@@ -711,11 +713,8 @@ dump_decl (t, v)\n \t  OB_UNPUT (2);\n \tOB_PUTC2 ('>', ' ');\n \n-\tif (DECL_TEMPLATE_IS_CLASS (t))\n-\t  {\n-\t    OB_PUTS (\"class \");\n-\t    OB_PUTID (DECL_NAME (t));\n-\t  }\n+\tif (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n+\t  dump_type (TREE_TYPE (t), v);\n \telse switch (NEXT_CODE (t))\n \t  {\n \t  case METHOD_TYPE:\n@@ -734,7 +733,8 @@ dump_decl (t, v)\n       break;\n \n     case CONST_DECL:\n-      if (NEXT_CODE (t) == ENUMERAL_TYPE)\n+      if (NEXT_CODE (t) == ENUMERAL_TYPE\n+\t  || TREE_CODE (DECL_INITIAL (t)) == TEMPLATE_CONST_PARM)\n \tgoto general;\n       else\n \tdump_expr (DECL_INITIAL (t), 0);\n@@ -1262,6 +1262,27 @@ dump_expr (t, nop)\n \tbreak;\n       }\n \n+    case TEMPLATE_CONST_PARM:\n+      {\n+\ttree r = TREE_VEC_ELT (TREE_VALUE (current_template_parms),\n+\t\t\t       TEMPLATE_CONST_IDX (t));\n+\tdump_decl (TREE_VALUE (r), -1);\n+\tbreak;\n+      }\n+\n+    case IDENTIFIER_NODE:\n+      OB_PUTID (t);\n+      break;\n+\n+    case SCOPE_REF:\n+      dump_type (TREE_OPERAND (t, 0), 0);\n+      OB_PUTS (\"::\");\n+      dump_expr (TREE_OPERAND (t, 1), 0);\n+      break;\n+\n+    case CAST_EXPR:\n+      break;\t\t\t/* XXX */\n+\n     case TREE_LIST:\n       if (TREE_VALUE (t) && TREE_CODE (TREE_VALUE (t)) == FUNCTION_DECL)\n \t{\n@@ -1312,8 +1333,8 @@ dump_unary_op (opstring, t, nop)\n }\n \n char *\n-fndecl_as_string (cname, fndecl, print_ret_type_p)\n-     tree cname, fndecl;\n+fndecl_as_string (fndecl, print_ret_type_p)\n+     tree fndecl;\n      int print_ret_type_p;\n {\n   return decl_as_string (fndecl, print_ret_type_p);\n@@ -1389,12 +1410,7 @@ cp_line_of (t)\n     t = TREE_TYPE (t);\n \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n-    {\n-      if (IS_AGGR_TYPE (t))\n-\tline = CLASSTYPE_SOURCE_LINE (t);\n-      else\n-\tline = DECL_SOURCE_LINE (TYPE_NAME (t));\n-    }\n+    line = DECL_SOURCE_LINE (TYPE_NAME (t));\n   else\n     line = DECL_SOURCE_LINE (t);\n "}, {"sha": "71421ccc8faeb59ba3d153b2eb76878191160ecc", "filename": "gcc/cp/except.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -37,6 +37,7 @@ tree protect_list;\n \n extern void (*interim_eh_hook)\tPROTO((tree));\n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n+static void end_eh_unwinder PROTO((rtx));\n \n /* holds the fndecl for __builtin_return_address () */\n tree builtin_return_address_fndecl;\n@@ -90,8 +91,6 @@ output_exception_table_entry (file, start_label, end_label, eh_label)\n      FILE *file;\n      rtx start_label, end_label, eh_label;\n {\n-  char label[100];\n-\n   assemble_integer (start_label, GET_MODE_SIZE (Pmode), 1);\n   assemble_integer (end_label, GET_MODE_SIZE (Pmode), 1);\n   assemble_integer (eh_label, GET_MODE_SIZE (Pmode), 1);\n@@ -146,7 +145,7 @@ asm (TEXT_SECTION_ASM_OP);\n \n #endif\n \n-void\n+static void\n exception_section ()\n {\n #ifdef ASM_OUTPUT_SECTION_NAME\n@@ -320,15 +319,15 @@ struct ehQueue {\n    ========================================================================= */\n \n /* Holds the pc for doing \"throw\" */\n-tree saved_pc;\n+static tree saved_pc;\n /* Holds the type of the thing being thrown. */\n-tree saved_throw_type;\n+static tree saved_throw_type;\n /* Holds the value being thrown.  */\n-tree saved_throw_value;\n+static tree saved_throw_value;\n /* Holds the cleanup for the value being thrown.  */\n-tree saved_cleanup;\n+static tree saved_cleanup;\n \n-int throw_used;\n+static int throw_used;\n \n static rtx catch_clauses;\n \n@@ -454,7 +453,8 @@ top_label_entry (labelstack)\n /* Push to permanent obstack for rtl generation.\n    One level only!  */\n static struct obstack *saved_rtl_obstack;\n-void\n+\n+static void\n push_rtl_perm ()\n {\n   extern struct obstack permanent_obstack;\n@@ -468,9 +468,7 @@ push_rtl_perm ()\n static void\n pop_rtl_from_perm ()\n {\n-  extern struct obstack permanent_obstack;\n   extern struct obstack *rtl_obstack;\n-  \n   rtl_obstack = saved_rtl_obstack;\n }\n \n@@ -587,7 +585,7 @@ new_eh_stack (stack)\n }\n \n /* cheesyness to save some typing. returns the return value rtx */\n-rtx\n+static rtx\n do_function_call (func, params, return_type)\n      tree func, params, return_type;\n {\n@@ -603,8 +601,6 @@ static void\n expand_internal_throw (pc)\n      rtx pc;\n {\n-  tree params;\n-\n   emit_move_insn (DECL_RTL (saved_pc), pc);\n #ifdef JUMP_TO_THROW\n   emit_indirect_jump (gen_rtx (SYMBOL_REF, Pmode, \"__throw\"));\n@@ -616,7 +612,7 @@ expand_internal_throw (pc)\n \n /* ========================================================================= */\n \n-void\n+static void\n lang_interim_eh (finalization)\n      tree finalization;\n {\n@@ -946,7 +942,7 @@ build_eh_type (exp)\n }\n \n /* This routine creates the cleanup for the exception handling object.  */\n-void\n+static void\n push_eh_cleanup ()\n {\n   /* All cleanups must last longer than normal.  */\n@@ -973,7 +969,6 @@ expand_start_catch_block (declspecs, declarator)\n   rtx protect_label_rtx;\n   tree decl = NULL_TREE;\n   tree init;\n-  tree cleanup;\n \n   if (! doing_eh (1))\n     return;\n@@ -1243,7 +1238,7 @@ do_unwind (inner_throw_label)\n /* Given the return address, compute the new pc to throw.  This has to\n    work for the current frame of the current function, and the one\n    above it in the case of throw.  */\n-rtx\n+static rtx\n eh_outer_context (addr)\n      rtx addr;\n {\n@@ -1306,8 +1301,6 @@ expand_builtin_throw ()\n   rtx return_val_rtx;\n   rtx gotta_rethrow_it;\n   rtx gotta_call_terminate;\n-  rtx unwind_and_throw;\n-  rtx goto_unwind_and_throw;\n   rtx top_of_loop;\n   rtx unwind_first;\n   tree t;\n@@ -1331,8 +1324,6 @@ expand_builtin_throw ()\n \n   gotta_rethrow_it = gen_label_rtx ();\n   gotta_call_terminate = gen_label_rtx ();\n-  unwind_and_throw = gen_label_rtx ();\n-  goto_unwind_and_throw = gen_label_rtx ();\n   top_of_loop = gen_label_rtx ();\n   unwind_first = gen_label_rtx ();\n \n@@ -1421,7 +1412,7 @@ expand_start_eh_spec ()\n   start_protect ();\n }\n \n-void\n+static void\n expand_end_eh_spec (raises)\n      tree raises;\n {\n@@ -1771,7 +1762,6 @@ emit_exception_table ()\n   int count = 0;\n   extern FILE *asm_out_file;\n   struct ehEntry *entry;\n-  tree eh_node_decl;\n \n   if (! doing_eh (0))\n     return;\n@@ -1826,11 +1816,13 @@ build_throw (e)\n   return e;\n }\n \n+void\n start_eh_unwinder ()\n {\n   start_protect ();\n }\n \n+static void\n end_eh_unwinder (end)\n      rtx end;\n {"}, {"sha": "fc59cb6cfa210b6fb4af25c0f99d9d15bb596aa4", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -359,3 +359,85 @@ extract_init (decl, init)\n   return 1;\n #endif\n }\n+\n+void\n+do_case (start, end)\n+     tree start, end;\n+{\n+  tree value1 = NULL_TREE, value2 = NULL_TREE, label;\n+\n+  if (end && pedantic)\n+    pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n+\n+  if (current_template_parms)\n+    {\n+      add_tree (build_min_nt (CASE_LABEL, start, end));\n+      return;\n+    }\n+\n+  if (start)\n+    value1 = check_cp_case_value (start);\n+  if (end)\n+    value2 = check_cp_case_value (end);\n+  \n+  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\n+  if (value1 != error_mark_node\n+      && value2 != error_mark_node)\n+    {\n+      tree duplicate;\n+      int success;\n+\n+      if (end)\n+\tsuccess = pushcase_range (value1, value2, convert_and_check,\n+\t\t\t\t  label, &duplicate);\n+      else if (start)\n+\tsuccess = pushcase (value1, convert_and_check, label, &duplicate);\n+      else\n+\tsuccess = pushcase (NULL_TREE, 0, label, &duplicate);\n+\n+      if (success == 1)\n+\t{\n+\t  if (end)\n+\t    error (\"case label not within a switch statement\");\n+\t  else if (start)\n+\t    cp_error (\"case label `%E' not within a switch statement\", start);\n+\t  else\n+\t    error (\"default label not within a switch statement\");\n+\t}\n+      else if (success == 2)\n+\t{\n+\t  if (end)\n+\t    {\n+\t      error (\"duplicate (or overlapping) case value\");\n+\t      cp_error_at (\"this is the first entry overlapping that value\",\n+\t\t\t   duplicate);\n+\t    }\n+\t  else if (start)\n+\t    {\n+\t      cp_error (\"duplicate case value `%E'\", start);\n+\t      cp_error_at (\"previously used here\", duplicate);\n+\t    }\n+\t  else\n+\t    {\n+\t      error (\"multiple default labels in one switch\");\n+\t      cp_error_at (\"this is the first default label\", duplicate);\n+\t    }\n+\t}\n+      else if (success == 3)\n+\twarning (\"case value out of range\");\n+      else if (success == 4)\n+\twarning (\"empty range specified\");\n+      else if (success == 5)\n+\t{\n+\t  if (end)\n+\t    error (\"case label within scope of cleanup or variable array\");\n+\t  else\n+\t    cp_error (\"case label `%E' within scope of cleanup or variable array\", start);\n+\t}\n+    }\n+  if (start)\n+    define_case_label (label);\n+  else\n+    define_case_label (NULL_TREE);\n+}"}, {"sha": "036fe27fbd4db600ccc4ea68e6f7f0ae81a8737a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 55, "deletions": 32, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -52,8 +52,6 @@ void expand_member_init ();\n void expand_aggr_init ();\n \n static void expand_aggr_init_1 ();\n-static void expand_recursive_init_1 ();\n-static void expand_recursive_init ();\n static void expand_virtual_init PROTO((tree, tree));\n tree expand_vec_init ();\n \n@@ -70,7 +68,7 @@ static tree minus_one;\n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n \n-tree BI_header_type, BI_header_size;\n+static tree BI_header_type, BI_header_size;\n \n void init_init_processing ()\n {\n@@ -257,9 +255,8 @@ static tree\n sort_member_init (t)\n      tree t;\n {\n-  tree x, member, name, field, init;\n+  tree x, member, name, field;\n   tree init_list = NULL_TREE;\n-  tree fields_to_unmark = NULL_TREE;\n   int last_pos = 0;\n   tree last_field;\n \n@@ -281,6 +278,8 @@ sort_member_init (t)\n \t  name = TREE_PURPOSE (x);\n \n #if 0\n+\t  /* This happens in templates, since the IDENTIFIER is replaced\n+             with the COMPONENT_REF in tsubst_expr.  */\n \t  field = (TREE_CODE (name) == COMPONENT_REF\n \t\t   ? TREE_OPERAND (name, 1) : IDENTIFIER_CLASS_VALUE (name));\n #else\n@@ -520,9 +519,7 @@ emit_base_init (t, immediately)\n      tree t;\n      int immediately;\n {\n-  extern tree in_charge_identifier;\n-\n-  tree member, x;\n+  tree member;\n   tree mem_init_list;\n   tree rbase_init_list, vbase_init_list;\n   tree t_binfo = TYPE_BINFO (t);\n@@ -571,7 +568,6 @@ emit_base_init (t, immediately)\n   /* Now, perform initialization of non-virtual base classes.  */\n   for (i = 0; i < n_baseclasses; i++)\n     {\n-      tree base = current_class_decl;\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       tree init = void_list_node;\n \n@@ -653,10 +649,15 @@ emit_base_init (t, immediately)\n \t  init = TREE_VALUE (mem_init_list);\n \t  from_init_list = 1;\n \n+#if 0\n+\t  if (TREE_CODE (name) == COMPONENT_REF)\n+\t    name = DECL_NAME (TREE_OPERAND (name, 1));\n+#else\n \t  /* Also see if it's ever a COMPONENT_REF here.  If it is, we\n \t     need to do `expand_assignment (name, init, 0, 0);' and\n \t     a continue.  */\n \t  my_friendly_assert (TREE_CODE (name) != COMPONENT_REF, 349);\n+#endif\n \t}\n       else\n \t{\n@@ -993,7 +994,7 @@ expand_member_init (exp, name, init)\n \t  else\n \t    {\n \t      if (basetype != type\n-\t\t  && ! binfo_member (basetype, TYPE_BINFO (type))\n+\t\t  && ! vec_binfo_member (basetype, TYPE_BINFO_BASETYPES (type))\n \t\t  && ! binfo_member (basetype, CLASSTYPE_VBASECLASSES (type)))\n \t\t{\n \t\t  if (IDENTIFIER_CLASS_VALUE (name))\n@@ -1783,6 +1784,9 @@ build_offset_ref (type, name)\n   tree basetypes = NULL_TREE;\n   int dtor = 0;\n \n+  if (current_template_parms)\n+    return build_min_nt (SCOPE_REF, type, name);\n+\n   /* Handle namespace names fully here.  */\n   if (TREE_CODE (type) == IDENTIFIER_NODE\n       && get_aggr_from_typedef (type, 0) == 0)\n@@ -1813,7 +1817,10 @@ build_offset_ref (type, name)\n \n   if (TYPE_SIZE (type) == 0)\n     {\n-      t = IDENTIFIER_CLASS_VALUE (name);\n+      if (type == current_class_type)\n+\tt = IDENTIFIER_CLASS_VALUE (name);\n+      else\n+\tt = NULL_TREE;\n       if (t == 0)\n \t{\n \t  cp_error (\"incomplete type `%T' does not have member `%D'\", type,\n@@ -2190,12 +2197,12 @@ is_friend (type, supplicant)\n \t  if (name == TREE_PURPOSE (list))\n \t    {\n \t      tree friends = TREE_VALUE (list);\n-\t      name = DECL_ASSEMBLER_NAME (supplicant);\n \t      for (; friends ; friends = TREE_CHAIN (friends))\n \t\t{\n \t\t  if (ctype == TREE_PURPOSE (friends))\n \t\t    return 1;\n-\t\t  if (name == DECL_ASSEMBLER_NAME (TREE_VALUE (friends)))\n+\t\t  if (comptypes (TREE_TYPE (supplicant),\n+\t\t\t\t TREE_TYPE (TREE_VALUE (friends)), 1))\n \t\t    return 1;\n \t\t}\n \t      break;\n@@ -2401,10 +2408,11 @@ make_friend_class (type, friend_type)\n    QUALS say what special qualifies should apply to the object\n    pointed to by `this'.  */\n tree\n-do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n+do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n      tree ctype, declarator, decl, parmdecls;\n      enum overload_flags flags;\n      tree quals;\n+     int funcdef_flag;\n {\n   /* Every decl that gets here is a friend of something.  */\n   DECL_FRIEND_P (decl) = 1;\n@@ -2424,7 +2432,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n \t  /* This will set up DECL_ARGUMENTS for us.  */\n \t  grokclassfn (ctype, cname, decl, flags, quals);\n \t  if (TYPE_SIZE (ctype) != 0)\n-\t    check_classfn (ctype, cname, decl);\n+\t    check_classfn (ctype, decl);\n \n \t  if (TREE_TYPE (decl) != error_mark_node)\n \t    {\n@@ -2492,7 +2500,8 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n \t= build_decl_overload (declarator, TYPE_ARG_TYPES (TREE_TYPE (decl)),\n \t\t\t       TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n       DECL_ARGUMENTS (decl) = parmdecls;\n-      DECL_CLASS_CONTEXT (decl) = current_class_type;\n+      if (funcdef_flag)\n+\tDECL_CLASS_CONTEXT (decl) = current_class_type;\n \n       /* We can call pushdecl here, because the TREE_CHAIN of this\n \t FUNCTION_DECL is not needed for other purposes.  */\n@@ -2639,6 +2648,11 @@ build_new (placement, decl, init, use_global_new)\n \t    {\n \t      if (this_nelts == NULL_TREE)\n \t\terror (\"new of array type fails to specify size\");\n+\t      else if (current_template_parms)\n+\t\t{\n+\t\t  nelts = this_nelts;\n+\t\t  absdcl = TREE_OPERAND (absdcl, 0);\n+\t\t}\n \t      else\n \t\t{\n \t\t  this_nelts = save_expr (convert (sizetype, this_nelts));\n@@ -2704,6 +2718,21 @@ build_new (placement, decl, init, use_global_new)\n       decl = TYPE_NAME (type);\n     }\n \n+  if (current_template_parms)\n+    {\n+      tree t;\n+      if (has_array)\n+\tt = min_tree_cons (min_tree_cons (NULL_TREE, type, NULL_TREE),\n+\t\t\t   build_min_nt (ARRAY_REF, NULL_TREE, nelts),\n+\t\t\t   NULL_TREE);\n+      else\n+\tt = type;\n+\t\n+      rval = build_min_nt (NEW_EXPR, placement, t, init);\n+      NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n+      return rval;\n+    }\n+\n   /* ``A reference cannot be created by the new operator.  A reference\n      is not an object (8.2.2, 8.4.3), so a pointer to it could not be\n      returned by new.'' ARM 5.3.3 */\n@@ -2740,6 +2769,13 @@ build_new (placement, decl, init, use_global_new)\n       nelts = build_binary_op (MULT_EXPR, nelts, this_nelts, 1);\n       true_type = TREE_TYPE (true_type);\n     }\n+\n+  if (TYPE_SIZE (complete_type (true_type)) == 0)\n+    {\n+      incomplete_type_error (0, true_type);\n+      return error_mark_node;\n+    }\n+\n   if (has_array)\n     size = fold (build_binary_op (MULT_EXPR, size_in_bytes (true_type),\n \t\t\t\t  nelts, 1));\n@@ -2752,12 +2788,6 @@ build_new (placement, decl, init, use_global_new)\n       return error_mark_node;\n     }\n \n-  if (TYPE_SIZE (true_type) == 0)\n-    {\n-      incomplete_type_error (0, true_type);\n-      return error_mark_node;\n-    }\n-\n   if (TYPE_LANG_SPECIFIC (true_type)\n       && CLASSTYPE_ABSTRACT_VIRTUALS (true_type))\n     {\n@@ -3473,7 +3503,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      if (TYPE_SIZE (type) == 0)\n+      if (TYPE_SIZE (complete_type (type)) == 0)\n \t{\n \t  incomplete_type_error (0, type);\n \t  return error_mark_node;\n@@ -3505,7 +3535,6 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  return error_mark_node;\n \t}\n       return build_vec_delete (addr, array_type_nelts (type),\n-\t\t\t       c_sizeof_nowarn (TREE_TYPE (type)),\n \t\t\t       auto_delete, integer_two_node,\n \t\t\t       use_global_delete);\n     }\n@@ -3718,12 +3747,6 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t       || (TREE_VIA_VIRTUAL (base_binfo) == 0\n \t\t   && ! TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo))))\n \t{\n-\t  tree virtual_size;\n-\n-\t  /* This is probably wrong. It should be the size of the virtual\n-\t     object being deleted.  */\n-\t  virtual_size = c_sizeof_nowarn (type);\n-\n \t  cond = build (COND_EXPR, void_type_node,\n \t\t\tbuild (BIT_AND_EXPR, integer_type_node, auto_delete, integer_one_node),\n \t\t\tbuild_builtin_call (void_type_node, BID,\n@@ -3834,9 +3857,9 @@ build_vbase_delete (type, decl)\n    confirm the size, and trap if the numbers differ; not clear that it'd\n    be worth bothering.)  */\n tree\n-build_vec_delete (base, maxindex, elt_size, auto_delete_vec, auto_delete,\n+build_vec_delete (base, maxindex, auto_delete_vec, auto_delete,\n \t\t  use_global_delete)\n-     tree base, maxindex, elt_size;\n+     tree base, maxindex;\n      tree auto_delete_vec, auto_delete;\n      int use_global_delete;\n {"}, {"sha": "17cdef0abff9e8bba2c1a589d4a14c1de7e5c8ee", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 145, "deletions": 202, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -47,12 +47,11 @@ Boston, MA 02111-1307, USA.  */\n #ifndef errno\n extern int errno;\t\t/* needed for VAX.  */\n #endif\n-extern jmp_buf toplevel;\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-extern struct obstack *expression_obstack, permanent_obstack;\n+extern struct obstack permanent_obstack;\n extern struct obstack *current_obstack, *saveable_obstack;\n \n extern double atof ();\n@@ -68,20 +67,11 @@ extern char *get_directive_line ();\t/* In c-common.c */\n \n extern char *index ();\n extern char *rindex ();\n-\n-void extract_interface_info ();\n void yyerror ();\n \n /* This obstack is needed to hold text.  It is not safe to use\n    TOKEN_BUFFER because `check_newline' calls `yylex'.  */\n struct obstack inline_text_obstack;\n-static char *inline_text_firstobj;\n-\n-/* This obstack is used to hold information about methods to be\n-   synthesized.  It should go away when synthesized methods are handled\n-   properly (i.e. only when needed).  */\n-struct obstack synth_obstack;\n-static char *synth_firstobj;\n \n int end_of_file;\n \n@@ -136,16 +126,8 @@ static tree get_time_identifier ();\n static tree filename_times;\n static tree this_filename_time;\n \n-/* For implementing #pragma unit.  */\n-tree current_unit_name;\n-tree current_unit_language;\n-\n /* Array for holding counts of the numbers of tokens seen.  */\n extern int *token_count;\n-\n-/* Textual definition used for default functions.  */\n-static void default_copy_constructor_body ();\n-static void default_assign_ref_body ();\n \f\n /* Return something to represent absolute declarators containing a *.\n    TARGET is the absolute declarator that the * contains.\n@@ -399,6 +381,8 @@ reinit_lang_specific ()\n   reinit_search_statistics ();\n }\n \n+int *init_parse ();\n+\n void\n init_lex ()\n {\n@@ -571,9 +555,6 @@ init_lex ()\n   init_method ();\n   init_error ();\n   gcc_obstack_init (&inline_text_obstack);\n-  inline_text_firstobj = (char *) obstack_alloc (&inline_text_obstack, 0);\n-  gcc_obstack_init (&synth_obstack);\n-  synth_firstobj = (char *) obstack_alloc (&synth_obstack, 0);\n \n   /* Start it at 0, because check_newline is called at the very beginning\n      and will increment it to 1.  */\n@@ -877,7 +858,10 @@ yyprint (file, yychar, yylval)\n     }\n }\n \n+#if defined(GATHER_STATISTICS) && defined(REDUCE_LENGTH)\n static int *reduce_count;\n+#endif\n+\n int *token_count;\n \n #if 0\n@@ -1037,8 +1021,7 @@ extract_interface_info ()\n     fileinfo = get_time_identifier (input_filename);\n   fileinfo = IDENTIFIER_CLASS_VALUE (fileinfo);\n   interface_only = TREE_INT_CST_LOW (fileinfo);\n-  if (!processing_template_defn || flag_external_templates)\n-    interface_unknown = TREE_INT_CST_HIGH (fileinfo);\n+  interface_unknown = TREE_INT_CST_HIGH (fileinfo);\n }\n \n /* Return nonzero if S is not considered part of an\n@@ -1118,6 +1101,7 @@ void\n do_pending_inlines ()\n {\n   struct pending_inline *t;\n+  tree context;\n \n   /* Oops, we're still dealing with the last batch.  */\n   if (yychar == PRE_PARSED_FUNCTION_DECL)\n@@ -1144,10 +1128,9 @@ do_pending_inlines ()\n     return;\n \t    \n   /* Now start processing the first inline function.  */\n-  my_friendly_assert ((t->parm_vec == NULL_TREE) == (t->bindings == NULL_TREE),\n-\t\t      226);\n-  if (t->parm_vec)\n-    push_template_decls (t->parm_vec, t->bindings, 0);\n+  context = decl_function_context (t->fndecl);\n+  if (context)\n+    push_cp_function_context (context);\n   if (t->len > 0)\n     {\n       feed_input (t->buf, t->len, t->can_free ? &inline_text_obstack : 0);\n@@ -1169,13 +1152,6 @@ do_pending_inlines ()\n   /* Pass back a handle on the rest of the inline functions, so that they\n      can be processed later.  */\n   yylval.ttype = build_tree_list ((tree) t, t->fndecl);\n-#if 0\n-  if (flag_default_inline && t->fndecl\n-      /* If we're working from a template, don't change\n-\t the `inline' state.  */\n-      && t->parm_vec == NULL_TREE)\n-    DECL_INLINE (t->fndecl) = 1;\n-#endif\n   DECL_PENDING_INLINE_INFO (t->fndecl) = 0;\n }\n \n@@ -1189,11 +1165,11 @@ void\n process_next_inline (t)\n      tree t;\n {\n+  tree context;\n   struct pending_inline *i = (struct pending_inline *) TREE_PURPOSE (t);\n-  my_friendly_assert ((i->parm_vec == NULL_TREE) == (i->bindings == NULL_TREE),\n-\t\t      227);\n-  if (i->parm_vec)\n-    pop_template_decls (i->parm_vec, i->bindings, 0);\n+  context = decl_function_context (i->fndecl);\n+  if (context)\n+    pop_cp_function_context (context);\n   i = i->next;\n   if (yychar == YYEMPTY)\n     yychar = yylex ();\n@@ -1215,22 +1191,14 @@ process_next_inline (t)\n   to_be_restored = 0;\n   if (i && i->fndecl != NULL_TREE)\n     {\n-      my_friendly_assert ((i->parm_vec == NULL_TREE) == (i->bindings == NULL_TREE),\n-\t\t\t  228);\n-      if (i->parm_vec)\n-\tpush_template_decls (i->parm_vec, i->bindings, 0);\n+      context = decl_function_context (i->fndecl);\n+      if (context)\n+\tpush_cp_function_context (context);\n       feed_input (i->buf, i->len, i->can_free ? &inline_text_obstack : 0);\n       lineno = i->lineno;\n       input_filename = i->filename;\n       yychar = PRE_PARSED_FUNCTION_DECL;\n       yylval.ttype = build_tree_list ((tree) i, i->fndecl);\n-#if 0\n-      if (flag_default_inline\n-\t  /* If we're working from a template, don't change\n-\t     the `inline' state.  */\n-\t  && i->parm_vec == NULL_TREE)\n-\tDECL_INLINE (i->fndecl) = 1;\n-#endif\n       DECL_PENDING_INLINE_INFO (i->fndecl) = 0;\n     }\n   if (i)\n@@ -1388,99 +1356,19 @@ yyungetc (ch, rescan)\n /* This function stores away the text for an inline function that should\n    be processed later.  It decides how much later, and may need to move\n    the info between obstacks; therefore, the caller should not refer to\n-   the T parameter after calling this function.\n-\n-   This function also stores the list of template-parameter bindings that\n-   will be needed for expanding the template, if any.  */\n+   the T parameter after calling this function.  */\n \n static void\n store_pending_inline (decl, t)\n      tree decl;\n      struct pending_inline *t;\n {\n-  extern int processing_template_defn;\n-  int delay_to_eof = 0;\n-  struct pending_inline **inlines;\n-\n   t->fndecl = decl;\n-  /* Default: compile right away, and no extra bindings are needed.  */\n-  t->parm_vec = t->bindings = 0;\n-  if (processing_template_defn)\n-    {\n-      tree type = current_class_type;\n-      /* Assumption: In this (possibly) nested class sequence, only\n-\t one name will have template parms.  */\n-      while (type && TREE_CODE_CLASS (TREE_CODE (type)) == 't')\n-\t{\n-\t  tree decl = TYPE_NAME (type);\n-\t  tree tmpl = IDENTIFIER_TEMPLATE (DECL_NAME (decl));\n-\t  if (tmpl)\n-\t    {\n-\t      t->parm_vec = DECL_TEMPLATE_INFO (TREE_PURPOSE (tmpl))->parm_vec;\n-\t      t->bindings = TREE_VALUE (tmpl);\n-\t    }\n-\t  type = DECL_CONTEXT (decl);\n-\t}\n-      if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n-\t  || TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\t    my_friendly_assert (TYPE_MAX_VALUE (TREE_TYPE (decl)) == current_class_type,\n-\t\t\t\t233);\n-\n-\t  /* Inline functions can be compiled immediately.  Other functions\n-\t     will be output separately, so if we're in interface-only mode,\n-\t     punt them now, or output them now if we're doing implementations\n-\t     and we know no overrides will exist.  Otherwise, we delay until\n-\t     end-of-file, to see if the definition is really required.  */\n-\t  if (DECL_THIS_INLINE (decl))\n-\t    /* delay_to_eof == 0 */;\n-\t  else if (current_class_type && !interface_unknown)\n-\t    {\n-\t      if (interface_only)\n-\t\t{\n-#if 0\n-\t\t  print_node_brief (stderr, \"\\ndiscarding text for \", decl, 0);\n-#endif\n-\t\t  if (t->can_free)\n-\t\t    obstack_free (&inline_text_obstack, t->buf);\n-\t\t  DECL_PENDING_INLINE_INFO (decl) = 0;\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  /* Don't delay the processing of virtual functions.  */\n-\t  else if (DECL_VINDEX (decl) == NULL_TREE)\n-\t    delay_to_eof = 1;\n-\t}\n-      else\n-\tmy_friendly_abort (58);\n-    }\n-\n-  if (delay_to_eof)\n-    {\n-      extern struct pending_inline *pending_template_expansions;\n-\n-      if (t->can_free)\n-\t{\n-\t  char *free_to = t->buf;\n-\t  t->buf = (char *) obstack_copy (&permanent_obstack, t->buf,\n-\t\t\t\t\t  t->len + 1);\n-\t  t = (struct pending_inline *) obstack_copy (&permanent_obstack, \n-\t\t\t\t\t\t      (char *)t, sizeof (*t));\n-\t  obstack_free (&inline_text_obstack, free_to);\n-\t}\n-      inlines = &pending_template_expansions;\n-      t->can_free = 0;\n-    }\n-  else\n-    {\n-      inlines = &pending_inlines;\n-      DECL_PENDING_INLINE_INFO (decl) = t;\n-    }\n+  DECL_PENDING_INLINE_INFO (decl) = t;\n \n   /* Because we use obstacks, we must process these in precise order.  */\n-  t->next = *inlines;\n-  *inlines = t;\n+  t->next = pending_inlines;\n+  pending_inlines = t;\n }\n \n void reinit_parse_for_block ();\n@@ -1494,7 +1382,7 @@ reinit_parse_for_method (yychar, decl)\n   int starting_lineno = lineno;\n   char *starting_filename = input_filename;\n \n-  reinit_parse_for_block (yychar, &inline_text_obstack, 0);\n+  reinit_parse_for_block (yychar, &inline_text_obstack);\n \n   len = obstack_object_size (&inline_text_obstack);\n   current_base_init_list = NULL_TREE;\n@@ -1523,24 +1411,22 @@ reinit_parse_for_method (yychar, decl)\n       t->len = len;\n       t->can_free = 1;\n       t->deja_vu = 0;\n+#if 0\n       if (interface_unknown && processing_template_defn && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (decl))\n \twarn_if_unknown_interface (decl);\n+#endif\n       t->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n       store_pending_inline (decl, t);\n     }\n }\n \n-/* Consume a block -- actually, a method or template definition beginning\n-   with `:' or `{' -- and save it away on the specified obstack.\n+/* Consume a block -- actually, a method beginning\n+   with `:' or `{' -- and save it away on the specified obstack.  */\n \n-   Argument IS_TEMPLATE indicates which set of error messages should be\n-   output if something goes wrong.  This should really be cleaned up somehow,\n-   without loss of clarity.  */\n void\n-reinit_parse_for_block (pyychar, obstackp, is_template)\n+reinit_parse_for_block (pyychar, obstackp)\n      int pyychar;\n      struct obstack *obstackp;\n-     int is_template;\n {\n   register int c = 0;\n   int blev = 1;\n@@ -1560,23 +1446,21 @@ reinit_parse_for_block (pyychar, obstackp, is_template)\n       look_for_lbrac = 1;\n       blev = 0;\n     }\n-  else if (pyychar == RETURN && !is_template)\n+  else if (pyychar == RETURN)\n     {\n       obstack_grow (obstackp, \"return\", 6);\n       look_for_lbrac = 1;\n       blev = 0;\n     }\n-  else if (pyychar == TRY && !is_template)\n+  else if (pyychar == TRY)\n     {\n       obstack_grow (obstackp, \"try\", 3);\n       look_for_lbrac = 1;\n       blev = 0;\n     }\n   else\n     {\n-      yyerror (is_template\n-\t       ? \"parse error in template specification\"\n-\t       : \"parse error in method specification\");\n+      yyerror (\"parse error in method specification\");\n       obstack_1grow (obstackp, '{');\n     }\n \n@@ -1673,9 +1557,7 @@ reinit_parse_for_block (pyychar, obstackp, is_template)\n \t    {\n \t      if (look_for_lbrac)\n \t\t{\n-\t\t  error (is_template\n-\t\t\t ? \"template body missing\"\n-\t\t\t : \"function body for constructor missing\");\n+\t\t  error (\"function body for constructor missing\");\n \t\t  obstack_1grow (obstackp, '{');\n \t\t  obstack_1grow (obstackp, '}');\n \t\t  len += 2;\n@@ -1721,13 +1603,10 @@ cons_up_default_function (type, full_name, kind)\n      int kind;\n {\n   extern tree void_list_node;\n-  char *func_buf = NULL;\n-  int func_len = 0;\n   tree declspecs = NULL_TREE;\n   tree fn, args;\n   tree argtype;\n   int retref = 0;\n-  int complex = 0;\n   tree name = constructor_name (full_name);\n \n   switch (kind)\n@@ -1744,7 +1623,6 @@ cons_up_default_function (type, full_name, kind)\n     case 2:\n       /* Default constructor.  */\n       args = void_list_node;\n-      complex = TYPE_NEEDS_CONSTRUCTING (type);\n       break;\n \n     case 3:\n@@ -1758,7 +1636,6 @@ cons_up_default_function (type, full_name, kind)\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n-      complex = TYPE_HAS_COMPLEX_INIT_REF (type);\n       break;\n \n     case 5:\n@@ -1775,7 +1652,6 @@ cons_up_default_function (type, full_name, kind)\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n-      complex = TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n       break;\n \n     default:\n@@ -1799,11 +1675,13 @@ cons_up_default_function (type, full_name, kind)\n   if (fn == void_type_node)\n     return fn;\n \n+#if 0\n   if (processing_template_defn)\n     {\n       SET_DECL_IMPLICIT_INSTANTIATION (fn);\n       repo_template_used (fn);\n     }\n+#endif\n \n   if (CLASSTYPE_INTERFACE_KNOWN (type))\n     {\n@@ -1814,27 +1692,7 @@ cons_up_default_function (type, full_name, kind)\n   else\n     DECL_NOT_REALLY_EXTERN (fn) = 1;\n \n-#if 0\n-  /* When on-the-fly synthesis works properly, remove the second and third\n-     conditions here.  */\n-  if (flag_keep_inline_functions\n-#if 0\n-      || ! flag_no_inline\n-      || complex\n-#endif\n-      || ! DECL_EXTERNAL (fn))\n-    {\n-      struct pending_inline *t;\n-      t = (struct pending_inline *)\n-\tobstack_alloc (&synth_obstack, sizeof (struct pending_inline));\n-      t->lineno = -kind;\n-      t->can_free = 0;\n-      t->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n-      store_pending_inline (fn, t);\n-    }\n-  else\n-#endif\n-    mark_inline_for_output (fn);\n+  mark_inline_for_output (fn);\n \n #ifdef DEBUG_DEFAULT_FUNCTIONS\n   { char *fn_type = NULL;\n@@ -2090,8 +1948,6 @@ check_newline ()\n \t\t      error (\"invalid #pragma unit\");\n \t\t      goto skipline;\n \t\t    }\n-\t\t  current_unit_name = get_identifier (TREE_STRING_POINTER (yylval.ttype));\n-\t\t  current_unit_language = current_lang_name;\n \t\t  if (nextchar < 0)\n \t\t    nextchar = getch ();\n \t\t  c = nextchar;\n@@ -2810,9 +2666,11 @@ int\n identifier_type (decl)\n      tree decl;\n {\n-  if (TREE_CODE (decl) == TEMPLATE_DECL\n-      && DECL_TEMPLATE_IS_CLASS (decl))\n-    return PTYPENAME;\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    {\n+      if (TREE_CODE (DECL_RESULT (decl)) == TYPE_DECL)\n+\treturn PTYPENAME;\n+    }\n   if (TREE_CODE (decl) == NAMESPACE_DECL)\n     return NSNAME;\n   if (TREE_CODE (decl) != TYPE_DECL)\n@@ -2841,22 +2699,24 @@ see_typename ()\n }\n \n tree\n-do_identifier (token)\n+do_identifier (token, parsing)\n      register tree token;\n+     int parsing;\n {\n-  register tree id = lastiddecl;\n+  register tree id;\n \n-  if (IDENTIFIER_OPNAME_P (token))\n+  if (! parsing || IDENTIFIER_OPNAME_P (token))\n     id = lookup_name (token, 0);\n+  else\n+    id = lastiddecl;\n \n-  if (yychar == YYEMPTY)\n+  if (parsing && yychar == YYEMPTY)\n     yychar = yylex ();\n   /* Scope class declarations before global\n      declarations.  */\n   if (id == IDENTIFIER_GLOBAL_VALUE (token)\n       && current_class_type != 0\n-      && TYPE_SIZE (current_class_type) == 0\n-      && TREE_CODE (current_class_type) != UNINSTANTIATED_P_TYPE)\n+      && TYPE_SIZE (current_class_type) == 0)\n     {\n       /* Could be from one of the base classes.  */\n       tree field = lookup_field (current_class_type, token, 1, 0);\n@@ -2898,13 +2758,15 @@ do_identifier (token)\n \t    return id;\n \t}\n \n-      if (IDENTIFIER_OPNAME_P (token))\n+      if (current_template_parms)\n+\treturn build_min_nt (LOOKUP_EXPR, token, NULL_TREE);\n+      else if (IDENTIFIER_OPNAME_P (token))\n \t{\n \t  if (token != ansi_opname[ERROR_MARK])\n \t    cp_error (\"operator %O not defined\", token);\n \t  id = error_mark_node;\n \t}\n-      else if (yychar == '(' || yychar == LEFT_RIGHT)\n+      else if (parsing && (yychar == '(' || yychar == LEFT_RIGHT))\n \t{\n \t  id = implicitly_declare (token);\n \t}\n@@ -2986,10 +2848,88 @@ do_identifier (token)\n \t    cp_error (\"enum `%D' is private\", id);\n \t  /* protected is OK, since it's an enum of `this'.  */\n \t}\n-      id = DECL_INITIAL (id);\n+      if (! current_template_parms\n+\t  || (DECL_INITIAL (id)\n+\t      && TREE_CODE (DECL_INITIAL (id)) == TEMPLATE_CONST_PARM))\n+\tid = DECL_INITIAL (id);\n     }\n   else\n-    id = hack_identifier (id, token, yychar);\n+    id = hack_identifier (id, token);\n+\n+  if (current_template_parms)\n+    {\n+      if (is_overloaded_fn (id))\n+\t{\n+\t  tree t = build_min (LOOKUP_EXPR, unknown_type_node,\n+\t\t\t      token, get_first_fn (id));\n+\t  if (id != IDENTIFIER_GLOBAL_VALUE (token))\n+\t    TREE_OPERAND (t, 1) = error_mark_node;\n+\t  id = t;\n+\t}\n+      else if (! TREE_PERMANENT (id) || TREE_CODE (id) == PARM_DECL\n+\t       || TREE_CODE (id) == USING_DECL)\n+\tid = build_min (LOOKUP_EXPR, TREE_TYPE (id), token, error_mark_node);\n+      /* else just use the decl */\n+    }\n+      \n+  return id;\n+}\n+\n+tree\n+do_scoped_id (token, parsing)\n+     tree token;\n+     int parsing;\n+{\n+  tree id = IDENTIFIER_GLOBAL_VALUE (token);\n+  if (parsing && yychar == YYEMPTY)\n+    yychar = yylex ();\n+  if (! id)\n+    {\n+      if (current_template_parms)\n+\t{\n+\t  id = build_min_nt (LOOKUP_EXPR, token, NULL_TREE);\n+\t  LOOKUP_EXPR_GLOBAL (id) = 1;\n+\t  return id;\n+\t}\n+      if (parsing && yychar == '(' || yychar == LEFT_RIGHT)\n+\tid = implicitly_declare (token);\n+      else\n+\t{\n+\t  if (IDENTIFIER_GLOBAL_VALUE (token) != error_mark_node)\n+\t    error (\"undeclared variable `%s' (first use here)\",\n+\t\t   IDENTIFIER_POINTER (token));\n+\t  id = error_mark_node;\n+\t  /* Prevent repeated error messages.  */\n+\t  IDENTIFIER_GLOBAL_VALUE (token) = error_mark_node;\n+\t}\n+    }\n+  else\n+    {\n+      if (TREE_CODE (id) == ADDR_EXPR)\n+\tmark_used (TREE_OPERAND (id, 0));\n+      else if (TREE_CODE (id) != TREE_LIST)\n+\tmark_used (id);\n+    }\n+  if (TREE_CODE (id) == CONST_DECL && ! current_template_parms)\n+    {\n+      /* XXX CHS - should we set TREE_USED of the constant? */\n+      id = DECL_INITIAL (id);\n+      /* This is to prevent an enum whose value is 0\n+\t from being considered a null pointer constant.  */\n+      id = build1 (NOP_EXPR, TREE_TYPE (id), id);\n+      TREE_CONSTANT (id) = 1;\n+    }\n+\n+  if (current_template_parms)\n+    {\n+      if (is_overloaded_fn (id))\n+\t{\n+\t  id = build_min (LOOKUP_EXPR, unknown_type_node,\n+\t\t\t  token, get_first_fn (id));\n+\t  LOOKUP_EXPR_GLOBAL (id) = 1;\n+\t}\n+      /* else just use the decl */\n+    }\n   return id;\n }\n \n@@ -3091,9 +3031,6 @@ real_yylex ()\n \tvalue = END_OF_SAVED_INPUT;\n       else if (linemode)\n \tvalue = END_OF_LINE;\n-      else if (do_pending_expansions ())\n-\t/* this will set yychar for us */\n-\treturn yychar;\n       else\n \tvalue = ENDFILE;\n       break;\n@@ -4141,12 +4078,20 @@ real_yylex ()\n \t      len = p - token_buffer - 1;\n \t    }\n #endif\n+\t    if (current_template_parms)\n+\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t    yylval.ttype = build_string ((len + 1) * WCHAR_BYTES, widep);\n+\t    if (current_template_parms)\n+\t      pop_obstacks ();\n \t    TREE_TYPE (yylval.ttype) = wchar_array_type_node;\n \t  }\n \telse\n \t  {\n+\t    if (current_template_parms)\n+\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t    yylval.ttype = build_string (p - token_buffer, token_buffer + 1);\n+\t    if (current_template_parms)\n+\t      pop_obstacks ();\n \t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n \t  }\n \n@@ -4363,15 +4308,10 @@ is_rid (t)\n   return !!is_reserved_word (IDENTIFIER_POINTER (t), IDENTIFIER_LENGTH (t));\n }\n \n-typedef enum\n-{\n-  d_kind, t_kind, s_kind, r_kind, e_kind, c_kind,\n-  id_kind, op_id_kind, perm_list_kind, temp_list_kind,\n-  vec_kind, x_kind, lang_decl, lang_type, all_kinds\n-} tree_node_kind;\n+#ifdef GATHER_STATISTICS\n extern int tree_node_counts[];\n extern int tree_node_sizes[];\n-extern char *tree_node_kind_names[];\n+#endif\n \n /* Place to save freed lang_decls which were allocated on the\n    permanent_obstack.  @@ Not currently used.  */\n@@ -4490,6 +4430,9 @@ copy_lang_decl (node)\n   int size;\n   int *pi;\n \n+  if (! DECL_LANG_SPECIFIC (node))\n+    return;\n+\n   if (TREE_CODE (node) == FIELD_DECL)\n     size = sizeof (struct lang_decl_flags);\n   else"}, {"sha": "5156121ffb74534b67b18fb2bf1d68d91f4312ca", "filename": "gcc/cp/method.c", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -346,17 +346,35 @@ build_overload_nested_name (decl)\n       OB_PUTCP (label);\n     }\n   else\t\t\t\t/* TYPE_DECL */\n-    {\n-      tree name = DECL_NAME (decl);\n-      build_overload_identifier (name);\n-    }\n+    build_overload_identifier (decl);\n }\n \n /* Encoding for an INTEGER_CST value. */\n static void\n build_overload_int (value)\n      tree value;\n {\n+  if (TREE_CODE (value) == TEMPLATE_CONST_PARM)\n+    {\n+      OB_PUTC ('Y');\n+      if (TEMPLATE_CONST_IDX (value) > 9)\n+\tOB_PUTC ('_');\n+      icat (TEMPLATE_CONST_IDX (value)); \n+      if (TEMPLATE_CONST_IDX (value) > 9)\n+\tOB_PUTC ('_');\n+      return;\n+    }\n+  else if (uses_template_parms (value))\n+    /* We don't ever want this output, but it's inconvenient not to\n+       be able to build the string.  This should cause assembler\n+       errors we'll notice.  */\n+    {\n+      static int n;\n+      sprintf (digit_buffer, \" *%d\", n++);\n+      OB_PUTCP (digit_buffer);\n+      return;\n+    }\n+\n   my_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n   if (TYPE_PRECISION (value) == 2 * HOST_BITS_PER_WIDE_INT)\n     {\n@@ -544,11 +562,14 @@ static void\n build_overload_identifier (name)\n      tree name;\n {\n-  if (IDENTIFIER_TEMPLATE (name))\n+  if (TREE_CODE (name) == TYPE_DECL\n+      && IS_AGGR_TYPE (TREE_TYPE (name))\n+      && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name))\n+      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name))))\n     {\n       tree template, parmlist, arglist, tname;\n       int i, nparms;\n-      template = IDENTIFIER_TEMPLATE (name);\n+      template = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name));\n       arglist = TREE_VALUE (template);\n       template = TREE_PURPOSE (template);\n       tname = DECL_NAME (template);\n@@ -580,6 +601,8 @@ build_overload_identifier (name)\n     }\n   else\n     {\n+      if (TREE_CODE (name) == TYPE_DECL)\n+\tname = DECL_NAME (name);\n       if (numeric_output_need_bar)\n \t{\n \t  OB_PUTC ('_');\n@@ -873,8 +896,8 @@ build_overload_name (parmtypes, begin, end)\n \t\tnumeric_output_need_bar = 0;\n \t\tbuild_overload_nested_name (TYPE_MAIN_DECL (parmtype));\n \t      }\n-\t    else\n-\t      build_overload_identifier (name);\n+\t    else\t      \n+\t      build_overload_identifier (TYPE_MAIN_DECL (parmtype));\n \t    break;\n \t  }\n \n@@ -884,8 +907,15 @@ build_overload_name (parmtypes, begin, end)\n \t  break;\n \n \tcase TEMPLATE_TYPE_PARM:\n-\tcase TEMPLATE_CONST_PARM:\n-        case UNINSTANTIATED_P_TYPE:\n+\t  OB_PUTC ('X');\n+\t  if (TEMPLATE_TYPE_IDX (parmtype) > 9)\n+\t    OB_PUTC ('_');\n+\t  icat (TEMPLATE_TYPE_IDX (parmtype)); \n+\t  if (TEMPLATE_TYPE_IDX (parmtype) > 9)\n+\t    OB_PUTC ('_');\n+\t  break;\n+\t    \n+\tcase TYPENAME_TYPE:\n \t  /* We don't ever want this output, but it's inconvenient not to\n \t     be able to build the string.  This should cause assembler\n \t     errors we'll notice.  */\n@@ -1468,7 +1498,6 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \n    NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.\n    VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)\n-   yychar is the pending input character (suitably encoded :-).\n \n    As a last ditch, try to look up the name as a label and return that\n    address.\n@@ -1478,11 +1507,10 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n    compiler faster).  */\n \n tree\n-hack_identifier (value, name, yychar)\n+hack_identifier (value, name)\n      tree value, name;\n-     int yychar;\n {\n-  tree type;\n+  tree type, context;\n \n   if (TREE_CODE (value) == ERROR_MARK)\n     {\n@@ -1562,6 +1590,20 @@ hack_identifier (value, name, yychar)\n   else\n     mark_used (value);\n \n+  if (pedantic\n+      && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == PARM_DECL))\n+    {\n+      tree context = decl_function_context (value);\n+      if (context != NULL_TREE && context != current_function_decl\n+\t  && ! TREE_STATIC (value))\n+\t{\n+\t  cp_pedwarn (\"use of %s from containing function\",\n+\t\t      (TREE_CODE (value) == VAR_DECL\n+\t\t       ? \"`auto' variable\" : \"parameter\"));\n+\t  cp_pedwarn_at (\"  `%#D' declared here\", value);\n+\t}\n+    }\n+\n   if (TREE_CODE_CLASS (TREE_CODE (value)) == 'd' && DECL_NONLOCAL (value))\n     {\n       if (DECL_LANG_SPECIFIC (value)\n@@ -1605,7 +1647,7 @@ hack_identifier (value, name, yychar)\n       return value;\n     }\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TREE_CODE (type) == REFERENCE_TYPE && ! current_template_parms)\n     {\n       my_friendly_assert (TREE_CODE (value) == VAR_DECL\n \t\t\t  || TREE_CODE (value) == PARM_DECL\n@@ -2217,9 +2259,6 @@ do_build_assign_ref (fndecl)\n   pop_momentary ();\n }\n \n-void push_cp_function_context ();\n-void pop_cp_function_context ();\n-\n void\n synthesize_method (fndecl)\n      tree fndecl;"}, {"sha": "be782b7eb9e9e29ca384859315f1c7f1672750e0", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 483, "deletions": 492, "changes": 975, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -55,6 +55,7 @@ extern int errno;\n \n extern int end_of_file;\n extern int current_class_depth;\n+extern tree last_tree;\n \n /* FSF LOCAL dje prefix attributes */\n extern tree strip_attrs\t\tPROTO((tree));\n@@ -230,7 +231,7 @@ empty_parms ()\n %token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL\n %type <ttype> fn.def1 /* Not really! */\n-%type <ttype> fn.def2 return_id\n+%type <ttype> fn.def2 return_id fn.defpen\n %type <itype> ctor_initializer_opt\n %type <ttype> named_class_head named_class_head_sans_basetype\n %type <ttype> named_complex_class_head_sans_basetype\n@@ -247,22 +248,20 @@ empty_parms ()\n %type <itype> initdcl0 notype_initdcl0 member_init_list\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type_parm\n+%type <code>  template_close_bracket\n %type <ttype> template_type template_arg_list template_arg\n-%type <ttype> template_instantiation template_type_name tmpl.2\n-%type <ttype> template_instantiate_once template_instantiate_some\n-%type <itype> fn_tmpl_end\n /* %type <itype> try_for_typename */\n %type <ttype> condition xcond paren_cond_or_null\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n %type <ttype> complete_type_name notype_identifier\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n-%type <ttype> new_initializer new_placement specialization type_specifier_seq\n+%type <ttype> new_initializer new_placement type_specifier_seq\n %type <ttype> using_decl .poplevel\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n-%type <ttype> named_class_head_sans_basetype_defn \n+%type <ttype> named_class_head_sans_basetype_defn\n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n \n %token NSNAME\n@@ -271,7 +270,7 @@ empty_parms ()\n /* Used in lex.c for parsing pragmas.  */\n %token END_OF_LINE\n \n-/* lex.c and pt.c depends on this being the last token.  Define\n+/* lex.c and pt.c depend on this being the last token.  Define\n    any new tokens before this one!  */\n %token END_OF_SAVED_INPUT\n \f\n@@ -447,10 +446,13 @@ template_parm:\n \t   their match before considering them nameless parameter\n \t   declarations.  */\n \t  template_type_parm\n-\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n-\t| template_type_parm '=' typespec\n-\t\t{ $$ = build_tree_list ($3, $$); }\n-\t| full_parm\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| template_type_parm '=' type_id\n+\t\t{ $$ = build_tree_list (groktypename ($3), $1); }\n+\t| parm\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| parm '=' expr_no_commas %prec ARITHCOMPARE\n+\t\t{ $$ = build_tree_list ($3, $1); }\n \t;\n \n overloaddef:\n@@ -463,102 +465,14 @@ ov_identifiers: IDENTIFIER\n \t| ov_identifiers ',' IDENTIFIER\n \t\t{ declare_overloaded ($3); }\n \t;\n-\t  \n-template_def:\n-\t/* Class template declarations go here; they aren't normal class\n-\t   declarations, because we can't process the bodies yet.  */\n-\t  template_header named_class_head_sans_basetype '{'\n-\t\t{ yychar = '{'; goto template1; }\n-\t ';'\n-\t| template_header named_class_head_sans_basetype_defn '{'\n-\t\t{ yychar = '{'; goto template1; }\n-\t ';'\n-\t| template_header named_class_head_sans_basetype ':'\n-\t\t{ yychar = ':'; goto template1; }\n-\t ';'\n-\t| template_header named_class_head_sans_basetype_defn ':'\n-\t\t{\n-\t\t  yychar = ':';\n-\t\ttemplate1:\n-\t\t  if (current_aggr == signature_type_node)\n-\t\t    sorry (\"template type defining a signature\");\n-\t\t  /* Maybe pedantic warning for union?\n-\t\t     How about an enum? :-)  */\n-\t\t  end_template_decl ($1, $2, current_aggr, 1);\n-\t\t  reinit_parse_for_template (yychar, $1, $2);\n-\t\t  yychar = YYEMPTY;\n-\t\t}\n-\t  ';'\n-\t| template_header named_class_head_sans_basetype ';'\n-\t\t{\n-\t\t  end_template_decl ($1, $2, current_aggr, 0);\n-\t\t  /* declare $2 as template name with $1 parm list */\n-\t\t}\n-\t| template_header named_class_head_sans_basetype_defn ';'\n-\t\t{\n-\t\t  end_template_decl ($1, $2, current_aggr, 0);\n-\t\t  /* declare $2 as template name with $1 parm list */\n-\t\t}\n-\t| template_header /* notype_initdcl0 ';' */\n-\t  notype_declarator exception_specification_opt maybeasm maybe_attribute\n-\t  fn_tmpl_end\n-\t\t{\n-\t\t  tree d;\n-\t\t  int momentary;\n-\t\t  int def = ($6 != ';');\n-\t\t  momentary = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>2, /*current_declspecs*/NULL_TREE, 0,\n-\t\t\t\t  $3);\n-\t\t  cplus_decl_attributes (d, $5, /*prefix_attributes*/NULL_TREE);\n-\t\t  cp_finish_decl (d, NULL_TREE, $4, 1, 0);\n-\t\t  end_template_decl ($1, d, 0, def);\n-\t\t  if (def)\n-\t\t    reinit_parse_for_template ((int) $6, $1, d);\n-\t\t  resume_momentary (momentary);\n-\t\t}\n-\t| template_header typed_declspecs /*initdcl0*/\n-\t  declarator exception_specification_opt maybeasm maybe_attribute\n-\t  fn_tmpl_end\n-\t\t{\n-\t\t  tree d, specs, attrs;\n-\t\t  int momentary;\n-\t\t  int def = ($7 != ';');\n-\t\t  split_specs_attrs ($2, &specs, &attrs);\n-\t\t  momentary = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>3, specs, 0, $<ttype>4);\n-\t\t  cplus_decl_attributes (d, $6, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, $5, 1, 0);\n-\t\t  end_template_decl ($1, d, 0, def);\n-\t\t  if (def)\n-\t\t    {\n-\t\t      reinit_parse_for_template ((int) $7, $1, d);\n-\t\t      yychar = YYEMPTY;\n-\t\t    }\n-\t\t  note_list_got_semicolon ($<ttype>2);\n-\t\t  resume_momentary (momentary);\n-\t\t}\n-\t| template_header declmods notype_declarator fn_tmpl_end\n-\t\t{\n-\t\t  tree d, specs, attrs;\n-\t\t  int def = ($4 != ';');\n-\t\t  split_specs_attrs ($2, &specs, &attrs);\n-\t\t  d = start_decl ($<ttype>3, specs, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-\t\t  end_template_decl ($1, d, 0, def);\n-\t\t  if (def)\n-\t\t    reinit_parse_for_template ((int) $4, $1, d);\n-\t\t}\n-\t/* Try to recover from syntax errors in templates.  */\n-\t| template_header error '}'\t{ end_template_decl ($1, 0, 0, 0); }\n-\t| template_header error ';'\t{ end_template_decl ($1, 0, 0, 0); }\n-\t;\n \n-fn_tmpl_end: '{'\t\t{ $$ = '{'; }\n-\t| ':'\t\t\t{ $$ = ':'; }\n-\t| ';'\t\t\t{ $$ = ';'; }\n-\t| '='\t\t\t{ $$ = '='; }\n-\t| RETURN\t\t{ $$ = RETURN; }\n+template_def:\n+\t  template_header\n+\t  extdef\n+\t\t{ end_template_decl (); }\n+\t| template_header\n+\t  error %prec EMPTY\n+\t\t{ end_template_decl (); }\n \t;\n \n datadef:\n@@ -595,19 +509,6 @@ datadef:\n \t    tree t, attrs;\n \t    split_specs_attrs ($1, &t, &attrs);\n \t    shadow_tag (t);\n-\t    if (TREE_CODE (t) == TREE_LIST\n-\t\t&& TREE_PURPOSE (t) == NULL_TREE)\n-\t      {\n-\t\tt = TREE_VALUE (t);\n-\t\tif (IS_AGGR_TYPE (t)\n-\t\t    && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (t)))\n-\t\t  {\n-\t\t    if (CLASSTYPE_USE_TEMPLATE (t) == 0)\n-\t\t      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n-\t\t    else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n-\t\t      error (\"override declaration for already-expanded template\");\n-\t\t  }\n-\t      }\n \t    note_list_got_semicolon ($<ttype>$);\n \t  }\n \t| error ';'\n@@ -635,14 +536,9 @@ eat_saved_input:\n \n fndef:\n \t  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error\n-\t\t{\n-\t\t  finish_function (lineno, (int)$3, 0);\n-\t\t  if ($<ttype>$) process_next_inline ($<ttype>$);\n-\t\t}\n+\t\t{ finish_function (lineno, (int)$3, 0); }\n \t| fn.def1 maybe_return_init function_try_block\n-\t\t{\n-\t\t  if ($<ttype>$) process_next_inline ($<ttype>$);\n-\t\t}\n+\t\t{ if ($<ttype>$) process_next_inline ($<ttype>$); }\n \t  eat_saved_input\n \t| typed_declspecs declarator error\n \t\t{}\n@@ -672,17 +568,20 @@ fn.def1:\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| PRE_PARSED_FUNCTION_DECL\n-\t\t{ start_function (NULL_TREE, TREE_VALUE ($$),\n-\t\t\t\t  NULL_TREE, NULL_TREE, 1);\n-\t\t  reinit_parse_for_function (); }\n \t;\n \n /* more C++ complexity.  See component_decl for a comment on the\n    reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n \t  typed_declspecs '(' parmlist ')' type_quals exception_specification_opt\n \t\t{ tree specs = strip_attrs ($1);\n+\t\t  if (TREE_VALUE (specs) == current_class_type)\n+\t\t    {\n+\t\t      if (TREE_CHAIN (specs) == NULL_TREE)\n+\t\t        specs = get_decl_list (current_class_name);\n+\t\t      else\n+\t\t        TREE_VALUE (specs) = current_class_name;\n+\t\t    } \n \t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs), $3, $5);\n \t\t  $$ = start_method (TREE_CHAIN (specs), $$, $6);\n \t\t rest_of_mdef:\n@@ -817,39 +716,61 @@ identifier_defn:\n \t;\n \n explicit_instantiation:\n-\t  TEMPLATE specialization template_instantiation\n-\t\t{ do_type_instantiation ($3 ? $3 : $2, NULL_TREE); }\n+\t  TEMPLATE aggr template_type\n+\t\t{ do_type_instantiation ($3, NULL_TREE); }\n \t| TEMPLATE typed_declspecs declarator\n \t\t{ tree specs = strip_attrs ($2);\n \t\t  do_function_instantiation (specs, $3, NULL_TREE); }\n \t| TEMPLATE notype_declarator\n \t\t{ do_function_instantiation (NULL_TREE, $2, NULL_TREE); }\n-\t| SCSPEC TEMPLATE specialization template_instantiation\n-\t\t{ do_type_instantiation ($4 ? $4 : $3, $1); }\n+\t| SCSPEC TEMPLATE aggr template_type\n+\t\t{ do_type_instantiation ($4, $1); }\n \t| SCSPEC TEMPLATE typed_declspecs declarator\n \t\t{ tree specs = strip_attrs ($3);\n \t\t  do_function_instantiation (specs, $4, $1); }\n \t| SCSPEC TEMPLATE notype_declarator\n \t\t{ do_function_instantiation (NULL_TREE, $3, $1); }\n \t;\n \n-template_type:\n-\t  template_type_name tmpl.2 template_instantiation\n-\t\t{ if ($3) $$ = $3; }\n-\t;\n+/* The TYPENAME expansions are to deal with use of a template class name as\n+  a template within the class itself, where the template decl is hidden by\n+  a type decl.  Got all that?  */\n \n-template_type_name:\n-\t  PTYPENAME '<' template_arg_list '>'\n-\t\t{ $$ = lookup_template_class ($$, $3, NULL_TREE); }\n-\t| PTYPENAME '<' '>'\n-\t\t{ $$ = lookup_template_class ($$, NULL_TREE, NULL_TREE); }\n-\t| TYPENAME  '<' template_arg_list '>'\n-\t\t{ $$ = lookup_template_class ($$, $3, NULL_TREE); }\n+template_type:\n+\t  PTYPENAME '<' template_arg_list template_close_bracket\n+\t\t{\n+\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE);\n+\t\t  if ($$ != error_mark_node)\n+\t\t    $$ = TYPE_STUB_DECL ($$);\n+\t\t}\n+\t| PTYPENAME '<' template_close_bracket\n+\t\t{\n+\t\t  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);\n+\t\t  if ($$ != error_mark_node)\n+\t\t    $$ = TYPE_STUB_DECL ($$);\n+\t\t}\n+\t| TYPENAME  '<' template_arg_list template_close_bracket\n+\t\t{\n+\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE);\n+\t\t  if ($$ != error_mark_node)\n+\t\t    $$ = TYPE_STUB_DECL ($$);\n+\t\t}\n+\t| TYPENAME '<' template_close_bracket\n+\t\t{\n+\t\t  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);\n+\t\t  if ($$ != error_mark_node)\n+\t\t    $$ = TYPE_STUB_DECL ($$);\n+\t\t}\n \t;\n \n-tmpl.2: \n-\t  /* empty */ %prec EMPTY\n-\t\t{ $$ = instantiate_class_template ($<ttype>0, 1); }\n+template_close_bracket:\n+\t  '>'\n+\t| RSHIFT \n+\t\t{\n+\t\t  /* Handle `Class<Class<Type>>' without space in the `>>' */\n+\t\t  pedwarn (\"`>>' should be `> >' in template class name\");\n+\t\t  yyungetc ('>', 1);\n+\t\t}\n \t;\n \n template_arg_list:\n@@ -862,75 +783,9 @@ template_arg_list:\n template_arg:\n \t  type_id\n \t\t{ $$ = groktypename ($$); }\n-\t| expr_no_commas  %prec UNARY\n+\t| expr_no_commas  %prec ARITHCOMPARE\n \t;\n \n-template_instantiate_once:\n-\t  PRE_PARSED_CLASS_DECL maybe_base_class_list\n-\t\t{\n-\t\t  tree t, decl, tmpl;\n-\n-\t\t  tmpl = TREE_PURPOSE (IDENTIFIER_TEMPLATE ($1));\n-\t\t  t = xref_tag (DECL_TEMPLATE_INFO (tmpl)->aggr, $1, $2, 0);\n-\t\t  set_current_level_tags_transparency (1);\n-\t\t  my_friendly_assert (TREE_CODE (t) == RECORD_TYPE\n-\t\t\t\t      || TREE_CODE (t) == UNION_TYPE, 257);\n-\t\t  $<ttype>$ = t;\n-\n-\t\t  /* Now, put a copy of the decl in global scope, to avoid\n-\t\t     recursive expansion.  */\n-\t\t  decl = IDENTIFIER_LOCAL_VALUE ($1);\n-\t\t  if (!decl)\n-\t\t    decl = IDENTIFIER_CLASS_VALUE ($1);\n-\t\t  /* Now, put a copy of the decl in global scope, to avoid\n-\t\t     recursive expansion.  */\n-                  if (decl)\n-                    {\n-\t\t      /* Need to copy it to clear the chain pointer,\n-\t\t\t and need to get it into permanent storage.  */\n-                      my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 258);\n-\t\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n-                      decl = copy_node (decl);\n-\t\t      if (DECL_LANG_SPECIFIC (decl))\n-\t\t\tcopy_lang_decl (decl);\n-\t\t      pop_obstacks ();\n-\t\t      pushdecl_top_level (decl);\n-\t\t    }\n-\t\t  /* Kludge; see instantiate_class_template.  */\n-\t\t  TYPE_BEING_DEFINED (t) = 0;\n-\t\t}\n-\t  left_curly opt.component_decl_list '}'\n-\t\t{\n-\t\t  tree t = finish_struct ($<ttype>3, $5, NULL_TREE, 0);\n-\n-\t\t  pop_obstacks ();\n-\t\t  end_template_instantiation ($1);\n-\n-\t\t  repo_template_used (t);\n-\n-                  /* Now go after the methods & class data.  */\n-                  instantiate_member_templates ($1);\n-\n-\t\t  pop_tinst_level();\n-\n-\t\t  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n-\t\t}\n-\t;\n-\n-template_instantiation:\n-          /* empty */\n-                { $$ = NULL_TREE; }\n-        | template_instantiate_once\n-                { $$ = $1; }\n-        ;\n-\n-template_instantiate_some:\n-          /* empty */\n-                { $$ = NULL_TREE; /* never used from here... */}\n-        | template_instantiate_once template_instantiate_some\n-                { $$ = $1; /*???*/ }\n-        ;\n-\n unop:     '-'\n \t\t{ $$ = NEGATE_EXPR; }\n \t| '+'\n@@ -1013,8 +868,25 @@ compstmtend:\n \t;\n \n already_scoped_stmt:\n-\t  '{' compstmtend\n-\t\t{ finish_stmt (); }\n+\t  '{'\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n+\t\t      COMPOUND_STMT_NO_SCOPE ($<ttype>$) = 1;\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t}\n+\t  compstmtend\n+\t\t{ \n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  finish_stmt (); \n+\t\t}\n \t| simple_stmt\n \t;\n \n@@ -1078,27 +950,7 @@ unary_expr:\n \t\t    }\n \t\t}\n \t| SIZEOF unary_expr  %prec UNARY\n-\t\t{ if (TREE_CODE ($2) == COMPONENT_REF\n-\t\t      && DECL_BIT_FIELD (TREE_OPERAND ($2, 1)))\n-\t\t    error (\"sizeof applied to a bit-field\");\n-\t\t  /* ANSI says arrays and functions are converted inside comma.\n-\t\t     But we can't really convert them in build_compound_expr\n-\t\t     because that would break commas in lvalues.\n-\t\t     So do the conversion here if operand was a comma.  */\n-\t\t  if (TREE_CODE ($2) == COMPOUND_EXPR\n-\t\t      && (TREE_CODE (TREE_TYPE ($2)) == ARRAY_TYPE\n-\t\t\t  || TREE_CODE (TREE_TYPE ($2)) == FUNCTION_TYPE))\n-\t\t    $2 = default_conversion ($2);\n-\t\t  else if (TREE_CODE ($2) == TREE_LIST)\n-\t            {\n-\t\t      tree t = TREE_VALUE ($2);\n-\t\t      if (t != NULL_TREE\n-\t\t\t  && ((TREE_TYPE (t)\n-\t\t\t      && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n-\t\t\t      || is_overloaded_fn (t)))\n-\t\t\tpedwarn (\"ANSI C++ forbids taking the sizeof a function type\");\n-\t\t    }\n-\t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n+\t\t{ $$ = expr_sizeof ($2); }\n \t| SIZEOF '(' type_id ')'  %prec HYPERUNARY\n \t\t{ $$ = c_sizeof (groktypename ($3)); }\n \t| ALIGNOF unary_expr  %prec UNARY\n@@ -1243,15 +1095,10 @@ expr_no_commas:\n \t| expr_no_commas '?' xexpr ':' expr_no_commas\n \t\t{ $$ = build_x_conditional_expr ($$, $3, $5); }\n \t| expr_no_commas '=' expr_no_commas\n-\t\t{ $$ = build_modify_expr ($$, NOP_EXPR, $3);\n+\t\t{ $$ = build_x_modify_expr ($$, NOP_EXPR, $3);\n                   C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }\n \t| expr_no_commas ASSIGN expr_no_commas\n-\t\t{ register tree rval;\n-\t\t  if ((rval = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, $$, $3,\n-\t\t\t\t\t     make_node ($2))))\n-\t\t    $$ = rval;\n-\t\t  else\n-\t\t    $$ = build_modify_expr ($$, $2, $3); }\n+\t\t{ $$ = build_x_modify_expr ($$, $2, $3); }\n \t| THROW\n \t\t{ $$ = build_throw (NULL_TREE); }\n \t| THROW expr_no_commas\n@@ -1308,12 +1155,18 @@ primary:\n \t\t  if (TREE_CODE ($$) == BIT_NOT_EXPR)\n \t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));\n \t\t  else\n-\t\t    $$ = do_identifier ($$);\n+\t\t    $$ = do_identifier ($$, 1);\n \t\t}\t\t\n \t| CONSTANT\n \t| boolean.literal\n \t| string\n-\t\t{ $$ = combine_strings ($$); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t\t  $$ = combine_strings ($$);\n+\t\t  if (current_template_parms)\n+\t\t    pop_obstacks ();\n+\t\t}\n \t| '(' expr ')'\n \t\t{ char class;\n \t\t  $$ = $2;\n@@ -1362,16 +1215,11 @@ primary:\n \t\t    $$ = $3;\n \t\t}\n \t| primary '(' nonnull_exprlist ')'\n-                { /* [eichin:19911016.1902EST] */\n-                  $<ttype>$ = build_x_function_call ($1, $3, current_class_decl); \n-                  /* here we instantiate_class_template as needed... */\n-                  do_pending_templates ();\n-                } template_instantiate_some {\n-                  if (TREE_CODE ($<ttype>5) == CALL_EXPR\n-                      && TREE_TYPE ($<ttype>5) != void_type_node)\n-\t            $$ = require_complete_type ($<ttype>5);\n-                  else\n-                    $$ = $<ttype>5;\n+                {\n+                  $$ = build_x_function_call ($1, $3, current_class_decl); \n+                  if (TREE_CODE ($$) == CALL_EXPR\n+                      && TREE_TYPE ($$) != void_type_node)\n+\t            $$ = require_complete_type ($$);\n                 }\n \t| primary LEFT_RIGHT\n                 {\n@@ -1498,65 +1346,37 @@ primary:\n \t\t{ tree type = groktypename ($3);\n \t\t  $$ = get_typeid (TYPE_MAIN_VARIANT (type)); }\n \t| global_scope IDENTIFIER\n-\t\t{\n-\t\tdo_scoped_id:\n-\t\t  $$ = IDENTIFIER_GLOBAL_VALUE ($2);\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  if (! $$)\n-\t\t    {\n-\t\t      if (yychar == '(' || yychar == LEFT_RIGHT)\n-\t\t\t$$ = implicitly_declare ($2);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (IDENTIFIER_GLOBAL_VALUE ($2) != error_mark_node)\n-\t\t\t    error (\"undeclared variable `%s' (first use here)\",\n-\t\t\t\t   IDENTIFIER_POINTER ($2));\n-\t\t\t  $$ = error_mark_node;\n-\t\t\t  /* Prevent repeated error messages.  */\n-\t\t\t  IDENTIFIER_GLOBAL_VALUE ($2) = error_mark_node;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (TREE_CODE ($$) == ADDR_EXPR)\n-\t\t\tmark_used (TREE_OPERAND ($$, 0));\n-\t\t      else\n-\t\t\tmark_used ($$);\n-\t\t    }\n-\t\t  if (TREE_CODE ($$) == CONST_DECL)\n-\t\t    {\n-\t\t      /* XXX CHS - should we set TREE_USED of the constant? */\n-\t\t      $$ = DECL_INITIAL ($$);\n-\t\t      /* This is to prevent an enum whose value is 0\n-\t\t\t from being considered a null pointer constant.  */\n-\t\t      $$ = build1 (NOP_EXPR, TREE_TYPE ($$), $$);\n-\t\t      TREE_CONSTANT ($$) = 1;\n-\t\t    }\n-\n-\t\t}\n+\t\t{ $$ = do_scoped_id ($2, 1); }\n \t| global_scope operator_name\n \t\t{\n \t\t  got_scope = NULL_TREE;\n \t\t  if (TREE_CODE ($2) == IDENTIFIER_NODE)\n-\t\t    goto do_scoped_id;\n-\t\t  $$ = $2;\n+\t\t    $$ = do_scoped_id ($2, 1);\n+\t\t  else\n+\t\t    $$ = $2;\n \t\t}\n \t| overqualified_id %prec HYPERUNARY\n \t\t{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }\n \t| overqualified_id '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }\n+\t\t{ if (current_template_parms)\n+\t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), $3, 0);\n+\t\t  else\n+\t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }\n \t| overqualified_id LEFT_RIGHT\n-\t\t{ $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n+\t\t{ if (current_template_parms)\n+\t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), \n+\t\t\t\t       NULL_TREE, 0);\n+\t\t  else\n+\t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n \t| object unqualified_id  %prec UNARY\n-\t\t{ got_object = NULL_TREE;\n-\t\t  $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n+\t\t{ $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n \t| object overqualified_id %prec UNARY\n-\t\t{ got_object = NULL_TREE;\n-\t\t  $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n+\t\t{ if (current_template_parms)\n+\t\t    $$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));\n+\t\t  else\n+\t\t    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n \t| object unqualified_id '(' nonnull_exprlist ')'\n \t\t{\n-\t\t  got_object = NULL_TREE;\n #if 0\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n@@ -1572,7 +1392,6 @@ primary:\n \t\t}\n \t| object unqualified_id LEFT_RIGHT\n \t\t{\n-\t\t  got_object = NULL_TREE;\n #if 0\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n@@ -1588,7 +1407,6 @@ primary:\n \t\t}\n \t| object overqualified_id '(' nonnull_exprlist ')'\n \t\t{\n-\t\t  got_object = NULL_TREE;\n \t\t  if (IS_SIGNATURE (OP0 ($2)))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n@@ -1600,7 +1418,6 @@ primary:\n \t\t}\n \t| object overqualified_id LEFT_RIGHT\n \t\t{\n-\t\t  got_object = NULL_TREE;\n \t\t  if (IS_SIGNATURE (OP0 ($2)))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n@@ -1613,7 +1430,6 @@ primary:\n \t/* p->int::~int() is valid -- 12.4 */\n \t| object '~' TYPESPEC LEFT_RIGHT\n \t\t{\n-\t\t  got_object = NULL_TREE;\n \t\t  if (IDENTIFIER_GLOBAL_VALUE ($3)\n \t\t      && (TREE_CODE (TREE_TYPE ($1)) \n \t\t\t  != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3)))))\n@@ -1622,7 +1438,6 @@ primary:\n \t\t}\n \t| object TYPESPEC SCOPE '~' TYPESPEC LEFT_RIGHT\n \t\t{\n-\t\t  got_object = NULL_TREE;\n \t\t  if ($2 != $5)\n \t\t    cp_error (\"destructor specifier `%T::~%T()' must have matching names\", $2, $5);\n \t\t  if (TREE_CODE (TREE_TYPE ($1))\n@@ -1632,7 +1447,6 @@ primary:\n \t\t}\n \t| object error\n \t\t{\n-\t\t  got_object = NULL_TREE;\n \t\t  $$ = error_mark_node;\n \t\t}\n \t;\n@@ -2126,6 +1940,9 @@ maybe_init:\n \t| '=' init\n \t\t{ $$ = $2; }\n \n+/* If we are processing a template, we don't want to expand this\n+   initializer yet.  */\n+\n init:\n \t  expr_no_commas %prec '='\n \t| '{' '}'\n@@ -2159,6 +1976,25 @@ initlist:\n \t\t{ $$ = tree_cons ($3, $5, $$); }\n \t;\n \n+fn.defpen:\n+\tPRE_PARSED_FUNCTION_DECL\n+\t\t{ start_function (NULL_TREE, TREE_VALUE ($1),\n+\t\t\t\t  NULL_TREE, NULL_TREE, 1);\n+\t\t  reinit_parse_for_function (); }\n+\n+pending_inlines:\n+\t/* empty */\n+\t| pending_inlines fn.defpen maybe_return_init ctor_initializer_opt\n+\t  compstmt_or_error\n+\t\t{\n+\t\t  finish_function (lineno, (int)$4, 0);\n+\t\t  process_next_inline ($2);\n+\t\t}\n+\t| pending_inlines fn.defpen maybe_return_init function_try_block\n+\t\t{ process_next_inline ($2); }\n+\t  eat_saved_input\n+\t;\n+\n structsp:\n \t  ENUM identifier '{'\n \t\t{ $<itype>3 = suspend_momentary ();\n@@ -2184,8 +2020,10 @@ structsp:\n \t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n \t| ENUM complex_type_name\n \t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n-\t| TYPENAME_KEYWORD complex_type_name\n-\t\t{ $$ = $2; }\n+\t| TYPENAME_KEYWORD nested_name_specifier identifier\n+\t\t{ $$ = make_typename_type ($2, $3); }\n+\t| TYPENAME_KEYWORD global_scope nested_name_specifier identifier\n+\t\t{ $$ = make_typename_type ($3, $4); }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly opt.component_decl_list '}' maybe_attribute\n \t\t{\n@@ -2195,46 +2033,34 @@ structsp:\n #if 0\n \t\t  /* Need to rework class nesting in the\n \t\t     presence of nested classes, etc.  */\n-\t\t  shadow_tag (CLASSTYPE_AS_LIST ($$)); */\n+\t\t  shadow_tag (CLASSTYPE_AS_LIST ($1)); */\n #endif\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  semi = yychar == ';';\n \t\t  /* finish_struct nukes this anyway; if\n \t\t     finish_exception does too, then it can go. */\n \t\t  if (semi)\n-\t\t    note_got_semicolon ($$);\n+\t\t    note_got_semicolon ($1);\n \n-\t\t  if (TREE_CODE ($$) == ENUMERAL_TYPE)\n-\t\t    /* $$ = $1 from default rule.  */;\n+\t\t  if (TREE_CODE ($1) == ENUMERAL_TYPE)\n+\t\t    ;\n \t\t  else\n \t\t    {\n-\t\t      $$ = finish_struct ($$, $3, $5, semi);\n-\t\t      if (semi) note_got_semicolon ($$);\n+\t\t      $<ttype>$ = finish_struct ($1, $3, $5, semi);\n+\t\t      if (semi) note_got_semicolon ($<ttype>$);\n \t\t    }\n \n \t\t  pop_obstacks ();\n \n-\t\t  id = TYPE_IDENTIFIER ($$);\n-\t\t  if (id && IDENTIFIER_TEMPLATE (id))\n-\t\t    {\n-\t\t      tree decl;\n-\n-\t\t      /* I don't know if the copying of this TYPE_DECL is\n-\t\t       * really needed.  However, it's such a small per-\n-\t\t       * formance penalty that the extra safety is a bargain.\n-\t\t       * - niklas@appli.se\n-\t\t       */\n-\t\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t\t      decl = copy_node (lookup_name (id, 0));\n-\t\t      if (DECL_LANG_SPECIFIC (decl))\n-\t\t\tcopy_lang_decl (decl);\n-\t\t      pop_obstacks ();\n-\t\t      undo_template_name_overload (id, 0);\n-\t\t      pushdecl_top_level (decl);\n-\t\t    }\n \t\t  if (! semi)\n-\t\t    check_for_missing_semicolon ($$); }\n+\t\t    check_for_missing_semicolon ($1); \n+\t\t  if (pending_inlines \n+\t\t      && current_scope () == current_function_decl)\n+\t\t    do_pending_inlines ();\n+\t\t}\n+\t  pending_inlines\n+\t\t{ $$ = $<ttype>6; }\n \t| class_head  %prec EMPTY\n \t\t{\n \t\t  /* struct B: public A; is not accepted by the WP grammar.  */\n@@ -2267,39 +2093,23 @@ aggr:\t  AGGR\n \t\t{ error (\"no body nor ';' separates two class, struct or union declarations\"); }\n \t;\n \n-specialization:\n-\t  aggr template_type_name ';'\n-\t\t{ \n-\t\t  yyungetc (';', 1); current_aggr = $$; $$ = $2; \n-\t\t  if ($<ttype>0 == ridpointers[(int) RID_TEMPLATE])\n-\t\t    instantiate_class_template ($$, 2);\n-\t\t}\n-\t;\n-\n named_class_head_sans_basetype:\n \t  aggr identifier\n \t\t{ current_aggr = $$; $$ = $2; }\n-\t| specialization\n \t;\n \n named_class_head_sans_basetype_defn:\n \t  aggr identifier_defn %prec EMPTY\n \t\t{ current_aggr = $$; $$ = $2; }\n-\t| aggr template_type_name '{'\n-\t\t{ yyungetc ('{', 1);\n-\t\taggr2:\n-\t\t  current_aggr = $$;\n-\t\t  $$ = $2;\n-\t\t  overload_template_name ($$, 0); }\n-\t| aggr template_type_name ':'\n-\t\t{ yyungetc (':', 1); goto aggr2; }\n \t;\n \n named_complex_class_head_sans_basetype:\n \t  aggr nested_name_specifier identifier\n \t\t{ current_aggr = $$; $$ = $3; }\n-\t| aggr template_type %prec EMPTY\n+\t| aggr template_type\n \t\t{ current_aggr = $$; $$ = $2; }\n+\t| aggr nested_name_specifier template_type\n+\t\t{ current_aggr = $$; $$ = $3; }\n \t;\n \n do_xref_defn: /* empty */ %prec EMPTY\n@@ -2320,7 +2130,7 @@ named_class_head:\n \t\t{ \n \t\t  $$ = TREE_TYPE ($1);\n \t\t  if ($2)\n-\t\t    xref_basetypes (current_aggr, $1, TREE_TYPE ($1), $2); \n+\t\t    xref_basetypes (current_aggr, $1, $$, $2); \n \t\t}\n \t;\n \n@@ -2506,8 +2316,19 @@ left_curly: '{'\n                       pushtag (TYPE_IDENTIFIER ($<ttype>0), t, 0);\n                       $<ttype>0 = t;\n                     }\n+\t\t  if (current_template_parms && TYPE_CONTEXT (t)\n+\t\t      && ! current_class_type)\n+\t\t    push_template_decl (TYPE_STUB_DECL (t));\n \t\t  pushclass (t, 0);\n \t\t  TYPE_BEING_DEFINED (t) = 1;\n+\t\t  if (IS_AGGR_TYPE (t) && CLASSTYPE_USE_TEMPLATE (t))\n+\t\t    {\n+\t\t      if (CLASSTYPE_IMPLICIT_INSTANTIATION (t)\n+\t\t\t  && TYPE_SIZE (t) == NULL_TREE)\n+\t\t\tSET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n+\t\t      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n+\t\t\tcp_error (\"specialization after instantiation of `%T'\", t);\n+\t\t    }\n \t\t  /* Reset the interface data, at the earliest possible\n \t\t     moment, as it might have been set via a class foo;\n \t\t     before.  */\n@@ -2650,13 +2471,27 @@ component_decl_1:\n \t| typed_declspecs '(' parmlist ')' type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  if (TREE_VALUE (specs) == current_class_type)\n+\t\t    {\n+\t\t      if (TREE_CHAIN (specs) == NULL_TREE)\n+\t\t        specs = get_decl_list (current_class_name);\n+\t\t      else\n+\t\t        TREE_VALUE (specs) = current_class_name;\n+\t\t    } \n \t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n \t\t\t\t\t $3, $5);\n \t\t  $$ = grokfield ($$, TREE_CHAIN (specs), $6, $9, $7,\n \t\t\t\t  build_tree_list ($8, attrs)); }\n \t| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  if (TREE_VALUE (specs) == current_class_type)\n+\t\t    {\n+\t\t      if (TREE_CHAIN (specs) == NULL_TREE)\n+\t\t        specs = get_decl_list (current_class_name);\n+\t\t      else\n+\t\t        TREE_VALUE (specs) = current_class_name;\n+\t\t    } \n \t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n \t\t\t\t\t empty_parms (), $3);\n \t\t  $$ = grokfield ($$, TREE_CHAIN (specs), $4, $7, $5,\n@@ -2900,7 +2735,7 @@ complete_type_name:\n \n nested_type:\n \tnested_name_specifier type_name %prec EMPTY\n-\t\t{ $$ = identifier_typedecl_value ($2); }\n+\t\t{ $$ = get_type_decl ($2); }\n \t;\n \n direct_after_type_declarator:\n@@ -3028,7 +2863,7 @@ nested_name_specifier_1:\n \t| NSNAME SCOPE\n \t\t{ got_scope = $$ = $1; }\n \t| template_type SCOPE\n-\t\t{ got_scope = $$ = TREE_TYPE ($1); }\n+\t\t{ got_scope = $$ = complete_type (TREE_TYPE ($1)); }\n /* \tThese break 'const i;'\n \t| IDENTIFIER SCOPE\n \t\t{\n@@ -3181,17 +3016,11 @@ errstmt:  error ';'\n   set up to point at this one.  */\n \n .pushlevel:  /* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  pushlevel (0);\n-\t\t  clear_last_expr ();\n-\t\t  push_momentary ();\n-\t\t  expand_start_bindings (0); }\n+\t\t{ do_pushlevel (); }\n \t;\n \n .poplevel:   /* empty */\n-\t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary (); }\n+\t\t{ $$ = do_poplevel (); }\n \t;\n \n /* Read zero or more forward-declarations for labels\n@@ -3228,24 +3057,88 @@ compstmt_or_error:\n \t| error compstmt\n \t;\n \n-compstmt: '{' .pushlevel compstmtend .poplevel\n-\t\t{ $$ = $4; }\n+compstmt: '{'\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t}\n+\t  .pushlevel compstmtend .poplevel\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  $$ = $5;\n+\t\t}\n \t;\n \n simple_if:\n \t  IF\n-\t\t{ cond_stmt_keyword = \"if\"; }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t        NULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+                  cond_stmt_keyword = \"if\";\n+\t\t}\n \t  .pushlevel paren_cond_or_null\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_start_cond ($4, 0); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      if (last_tree != $<ttype>2)\n+\t\t        {\n+\t\t\t  TREE_OPERAND ($<ttype>2, 0) = last_tree;\n+\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t\t  last_tree = $<ttype>2;\n+\t\t\t}\n+\t\t      else\n+\t\t        TREE_OPERAND ($<ttype>2, 0) = $4;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_start_cond ($4, 0);\n+\t\t    }\n+\t\t}\n \t  implicitly_scoped_stmt\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      $<ttype>$ = last_tree = $<ttype>2;\n+\t\t    }\n+\t\t}\n \t;\n \n implicitly_scoped_stmt:\n \t  compstmt\n \t\t{ finish_stmt (); }\n-\t| .pushlevel simple_stmt .poplevel\n-\t\t{ $$ = $3; }\n+\t| .pushlevel\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t}\n+\t  simple_stmt .poplevel\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  $$ = $4;\n+\t\t}\n \t;\n \n stmt:\n@@ -3260,53 +3153,136 @@ simple_stmt:\n \t| expr ';'\n \t\t{\n \t\t  tree expr = $1;\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  /* Do default conversion if safe and possibly important,\n-\t\t     in case within ({...}).  */\n-\t\t  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-\t\t       && lvalue_p (expr))\n-\t\t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n-\t\t    expr = default_conversion (expr);\n+\t\t  if (! current_template_parms)\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      /* Do default conversion if safe and possibly important,\n+\t\t         in case within ({...}).  */\n+\t\t      if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+\t\t           && lvalue_p (expr))\n+\t\t          || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n+\t\t        expr = default_conversion (expr);\n+\t\t    }\n \t\t  cplus_expand_expr_stmt (expr);\n \t\t  clear_momentary ();\n \t\t  finish_stmt (); }\n \t| simple_if ELSE\n-\t\t{ expand_start_else (); }\n+\t\t{ if (! current_template_parms) expand_start_else (); }\n \t  implicitly_scoped_stmt\n-\t\t{ expand_end_cond (); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>1, 2) = TREE_CHAIN ($<ttype>1);\n+\t\t      TREE_CHAIN ($<ttype>1) = NULL_TREE;\n+\t\t      last_tree = $<ttype>1;\n+\t\t    }\n+\t\t  else\n+\t\t    expand_end_cond ();\n+\t\t}\n \t  .poplevel\n \t\t{ finish_stmt (); }\n \t| simple_if %prec IF\n-\t\t{ expand_end_cond ();\n+\t\t{ if (! current_template_parms) expand_end_cond ();\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n \t\t  finish_stmt (); }\n \t| WHILE\n-\t\t{ emit_nop ();\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_start_loop (1);\n-\t\t  cond_stmt_keyword = \"while\"; }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_nop ();\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_start_loop (1); \n+\t\t    }\n+\t\t  cond_stmt_keyword = \"while\";\n+\t\t}\n \t  .pushlevel paren_cond_or_null\n-\t\t{ expand_exit_loop_if_false (0, $4); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      if (last_tree != $<ttype>2)\n+\t\t        {\n+\t\t\t  TREE_OPERAND ($<ttype>2, 0) = last_tree;\n+\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t\t  last_tree = $<ttype>2;\n+\t\t\t}\n+\t\t      else\n+\t\t        TREE_OPERAND ($<ttype>2, 0) = $4;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_exit_loop_if_false (0, $4);\n+\t\t    }\n+\t\t}\n \t  already_scoped_stmt .poplevel\n-\t\t{ expand_end_loop ();\n-\t\t  finish_stmt (); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  else\n+\t\t    expand_end_loop ();\n+\t\t  finish_stmt ();\n+\t\t}\n \t| DO\n-\t\t{ emit_nop ();\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_start_loop_continue_elsewhere (1); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_nop ();\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_start_loop_continue_elsewhere (1);\n+\t\t    }\n+\t\t}\n \t  implicitly_scoped_stmt WHILE\n-\t\t{ expand_loop_continue_here ();\n-\t\t  cond_stmt_keyword = \"do\"; }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      expand_loop_continue_here ();\n+\t\t      cond_stmt_keyword = \"do\";\n+\t\t    }\n+\t\t}\n \t  paren_expr_or_null ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (0, $6);\n-\t\t  expand_end_loop ();\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    TREE_OPERAND ($<ttype>2, 1) = $6;\n+\t\t  else\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_exit_loop_if_false (0, $6);\n+\t\t      expand_end_loop ();\n+\t\t    }\n \t\t  clear_momentary ();\n-\t\t  finish_stmt (); }\n+\t\t  finish_stmt ();\n+\t\t}\n \t| FOR\n-\t\t{ emit_line_note (input_filename, lineno);\n+\t\t{ if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, \n+\t\t\t\t\t        NULL_TREE, NULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+                  else\n+\t\t    emit_line_note (input_filename, lineno);\n \t\t  if (flag_new_for_scope > 0)\n \t\t    {\n \t\t      /* Conditionalize .pushlevel */\n@@ -3318,22 +3294,66 @@ simple_stmt:\n \t\t    }\n \t\t}\n \t  '(' for.init.statement\n-\t\t{ emit_nop ();\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_start_loop_continue_elsewhere (1); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      if (last_tree != $<ttype>2)\n+\t\t\t{\n+\t\t\t  TREE_OPERAND ($<ttype>2, 0) = last_tree;\n+\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t\t  last_tree = $<ttype>2;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_nop ();\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_start_loop_continue_elsewhere (1); \n+\t\t    }\n+\t\t}\n \t  .pushlevel xcond ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ($7) expand_exit_loop_if_false (0, $7); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      if (last_tree != $<ttype>2)\n+\t\t        {\n+\t\t\t  TREE_OPERAND ($<ttype>2, 1) = last_tree;\n+\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t\t  last_tree = $<ttype>2;\n+\t\t\t}\n+\t\t      else\n+\t\t        TREE_OPERAND ($<ttype>2, 1) = $7;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      if ($7) expand_exit_loop_if_false (0, $7);\n+\t\t    }\n+\t\t}\n \t  xexpr ')'\n \t\t/* Don't let the tree nodes for $10 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n-\t\t{ push_momentary (); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    TREE_OPERAND ($<ttype>2, 2) = $10;\n+\t\t  push_momentary ();\n+\t\t}\n \t  already_scoped_stmt .poplevel\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_loop_continue_here ();\n-\t\t  if ($10) cplus_expand_expr_stmt ($10);\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 3) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_loop_continue_here ();\n+\t\t      if ($10) cplus_expand_expr_stmt ($10);\n+\t\t      expand_end_loop ();\n+\t\t    }\n \t\t  pop_momentary ();\n-\t\t  expand_end_loop ();\n \t\t  if (flag_new_for_scope > 0)\n \t\t    {\n \t\t      expand_end_bindings (getdecls (), kept_level_p (), 1);\n@@ -3342,98 +3362,57 @@ simple_stmt:\n \t\t    }\n \t\t  finish_stmt (); }\n \t| SWITCH .pushlevel '(' condition ')'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  c_expand_start_case ($4);\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (SWITCH_STMT, $4, NULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      c_expand_start_case ($4);\n+\t\t    }\n \t\t  push_switch ();\n \t\t  /* Don't let the tree nodes for $4 be discarded by\n \t\t     clear_momentary during the parsing of the next stmt.  */\n-\t\t  push_momentary (); }\n+\t\t  push_momentary ();\n+\t\t}\n \t  implicitly_scoped_stmt\n-\t\t{ expand_end_case ($4);\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>6, 1) = TREE_CHAIN ($<ttype>6);\n+\t\t      TREE_CHAIN ($<ttype>6) = NULL_TREE;\n+\t\t      last_tree = $<ttype>6;\n+\t\t    }\n+\t\t  else\n+\t\t    expand_end_case ($4);\n \t\t  pop_momentary ();\n-\t\t  pop_switch (); }\n+\t\t  pop_switch (); \n+\t\t}\n \t  .poplevel\n \t\t{ finish_stmt (); }\n \t| CASE expr_no_commas ':'\n-\t\t{ register tree value = check_cp_case_value ($2);\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-\t\t  if (value != error_mark_node)\n-\t\t    {\n-\t\t      tree duplicate;\n-\t\t      int success = pushcase (value, convert_and_check,\n-\t\t\t\t\t      label, &duplicate);\n-\t\t      if (success == 1)\n-\t\t\tcp_error (\"case label `%E' not within a switch statement\", $2);\n-\t\t      else if (success == 2)\n-\t\t\t{\n-\t\t\t  cp_error (\"duplicate case value `%E'\", $2);\n-\t\t\t  cp_error_at (\"previously used here\", duplicate);\n-\t\t\t}\n-\t\t      else if (success == 3)\n-\t\t\twarning (\"case value out of range\");\n-\t\t      else if (success == 5)\n-\t\t\tcp_error (\"case label `%E' within scope of cleanup or variable array\", $2);\n-\t\t    }\n-\t\t  define_case_label (label);\n-\t\t}\n+\t\t{ do_case ($2, NULL_TREE); }\n \t  stmt\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-\t\t{ register tree value1 = check_cp_case_value ($2);\n-\t\t  register tree value2 = check_cp_case_value ($4);\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n-\t\t  if (value1 != error_mark_node\n-\t\t      && value2 != error_mark_node)\n-\t\t    {\n-\t\t      tree duplicate;\n-\t\t      int success = pushcase_range (value1, value2,\n-\t\t\t\t\t\t    convert_and_check, label,\n-\t\t\t\t\t\t    &duplicate);\n-\t\t      if (success == 1)\n-\t\t\terror (\"case label not within a switch statement\");\n-\t\t      else if (success == 2)\n-\t\t\t{\n-\t\t\t  error (\"duplicate (or overlapping) case value\");\n-\t\t\t  error_with_decl (duplicate, \"this is the first entry overlapping that value\");\n-\t\t\t}\n-\t\t      else if (success == 3)\n-\t\t\twarning (\"case value out of range\");\n-\t\t      else if (success == 4)\n-\t\t\twarning (\"empty range specified\");\n-\t\t      else if (success == 5)\n-\t\t\terror (\"case label within scope of cleanup or variable array\");\n-\t\t    }\n-\t\t  define_case_label (label);\n-\t\t}\n+\t\t{ do_case ($2, $4); }\n \t  stmt\n \t| DEFAULT ':'\n-\t\t{\n-\t\t  tree duplicate;\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\t\t  int success = pushcase (NULL_TREE, 0, label, &duplicate);\n-\t\t  if (success == 1)\n-\t\t    error (\"default label not within a switch statement\");\n-\t\t  else if (success == 2)\n-\t\t    {\n-\t\t      error (\"multiple default labels in one switch\");\n-\t\t      error_with_decl (duplicate, \"this is the first default label\");\n-\t\t    }\n-\t\t  define_case_label (NULL_TREE);\n-\t\t}\n+\t\t{ do_case (NULL_TREE, NULL_TREE); }\n \t  stmt\n \t| BREAK ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ( ! expand_exit_something ())\n+\t\t  if (current_template_parms)\n+\t\t    add_tree (build_min_nt (BREAK_STMT));\n+\t\t  else if ( ! expand_exit_something ())\n \t\t    error (\"break statement not within loop or switch\"); }\n \t| CONTINUE ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if (! expand_continue_loop (0))\n+\t\t  if (current_template_parms)\n+\t\t    add_tree (build_min_nt (CONTINUE_STMT));\n+\t\t  else if (! expand_continue_loop (0))\n \t\t    error (\"continue statement not within a loop\"); }\n \t| RETURN ';'\n \t\t{ emit_line_note (input_filename, lineno);\n@@ -3478,14 +3457,26 @@ simple_stmt:\n \t\t  finish_stmt ();\n \t\t}\n \t| GOTO '*' expr ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_computed_goto ($3); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    add_tree (build_min_nt (GOTO_STMT, $3));\n+\t\t  else\n+\t\t    { emit_line_note (input_filename, lineno);\n+\t\t      expand_computed_goto ($3); }\n+\t\t}\n \t| GOTO identifier ';'\n-\t\t{ tree decl;\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  decl = lookup_label ($2);\n-\t\t  TREE_USED (decl) = 1;\n-\t\t  expand_goto (decl); }\n+\t\t{\n+\t\t  if (current_template_parms)\n+\t\t    add_tree (build_min_nt (GOTO_STMT, $2));\n+\t\t  else\n+\t\t    {\n+\t\t      tree decl;\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      decl = lookup_label ($2);\n+\t\t      TREE_USED (decl) = 1;\n+\t\t      expand_goto (decl); \n+\t\t    }\n+\t\t}\n \t| label_colon stmt\n \t\t{ finish_stmt (); }\n \t| label_colon '}'\n@@ -3563,7 +3554,7 @@ label_colon:\n \t\t{ tree label;\n \t\tdo_label:\n \t\t  label = define_label (input_filename, lineno, $1);\n-\t\t  if (label)\n+\t\t  if (label && ! minimal_parse_mode)\n \t\t    expand_label (label);\n \t\t}\n \t| PTYPENAME ':'"}, {"sha": "5a30c9a2301a5c1dc0d54b08a96fe14d294c6262", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1589, "deletions": 1238, "changes": 2827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2"}, {"sha": "5a859561512b079b5e38b1364735aba0bbd057c8", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -72,13 +72,6 @@ print_lang_type (file, node, indent)\n       return;\n     }\n \n-  if (TREE_CODE (node) == UNINSTANTIATED_P_TYPE)\n-    {\n-      print_node (file, \"template\", UPT_TEMPLATE (node), indent + 4);\n-      print_node (file, \"parameters\", UPT_PARMS (node), indent + 4);\n-      return;\n-    }\n-\n   if (! (TREE_CODE (node) == RECORD_TYPE\n \t || TREE_CODE (node) == UNION_TYPE))\n     return;"}, {"sha": "6800512825b648c0f5bfe1da395574fa4be051ea", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -49,6 +49,7 @@ extern struct obstack permanent_obstack;\n #define IDENTIFIER_REPO_USED(NODE)   (TREE_LANG_FLAG_3 (NODE))\n #define IDENTIFIER_REPO_CHOSEN(NODE) (TREE_LANG_FLAG_4 (NODE))\n \n+#if 0\n /* Record the flags used to compile this translation unit.  */\n \n void\n@@ -82,8 +83,9 @@ void\n repo_class_defined (t)\n      tree t;\n {}\n+#endif\n \n-tree\n+static tree\n repo_get_id (t)\n      tree t;\n {\n@@ -120,7 +122,7 @@ repo_template_used (t)\n   else if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n     {\n       if (IDENTIFIER_REPO_CHOSEN (id))\n-\tmark_function_instantiated (t, 0);\n+\tmark_decl_instantiated (t, 0);\n     }\n   else\n     my_friendly_abort (1);\n@@ -132,9 +134,10 @@ repo_template_used (t)\n     }\n }\n \n+#if 0\n /* Note that the vtable for a class has been used, and offer to emit it.  */\n \n-void\n+static void\n repo_vtable_used (t)\n      tree t;\n {\n@@ -172,6 +175,7 @@ repo_tinfo_used (ti)\n      tree ti;\n {\n }\n+#endif\n \n void\n repo_template_instantiated (t, extern_p)\n@@ -246,7 +250,7 @@ static void\n open_repo_file (filename)\n      char *filename;\n {\n-  register char *p, *q;\n+  register char *p;\n   char *s = get_base_filename (filename);\n \n   if (s == NULL)"}, {"sha": "4a762eb58b543ee769e446bdd734eb52c4144e6f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -37,7 +37,7 @@ extern tree combine_strings PROTO((tree));\n \f\n /* Given the expression EXP of type `class *', return the head\n    of the object pointed to by EXP.  */\n-tree\n+static tree\n build_headof (exp)\n      tree exp;\n {\n@@ -156,7 +156,7 @@ get_typeid (type)\n /* Get a bad_cast node for the program to throw...\n \n    See libstdc++::exception{,.cc} for __bad_cast_object */\n-tree\n+static tree\n get_bad_cast_node ()\n {\n   static tree t;\n@@ -179,7 +179,6 @@ build_dynamic_cast (type, expr)\n   enum tree_code tc = TREE_CODE (type);\n   tree exprtype = TREE_TYPE (expr);\n   enum tree_code ec = TREE_CODE (exprtype);\n-  tree retval;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -268,7 +267,7 @@ build_dynamic_cast (type, expr)\n       else\n \t{\n \t  tree retval;\n-          tree result, td1, td2, elems, tmp1, expr1;\n+          tree result, td1, td2, elems, expr1;\n \n  \t  /* If we got here, we can't convert statically.  Therefore,\n \t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n@@ -462,7 +461,7 @@ static tree\n build_user_desc (tdecl)\n      tree tdecl;\n {\n-  tree elems, name_string, t;\n+  tree elems, name_string;\n   tree tname = DECL_NAME (tdecl);\n \n   name_string = combine_strings (build_string \n@@ -481,13 +480,15 @@ build_class_desc (tdecl, type)\n   tree name_string;\n \n   int i = CLASSTYPE_N_BASECLASSES (type);\n-  int n_base = i;\n   int base_cnt = 0;\n   tree binfos = TYPE_BINFO_BASETYPES (type);\n+#if 0\n+  /* See code below that used these.  */\n   tree vb = CLASSTYPE_VBASECLASSES (type);\n+  int n_base = i;\n+#endif\n   tree base, elems, access, offset, isvir;\n   tree base_list, off_list, acc_list, isvir_list;\n-  tree t;\n   static tree acc_pub = NULL_TREE;\n   static tree acc_pro = NULL_TREE;\n   static tree acc_pri = NULL_TREE;\n@@ -516,7 +517,6 @@ build_class_desc (tdecl, type)\n \t  tree t = BINFO_TYPE (binfo);\n \t  char *name;\n \t  tree field;\n-\t  int off;\n \n \t  name = (char *) alloca (TYPE_NAME_LENGTH (t)+sizeof (VBASE_NAME)+1);\n \t  sprintf (name, VBASE_NAME_FORMAT, TYPE_NAME_STRING (t));\n@@ -659,9 +659,8 @@ build_func_desc (tdecl)\n \n /* Build an initializer for a __ptmf_type_info node.  */\n static tree\n-build_ptmf_desc (tdecl, type)\n+build_ptmf_desc (tdecl)\n      tree tdecl;\n-     tree type;\n { \n   tree elems, name_string;\n   tree tname = DECL_NAME (tdecl);\n@@ -711,7 +710,7 @@ add_uninstantiated_desc (type)\n    objects, we do that here.  Return the type to link against if such a\n    link exists, otherwise just return TYPE.  */\n \n-tree\n+static tree\n get_def_to_follow (type)\n      tree type;\n {\n@@ -735,10 +734,8 @@ build_t_desc (type, definition)\n      tree type;\n      int definition;\n {\n-  tree tdecl;\n-  tree tname, name_string;\n-  tree elems;\n-  tree t, tt, taggr;\n+  tree tdecl, tname;\n+  tree t, taggr;\n \n   if (__ptmd_desc_type_node == NULL_TREE)\n     {\n@@ -841,13 +838,9 @@ build_t_desc (type, definition)\n   else if (IS_AGGR_TYPE (type))\n     {\n       if (TYPE_PTRMEMFUNC_P (type))\n-\t{\n-\t  t = build_ptmf_desc (tdecl, type);\n-\t}\n+\tt = build_ptmf_desc (tdecl);\n       else\n-\t{\n-\t  t = build_class_desc (tdecl, type);\n-\t}\n+\tt = build_class_desc (tdecl, type);\n     }\n   else if (TREE_CODE (type) == FUNCTION_TYPE)\n     t = build_func_desc (tdecl);"}, {"sha": "bd46eb79c25d20c21f4a40b700821c2aa1142b4c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 62, "deletions": 42, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-void init_search ();\n extern struct obstack *current_obstack;\n extern tree abort_fndecl;\n \n@@ -82,8 +81,7 @@ static void dfs_unmark ();\n static void dfs_init_vbase_pointers ();\n \n static tree vbase_types;\n-static tree vbase_decl, vbase_decl_ptr;\n-static tree vbase_decl_ptr_intermediate;\n+static tree vbase_decl_ptr_intermediate, vbase_decl_ptr;\n static tree vbase_init_result;\n \n /* Allocate a level of searching.  */\n@@ -141,12 +139,14 @@ extern int flag_memoize_lookups, flag_save_memoized_contexts;\n static int my_memoized_entry_counter;\n static int memoized_fast_finds[2], memoized_adds[2], memoized_fast_rejects[2];\n static int memoized_fields_searched[2];\n+#ifdef GATHER_STATISTICS\n static int n_fields_searched;\n static int n_calls_lookup_field, n_calls_lookup_field_1;\n static int n_calls_lookup_fnfields, n_calls_lookup_fnfields_1;\n static int n_calls_get_base_type;\n static int n_outer_fields_searched;\n static int n_contexts_saved;\n+#endif\n \n /* Local variables to help save memoization contexts.  */\n static tree prev_type_memoized;\n@@ -249,7 +249,7 @@ my_new_memoized_entry (chain)\n /* Make an entry in the memoized table for type TYPE\n    that the entry for NAME is FIELD.  */\n \n-tree\n+static tree\n make_memoized_table_entry (type, name, function_p)\n      tree type, name;\n      int function_p;\n@@ -492,10 +492,10 @@ get_binfo (parent, binfo, protect)\n \n /* This is the newer depth first get_base_distance routine.  */\n static int\n-get_base_distance_recursive (binfo, depth, is_private, basetype_path, rval,\n+get_base_distance_recursive (binfo, depth, is_private, rval,\n \t\t\t     rval_private_ptr, new_binfo_ptr, parent, path_ptr,\n \t\t\t     protect, via_virtual_ptr, via_virtual)\n-     tree binfo, basetype_path, *new_binfo_ptr, parent, *path_ptr;\n+     tree binfo, *new_binfo_ptr, parent, *path_ptr;\n      int *rval_private_ptr, depth, is_private, rval, protect, *via_virtual_ptr,\n        via_virtual;\n {\n@@ -569,7 +569,7 @@ get_base_distance_recursive (binfo, depth, is_private, basetype_path, rval,\n \n \t  was = WATCH_VALUES (rval, *via_virtual_ptr);\n \t  rval = get_base_distance_recursive (base_binfo, depth, via_private,\n-\t\t\t\t\t      binfo, rval, rval_private_ptr,\n+\t\t\t\t\t      rval, rval_private_ptr,\n \t\t\t\t\t      new_binfo_ptr, parent, path_ptr,\n \t\t\t\t\t      protect, via_virtual_ptr,\n \t\t\t\t\t      this_virtual);\n@@ -619,8 +619,11 @@ get_base_distance (parent, binfo, protect, path_ptr)\n   int via_virtual;\n   int watch_access = protect;\n \n+  /* Should we be completing types here?  */\n   if (TREE_CODE (parent) != TREE_VEC)\n-    parent = TYPE_MAIN_VARIANT (parent);\n+    parent = complete_type (TYPE_MAIN_VARIANT (parent));\n+  else\n+    complete_type (TREE_TYPE (parent));\n \n   if (TREE_CODE (binfo) == TREE_VEC)\n     type = BINFO_TYPE (binfo);\n@@ -647,7 +650,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n   if (path_ptr)\n     watch_access = 1;\n \n-  rval = get_base_distance_recursive (binfo, 0, 0, NULL_TREE, -1,\n+  rval = get_base_distance_recursive (binfo, 0, 0, -1,\n \t\t\t\t      &rval_private, &new_binfo, parent,\n \t\t\t\t      path_ptr, watch_access, &via_virtual, 0);\n \n@@ -721,6 +724,8 @@ lookup_field_1 (type, name)\n       if (TYPE_VIRTUAL_P (type))\n \treturn CLASSTYPE_VFIELD (type);\n     }\n+  if (name == constructor_name (type))\n+    return TYPE_STUB_DECL (type);\n   return NULL_TREE;\n }\n \n@@ -1081,8 +1086,8 @@ lookup_field (xbasetype, name, protect, want_type)\n     }\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)))\n     {\n-      type = xbasetype;\n-      basetype_path = TYPE_BINFO (xbasetype);\n+      type = complete_type (xbasetype);\n+      basetype_path = TYPE_BINFO (type);\n       BINFO_VIA_PUBLIC (basetype_path) = 1;\n       BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n     }\n@@ -1132,7 +1137,10 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    {\n \t      if (TREE_CODE (rval) != TYPE_DECL)\n \t\t{\n-\t\t  rval = purpose_member (name, CLASSTYPE_TAGS (type));\n+\t\t  if (name == constructor_name (type))\n+\t\t    rval = type;\n+\t\t  else\n+\t\t    rval = purpose_member (name, CLASSTYPE_TAGS (type));\n \t\t  if (rval)\n \t\t    rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n \t\t}\n@@ -1314,7 +1322,10 @@ lookup_field (xbasetype, name, protect, want_type)\n \t      {\n \t\tif (TREE_CODE (rval) != TYPE_DECL)\n \t\t  {\n-\t\t    rval = purpose_member (name, CLASSTYPE_TAGS (type));\n+\t\t    if (name == constructor_name (type))\n+\t\t      rval = type;\n+\t\t    else\n+\t\t      rval = purpose_member (name, CLASSTYPE_TAGS (type));\n \t\t    if (rval)\n \t\t      rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n \t\t  }\n@@ -1577,7 +1588,7 @@ lookup_fnfields (basetype_path, name, complain)\n \n   binfo = basetype_path;\n   binfo_h = binfo;\n-  type = BINFO_TYPE (basetype_path);\n+  type = complete_type (BINFO_TYPE (basetype_path));\n \n   /* The memoization code is in need of maintenance. */\n   if (!find_all && CLASSTYPE_MTABLE_ENTRY (type))\n@@ -1826,7 +1837,7 @@ lookup_fnfields (basetype_path, name, complain)\n    QFN, if non-NULL, is a predicate dictating whether the type should\n    even be queued.  */\n \n-HOST_WIDE_INT\n+static HOST_WIDE_INT\n breadth_first_search (binfo, testfn, qfn)\n      tree binfo;\n      int (*testfn)();\n@@ -1932,7 +1943,8 @@ static tree get_virtual_destructor (binfo, i)\n   return 0;\n }\n \n-int tree_has_any_destructor_p (binfo, i)\n+static int\n+tree_has_any_destructor_p (binfo, i)\n      tree binfo;\n      int i;\n {\n@@ -2297,7 +2309,9 @@ dfs_walk (binfo, fn, qfn)\n \n       if (qfn == 0 || (*qfn)(base_binfo))\n \t{\n-\t  if (fn == dfs_init_vbase_pointers)\n+\t  if (TREE_CODE (BINFO_TYPE (base_binfo)) == TEMPLATE_TYPE_PARM)\n+\t    /* Pass */;\n+\t  else if (fn == dfs_init_vbase_pointers)\n \t    {\n \t      /* When traversing an arbitrary MI hierarchy, we need to keep\n \t\t a record of the path we took to get down to the final base\n@@ -2334,8 +2348,9 @@ dfs_walk (binfo, fn, qfn)\n \t      dfs_walk (base_binfo, fn, qfn);\n \n \t      vbase_decl_ptr_intermediate = saved_vbase_decl_ptr_intermediate;\n-\t    } else\n-\t      dfs_walk (base_binfo, fn, qfn);\n+\t    }\n+\t  else\n+\t    dfs_walk (base_binfo, fn, qfn);\n \t}\n     }\n \n@@ -2350,31 +2365,37 @@ static int unnumberedp (binfo) tree binfo;\n \n static int markedp (binfo) tree binfo;\n { return BINFO_MARKED (binfo); }\n-static int bfs_markedp (binfo, i) tree binfo; int i;\n-{ return BINFO_MARKED (BINFO_BASETYPE (binfo, i)); }\n static int unmarkedp (binfo) tree binfo;\n { return BINFO_MARKED (binfo) == 0; }\n+\n+#if 0\n+static int bfs_markedp (binfo, i) tree binfo; int i;\n+{ return BINFO_MARKED (BINFO_BASETYPE (binfo, i)); }\n static int bfs_unmarkedp (binfo, i) tree binfo; int i;\n { return BINFO_MARKED (BINFO_BASETYPE (binfo, i)) == 0; }\n-static int marked_vtable_pathp (binfo) tree binfo;\n-{ return BINFO_VTABLE_PATH_MARKED (binfo); }\n static int bfs_marked_vtable_pathp (binfo, i) tree binfo; int i;\n { return BINFO_VTABLE_PATH_MARKED (BINFO_BASETYPE (binfo, i)); }\n-static int unmarked_vtable_pathp (binfo) tree binfo;\n-{ return BINFO_VTABLE_PATH_MARKED (binfo) == 0; }\n static int bfs_unmarked_vtable_pathp (binfo, i) tree binfo; int i;\n { return BINFO_VTABLE_PATH_MARKED (BINFO_BASETYPE (binfo, i)) == 0; }\n-static int marked_new_vtablep (binfo) tree binfo;\n-{ return BINFO_NEW_VTABLE_MARKED (binfo); }\n static int bfs_marked_new_vtablep (binfo, i) tree binfo; int i;\n { return BINFO_NEW_VTABLE_MARKED (BINFO_BASETYPE (binfo, i)); }\n-static int unmarked_new_vtablep (binfo) tree binfo;\n-{ return BINFO_NEW_VTABLE_MARKED (binfo) == 0; }\n static int bfs_unmarked_new_vtablep (binfo, i) tree binfo; int i;\n { return BINFO_NEW_VTABLE_MARKED (BINFO_BASETYPE (binfo, i)) == 0; }\n+#endif\n+\n+static int marked_vtable_pathp (binfo) tree binfo;\n+{ return BINFO_VTABLE_PATH_MARKED (binfo); }\n+static int unmarked_vtable_pathp (binfo) tree binfo;\n+{ return BINFO_VTABLE_PATH_MARKED (binfo) == 0; }\n+static int marked_new_vtablep (binfo) tree binfo;\n+{ return BINFO_NEW_VTABLE_MARKED (binfo); }\n+static int unmarked_new_vtablep (binfo) tree binfo;\n+{ return BINFO_NEW_VTABLE_MARKED (binfo) == 0; }\n \n+#if 0\n static int dfs_search_slot_nonempty_p (binfo) tree binfo;\n { return CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) != 0; }\n+#endif\n \n static int dfs_debug_unmarkedp (binfo) tree binfo;\n { return CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) == 0; }\n@@ -2400,14 +2421,17 @@ dfs_unnumber (binfo)\n   BINFO_CID (binfo) = 0;\n }\n \n+#if 0\n static void\n dfs_mark (binfo) tree binfo;\n { SET_BINFO_MARKED (binfo); }\n+#endif\n \n static void\n dfs_unmark (binfo) tree binfo;\n { CLEAR_BINFO_MARKED (binfo); }\n \n+#if 0\n static void\n dfs_mark_vtable_path (binfo) tree binfo;\n { SET_BINFO_VTABLE_PATH_MARKED (binfo); }\n@@ -2427,6 +2451,7 @@ dfs_unmark_new_vtable (binfo) tree binfo;\n static void\n dfs_clear_search_slot (binfo) tree binfo;\n { CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) = 0; }\n+#endif\n \n static void\n dfs_debug_mark (binfo)\n@@ -2571,9 +2596,7 @@ init_vbase_pointers (type, decl_ptr)\n       tree binfo = TYPE_BINFO (type);\n       flag_this_is_variable = -2;\n       vbase_types = CLASSTYPE_VBASECLASSES (type);\n-      vbase_decl_ptr = decl_ptr;\n-      vbase_decl = build_indirect_ref (decl_ptr, NULL_PTR);\n-      vbase_decl_ptr_intermediate = vbase_decl_ptr;\n+      vbase_decl_ptr = vbase_decl_ptr_intermediate = decl_ptr;\n       vbase_init_result = NULL_TREE;\n       dfs_walk (binfo, dfs_find_vbases, unmarked_vtable_pathp);\n       dfs_walk (binfo, dfs_init_vbase_pointers, marked_vtable_pathp);\n@@ -2800,7 +2823,7 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n    offsets are valid to store vtables.  When zero, we must store new\n    vtables through virtual baseclass pointers.\n \n-   We setup and use the globals: vbase_decl, vbase_decl_ptr, vbase_types\n+   We setup and use the globals: vbase_decl_ptr, vbase_types\n    ICK!  */\n \n void\n@@ -2816,7 +2839,6 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n       vbase_types = vbases;\n       vbase_decl_ptr = true_exp ? build_unary_op (ADDR_EXPR, true_exp, 0) : decl_ptr;\n-      vbase_decl = true_exp ? true_exp : build_indirect_ref (decl_ptr, NULL_PTR);\n \n       dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep);\n \n@@ -2840,7 +2862,8 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \n \t  if (flag_vtable_thunks)\n \t    {\n-\t      /* We don't have dynamic thunks yet!  So for now, just fail silently. */\n+\t      /* We don't have dynamic thunks yet!\n+\t\t So for now, just fail silently. */\n \t    }\n \t  else\n \t    {\n@@ -3270,13 +3293,9 @@ void\n push_class_decls (type)\n      tree type;\n {\n-  tree id;\n   struct obstack *ambient_obstack = current_obstack;\n-\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n-  id = TYPE_IDENTIFIER (type);\n-\n   /* Push class fields into CLASS_VALUE scope, and mark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_pushdecls, unmarkedp);\n \n@@ -3351,8 +3370,7 @@ unuse_fields (type)\n }\n \n void\n-pop_class_decls (type)\n-     tree type;\n+pop_class_decls ()\n {\n   /* We haven't pushed a search level when dealing with cached classes,\n      so we'd better not try to pop it.  */\n@@ -3400,7 +3418,7 @@ init_search_processing ()\n \n   /* This gives us room to build our chains of basetypes,\n      whether or not we decide to memoize them.  */\n-  type_stack = push_type_level (0, &type_obstack);\n+  type_stack = push_type_level ((struct stack_level *)0, &type_obstack);\n   _vptr_name = get_identifier (\"_vptr\");\n }\n \n@@ -3416,12 +3434,14 @@ reinit_search_statistics ()\n   memoized_fast_rejects[1] = 0;\n   memoized_fields_searched[0] = 0;\n   memoized_fields_searched[1] = 0;\n+#ifdef GATHER_STATISTICS\n   n_fields_searched = 0;\n   n_calls_lookup_field = 0, n_calls_lookup_field_1 = 0;\n   n_calls_lookup_fnfields = 0, n_calls_lookup_fnfields_1 = 0;\n   n_calls_get_base_type = 0;\n   n_outer_fields_searched = 0;\n   n_contexts_saved = 0;\n+#endif\n }\n \n static tree conversions;"}, {"sha": "de687e02a58b2116032e308299a82815ca43b0cb", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -534,7 +534,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t    {\n \t      error (\"class `%s' does not contain a method conforming to `%s'\",\n \t\t     TYPE_NAME_STRING (rhstype),\n-\t\t     fndecl_as_string (NULL, sig_method, 1));\n+\t\t     fndecl_as_string (sig_method, 1));\n \t      undo_casts (sig_ty);\n \t      return error_mark_node;\n \t    }\n@@ -1000,7 +1000,7 @@ build_signature_method_call (basetype, instance, function, parms)\n \t  && (!deflt_call || deflt_call == error_mark_node)))\n     {\n       compiler_error (\"cannot build call of signature member function `%s'\",\n-\t\t      fndecl_as_string (NULL, function, 1));\n+\t\t      fndecl_as_string (function, 1));\n       return error_mark_node;\n     }\n "}, {"sha": "6564cab2e6331fd78e64659df35fd0b2fda6e690", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -295,8 +295,8 @@ yylex()\n \t      if (lastiddecl != trrr)\n \t\t{\n \t\t  lastiddecl = trrr;\n-\t\t  if (got_scope || got_object)\n-\t\t    tmp_token.yylval.ttype = DECL_NESTED_TYPENAME (trrr);\n+\t\t  if (got_scope)\n+\t\t    tmp_token.yylval.ttype = trrr;\n \t\t}\n \t      break;\n \t    case IDENTIFIER:\n@@ -307,7 +307,7 @@ yylex()\n \t      break;\n \t    case NSNAME:\n \t      lastiddecl = trrr;\n-\t      if (got_scope || got_object)\n+\t      if (got_scope)\n \t\ttmp_token.yylval.ttype = trrr;\n \t      break;\n \t    default:\n@@ -352,6 +352,7 @@ yylex()\n       consume_token();\n     }\n \n+  got_object = NULL_TREE;\n   yylval = tmp_token.yylval;\n   yychar = tmp_token.yychar;\n   end_of_file = tmp_token.end_of_file;"}, {"sha": "e5eb64749e5e6294c1eabf73cd42a824be63a247", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 179, "deletions": 14, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -26,6 +26,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"rtl.h\"\n+#ifdef __STDC__\n+#include <stdarg.h>\n+#else\n+#include <varargs.h>\n+#endif\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n@@ -202,10 +207,9 @@ lvalue_or_else (ref, string)\n    and return it so that it can be processed by language-independent\n    and language-specific expression expanders.  */\n tree\n-build_cplus_new (type, init, with_cleanup_p)\n+build_cplus_new (type, init)\n      tree type;\n      tree init;\n-     int with_cleanup_p;\n {\n   tree slot;\n   tree rval;\n@@ -234,7 +238,7 @@ break_out_cleanups (exp)\n \n   if (TREE_CODE (tmp) == CALL_EXPR\n       && TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (tmp)))\n-    return build_cplus_new (TREE_TYPE (tmp), tmp, 1);\n+    return build_cplus_new (TREE_TYPE (tmp), tmp);\n \n   while (TREE_CODE (tmp) == NOP_EXPR\n \t || TREE_CODE (tmp) == CONVERT_EXPR\n@@ -245,7 +249,7 @@ break_out_cleanups (exp)\n \t{\n \t  TREE_OPERAND (tmp, 0)\n \t    = build_cplus_new (TREE_TYPE (TREE_OPERAND (tmp, 0)),\n-\t\t\t       TREE_OPERAND (tmp, 0), 1);\n+\t\t\t       TREE_OPERAND (tmp, 0));\n \t  break;\n \t}\n       else\n@@ -412,7 +416,14 @@ build_cplus_array_type (elt_type, index_type)\n       saveable_obstack = &permanent_obstack;\n     }\n \n-  t = build_array_type (elt_type, index_type);\n+  if (current_template_parms)\n+    {\n+      t = make_node (ARRAY_TYPE);\n+      TREE_TYPE (t) = elt_type;\n+      TYPE_DOMAIN (t) = index_type;\n+    }\n+  else\n+    t = build_array_type (elt_type, index_type);\n \n   /* Push these needs up so that initialization takes place\n      more easily.  */\n@@ -568,7 +579,6 @@ layout_vbasetypes (rec, max)\n   register unsigned const_size = 0;\n   register tree var_size = 0;\n   int nonvirtual_const_size;\n-  tree nonvirtual_var_size;\n \n   CLASSTYPE_VBASECLASSES (rec) = vbase_types;\n \n@@ -578,7 +588,6 @@ layout_vbasetypes (rec, max)\n     var_size = TYPE_SIZE (rec);\n \n   nonvirtual_const_size = const_size;\n-  nonvirtual_var_size = var_size;\n \n   while (vbase_types)\n     {\n@@ -1403,10 +1412,7 @@ build_exception_variant (type, raises)\n      tree type;\n      tree raises;\n {\n-  int i;\n   tree v = TYPE_MAIN_VARIANT (type);\n-  tree t, t2, cname;\n-  tree *a = (tree *)alloca ((list_length (raises)+1) * sizeof (tree));\n   int constp = TYPE_READONLY (type);\n   int volatilep = TYPE_VOLATILE (type);\n \n@@ -1435,6 +1441,7 @@ build_exception_variant (type, raises)\n       raises = copy_list (raises);\n       pop_obstacks ();\n     }\n+\n   TYPE_RAISES_EXCEPTIONS (v) = raises;\n   return v;\n }\n@@ -1449,7 +1456,6 @@ mapcar (t, func)\n      tree t;\n      tree (*func)();\n {\n-  enum tree_code code;\n   tree tmp;\n \n   if (t == NULL_TREE)\n@@ -1458,7 +1464,7 @@ mapcar (t, func)\n   if (tmp = func (t), tmp != NULL_TREE)\n     return tmp;\n \n-  switch (code = TREE_CODE (t))\n+  switch (TREE_CODE (t))\n     {\n     case ERROR_MARK:\n       return error_mark_node;\n@@ -1552,6 +1558,8 @@ mapcar (t, func)\n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case CALL_EXPR:\n+    case ARRAY_REF:\n+    case SCOPE_REF:\n       t = copy_node (t);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n@@ -1646,15 +1654,24 @@ copy_to_permanent (t)\n   return t;\n }\n \n+#ifdef GATHER_STATISTICS\n+extern int depth_reached;\n+#endif\n+\n void\n print_lang_statistics ()\n {\n-  extern struct obstack maybepermanent_obstack;\n+  extern struct obstack maybepermanent_obstack, decl_obstack;\n   print_obstack_statistics (\"class_obstack\", &class_obstack);\n+  print_obstack_statistics (\"decl_obstack\", &decl_obstack);\n   print_obstack_statistics (\"permanent_obstack\", &permanent_obstack);\n   print_obstack_statistics (\"maybepermanent_obstack\", &maybepermanent_obstack);\n   print_search_statistics ();\n   print_class_statistics ();\n+#ifdef GATHER_STATISTICS\n+  fprintf (stderr, \"maximum template instantiation depth reached: %d\\n\",\n+\t   depth_reached);\n+#endif\n }\n \n /* This is used by the `assert' macro.  It is provided in libgcc.a,\n@@ -1720,7 +1737,7 @@ bot_manip (t)\n     return t;\n   else if (TREE_CODE (t) == TARGET_EXPR)\n     return build_cplus_new (TREE_TYPE (t),\n-\t\t\t    break_out_target_exprs (TREE_OPERAND (t, 1)), 0);\n+\t\t\t    break_out_target_exprs (TREE_OPERAND (t, 1)));\n   return NULL_TREE;\n }\n   \n@@ -1819,3 +1836,151 @@ cp_expand_decl_cleanup (decl, cleanup)\n {\n   return expand_decl_cleanup (decl, unsave_expr (cleanup));\n }\n+\n+/* Obstack used for allocating nodes in template function and variable\n+   definitions.  */\n+\n+extern struct obstack *expression_obstack;\n+\n+/* Similar to `build_nt', except we build\n+   on the permanent_obstack, regardless.  */\n+\n+tree\n+build_min_nt VPROTO((enum tree_code code, ...))\n+{\n+#ifndef __STDC__\n+  enum tree_code code;\n+#endif\n+  register struct obstack *ambient_obstack = expression_obstack;\n+  va_list p;\n+  register tree t;\n+  register int length;\n+  register int i;\n+\n+  VA_START (p, code);\n+\n+#ifndef __STDC__\n+  code = va_arg (p, enum tree_code);\n+#endif\n+\n+  expression_obstack = &permanent_obstack;\n+\n+  t = make_node (code);\n+  length = tree_code_length[(int) code];\n+  TREE_COMPLEXITY (t) = lineno;\n+\n+  for (i = 0; i < length; i++)\n+    {\n+      tree x = va_arg (p, tree);\n+      TREE_OPERAND (t, i) = copy_to_permanent (x);\n+    }\n+\n+  va_end (p);\n+  expression_obstack = ambient_obstack;\n+  return t;\n+}\n+\n+/* Similar to `build', except we build\n+   on the permanent_obstack, regardless.  */\n+\n+tree\n+build_min VPROTO((enum tree_code code, tree tt, ...))\n+{\n+#ifndef __STDC__\n+  enum tree_code code;\n+  tree tt;\n+#endif\n+  register struct obstack *ambient_obstack = expression_obstack;\n+  va_list p;\n+  register tree t;\n+  register int length;\n+  register int i;\n+\n+  VA_START (p, tt);\n+\n+#ifndef __STDC__\n+  code = va_arg (p, enum tree_code);\n+  tt = va_arg (p, tree);\n+#endif\n+\n+  expression_obstack = &permanent_obstack;\n+\n+  t = make_node (code);\n+  length = tree_code_length[(int) code];\n+  TREE_TYPE (t) = tt;\n+  TREE_COMPLEXITY (t) = lineno;\n+\n+  for (i = 0; i < length; i++)\n+    {\n+      tree x = va_arg (p, tree);\n+      TREE_OPERAND (t, i) = copy_to_permanent (x);\n+    }\n+\n+  va_end (p);\n+  expression_obstack = ambient_obstack;\n+  return t;\n+}\n+\n+/* Same as `tree_cons' but make a permanent object.  */\n+\n+tree\n+min_tree_cons (purpose, value, chain)\n+     tree purpose, value, chain;\n+{\n+  register tree node;\n+  register struct obstack *ambient_obstack = current_obstack;\n+  current_obstack = &permanent_obstack;\n+\n+  node = tree_cons (purpose, value, chain);\n+  current_obstack = ambient_obstack;\n+  return node;\n+}\n+\n+tree\n+get_type_decl (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == IDENTIFIER_NODE)\n+    return identifier_typedecl_value (t);\n+  if (TREE_CODE (t) == TYPE_DECL)\n+    return t;\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+    return TYPE_STUB_DECL (t);\n+  \n+  my_friendly_abort (42);\n+}\n+\n+int\n+can_free (obstack, t)\n+     struct obstack *obstack;\n+     tree t;\n+{\n+  int size;\n+\n+  if (TREE_CODE (t) == TREE_VEC)\n+    size = (TREE_VEC_LENGTH (t)-1) * sizeof (tree) + sizeof (struct tree_vec);\n+  else\n+    my_friendly_abort (42);\n+\n+#define ROUND(x) ((x + obstack_alignment_mask (obstack)) \\\n+\t\t  & ~ obstack_alignment_mask (obstack))\n+  if ((char *)t + ROUND (size) == obstack_next_free (obstack))\n+    return 1;\n+#undef ROUND\n+\n+  return 0;\n+}\n+\n+/* Return first vector element whose BINFO_TYPE is ELEM.\n+   Return 0 if ELEM is not in VEC.  */\n+\n+tree\n+vec_binfo_member (elem, vec)\n+     tree elem, vec;\n+{\n+  int i;\n+  for (i = 0; i < TREE_VEC_LENGTH (vec); ++i)\n+    if (elem == BINFO_TYPE (TREE_VEC_ELT (vec, i)))\n+      return TREE_VEC_ELT (vec, i);\n+  return NULL_TREE;\n+}"}, {"sha": "e4b944b4784ad92578b86cdb93703eaa461a15c0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 192, "deletions": 62, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -79,7 +79,12 @@ tree\n require_complete_type (value)\n      tree value;\n {\n-  tree type = TREE_TYPE (value);\n+  tree type;\n+\n+  if (current_template_parms)\n+    return value;\n+\n+  type = TREE_TYPE (value);\n \n   /* First, detect a valid value with a complete type.  */\n   if (TYPE_SIZE (type) != 0\n@@ -105,10 +110,35 @@ require_complete_type (value)\n       return require_complete_type (value);\n     }\n \n+  if (IS_AGGR_TYPE (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+    {\n+      instantiate_class_template (type);\n+      if (TYPE_SIZE (type) != 0)\n+\treturn value;\n+    }\n+\n   incomplete_type_error (value, type);\n   return error_mark_node;\n }\n \n+tree\n+complete_type (type)\n+     tree type;\n+{\n+  if (TYPE_SIZE (type) != NULL_TREE)\n+    ;\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree t = complete_type (TREE_TYPE (type));\n+      if (TYPE_SIZE (t) != NULL_TREE)\n+\ttype = build_cplus_array_type (t, TYPE_DOMAIN (type));\n+    }\n+  else if (IS_AGGR_TYPE (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+    instantiate_class_template (type);\n+\n+  return type;\n+}\n+\n /* Return truthvalue of whether type of EXP is instantiated.  */\n int\n type_unknown_p (exp)\n@@ -309,6 +339,11 @@ common_type (t1, t2)\n   if (TREE_CODE (t2) == ENUMERAL_TYPE)\n     t2 = type_for_size (TYPE_PRECISION (t2), 1);\n \n+  if (TYPE_PTRMEMFUNC_P (t1))\n+    t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n+  if (TYPE_PTRMEMFUNC_P (t2))\n+    t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n+\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n@@ -471,7 +506,8 @@ common_type (t1, t2)\n \t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n \t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n \n-\t  if (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2))\n+\t  if (comptypes (b1, b2, 1)\n+\t      || (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n \t    basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t2)));\n \t  else\n \t    {\n@@ -516,9 +552,8 @@ common_type (t1, t2)\n \f\n /* Return 1 if TYPE1 and TYPE2 raise the same exceptions.  */\n int\n-compexcepttypes (t1, t2, strict)\n+compexcepttypes (t1, t2)\n      tree t1, t2;\n-     int strict;\n {\n   return TYPE_RAISES_EXCEPTIONS (t1) == TYPE_RAISES_EXCEPTIONS (t2);\n }\n@@ -611,6 +646,11 @@ comptypes (type1, type2, strict)\n \treturn 1;\n     }\n \n+  if (TYPE_PTRMEMFUNC_P (t1))\n+    t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n+  if (TYPE_PTRMEMFUNC_P (t2))\n+    t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n+\n   /* Different classes of types can't be compatible.  */\n \n   if (TREE_CODE (t1) != TREE_CODE (t2))\n@@ -660,6 +700,28 @@ comptypes (type1, type2, strict)\n     {\n     case RECORD_TYPE:\n     case UNION_TYPE:\n+      if (CLASSTYPE_TEMPLATE_INFO (t1) && CLASSTYPE_TEMPLATE_INFO (t2)\n+\t  && CLASSTYPE_TI_TEMPLATE (t1) == CLASSTYPE_TI_TEMPLATE (t2))\n+\t{\n+\t  int i = TREE_VEC_LENGTH (CLASSTYPE_TI_ARGS (t1));\n+\t  tree *p1 = &TREE_VEC_ELT (CLASSTYPE_TI_ARGS (t1), 0);\n+\t  tree *p2 = &TREE_VEC_ELT (CLASSTYPE_TI_ARGS (t2), 0);\n+\t\n+\t  while (i--)\n+\t    {\n+\t      if (TREE_CODE_CLASS (TREE_CODE (p1[i])) == 't')\n+\t\t{\n+\t\t  if (! comptypes (p1[i], p2[i], 1))\n+\t\t    return 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (simple_cst_equal (p1[i], p2[i]) <= 0)\n+\t\t    return 0;\n+\t\t}\n+\t    }\n+\t  return 1;\n+\t}\n       if (strict <= 0)\n \tgoto look_hard;\n       return 0;\n@@ -671,7 +733,7 @@ comptypes (type1, type2, strict)\n       break;\n \n     case METHOD_TYPE:\n-      if (! compexcepttypes (t1, t2, strict))\n+      if (! compexcepttypes (t1, t2))\n \treturn 0;\n \n       /* This case is anti-symmetrical!\n@@ -719,7 +781,7 @@ comptypes (type1, type2, strict)\n       break;\n \n     case FUNCTION_TYPE:\n-      if (! compexcepttypes (t1, t2, strict))\n+      if (! compexcepttypes (t1, t2))\n \treturn 0;\n \n       val = ((TREE_TYPE (t1) == TREE_TYPE (t2)\n@@ -734,30 +796,6 @@ comptypes (type1, type2, strict)\n \n     case TEMPLATE_TYPE_PARM:\n       return TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2);\n-\n-    case UNINSTANTIATED_P_TYPE:\n-      if (UPT_TEMPLATE (t1) != UPT_TEMPLATE (t2))\n-\treturn 0;\n-      {\n-\tint i = TREE_VEC_LENGTH (UPT_PARMS (t1));\n-\ttree *p1 = &TREE_VEC_ELT (UPT_PARMS (t1), 0);\n-\ttree *p2 = &TREE_VEC_ELT (UPT_PARMS (t2), 0);\n-\t\n-\twhile (i--)\n-\t  {\n-\t    if (TREE_CODE_CLASS (TREE_CODE (p1[i])) == 't')\n-\t      {\n-\t\tif (! comptypes (p1[i], p2[i], 1))\n-\t\t  return 0;\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (simple_cst_equal (p1[i], p2[i]) <= 0)\n-\t\t  return 0;\n-\t      }\n-\t  }\n-      }\n-      return 1;\n     }\n   return attrval == 2 && val == 1 ? 2 : val;\n }\n@@ -889,7 +927,7 @@ tree\n common_base_type (tt1, tt2)\n      tree tt1, tt2;\n {\n-  tree best = NULL_TREE, tmp;\n+  tree best = NULL_TREE;\n   int i;\n \n   /* If one is a baseclass of another, that's good enough.  */\n@@ -1215,6 +1253,9 @@ c_sizeof (type)\n   enum tree_code code = TREE_CODE (type);\n   tree t;\n \n+  if (current_template_parms)\n+    return build_min (SIZEOF_EXPR, sizetype, type);\n+\n   if (code == FUNCTION_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n@@ -1259,9 +1300,9 @@ c_sizeof (type)\n       return size_int (0);\n     }\n \n-  if (TYPE_SIZE (type) == 0)\n+  if (TYPE_SIZE (complete_type (type)) == 0)\n     {\n-      error (\"`sizeof' applied to an incomplete type\");\n+      cp_error (\"`sizeof' applied to incomplete type `%T'\", type);\n       return size_int (0);\n     }\n \n@@ -1274,6 +1315,36 @@ c_sizeof (type)\n   return t;\n }\n \n+tree\n+expr_sizeof (e)\n+     tree e;\n+{\n+  if (current_template_parms)\n+    return build_min (SIZEOF_EXPR, sizetype, e);\n+\n+  if (TREE_CODE (e) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (e, 1)))\n+    error (\"sizeof applied to a bit-field\");\n+  /* ANSI says arrays and functions are converted inside comma.\n+     But we can't really convert them in build_compound_expr\n+     because that would break commas in lvalues.\n+     So do the conversion here if operand was a comma.  */\n+  if (TREE_CODE (e) == COMPOUND_EXPR\n+      && (TREE_CODE (TREE_TYPE (e)) == ARRAY_TYPE\n+\t  || TREE_CODE (TREE_TYPE (e)) == FUNCTION_TYPE))\n+    e = default_conversion (e);\n+  else if (TREE_CODE (e) == TREE_LIST)\n+    {\n+      tree t = TREE_VALUE (e);\n+      if (t != NULL_TREE\n+\t  && ((TREE_TYPE (t)\n+\t       && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+\t      || is_overloaded_fn (t)))\n+\tpedwarn (\"ANSI C++ forbids taking the sizeof a function type\");\n+    }\n+  return c_sizeof (TREE_TYPE (e));\n+}\n+  \n tree\n c_sizeof_nowarn (type)\n      tree type;\n@@ -1657,10 +1728,13 @@ build_component_ref (datum, component, basetype_path, protect)\n      int protect;\n {\n   register tree basetype = TREE_TYPE (datum);\n-  register enum tree_code code = TREE_CODE (basetype);\n+  register enum tree_code code;\n   register tree field = NULL;\n   register tree ref;\n \n+  if (current_template_parms)\n+    return build_min_nt (COMPONENT_REF, datum, component);\n+\n   /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it. */\n   switch (TREE_CODE (datum))\n     {\n@@ -1680,6 +1754,8 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t      basetype_path, protect));\n     }\n \n+  code = TREE_CODE (basetype);\n+\n   if (code == REFERENCE_TYPE)\n     {\n       datum = convert_from_reference (datum);\n@@ -1703,7 +1779,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       return error_mark_node;\n     }\n \n-  if (TYPE_SIZE (basetype) == 0)\n+  if (TYPE_SIZE (complete_type (basetype)) == 0)\n     {\n       incomplete_type_error (0, basetype);\n       return error_mark_node;\n@@ -1888,7 +1964,12 @@ build_x_indirect_ref (ptr, errorstring)\n      tree ptr;\n      char *errorstring;\n {\n-  tree rval = build_opfncall (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE, NULL_TREE);\n+  tree rval;\n+\n+  if (current_template_parms)\n+    return build_min_nt (INDIRECT_REF, ptr);\n+\n+  rval = build_opfncall (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE, NULL_TREE);\n   if (rval)\n     return rval;\n   return build_indirect_ref (ptr, errorstring);\n@@ -1984,8 +2065,6 @@ tree\n build_array_ref (array, idx)\n      tree array, idx;\n {\n-  tree itype;\n-\n   if (idx == 0)\n     {\n       error (\"subscript missing in array reference\");\n@@ -1996,8 +2075,6 @@ build_array_ref (array, idx)\n       || TREE_TYPE (idx) == error_mark_node)\n     return error_mark_node;\n \n-  itype = TREE_TYPE (idx);\n-\n   if (TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE\n       && TREE_CODE (array) != INDIRECT_REF)\n     {\n@@ -2145,6 +2222,9 @@ build_x_function_call (function, params, decl)\n   if (function == error_mark_node)\n     return error_mark_node;\n \n+  if (current_template_parms)\n+    return build_min_nt (CALL_EXPR, function, params, 0);\n+\n   type = TREE_TYPE (function);\n   is_method = ((TREE_CODE (function) == TREE_LIST\n \t\t&& current_class_type != NULL_TREE\n@@ -2818,8 +2898,13 @@ build_x_binary_op (code, arg1, arg2)\n      enum tree_code code;\n      tree arg1, arg2;\n {\n-  tree rval = build_opfncall (code, LOOKUP_SPECULATIVELY,\n-\t\t\t      arg1, arg2, NULL_TREE);\n+  tree rval;\n+\n+  if (current_template_parms)\n+    return build_min_nt (code, arg1, arg2);\n+\n+  rval = build_opfncall (code, LOOKUP_SPECULATIVELY,\n+\t\t\t arg1, arg2, NULL_TREE);\n   if (rval)\n     return build_opfncall (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n   if (code == MEMBER_REF)\n@@ -2841,7 +2926,6 @@ build_binary_op (code, arg1, arg2, convert_p)\n \n   if (convert_p)\n     {\n-      tree args_save [2];\n       tree type0, type1;\n       args[0] = decay_conversion (args[0]);\n       args[1] = decay_conversion (args[1]);\n@@ -3483,7 +3567,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t it never happens because available widths are 2**N.  */\n \t      && (!TREE_UNSIGNED (final_type)\n \t\t  || unsigned_arg\n-\t\t  || ((unsigned) 2 * TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t  || (((unsigned) 2 * TYPE_PRECISION (TREE_TYPE (arg0)))\n \t\t      <= TYPE_PRECISION (result_type))))\n \t    {\n \t      /* Do an unsigned shift if the operand was zero-extended.  */\n@@ -3578,8 +3662,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t     have all bits set that are set in the ~ operand when it is\n \t     extended.  */\n \n-\t  if (TREE_CODE (primop0) == BIT_NOT_EXPR\n-\t      ^ TREE_CODE (primop1) == BIT_NOT_EXPR)\n+\t  if ((TREE_CODE (primop0) == BIT_NOT_EXPR)\n+\t      ^ (TREE_CODE (primop1) == BIT_NOT_EXPR))\n \t    {\n \t      if (TREE_CODE (primop0) == BIT_NOT_EXPR)\n \t\tprimop0 = get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n@@ -3705,7 +3789,7 @@ pointer_int_sum (resultcode, ptrop, intop)\n       size_exp = integer_one_node;\n     }\n   else\n-    size_exp = size_in_bytes (TREE_TYPE (result_type));\n+    size_exp = size_in_bytes (complete_type (TREE_TYPE (result_type)));\n \n   /* Needed to make OOPS V2R3 work.  */\n   intop = folded;\n@@ -3863,6 +3947,9 @@ build_x_unary_op (code, xarg)\n      enum tree_code code;\n      tree xarg;\n {\n+  if (current_template_parms)\n+    return build_min_nt (code, xarg, NULL_TREE);\n+\n   /* & rec, on incomplete RECORD_TYPEs is the simple opr &, not an\n      error message. */\n   if (code == ADDR_EXPR\n@@ -3887,7 +3974,10 @@ tree\n condition_conversion (expr)\n      tree expr;\n {\n-  tree t = convert (boolean_type_node, expr);\n+  tree t;\n+  if (current_template_parms)\n+    return expr;\n+  t = convert (boolean_type_node, expr);\n   t = fold (build1 (CLEANUP_POINT_EXPR, boolean_type_node, t));\n   return t;\n }\n@@ -4018,7 +4108,7 @@ build_unary_op (code, xarg, noconvert)\n \tif (TREE_CODE (argtype) == POINTER_TYPE)\n \t  {\n \t    enum tree_code tmp = TREE_CODE (TREE_TYPE (argtype));\n-\t    if (TYPE_SIZE (TREE_TYPE (argtype)) == 0)\n+\t    if (TYPE_SIZE (complete_type (TREE_TYPE (argtype))) == 0)\n \t      cp_error (\"cannot %s a pointer to incomplete type `%T'\",\n \t\t\t((code == PREINCREMENT_EXPR\n \t\t\t  || code == POSTINCREMENT_EXPR)\n@@ -4420,7 +4510,7 @@ unary_complex_lvalue (code, arg)\n \tif (TREE_CODE (arg) == SAVE_EXPR)\n \t  targ = arg;\n \telse\n-\t  targ = build_cplus_new (TREE_TYPE (arg), arg, 1);\n+\t  targ = build_cplus_new (TREE_TYPE (arg), arg);\n \treturn build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg)), targ);\n       }\n \n@@ -4531,6 +4621,9 @@ build_x_conditional_expr (ifexp, op1, op2)\n {\n   tree rval = NULL_TREE;\n \n+  if (current_template_parms)\n+    return build_min_nt (COND_EXPR, ifexp, op1, op2);\n+\n   /* See comments in `build_x_binary_op'.  */\n   if (op1 != 0)\n     rval = build_opfncall (COND_EXPR, LOOKUP_SPECULATIVELY, ifexp, op1, op2);\n@@ -4838,6 +4931,9 @@ build_x_compound_expr (list)\n   tree rest = TREE_CHAIN (list);\n   tree result;\n \n+  if (current_template_parms)\n+    return build_min_nt (COMPOUND_EXPR, list, NULL_TREE);\n+\n   if (rest == NULL_TREE)\n     return build_compound_expr (list);\n \n@@ -4915,6 +5011,13 @@ tree build_reinterpret_cast (type, expr)\n \n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+\n+  if (current_template_parms)\n+    {\n+      tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n+      return t;\n+    }\n+\n   if (TYPE_PTRMEMFUNC_P (intype))\n     intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n \n@@ -5080,6 +5183,13 @@ build_c_cast (type, expr, allow_nonconverting)\n       && TREE_CHAIN (value) == NULL_TREE)\n     value = TREE_VALUE (value);\n \n+  if (current_template_parms)\n+    {\n+      tree t = build_min (CAST_EXPR, type,\n+\t\t\t  min_tree_cons (NULL_TREE, value, NULL_TREE));\n+      return t;\n+    }\n+\n   if (TREE_CODE (type) == VOID_TYPE)\n     value = build1 (CONVERT_EXPR, type, value);\n   else if (TREE_TYPE (value) == NULL_TREE\n@@ -5625,7 +5735,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t\t NULL_TREE, 0);\n       if (TREE_CODE (newrhs) == CALL_EXPR\n \t  && TYPE_NEEDS_CONSTRUCTING (lhstype))\n-\tnewrhs = build_cplus_new (lhstype, newrhs, 0);\n+\tnewrhs = build_cplus_new (lhstype, newrhs);\n \n       /* Can't initialize directly from a TARGET_EXPR, since that would\n \t cause the lhs to be constructed twice, and possibly result in\n@@ -5700,6 +5810,25 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t NULL_TREE, 0);\n }\n \n+tree\n+build_x_modify_expr (lhs, modifycode, rhs)\n+     tree lhs;\n+     enum tree_code modifycode;\n+     tree rhs;\n+{\n+  if (current_template_parms)\n+    return build_min_nt (MODOP_EXPR, lhs,\n+\t\t\t build_min_nt (modifycode, 0, 0), rhs);\n+\n+  if (modifycode != NOP_EXPR)\n+    {\n+      tree rval = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, lhs, rhs,\n+\t\t\t\t  make_node (modifycode));\n+      if (rval)\n+\treturn rval;\n+    }\n+  return build_modify_expr (lhs, modifycode, rhs);\n+}\n \n /* Return 0 if EXP is not a valid lvalue in this language\n    even though `lvalue_or_else' would accept it.  */\n@@ -6216,8 +6345,8 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  for (; ; ttl = TREE_TYPE (ttl), ttr = TREE_TYPE (ttr))\n \t    {\n \t      nptrs -= 1;\n-\t      const_parity |= TYPE_READONLY (ttl) < TYPE_READONLY (ttr);\n-\t      volatile_parity |= TYPE_VOLATILE (ttl) < TYPE_VOLATILE (ttr);\n+\t      const_parity |= (TYPE_READONLY (ttl) < TYPE_READONLY (ttr));\n+\t      volatile_parity |= (TYPE_VOLATILE (ttl) < TYPE_VOLATILE (ttr));\n \n \t      if (! left_const\n \t\t  && (TYPE_READONLY (ttl) > TYPE_READONLY (ttr)\n@@ -6525,7 +6654,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t     cleanups if it is used.  */\n \t  if (TREE_CODE (rhs) == CALL_EXPR)\n \t    {\n-\t      rhs = build_cplus_new (type, rhs, 0);\n+\t      rhs = build_cplus_new (type, rhs);\n \t      return rhs;\n \t    }\n \t  /* Handle the case of default parameter initialization and\n@@ -6542,7 +6671,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t\t    = build_unary_op (ADDR_EXPR, exp, 0);\n \t\t}\n \t      else\n-\t\trhs = build_cplus_new (type, TREE_OPERAND (rhs, 0), 0);\n+\t\trhs = build_cplus_new (type, TREE_OPERAND (rhs, 0));\n \t      return rhs;\n \t    }\n \t  else if (TYPE_HAS_TRIVIAL_INIT_REF (type))\n@@ -6562,7 +6691,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \n \t      if (exp == 0)\n \t\t{\n-\t\t  exp = build_cplus_new (type, init, 0);\n+\t\t  exp = build_cplus_new (type, init);\n \t\t  return exp;\n \t\t}\n \n@@ -6675,7 +6804,6 @@ c_expand_return (retval)\n   extern tree dtor_label, ctor_label;\n   tree result = DECL_RESULT (current_function_decl);\n   tree valtype = TREE_TYPE (result);\n-  register int use_temp = 0;\n   int returns_value = 1;\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n@@ -6687,6 +6815,12 @@ c_expand_return (retval)\n       return;\n     }\n \n+  if (current_template_parms)\n+    {\n+      add_tree (build_min_nt (RETURN_STMT, retval));\n+      return;\n+    }\n+\n   if (retval == NULL_TREE)\n     {\n       /* A non-named return value does not count.  */\n@@ -6827,10 +6961,7 @@ c_expand_return (retval)\n \n       if (TYPE_MODE (valtype) != BLKmode\n \t  && any_pending_cleanups (1))\n-\t{\n-\t  retval = get_temp_regvar (valtype, retval);\n-\t  use_temp = obey_regdecls;\n-\t}\n+\tretval = get_temp_regvar (valtype, retval);\n     }\n   else if (IS_AGGR_TYPE (valtype) && current_function_returns_struct)\n     {\n@@ -6855,7 +6986,6 @@ c_expand_return (retval)\n \t{\n \t  retval = get_temp_regvar (valtype, retval);\n \t  expand_cleanups_to (NULL_TREE);\n-\t  use_temp = obey_regdecls;\n \t  result = 0;\n \t}\n       else"}, {"sha": "891a9f70a497a42c97454ee603c53da9323a02dc", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -468,8 +468,8 @@ initializer_constant_valid_p (value, endtype)\n       return 0;\n \n     case PLUS_EXPR:\n-      if (TREE_CODE (endtype) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n+      if ((TREE_CODE (endtype) == INTEGER_TYPE)\n+\t  && (TYPE_PRECISION (endtype) < POINTER_SIZE))\n \treturn 0;\n       {\n \ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n@@ -485,8 +485,8 @@ initializer_constant_valid_p (value, endtype)\n       }\n \n     case MINUS_EXPR:\n-      if (TREE_CODE (endtype) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n+      if ((TREE_CODE (endtype) == INTEGER_TYPE)\n+\t  && (TYPE_PRECISION (endtype) < POINTER_SIZE))\n \treturn 0;\n       {\n \ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n@@ -1287,6 +1287,9 @@ build_x_arrow (datum)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n+  if (current_template_parms)\n+    return build_min_nt (ARROW_EXPR, rval);\n+\n   if (TREE_CODE (rval) == OFFSET_REF)\n     {\n       rval = resolve_offset_ref (datum);\n@@ -1299,7 +1302,7 @@ build_x_arrow (datum)\n       type = TREE_TYPE (rval);\n     }\n \n-  if (IS_AGGR_TYPE (type) && TYPE_OVERLOADS_ARROW (type))\n+  if (IS_AGGR_TYPE (type) && TYPE_OVERLOADS_ARROW (complete_type (type)))\n     {\n       while ((rval = build_opfncall (COMPONENT_REF, LOOKUP_NORMAL, rval, NULL_TREE, NULL_TREE)))\n \t{\n@@ -1359,6 +1362,9 @@ build_m_component_ref (datum, component)\n   tree rettype;\n   tree binfo;\n \n+  if (current_template_parms)\n+    return build_min_nt (DOTSTAR_EXPR, datum, component);\n+\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (component)))\n     {\n       type = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (component)));\n@@ -1445,6 +1451,9 @@ build_functional_cast (exp, parms)\n   else\n     type = exp;\n \n+  if (current_template_parms)\n+    return build_min (CAST_EXPR, type, parms);\n+\n   if (IS_SIGNATURE (type))\n     {\n       error (\"signature type not allowed in cast or constructor expression\");\n@@ -1480,7 +1489,7 @@ build_functional_cast (exp, parms)\n \tname = DECL_NESTED_TYPENAME (name);\n     }\n \n-  if (TYPE_SIZE (type) == NULL_TREE)\n+  if (TYPE_SIZE (complete_type (type)) == NULL_TREE)\n     {\n       cp_error (\"type `%T' is not yet defined\", type);\n       return error_mark_node;\n@@ -1495,7 +1504,7 @@ build_functional_cast (exp, parms)\n   if (expr_as_ctor == error_mark_node)\n     return error_mark_node;\n \n-  return build_cplus_new (type, expr_as_ctor, 1);\n+  return build_cplus_new (type, expr_as_ctor);\n }\n \f\n /* Return the character string for the name that encodes the"}, {"sha": "2645848b7a781de3e660879deae739eb55eb62c2", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5566b478bdfe8bfc554a57f2631c1d3646ac4ae2/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=5566b478bdfe8bfc554a57f2631c1d3646ac4ae2", "patch": "@@ -183,7 +183,7 @@ GNU_xref_end (ect)\n   if (xf == NULL) return;\n \n   while (cur_scope != NULL)\n-    GNU_xref_end_scope(cur_scope->gid,0,0,0,0);\n+    GNU_xref_end_scope(cur_scope->gid,0,0,0);\n \n   doing_xref = 0;\n \n@@ -275,10 +275,10 @@ GNU_xref_start_scope (id)\n    TRNS is ???  */\n \n void\n-GNU_xref_end_scope (id,inid,prm,keep,trns)\n+GNU_xref_end_scope (id,inid,prm,keep)\n    HOST_WIDE_INT id;\n    HOST_WIDE_INT inid;\n-   int prm,keep,trns;\n+   int prm,keep;\n {\n   XREF_FILE xf;\n   XREF_SCOPE xs,lxs,oxs;\n@@ -400,7 +400,7 @@ GNU_xref_decl (fndecl,decl)\n     }\n   else if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n-      if (DECL_TEMPLATE_IS_CLASS (decl))\n+      if (TREE_CODE (DECL_RESULT (decl)) == TYPE_DECL)\n \tcls = \"CLASSTEMP\";\n       else if (TREE_CODE (DECL_RESULT (decl)) == FUNCTION_DECL)\n \tcls = \"FUNCTEMP\";\n@@ -599,7 +599,9 @@ GNU_xref_member(cls, fld)\n   char *prot;\n   int confg, pure;\n   char *d;\n+#ifdef XREF_SHORT_MEMBER_NAMES\n   int i;\n+#endif\n   char buf[1024], bufa[1024];\n \n   if (!doing_xref) return;\n@@ -622,7 +624,9 @@ GNU_xref_member(cls, fld)\n \n   d = IDENTIFIER_POINTER(cls);\n   sprintf(buf, \"%d%s\", strlen(d), d);\n+#ifdef XREF_SHORT_MEMBER_NAMES\n   i = strlen(buf);\n+#endif\n   strcpy(bufa, declname(fld));\n \n #ifdef XREF_SHORT_MEMBER_NAMES"}]}