{"sha": "03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNjMmEzMDhmMzJiMDFiZGI1YmVhNTUzOGJjY2JiOWI4ODViNDdhOQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2009-01-22T07:15:41Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2009-01-22T07:15:41Z"}, "message": "Reverted commit 143546 related to PR c++/26693\n\nFrom-SVN: r143562", "tree": {"sha": "8c0ca9e4a8b6ac8aced92cf10fba12e1269c35c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c0ca9e4a8b6ac8aced92cf10fba12e1269c35c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/comments", "author": null, "committer": null, "parents": [{"sha": "73cc93abd2d93d6d5dcbfb8654bc7718a13c2476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476"}], "stats": {"total": 456, "additions": 148, "deletions": 308}, "files": [{"sha": "d2e64ab3fd76de55d27b2d44afaef7078573cb46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -1,3 +1,13 @@\n+2009-01-22  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/38930\n+\t* c-decl.c: (clone_underlying_type): Revert PR c++/26693 changes.\n+\t* c-common.c (set_underlying_type): Likewise.\n+\t(is_typedef_decl ): Likewise\n+\t* tree.h: Likewise\n+\t(set_underlying_type): Likewise.\n+\t(is_typedef_type): Likewise.\n+\n 2009-01-21  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/38587"}, {"sha": "5eed1dc89e1b5dda78afb85aa3d30569059aaa33", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -8363,73 +8363,4 @@ warn_for_sign_compare (location_t location,\n     }\n }\n \n-/* Setup a TYPE_DECL node as a typedef representation.\n-\n-   X is a TYPE_DECL for a typedef statement.  Create a brand new\n-   ..._TYPE node (which will be just a variant of the existing\n-   ..._TYPE node with identical properties) and then install X\n-   as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n-\n-   The whole point here is to end up with a situation where each\n-   and every ..._TYPE node the compiler creates will be uniquely\n-   associated with AT MOST one node representing a typedef name.\n-   This way, even though the compiler substitutes corresponding\n-   ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n-   early on, later parts of the compiler can always do the reverse\n-   translation and get back the corresponding typedef name.  For\n-   example, given:\n-\n-\ttypedef struct S MY_TYPE;\n-\tMY_TYPE object;\n-\n-   Later parts of the compiler might only know that `object' was of\n-   type `struct S' if it were not for code just below.  With this\n-   code however, later parts of the compiler see something like:\n-\n-\tstruct S' == struct S\n-\ttypedef struct S' MY_TYPE;\n-\tstruct S' object;\n-\n-    And they can then deduce (from the node for type struct S') that\n-    the original object declaration was:\n-\n-\t\tMY_TYPE object;\n-\n-    Being able to do this is important for proper support of protoize,\n-    and also for generating precise symbolic debugging information\n-    which takes full account of the programmer's (typedef) vocabulary.\n-\n-    Obviously, we don't want to generate a duplicate ..._TYPE node if\n-    the TYPE_DECL node that we are now processing really represents a\n-    standard built-in type.  */\n-\n-void\n-set_underlying_type (tree x)\n-{\n-  if (DECL_IS_BUILTIN (x))\n-    {\n-      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n-\tTYPE_NAME (TREE_TYPE (x)) = x;\n-    }\n-  else if (TREE_TYPE (x) != error_mark_node\n-\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n-    {\n-      tree tt = TREE_TYPE (x);\n-      DECL_ORIGINAL_TYPE (x) = tt;\n-      tt = build_variant_type_copy (tt);\n-      TYPE_STUB_DECL (tt) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n-      TYPE_NAME (tt) = x;\n-      TREE_USED (tt) = TREE_USED (x);\n-      TREE_TYPE (x) = tt;\n-    }\n-}\n-\n-/* Returns true if X is a typedef type.  */\n-bool\n-is_typedef_decl (tree x)\n-{\n-  return (x && TREE_CODE (x) == TYPE_DECL\n-          && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n-}\n-\n #include \"gt-c-common.h\""}, {"sha": "7f7f2b00ac73c4538004b50280e7881c906b1b71", "filename": "gcc/c-decl.c", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -1971,6 +1971,67 @@ warn_if_shadowing (tree new_decl)\n       }\n }\n \n+\n+/* Subroutine of pushdecl.\n+\n+   X is a TYPE_DECL for a typedef statement.  Create a brand new\n+   ..._TYPE node (which will be just a variant of the existing\n+   ..._TYPE node with identical properties) and then install X\n+   as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n+\n+   The whole point here is to end up with a situation where each\n+   and every ..._TYPE node the compiler creates will be uniquely\n+   associated with AT MOST one node representing a typedef name.\n+   This way, even though the compiler substitutes corresponding\n+   ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n+   early on, later parts of the compiler can always do the reverse\n+   translation and get back the corresponding typedef name.  For\n+   example, given:\n+\n+\ttypedef struct S MY_TYPE;\n+\tMY_TYPE object;\n+\n+   Later parts of the compiler might only know that `object' was of\n+   type `struct S' if it were not for code just below.  With this\n+   code however, later parts of the compiler see something like:\n+\n+\tstruct S' == struct S\n+\ttypedef struct S' MY_TYPE;\n+\tstruct S' object;\n+\n+    And they can then deduce (from the node for type struct S') that\n+    the original object declaration was:\n+\n+\t\tMY_TYPE object;\n+\n+    Being able to do this is important for proper support of protoize,\n+    and also for generating precise symbolic debugging information\n+    which takes full account of the programmer's (typedef) vocabulary.\n+\n+    Obviously, we don't want to generate a duplicate ..._TYPE node if\n+    the TYPE_DECL node that we are now processing really represents a\n+    standard built-in type.  */\n+\n+static void\n+clone_underlying_type (tree x)\n+{\n+  if (DECL_IS_BUILTIN (x))\n+    {\n+      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n+\tTYPE_NAME (TREE_TYPE (x)) = x;\n+    }\n+  else if (TREE_TYPE (x) != error_mark_node\n+\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n+    {\n+      tree tt = TREE_TYPE (x);\n+      DECL_ORIGINAL_TYPE (x) = tt;\n+      tt = build_variant_type_copy (tt);\n+      TYPE_NAME (tt) = x;\n+      TREE_USED (tt) = TREE_USED (x);\n+      TREE_TYPE (x) = tt;\n+    }\n+}\n+\n /* Record a decl-node X as belonging to the current lexical scope.\n    Check for errors (such as an incompatible declaration for the same\n    name already seen in the same scope).\n@@ -2193,7 +2254,7 @@ pushdecl (tree x)\n \n  skip_external_and_shadow_checks:\n   if (TREE_CODE (x) == TYPE_DECL)\n-    set_underlying_type (x);\n+    clone_underlying_type (x);\n \n   bind (name, x, scope, /*invisible=*/false, nested);\n "}, {"sha": "a7d18d22fb64d7c1d3b5b8b8241d070b5c4acc98", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -1,3 +1,18 @@\n+2009-01-22  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/38930\n+\t* decl2.c (grokfield): Reverting changes of PR c++/26693\n+\t(save_template_attributes): Likewise.\n+\t* decl.c (grokdeclarator): Likewise.\n+\t* name-lookup.c (pushdecl_maybe_friend): Likewise.\n+\t* cp-tree.h (MEMBER_TYPES_NEEDING_ACCESS_CHECK): Likewise.\n+\t(append_type_to_template_for_access_check): Likewise.\n+\t* semantics.c (check_accessibility_of_qualified_id): Likewise.\n+\t* pt.c (instantiate_class_template, instantiate_template ): Likewise.\n+\t(tsubst): Likewise.\n+\t(resolve_type_name_type): Likewise.\n+\t(append_type_to_template_for_access_check): Likewise.\n+\n 2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/26693"}, {"sha": "186ec9ab6adffef6a615d8ba42cd3bc9b79e28c5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -3179,14 +3179,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == TYPE_DECL \\\n    && !DECL_TEMPLATE_TEMPLATE_PARM_P (NODE))\n \n-/* The chained list of some types that are referenced in templates.\n-   These types are those which need to be access checked at\n-   template instantiation time.  For the time being, only typedef-ed types defined\n-   as class members are put here at parsing time.\n-   Other types for which access check could be required at template instantiation\n-   time could be added later.  */\n-#define MEMBER_TYPES_NEEDING_ACCESS_CHECK(NODE) DECL_ACCESS (NODE)\n-\n /* Nonzero if NODE which declares a type.  */\n #define DECL_DECLARES_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == TYPE_DECL || DECL_CLASS_TEMPLATE_P (NODE))\n@@ -4547,7 +4539,6 @@ extern tree check_explicit_specialization\t(tree, tree, int, int);\n extern tree make_auto\t\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);\n-extern void append_type_to_template_for_access_check (tree, tree, tree);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, tree, bool, bool);"}, {"sha": "8476959bff44976f44ae31428d85c229d6b0560d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -8729,7 +8729,6 @@ grokdeclarator (const cp_declarator *declarator,\n \tdecl = build_lang_decl (TYPE_DECL, unqualified_id, type);\n       else\n \tdecl = build_decl (TYPE_DECL, unqualified_id, type);\n-\n       if (id_declarator && declarator->u.id.qualifying_scope) {\n \terror (\"%Jtypedef name may not be a nested-name-specifier\", decl);\n \tTREE_TYPE (decl) = error_mark_node;\n@@ -8764,11 +8763,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t  && TYPE_ANONYMOUS_P (type)\n \t  && cp_type_quals (type) == TYPE_UNQUALIFIED)\n \t{\n+\t  tree oldname = TYPE_NAME (type);\n \t  tree t;\n \n \t  /* Replace the anonymous name with the real name everywhere.  */\n \t  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n-\t    if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t    if (TYPE_NAME (t) == oldname)\n \t      TYPE_NAME (t) = decl;\n \n \t  if (TYPE_LANG_SPECIFIC (type))"}, {"sha": "c8887257ece17cef31d57886738c18b01237eead", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -804,9 +804,6 @@ grokfield (const cp_declarator *declarator,\n       DECL_NONLOCAL (value) = 1;\n       DECL_CONTEXT (value) = current_class_type;\n \n-      if (declspecs->specs[(int)ds_typedef])\n-\tset_underlying_type (value);\n-\n       if (processing_template_decl)\n \tvalue = push_template_decl (value);\n \n@@ -1128,6 +1125,19 @@ save_template_attributes (tree *attr_p, tree *decl_p)\n   if (!late_attrs)\n     return;\n \n+  /* Give this type a name so we know to look it up again at instantiation\n+     time.  */\n+  if (TREE_CODE (*decl_p) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (*decl_p) == NULL_TREE)\n+    {\n+      tree oldt = TREE_TYPE (*decl_p);\n+      tree newt = build_variant_type_copy (oldt);\n+      DECL_ORIGINAL_TYPE (*decl_p) = oldt;\n+      TREE_TYPE (*decl_p) = newt;\n+      TYPE_NAME (newt) = *decl_p;\n+      TREE_USED (newt) = TREE_USED (*decl_p);\n+    }\n+\n   if (DECL_P (*decl_p))\n     q = &DECL_ATTRIBUTES (*decl_p);\n   else"}, {"sha": "f8d0204f0994bc22463c4306abc3803f4ef58557", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -847,20 +847,28 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n \t at line 0), and install this TYPE_DECL as the new type's typedef\n-\t name.  See the extensive comment of set_underlying_type ().  */\n+\t name.  See the extensive comment in ../c-decl.c (pushdecl).  */\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n \t  tree type = TREE_TYPE (x);\n-\n-\t  if (DECL_IS_BUILTIN (x)\n-\t      || (TREE_TYPE (x) != error_mark_node\n-\t\t  && TYPE_NAME (type) != x\n-\t\t  /* We don't want to copy the type when all we're\n-\t\t     doing is making a TYPE_DECL for the purposes of\n-\t\t     inlining.  */\n-\t\t  && (!TYPE_NAME (type)\n-\t\t      || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x))))\n-\t    set_underlying_type (x);\n+\t  if (DECL_IS_BUILTIN (x))\n+\t    {\n+\t      if (TYPE_NAME (type) == 0)\n+\t\tTYPE_NAME (type) = x;\n+\t    }\n+\t  else if (type != error_mark_node && TYPE_NAME (type) != x\n+\t\t   /* We don't want to copy the type when all we're\n+\t\t      doing is making a TYPE_DECL for the purposes of\n+\t\t      inlining.  */\n+\t\t   && (!TYPE_NAME (type)\n+\t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n+\t    {\n+\t      DECL_ORIGINAL_TYPE (x) = type;\n+\t      type = build_variant_type_copy (type);\n+\t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n+\t      TYPE_NAME (type) = x;\n+\t      TREE_TYPE (x) = type;\n+\t    }\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)"}, {"sha": "f6809f2bdf7db53d78b412e66acde646c8f4042a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 94, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -7387,31 +7387,6 @@ instantiate_class_template (tree type)\n \t  && DECL_TEMPLATE_INFO (t))\n \ttsubst_default_arguments (t);\n \n-  /* Some types referenced from within the template code need to be access\n-     checked at template instantiation time, i.e now. These types were\n-     added to the template at parsing time. Let's get those and perfom\n-     the acces checks then.  */\n-  for (t = MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ); t; t = TREE_CHAIN (t))\n-    {\n-      tree type_decl = TREE_PURPOSE (t);\n-      tree type_scope = TREE_VALUE (t);\n-\n-      if (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n-\tcontinue;\n-\n-      if (uses_template_parms (type_decl))\n-\ttype_decl = tsubst (type_decl, args, tf_error, NULL_TREE);\n-\n-      if (uses_template_parms (type_scope))\n-\ttype_scope = tsubst (type_scope, args, tf_error, NULL_TREE);\n-\n-      gcc_assert (type_decl && type_decl != error_mark_node\n-\t\t  && type_scope && type_scope != error_mark_node);\n-\n-      perform_or_defer_access_check (TYPE_BINFO (type_scope), type_decl, type_decl);\n-    }\n-\n-  perform_deferred_access_checks ();\n   pop_nested_class ();\n   pop_from_top_level ();\n   pop_deferring_access_checks ();\n@@ -11894,7 +11869,6 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n   tree fndecl;\n   tree gen_tmpl;\n   tree spec;\n-  tree t;\n   HOST_WIDE_INT saved_processing_template_decl;\n \n   if (tmpl == error_mark_node)\n@@ -11973,24 +11947,6 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n   /* Now we know the specialization, compute access previously\n      deferred.  */\n   push_access_scope (fndecl);\n-\n-  /* Some types referenced from within the template code need to be access\n-     checked at template instantiation time, i.e now. These types were\n-     added to the template at parsing time. Let's get those and perfom\n-     the acces checks then.  */\n-  for (t = MEMBER_TYPES_NEEDING_ACCESS_CHECK (tmpl); t; t = TREE_CHAIN (t))\n-    {\n-      tree type_decl = TREE_PURPOSE (t);\n-      tree type_scope = TREE_VALUE (t);\n-\n-      if (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n-\tcontinue;\n-\n-      if (uses_template_parms (type_decl))\n-\ttype_decl = tsubst (type_decl, targ_ptr, tf_error, NULL_TREE);\n-\n-      perform_or_defer_access_check (TYPE_BINFO (type_scope), type_decl, type_decl);\n-    }\n   perform_deferred_access_checks ();\n   pop_access_scope (fndecl);\n   pop_deferring_access_checks ();\n@@ -16677,15 +16633,7 @@ resolve_typename_type (tree type, bool only_current_p)\n   gcc_assert (TREE_CODE (type) == TYPENAME_TYPE);\n \n   scope = TYPE_CONTEXT (type);\n-  /* Usually the non-qualified identifier of a TYPENAME_TYPE is\n-     TYPE_IDENTIFIER (type). But when 'type' is a typedef variant of\n-     a TYPENAME_TYPE node, then TYPE_NAME (type) is set to the TYPE_DECL representing\n-     the typedef. In that case TYPE_IDENTIFIER (type) is not the non-qualified\n-     identifier  of the TYPENAME_TYPE anymore.\n-     So by getting the TYPE_IDENTIFIER of the _main declaration_ of the\n-     TYPENAME_TYPE instead, we avoid messing up with a possible\n-     typedef variant case.  */\n-  name = TYPE_IDENTIFIER (TYPE_MAIN_VARIANT (type));\n+  name = TYPE_IDENTIFIER (type);\n \n   /* If the SCOPE is itself a TYPENAME_TYPE, then we need to resolve\n      it first before we can figure out what NAME refers to.  */\n@@ -17010,45 +16958,4 @@ type_uses_auto (tree type)\n   return NULL_TREE;\n }\n \n-/* Append TYPE_DECL to the template TMPL.\n-   TMPL is eiter a class type or a FUNCTION_DECL associated\n-   to a TEMPLATE_DECL.\n-   At TMPL instanciation time, TYPE_DECL will be checked to see\n-   if it can be accessed through SCOPE.  */\n-void\n-append_type_to_template_for_access_check (tree templ,\n-                                          tree type_decl,\n-\t\t\t\t\t  tree scope)\n-{\n-  tree node, templ_decl;\n-\n-  gcc_assert (templ\n-\t      && get_template_info (templ)\n-\t      && TI_TEMPLATE (get_template_info (templ))\n-\t      && type_decl\n-\t      && (TREE_CODE (type_decl) == TYPE_DECL));\n-\n-  templ_decl = TI_TEMPLATE (get_template_info (templ));\n-  gcc_assert (templ_decl);\n-\n-  /* Make sure we don't append the type to the template twice.\n-     If this appears to be too slow, the\n-     MEMBER_TYPE_NEEDING_ACCESS_CHECK property\n-     of templ should be a hash table instead.  */\n-  for (node = MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl);\n-       node;\n-       node = TREE_CHAIN (node))\n-    {\n-      tree decl = TREE_PURPOSE (node);\n-      tree type_scope = TREE_VALUE (node);\n-\n-      if (decl == type_decl && type_scope == scope)\n-\treturn;\n-    }\n-\n-  MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl) =\n-    tree_cons (type_decl, scope,\n-\t       MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl));\n-}\n-\n #include \"gt-cp-pt.h\""}, {"sha": "c9f0641f5f8452ace0325ee8ca6613f3cfbb2009", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -1529,30 +1529,6 @@ check_accessibility_of_qualified_id (tree decl,\n   tree scope;\n   tree qualifying_type = NULL_TREE;\n \n-  /* If we are parsing a template declaration and if decl is a typedef,\n-     add it to a list tied to the template.\n-     At template instantiation time, that list will be walked and\n-     access check performed.  */\n-  if (is_typedef_decl (decl))\n-    {\n-      /* This the scope through which type_decl is accessed.\n-\t It will be useful information later to do access check for\n-\t type_decl usage.  */\n-      tree scope = nested_name_specifier ? nested_name_specifier : DECL_CONTEXT (decl);\n-      tree templ_info = NULL;\n-      tree cs = current_scope ();\n-\n-      if (cs && (CLASS_TYPE_P (cs) || TREE_CODE (cs) == FUNCTION_DECL))\n-\ttempl_info = get_template_info (cs);\n-\n-      if (templ_info\n-\t  && TI_TEMPLATE (templ_info)\n-\t  && scope\n-\t  && CLASS_TYPE_P (scope)\n-\t  && !currently_open_class (scope))\n-\tappend_type_to_template_for_access_check (current_scope (), decl, scope);\n-    }\n-\n   /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)\n     return;"}, {"sha": "df530ddb93f4faffca23ba70f4ec8d09371752a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -1,3 +1,14 @@\n+2009-01-22  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/38930\n+\t* g++.dg/template/typedef11.C: Reverting changes of PR c++/26693.\n+\t* g++.dg/template/typedef12.C: Likewise.\n+\t* g++.dg/template/typedef13.C: Likewise.\n+\t* g++.dg/template/typedef14.C: Likewise.\n+\t* g++.dg/template/sfinae3.C: Likewise.\n+\t* g++.old-deja/g++.pt/typename8.C: Likewise.\n+\t* g++.dg/template/access11.C: Likewise\n+\n 2009-01-21  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.dg/tree-ssa/ssa-store-ccp-3.c: Skip for mips*-*-linux*"}, {"sha": "4c8dce521a894a35da7b473dd34a9fe00a6982a6", "filename": "gcc/testsuite/g++.dg/template/access11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -17,8 +17,8 @@ template <> struct X::Y<int> {\n   A::X x;\t\t\t// { dg-error \"this context\" }\n };\n \n-template <typename T> struct X::Y { // { dg-error \"this context\" }\n+template <typename T> struct X::Y {\n   typename T::X x;\t\t// { dg-error \"this context\" }\n };\n \n-template struct X::Y<A>;\t// { dg-message \"instantiated from here\" }\n+template struct X::Y<A>;\t// { dg-message \"instantiated\" }"}, {"sha": "5799a364e4253d74c77a7fd3a58fbb9bd9ab54c0", "filename": "gcc/testsuite/g++.dg/template/sfinae3.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -1,5 +1,5 @@\n // PR c++/24671\n-// { dg-do compile }\n+// { dg-options \"\" }\n \n template<typename> struct A\n {\n@@ -9,9 +9,9 @@ template<typename> struct A\n \n template<typename> struct B\n {\n-  B(const B&);\n-  typedef typename A<char[A<B>::i]>::X Y; // { dg-error \"forbids zero-size array\" }\n-  template<typename T> B(T, Y);\n+  B(const B&); // { dg-message \"candidate\" }\n+  typedef typename A<char[A<B>::i]>::X Y;\n+  template<typename T> B(T, Y); // { dg-error \"call\" }\n };\n \n-B<int> b(0,0); // { dg-message \"instantiated from here\" }\n+B<int> b(0,0); "}, {"sha": "c7c7c989f729330474b0abf0fd0a6eeadad1dfb3", "filename": "gcc/testsuite/g++.dg/template/typedef11.C", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C?ref=73cc93abd2d93d6d5dcbfb8654bc7718a13c2476", "patch": "@@ -1,25 +0,0 @@\n-// Author: Dodji Seketeli <dodji@redhat.com>\n-// Origin: PR c++/26693\n-// { dg-do compile }\n-\n-\n-class Alpha\n-{\n-  typedef int X; // { dg-error \"'typedef int Alpha::X' is private\" }\n-};\n-\n-template<int>\n-class Beta\n-{\n-    typedef int Y; // { dg-error \"'typedef int Beta<0>::Y' is private\" }\n-};\n-\n-template <int>\n-int\n-bar ()\n-{\n-  Beta<0>::Y i = 0;\n-  return Alpha::X ();\n-}\n-\n-int i = bar<0> (); // { dg-error \"within this context\" }"}, {"sha": "30605044f6f2469e639ce6a8a19ca0b3210913a4", "filename": "gcc/testsuite/g++.dg/template/typedef12.C", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C?ref=73cc93abd2d93d6d5dcbfb8654bc7718a13c2476", "patch": "@@ -1,23 +0,0 @@\n-// Contributed by Dodji Seketeli <dodji@redhat.com>\n-// Origin: Jason Merrill <jason@redhat.com>, PR c++/26693\n-// { dg-do compile }\n-\n-class A\n-{\n-     protected:\n-           typedef int mytype;\n-};\n-\n-template <class T> class B;\n-\n-class C: public A\n-{\n-      template <class T> friend class B;\n-};\n-\n-template <class T> class B\n-{\n-      C::mytype mem;\n-};\n-\n-B<int> b;"}, {"sha": "aa8bb3268298c6e044416a4425344644b26c106a", "filename": "gcc/testsuite/g++.dg/template/typedef13.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C?ref=73cc93abd2d93d6d5dcbfb8654bc7718a13c2476", "patch": "@@ -1,16 +0,0 @@\n-// Contributed by Dodji Seketeli <dodji@redhat.com>\n-// Origin: PR c++/26693\n-// { dg-do compile }\n-\n-class A\n-{\n-  typedef int mytype; // { dg-error \"typedef int A::mytype' is private\" }\n-};\n-\n-template <class T> class B : public A\n-{ // { dg-error \"within this context\"  }\n-  mytype mem;\n-};\n-\n-B<int> b; // { dg-message \"instantiated from here\" }\n-"}, {"sha": "caa565a08cd0154a36eb9964c59b263e62089591", "filename": "gcc/testsuite/g++.dg/template/typedef14.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cc93abd2d93d6d5dcbfb8654bc7718a13c2476/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C?ref=73cc93abd2d93d6d5dcbfb8654bc7718a13c2476", "patch": "@@ -1,16 +0,0 @@\n-// Contributed by Dodji Seketeli <dodji@redhat.com>\n-// Origin: PR c++/26693\n-// { dg-do compile }\n-\n-template <class T>\n-struct A\n-{\n-  typedef int mytype;\n-\n-  void\n-  foo ()\n-  {\n-    mytype v = ~static_cast<mytype> (0);\n-  }\n-};\n-"}, {"sha": "6eb818b394728c3fe1115eecf945fb94908b31c8", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename8.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -5,14 +5,14 @@ template < class T > class A\n public:\n   typedef typename T::myT anotherT; // { dg-error \"\" } undefined type\n \n-  anotherT t;\n+  anotherT t; // { dg-error \"\" } undefined type \n \n   A() { }\n-  A(anotherT _t) {\n+  A(anotherT _t) { // { dg-error \"\" } undefined type\n     t=_t;\n   }\n \n-  anotherT getT() {\n+  anotherT getT() { // { dg-error \"\" } undefined type\n     return t;\n   }\n };"}, {"sha": "55163b6c1b7a5b7a0ca8e4eb015ef9a296a26f95", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -3412,9 +3412,6 @@ struct tree_target_option GTY(())\n /* Return a tree node that encapsulates the current target options.  */\n extern tree build_target_option_node (void);\n \n-extern void set_underlying_type (tree x);\n-\n-extern bool is_typedef_decl (tree x);\n \f\n /* Define the overall contents of a tree node.\n    It may be any of the structures declared above"}, {"sha": "e103b8851f43ce72488b5e4dd4cfa054cff6d286", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -1,3 +1,8 @@\n+2009-01-22  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* include/ext/bitmap_allocator.h: Reverting changes related to PR\n+\tc++/26693.\n+\n 2009-01-21  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/29_atomics/headers/stdatomic.h/functions.c: Remove"}, {"sha": "7f5466afe188c7ae3c48894ffef78a34571c5b3e", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c2a308f32b01bdb5bea5538bccbb9b885b47a9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=03c2a308f32b01bdb5bea5538bccbb9b885b47a9", "patch": "@@ -549,13 +549,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    */\n   class free_list\n   {\n-  public:\n     typedef size_t* \t\t\t\tvalue_type;\n     typedef __detail::__mini_vector<value_type> vector_type;\n     typedef vector_type::iterator \t\titerator;\n     typedef __mutex\t\t\t\t__mutex_type;\n \n-  private:\n     struct _LT_pointer_compare\n     {\n       bool"}]}