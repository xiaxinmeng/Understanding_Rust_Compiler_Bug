{"sha": "12c583a2a3da798e82737c2d0e11fd686636cfeb", "node_id": "C_kwDOANBUbNoAKDEyYzU4M2EyYTNkYTc5OGU4MjczN2MyZDBlMTFmZDY4NjYzNmNmZWI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-11T20:58:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-11T20:58:40Z"}, "message": "analyzer: new warning: -Wanalyzer-infinite-recursion [PR106147]\n\nThis patch adds a new -Wanalyzer-infinite-recursion warning to\n-fanalyzer, which complains about certain cases of infinite recursion.\n\nSpecifically, when it detects recursion during its symbolic execution\nof the user's code, it compares the state of memory to that at the\nprevious level of recursion, and if nothing appears to have effectively\nchanged, it issues a warning.\n\nUnlike the middle-end warning -Winfinite-recursion (added by Martin\nSebor in GCC 12; r12-5483-g30ba058f77eedf), the analyzer warning\ncomplains if there exists an interprocedural path in which recursion\noccurs in which memory has not changed, whereas -Winfinite-recursion\ncomplains if *every* intraprocedural path through the function leads to\na self-call.\n\nHence the warnings complement each other: there's some overlap, but each\nalso catches issues that the other misses.\n\nFor example, the new warning complains about a guarded recursion in\nwhich the guard is passed unchanged:\n\nvoid test_guarded (int flag)\n{\n  if (flag)\n    test_guarded (flag);\n}\n\nt.c: In function 'test_guarded':\nt.c:4:5: warning: infinite recursion [CWE-674] [-Wanalyzer-infinite-recursion]\n    4 |     test_guarded (flag);\n      |     ^~~~~~~~~~~~~~~~~~~\n  'test_guarded': events 1-4\n    |\n    |    1 | void test_guarded (int flag)\n    |      |      ^~~~~~~~~~~~\n    |      |      |\n    |      |      (1) initial entry to 'test_guarded'\n    |    2 | {\n    |    3 |   if (flag)\n    |      |      ~\n    |      |      |\n    |      |      (2) following 'true' branch (when 'flag != 0')...\n    |    4 |     test_guarded (flag);\n    |      |     ~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (3) ...to here\n    |      |     (4) calling 'test_guarded' from 'test_guarded'\n    |\n    +--> 'test_guarded': events 5-6\n           |\n           |    1 | void test_guarded (int flag)\n           |      |      ^~~~~~~~~~~~\n           |      |      |\n           |      |      (5) recursive entry to 'test_guarded'; previously entered at (1)\n           |      |      (6) apparently infinite recursion\n           |\n\nwhereas the existing warning doesn't complain, since when \"flag\" is\nfalse the function doesn't recurse.\n\nThe new warning doesn't trigger for e.g.:\n\n  void test_param_variant (int depth)\n  {\n    if (depth > 0)\n      test_param_variant (depth - 1);\n  }\n\non the grounds that \"depth\" is changing, and appears to be a variant\nthat enforces termination of the recursion.\n\ngcc/ChangeLog:\n\tPR analyzer/106147\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/infinite-recursion.o.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106147\n\t* analyzer.opt (Wanalyzer-infinite-recursion): New.\n\t* call-string.cc (call_string::count_occurrences_of_function):\n\tNew.\n\t* call-string.h (call_string::count_occurrences_of_function): New\n\tdecl.\n\t* checker-path.cc (function_entry_event::function_entry_event):\n\tNew ctor.\n\t(checker_path::add_final_event): Delete.\n\t* checker-path.h (function_entry_event::function_entry_event): New\n\tctor.\n\t(function_entry_event::get_desc): Drop \"final\".\n\t(checker_path::add_final_event): Delete.\n\t* diagnostic-manager.cc\n\t(diagnostic_manager::emit_saved_diagnostic): Create the final\n\tevent via a new pending_diagnostic::add_final_event vfunc, rather\n\tthan checker_path::add_final_event.\n\t(diagnostic_manager::add_events_for_eedge): Create function entry\n\tevents via a new pending_diagnostic::add_function_entry_event\n\tvfunc.\n\t* engine.cc (exploded_graph::process_node): When creating a new\n\tPK_BEFORE_SUPERNODE node, call\n\texploded_graph::detect_infinite_recursion on it after adding the\n\tin-edge.\n\t* exploded-graph.h (exploded_graph::detect_infinite_recursion):\n\tNew decl.\n\t(exploded_graph::find_previous_entry_to): New decl.\n\t* infinite-recursion.cc: New file.\n\t* pending-diagnostic.cc\n\t(pending_diagnostic::add_function_entry_event): New.\n\t(pending_diagnostic::add_final_event): New.\n\t* pending-diagnostic.h\n\t(pending_diagnostic::add_function_entry_event): New vfunc.\n\t(pending_diagnostic::add_final_event): New vfunc.\n\ngcc/ChangeLog:\n\tPR analyzer/106147\n\t* doc/gcc/gcc-command-options/options-that-control-static-analysis.rst:\n\tAdd -Wanalyzer-infinite-recursion.\n\t* doc/gcc/gcc-command-options/options-to-request-or-suppress-warnings.rst\n\t(-Winfinite-recursion): Mention -Wanalyzer-infinite-recursion.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106147\n\t* g++.dg/analyzer/infinite-recursion-1.C: New test.\n\t* g++.dg/analyzer/infinite-recursion-2.C: New test, copied from\n\tg++.dg/warn/Winfinite-recursion-2.C.\n\t* g++.dg/analyzer/infinite-recursion-3.C: New test, adapted from\n\tg++.dg/warn/Winfinite-recursion-3.C.\n\t* gcc.dg/analyzer/infinite-recursion-2.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-3.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-4-limited-buggy.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-4-limited.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-4-unlimited-buggy.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-4-unlimited.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-5.c: New test, adapted from\n\tgcc.dg/Winfinite-recursion.c.\n\t* gcc.dg/analyzer/infinite-recursion-alloca.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-inlining.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-multiline-1.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-multiline-2.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-variadic.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion.c: Add dg-warning directives\n\twhere infinite recursions occur.\n\t* gcc.dg/analyzer/malloc-ipa-12.c: Likewise.\n\t* gcc.dg/analyzer/pr105365.c: Likewise.\n\t* gcc.dg/analyzer/pr105366.c: Likewise.\n\t* gcc.dg/analyzer/pr97029.c: Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "40ffeaa23c73b23c1bbcf48c67ba2eb7b038d7b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40ffeaa23c73b23c1bbcf48c67ba2eb7b038d7b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12c583a2a3da798e82737c2d0e11fd686636cfeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c583a2a3da798e82737c2d0e11fd686636cfeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c583a2a3da798e82737c2d0e11fd686636cfeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c583a2a3da798e82737c2d0e11fd686636cfeb/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a7b437ca71e2721e9bcf070762fc54ef7991aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7b437ca71e2721e9bcf070762fc54ef7991aeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7b437ca71e2721e9bcf070762fc54ef7991aeb"}], "stats": {"total": 1627, "additions": 1590, "deletions": 37}, "files": [{"sha": "246a85a167741ce81d1697507aba7df4d6e23d14", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -1250,6 +1250,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/engine.o \\\n \tanalyzer/feasible-graph.o \\\n \tanalyzer/function-set.o \\\n+\tanalyzer/infinite-recursion.o \\\n \tanalyzer/known-function-manager.o \\\n \tanalyzer/pending-diagnostic.o \\\n \tanalyzer/program-point.o \\"}, {"sha": "518a5d422ffe24cdd7965005f24e0fd200f2432d", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -110,6 +110,10 @@ Wanalyzer-imprecise-fp-arithmetic\n Common Var(warn_analyzer_imprecise_fp_arithmetic) Init(1) Warning\n Warn about code paths in which floating-point arithmetic is used in locations where precise computation is needed.\n \n+Wanalyzer-infinite-recursion\n+Common Var(warn_analyzer_infinite_recursion) Init(1) Warning\n+Warn about code paths which appear to lead to infinite recursion.\n+\n Wanalyzer-jump-through-null\n Common Var(warn_analyzer_jump_through_null) Init(1) Warning\n Warn about code paths in which a NULL function pointer is called."}, {"sha": "d78ae81bd7db091ce94493066e810518e9b9def2", "filename": "gcc/analyzer/call-string.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -170,6 +170,22 @@ call_string::calc_recursion_depth () const\n   return result;\n }\n \n+/* Count the number of times FUN appears in the string.  */\n+\n+int\n+call_string::count_occurrences_of_function (function *fun) const\n+{\n+  int result = 0;\n+  for (const call_string::element_t &e : m_elements)\n+    {\n+      if (e.get_callee_function () == fun)\n+\tresult++;\n+      if (e.get_caller_function () == fun)\n+\tresult++;\n+    }\n+  return result;\n+}\n+\n /* Comparator for call strings.\n    This implements a version of lexicographical order.\n    Return negative if A is before B."}, {"sha": "d97ff84ce779cb9623856c99a092540f9e232e1f", "filename": "gcc/analyzer/call-string.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fcall-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fcall-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.h?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -105,6 +105,8 @@ class call_string\n     return m_elements[m_elements.length () - 1];\n   }\n \n+  int count_occurrences_of_function (function *) const;\n+\n   void validate () const;\n \n private:"}, {"sha": "39de7453f51a176e70434fcc6f7ee6e58b97d297", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -377,6 +377,14 @@ region_creation_event::get_desc (bool can_colorize) const\n \n /* class function_entry_event : public checker_event.  */\n \n+function_entry_event::function_entry_event (const program_point &dst_point)\n+: checker_event (EK_FUNCTION_ENTRY,\n+\t\t dst_point.get_supernode ()->get_start_location (),\n+\t\t dst_point.get_fndecl (),\n+\t\t dst_point.get_stack_depth ())\n+{\n+}\n+\n /* Implementation of diagnostic_event::get_desc vfunc for\n    function_entry_event.\n \n@@ -1304,21 +1312,6 @@ checker_path::add_region_creation_events (const region *reg,\n \t\t\t\t\t\t   loc, fndecl, depth));\n }\n \n-/* Add a warning_event to the end of this path.  */\n-\n-void\n-checker_path::add_final_event (const state_machine *sm,\n-\t\t\t       const exploded_node *enode, const gimple *stmt,\n-\t\t\t       tree var, state_machine::state_t state)\n-{\n-  add_event\n-    (make_unique<warning_event> (get_stmt_location (stmt,\n-\t\t\t\t\t\t    enode->get_function ()),\n-\t\t\t\t enode->get_function ()->decl,\n-\t\t\t\t enode->get_stack_depth (),\n-\t\t\t\t sm, var, state));\n-}\n-\n void\n checker_path::fixup_locations (pending_diagnostic *pd)\n {"}, {"sha": "53e6bff03ecd583a8ea6e177d5f7c0839dacee1f", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -260,7 +260,9 @@ class function_entry_event : public checker_event\n   {\n   }\n \n-  label_text get_desc (bool can_colorize) const final override;\n+  function_entry_event (const program_point &dst_point);\n+\n+  label_text get_desc (bool can_colorize) const override;\n   meaning get_meaning () const override;\n \n   bool is_function_entry_p () const final override { return true; }\n@@ -660,10 +662,6 @@ class checker_path : public diagnostic_path\n \t\t\t\t   tree fndecl, int depth,\n \t\t\t\t   bool debug);\n \n-  void add_final_event (const state_machine *sm,\n-\t\t\tconst exploded_node *enode, const gimple *stmt,\n-\t\t\ttree var, state_machine::state_t state);\n-\n   /* After all event-pruning, a hook for notifying each event what\n      its ID will be.  The events are notified in order, allowing\n      for later events to refer to the IDs of earlier events in"}, {"sha": "9b319c3a3f58f2cb6685147b905fa5f68e84f4c0", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -1368,8 +1368,8 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n      We use the final enode from the epath, which might be different from\n      the sd.m_enode, as the dedupe code doesn't care about enodes, just\n      snodes.  */\n-  emission_path.add_final_event (sd.m_sm, epath->get_final_enode (), sd.m_stmt,\n-\t\t\t\t sd.m_var, sd.m_state);\n+  sd.m_d->add_final_event (sd.m_sm, epath->get_final_enode (), sd.m_stmt,\n+\t\t\t   sd.m_var, sd.m_state, &emission_path);\n \n   /* The \"final\" event might not be final; if the saved_diagnostic has a\n      trailing eedge stashed, add any events for it.  This is for use\n@@ -1922,11 +1922,8 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n       /* Add function entry events.  */\n       if (dst_point.get_supernode ()->entry_p ())\n \t{\n-\t  emission_path->add_event\n-\t    (make_unique<function_entry_event>\n-\t     (dst_point.get_supernode ()->get_start_location (),\n-\t      dst_point.get_fndecl (),\n-\t      dst_stack_depth));\n+\t  pb.get_pending_diagnostic ()->add_function_entry_event\n+\t    (eedge, emission_path);\n \t  /* Create region_creation_events for on-stack regions within\n \t     this frame.  */\n \t  if (interest)"}, {"sha": "d0595ef0d07768e875248306bacd33935a6cea4c", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -4276,7 +4276,12 @@ exploded_graph::process_node (exploded_node *node)\n \t    exploded_node *next = get_or_create_node (next_point, next_state,\n \t\t\t\t\t\t      node);\n \t    if (next)\n-\t      add_edge (node, next, succ);\n+\t      {\n+\t\tadd_edge (node, next, succ);\n+\n+\t\t/* We might have a function entrypoint.  */\n+\t\tdetect_infinite_recursion (next);\n+\t      }\n \t  }\n \n \t/* Return from the calls which doesn't have a return superedge."}, {"sha": "a4cbc8f688a2bd878110e80213094f8f5db369e7", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -851,6 +851,11 @@ class exploded_graph : public digraph<eg_traits>\n \n   void on_escaped_function (tree fndecl);\n \n+  /* In infinite-recursion.cc */\n+  void detect_infinite_recursion (exploded_node *enode);\n+  exploded_node *find_previous_entry_to (function *top_of_stack_fun,\n+\t\t\t\t\t exploded_node *enode) const;\n+\n private:\n   void print_bar_charts (pretty_printer *pp) const;\n "}, {"sha": "7055926b156fd76069bf4d30001eeec28ce6c5eb", "filename": "gcc/analyzer/infinite-recursion.cc", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Finfinite-recursion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Finfinite-recursion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Finfinite-recursion.cc?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,481 @@\n+/* Detection of infinite recursion.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_MEMORY\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"fold-const.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"diagnostic-core.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"pretty-print.h\"\n+#include \"sbitmap.h\"\n+#include \"bitmap.h\"\n+#include \"tristate.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"selftest.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cgraph.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"make-unique.h\"\n+#include \"analyzer/checker-path.h\"\n+\n+/* A subclass of pending_diagnostic for complaining about suspected\n+   infinite recursion.  */\n+\n+class infinite_recursion_diagnostic\n+: public pending_diagnostic_subclass<infinite_recursion_diagnostic>\n+{\n+public:\n+  infinite_recursion_diagnostic (const exploded_node *prev_entry_enode,\n+\t\t\t\t const exploded_node *new_entry_enode,\n+\t\t\t\t tree callee_fndecl)\n+  : m_prev_entry_enode (prev_entry_enode),\n+    m_new_entry_enode (new_entry_enode),\n+    m_callee_fndecl (callee_fndecl),\n+    m_prev_entry_event (NULL)\n+  {}\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"infinite_recursion_diagnostic\";\n+  }\n+\n+  bool operator== (const infinite_recursion_diagnostic &other) const\n+  {\n+    return m_callee_fndecl == other.m_callee_fndecl;\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_infinite_recursion;\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    /* \"CWE-674: Uncontrolled Recursion\".  */\n+    diagnostic_metadata m;\n+    m.add_cwe (674);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"infinite recursion\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    const int frames_consumed = (m_new_entry_enode->get_stack_depth ()\n+\t\t\t\t - m_prev_entry_enode->get_stack_depth ());\n+    if (frames_consumed > 1)\n+      return ev.formatted_print\n+\t(\"apparently infinite chain of mutually-recursive function calls,\"\n+\t \" consuming %i stack frames per recursion\",\n+\t frames_consumed);\n+    else\n+      return ev.formatted_print (\"apparently infinite recursion\");\n+  }\n+\n+  void\n+  add_function_entry_event (const exploded_edge &eedge,\n+\t\t\t    checker_path *emission_path) final override\n+  {\n+    /* Subclass of function_entry_event for use when reporting both\n+       the initial and subsequent entries to the function of interest,\n+       allowing for cross-referencing the first event in the description\n+       of the second.  */\n+    class recursive_function_entry_event : public function_entry_event\n+    {\n+    public:\n+      recursive_function_entry_event (const program_point &dst_point,\n+\t\t\t\t      const infinite_recursion_diagnostic &pd,\n+\t\t\t\t      bool topmost)\n+      : function_entry_event (dst_point),\n+\tm_pd (pd),\n+\tm_topmost (topmost)\n+      {\n+      }\n+\n+      label_text\n+      get_desc (bool can_colorize) const final override\n+      {\n+\tif (m_topmost)\n+\t  {\n+\t    if (m_pd.m_prev_entry_event\n+\t\t&& m_pd.m_prev_entry_event->get_id_ptr ()->known_p ())\n+\t      return make_label_text\n+\t\t(can_colorize,\n+\t\t \"recursive entry to %qE; previously entered at %@\",\n+\t\t m_effective_fndecl,\n+\t\t m_pd.m_prev_entry_event->get_id_ptr ());\n+\t    else\n+\t      return make_label_text (can_colorize, \"recursive entry to %qE\",\n+\t\t\t\t      m_effective_fndecl);\n+\t  }\n+\telse\n+\t  return make_label_text (can_colorize, \"initial entry to %qE\",\n+\t\t\t\t  m_effective_fndecl);\n+      }\n+\n+    private:\n+      const infinite_recursion_diagnostic &m_pd;\n+      bool m_topmost;\n+    };\n+    const exploded_node *dst_node = eedge.m_dest;\n+    const program_point &dst_point = dst_node->get_point ();\n+    if (eedge.m_dest == m_prev_entry_enode)\n+      {\n+\tgcc_assert (m_prev_entry_event == NULL);\n+\tstd::unique_ptr<checker_event> prev_entry_event\n+\t  = make_unique <recursive_function_entry_event> (dst_point,\n+\t\t\t\t\t\t\t  *this, false);\n+\tm_prev_entry_event = prev_entry_event.get ();\n+\temission_path->add_event (std::move (prev_entry_event));\n+      }\n+    else if (eedge.m_dest == m_new_entry_enode)\n+      emission_path->add_event\n+\t(make_unique<recursive_function_entry_event> (dst_point, *this, true));\n+    else\n+      pending_diagnostic::add_function_entry_event (eedge, emission_path);\n+  }\n+\n+  /* Customize the location where the warning_event appears, putting\n+     it at the topmost entrypoint to the function.  */\n+  void add_final_event (const state_machine *,\n+\t\t\tconst exploded_node *,\n+\t\t\tconst gimple *,\n+\t\t\ttree,\n+\t\t\tstate_machine::state_t,\n+\t\t\tchecker_path *emission_path) final override\n+  {\n+    gcc_assert (m_new_entry_enode);\n+    emission_path->add_event\n+      (make_unique<warning_event>\n+       (m_new_entry_enode->get_supernode ()->get_start_location (),\n+\tm_callee_fndecl,\n+\tm_new_entry_enode->get_stack_depth (),\n+\tNULL, NULL, NULL));\n+  }\n+\n+private:\n+  const exploded_node *m_prev_entry_enode;\n+  const exploded_node *m_new_entry_enode;\n+  tree m_callee_fndecl;\n+  const checker_event *m_prev_entry_event;\n+};\n+\n+/* Return true iff ENODE is the PK_BEFORE_SUPERNODE at a function\n+   entrypoint.  */\n+\n+static bool\n+is_entrypoint_p (exploded_node *enode)\n+{\n+  /* Look for an entrypoint to a function...  */\n+  const supernode *snode = enode->get_supernode ();\n+  if (!snode)\n+    return false;\n+  if (!snode->entry_p ())\n+    return false;;\n+  const program_point &point = enode->get_point ();\n+  if (point.get_kind () != PK_BEFORE_SUPERNODE)\n+    return false;\n+  return true;\n+}\n+\n+/* Walk backwards through the eg, looking for the first\n+   enode we find that's also the entrypoint of the same function.  */\n+\n+exploded_node *\n+exploded_graph::find_previous_entry_to (function *top_of_stack_fun,\n+\t\t\t\t\texploded_node *enode) const\n+{\n+  auto_vec<exploded_node *> worklist;\n+  hash_set<exploded_node *> visited;\n+\n+  visited.add (enode);\n+  for (auto in_edge : enode->m_preds)\n+    worklist.safe_push (in_edge->m_src);\n+\n+  while (worklist.length () > 0)\n+    {\n+      exploded_node *iter = worklist.pop ();\n+\n+      if (is_entrypoint_p (iter)\n+\t  && iter->get_function () == top_of_stack_fun)\n+\treturn iter;\n+\n+      if (visited.contains (iter))\n+\tcontinue;\n+      visited.add (iter);\n+      for (auto in_edge : iter->m_preds)\n+\tworklist.safe_push (in_edge->m_src);\n+    }\n+\n+  /* Not found.  */\n+  return NULL;\n+}\n+\n+/* Given BASE_REG within ENCLOSING_FRAME (such as a function parameter),\n+   remap it to the equivalent region within EQUIV_PREV_FRAME.\n+\n+   For example, given param \"n\" within frame \"foo@3\", and equiv prev frame\n+   \"foo@1\", remap it to param \"n\" within frame \"foo@1\".  */\n+\n+static const region *\n+remap_enclosing_frame (const region *base_reg,\n+\t\t       const frame_region *enclosing_frame,\n+\t\t       const frame_region *equiv_prev_frame,\n+\t\t       region_model_manager *mgr)\n+{\n+  gcc_assert (base_reg->get_parent_region () == enclosing_frame);\n+  switch (base_reg->get_kind ())\n+    {\n+    default:\n+      /* We should only encounter params and varargs at the topmost\n+\t entrypoint.  */\n+      gcc_unreachable ();\n+\n+    case RK_VAR_ARG:\n+      {\n+\tconst var_arg_region *var_arg_reg = (const var_arg_region *)base_reg;\n+\treturn mgr->get_var_arg_region (equiv_prev_frame,\n+\t\t\t\t\tvar_arg_reg->get_index ());\n+      }\n+    case RK_DECL:\n+      {\n+\tconst decl_region *decl_reg = (const decl_region *)base_reg;\n+\treturn equiv_prev_frame->get_region_for_local (mgr,\n+\t\t\t\t\t\t       decl_reg->get_decl (),\n+\t\t\t\t\t\t       NULL);\n+      }\n+    }\n+}\n+\n+/* Compare the state of memory at NEW_ENTRY_ENODE and PREV_ENTRY_ENODE,\n+   both of which are entrypoints to the same function, where recursion has\n+   occurred.\n+\n+   Return true if the state of NEW_ENTRY_ENODE is sufficiently different\n+   from PREV_ENTRY_ENODE to suggests that some variant is being modified,\n+   and thus the recursion isn't infinite.\n+\n+   Return false if the states are effectively the same, suggesting that\n+   the recursion is infinite.\n+\n+   For example, consider mutually recursive functions \"foo\" and \"bar\".\n+   At the entrypoint to a \"foo\" frame where we've detected recursion,\n+   we might have three frames on the stack: the new 'foo'@3, an inner\n+   'bar'@2, and the innermost 'foo'@1.\n+\n+     (gdb) call enode->dump(m_ext_state)\n+     EN: 16\n+     callstring: [(SN: 9 -> SN: 3 in foo), (SN: 5 -> SN: 8 in bar)]\n+     before SN: 0 (NULL from-edge)\n+\n+     rmodel:\n+     stack depth: 3\n+       frame (index 2): frame: \u2018foo\u2019@3\n+       frame (index 1): frame: \u2018bar\u2019@2\n+       frame (index 0): frame: \u2018foo\u2019@1\n+     clusters within root region\n+       cluster for: (*INIT_VAL(f_4(D)))\n+     clusters within frame: \u2018bar\u2019@2\n+       cluster for: b_2(D): INIT_VAL(f_4(D))\n+     clusters within frame: \u2018foo\u2019@3\n+       cluster for: f_4(D): INIT_VAL(f_4(D))\n+     m_called_unknown_fn: FALSE\n+\n+   whereas for the previous entry node we'd have just the innermost\n+   'foo'@1\n+\n+     (gdb) call prev_entry_enode->dump(m_ext_state)\n+     EN: 1\n+     callstring: []\n+     before SN: 0 (NULL from-edge)\n+\n+     rmodel:\n+     stack depth: 1\n+       frame (index 0): frame: \u2018foo\u2019@1\n+     clusters within root region\n+       cluster for: (*INIT_VAL(f_4(D)))\n+     m_called_unknown_fn: FALSE\n+\n+   We want to abstract away frames 1 and 2 in the new entry enode,\n+   and compare its frame 3 with the frame 1 in the previous entry\n+   enode, and determine if enough state changes between them to\n+   rule out infinite recursion.  */\n+\n+static bool\n+sufficiently_different_p (exploded_node *new_entry_enode,\n+\t\t\t  exploded_node *prev_entry_enode,\n+\t\t\t  logger *logger)\n+{\n+  LOG_SCOPE (logger);\n+  gcc_assert (new_entry_enode);\n+  gcc_assert (prev_entry_enode);\n+  gcc_assert (is_entrypoint_p (new_entry_enode));\n+  gcc_assert (is_entrypoint_p (prev_entry_enode));\n+\n+  const int new_stack_depth = new_entry_enode->get_stack_depth ();\n+\n+  /* Compare the stores of the two enodes.  */\n+  const region_model &new_model\n+    = *new_entry_enode->get_state ().m_region_model;\n+  const region_model &prev_model\n+    = *prev_entry_enode->get_state ().m_region_model;\n+  const store &new_store = *new_model.get_store ();\n+\n+  for (auto kv : new_store)\n+    {\n+      const region *base_reg = kv.first;\n+\n+      /* Get the value within the new frame.  */\n+      const svalue *new_sval\n+\t= new_model.get_store_value (base_reg, NULL);\n+\n+      /* If the value is UNKNOWN (e.g. due to hitting complexity limits)\n+\t assume that it differs from the previous value.  */\n+      if (new_sval->get_kind () == SK_UNKNOWN)\n+\treturn true;\n+\n+      /* Get the equivalent value within the old enode.  */\n+      const svalue *prev_sval;\n+\n+      if (const frame_region *enclosing_frame\n+\t    = base_reg->maybe_get_frame_region ())\n+\t{\n+\t  /* We have a binding within a frame in the new entry enode.  */\n+\n+\t  /* Ignore bindings within frames below the new entry node.  */\n+\t  if (enclosing_frame->get_stack_depth () < new_stack_depth)\n+\t    continue;\n+\n+\t  /* We have a binding within the frame of the new entry node,\n+\t     presumably a parameter.  */\n+\n+\t  /* Get the value within the equivalent frame of\n+\t     the old entrypoint; typically will be the initial_svalue\n+\t     of the parameter.  */\n+\t  const frame_region *equiv_prev_frame\n+\t    = prev_model.get_current_frame ();\n+\t  const region *equiv_prev_base_reg\n+\t    = remap_enclosing_frame (base_reg,\n+\t\t\t\t     enclosing_frame,\n+\t\t\t\t     equiv_prev_frame,\n+\t\t\t\t     new_model.get_manager ());\n+\t  prev_sval = prev_model.get_store_value (equiv_prev_base_reg, NULL);\n+\t}\n+      else\n+\tprev_sval = prev_model.get_store_value (base_reg, NULL);\n+\n+      /* If the prev_sval is UNKNOWN (e.g. due to hitting complexity limits)\n+\t assume that it will differ from any new value.  */\n+      if (prev_sval->get_kind () == SK_UNKNOWN)\n+\treturn true;\n+\n+      if (new_sval != prev_sval)\n+\treturn true;\n+    }\n+\n+  /* No significant differences found.  */\n+  return false;\n+}\n+\n+/* Implementation of -Wanalyzer-infinite-recursion.\n+\n+   Called when adding ENODE to the graph, after adding its first in-edge.\n+\n+   For function entrypoints, see if recursion has occurred, and, if so,\n+   check if the state of memory changed between the recursion levels,\n+   which would suggest some kind of decreasing variant that leads to\n+   termination.\n+\n+   For recursive calls where the state of memory is effectively unchanged\n+   between recursion levels, warn with -Wanalyzer-infinite-recursion.  */\n+\n+void\n+exploded_graph::detect_infinite_recursion (exploded_node *enode)\n+{\n+  if (!is_entrypoint_p (enode))\n+    return;\n+  function *top_of_stack_fun = enode->get_function ();\n+  gcc_assert (top_of_stack_fun);\n+\n+  /* ....where a call to that function is already in the call string.  */\n+  const call_string &call_string = enode->get_point ().get_call_string ();\n+\n+  if (call_string.count_occurrences_of_function (top_of_stack_fun) < 2)\n+    return;\n+\n+  tree fndecl = top_of_stack_fun->decl;\n+\n+  log_scope s (get_logger (),\n+\t       \"checking for infinite recursion\",\n+\t       \"considering recursion at EN: %i entering %qE\",\n+\t       enode->m_index, fndecl);\n+\n+  /* Find enode that's the entrypoint for the previous frame for fndecl\n+     in the recursion.  */\n+  exploded_node *prev_entry_enode\n+    = find_previous_entry_to (top_of_stack_fun, enode);\n+  gcc_assert (prev_entry_enode);\n+  if (get_logger ())\n+    get_logger ()->log (\"previous entrypoint to %qE is EN: %i\",\n+\t\t\tfndecl, prev_entry_enode->m_index);\n+\n+  /* Look for changes to the state of memory between the recursion levels.  */\n+  if (sufficiently_different_p (enode, prev_entry_enode, get_logger ()))\n+    return;\n+\n+  /* Otherwise, the state of memory is effectively the same between the two\n+     recursion levels; warn.  */\n+\n+  const supernode *caller_snode = call_string.get_top_of_stack ().m_caller;\n+  const supernode *snode = enode->get_supernode ();\n+  gcc_assert (caller_snode->m_returning_call);\n+  get_diagnostic_manager ().add_diagnostic\n+    (enode, snode, caller_snode->m_returning_call, NULL,\n+     make_unique<infinite_recursion_diagnostic> (prev_entry_enode,\n+\t\t\t\t\t\t enode,\n+\t\t\t\t\t\t fndecl));\n+}"}, {"sha": "9216a22e64def8547f7fc4c4a421457b7f8d3408", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -167,6 +167,18 @@ pending_diagnostic::fixup_location (location_t loc) const\n   return loc;\n }\n \n+/* Base implementation of pending_diagnostic::add_function_entry_event.\n+   Add a function_entry_event to EMISSION_PATH.  */\n+\n+void\n+pending_diagnostic::add_function_entry_event (const exploded_edge &eedge,\n+\t\t\t\t\t      checker_path *emission_path)\n+{\n+  const exploded_node *dst_node = eedge.m_dest;\n+  const program_point &dst_point = dst_node->get_point ();\n+  emission_path->add_event (make_unique<function_entry_event> (dst_point));\n+}\n+\n /* Base implementation of pending_diagnostic::add_call_event.\n    Add a call_event to EMISSION_PATH.  */\n \n@@ -187,6 +199,24 @@ pending_diagnostic::add_call_event (const exploded_edge &eedge,\n \t\t\t      src_stack_depth));\n }\n \n+/* Base implementation of pending_diagnostic::add_final_event.\n+   Add a warning_event to the end of EMISSION_PATH.  */\n+\n+void\n+pending_diagnostic::add_final_event (const state_machine *sm,\n+\t\t\t\t     const exploded_node *enode,\n+\t\t\t\t     const gimple *stmt,\n+\t\t\t\t     tree var, state_machine::state_t state,\n+\t\t\t\t     checker_path *emission_path)\n+{\n+  emission_path->add_event\n+    (make_unique<warning_event> (get_stmt_location (stmt,\n+\t\t\t\t\t\t    enode->get_function ()),\n+\t\t\t\t enode->get_function ()->decl,\n+\t\t\t\t enode->get_stack_depth (),\n+\t\t\t\t sm, var, state));\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "0e91e71a2089e4ba06f98cb0c78f76e525bf410f", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -309,6 +309,14 @@ class pending_diagnostic\n \n   /* End of precision-of-wording vfuncs.  */\n \n+  /* Vfunc for adding a function_entry_event to a checker_path, so that e.g.\n+     the infinite recursion diagnostic can add a custom event subclass\n+     that annotates recursively entering a function.  */\n+\n+  virtual void\n+  add_function_entry_event (const exploded_edge &eedge,\n+\t\t\t    checker_path *emission_path);\n+\n   /* Vfunc for extending/overriding creation of the events for an\n      exploded_edge that corresponds to a superedge, allowing for custom\n      events to be created that are pertinent to a particular\n@@ -330,6 +338,16 @@ class pending_diagnostic\n   virtual void add_call_event (const exploded_edge &,\n \t\t\t       checker_path *);\n \n+  /* Vfunc for adding the final warning_event to a checker_path, so that e.g.\n+     the infinite recursion diagnostic can have its diagnostic appear at\n+     the callsite, but the final event in the path be at the entrypoint\n+     of the called function.  */\n+  virtual void add_final_event (const state_machine *sm,\n+\t\t\t\tconst exploded_node *enode,\n+\t\t\t\tconst gimple *stmt,\n+\t\t\t\ttree var, state_machine::state_t state,\n+\t\t\t\tchecker_path *emission_path);\n+\n   /* Vfunc for determining that this pending_diagnostic supercedes OTHER,\n      and that OTHER should therefore not be emitted.\n      They have already been tested for being at the same stmt.  */"}, {"sha": "32a626c16a9aaf410628f4889bcb382ddb84ea4e", "filename": "gcc/doc/gcc/gcc-command-options/options-that-control-static-analysis.rst", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -32,6 +32,7 @@ Options That Control Static Analysis\n   :option:`-Wanalyzer-file-leak` |gol|\n   :option:`-Wanalyzer-free-of-non-heap` |gol|\n   :option:`-Wanalyzer-imprecise-fp-arithmetic` |gol|\n+  :option:`-Wanalyzer-infinite-recursion` |gol|\n   :option:`-Wanalyzer-jump-through-null` |gol|\n   :option:`-Wanalyzer-malloc-leak` |gol|\n   :option:`-Wanalyzer-mismatching-deallocation` |gol|\n@@ -308,6 +309,33 @@ Options That Control Static Analysis\n \n   Default setting; overrides :option:`-Wno-analyzer-imprecise-fp-arithmetic`.\n \n+.. option:: -Wno-analyzer-infinite-recursion\n+\n+  This warning requires :option:`-fanalyzer`, which enables it; use\n+  :option:`-Wno-analyzer-infinite-recursion` to disable it.\n+\n+  This diagnostics warns for paths through the code which appear to\n+  lead to infinite recursion.\n+\n+  Specifically, when the analyzer \"sees\" a recursive call, it will compare\n+  the state of memory at the entry to the new frame with that at the entry\n+  to the previous frame of that function on the stack.  The warning is\n+  issued if nothing in memory appears to be changing; any changes observed\n+  to parameters or globals are assumed to lead to termination of the\n+  recursion and thus suppress the warning.\n+\n+  This diagnostic is likely to miss cases of infinite recursion that\n+  are convered to iteration by the optimizer before the analyzer \"sees\"\n+  them.  Hence optimization should be disabled when attempting to trigger\n+  this diagnostic.\n+\n+  Compare with :option:`-Winfinite-recursion`, which provides a similar\n+  diagnostic, but is implemented in a different way.\n+\n+.. option:: -Wanalyzer-infinite-recursion\n+\n+  Default setting; overrides :option:`-Wno-analyzer-infinite-recursion`.\n+\n .. option:: -Wno-analyzer-jump-through-null\n \n   This warning requires :option:`-fanalyzer`, which enables it; use"}, {"sha": "b57f4784780530157ca874fc438060a91303d704", "filename": "gcc/doc/gcc/gcc-command-options/options-to-request-or-suppress-warnings.rst", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-to-request-or-suppress-warnings.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-to-request-or-suppress-warnings.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-to-request-or-suppress-warnings.rst?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -804,6 +804,10 @@ warnings, in some cases it may also cause false positives.\n   recursion in calls between two or more functions.\n   :option:`-Winfinite-recursion` is included in :option:`-Wall`.\n \n+  Compare with :option:`-Wanalyzer-infinite-recursion` which provides a\n+  similar diagnostic, but is implemented in a different way (as part of\n+  :option:`-fanalyzer`).\n+\n .. option:: -Wno-infinite-recursion\n \n   Default setting; overrides :option:`-Winfinite-recursion`."}, {"sha": "33f3b33f33edcf8e30cc49dca5f411db579a29e2", "filename": "gcc/testsuite/g++.dg/analyzer/infinite-recursion-1.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-1.C?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,84 @@\n+class widget\n+{\n+public:\n+  virtual void draw ()\n+  {\n+    /* no-op */\n+  }\n+};\n+\n+class foo_widget : public widget\n+{\n+public:\n+  void draw ();\n+};\n+\n+void foo_widget::draw ()\n+{\n+  // Bogus attempt to chain up to base class leading to infinite recursion:\n+  foo_widget::draw (); /* { dg-warning \"infinite recursion\" } */\n+\n+  // [...snip...]\n+}\n+\n+/* Infinite recursion due to a buggy \"operator int\".  */\n+\n+class boxed_int\n+{\n+  int m_val;\n+public:\n+  operator int ();\n+};\n+\n+boxed_int::operator int ()\n+{\n+  return *this; /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+template <typename T>\n+class buggy_getter\n+{\n+public:\n+  T get_value () const\n+  {\n+    return get_value (); /* { dg-warning \"infinite recursion\" } */\n+  }\n+};\n+\n+int test_buggy_getter (buggy_getter<int> g)\n+{\n+  return g.get_value ();\n+}\n+\n+/* Copy of g++.dg/warn/Winfinite-recursion.C  */\n+\n+template <typename D>\n+struct C\n+{\n+  void foo ()\n+  {\n+    static_cast<D *>(this)->foo (); /* { dg-warning \"-Wanalyzer-infinite-recursion\" } */\n+  }\n+};\n+\n+struct D : C<D>\n+{\n+  // this is missing:\n+  // void foo() {}\n+};\n+\n+void f (D *d)\n+{\n+  d->foo ();\n+}\n+\n+\n+struct E : C<D>\n+{\n+  void foo() {}\n+};\n+\n+void g (E *e)\n+{\n+  e->foo ();\n+}"}, {"sha": "c582fbf4f073584687c670178609b9c49f889263", "filename": "gcc/testsuite/g++.dg/analyzer/infinite-recursion-2.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-2.C?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,74 @@\n+/* Copy of g++.dg/warn/Winfinite-recursion-2.C  */\n+\n+/* { dg-do compile { target c++11 } }  */\n+\n+namespace std\n+{\n+class type_info {\n+public:\n+  void k() const;\n+};\n+\n+} // namespace std\n+\n+using std::type_info;\n+\n+template <int a> struct f { static constexpr int c = a; };\n+struct h {\n+  typedef int e;\n+};\n+\n+template <unsigned long, typename...> struct m;\n+template <unsigned long ab, typename i, typename j, typename... ac>\n+struct m<ab, i, j, ac...> : m<ab + 1, i, ac...> {};\n+template <unsigned long ab, typename j, typename... ac>\n+struct m<ab, j, j, ac...> : f<ab> {};\n+template <unsigned long, typename...> struct n;\n+template <unsigned long ab, typename j, typename... ac>\n+struct n<ab, j, ac...> : n<ab - 1, ac...> {};\n+template <typename j, typename... ac> struct n<0, j, ac...> : h {};\n+template <typename... l> class F {\n+  template <typename i> struct I : m<0, i, l...> {};\n+  template <int ab> struct s : n<ab, l...> {};\n+  static const type_info *const b[];\n+  struct G {\n+    template <typename ag>\n+    operator ag() const\n+    {\n+      return *this; /* { dg-warning \"-Wanalyzer-infinite-recursion\" } */\n+    }\n+  };\n+  unsigned o;\n+  G ah;\n+\n+public:\n+  F();\n+  long t() const { return o; }\n+  const type_info &m_fn3() const { return *b[o]; }\n+  template <int ab> typename s<ab>::e *m_fn4() const {\n+    if (o != ab)\n+      return nullptr;\n+    return ah;\n+  }\n+  template <int ab> void m_fn5() const {\n+    m_fn4<ab>();\n+    const type_info &r = m_fn3();\n+    r.k();\n+  }\n+  template <typename i> void u() const { m_fn5<I<i>::c>(); }\n+};\n+template <typename... l> const type_info *const F<l...>::b[] {&typeid(l)...};\n+using am = unsigned char;\n+class H {\n+  enum bd : am { be = 2 };\n+  using bf = F<int, int, H>;\n+  bf ah;\n+  template <typename bg> void v() const { ah.u<bg>(); }\n+  void w() const;\n+};\n+void H::w() const {\n+  bd d = bd(ah.t());\n+  switch (d)\n+  case be:\n+    v<H>();\n+}"}, {"sha": "a749f6266667b3ef939de089f598c470fd331f5c", "filename": "gcc/testsuite/g++.dg/analyzer/infinite-recursion-3.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Finfinite-recursion-3.C?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,62 @@\n+/* Adapted from g++.dg/warn/Winfinite-recursion-3.C  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+/* Might throw.  */\n+void f ();\n+\n+void warn_f_call_r (int  n)\n+{\n+  if (n > 7)\n+    f ();\n+  warn_f_call_r (n - 1);\n+}\n+\n+void warn_f_do_while_call_r (int n)\n+{\n+  f ();\n+  do\n+    {\n+      f ();\n+      warn_f_do_while_call_r (n - 1);\n+    }\n+  while (1);\n+}\n+\n+\n+struct X\n+{\n+  X (int);\n+  ~X ();\n+};\n+\n+int warn_class_with_ctor (int n)\n+{\n+  X x (n);\n+  return n + warn_class_with_ctor (n - 1);\n+}\n+\n+\n+int nowarn_throw (int n)\n+{\n+  if (n > 7)\n+    throw \"argument too big\";\n+\n+  return n + nowarn_throw (n - 1);\n+}\n+\n+extern int* eipa[];\n+\n+void warn_call_new (int i)\n+{\n+  eipa[i] = new int;\n+\n+  warn_call_new (i - 1);\n+}\n+\n+void* operator new[] (size_t n)\n+{\n+  char *p = new char[n + sizeof (n)];\n+  *(size_t*)p = n;\n+  return p + sizeof n;\n+}"}, {"sha": "f0ab1300b8450ba8bac9ad4fdc0cc1d5eacc70eb", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-2.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-2.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,109 @@\n+void test_direct (void)\n+{\n+  test_direct (); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+void test_guarded (int flag)\n+{\n+  if (flag)\n+    test_guarded (flag); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+void test_flipped_guard (int flag)\n+{\n+  if (flag)\n+    test_guarded (!flag); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+void test_param_variant (int depth)\n+{\n+  if (depth > 0)\n+    test_param_variant (depth - 1); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+void test_unguarded_param_variant (int depth)\n+{\n+  /* We fail to report this: we see that depth is being decremented,\n+     but don't notice that every path through the function is\n+     recursing.  */\n+  test_unguarded_param_variant (depth - 1); /* { dg-warning \"infinite recursion\" \"TODO\" { xfail *-*-* } } */\n+}\n+\n+int g;\n+\n+void test_global_variant ()\n+{\n+  if (g-- > 0)\n+    test_global_variant (); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+/* This is a bounded recursion, as \"n\" is decremented before recursing... */\n+\n+int test_while_do_predecrement_param (int n)\n+{\n+  int x = 0;\n+  while (n)\n+    x += test_while_do_predecrement_param (--n); /* { dg-bogus \"infinite recursion\" } */\n+  return x;\n+}\n+\n+/* ...whereas this one is unbounded, as \"n\" is decremented *after* the\n+   recursive call, and so is repeatedly called with the same value.  */\n+\n+int test_while_do_postdecrement_param (int n)\n+{\n+  int x = 0;\n+  while (n)\n+    x += test_while_do_postdecrement_param (n--); /* { dg-warning \"infinite recursion\" } */\n+  return x;\n+}\n+/* This is a bounded recursion, as \"n\" is decremented before recursing... */\n+\n+int test_do_while_predecrement_param (int n)\n+{\n+  int x = 0;\n+  do\n+    x += test_do_while_predecrement_param (--n); /* { dg-bogus \"infinite recursion\" } */\n+  while (--n);\n+  return x;\n+}\n+\n+/* ...whereas this one is unbounded, as \"n\" is decremented *after* the\n+   recursive call, and so is repeatedly called with the same value.  */\n+\n+int test_do_while_postdecrement_param (int n)\n+{\n+  int x = 0;\n+  do\n+    x += test_do_while_postdecrement_param (n--); /* { dg-warning \"infinite recursion\" } */\n+  while (--n);\n+  return x;\n+}\n+\n+/* Various cases of decrementing \"n\" as the recursion proceeds where\n+   not every path recurses, but we're not actually checking \"n\", so\n+   if \"flag\" is true it's an infinite recursion.  */\n+\n+void test_partially_guarded_postdecrement (int flag, int n)\n+{\n+  /* We catch this; the \"n--\" means we recurse with the\n+     same value for the 2nd param.  */\n+  if (flag) /* { dg-message \"when 'flag != 0'\" } */\n+    test_partially_guarded_postdecrement (flag, n--); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+void test_partially_guarded_predecrement (int flag, int n)\n+{\n+  /* We fail to report this; we see that \"n\" is changing,\n+     though it isn't relevant to whether we recurse.  */\n+  if (flag)\n+    test_partially_guarded_predecrement (flag, --n); /* { dg-warning \"infinite recursion\" \"TODO\" { xfail *-*-* } } */\n+}\n+\n+void test_partially_guarded_subtract (int flag, int n)\n+{\n+  /* We fail to report this; we see that \"n\" is changing,\n+     though it isn't relevant to whether we recurse.  */\n+  if (flag)\n+    test_partially_guarded_subtract (flag, n - 1); /* { dg-warning \"infinite recursion\" \"TODO\" { xfail *-*-* } } */\n+}"}, {"sha": "68c4fa396caa11a0ee40b923b4cf7d9fc9a5d118", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-3.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -Wno-analyzer-too-complex\" } */\n+\n+struct node\n+{\n+  struct node *left;\n+  struct node *right;\n+  int val;\n+};\n+\n+int sum (struct node *n)\n+{\n+  int result = 0;\n+  if (n->left)\n+    result += sum (n->left); /* { dg-bogus \"infinite recursion\" } */\n+  if (n->right)\n+    result += sum (n->right); /* { dg-bogus \"infinite recursion\" } */\n+  return result;\n+}"}, {"sha": "a71b9029af97b77fd70864d094f0af2a91da2a59", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-4-limited-buggy.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-limited-buggy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-limited-buggy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-limited-buggy.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -Wno-analyzer-too-complex\" } */\n+\n+/* A two-deep mutual recursion, and failing to walk a list,\n+   but with a depth limit, thus not an infinite recursion (assuming a\n+   suitable depth limit).  */\n+\n+struct node\n+{\n+  struct node *child;\n+};\n+\n+void foo (struct node *f, int depth);\n+\n+void bar (struct node *b, int depth)\n+{\n+  foo (b, depth); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+void foo (struct node *f, int depth)\n+{\n+  if (f->child && depth > 0)\n+    /* Bug: should have recursed to f->child, not to f,\n+       but we assume that the depth limit should save us.  */\n+    bar (f, depth - 1); /* { dg-bogus \"infinite recursion\" } */\n+}"}, {"sha": "55326d2b473464f92cec98df643feb472e2955bc", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-4-limited.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-limited.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-limited.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-limited.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -Wno-analyzer-too-complex\" } */\n+\n+/* A two-deep mutual recursion, walking a singly-linked list,\n+   with a depth limit.  */\n+\n+struct node\n+{\n+  struct node *child;\n+};\n+\n+void foo (struct node *f, int depth);\n+\n+void bar (struct node *b, int depth)\n+{\n+  foo (b, depth); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+void foo (struct node *f, int depth)\n+{\n+  if (f->child && depth > 0)\n+    bar (f->child, depth - 1); /* { dg-bogus \"infinite recursion\" } */\n+}"}, {"sha": "7ed1a2bb38c732614ec577b639969a995f0abb23", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-4-unlimited-buggy.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-unlimited-buggy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-unlimited-buggy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-unlimited-buggy.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -Wno-analyzer-too-complex\" } */\n+\n+/* A two-deep mutual recursion, with no limit, and\n+   failing to walk the list, thus leading to an infinite recursion.  */\n+\n+struct node\n+{\n+  struct node *child;\n+};\n+\n+void foo (struct node *f);\n+\n+void bar (struct node *b)\n+{\n+  foo (b); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+void foo (struct node *f)\n+{\n+  if (f->child)\n+    /* Bug: should have recursed to f->child, not to f.  */\n+    bar (f); /* { dg-warning \"infinite recursion\" } */\n+}"}, {"sha": "bdb54a3ee78705b5a53d3a361209def02aa6333d", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-4-unlimited.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-unlimited.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-unlimited.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-4-unlimited.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -Wno-analyzer-too-complex\" } */\n+\n+/* A two-deep mutual recursion, walking a linked list (and thus presumably\n+   terminating), with no explicit depth limit.  */\n+\n+struct node\n+{\n+  struct node *child;\n+};\n+\n+void foo (struct node *f);\n+\n+void bar (struct node *b)\n+{\n+  foo (b); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+void foo (struct node *f)\n+{\n+  if (f->child)\n+    bar (f->child); /* { dg-bogus \"infinite recursion\" } */\n+}"}, {"sha": "bf206394186a829b2463d83185505ae6d92f816b", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-5.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-5.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,221 @@\n+/* Adapted from gcc.dg/Winfinite-recursion.c.  */\n+\n+#define NORETURN __attribute__ ((noreturn))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+extern int ei;\n+int (*pfi_v)(void);\n+\n+\n+/* Make sure the warning doesn't assume every call has a DECL.  */\n+\n+int nowarn_pfi_v (void)\n+{\n+  return pfi_v ();\n+}\n+\n+\n+int warn_fi_v (void)\n+{\n+  return warn_fi_v ();               // { dg-warning \"-Wanalyzer-infinite-recursion\" }\n+}\n+\n+/* Verify #pragma suppression works.  */\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wanalyzer-infinite-recursion\"\n+\n+int suppress_warn_fi_v (void)\n+{\n+  return suppress_warn_fi_v ();\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+\n+int nowarn_fi_v (void)\n+{\n+  if (ei++ == 0)\n+    return nowarn_fi_v ();\n+  return 0;\n+}\n+\n+/* -Winfinite-recursion warns for this, but\n+   -Wanalyzer-infinite-recursion doesn't.  */\n+\n+int warn_if_i (int i)\n+{\n+  if (i > 0)\n+    return warn_if_i (--i);\n+  else if (i < 0)\n+    return warn_if_i (-i);\n+  else\n+    return warn_if_i (7);\n+}\n+\n+\n+int nowarn_if_i (int i)\n+{\n+  if (i > 0)\n+    return nowarn_if_i (--i);\n+  else if (i < 0)\n+    return nowarn_if_i (-i);\n+  else\n+    return -1;\n+}\n+\n+int nowarn_switch (int i, int a[])\n+{\n+  switch (i)\n+    {\n+    case 0: return nowarn_switch (a[3], a + 1);\n+    case 1: return nowarn_switch (a[5], a + 2);\n+    case 2: return nowarn_switch (a[7], a + 3);\n+    case 3: return nowarn_switch (a[9], a + 4);\n+    }\n+  return 77;\n+}\n+\n+/* -Winfinite-recursion warns for this, but\n+   -Wanalyzer-infinite-recursion doesn't.  */\n+\n+int warn_switch (int i, int a[])\n+{\n+  switch (i)\n+    {\n+    case 0: return warn_switch (a[3], a + 1);\n+    case 1: return warn_switch (a[5], a + 2);\n+    case 2: return warn_switch (a[7], a + 3);\n+    case 3: return warn_switch (a[9], a + 4);\n+    default: return warn_switch (a[1], a + 5);\n+    }\n+}\n+\n+NORETURN void fnoreturn (void);\n+\n+/* Verify there's no warning for a function that doesn't return.  */\n+int nowarn_call_noret (void)\n+{\n+  fnoreturn ();\n+}\n+\n+int warn_call_noret_r (void)\n+{\n+  warn_call_noret_r ();             // { dg-warning \"-Wanalyzer-infinite-recursion\" }\n+  fnoreturn ();\n+}\n+\n+/* -Winfinite-recursion warns for this, but\n+   -Wanalyzer-infinite-recursion doesn't.  */\n+\n+int\n+warn_noret_call_abort_r (char *s, int n)\n+{\n+  if (!s)\n+    abort ();\n+\n+  if (n > 7)\n+    abort ();\n+\n+  return n + warn_noret_call_abort_r (s, n - 1);\n+}\n+\n+NORETURN void nowarn_noret_call_abort_r (int n)\n+{\n+  if (n > 7)\n+    abort ();\n+\n+  nowarn_noret_call_abort_r (n - 1);\n+}\n+\n+/* -Winfinite-recursion warns for this, but\n+   -Wanalyzer-infinite-recursion doesn't.  */\n+\n+int warn_call_abort_r (int n)\n+{\n+  n += warn_call_abort_r (n - 1);\n+  if (n > 7)   // unreachable\n+    abort ();\n+  return n;\n+}\n+\n+\n+/* -Winfinite-recursion warns for this, but\n+   -Wanalyzer-infinite-recursion doesn't.  */\n+\n+int warn_call_exit_r (int n)\n+{\n+  n += warn_call_exit_r (n - 1);\n+  if (n > 7)\n+    exit (0);\n+  return n;\n+}\n+\n+struct __jmp_buf_tag { };\n+typedef struct __jmp_buf_tag jmp_buf[1];\n+\n+extern jmp_buf jmpbuf;\n+\n+/* A call to longjmp() breaks infinite recursion.  Verify it suppresses\n+   the warning.  */\n+\n+int nowarn_call_longjmp_r (int n)\n+{\n+  if (n > 7)\n+    __builtin_longjmp (jmpbuf, 1);\n+  return n + nowarn_call_longjmp_r (n - 1);\n+}\n+\n+/* -Winfinite-recursion warns for this, but\n+   -Wanalyzer-infinite-recursion doesn't.  */\n+\n+int warn_call_longjmp_r (int n)\n+{\n+  n += warn_call_longjmp_r (n - 1);\n+  if (n > 7)\n+    __builtin_longjmp (jmpbuf, 1);\n+  return n;\n+}\n+\n+\n+struct __sigjmp_buf_tag { };\n+typedef struct __sigjmp_buf_tag sigjmp_buf[1];\n+\n+extern sigjmp_buf sigjmpbuf;\n+\n+/* GCC has no __builtin_siglongjmp().  */\n+extern void siglongjmp (sigjmp_buf, int);\n+\n+/* A call to longjmp() breaks infinite recursion.  Verify it suppresses\n+   the warning.  */\n+\n+int nowarn_call_siglongjmp_r (int n)\n+{\n+  if (n > 7)\n+    siglongjmp (sigjmpbuf, 1);\n+  return n + nowarn_call_siglongjmp_r (n - 1);\n+}\n+\n+/* -Winfinite-recursion doesn't warn for this unbounded recursion, but\n+   -Wanalyzer-infinite-recursion does.  */\n+\n+int nowarn_while_do_call_r (int n)\n+{\n+  int z = 0;\n+  while (n)\n+    z += nowarn_while_do_call_r (n--); // { dg-warning \"-Wanalyzer-infinite-recursion\" }\n+  return z;\n+}\n+\n+int warn_do_while_call_r (int n)\n+{\n+  int z = 0;\n+  do\n+    z += warn_do_while_call_r (n); // { dg-warning \"-Wanalyzer-infinite-recursion\" }\n+  while (--n);\n+  return z;\n+}"}, {"sha": "8c50631d8ceb820c4e134ad9930831e7fa1f89eb", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-alloca.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-alloca.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,27 @@\n+typedef __SIZE_TYPE__ size_t;\n+\n+int test_alloca_1 (void)\n+{\n+  void *buf = __builtin_alloca (1024);\n+  return test_alloca_1 (); /* { dg-warning \"-Wanalyzer-infinite-recursion\" } */\n+}\n+\n+int test_alloca_2 (size_t n)\n+{\n+  void *buf = __builtin_alloca (n);\n+  return test_alloca_2 (n); /* { dg-warning \"-Wanalyzer-infinite-recursion\" } */\n+}\n+\n+int test_alloca_3 (size_t n)\n+{\n+  void *buf = __builtin_alloca (n);\n+  return test_alloca_2 (n - 1);\n+}\n+\n+int test_alloca_4 (size_t n)\n+{\n+  void *buf = __builtin_alloca (n);\n+  if (n > 0)\n+    return test_alloca_2 (n - 1);\n+  return 42;\n+}"}, {"sha": "c885c922fe187490a3230459b6e228a67ff1f441", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-inlining.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-inlining.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-inlining.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-inlining.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,116 @@\n+/* A copy of infinite-recursion-2.c, to see what inlining does to the IR\n+   when we see it.\n+\n+   Many cases get converted by the optimizer into iteration, and\n+   into infinite loops, sometimes trivial ones.\n+\n+   Right now this is a documented limitation of the warning, but perhaps\n+   could be readdressed by moving the analyzer earlier.   */\n+\n+/* { dg-additional-options \"-O3\" } */\n+\n+void test_direct (void)\n+{\n+  test_direct (); /* Ideally would warn here, but it becomes an infinite loop.  */\n+}\n+\n+void test_guarded (int flag)\n+{\n+  if (flag)\n+    test_guarded (flag);  /* Ideally would warn here, but it becomes an infinite loop.  */\n+}\n+\n+void test_flipped_guard (int flag)\n+{\n+  if (flag)\n+    test_guarded (!flag);\n+}\n+\n+void test_param_variant (int depth)\n+{\n+  if (depth > 0)\n+    test_param_variant (depth - 1);\n+}\n+\n+void test_unguarded_param_variant (int depth)\n+{\n+  test_unguarded_param_variant (depth - 1); /* Ideally would warn here, but it becomes an infinite loop.  */\n+}\n+\n+int g;\n+\n+void test_global_variant ()\n+{\n+  if (g-- > 0)\n+    test_global_variant ();\n+}\n+\n+/* This is a bounded recursion, as \"n\" is decremented before recursing... */\n+\n+int test_while_do_predecrement_param (int n)\n+{\n+  int x = 0;\n+  while (n)\n+    x += test_while_do_predecrement_param (--n);\n+  return x;\n+}\n+\n+/* ...whereas this one is unbounded, as \"n\" is decremented *after* the\n+   recursive call, and so is repeatedly called with the same value.  */\n+\n+int test_while_do_postdecrement_param (int n)\n+{\n+  int x = 0;\n+  while (n)\n+    x += test_while_do_postdecrement_param (n--); /* { dg-warning \"infinite recursion\" } */\n+  return x;\n+}\n+/* This is a bounded recursion, as \"n\" is decremented before recursing... */\n+\n+int test_do_while_predecrement_param (int n)\n+{\n+  int x = 0;\n+  do\n+    x += test_do_while_predecrement_param (--n);\n+  while (--n);\n+  return x;\n+}\n+\n+/* ...whereas this one is unbounded, as \"n\" is decremented *after* the\n+   recursive call, and so is repeatedly called with the same value.  */\n+\n+int test_do_while_postdecrement_param (int n)\n+{\n+  int x = 0;\n+  do\n+    x += test_do_while_postdecrement_param (n--); /* { dg-warning \"infinite recursion\" } */\n+  while (--n);\n+  return x;\n+}\n+\n+/* Various cases of decrementing \"n\" as the recursion proceeds where\n+   not every path recurses, but we're not actually checking \"n\", so\n+   if \"flag\" is true it's an infinite recursion.  */\n+\n+void test_partially_guarded_postdecrement (int flag, int n)\n+{\n+  /* Ideally we'd catch this, but it becomes an infinite loop.  */\n+  if (flag)\n+    test_partially_guarded_postdecrement (flag, n--);\n+}\n+\n+void test_partially_guarded_predecrement (int flag, int n)\n+{\n+  /* We fail to report this; we see that \"n\" is changing,\n+     though it isn't relevant to whether we recurse.  */\n+  if (flag)\n+    test_partially_guarded_predecrement (flag, --n); /* { dg-warning \"infinite recursion\" \"TODO\" { xfail *-*-* } } */\n+}\n+\n+void test_partially_guarded_subtract (int flag, int n)\n+{\n+  /* We fail to report this; we see that \"n\" is changing,\n+     though it isn't relevant to whether we recurse.  */\n+  if (flag)\n+    test_partially_guarded_subtract (flag, n - 1); /* { dg-warning \"infinite recursion\" \"TODO\" { xfail *-*-* } } */\n+}"}, {"sha": "e236dd48712dbbf61949cccaa4c82c32fb5ed8d8", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-multiline-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-multiline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-multiline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-multiline-1.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,41 @@\n+/* Integration test of how the execution path looks for\n+   -Wanalyzer-infinite-recursion.  */\n+\n+/* { dg-additional-options \"-fdiagnostics-show-path-depths\" } */\n+/* { dg-additional-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-caret\" } */\n+\n+void foo (int flag)\n+{\n+  if (flag)\n+    foo (flag); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+     foo (flag);\n+     ^~~~~~~~~~\n+  'foo': events 1-4 (depth 1)\n+    |\n+    | void foo (int flag)\n+    |      ^~~\n+    |      |\n+    |      (1) initial entry to 'foo'\n+    |\n+    |   if (flag)\n+    |      ~\n+    |      |\n+    |      (2) following 'true' branch (when 'flag != 0')...\n+    |     foo (flag);\n+    |     ~~~~~~~~~~\n+    |     |\n+    |     (3) ...to here\n+    |     (4) calling 'foo' from 'foo'\n+    |\n+    +--> 'foo': events 5-6 (depth 2)\n+           |\n+           | void foo (int flag)\n+           |      ^~~\n+           |      |\n+           |      (5) recursive entry to 'foo'; previously entered at (1)\n+           |      (6) apparently infinite recursion\n+           |\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "2c69dd508f0df59a23f4441b995105b78e122672", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-multiline-2.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-multiline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-multiline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-multiline-2.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,93 @@\n+/* Integration test of how the execution path looks for\n+   -Wanalyzer-infinite-recursion.  */\n+\n+/* { dg-additional-options \"-fdiagnostics-show-path-depths\" } */\n+/* { dg-additional-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-caret\" } */\n+\n+void mutual_2 (void);\n+\n+void mutual_1 (void)\n+{\n+  mutual_2 (); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+void mutual_2 (void)\n+{\n+  mutual_1 (); /* { dg-warning \"infinite recursion\" } */\n+}\n+\n+\n+/* { dg-begin-multiline-output \"\" }\n+   mutual_2 ();\n+   ^~~~~~~~~~~\n+  'mutual_2': events 1-2 (depth 1)\n+    |\n+    | void mutual_2 (void)\n+    |      ^~~~~~~~\n+    |      |\n+    |      (1) initial entry to 'mutual_2'\n+    |\n+    |   mutual_1 ();\n+    |   ~~~~~~~~~~~\n+    |   |\n+    |   (2) calling 'mutual_1' from 'mutual_2'\n+    |\n+    +--> 'mutual_1': events 3-4 (depth 2)\n+           |\n+           | void mutual_1 (void)\n+           |      ^~~~~~~~\n+           |      |\n+           |      (3) entry to 'mutual_1'\n+           |\n+           |   mutual_2 ();\n+           |   ~~~~~~~~~~~\n+           |   |\n+           |   (4) calling 'mutual_2' from 'mutual_1'\n+           |\n+           +--> 'mutual_2': events 5-6 (depth 3)\n+                  |\n+                  | void mutual_2 (void)\n+                  |      ^~~~~~~~\n+                  |      |\n+                  |      (5) recursive entry to 'mutual_2'; previously entered at (1)\n+                  |      (6) apparently infinite chain of mutually-recursive function calls, consuming 2 stack frames per recursion\n+                  |\n+   { dg-end-multiline-output \"\" } */\n+\n+\n+/* { dg-begin-multiline-output \"\" }\n+   mutual_1 ();\n+   ^~~~~~~~~~~\n+  'mutual_1': events 1-2 (depth 1)\n+    |\n+    | void mutual_1 (void)\n+    |      ^~~~~~~~\n+    |      |\n+    |      (1) initial entry to 'mutual_1'\n+    |\n+    |   mutual_2 ();\n+    |   ~~~~~~~~~~~\n+    |   |\n+    |   (2) calling 'mutual_2' from 'mutual_1'\n+    |\n+    +--> 'mutual_2': events 3-4 (depth 2)\n+           |\n+           | void mutual_2 (void)\n+           |      ^~~~~~~~\n+           |      |\n+           |      (3) entry to 'mutual_2'\n+           |\n+           |   mutual_1 ();\n+           |   ~~~~~~~~~~~\n+           |   |\n+           |   (4) calling 'mutual_1' from 'mutual_2'\n+           |\n+           +--> 'mutual_1': events 5-6 (depth 3)\n+                  |\n+                  | void mutual_1 (void)\n+                  |      ^~~~~~~~\n+                  |      |\n+                  |      (5) recursive entry to 'mutual_1'; previously entered at (1)\n+                  |      (6) apparently infinite chain of mutually-recursive function calls, consuming 2 stack frames per recursion\n+                  |\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "eafbeba08cdb6cb70299a7809aebc5fe1c4686e8", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-variadic.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-variadic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-variadic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-variadic.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -0,0 +1,34 @@\n+int test_variadic_1 (int n, ...)\n+{\n+  __builtin_va_list args;\n+  int total =0;\n+  int i;\n+\n+  __builtin_va_start(args, n);\n+\n+  for (i = 0; i < n; i++)\n+    total += __builtin_va_arg(args, int);\n+\n+  __builtin_va_end(args);\n+\n+  return total;  \n+}\n+\n+int test_variadic_2 (int n, ...)\n+{\n+  return test_variadic_2 (n, 42); /* { dg-warning \"-Wanalyzer-infinite-recursion\" } */\n+}\n+\n+int test_variadic_3 (int n, ...)\n+{\n+  if (n > 0) /* { dg-message \"when 'n > 0'\" } */\n+    return test_variadic_3 (n, 42); /* { dg-warning \"-Wanalyzer-infinite-recursion\" } */\n+  return 0;\n+}\n+\n+int test_variadic_4 (int n, ...)\n+{\n+  if (n > 0)\n+    return test_variadic_4 (n - 1, 42);\n+  return 0;\n+}"}, {"sha": "6b7d25cfabe6c576b0e13964813020fe7d6b7779", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -11,7 +11,7 @@ void test(int flag)\n     marker_B();\n \n     /* Recurse, infinitely, as it happens: */\n-    test(flag);\n+    test(flag); /* { dg-warning \"infinite recursion\" } */\n \n     marker_C();\n   }\n@@ -30,26 +30,26 @@ void mutual_test_1 (int flag)\n {\n   marker_A ();\n   if (flag)\n-    mutual_test_2 (flag);\n+    mutual_test_2 (flag); /* { dg-warning \"infinite recursion\" } */\n }\n \n void mutual_test_2 (int flag)\n {\n   marker_B ();\n   if (flag)\n-    mutual_test_3 (flag);\n+    mutual_test_3 (flag); /* { dg-warning \"infinite recursion\" } */\n }\n \n void mutual_test_3 (int flag)\n {\n   marker_C ();\n   if (flag)\n-    mutual_test_4 (flag);\n+    mutual_test_4 (flag); /* { dg-warning \"infinite recursion\" } */\n }\n \n void mutual_test_4 (int flag)\n {\n   marker_D ();\n   if (flag)\n-    mutual_test_1 (flag);\n+    mutual_test_1 (flag); /* { dg-warning \"infinite recursion\" } */\n }"}, {"sha": "3813c9ae45ea8f44dbbe79b9fdebd46dbf470768", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-12.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -3,5 +3,5 @@\n void recursive_free (void *ptr)\n {\n   free (ptr); /* { dg-warning \"double-'free' of 'ptr'\" } */\n-  recursive_free (ptr);\n+  recursive_free (ptr); /* { dg-warning \"infinite recursion\" } */\n }"}, {"sha": "c2e6b2e16fc24287c55c17a5ad194b3d5dbbd419", "filename": "gcc/testsuite/gcc.dg/analyzer/pr105365.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr105365.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr105365.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr105365.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -13,5 +13,5 @@ foo(_Float32 k) {\n   f /= (_Complex char)__builtin_llround(g);\n   k /= (cf32)__builtin_copysignf(0, i);\n   bar(f + k);\n-  foo(0);\n+  foo(0); /* { dg-warning \"infinite recursion\" } */\n }"}, {"sha": "af8a2c4f9cc9208b9dda6b1bd049ef04fb61806e", "filename": "gcc/testsuite/gcc.dg/analyzer/pr105366.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr105366.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr105366.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr105366.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -15,5 +15,5 @@ foo(u32 u, __int128 i) {\n   u /= (_Complex short)s;\n   u32 r = u + c;\n   bar(r);\n-  foo(0, 0);\n+  foo(0, 0); /* { dg-warning \"infinite recursion\" } */\n }"}, {"sha": "2ab2d4155ccff8f379b1ac60e92057ca2dae2d07", "filename": "gcc/testsuite/gcc.dg/analyzer/pr97029.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97029.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c583a2a3da798e82737c2d0e11fd686636cfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97029.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97029.c?ref=12c583a2a3da798e82737c2d0e11fd686636cfeb", "patch": "@@ -5,5 +5,5 @@ struct vj {\n void\n setjmp (struct vj pl)\n {\n-  setjmp (pl);\n+  setjmp (pl); /* { dg-warning \"infinite recursion\" } */\n }"}]}