{"sha": "29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlmZTA0Nzk4MTlkMTIxMmIxOGY3ZTU3N2ZiM2ViY2ZhZDNkNGNlNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-12-08T19:41:15Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2000-12-08T19:41:15Z"}, "message": "libffi closures for Alpha\n\nFrom-SVN: r38136", "tree": {"sha": "144dbd16bc03eddec8cc13570b2b3a4142fa8d6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/144dbd16bc03eddec8cc13570b2b3a4142fa8d6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/comments", "author": null, "committer": null, "parents": [{"sha": "859230d482f7c3e95b751b228b764622947fee83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859230d482f7c3e95b751b228b764622947fee83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859230d482f7c3e95b751b228b764622947fee83"}], "stats": {"total": 454, "additions": 295, "deletions": 159}, "files": [{"sha": "71dad41917460aa3a5c65dc5e47cffbdf7a41112", "filename": "libffi/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "patch": "@@ -1,3 +1,19 @@\n+2000-12-07 Dec  8 11:23:29 2000  Richard Henderson  <rth@redhat.com>\n+\n+\t* src/raw_api.c (ffi_translate_args): Fix typo.\n+\t(ffi_prep_closure): Likewise.\n+\n+\t* include/ffi.h.in [ALPHA]: Define FFI_CLOSURES and\n+\tFFI_TRAMPOLINE_SIZE.\n+\t* src/alpha/ffi.c (ffi_prep_cif_machdep): Adjust minimal\n+\tcif->bytes for new ffi_call_osf implementation.\n+\t(ffi_prep_args): Absorb into ...\n+\t(ffi_call): ... here.  Do all stack allocation here and\n+\tavoid a callback function.\n+\t(ffi_prep_closure, ffi_closure_osf_inner): New.\n+\t* src/alpha/osf.S (ffi_call_osf): Reimplement with no callback.\n+\t(ffi_closure_osf): New.\n+\n 2000-09-10  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config.guess, config.sub, install-sh: Removed."}, {"sha": "0d8e70788c94c30052904b68fd77796c447d9380", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------*-C-*-\n    libffi @VERSION@ - Copyright (c) 1996-1999  Cygnus Solutions\n \n-   $Id: ffi.h.in,v 1.4 2000/02/25 19:13:44 tromey Exp $\n+   $Id: ffi.h.in,v 1.5 2000/04/17 02:15:31 green Exp $\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -368,6 +368,12 @@ struct ffi_ia64_trampoline_struct {\n };\n #define FFI_NATIVE_RAW_API 0\n \n+#elif defined(ALPHA)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 24\n+#define FFI_NATIVE_RAW_API 0\n+\n #else \n \n #define FFI_CLOSURES 0"}, {"sha": "84ee8494e3d38a35e084cc4f6fec61c38237c09c", "filename": "libffi/src/alpha/ffi.c", "status": "modified", "additions": 150, "deletions": 100, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2Fsrc%2Falpha%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2Fsrc%2Falpha%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fffi.c?ref=29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "patch": "@@ -30,170 +30,220 @@\n \n #include <stdlib.h>\n \n-/* ffi_prep_args is called by the assembly routine once stack space\n-   has been allocated for the function's arguments */\n+extern void ffi_call_osf(void *, unsigned long, unsigned, void *, void (*)());\n+extern void ffi_closure_osf(void);\n \n-static void\n-ffi_prep_args(char *stack, extended_cif *ecif, int bytes, int flags)\n+\n+ffi_status\n+ffi_prep_cif_machdep(ffi_cif *cif)\n {\n-  register long i, avn;\n-  register void **p_argv;\n-  register char *argp;\n-  register ffi_type **p_arg;\n-\n-  /* To streamline things in the assembly code, we always allocate 12\n-     words for loading up the int and fp argument registers.  The layout\n-     is as when processing varargs: the 6 fp args, the 6 int args, then\n-     the incoming stack.  ARGP points to the first int slot.  */\n-  argp = stack + 6 * SIZEOF_ARG;\n-  memset (stack, 0, 12 * SIZEOF_ARG);\n-\n-  if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT )\n+  /* Adjust cif->bytes to represent a minimum 6 words for the temporary\n+     register argument loading area.  */\n+  if (cif->bytes < 6*SIZEOF_ARG)\n+    cif->bytes = 6*SIZEOF_ARG;\n+\n+  /* Set the return type flag */\n+  switch (cif->rtype->type)\n     {\n-      *(void **) argp = ecif->rvalue;\n-      argp += sizeof(void *);\n+    case FFI_TYPE_STRUCT:\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+      cif->flags = cif->rtype->type;\n+      break;\n+\n+    default:\n+      cif->flags = FFI_TYPE_INT;\n+      break;\n     }\n+  \n+  return FFI_OK;\n+}\n+\n+void\n+ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n+{\n+  unsigned long *stack, *argp;\n+  long i, avn;\n+  ffi_type **arg_types;\n+  \n+  FFI_ASSERT (cif->abi == FFI_OSF);\n+\n+  /* If the return value is a struct and we don't have a return\n+     value address then we need to make one.  */\n+  if (rvalue == NULL && cif->rtype->type == FFI_TYPE_STRUCT)\n+    rvalue = alloca(cif->rtype->size);\n+\n+  /* Allocate the space for the arguments, plus 4 words of temp\n+     space for ffi_call_osf.  */\n+  argp = stack = alloca(cif->bytes + 4*SIZEOF_ARG);\n+\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    *(void **) argp++ = rvalue;\n \n   i = 0;\n-  avn = ecif->cif->nargs;\n-  p_arg = ecif->cif->arg_types;\n-  p_argv = ecif->avalue;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+\n   while (i < avn)\n     {\n-      size_t z = ALIGN((*p_arg)->size, SIZEOF_ARG);\n-\n-      switch ((*p_arg)->type)\n+      switch ((*arg_types)->type)\n \t{\n \tcase FFI_TYPE_SINT8:\n-\t  *(SINT64 *) argp = *(SINT8 *)(* p_argv);\n+\t  *(SINT64 *) argp = *(SINT8 *)(* avalue);\n \t  break;\n \t\t  \n \tcase FFI_TYPE_UINT8:\n-\t  *(UINT64 *) argp = *(UINT8 *)(* p_argv);\n+\t  *(SINT64 *) argp = *(UINT8 *)(* avalue);\n \t  break;\n \t\t  \n \tcase FFI_TYPE_SINT16:\n-\t  *(SINT64 *) argp = *(SINT16 *)(* p_argv);\n+\t  *(SINT64 *) argp = *(SINT16 *)(* avalue);\n \t  break;\n \t\t  \n \tcase FFI_TYPE_UINT16:\n-\t  *(UINT64 *) argp = *(UINT16 *)(* p_argv);\n+\t  *(SINT64 *) argp = *(UINT16 *)(* avalue);\n \t  break;\n \t\t  \n \tcase FFI_TYPE_SINT32:\n-\t  *(SINT64 *) argp = *(SINT32 *)(* p_argv);\n-\t  break;\n-\t\t  \n \tcase FFI_TYPE_UINT32:\n-\t  *(UINT64 *) argp = *(UINT32 *)(* p_argv);\n+\t  /* Note that unsigned 32-bit quantities are sign extended.  */\n+\t  *(SINT64 *) argp = *(SINT32 *)(* avalue);\n \t  break;\n-\n+\t\t  \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_POINTER:\n-\t  *(UINT64 *) argp = *(UINT64 *)(* p_argv);\n+\t  *(UINT64 *) argp = *(UINT64 *)(* avalue);\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n-\t  if (argp - stack < 12 * SIZEOF_ARG)\n+\t  if (argp - stack < 6)\n \t    {\n \t      /* Note the conversion -- all the fp regs are loaded as\n \t\t doubles.  The in-register format is the same.  */\n-\t      *(double *) (argp - 6 * SIZEOF_ARG) = *(float *)(* p_argv);\n+\t      *(double *) argp = *(float *)(* avalue);\n \t    }\n \t  else\n-\t    *(float *) argp = *(float *)(* p_argv);\n+\t    *(float *) argp = *(float *)(* avalue);\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  if (argp - stack < 12 * SIZEOF_ARG)\n-\t    *(double *) (argp - 6 * SIZEOF_ARG) = *(double *)(* p_argv);\n-\t  else\n-\t    *(double *) argp = *(double *)(* p_argv);\n+\t  *(double *) argp = *(double *)(* avalue);\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-\t  memcpy(argp, *p_argv, (*p_arg)->size);\n+\t  memcpy(argp, *avalue, (*arg_types)->size);\n \t  break;\n \n \tdefault:\n \t  FFI_ASSERT(0);\n \t}\n \n-      argp += z;\n-      i++, p_arg++, p_argv++;\n+      argp += ALIGN((*arg_types)->size, SIZEOF_ARG) / SIZEOF_ARG;\n+      i++, arg_types++, avalue++;\n     }\n+\n+  ffi_call_osf(stack, cif->bytes, cif->flags, rvalue, fn);\n }\n \n-/* Perform machine dependent cif processing */\n+\n ffi_status\n-ffi_prep_cif_machdep(ffi_cif *cif)\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t  void *user_data)\n {\n-  /* Adjust cif->bytes. to include 12 words for the temporary register\n-     argument loading area.  This will be removed before the call.  */\n-\n-  cif->bytes += 6*SIZEOF_ARG;\n-  if (cif->bytes < 12*SIZEOF_ARG)\n-    cif->bytes = 12*SIZEOF_ARG;\n-\n-  /* The stack must be double word aligned, so round bytes up\n-     appropriately. */\n+  unsigned int *tramp;\n \n-  cif->bytes = ALIGN(cif->bytes, 2*sizeof(void*));\n+  FFI_ASSERT (cif->abi == FFI_OSF);\n \n-  /* Set the return type flag */\n-  switch (cif->rtype->type)\n-    {\n-    case FFI_TYPE_VOID:\n-    case FFI_TYPE_STRUCT:\n-      cif->flags = cif->rtype->type;\n-      break;\n+  tramp = (unsigned int *) &closure->tramp[0];\n+  tramp[0] = 0x47fb0401;\t/* mov $27,$1\t\t*/\n+  tramp[1] = 0xa77b0010;\t/* ldq $27,16($27)\t*/\n+  tramp[2] = 0x6bfb0000;\t/* jmp $31,($27),0\t*/\n+  tramp[3] = 0x47ff041f;\t/* nop\t\t\t*/\n+  *(void **) &tramp[4] = ffi_closure_osf;\n \n-    case FFI_TYPE_FLOAT:\n-      cif->flags = FFI_TYPE_FLOAT;\n-      break;\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n \n-    case FFI_TYPE_DOUBLE:\n-      cif->flags = FFI_TYPE_DOUBLE;\n-      break;\n+  /* Flush the Icache.  */\n+  asm volatile (\"imb\" : : : \"memory\");\n \n-    default:\n-      cif->flags = FFI_TYPE_INT;\n-      break;\n-    }\n-  \n   return FFI_OK;\n }\n \n-extern int ffi_call_osf(void (*)(char *, extended_cif *, int, int), \n-\t\t\textended_cif *, unsigned, \n-\t\t\tunsigned, unsigned *, void (*)());\n-\n-void\n-ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n+int\n+ffi_closure_osf_inner(ffi_closure *closure, void *rvalue, unsigned long *argp)\n {\n-  extended_cif ecif;\n+  ffi_cif *cif;\n+  void **avalue;\n+  ffi_type **arg_types;\n+  long i, avn, argn;\n \n-  ecif.cif = cif;\n-  ecif.avalue = avalue;\n-  \n-  /* If the return value is a struct and we don't have a return\n-     value address then we need to make one.  */\n+  cif = closure->cif;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n+\n+  argn = 0;\n+\n+  /* Copy the caller's structure return address to that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    {\n+      rvalue = (void *) argp[0];\n+      argn = 1;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n   \n-  if (rvalue == NULL && cif->rtype->type == FFI_TYPE_STRUCT)\n-    ecif.rvalue = alloca(cif->rtype->size);\n-  else\n-    ecif.rvalue = rvalue;\n-    \n-  switch (cif->abi) \n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn)\n     {\n-    case FFI_OSF:\n-      ffi_call_osf(ffi_prep_args, &ecif, cif->bytes, \n-\t\t   cif->flags, rvalue, fn);\n-      break;\n+      switch ((*arg_types)->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\tcase FFI_TYPE_STRUCT:\n+\t  *avalue = &argp[argn];\n+\t  break;\n \n-    default:\n-      FFI_ASSERT(0);\n-      break;\n+\tcase FFI_TYPE_FLOAT:\n+\t  if (argn < 6)\n+\t    {\n+\t      /* Floats coming from registers need conversion from double\n+\t         back to float format.  */\n+\t      *(float *)&argp[argn - 6] = *(double *)&argp[argn - 6];\n+\t      *avalue = &argp[argn - 6];\n+\t    }\n+\t  else\n+\t    *avalue = &argp[argn];\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  *avalue = &argp[argn - (argn < 6 ? 6 : 0)];\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      argn += ALIGN((*arg_types)->size, SIZEOF_ARG) / SIZEOF_ARG;\n+      i++, arg_types++, avalue++;\n     }\n+\n+  /* Invoke the closure.  */\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_osf what register to put the return value in.  */\n+  return cif->flags;\n }"}, {"sha": "9ed37cbb00e18d405f4a497ae4ee0144a0955b60", "filename": "libffi/src/alpha/osf.S", "status": "modified", "additions": 122, "deletions": 58, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2Fsrc%2Falpha%2Fosf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fe0479819d1212b18f7e577fb3ebcfad3d4ce5/libffi%2Fsrc%2Falpha%2Fosf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fosf.S?ref=29fe0479819d1212b18f7e577fb3ebcfad3d4ce5", "patch": "@@ -28,91 +28,155 @@\n #define LIBFFI_ASM\t\n #include <ffi.h>\n \n-#define callback $16\n-#define ecifp\t $17\n-#define bytes\t $18\n-#define flags\t $19\n-#define raddr    $20\n-#define fn       $21\n+\t.text\n \n-#define flags_ofs\t16\n-#define raddr_ofs\t24\n-#define fn_ofs\t\t32\n+/* ffi_call_osf (void *args, unsigned long bytes, unsigned flags,\n+\t\t void *raddr, void (*fnaddr)());\n \n-#define SIZEOF_FRAME\t(6*8)\n+   Bit o trickiness here -- ARGS+BYTES is the base of the stack frame\n+   for this function.  This has been allocated by ffi_call.  We also\n+   deallocate some of the stack that has been alloca'd.  */\n \n-\t.text\n-\t.align\t4\n+\t.align\t3\n \t.globl\tffi_call_osf\n \t.ent\tffi_call_osf\n-\t\n ffi_call_osf:\n-\tlda\t$30, -SIZEOF_FRAME($30)\n-\tstq\t$26, 0($30)\n-\tstq\t$15, 8($30)\n-\tstq\tflags, flags_ofs($30)\n-\tstq\traddr, raddr_ofs($30)\n-\tstq\tfn, fn_ofs($30)\n-\tmov\t$30, $15\n-\t.frame\t$15, SIZEOF_FRAME, $26, 0\n-        .mask   0x4008000, -SIZEOF_FRAME\n+\t.frame\t$15, 32, $26, 0\n+\t.mask   0x4008000, -32\n+\taddq\t$16,$17,$1\n+\tmov\t$16, $30\n+\tstq\t$26, 0($1)\n+\tstq\t$15, 8($1)\n+\tstq\t$18, 16($1)\n+\tmov\t$1, $15\n \t.prologue 0\n \n-\tmov\tcallback, $27\t\t# mov callback into place\n-\tsubq\t$30, bytes, $30\t\t# allocate stack space\n-\t\n-\t# Call ffi_prep_args; ecif, bytes and flags are already in place.\n-\tmov\t$30, $16\t\t# push stack arg\n-\tjsr\t$26, ($27), 0\n+\tstq\t$19, 24($1)\n+\tmov\t$20, $27\n \n \t# Load up all of the (potential) argument registers.\n+\tldq\t$16, 0($30)\n \tldt\t$f16, 0($30)\n \tldt\t$f17, 8($30)\n+\tldq\t$17, 8($30)\n \tldt\t$f18, 16($30)\n+\tldq\t$18, 16($30)\n \tldt\t$f19, 24($30)\n+\tldq\t$19, 24($30)\n \tldt\t$f20, 32($30)\n+\tldq\t$20, 32($30)\n \tldt\t$f21, 40($30)\n-\tldq\t$16, 48($30)\n-\tldq\t$17, 56($30)\n-\tldq\t$18, 64($30)\n-\tldq\t$19, 72($30)\n-\tldq\t$20, 80($30)\n-\tldq\t$21, 88($30)\n-\n-\t# Get rid of the arg reg temp space and call the function.\n-\tldq\t$27, fn_ofs($15)\n-\tlda\t$30, 12*8($30)\n+\tldq\t$21, 40($30)\n+\n+\t# Deallocate the register argument area.\n+\tlda\t$30, 48($30)\n+\n \tjsr\t$26, ($27), 0\n+\tldgp\t$29, 0($26)\n \n \t# If the return value pointer is NULL, assume no return value.\n-\tldq\traddr, raddr_ofs($15)\n-\tbeq\traddr, $noretval\n+\tldq\t$19, 24($15)\n+\tldq\t$18, 16($15)\n+\tldq\t$26, 0($15)\n+\tbeq\t$19, $noretval\n \n-\tldq\tflags, flags_ofs($15)\n-\tcmpeq\tflags, FFI_TYPE_INT, $1\n+\t# Store the return value out in the proper type.\n+\tcmpeq\t$18, FFI_TYPE_INT, $1\n \tbne\t$1, $retint\n-\tcmpeq\tflags, FFI_TYPE_FLOAT, $2\n+\tcmpeq\t$18, FFI_TYPE_FLOAT, $2\n \tbne\t$2, $retfloat\n-\tcmpeq\tflags, FFI_TYPE_DOUBLE, $3\n+\tcmpeq\t$18, FFI_TYPE_DOUBLE, $3\n \tbne\t$3, $retdouble\n-\tbr\t$retstruct\n-\t\n-\t.align 3\n+\n+$noretval:\n+\tldq\t$15, 8($15)\n+\tret\n+\n $retint:\n-\tstq\t$0, 0(raddr)\n-\tbr\t$noretval\n+\tstq\t$0, 0($19)\n+\tnop\n+\tldq\t$15, 8($15)\n+\tret\n+\n $retfloat:\n-\tsts\t$f0, 0(raddr)\n-\tbr\t$noretval\n-$retdouble:\n-\tstt\t$f0, 0(raddr)\n+\tsts\t$f0, 0($19)\n+\tnop\n+\tldq\t$15, 8($15)\n+\tret\n \n-$retstruct:\n-$noretval:\n-\tmov\t$15, $30\n-\tldq\t$26, 0($15)\n+$retdouble:\n+\tstt\t$f0, 0($19)\n+\tnop\n \tldq\t$15, 8($15)\n-\tlda\t$30, SIZEOF_FRAME($30)\n \tret\n \n \t.end\tffi_call_osf\n+\n+/* ffi_closure_osf(...)\n+\n+   Receives the closure argument in $1.   */\n+\n+\t.align\t3\n+\t.globl\tffi_closure_osf\n+\t.ent\tffi_closure_osf\n+ffi_closure_osf:\n+\t.frame\t$30, 16*8, $26, 0\n+\t.mask\t0x4000000, -14*8\n+\tldgp\t$29, 0($27)\n+\tsubq\t$30, 14*8, $30\n+\tstq\t$26, 0($30)\n+\t.prologue 1\n+\n+\t# Store all of the potential argument registers in va_list format.\n+\tstt\t$f16, 4*8($30)\n+\tstt\t$f17, 5*8($30)\n+\tstt\t$f18, 6*8($30)\n+\tstt\t$f19, 7*8($30)\n+\tstt\t$f20, 8*8($30)\n+\tstt\t$f21, 9*8($30)\n+\tstq\t$16, 10*8($30)\n+\tstq\t$17, 11*8($30)\n+\tstq\t$18, 12*8($30)\n+\tstq\t$19, 13*8($30)\n+\tstq\t$20, 14*8($30)\n+\tstq\t$21, 15*8($30)\n+\n+\t# Call ffi_closure_osf_inner to do the bulk of the work.\n+\tmov\t$1, $16\n+\tlda\t$17, 2*8($30)\n+\tlda\t$18, 10*8($30)\n+\tjsr\t$26, ffi_closure_osf_inner\n+\tldgp\t$29, 0($26)\n+\tldq\t$26, 0($30)\n+\n+\t# Load up the return value in the proper type.\n+\tcmpeq\t$0, FFI_TYPE_INT, $1\n+\tbne\t$1, $loadint\n+\tcmpeq\t$0, FFI_TYPE_FLOAT, $2\n+\tbne\t$2, $loadfloat\n+\tcmpeq\t$18, FFI_TYPE_DOUBLE, $3\n+\tbne\t$3, $loaddouble\n+\n+\taddq\t$30, 16*8, $30\n+\tret\n+\n+\t.align 3\n+$loadint:\n+\tldq\t$0, 16($30)\n+\tnop\n+\taddq\t$30, 16*8, $30\n+\tret\n+\n+$loadfloat:\n+\tlds\t$f0, 16($30)\n+\tnop\n+\taddq\t$30, 16*8, $30\n+\tret\n+\n+$loaddouble:\n+\tldt\t$f0, 16($30)\n+\tnop\n+\taddq\t$30, 16*8, $30\n+\tret\n+\n+\t.end\tffi_closure_osf"}]}