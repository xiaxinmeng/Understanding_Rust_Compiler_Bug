{"sha": "b02b9b53ec39cfd36e27424c4c07be5880ec393a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAyYjliNTNlYzM5Y2ZkMzZlMjc0MjRjNGMwN2JlNTg4MGVjMzkzYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-05-17T08:10:24Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-17T08:10:24Z"}, "message": "tree-vrp.c (finalize_jump_threads): Do not care about dominance info.\n\n\t* tree-vrp.c (finalize_jump_threads): Do not care about dominance info.\n\t(execute_vrp): Preserve loops through jump threading.\n\t* tree-ssa-threadupdate.c (thread_single_edge,\n\tdbds_continue_enumeration_p, determine_bb_domination_status,\n\tthread_through_loop_header): New functions.\n\t(create_edge_and_update_destination_phis,\n\tcreate_edge_and_update_destination_phis): Set loops for the new blocks.\n\t(prune_undesirable_thread_requests): Removed.\n\t(redirect_edges): Do not pretend that redirect_edge_and_branch can\n\tcreate new blocks.\n\t(thread_block): Do not call prune_undesirable_thread_requests.\n\tUpdate loops.\n\t(mark_threaded_blocks): Select edges to thread here.\n\t(thread_through_all_blocks): Take may_peel_loop_headers argument.\n\tThread edges through loop headers independently.\n\t* cfgloopmanip.c (create_preheader, mfb_keep_just): Export.\n\t* tree-pass.h (TODO_mark_first_instance): New.\n\t(first_pass_instance): Declare.\n\t* cfghooks.c (duplicate_block): Put the block to the original loop\n\tif copy is not specified.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Preserve loops through\n\tjump threading.  Pass may_peel_loop_headers to\n\tthread_through_all_blocks according to first_pass_instance.\n\t* cfgloop.h (create_preheader): Declare.\n\t* tree-flow.h (thread_through_all_blocks): Declaration changed.\n\t* basic-block.h (mfb_keep_just, mfb_kj_edge): Declare.\n\t* passes.c (first_pass_instance): New variable.\n\t(next_pass_1): Set TODO_mark_first_instance.\n\t(execute_todo): Set first_pass_instance.\n\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2.c: New test.\n\t* gcc.dg/vect/vect-102.c, gcc.dg/vect/vect-103.c,\n\tgcc.dg/vect/vect-104.c: Use more complex construction to prevent vectorizing.\n\t* gcc.dg/tree-ssa/pr21559.c: Update outcome.\n\nFrom-SVN: r124786", "tree": {"sha": "7157094906e2791038cab066565c2c9b9c4e3104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7157094906e2791038cab066565c2c9b9c4e3104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b02b9b53ec39cfd36e27424c4c07be5880ec393a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b02b9b53ec39cfd36e27424c4c07be5880ec393a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b02b9b53ec39cfd36e27424c4c07be5880ec393a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b02b9b53ec39cfd36e27424c4c07be5880ec393a/comments", "author": null, "committer": null, "parents": [{"sha": "d2594859a6d1ea12ddde863721acbcb7fa645371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2594859a6d1ea12ddde863721acbcb7fa645371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2594859a6d1ea12ddde863721acbcb7fa645371"}], "stats": {"total": 956, "additions": 660, "deletions": 296}, "files": [{"sha": "247a42d9b24988a59f2a23147d0a149b690ac131", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -1,3 +1,35 @@\n+2007-05-17  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-vrp.c (finalize_jump_threads): Do not care about dominance info.\n+\t(execute_vrp): Preserve loops through jump threading.\n+\t* tree-ssa-threadupdate.c (thread_single_edge,\n+\tdbds_continue_enumeration_p, determine_bb_domination_status,\n+\tthread_through_loop_header): New functions.\n+\t(create_edge_and_update_destination_phis,\n+\tcreate_edge_and_update_destination_phis): Set loops for the new blocks.\n+\t(prune_undesirable_thread_requests): Removed.\n+\t(redirect_edges): Do not pretend that redirect_edge_and_branch can\n+\tcreate new blocks.\n+\t(thread_block): Do not call prune_undesirable_thread_requests.\n+\tUpdate loops.\n+\t(mark_threaded_blocks): Select edges to thread here.\n+\t(thread_through_all_blocks): Take may_peel_loop_headers argument.\n+\tThread edges through loop headers independently.\n+\t* cfgloopmanip.c (create_preheader, mfb_keep_just): Export.\n+\t* tree-pass.h (TODO_mark_first_instance): New.\n+\t(first_pass_instance): Declare.\n+\t* cfghooks.c (duplicate_block): Put the block to the original loop\n+\tif copy is not specified.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Preserve loops through\n+\tjump threading.  Pass may_peel_loop_headers to\n+\tthread_through_all_blocks according to first_pass_instance.\n+\t* cfgloop.h (create_preheader): Declare.\n+\t* tree-flow.h (thread_through_all_blocks): Declaration changed.\n+\t* basic-block.h (mfb_keep_just, mfb_kj_edge): Declare.\n+\t* passes.c (first_pass_instance): New variable.\n+\t(next_pass_1): Set TODO_mark_first_instance.\n+\t(execute_todo): Set first_pass_instance.\n+\n 2007-05-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR tree-optimization/24659"}, {"sha": "a3d4dc84b69ed3f3128c4c83e7fa0a8d24c350a4", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -1173,4 +1173,8 @@ bb_has_eh_pred (basic_block bb)\n   return false;\n }\n \n+/* In cfgloopmanip.c.  */\n+extern edge mfb_kj_edge;\n+bool mfb_keep_just (edge);\n+\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "7f544c3ee3cccea54b49cc944da88df313c957d4", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -923,9 +923,15 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n   set_bb_original (new_bb, bb);\n   set_bb_copy (bb, new_bb);\n \n-  /* Add the new block to the prescribed loop.  */\n+  /* Add the new block to the copy of the loop of BB, or directly to the loop\n+     of BB if the loop is not being copied.  */\n   if (current_loops != NULL)\n-    add_bb_to_loop (new_bb, bb->loop_father->copy);\n+    {\n+      struct loop *cloop = bb->loop_father;\n+      if (cloop->copy)\n+\tcloop = cloop->copy;\n+      add_bb_to_loop (new_bb, cloop);\n+    }\n \n   return new_bb;\n }"}, {"sha": "378698606885404e696b13449b68d30e62d339db", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -252,6 +252,7 @@ enum\n   CP_SIMPLE_PREHEADERS = 1\n };\n \n+basic_block create_preheader (struct loop *, int);\n extern void create_preheaders (int);\n extern void force_single_succ_latches (void);\n "}, {"sha": "1fadbb4356d8cf9862c1d0963747c6c4fbadd6ba", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -41,7 +41,6 @@ static int find_path (edge, basic_block **);\n static void fix_loop_placements (struct loop *, bool *);\n static bool fix_bb_placement (basic_block);\n static void fix_bb_placements (basic_block, bool *);\n-static basic_block create_preheader (struct loop *, int);\n static void unloop (struct loop *, bool *);\n \n #define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n@@ -1085,8 +1084,8 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n    MFB_KJ_EDGE to the entry part.  E is the edge for that we should decide\n    whether to redirect it.  */\n \n-static edge mfb_kj_edge;\n-static bool\n+edge mfb_kj_edge;\n+bool\n mfb_keep_just (edge e)\n {\n   return e != mfb_kj_edge;\n@@ -1097,7 +1096,7 @@ mfb_keep_just (edge e)\n    entry; otherwise we also force preheader block to have only one successor.\n    The function also updates dominators.  */\n \n-static basic_block\n+basic_block\n create_preheader (struct loop *loop, int flags)\n {\n   edge e, fallthru;"}, {"sha": "78ccb47049e636f7a1bc71802af56a61815c6014", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -105,6 +105,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Global variables used to communicate with passes.  */\n int dump_flags;\n bool in_gimple_form;\n+bool first_pass_instance;\n \n \n /* This is called from various places for FUNCTION_DECL, VAR_DECL,\n@@ -392,6 +393,8 @@ next_pass_1 (struct tree_opt_pass **list, struct tree_opt_pass *pass)\n       memcpy (new, pass, sizeof (*new));\n       new->next = NULL;\n \n+      new->todo_flags_start &= ~TODO_mark_first_instance;\n+\n       /* Indicate to register_dump_files that this pass has duplicates,\n          and so it should rename the dump file.  The first instance will\n          be -1, and be number of duplicates = -static_pass_number - 1.\n@@ -406,6 +409,7 @@ next_pass_1 (struct tree_opt_pass **list, struct tree_opt_pass *pass)\n     }\n   else\n     {\n+      pass->todo_flags_start |= TODO_mark_first_instance;\n       pass->static_pass_number = -1;\n       *list = pass;\n     }  \n@@ -932,6 +936,9 @@ execute_todo (unsigned int flags)\n     gcc_assert (flags & TODO_update_ssa_any);\n #endif\n \n+  /* Inform the pass whether it is the first time it is run.  */\n+  first_pass_instance = (flags & TODO_mark_first_instance) != 0;\n+\n   do_per_function (execute_function_todo, (void *)(size_t) flags);\n \n   /* Always remove functions just as before inlining: IPA passes might be"}, {"sha": "e829a0f9c7250039069504ec7ecd7de448f02c61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -1,3 +1,10 @@\n+2007-05-17  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2.c: New test.\n+\t* gcc.dg/vect/vect-102.c, gcc.dg/vect/vect-103.c,\n+\tgcc.dg/vect/vect-104.c: Use more complex construction to prevent vectorizing.\n+\t* gcc.dg/tree-ssa/pr21559.c: Update outcome.\n+\n 2007-05-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR tree-optimization/24659"}, {"sha": "402c102d25922cac99644add8e83b3b357f37403", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21559.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -35,11 +35,9 @@ void foo (void)\n /* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp1\" } } */\n \n /* Second, we should thread the edge out of the loop via the break\n-   statement.  */\n-/* { dg-final { scan-tree-dump-times \"Threaded jump\" 1 \"vrp1\" } } */\n-\n-/* Now if we were really good, we'd realize that the final bytes == 0\n-   test is totally useless.  That's not likely to happen anytime soon.  */\n+   statement.  We also realize that the final bytes == 0 test is useless,\n+   and thread over it.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded jump\" 2 \"vrp1\" } } */\n \n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "6aaea8ecb38c9646f6f689d437ca682d1b18dbd7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n+\n+void foo();\n+void bla();\n+void bar();\n+\n+/* In the following two cases, we should be able to thread edge through\n+   the loop header.  */\n+\n+void thread_entry_through_header (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 170; i++)\n+    bla ();\n+}\n+\n+void thread_latch_through_header (void)\n+{\n+  int i = 0;\n+  int first = 1;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+\n+      first = 0;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* This is a TODO -- it is correct to thread both entry and latch edge through\n+   the header, but we do not handle this case yet.  */\n+\n+void dont_thread_1 (void)\n+{\n+  int i = 0;\n+  int first = 1;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = 0;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* Avoid threading in the following two cases, to prevent creating subloops.  */\n+\n+void dont_thread_2 (int first)\n+{\n+  int i = 0;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = 0;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+void dont_thread_3 (int nfirst)\n+{\n+  int i = 0;\n+  int first = 0;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = nfirst;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* Avoid threading in this case, in order to avoid creating loop with\n+   multiple entries.  */\n+\n+void dont_thread_4 (int a, int nfirst)\n+{\n+  int i = 0;\n+  int first;\n+\n+  if (a)\n+    first = 0;\n+  else\n+    first = 1;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = nfirst;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 1 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 0 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 0 \"dom1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 1 \"dom1\"} } */\n+/* { dg-final { cleanup-tree-dump \"dom1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "49df4f9bc905a5bcac6a4f8b5f2c80862be1c00f", "filename": "gcc/testsuite/gcc.dg/vect/vect-102.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-102.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-102.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-102.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -14,6 +14,7 @@ struct extraction\n \n static int a[N] = {1,2,3,4,5,6,7,8,9};\n static int b[N] = {2,3,4,5,6,7,8,9,9};\n+volatile int foo;\n \n int main1 (int x, int y) {\n   int i;\n@@ -23,7 +24,7 @@ int main1 (int x, int y) {\n   for (i = 0; i < N; i++)\n     {\n        p->a[i] = a[i];\n-       if (x == 135)\n+       if (foo == 135)\n \t abort (); /* to avoid vectorization  */\n     }\n \n@@ -46,6 +47,7 @@ int main (void)\n { \n   check_vect ();\n \n+  foo = 0;\n   return main1 (0, N);\n }\n "}, {"sha": "da1b69e562664e3c5dd2265def2add42587a9f9f", "filename": "gcc/testsuite/gcc.dg/vect/vect-103.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -15,6 +15,7 @@ struct extraction\n static int a[N] = {1,2,3,4,5,6,7,8,9};\n static int b[N] = {17,24,7,0,2,3,4,31,82};\n static int c[N] = {9,17,24,7,0,2,3,4,31};\n+volatile int foo;\n \n int main1 (int x, int y) {\n   int i;\n@@ -25,7 +26,7 @@ int main1 (int x, int y) {\n     {\n        p->a[i] = a[i];\n        p->b[i] = b[i];\n-       if (x == 135)\n+       if (foo == 135)\n \t abort (); /* to avoid vectorization  */\n     }\n \n@@ -48,6 +49,7 @@ int main (void)\n { \n   check_vect ();\n \n+  foo = 0;\n   return main1 (0, N);\n }\n "}, {"sha": "6ab0f23acf8090bdada43e7ca35c56156aa858d8", "filename": "gcc/testsuite/gcc.dg/vect/vect-104.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-104.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-104.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-104.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -15,6 +15,7 @@ struct extraction\n static int a[N][N] = {{1,2,3},{4,5,6},{7,8,9}};\n static int b[N][N] = {{17,24,7},{0,2,3},{4,31,82}};\n static int c[N][N] = {{1,2,3},{4,6,8},{8,9,9}};\n+volatile int foo;\n \n int main1 (int x) {\n   int i,j;\n@@ -27,7 +28,7 @@ int main1 (int x) {\n      {\n        p->a[i][j] = a[i][j];\n        p->b[i][j] = b[i][j];\n-       if (x == 135)\n+       if (foo == 135)\n \t abort (); /* to avoid vectorization  */\n      }\n    }\n@@ -57,6 +58,7 @@ int main (void)\n { \n   check_vect ();\n \n+  foo = 0;\n   return main1 (N);\n }\n "}, {"sha": "156ae13b43ba3949e79decba7e268e25cd9e5613", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -1113,7 +1113,7 @@ bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode);\n unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode);\n \n /* In tree-ssa-threadupdate.c.  */\n-extern bool thread_through_all_blocks (void);\n+extern bool thread_through_all_blocks (bool);\n extern void register_jump_thread (edge, edge);\n \n /* In gimplify.c  */"}, {"sha": "299255cea758a26f2b3c34497bc8f2b5c31658c5", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -218,6 +218,9 @@ struct dump_file_info\n    for the passes that are handed to register_dump_files.  */\n #define TODO_set_props\t\t\t(1 << 15)\n \n+/* Internally used for the first instance of a pass.  */\n+#define TODO_mark_first_instance\t(1 << 16)\n+\n #define TODO_update_ssa_any\t\t\\\n     (TODO_update_ssa\t\t\t\\\n      | TODO_update_ssa_no_phi\t\t\\\n@@ -417,4 +420,13 @@ extern struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;\n extern void execute_pass_list (struct tree_opt_pass *);\n extern void execute_ipa_pass_list (struct tree_opt_pass *);\n \n+/* Set to true if the pass is called the first time during compilation of the\n+   current function.  Note that using this information in the optimization\n+   passes is considered not to be clean, and it should be avoided if possible.\n+   This flag is currently used to prevent loops from being peeled repeatedly\n+   in jump threading; it will be removed once we preserve loop structures\n+   throughout the compilation -- we will be able to mark the affected loops\n+   directly in jump threading, and avoid peeling them next time.  */\n+extern bool first_pass_instance;\n+\n #endif /* GCC_TREE_PASS_H */"}, {"sha": "87270fc8e083b94cc0d161599196b180e10211b6", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -277,25 +277,17 @@ tree_ssa_dominator_optimize (void)\n   calculate_dominance_info (CDI_DOMINATORS);\n   cfg_altered = false;\n \n-  /* We need to know which edges exit loops so that we can\n-     aggressively thread through loop headers to an exit\n-     edge.  */\n-  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n-  if (current_loops)\n-    {\n-      mark_loop_exit_edges ();\n-      loop_optimizer_finalize ();\n-    }\n-\n-  /* Clean up the CFG so that any forwarder blocks created by loop\n-     canonicalization are removed.  */\n-  cleanup_tree_cfg ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n+  /* We need to know loop structures in order to avoid destroying them\n+     in jump threading.  Note that we still can e.g. thread through loop\n+     headers to an exit edge, or through loop header to the loop body, assuming\n+     that we update the loop info.  */\n+  loop_optimizer_init (LOOPS_HAVE_SIMPLE_LATCHES);\n \n   /* We need accurate information regarding back edges in the CFG\n-     for jump threading.  */\n+     for jump threading; this may include back edes that are not part of\n+     a single loop.  */\n   mark_dfs_back_edges ();\n-\n+      \n   /* Recursively walk the dominator tree optimizing statements.  */\n   walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n \n@@ -319,7 +311,7 @@ tree_ssa_dominator_optimize (void)\n   free_all_edge_infos ();\n \n   /* Thread jumps, creating duplicate blocks as needed.  */\n-  cfg_altered |= thread_through_all_blocks ();\n+  cfg_altered |= thread_through_all_blocks (first_pass_instance);\n \n   if (cfg_altered)\n     free_dominance_info (CDI_DOMINATORS);\n@@ -353,6 +345,8 @@ tree_ssa_dominator_optimize (void)\n   if (dump_file && (dump_flags & TDF_STATS))\n     dump_dominator_optimization_stats (dump_file);\n \n+  loop_optimizer_finalize ();\n+\n   /* Delete our main hashtable.  */\n   htab_delete (avail_exprs);\n "}, {"sha": "22266bd355c91cb224a7e7912d37fa5ae31f77a8", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 429, "deletions": 247, "changes": 676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -315,6 +315,7 @@ create_edge_and_update_destination_phis (struct redirection_data *rd)\n \n   e->probability = REG_BR_PROB_BASE;\n   e->count = rd->dup_block->count;\n+  e->aux = rd->outgoing_edge->aux;\n \n   /* If there are any PHI nodes at the destination of the outgoing edge\n      from the duplicate block, then we will need to add a new argument\n@@ -385,199 +386,6 @@ fixup_template_block (void **slot, void *data)\n   return 1;\n }\n \n-/* Not all jump threading requests are useful.  In particular some\n-   jump threading requests can create irreducible regions which are\n-   undesirable.\n-\n-   This routine will examine the BB's incoming edges for jump threading\n-   requests which, if acted upon, would create irreducible regions.  Any\n-   such jump threading requests found will be pruned away.  */\n-\n-static void\n-prune_undesirable_thread_requests (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  bool may_create_irreducible_region = false;\n-  unsigned int num_outgoing_edges_into_loop = 0;\n-\n-  /* For the heuristics below, we need to know if BB has more than\n-     one outgoing edge into a loop.  */\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    num_outgoing_edges_into_loop += ((e->flags & EDGE_LOOP_EXIT) == 0);\n-\n-  if (num_outgoing_edges_into_loop > 1)\n-    {\n-      edge backedge = NULL;\n-\n-      /* Consider the effect of threading the edge (0, 1) to 2 on the left\n-\t CFG to produce the right CFG:\n-    \n-\n-             0            0\n-             |            |\n-             1<--+        2<--------+\n-            / \\  |        |         |\n-           2   3 |        4<----+   |\n-            \\ /  |       / \\    |   |\n-             4---+      E   1-- | --+\n-             |              |   |\n-             E              3---+\n-\n-\n- \tThreading the (0, 1) edge to 2 effectively creates two loops\n- \t(2, 4, 1) and (4, 1, 3) which are neither disjoint nor nested.\n-\tThis is not good.\n-\n-\tHowever, we do need to be able to thread  (0, 1) to 2 or 3\n-\tin the left CFG below (which creates the middle and right\n-\tCFGs with nested loops).\n-\n-             0          0             0\n-             |          |             |\n-             1<--+      2<----+       3<-+<-+\n-            /|   |      |     |       |  |  |\n-           2 |   |      3<-+  |       1--+  |\n-            \\|   |      |  |  |       |     |\n-             3---+      1--+--+       2-----+\n-\n-\t \n-\t A safe heuristic appears to be to only allow threading if BB\n-\t has a single incoming backedge from one of its direct successors.  */\n-\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  if (e->flags & EDGE_DFS_BACK)\n-\t    {\n-\t      if (backedge)\n-\t\t{\n-\t\t  backedge = NULL;\n-\t\t  break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  backedge = e;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (backedge && find_edge (bb, backedge->src))\n-\t;\n-      else\n-        may_create_irreducible_region = true;\n-    }\n-  else\n-    {\n-      edge dest = NULL;\n-\n-      /* If we thread across the loop entry block (BB) into the\n-\t loop and BB is still reached from outside the loop, then\n-\t we would create an irreducible CFG.  Consider the effect\n-\t of threading the edge (1, 4) to 5 on the left CFG to produce\n-\t the right CFG\n-\n-             0               0\n-            / \\             / \\\n-           1   2           1   2\n-            \\ /            |   |\n-             4<----+       5<->4\n-            / \\    |           |\n-           E   5---+           E\n-\n-\n-\t Threading the (1, 4) edge to 5 creates two entry points\n-\t into the loop (4, 5) (one from block 1, the other from\n-\t block 2).  A classic irreducible region. \n-\n-\t So look at all of BB's incoming edges which are not\n-\t backedges and which are not threaded to the loop exit.\n-\t If that subset of incoming edges do not all thread\n-\t to the same block, then threading any of them will create\n-\t an irreducible region.  */\n-\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  edge e2;\n-\n-\t  /* We ignore back edges for now.  This may need refinement\n-    \t     as threading a backedge creates an inner loop which\n-\t     we would need to verify has a single entry point. \n-\n-\t     If all backedges thread to new locations, then this\n-\t     block will no longer have incoming backedges and we\n-\t     need not worry about creating irreducible regions\n-\t     by threading through BB.  I don't think this happens\n-\t     enough in practice to worry about it.  */\n-\t  if (e->flags & EDGE_DFS_BACK)\n-\t    continue;\n-\n-\t  /* If the incoming edge threads to the loop exit, then it\n-\t     is clearly safe.  */\n-\t  e2 = e->aux;\n-\t  if (e2 && (e2->flags & EDGE_LOOP_EXIT))\n-\t    continue;\n-\n-\t  /* E enters the loop header and is not threaded.  We can\n-\t     not allow any other incoming edges to thread into\n-\t     the loop as that would create an irreducible region.  */\n-\t  if (!e2)\n-\t    {\n-\t      may_create_irreducible_region = true;\n-\t      break;\n-\t    }\n-\n-\t  /* We know that this incoming edge threads to a block inside\n-\t     the loop.  This edge must thread to the same target in\n-\t     the loop as any previously seen threaded edges.  Otherwise\n-\t     we will create an irreducible region.  */\n-\t  if (!dest)\n-\t    dest = e2;\n-\t  else if (e2 != dest)\n-\t    {\n-\t      may_create_irreducible_region = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  /* If we might create an irreducible region, then cancel any of\n-     the jump threading requests for incoming edges which are\n-     not backedges and which do not thread to the exit block.  */\n-  if (may_create_irreducible_region)\n-    {\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  edge e2;\n-\n-\t  /* Ignore back edges.  */\n-\t  if (e->flags & EDGE_DFS_BACK)\n-\t    continue;\n-\n-\t  e2 = e->aux;\n-\n-\t  /* If this incoming edge was not threaded, then there is\n-\t     nothing to do.  */\n-\t  if (!e2)\n-\t    continue;\n-\n-\t  /* If this incoming edge threaded to the loop exit,\n-\t     then it can be ignored as it is safe.  */\n-\t  if (e2->flags & EDGE_LOOP_EXIT)\n-\t    continue;\n-\n-\t  if (e2)\n-\t    {\n-\t      /* This edge threaded into the loop and the jump thread\n-\t\t request must be cancelled.  */\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  Not threading jump %d --> %d to %d\\n\",\n-\t\t\t e->src->index, e->dest->index, e2->dest->index);\n-\t      e->aux = NULL;\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Hash table traversal callback to redirect each incoming edge\n    associated with this hash table element to its new destination.  */\n \n@@ -620,11 +428,8 @@ redirect_edges (void **slot, void *data)\n \t  /* Redirect the incoming edge to the appropriate duplicate\n \t     block.  */\n \t  e2 = redirect_edge_and_branch (e, rd->dup_block);\n+\t  gcc_assert (e == e2);\n \t  flush_pending_stmts (e2);\n-\n-\t  if ((dump_file && (dump_flags & TDF_DETAILS))\n-\t      && e->src != e2->src)\n-\t    fprintf (dump_file, \"    basic block %d created\\n\", e2->src->index);\n \t}\n       else\n \t{\n@@ -696,46 +501,23 @@ redirection_block_p (basic_block bb)\n    successor of BB.  We then revector the incoming edges into BB to\n    the appropriate duplicate of BB.\n \n-   BB and its duplicates will have assignments to the same set of\n-   SSA_NAMEs.  Right now, we just call into update_ssa to update the\n-   SSA graph for those names.\n-\n-   We are also going to experiment with a true incremental update\n-   scheme for the duplicated resources.  One of the interesting\n-   properties we can exploit here is that all the resources set\n-   in BB will have the same IDFS, so we have one IDFS computation\n-   per block with incoming threaded edges, which can lower the\n-   cost of the true incremental update algorithm.  */\n+   If NOLOOP_ONLY is true, we only perform the threading as long as it\n+   does not affect the structure of the loops in a nontrivial way.  */\n \n static bool\n-thread_block (basic_block bb)\n+thread_block (basic_block bb, bool noloop_only)\n {\n   /* E is an incoming edge into BB that we may or may not want to\n      redirect to a duplicate of BB.  */\n-  edge e;\n+  edge e, e2;\n   edge_iterator ei;\n   struct local_info local_info;\n-\n-  /* FOUND_BACKEDGE indicates that we found an incoming backedge\n-     into BB, in which case we may ignore certain jump threads\n-     to avoid creating irreducible regions.  */\n-  bool found_backedge = false;\n+  struct loop *loop = bb->loop_father;\n \n   /* ALL indicates whether or not all incoming edges into BB should\n      be threaded to a duplicate of BB.  */\n   bool all = true;\n \n-  /* If optimizing for size, only thread this block if we don't have\n-     to duplicate it or it's an otherwise empty redirection block.  */\n-  if (optimize_size\n-      && EDGE_COUNT (bb->preds) > 1\n-      && !redirection_block_p (bb))\n-    {\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\te->aux = NULL;\n-      return false;\n-    }\n-\n   /* To avoid scanning a linear array for the element we need we instead\n      use a hash table.  For normal code there should be no noticeable\n      difference.  However, if we have a block with a large number of\n@@ -745,35 +527,45 @@ thread_block (basic_block bb)\n \t\t\t\t  redirection_data_eq,\n \t\t\t\t  free);\n \n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    found_backedge |= ((e->flags & EDGE_DFS_BACK) != 0);\n+  /* If we thread the latch of the loop to its exit, the loop ceases to\n+     exist.  Make sure we do not restrict ourselves in order to preserve\n+     this loop.  */\n+  if (current_loops && loop->header == bb)\n+    {\n+      e = loop_latch_edge (loop);\n+      e2 = e->aux;\n \n-  /* If BB has incoming backedges, then threading across BB might\n-     introduce an irreducible region, which would be undesirable\n-     as that inhibits various optimizations later.  Prune away\n-     any jump threading requests which we know will result in\n-     an irreducible region.  */\n-  if (found_backedge)\n-    prune_undesirable_thread_requests (bb);\n+      if (e2 && loop_exit_edge_p (loop, e2))\n+\t{\n+\t  loop->header = NULL;\n+\t  loop->latch = NULL;\n+\t}\n+    }\n \n   /* Record each unique threaded destination into a hash table for\n      efficient lookups.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      if (!e->aux)\n+      e2 = e->aux;\n+\n+      if (!e2\n+\t  /* If NOLOOP_ONLY is true, we only allow threading through the\n+\t     header of a loop to exit edges.  */\n+\t  || (noloop_only\n+\t      && current_loops\n+\t      && bb == bb->loop_father->header\n+\t      && !loop_exit_edge_p (bb->loop_father, e2)))\n \t{\n \t  all = false;\n+\t  continue;\n \t}\n-      else\n-\t{\n-\t  edge e2 = e->aux;\n-\t  update_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n-\t\t\t\t\t   e->count, e->aux);\n \n-\t  /* Insert the outgoing edge into the hash table if it is not\n-\t     already in the hash table.  */\n-\t  lookup_redirection_data (e2, e, INSERT);\n-\t}\n+      update_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n+\t\t\t\t       e->count, e->aux);\n+\n+      /* Insert the outgoing edge into the hash table if it is not\n+\t already in the hash table.  */\n+      lookup_redirection_data (e2, e, INSERT);\n     }\n \n   /* If we are going to thread all incoming edges to an outgoing edge, then\n@@ -821,6 +613,339 @@ thread_block (basic_block bb)\n   return local_info.jumps_threaded;\n }\n \n+/* Threads edge E through E->dest to the edge E->aux.  Returns the copy\n+   of E->dest created during threading, or E->dest if it was not necessary\n+   to copy it (E is its single predecessor).  */\n+\n+static basic_block\n+thread_single_edge (edge e)\n+{\n+  basic_block bb = e->dest;\n+  edge eto = e->aux;\n+  struct redirection_data rd;\n+  struct local_info local_info;\n+\n+  e->aux = NULL;\n+\n+  thread_stats.num_threaded_edges++;\n+\n+  if (single_pred_p (bb))\n+    {\n+      /* If BB has just a single predecessor, we should only remove the\n+\t control statements at its end, and successors except for ETO.  */\n+      remove_ctrl_stmt_and_useless_edges (bb, eto->dest);\n+      return bb;\n+    }\n+\n+  /* Otherwise, we need to create a copy.  */\n+  update_bb_profile_for_threading (bb, EDGE_FREQUENCY (e), e->count, eto);\n+\n+  local_info.bb = bb;\n+  rd.outgoing_edge = eto;\n+\n+  create_block_for_threading (bb, &rd);\n+  create_edge_and_update_destination_phis (&rd);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n+\t     e->src->index, e->dest->index, rd.dup_block->index);\n+\n+  rd.dup_block->count = e->count;\n+  rd.dup_block->frequency = EDGE_FREQUENCY (e);\n+  single_succ_edge (rd.dup_block)->count = e->count;\n+  redirect_edge_and_branch (e, rd.dup_block);\n+  flush_pending_stmts (e);\n+\n+  return rd.dup_block;\n+}\n+\n+/* Callback for dfs_enumerate_from.  Returns true if BB is different\n+   from STOP and DBDS_CE_STOP.  */\n+\n+static basic_block dbds_ce_stop;\n+static bool\n+dbds_continue_enumeration_p (basic_block bb, void *stop)\n+{\n+  return (bb != (basic_block) stop\n+\t  && bb != dbds_ce_stop);\n+}\n+\n+/* Evaluates the dominance relationship of latch of the LOOP and BB, and\n+   returns the state.  */\n+\n+enum bb_dom_status\n+{\n+  /* BB does not dominate latch of the LOOP.  */\n+  DOMST_NONDOMINATING,\n+  /* The LOOP is broken (there is no path from the header to its latch.  */\n+  DOMST_LOOP_BROKEN,\n+  /* BB dominates the latch of the LOOP.  */\n+  DOMST_DOMINATING\n+};\n+\n+static enum bb_dom_status\n+determine_bb_domination_status (struct loop *loop, basic_block bb)\n+{\n+  basic_block *bblocks;\n+  unsigned nblocks, i;\n+  bool bb_reachable = false;\n+  edge_iterator ei;\n+  edge e;\n+\n+#ifdef ENABLE_CHECKING\n+  /* This function assumes BB is a successor of LOOP->header.  */\n+    {\n+      bool ok = false;\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+     \t  if (e->src == loop->header)\n+\t    {\n+\t      ok = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+      gcc_assert (ok);\n+    }\n+#endif\n+\n+  if (bb == loop->latch)\n+    return DOMST_DOMINATING;\n+\n+  /* Check that BB dominates LOOP->latch, and that it is back-reachable\n+     from it.  */\n+\n+  bblocks = XCNEWVEC (basic_block, loop->num_nodes);\n+  dbds_ce_stop = loop->header;\n+  nblocks = dfs_enumerate_from (loop->latch, 1, dbds_continue_enumeration_p,\n+\t\t\t\tbblocks, loop->num_nodes, bb);\n+  for (i = 0; i < nblocks; i++)\n+    FOR_EACH_EDGE (e, ei, bblocks[i]->preds)\n+      {\n+\tif (e->src == loop->header)\n+\t  {\n+\t    free (bblocks);\n+\t    return DOMST_NONDOMINATING;\n+\t  }\n+\tif (e->src == bb)\n+\t  bb_reachable = true;\n+      }\n+\n+  free (bblocks);\n+  return (bb_reachable ? DOMST_DOMINATING : DOMST_LOOP_BROKEN);\n+}\n+\n+/* Thread jumps through the header of LOOP.  Returns true if cfg changes.\n+   If MAY_PEEL_LOOP_HEADERS is false, we avoid threading from entry edges\n+   to the inside of the loop.  */\n+\n+static bool\n+thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n+{\n+  basic_block header = loop->header;\n+  edge e, tgt_edge, latch = loop_latch_edge (loop);\n+  edge_iterator ei;\n+  basic_block tgt_bb, atgt_bb;\n+  enum bb_dom_status domst;\n+\n+  /* We have already threaded through headers to exits, so all the threading\n+     requests now are to the inside of the loop.  We need to avoid creating\n+     irreducible regions (i.e., loops with more than one entry block), and\n+     also loop with several latch edges, or new subloops of the loop (although\n+     there are cases where it might be appropriate, it is difficult to decide,\n+     and doing it wrongly may confuse other optimizers).\n+\n+     We could handle more general cases here.  However, the intention is to\n+     preserve some information about the loop, which is impossible if its\n+     structure changes significantly, in a way that is not well understood.\n+     Thus we only handle few important special cases, in which also updating\n+     of the loop-carried information should be feasible:\n+\n+     1) Propagation of latch edge to a block that dominates the latch block\n+\tof a loop.  This aims to handle the following idiom:\n+\n+\tfirst = 1;\n+\twhile (1)\n+\t  {\n+\t    if (first)\n+\t      initialize;\n+\t    first = 0;\n+\t    body;\n+\t  }\n+\n+\tAfter threading the latch edge, this becomes\n+\n+\tfirst = 1;\n+\tif (first)\n+\t  initialize;\n+\twhile (1)\n+\t  {\n+\t    first = 0;\n+\t    body;\n+\t  }\n+\n+\tThe original header of the loop is moved out of it, and we may thread\n+\tthe remaining edges through it without further constraints.\n+\n+     2) All entry edges are propagated to a single basic block that dominates\n+\tthe latch block of the loop.  This aims to handle the following idiom\n+\t(normally created for \"for\" loops):\n+\n+\ti = 0;\n+\twhile (1)\n+\t  {\n+\t    if (i >= 100)\n+\t      break;\n+\t    body;\n+\t    i++;\n+\t  }\n+\n+\tThis becomes\n+\n+\ti = 0;\n+\twhile (1)\n+\t  {\n+\t    body;\n+\t    i++;\n+\t    if (i >= 100)\n+\t      break;\n+\t  }\n+     */\n+\n+  /* Threading through the header won't improve the code if the header has just\n+     one successor.  */\n+  if (single_succ_p (header))\n+    goto fail;\n+\n+  if (latch->aux)\n+    {\n+      tgt_edge = latch->aux;\n+      tgt_bb = tgt_edge->dest;\n+    }\n+  else if (!may_peel_loop_headers\n+\t   && !redirection_block_p (loop->header))\n+    goto fail;\n+  else\n+    {\n+      tgt_bb = NULL;\n+      tgt_edge = NULL;\n+      FOR_EACH_EDGE (e, ei, header->preds)\n+\t{\n+\t  if (!e->aux)\n+\t    {\n+\t      if (e == latch)\n+\t\tcontinue;\n+\n+\t      /* If latch is not threaded, and there is a header\n+\t\t edge that is not threaded, we would create loop\n+\t\t with multiple entries.  */\n+\t      goto fail;\n+\t    }\n+\n+\t  tgt_edge = e->aux;\n+\t  atgt_bb = tgt_edge->dest;\n+\t  if (!tgt_bb)\n+\t    tgt_bb = atgt_bb;\n+\t  /* Two targets of threading would make us create loop\n+\t     with multiple entries.  */\n+\t  else if (tgt_bb != atgt_bb)\n+\t    goto fail;\n+\t}\n+\n+      if (!tgt_bb)\n+\t{\n+\t  /* There are no threading requests.  */\n+\t  return false;\n+\t}\n+\n+      /* Redirecting to empty loop latch is useless.  */\n+      if (tgt_bb == loop->latch\n+\t  && empty_block_p (loop->latch))\n+\tgoto fail;\n+    }\n+\n+  /* The target block must dominate the loop latch, otherwise we would be\n+     creating a subloop.  */\n+  domst = determine_bb_domination_status (loop, tgt_bb);\n+  if (domst == DOMST_NONDOMINATING)\n+    goto fail;\n+  if (domst == DOMST_LOOP_BROKEN)\n+    {\n+      /* If the loop ceased to exist, mark it as such, and thread through its\n+\t original header.  */\n+      loop->header = NULL;\n+      loop->latch = NULL;\n+      return thread_block (header, false);\n+    }\n+\n+  if (tgt_bb->loop_father->header == tgt_bb)\n+    {\n+      /* If the target of the threading is a header of a subloop, we need\n+\t to create a preheader for it, so that the headers of the two loops\n+\t do not merge.  */\n+      if (EDGE_COUNT (tgt_bb->preds) > 2)\n+\t{\n+\t  tgt_bb = create_preheader (tgt_bb->loop_father, 0);\n+\t  gcc_assert (tgt_bb != NULL);\n+\t}\n+      else\n+\ttgt_bb = split_edge (tgt_edge);\n+    }\n+      \n+  if (latch->aux)\n+    {\n+      /* First handle the case latch edge is redirected.  */\n+      loop->latch = thread_single_edge (latch);\n+      gcc_assert (single_succ (loop->latch) == tgt_bb);\n+      loop->header = tgt_bb;\n+\n+      /* Thread the remaining edges through the former header.  */\n+      thread_block (header, false);\n+    }\n+  else\n+    {\n+      basic_block new_preheader;\n+\n+      /* Now consider the case entry edges are redirected to the new entry\n+\t block.  Remember one entry edge, so that we can find the new\n+\tpreheader (its destination after threading).  */\n+      FOR_EACH_EDGE (e, ei, header->preds)\n+\t{\n+\t  if (e->aux)\n+\t    break;\n+\t}\n+\n+      /* The duplicate of the header is the new preheader of the loop.  Ensure\n+\t that it is placed correctly in the loop hierarchy.  */\n+      loop->copy = loop_outer (loop);\n+\n+      thread_block (header, false);\n+      loop->copy = NULL;\n+      new_preheader = e->dest;\n+\n+      /* Create the new latch block.  This is always necessary, as the latch\n+\t must have only a single successor, but the original header had at\n+\t least two successors.  */\n+      loop->latch = NULL;\n+      mfb_kj_edge = single_succ_edge (new_preheader);\n+      loop->header = mfb_kj_edge->dest;\n+      latch = make_forwarder_block (tgt_bb, mfb_keep_just, NULL);\n+      loop->header = latch->dest;\n+      loop->latch = latch->src;\n+    }\n+  \n+  return true;\n+\n+fail:\n+  /* We failed to thread anything.  Cancel the requests.  */\n+  FOR_EACH_EDGE (e, ei, header->preds)\n+    {\n+      e->aux = NULL;\n+    }\n+  return false;\n+}\n+\n /* Walk through the registered jump threads and convert them into a\n    form convenient for this pass.\n \n@@ -838,15 +963,42 @@ static void\n mark_threaded_blocks (bitmap threaded_blocks)\n {\n   unsigned int i;\n+  bitmap_iterator bi;\n+  bitmap tmp = BITMAP_ALLOC (NULL);\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n \n   for (i = 0; i < VEC_length (edge, threaded_edges); i += 2)\n     {\n       edge e = VEC_index (edge, threaded_edges, i);\n       edge e2 = VEC_index (edge, threaded_edges, i + 1);\n \n       e->aux = e2;\n-      bitmap_set_bit (threaded_blocks, e->dest->index);\n+      bitmap_set_bit (tmp, e->dest->index);\n+    }\n+\n+  /* If optimizing for size, only thread through block if we don't have\n+     to duplicate it or it's an otherwise empty redirection block.  */\n+  if (optimize_size)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n+\t{\n+\t  bb = BASIC_BLOCK (i);\n+\t  if (EDGE_COUNT (bb->preds) > 1\n+\t      && !redirection_block_p (bb))\n+\t    {\n+\t      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\t      e->aux = NULL;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (threaded_blocks, i);\n+\t}\n     }\n+  else\n+    bitmap_copy (threaded_blocks, tmp);\n+\n+  BITMAP_FREE(tmp);\n }\n \n \n@@ -856,15 +1008,20 @@ mark_threaded_blocks (bitmap threaded_blocks)\n    It is the caller's responsibility to fix the dominance information\n    and rewrite duplicated SSA_NAMEs back into SSA form.\n \n+   If MAY_PEEL_LOOP_HEADERS is false, we avoid threading edges through\n+   loop headers if it does not simplify the loop.\n+\n    Returns true if one or more edges were threaded, false otherwise.  */\n \n bool\n-thread_through_all_blocks (void)\n+thread_through_all_blocks (bool may_peel_loop_headers)\n {\n   bool retval = false;\n   unsigned int i;\n   bitmap_iterator bi;\n   bitmap threaded_blocks;\n+  struct loop *loop;\n+  loop_iterator li;\n \n   if (threaded_edges == NULL)\n     return false;\n@@ -874,14 +1031,38 @@ thread_through_all_blocks (void)\n \n   mark_threaded_blocks (threaded_blocks);\n \n+  if (current_loops)\n+    FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+      loop->copy = NULL;\n+\n+  /* First perform the threading requests that do not affect\n+     loop structure.  */\n   EXECUTE_IF_SET_IN_BITMAP (threaded_blocks, 0, i, bi)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n \n       if (EDGE_COUNT (bb->preds) > 0)\n-\tretval |= thread_block (bb);\n+\tretval |= thread_block (bb, true);\n+    }\n+\n+  /* Then perform the threading through loop headers.  We start with the\n+     innermost loop, so that the changes in cfg we perform won't affect\n+     further threading.  */\n+  if (current_loops)\n+    {\n+      FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+\t{\n+\t  if (!loop->header\n+\t      || !bitmap_bit_p (threaded_blocks, loop->header->index))\n+\t    continue;\n+\n+\t  retval |= thread_through_loop_header (loop, may_peel_loop_headers);\n+\t}\n     }\n \n+  if (retval)\n+    free_dominance_info (CDI_DOMINATORS);\n+\n   if (dump_file && (dump_flags & TDF_STATS))\n     fprintf (dump_file, \"\\nJumps threaded: %lu\\n\",\n \t     thread_stats.num_threaded_edges);\n@@ -890,6 +1071,7 @@ thread_through_all_blocks (void)\n   threaded_blocks = NULL;\n   VEC_free (edge, heap, threaded_edges);\n   threaded_edges = NULL;\n+\n   return retval;\n }\n "}, {"sha": "5f42ff6d1a5d523ad6554dacfd3be74964450a65", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02b9b53ec39cfd36e27424c4c07be5880ec393a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b02b9b53ec39cfd36e27424c4c07be5880ec393a", "patch": "@@ -5865,13 +5865,7 @@ identify_jump_threads (void)\n static void\n finalize_jump_threads (void)\n {\n-  bool cfg_altered = false;\n-  cfg_altered = thread_through_all_blocks ();\n-\n-  /* If we threaded jumps, then we need to recompute the dominance\n-     information.  */\n-  if (cfg_altered)\n-    free_dominance_info (CDI_DOMINATORS);\n+  thread_through_all_blocks (false);\n   VEC_free (tree, heap, stack);\n }\n \n@@ -5990,22 +5984,19 @@ vrp_finalize (void)\n static unsigned int\n execute_vrp (void)\n {\n-  insert_range_assertions ();\n-\n-  loop_optimizer_init (LOOPS_NORMAL);\n+  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n   if (current_loops)\n-    scev_initialize ();\n+    {\n+      rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+      scev_initialize ();\n+    }\n+\n+  insert_range_assertions ();\n \n   vrp_initialize ();\n   ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);\n   vrp_finalize ();\n \n-  if (current_loops)\n-    {\n-      scev_finalize ();\n-      loop_optimizer_finalize ();\n-    }\n-\n   /* ASSERT_EXPRs must be removed before finalizing jump threads\n      as finalizing jump threads calls the CFG cleanup code which\n      does not properly handle ASSERT_EXPRs.  */\n@@ -6019,6 +6010,12 @@ execute_vrp (void)\n   update_ssa (TODO_update_ssa);\n \n   finalize_jump_threads ();\n+  if (current_loops)\n+    {\n+      scev_finalize ();\n+      loop_optimizer_finalize ();\n+    }\n+\n   return 0;\n }\n "}]}