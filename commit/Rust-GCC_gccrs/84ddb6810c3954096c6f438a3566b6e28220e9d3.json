{"sha": "84ddb6810c3954096c6f438a3566b6e28220e9d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRkZGI2ODEwYzM5NTQwOTZjNmY0MzhhMzU2NmI2ZTI4MjIwZTlkMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-06-19T18:19:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-06-19T18:19:16Z"}, "message": "Use synth_mult for vector multiplies vs scalar constant\n\nFrom-SVN: r188786", "tree": {"sha": "8ebeb7ca05a791fbd1e88e45010bd6c59f97b95b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ebeb7ca05a791fbd1e88e45010bd6c59f97b95b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84ddb6810c3954096c6f438a3566b6e28220e9d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ddb6810c3954096c6f438a3566b6e28220e9d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84ddb6810c3954096c6f438a3566b6e28220e9d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ddb6810c3954096c6f438a3566b6e28220e9d3/comments", "author": null, "committer": null, "parents": [{"sha": "6bc0ff89a187517f1b11669f7065945395eeafdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc0ff89a187517f1b11669f7065945395eeafdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc0ff89a187517f1b11669f7065945395eeafdd"}], "stats": {"total": 460, "additions": 262, "deletions": 198}, "files": [{"sha": "0aed15f86e21f5287918ff3cb5f41b9ea988621a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ddb6810c3954096c6f438a3566b6e28220e9d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ddb6810c3954096c6f438a3566b6e28220e9d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84ddb6810c3954096c6f438a3566b6e28220e9d3", "patch": "@@ -1,3 +1,14 @@\n+2012-06-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* expmed.c (struct init_expmed_rtl): Split ...\n+\t(init_expmed_one_mode): ... out of ...\n+\t(init_expmed): ... here.  Initialize integer vector modes also.\n+\t(synth_mult): Handle integer vector modes.\n+\t(choose_mult_variant): Likewise.\n+\t(expand_mult_const): Likewise.\n+\t(expand_mult): Likewise.\n+\t* machmode.h (GET_MODE_UNIT_BITSIZE): New.\n+\n 2012-06-19  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_rtx_costs): Handle CONST_VECTOR, and"}, {"sha": "989f86cbe7ae6c96625ee2904506a836c6b4af21", "filename": "gcc/expmed.c", "status": "modified", "additions": 243, "deletions": 195, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ddb6810c3954096c6f438a3566b6e28220e9d3/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ddb6810c3954096c6f438a3566b6e28220e9d3/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=84ddb6810c3954096c6f438a3566b6e28220e9d3", "patch": "@@ -2,7 +2,7 @@\n    and shifts, multiplies and divides to rtl instructions.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011\n+   2011, 2012\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -93,43 +93,112 @@ static rtx expand_sdiv_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n #define gen_extzv(a,b,c,d) NULL_RTX\n #endif\n \n-void\n-init_expmed (void)\n+struct init_expmed_rtl\n {\n-  struct\n-  {\n-    struct rtx_def reg;\t\trtunion reg_fld[2];\n-    struct rtx_def plus;\trtunion plus_fld1;\n-    struct rtx_def neg;\n-    struct rtx_def mult;\trtunion mult_fld1;\n-    struct rtx_def sdiv;\trtunion sdiv_fld1;\n-    struct rtx_def udiv;\trtunion udiv_fld1;\n-    struct rtx_def zext;\n-    struct rtx_def sdiv_32;\trtunion sdiv_32_fld1;\n-    struct rtx_def smod_32;\trtunion smod_32_fld1;\n-    struct rtx_def wide_mult;\trtunion wide_mult_fld1;\n-    struct rtx_def wide_lshr;\trtunion wide_lshr_fld1;\n-    struct rtx_def wide_trunc;\n-    struct rtx_def shift;\trtunion shift_fld1;\n-    struct rtx_def shift_mult;\trtunion shift_mult_fld1;\n-    struct rtx_def shift_add;\trtunion shift_add_fld1;\n-    struct rtx_def shift_sub0;\trtunion shift_sub0_fld1;\n-    struct rtx_def shift_sub1;\trtunion shift_sub1_fld1;\n-  } all;\n+  struct rtx_def reg;\t\trtunion reg_fld[2];\n+  struct rtx_def plus;\trtunion plus_fld1;\n+  struct rtx_def neg;\n+  struct rtx_def mult;\trtunion mult_fld1;\n+  struct rtx_def sdiv;\trtunion sdiv_fld1;\n+  struct rtx_def udiv;\trtunion udiv_fld1;\n+  struct rtx_def zext;\n+  struct rtx_def sdiv_32;\trtunion sdiv_32_fld1;\n+  struct rtx_def smod_32;\trtunion smod_32_fld1;\n+  struct rtx_def wide_mult;\trtunion wide_mult_fld1;\n+  struct rtx_def wide_lshr;\trtunion wide_lshr_fld1;\n+  struct rtx_def wide_trunc;\n+  struct rtx_def shift;\trtunion shift_fld1;\n+  struct rtx_def shift_mult;\trtunion shift_mult_fld1;\n+  struct rtx_def shift_add;\trtunion shift_add_fld1;\n+  struct rtx_def shift_sub0;\trtunion shift_sub0_fld1;\n+  struct rtx_def shift_sub1;\trtunion shift_sub1_fld1;\n \n   rtx pow2[MAX_BITS_PER_WORD];\n   rtx cint[MAX_BITS_PER_WORD];\n-  int m, n;\n-  enum machine_mode mode, wider_mode;\n-  int speed;\n+};\n+\n+static void\n+init_expmed_one_mode (struct init_expmed_rtl *all,\n+\t\t      enum machine_mode mode, int speed)\n+{\n+  int m, n, mode_bitsize;\n+\n+  mode_bitsize = GET_MODE_UNIT_BITSIZE (mode);\n+\n+  PUT_MODE (&all->reg, mode);\n+  PUT_MODE (&all->plus, mode);\n+  PUT_MODE (&all->neg, mode);\n+  PUT_MODE (&all->mult, mode);\n+  PUT_MODE (&all->sdiv, mode);\n+  PUT_MODE (&all->udiv, mode);\n+  PUT_MODE (&all->sdiv_32, mode);\n+  PUT_MODE (&all->smod_32, mode);\n+  PUT_MODE (&all->wide_trunc, mode);\n+  PUT_MODE (&all->shift, mode);\n+  PUT_MODE (&all->shift_mult, mode);\n+  PUT_MODE (&all->shift_add, mode);\n+  PUT_MODE (&all->shift_sub0, mode);\n+  PUT_MODE (&all->shift_sub1, mode);\n+\n+  add_cost[speed][mode] = set_src_cost (&all->plus, speed);\n+  neg_cost[speed][mode] = set_src_cost (&all->neg, speed);\n+  mul_cost[speed][mode] = set_src_cost (&all->mult, speed);\n+  sdiv_cost[speed][mode] = set_src_cost (&all->sdiv, speed);\n+  udiv_cost[speed][mode] = set_src_cost (&all->udiv, speed);\n+\n+  sdiv_pow2_cheap[speed][mode] = (set_src_cost (&all->sdiv_32, speed)\n+\t\t\t          <= 2 * add_cost[speed][mode]);\n+  smod_pow2_cheap[speed][mode] = (set_src_cost (&all->smod_32, speed)\n+\t\t\t          <= 4 * add_cost[speed][mode]);\n+\n+  shift_cost[speed][mode][0] = 0;\n+  shiftadd_cost[speed][mode][0] = shiftsub0_cost[speed][mode][0]\n+    = shiftsub1_cost[speed][mode][0] = add_cost[speed][mode];\n+\n+  n = MIN (MAX_BITS_PER_WORD, mode_bitsize);\n+  for (m = 1; m < n; m++)\n+    {\n+      XEXP (&all->shift, 1) = all->cint[m];\n+      XEXP (&all->shift_mult, 1) = all->pow2[m];\n \n+      shift_cost[speed][mode][m] = set_src_cost (&all->shift, speed);\n+      shiftadd_cost[speed][mode][m] = set_src_cost (&all->shift_add, speed);\n+      shiftsub0_cost[speed][mode][m] = set_src_cost (&all->shift_sub0, speed);\n+      shiftsub1_cost[speed][mode][m] = set_src_cost (&all->shift_sub1, speed);\n+    }\n \n-  for (m = 1; m < MAX_BITS_PER_WORD; m++)\n+  if (SCALAR_INT_MODE_P (mode))\n     {\n-      pow2[m] = GEN_INT ((HOST_WIDE_INT) 1 << m);\n-      cint[m] = GEN_INT (m);\n+      enum machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n+\n+      if (wider_mode != VOIDmode)\n+\t{\n+\t  PUT_MODE (&all->zext, wider_mode);\n+\t  PUT_MODE (&all->wide_mult, wider_mode);\n+\t  PUT_MODE (&all->wide_lshr, wider_mode);\n+\t  XEXP (&all->wide_lshr, 1) = GEN_INT (mode_bitsize);\n+\n+\t  mul_widen_cost[speed][wider_mode]\n+\t    = set_src_cost (&all->wide_mult, speed);\n+\t  mul_highpart_cost[speed][mode]\n+\t    = set_src_cost (&all->wide_trunc, speed);\n+\t}\n     }\n+}\n+\n+void\n+init_expmed (void)\n+{\n+  struct init_expmed_rtl all;\n+  enum machine_mode mode;\n+  int m, speed;\n+\n   memset (&all, 0, sizeof all);\n+  for (m = 1; m < MAX_BITS_PER_WORD; m++)\n+    {\n+      all.pow2[m] = GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      all.cint[m] = GEN_INT (m);\n+    }\n \n   PUT_CODE (&all.reg, REG);\n   /* Avoid using hard regs in ways which may be unsupported.  */\n@@ -156,7 +225,7 @@ init_expmed (void)\n \n   PUT_CODE (&all.sdiv_32, DIV);\n   XEXP (&all.sdiv_32, 0) = &all.reg;\n-  XEXP (&all.sdiv_32, 1) = 32 < MAX_BITS_PER_WORD ? cint[32] : GEN_INT (32);\n+  XEXP (&all.sdiv_32, 1) = 32 < MAX_BITS_PER_WORD ? all.cint[32] : GEN_INT (32);\n \n   PUT_CODE (&all.smod_32, MOD);\n   XEXP (&all.smod_32, 0) = &all.reg;\n@@ -201,67 +270,14 @@ init_expmed (void)\n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   mode != VOIDmode;\n \t   mode = GET_MODE_WIDER_MODE (mode))\n-\t{\n-\t  PUT_MODE (&all.reg, mode);\n-\t  PUT_MODE (&all.plus, mode);\n-\t  PUT_MODE (&all.neg, mode);\n-\t  PUT_MODE (&all.mult, mode);\n-\t  PUT_MODE (&all.sdiv, mode);\n-\t  PUT_MODE (&all.udiv, mode);\n-\t  PUT_MODE (&all.sdiv_32, mode);\n-\t  PUT_MODE (&all.smod_32, mode);\n-\t  PUT_MODE (&all.wide_trunc, mode);\n-\t  PUT_MODE (&all.shift, mode);\n-\t  PUT_MODE (&all.shift_mult, mode);\n-\t  PUT_MODE (&all.shift_add, mode);\n-\t  PUT_MODE (&all.shift_sub0, mode);\n-\t  PUT_MODE (&all.shift_sub1, mode);\n-\n-\t  add_cost[speed][mode] = set_src_cost (&all.plus, speed);\n-\t  neg_cost[speed][mode] = set_src_cost (&all.neg, speed);\n-\t  mul_cost[speed][mode] = set_src_cost (&all.mult, speed);\n-\t  sdiv_cost[speed][mode] = set_src_cost (&all.sdiv, speed);\n-\t  udiv_cost[speed][mode] = set_src_cost (&all.udiv, speed);\n-\n-\t  sdiv_pow2_cheap[speed][mode] = (set_src_cost (&all.sdiv_32, speed)\n-\t\t\t\t          <= 2 * add_cost[speed][mode]);\n-\t  smod_pow2_cheap[speed][mode] = (set_src_cost (&all.smod_32, speed)\n-\t\t\t\t          <= 4 * add_cost[speed][mode]);\n-\n-\t  wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t  if (wider_mode != VOIDmode)\n-\t    {\n-\t      PUT_MODE (&all.zext, wider_mode);\n-\t      PUT_MODE (&all.wide_mult, wider_mode);\n-\t      PUT_MODE (&all.wide_lshr, wider_mode);\n-\t      XEXP (&all.wide_lshr, 1) = GEN_INT (GET_MODE_BITSIZE (mode));\n-\n-\t      mul_widen_cost[speed][wider_mode]\n-\t        = set_src_cost (&all.wide_mult, speed);\n-\t      mul_highpart_cost[speed][mode]\n-\t        = set_src_cost (&all.wide_trunc, speed);\n-\t    }\n-\n-\t  shift_cost[speed][mode][0] = 0;\n-\t  shiftadd_cost[speed][mode][0] = shiftsub0_cost[speed][mode][0]\n-\t    = shiftsub1_cost[speed][mode][0] = add_cost[speed][mode];\n+\tinit_expmed_one_mode (&all, mode, speed);\n \n-\t  n = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n-\t  for (m = 1; m < n; m++)\n-\t    {\n-\t      XEXP (&all.shift, 1) = cint[m];\n-\t      XEXP (&all.shift_mult, 1) = pow2[m];\n-\n-\t      shift_cost[speed][mode][m] = set_src_cost (&all.shift, speed);\n-\t      shiftadd_cost[speed][mode][m] = set_src_cost (&all.shift_add,\n-\t\t\t\t\t\t\t    speed);\n-\t      shiftsub0_cost[speed][mode][m] = set_src_cost (&all.shift_sub0,\n-\t\t\t\t\t\t\t     speed);\n-\t      shiftsub1_cost[speed][mode][m] = set_src_cost (&all.shift_sub1,\n-\t\t\t\t\t\t\t     speed);\n-\t    }\n-\t}\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n+\t   mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\tinit_expmed_one_mode (&all, mode, speed);\n     }\n+\n   if (alg_hash_used_p)\n     memset (alg_hash, 0, sizeof (alg_hash));\n   else\n@@ -2385,11 +2401,11 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   int op_cost, op_latency;\n   unsigned HOST_WIDE_INT orig_t = t;\n   unsigned HOST_WIDE_INT q;\n-  int maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n-  int hash_index;\n+  int maxm, hash_index;\n   bool cache_hit = false;\n   enum alg_code cache_alg = alg_zero;\n   bool speed = optimize_insn_for_speed_p ();\n+  enum machine_mode imode;\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n      is found, this value will be returned and indicate failure.  */\n@@ -2400,8 +2416,15 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       || (cost_limit->cost == 0 && cost_limit->latency <= 0))\n     return;\n \n+  /* Be prepared for vector modes.  */\n+  imode = GET_MODE_INNER (mode);\n+  if (imode == VOIDmode)\n+    imode = mode;\n+\n+  maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (imode));\n+\n   /* Restrict the bits of \"t\" to the multiplication's mode.  */\n-  t &= GET_MODE_MASK (mode);\n+  t &= GET_MODE_MASK (imode);\n \n   /* t == 1 can be done in zero cost.  */\n   if (t == 1)\n@@ -2632,7 +2655,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  op_cost = shiftsub1_cost[speed][mode][m];\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n-\t  synth_mult (alg_in, (unsigned HOST_WIDE_INT) (-orig_t + 1) >> m, &new_limit, mode);\n+\t  synth_mult (alg_in, (unsigned HOST_WIDE_INT) (-orig_t + 1) >> m,\n+\t\t      &new_limit, mode);\n \n \t  alg_in->cost.cost += op_cost;\n \t  alg_in->cost.latency += op_cost;\n@@ -2871,7 +2895,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n   /* Ensure that mult_cost provides a reasonable upper bound.\n      Any constant multiplication can be performed with less\n      than 2 * bits additions.  */\n-  op_cost = 2 * GET_MODE_BITSIZE (mode) * add_cost[speed][mode];\n+  op_cost = 2 * GET_MODE_UNIT_BITSIZE (mode) * add_cost[speed][mode];\n   if (mult_cost > op_cost)\n     mult_cost = op_cost;\n \n@@ -2882,7 +2906,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n \n   /* This works only if the inverted value actually fits in an\n      `unsigned int' */\n-  if (HOST_BITS_PER_INT >= GET_MODE_BITSIZE (mode))\n+  if (HOST_BITS_PER_INT >= GET_MODE_UNIT_BITSIZE (mode))\n     {\n       op_cost = neg_cost[speed][mode];\n       if (MULT_COST_LESS (&alg->cost, mult_cost))\n@@ -2949,7 +2973,7 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \n   if (alg->op[0] == alg_zero)\n     {\n-      accum = copy_to_mode_reg (mode, const0_rtx);\n+      accum = copy_to_mode_reg (mode, CONST0_RTX (mode));\n       val_so_far = 0;\n     }\n   else if (alg->op[0] == alg_m)\n@@ -3029,24 +3053,25 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \t  gcc_unreachable ();\n \t}\n \n-      /* Write a REG_EQUAL note on the last insn so that we can cse\n-\t multiplication sequences.  Note that if ACCUM is a SUBREG,\n-\t we've set the inner register and must properly indicate\n-\t that.  */\n-\n-      tem = op0, nmode = mode;\n-      accum_inner = accum;\n-      if (GET_CODE (accum) == SUBREG)\n+      if (SCALAR_INT_MODE_P (mode))\n \t{\n-\t  accum_inner = SUBREG_REG (accum);\n-\t  nmode = GET_MODE (accum_inner);\n-\t  tem = gen_lowpart (nmode, op0);\n-\t}\n+\t  /* Write a REG_EQUAL note on the last insn so that we can cse\n+\t     multiplication sequences.  Note that if ACCUM is a SUBREG,\n+\t     we've set the inner register and must properly indicate that.  */\n+          tem = op0, nmode = mode;\n+          accum_inner = accum;\n+          if (GET_CODE (accum) == SUBREG)\n+\t    {\n+\t      accum_inner = SUBREG_REG (accum);\n+\t      nmode = GET_MODE (accum_inner);\n+\t      tem = gen_lowpart (nmode, op0);\n+\t    }\n \n-      insn = get_last_insn ();\n-      set_dst_reg_note (insn, REG_EQUAL,\n-\t\t\tgen_rtx_MULT (nmode, tem, GEN_INT (val_so_far)),\n-\t\t\taccum_inner);\n+          insn = get_last_insn ();\n+          set_dst_reg_note (insn, REG_EQUAL,\n+\t\t\t    gen_rtx_MULT (nmode, tem, GEN_INT (val_so_far)),\n+\t\t\t    accum_inner);\n+\t}\n     }\n \n   if (variant == negate_variant)\n@@ -3062,8 +3087,11 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \n   /* Compare only the bits of val and val_so_far that are significant\n      in the result mode, to avoid sign-/zero-extension confusion.  */\n-  val &= GET_MODE_MASK (mode);\n-  val_so_far &= GET_MODE_MASK (mode);\n+  nmode = GET_MODE_INNER (mode);\n+  if (nmode == VOIDmode)\n+    nmode = mode;\n+  val &= GET_MODE_MASK (nmode);\n+  val_so_far &= GET_MODE_MASK (nmode);\n   gcc_assert (val == val_so_far);\n \n   return accum;\n@@ -3083,29 +3111,51 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n {\n   enum mult_variant variant;\n   struct algorithm algorithm;\n+  rtx scalar_op1;\n   int max_cost;\n   bool speed = optimize_insn_for_speed_p ();\n+  bool do_trapv = flag_trapv && SCALAR_INT_MODE_P (mode) && !unsignedp;\n \n-  /* Handling const0_rtx here allows us to use zero as a rogue value for\n-     coeff below.  */\n-  if (op1 == const0_rtx)\n-    return const0_rtx;\n-  if (op1 == const1_rtx)\n-    return op0;\n-  if (op1 == constm1_rtx)\n-    return expand_unop (mode,\n-\t\t\tGET_MODE_CLASS (mode) == MODE_INT\n-\t\t\t&& !unsignedp && flag_trapv\n-\t\t\t? negv_optab : neg_optab,\n-\t\t\top0, target, 0);\n-\n-  /* These are the operations that are potentially turned into a sequence\n-     of shifts and additions.  */\n-  if (SCALAR_INT_MODE_P (mode)\n-      && (unsignedp || !flag_trapv))\n+  if (CONSTANT_P (op0))\n     {\n-      HOST_WIDE_INT coeff = 0;\n-      rtx fake_reg = gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1);\n+      rtx temp = op0;\n+      op0 = op1;\n+      op1 = temp;\n+    }\n+\n+  /* For vectors, there are several simplifications that can be made if\n+     all elements of the vector constant are identical.  */\n+  scalar_op1 = op1;\n+  if (GET_CODE (op1) == CONST_VECTOR)\n+    {\n+      int i, n = CONST_VECTOR_NUNITS (op1);\n+      scalar_op1 = CONST_VECTOR_ELT (op1, 0);\n+      for (i = 1; i < n; ++i)\n+\tif (!rtx_equal_p (scalar_op1, CONST_VECTOR_ELT (op1, i)))\n+\t  goto skip_scalar;\n+    }\n+\n+  if (INTEGRAL_MODE_P (mode))\n+    {\n+      rtx fake_reg;\n+      HOST_WIDE_INT coeff;\n+      bool is_neg;\n+      int mode_bitsize;\n+\n+      if (op1 == CONST0_RTX (mode))\n+\treturn op1;\n+      if (op1 == CONST1_RTX (mode))\n+\treturn op0;\n+      if (op1 == CONSTM1_RTX (mode))\n+\treturn expand_unop (mode, do_trapv ? negv_optab : neg_optab,\n+\t\t\t    op0, target, 0);\n+\n+      if (do_trapv)\n+\tgoto skip_synth;\n+\n+      /* These are the operations that are potentially turned into\n+\t a sequence of shifts and additions.  */\n+      mode_bitsize = GET_MODE_UNIT_BITSIZE (mode);\n \n       /* synth_mult does an `unsigned int' multiply.  As long as the mode is\n \t less than or equal in size to `unsigned int' this doesn't matter.\n@@ -3114,86 +3164,86 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t any truncation.  This means that multiplying by negative values does\n \t not work; results are off by 2^32 on a 32 bit machine.  */\n \n-      if (CONST_INT_P (op1))\n+      if (CONST_INT_P (scalar_op1))\n \t{\n-\t  /* Attempt to handle multiplication of DImode values by negative\n-\t     coefficients, by performing the multiplication by a positive\n-\t     multiplier and then inverting the result.  */\n-\t  if (INTVAL (op1) < 0\n-\t      && GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n-\t    {\n-\t      /* Its safe to use -INTVAL (op1) even for INT_MIN, as the\n-\t\t result is interpreted as an unsigned coefficient.\n-\t\t Exclude cost of op0 from max_cost to match the cost\n-\t\t calculation of the synth_mult.  */\n-\t      max_cost = (set_src_cost (gen_rtx_MULT (mode, fake_reg, op1),\n-\t\t\t\t\tspeed)\n-\t\t\t  - neg_cost[speed][mode]);\n-\t      if (max_cost > 0\n-\t\t  && choose_mult_variant (mode, -INTVAL (op1), &algorithm,\n-\t\t\t\t\t  &variant, max_cost))\n-\t\t{\n-\t\t  rtx temp = expand_mult_const (mode, op0, -INTVAL (op1),\n-\t\t\t\t\t\tNULL_RTX, &algorithm,\n-\t\t\t\t\t\tvariant);\n-\t\t  return expand_unop (mode, neg_optab, temp, target, 0);\n-\t\t}\n-\t    }\n-\t  else coeff = INTVAL (op1);\n+\t  coeff = INTVAL (scalar_op1);\n+\t  is_neg = coeff < 0;\n \t}\n-      else if (GET_CODE (op1) == CONST_DOUBLE)\n+      else if (CONST_DOUBLE_P (scalar_op1))\n \t{\n \t  /* If we are multiplying in DImode, it may still be a win\n \t     to try to work with shifts and adds.  */\n-\t  if (CONST_DOUBLE_HIGH (op1) == 0\n-\t      && CONST_DOUBLE_LOW (op1) > 0)\n-\t    coeff = CONST_DOUBLE_LOW (op1);\n-\t  else if (CONST_DOUBLE_LOW (op1) == 0\n-\t\t   && EXACT_POWER_OF_2_OR_ZERO_P (CONST_DOUBLE_HIGH (op1)))\n+\t  if (CONST_DOUBLE_HIGH (scalar_op1) == 0\n+\t      && CONST_DOUBLE_LOW (scalar_op1) > 0)\n \t    {\n-\t      int shift = floor_log2 (CONST_DOUBLE_HIGH (op1))\n-\t\t\t  + HOST_BITS_PER_WIDE_INT;\n-\t      if (shift < HOST_BITS_PER_DOUBLE_INT - 1\n-\t\t  || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_DOUBLE_INT)\n-\t\treturn expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t     shift, target, unsignedp);\n+\t      coeff = CONST_DOUBLE_LOW (scalar_op1);\n+\t      is_neg = false;\n+\t    }\n+\t  else if (CONST_DOUBLE_LOW (scalar_op1) == 0)\n+\t    {\n+\t      coeff = CONST_DOUBLE_HIGH (scalar_op1);\n+\t      if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))\n+\t\t{\n+\t\t  int shift = floor_log2 (coeff) + HOST_BITS_PER_WIDE_INT;\n+\t\t  if (shift < HOST_BITS_PER_DOUBLE_INT - 1\n+\t\t      || mode_bitsize <= HOST_BITS_PER_DOUBLE_INT)\n+\t\t    return expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t\t shift, target, unsignedp);\n+\t\t}\n+\t      goto skip_synth;\n \t    }\n \t}\n+      else\n+\tgoto skip_synth;\n \n       /* We used to test optimize here, on the grounds that it's better to\n \t produce a smaller program when -O is not used.  But this causes\n \t such a terrible slowdown sometimes that it seems better to always\n \t use synth_mult.  */\n-      if (coeff != 0)\n-\t{\n-\t  /* Special case powers of two.  */\n-\t  if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))\n-\t    return expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t floor_log2 (coeff), target, unsignedp);\n \n-\t  /* Exclude cost of op0 from max_cost to match the cost\n+      /* Special case powers of two.  */\n+      if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))\n+\treturn expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t     floor_log2 (coeff), target, unsignedp);\n+\n+      fake_reg = gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1);\n+\n+      /* Attempt to handle multiplication of DImode values by negative\n+\t coefficients, by performing the multiplication by a positive\n+\t multiplier and then inverting the result.  */\n+      /* ??? How is this not slightly redundant with the neg variant?  */\n+      if (is_neg && mode_bitsize > HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  /* Its safe to use -coeff even for INT_MIN, as the\n+\t     result is interpreted as an unsigned coefficient.\n+\t     Exclude cost of op0 from max_cost to match the cost\n \t     calculation of the synth_mult.  */\n-\t  max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed);\n-\t  if (choose_mult_variant (mode, coeff, &algorithm, &variant,\n-\t\t\t\t   max_cost))\n-\t    return expand_mult_const (mode, op0, coeff, target,\n-\t\t\t\t      &algorithm, variant);\n+\t  max_cost = (set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed)\n+\t\t      - neg_cost[speed][mode]);\n+\t  if (max_cost > 0\n+\t      && choose_mult_variant (mode, -coeff, &algorithm,\n+\t\t\t\t      &variant, max_cost))\n+\t    {\n+\t      rtx temp = expand_mult_const (mode, op0, -coeff, NULL_RTX,\n+\t\t\t\t\t    &algorithm, variant);\n+\t      return expand_unop (mode, neg_optab, temp, target, 0);\n+\t    }\n \t}\n-    }\n \n-  if (GET_CODE (op0) == CONST_DOUBLE)\n-    {\n-      rtx temp = op0;\n-      op0 = op1;\n-      op1 = temp;\n+      /* Exclude cost of op0 from max_cost to match the cost\n+\t calculation of the synth_mult.  */\n+      max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed);\n+      if (choose_mult_variant (mode, coeff, &algorithm, &variant, max_cost))\n+\treturn expand_mult_const (mode, op0, coeff, target,\n+\t\t\t\t  &algorithm, variant);\n     }\n+ skip_synth:\n \n   /* Expand x*2.0 as x+x.  */\n-  if (GET_CODE (op1) == CONST_DOUBLE\n-      && SCALAR_FLOAT_MODE_P (mode))\n+  if (GET_CODE (scalar_op1) == CONST_DOUBLE && FLOAT_MODE_P (mode))\n     {\n       REAL_VALUE_TYPE d;\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op1);\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, scalar_op1);\n \n       if (REAL_VALUES_EQUAL (d, dconst2))\n \t{\n@@ -3202,13 +3252,11 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t\t       target, unsignedp, OPTAB_LIB_WIDEN);\n \t}\n     }\n+ skip_scalar:\n \n   /* This used to use umul_optab if unsigned, but for non-widening multiply\n      there is no difference between signed and unsigned.  */\n-  op0 = expand_binop (mode,\n-\t\t      ! unsignedp\n-\t\t      && flag_trapv && (GET_MODE_CLASS(mode) == MODE_INT)\n-\t\t      ? smulv_optab : smul_optab,\n+  op0 = expand_binop (mode, do_trapv ? smulv_optab : smul_optab,\n \t\t      op0, op1, target, unsignedp, OPTAB_LIB_WIDEN);\n   gcc_assert (op0);\n   return op0;"}, {"sha": "bdaf1bee2747405db6086084f6868186615866b8", "filename": "gcc/machmode.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ddb6810c3954096c6f438a3566b6e28220e9d3/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ddb6810c3954096c6f438a3566b6e28220e9d3/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=84ddb6810c3954096c6f438a3566b6e28220e9d3", "patch": "@@ -1,6 +1,6 @@\n /* Machine mode definitions for GCC; included by rtl.h and tree.h.\n    Copyright (C) 1991, 1993, 1994, 1996, 1998, 1999, 2000, 2001, 2003,\n-   2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   2007, 2008, 2009, 2010, 2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -179,7 +179,8 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n \n extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];\n #define GET_MODE_SIZE(MODE)    ((unsigned short) mode_size[MODE])\n-#define GET_MODE_BITSIZE(MODE) ((unsigned short) (GET_MODE_SIZE (MODE) * BITS_PER_UNIT))\n+#define GET_MODE_BITSIZE(MODE) \\\n+  ((unsigned short) (GET_MODE_SIZE (MODE) * BITS_PER_UNIT))\n \n /* Get the number of value bits of an object of mode MODE.  */\n extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n@@ -205,13 +206,17 @@ extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n #define GET_MODE_INNER(MODE) ((enum machine_mode) mode_inner[MODE])\n \n-/* Get the size in bytes of the basic parts of an object of mode MODE.  */\n+/* Get the size in bytes or bites of the basic parts of an\n+   object of mode MODE.  */\n \n #define GET_MODE_UNIT_SIZE(MODE)\t\t\\\n   (GET_MODE_INNER (MODE) == VOIDmode\t\t\\\n    ? GET_MODE_SIZE (MODE)\t\t\t\\\n    : GET_MODE_SIZE (GET_MODE_INNER (MODE)))\n \n+#define GET_MODE_UNIT_BITSIZE(MODE) \\\n+  ((unsigned short) (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT))\n+\n /* Get the number of units in the object.  */\n \n extern const unsigned char mode_nunits[NUM_MACHINE_MODES];"}]}