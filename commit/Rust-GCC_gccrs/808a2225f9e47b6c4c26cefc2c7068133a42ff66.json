{"sha": "808a2225f9e47b6c4c26cefc2c7068133a42ff66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA4YTIyMjVmOWU0N2I2YzRjMjZjZWZjMmM3MDY4MTMzYTQyZmY2Ng==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-10-04T15:57:28Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-10-04T15:57:28Z"}, "message": "re PR libfortran/33253 (namelist: reading back a string with apostrophe)\n\n2007-10-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/33253\n\t* io/list_read.c (read_character): Use line_buffer to scan ahead for\n\tobject name or string when no delimiter is found.\n\nFrom-SVN: r129016", "tree": {"sha": "359610196bbde0430e898172cb9d1b058fe4fee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/359610196bbde0430e898172cb9d1b058fe4fee6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/808a2225f9e47b6c4c26cefc2c7068133a42ff66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808a2225f9e47b6c4c26cefc2c7068133a42ff66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/808a2225f9e47b6c4c26cefc2c7068133a42ff66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808a2225f9e47b6c4c26cefc2c7068133a42ff66/comments", "author": null, "committer": null, "parents": [{"sha": "d17cd69f66c1c0cb10074efa10252deea1ad260e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17cd69f66c1c0cb10074efa10252deea1ad260e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17cd69f66c1c0cb10074efa10252deea1ad260e"}], "stats": {"total": 61, "additions": 55, "deletions": 6}, "files": [{"sha": "8e4140eb065c84f046f014a8ed9e7ca6b12f2a35", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808a2225f9e47b6c4c26cefc2c7068133a42ff66/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808a2225f9e47b6c4c26cefc2c7068133a42ff66/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=808a2225f9e47b6c4c26cefc2c7068133a42ff66", "patch": "@@ -1,3 +1,11 @@\n+<<<<<<< .mine\n+2007-10-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/33253\n+\t* io/list_read.c (read_character): Use line_buffer to scan ahead for\n+\tobject name or string when no delimiter is found.\n+\n+=======\n 2007-10-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR libfortran/32021\n@@ -10,6 +18,7 @@\n \tfpu_precision, sighup, sigint, allocate_init_flag and\n \tallocate_init_value.\n \n+>>>>>>> .r129015\n 2007-10-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/33253"}, {"sha": "88b83443bbd62afa6af4ceba4798c51e0a0b90f4", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808a2225f9e47b6c4c26cefc2c7068133a42ff66/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808a2225f9e47b6c4c26cefc2c7068133a42ff66/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=808a2225f9e47b6c4c26cefc2c7068133a42ff66", "patch": "@@ -893,14 +893,53 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n       goto get_string;\n \n     default:\n-      if (dtp->u.p.namelist_mode\n-\t  && (dtp->u.p.current_unit->flags.delim == DELIM_APOSTROPHE\n-\t      || dtp->u.p.current_unit->flags.delim == DELIM_QUOTE\n-\t      || quote == ' '))\n+      if (dtp->u.p.namelist_mode)\n \t{\n-\t  unget_char (dtp,c);\n-\t  return;\n+\t  if (dtp->u.p.current_unit->flags.delim == DELIM_APOSTROPHE\n+\t      || dtp->u.p.current_unit->flags.delim == DELIM_QUOTE)\n+\t    {\n+\t      unget_char (dtp, c);\n+\t      return;\n+\t    }\n+\n+\t  /* Check to see if we are seeing a namelist object name by using the\n+\t     line buffer and looking ahead for an '=' or '('.  */\n+\t  l_push_char (dtp, c);\n+\n+\t  int i;\n+\t  for(i = 0; i < 63; i++)\n+\t    {\n+\t      c = next_char (dtp);\n+\t      if (is_separator(c))\n+\t\t{\n+\t\t  unget_char (dtp, c);\n+\t\t  eat_separator (dtp);\n+\t\t  c = next_char (dtp);\n+\t\t  if (c != '=')\n+\t\t    {\n+\t\t      l_push_char (dtp, c);\n+\t\t      dtp->u.p.item_count = 0;\n+\t\t      dtp->u.p.line_buffer_enabled = 1;\n+\t\t      goto get_string;\n+\t\t    }\n+\t\t}\n+ \n+\t      l_push_char (dtp, c);\n+\t      if (c == '=' || c == '(')\n+\t\t{\n+\t\t  dtp->u.p.item_count = 0;\n+\t\t  dtp->u.p.nml_read_error = 1;\n+\t\t  dtp->u.p.line_buffer_enabled = 1;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\n+\t  /* The string is too long to be a valid object name so assume that it\n+\t     is a string to be read in as a value.  */\n+\t  dtp->u.p.line_buffer_enabled = 1;\n+\t  goto get_string;\n \t}\n+\n       push_char (dtp, c);\n       goto get_string;\n     }\n@@ -1007,6 +1046,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n       unget_char (dtp, c);\n       eat_separator (dtp);\n       dtp->u.p.saved_type = BT_CHARACTER;\n+      free_line (dtp);\n     }\n   else\n     {"}]}