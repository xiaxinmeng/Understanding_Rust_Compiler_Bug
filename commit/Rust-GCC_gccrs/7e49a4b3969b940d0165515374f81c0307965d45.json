{"sha": "7e49a4b3969b940d0165515374f81c0307965d45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0OWE0YjM5NjliOTQwZDAxNjU1MTUzNzRmODFjMDMwNzk2NWQ0NQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2009-08-28T09:04:52Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2009-08-28T09:04:52Z"}, "message": "collect2.c (DO_COLLECT_EXPORT_LIST): New internal macro, always defined.\n\n\n        * collect2.c (DO_COLLECT_EXPORT_LIST): New internal macro,\n        always defined.  Reflect definition or absence of such for\n        COLLECT_EXPORT_LIST.  Readability helper.\n        (scanfilter): New enum, to help control what symbols\n        are to be considered or ignored by scan_prog_file.\n        (enum pass): Rename as \"scanpass\", moved together with scanfilter\n        prior to scan_prog_file's prototype.\n        (scan_prog_file): Accept and honor scanpass and scanfilter arguments.\n        Group prototype with the scanpass/scanfilter definitions, factorize\n        head comments for the several implementations at the prototype.\n        (main): Reorganize the first pass link control to let AIX\n        drag only the needed frame tables in executables.  Prevent\n        frame tables collection during the scan aimed at static ctors.\n        Pre-link and scan for frame tables later to compensate.\n        * doc/tm.texi (ASM_OUTPUT_DWARF_TABLE_REF): New macro.\n        A C statement to issue assembly directives that create a reference\n        to the given DWARF table identifier label from the current function\n        section.\n        * dwarf2out.c (switch_to_eh_frame_section): Add a BACK argument\n        to differentiate first time section entry.  Only emit a .data\n        tables start identifier label the first time around.\n        (switch_to_frame_table_section): New function.  Helper for\n        output_call_frame_info to switch possibly BACK into the eh_frame\n        or the debug_frame section depending on FOR_EH.\n        (output_call_frame_info): Use helper to first enter the proper\n        frame section.\n        (output_fde): Use ASM_OUTPUT_DWARF_TABLE_REF when defined to\n        emit a link to the frame table start label from each function\n        section.\n        * config/rs6000/rs6000.c (rs6000_aix_asm_output_dwarf_table_ref):\n        New function.  Implementation of ASM_OUTPUT_DWARF_TABLE_REF.\n        * config/rs6000/rs6000-protos.h: Declare it.\n        * config/rs6000/aix.h (ASM_OUTPUT_DWARF_TABLE_REF): Define.\n\nFrom-SVN: r151157", "tree": {"sha": "3e42ebb98788d56f06fc541c25397579d2c0909d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e42ebb98788d56f06fc541c25397579d2c0909d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e49a4b3969b940d0165515374f81c0307965d45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e49a4b3969b940d0165515374f81c0307965d45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e49a4b3969b940d0165515374f81c0307965d45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e49a4b3969b940d0165515374f81c0307965d45/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72129a2509b0f79a94bcc96392f33228813e8bb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72129a2509b0f79a94bcc96392f33228813e8bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72129a2509b0f79a94bcc96392f33228813e8bb2"}], "stats": {"total": 351, "additions": 260, "deletions": 91}, "files": [{"sha": "c53d9c8ef8232dd5dc2b3162aefed64a50ded064", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e49a4b3969b940d0165515374f81c0307965d45", "patch": "@@ -1,3 +1,39 @@\n+2009-08-28  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* collect2.c (DO_COLLECT_EXPORT_LIST): New internal macro,\n+\talways defined.  Reflect definition or absence of such for\n+\tCOLLECT_EXPORT_LIST.  Readability helper.\n+\t(scanfilter): New enum, to help control what symbols\n+\tare to be considered or ignored by scan_prog_file.\n+\t(enum pass): Rename as \"scanpass\", moved together with scanfilter\n+\tprior to scan_prog_file's prototype.\n+\t(scan_prog_file): Accept and honor scanpass and scanfilter arguments.\n+\tGroup prototype with the scanpass/scanfilter definitions, factorize\n+\thead comments for the several implementations at the prototype.\n+\t(main): Reorganize the first pass link control to let AIX\n+\tdrag only the needed frame tables in executables.  Prevent\n+\tframe tables collection during the scan aimed at static ctors.\n+\tPre-link and scan for frame tables later to compensate.\n+\t* doc/tm.texi (ASM_OUTPUT_DWARF_TABLE_REF): New macro.\n+\tA C statement to issue assembly directives that create a reference\n+\tto the given DWARF table identifier label from the current function\n+\tsection.\n+\t* dwarf2out.c (switch_to_eh_frame_section): Add a BACK argument\n+\tto differentiate first time section entry.  Only emit a .data\n+\ttables start identifier label the first time around.\n+\t(switch_to_frame_table_section): New function.  Helper for\n+\toutput_call_frame_info to switch possibly BACK into the eh_frame\n+\tor the debug_frame section depending on FOR_EH.\n+\t(output_call_frame_info): Use helper to first enter the proper\n+\tframe section.\n+\t(output_fde): Use ASM_OUTPUT_DWARF_TABLE_REF when defined to\n+\temit a link to the frame table start label from each function\n+\tsection.\n+\t* config/rs6000/rs6000.c (rs6000_aix_asm_output_dwarf_table_ref):\n+\tNew function.  Implementation of ASM_OUTPUT_DWARF_TABLE_REF.\n+\t* config/rs6000/rs6000-protos.h: Declare it.\n+\t* config/rs6000/aix.h (ASM_OUTPUT_DWARF_TABLE_REF): Define.\n+\n 2009-08-27  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (split_branches): Check the result of"}, {"sha": "b235f2bda8435cd9d6facd0ec2b7c49ef1080546", "filename": "gcc/collect2.c", "status": "modified", "additions": 155, "deletions": 73, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=7e49a4b3969b940d0165515374f81c0307965d45", "patch": "@@ -145,6 +145,15 @@ int do_collecting = 1;\n int do_collecting = 0;\n #endif\n \n+/* Cook up an always defined indication of whether we proceed the\n+   \"EXPORT_LIST\" way.  */\n+\n+#ifdef COLLECT_EXPORT_LIST\n+#define DO_COLLECT_EXPORT_LIST 1\n+#else\n+#define DO_COLLECT_EXPORT_LIST 0\n+#endif\n+\n /* Nonzero if we should suppress the automatic demangling of identifiers\n    in linker error messages.  Set from COLLECT_NO_DEMANGLE.  */\n int no_demangle;\n@@ -165,15 +174,6 @@ struct head\n   int number;\n };\n \n-/* Enumeration giving which pass this is for scanning the program file.  */\n-\n-enum pass {\n-  PASS_FIRST,\t\t\t\t/* without constructors */\n-  PASS_OBJ,\t\t\t\t/* individual objects */\n-  PASS_LIB,\t\t\t\t/* looking for shared libraries */\n-  PASS_SECOND\t\t\t\t/* with constructors linked in */\n-};\n-\n int vflag;\t\t\t\t/* true if -v */\n static int rflag;\t\t\t/* true if -r */\n static int strip_flag;\t\t\t/* true if -s */\n@@ -288,7 +288,6 @@ static void write_c_file_stat (FILE *, const char *);\n #ifndef LD_INIT_SWITCH\n static void write_c_file_glob (FILE *, const char *);\n #endif\n-static void scan_prog_file (const char *, enum pass);\n #ifdef SCAN_LIBRARIES\n static void scan_libraries (const char *);\n #endif\n@@ -303,6 +302,50 @@ static void write_aix_file (FILE *, struct id *);\n static char *resolve_lib_name (const char *);\n #endif\n static char *extract_string (const char **);\n+\n+/* Enumerations describing which pass this is for scanning the\n+   program file ...  */\n+\n+typedef enum {\n+  PASS_FIRST,\t\t\t\t/* without constructors */\n+  PASS_OBJ,\t\t\t\t/* individual objects */\n+  PASS_LIB,\t\t\t\t/* looking for shared libraries */\n+  PASS_SECOND\t\t\t\t/* with constructors linked in */\n+} scanpass;\n+\n+/* ... and which kinds of symbols are to be considered.  */\n+\n+enum scanfilter_masks {\n+  SCAN_NOTHING = 0,\n+\n+  SCAN_CTOR = 1 << SYM_CTOR, \n+  SCAN_DTOR = 1 << SYM_DTOR,\n+  SCAN_INIT = 1 << SYM_INIT,\n+  SCAN_FINI = 1 << SYM_FINI,\n+  SCAN_DWEH = 1 << SYM_DWEH,\n+  SCAN_ALL  = ~0\n+};\n+\n+/* This type is used for parameters and variables which hold\n+   combinations of the flags in enum scanfilter_masks.  */\n+typedef int scanfilter;\n+\n+/* Scan the name list of the loaded program for the symbols g++ uses for\n+   static constructors and destructors.\n+\n+   The SCANPASS argument tells which collect processing pass this is for and\n+   the SCANFILTER argument tells which kinds of symbols to consider in this\n+   pass.  Symbols of a special kind not in the filter mask are considered as\n+   regular ones.\n+\n+   The constructor table begins at __CTOR_LIST__ and contains a count of the\n+   number of pointers (or -1 if the constructors are built in a separate\n+   section by the linker), followed by the pointers to the constructor\n+   functions, terminated with a null pointer.  The destructor table has the\n+   same format, and begins at __DTOR_LIST__.  */\n+\n+static void scan_prog_file (const char *, scanpass, scanfilter);\n+\n \f\n /* Delete tempfiles and exit function.  */\n \n@@ -831,6 +874,15 @@ main (int argc, char **argv)\n   const char **c_ptr;\n   char **ld1_argv;\n   const char **ld1;\n+  \n+  /* The kinds of symbols we will have to consider when scanning the\n+     outcome of a first pass link.  This is ALL to start with, then might\n+     be adjusted before getting to the first pass link per se, typically on\n+     AIX where we perform an early scan of objects and libraries to fetch\n+     the list of global ctors/dtors and make sure they are not garbage\n+     collected.  */\n+  scanfilter ld1_filter = SCAN_ALL;\n+\n   char **ld2_argv;\n   const char **ld2;\n   char **object_lst;\n@@ -1279,19 +1331,31 @@ main (int argc, char **argv)\n     }\n \n   /* The AIX linker will discard static constructors in object files if\n-     nothing else in the file is referenced, so look at them first.  */\n-  {\n-      const char **export_object_lst \n-\t= CONST_CAST2 (const char **, char **, object_lst);\n-\n-      while (export_object_lst < object)\n-\tscan_prog_file (*export_object_lst++, PASS_OBJ);\n-  }\n+     nothing else in the file is referenced, so look at them first.  Unless\n+     we are building a shared object, ignore the eh frame tables, as we\n+     would otherwise reference them all, hence drag all the corresponding\n+     objects even if nothing else is referenced.  */\n   {\n+    const char **export_object_lst \n+      = CONST_CAST2 (const char **, char **, object_lst);\n+    \n     struct id *list = libs.first;\n \n+    /* Compute the filter to use from the current one, do scan, then adjust\n+       the \"current\" filter to remove what we just included here.  This will\n+       control whether we need a first pass link later on or not, and what\n+       will remain to be scanned there.  */\n+    \n+    scanfilter this_filter\n+      = shared_obj ? ld1_filter : (ld1_filter & ~SCAN_DWEH);\n+    \n+    while (export_object_lst < object)\n+      scan_prog_file (*export_object_lst++, PASS_OBJ, this_filter);\n+    \n     for (; list; list = list->next)\n-      scan_prog_file (list->name, PASS_FIRST);\n+      scan_prog_file (list->name, PASS_FIRST, this_filter);\n+    \n+    ld1_filter = ld1_filter & ~this_filter;\n   }\n \n   if (exports.first)\n@@ -1362,42 +1426,45 @@ main (int argc, char **argv)\n     }\n \n   /* Load the program, searching all libraries and attempting to provide\n-     undefined symbols from repository information.  */\n-\n-  /* On AIX we do this later.  */\n-#ifndef COLLECT_EXPORT_LIST\n-  do_tlink (ld1_argv, object_lst);\n-#endif\n-\n-  /* If -r or they will be run via some other method, do not build the\n-     constructor or destructor list, just return now.  */\n-  if (rflag\n-#ifndef COLLECT_EXPORT_LIST\n-      || ! do_collecting\n-#endif\n-      )\n-    {\n-#ifdef COLLECT_EXPORT_LIST\n-      /* Do the link we avoided above if we are exiting.  */\n+     undefined symbols from repository information.\n+     \n+     If -r or they will be run via some other method, do not build the\n+     constructor or destructor list, just return now.  */  \n+  {\n+    bool early_exit\n+      = rflag || (! DO_COLLECT_EXPORT_LIST && ! do_collecting);\n+\n+    /* Perform the first pass link now, if we're about to exit or if we need\n+       to scan for things we haven't collected yet before pursuing further.\n+\n+       On AIX, the latter typically includes nothing for shared objects or\n+       frame tables for an executable, out of what the required early scan on\n+       objects and libraries has performed above.  In the !shared_obj case, we\n+       expect the relevant tables to be dragged together with their associated\n+       functions from precise cross reference insertions by the compiler.  */\n+       \n+    if (early_exit || ld1_filter != SCAN_NOTHING)\n       do_tlink (ld1_argv, object_lst);\n-\n-      /* But make sure we delete the export file we may have created.  */\n-      if (export_file != 0 && export_file[0])\n-\tmaybe_unlink (export_file);\n+    \n+    if (early_exit)\n+      {\n+#ifdef COLLECT_EXPORT_LIST\n+\t/* Make sure we delete the export file we may have created.  */\n+\tif (export_file != 0 && export_file[0])\n+\t  maybe_unlink (export_file);\n #endif\n-      maybe_unlink (c_file);\n-      maybe_unlink (o_file);\n-      return 0;\n-    }\n+\tmaybe_unlink (c_file);\n+\tmaybe_unlink (o_file);\n+\treturn 0;\n+      }\n+  }\n \n-  /* Examine the namelist with nm and search it for static constructors\n-     and destructors to call.\n-     Write the constructor and destructor tables to a .s file and reload.  */\n+  /* Unless we have done it all already, examine the namelist and search for\n+     static constructors and destructors to call.  Write the constructor and\n+     destructor tables to a .s file and reload.  */\n \n-  /* On AIX we already scanned for global constructors/destructors.  */\n-#ifndef COLLECT_EXPORT_LIST\n-  scan_prog_file (output_file, PASS_FIRST);\n-#endif\n+  if (ld1_filter != SCAN_NOTHING)\n+    scan_prog_file (output_file, PASS_FIRST, ld1_filter);\n \n #ifdef SCAN_LIBRARIES\n   scan_libraries (output_file);\n@@ -1410,6 +1477,9 @@ main (int argc, char **argv)\n       notice (\"%d frame table(s) found\\n\", frame_tables.number);\n     }\n \n+  /* If the scan exposed nothing of special interest, there's no need to\n+     generate the glue code and relink so return now.  */\n+\n   if (constructors.number == 0 && destructors.number == 0\n       && frame_tables.number == 0\n #if defined (SCAN_LIBRARIES) || defined (COLLECT_EXPORT_LIST)\n@@ -1420,10 +1490,11 @@ main (int argc, char **argv)\n #endif\n       )\n     {\n-#ifdef COLLECT_EXPORT_LIST\n-      /* Do tlink without additional code generation.  */\n-      do_tlink (ld1_argv, object_lst);\n-#endif\n+      /* Do tlink without additional code generation now if we didn't\n+\t do it earlier for scanning purposes.  */\n+      if (ld1_filter == SCAN_NOTHING)\n+\tdo_tlink (ld1_argv, object_lst);\n+\n       /* Strip now if it was requested on the command line.  */\n       if (strip_flag)\n \t{\n@@ -1523,7 +1594,7 @@ main (int argc, char **argv)\n \n   /* Let scan_prog_file do any final mods (OSF/rose needs this for\n      constructors/destructors in shared libraries.  */\n-  scan_prog_file (output_file, PASS_SECOND);\n+  scan_prog_file (output_file, PASS_SECOND, SCAN_ALL);\n #endif\n \n   maybe_unlink (c_file);\n@@ -2097,16 +2168,11 @@ write_aix_file (FILE *stream, struct id *list)\n #ifdef OBJECT_FORMAT_NONE\n \n /* Generic version to scan the name list of the loaded program for\n-   the symbols g++ uses for static constructors and destructors.\n-\n-   The constructor table begins at __CTOR_LIST__ and contains a count\n-   of the number of pointers (or -1 if the constructors are built in a\n-   separate section by the linker), followed by the pointers to the\n-   constructor functions, terminated with a null pointer.  The\n-   destructor table has the same format, and begins at __DTOR_LIST__.  */\n+   the symbols g++ uses for static constructors and destructors.  */\n \n static void\n-scan_prog_file (const char *prog_name, enum pass which_pass)\n+scan_prog_file (const char *prog_name, scanpass which_pass,\n+\t\tscanfilter filter)\n {\n   void (*int_handler) (int);\n #ifdef SIGQUIT\n@@ -2185,7 +2251,8 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n       char *name, *end;\n \n       /* If it contains a constructor or destructor name, add the name\n-\t to the appropriate list.  */\n+\t to the appropriate list unless this is a kind of symbol we're\n+\t not supposed to even consider.  */\n \n       for (p = buf; (ch = *p) != '\\0' && ch != '\\n' && ch != '_'; p++)\n \tif (ch == ' ' && p[1] == 'U' && p[2] == ' ')\n@@ -2206,16 +2273,22 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n       switch (is_ctor_dtor (name))\n \t{\n \tcase SYM_CTOR:\n+\t  if (! (filter & SCAN_CTOR))\n+\t    break;\n \t  if (which_pass != PASS_LIB)\n \t    add_to_list (&constructors, name);\n \t  break;\n \n \tcase SYM_DTOR:\n+\t  if (! (filter & SCAN_DTOR))\n+\t    break;\n \t  if (which_pass != PASS_LIB)\n \t    add_to_list (&destructors, name);\n \t  break;\n \n \tcase SYM_INIT:\n+\t  if (! (filter & SCAN_INIT))\n+\t    break;\n \t  if (which_pass != PASS_LIB)\n \t    fatal (\"init function found in object %s\", prog_name);\n #ifndef LD_INIT_SWITCH\n@@ -2224,6 +2297,8 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n \t  break;\n \n \tcase SYM_FINI:\n+\t  if (! (filter & SCAN_FINI))\n+\t    break;\n \t  if (which_pass != PASS_LIB)\n \t    fatal (\"fini function found in object %s\", prog_name);\n #ifndef LD_FINI_SWITCH\n@@ -2232,6 +2307,8 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n \t  break;\n \n \tcase SYM_DWEH:\n+\t  if (! (filter & SCAN_DWEH))\n+\t    break;\n \t  if (which_pass != PASS_LIB)\n \t    add_to_list (&frame_tables, name);\n \t  break;\n@@ -2488,16 +2565,11 @@ extern char *ldgetname (LDFILE *, GCC_SYMENT *);\n #endif\n \n /* COFF version to scan the name list of the loaded program for\n-   the symbols g++ uses for static constructors and destructors.\n-\n-   The constructor table begins at __CTOR_LIST__ and contains a count\n-   of the number of pointers (or -1 if the constructors are built in a\n-   separate section by the linker), followed by the pointers to the\n-   constructor functions, terminated with a null pointer.  The\n-   destructor table has the same format, and begins at __DTOR_LIST__.  */\n+   the symbols g++ uses for static constructors and destructors.  */\n \n static void\n-scan_prog_file (const char *prog_name, enum pass which_pass)\n+scan_prog_file (const char *prog_name, scanpass which_pass,\n+\t\tscanfilter filter)\n {\n   LDFILE *ldptr = NULL;\n   int sym_index, sym_count;\n@@ -2561,6 +2633,8 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n \t\t      switch (is_ctor_dtor (name))\n \t\t\t{\n \t\t\tcase SYM_CTOR:\n+\t\t\t  if (! (filter & SCAN_CTOR))\n+\t\t\t    break;\n \t\t\t  if (! is_shared)\n \t\t\t    add_to_list (&constructors, name);\n #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)\n@@ -2570,6 +2644,8 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n \t\t\t  break;\n \n \t\t\tcase SYM_DTOR:\n+\t\t\t  if (! (filter & SCAN_DTOR))\n+\t\t\t    break;\n \t\t\t  if (! is_shared)\n \t\t\t    add_to_list (&destructors, name);\n #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)\n@@ -2580,13 +2656,17 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n \n #ifdef COLLECT_EXPORT_LIST\n \t\t\tcase SYM_INIT:\n+\t\t\t  if (! (filter & SCAN_INIT))\n+\t\t\t    break;\n #ifndef LD_INIT_SWITCH\n \t\t\t  if (is_shared)\n \t\t\t    add_to_list (&constructors, name);\n #endif\n \t\t\t  break;\n \n \t\t\tcase SYM_FINI:\n+\t\t\t  if (! (filter & SCAN_FINI))\n+\t\t\t    break;\n #ifndef LD_INIT_SWITCH\n \t\t\t  if (is_shared)\n \t\t\t    add_to_list (&destructors, name);\n@@ -2595,6 +2675,8 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n #endif\n \n \t\t\tcase SYM_DWEH:\n+\t\t\t  if (! (filter & SCAN_DWEH))\n+\t\t\t    break;\n \t\t\t  if (! is_shared)\n \t\t\t    add_to_list (&frame_tables, name);\n #if defined (COLLECT_EXPORT_LIST) && !defined (LD_INIT_SWITCH)"}, {"sha": "4676110b44ee684275dcb652afa10f014bbc2997", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=7e49a4b3969b940d0165515374f81c0307965d45", "patch": "@@ -43,6 +43,12 @@\n    collect has a chance to see them, so scan the object files directly.  */\n #define COLLECT_EXPORT_LIST\n \n+/* Issue assembly directives that create a reference to the given DWARF table\n+   identifier label from the current function section.  This is defined to\n+   ensure we drag frame frame tables associated with needed function bodies in\n+   a link with garbage collection activated.  */\n+#define ASM_OUTPUT_DWARF_TABLE_REF rs6000_aix_asm_output_dwarf_table_ref\n+\n /* Handle #pragma weak and #pragma pack.  */\n #define HANDLE_SYSV_PRAGMA 1\n "}, {"sha": "6e6bb9e389140b47012a1ef141f5579e3f9f68b9", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=7e49a4b3969b940d0165515374f81c0307965d45", "patch": "@@ -179,6 +179,8 @@ extern int rs6000_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern bool rs6000_tls_referenced_p (rtx);\n extern void rs6000_conditional_register_usage (void);\n \n+extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n+\n /* Declare functions in rs6000-c.c */\n \n extern void rs6000_pragma_longcall (struct cpp_reader *);"}, {"sha": "8e31cbbe7a680a9977136344b10f4a68e81c6fac", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7e49a4b3969b940d0165515374f81c0307965d45", "patch": "@@ -17612,6 +17612,15 @@ create_TOC_reference (rtx symbol)\n \t       gen_rtx_UNSPEC (Pmode, gen_rtvec (1, symbol), UNSPEC_TOCREL)));\n }\n \n+/* Issue assembly directives that create a reference to the given DWARF\n+   FRAME_TABLE_LABEL from the current function section.  */\n+void\n+rs6000_aix_asm_output_dwarf_table_ref (char * frame_table_label)\n+{\n+  fprintf (asm_out_file, \"\\t.ref %s\\n\",\n+\t   TARGET_STRIP_NAME_ENCODING (frame_table_label));\n+}\n+\n /* If _Unwind_* has been called from within the same module,\n    toc register is not guaranteed to be saved to 40(1) on function\n    entry.  Save it there in that case.  */"}, {"sha": "f236a7d1c1b92f9d28005f44f82f427a2fe6ba68", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7e49a4b3969b940d0165515374f81c0307965d45", "patch": "@@ -9159,6 +9159,13 @@ A C statement to issue assembly directives that create a self-relative\n reference to the given @var{label}, using an integer of the given @var{size}.\n @end defmac\n \n+@defmac ASM_OUTPUT_DWARF_TABLE_REF (@var{label})\n+A C statement to issue assembly directives that create a reference to\n+the DWARF table identifier @var{label} from the current section.  This\n+is used on some systems to avoid garbage collecting a DWARF table which\n+is referenced by a function.\n+@end defmac\n+\n @deftypefn {Target Hook} void TARGET_ASM_OUTPUT_DWARF_DTPREL (FILE *@var{FILE}, int @var{size}, rtx @var{x})\n If defined, this target hook is a function which outputs a DTP-relative\n reference to the given TLS symbol of the specified size."}, {"sha": "04f875870c326fe8238d26956683d876fe72c267", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e49a4b3969b940d0165515374f81c0307965d45/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7e49a4b3969b940d0165515374f81c0307965d45", "patch": "@@ -2932,12 +2932,12 @@ dw_cfi_oprnd2_desc (enum dwarf_call_frame_info cfi)\n \n #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n \n-/* Switch to eh_frame_section.  If we don't have an eh_frame_section,\n-   switch to the data section instead, and write out a synthetic label\n-   for collect2.  */\n+/* Switch [BACK] to eh_frame_section.  If we don't have an eh_frame_section,\n+   switch to the data section instead, and write out a synthetic start label\n+   for collect2 the first time around.  */\n \n static void\n-switch_to_eh_frame_section (void)\n+switch_to_eh_frame_section (bool back)\n {\n   tree label;\n \n@@ -2980,11 +2980,15 @@ switch_to_eh_frame_section (void)\n       /* We have no special eh_frame section.  Put the information in\n \t the data section and emit special labels to guide collect2.  */\n       switch_to_section (data_section);\n-      label = get_file_function_name (\"F\");\n-      ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n-      targetm.asm_out.globalize_label (asm_out_file,\n-\t\t\t\t       IDENTIFIER_POINTER (label));\n-      ASM_OUTPUT_LABEL (asm_out_file, IDENTIFIER_POINTER (label));\n+\n+      if (!back)\n+\t{\n+\t  label = get_file_function_name (\"F\");\n+\t  ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n+\t  targetm.asm_out.globalize_label (asm_out_file,\n+\t\t\t\t\t   IDENTIFIER_POINTER (label));\n+\t  ASM_OUTPUT_LABEL (asm_out_file, IDENTIFIER_POINTER (label));\n+\t}\n     }\n }\n \n@@ -3534,6 +3538,20 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n \toutput_cfi (cfi, fde, for_eh);\n     }\n \n+  /* If we are to emit a ref/link from function bodies to their frame tables,\n+     do it now.  This is typically performed to make sure that tables\n+     associated with functions are dragged with them and not discarded in\n+     garbage collecting links. We need to do this on a per function basis to\n+     cope with -ffunction-sections.  */\n+\n+#ifdef ASM_OUTPUT_DWARF_TABLE_REF\n+  /* Switch to the function section, emit the ref to the tables, and\n+     switch *back* into the table section.  */\n+  switch_to_section (function_section (fde->decl));\n+  ASM_OUTPUT_DWARF_TABLE_REF (section_start_label);\n+  switch_to_frame_table_section (for_eh, true);\n+#endif\n+\n   /* Pad the FDE out to an address sized boundary.  */\n   ASM_OUTPUT_ALIGN (asm_out_file,\n \t\t    floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n@@ -3543,6 +3561,22 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n }\n \n \n+/* Switch [BACK] to the eh or debug frame table section, depending on\n+   FOR_EH.  */\n+static void\n+switch_to_frame_table_section (int for_eh, bool back)\n+{\n+  if (for_eh)\n+    switch_to_eh_frame_section (back);\n+  else\n+    {\n+      if (!debug_frame_section)\n+\tdebug_frame_section = get_section (DEBUG_FRAME_SECTION,\n+\t\t\t\t\t   SECTION_DEBUG, NULL);\n+      switch_to_section (debug_frame_section);\n+    }\n+}\n+\n /* Output the call frame information used to record information\n    that relates to calculating the frame pointer, and records the\n    location of saved registers.  */\n@@ -3613,15 +3647,8 @@ output_call_frame_info (int for_eh)\n   if (flag_debug_asm)\n     app_enable ();\n \n-  if (for_eh)\n-    switch_to_eh_frame_section ();\n-  else\n-    {\n-      if (!debug_frame_section)\n-\tdebug_frame_section = get_section (DEBUG_FRAME_SECTION,\n-\t\t\t\t\t   SECTION_DEBUG, NULL);\n-      switch_to_section (debug_frame_section);\n-    }\n+  /* Switch to the proper frame section, first time.  */\n+  switch_to_frame_table_section (for_eh, false);\n \n   ASM_GENERATE_INTERNAL_LABEL (section_start_label, FRAME_BEGIN_LABEL, for_eh);\n   ASM_OUTPUT_LABEL (asm_out_file, section_start_label);"}]}