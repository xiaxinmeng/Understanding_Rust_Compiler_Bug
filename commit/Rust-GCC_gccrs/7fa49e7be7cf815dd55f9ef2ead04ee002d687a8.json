{"sha": "7fa49e7be7cf815dd55f9ef2ead04ee002d687a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZhNDllN2JlN2NmODE1ZGQ1NWY5ZWYyZWFkMDRlZTAwMmQ2ODdhOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-21T18:35:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-21T18:35:27Z"}, "message": "ipa-inline.c (inlining_mode): Comment, move up.\n\n\t* ipa-inline.c (inlining_mode): Comment, move up.\n\t(cgraph_decide_inlining_incrementally): Do not perform inlining itself; fix\n\thandling of flattening of self recursive functions.\n\t(cgraph_find_cycles): Remove.\n\t(cgraph_flatten_node): Remove.\n\t(cgraph_decide_inlining): Use incremental inliner to handle flattening.\n\t(try_inline): New function.\n\t(cgraph_early_inlining): Update call of cgraph_decide_inlining_incrementally.\n\tApply inlining here.\n\t(apply_inline): Update call of cgraph_decide_inlining_incrementally.\n\nFrom-SVN: r121034", "tree": {"sha": "a24a52039878918494071aabc8020dbb0f11b90d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a24a52039878918494071aabc8020dbb0f11b90d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8/comments", "author": null, "committer": null, "parents": [{"sha": "a63a09594132dfe461a87dfd71cf607b987fc770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a63a09594132dfe461a87dfd71cf607b987fc770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a63a09594132dfe461a87dfd71cf607b987fc770"}], "stats": {"total": 292, "additions": 162, "deletions": 130}, "files": [{"sha": "a201681e4dc37c9f1873297648bc445704c4f91e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7fa49e7be7cf815dd55f9ef2ead04ee002d687a8", "patch": "@@ -1,3 +1,16 @@\n+2007-01-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (inlining_mode): Comment, move up.\n+\t(cgraph_decide_inlining_incrementally): Do not perform inlining itself; fix\n+\thandling of flattening of self recursive functions.\n+\t(cgraph_find_cycles): Remove.\n+\t(cgraph_flatten_node): Remove.\n+\t(cgraph_decide_inlining): Use incremental inliner to handle flattening.\n+\t(try_inline): New function.\n+\t(cgraph_early_inlining): Update call of cgraph_decide_inlining_incrementally.\n+\tApply inlining here.\n+\t(apply_inline): Update call of cgraph_decide_inlining_incrementally.\n+\n 2007-01-21  Dirk Mueller  <dmueller@suse.de>\n \n \tPR bootstrap/30511"}, {"sha": "646b72e7c42ef4ded8270c8e5012e5d6ef779228", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 149, "deletions": 130, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa49e7be7cf815dd55f9ef2ead04ee002d687a8/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=7fa49e7be7cf815dd55f9ef2ead04ee002d687a8", "patch": "@@ -140,6 +140,32 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"tree-flow.h\"\n \n+/* Mode incremental inliner operate on:\n+\n+   In ALWAYS_INLINE only functions marked\n+   always_inline are inlined.  This mode is used after detecting cycle during\n+   flattening.\n+\n+   In SIZE mode, only functions that reduce function body size after inlining\n+   are inlined, this is used during early inlining.\n+\n+   In SPEED mode, all small functions are inlined.  This might result in\n+   unbounded growth of compilation unit and is used only in non-unit-at-a-time\n+   mode.\n+\n+   in ALL mode, everything is inlined.  This is used during flattening.  */\n+enum inlining_mode {\n+  INLINE_NONE = 0,\n+  INLINE_ALWAYS_INLINE,\n+  INLINE_SIZE,\n+  INLINE_SPEED,\n+  INLINE_ALL\n+};\n+static bool\n+cgraph_decide_inlining_incrementally (struct cgraph_node *, enum inlining_mode,\n+\t\t\t\t      int);\n+\n+\n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n static int nfunctions_inlined;\n@@ -587,65 +613,6 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n       lookup_recursive_calls (node, e->callee, heap);\n }\n \n-/* Find callgraph nodes closing a circle in the graph.  The\n-   resulting hashtab can be used to avoid walking the circles.\n-   Uses the cgraph nodes ->aux field which needs to be zero\n-   before and will be zero after operation.  */\n-\n-static void\n-cgraph_find_cycles (struct cgraph_node *node, htab_t cycles)\n-{\n-  struct cgraph_edge *e;\n-\n-  if (node->aux)\n-    {\n-      void **slot;\n-      slot = htab_find_slot (cycles, node, INSERT);\n-      if (!*slot)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Cycle contains %s\\n\", cgraph_node_name (node));\n-\t  *slot = node;\n-\t}\n-      return;\n-    }\n-\n-  node->aux = node;\n-  for (e = node->callees; e; e = e->next_callee)\n-    cgraph_find_cycles (e->callee, cycles); \n-  node->aux = 0;\n-}\n-\n-/* Flatten the cgraph node.  We have to be careful in recursing\n-   as to not run endlessly in circles of the callgraph.\n-   We do so by using a hashtab of cycle entering nodes as generated\n-   by cgraph_find_cycles.  */\n-\n-static void\n-cgraph_flatten_node (struct cgraph_node *node, htab_t cycles)\n-{\n-  struct cgraph_edge *e;\n-\n-  for (e = node->callees; e; e = e->next_callee)\n-    {\n-      /* Inline call, if possible, and recurse.  Be sure we are not\n-\t entering callgraph circles here.  */\n-      if (e->inline_failed\n-\t  && e->callee->local.inlinable\n-\t  && !cgraph_recursive_inlining_p (node, e->callee,\n-\t\t\t\t  \t   &e->inline_failed)\n-\t  && !htab_find (cycles, e->callee))\n-\t{\n-\t  if (dump_file)\n-    \t    fprintf (dump_file, \" inlining %s\", cgraph_node_name (e->callee));\n-          cgraph_mark_inline_edge (e, true);\n-\t  cgraph_flatten_node (e->callee, cycles);\n-\t}\n-      else if (dump_file)\n-\tfprintf (dump_file, \" !inlining %s\", cgraph_node_name (e->callee));\n-    }\n-}\n-\n /* Decide on recursive inlining: in the case function has recursive calls,\n    inline until body size reaches given argument.  */\n \n@@ -1030,18 +997,11 @@ cgraph_decide_inlining (void)\n       if (lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n         {\n \t  int old_overall_insns = overall_insns;\n-\t  htab_t cycles;\n   \t  if (dump_file)\n     \t    fprintf (dump_file,\n \t     \t     \"Flattening %s\\n\", cgraph_node_name (node));\n-\t  cycles = htab_create (7, htab_hash_pointer, htab_eq_pointer, NULL);\n-\t  cgraph_find_cycles (node, cycles);\n-\t  cgraph_flatten_node (node, cycles);\n-\t  htab_delete (cycles);\n+\t  cgraph_decide_inlining_incrementally (node, INLINE_ALL, 0);\n \t  overall_insns = old_overall_insns;\n-\t  /* We don't need to consider always_inline functions inside the flattened\n-\t     function anymore.  */\n-\t  continue;\n         }\n \n       if (!node->local.disregard_inline_limits)\n@@ -1066,6 +1026,12 @@ cgraph_decide_inlining (void)\n \t\t     cgraph_node_name (e->caller),\n \t\t     e->caller->global.insns);\n \t}\n+      /* Inlining self recursive function might introduce new calls to\n+\t thsemselves we didn't see in the loop above.  Fill in the proper\n+\t reason why inline failed.  */\n+      for (e = node->callers; e; e = e->next_caller)\n+\tif (e->inline_failed)\n+\t  e->inline_failed = N_(\"recursive inlining\");\n       if (dump_file)\n \tfprintf (dump_file, \n \t\t \" Inlined for a net change of %+i insns.\\n\",\n@@ -1136,66 +1102,128 @@ cgraph_decide_inlining (void)\n   return 0;\n }\n \n-enum inlining_mode {\n-  INLINE_SIZE,\n-  INLINE_SPEED,\n-  INLINE_ALL\n-};\n+/* Try to inline edge E from incremental inliner.  MODE specifies mode\n+   of inliner.\n+\n+   We are detecting cycles by storing mode of inliner into cgraph_node last\n+   time we visited it in the recursion.  In general when mode is set, we have\n+   recursive inlining, but as an special case, we want to try harder inline\n+   ALWAYS_INLINE functions: consider callgraph a->b->c->b, with a being\n+   flatten, b being always inline.  Flattening 'a' will collapse\n+   a->b->c before hitting cycle.  To accomondate always inline, we however\n+   need to inline a->b->c->b.\n+\n+   So after hitting cycle first time, we switch into ALWAYS_INLINE mode and\n+   stop inlining only after hitting ALWAYS_INLINE in ALWAY_INLINE mode.  */\n+static bool\n+try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n+{\n+  struct cgraph_node *callee = e->callee;\n+  enum inlining_mode callee_mode = (size_t) callee->aux;\n+  bool always_inline = e->callee->local.disregard_inline_limits;\n+\n+  /* We've hit cycle?  */\n+  if (callee_mode)\n+    {\n+      /* It is first time we see it and we are not in ALWAY_INLINE only\n+\t mode yet.  and the function in question is always_inline.  */\n+      if (always_inline && mode != INLINE_ALWAYS_INLINE)\n+\tmode = INLINE_ALWAYS_INLINE;\n+      /* Otheriwse it is time to give up.  */\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      indent_to (dump_file, depth);\n+\t      fprintf (dump_file,\n+\t\t       \"Not inlining %s into %s to avoid cycle.\\n\",\n+\t\t       cgraph_node_name (callee),\n+\t\t       cgraph_node_name (e->caller));\n+\t    }\n+\t  e->inline_failed = (e->callee->local.disregard_inline_limits\n+\t\t              ? N_(\"recursive inlining\") : \"\");\n+          return false;\n+\t}\n+    }\n+      \n+  callee->aux = (void *)(size_t) mode;\n+  if (dump_file)\n+    {\n+      indent_to (dump_file, depth);\n+      fprintf (dump_file, \" Inlining %s into %s.\\n\",\n+\t       cgraph_node_name (e->callee),\n+\t       cgraph_node_name (e->caller));\n+    }\n+  cgraph_mark_inline (e);\n+\n+  /* In order to fully inline always_inline functions at -O0, we need to\n+     recurse here, since the inlined functions might not be processed by\n+     incremental inlining at all yet.  \n+\n+     Also flattening needs to be done recursively.  */\n+\n+  if (!flag_unit_at_a_time || mode == INLINE_ALL || always_inline)\n+    cgraph_decide_inlining_incrementally (e->callee, mode, depth + 1);\n+  callee->aux = (void *)(size_t) callee_mode;\n+  return true;\n+}\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n-   expenses on updating data structures.  */\n+   expenses on updating data structures.  \n+   DEPTH is depth of recursion, used only for debug output.  */\n \n-static unsigned int\n-cgraph_decide_inlining_incrementally (struct cgraph_node *node, enum inlining_mode mode)\n+static bool\n+cgraph_decide_inlining_incrementally (struct cgraph_node *node, enum inlining_mode mode,\n+\t\t\t\t      int depth)\n {\n   struct cgraph_edge *e;\n   bool inlined = false;\n   const char *failed_reason;\n-  unsigned int todo = 0;\n+  enum inlining_mode old_mode;\n \n #ifdef ENABLE_CHECKING\n   verify_cgraph_node (node);\n #endif\n-  if (lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n+\n+  old_mode = (size_t)node->aux;\n+\n+  if (mode != INLINE_ALWAYS_INLINE\n+      && lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"  Flattening %s\\n\", cgraph_node_name (node));\n+\tfprintf (dump_file, \" Flattening %s\\n\", cgraph_node_name (node));\n       mode = INLINE_ALL;\n     }\n \n+  node->aux = (void *)(size_t) mode;\n+\n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n-    if ((e->callee->local.disregard_inline_limits\n-\t || (mode == INLINE_ALL && e->callee->local.inlinable))\n-\t&& e->inline_failed\n-\t&& (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t    == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-        && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n-\t/* ??? It is possible that renaming variable removed the function body\n-\t   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n-\t&& (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n-      {\n-        if (dump_file)\n-\t  {\n-\t    fprintf (dump_file, \"  Inlining always_inline %s\",\n-\t\t     cgraph_node_name (e->callee));\n-\t    fprintf (dump_file, \" into %s\\n\", cgraph_node_name (node));\n-\t  }\n-\tcgraph_mark_inline (e);\n-\t/* In order to fully inline always_inline functions at -O0, we need to\n-\t   recurse here, since the inlined functions might not be processed by\n-\t   incremental inlining at all yet.  \n-\n-\t   Also flattening needs to be done recursively.  */\n-\t\n-        if (!flag_unit_at_a_time || mode == INLINE_ALL)\n-          cgraph_decide_inlining_incrementally (e->callee, mode);\n-\t\n-\tinlined = true;\n-      }\n+    {\n+      if (dump_file && e->callee->local.inlinable\n+\t  && (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t      != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl))))\n+\t{\n+\t  fprintf (dump_file, \"  Ignoring %s: SSA form not computed yet.\\n\",\n+\t\t   cgraph_node_name (e->callee));\n+\t}\n+      if ((e->callee->local.disregard_inline_limits\n+\t   || (mode == INLINE_ALL && e->callee->local.inlinable))\n+\t  && e->inline_failed\n+\t  && (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t      == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+\t  && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n+\t  /* ??? It is possible that renaming variable removed the function body\n+\t     in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n+\t  && (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n+\t{\n+\t  inlined |= try_inline (e, mode, depth);\n+\t}\n+    }\n \n   /* Now do the automatic inlining.  */\n-  if (!flag_really_no_inline && mode != INLINE_ALL)\n+  if (!flag_really_no_inline && mode != INLINE_ALL\n+      && mode != INLINE_ALWAYS_INLINE)\n     for (e = node->callees; e; e = e->next_callee)\n       if (e->callee->local.inlinable\n \t  && e->inline_failed\n@@ -1211,28 +1239,12 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, enum inlining_mo\n \t  && (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n \t{\n \t  if (cgraph_default_inline_p (e->callee, &failed_reason))\n-\t    {\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file, \"  Inlining %s\",\n-\t\t\t   cgraph_node_name (e->callee));\n-\t\t  fprintf (dump_file, \" into %s\\n\", cgraph_node_name (node));\n-\t\t}\n-\t      cgraph_mark_inline (e);\n-\t      inlined = true;\n-\t      if (!flag_unit_at_a_time)\n-\t\tcgraph_decide_inlining_incrementally (e->callee, mode);\n-\t    }\n+\t    inlined |= try_inline (e, mode, depth);\n \t  else if (!flag_unit_at_a_time)\n \t    e->inline_failed = failed_reason;\n \t}\n-  if (flag_unit_at_a_time && inlined && !node->global.inlined_to)\n-    {\n-      timevar_push (TV_INTEGRATION);\n-      todo = optimize_inline_calls (current_function_decl);\n-      timevar_pop (TV_INTEGRATION);\n-    }\n-  return todo;\n+  node->aux = (void *)(size_t) old_mode;\n+  return inlined;\n }\n \n /* When inlining shall be performed.  */\n@@ -1273,12 +1285,19 @@ static unsigned int\n cgraph_early_inlining (void)\n {\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n+  unsigned int todo = 0;\n \n   if (sorrycount || errorcount)\n     return 0;\n-  return cgraph_decide_inlining_incrementally (node,\n-\t\t\t\t\t       flag_unit_at_a_time\n-\t\t\t\t\t       ? INLINE_SIZE : INLINE_SPEED);\n+  if (cgraph_decide_inlining_incrementally (node,\n+\t\t\t\t\t    flag_unit_at_a_time\n+\t\t\t\t\t    ? INLINE_SIZE : INLINE_SPEED, 0))\n+    {\n+      timevar_push (TV_INTEGRATION);\n+      todo = optimize_inline_calls (current_function_decl);\n+      timevar_pop (TV_INTEGRATION);\n+    }\n+  return todo;\n }\n \n /* When inlining shall be performed.  */\n@@ -1390,7 +1409,7 @@ apply_inline (void)\n   /* Even when not optimizing, ensure that always_inline functions get inlined.\n    */\n   if (!optimize)\n-   cgraph_decide_inlining_incrementally (node, false);\n+   cgraph_decide_inlining_incrementally (node, INLINE_SPEED, 0);\n \n   /* We might need the body of this function so that we can expand\n      it inline somewhere else.  */"}]}