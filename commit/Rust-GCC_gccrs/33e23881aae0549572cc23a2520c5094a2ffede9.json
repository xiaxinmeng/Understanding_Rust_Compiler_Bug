{"sha": "33e23881aae0549572cc23a2520c5094a2ffede9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNlMjM4ODFhYWUwNTQ5NTcyY2MyM2EyNTIwYzUwOTRhMmZmZWRlOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-29T20:41:11Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-29T20:41:11Z"}, "message": "Simplify tree streaming.\n\nthis patch cleans up tree streaming.  The code is prepared to stream nested\ntrees, but we only handle flat trees. As a result we have quite heavy function\nto stream in/out tree reference which is used many times and shows up in\nprofile.\n\nThis patch adds stream_write_tree_ref/stream_read_tree_ref which is used to\nstream references to trees that are required to exist in the cache or be\nindexable.\n\nThe actual implementation is just a first cut.  I would like to make it more\ncompact. We used to stream 2 byte tag (as UHWI) + UHWI representing the index.\nNow we stream one UHWI that represent type of reference + index for references\nto cache, but still two integers for references to global stream.  This is\nbecaue the abstraction is not very helpful here and I want to clean this up\nincrementally.\n\nI would also like to get rid of the ref_p parameters which seems unnecessary for\nflat streams.\n\nThis reduces around 7% of global stream, 3% when compressed.\nMore reduction will happen once the format is sanitized a bit.\n\nfrom\n[WPA] read 4597161 unshared trees\n[WPA] read 2937414 mergeable SCCs of average size 1.364280\n[WPA] 8604617 tree bodies read in total\n[WPA] tree SCC table: size 524287, 247507 elements, collision ratio: 0.377468\n[WPA] tree SCC max chain length 2 (size 1)\n[WPA] Compared 2689907 SCCs, 184 collisions (0.000068)\n[WPA] Merged 2689890 SCCs\n[WPA] Merged 3722677 tree bodies\n[WPA] Merged 632040 types\n...\n[WPA] Compression: 88124141 input bytes, 234906430 uncompressed bytes (ratio: 2.665631)\n[WPA] Size of mmap'd section decls: 88124141 bytes\n...\n[WPA] Compression: 113758813 input bytes, 316149514 uncompressed bytes (ratio: 2.779121)\n[WPA] Size of mmap'd section decls: 88124141 bytes\n[WPA] Size of mmap'd section function_body: 14485721 bytes\n\nto\n\n[WPA] read 4597174 unshared trees\n[WPA] read 2937413 mergeable SCCs of average size 1.364280\n[WPA] 8604629 tree bodies read in total\n[WPA] tree SCC table: size 524287, 247509 elements, collision ratio: 0.377458\n[WPA] tree SCC max chain length 2 (size 1)\n[WPA] Compared 2689904 SCCs, 183 collisions (0.000068)\n[WPA] Merged 2689888 SCCs\n[WPA] Merged 3722675 tree bodies\n[WPA] Merged 632041 types\n....\n[WPA] Size of mmap'd section decls: 86177293 bytes\n[WPA] Compression: 86177293 input bytes, 217625095 uncompressed bytes (ratio: 2.525318)\n....\n[WPA] Compression: 111682269 input bytes, 297228756 uncompressed bytes (ratio: 2.661378)\n[WPA] Size of mmap'd section decls: 86177293 bytes\n[WPA] Size of mmap'd section function_body: 14349032 bytes\n\ngcc/ChangeLog:\n\n\t* lto-streamer-in.c (streamer_read_chain): Move here from\n\ttree-streamer-in.c.\n\t(stream_read_tree_ref): New.\n\t(lto_input_tree_1): Simplify.\n\t* lto-streamer-out.c (stream_write_tree_ref): New.\n\t(lto_write_tree_1): Simplify.\n\t(lto_output_tree_1): Simplify.\n\t(DFS::DFS_write_tree): Simplify.\n\t(streamer_write_chain): Move here from tree-stremaer-out.c.\n\t* lto-streamer.h (lto_output_tree_ref): Update prototype.\n\t(stream_read_tree_ref): Declare\n\t(stream_write_tree_ref): Declare\n\t* tree-streamer-in.c (streamer_read_chain): Update to use\n\tstream_read_tree_ref.\n\t(lto_input_ts_common_tree_pointers): Likewise.\n\t(lto_input_ts_vector_tree_pointers): Likewise.\n\t(lto_input_ts_poly_tree_pointers): Likewise.\n\t(lto_input_ts_complex_tree_pointers): Likewise.\n\t(lto_input_ts_decl_minimal_tree_pointers): Likewise.\n\t(lto_input_ts_decl_common_tree_pointers): Likewise.\n\t(lto_input_ts_decl_with_vis_tree_pointers): Likewise.\n\t(lto_input_ts_field_decl_tree_pointers): Likewise.\n\t(lto_input_ts_function_decl_tree_pointers): Likewise.\n\t(lto_input_ts_type_common_tree_pointers): Likewise.\n\t(lto_input_ts_type_non_common_tree_pointers): Likewise.\n\t(lto_input_ts_list_tree_pointers): Likewise.\n\t(lto_input_ts_vec_tree_pointers): Likewise.\n\t(lto_input_ts_exp_tree_pointers): Likewise.\n\t(lto_input_ts_block_tree_pointers): Likewise.\n\t(lto_input_ts_binfo_tree_pointers): Likewise.\n\t(lto_input_ts_constructor_tree_pointers): Likewise.\n\t(lto_input_ts_omp_clause_tree_pointers): Likewise.\n\t* tree-streamer-out.c (streamer_write_chain): Update to use\n\tstream_write_tree_ref.\n\t(write_ts_common_tree_pointers): Likewise.\n\t(write_ts_vector_tree_pointers): Likewise.\n\t(write_ts_poly_tree_pointers): Likewise.\n\t(write_ts_complex_tree_pointers): Likewise.\n\t(write_ts_decl_minimal_tree_pointers): Likewise.\n\t(write_ts_decl_common_tree_pointers): Likewise.\n\t(write_ts_decl_non_common_tree_pointers): Likewise.\n\t(write_ts_decl_with_vis_tree_pointers): Likewise.\n\t(write_ts_field_decl_tree_pointers): Likewise.\n\t(write_ts_function_decl_tree_pointers): Likewise.\n\t(write_ts_type_common_tree_pointers): Likewise.\n\t(write_ts_type_non_common_tree_pointers): Likewise.\n\t(write_ts_list_tree_pointers): Likewise.\n\t(write_ts_vec_tree_pointers): Likewise.\n\t(write_ts_exp_tree_pointers): Likewise.\n\t(write_ts_block_tree_pointers): Likewise.\n\t(write_ts_binfo_tree_pointers): Likewise.\n\t(write_ts_constructor_tree_pointers): Likewise.\n\t(write_ts_omp_clause_tree_pointers): Likewise.\n\t(streamer_write_tree_body): Likewise.\n\t(streamer_write_integer_cst): Likewise.\n\t* tree-streamer.h (streamer_read_chain):Declare.\n\t(streamer_write_chain):Declare.\n\t(streamer_write_tree_body): Update prototype.\n\t(streamer_write_integer_cst): Update prototype.", "tree": {"sha": "aae42457e3f6caefc5c39148438c52caef49c2c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aae42457e3f6caefc5c39148438c52caef49c2c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33e23881aae0549572cc23a2520c5094a2ffede9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e23881aae0549572cc23a2520c5094a2ffede9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33e23881aae0549572cc23a2520c5094a2ffede9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e23881aae0549572cc23a2520c5094a2ffede9/comments", "author": null, "committer": null, "parents": [{"sha": "9051b548274bffef9f41e720e1894d12cf68a47c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9051b548274bffef9f41e720e1894d12cf68a47c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9051b548274bffef9f41e720e1894d12cf68a47c"}], "stats": {"total": 421, "additions": 256, "deletions": 165}, "files": [{"sha": "805a51c0fb8c3afbf7fc12cf3b4a59452c4a42dd", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=33e23881aae0549572cc23a2520c5094a2ffede9", "patch": "@@ -1021,6 +1021,30 @@ input_struct_function_base (struct function *fn, class data_in *data_in,\n     }\n }\n \n+/* Read a chain of tree nodes from input block IB.  DATA_IN contains\n+   tables and descriptors for the file being read.  */\n+\n+static tree\n+streamer_read_chain (class lto_input_block *ib, class data_in *data_in)\n+{\n+  tree first, prev, curr;\n+\n+  /* The chain is written as NULL terminated list of trees.  */\n+  first = prev = NULL_TREE;\n+  do\n+    {\n+      curr = stream_read_tree (ib, data_in);\n+      if (prev)\n+\tTREE_CHAIN (prev) = curr;\n+      else\n+\tfirst = curr;\n+\n+      prev = curr;\n+    }\n+  while (curr);\n+\n+  return first;\n+}\n \n /* Read the body of function FN_DECL from DATA_IN using input block IB.  */\n \n@@ -1481,6 +1505,30 @@ lto_input_scc (class lto_input_block *ib, class data_in *data_in,\n   return scc_hash;\n }\n \n+/* Read reference to tree from IB and DATA_IN.\n+   This is used for streaming tree bodies where we know that\n+   the tree is already in cache or is indexable and \n+   must be matched with stream_write_tree_ref.  */\n+\n+tree\n+stream_read_tree_ref (lto_input_block *ib, data_in *data_in)\n+{\n+  unsigned ix = streamer_read_uhwi (ib);\n+  tree ret;\n+  if (!ix)\n+    return NULL_TREE;\n+  else if (ix < LTO_NUM_TAGS)\n+    ret = lto_input_tree_ref (ib, data_in, cfun, (LTO_tags)ix);\n+  else\n+    ret = streamer_tree_cache_get_tree (data_in->reader_cache,\n+\t\t\t\t\tix - LTO_NUM_TAGS);\n+  if (ret && streamer_debugging)\n+    {\n+      enum tree_code c = (enum tree_code)streamer_read_uhwi (ib);\n+      gcc_assert (c == TREE_CODE (ret));\n+    }\n+  return ret;\n+}\n \n /* Read a tree from input block IB using the per-file context in\n    DATA_IN.  This context is used, for example, to resolve references\n@@ -1513,7 +1561,7 @@ lto_input_tree_1 (class lto_input_block *ib, class data_in *data_in,\n     {\n       /* For shared integer constants in singletons we can use the\n          existing tree integer constant merging code.  */\n-      tree type = stream_read_tree (ib, data_in);\n+      tree type = stream_read_tree_ref (ib, data_in);\n       unsigned HOST_WIDE_INT len = streamer_read_uhwi (ib);\n       unsigned HOST_WIDE_INT i;\n       HOST_WIDE_INT a[WIDE_INT_MAX_ELTS];"}, {"sha": "1e147a3ab8a277c79ddfb7b5674a60849062f491", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=33e23881aae0549572cc23a2520c5094a2ffede9", "patch": "@@ -409,6 +409,34 @@ get_symbol_initial_value (lto_symtab_encoder_t encoder, tree expr)\n }\n \n \n+/* Output reference to tree T to the stream.\n+   Assume that T is already in encoder cache. \n+   This is used to stream tree bodies where we know the DFS walk arranged\n+   everything to cache.  Must be matched with stream_read_tree_ref.  */\n+\n+void\n+stream_write_tree_ref (struct output_block *ob, tree t)\n+{\n+  if (!t)\n+    streamer_write_zero (ob);\n+  else\n+    {\n+      unsigned int ix;\n+      bool existed_p = streamer_tree_cache_lookup (ob->writer_cache, t, &ix);\n+      if (existed_p)\n+\tstreamer_write_uhwi (ob, ix + LTO_NUM_TAGS);\n+      else\n+\t{\n+\t  gcc_checking_assert (tree_is_indexable (t));\n+\t  lto_output_tree_ref (ob, t);\n+\t}\n+      if (streamer_debugging)\n+\tstreamer_write_uhwi (ob, TREE_CODE (t));\n+    }\n+}\n+\n+\n+\n /* Write a physical representation of tree node EXPR to output block\n    OB.  If REF_P is true, the leaves of EXPR are emitted as references\n    via lto_output_tree_ref.  IX is the index into the streamer cache\n@@ -430,7 +458,7 @@ lto_write_tree_1 (struct output_block *ob, tree expr, bool ref_p)\n   streamer_write_tree_bitfields (ob, expr);\n \n   /* Write all the pointer fields in EXPR.  */\n-  streamer_write_tree_body (ob, expr, ref_p);\n+  streamer_write_tree_body (ob, expr);\n \n   /* Write any LTO-specific data to OB.  */\n   if (DECL_P (expr)\n@@ -505,7 +533,7 @@ lto_output_tree_1 (struct output_block *ob, tree expr, hashval_t hash,\n       /* Shared INTEGER_CST nodes are special because they need their\n \t original type to be materialized by the reader (to implement\n \t TYPE_CACHED_VALUES).  */\n-      streamer_write_integer_cst (ob, expr, ref_p);\n+      streamer_write_integer_cst (ob, expr);\n     }\n   else\n     {\n@@ -1685,7 +1713,7 @@ DFS::DFS_write_tree (struct output_block *ob, sccs *from_state,\n   /* Check if we already streamed EXPR.  */\n   if (streamer_tree_cache_lookup (ob->writer_cache, expr, NULL))\n     {\n-      /* Refernece to a local tree makes entry also local.  We always process\n+      /* Reference to a local tree makes entry also local.  We always process\n \t top of stack entry, so set max to number of entries in stack - 1.  */\n       if (ob->local_trees\n \t  && ob->local_trees->contains (expr))\n@@ -2272,6 +2300,29 @@ lto_prepare_function_for_streaming (struct cgraph_node *node)\n \n }\n \n+/* Emit the chain of tree nodes starting at T.  OB is the output block\n+   to write to.  REF_P is true if chain elements should be emitted\n+   as references.  */\n+\n+static void\n+streamer_write_chain (struct output_block *ob, tree t, bool ref_p)\n+{\n+  while (t)\n+    {\n+      /* We avoid outputting external vars or functions by reference\n+\t to the global decls section as we do not want to have them\n+\t enter decl merging.  We should not need to do this anymore because\n+\t free_lang_data removes them from block scopes.  */\n+      gcc_assert (!VAR_OR_FUNCTION_DECL_P (t) || !DECL_EXTERNAL (t));\n+      stream_write_tree (ob, t, ref_p);\n+\n+      t = TREE_CHAIN (t);\n+    }\n+\n+  /* Write a sentinel to terminate the chain.  */\n+  stream_write_tree (ob, NULL_TREE, ref_p);\n+}\n+\n /* Output the body of function NODE->DECL.  */\n \n static void"}, {"sha": "d527d51ef362d2b019aae29aff415ea3b17b7302", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=33e23881aae0549572cc23a2520c5094a2ffede9", "patch": "@@ -914,13 +914,15 @@ hashval_t lto_input_scc (class lto_input_block *, class data_in *,\n tree lto_input_tree_1 (class lto_input_block *, class data_in *,\n \t\t       enum LTO_tags, hashval_t hash);\n tree lto_input_tree (class lto_input_block *, class data_in *);\n+tree stream_read_tree_ref (class lto_input_block *, class data_in *);\n \n \n /* In lto-streamer-out.c  */\n extern void lto_register_decl_definition (tree, struct lto_file_decl_data *);\n extern struct output_block *create_output_block (enum lto_section_type);\n extern void destroy_output_block (struct output_block *);\n extern void lto_output_tree (struct output_block *, tree, bool, bool);\n+extern void stream_write_tree_ref (struct output_block *, tree);\n extern void lto_output_toplevel_asms (void);\n extern void produce_asm (struct output_block *ob, tree fn);\n extern void lto_output ();"}, {"sha": "447a3110e82479e6504d3443fdc54ee3b714af38", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=33e23881aae0549572cc23a2520c5094a2ffede9", "patch": "@@ -69,10 +69,10 @@ input_identifier (class data_in *data_in, class lto_input_block *ib)\n }\n \n \n-/* Read a chain of tree nodes from input block IB. DATA_IN contains\n+/* Read a chain of tree nodes from input block IB.  DATA_IN contains\n    tables and descriptors for the file being read.  */\n \n-tree\n+static tree\n streamer_read_chain (class lto_input_block *ib, class data_in *data_in)\n {\n   tree first, prev, curr;\n@@ -81,7 +81,7 @@ streamer_read_chain (class lto_input_block *ib, class data_in *data_in)\n   first = prev = NULL_TREE;\n   do\n     {\n-      curr = stream_read_tree (ib, data_in);\n+      curr = stream_read_tree_ref (ib, data_in);\n       if (prev)\n \tTREE_CHAIN (prev) = curr;\n       else\n@@ -651,7 +651,7 @@ lto_input_ts_common_tree_pointers (class lto_input_block *ib,\n \t\t\t\t   class data_in *data_in, tree expr)\n {\n   if (TREE_CODE (expr) != IDENTIFIER_NODE)\n-    TREE_TYPE (expr) = stream_read_tree (ib, data_in);\n+    TREE_TYPE (expr) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -665,7 +665,7 @@ lto_input_ts_vector_tree_pointers (class lto_input_block *ib,\n {\n   unsigned int count = vector_cst_encoded_nelts (expr);\n   for (unsigned int i = 0; i < count; ++i)\n-    VECTOR_CST_ENCODED_ELT (expr, i) = stream_read_tree (ib, data_in);\n+    VECTOR_CST_ENCODED_ELT (expr, i) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -678,7 +678,7 @@ lto_input_ts_poly_tree_pointers (class lto_input_block *ib,\n \t\t\t\t class data_in *data_in, tree expr)\n {\n   for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n-    POLY_INT_CST_COEFF (expr, i) = stream_read_tree (ib, data_in);\n+    POLY_INT_CST_COEFF (expr, i) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -690,8 +690,8 @@ static void\n lto_input_ts_complex_tree_pointers (class lto_input_block *ib,\n \t\t\t\t    class data_in *data_in, tree expr)\n {\n-  TREE_REALPART (expr) = stream_read_tree (ib, data_in);\n-  TREE_IMAGPART (expr) = stream_read_tree (ib, data_in);\n+  TREE_REALPART (expr) = stream_read_tree_ref (ib, data_in);\n+  TREE_IMAGPART (expr) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -703,8 +703,8 @@ static void\n lto_input_ts_decl_minimal_tree_pointers (class lto_input_block *ib,\n \t\t\t\t\t class data_in *data_in, tree expr)\n {\n-  DECL_NAME (expr) = stream_read_tree (ib, data_in);\n-  DECL_CONTEXT (expr) = stream_read_tree (ib, data_in);\n+  DECL_NAME (expr) = stream_read_tree_ref (ib, data_in);\n+  DECL_CONTEXT (expr) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -716,19 +716,19 @@ static void\n lto_input_ts_decl_common_tree_pointers (class lto_input_block *ib,\n \t\t\t\t\tclass data_in *data_in, tree expr)\n {\n-  DECL_SIZE (expr) = stream_read_tree (ib, data_in);\n-  DECL_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n-  DECL_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n-  DECL_ABSTRACT_ORIGIN (expr) = stream_read_tree (ib, data_in);\n+  DECL_SIZE (expr) = stream_read_tree_ref (ib, data_in);\n+  DECL_SIZE_UNIT (expr) = stream_read_tree_ref (ib, data_in);\n+  DECL_ATTRIBUTES (expr) = stream_read_tree_ref (ib, data_in);\n+  DECL_ABSTRACT_ORIGIN (expr) = stream_read_tree_ref (ib, data_in);\n \n   if ((VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))\n-    SET_DECL_VALUE_EXPR (expr, stream_read_tree (ib, data_in));\n+    SET_DECL_VALUE_EXPR (expr, stream_read_tree_ref (ib, data_in));\n \n   if (VAR_P (expr)\n       && DECL_HAS_DEBUG_EXPR_P (expr))\n     {\n-      tree dexpr = stream_read_tree (ib, data_in);\n+      tree dexpr = stream_read_tree_ref (ib, data_in);\n       if (dexpr)\n \tSET_DECL_DEBUG_EXPR (expr, dexpr);\n     }\n@@ -756,7 +756,7 @@ lto_input_ts_decl_with_vis_tree_pointers (class lto_input_block *ib,\n {\n   tree id;\n \n-  id = stream_read_tree (ib, data_in);\n+  id = stream_read_tree_ref (ib, data_in);\n   if (id)\n     {\n       gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n@@ -773,10 +773,10 @@ static void\n lto_input_ts_field_decl_tree_pointers (class lto_input_block *ib,\n \t\t\t\t       class data_in *data_in, tree expr)\n {\n-  DECL_FIELD_OFFSET (expr) = stream_read_tree (ib, data_in);\n-  DECL_BIT_FIELD_TYPE (expr) = stream_read_tree (ib, data_in);\n-  DECL_BIT_FIELD_REPRESENTATIVE (expr) = stream_read_tree (ib, data_in);\n-  DECL_FIELD_BIT_OFFSET (expr) = stream_read_tree (ib, data_in);\n+  DECL_FIELD_OFFSET (expr) = stream_read_tree_ref (ib, data_in);\n+  DECL_BIT_FIELD_TYPE (expr) = stream_read_tree_ref (ib, data_in);\n+  DECL_BIT_FIELD_REPRESENTATIVE (expr) = stream_read_tree_ref (ib, data_in);\n+  DECL_FIELD_BIT_OFFSET (expr) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -789,11 +789,12 @@ lto_input_ts_function_decl_tree_pointers (class lto_input_block *ib,\n \t\t\t\t\t  class data_in *data_in, tree expr)\n {\n   /* DECL_STRUCT_FUNCTION is loaded on demand by cgraph_get_body.  */\n-  DECL_FUNCTION_PERSONALITY (expr) = stream_read_tree (ib, data_in);\n+  DECL_FUNCTION_PERSONALITY (expr) = stream_read_tree_ref (ib, data_in);\n #ifndef ACCEL_COMPILER\n-  DECL_FUNCTION_SPECIFIC_TARGET (expr) = stream_read_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_TARGET (expr) = stream_read_tree_ref (ib, data_in);\n #endif\n-  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr) = stream_read_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr)\n+    = stream_read_tree_ref (ib, data_in);\n #ifdef ACCEL_COMPILER\n   {\n     tree opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr);\n@@ -819,16 +820,16 @@ static void\n lto_input_ts_type_common_tree_pointers (class lto_input_block *ib,\n \t\t\t\t\tclass data_in *data_in, tree expr)\n {\n-  TYPE_SIZE (expr) = stream_read_tree (ib, data_in);\n-  TYPE_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n-  TYPE_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n-  TYPE_NAME (expr) = stream_read_tree (ib, data_in);\n+  TYPE_SIZE (expr) = stream_read_tree_ref (ib, data_in);\n+  TYPE_SIZE_UNIT (expr) = stream_read_tree_ref (ib, data_in);\n+  TYPE_ATTRIBUTES (expr) = stream_read_tree_ref (ib, data_in);\n+  TYPE_NAME (expr) = stream_read_tree_ref (ib, data_in);\n   /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n      reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n-  TYPE_MAIN_VARIANT (expr) = stream_read_tree (ib, data_in);\n-  TYPE_CONTEXT (expr) = stream_read_tree (ib, data_in);\n+  TYPE_MAIN_VARIANT (expr) = stream_read_tree_ref (ib, data_in);\n+  TYPE_CONTEXT (expr) = stream_read_tree_ref (ib, data_in);\n   /* TYPE_CANONICAL gets re-computed during type merging.  */\n   TYPE_CANONICAL (expr) = NULL_TREE;\n }\n@@ -843,18 +844,18 @@ lto_input_ts_type_non_common_tree_pointers (class lto_input_block *ib,\n \t\t\t\t\t    tree expr)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    TYPE_VALUES (expr) = stream_read_tree (ib, data_in);\n+    TYPE_VALUES (expr) = stream_read_tree_ref (ib, data_in);\n   else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    TYPE_DOMAIN (expr) = stream_read_tree (ib, data_in);\n+    TYPE_DOMAIN (expr) = stream_read_tree_ref (ib, data_in);\n   else if (RECORD_OR_UNION_TYPE_P (expr))\n     TYPE_FIELDS (expr) = streamer_read_chain (ib, data_in);\n   else if (TREE_CODE (expr) == FUNCTION_TYPE\n \t   || TREE_CODE (expr) == METHOD_TYPE)\n-    TYPE_ARG_TYPES (expr) = stream_read_tree (ib, data_in);\n+    TYPE_ARG_TYPES (expr) = stream_read_tree_ref (ib, data_in);\n \n   if (!POINTER_TYPE_P (expr))\n-    TYPE_MIN_VALUE_RAW (expr) = stream_read_tree (ib, data_in);\n-  TYPE_MAX_VALUE_RAW (expr) = stream_read_tree (ib, data_in);\n+    TYPE_MIN_VALUE_RAW (expr) = stream_read_tree_ref (ib, data_in);\n+  TYPE_MAX_VALUE_RAW (expr) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -866,9 +867,9 @@ static void\n lto_input_ts_list_tree_pointers (class lto_input_block *ib,\n \t\t\t\t class data_in *data_in, tree expr)\n {\n-  TREE_PURPOSE (expr) = stream_read_tree (ib, data_in);\n-  TREE_VALUE (expr) = stream_read_tree (ib, data_in);\n-  TREE_CHAIN (expr) = stream_read_tree (ib, data_in);\n+  TREE_PURPOSE (expr) = stream_read_tree_ref (ib, data_in);\n+  TREE_VALUE (expr) = stream_read_tree_ref (ib, data_in);\n+  TREE_CHAIN (expr) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -885,7 +886,7 @@ lto_input_ts_vec_tree_pointers (class lto_input_block *ib,\n   /* Note that TREE_VEC_LENGTH was read by streamer_alloc_tree to\n      instantiate EXPR.  */\n   for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n-    TREE_VEC_ELT (expr, i) = stream_read_tree (ib, data_in);\n+    TREE_VEC_ELT (expr, i) = stream_read_tree_ref (ib, data_in);\n }\n \n \n@@ -902,9 +903,9 @@ lto_input_ts_exp_tree_pointers (class lto_input_block *ib,\n   tree block;\n \n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n-    TREE_OPERAND (expr, i) = stream_read_tree (ib, data_in);\n+    TREE_OPERAND (expr, i) = stream_read_tree_ref (ib, data_in);\n \n-  block = stream_read_tree (ib, data_in);\n+  block = stream_read_tree_ref (ib, data_in);\n \n   /* TODO: Block is stored in the locus information.  It may make more sense to\n      to make it go via the location cache.  */\n@@ -926,8 +927,8 @@ lto_input_ts_block_tree_pointers (class lto_input_block *ib,\n {\n   BLOCK_VARS (expr) = streamer_read_chain (ib, data_in);\n \n-  BLOCK_SUPERCONTEXT (expr) = stream_read_tree (ib, data_in);\n-  BLOCK_ABSTRACT_ORIGIN (expr) = stream_read_tree (ib, data_in);\n+  BLOCK_SUPERCONTEXT (expr) = stream_read_tree_ref (ib, data_in);\n+  BLOCK_ABSTRACT_ORIGIN (expr) = stream_read_tree_ref (ib, data_in);\n   /* We may end up prevailing a decl with DECL_ORIGIN (t) != t here\n      which breaks the invariant that BLOCK_ABSTRACT_ORIGIN is the\n      ultimate origin.  Fixup here.\n@@ -979,14 +980,14 @@ lto_input_ts_binfo_tree_pointers (class lto_input_block *ib,\n      list on the writer side.  */\n   do\n     {\n-      t = stream_read_tree (ib, data_in);\n+      t = stream_read_tree_ref (ib, data_in);\n       if (t)\n \tBINFO_BASE_BINFOS (expr)->quick_push (t);\n     }\n   while (t);\n \n-  BINFO_OFFSET (expr) = stream_read_tree (ib, data_in);\n-  BINFO_VTABLE (expr) = stream_read_tree (ib, data_in);\n+  BINFO_OFFSET (expr) = stream_read_tree_ref (ib, data_in);\n+  BINFO_VTABLE (expr) = stream_read_tree_ref (ib, data_in);\n \n   /* Do not walk BINFO_INHERITANCE_CHAIN, BINFO_SUBVTT_INDEX,\n      BINFO_BASE_ACCESSES and BINFO_VPTR_INDEX; these are used by C++ FE\n@@ -1007,8 +1008,8 @@ lto_input_ts_constructor_tree_pointers (class lto_input_block *ib,\n   for (i = 0; i < CONSTRUCTOR_NELTS (expr); i++)\n     {\n       constructor_elt e;\n-      e.index = stream_read_tree (ib, data_in);\n-      e.value = stream_read_tree (ib, data_in);\n+      e.index = stream_read_tree_ref (ib, data_in);\n+      e.value = stream_read_tree_ref (ib, data_in);\n       (*CONSTRUCTOR_ELTS (expr))[i] = e;\n     }\n }\n@@ -1025,8 +1026,8 @@ lto_input_ts_omp_clause_tree_pointers (class lto_input_block *ib,\n   int i;\n \n   for (i = 0; i < omp_clause_num_ops[OMP_CLAUSE_CODE (expr)]; i++)\n-    OMP_CLAUSE_OPERAND (expr, i) = stream_read_tree (ib, data_in);\n-  OMP_CLAUSE_CHAIN (expr) = stream_read_tree (ib, data_in);\n+    OMP_CLAUSE_OPERAND (expr, i) = stream_read_tree_ref (ib, data_in);\n+  OMP_CLAUSE_CHAIN (expr) = stream_read_tree_ref (ib, data_in);\n }\n \n "}, {"sha": "98631789cc394db522d479ccd249958df63e05ca", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 98, "deletions": 107, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=33e23881aae0549572cc23a2520c5094a2ffede9", "patch": "@@ -510,8 +510,8 @@ streamer_write_tree_bitfields (struct output_block *ob, tree expr)\n    to write to.  REF_P is true if chain elements should be emitted\n    as references.  */\n \n-void\n-streamer_write_chain (struct output_block *ob, tree t, bool ref_p)\n+static void\n+streamer_write_chain (struct output_block *ob, tree t)\n {\n   while (t)\n     {\n@@ -520,13 +520,13 @@ streamer_write_chain (struct output_block *ob, tree t, bool ref_p)\n \t enter decl merging.  We should not need to do this anymore because\n \t free_lang_data removes them from block scopes.  */\n       gcc_assert (!VAR_OR_FUNCTION_DECL_P (t) || !DECL_EXTERNAL (t));\n-      stream_write_tree (ob, t, ref_p);\n+      stream_write_tree_ref (ob, t);\n \n       t = TREE_CHAIN (t);\n     }\n \n   /* Write a sentinel to terminate the chain.  */\n-  stream_write_tree (ob, NULL_TREE, ref_p);\n+  stream_write_tree_ref (ob, NULL_TREE);\n }\n \n \n@@ -535,10 +535,10 @@ streamer_write_chain (struct output_block *ob, tree t, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_common_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_common_tree_pointers (struct output_block *ob, tree expr)\n {\n   if (TREE_CODE (expr) != IDENTIFIER_NODE)\n-    stream_write_tree (ob, TREE_TYPE (expr), ref_p);\n+    stream_write_tree_ref (ob, TREE_TYPE (expr));\n }\n \n \n@@ -547,13 +547,13 @@ write_ts_common_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_vector_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_vector_tree_pointers (struct output_block *ob, tree expr)\n {\n   /* Note that the number of elements for EXPR has already been emitted\n      in EXPR's header (see streamer_write_tree_header).  */\n   unsigned int count = vector_cst_encoded_nelts (expr);\n   for (unsigned int i = 0; i < count; ++i)\n-    stream_write_tree (ob, VECTOR_CST_ENCODED_ELT (expr, i), ref_p);\n+    stream_write_tree_ref (ob, VECTOR_CST_ENCODED_ELT (expr, i));\n }\n \n \n@@ -562,10 +562,10 @@ write_ts_vector_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_poly_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_poly_tree_pointers (struct output_block *ob, tree expr)\n {\n   for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n-    stream_write_tree (ob, POLY_INT_CST_COEFF (expr, i), ref_p);\n+    stream_write_tree_ref (ob, POLY_INT_CST_COEFF (expr, i));\n }\n \n \n@@ -574,10 +574,10 @@ write_ts_poly_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_complex_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_complex_tree_pointers (struct output_block *ob, tree expr)\n {\n-  stream_write_tree (ob, TREE_REALPART (expr), ref_p);\n-  stream_write_tree (ob, TREE_IMAGPART (expr), ref_p);\n+  stream_write_tree_ref (ob, TREE_REALPART (expr));\n+  stream_write_tree_ref (ob, TREE_IMAGPART (expr));\n }\n \n \n@@ -586,21 +586,20 @@ write_ts_complex_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    pointer fields.  */\n \n static void\n-write_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t     bool ref_p)\n+write_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr)\n {\n   /* Drop names that were created for anonymous entities.  */\n   if (DECL_NAME (expr)\n       && TREE_CODE (DECL_NAME (expr)) == IDENTIFIER_NODE\n       && IDENTIFIER_ANON_P (DECL_NAME (expr)))\n-    stream_write_tree (ob, NULL_TREE, ref_p);\n+    stream_write_tree_ref (ob, NULL_TREE);\n   else\n-    stream_write_tree (ob, DECL_NAME (expr), ref_p);\n+    stream_write_tree_ref (ob, DECL_NAME (expr));\n   if (TREE_CODE (expr) != TRANSLATION_UNIT_DECL\n       && ! DECL_CONTEXT (expr))\n-    stream_write_tree (ob, (*all_translation_units)[0], ref_p);\n+    stream_write_tree_ref (ob, (*all_translation_units)[0]);\n   else\n-    stream_write_tree (ob, DECL_CONTEXT (expr), ref_p);\n+    stream_write_tree_ref (ob, DECL_CONTEXT (expr));\n }\n \n \n@@ -609,16 +608,15 @@ write_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-write_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t    bool ref_p)\n+write_ts_decl_common_tree_pointers (struct output_block *ob, tree expr)\n {\n-  stream_write_tree (ob, DECL_SIZE (expr), ref_p);\n-  stream_write_tree (ob, DECL_SIZE_UNIT (expr), ref_p);\n+  stream_write_tree_ref (ob, DECL_SIZE (expr));\n+  stream_write_tree_ref (ob, DECL_SIZE_UNIT (expr));\n \n   /* Note, DECL_INITIAL is not handled here.  Since DECL_INITIAL needs\n      special handling in LTO, it must be handled by streamer hooks.  */\n \n-  stream_write_tree (ob, DECL_ATTRIBUTES (expr), ref_p);\n+  stream_write_tree_ref (ob, DECL_ATTRIBUTES (expr));\n \n   /* On non-early-LTO enabled targets we claim we compiled with -g0\n      but dwarf2out still did its set_decl_origin_self game fooling\n@@ -628,15 +626,15 @@ write_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n   if (debug_info_level == DINFO_LEVEL_NONE\n       && ao == expr)\n     ao = NULL_TREE;\n-  stream_write_tree (ob, ao, ref_p);\n+  stream_write_tree_ref (ob, ao);\n \n   if ((VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))\n-    stream_write_tree (ob, DECL_VALUE_EXPR (expr), ref_p);\n+    stream_write_tree_ref (ob, DECL_VALUE_EXPR (expr));\n \n   if (VAR_P (expr)\n       && DECL_HAS_DEBUG_EXPR_P (expr))\n-    stream_write_tree (ob, DECL_DEBUG_EXPR (expr), ref_p);\n+    stream_write_tree_ref (ob, DECL_DEBUG_EXPR (expr));\n }\n \n \n@@ -645,7 +643,7 @@ write_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-write_ts_decl_non_common_tree_pointers (struct output_block *, tree, bool)\n+write_ts_decl_non_common_tree_pointers (struct output_block *, tree)\n {\n }\n \n@@ -655,14 +653,13 @@ write_ts_decl_non_common_tree_pointers (struct output_block *, tree, bool)\n    pointer fields.  */\n \n static void\n-write_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t              bool ref_p)\n+write_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr)\n {\n   /* Make sure we don't inadvertently set the assembler name.  */\n   if (DECL_ASSEMBLER_NAME_SET_P (expr))\n-    stream_write_tree (ob, DECL_ASSEMBLER_NAME (expr), ref_p);\n+    stream_write_tree_ref (ob, DECL_ASSEMBLER_NAME (expr));\n   else\n-    stream_write_tree (ob, NULL_TREE, false);\n+    stream_write_tree_ref (ob, NULL_TREE);\n }\n \n \n@@ -671,13 +668,12 @@ write_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-write_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t   bool ref_p)\n+write_ts_field_decl_tree_pointers (struct output_block *ob, tree expr)\n {\n-  stream_write_tree (ob, DECL_FIELD_OFFSET (expr), ref_p);\n-  stream_write_tree (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n-  stream_write_tree (ob, DECL_BIT_FIELD_REPRESENTATIVE (expr), ref_p);\n-  stream_write_tree (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n+  stream_write_tree_ref (ob, DECL_FIELD_OFFSET (expr));\n+  stream_write_tree_ref (ob, DECL_BIT_FIELD_TYPE (expr));\n+  stream_write_tree_ref (ob, DECL_BIT_FIELD_REPRESENTATIVE (expr));\n+  stream_write_tree_ref (ob, DECL_FIELD_BIT_OFFSET (expr));\n }\n \n \n@@ -686,15 +682,14 @@ write_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-write_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t      bool ref_p)\n+write_ts_function_decl_tree_pointers (struct output_block *ob, tree expr)\n {\n   /* DECL_STRUCT_FUNCTION is handled by lto_output_function.  */\n-  stream_write_tree (ob, DECL_FUNCTION_PERSONALITY (expr), ref_p);\n+  stream_write_tree_ref (ob, DECL_FUNCTION_PERSONALITY (expr));\n   /* Don't stream these when passing things to a different target.  */\n   if (!lto_stream_offload_p)\n-    stream_write_tree (ob, DECL_FUNCTION_SPECIFIC_TARGET (expr), ref_p);\n-  stream_write_tree (ob, DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr), ref_p);\n+    stream_write_tree_ref (ob, DECL_FUNCTION_SPECIFIC_TARGET (expr));\n+  stream_write_tree_ref (ob, DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr));\n }\n \n \n@@ -703,19 +698,18 @@ write_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-write_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t    bool ref_p)\n+write_ts_type_common_tree_pointers (struct output_block *ob, tree expr)\n {\n-  stream_write_tree (ob, TYPE_SIZE (expr), ref_p);\n-  stream_write_tree (ob, TYPE_SIZE_UNIT (expr), ref_p);\n-  stream_write_tree (ob, TYPE_ATTRIBUTES (expr), ref_p);\n-  stream_write_tree (ob, TYPE_NAME (expr), ref_p);\n+  stream_write_tree_ref (ob, TYPE_SIZE (expr));\n+  stream_write_tree_ref (ob, TYPE_SIZE_UNIT (expr));\n+  stream_write_tree_ref (ob, TYPE_ATTRIBUTES (expr));\n+  stream_write_tree_ref (ob, TYPE_NAME (expr));\n   /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n      reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n-  stream_write_tree (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n-  stream_write_tree (ob, TYPE_CONTEXT (expr), ref_p);\n+  stream_write_tree_ref (ob, TYPE_MAIN_VARIANT (expr));\n+  stream_write_tree_ref (ob, TYPE_CONTEXT (expr));\n   /* TYPE_CANONICAL is re-computed during type merging, so no need\n      to stream it here.  */\n   /* Do not stream TYPE_STUB_DECL; it is not needed by LTO but currently\n@@ -728,22 +722,21 @@ write_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\tbool ref_p)\n+write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    stream_write_tree (ob, TYPE_VALUES (expr), ref_p);\n+    stream_write_tree_ref (ob, TYPE_VALUES (expr));\n   else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    stream_write_tree (ob, TYPE_DOMAIN (expr), ref_p);\n+    stream_write_tree_ref (ob, TYPE_DOMAIN (expr));\n   else if (RECORD_OR_UNION_TYPE_P (expr))\n-    streamer_write_chain (ob, TYPE_FIELDS (expr), ref_p);\n+    streamer_write_chain (ob, TYPE_FIELDS (expr));\n   else if (TREE_CODE (expr) == FUNCTION_TYPE\n \t   || TREE_CODE (expr) == METHOD_TYPE)\n-    stream_write_tree (ob, TYPE_ARG_TYPES (expr), ref_p);\n+    stream_write_tree_ref (ob, TYPE_ARG_TYPES (expr));\n \n   if (!POINTER_TYPE_P (expr))\n-    stream_write_tree (ob, TYPE_MIN_VALUE_RAW (expr), ref_p);\n-  stream_write_tree (ob, TYPE_MAX_VALUE_RAW (expr), ref_p);\n+    stream_write_tree_ref (ob, TYPE_MIN_VALUE_RAW (expr));\n+  stream_write_tree_ref (ob, TYPE_MAX_VALUE_RAW (expr));\n }\n \n \n@@ -752,11 +745,11 @@ write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr,\n    fields.  */\n \n static void\n-write_ts_list_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_list_tree_pointers (struct output_block *ob, tree expr)\n {\n-  stream_write_tree (ob, TREE_PURPOSE (expr), ref_p);\n-  stream_write_tree (ob, TREE_VALUE (expr), ref_p);\n-  stream_write_tree (ob, TREE_CHAIN (expr), ref_p);\n+  stream_write_tree_ref (ob, TREE_PURPOSE (expr));\n+  stream_write_tree_ref (ob, TREE_VALUE (expr));\n+  stream_write_tree_ref (ob, TREE_CHAIN (expr));\n }\n \n \n@@ -765,14 +758,14 @@ write_ts_list_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_vec_tree_pointers (struct output_block *ob, tree expr)\n {\n   int i;\n \n   /* Note that the number of slots for EXPR has already been emitted\n      in EXPR's header (see streamer_write_tree_header).  */\n   for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n-    stream_write_tree (ob, TREE_VEC_ELT (expr, i), ref_p);\n+    stream_write_tree_ref (ob, TREE_VEC_ELT (expr, i));\n }\n \n \n@@ -781,13 +774,13 @@ write_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_exp_tree_pointers (struct output_block *ob, tree expr)\n {\n   int i;\n \n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n-    stream_write_tree (ob, TREE_OPERAND (expr, i), ref_p);\n-  stream_write_tree (ob, TREE_BLOCK (expr), ref_p);\n+    stream_write_tree_ref (ob, TREE_OPERAND (expr, i));\n+  stream_write_tree_ref (ob, TREE_BLOCK (expr));\n }\n \n \n@@ -796,12 +789,12 @@ write_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_block_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_block_tree_pointers (struct output_block *ob, tree expr)\n {\n-  streamer_write_chain (ob, BLOCK_VARS (expr), ref_p);\n+  streamer_write_chain (ob, BLOCK_VARS (expr));\n \n-  stream_write_tree (ob, BLOCK_SUPERCONTEXT (expr), ref_p);\n-  stream_write_tree (ob, BLOCK_ABSTRACT_ORIGIN (expr), ref_p);\n+  stream_write_tree_ref (ob, BLOCK_SUPERCONTEXT (expr));\n+  stream_write_tree_ref (ob, BLOCK_ABSTRACT_ORIGIN (expr));\n \n   /* Do not stream BLOCK_NONLOCALIZED_VARS.  We cannot handle debug information\n      for early inlined BLOCKs so drop it on the floor instead of ICEing in\n@@ -820,7 +813,7 @@ write_ts_block_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-write_ts_binfo_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_binfo_tree_pointers (struct output_block *ob, tree expr)\n {\n   unsigned i;\n   tree t;\n@@ -829,11 +822,11 @@ write_ts_binfo_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n      EXPR's header (see streamer_write_tree_header) because this length\n      is needed to build the empty BINFO node on the reader side.  */\n   FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (expr), i, t)\n-    stream_write_tree (ob, t, ref_p);\n-  stream_write_tree (ob, NULL_TREE, false);\n+    stream_write_tree_ref (ob, t);\n+  stream_write_tree_ref (ob, NULL_TREE);\n \n-  stream_write_tree (ob, BINFO_OFFSET (expr), ref_p);\n-  stream_write_tree (ob, BINFO_VTABLE (expr), ref_p);\n+  stream_write_tree_ref (ob, BINFO_OFFSET (expr));\n+  stream_write_tree_ref (ob, BINFO_VTABLE (expr));\n \n   /* Do not walk BINFO_INHERITANCE_CHAIN, BINFO_SUBVTT_INDEX,\n      BINFO_BASE_ACCESSES and BINFO_VPTR_INDEX; these are used by C++ FE only.  */\n@@ -845,16 +838,15 @@ write_ts_binfo_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    pointer fields.  */\n \n static void\n-write_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t    bool ref_p)\n+write_ts_constructor_tree_pointers (struct output_block *ob, tree expr)\n {\n   unsigned i;\n   tree index, value;\n \n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, index, value)\n     {\n-      stream_write_tree (ob, index, ref_p);\n-      stream_write_tree (ob, value, ref_p);\n+      stream_write_tree_ref (ob, index);\n+      stream_write_tree_ref (ob, value);\n     }\n }\n \n@@ -864,12 +856,11 @@ write_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-write_ts_omp_clause_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t   bool ref_p)\n+write_ts_omp_clause_tree_pointers (struct output_block *ob, tree expr)\n {\n   int i;\n   for (i = 0; i < omp_clause_num_ops[OMP_CLAUSE_CODE (expr)]; i++)\n-    stream_write_tree (ob, OMP_CLAUSE_OPERAND (expr, i), ref_p);\n+    stream_write_tree_ref (ob, OMP_CLAUSE_OPERAND (expr, i));\n   switch (OMP_CLAUSE_CODE (expr))\n     {\n     case OMP_CLAUSE_REDUCTION:\n@@ -883,15 +874,15 @@ write_ts_omp_clause_tree_pointers (struct output_block *ob, tree expr,\n     default:\n       break;\n     }\n-  stream_write_tree (ob, OMP_CLAUSE_CHAIN (expr), ref_p);\n+  stream_write_tree_ref (ob, OMP_CLAUSE_CHAIN (expr));\n }\n \n \n /* Write all pointer fields in EXPR to output block OB.  If REF_P is true,\n    the leaves of EXPR are emitted as references.  */\n \n void\n-streamer_write_tree_body (struct output_block *ob, tree expr, bool ref_p)\n+streamer_write_tree_body (struct output_block *ob, tree expr)\n {\n   enum tree_code code;\n \n@@ -900,61 +891,61 @@ streamer_write_tree_body (struct output_block *ob, tree expr, bool ref_p)\n   code = TREE_CODE (expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n-    write_ts_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_common_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    write_ts_vector_tree_pointers (ob, expr, ref_p);\n+    write_ts_vector_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_POLY_INT_CST))\n-    write_ts_poly_tree_pointers (ob, expr, ref_p);\n+    write_ts_poly_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n-    write_ts_complex_tree_pointers (ob, expr, ref_p);\n+    write_ts_complex_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n-    write_ts_decl_minimal_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_minimal_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    write_ts_decl_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_common_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n-    write_ts_decl_non_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_non_common_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    write_ts_decl_with_vis_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_with_vis_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n-    write_ts_field_decl_tree_pointers (ob, expr, ref_p);\n+    write_ts_field_decl_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    write_ts_function_decl_tree_pointers (ob, expr, ref_p);\n+    write_ts_function_decl_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    write_ts_type_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_type_common_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n-    write_ts_type_non_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_type_non_common_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n-    write_ts_list_tree_pointers (ob, expr, ref_p);\n+    write_ts_list_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    write_ts_vec_tree_pointers (ob, expr, ref_p);\n+    write_ts_vec_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n-    write_ts_exp_tree_pointers (ob, expr, ref_p);\n+    write_ts_exp_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n-    write_ts_block_tree_pointers (ob, expr, ref_p);\n+    write_ts_block_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    write_ts_binfo_tree_pointers (ob, expr, ref_p);\n+    write_ts_binfo_tree_pointers (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n-    write_ts_constructor_tree_pointers (ob, expr, ref_p);\n+    write_ts_constructor_tree_pointers (ob, expr);\n \n   if (code == OMP_CLAUSE)\n-    write_ts_omp_clause_tree_pointers (ob, expr, ref_p);\n+    write_ts_omp_clause_tree_pointers (ob, expr);\n }\n \n \n@@ -1021,7 +1012,7 @@ streamer_write_tree_header (struct output_block *ob, tree expr)\n    CST's type will be emitted as a reference.  */\n \n void\n-streamer_write_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n+streamer_write_integer_cst (struct output_block *ob, tree cst)\n {\n   int i;\n   int len = TREE_INT_CST_NUNITS (cst);\n@@ -1033,7 +1024,7 @@ streamer_write_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n       fprintf (streamer_dump_file, \"\\n\");\n     }\n   streamer_write_record_start (ob, LTO_integer_cst);\n-  stream_write_tree (ob, TREE_TYPE (cst), ref_p);\n+  stream_write_tree_ref (ob, TREE_TYPE (cst));\n   /* We're effectively streaming a non-sign-extended wide_int here,\n      so there's no need to stream TREE_INT_CST_EXT_NUNITS or any\n      array members beyond LEN.  We'll recreate the tree from the"}, {"sha": "d40724237a1babf6470c722f04442817c4f4e585", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33e23881aae0549572cc23a2520c5094a2ffede9/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=33e23881aae0549572cc23a2520c5094a2ffede9", "patch": "@@ -59,7 +59,6 @@ struct streamer_tree_cache_d\n \n /* In tree-streamer-in.c.  */\n tree streamer_read_string_cst (class data_in *, class lto_input_block *);\n-tree streamer_read_chain (class lto_input_block *, class data_in *);\n tree streamer_alloc_tree (class lto_input_block *, class data_in *,\n \t\t          enum LTO_tags);\n void streamer_read_tree_body (class lto_input_block *, class data_in *, tree);\n@@ -70,11 +69,10 @@ void streamer_read_tree_bitfields (class lto_input_block *,\n /* In tree-streamer-out.c.  */\n void streamer_write_string_cst (struct output_block *,\n \t\t\t\tstruct lto_output_stream *, tree);\n-void streamer_write_chain (struct output_block *, tree, bool);\n void streamer_write_tree_header (struct output_block *, tree);\n void streamer_write_tree_bitfields (struct output_block *, tree);\n-void streamer_write_tree_body (struct output_block *, tree, bool);\n-void streamer_write_integer_cst (struct output_block *, tree, bool);\n+void streamer_write_tree_body (struct output_block *, tree);\n+void streamer_write_integer_cst (struct output_block *, tree);\n \n /* In tree-streamer.c.  */\n extern unsigned char streamer_mode_table[1 << 8];"}]}