{"sha": "f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBkYmUzNzI0NWVkNDc2MmRiZTZlYmI3ZDAwYzM0OWI0ZmI5MWRiMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-08T22:02:44Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-08T22:02:44Z"}, "message": "(expand_expr, MAX_EXPR and MIN_EXPR case):\n\nDon't store in TARGET twice if it's volatile.\n\nFrom-SVN: r5688", "tree": {"sha": "61f642345b64c22bbcf41342b024f406c3bda14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61f642345b64c22bbcf41342b024f406c3bda14d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2/comments", "author": null, "committer": null, "parents": [{"sha": "a851303047ec3886fc45c29780dd6643c101bfc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a851303047ec3886fc45c29780dd6643c101bfc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a851303047ec3886fc45c29780dd6643c101bfc2"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "b0dcba9d915763d8f0f16d45d64fcf6599b1070d", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f0dbe37245ed4762dbe6ebb7d00c349b4fb91db2", "patch": "@@ -5041,42 +5041,56 @@ expand_expr (exp, target, tmode, modifier)\n       if (temp != 0)\n \treturn temp;\n \n-      if (target != op0)\n-\temit_move_insn (target, op0);\n+      /* If TARGET is volatile, do the work into a pseudo,\n+\t then store it (just once!) into TARGET.  */\n+      subtarget = target;\n+      if (GET_CODE (subtarget) == MEM && MEM_VOLATILE_P (subtarget))\n+\tsubtarget = gen_rtx (GET_MODE (subtarget));\n+\n+      /* First, copy operand 0.  */\n+\n+      if (subtarget != op0)\n+\temit_move_insn (subtarget, op0);\n       op0 = gen_label_rtx ();\n+\n+      /* Then, if operand 1 is better, copy that.  */\n+\n       /* If this mode is an integer too wide to compare properly,\n \t compare word by word.  Rely on cse to optimize constant cases.  */\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && !can_compare_p (mode))\n \t{\n \t  if (code == MAX_EXPR)\n-\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), target, op1, NULL, op0);\n+\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), subtarget, op1, NULL, op0);\n \t  else\n-\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), op1, target, NULL, op0);\n-\t  emit_move_insn (target, op1);\n+\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), op1, subtarget, NULL, op0);\n+\t  emit_move_insn (subtarget, op1);\n \t}\n       else\n \t{\n \t  if (code == MAX_EXPR)\n \t    temp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t    ? compare_from_rtx (target, op1, GEU, 1, mode, NULL_RTX, 0)\n-\t\t    : compare_from_rtx (target, op1, GE, 0, mode, NULL_RTX, 0));\n+\t\t    ? compare_from_rtx (subtarget, op1, GEU, 1, mode, NULL_RTX, 0)\n+\t\t    : compare_from_rtx (subtarget, op1, GE, 0, mode, NULL_RTX, 0));\n \t  else\n \t    temp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t    ? compare_from_rtx (target, op1, LEU, 1, mode, NULL_RTX, 0)\n-\t\t    : compare_from_rtx (target, op1, LE, 0, mode, NULL_RTX, 0));\n+\t\t    ? compare_from_rtx (subtarget, op1, LEU, 1, mode, NULL_RTX, 0)\n+\t\t    : compare_from_rtx (subtarget, op1, LE, 0, mode, NULL_RTX, 0));\n \t  if (temp == const0_rtx)\n-\t    emit_move_insn (target, op1);\n+\t    emit_move_insn (subtarget, op1);\n \t  else if (temp != const_true_rtx)\n \t    {\n \t      if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n \t\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op0));\n \t      else\n \t\tabort ();\n-\t      emit_move_insn (target, op1);\n+\t      emit_move_insn (subtarget, op1);\n \t    }\n \t}\n       emit_label (op0);\n+      /* Store into the real target.  */\n+      if (target != subtarget)\n+\temit_move_insn (target, subtarget);\n       return target;\n \n /* ??? Can optimize when the operand of this is a bitwise operation,"}]}