{"sha": "b30f05db0126204d27f14419e1756886612cd0e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMwZjA1ZGIwMTI2MjA0ZDI3ZjE0NDE5ZTE3NTY4ODY2MTJjZDBlMA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-08-18T17:51:27Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-08-18T17:51:27Z"}, "message": "Combined compare & jump infrastructure\n\nFrom-SVN: r28752", "tree": {"sha": "83d8b1fdb52abb77c6634e2b955cb1f3dff5589e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83d8b1fdb52abb77c6634e2b955cb1f3dff5589e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b30f05db0126204d27f14419e1756886612cd0e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b30f05db0126204d27f14419e1756886612cd0e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b30f05db0126204d27f14419e1756886612cd0e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b30f05db0126204d27f14419e1756886612cd0e0/comments", "author": null, "committer": null, "parents": [{"sha": "9bb2199881bb29d538aa8a1c2b84703cf36784d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb2199881bb29d538aa8a1c2b84703cf36784d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb2199881bb29d538aa8a1c2b84703cf36784d9"}], "stats": {"total": 972, "additions": 490, "deletions": 482}, "files": [{"sha": "7cc2f1c46a931f443cebe807c56d3792bf9ed346", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -1,3 +1,49 @@\n+Wed Aug 18 18:20:40 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* expmed.c (emit_store_flag): If UNSIGNEDP, call unsigned_condition\n+\ton CODE.\n+\t(emit_store_flag_force): Use do_compare_rtx_and_jump.\n+\t(do_cmp_and_jump): Formatting fixes.\n+\t* expr.c (do_compare_and_jump): Renamed from compare; changed to call\n+\tdo_compare_rtx_and_jump instead of compare_from_rtx.\n+\t(do_compare_rtx_and_jump): New function; mostly copied from\n+\tcompare_from_rtx.\n+\t(do_jump_for_compare): Delete.\n+\t(expand_expr): Use do_compare_rtx_and_jump when handling MAX_EXPR and\n+\tMIN_EXPR.\n+\t(do_jump): Use do_compare_and_jump or do_compare_rtx_and_jump instead\n+\tof compare/do_jump_for_compare pairs.\n+\t(do_jump_by_parts_greater): Use do_jump_by_parts_greater_rtx.\n+\t(do_jump_by_parts_greater_rtx): Use do_compare_rtx_and_jump instead of\n+\tcompare_from_rtx/do_jump_for_compare pairs.\n+\t(do_jump_by_parts_equality): Likewise.\n+\t(do_jump_by_parts_equality_rtx): Likewise.\n+\t* expr.h (do_compare_rtx_and_jump): Declare.\n+\t* optabs.c (prepare_cmp_insn): New function, contains most of the code\n+\tthat used to be in emit_cmp_insn.\n+\t(cmp_available_p): New function.\n+\t(prepare_operand): New function.\n+\t(emit_cmp_and_jump_insn_1): New function, contains some code that used\n+\tto be in emit_cmp_insn.\n+\t(prepare_float_lib_cmp): Renamed from emit_float_lib_cmp; change some\n+\tparameters to be pointers; don't emit final compare but modify some of\n+\tthe values pointed to by the args so the caller can perform the\n+\tcorrect comparison.\n+\t(expand_binop): Call emit_store_flag_force with signed forms of\n+\tcomparison code.\n+\t(expand_abs): Use do_compare_rtx_and_jump instead of compare_from_rtx/\n+\temit_jump_insn pair.\n+\t(emit_cmp_and_jump_insn): Use prepare_cmp_insn and\n+\temit_cmp_and_jump_insn_1.  Call emit_queue.\n+\t(emit_cmp_insn): Just call emit_cmp_and_jump_insns with zero for LABEL\n+\targ.\n+\t* flow.c (tidy_fallthru_edge): If HAVE_cc0, verify insn before a\n+\tjump sets cc0 before deleting it.\n+\t* integrate.c (expand_inline_function): Likewise.\n+\t* unroll.c (unroll_loop): Similar changes in several places.\n+\t(copy_loop_body): If HAVE_cc0, verify insn before a jump sets cc0\n+\tbefore deleting it.\n+\n Wed Aug 18 06:37:44 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* Makefile.in (insn-recog.o): Update dependencies."}, {"sha": "b7e35af95ff8d3b3f95bfeafb6192468f88877b0", "filename": "gcc/expmed.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -4093,6 +4093,9 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n   rtx last = get_last_insn ();\n   rtx pattern, comparison;\n \n+  if (unsignedp)\n+    code = unsigned_condition (code);\n+\n   /* If one operand is constant, make it the second one.  Only do this\n      if the other operand is not constant as well.  */\n \n@@ -4492,15 +4495,10 @@ emit_store_flag_force (target, code, op0, op1, mode, unsignedp, normalizep)\n     target = gen_reg_rtx (GET_MODE (target));\n \n   emit_move_insn (target, const1_rtx);\n-  tem = compare_from_rtx (op0, op1, code, unsignedp, mode, NULL_RTX, 0);\n-  if (GET_CODE (tem) == CONST_INT)\n-    return tem;\n-\n   label = gen_label_rtx ();\n-  if (bcc_gen_fctn[(int) code] == 0)\n-    abort ();\n+  do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX, 0,\n+\t\t\t   NULL_RTX, label);\n \n-  emit_jump_insn ((*bcc_gen_fctn[(int) code]) (label));\n   emit_move_insn (target, const0_rtx);\n   emit_label (label);\n \n@@ -4519,13 +4517,13 @@ emit_store_flag_force (target, code, op0, op1, mode, unsignedp, normalizep)\n static void\n do_cmp_and_jump (arg1, arg2, op, mode, label)\n      rtx arg1, arg2, label;\n-    enum rtx_code op;\n-    enum machine_mode mode;\n+     enum rtx_code op;\n+     enum machine_mode mode;\n {\n   /* If this mode is an integer too wide to compare properly,\n      compare word by word.  Rely on cse to optimize constant cases.  */\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT && !can_compare_p (mode))\n+  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n     {\n       rtx label2 = gen_label_rtx ();\n "}, {"sha": "5ad38cda1d804312a590892248318c82f0520839", "filename": "gcc/expr.c", "status": "modified", "additions": 216, "deletions": 300, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -152,8 +152,7 @@ static rtx expand_increment\tPROTO((tree, int, int));\n static void preexpand_calls\tPROTO((tree));\n static void do_jump_by_parts_greater PROTO((tree, int, rtx, rtx));\n static void do_jump_by_parts_equality PROTO((tree, rtx, rtx));\n-static void do_jump_for_compare\tPROTO((rtx, rtx, rtx));\n-static rtx compare\t\tPROTO((tree, enum rtx_code, enum rtx_code));\n+static void do_compare_and_jump\tPROTO((tree, enum rtx_code, enum rtx_code, rtx, rtx));\n static rtx do_store_flag\tPROTO((tree, rtx, enum machine_mode, int));\n \n /* Record for each mode whether we can move a register directly to or\n@@ -7297,37 +7296,23 @@ expand_expr (exp, target, tmode, modifier)\n \n       /* If this mode is an integer too wide to compare properly,\n \t compare word by word.  Rely on cse to optimize constant cases.  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT && !can_compare_p (mode))\n+      if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n \t{\n \t  if (code == MAX_EXPR)\n \t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type),\n \t\t\t\t\t  target, op1, NULL_RTX, op0);\n \t  else\n \t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type),\n \t\t\t\t\t  op1, target, NULL_RTX, op0);\n-\t  emit_move_insn (target, op1);\n \t}\n       else\n \t{\n-\t  if (code == MAX_EXPR)\n-\t    temp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t    ? compare_from_rtx (target, op1, GEU, 1, mode, NULL_RTX, 0)\n-\t\t    : compare_from_rtx (target, op1, GE, 0, mode, NULL_RTX, 0));\n-\t  else\n-\t    temp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t    ? compare_from_rtx (target, op1, LEU, 1, mode, NULL_RTX, 0)\n-\t\t    : compare_from_rtx (target, op1, LE, 0, mode, NULL_RTX, 0));\n-\t  if (temp == const0_rtx)\n-\t    emit_move_insn (target, op1);\n-\t  else if (temp != const_true_rtx)\n-\t    {\n-\t      if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n-\t\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op0));\n-\t      else\n-\t\tabort ();\n-\t      emit_move_insn (target, op1);\n-\t    }\n+\t  int unsignedp = TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)));\n+\t  do_compare_rtx_and_jump (target, op1, code == MAX_EXPR ? GE : LE,\n+\t\t\t\t   unsignedp, mode, NULL_RTX, 0, NULL_RTX,\n+\t\t\t\t   op0);\n \t}\n+      emit_move_insn (target, op1);\n       emit_label (op0);\n       return target;\n \n@@ -8626,7 +8611,6 @@ do_jump (exp, if_false_label, if_true_label)\n      These cases set DROP_THROUGH_LABEL nonzero.  */\n   rtx drop_through_label = 0;\n   rtx temp;\n-  rtx comparison = 0;\n   int i;\n   tree type;\n   enum machine_mode mode;\n@@ -8692,10 +8676,10 @@ do_jump (exp, if_false_label, if_true_label)\n \n     case MINUS_EXPR:\n       /* Non-zero iff operands of minus differ.  */\n-      comparison = compare (build (NE_EXPR, TREE_TYPE (exp),\n-\t\t\t\t   TREE_OPERAND (exp, 0),\n-\t\t\t\t   TREE_OPERAND (exp, 1)),\n-\t\t\t    NE, NE);\n+      do_compare_and_jump (build (NE_EXPR, TREE_TYPE (exp),\n+\t\t\t\t  TREE_OPERAND (exp, 0),\n+\t\t\t\t  TREE_OPERAND (exp, 1)),\n+\t\t\t   NE, NE, if_false_label, if_true_label);\n       break;\n \n     case BIT_AND_EXPR:\n@@ -8854,7 +8838,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t\t && !can_compare_p (TYPE_MODE (inner_type)))\n \t  do_jump_by_parts_equality (exp, if_false_label, if_true_label);\n \telse\n-\t  comparison = compare (exp, EQ, EQ);\n+\t  do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label);\n \tbreak;\n       }\n \n@@ -8894,7 +8878,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t\t && !can_compare_p (TYPE_MODE (inner_type)))\n \t  do_jump_by_parts_equality (exp, if_true_label, if_false_label);\n \telse\n-\t  comparison = compare (exp, NE, NE);\n+\t  do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label);\n \tbreak;\n       }\n \n@@ -8904,7 +8888,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n \tdo_jump_by_parts_greater (exp, 1, if_false_label, if_true_label);\n       else\n-\tcomparison = compare (exp, LT, LTU);\n+\tdo_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label);\n       break;\n \n     case LE_EXPR:\n@@ -8913,7 +8897,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n \tdo_jump_by_parts_greater (exp, 0, if_true_label, if_false_label);\n       else\n-\tcomparison = compare (exp, LE, LEU);\n+\tdo_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label);\n       break;\n \n     case GT_EXPR:\n@@ -8922,7 +8906,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n \tdo_jump_by_parts_greater (exp, 0, if_false_label, if_true_label);\n       else\n-\tcomparison = compare (exp, GT, GTU);\n+\tdo_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label);\n       break;\n \n     case GE_EXPR:\n@@ -8931,7 +8915,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n \tdo_jump_by_parts_greater (exp, 1, if_true_label, if_false_label);\n       else\n-\tcomparison = compare (exp, GE, GEU);\n+\tdo_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label);\n       break;\n \n     default:\n@@ -8947,42 +8931,28 @@ do_jump (exp, if_false_label, if_true_label)\n \ttemp = copy_to_reg (temp);\n #endif\n       do_pending_stack_adjust ();\n-      if (GET_CODE (temp) == CONST_INT)\n-\tcomparison = (temp == const0_rtx ? const0_rtx : const_true_rtx);\n-      else if (GET_CODE (temp) == LABEL_REF)\n-\tcomparison = const_true_rtx;\n+      /* Do any postincrements in the expression that was tested.  */\n+      emit_queue ();\n+\n+      if (GET_CODE (temp) == CONST_INT || GET_CODE (temp) == LABEL_REF)\n+\t{\n+\t  rtx target = temp == const0_rtx ? if_false_label : if_true_label;\n+\t  if (target)\n+\t    emit_jump (target);\n+\t}\n       else if (GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT\n-\t       && !can_compare_p (GET_MODE (temp)))\n+\t       && ! can_compare_p (GET_MODE (temp)))\n \t/* Note swapping the labels gives us not-equal.  */\n \tdo_jump_by_parts_equality_rtx (temp, if_true_label, if_false_label);\n       else if (GET_MODE (temp) != VOIDmode)\n-\tcomparison = compare_from_rtx (temp, CONST0_RTX (GET_MODE (temp)),\n-\t\t\t\t       NE, TREE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t\t       GET_MODE (temp), NULL_RTX, 0);\n+\tdo_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),\n+\t\t\t\t NE, TREE_UNSIGNED (TREE_TYPE (exp)),\n+\t\t\t\t GET_MODE (temp), NULL_RTX, 0,\n+\t\t\t\t if_false_label, if_true_label);\n       else\n \tabort ();\n     }\n \n-  /* Do any postincrements in the expression that was tested.  */\n-  emit_queue ();\n-\n-  /* If COMPARISON is nonzero here, it is an rtx that can be substituted\n-     straight into a conditional jump instruction as the jump condition.\n-     Otherwise, all the work has been done already.  */\n-\n-  if (comparison == const_true_rtx)\n-    {\n-      if (if_true_label)\n-\temit_jump (if_true_label);\n-    }\n-  else if (comparison == const0_rtx)\n-    {\n-      if (if_false_label)\n-\temit_jump (if_false_label);\n-    }\n-  else if (comparison)\n-    do_jump_for_compare (comparison, if_false_label, if_true_label);\n-\n   if (drop_through_label)\n     {\n       /* If do_jump produces code that might be jumped around,\n@@ -9007,57 +8977,9 @@ do_jump_by_parts_greater (exp, swap, if_false_label, if_true_label)\n   rtx op0 = expand_expr (TREE_OPERAND (exp, swap), NULL_RTX, VOIDmode, 0);\n   rtx op1 = expand_expr (TREE_OPERAND (exp, !swap), NULL_RTX, VOIDmode, 0);\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-  int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n-  rtx drop_through_label = 0;\n   int unsignedp = TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-  int i;\n-\n-  if (! if_true_label || ! if_false_label)\n-    drop_through_label = gen_label_rtx ();\n-  if (! if_true_label)\n-    if_true_label = drop_through_label;\n-  if (! if_false_label)\n-    if_false_label = drop_through_label;\n \n-  /* Compare a word at a time, high order first.  */\n-  for (i = 0; i < nwords; i++)\n-    {\n-      rtx comp;\n-      rtx op0_word, op1_word;\n-\n-      if (WORDS_BIG_ENDIAN)\n-\t{\n-\t  op0_word = operand_subword_force (op0, i, mode);\n-\t  op1_word = operand_subword_force (op1, i, mode);\n-\t}\n-      else\n-\t{\n-\t  op0_word = operand_subword_force (op0, nwords - 1 - i, mode);\n-\t  op1_word = operand_subword_force (op1, nwords - 1 - i, mode);\n-\t}\n-\n-      /* All but high-order word must be compared as unsigned.  */\n-      comp = compare_from_rtx (op0_word, op1_word,\n-\t\t\t       (unsignedp || i > 0) ? GTU : GT,\n-\t\t\t       unsignedp, word_mode, NULL_RTX, 0);\n-      if (comp == const_true_rtx)\n-\temit_jump (if_true_label);\n-      else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, NULL_RTX, if_true_label);\n-\n-      /* Consider lower words only if these are equal.  */\n-      comp = compare_from_rtx (op0_word, op1_word, NE, unsignedp, word_mode,\n-\t\t\t       NULL_RTX, 0);\n-      if (comp == const_true_rtx)\n-\temit_jump (if_false_label);\n-      else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, NULL_RTX, if_false_label);\n-    }\n-\n-  if (if_false_label)\n-    emit_jump (if_false_label);\n-  if (drop_through_label)\n-    emit_label (drop_through_label);\n+  do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true_label);\n }\n \n /* Compare OP0 with OP1, word at a time, in mode MODE.\n@@ -9100,21 +9022,13 @@ do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true\n \t}\n \n       /* All but high-order word must be compared as unsigned.  */\n-      comp = compare_from_rtx (op0_word, op1_word,\n-\t\t\t       (unsignedp || i > 0) ? GTU : GT,\n-\t\t\t       unsignedp, word_mode, NULL_RTX, 0);\n-      if (comp == const_true_rtx)\n-\temit_jump (if_true_label);\n-      else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, NULL_RTX, if_true_label);\n+      do_compare_rtx_and_jump (op0_word, op1_word, GT,\n+\t\t\t       (unsignedp || i > 0), word_mode, NULL_RTX, 0,\n+\t\t\t       NULL_RTX, if_true_label);\n \n       /* Consider lower words only if these are equal.  */\n-      comp = compare_from_rtx (op0_word, op1_word, NE, unsignedp, word_mode,\n-\t\t\t       NULL_RTX, 0);\n-      if (comp == const_true_rtx)\n-\temit_jump (if_false_label);\n-      else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, NULL_RTX, if_false_label);\n+      do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,\n+\t\t\t       NULL_RTX, 0, NULL_RTX, if_false_label);\n     }\n \n   if (if_false_label)\n@@ -9142,16 +9056,11 @@ do_jump_by_parts_equality (exp, if_false_label, if_true_label)\n     drop_through_label = if_false_label = gen_label_rtx ();\n \n   for (i = 0; i < nwords; i++)\n-    {\n-      rtx comp = compare_from_rtx (operand_subword_force (op0, i, mode),\n-\t\t\t\t   operand_subword_force (op1, i, mode),\n-\t\t\t\t   EQ, TREE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t\t   word_mode, NULL_RTX, 0);\n-      if (comp == const_true_rtx)\n-\temit_jump (if_false_label);\n-      else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, if_false_label, NULL_RTX);\n-    }\n+    do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n+\t\t\t     operand_subword_force (op1, i, mode),\n+\t\t\t     EQ, TREE_UNSIGNED (TREE_TYPE (exp)),\n+\t\t\t     word_mode, NULL_RTX, 0, if_false_label,\n+\t\t\t     NULL_RTX);\n \n   if (if_true_label)\n     emit_jump (if_true_label);\n@@ -9187,15 +9096,8 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n \n   if (part != 0)\n     {\n-      rtx comp = compare_from_rtx (part, const0_rtx, EQ, 1, word_mode,\n-\t\t\t\t   NULL_RTX, 0);\n-\n-      if (comp == const_true_rtx)\n-\temit_jump (if_false_label);\n-      else if (comp == const0_rtx)\n-\temit_jump (if_true_label);\n-      else\n-\tdo_jump_for_compare (comp, if_false_label, if_true_label);\n+      do_compare_rtx_and_jump (part, const0_rtx, EQ, 1, word_mode,\n+\t\t\t       NULL_RTX, 0, if_false_label, if_true_label);\n \n       return;\n     }\n@@ -9205,184 +9107,94 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n     drop_through_label = if_false_label = gen_label_rtx ();\n \n   for (i = 0; i < nwords; i++)\n-    {\n-      rtx comp = compare_from_rtx (operand_subword_force (op0, i,\n-\t\t\t\t\t\t\t  GET_MODE (op0)),\n-\t\t\t\t   const0_rtx, EQ, 1, word_mode, NULL_RTX, 0);\n-      if (comp == const_true_rtx)\n-\temit_jump (if_false_label);\n-      else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, if_false_label, NULL_RTX);\n-    }\n+    do_compare_rtx_and_jump (operand_subword_force (op0, i, GET_MODE (op0)),\n+\t\t\t     const0_rtx, EQ, 1, word_mode, NULL_RTX, 0,\n+\t\t\t     if_false_label, NULL_RTX);\n \n   if (if_true_label)\n     emit_jump (if_true_label);\n \n   if (drop_through_label)\n     emit_label (drop_through_label);\n }\n-\n-/* Given a comparison expression in rtl form, output conditional branches to\n-   IF_TRUE_LABEL, IF_FALSE_LABEL, or both.  */\n-\n-static void\n-do_jump_for_compare (comparison, if_false_label, if_true_label)\n-     rtx comparison, if_false_label, if_true_label;\n-{\n-  if (if_true_label)\n-    {\n-      if (bcc_gen_fctn[(int) GET_CODE (comparison)] != 0)\n-\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (comparison)])\n-\t\t\t  (if_true_label));\n-      else\n-\tabort ();\n-\n-      if (if_false_label)\n-\temit_jump (if_false_label);\n-    }\n-  else if (if_false_label)\n-    {\n-      rtx first = get_last_insn (), insn, branch;\n-      int br_count;\n-\n-      /* Output the branch with the opposite condition.  Then try to invert\n-\t what is generated.  If more than one insn is a branch, or if the\n-\t branch is not the last insn written, abort. If we can't invert\n-\t the branch, emit make a true label, redirect this jump to that,\n-\t emit a jump to the false label and define the true label.  */\n-      /* ??? Note that we wouldn't have to do any of this nonsense if\n-\t we passed both labels into a combined compare-and-branch. \n-\t Ah well, jump threading does a good job of repairing the damage.  */\n-\n-      if (bcc_gen_fctn[(int) GET_CODE (comparison)] != 0)\n-\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (comparison)])\n-\t\t\t  (if_false_label));\n-      else\n-\tabort ();\n-\n-      /* Here we get the first insn that was just emitted.  It used to be the\n-\t case that, on some machines, emitting the branch would discard\n-\t the previous compare insn and emit a replacement.  This isn't\n-\t done anymore, but abort if we see that FIRST is deleted.  */\n-\n-      if (first == 0)\n-\tfirst = get_insns ();\n-      else if (INSN_DELETED_P (first))\n-\tabort ();\n-      else\n-\tfirst = NEXT_INSN (first);\n-\n-      /* Look for multiple branches in this sequence, as might be generated\n-\t for a multi-word integer comparison.  */\n-\n-      br_count = 0;\n-      branch = NULL_RTX;\n-      for (insn = first; insn ; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == JUMP_INSN)\n-\t  {\n-\t    branch = insn;\n-\t    br_count += 1;\n-\t  }\n-\n-      /* If we've got one branch at the end of the sequence,\n-\t we can try to reverse it.  */\n-\n-      if (br_count == 1 && NEXT_INSN (branch) == NULL_RTX)\n-\t{\n-\t  rtx insn_label;\n-\t  insn_label = XEXP (condjump_label (branch), 0);\n-\t  JUMP_LABEL (branch) = insn_label;\n-\n-\t  if (insn_label != if_false_label)\n-\t    abort ();\n-\n-\t  if (invert_jump (branch, if_false_label))\n-\t    return;\n-\t}\n-\n-      /* Multiple branches, or reversion failed.  Convert to branches\n-\t around an unconditional jump.  */\n-\n-      if_true_label = gen_label_rtx ();\n-      for (insn = first; insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == JUMP_INSN)\n-\t  {\n-\t    rtx insn_label;\n-\t    insn_label = XEXP (condjump_label (insn), 0);\n-\t    JUMP_LABEL (insn) = insn_label;\n-\n-\t    if (insn_label == if_false_label)\n-\t      redirect_jump (insn, if_true_label);\n-\t  }\n-\temit_jump (if_false_label);\n-\temit_label (if_true_label);\n-    }\n-}\n \f\n-/* Generate code for a comparison expression EXP\n+/* Generate code for a comparison of OP0 and OP1 with rtx code CODE.\n    (including code to compute the values to be compared)\n    and set (CC0) according to the result.\n-   SIGNED_CODE should be the rtx operation for this comparison for\n-   signed data; UNSIGNED_CODE, likewise for use if data is unsigned.\n+   The decision as to signed or unsigned comparison must be made by the caller.\n \n    We force a stack adjustment unless there are currently\n-   things pushed on the stack that aren't yet used.  */\n+   things pushed on the stack that aren't yet used.\n \n-static rtx\n-compare (exp, signed_code, unsigned_code)\n-     register tree exp;\n-     enum rtx_code signed_code, unsigned_code;\n+   If MODE is BLKmode, SIZE is an RTX giving the size of the objects being\n+   compared.\n+\n+   If ALIGN is non-zero, it is the alignment of this type; if zero, the\n+   size of MODE should be used.  */\n+\n+rtx\n+compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n+     register rtx op0, op1;\n+     enum rtx_code code;\n+     int unsignedp;\n+     enum machine_mode mode;\n+     rtx size;\n+     int align;\n {\n-  register rtx op0, op1;\n-  register tree type;\n-  register enum machine_mode mode;\n-  int unsignedp;\n-  enum rtx_code code;\n+  rtx tem;\n \n-  /* Don't crash if the comparison was erroneous.  */\n-  op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n-  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ERROR_MARK)\n-    return op0;\n-  \n-  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n-  type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-  mode = TYPE_MODE (type);\n-  unsignedp = TREE_UNSIGNED (type);\n-  code = unsignedp ? unsigned_code : signed_code;\n+  /* If one operand is constant, make it the second one.  Only do this\n+     if the other operand is not constant as well.  */\n \n-#ifdef HAVE_canonicalize_funcptr_for_compare\n-  /* If function pointers need to be \"canonicalized\" before they can\n-     be reliably compared, then canonicalize them.  */\n-  if (HAVE_canonicalize_funcptr_for_compare\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n-      && (TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t  == FUNCTION_TYPE))\n+  if ((CONSTANT_P (op0) && ! CONSTANT_P (op1))\n+      || (GET_CODE (op0) == CONST_INT && GET_CODE (op1) != CONST_INT))\n     {\n-      rtx new_op0 = gen_reg_rtx (mode);\n-\n-      emit_insn (gen_canonicalize_funcptr_for_compare (new_op0, op0));\n-      op0 = new_op0;\n+      tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n+      code = swap_condition (code);\n     }\n \n-  if (HAVE_canonicalize_funcptr_for_compare\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 1))) == POINTER_TYPE\n-      && (TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 1))))\n-\t  == FUNCTION_TYPE))\n+  if (flag_force_mem)\n     {\n-      rtx new_op1 = gen_reg_rtx (mode);\n+      op0 = force_not_mem (op0);\n+      op1 = force_not_mem (op1);\n+    }\n \n-      emit_insn (gen_canonicalize_funcptr_for_compare (new_op1, op1));\n-      op1 = new_op1;\n+  do_pending_stack_adjust ();\n+\n+  if (GET_CODE (op0) == CONST_INT && GET_CODE (op1) == CONST_INT\n+      && (tem = simplify_relational_operation (code, mode, op0, op1)) != 0)\n+    return tem;\n+\n+#if 0\n+  /* There's no need to do this now that combine.c can eliminate lots of\n+     sign extensions.  This can be less efficient in certain cases on other\n+     machines.  */\n+\n+  /* If this is a signed equality comparison, we can do it as an\n+     unsigned comparison since zero-extension is cheaper than sign\n+     extension and comparisons with zero are done as unsigned.  This is\n+     the case even on machines that can do fast sign extension, since\n+     zero-extension is easier to combine with other operations than\n+     sign-extension is.  If we are comparing against a constant, we must\n+     convert it to what it would look like unsigned.  */\n+  if ((code == EQ || code == NE) && ! unsignedp\n+      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      if (GET_CODE (op1) == CONST_INT\n+\t  && (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1))\n+\top1 = GEN_INT (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0)));\n+      unsignedp = 1;\n     }\n #endif\n+\t\n+  emit_cmp_insn (op0, op1, code, size, mode, unsignedp, align);\n \n-  return compare_from_rtx (op0, op1, code, unsignedp, mode,\n-\t\t\t   ((mode == BLKmode)\n-\t\t\t    ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),\n-\t\t\t   TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);\n+  return gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n }\n \n-/* Like compare but expects the values to compare as two rtx's.\n+/* Like do_compare_and_jump but expects the values to compare as two rtx's.\n    The decision as to signed or unsigned comparison must be made by the caller.\n \n    If MODE is BLKmode, SIZE is an RTX giving the size of the objects being\n@@ -9391,16 +9203,28 @@ compare (exp, signed_code, unsigned_code)\n    If ALIGN is non-zero, it is the alignment of this type; if zero, the\n    size of MODE should be used.  */\n \n-rtx\n-compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n+void\n+do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size, align,\n+\t\t\t if_false_label, if_true_label)\n      register rtx op0, op1;\n      enum rtx_code code;\n      int unsignedp;\n      enum machine_mode mode;\n      rtx size;\n      int align;\n+     rtx if_false_label, if_true_label;\n {\n   rtx tem;\n+  int dummy_true_label = 0;\n+\n+  /* Reverse the comparison if that is safe and we want to jump if it is\n+     false.  */\n+  if (! if_true_label && ! FLOAT_MODE_P (mode))\n+    {\n+      if_true_label = if_false_label;\n+      if_false_label = 0;\n+      code = reverse_condition (code);\n+    }\n \n   /* If one operand is constant, make it the second one.  Only do this\n      if the other operand is not constant as well.  */\n@@ -9424,7 +9248,19 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n \n   if (GET_CODE (op0) == CONST_INT && GET_CODE (op1) == CONST_INT\n       && (tem = simplify_relational_operation (code, mode, op0, op1)) != 0)\n-    return tem;\n+    {\n+      if (tem == const_true_rtx)\n+\t{\n+\t  if (if_true_label)\n+\t    emit_jump (if_true_label);\n+\t}\n+      else\n+\t{\n+\t  if (if_false_label)\n+\t    emit_jump (if_false_label);\n+\t}\n+      return;\n+    }\n \n #if 0\n   /* There's no need to do this now that combine.c can eliminate lots of\n@@ -9447,10 +9283,90 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n       unsignedp = 1;\n     }\n #endif\n-\t\n-  emit_cmp_insn (op0, op1, code, size, mode, unsignedp, align);\n \n-  return gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n+  if (! if_true_label)\n+    {\n+      dummy_true_label = 1;\n+      if_true_label = gen_label_rtx ();\n+    }\n+\n+  emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp, align,\n+\t\t\t   if_true_label);\n+\n+  if (if_false_label)\n+    emit_jump (if_false_label);\n+  if (dummy_true_label)\n+    emit_label (if_true_label);\n+}\n+\n+/* Generate code for a comparison expression EXP (including code to compute\n+   the values to be compared) and a conditional jump to IF_FALSE_LABEL and/or\n+   IF_TRUE_LABEL.  One of the labels can be NULL_RTX, in which case the\n+   generated code will drop through.\n+   SIGNED_CODE should be the rtx operation for this comparison for\n+   signed data; UNSIGNED_CODE, likewise for use if data is unsigned.\n+\n+   We force a stack adjustment unless there are currently\n+   things pushed on the stack that aren't yet used.  */\n+\n+static void\n+do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n+\t\t     if_true_label)\n+     register tree exp;\n+     enum rtx_code signed_code, unsigned_code;\n+     rtx if_false_label, if_true_label;\n+{\n+  register rtx op0, op1;\n+  register tree type;\n+  register enum machine_mode mode;\n+  int unsignedp;\n+  enum rtx_code code;\n+\n+  /* Don't crash if the comparison was erroneous.  */\n+  op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ERROR_MARK)\n+    return;\n+\n+  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n+  type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+  mode = TYPE_MODE (type);\n+  unsignedp = TREE_UNSIGNED (type);\n+  code = unsignedp ? unsigned_code : signed_code;\n+\n+#ifdef HAVE_canonicalize_funcptr_for_compare\n+  /* If function pointers need to be \"canonicalized\" before they can\n+     be reliably compared, then canonicalize them.  */\n+  if (HAVE_canonicalize_funcptr_for_compare\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n+      && (TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\t  == FUNCTION_TYPE))\n+    {\n+      rtx new_op0 = gen_reg_rtx (mode);\n+\n+      emit_insn (gen_canonicalize_funcptr_for_compare (new_op0, op0));\n+      op0 = new_op0;\n+    }\n+\n+  if (HAVE_canonicalize_funcptr_for_compare\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 1))) == POINTER_TYPE\n+      && (TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 1))))\n+\t  == FUNCTION_TYPE))\n+    {\n+      rtx new_op1 = gen_reg_rtx (mode);\n+\n+      emit_insn (gen_canonicalize_funcptr_for_compare (new_op1, op1));\n+      op1 = new_op1;\n+    }\n+#endif\n+\n+  /* Do any postincrements in the expression that was tested.  */\n+  emit_queue ();\n+\n+  do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,\n+\t\t\t   ((mode == BLKmode)\n+\t\t\t    ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),\n+\t\t\t   TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT,\n+\t\t\t   if_false_label, if_true_label);\n }\n \f\n /* Generate code to calculate EXP using a store-flag instruction"}, {"sha": "b3fbaeada939c919bb728152db0c550b0b92293c", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -801,6 +801,9 @@ extern void do_jump PROTO((tree, rtx, rtx));\n /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n extern rtx compare_from_rtx PROTO((rtx, rtx, enum rtx_code, int,\n \t\t\t\t   enum machine_mode, rtx, int));\n+extern void do_compare_rtx_and_jump PROTO((rtx, rtx, enum rtx_code, int,\n+\t\t\t\t\t   enum machine_mode, rtx, int,\n+\t\t\t\t\t   rtx, rtx));\n \n /* Generate a tablejump instruction (used for switch statements).  */\n extern void do_tablejump PROTO((rtx, enum machine_mode, rtx, rtx, rtx));"}, {"sha": "c7ffe78aac8f78362f9d881a45fd0dd16033ae16", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -1998,7 +1998,7 @@ tidy_fallthru_edge (e, b, c)\n #ifdef HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n \t the insn that set cc0.  */\n-      if (! simplejump_p (q) && condjump_p (q))\n+      if (! simplejump_p (q) && condjump_p (q) && sets_cc0_p (PREV_INSN (q)))\n \tq = PREV_INSN (q);\n #endif\n "}, {"sha": "af7f9d2786522b4abde96d5c0e1d3c6ea317fdf9", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -1958,8 +1958,9 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  if (condjump_p (insn) && ! simplejump_p (insn) && map->last_pc_value)\n \t    {\n #ifdef HAVE_cc0\n-\t      /* The previous insn set cc0 for us.  So delete it.  */\n-\t      delete_insn (PREV_INSN (copy));\n+\t      /* If the previous insn set cc0 for us, delete it.  */\n+\t      if (sets_cc0_p (PREV_INSN (copy)))\n+\t\tdelete_insn (PREV_INSN (copy));\n #endif\n \n \t      /* If this is now a no-op, delete it.  */"}, {"sha": "2de77e52f46ec658c7ef79326cb95f11fd4ef7bd", "filename": "gcc/optabs.c", "status": "modified", "additions": 184, "deletions": 129, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -267,6 +267,15 @@ static void init_floating_libfuncs PROTO((optab, const char *, int));\n #ifdef HAVE_conditional_trap\n static void init_traps PROTO((void));\n #endif\n+static int cmp_available_p PROTO((enum machine_mode, enum rtx_code, int));\n+static void emit_cmp_and_jump_insn_1 PROTO((rtx, rtx, enum machine_mode,\n+\t\t\t\t\t    enum rtx_code, int, rtx));\n+static void prepare_cmp_insn PROTO((rtx *, rtx *, enum rtx_code, rtx,\n+\t\t\t\t    enum machine_mode *, int *, int));\n+static rtx prepare_operand PROTO((int, rtx, int, enum machine_mode,\n+\t\t\t\t  enum machine_mode, int));\n+static void prepare_float_lib_cmp PROTO((rtx *, rtx *, enum rtx_code,\n+\t\t\t\t\t enum machine_mode *, int *));\n \f\n /* Add a REG_EQUAL note to the last insn in SEQ.  TARGET is being set to\n    the result of operation CODE applied to OP0 (and OP1 if it is a binary\n@@ -1326,7 +1335,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      carry_out = gen_reg_rtx (word_mode);\n \t      carry_out = emit_store_flag_force (carry_out,\n \t\t\t\t\t\t (binoptab == add_optab\n-\t\t\t\t\t\t  ? LTU : GTU),\n+\t\t\t\t\t\t  ? LT : GT),\n \t\t\t\t\t\t x, op0_piece,\n \t\t\t\t\t\t word_mode, 1, normalizep);\n \t    }\n@@ -1349,7 +1358,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t  /* Get out carry from adding/subtracting carry in.  */\n \t\t  carry_tmp = emit_store_flag_force (carry_tmp,\n \t\t\t\t\t\t     binoptab == add_optab\n-\t\t\t\t\t\t     ? LTU : GTU,\n+\t\t\t\t\t\t     ? LT : GT,\n \t\t\t\t\t\t     x, carry_in,\n \t\t\t\t\t\t     word_mode, 1, normalizep);\n \n@@ -2463,19 +2472,8 @@ expand_abs (mode, op0, target, safe)\n     do_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx, \n \t\t\t\t  NULL_RTX, op1);\n   else\n-    {\n-      temp = compare_from_rtx (target, CONST0_RTX (mode), GE, 0, mode,\n-\t\t\t       NULL_RTX, 0);\n-      if (temp == const1_rtx)\n-\treturn target;\n-      else if (temp != const0_rtx)\n-\t{\n-\t  if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n-\t    emit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op1));\n-\t  else\n-\t    abort ();\n-\t}\n-    }\n+    do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n+\t\t\t     NULL_RTX, 0, NULL_RTX, op1);\n \n   op0 = expand_unop (mode, neg_optab, target, target, 0);\n   if (op0 != target)\n@@ -2983,31 +2981,57 @@ emit_0_to_1_insn (x)\n   emit_move_insn (x, const1_rtx);\n }\n \n-/* Generate code to compare X with Y\n-   so that the condition codes are set.\n+/* Nonzero if we can perform a comparison of mode MODE for a conditional jump\n+   straightforwardly.  */\n \n-   MODE is the mode of the inputs (in case they are const_int).\n-   UNSIGNEDP nonzero says that X and Y are unsigned;\n+static int\n+cmp_available_p (mode, code, can_use_tst_p)\n+     enum machine_mode mode;\n+     enum rtx_code code;\n+     int can_use_tst_p;\n+{\n+  do\n+    {\n+      if (cmp_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing\n+\t  || (can_use_tst_p\n+\t      && tst_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing))\n+\treturn 1;\n+      mode = GET_MODE_WIDER_MODE (mode);\n+    } while (mode != VOIDmode);\n+\n+  return 0;\n+}\n+\n+/* This function is called when we are going to emit a compare instruction that\n+   compares the values found in *PX and *PY, using the rtl operator COMPARISON.\n+\n+   *PMODE is the mode of the inputs (in case they are const_int).\n+   *PUNSIGNEDP nonzero says that the operands are unsigned;\n    this matters if they need to be widened.\n \n-   If they have mode BLKmode, then SIZE specifies the size of both X and Y,\n-   and ALIGN specifies the known shared alignment of X and Y.\n+   If they have mode BLKmode, then SIZE specifies the size of both operands,\n+   and ALIGN specifies the known shared alignment of the operands.\n \n-   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n-   It is ignored for fixed-point and block comparisons;\n-   it is used only for floating-point comparisons.  */\n+   This function performs all the setup necessary so that the caller only has\n+   to emit a single comparison insn.  This setup can involve doing a BLKmode\n+   comparison or emitting a library call to perform the comparison if no insn\n+   is available to handle it.\n+   The values which are passed in through pointers can be modified; the caller\n+   should perform the comparison on the modified values.  */\n \n void\n-emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n-     rtx x, y;\n+prepare_cmp_insn (px, py, comparison, size, pmode, punsignedp, align)\n+     rtx *px, *py;\n      enum rtx_code comparison;\n      rtx size;\n-     enum machine_mode mode;\n-     int unsignedp;\n+     enum machine_mode *pmode;\n+     int *punsignedp;\n      int align;\n {\n+  enum machine_mode mode = *pmode;\n+  rtx x = *px, y = *py;\n+  int unsignedp = *punsignedp;\n   enum mode_class class;\n-  enum machine_mode wider_mode;\n \n   class = GET_MODE_CLASS (mode);\n \n@@ -3046,6 +3070,9 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \n   if (mode == BLKmode)\n     {\n+      rtx result;\n+      enum machine_mode result_mode;\n+\n       emit_queue ();\n       x = protect_from_queue (x, 0);\n       y = protect_from_queue (y, 0);\n@@ -3057,12 +3084,9 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t  && GET_CODE (size) == CONST_INT\n \t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (QImode)))\n \t{\n-\t  enum machine_mode result_mode\n-\t    = insn_operand_mode[(int) CODE_FOR_cmpstrqi][0];\n-\t  rtx result = gen_reg_rtx (result_mode);\n+\t  result_mode = insn_operand_mode[(int) CODE_FOR_cmpstrqi][0];\n+\t  result = gen_reg_rtx (result_mode);\n \t  emit_insn (gen_cmpstrqi (result, x, y, size, GEN_INT (align)));\n-\t  emit_cmp_insn (result, const0_rtx, comparison, NULL_RTX,\n-\t\t\t result_mode, 0, 0);\n \t}\n       else\n #endif\n@@ -3071,33 +3095,25 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t  && GET_CODE (size) == CONST_INT\n \t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (HImode)))\n \t{\n-\t  enum machine_mode result_mode\n-\t    = insn_operand_mode[(int) CODE_FOR_cmpstrhi][0];\n-\t  rtx result = gen_reg_rtx (result_mode);\n+\t  result_mode = insn_operand_mode[(int) CODE_FOR_cmpstrhi][0];\n+\t  result = gen_reg_rtx (result_mode);\n \t  emit_insn (gen_cmpstrhi (result, x, y, size, GEN_INT (align)));\n-\t  emit_cmp_insn (result, const0_rtx, comparison, NULL_RTX,\n-\t\t\t result_mode, 0, 0);\n \t}\n       else\n #endif\n #ifdef HAVE_cmpstrsi\n       if (HAVE_cmpstrsi)\n \t{\n-\t  enum machine_mode result_mode\n-\t    = insn_operand_mode[(int) CODE_FOR_cmpstrsi][0];\n-\t  rtx result = gen_reg_rtx (result_mode);\n+\t  result_mode = insn_operand_mode[(int) CODE_FOR_cmpstrsi][0];\n+\t  result = gen_reg_rtx (result_mode);\n \t  size = protect_from_queue (size, 0);\n \t  emit_insn (gen_cmpstrsi (result, x, y,\n \t\t\t\t   convert_to_mode (SImode, size, 1),\n \t\t\t\t   GEN_INT (align)));\n-\t  emit_cmp_insn (result, const0_rtx, comparison, NULL_RTX,\n-\t\t\t result_mode, 0, 0);\n \t}\n       else\n #endif\n \t{\n-\t  rtx result;\n-\n #ifdef TARGET_MEM_FUNCTIONS\n \t  emit_library_call (memcmp_libfunc, 0,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n@@ -3119,83 +3135,24 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t     register so reload doesn't clobber the value if it needs\n \t     the return register for a spill reg.  */\n \t  result = gen_reg_rtx (TYPE_MODE (integer_type_node));\n+\t  result_mode = TYPE_MODE (integer_type_node);\n \t  emit_move_insn (result,\n-\t\t\t  hard_libcall_value (TYPE_MODE (integer_type_node)));\n-\t  emit_cmp_insn (result,\n-\t\t\t const0_rtx, comparison, NULL_RTX,\n-\t\t\t TYPE_MODE (integer_type_node), 0, 0);\n+\t\t\t  hard_libcall_value (result_mode));\n \t}\n+      *px = result;\n+      *py = const0_rtx;\n+      *pmode = result_mode;\n       return;\n     }\n \n-  /* Handle some compares against zero.  */\n-\n-  if (y == CONST0_RTX (mode)\n-      && tst_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n-    {\n-      int icode = (int) tst_optab->handlers[(int) mode].insn_code;\n-\n-      emit_queue ();\n-      x = protect_from_queue (x, 0);\n-      y = protect_from_queue (y, 0);\n-\n-      /* Now, if insn does accept these operands, put them into pseudos.  */\n-      if (! (*insn_operand_predicate[icode][0])\n-\t  (x, insn_operand_mode[icode][0]))\n-\tx = copy_to_mode_reg (insn_operand_mode[icode][0], x);\n-\n-      emit_insn (GEN_FCN (icode) (x));\n-      return;\n-    }\n-\n-  /* Handle compares for which there is a directly suitable insn.  */\n-\n-  if (cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n-    {\n-      int icode = (int) cmp_optab->handlers[(int) mode].insn_code;\n-\n-      emit_queue ();\n-      x = protect_from_queue (x, 0);\n-      y = protect_from_queue (y, 0);\n-\n-      /* Now, if insn doesn't accept these operands, put them into pseudos.  */\n-      if (! (*insn_operand_predicate[icode][0])\n-\t  (x, insn_operand_mode[icode][0]))\n-\tx = copy_to_mode_reg (insn_operand_mode[icode][0], x);\n-\n-      if (! (*insn_operand_predicate[icode][1])\n-\t  (y, insn_operand_mode[icode][1]))\n-\ty = copy_to_mode_reg (insn_operand_mode[icode][1], y);\n-\n-      emit_insn (GEN_FCN (icode) (x, y));\n-      return;\n-    }\n-\n-  /* Try widening if we can find a direct insn that way.  */\n-\n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n-    {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-\t{\n-\t  if (cmp_optab->handlers[(int) wider_mode].insn_code\n-\t      != CODE_FOR_nothing)\n-\t    {\n-\t      x = protect_from_queue (x, 0);\n-\t      y = protect_from_queue (y, 0);\n-\t      x = convert_modes (wider_mode, mode, x, unsignedp);\n-\t      y = convert_modes (wider_mode, mode, y, unsignedp);\n-\t      emit_cmp_insn (x, y, comparison, NULL_RTX,\n-\t\t\t     wider_mode, unsignedp, align);\n-\t      return;\n-\t    }\n-\t}\n-    }\n+  *px = x;\n+  *py = y;\n+  if (cmp_available_p (mode, comparison, y == CONST0_RTX (mode)))\n+    return;\n \n   /* Handle a lib call just for the mode we are using.  */\n \n-  if (cmp_optab->handlers[(int) mode].libfunc\n-      && class != MODE_FLOAT)\n+  if (cmp_optab->handlers[(int) mode].libfunc && class != MODE_FLOAT)\n     {\n       rtx libfunc = cmp_optab->handlers[(int) mode].libfunc;\n       rtx result;\n@@ -3217,18 +3174,99 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n       /* Integer comparison returns a result that must be compared against 1,\n \t so that even if we do an unsigned compare afterward,\n \t there is still a value that can represent the result \"less than\".  */\n-      emit_cmp_insn (result, const1_rtx,\n-\t\t     comparison, NULL_RTX, word_mode, unsignedp, 0);\n+      *px = result;\n+      *py = const1_rtx;\n+      *pmode = word_mode;\n       return;\n     }\n \n   if (class == MODE_FLOAT)\n-    emit_float_lib_cmp (x, y, comparison);\n+    prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp);\n \n   else\n     abort ();\n }\n \n+/* Before emitting an insn with code ICODE, make sure that X, which is going\n+   to be used for operand OPNUM of the insn, is converted from mode MODE to\n+   WIDER_MODE (UNSIGNEDP determines whether it is a unsigned conversion), and\n+   that it is accepted by the operand predicate.  Return the new value.  */\n+static rtx\n+prepare_operand (icode, x, opnum, mode, wider_mode, unsignedp)\n+     int icode;\n+     rtx x;\n+     int opnum;\n+     enum machine_mode mode, wider_mode;\n+     int unsignedp;\n+{\n+  x = protect_from_queue (x, 0);\n+\n+  if (mode != wider_mode)\n+    x = convert_modes (wider_mode, mode, x, unsignedp);\n+\n+  if (! (*insn_operand_predicate[icode][opnum])\n+      (x, insn_operand_mode[icode][opnum]))\n+    x = copy_to_mode_reg (insn_operand_mode[icode][opnum], x);\n+  return x;\n+}\n+\n+/* Subroutine of emit_cmp_and_jump_insns; this function is called when we know\n+   we can do the comparison.\n+   The arguments are the same as for emit_cmp_and_jump_insns; but LABEL may\n+   be NULL_RTX which indicates that only a comparison is to be generated.  */\n+\n+static void\n+emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n+     rtx x, y;\n+     enum machine_mode mode;\n+     enum rtx_code comparison;\n+     int unsignedp;\n+     rtx label;\n+{\n+  rtx test = gen_rtx_fmt_ee (comparison, mode, x, y);\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum machine_mode wider_mode = mode;\n+\n+  /* Try combined insns first.  */\n+  do\n+    {\n+      enum insn_code icode;\n+      PUT_MODE (test, wider_mode);\n+\n+      /* Handle some compares against zero.  */\n+      icode = (int) tst_optab->handlers[(int) wider_mode].insn_code;\n+      if (y == CONST0_RTX (mode) && icode != CODE_FOR_nothing)\n+\t{\n+\t  x = prepare_operand (icode, x, 0, mode, wider_mode, unsignedp);\n+\t  emit_insn (GEN_FCN (icode) (x));\n+\t  if (label)\n+\t    emit_jump_insn ((*bcc_gen_fctn[(int) comparison]) (label));\n+\t  return;\n+\t}\n+\n+      /* Handle compares for which there is a directly suitable insn.  */\n+\n+      icode = (int) cmp_optab->handlers[(int) wider_mode].insn_code;\n+      if (icode != CODE_FOR_nothing)\n+\t{\n+\t  x = prepare_operand (icode, x, 0, mode, wider_mode, unsignedp);\n+\t  y = prepare_operand (icode, y, 1, mode, wider_mode, unsignedp);\n+\t  emit_insn (GEN_FCN (icode) (x, y));\n+\t  if (label)\n+\t    emit_jump_insn ((*bcc_gen_fctn[(int) comparison]) (label));\n+\t  return;\n+\t}\n+\n+      if (class != MODE_INT && class != MODE_FLOAT\n+\t  && class != MODE_COMPLEX_FLOAT)\n+\tbreak;\n+\n+      wider_mode = GET_MODE_WIDER_MODE (wider_mode);\n+    } while (wider_mode != VOIDmode);\n+\n+  abort ();\n+}\n+\n /* Generate code to compare X with Y so that the condition codes are\n    set and to jump to LABEL if the condition is true.  If X is a\n    constant and Y is not a constant, then the comparison is swapped to\n@@ -3281,11 +3319,24 @@ emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n     op0 = force_reg (mode, op0);\n #endif\n \n-  emit_cmp_insn (op0, op1, comparison, size, mode, unsignedp, align);\n-\n+  emit_queue ();\n   if (unsignedp)\n     comparison = unsigned_condition (comparison);\n-  emit_jump_insn ((*bcc_gen_fctn[(int) comparison]) (label));\n+  prepare_cmp_insn (&op0, &op1, comparison, size, &mode, &unsignedp, align);\n+  emit_cmp_and_jump_insn_1 (op0, op1, mode, comparison, unsignedp, label);\n+}\n+\n+/* Like emit_cmp_and_jump_insns, but generate only the comparison.  */\n+void\n+emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n+     rtx x, y;\n+     enum rtx_code comparison;\n+     rtx size;\n+     enum machine_mode mode;\n+     int unsignedp;\n+     int align;\n+{\n+  emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, 0);\n }\n \n \n@@ -3310,10 +3361,13 @@ can_compare_p (mode)\n    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */\n \n void\n-emit_float_lib_cmp (x, y, comparison)\n-     rtx x, y;\n+prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp)\n+     rtx *px, *py;\n      enum rtx_code comparison;\n+     enum machine_mode *pmode;\n+     int *punsignedp;\n {\n+  rtx x = *px, y = *py;\n   enum machine_mode mode = GET_MODE (x);\n   rtx libfunc = 0;\n   rtx result;\n@@ -3481,9 +3535,9 @@ emit_float_lib_cmp (x, y, comparison)\n \t    {\n \t      x = protect_from_queue (x, 0);\n \t      y = protect_from_queue (y, 0);\n-\t      x = convert_to_mode (wider_mode, x, 0);\n-\t      y = convert_to_mode (wider_mode, y, 0);\n-\t      emit_float_lib_cmp (x, y, comparison);\n+\t      *px = convert_to_mode (wider_mode, x, 0);\n+\t      *py = convert_to_mode (wider_mode, y, 0);\n+\t      prepare_float_lib_cmp (px, py, comparison, pmode, punsignedp);\n \t      return;\n \t    }\n \t}\n@@ -3501,9 +3555,10 @@ emit_float_lib_cmp (x, y, comparison)\n      the return register for a spill reg.  */\n   result = gen_reg_rtx (word_mode);\n   emit_move_insn (result, hard_libcall_value (word_mode));\n-\n-  emit_cmp_insn (result, const0_rtx, comparison,\n-\t\t NULL_RTX, word_mode, 0, 0);\n+  *px = result;\n+  *py = const0_rtx;\n+  *pmode = word_mode;\n+  *punsignedp = 0;\n }\n \f\n /* Generate code to indirectly jump to a location given in the rtx LOC.  */"}, {"sha": "8bfd6b7aef02c02394c18210e45528f003cd23dc", "filename": "gcc/unroll.c", "status": "modified", "additions": 29, "deletions": 40, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b30f05db0126204d27f14419e1756886612cd0e0/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=b30f05db0126204d27f14419e1756886612cd0e0", "patch": "@@ -339,15 +339,13 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t}\n       else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n \t{\n+\t  rtx prev = PREV_INSN (last_loop_insn);\n+\t  delete_insn (last_loop_insn);\n #ifdef HAVE_cc0\n-\t  /* The immediately preceding insn is a compare which must be\n+\t  /* The immediately preceding insn may be a compare which must be\n \t     deleted.  */\n-\t  delete_insn (last_loop_insn);\n-\t  delete_insn (PREV_INSN (last_loop_insn));\n-#else\n-\t  /* The immediately preceding insn may not be the compare, so don't\n-\t     delete it.  */\n-\t  delete_insn (last_loop_insn);\n+\t  if (sets_cc0_p (prev))\n+\t    delete_insn (prev);\n #endif\n \t}\n       return;\n@@ -479,14 +477,12 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \tcopy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n       else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n \t{\n+\t  copy_end = PREV_INSN (last_loop_insn);\n #ifdef HAVE_cc0\n-\t  /* The instruction immediately before the JUMP_INSN is a compare\n+\t  /* The instruction immediately before the JUMP_INSN may be a compare\n \t     instruction which we do not want to copy.  */\n-\t  copy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n-#else\n-\t  /* The instruction immediately before the JUMP_INSN may not be the\n-\t     compare, so we must copy it.  */\n-\t  copy_end = PREV_INSN (last_loop_insn);\n+\t  if (sets_cc0_p (PREV_INSN (copy_end)))\n+\t    copy_end = PREV_INSN (copy_end);\n #endif\n \t}\n       else\n@@ -520,17 +516,14 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t}\n       else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n \t{\n+\t  insert_before = last_loop_insn;\n #ifdef HAVE_cc0\n-\t  /* The instruction immediately before the JUMP_INSN is a compare\n+\t  /* The instruction immediately before the JUMP_INSN may be a compare\n \t     instruction which we do not want to copy or delete.  */\n-\t  insert_before = PREV_INSN (last_loop_insn);\n-\t  copy_end = PREV_INSN (insert_before);\n-#else\n-\t  /* The instruction immediately before the JUMP_INSN may not be the\n-\t     compare, so we must copy it.  */\n-\t  insert_before = last_loop_insn;\n-\t  copy_end = PREV_INSN (last_loop_insn);\n+\t  if (sets_cc0_p (PREV_INSN (insert_before)))\n+\t    insert_before = PREV_INSN (insert_before);\n #endif\n+\t  copy_end = PREV_INSN (insert_before);\n \t}\n       else\n \t{\n@@ -793,9 +786,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \tcopy_end_luid--;\n \n       /* If we have a target that uses cc0, then we also must not duplicate\n-\t the insn that sets cc0 before the jump insn.  */\n+\t the insn that sets cc0 before the jump insn, if one is present.  */\n #ifdef HAVE_cc0\n-      if (GET_CODE (copy_end) == JUMP_INSN)\n+      if (GET_CODE (copy_end) == JUMP_INSN && sets_cc0_p (PREV_INSN (copy_end)))\n \tcopy_end_luid--;\n #endif\n \n@@ -1036,14 +1029,12 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t    copy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n \t  else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n \t    {\n+\t      copy_end = PREV_INSN (last_loop_insn);\n #ifdef HAVE_cc0\n-\t      /* The immediately preceding insn is a compare which we do not\n+\t      /* The immediately preceding insn may be a compare which we do not\n \t\t want to copy.  */\n-\t      copy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n-#else\n-\t      /* The immediately preceding insn may not be a compare, so we\n-\t\t must copy it.  */\n-\t      copy_end = PREV_INSN (last_loop_insn);\n+\t      if (sets_cc0_p (PREV_INSN (copy_end)))\n+\t\tcopy_end = PREV_INSN (copy_end);\n #endif\n \t    }\n \t  else\n@@ -1098,17 +1089,14 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t    }\n \t  else\n \t    {\n-#ifdef HAVE_cc0\n-\t      /* The immediately preceding insn is a compare which we do not\n-\t\t want to copy.  */\n-\t      insert_before = PREV_INSN (last_loop_insn);\n-\t      copy_end = PREV_INSN (insert_before);\n-#else\n-\t      /* The immediately preceding insn may not be a compare, so we\n-\t\t must copy it.  */\n \t      insert_before = last_loop_insn;\n-\t      copy_end = PREV_INSN (last_loop_insn);\n+#ifdef HAVE_cc0\n+\t      /* The instruction immediately before the JUMP_INSN may be a compare\n+\t\t instruction which we do not want to copy or delete.  */\n+\t      if (sets_cc0_p (PREV_INSN (insert_before)))\n+\t\tinsert_before = PREV_INSN (insert_before);\n #endif\n+\t      copy_end = PREV_INSN (insert_before);\n \t    }\n \n \t  /* Set unroll type to MODULO now.  */\n@@ -2089,8 +2077,9 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  if (condjump_p (insn) && !simplejump_p (insn) && map->last_pc_value)\n \t    {\n #ifdef HAVE_cc0\n-\t      /* The previous insn set cc0 for us.  So delete it.  */\n-\t      delete_insn (PREV_INSN (copy));\n+\t      /* If the previous insn set cc0 for us, delete it.  */\n+\t      if (sets_cc0_p (PREV_INSN (copy)))\n+\t\tdelete_insn (PREV_INSN (copy));\n #endif\n \n \t      /* If this is now a no-op, delete it.  */"}]}