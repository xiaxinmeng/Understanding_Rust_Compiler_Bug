{"sha": "23f0ecff4a6e9c554e4ddddf59d022e632810a72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNmMGVjZmY0YTZlOWM1NTRlNGRkZGRmNTlkMDIyZTYzMjgxMGE3Mg==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-04-20T11:13:09Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-04-20T11:13:09Z"}, "message": "[multiple changes]\n\n2004-04-20  Ingo Proetel  <proetel@aicas.com>\n\n\t* java/awt/FontMetrics.java:\n\t(charsWidth): fixed accumulation of total_width\n\t(getWidth): simple default implementation\n\t* java/awt/Polygon.java (getBoundingBox): Use correct y-coordinate\n\tin Rectangle constructor.\n\t* java/awt/image/Raster.java (toString): Added method.\n\t* java/awt/image/SampleModel.java (<init>): Added error cause\n\tinformation to thrown exception.\n\t* java/awt/image/SinglePixelPackedSampleModel.java (getDataElements):\n\tNew method.\n\t(setDataElements): New method.\n\t(setPixels): New method.\n\t(toString): New method.\n\n2004-04-20  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/image/ComponentColorModel.java\n\t(createCompatibleSampleModel): Return PixelInterleavedSampleModel\n\tfor TYPE_BYTE and TYPE_USHORT transferTypes, in order to pass the\n\tMauve tests on this method. Improved documentation.\n\nFrom-SVN: r80894", "tree": {"sha": "3d1d46584dcbc5ef07de3e01050fdd01c2d9563e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d1d46584dcbc5ef07de3e01050fdd01c2d9563e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23f0ecff4a6e9c554e4ddddf59d022e632810a72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23f0ecff4a6e9c554e4ddddf59d022e632810a72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23f0ecff4a6e9c554e4ddddf59d022e632810a72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23f0ecff4a6e9c554e4ddddf59d022e632810a72/comments", "author": null, "committer": null, "parents": [{"sha": "2c4d54e6d07a0b3aab74c0a5bafe55f49dabb86d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4d54e6d07a0b3aab74c0a5bafe55f49dabb86d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c4d54e6d07a0b3aab74c0a5bafe55f49dabb86d"}], "stats": {"total": 278, "additions": 260, "deletions": 18}, "files": [{"sha": "17017de7ae56f064a042506f2be8b7d01479e638", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=23f0ecff4a6e9c554e4ddddf59d022e632810a72", "patch": "@@ -1,3 +1,26 @@\n+2004-04-20  Ingo Proetel  <proetel@aicas.com>\n+\n+\t* java/awt/FontMetrics.java:\n+\t(charsWidth): fixed accumulation of total_width\n+\t(getWidth): simple default implementation\n+\t* java/awt/Polygon.java (getBoundingBox): Use correct y-coordinate\n+\tin Rectangle constructor.\n+\t* java/awt/image/Raster.java (toString): Added method. \n+\t* java/awt/image/SampleModel.java (<init>): Added error cause\n+\tinformation to thrown exception.\n+\t* java/awt/image/SinglePixelPackedSampleModel.java (getDataElements):\n+\tNew method.\n+\t(setDataElements): New method.\n+\t(setPixels): New method.\n+\t(toString): New method.\n+\n+2004-04-20  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/image/ComponentColorModel.java\n+\t(createCompatibleSampleModel): Return PixelInterleavedSampleModel\n+\tfor TYPE_BYTE and TYPE_USHORT transferTypes, in order to pass the\n+\tMauve tests on this method. Improved documentation.\n+\n 2004-04-20  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/swing/JLayeredPane.java,"}, {"sha": "cb76f507909e613ce2a6eb57d7c3516404d2827d", "filename": "libjava/java/awt/FontMetrics.java", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2FFontMetrics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2FFontMetrics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFontMetrics.java?ref=23f0ecff4a6e9c554e4ddddf59d022e632810a72", "patch": "@@ -292,8 +292,7 @@ public abstract class FontMetrics implements java.io.Serializable\n {\n   int total_width = 0;\n   for (int i = offset; i < len; i++)\n-    total_width = charWidth(buf[i]);\n-\n+    total_width += charWidth(buf[i]);\n   return(total_width);\n }\n \n@@ -328,7 +327,12 @@ public abstract class FontMetrics implements java.io.Serializable\n public int[]\n getWidths()\n {\n-  return(new int[256]);\n+  int [] result = new int[256];\n+  for(char i = 0; i < 256; i++)\n+  {\n+    result[i]= charWidth(i);\n+  }\n+  return(result);\n }\n \n /*************************************************************************/\n@@ -347,3 +351,4 @@ public abstract class FontMetrics implements java.io.Serializable\n \n } // class FontMetrics \n \n+"}, {"sha": "96c370aafc145e5e771c16a5174ce55df88b743e", "filename": "libjava/java/awt/Polygon.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2FPolygon.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2FPolygon.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPolygon.java?ref=23f0ecff4a6e9c554e4ddddf59d022e632810a72", "patch": "@@ -294,7 +294,7 @@ else if (x > maxx)\n             else if (y > maxy)\n               maxy = y;\n           }\n-        bounds = new Rectangle (minx, maxy, maxx - minx, maxy - miny);\n+        bounds = new Rectangle (minx, miny, maxx - minx, maxy - miny);\n       }\n     return bounds;\n   }"}, {"sha": "24d8b8ea685741eda71f2fc284989aef2f5d80ab", "filename": "libjava/java/awt/image/ComponentColorModel.java", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FComponentColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FComponentColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FComponentColorModel.java?ref=23f0ecff4a6e9c554e4ddddf59d022e632810a72", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000, 2002  Free Software Foundation\n+/* Copyright (C) 2000, 2002, 2004  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -292,19 +292,56 @@ public WritableRaster createCompatibleWritableRaster(int w, int h)\n     return Raster.createWritableRaster(sm, origin);\n   }\n \n+\n+  /**\n+   * Creates a <code>SampleModel</code> whose arrangement of pixel\n+   * data is compatible to this <code>ColorModel</code>.\n+   *\n+   * @param w the number of pixels in the horizontal direction.\n+   * @param h the number of pixels in the vertical direction.\n+   */\n   public SampleModel createCompatibleSampleModel(int w, int h)\n   {\n-    int pixelStride = getNumComponents();\n-    \n-    /* TODO: Maybe we don't need to create a new offset array each\n-       time, but rather use the same array every time. */\n-    int[] bandOffsets = new int[pixelStride];\n-    for (int i=0; i<pixelStride; i++) bandOffsets[i] = i;\n-    return new ComponentSampleModel(transferType, w, h,\n-\t\t\t\t    pixelStride, pixelStride*w,\n-\t\t\t\t    bandOffsets);\n+    int pixelStride, scanlineStride;\n+    int[] bandOffsets;\n+\n+    pixelStride = getNumComponents();\n+    scanlineStride = pixelStride * w;\n+\n+    /* We might be able to re-use the same bandOffsets array among\n+     * multiple calls to this method. However, this optimization does\n+     * not seem worthwile because setting up descriptive data\n+     * structures (such as SampleModels) is neglectible in comparision\n+     * to shuffling around masses of pixel data.\n+     */\n+    bandOffsets = new int[pixelStride];\n+    for (int i = 0; i < pixelStride; i++)\n+      bandOffsets[i] = i;\n+\n+    /* FIXME: Think about whether it would make sense to return the\n+     * possibly more efficient PixelInterleavedSampleModel for other\n+     * transferTypes as well. It seems unlikely that this would break\n+     * any user applications, so the Mauve tests on this method\n+     * might be too restrictive.\n+     */\n+    switch (transferType)\n+      {\n+      case DataBuffer.TYPE_BYTE:\n+      case DataBuffer.TYPE_USHORT:\n+        return new PixelInterleavedSampleModel(transferType, w, h,\n+                                               pixelStride,\n+                                               scanlineStride,\n+                                               bandOffsets);\n+\n+      default:\n+        return new ComponentSampleModel(transferType, w, h,\n+                                        pixelStride,\n+                                        scanlineStride,\n+                                        bandOffsets);\n+      }\n   }\n \n+\n   public boolean isCompatibleSampleModel(SampleModel sm)\n   {\n     return "}, {"sha": "4fd194e2a9eb93e30eb922dc98b8db58cc9b55dc", "filename": "libjava/java/awt/image/Raster.java", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FRaster.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FRaster.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FRaster.java?ref=23f0ecff4a6e9c554e4ddddf59d022e632810a72", "patch": "@@ -452,4 +452,25 @@ public double[] getSamples(int x, int y, int w, int h, int b,\n \t\t\t\t  y-sampleModelTranslateY,\n \t\t\t\t  w, h, b, dArray, dataBuffer);\n   }\n+  \n+  /**\n+   * Create a String representing the stat of this Raster.\n+   * @return A String representing the stat of this Raster.\n+   * @see java.lang.Object#toString()\n+   */\n+  public String toString()\n+  {\n+    StringBuffer result = new StringBuffer();\n+    \n+    result.append(getClass().getName());\n+    result.append(\"[(\");\n+    result.append(minX).append(\",\").append(minY).append(\"), \");\n+    result.append(width).append(\" x \").append(height).append(\",\");\n+    result.append(sampleModel).append(\",\");\n+    result.append(dataBuffer);\n+    result.append(\"]\");\n+    \n+    return result.toString();\n+  }\n+  \n }"}, {"sha": "a5d65ff20feae6e800d0ad7a4dffa7607bf5903f", "filename": "libjava/java/awt/image/SampleModel.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FSampleModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FSampleModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FSampleModel.java?ref=23f0ecff4a6e9c554e4ddddf59d022e632810a72", "patch": "@@ -58,7 +58,9 @@\n \n   public SampleModel(int dataType, int w, int h, int numBands)\n   {\n-    if ((w<=0) || (h<=0)) throw new IllegalArgumentException();\n+    if ((w <= 0) || (h <= 0)) \n+      throw new IllegalArgumentException((w <= 0 ? \" width<=0\" : \" width is ok\")\n+                                         +(h <= 0 ? \" height<=0\" : \" height is ok\"));\n \t\n     // FIXME: How can an int be greater than Integer.MAX_VALUE?\n     // FIXME: How do we identify an unsupported data type?\n@@ -68,7 +70,7 @@ public SampleModel(int dataType, int w, int h, int numBands)\n     this.height = h;\n     this.numBands = numBands;  \n   }\n-\n+  \n   public final int getWidth()\n   {\n     return width;"}, {"sha": "578500dbd0a53179ead3d246565f0577c82ab34c", "filename": "libjava/java/awt/image/SinglePixelPackedSampleModel.java", "status": "modified", "additions": 156, "deletions": 2, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f0ecff4a6e9c554e4ddddf59d022e632810a72/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java?ref=23f0ecff4a6e9c554e4ddddf59d022e632810a72", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 2000, 2002, 2003, 2004  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -162,6 +162,63 @@ public Object getDataElements(int x, int y, Object obj,\n \t\t\t   1  // length\n \t\t\t   );\n   }\n+  \n+  /**\n+   * This is a more efficient implementation of the default implementation in the super\n+   * class. \n+   * @param x The x-coordinate of the pixel rectangle to store in <code>obj</code>.\n+   * @param y The y-coordinate of the pixel rectangle to store in <code>obj</code>.\n+   * @param w The width of the pixel rectangle to store in <code>obj</code>.\n+   * @param h The height of the pixel rectangle to store in <code>obj</code>.\n+   * @param obj The primitive array to store the pixels into or null to force creation.\n+   * @param data The DataBuffer that is the source of the pixel data.\n+   * @return The primitive array containing the pixel data.\n+   * @see java.awt.image.SampleModel#getDataElements(int, int, int, int, java.lang.Object, java.awt.image.DataBuffer)\n+   */\n+  public Object getDataElements(int x, int y, int w, int h, Object obj,\n+\t\t\t\t\t\t\tDataBuffer data)\n+  {\n+    int size = w*h;\n+    int dataSize = size;\n+    Object pixelData = null;\n+    switch (getTransferType())\n+    {\n+      case DataBuffer.TYPE_BYTE:\n+        pixelData = ((DataBufferByte) data).getData();\n+        if (obj == null) obj = new byte[dataSize];\n+        break;\n+       case DataBuffer.TYPE_USHORT:\n+         pixelData = ((DataBufferUShort) data).getData();\n+         if (obj == null) obj = new short[dataSize];\n+         break;\n+        case DataBuffer.TYPE_INT:\n+          pixelData = ((DataBufferInt) data).getData();\n+          if (obj == null) obj = new int[dataSize];\n+          break;\n+         default:\n+             // Seems like the only sensible thing to do.\n+           throw new ClassCastException();\n+      }\n+      if(x==0 && scanlineStride == w)\n+      { \n+        // The full width need to be copied therefore we can copy in one shot.\n+        System.arraycopy(pixelData, scanlineStride*y + data.getOffset(), obj, 0, size);\n+      }\n+      else\n+      {  \n+        // Since we do not need the full width we need to copy line by line.\n+        int outOffset = 0;\n+        int dataOffset = scanlineStride*y + x + data.getOffset();\n+        for (int yy = y; yy<(y+h); yy++)\n+        {\n+          System.arraycopy(pixelData, dataOffset, obj, outOffset, w);\n+          dataOffset += scanlineStride;\n+          outOffset += w;\n+        }\n+      }\n+    return obj;\n+  }\n+  \n \n   public int[] getPixel(int x, int y, int[] iArray, DataBuffer data)\n   {\n@@ -201,7 +258,51 @@ public int getSample(int x, int y, int b, DataBuffer data)\n     int samples = data.getElem(offset);\n     return (samples & bitMasks[b]) >>> bitOffsets[b];\n   }\n-\n+  \n+  /**\n+   * This method implements a more efficient way to set data elements than the default\n+   * implementation of the super class. It sets the data elements line by line instead \n+   * of pixel by pixel.\n+   * @param x The x-coordinate of the data elements in <code>obj</code>.\n+   * @param y The y-coordinate of the data elements in <code>obj</code>.\n+   * @param w The width of the data elements in <code>obj</code>.\n+   * @param h The height of the data elements in <code>obj</code>.\n+   * @param obj The primitive array containing the data elements to set.\n+   * @param data The DataBuffer to store the data elements into.\n+   * @see java.awt.image.SampleModel#setDataElements(int, int, int, int, java.lang.Object, java.awt.image.DataBuffer)\n+   */\n+  public void setDataElements(int x, int y, int w, int h,\n+\t\t\t\tObject obj, DataBuffer data)\n+  {\n+    \n+    Object pixelData;\n+    switch (getTransferType())\n+    {\n+      case DataBuffer.TYPE_BYTE:\n+        pixelData = ((DataBufferByte) data).getData();\n+        break;\n+       case DataBuffer.TYPE_USHORT:\n+         pixelData = ((DataBufferUShort) data).getData();\n+         break;\n+       case DataBuffer.TYPE_INT:\n+         pixelData = ((DataBufferInt) data).getData();\n+         break;\n+       default:\n+          // Seems like the only sensible thing to do.\n+          throw new ClassCastException();\n+    }\n+    \n+    int inOffset = 0;\n+    int dataOffset = scanlineStride*y + x + data.getOffset();\n+    for (int yy=y; yy<(y+h); yy++)\n+    {\n+      System.arraycopy(obj,inOffset,pixelData,dataOffset,w);\n+      dataOffset += scanlineStride;\n+      inOffset += w;\n+    }\n+  }\n+  \n+  \n   public void setDataElements(int x, int y, Object obj, DataBuffer data)\n   {\n     int offset = scanlineStride*y + x + data.getOffset();\n@@ -273,6 +374,39 @@ public void setPixel(int x, int y, int[] iArray, DataBuffer data)\n     data.setElem(offset, samples);\n   }\n \n+  /**\n+   * This method implements a more efficient way to set pixels than the default\n+   * implementation of the super class. It copies the pixel components directly\n+   * from the input array instead of creating a intermediate buffer.\n+   * @param x The x-coordinate of the pixel rectangle in <code>obj</code>.\n+   * @param y The y-coordinate of the pixel rectangle in <code>obj</code>.\n+   * @param w The width of the pixel rectangle in <code>obj</code>.\n+   * @param h The height of the pixel rectangle in <code>obj</code>.\n+   * @param obj The primitive array containing the pixels to set.\n+   * @param data The DataBuffer to store the pixels into.\n+   * @see java.awt.image.SampleModel#setPixels(int, int, int, int, int[], java.awt.image.DataBuffer)\n+   */\n+  public void setPixels(int x, int y, int w, int h, int[] iArray,\n+\t\t\t\t\t\tDataBuffer data)\n+  {\n+    int inOffset = 0;\n+    int[] pixel = new int[numBands];\n+    for (int yy=y; yy<(y+h); yy++)\n+     {\n+      int offset = scanlineStride*yy + x;\n+      for (int xx=x; xx<(x+w); xx++)\n+       { \n+        int samples = 0;\n+        for (int b=0; b<numBands; b++)\n+          samples |= (iArray[inOffset+b] << bitOffsets[b]) & bitMasks[b];\n+        data.setElem(0, offset, samples);\n+        inOffset += numBands;\n+        offset += 1;\n+      }\n+    }\n+  }\n+  \n+  \n   public void setSample(int x, int y, int b, int s, DataBuffer data)\n   {\n     int offset = scanlineStride*y + x;\n@@ -282,4 +416,24 @@ public void setSample(int x, int y, int b, int s, DataBuffer data)\n     samples |= (s << bitOffsets[b]) & bitMask;\n     data.setElem(offset, samples);\n   }\n+  \n+  /**\n+   * Creates a String with some information about this SampleModel.\n+   * @return A String describing this SampleModel.\n+   * @see java.lang.Object#toString()\n+   */\n+  public String toString()\n+  {\n+    StringBuffer result = new StringBuffer();\n+    result.append(getClass().getName());\n+    result.append(\"[\");\n+    result.append(\"scanlineStride=\").append(scanlineStride);\n+    for(int i=0; i < bitMasks.length; i+=1)\n+    {\n+      result.append(\", mask[\").append(i).append(\"]=0x\").append(Integer.toHexString(bitMasks[i]));\n+    }\n+    \n+    result.append(\"]\");\n+    return result.toString();\n+  }\n }"}]}