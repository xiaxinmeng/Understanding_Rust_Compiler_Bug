{"sha": "3eb90047bc582186f2214ba3b7055f8707f811f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ViOTAwNDdiYzU4MjE4NmYyMjE0YmEzYjcwNTVmODcwN2Y4MTFmNA==", "commit": {"author": {"name": "Jeff Johnston", "email": "jjohnstn@redhat.com", "date": "2001-07-11T00:10:28Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2001-07-11T00:10:28Z"}, "message": "xregex.h: New file to support libiberty regex.\n\n* xregex.h: New file to support libiberty regex.\n* xregex2.h: Ditto.\n\nFrom-SVN: r43913", "tree": {"sha": "67eb8b50ad17e25f60b031fec4e3a8fd324fa7b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67eb8b50ad17e25f60b031fec4e3a8fd324fa7b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3eb90047bc582186f2214ba3b7055f8707f811f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb90047bc582186f2214ba3b7055f8707f811f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb90047bc582186f2214ba3b7055f8707f811f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb90047bc582186f2214ba3b7055f8707f811f4/comments", "author": {"login": "jjohnstn", "id": 1216877, "node_id": "MDQ6VXNlcjEyMTY4Nzc=", "avatar_url": "https://avatars.githubusercontent.com/u/1216877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjohnstn", "html_url": "https://github.com/jjohnstn", "followers_url": "https://api.github.com/users/jjohnstn/followers", "following_url": "https://api.github.com/users/jjohnstn/following{/other_user}", "gists_url": "https://api.github.com/users/jjohnstn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjohnstn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjohnstn/subscriptions", "organizations_url": "https://api.github.com/users/jjohnstn/orgs", "repos_url": "https://api.github.com/users/jjohnstn/repos", "events_url": "https://api.github.com/users/jjohnstn/events{/privacy}", "received_events_url": "https://api.github.com/users/jjohnstn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07217645f7ab36e65d91ff5ab0d8778ba9f924b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07217645f7ab36e65d91ff5ab0d8778ba9f924b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07217645f7ab36e65d91ff5ab0d8778ba9f924b5"}], "stats": {"total": 595, "additions": 595, "deletions": 0}, "files": [{"sha": "096599e7827b71dc7fef9c330f20267a47b6ed11", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb90047bc582186f2214ba3b7055f8707f811f4/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb90047bc582186f2214ba3b7055f8707f811f4/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=3eb90047bc582186f2214ba3b7055f8707f811f4", "patch": "@@ -1,3 +1,8 @@\n+2001-07-10  Jeff Johnston  <jjohnstn@redhat.com>\n+\n+\t* xregex.h: New file to support libiberty regex.\n+\t* xregex2.h: Ditto.\n+\n 2001-05-16  Matt Kraai  <kraai@alumni.carnegiemellon.edu>\n \n \t* partition.h: Fix misspelling of `implementation'."}, {"sha": "694fd166f1080139e3d2a3625d8aebfd147c302a", "filename": "include/xregex.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb90047bc582186f2214ba3b7055f8707f811f4/include%2Fxregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb90047bc582186f2214ba3b7055f8707f811f4/include%2Fxregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fxregex.h?ref=3eb90047bc582186f2214ba3b7055f8707f811f4", "patch": "@@ -0,0 +1,24 @@\n+/* This file redefines all regex external names before including\n+   a renamed copy of glibc's regex.h.  */\n+\n+#ifndef _XREGEX_H\n+#define _XREGEX_H 1\n+\n+#  define regfree xregfree \n+#  define regexec xregexec\n+#  define regcomp xregcomp\n+#  define regerror xregerror\n+#  define re_set_registers xre_set_registers\n+#  define re_match_2 xre_match_2\n+#  define re_match xre_match\n+#  define re_search xre_search\n+#  define re_compile_pattern xre_compile_pattern\n+#  define re_set_syntax xre_set_syntax\n+#  define re_search_2 xre_search_2\n+#  define re_compile_fastmap xre_compile_fastmap\n+#  define re_syntax_options xre_syntax_options\n+#  define re_max_failures xre_max_failures\n+\n+#include \"xregex2.h\"\n+\n+#endif /* xregex.h */"}, {"sha": "63c2fef6967b2c87a68eeefd79e7abd444d05382", "filename": "include/xregex2.h", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb90047bc582186f2214ba3b7055f8707f811f4/include%2Fxregex2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb90047bc582186f2214ba3b7055f8707f811f4/include%2Fxregex2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fxregex2.h?ref=3eb90047bc582186f2214ba3b7055f8707f811f4", "patch": "@@ -0,0 +1,566 @@\n+/* Definitions for data structures and routines for the regular\n+   expression library, version 0.12.\n+   Copyright (C) 1985,1989-1993,1995-1998, 2000 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU C Library.  Its master source is NOT part of\n+   the C library, however.  The master source lives in /gd/gnu/lib.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _REGEX_H\n+#define _REGEX_H 1\n+\n+/* Allow the use in C++ code.  */\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* POSIX says that <sys/types.h> must be included (by the caller) before\n+   <regex.h>.  */\n+\n+#if !defined _POSIX_C_SOURCE && !defined _POSIX_SOURCE && defined VMS\n+/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it\n+   should be there.  */\n+# include <stddef.h>\n+#endif\n+\n+/* The following two types have to be signed and unsigned integer type\n+   wide enough to hold a value of a pointer.  For most ANSI compilers\n+   ptrdiff_t and size_t should be likely OK.  Still size of these two\n+   types is 2 for Microsoft C.  Ugh... */\n+typedef long int s_reg_t;\n+typedef unsigned long int active_reg_t;\n+\n+/* The following bits are used to determine the regexp syntax we\n+   recognize.  The set/not-set meanings are chosen so that Emacs syntax\n+   remains the value 0.  The bits are given in alphabetical order, and\n+   the definitions shifted by one from the previous bit; thus, when we\n+   add or remove a bit, only one other definition need change.  */\n+typedef unsigned long int reg_syntax_t;\n+\n+/* If this bit is not set, then \\ inside a bracket expression is literal.\n+   If set, then such a \\ quotes the following character.  */\n+#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)\n+\n+/* If this bit is not set, then + and ? are operators, and \\+ and \\? are\n+     literals.\n+   If set, then \\+ and \\? are operators and + and ? are literals.  */\n+#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)\n+\n+/* If this bit is set, then character classes are supported.  They are:\n+     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],\n+     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].\n+   If not set, then character classes are not supported.  */\n+#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)\n+\n+/* If this bit is set, then ^ and $ are always anchors (outside bracket\n+     expressions, of course).\n+   If this bit is not set, then it depends:\n+        ^  is an anchor if it is at the beginning of a regular\n+           expression or after an open-group or an alternation operator;\n+        $  is an anchor if it is at the end of a regular expression, or\n+           before a close-group or an alternation operator.\n+\n+   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because\n+   POSIX draft 11.2 says that * etc. in leading positions is undefined.\n+   We already implemented a previous draft which made those constructs\n+   invalid, though, so we haven't changed the code back.  */\n+#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)\n+\n+/* If this bit is set, then special characters are always special\n+     regardless of where they are in the pattern.\n+   If this bit is not set, then special characters are special only in\n+     some contexts; otherwise they are ordinary.  Specifically,\n+     * + ? and intervals are only special when not after the beginning,\n+     open-group, or alternation operator.  */\n+#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)\n+\n+/* If this bit is set, then *, +, ?, and { cannot be first in an re or\n+     immediately after an alternation or begin-group operator.  */\n+#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)\n+\n+/* If this bit is set, then . matches newline.\n+   If not set, then it doesn't.  */\n+#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)\n+\n+/* If this bit is set, then . doesn't match NUL.\n+   If not set, then it does.  */\n+#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)\n+\n+/* If this bit is set, nonmatching lists [^...] do not match newline.\n+   If not set, they do.  */\n+#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)\n+\n+/* If this bit is set, either \\{...\\} or {...} defines an\n+     interval, depending on RE_NO_BK_BRACES.\n+   If not set, \\{, \\}, {, and } are literals.  */\n+#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)\n+\n+/* If this bit is set, +, ? and | aren't recognized as operators.\n+   If not set, they are.  */\n+#define RE_LIMITED_OPS (RE_INTERVALS << 1)\n+\n+/* If this bit is set, newline is an alternation operator.\n+   If not set, newline is literal.  */\n+#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)\n+\n+/* If this bit is set, then `{...}' defines an interval, and \\{ and \\}\n+     are literals.\n+  If not set, then `\\{...\\}' defines an interval.  */\n+#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)\n+\n+/* If this bit is set, (...) defines a group, and \\( and \\) are literals.\n+   If not set, \\(...\\) defines a group, and ( and ) are literals.  */\n+#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)\n+\n+/* If this bit is set, then \\<digit> matches <digit>.\n+   If not set, then \\<digit> is a back-reference.  */\n+#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)\n+\n+/* If this bit is set, then | is an alternation operator, and \\| is literal.\n+   If not set, then \\| is an alternation operator, and | is literal.  */\n+#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)\n+\n+/* If this bit is set, then an ending range point collating higher\n+     than the starting range point, as in [z-a], is invalid.\n+   If not set, then when ending range point collates higher than the\n+     starting range point, the range is ignored.  */\n+#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)\n+\n+/* If this bit is set, then an unmatched ) is ordinary.\n+   If not set, then an unmatched ) is invalid.  */\n+#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)\n+\n+/* If this bit is set, succeed as soon as we match the whole pattern,\n+   without further backtracking.  */\n+#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)\n+\n+/* If this bit is set, do not process the GNU regex operators.\n+   If not set, then the GNU regex operators are recognized. */\n+#define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)\n+\n+/* If this bit is set, turn on internal regex debugging.\n+   If not set, and debugging was on, turn it off.\n+   This only works if regex.c is compiled -DDEBUG.\n+   We define this bit always, so that all that's needed to turn on\n+   debugging is to recompile regex.c; the calling code can always have\n+   this bit set, and it won't affect anything in the normal case. */\n+#define RE_DEBUG (RE_NO_GNU_OPS << 1)\n+\n+/* If this bit is set, a syntactically invalid interval is treated as\n+   a string of ordinary characters.  For example, the ERE 'a{1' is\n+   treated as 'a\\{1'.  */\n+#define RE_INVALID_INTERVAL_ORD (RE_DEBUG << 1)\n+\n+/* This global variable defines the particular regexp syntax to use (for\n+   some interfaces).  When a regexp is compiled, the syntax used is\n+   stored in the pattern buffer, so changing this does not affect\n+   already-compiled regexps.  */\n+extern reg_syntax_t re_syntax_options;\n+\f\n+/* Define combinations of the above bits for the standard possibilities.\n+   (The [[[ comments delimit what gets put into the Texinfo file, so\n+   don't delete them!)  */\n+/* [[[begin syntaxes]]] */\n+#define RE_SYNTAX_EMACS 0\n+\n+#define RE_SYNTAX_AWK\t\t\t\t\t\t\t\\\n+  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL\t\t\t\\\n+   | RE_NO_BK_PARENS              | RE_NO_BK_REFS\t\t\t\\\n+   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES\t\t\t\\\n+   | RE_DOT_NEWLINE\t\t  | RE_CONTEXT_INDEP_ANCHORS\t\t\\\n+   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)\n+\n+#define RE_SYNTAX_GNU_AWK\t\t\t\t\t\t\\\n+  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DEBUG)\t\\\n+   & ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS))\n+\n+#define RE_SYNTAX_POSIX_AWK \t\t\t\t\t\t\\\n+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS\t\t\\\n+   | RE_INTERVALS\t    | RE_NO_GNU_OPS)\n+\n+#define RE_SYNTAX_GREP\t\t\t\t\t\t\t\\\n+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES\t\t\t\t\\\n+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS\t\t\t\t\\\n+   | RE_NEWLINE_ALT)\n+\n+#define RE_SYNTAX_EGREP\t\t\t\t\t\t\t\\\n+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE\t\t\t\\\n+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS\t\t\t\t\\\n+   | RE_NO_BK_VBAR)\n+\n+#define RE_SYNTAX_POSIX_EGREP\t\t\t\t\t\t\\\n+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES\t\t\t\\\n+   | RE_INVALID_INTERVAL_ORD)\n+\n+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */\n+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC\n+\n+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC\n+\n+/* Syntax bits common to both basic and extended POSIX regex syntax.  */\n+#define _RE_SYNTAX_POSIX_COMMON\t\t\t\t\t\t\\\n+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL\t\t\\\n+   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)\n+\n+#define RE_SYNTAX_POSIX_BASIC\t\t\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)\n+\n+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes\n+   RE_LIMITED_OPS, i.e., \\? \\+ \\| are not recognized.  Actually, this\n+   isn't minimal, since other operators, such as \\`, aren't disabled.  */\n+#define RE_SYNTAX_POSIX_MINIMAL_BASIC\t\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)\n+\n+#define RE_SYNTAX_POSIX_EXTENDED\t\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n+   | RE_CONTEXT_INDEP_OPS   | RE_NO_BK_BRACES\t\t\t\t\\\n+   | RE_NO_BK_PARENS        | RE_NO_BK_VBAR\t\t\t\t\\\n+   | RE_CONTEXT_INVALID_OPS | RE_UNMATCHED_RIGHT_PAREN_ORD)\n+\n+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INDEP_OPS is\n+   removed and RE_NO_BK_REFS is added.  */\n+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED\t\t\t\t\\\n+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES\t\t\t\t\\\n+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS\t\t\t\t\\\n+   | RE_NO_BK_VBAR\t    | RE_UNMATCHED_RIGHT_PAREN_ORD)\n+/* [[[end syntaxes]]] */\n+\f\n+/* Maximum number of duplicates an interval can allow.  Some systems\n+   (erroneously) define this in other header files, but we want our\n+   value, so remove any previous define.  */\n+#ifdef RE_DUP_MAX\n+# undef RE_DUP_MAX\n+#endif\n+/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */\n+#define RE_DUP_MAX (0x7fff)\n+\n+\n+/* POSIX `cflags' bits (i.e., information for `regcomp').  */\n+\n+/* If this bit is set, then use extended regular expression syntax.\n+   If not set, then use basic regular expression syntax.  */\n+#define REG_EXTENDED 1\n+\n+/* If this bit is set, then ignore case when matching.\n+   If not set, then case is significant.  */\n+#define REG_ICASE (REG_EXTENDED << 1)\n+\n+/* If this bit is set, then anchors do not match at newline\n+     characters in the string.\n+   If not set, then anchors do match at newlines.  */\n+#define REG_NEWLINE (REG_ICASE << 1)\n+\n+/* If this bit is set, then report only success or fail in regexec.\n+   If not set, then returns differ between not matching and errors.  */\n+#define REG_NOSUB (REG_NEWLINE << 1)\n+\n+\n+/* POSIX `eflags' bits (i.e., information for regexec).  */\n+\n+/* If this bit is set, then the beginning-of-line operator doesn't match\n+     the beginning of the string (presumably because it's not the\n+     beginning of a line).\n+   If not set, then the beginning-of-line operator does match the\n+     beginning of the string.  */\n+#define REG_NOTBOL 1\n+\n+/* Like REG_NOTBOL, except for the end-of-line.  */\n+#define REG_NOTEOL (1 << 1)\n+\n+\n+/* If any error codes are removed, changed, or added, update the\n+   `re_error_msg' table in regex.c.  */\n+typedef enum\n+{\n+#ifdef _XOPEN_SOURCE\n+  REG_ENOSYS = -1,\t/* This will never happen for this implementation.  */\n+#endif\n+\n+  REG_NOERROR = 0,\t/* Success.  */\n+  REG_NOMATCH,\t\t/* Didn't find a match (for regexec).  */\n+\n+  /* POSIX regcomp return error codes.  (In the order listed in the\n+     standard.)  */\n+  REG_BADPAT,\t\t/* Invalid pattern.  */\n+  REG_ECOLLATE,\t\t/* Not implemented.  */\n+  REG_ECTYPE,\t\t/* Invalid character class name.  */\n+  REG_EESCAPE,\t\t/* Trailing backslash.  */\n+  REG_ESUBREG,\t\t/* Invalid back reference.  */\n+  REG_EBRACK,\t\t/* Unmatched left bracket.  */\n+  REG_EPAREN,\t\t/* Parenthesis imbalance.  */\n+  REG_EBRACE,\t\t/* Unmatched \\{.  */\n+  REG_BADBR,\t\t/* Invalid contents of \\{\\}.  */\n+  REG_ERANGE,\t\t/* Invalid range end.  */\n+  REG_ESPACE,\t\t/* Ran out of memory.  */\n+  REG_BADRPT,\t\t/* No preceding re for repetition op.  */\n+\n+  /* Error codes we've added.  */\n+  REG_EEND,\t\t/* Premature end.  */\n+  REG_ESIZE,\t\t/* Compiled pattern bigger than 2^16 bytes.  */\n+  REG_ERPAREN\t\t/* Unmatched ) or \\); not returned from regcomp.  */\n+} reg_errcode_t;\n+\f\n+/* This data structure represents a compiled pattern.  Before calling\n+   the pattern compiler, the fields `buffer', `allocated', `fastmap',\n+   `translate', and `no_sub' can be set.  After the pattern has been\n+   compiled, the `re_nsub' field is available.  All other fields are\n+   private to the regex routines.  */\n+\n+#ifndef RE_TRANSLATE_TYPE\n+# define RE_TRANSLATE_TYPE char *\n+#endif\n+\n+struct re_pattern_buffer\n+{\n+/* [[[begin pattern_buffer]]] */\n+\t/* Space that holds the compiled pattern.  It is declared as\n+          `unsigned char *' because its elements are\n+           sometimes used as array indexes.  */\n+  unsigned char *buffer;\n+\n+\t/* Number of bytes to which `buffer' points.  */\n+  unsigned long int allocated;\n+\n+\t/* Number of bytes actually used in `buffer'.  */\n+  unsigned long int used;\n+\n+        /* Syntax setting with which the pattern was compiled.  */\n+  reg_syntax_t syntax;\n+\n+        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses\n+           the fastmap, if there is one, to skip over impossible\n+           starting points for matches.  */\n+  char *fastmap;\n+\n+        /* Either a translate table to apply to all characters before\n+           comparing them, or zero for no translation.  The translation\n+           is applied to a pattern when it is compiled and to a string\n+           when it is matched.  */\n+  RE_TRANSLATE_TYPE translate;\n+\n+\t/* Number of subexpressions found by the compiler.  */\n+  size_t re_nsub;\n+\n+        /* Zero if this pattern cannot match the empty string, one else.\n+           Well, in truth it's used only in `re_search_2', to see\n+           whether or not we should use the fastmap, so we don't set\n+           this absolutely perfectly; see `re_compile_fastmap' (the\n+           `duplicate' case).  */\n+  unsigned can_be_null : 1;\n+\n+        /* If REGS_UNALLOCATED, allocate space in the `regs' structure\n+             for `max (RE_NREGS, re_nsub + 1)' groups.\n+           If REGS_REALLOCATE, reallocate space if necessary.\n+           If REGS_FIXED, use what's there.  */\n+#define REGS_UNALLOCATED 0\n+#define REGS_REALLOCATE 1\n+#define REGS_FIXED 2\n+  unsigned regs_allocated : 2;\n+\n+        /* Set to zero when `regex_compile' compiles a pattern; set to one\n+           by `re_compile_fastmap' if it updates the fastmap.  */\n+  unsigned fastmap_accurate : 1;\n+\n+        /* If set, `re_match_2' does not return information about\n+           subexpressions.  */\n+  unsigned no_sub : 1;\n+\n+        /* If set, a beginning-of-line anchor doesn't match at the\n+           beginning of the string.  */\n+  unsigned not_bol : 1;\n+\n+        /* Similarly for an end-of-line anchor.  */\n+  unsigned not_eol : 1;\n+\n+        /* If true, an anchor at a newline matches.  */\n+  unsigned newline_anchor : 1;\n+\n+/* [[[end pattern_buffer]]] */\n+};\n+\n+typedef struct re_pattern_buffer regex_t;\n+\f\n+/* Type for byte offsets within the string.  POSIX mandates this.  */\n+typedef int regoff_t;\n+\n+\n+/* This is the structure we store register match data in.  See\n+   regex.texinfo for a full description of what registers match.  */\n+struct re_registers\n+{\n+  unsigned num_regs;\n+  regoff_t *start;\n+  regoff_t *end;\n+};\n+\n+\n+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,\n+   `re_match_2' returns information about at least this many registers\n+   the first time a `regs' structure is passed.  */\n+#ifndef RE_NREGS\n+# define RE_NREGS 30\n+#endif\n+\n+\n+/* POSIX specification for registers.  Aside from the different names than\n+   `re_registers', POSIX uses an array of structures, instead of a\n+   structure of arrays.  */\n+typedef struct\n+{\n+  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */\n+  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */\n+} regmatch_t;\n+\f\n+/* Declarations for routines.  */\n+\n+/* To avoid duplicating every routine declaration -- once with a\n+   prototype (if we are ANSI), and once without (if we aren't) -- we\n+   use the following macro to declare argument types.  This\n+   unfortunately clutters up the declarations a bit, but I think it's\n+   worth it.  */\n+\n+#if __STDC__\n+\n+# define _RE_ARGS(args) args\n+\n+#else /* not __STDC__ */\n+\n+# define _RE_ARGS(args) ()\n+\n+#endif /* not __STDC__ */\n+\n+/* Sets the current default syntax to SYNTAX, and return the old syntax.\n+   You can also simply assign to the `re_syntax_options' variable.  */\n+extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n+\n+/* Compile the regular expression PATTERN, with length LENGTH\n+   and syntax given by the global `re_syntax_options', into the buffer\n+   BUFFER.  Return NULL if successful, and an error string if not.  */\n+extern const char *re_compile_pattern\n+  _RE_ARGS ((const char *pattern, size_t length,\n+             struct re_pattern_buffer *buffer));\n+\n+\n+/* Compile a fastmap for the compiled pattern in BUFFER; used to\n+   accelerate searches.  Return 0 if successful and -2 if was an\n+   internal error.  */\n+extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n+\n+\n+/* Search in the string STRING (with length LENGTH) for the pattern\n+   compiled into BUFFER.  Start searching at position START, for RANGE\n+   characters.  Return the starting position of the match, -1 for no\n+   match, or -2 for an internal error.  Also return register\n+   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */\n+extern int re_search\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n+            int length, int start, int range, struct re_registers *regs));\n+\n+\n+/* Like `re_search', but search in the concatenation of STRING1 and\n+   STRING2.  Also, stop searching at index START + STOP.  */\n+extern int re_search_2\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n+             int length1, const char *string2, int length2,\n+             int start, int range, struct re_registers *regs, int stop));\n+\n+\n+/* Like `re_search', but return how many characters in STRING the regexp\n+   in BUFFER matched, starting at position START.  */\n+extern int re_match\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n+             int length, int start, struct re_registers *regs));\n+\n+\n+/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */\n+extern int re_match_2\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n+             int length1, const char *string2, int length2,\n+             int start, struct re_registers *regs, int stop));\n+\n+\n+/* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n+   ENDS.  Subsequent matches using BUFFER and REGS will use this memory\n+   for recording register information.  STARTS and ENDS must be\n+   allocated with malloc, and must each be at least `NUM_REGS * sizeof\n+   (regoff_t)' bytes long.\n+\n+   If NUM_REGS == 0, then subsequent matches should allocate their own\n+   register data.\n+\n+   Unless this function is called, the first search or match using\n+   PATTERN_BUFFER will allocate its own register data, without\n+   freeing the old data.  */\n+extern void re_set_registers\n+  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n+             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n+\n+#if defined _REGEX_RE_COMP || defined _LIBC\n+# ifndef _CRAY\n+/* 4.2 bsd compatibility.  */\n+extern char *re_comp _RE_ARGS ((const char *));\n+extern int re_exec _RE_ARGS ((const char *));\n+# endif\n+#endif\n+\n+/* GCC 2.95 and later have \"__restrict\"; C99 compilers have\n+   \"restrict\", and \"configure\" may have defined \"restrict\".  */\n+#ifndef __restrict\n+# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))\n+#  if defined restrict || 199901L <= __STDC_VERSION__\n+#   define __restrict restrict\n+#  else\n+#   define __restrict\n+#  endif\n+# endif\n+#endif\n+/* For now unconditionally define __restrict_arr to expand to nothing.\n+   Ideally we would have a test for the compiler which allows defining\n+   it to restrict.  */\n+#define __restrict_arr\n+\n+/* POSIX compatibility.  */\n+extern int regcomp _RE_ARGS ((regex_t *__restrict __preg,\n+\t\t\t      const char *__restrict __pattern,\n+\t\t\t      int __cflags));\n+\n+extern int regexec _RE_ARGS ((const regex_t *__restrict __preg,\n+\t\t\t      const char *__restrict __string, size_t __nmatch,\n+\t\t\t      regmatch_t __pmatch[__restrict_arr],\n+\t\t\t      int __eflags));\n+\n+extern size_t regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n+\t\t\t\t  char *__errbuf, size_t __errbuf_size));\n+\n+extern void regfree _RE_ARGS ((regex_t *__preg));\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\t/* C++ */\n+\n+#endif /* regex.h */\n+\f\n+/*\n+Local variables:\n+make-backup-files: t\n+version-control: t\n+trim-versions-without-asking: nil\n+End:\n+*/"}]}