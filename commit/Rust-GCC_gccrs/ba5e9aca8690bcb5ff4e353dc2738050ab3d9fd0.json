{"sha": "ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE1ZTlhY2E4NjkwYmNiNWZmNGUzNTNkYzI3MzgwNTBhYjNkOWZkMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-03-26T13:03:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-03-26T13:03:46Z"}, "message": "basic-block.h (fixup_abnormal_edges): Adjust prototype.\n\n\t* basic-block.h (fixup_abnormal_edges): Adjust prototype.\n\t* reload1.c (reload): Adjust call to fixup_abnormal_edges.  Rediscover\n\tbasic blocks and call commit_edge_insertions directly.\n\t(fixup_abnormal_edges): Move from here to...\n\t* cfgrtl.c (fixup_abnormal_edges): ...here.  Only insert instructions\n\ton the edges and return whether some have actually been inserted.\n\t* reg-stack.c (convert_regs): Fix up abnormal edges before inserting\n\tcompensation code.\n\nFrom-SVN: r171556", "tree": {"sha": "d62fdb4e2bf55596cf3feea95658385026ca7c2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d62fdb4e2bf55596cf3feea95658385026ca7c2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/comments", "author": null, "committer": null, "parents": [{"sha": "5d369d583699112c7339f1f5555bd592f6fed70c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d369d583699112c7339f1f5555bd592f6fed70c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d369d583699112c7339f1f5555bd592f6fed70c"}], "stats": {"total": 235, "additions": 123, "deletions": 112}, "files": [{"sha": "54dfbe8c7056a51b717a334ed1aadc1485d1c767", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "patch": "@@ -1,3 +1,14 @@\n+2011-03-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* basic-block.h (fixup_abnormal_edges): Adjust prototype.\n+\t* reload1.c (reload): Adjust call to fixup_abnormal_edges.  Rediscover\n+\tbasic blocks and call commit_edge_insertions directly.\n+\t(fixup_abnormal_edges): Move from here to...\n+\t* cfgrtl.c (fixup_abnormal_edges): ...here.  Only insert instructions\n+\ton the edges and return whether some have actually been inserted.\n+\t* reg-stack.c (convert_regs): Fix up abnormal edges before inserting\n+\tcompensation code.\n+\n 2011-03-26  Andrey Belevantsev  <abel@ispras.ru>\n \n \tPR rtl-optimization/48144"}, {"sha": "239c9254b3bc0fc9a955a54ef49bed5ce199cfb7", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "patch": "@@ -798,6 +798,7 @@ extern basic_block force_nonfallthru (edge);\n extern rtx block_label (basic_block);\n extern bool purge_all_dead_edges (void);\n extern bool purge_dead_edges (basic_block);\n+extern bool fixup_abnormal_edges (void);\n \n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);\n@@ -814,7 +815,6 @@ extern bool delete_unreachable_blocks (void);\n extern bool mark_dfs_back_edges (void);\n extern void set_edge_can_fallthru_flag (void);\n extern void update_br_prob_note (basic_block);\n-extern void fixup_abnormal_edges (void);\n extern bool inside_basic_block_p (const_rtx);\n extern bool control_flow_insn_p (const_rtx);\n extern rtx get_last_bb_insn (basic_block);"}, {"sha": "9031886fb1689f40e432ded78e0d70176038548e", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "patch": "@@ -30,6 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n \t insert_insn_on_edge, commit_edge_insertions\n      - CFG updating after insn simplification\n \t purge_dead_edges, purge_all_dead_edges\n+     - CFG fixing after coarse manipulation\n+\tfixup_abnormal_edges\n \n    Functions not supposed for generic use:\n      - Infrastructure to determine quickly basic block for insn\n@@ -2471,6 +2473,95 @@ purge_all_dead_edges (void)\n   return purged;\n }\n \n+/* This is used by a few passes that emit some instructions after abnormal\n+   calls, moving the basic block's end, while they in fact do want to emit\n+   them on the fallthru edge.  Look for abnormal call edges, find backward\n+   the call in the block and insert the instructions on the edge instead.\n+\n+   Similarly, handle instructions throwing exceptions internally.\n+\n+   Return true when instructions have been found and inserted on edges.  */\n+\n+bool\n+fixup_abnormal_edges (void)\n+{\n+  bool inserted = false;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      /* Look for cases we are interested in - calls or instructions causing\n+         exceptions.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif ((e->flags & EDGE_ABNORMAL_CALL)\n+\t    || ((e->flags & (EDGE_ABNORMAL | EDGE_EH))\n+\t\t== (EDGE_ABNORMAL | EDGE_EH)))\n+\t  break;\n+\n+      if (e && !CALL_P (BB_END (bb)) && !can_throw_internal (BB_END (bb)))\n+\t{\n+\t  rtx insn;\n+\n+\t  /* Get past the new insns generated.  Allow notes, as the insns\n+\t     may be already deleted.  */\n+\t  insn = BB_END (bb);\n+\t  while ((NONJUMP_INSN_P (insn) || NOTE_P (insn))\n+\t\t && !can_throw_internal (insn)\n+\t\t && insn != BB_HEAD (bb))\n+\t    insn = PREV_INSN (insn);\n+\n+\t  if (CALL_P (insn) || can_throw_internal (insn))\n+\t    {\n+\t      rtx stop, next;\n+\n+\t      e = find_fallthru_edge (bb->succs);\n+\n+\t      stop = NEXT_INSN (BB_END (bb));\n+\t      BB_END (bb) = insn;\n+\n+\t      for (insn = NEXT_INSN (insn); insn != stop; insn = next)\n+\t\t{\n+\t\t  next = NEXT_INSN (insn);\n+\t\t  if (INSN_P (insn))\n+\t\t    {\n+\t\t      delete_insn (insn);\n+\n+\t\t      /* Sometimes there's still the return value USE.\n+\t\t\t If it's placed after a trapping call (i.e. that\n+\t\t\t call is the last insn anyway), we have no fallthru\n+\t\t\t edge.  Simply delete this use and don't try to insert\n+\t\t\t on the non-existent edge.  */\n+\t\t      if (GET_CODE (PATTERN (insn)) != USE)\n+\t\t\t{\n+\t\t\t  /* We're not deleting it, we're moving it.  */\n+\t\t\t  INSN_DELETED_P (insn) = 0;\n+\t\t\t  PREV_INSN (insn) = NULL_RTX;\n+\t\t\t  NEXT_INSN (insn) = NULL_RTX;\n+\n+\t\t\t  insert_insn_on_edge (insn, e);\n+\t\t\t  inserted = true;\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (!BARRIER_P (insn))\n+\t\t    set_block_for_insn (insn, NULL);\n+\t\t}\n+\t    }\n+\n+\t  /* It may be that we don't find any trapping insn.  In this\n+\t     case we discovered quite late that the insn that had been\n+\t     marked as can_throw_internal in fact couldn't trap at all.\n+\t     So we should in fact delete the EH edges out of the block.  */\n+\t  else\n+\t    purge_dead_edges (bb);\n+\t}\n+    }\n+\n+  return inserted;\n+}\n+\n /* Same as split_block but update cfg_layout structures.  */\n \n static basic_block"}, {"sha": "60835c75528d0c09a9472bf89fe9d6ad06a715dc", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "patch": "@@ -3150,11 +3150,14 @@ convert_regs (void)\n \tcfg_altered |= convert_regs_2 (b);\n     }\n \n+  /* We must fix up abnormal edges before inserting compensation code\n+     because both mechanisms insert insns on edges.  */\n+  inserted |= fixup_abnormal_edges ();\n+\n   inserted |= compensate_edges ();\n \n   clear_aux_for_blocks ();\n \n-  fixup_abnormal_edges ();\n   if (inserted)\n     commit_edge_insertions ();\n "}, {"sha": "100e5e929f795960ece47abdcb6bc5c87e3dd7a7", "filename": "gcc/reload1.c", "status": "modified", "additions": 16, "deletions": 110, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ba5e9aca8690bcb5ff4e353dc2738050ab3d9fd0", "patch": "@@ -721,6 +721,7 @@ reload (rtx first, int global)\n   rtx insn;\n   struct elim_table *ep;\n   basic_block bb;\n+  bool inserted;\n \n   /* Make sure even insns with volatile mem refs are recognizable.  */\n   init_recog ();\n@@ -1299,7 +1300,21 @@ reload (rtx first, int global)\n   /* Free all the insn_chain structures at once.  */\n   obstack_free (&reload_obstack, reload_startobj);\n   unused_insn_chains = 0;\n-  fixup_abnormal_edges ();\n+\n+  inserted = fixup_abnormal_edges ();\n+\n+  /* We've possibly turned single trapping insn into multiple ones.  */\n+  if (cfun->can_throw_non_call_exceptions)\n+    {\n+      sbitmap blocks;\n+      blocks = sbitmap_alloc (last_basic_block);\n+      sbitmap_ones (blocks);\n+      find_many_sub_basic_blocks (blocks);\n+      sbitmap_free (blocks);\n+    }\n+\n+  if (inserted)\n+    commit_edge_insertions ();\n \n   /* Replacing pseudos with their memory equivalents might have\n      created shared rtx.  Subsequent passes would get confused\n@@ -9112,112 +9127,3 @@ add_auto_inc_notes (rtx insn, rtx x)\n     }\n }\n #endif\n-\n-/* This is used by reload pass, that does emit some instructions after\n-   abnormal calls moving basic block end, but in fact it wants to emit\n-   them on the edge.  Looks for abnormal call edges, find backward the\n-   proper call and fix the damage.\n-\n-   Similar handle instructions throwing exceptions internally.  */\n-void\n-fixup_abnormal_edges (void)\n-{\n-  bool inserted = false;\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      /* Look for cases we are interested in - calls or instructions causing\n-         exceptions.  */\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  if (e->flags & EDGE_ABNORMAL_CALL)\n-\t    break;\n-\t  if ((e->flags & (EDGE_ABNORMAL | EDGE_EH))\n-\t      == (EDGE_ABNORMAL | EDGE_EH))\n-\t    break;\n-\t}\n-      if (e && !CALL_P (BB_END (bb))\n-\t  && !can_throw_internal (BB_END (bb)))\n-\t{\n-\t  rtx insn;\n-\n-\t  /* Get past the new insns generated.  Allow notes, as the insns\n-\t     may be already deleted.  */\n-\t  insn = BB_END (bb);\n-\t  while ((NONJUMP_INSN_P (insn) || NOTE_P (insn))\n-\t\t && !can_throw_internal (insn)\n-\t\t && insn != BB_HEAD (bb))\n-\t    insn = PREV_INSN (insn);\n-\n-\t  if (CALL_P (insn) || can_throw_internal (insn))\n-\t    {\n-\t      rtx stop, next;\n-\n-\t      stop = NEXT_INSN (BB_END (bb));\n-\t      BB_END (bb) = insn;\n-\t      insn = NEXT_INSN (insn);\n-\n-\t      e = find_fallthru_edge (bb->succs);\n-\n-\t      while (insn && insn != stop)\n-\t\t{\n-\t\t  next = NEXT_INSN (insn);\n-\t\t  if (INSN_P (insn))\n-\t\t    {\n-\t\t      delete_insn (insn);\n-\n-\t\t      /* Sometimes there's still the return value USE.\n-\t\t\t If it's placed after a trapping call (i.e. that\n-\t\t\t call is the last insn anyway), we have no fallthru\n-\t\t\t edge.  Simply delete this use and don't try to insert\n-\t\t\t on the non-existent edge.  */\n-\t\t      if (GET_CODE (PATTERN (insn)) != USE)\n-\t\t\t{\n-\t\t\t  /* We're not deleting it, we're moving it.  */\n-\t\t\t  INSN_DELETED_P (insn) = 0;\n-\t\t\t  PREV_INSN (insn) = NULL_RTX;\n-\t\t\t  NEXT_INSN (insn) = NULL_RTX;\n-\n-\t\t\t  insert_insn_on_edge (insn, e);\n-\t\t\t  inserted = true;\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (!BARRIER_P (insn))\n-\t\t    set_block_for_insn (insn, NULL);\n-\t\t  insn = next;\n-\t\t}\n-\t    }\n-\n-\t  /* It may be that we don't find any such trapping insn.  In this\n-\t     case we discovered quite late that the insn that had been\n-\t     marked as can_throw_internal in fact couldn't trap at all.\n-\t     So we should in fact delete the EH edges out of the block.  */\n-\t  else\n-\t    purge_dead_edges (bb);\n-\t}\n-    }\n-\n-  /* We've possibly turned single trapping insn into multiple ones.  */\n-  if (cfun->can_throw_non_call_exceptions)\n-    {\n-      sbitmap blocks;\n-      blocks = sbitmap_alloc (last_basic_block);\n-      sbitmap_ones (blocks);\n-      find_many_sub_basic_blocks (blocks);\n-      sbitmap_free (blocks);\n-    }\n-\n-  if (inserted)\n-    commit_edge_insertions ();\n-\n-#ifdef ENABLE_CHECKING\n-  /* Verify that we didn't turn one trapping insn into many, and that\n-     we found and corrected all of the problems wrt fixups on the\n-     fallthru edge.  */\n-  verify_flow_info ();\n-#endif\n-}"}]}