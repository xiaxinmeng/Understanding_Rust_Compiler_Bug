{"sha": "ac43e11e234201441e84b5bc015587ecfff6c797", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM0M2UxMWUyMzQyMDE0NDFlODRiNWJjMDE1NTg3ZWNmZmY2Yzc5Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:23:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:23:17Z"}, "message": "[multiple changes]\n\n2014-07-30  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): New predicate.\n\t(Expand_Array_Aggregate): Also enable in-place expansion for\n\tcode generated by the compiler.  For an object declaration,\n\tset the kind of the object in addition to its type.  If an\n\tin-place assignment is to be generated and it can be directly\n\tdone by the back-end, do not expand the aggregate.\n\t* fe.h (Is_Others_Aggregate): Declare.\n\t* gcc-interface/trans.c\n\t(gnat_to_gnu) <N_Assignment_Statement>: Add support for an\n\taggregate with a single Others choice on the RHS by means of\n\t__builtin_memset.  Tidy up.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat_rm.texi: minor reformatting.\n\n2014-07-30  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Helper_Body): Remove body to inline\n\tin SPARK_Mode Off.\n\nFrom-SVN: r213240", "tree": {"sha": "3c0096f5117603b8ed3b9e8bbc41137367131e1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c0096f5117603b8ed3b9e8bbc41137367131e1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac43e11e234201441e84b5bc015587ecfff6c797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac43e11e234201441e84b5bc015587ecfff6c797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac43e11e234201441e84b5bc015587ecfff6c797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac43e11e234201441e84b5bc015587ecfff6c797/comments", "author": null, "committer": null, "parents": [{"sha": "eb16ddf8ed7f0b7ec30c86895a16f0fa7c7c6e26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb16ddf8ed7f0b7ec30c86895a16f0fa7c7c6e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb16ddf8ed7f0b7ec30c86895a16f0fa7c7c6e26"}], "stats": {"total": 327, "additions": 276, "deletions": 51}, "files": [{"sha": "f4bee3a89e3afe8d300d05c9a4210ead92644961", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ac43e11e234201441e84b5bc015587ecfff6c797", "patch": "@@ -1,3 +1,26 @@\n+2014-07-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): New predicate.\n+\t(Expand_Array_Aggregate): Also enable in-place expansion for\n+\tcode generated by the compiler.  For an object declaration,\n+\tset the kind of the object in addition to its type.  If an\n+\tin-place assignment is to be generated and it can be directly\n+\tdone by the back-end, do not expand the aggregate.\n+\t* fe.h (Is_Others_Aggregate): Declare.\n+\t* gcc-interface/trans.c\n+\t(gnat_to_gnu) <N_Assignment_Statement>: Add support for an\n+\taggregate with a single Others choice on the RHS by means of\n+\t__builtin_memset.  Tidy up.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat_rm.texi: minor reformatting.\n+\n+2014-07-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Helper_Body): Remove body to inline\n+\tin SPARK_Mode Off.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Document additional implementation-defined use"}, {"sha": "60373568d346a5bd9c97a4080f5e3325a4cfb866", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 147, "deletions": 10, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=ac43e11e234201441e84b5bc015587ecfff6c797", "patch": "@@ -3945,6 +3945,9 @@ package body Exp_Aggr is\n       Aggr_Index_Typ : array (1 .. Aggr_Dimension) of Entity_Id;\n       --  The type of each index\n \n+      In_Place_Assign_OK_For_Declaration : Boolean := False;\n+      --  True if we are to generate an in place assignment for a declaration\n+\n       Maybe_In_Place_OK : Boolean;\n       --  If the type is neither controlled nor packed and the aggregate\n       --  is the expression in an assignment, assignment in place may be\n@@ -3955,6 +3958,9 @@ package body Exp_Aggr is\n       --  If Others_Present (J) is True, then there is an others choice\n       --  in one of the sub-aggregates of N at dimension J.\n \n+      function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean;\n+      --  Returns true if an aggregate assignment can be done by the back end\n+\n       procedure Build_Constrained_Type (Positional : Boolean);\n       --  If the subtype is not static or unconstrained, build a constrained\n       --  type using the computable sizes of the aggregate and its sub-\n@@ -3991,6 +3997,108 @@ package body Exp_Aggr is\n       --  built directly into the target of the assignment it must be free\n       --  of side-effects.\n \n+      ------------------------------------\n+      -- Aggr_Assignment_OK_For_Backend --\n+      ------------------------------------\n+\n+      --  Backend processing by Gigi/gcc is possible only if all the following\n+      --  conditions are met:\n+\n+      --    1. N consists of a single OTHERS choice, possibly recursively\n+\n+      --    2. The component type is discrete\n+\n+      --    3. The component size is a multiple of Storage_Unit\n+\n+      --    4. The component size is exactly Storage_Unit or the expression is\n+      --       an integer whose unsigned value is the binary concatenation of\n+      --       K times its remainder modulo 2**Storage_Unit.\n+\n+      --  The ultimate goal is to generate a call to a fast memset routine\n+      --  specifically optimized for the target.\n+\n+      function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean is\n+         Ctyp      : Entity_Id;\n+         Expr      : Node_Id := N;\n+         Remainder : Uint;\n+         Value     : Uint;\n+         Nunits    : Nat;\n+\n+      begin\n+         --  Recurse as far as possible to find the innermost component type\n+\n+         Ctyp := Etype (N);\n+         while Is_Array_Type (Ctyp) loop\n+            if Nkind (Expr) /= N_Aggregate\n+              or else not Is_Others_Aggregate (Expr)\n+            then\n+               return False;\n+            end if;\n+\n+            Expr := Expression (First (Component_Associations (Expr)));\n+\n+            for J in 1 .. Number_Dimensions (Ctyp) - 1 loop\n+               if Nkind (Expr) /= N_Aggregate\n+                 or else not Is_Others_Aggregate (Expr)\n+               then\n+                  return False;\n+               end if;\n+\n+               Expr := Expression (First (Component_Associations (Expr)));\n+            end loop;\n+\n+            Ctyp := Component_Type (Ctyp);\n+         end loop;\n+\n+         if not Is_Discrete_Type (Ctyp)\n+           or else RM_Size (Ctyp) mod System_Storage_Unit /= 0\n+         then\n+            return False;\n+         end if;\n+\n+         --  The expression needs to be analyzed if True is returned\n+\n+         Analyze_And_Resolve (Expr, Ctyp);\n+\n+         Nunits := UI_To_Int (RM_Size (Ctyp) / System_Storage_Unit);\n+         if Nunits = 1 then\n+            return True;\n+         end if;\n+\n+         if not Compile_Time_Known_Value (Expr) then\n+            return False;\n+         end if;\n+\n+         Value := Expr_Value (Expr);\n+\n+         if Has_Biased_Representation (Ctyp) then\n+            Value := Value - Expr_Value (Type_Low_Bound (Ctyp));\n+         end if;\n+\n+         --  0 and -1 immediately satisfy check #4\n+\n+         if Value = Uint_0 or else Value = Uint_Minus_1 then\n+            return True;\n+         end if;\n+\n+         --  We need to work with an unsigned value\n+\n+         if Value < 0 then\n+            Value := Value + 2**(System_Storage_Unit * Nunits);\n+         end if;\n+\n+         Remainder := Value rem 2**System_Storage_Unit;\n+         for I in 1 .. Nunits - 1 loop\n+            Value := Value / 2**System_Storage_Unit;\n+\n+            if Value rem 2**System_Storage_Unit /= Remainder then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Aggr_Assignment_OK_For_Backend;\n+\n       ----------------------------\n       -- Build_Constrained_Type --\n       ----------------------------\n@@ -5065,7 +5173,6 @@ package body Exp_Aggr is\n       else\n          Maybe_In_Place_OK :=\n           (Nkind (Parent (N)) = N_Assignment_Statement\n-            and then Comes_From_Source (N)\n             and then In_Place_Assign_OK)\n \n           or else\n@@ -5098,22 +5205,27 @@ package body Exp_Aggr is\n          and then not Is_Bit_Packed_Array (Typ)\n          and then not Has_Controlled_Component (Typ)\n       then\n+         In_Place_Assign_OK_For_Declaration := True;\n          Tmp := Defining_Identifier (Parent (N));\n          Set_No_Initialization (Parent (N));\n          Set_Expression (Parent (N), Empty);\n \n-         --  Set the type of the entity, for use in the analysis of the\n-         --  subsequent indexed assignments. If the nominal type is not\n+         --  Set kind and type of the entity, for use in the analysis\n+         --  of the subsequent assignments. If the nominal type is not\n          --  constrained, build a subtype from the known bounds of the\n          --  aggregate. If the declaration has a subtype mark, use it,\n          --  otherwise use the itype of the aggregate.\n \n+         Set_Ekind (Tmp, E_Variable);\n+\n          if not Is_Constrained (Typ) then\n             Build_Constrained_Type (Positional => False);\n+\n          elsif Is_Entity_Name (Object_Definition (Parent (N)))\n            and then Is_Constrained (Entity (Object_Definition (Parent (N))))\n          then\n             Set_Etype (Tmp, Entity (Object_Definition (Parent (N))));\n+\n          else\n             Set_Size_Known_At_Compile_Time (Typ, False);\n             Set_Etype (Tmp, Typ);\n@@ -5150,7 +5262,6 @@ package body Exp_Aggr is\n \n       elsif Maybe_In_Place_OK\n         and then Nkind (Name (Parent (N))) = N_Slice\n-        and then Comes_From_Source (N)\n         and then Is_Others_Aggregate (N)\n       then\n          Tmp := Name (Parent (N));\n@@ -5214,12 +5325,38 @@ package body Exp_Aggr is\n             Target := New_Copy (Tmp);\n          end if;\n \n-         Aggr_Code :=\n-           Build_Array_Aggr_Code (N,\n-             Ctype       => Ctyp,\n-             Index       => First_Index (Typ),\n-             Into        => Target,\n-             Scalar_Comp => Is_Scalar_Type (Ctyp));\n+         --  If we are to generate an in place assignment for a declaration or\n+         --  an assignment statement, and the assignment can be done directly\n+         --  by the back end, then do not expand further.\n+\n+         --  ??? We can also do that if in place expansion is not possible but\n+         --  then we could go into an infinite recursion.\n+\n+         if (In_Place_Assign_OK_For_Declaration or else Maybe_In_Place_OK)\n+           and then not AAMP_On_Target\n+           and then VM_Target = No_VM\n+           and then not Generate_SCIL\n+           and then not Possible_Bit_Aligned_Component (Target)\n+           and then Aggr_Assignment_OK_For_Backend (N)\n+         then\n+            if Maybe_In_Place_OK then\n+               return;\n+            end if;\n+\n+            Aggr_Code :=\n+              New_List (\n+                Make_Assignment_Statement (Loc,\n+                  Name       => Target,\n+                  Expression => New_Copy (N)));\n+         else\n+\n+            Aggr_Code :=\n+              Build_Array_Aggr_Code (N,\n+                Ctype       => Ctyp,\n+                Index       => First_Index (Typ),\n+                Into        => Target,\n+                Scalar_Comp => Is_Scalar_Type (Ctyp));\n+         end if;\n \n          --  Save the last assignment statement associated with the aggregate\n          --  when building a controlled object. This reference is utilized by"}, {"sha": "f930315be54757dfcd111c5ce111a94c4355f828", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=ac43e11e234201441e84b5bc015587ecfff6c797", "patch": "@@ -202,6 +202,11 @@ extern void Check_No_Implicit_Heap_Alloc   (Node_Id);\n extern void Check_Elaboration_Code_Allowed (Node_Id);\n extern void Check_Implicit_Dynamic_Code_Allowed (Node_Id);\n \n+/* sem_aggr:  */\n+#define Is_Others_Aggregate    sem_aggr__is_others_aggregate\n+\n+extern Boolean Is_Others_Aggregate (Node_Id);\n+\n /* sem_aux:  */\n \n #define Ancestor_Subtype               sem_aux__ancestor_subtype"}, {"sha": "f038910e316550ef8d118cc2877a7e30d606194c", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 86, "deletions": 38, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ac43e11e234201441e84b5bc015587ecfff6c797", "patch": "@@ -2400,9 +2400,11 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n       /* First compile all the different case choices for the current WHEN\n \t alternative.  */\n       for (gnat_choice = First (Discrete_Choices (gnat_when));\n-\t   Present (gnat_choice); gnat_choice = Next (gnat_choice))\n+\t   Present (gnat_choice);\n+\t   gnat_choice = Next (gnat_choice))\n \t{\n \t  tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n+\t  tree label = create_artificial_label (input_location);\n \n \t  switch (Nkind (gnat_choice))\n \t    {\n@@ -2426,8 +2428,8 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t\t{\n \t\t  tree gnu_type = get_unpadded_type (Entity (gnat_choice));\n \n-\t\t  gnu_low = fold (TYPE_MIN_VALUE (gnu_type));\n-\t\t  gnu_high = fold (TYPE_MAX_VALUE (gnu_type));\n+\t\t  gnu_low = TYPE_MIN_VALUE (gnu_type);\n+\t\t  gnu_high = TYPE_MAX_VALUE (gnu_type);\n \t\t  break;\n \t\t}\n \n@@ -2445,20 +2447,13 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t      gcc_unreachable ();\n \t    }\n \n-\t  /* If the case value is a subtype that raises Constraint_Error at\n-\t     run time because of a wrong bound, then gnu_low or gnu_high is\n-\t     not translated into an INTEGER_CST.  In such a case, we need\n-\t     to ensure that the when statement is not added in the tree,\n-\t     otherwise it will crash the gimplifier.  */\n-\t  if ((!gnu_low || TREE_CODE (gnu_low) == INTEGER_CST)\n-\t      && (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST))\n-\t    {\n-\t      add_stmt_with_node (build_case_label\n-\t\t\t\t  (gnu_low, gnu_high,\n-\t\t\t\t   create_artificial_label (input_location)),\n-\t\t\t\t  gnat_choice);\n-\t      choices_added_p = true;\n-\t    }\n+\t  /* Everything should be folded into constants at this point.  */\n+\t  gcc_assert (!gnu_low  || TREE_CODE (gnu_low)  == INTEGER_CST);\n+\t  gcc_assert (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST);\n+\n+\t  add_stmt_with_node (build_case_label (gnu_low, gnu_high, label),\n+\t\t\t      gnat_choice);\n+\t  choices_added_p = true;\n \t}\n \n       /* This construct doesn't define a scope so we shouldn't push a binding\n@@ -5713,16 +5708,27 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_result = alloc_stmt_list ();\n       break;\n \n+    case N_Exception_Renaming_Declaration:\n+      gnat_temp = Defining_Entity (gnat_node);\n+      if (Renamed_Entity (gnat_temp) != Empty)\n+        gnu_result\n+          = gnat_to_gnu_entity (gnat_temp,\n+                                gnat_to_gnu (Renamed_Entity (gnat_temp)), 1);\n+      else\n+        gnu_result = alloc_stmt_list ();\n+      break;\n+\n     case N_Implicit_Label_Declaration:\n       gnat_to_gnu_entity (Defining_Entity (gnat_node), NULL_TREE, 1);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n-    case N_Exception_Renaming_Declaration:\n     case N_Number_Declaration:\n-    case N_Package_Renaming_Declaration:\n     case N_Subprogram_Renaming_Declaration:\n+    case N_Package_Renaming_Declaration:\n       /* These are fully handled in the front end.  */\n+      /* ??? For package renamings, find a way to use GENERIC namespaces so\n+\t that we get proper debug information for them.  */\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -6479,40 +6485,79 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t atomic_sync_required_p (Name (gnat_node)));\n       else\n \t{\n-\t  gnu_rhs\n-\t    = maybe_unconstrained_array (gnat_to_gnu (Expression (gnat_node)));\n+\t  const Node_Id gnat_expr = Expression (gnat_node);\n+\t  const Entity_Id gnat_type\n+\t    = Underlying_Type (Etype (Name (gnat_node)));\n+\t  const bool regular_array_type_p\n+\t    = (Is_Array_Type (gnat_type) && !Is_Bit_Packed_Array (gnat_type));\n+\t  const bool use_memset_p\n+\t    = (regular_array_type_p\n+\t       && Nkind (gnat_expr) == N_Aggregate\n+\t       && Is_Others_Aggregate (gnat_expr));\n+\n+\t  /* If we'll use memset, we need to find the inner expression.  */\n+\t  if (use_memset_p)\n+\t    {\n+\t      Node_Id gnat_inner\n+\t\t= Expression (First (Component_Associations (gnat_expr)));\n+\t      while (Nkind (gnat_inner) == N_Aggregate\n+\t\t     && Is_Others_Aggregate (gnat_inner))\n+\t\tgnat_inner\n+\t\t  = Expression (First (Component_Associations (gnat_inner)));\n+\t      gnu_rhs = gnat_to_gnu (gnat_inner);\n+\t    }\n+\t  else\n+\t    gnu_rhs = maybe_unconstrained_array (gnat_to_gnu (gnat_expr));\n \n \t  /* If range check is needed, emit code to generate it.  */\n-\t  if (Do_Range_Check (Expression (gnat_node)))\n+\t  if (Do_Range_Check (gnat_expr))\n \t    gnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)),\n \t\t\t\t\tgnat_node);\n \n+\t  /* If atomic synchronization is required, build an atomic store.  */\n \t  if (atomic_sync_required_p (Name (gnat_node)))\n \t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs);\n+\n+\t  /* Or else, use memset when the conditions are met.  */\n+\t  else if (use_memset_p)\n+\t    {\n+\t      tree value = fold_convert (integer_type_node, gnu_rhs);\n+\t      tree to = gnu_lhs;\n+\t      tree type = TREE_TYPE (to);\n+\t      tree size\n+\t        = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (type), to);\n+\t      tree to_ptr = build_fold_addr_expr (to);\n+\t      tree t = builtin_decl_implicit (BUILT_IN_MEMSET);\n+\t      if (TREE_CODE (value) == INTEGER_CST)\n+\t\t{\n+\t\t  tree mask\n+\t\t    = build_int_cst (integer_type_node,\n+\t\t\t\t     ((HOST_WIDE_INT) 1 << BITS_PER_UNIT) - 1);\n+\t\t  value = int_const_binop (BIT_AND_EXPR, value, mask);\n+\t\t}\n+\t      gnu_result = build_call_expr (t, 3, to_ptr, value, size);\n+\t    }\n+\n+\t  /* Otherwise build a regular assignment.  */\n \t  else\n \t    gnu_result\n \t      = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n \n-\t  /* If the type being assigned is an array type and the two sides are\n+\t  /* If the assignment type is a regular array and the two sides are\n \t     not completely disjoint, play safe and use memmove.  But don't do\n \t     it for a bit-packed array as it might not be byte-aligned.  */\n \t  if (TREE_CODE (gnu_result) == MODIFY_EXPR\n-\t      && Is_Array_Type (Etype (Name (gnat_node)))\n-\t      && !Is_Bit_Packed_Array (Etype (Name (gnat_node)))\n+\t      && regular_array_type_p\n \t      && !(Forwards_OK (gnat_node) && Backwards_OK (gnat_node)))\n \t    {\n-\t      tree to, from, size, to_ptr, from_ptr, t;\n-\n-\t      to = TREE_OPERAND (gnu_result, 0);\n-\t      from = TREE_OPERAND (gnu_result, 1);\n-\n-\t      size = TYPE_SIZE_UNIT (TREE_TYPE (from));\n-\t      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, from);\n-\n-\t      to_ptr = build_fold_addr_expr (to);\n-\t      from_ptr = build_fold_addr_expr (from);\n-\n-\t      t = builtin_decl_implicit (BUILT_IN_MEMMOVE);\n+\t      tree to = TREE_OPERAND (gnu_result, 0);\n+\t      tree from = TREE_OPERAND (gnu_result, 1);\n+\t      tree type = TREE_TYPE (from);\n+\t      tree size\n+\t        = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (type), from);\n+\t      tree to_ptr = build_fold_addr_expr (to);\n+\t      tree from_ptr = build_fold_addr_expr (from);\n+\t      tree t = builtin_decl_implicit (BUILT_IN_MEMMOVE);\n \t      gnu_result = build_call_expr (t, 3, to_ptr, from_ptr, size);\n \t   }\n \t}\n@@ -7457,7 +7502,10 @@ add_stmt_force (tree gnu_stmt)\n void\n add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node)\n {\n-  if (Present (gnat_node))\n+  /* Do not emit a location for renamings that come from generic instantiation,\n+     they are likely to disturb debugging.  */\n+  if (Present (gnat_node)\n+      && !renaming_from_generic_instantiation_p (gnat_node))\n     set_expr_location_from_node (gnu_stmt, gnat_node);\n   add_stmt (gnu_stmt);\n }"}, {"sha": "bf5623d522581d42b114d749ed169c671e42f852", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=ac43e11e234201441e84b5bc015587ecfff6c797", "patch": "@@ -8821,9 +8821,9 @@ In addition to the usage of this attribute in the Ada RM, @code{GNAT}\n also permits the use of the @code{'Constrained} attribute\n in a generic template\n for any type, including types without discriminants. The value of this\n-attribute in the generic instance when applied to a type without\n-discriminants is always @code{True}. This usage is compatible with\n-older Ada compilers, including notably DEC Ada.\n+attribute in the generic instance when applied to a scalar type or a\n+record type without discriminants is always @code{True}. This usage is\n+compatible with older Ada compilers, including notably DEC Ada.\n \n @node Attribute Default_Bit_Order\n @unnumberedsec Attribute Default_Bit_Order"}, {"sha": "8919a4ab7a127246cddf700ecdef10ea189391fe", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac43e11e234201441e84b5bc015587ecfff6c797/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ac43e11e234201441e84b5bc015587ecfff6c797", "patch": "@@ -3527,6 +3527,18 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n+      --  If SPARK_Mode for body is not On, disable frontend inlining for this\n+      --  subprogram in GNATprove mode, as its body should not be analyzed.\n+\n+      if SPARK_Mode /= On\n+        and then GNATprove_Mode\n+        and then Debug_Flag_QQ\n+        and then Present (Spec_Id)\n+        and then Nkind (Parent (Parent (Spec_Id))) = N_Subprogram_Declaration\n+      then\n+         Set_Body_To_Inline (Parent (Parent (Spec_Id)), Empty);\n+      end if;\n+\n       --  Check completion, and analyze the statements\n \n       Check_Completion;"}]}