{"sha": "6f837f81fcf631289a01f23bbc61476df7b2acdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY4MzdmODFmY2Y2MzEyODlhMDFmMjNiYmM2MTQ3NmRmN2IyYWNkYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-14T19:32:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-14T19:32:10Z"}, "message": "Initial revision\n\nFrom-SVN: r1838", "tree": {"sha": "2d56fc7f6021668ae72ee6768ffaf5f30e881d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d56fc7f6021668ae72ee6768ffaf5f30e881d73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f837f81fcf631289a01f23bbc61476df7b2acdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f837f81fcf631289a01f23bbc61476df7b2acdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f837f81fcf631289a01f23bbc61476df7b2acdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f837f81fcf631289a01f23bbc61476df7b2acdc/comments", "author": null, "committer": null, "parents": [{"sha": "c7c955eebcd40249f1ffd2dfca29d2c3d5b0d477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c955eebcd40249f1ffd2dfca29d2c3d5b0d477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c955eebcd40249f1ffd2dfca29d2c3d5b0d477"}], "stats": {"total": 186, "additions": 186, "deletions": 0}, "files": [{"sha": "37de6894b0f5c2e8de3e57d83860c6783893a0bc", "filename": "gcc/ginclude/va-alpha.h", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f837f81fcf631289a01f23bbc61476df7b2acdc/gcc%2Fginclude%2Fva-alpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f837f81fcf631289a01f23bbc61476df7b2acdc/gcc%2Fginclude%2Fva-alpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-alpha.h?ref=6f837f81fcf631289a01f23bbc61476df7b2acdc", "patch": "@@ -0,0 +1,186 @@\n+/* GNU C varargs and stdargs support for the DEC Alpha.  */\n+\n+/* Note:  We must use the name __builtin_savregs.  GCC attaches special\n+   significance to that name.  In particular, regardless of where in a\n+   function __builtin_saveregs is called, GCC moves the call up to the\n+   very start of the function.  */\n+\n+/* Define __gnuc_va_list.  */\n+\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+\n+typedef struct {\n+  long __va_arg;\t\t/* Current argument number. */\n+  long *__va_stack;\t\t/* Start of arguments on stack */\n+  long *__va_iregs;\t\t/* Integer parameter registers ($16-$21) */\n+  long *__va_fregs;\t\t/* FP parameter registers ($f16-$f21) */\n+} __gnuc_va_list;\n+#endif /* not __GNUC_VA_LIST */\n+\n+/* If this is for internal libc use, don't define anything but\n+   __gnuc_va_list.  */\n+#if defined (_STDARG_H) || defined (_VARARGS_H)\n+\n+#define va_list __gnuc_va_list\n+#define _VA_LIST\n+#define _VA_LIST_\n+\n+#if !defined(_STDARG_H)\n+\n+/* varargs support */\n+#define va_alist __builtin_va_alist\n+#define va_dcl\n+#define va_start(pvar) ((pvar) = * (__gnuc_va_list *) __builtin_saveregs ())\n+\n+#else /* STDARG.H */\n+\n+/* ANSI alternative.  */\n+\n+#define va_start(pvar, firstarg)  \\\n+  ((pvar) = *(__gnuc_va_list *) __builtin_saveregs ())\n+\n+#endif /* _STDARG_H */\n+\n+#define va_end(__va)\n+\n+/* Values returned by __builtin_classify_type.  */\n+\n+enum {\n+  __no_type_class = -1,\n+  __void_type_class,\n+  __integer_type_class,\n+  __char_type_class,\n+  __enumeral_type_class,\n+  __boolean_type_class,\n+  __pointer_type_class,\n+  __reference_type_class,\n+  __offset_type_class,\n+  __real_type_class,\n+  __complex_type_class,\n+  __function_type_class,\n+  __method_type_class,\n+  __record_type_class,\n+  __union_type_class,\n+  __array_type_class,\n+  __string_type_class,\n+  __set_type_class,\n+  __file_type_class,\n+  __lang_type_class\n+};\n+\n+/* Note that parameters are always aligned at least to a word boundary\n+   (when passed) regardless of what GCC's __alignof__ operator says.  */\n+\n+/* Avoid errors if compiling GCC v2 with GCC v1.  */\n+#if __GNUC__ == 1\n+#define __extension__\n+#endif\n+\n+/* Get the rounded number of words of a type.  */\n+\n+#define __va_nwords(__type)  \\\n+  ((sizeof (__type) + sizeof (long) - 1) / sizeof (long))\n+\n+#define va_arg(__va, __type)\t\t\t\t\t\t\\\n+__extension__\t\t\t\t\t\t\t\t\\\n+(* (__type *)\t\t\t\t\t\t\t\t\\\n+ ({\t\t\t\t\t\t\t\t\t\\\n+  register void *__rv;  /* result value */\t\t\t\t\\\n+  switch (__builtin_classify_type (* (__type *) 0))\t\t\t\\\n+    {\t\t\t        \t\t\t\t\t\\\n+    case __real_type_class:\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Get a pointer to the value.  If we want a float instead of\t\\\n+\t a double, we have to make one and point to it instead.  */     \\\n+\t\t\t\t\t\t\t\t\t\\\n+      __rv = (void *) & (__va.__va_arg < 6\t\t\t\t\\\n+\t\t\t ? __va.__va_fregs[__va.__va_arg]\t\t\\\n+\t\t\t : __va.__va_stack[__va.__va_arg - 6]);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (sizeof (__type) == sizeof (float))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  float __rf = * ((double *) __rv);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  __rv = (void *) &__rf;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t      \t\t\t\t\t\t\t\t\\\n+    case __void_type_class:\t\t\t\t\t\t\\\n+    case __integer_type_class:\t\t\t\t\t\t\\\n+    case __char_type_class:\t\t\t\t\t\t\\\n+    case __enumeral_type_class:\t\t\t\t\t\t\\\n+    case __boolean_type_class:\t\t\t\t\t\t\\\n+    case __pointer_type_class:\t\t\t\t\t\t\\\n+    case __reference_type_class:\t\t\t\t\t\\\n+    case __offset_type_class:\t\t\t\t\t\t\\\n+    case __record_type_class:\t\t\t\t\t\t\\\n+    case __union_type_class:\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Force this on the stack if it's alignment isn't right.  */\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (__va.__va_arg < 6)\t\t\t\t\t\t\\\n+\tswitch (sizeof (__type))\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t  case sizeof (char):\t\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case sizeof (short):\t\t\t\t\t\t\\\n+\t    if (__alignof__ (__type) < sizeof (short))\t\t\t\\\n+\t      __va.__va_arg = 6;\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case 3:\t\t\t\t\t\t\t\\\n+\t  case sizeof (int):\t\t\t\t\t\t\\\n+\t    if (__alignof__ (__type) < sizeof (int))\t\t\t\\\n+\t      __va.__va_arg = 6;\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  default:\t\t\t\t\t\t\t\\\n+\t    if (__alignof__ (__type) < sizeof (long))\t\t\t\\\n+\t      __va.__va_arg = 6;\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* If this object is only one word long, just get it.  If it is   \\\n+\t longer, we need to worry about the possibility that it is\t\\\n+\t passed both in registers and in memory.  */\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (sizeof (__type) <= sizeof (long)\t\t\t\t\\\n+\t  || __va.__va_arg >= 6\t\t\t\t\t\\\n+\t  || __va.__va_arg + __va_nwords (__type) < 6)\t\t\t\\\n+\t__rv = (void *) & (__va.__va_arg < 6\t\t\t\t\\\n+\t\t\t   ? __va.__va_iregs[__va.__va_arg]\t\t\\\n+\t\t\t   : __va.__va_stack[__va.__va_arg - 6]);\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  long __obj[__va_nwords (__type)];\t\t\t\t\\\n+\t  int __i;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  for (__i = 0; __i < __va_nwords (__type); __i++)\t\t\\\n+\t    __obj[__i] = (__va.__va_arg < 6\t\t\t\t\\\n+\t\t\t  ? __va.__va_iregs[__va.__va_arg]\t\t\\\n+\t\t\t  : __va.__va_stack[__va.__va_arg - 6]);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  __rv = (void *) &__obj[0];\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    case __complex_type_class:\t\t\t\t\t\t\\\n+    case __function_type_class:\t\t\t\t\t\t\\\n+    case __method_type_class:\t\t\t\t\t\t\\\n+    case __array_type_class:\t\t\t\t\t\t\\\n+    case __string_type_class:\t\t\t\t\t\t\\\n+    case __set_type_class:\t\t\t\t\t\t\\\n+    case __file_type_class:\t\t\t\t\t\t\\\n+    case __lang_type_class:\t\t\t\t\t\t\\\n+    case __no_type_class:\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  __va.__va_arg += __va_nwords (__type);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  __rv;\t\t\t\t\t\t\t\t\t\\\n+}))\n+\n+#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */\n+"}]}