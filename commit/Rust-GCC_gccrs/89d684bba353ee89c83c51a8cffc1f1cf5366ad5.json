{"sha": "89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkNjg0YmJhMzUzZWU4OWM4M2M1MWE4Y2ZmYzFmMWNmNTM2NmFkNQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2001-11-22T02:33:02Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-11-22T02:33:02Z"}, "message": "tree-dump.c: Rename from c-dump.c.\n\n\t* tree-dump.c: Rename from c-dump.c. Include c-tree.h, not c-common.h.\n\t(lang_type_quals): Declare.\n\t(dequeue_and_dump): Use lang_hooks.tree_dump.type_quals function to\n\tretrieve language-specific qualifiers for a type node, instead of\n\tC_TYPE_QUALS. Likewise for lang_hooks.tree_dump.dump_tree instead of\n\tlang_dump_tree.\n\t* tree-dump.h: Rename from c-dump.h.\n\t* c-common.h (C_TYPE_QUALS): Removed.\n\tMove declarations for tree-dump.c interface to...\n\t* tree.h: ... here. Remove lang_dump_tree.\n\t* langhooks.h (struct lang_hooks_for_tree_dump): New.\n\t(struct lang_hooks): Add tree_dump hooks.\n\t* langhooks.c (lhd_tree_dump_dump_tree): New function.\n\t(lhd_tree_dump_type_quals): New function.\n\t* langhooks-def.h (lhd_tree_dump_dump_tree, lhd_tree_dump_type_quals):\n\tDeclare.\n\t(LANG_HOOKS_INITIALIZER): Add tree_dump hooks.\n\t* Makefile.in: Move tree-dump.o to language-independent back-end.\n\ncp:\n\t* cp-tree.h (CP_TYPE_QUALS): Removed.\n\t* decl.c (cxx_init_decl_processing): Don't set lang_dump_tree.\n\t* cp-lang.c: Set LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN and\n\tLANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN.\n\t* dump.c (cp_dump_tree): Use void* dump_info argument to match\n\tlang-hooks prototype.\n\t* call.c, cp-tree.h, cvt.c, decl.c, init.c, mangle.c, method.c, pt.c,\n\trtti.c, semantics.c, tree.c, typeck.c, typeck2.c: All references to\n\tCP_TYPE_QUALS changed to cp_type_quals.\n\t* Make-lang.in: References to c-dump.h changed to tree-dump.h.\n\t(CXX_C_OBJS): Remove c-dump.o.\n\nFrom-SVN: r47257", "tree": {"sha": "0e638461639b9ee591262162e137dc8d4432891b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e638461639b9ee591262162e137dc8d4432891b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/comments", "author": null, "committer": null, "parents": [{"sha": "4617e3b52be023a28be288988fa0b299aefdc97b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4617e3b52be023a28be288988fa0b299aefdc97b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4617e3b52be023a28be288988fa0b299aefdc97b"}], "stats": {"total": 1364, "additions": 203, "deletions": 1161}, "files": [{"sha": "4909aaca435d2b01f45de61185da2ddb719d4f05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -1,3 +1,24 @@\n+2001-11-21  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* tree-dump.c: Rename from c-dump.c. Include c-tree.h, not c-common.h.\n+\t(lang_type_quals): Declare.\n+\t(dequeue_and_dump): Use lang_hooks.tree_dump.type_quals function to \n+\tretrieve language-specific qualifiers for a type node, instead of \n+\tC_TYPE_QUALS. Likewise for lang_hooks.tree_dump.dump_tree instead of \n+\tlang_dump_tree.\n+\t* tree-dump.h: Rename from c-dump.h.\n+\t* c-common.h (C_TYPE_QUALS): Removed.\n+\tMove declarations for tree-dump.c interface to...\n+\t* tree.h: ... here. Remove lang_dump_tree.\n+\t* langhooks.h (struct lang_hooks_for_tree_dump): New.\n+\t(struct lang_hooks): Add tree_dump hooks.\n+\t* langhooks.c (lhd_tree_dump_dump_tree): New function.\n+\t(lhd_tree_dump_type_quals): New function.\n+\t* langhooks-def.h (lhd_tree_dump_dump_tree, lhd_tree_dump_type_quals):\n+\tDeclare.\n+\t(LANG_HOOKS_INITIALIZER): Add tree_dump hooks.\n+\t* Makefile.in: Move tree-dump.o to language-independent back-end.\n+\n 2001-11-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* 1750a.h (DBX_REGISTER_NUMBER): Don't define."}, {"sha": "f88b0b4bf1e924e240e380260825742d1b24dee3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -723,7 +723,7 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n \n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n-  c-convert.o c-aux-info.o c-common.o c-format.o c-semantics.o c-dump.o \\\n+  c-convert.o c-aux-info.o c-common.o c-format.o c-semantics.o \\\n   libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n@@ -745,8 +745,9 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t\\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t\\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t\\\n  sibcall.o simplify-rtx.o splay-tree.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\\\n- stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-inline.o \t\\\n- unroll.o varasm.o varray.o version.o xcoffout.o cfglayout.o\t\t\\\n+ stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-dump.o \t\\\n+ tree-inline.o unroll.o varasm.o varray.o version.o xcoffout.o \t\t\\\n+ cfglayout.o\t\t\t\t\t\t\t\t\\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n BACKEND = main.o libbackend.a\n@@ -1264,10 +1265,6 @@ c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n \tc-lex.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H)\n \n-c-dump.o: c-dump.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n-\tc-lex.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n-\t$(EXPR_H) $(SPLAY_TREE_H) c-dump.h\n-\n # Language-independent files.\n \n DRIVER_DEFINES = \\\n@@ -1352,6 +1349,9 @@ langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) toplev.h \\\n    tree-inline.h $(RTL_H) insn-config.h integrate.h langhooks.h langhooks-def.h\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h function.h toplev.h \\\n    $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h\n+tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n+   flags.h langhooks.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n+   $(EXPR_H) $(SPLAY_TREE_H) tree-dump.h\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n    expr.h flags.h params.h input.h insn-config.h $(INTEGRATE_H) \\\n    $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h langhooks.h \\"}, {"sha": "b289cb8b24f2edcce14c4dc07ec0cba2fea8cf23", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -457,14 +457,6 @@ extern int warn_long_long;\n #define C_TYPE_FUNCTION_P(type) \\\n   (TREE_CODE (type) == FUNCTION_TYPE)\n \n-/* Return the qualifiers that apply to this type.  In C++, that means\n-   descending through array types.  Note that this macro evaluates its\n-   arguments more than once.  */\n-#define C_TYPE_QUALS(TYPE)\t\t\t\t\\\n-  (TYPE_QUALS ((TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-\t\t&& c_language == clk_cplusplus)\t\t\\\n-\t       ? strip_array_types (TYPE) : TYPE))\n-\n /* For convenience we define a single macro to identify the class of\n    object or incomplete types.  */\n #define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n@@ -819,45 +811,6 @@ extern int c_safe_from_p                        PARAMS ((rtx, tree));\n \n extern int c_unsafe_for_reeval\t\t\tPARAMS ((tree));\n \n-/* In c-dump.c */\n-\n-/* Different tree dump places.  When you add new tree dump places,\n-   extend the DUMP_FILES array in c-dump.c */\n-enum tree_dump_index\n-{\n-  TDI_all,\t\t\t/* dump the whole translation unit */\n-  TDI_class,\t\t\t/* dump class hierarchy */\n-  TDI_original,\t\t\t/* dump each function before optimizing it */\n-  TDI_optimized,\t\t/* dump each function after optimizing it */\n-  TDI_inlined,\t\t\t/* dump each function after inlining\n-\t\t\t\t   within it.  */\n-  TDI_end\n-};\n-\n-/* Bit masks to control tree dumping. Not all values are applicable to\n-   all tree dumps. Add new ones at the end. When you define new\n-   values, extend the DUMP_OPTIONS array in c-dump.c */\n-#define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n-#define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n-\n-typedef struct dump_info *dump_info_p;\n-\n-/* A callback function used dump language-specific parts of tree\n-   nodes.  Returns non-zero if it does not want the usual dumping of\n-   the second argument.  */\n-\n-typedef int (*dump_tree_fn) PARAMS ((dump_info_p, tree));\n-\n-extern dump_tree_fn lang_dump_tree;\n-\n-extern int dump_flag\t\t\tPARAMS ((dump_info_p, int, tree));\n-extern int dump_enabled_p\t\tPARAMS ((enum tree_dump_index));\n-extern FILE *dump_begin\t\t\tPARAMS ((enum tree_dump_index, int *));\n-extern void dump_end\t\t\tPARAMS ((enum tree_dump_index, FILE *));\n-extern void dump_node\t\t\tPARAMS ((tree, int, FILE *));\n-extern int dump_switch_p                PARAMS ((const char *));\n-extern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n-\n /* Information recorded about each file examined during compilation.  */\n \n struct c_fileinfo"}, {"sha": "7f3dbdd3734671fed4a8bdc20d2767b77bb80f12", "filename": "gcc/c-dump.c", "status": "removed", "additions": 0, "deletions": 933, "changes": 933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4617e3b52be023a28be288988fa0b299aefdc97b/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4617e3b52be023a28be288988fa0b299aefdc97b/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=4617e3b52be023a28be288988fa0b299aefdc97b", "patch": "@@ -1,933 +0,0 @@\n-/* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n-   Written by Mark Mitchell <mark@codesourcery.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"c-common.h\"\n-#include \"splay-tree.h\"\n-#include \"diagnostic.h\"\n-#include \"toplev.h\"\n-#include \"c-dump.h\"\n-\n-/* A callback function used dump language-specific parts of tree\n-   nodes.  Returns non-zero if it does not want the usual dumping of\n-   the second argument.  */\n-\n-dump_tree_fn lang_dump_tree;\n-\n-static unsigned int queue PARAMS ((dump_info_p, tree, int));\n-static void dump_index PARAMS ((dump_info_p, unsigned int));\n-static void dequeue_and_dump PARAMS ((dump_info_p));\n-static void dump_new_line PARAMS ((dump_info_p));\n-static void dump_maybe_newline PARAMS ((dump_info_p));\n-static void dump_string_field PARAMS ((dump_info_p, const char *, const char *));\n-\n-/* Add T to the end of the queue of nodes to dump.  Returns the index\n-   assigned to T.  */\n-\n-static unsigned int\n-queue (di, t, flags)\n-     dump_info_p di;\n-     tree t;\n-     int flags;\n-{\n-  dump_queue_p dq;\n-  dump_node_info_p dni;\n-  unsigned int index;\n-\n-  /* Assign the next available index to T.  */\n-  index = ++di->index;\n-\n-  /* Obtain a new queue node.  */\n-  if (di->free_list)\n-    {\n-      dq = di->free_list;\n-      di->free_list = dq->next;\n-    }\n-  else\n-    dq = (dump_queue_p) xmalloc (sizeof (struct dump_queue));\n-\n-  /* Create a new entry in the splay-tree.  */\n-  dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n-  dni->index = index;\n-  dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n-  dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t, \n-\t\t\t\t(splay_tree_value) dni);\n-\n-  /* Add it to the end of the queue.  */\n-  dq->next = 0;\n-  if (!di->queue_end)\n-    di->queue = dq;\n-  else\n-    di->queue_end->next = dq;\n-  di->queue_end = dq;\n-\n-  /* Return the index.  */\n-  return index;\n-}\n-\n-static void\n-dump_index (di, index)\n-     dump_info_p di;\n-     unsigned int index;\n-{\n-  fprintf (di->stream, \"@%-6u \", index);\n-  di->column += 8;\n-}\n-\n-/* If T has not already been output, queue it for subsequent output.\n-   FIELD is a string to print before printing the index.  Then, the\n-   index of T is printed.  */\n-\n-void\n-queue_and_dump_index (di, field, t, flags)\n-     dump_info_p di;\n-     const char *field;\n-     tree t;\n-     int flags;\n-{\n-  unsigned int index;\n-  splay_tree_node n;\n-\n-  /* If there's no node, just return.  This makes for fewer checks in\n-     our callers.  */\n-  if (!t)\n-    return;\n-\n-  /* See if we've already queued or dumped this node.  */\n-  n = splay_tree_lookup (di->nodes, (splay_tree_key) t);\n-  if (n)\n-    index = ((dump_node_info_p) n->value)->index;\n-  else\n-    /* If we haven't, add it to the queue.  */\n-    index = queue (di, t, flags);\n-\n-  /* Print the index of the node.  */\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-4s: \", field);\n-  di->column += 6;\n-  dump_index (di, index);\n-}\n-\n-/* Dump the type of T.  */\n-\n-void\n-queue_and_dump_type (di, t)\n-     dump_info_p di;\n-     tree t;\n-{\n-  queue_and_dump_index (di, \"type\", TREE_TYPE (t), DUMP_NONE);\n-}\n-\n-/* Dump column control */\n-#define SOL_COLUMN 25\t\t/* Start of line column.  */\n-#define EOL_COLUMN 55\t\t/* End of line column.  */\n-#define COLUMN_ALIGNMENT 15\t/* Alignment.  */\n-\n-/* Insert a new line in the dump output, and indent to an appropriate\n-   place to start printing more fields.  */\n-\n-static void\n-dump_new_line (di)\n-     dump_info_p di;\n-{\n-  fprintf (di->stream, \"\\n%*s\", SOL_COLUMN, \"\");\n-  di->column = SOL_COLUMN;\n-}\n-\n-/* If necessary, insert a new line.  */\n-\n-static void\n-dump_maybe_newline (di)\n-     dump_info_p di;\n-{\n-  int extra;\n-  \n-  /* See if we need a new line.  */\n-  if (di->column > EOL_COLUMN)\n-    dump_new_line (di);\n-  /* See if we need any padding.  */\n-  else if ((extra = (di->column - SOL_COLUMN) % COLUMN_ALIGNMENT) != 0)\n-    {\n-      fprintf (di->stream, \"%*s\", COLUMN_ALIGNMENT - extra, \"\");\n-      di->column += COLUMN_ALIGNMENT - extra;\n-    }\n-}\n-\n-/* Dump pointer PTR using FIELD to identify it.  */\n-\n-void\n-dump_pointer (di, field, ptr)\n-     dump_info_p di;\n-     const char *field;\n-     void *ptr;\n-{\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-4s: %-8lx \", field, (long) ptr);\n-  di->column += 15;\n-}\n-\n-/* Dump integer I using FIELD to identify it.  */\n-\n-void\n-dump_int (di, field, i)\n-     dump_info_p di;\n-     const char *field;\n-     int i;\n-{\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-4s: %-7d \", field, i);\n-  di->column += 14;\n-}\n-\n-/* Dump the string S.  */\n-\n-void\n-dump_string (di, string)\n-     dump_info_p di;\n-     const char *string;\n-{\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-13s \", string);\n-  if (strlen (string) > 13)\n-    di->column += strlen (string) + 1;\n-  else\n-    di->column += 14;\n-}\n-\n-/* Dump the string field S.  */\n-\n-static void\n-dump_string_field (di, field, string)\n-     dump_info_p di;\n-     const char *field;\n-     const char *string;\n-{\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-4s: %-7s \", field, string);\n-  if (strlen (string) > 7)\n-    di->column += 6 + strlen (string) + 1;\n-  else\n-    di->column += 14;\n-}\n-\n-/* Dump information common to statements from STMT.  */\n-\n-void\n-dump_stmt (di, t)\n-     dump_info_p di;\n-     tree t;\n-{\n-  dump_int (di, \"line\", STMT_LINENO (t));\n-}\n-\n-/* Dump the next statement after STMT.  */\n-\n-void\n-dump_next_stmt (di, t)\n-     dump_info_p di;\n-     tree t;\n-{\n-  dump_child (\"next\", TREE_CHAIN (t));\n-}\n-\n-/* Dump the next node in the queue.  */\n-\n-static void \n-dequeue_and_dump (di)\n-     dump_info_p di;\n-{\n-  dump_queue_p dq;\n-  splay_tree_node stn;\n-  dump_node_info_p dni;\n-  tree t;\n-  unsigned int index;\n-  enum tree_code code;\n-  char code_class;\n-  const char* code_name;\n-\n-  /* Get the next node from the queue.  */\n-  dq = di->queue;\n-  stn = dq->node;\n-  t = (tree) stn->key;\n-  dni = (dump_node_info_p) stn->value;\n-  index = dni->index;\n-\n-  /* Remove the node from the queue, and put it on the free list.  */\n-  di->queue = dq->next;\n-  if (!di->queue)\n-    di->queue_end = 0;\n-  dq->next = di->free_list;\n-  di->free_list = dq;\n-\n-  /* Print the node index.  */\n-  dump_index (di, index);\n-  /* And the type of node this is.  */\n-  if (dni->binfo_p)\n-    code_name = \"binfo\";\n-  else\n-    code_name = tree_code_name[(int) TREE_CODE (t)];\n-  fprintf (di->stream, \"%-16s \", code_name);\n-  di->column = 25;\n-\n-  /* Figure out what kind of node this is.  */\n-  code = TREE_CODE (t);\n-  code_class = TREE_CODE_CLASS (code);\n-\n-  /* Although BINFOs are TREE_VECs, we dump them specially so as to be\n-     more informative.  */\n-  if (dni->binfo_p)\n-    {\n-      if (TREE_VIA_PUBLIC (t))\n-\tdump_string (di, \"pub\");\n-      else if (TREE_VIA_PROTECTED (t))\n-\tdump_string (di, \"prot\");\n-      else if (TREE_VIA_PRIVATE (t))\n-\tdump_string (di, \"priv\");\n-      if (TREE_VIA_VIRTUAL (t))\n-\tdump_string (di, \"virt\");\n-\t    \n-      dump_child (\"type\", BINFO_TYPE (t));\n-      dump_child (\"base\", BINFO_BASETYPES (t));\n-\n-      goto done;\n-    }\n-\n-  /* We can knock off a bunch of expression nodes in exactly the same\n-     way.  */\n-  if (IS_EXPR_CODE_CLASS (code_class))\n-    {\n-      /* If we're dumping children, dump them now.  */\n-      queue_and_dump_type (di, t);\n-\n-      switch (code_class)\n-\t{\n-\tcase '1':\n-\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-\t  break;\n-\t      \n-\tcase '2':\n-\tcase '<':\n-\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-\t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-\t  break;\n-\t      \n-\tcase 'e':\n-\t  /* These nodes are handled explicitly below.  */\n-\t  break;\n-\t      \n-\tdefault:\n-\t  abort();\n-\t}\n-    }\n-  else if (DECL_P (t))\n-    {\n-      /* All declarations have names.  */\n-      if (DECL_NAME (t))\n-\tdump_child (\"name\", DECL_NAME (t));\n-      if (DECL_ASSEMBLER_NAME_SET_P (t) \n-\t  && DECL_ASSEMBLER_NAME (t) != DECL_NAME (t))\n-\tdump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n-      /* And types.  */\n-      queue_and_dump_type (di, t);\n-      dump_child (\"scpe\", DECL_CONTEXT (t));\n-      /* And a source position.  */\n-      if (DECL_SOURCE_FILE (t))\n-\t{\n-\t  const char *filename = strrchr (DECL_SOURCE_FILE (t), '/');\n-\t  if (!filename)\n-\t    filename = DECL_SOURCE_FILE (t);\n-\t  else\n-\t    /* Skip the slash.  */\n-\t    ++filename;\n-\n-\t  dump_maybe_newline (di);\n-\t  fprintf (di->stream, \"srcp: %s:%-6d \", filename, \n-\t\t   DECL_SOURCE_LINE (t));\n-\t  di->column += 6 + strlen (filename) + 8;\n-\t}\n-      /* And any declaration can be compiler-generated.  */\n-      if (DECL_ARTIFICIAL (t))\n-\tdump_string (di, \"artificial\");\n-      if (TREE_CHAIN (t) && !dump_flag (di, TDF_SLIM, NULL))\n-\tdump_child (\"chan\", TREE_CHAIN (t));\n-    }\n-  else if (code_class == 't')\n-    {\n-      /* All types have qualifiers.  */\n-      int quals = C_TYPE_QUALS (t);\n-      if (quals != TYPE_UNQUALIFIED)\n-\t{\n-\t  fprintf (di->stream, \"qual: %c%c%c     \",\n-\t\t   (quals & TYPE_QUAL_CONST) ? 'c' : ' ',\n-\t\t   (quals & TYPE_QUAL_VOLATILE) ? 'v' : ' ',\n-\t\t   (quals & TYPE_QUAL_RESTRICT) ? 'r' : ' ');\n-\t  di->column += 14;\n-\t}\n-\n-      /* All types have associated declarations.  */\n-      dump_child (\"name\", TYPE_NAME (t));\n-\n-      /* All types have a main variant.  */\n-      if (TYPE_MAIN_VARIANT (t) != t)\n-\tdump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n-      \n-      /* And sizes.  */\n-      dump_child (\"size\", TYPE_SIZE (t));\n-\n-      /* All types have alignments.  */\n-      dump_int (di, \"algn\", TYPE_ALIGN (t));\n-    }\n-  else if (code_class == 'c')\n-    /* All constants can have types.  */\n-    queue_and_dump_type (di, t);\n-\n-  /* Give the language-specific code a chance to print something.  If\n-     it's completely taken care of things, don't bother printing\n-     anything more ourselves.  */\n-  if (lang_dump_tree && (*lang_dump_tree) (di, t))\n-    goto done;\n-\n-  /* Now handle the various kinds of nodes.  */\n-  switch (code)\n-    {\n-      int i;\n-\n-    case IDENTIFIER_NODE:\n-      dump_string_field (di, \"strg\", IDENTIFIER_POINTER (t));\n-      dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n-      break;\n-\n-    case TREE_LIST:\n-      dump_child (\"purp\", TREE_PURPOSE (t));\n-      dump_child (\"valu\", TREE_VALUE (t));\n-      dump_child (\"chan\", TREE_CHAIN (t));\n-      break;\n-\n-    case TREE_VEC:\n-      dump_int (di, \"lngt\", TREE_VEC_LENGTH (t));\n-      for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n-\t{\n-\t  char buffer[32];\n-\t  sprintf (buffer, \"%u\", i);\n-\t  dump_child (buffer, TREE_VEC_ELT (t, i));\n-\t}\n-      break;\n-\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-      dump_int (di, \"prec\", TYPE_PRECISION (t));\n-      if (TREE_UNSIGNED (t))\n-\tdump_string (di, \"unsigned\");\n-      dump_child (\"min\", TYPE_MIN_VALUE (t));\n-      dump_child (\"max\", TYPE_MAX_VALUE (t));\n-\n-      if (code == ENUMERAL_TYPE)\n-\tdump_child (\"csts\", TYPE_VALUES (t));\n-      break;\n-\n-    case REAL_TYPE:\n-      dump_int (di, \"prec\", TYPE_PRECISION (t));\n-      break;\n-\n-    case POINTER_TYPE:\n-      dump_child (\"ptd\", TREE_TYPE (t));\n-      break;\n-\n-    case REFERENCE_TYPE:\n-      dump_child (\"refd\", TREE_TYPE (t));\n-      break;\n-\n-    case METHOD_TYPE:\n-      dump_child (\"clas\", TYPE_METHOD_BASETYPE (t));\n-      /* Fall through.  */\n-\n-    case FUNCTION_TYPE:\n-      dump_child (\"retn\", TREE_TYPE (t));\n-      dump_child (\"prms\", TYPE_ARG_TYPES (t));\n-      break;\n-\n-    case ARRAY_TYPE:\n-      dump_child (\"elts\", TREE_TYPE (t));\n-      dump_child (\"domn\", TYPE_DOMAIN (t));\n-      break;\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-      if (TREE_CODE (t) == RECORD_TYPE)\n-\tdump_string (di, \"struct\");\n-      else\n-\tdump_string (di, \"union\");\n-      \n-      dump_child (\"flds\", TYPE_FIELDS (t));\n-      dump_child (\"fncs\", TYPE_METHODS (t));\n-      queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n-\t\t\t    DUMP_BINFO);\n-      break;\n-\n-    case CONST_DECL:\n-      dump_child (\"cnst\", DECL_INITIAL (t));\n-      break;\n-\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case FIELD_DECL:\n-    case RESULT_DECL:\n-      if (TREE_CODE (t) == PARM_DECL)\n-\tdump_child (\"argt\", DECL_ARG_TYPE (t));\n-      else\n-\tdump_child (\"init\", DECL_INITIAL (t));\n-      dump_child (\"size\", DECL_SIZE (t));\n-      dump_int (di, \"algn\", DECL_ALIGN (t));\n-\n-      if (TREE_CODE (t) == FIELD_DECL)\n-\t{\n-\t  if (DECL_C_BIT_FIELD (t))\n-\t    dump_string (di, \"bitfield\");\n-\t  if (DECL_FIELD_OFFSET (t))\n-\t    dump_child (\"bpos\", bit_position (t));\n-\t}\n-      else if (TREE_CODE (t) == VAR_DECL \n-\t       || TREE_CODE (t) == PARM_DECL)\n-\t{\n-\t  dump_int (di, \"used\", TREE_USED (t));\n-\t  if (DECL_REGISTER (t))\n-\t    dump_string (di, \"register\");\n-\t}\n-      break;\n-\n-    case FUNCTION_DECL:\n-      dump_child (\"args\", DECL_ARGUMENTS (t));\n-      if (DECL_EXTERNAL (t))\n-\tdump_string (di, \"undefined\");\n-      if (TREE_PUBLIC (t))\n-\tdump_string (di, \"extern\");\n-      else\n-\tdump_string (di, \"static\");\n-      if (DECL_LANG_SPECIFIC (t) && !dump_flag (di, TDF_SLIM, t))\n-\tdump_child (\"body\", DECL_SAVED_TREE (t));\n-      break;\n-\n-    case ASM_STMT:\n-      dump_stmt (di, t);\n-      if (ASM_VOLATILE_P (t))\n-\tdump_string (di, \"volatile\");\n-      dump_child (\"strg\", ASM_STRING (t));\n-      dump_child (\"outs\", ASM_OUTPUTS (t));\n-      dump_child (\"ins\", ASM_INPUTS (t));\n-      dump_child (\"clbr\", ASM_CLOBBERS (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case BREAK_STMT:\n-    case CONTINUE_STMT:\n-      dump_stmt (di, t);\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case CASE_LABEL:\n-      /* Note that a case label is not like other statements; there is\n-\t no way to get the line-number of a case label.  */\n-      dump_child (\"low\", CASE_LOW (t));\n-      dump_child (\"high\", CASE_HIGH (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case COMPOUND_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"body\", COMPOUND_BODY (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case DECL_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"decl\", DECL_STMT_DECL (t));\n-      dump_next_stmt (di, t);\n-      break;\n-      \n-    case DO_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"body\", DO_BODY (t));\n-      dump_child (\"cond\", DO_COND (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case EXPR_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"expr\", EXPR_STMT_EXPR (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case FOR_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"init\", FOR_INIT_STMT (t));\n-      dump_child (\"cond\", FOR_COND (t));\n-      dump_child (\"expr\", FOR_EXPR (t));\n-      dump_child (\"body\", FOR_BODY (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case GOTO_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"dest\", GOTO_DESTINATION (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case IF_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", IF_COND (t));\n-      dump_child (\"then\", THEN_CLAUSE (t));\n-      dump_child (\"else\", ELSE_CLAUSE (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case LABEL_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"labl\", LABEL_STMT_LABEL (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case RETURN_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"expr\", RETURN_EXPR (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case SWITCH_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", SWITCH_COND (t));\n-      dump_child (\"body\", SWITCH_BODY (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case WHILE_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", WHILE_COND (t));\n-      dump_child (\"body\", WHILE_BODY (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case SCOPE_STMT:\n-      dump_stmt (di, t);\n-      if (SCOPE_BEGIN_P (t))\n-\tdump_string (di, \"begn\");\n-      else\n-\tdump_string (di, \"end\");\n-      if (SCOPE_NULLIFIED_P (t))\n-\tdump_string (di, \"null\");\n-      if (!SCOPE_NO_CLEANUPS_P (t))\n-\tdump_string (di, \"clnp\");\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case INTEGER_CST:\n-      if (TREE_INT_CST_HIGH (t))\n-\tdump_int (di, \"high\", TREE_INT_CST_HIGH (t));\n-      dump_int (di, \"low\", TREE_INT_CST_LOW (t));\n-      break;\n-\n-    case STRING_CST:\n-      fprintf (di->stream, \"strg: %-7s \", TREE_STRING_POINTER (t));\n-      dump_int (di, \"lngt\", TREE_STRING_LENGTH (t));\n-      break;\n-\n-    case TRUTH_NOT_EXPR:\n-    case ADDR_EXPR:\n-    case INDIRECT_REF:\n-    case CLEANUP_POINT_EXPR:\n-    case SAVE_EXPR:\n-      /* These nodes are unary, but do not have code class `1'.  */\n-      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-      break;\n-\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case INIT_EXPR:\n-    case MODIFY_EXPR:\n-    case COMPONENT_REF:\n-    case COMPOUND_EXPR:\n-    case ARRAY_REF:\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-      /* These nodes are binary, but do not have code class `2'.  */\n-      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case COND_EXPR:\n-      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-      dump_child (\"op 2\", TREE_OPERAND (t, 2));\n-      break;\n-\n-    case CALL_EXPR:\n-      dump_child (\"fn\", TREE_OPERAND (t, 0));\n-      dump_child (\"args\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case CONSTRUCTOR:\n-      dump_child (\"elts\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case STMT_EXPR:\n-      dump_child (\"stmt\", STMT_EXPR_STMT (t));\n-      break;\n-\n-    case BIND_EXPR:\n-      dump_child (\"vars\", TREE_OPERAND (t, 0));\n-      dump_child (\"body\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case LOOP_EXPR:\n-      dump_child (\"body\", TREE_OPERAND (t, 0));\n-      break;\n-\n-    case EXIT_EXPR:\n-      dump_child (\"cond\", TREE_OPERAND (t, 0));\n-      break;\n-\n-    case TARGET_EXPR:\n-      dump_child (\"decl\", TREE_OPERAND (t, 0));\n-      dump_child (\"init\", TREE_OPERAND (t, 1));\n-      dump_child (\"clnp\", TREE_OPERAND (t, 2));\n-      /* There really are two possible places the initializer can be.\n-\t After RTL expansion, the second operand is moved to the\n-\t position of the fourth operand, and the second operand\n-\t becomes NULL.  */\n-      dump_child (\"init\", TREE_OPERAND (t, 3));\n-      break;\n-      \n-    case EXPR_WITH_FILE_LOCATION:\n-      dump_child (\"expr\", EXPR_WFL_NODE (t));\n-      break;\n-\n-    default:\n-      /* There are no additional fields to print.  */\n-      break;\n-    }\n-\n- done:\n-  if (dump_flag (di, TDF_ADDRESS, NULL))\n-    dump_pointer (di, \"addr\", (void *)t);\n-  \n-  /* Terminate the line.  */\n-  fprintf (di->stream, \"\\n\");\n-}\n-\n-/* Return non-zero if FLAG has been specified for the dump, and NODE\n-   is not the root node of the dump.  */\n-\n-int dump_flag (di, flag, node)\n-     dump_info_p di;\n-     int flag;\n-     tree node;\n-{\n-  return (di->flags & flag) && (node != di->node);\n-}\n-\n-/* Dump T, and all its children, on STREAM.  */\n-\n-void\n-dump_node (t, flags, stream)\n-     tree t;\n-     int flags;\n-     FILE *stream;\n-{\n-  struct dump_info di;\n-  dump_queue_p dq;\n-  dump_queue_p next_dq;\n-\n-  /* Initialize the dump-information structure.  */\n-  di.stream = stream;\n-  di.index = 0;\n-  di.column = 0;\n-  di.queue = 0;\n-  di.queue_end = 0;\n-  di.free_list = 0;\n-  di.flags = flags;\n-  di.node = t;\n-  di.nodes = splay_tree_new (splay_tree_compare_pointers, 0, \n-\t\t\t     (splay_tree_delete_value_fn) &free);\n-\n-  /* Queue up the first node.  */\n-  queue (&di, t, DUMP_NONE);\n-\n-  /* Until the queue is empty, keep dumping nodes.  */\n-  while (di.queue)\n-    dequeue_and_dump (&di);\n-\n-  /* Now, clean up.  */\n-  for (dq = di.free_list; dq; dq = next_dq)\n-    {\n-      next_dq = dq->next;\n-      free (dq);\n-    }\n-  splay_tree_delete (di.nodes);\n-}\n-\n-/* Define a tree dump switch.  */\n-struct dump_file_info\n-{\n-  const char *suffix;\t\t/* suffix to give output file.  */\n-  const char *swtch;\t\t/* command line switch */\n-  int flags;\t\t\t/* user flags */\n-  int state;\t\t\t/* state of play */\n-};\n-\n-/* Table of tree dump switches. This must be consistent with the\n-   TREE_DUMP_INDEX enumeration in c-common.h */\n-static struct dump_file_info dump_files[TDI_end] =\n-{\n-  {\".tu\", \"dump-translation-unit\", 0, 0},\n-  {\".class\", \"dump-class-hierarchy\", 0, 0},\n-  {\".original\", \"dump-tree-original\", 0, 0},\n-  {\".optimized\", \"dump-tree-optimized\", 0, 0},\n-  {\".inlined\", \"dump-tree-inlined\", 0, 0},\n-};\n-\n-/* Define a name->number mapping for a dump flag value.  */\n-struct dump_option_value_info\n-{\n-  const char *const name;\t/* the name of the value */\n-  const int value;\t\t/* the value of the name */\n-};\n-\n-/* Table of dump options. This must be consistent with the TDF_* flags\n-   in c-common.h */\n-static const struct dump_option_value_info dump_options[] =\n-{\n-  {\"address\", TDF_ADDRESS},\n-  {\"slim\", TDF_SLIM},\n-  {\"all\", ~0},\n-  {NULL, 0}\n-};\n-\n-/* Begin a tree dump for PHASE. Stores any user supplied flag in\n-   *FLAG_PTR and returns a stream to write to. If the dump is not\n-   enabled, returns NULL.\n-   Multiple calls will reopen and append to the dump file.  */\n-\n-FILE *\n-dump_begin (phase, flag_ptr)\n-     enum tree_dump_index phase;\n-     int *flag_ptr;\n-{\n-  FILE *stream;\n-  char *name;\n-  \n-  if (!dump_files[phase].state)\n-    return NULL;\n-  \n-  name = concat (dump_base_name, dump_files[phase].suffix, NULL);\n-  stream = fopen (name, dump_files[phase].state < 0 ? \"w\" : \"a\");\n-  if (!stream)\n-    error (\"could not open dump file `%s'\", name);\n-  else\n-    dump_files[phase].state = 1;\n-  free (name);\n-  if (flag_ptr)\n-    *flag_ptr = dump_files[phase].flags;\n-  \n-  return stream;\n-}\n-\n-/* Returns non-zero if tree dump PHASE is enabled.  */\n-\n-int\n-dump_enabled_p (phase)\n-     enum tree_dump_index phase;\n-{\n-  return dump_files[phase].state;\n-}\n-\n-/* Returns the switch name of PHASE.  */\n-\n-const char *\n-dump_flag_name (phase)\n-     enum tree_dump_index phase;\n-{\n-  return dump_files[phase].swtch;\n-}\n-\n-/* Finish a tree dump for PHASE. STREAM is the stream created by\n-   dump_begin.  */\n-\n-void\n-dump_end (phase, stream)\n-     enum tree_dump_index phase ATTRIBUTE_UNUSED;\n-     FILE *stream;\n-{\n-  fclose (stream);\n-}\n-\n-/* Parse ARG as a dump switch. Return non-zero if it is, and store the\n-   relevant details in the dump_files array.  */\n-\n-int\n-dump_switch_p (arg)\n-     const char *arg;\n-{\n-  unsigned ix;\n-  const char *option_value;\n-  \n-  for (ix = 0; ix != TDI_end; ix++)\n-    if ((option_value = skip_leading_substring (arg, dump_files[ix].swtch)))\n-      {\n-\tconst char *ptr = option_value;\n-\tint flags = 0;\n-\t\n-\twhile (*ptr)\n-\t  {\n-\t    const struct dump_option_value_info *option_ptr;\n-\t    const char *end_ptr;\n-\t    unsigned length;\n-\t    \n-\t    while (*ptr == '-')\n-\t      ptr++;\n-\t    end_ptr = strchr (ptr, '-');\n-\t    if (!end_ptr)\n-\t      end_ptr = ptr + strlen (ptr);\n-\t    length = end_ptr - ptr;\n-\t    \n-\t    for (option_ptr = dump_options; option_ptr->name;\n-\t\t option_ptr++)\n-\t      if (strlen (option_ptr->name) == length\n-\t\t  && !memcmp (option_ptr->name, ptr, length))\n-\t\t{\n-\t\t  flags |= option_ptr->value;\n-\t\t  goto found;\n-\t\t}\n-\t    warning (\"ignoring unknown option `%.*s' in `-f%s'\",\n-\t\t     length, ptr, dump_files[ix].swtch);\n-\t  found:;\n-\t    ptr = end_ptr;\n-\t  }\n-\t\n-\tdump_files[ix].state = -1;\n-\tdump_files[ix].flags = flags;\n-\t\n-\treturn 1;\n-      }\n-  return 0;\n-}"}, {"sha": "4c4962c9a5c7237257702cf239d0dc2db09f3d95", "filename": "gcc/c-dump.h", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4617e3b52be023a28be288988fa0b299aefdc97b/gcc%2Fc-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4617e3b52be023a28be288988fa0b299aefdc97b/gcc%2Fc-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.h?ref=4617e3b52be023a28be288988fa0b299aefdc97b", "patch": "@@ -1,95 +0,0 @@\n-/* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n-   Written by Mark Mitchell <mark@codesourcery.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#ifndef GCC_C_DUMP_H\n-#define GCC_C_DUMP_H\n-\n-/* Flags used with queue functions.  */\n-#define DUMP_NONE     0\n-#define DUMP_BINFO    1\n-\n-/* Information about a node to be dumped.  */\n-\n-typedef struct dump_node_info\n-{\n-  /* The index for the node.  */\n-  unsigned int index;\n-  /* Nonzero if the node is a binfo.  */\n-  unsigned int binfo_p : 1;\n-} *dump_node_info_p;\n-\n-/* A dump_queue is a link in the queue of things to be dumped.  */\n-\n-typedef struct dump_queue\n-{\n-  /* The queued tree node.  */\n-  splay_tree_node node;\n-  /* The next node in the queue.  */\n-  struct dump_queue *next;\n-} *dump_queue_p;\n-\n-/* A dump_info gives information about how we should perform the dump \n-   and about the current state of the dump.  */\n-\n-struct dump_info\n-{\n-  /* The stream on which to dump the information.  */\n-  FILE *stream;\n-  /* The original node.  */\n-  tree node;\n-  /* User flags.  */\n-  int flags;\n-  /* The next unused node index.  */\n-  unsigned int index;\n-  /* The next column.  */\n-  unsigned int column;\n-  /* The first node in the queue of nodes to be written out.  */\n-  dump_queue_p queue;\n-  /* The last node in the queue.  */\n-  dump_queue_p queue_end;\n-  /* Free queue nodes.  */\n-  dump_queue_p free_list;\n-  /* The tree nodes which we have already written out.  The \n-     keys are the addresses of the nodes; the values are the integer\n-     indices we assigned them.  */\n-  splay_tree nodes;\n-};\n-\n-/* Dump the CHILD and its children.  */\n-#define dump_child(field, child) \\\n-  queue_and_dump_index (di, field, child, DUMP_NONE)\n-\n-extern void dump_pointer\n-  PARAMS ((dump_info_p, const char *, void *));\n-extern void dump_int \n-  PARAMS ((dump_info_p, const char *, int));\n-extern void dump_string \n-  PARAMS ((dump_info_p, const char *));\n-extern void dump_stmt \n-  PARAMS ((dump_info_p, tree));\n-extern void dump_next_stmt \n-  PARAMS ((dump_info_p, tree));\n-extern void queue_and_dump_index \n-  PARAMS ((dump_info_p, const char *, tree, int));\n-extern void queue_and_dump_type \n-  PARAMS ((dump_info_p, tree));\n-\n-#endif /* ! GCC_C_DUMP_H */"}, {"sha": "a3856da7f4ab8417d69b7c59e584fc9cc58c3889", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -1,3 +1,17 @@\n+2001-11-22  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* cp-tree.h (CP_TYPE_QUALS): Removed.\n+\t* decl.c (cxx_init_decl_processing): Don't set lang_dump_tree.\n+\t* cp-lang.c: Set LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN and \n+\tLANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN.\n+\t* dump.c (cp_dump_tree): Use void* dump_info argument to match \n+\tlang-hooks prototype.\n+\t* call.c, cp-tree.h, cvt.c, decl.c, init.c, mangle.c, method.c, pt.c,\n+\trtti.c, semantics.c, tree.c, typeck.c, typeck2.c: All references to\n+\tCP_TYPE_QUALS changed to cp_type_quals.\n+\t* Make-lang.in: References to c-dump.h changed to tree-dump.h.\n+\t(CXX_C_OBJS): Remove c-dump.o.\n+\n 2001-11-21  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/3637"}, {"sha": "3a1f1497fd049370138fc90bc958612782c467d1", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -96,7 +96,7 @@ $(DEMANGLER_PROG): cxxmain.o underscore.o $(LIBDEPS)\n # The compiler itself.\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n- c-dump.o $(CXX_TARGET_OBJS)\n+ $(CXX_TARGET_OBJS)\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n@@ -279,7 +279,7 @@ cp/repo.o: cp/repo.c $(CXX_TREE_H) toplev.h $(GGC_H) diagnostic.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) cp/lex.h except.h toplev.h \\\n   flags.h $(GGC_H) debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n   tree-inline.h\n-cp/dump.o: cp/dump.c $(CXX_TREE_H) c-dump.h\n+cp/dump.o: cp/dump.c $(CXX_TREE_H) tree-dump.h\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) rtl.h integrate.h insn-config.h \\\n   input.h $(PARAMS_H) debug.h tree-inline.h\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) toplev.h"}, {"sha": "46aacca2f0498ad8029fbc98f04df4180d24a98a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -777,7 +777,7 @@ standard_conversion (to, from, expr)\n \t{\n \t  from = build_pointer_type\n \t    (cp_build_qualified_type (void_type_node, \n-\t\t\t\t      CP_TYPE_QUALS (TREE_TYPE (from))));\n+\t\t\t\t      cp_type_quals (TREE_TYPE (from))));\n \t  conv = build_conv (PTR_CONV, from, conv);\n \t}\n       else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n@@ -803,7 +803,7 @@ standard_conversion (to, from, expr)\n \t    {\n \t      from = \n \t\tcp_build_qualified_type (TREE_TYPE (to),\n-\t\t\t\t\t CP_TYPE_QUALS (TREE_TYPE (from)));\n+\t\t\t\t\t cp_type_quals (TREE_TYPE (from)));\n \t      from = build_pointer_type (from);\n \t      conv = build_conv (PTR_CONV, from, conv);\n \t    }\n@@ -838,10 +838,10 @@ standard_conversion (to, from, expr)\n \t  || !same_type_p (TREE_TYPE (fromfn), TREE_TYPE (tofn))\n \t  || !compparms (TREE_CHAIN (TYPE_ARG_TYPES (fromfn)),\n \t\t\t TREE_CHAIN (TYPE_ARG_TYPES (tofn)))\n-\t  || CP_TYPE_QUALS (fbase) != CP_TYPE_QUALS (tbase))\n+\t  || cp_type_quals (fbase) != cp_type_quals (tbase))\n \treturn 0;\n \n-      from = cp_build_qualified_type (tbase, CP_TYPE_QUALS (fbase));\n+      from = cp_build_qualified_type (tbase, cp_type_quals (fbase));\n       from = build_cplus_method_type (from, TREE_TYPE (fromfn),\n \t\t\t\t      TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n       from = build_ptrmemfunc_type (build_pointer_type (from));"}, {"sha": "dbca8af24def2dfa7cef26015f700b6a4f6fd6fa", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -78,6 +78,10 @@ static HOST_WIDE_INT cxx_get_alias_set PARAMS ((tree));\n   cp_copy_res_decl_for_inlining\n #undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P anon_aggr_type_p\n+#undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n+#define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN cp_dump_tree\n+#undef LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN\n+#define LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN cp_type_quals\n \n /* Each front end provides its own hooks, for toplev.c.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;"}, {"sha": "4b39e804172b0b0f45c764c4008cfdcda74062cf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -1128,28 +1128,24 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* True if this a \"Java\" type, defined in 'extern \"Java\"'. */\n #define TYPE_FOR_JAVA(NODE) TYPE_LANG_FLAG_3(NODE)\n \n-/* The type qualifiers for this type, including the qualifiers on the\n-   elements for an array type.  */\n-#define CP_TYPE_QUALS(NODE) C_TYPE_QUALS (NODE)\n-\n /* Nonzero if this type is const-qualified.  */\n #define CP_TYPE_CONST_P(NODE)\t\t\t\t\\\n-  ((CP_TYPE_QUALS (NODE) & TYPE_QUAL_CONST) != 0)\n+  ((cp_type_quals (NODE) & TYPE_QUAL_CONST) != 0)\n \n /* Nonzero if this type is volatile-qualified.  */\n #define CP_TYPE_VOLATILE_P(NODE)\t\t\t\\\n-  ((CP_TYPE_QUALS (NODE) & TYPE_QUAL_VOLATILE) != 0)\n+  ((cp_type_quals (NODE) & TYPE_QUAL_VOLATILE) != 0)\n \n /* Nonzero if this type is restrict-qualified.  */\n #define CP_TYPE_RESTRICT_P(NODE)\t\t\t\\\n-  ((CP_TYPE_QUALS (NODE) & TYPE_QUAL_RESTRICT) != 0)\n+  ((cp_type_quals (NODE) & TYPE_QUAL_RESTRICT) != 0)\n \n /* Nonzero if this type is const-qualified, but not\n    volatile-qualified.  Other qualifiers are ignored.  This macro is\n    used to test whether or not it is OK to bind an rvalue to a\n    reference.  */\n #define CP_TYPE_CONST_NON_VOLATILE_P(NODE)\t\t\t\t\\\n-  ((CP_TYPE_QUALS (NODE) & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE))\t\\\n+  ((cp_type_quals (NODE) & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE))\t\\\n    == TYPE_QUAL_CONST)\n \n #define FUNCTION_ARG_CHAIN(NODE) \\\n@@ -4341,7 +4337,7 @@ extern tree mangle_guard_variable               PARAMS ((tree));\n extern tree mangle_ref_init_variable            PARAMS ((tree));\n \n /* in dump.c */\n-extern int cp_dump_tree                         PARAMS ((dump_info_p, tree));\n+extern int cp_dump_tree                         PARAMS ((void *, tree));\n \n /* -- end of C++ */\n "}, {"sha": "3ab60b63f8f8acd0fc0b5185ec5e31c4a57d1562", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -657,7 +657,7 @@ convert_pointer_to_real (binfo, expr)\n     }\n \n   ptr_type = cp_build_qualified_type (type,\n-\t\t\t\t      CP_TYPE_QUALS (TREE_TYPE (intype)));\n+\t\t\t\t      cp_type_quals (TREE_TYPE (intype)));\n   ptr_type = build_pointer_type (ptr_type);\n   if (same_type_p (ptr_type, TYPE_MAIN_VARIANT (intype)))\n     return expr;\n@@ -1267,7 +1267,7 @@ type_promotes_to (type)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  type_quals = CP_TYPE_QUALS (type);\n+  type_quals = cp_type_quals (type);\n   type = TYPE_MAIN_VARIANT (type);\n \n   /* bool always promotes to int (not unsigned), even if it's the same"}, {"sha": "6fdb1c48d65b58d9afe20a45ba07b3effda3dd01", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -6408,7 +6408,6 @@ cxx_init_decl_processing ()\n   free_lang_status = &pop_cp_function_context;\n   mark_lang_status = &mark_cp_function_context;\n   lang_safe_from_p = &c_safe_from_p;\n-  lang_dump_tree = &cp_dump_tree;\n   lang_missing_noreturn_ok_p = &cp_missing_noreturn_ok_p;\n \n   cp_parse_init ();\n@@ -9206,7 +9205,7 @@ build_ptrmemfunc_type (type)\n \n   /* Make sure that we always have the unqualified pointer-to-member\n      type first.  */\n-  if (CP_TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n+  if (cp_type_quals (type) != TYPE_UNQUALIFIED)\n     unqualified_variant\n       = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n \n@@ -9229,9 +9228,9 @@ build_ptrmemfunc_type (type)\n      type, set the TYPE_MAIN_VARIANT for this type to be the\n      unqualified type.  Since they are actually RECORD_TYPEs that are\n      not variants of each other, we must do this manually.  */\n-  if (CP_TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n+  if (cp_type_quals (type) != TYPE_UNQUALIFIED)\n     {\n-      t = build_qualified_type (t, CP_TYPE_QUALS (type));\n+      t = build_qualified_type (t, cp_type_quals (type));\n       TYPE_MAIN_VARIANT (t) = unqualified_variant;\n       TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (unqualified_variant);\n       TYPE_NEXT_VARIANT (unqualified_variant) = t;\n@@ -10159,7 +10158,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n     {\n       RIDBIT_RESET (RID_LONG, specbits);\n       type = build_qualified_type (long_double_type_node,\n-\t\t\t\t   CP_TYPE_QUALS (type));\n+\t\t\t\t   cp_type_quals (type));\n     }\n \n   /* Check all other uses of type modifiers.  */\n@@ -11129,7 +11128,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  && TYPE_NAME (type)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && TYPE_ANONYMOUS_P (type)\n-\t  && CP_TYPE_QUALS (type) == TYPE_UNQUALIFIED)\n+\t  && cp_type_quals (type) == TYPE_UNQUALIFIED)\n \t{\n \t  tree oldname = TYPE_NAME (type);\n \t  tree t;\n@@ -13539,7 +13538,7 @@ start_function (declspecs, declarator, attrs, flags)\n \t{\n \t  DECL_RESULT (decl1)\n \t    = build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (restype));\n-\t  c_apply_type_quals_to_decl (CP_TYPE_QUALS (restype),\n+\t  c_apply_type_quals_to_decl (cp_type_quals (restype),\n \t\t\t\t      DECL_RESULT (decl1));\n \t}\n     }\n@@ -14469,14 +14468,14 @@ revert_static_member_fn (decl)\n   tree function = TREE_TYPE (decl);\n   tree args = TYPE_ARG_TYPES (function);\n \n-  if (CP_TYPE_QUALS (TREE_TYPE (TREE_VALUE (args)))\n+  if (cp_type_quals (TREE_TYPE (TREE_VALUE (args)))\n       != TYPE_UNQUALIFIED)\n     cp_error (\"static member function `%#D' declared with type qualifiers\",\n \t      decl);\n \n   args = TREE_CHAIN (args);\n   tmp = build_function_type (TREE_TYPE (function), args);\n-  tmp = build_qualified_type (tmp, CP_TYPE_QUALS (function));\n+  tmp = build_qualified_type (tmp, cp_type_quals (function));\n   tmp = build_exception_variant (tmp,\n \t\t\t\t TYPE_RAISES_EXCEPTIONS (function));\n   TREE_TYPE (decl) = tmp;"}, {"sha": "98c1fc49d87b0ad5ee0d88e45cef9d257feb75e0", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -23,7 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n-#include \"c-dump.h\"\n+#include \"tree-dump.h\"\n \n static void dump_access\n   PARAMS ((dump_info_p, tree));\n@@ -208,11 +208,12 @@ dump_op (di, t)\n }\n \n int\n-cp_dump_tree (di, t)\n-     dump_info_p di;\n+cp_dump_tree (dump_info, t)\n+     void *dump_info;\n      tree t;\n {\n   enum tree_code code;\n+  dump_info_p di = (dump_info_p) dump_info;\n \n   /* Figure out what kind of node this is.  */\n   code = TREE_CODE (t);"}, {"sha": "ffbe8221309aa448a2ac28b7ede03fab0a2d4c51", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -1177,7 +1177,7 @@ build_aggr_init (exp, init, flags)\n \t  cp_error (\"bad array initializer\");\n \t  return error_mark_node;\n \t}\n-      if (CP_TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n+      if (cp_type_quals (type) != TYPE_UNQUALIFIED)\n \t{\n \t  TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n \t  if (init)"}, {"sha": "a0260e19b68fe8403d36adbeb782efb4d5433d2e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -509,7 +509,7 @@ find_substitution (node)\n   \t         std::basic_string <char,\n \t\t \t\t    std::char_traits<char>,\n \t\t\t\t    std::allocator<char> > .  */\n-\t  if (CP_TYPE_QUALS (type) == TYPE_UNQUALIFIED\n+\t  if (cp_type_quals (type) == TYPE_UNQUALIFIED\n \t      && CLASSTYPE_USE_TEMPLATE (type))\n \t    {\n \t      tree args = CLASSTYPE_TI_ARGS (type);\n@@ -535,7 +535,7 @@ find_substitution (node)\n \n   /* Check for basic_{i,o,io}stream.  */\n   if (TYPE_P (node)\n-      && CP_TYPE_QUALS (type) == TYPE_UNQUALIFIED\n+      && cp_type_quals (type) == TYPE_UNQUALIFIED\n       && CLASS_TYPE_P (type)\n       && CLASSTYPE_USE_TEMPLATE (type)\n       && CLASSTYPE_TEMPLATE_INFO (type) != NULL)"}, {"sha": "4de7605984c874831c7eac3d76b1ce67d0b9190e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -551,7 +551,7 @@ do_build_copy_constructor (fndecl)\n       tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n       tree member_init_list = NULL_TREE;\n       tree base_init_list = NULL_TREE;\n-      int cvquals = CP_TYPE_QUALS (TREE_TYPE (parm));\n+      int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n \n       /* Initialize all the base-classes with the parameter converted to\n@@ -640,7 +640,7 @@ do_build_assign_ref (fndecl)\n       tree fields = TYPE_FIELDS (current_class_type);\n       int n_bases = CLASSTYPE_N_BASECLASSES (current_class_type);\n       tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n-      int cvquals = CP_TYPE_QUALS (TREE_TYPE (parm));\n+      int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n \n       for (i = 0; i < n_bases; ++i)\n@@ -919,7 +919,7 @@ locate_copy (type, client_)\n         continue;\n       if (!sufficient_parms_p (TREE_CHAIN (parms)))\n         continue;\n-      quals = CP_TYPE_QUALS (src_type);\n+      quals = cp_type_quals (src_type);\n       if (client->quals & ~quals)\n         continue;\n       excess = quals & ~client->quals;"}, {"sha": "8273e168d1c31cc45f12a8e2fdfbfebd135af205", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -5905,7 +5905,7 @@ tsubst_decl (t, args, type)\n       {\n \tr = copy_node (t);\n \tTREE_TYPE (r) = type;\n-\tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n+\tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n \tif (TREE_CODE (DECL_INITIAL (r)) != TEMPLATE_PARM_INDEX)\n \t  DECL_INITIAL (r) = TREE_TYPE (r);\n@@ -5928,7 +5928,7 @@ tsubst_decl (t, args, type)\n       {\n \tr = copy_decl (t);\n \tTREE_TYPE (r) = type;\n-\tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n+\tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n \t/* We don't have to set DECL_CONTEXT here; it is set by\n \t   finish_member_declaration.  */\n@@ -6007,7 +6007,7 @@ tsubst_decl (t, args, type)\n \n \tr = copy_decl (t);\n \tTREE_TYPE (r) = type;\n-\tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n+\tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n \tDECL_CONTEXT (r) = ctx;\n \t/* Clear out the mangled name and RTL for the instantiation.  */\n \tSET_DECL_ASSEMBLER_NAME (r, NULL_TREE);\n@@ -6394,7 +6394,7 @@ tsubst (t, args, complain, in_decl)\n \t\t  {\n \t\t    my_friendly_assert (TYPE_P (arg), 0);\n \t\t    return cp_build_qualified_type_real\n-\t\t      (arg, CP_TYPE_QUALS (arg) | CP_TYPE_QUALS (t),\n+\t\t      (arg, cp_type_quals (arg) | cp_type_quals (t),\n \t\t       complain);\n \t\t  }\n \t\telse if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n@@ -6445,10 +6445,10 @@ tsubst (t, args, complain, in_decl)\n \t  case TEMPLATE_TYPE_PARM:\n \t  case TEMPLATE_TEMPLATE_PARM:\n \t  case BOUND_TEMPLATE_TEMPLATE_PARM:\n-\t    if (CP_TYPE_QUALS (t))\n+\t    if (cp_type_quals (t))\n \t      {\n \t\tr = tsubst (TYPE_MAIN_VARIANT (t), args, complain, in_decl);\n-\t\tr = cp_build_qualified_type_real (r, CP_TYPE_QUALS (t),\n+\t\tr = cp_build_qualified_type_real (r, cp_type_quals (t),\n \t\t\t\t\t\t  complain);\n \t      }\n \t    else\n@@ -6755,8 +6755,8 @@ tsubst (t, args, complain, in_decl)\n \tif (f == error_mark_node)\n \t  return f;\n \treturn cp_build_qualified_type_real (f, \n-\t\t\t\t\t     CP_TYPE_QUALS (f) \n-\t\t\t\t\t     | CP_TYPE_QUALS (t),\n+\t\t\t\t\t     cp_type_quals (f) \n+\t\t\t\t\t     | cp_type_quals (t),\n \t\t\t\t\t     complain);\n       }\n \n@@ -8667,8 +8667,8 @@ unify (tparms, targs, parm, arg, strict)\n \t     PARM is `const T'.  Then, T should be `volatile int'.  */\n \t  arg = \n \t    cp_build_qualified_type_real (arg,\n-\t\t\t\t\t  CP_TYPE_QUALS (arg) \n-\t\t\t\t\t  & ~CP_TYPE_QUALS (parm),\n+\t\t\t\t\t  cp_type_quals (arg) \n+\t\t\t\t\t  & ~cp_type_quals (parm),\n \t\t\t\t\t  /*complain=*/0);\n \t  if (arg == error_mark_node)\n \t    return 1;"}, {"sha": "ae9600c648d4031d1f54a04cf726bd866c24b4da", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -107,7 +107,7 @@ build_headof (exp)\n   offset = build_vtbl_ref (build_indirect_ref (exp, NULL), index);\n \n   type = build_qualified_type (ptr_type_node, \n-\t\t\t       CP_TYPE_QUALS (TREE_TYPE (exp)));\n+\t\t\t       cp_type_quals (TREE_TYPE (exp)));\n   return build (PLUS_EXPR, type, exp,\n \t\tcp_convert (ptrdiff_type_node, offset));\n }\n@@ -923,8 +923,8 @@ typeinfo_in_lib_p (type)\n   /* The typeinfo objects for `T*' and `const T*' are in the runtime\n      library for simple types T.  */\n   if (TREE_CODE (type) == POINTER_TYPE\n-      && (CP_TYPE_QUALS (TREE_TYPE (type)) == TYPE_QUAL_CONST\n-\t  || CP_TYPE_QUALS (TREE_TYPE (type)) == TYPE_UNQUALIFIED))\n+      && (cp_type_quals (TREE_TYPE (type)) == TYPE_QUAL_CONST\n+\t  || cp_type_quals (TREE_TYPE (type)) == TYPE_UNQUALIFIED))\n     type = TREE_TYPE (type);\n \n   switch (TREE_CODE (type))"}, {"sha": "edd676be3684819337f39f3460d57ab2bb56c8a3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -2128,7 +2128,7 @@ finish_base_specifier (access_specifier, base_class)\n     result = NULL_TREE;\n   else\n     {\n-      if (CP_TYPE_QUALS (base_class) != 0)\n+      if (cp_type_quals (base_class) != 0)\n         {\n           cp_error (\"base class `%T' has cv qualifiers\", base_class);\n           base_class = TYPE_MAIN_VARIANT (base_class);"}, {"sha": "ae4c375fd9ee48a8230d3c1c63931c1efb45d279", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -490,7 +490,7 @@ build_cplus_array_type (elt_type, index_type)\n      tree index_type;\n {\n   tree t;\n-  int type_quals = CP_TYPE_QUALS (elt_type);\n+  int type_quals = cp_type_quals (elt_type);\n \n   if (type_quals != TYPE_UNQUALIFIED)\n     elt_type = cp_build_qualified_type (elt_type, TYPE_UNQUALIFIED);\n@@ -521,7 +521,7 @@ cp_build_qualified_type_real (type, type_quals, complain)\n   if (type == error_mark_node)\n     return type;\n \n-  if (type_quals == CP_TYPE_QUALS (type))\n+  if (type_quals == cp_type_quals (type))\n     return type;\n \n   /* A restrict-qualified pointer type must be a pointer (or reference)\n@@ -624,7 +624,7 @@ tree\n canonical_type_variant (t)\n      tree t;\n {\n-  return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), CP_TYPE_QUALS (t));\n+  return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), cp_type_quals (t));\n }\n \f\n /* Makes new binfos for the indirect bases under BINFO, and updates"}, {"sha": "c4c0e10d0785f98b8a9ccbc106ee0dccb1a9e28b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -223,7 +223,7 @@ qualify_type_recursive (t1, t2)\n       else\n \tb1 = NULL_TREE;\n \n-      type_quals = (CP_TYPE_QUALS (tt1) | CP_TYPE_QUALS (tt2));\n+      type_quals = (cp_type_quals (tt1) | cp_type_quals (tt2));\n       tgt = qualify_type_recursive (tt1, tt2);\n       tgt = cp_build_qualified_type (tgt, type_quals);\n       if (b1)\n@@ -486,8 +486,8 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n       t1 = TREE_TYPE (t1);\n       t2 = TREE_TYPE (t2);\n       result_type = cp_build_qualified_type (void_type_node,\n-\t\t\t\t\t     (CP_TYPE_QUALS (t1)\n-\t\t\t\t\t      | CP_TYPE_QUALS (t2)));\n+\t\t\t\t\t     (cp_type_quals (t1)\n+\t\t\t\t\t      | cp_type_quals (t2)));\n       result_type = build_pointer_type (result_type);\n     }\n   else\n@@ -617,7 +617,7 @@ common_type (t1, t2)\n \telse\n \t  b1 = b2 = NULL_TREE;\n \n-\ttype_quals = (CP_TYPE_QUALS (tt1) | CP_TYPE_QUALS (tt2));\n+\ttype_quals = (cp_type_quals (tt1) | cp_type_quals (tt2));\n \ttt1 = TYPE_MAIN_VARIANT (tt1);\n \ttt2 = TYPE_MAIN_VARIANT (tt2);\n \n@@ -795,15 +795,15 @@ comp_except_types (a, b, exact)\n     return 1;\n   else if (!exact)\n     {\n-      if (CP_TYPE_QUALS (a) || CP_TYPE_QUALS (b))\n+      if (cp_type_quals (a) || cp_type_quals (b))\n         return 0;\n       \n       if (TREE_CODE (a) == POINTER_TYPE\n           && TREE_CODE (b) == POINTER_TYPE)\n         {\n           a = TREE_TYPE (a);\n           b = TREE_TYPE (b);\n-          if (CP_TYPE_QUALS (a) || CP_TYPE_QUALS (b))\n+          if (cp_type_quals (a) || cp_type_quals (b))\n             return 0;\n         }\n       \n@@ -983,7 +983,7 @@ comptypes (t1, t2, strict)\n     return 0;\n \n   /* Qualifiers must match.  */\n-  if (CP_TYPE_QUALS (t1) != CP_TYPE_QUALS (t2))\n+  if (cp_type_quals (t1) != cp_type_quals (t2))\n     return 0;\n   if (strict == COMPARE_STRICT \n       && TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n@@ -1327,8 +1327,8 @@ at_least_as_qualified_p (type1, type2)\n      tree type2;\n {\n   /* All qualifiers for TYPE2 must also appear in TYPE1.  */\n-  return ((CP_TYPE_QUALS (type1) & CP_TYPE_QUALS (type2))\n-\t  == CP_TYPE_QUALS (type2));\n+  return ((cp_type_quals (type1) & cp_type_quals (type2))\n+\t  == cp_type_quals (type2));\n }\n \n /* Returns 1 if TYPE1 is more qualified than TYPE2.  */\n@@ -1338,7 +1338,7 @@ more_qualified_p (type1, type2)\n      tree type1;\n      tree type2;\n {\n-  return (CP_TYPE_QUALS (type1) != CP_TYPE_QUALS (type2)\n+  return (cp_type_quals (type1) != cp_type_quals (type2)\n \t  && at_least_as_qualified_p (type1, type2));\n }\n \n@@ -1350,7 +1350,7 @@ comp_cv_qualification (type1, type2)\n      tree type1;\n      tree type2;\n {\n-  if (CP_TYPE_QUALS (type1) == CP_TYPE_QUALS (type2))\n+  if (cp_type_quals (type1) == cp_type_quals (type2))\n     return 0;\n \n   if (at_least_as_qualified_p (type1, type2))\n@@ -2241,8 +2241,8 @@ build_component_ref (datum, component, basetype_path, protect)\n     ;\n   else\n     {\n-      type_quals = (CP_TYPE_QUALS (field_type)  \n-\t\t    | CP_TYPE_QUALS (TREE_TYPE (datum)));\n+      type_quals = (cp_type_quals (field_type)  \n+\t\t    | cp_type_quals (TREE_TYPE (datum)));\n \n       /* A field is const (volatile) if the enclosing object, or the\n \t field itself, is const (volatile).  But, a mutable field is\n@@ -6892,7 +6892,8 @@ comp_ptr_ttypes_reinterpret (to, from)\n     }\n }\n \n-/* Returns the type-qualifier set corresponding to TYPE.  */\n+/* Returns the type qualifiers for this type, including the qualifiers on the\n+   elements for an array type.  */\n \n int\n cp_type_quals (type)\n@@ -6958,14 +6959,14 @@ casts_away_constness_r (t1, t2)\n       || TREE_CODE (*t2) != POINTER_TYPE)\n     {\n       *t1 = cp_build_qualified_type (void_type_node,\n-\t\t\t\t     CP_TYPE_QUALS (*t1));\n+\t\t\t\t     cp_type_quals (*t1));\n       *t2 = cp_build_qualified_type (void_type_node,\n-\t\t\t\t     CP_TYPE_QUALS (*t2));\n+\t\t\t\t     cp_type_quals (*t2));\n       return;\n     }\n   \n-  quals1 = CP_TYPE_QUALS (*t1);\n-  quals2 = CP_TYPE_QUALS (*t2);\n+  quals1 = cp_type_quals (*t1);\n+  quals2 = cp_type_quals (*t2);\n   *t1 = TREE_TYPE (*t1);\n   *t2 = TREE_TYPE (*t2);\n   casts_away_constness_r (t1, t2);"}, {"sha": "8281b34de4991a35abffda8aba728fbacc7f364e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -1159,8 +1159,8 @@ build_m_component_ref (datum, component)\n     ;\n   else\n     {\n-      type_quals = (CP_TYPE_QUALS (field_type)  \n-\t\t    | CP_TYPE_QUALS (TREE_TYPE (datum)));\n+      type_quals = (cp_type_quals (field_type)  \n+\t\t    | cp_type_quals (TREE_TYPE (datum)));\n \n       /* There's no such thing as a mutable pointer-to-member, so we don't\n \t need to deal with that here like we do in build_component_ref.  */"}, {"sha": "7c8480f4f842a07613a3e5942b1480858200c599", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -103,7 +103,19 @@ int lhd_tree_inlining_anon_aggr_type_p\t\tPARAMS ((tree));\n   LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n } \\\n \n-/* The whole thing.  The structure is defined in toplev.h.  */\n+/* Tree dump hooks.  */\n+int lhd_tree_dump_dump_tree \t\t\tPARAMS ((void *, tree));\n+int lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n+\n+#define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN lhd_tree_dump_dump_tree\n+#define LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN lhd_tree_dump_type_quals\n+\n+#define LANG_HOOKS_TREE_DUMP_INITIALIZER { \\\n+  LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN, \\\n+  LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN \\\n+} \\\n+\n+/* The whole thing.  The structure is defined in langhooks.h.  */\n #define LANG_HOOKS_INITIALIZER { \\\n   LANG_HOOKS_NAME, \\\n   LANG_HOOKS_IDENTIFIER_SIZE, \\\n@@ -121,7 +133,8 @@ int lhd_tree_inlining_anon_aggr_type_p\t\tPARAMS ((tree));\n   LANG_HOOKS_PRINT_TYPE, \\\n   LANG_HOOKS_PRINT_IDENTIFIER, \\\n   LANG_HOOKS_SET_YYDEBUG, \\\n-  LANG_HOOKS_TREE_INLINING_INITIALIZER \\\n+  LANG_HOOKS_TREE_INLINING_INITIALIZER, \\\n+  LANG_HOOKS_TREE_DUMP_INITIALIZER \\\n }\n \n #endif /* GCC_LANG_HOOKS_DEF_H */"}, {"sha": "8465bd32e50599819ca0b1bf5ceb43d6793749f1", "filename": "gcc/langhooks.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"toplev.h\"\n #include \"tree.h\"\n+#include \"c-tree.h\"\n #include \"tree-inline.h\"\n #include \"rtl.h\"\n #include \"insn-config.h\"\n@@ -211,3 +212,25 @@ lhd_tree_inlining_anon_aggr_type_p (t)\n   return 0;\n }\n \n+/* lang_hooks.tree_dump.dump_tree:  Dump language-specific parts of tree \n+   nodes.  Returns non-zero if it does not want the usual dumping of the \n+   second argument.  */\n+\n+int\n+lhd_tree_dump_dump_tree (di, t)\n+     void *di ATTRIBUTE_UNUSED;\n+     tree t ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+/* lang_hooks.tree_dump.type_qual:  Determine type qualifiers in a \n+   language-specific way.  */\n+\n+int\n+lhd_tree_dump_type_quals (t)\n+     tree t;\n+{\n+  return TYPE_QUALS (t);\n+}\n+"}, {"sha": "4ec01e70d016e3bc32aaa209b90471ce693d5dfe", "filename": "gcc/langhooks.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -48,6 +48,18 @@ struct lang_hooks_for_tree_inlining\n   int (*anon_aggr_type_p) PARAMS ((union tree_node *));\n };\n \n+/* The following hooks are used by tree-dump.c.  */\n+\n+struct lang_hooks_for_tree_dump\n+{\n+  /* Dump language-specific parts of tree nodes.  Returns non-zero if it \n+     does not want the usual dumping of the second argument.  */\n+  int (*dump_tree) PARAMS ((void *, tree));\n+\n+  /* Determine type qualifiers in a language-specific way.  */\n+  int (*type_quals) PARAMS ((tree));\n+};\n+\n /* Language-specific hooks.  See langhooks-def.h for defaults.  */\n \n struct lang_hooks\n@@ -116,8 +128,10 @@ struct lang_hooks\n   void (*set_yydebug) PARAMS ((int));\n \n   struct lang_hooks_for_tree_inlining tree_inlining;\n+  \n+  struct lang_hooks_for_tree_dump tree_dump;\n \n-  /* Whenever you add entries here, make sure you adjust langhooks.h\n+  /* Whenever you add entries here, make sure you adjust langhooks-def.h\n      and langhooks.c accordingly.  */\n };\n "}, {"sha": "91d6e714c5598f5e1e8c2d4ad0db69509f2b5f2f", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -26,7 +26,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"splay-tree.h\"\n #include \"diagnostic.h\"\n #include \"toplev.h\"\n-#include \"c-dump.h\"\n+#include \"tree-dump.h\"\n #include \"langhooks.h\"\n \n static unsigned int queue PARAMS ((dump_info_p, tree, int));"}, {"sha": "9e9888e0ad5b767eaf6e181a73c732b053c0a6e2", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -19,8 +19,8 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-#ifndef GCC_C_DUMP_H\n-#define GCC_C_DUMP_H\n+#ifndef GCC_TREE_DUMP_H\n+#define GCC_TREE_DUMP_H\n \n /* Flags used with queue functions.  */\n #define DUMP_NONE     0\n@@ -92,4 +92,4 @@ extern void queue_and_dump_index\n extern void queue_and_dump_type \n   PARAMS ((dump_info_p, tree));\n \n-#endif /* ! GCC_C_DUMP_H */\n+#endif /* ! GCC_TREE_DUMP_H */"}, {"sha": "5f6424da7b76f99a18881c0f5b3b276c846cd9da", "filename": "gcc/tree.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d684bba353ee89c83c51a8cffc1f1cf5366ad5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=89d684bba353ee89c83c51a8cffc1f1cf5366ad5", "patch": "@@ -3059,6 +3059,37 @@ extern void dwarf2out_return_reg\tPARAMS ((const char *, unsigned));\n \n typedef tree (*walk_tree_fn)\t\tPARAMS ((tree *, int *, void *));\n \n+/* In tree-dump.c */\n+\n+/* Different tree dump places.  When you add new tree dump places,\n+   extend the DUMP_FILES array in tree-dump.c */\n+enum tree_dump_index\n+{\n+  TDI_all,\t\t\t/* dump the whole translation unit */\n+  TDI_class,\t\t\t/* dump class hierarchy */\n+  TDI_original,\t\t\t/* dump each function before optimizing it */\n+  TDI_optimized,\t\t/* dump each function after optimizing it */\n+  TDI_inlined,\t\t\t/* dump each function after inlining\n+\t\t\t\t   within it.  */\n+  TDI_end\n+};\n+\n+/* Bit masks to control tree dumping. Not all values are applicable to\n+   all tree dumps. Add new ones at the end. When you define new\n+   values, extend the DUMP_OPTIONS array in tree-dump.c */\n+#define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n+#define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n+\n+typedef struct dump_info *dump_info_p;\n+\n+extern int dump_flag\t\t\tPARAMS ((dump_info_p, int, tree));\n+extern int dump_enabled_p\t\tPARAMS ((enum tree_dump_index));\n+extern FILE *dump_begin\t\t\tPARAMS ((enum tree_dump_index, int *));\n+extern void dump_end\t\t\tPARAMS ((enum tree_dump_index, FILE *));\n+extern void dump_node\t\t\tPARAMS ((tree, int, FILE *));\n+extern int dump_switch_p                PARAMS ((const char *));\n+extern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n+\n \f\n /* Redefine abort to report an internal error w/o coredump, and\n    reporting the location of the error in the source file.  This logic"}]}