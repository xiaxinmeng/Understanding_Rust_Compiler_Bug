{"sha": "490d0f6c91c0c4fef57a5ffe438629b0687113de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkwZDBmNmM5MWMwYzRmZWY1N2E1ZmZlNDM4NjI5YjA2ODcxMTNkZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:09:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:09:01Z"}, "message": "[6/77] Make GET_MODE_WIDER return an opt_mode\n\nGET_MODE_WIDER previously returned VOIDmode if no wider mode existed.\nThat would cause problems with stricter mode classes, since VOIDmode\nisn't for example a valid scalar integer or floating-point mode.\nThis patch instead makes it return a new opt_mode<T> class, which\nholds either a T or nothing.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* coretypes.h (opt_mode): New class.\n\t* machmode.h (opt_mode): Likewise.\n\t(opt_mode::else_void): New function.\n\t(opt_mode::require): Likewise.\n\t(opt_mode::exists): Likewise.\n\t(GET_MODE_WIDER_MODE): Turn into a function and return an opt_mode.\n\t(GET_MODE_2XWIDER_MODE): Likewise.\n\t(mode_iterator::get_wider): Update accordingly.\n\t(mode_iterator::get_2xwider): Likewise.\n\t(mode_iterator::get_known_wider): Likewise, turning into a template.\n\t* combine.c (make_extraction): Update use of GET_MODE_WIDER_MODE,\n\tforcing a wider mode to exist.\n\t* config/cr16/cr16.h (LONG_REG_P): Likewise.\n\t* rtlanal.c (init_num_sign_bit_copies_in_rep): Likewise.\n\t* config/c6x/c6x.c (c6x_rtx_costs): Update use of\n\tGET_MODE_2XWIDER_MODE, forcing a wider mode to exist.\n\t* lower-subreg.c (init_lower_subreg): Likewise.\n\t* optabs-libfuncs.c (init_sync_libfuncs_1): Likewise, but not\n\ton the final iteration.\n\t* config/i386/i386.c (ix86_expand_set_or_movmem): Check whether\n\ta wider mode exists before asking for a move pattern.\n\t(get_mode_wider_vector): Update use of GET_MODE_WIDER_MODE,\n\tforcing a wider mode to exist.\n\t(expand_vselect_vconcat): Update use of GET_MODE_2XWIDER_MODE,\n\treturning false if no such mode exists.\n\t* config/ia64/ia64.c (expand_vselect_vconcat): Likewise.\n\t* config/mips/mips.c (mips_expand_vselect_vconcat): Likewise.\n\t* expmed.c (init_expmed_one_mode): Update use of GET_MODE_WIDER_MODE.\n\tAvoid checking for a MODE_INT if we already know the mode is not a\n\tSCALAR_INT_MODE_P.\n\t(extract_high_half): Update use of GET_MODE_WIDER_MODE,\n\tforcing a wider mode to exist.\n\t(expmed_mult_highpart_optab): Likewise.\n\t(expmed_mult_highpart): Likewise.\n\t* expr.c (expand_expr_real_2): Update use of GET_MODE_WIDER_MODE,\n\tusing else_void.\n\t* lto-streamer-in.c (lto_input_mode_table): Likewise.\n\t* optabs-query.c (find_widening_optab_handler_and_mode): Likewise.\n\t* stor-layout.c (bit_field_mode_iterator::next_mode): Likewise.\n\t* internal-fn.c (expand_mul_overflow): Update use of\n\tGET_MODE_2XWIDER_MODE.\n\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n\t* tree-ssa-math-opts.c (convert_mult_to_widen): Update use of\n\tGET_MODE_WIDER_MODE.\n\t(convert_plusminus_to_widen): Likewise.\n\t* tree-switch-conversion.c (array_value_type): Likewise.\n\t* var-tracking.c (emit_note_insn_var_location): Likewise.\n\t* tree-vrp.c (simplify_float_conversion_using_ranges): Likewise.\n\tReturn false inside rather than outside the loop if no wider mode\n\texists\n\t* optabs.c (expand_binop): Update use of GET_MODE_WIDER_MODE\n\tand GET_MODE_2XWIDER_MODE\n\t(can_compare_p): Use else_void.\n\t* gdbhooks.py (OptMachineModePrinter): New class.\n\t(build_pretty_printer): Use it for opt_mode.\n\ngcc/ada/\n\t* gcc-interface/decl.c (validate_size): Update use of\n\tGET_MODE_WIDER_MODE, forcing a wider mode to exist.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251457", "tree": {"sha": "2c5b1e4319507b30cf23a863c8d44ac6e10e3d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c5b1e4319507b30cf23a863c8d44ac6e10e3d57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/490d0f6c91c0c4fef57a5ffe438629b0687113de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490d0f6c91c0c4fef57a5ffe438629b0687113de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/490d0f6c91c0c4fef57a5ffe438629b0687113de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490d0f6c91c0c4fef57a5ffe438629b0687113de/comments", "author": null, "committer": null, "parents": [{"sha": "ec35d57225c9cd7f69ab1b25982b90bfc0f878e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec35d57225c9cd7f69ab1b25982b90bfc0f878e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec35d57225c9cd7f69ab1b25982b90bfc0f878e7"}], "stats": {"total": 296, "additions": 225, "deletions": 71}, "files": [{"sha": "9d8c1f0d74db312b6ac7b6c2ffdf4a7f4f997ddc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -1,3 +1,63 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* coretypes.h (opt_mode): New class.\n+\t* machmode.h (opt_mode): Likewise.\n+\t(opt_mode::else_void): New function.\n+\t(opt_mode::require): Likewise.\n+\t(opt_mode::exists): Likewise.\n+\t(GET_MODE_WIDER_MODE): Turn into a function and return an opt_mode.\n+\t(GET_MODE_2XWIDER_MODE): Likewise.\n+\t(mode_iterator::get_wider): Update accordingly.\n+\t(mode_iterator::get_2xwider): Likewise.\n+\t(mode_iterator::get_known_wider): Likewise, turning into a template.\n+\t* combine.c (make_extraction): Update use of GET_MODE_WIDER_MODE,\n+\tforcing a wider mode to exist.\n+\t* config/cr16/cr16.h (LONG_REG_P): Likewise.\n+\t* rtlanal.c (init_num_sign_bit_copies_in_rep): Likewise.\n+\t* config/c6x/c6x.c (c6x_rtx_costs): Update use of\n+\tGET_MODE_2XWIDER_MODE, forcing a wider mode to exist.\n+\t* lower-subreg.c (init_lower_subreg): Likewise.\n+\t* optabs-libfuncs.c (init_sync_libfuncs_1): Likewise, but not\n+\ton the final iteration.\n+\t* config/i386/i386.c (ix86_expand_set_or_movmem): Check whether\n+\ta wider mode exists before asking for a move pattern.\n+\t(get_mode_wider_vector): Update use of GET_MODE_WIDER_MODE,\n+\tforcing a wider mode to exist.\n+\t(expand_vselect_vconcat): Update use of GET_MODE_2XWIDER_MODE,\n+\treturning false if no such mode exists.\n+\t* config/ia64/ia64.c (expand_vselect_vconcat): Likewise.\n+\t* config/mips/mips.c (mips_expand_vselect_vconcat): Likewise.\n+\t* expmed.c (init_expmed_one_mode): Update use of GET_MODE_WIDER_MODE.\n+\tAvoid checking for a MODE_INT if we already know the mode is not a\n+\tSCALAR_INT_MODE_P.\n+\t(extract_high_half): Update use of GET_MODE_WIDER_MODE,\n+\tforcing a wider mode to exist.\n+\t(expmed_mult_highpart_optab): Likewise.\n+\t(expmed_mult_highpart): Likewise.\n+\t* expr.c (expand_expr_real_2): Update use of GET_MODE_WIDER_MODE,\n+\tusing else_void.\n+\t* lto-streamer-in.c (lto_input_mode_table): Likewise.\n+\t* optabs-query.c (find_widening_optab_handler_and_mode): Likewise.\n+\t* stor-layout.c (bit_field_mode_iterator::next_mode): Likewise.\n+\t* internal-fn.c (expand_mul_overflow): Update use of\n+\tGET_MODE_2XWIDER_MODE.\n+\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n+\t* tree-ssa-math-opts.c (convert_mult_to_widen): Update use of\n+\tGET_MODE_WIDER_MODE.\n+\t(convert_plusminus_to_widen): Likewise.\n+\t* tree-switch-conversion.c (array_value_type): Likewise.\n+\t* var-tracking.c (emit_note_insn_var_location): Likewise.\n+\t* tree-vrp.c (simplify_float_conversion_using_ranges): Likewise.\n+\tReturn false inside rather than outside the loop if no wider mode\n+\texists\n+\t* optabs.c (expand_binop): Update use of GET_MODE_WIDER_MODE\n+\tand GET_MODE_2XWIDER_MODE\n+\t(can_compare_p): Use else_void.\n+\t* gdbhooks.py (OptMachineModePrinter): New class.\n+\t(build_pretty_printer): Use it for opt_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "769546c43ac2c474fd5c6408d4bb8ed251cbf5f2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/decl.c (validate_size): Update use of\n+\tGET_MODE_WIDER_MODE, forcing a wider mode to exist.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n             Alan Hayward  <alan.hayward@arm.com>\n             David Sherwood  <david.sherwood@arm.com>"}, {"sha": "83c582ff64fc985d976d5fb1d809ddd95ebfaa21", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -8576,7 +8576,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n     {\n       machine_mode p_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n       while (!targetm.valid_pointer_mode (p_mode))\n-\tp_mode = GET_MODE_WIDER_MODE (p_mode);\n+\tp_mode = GET_MODE_WIDER_MODE (p_mode).require ();\n       type_size = bitsize_int (GET_MODE_BITSIZE (p_mode));\n     }\n "}, {"sha": "1a6eda609ed963462a6aa8fab721c93c021df1e3", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -7604,10 +7604,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       wanted_inner_mode = smallest_mode_for_size (len, MODE_INT);\n       while (pos % GET_MODE_BITSIZE (wanted_inner_mode) + len\n \t     > GET_MODE_BITSIZE (wanted_inner_mode))\n-\t{\n-\t  wanted_inner_mode = GET_MODE_WIDER_MODE (wanted_inner_mode);\n-\t  gcc_assert (wanted_inner_mode != VOIDmode);\n-\t}\n+\twanted_inner_mode = GET_MODE_WIDER_MODE (wanted_inner_mode).require ();\n     }\n \n   orig_pos = pos;"}, {"sha": "d92b8782c49d8fbc8938ef84049947347abdbd03", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -6066,7 +6066,7 @@ c6x_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno, int *total,\n       /* Recognize a mult_highpart operation.  */\n       if ((mode == HImode || mode == SImode)\n \t  && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n-\t  && GET_MODE (XEXP (x, 0)) == GET_MODE_2XWIDER_MODE (mode)\n+\t  && GET_MODE (XEXP (x, 0)) == GET_MODE_2XWIDER_MODE (mode).require ()\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode))"}, {"sha": "eba92544aa38d1733d5d755405a0d0da42a4f8c1", "filename": "gcc/config/cr16/cr16.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -197,9 +197,7 @@ while (0)\n \n /* Returns 1 if the register is longer than word size, 0 otherwise.  */\n #define LONG_REG_P(REGNO)                                                    \\\n-  (HARD_REGNO_NREGS (REGNO,                                                  \\\n-\t\t     GET_MODE_WIDER_MODE (smallest_mode_for_size\t     \\\n-\t\t\t\t\t (BITS_PER_WORD, MODE_INT))) == 1)\n+  (HARD_REGNO_NREGS (REGNO, GET_MODE_WIDER_MODE (word_mode).require ()) == 1)\n \n #define HARD_REGNO_NREGS(REGNO, MODE)                                         \\\n  ((REGNO >= CR16_FIRST_DWORD_REGISTER)                                        \\"}, {"sha": "88850bde786a9f9f29001d83c5e1cb85ab9a3e4b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -28534,6 +28534,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   bool need_zero_guard = false;\n   bool noalign;\n   machine_mode move_mode = VOIDmode;\n+  machine_mode wider_mode;\n   int unroll_factor = 1;\n   /* TODO: Once value ranges are available, fill in proper data.  */\n   unsigned HOST_WIDE_INT min_size = 0;\n@@ -28627,9 +28628,9 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n       unroll_factor = 4;\n       /* Find the widest supported mode.  */\n       move_mode = word_mode;\n-      while (optab_handler (mov_optab, GET_MODE_WIDER_MODE (move_mode))\n-\t     != CODE_FOR_nothing)\n-\t  move_mode = GET_MODE_WIDER_MODE (move_mode);\n+      while (GET_MODE_WIDER_MODE (move_mode).exists (&wider_mode)\n+\t     && optab_handler (mov_optab, wider_mode) != CODE_FOR_nothing)\n+\tmove_mode = wider_mode;\n \n       /* Find the corresponding vector mode with the same size as MOVE_MODE.\n \t MOVE_MODE is an integer mode at the moment (SI, DI, TI, etc.).  */\n@@ -43502,7 +43503,7 @@ static inline machine_mode\n get_mode_wider_vector (machine_mode o)\n {\n   /* ??? Rely on the ordering that genmodes.c gives to vectors.  */\n-  machine_mode n = GET_MODE_WIDER_MODE (o);\n+  machine_mode n = GET_MODE_WIDER_MODE (o).require ();\n   gcc_assert (GET_MODE_NUNITS (o) == GET_MODE_NUNITS (n) * 2);\n   gcc_assert (GET_MODE_SIZE (o) == GET_MODE_SIZE (n));\n   return n;\n@@ -46865,7 +46866,8 @@ expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n   if (vselect_insn == NULL_RTX)\n     init_vselect_insn ();\n \n-  v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n+  if (!GET_MODE_2XWIDER_MODE (GET_MODE (op0)).exists (&v2mode))\n+    return false;\n   x = XEXP (SET_SRC (PATTERN (vselect_insn)), 0);\n   PUT_MODE (x, v2mode);\n   XEXP (x, 0) = op0;"}, {"sha": "720c16bd0036e8cd02c5058bbf9e728018732782", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -11298,7 +11298,8 @@ expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n   machine_mode v2mode;\n   rtx x;\n \n-  v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n+  if (!GET_MODE_2XWIDER_MODE (GET_MODE (op0)).exists (&v2mode))\n+    return false;\n   x = gen_rtx_VEC_CONCAT (v2mode, op0, op1);\n   return expand_vselect (target, x, perm, nelt);\n }"}, {"sha": "d646f612591c017c0580169245847e3bfd06370c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -21105,7 +21105,8 @@ mips_expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n   machine_mode v2mode;\n   rtx x;\n \n-  v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n+  if (!GET_MODE_2XWIDER_MODE (GET_MODE (op0)).exists (&v2mode))\n+    return false;\n   x = gen_rtx_VEC_CONCAT (v2mode, op0, op1);\n   return mips_expand_vselect (target, x, perm, nelt);\n }"}, {"sha": "4de0611ebb4d582d046c7b67f549f4b6edf7bfec", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -55,6 +55,7 @@ typedef const struct simple_bitmap_def *const_sbitmap;\n struct rtx_def;\n typedef struct rtx_def *rtx;\n typedef const struct rtx_def *const_rtx;\n+template<typename> class opt_mode;\n \n /* Subclasses of rtx_def, using indentation to show the class\n    hierarchy, along with the relevant invariant."}, {"sha": "48a006004ffe47b88cf85b5f08ef5dc39426f84e", "filename": "gcc/expmed.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -207,11 +207,10 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n       for (mode_from = MIN_MODE_INT; mode_from <= MAX_MODE_INT;\n \t   mode_from = (machine_mode)(mode_from + 1))\n \tinit_expmed_one_conv (all, mode, mode_from, speed);\n-    }\n-  if (GET_MODE_CLASS (mode) == MODE_INT)\n-    {\n-      machine_mode  wider_mode = GET_MODE_WIDER_MODE (mode);\n-      if (wider_mode != VOIDmode)\n+\n+      machine_mode wider_mode;\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_WIDER_MODE (mode).exists (&wider_mode))\n \t{\n \t  PUT_MODE (all->zext, wider_mode);\n \t  PUT_MODE (all->wide_mult, wider_mode);\n@@ -3641,7 +3640,7 @@ extract_high_half (machine_mode mode, rtx op)\n \n   gcc_assert (!SCALAR_FLOAT_MODE_P (mode));\n \n-  wider_mode = GET_MODE_WIDER_MODE (mode);\n+  wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n   op = expand_shift (RSHIFT_EXPR, wider_mode, op,\n \t\t     GET_MODE_BITSIZE (mode), 0, 1);\n   return convert_modes (mode, wider_mode, op, 0);\n@@ -3663,7 +3662,7 @@ expmed_mult_highpart_optab (machine_mode mode, rtx op0, rtx op1,\n \n   gcc_assert (!SCALAR_FLOAT_MODE_P (mode));\n \n-  wider_mode = GET_MODE_WIDER_MODE (mode);\n+  wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n   size = GET_MODE_BITSIZE (mode);\n \n   /* Firstly, try using a multiplication insn that only generates the needed\n@@ -3769,7 +3768,7 @@ static rtx\n expmed_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n \t\t      rtx target, int unsignedp, int max_cost)\n {\n-  machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n+  machine_mode wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n   unsigned HOST_WIDE_INT cnst1;\n   int extra_cost;\n   bool sign_adjust = false;"}, {"sha": "0219045f9ff793db77b6dcf71401b518affde9ba", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -9159,7 +9159,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \tif (code == LSHIFT_EXPR\n \t    && target\n \t    && REG_P (target)\n-\t    && mode == GET_MODE_WIDER_MODE (word_mode)\n+\t    && mode == GET_MODE_WIDER_MODE (word_mode).else_void ()\n \t    && GET_MODE_SIZE (mode) == 2 * GET_MODE_SIZE (word_mode)\n \t    && TREE_CONSTANT (treeop1)\n \t    && TREE_CODE (treeop0) == SSA_NAME)"}, {"sha": "847cd08302f52de9b8dcf999daa879ffbfcf9e01", "filename": "gcc/gdbhooks.py", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -422,6 +422,18 @@ def children (self):\n \n ######################################################################\n \n+class OptMachineModePrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def to_string (self):\n+        name = str(self.gdbval['m_mode'])\n+\tif name == 'E_VOIDmode':\n+\t    return '<None>'\n+        return name[2:] if name.startswith('E_') else name\n+\n+######################################################################\n+\n # TODO:\n #   * hashtab\n #   * location_t\n@@ -518,6 +530,9 @@ def build_pretty_printer():\n                              'vec',\n                              VecPrinter)\n \n+    pp.add_printer_for_regex(r'opt_mode<(\\S+)>',\n+                             'opt_mode', OptMachineModePrinter)\n+\n     return pp\n \n gdb.printing.register_pretty_printer("}, {"sha": "8ac4f6a982627b4ebecac4443e51b8adfeb247f2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -1460,14 +1460,14 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n       struct separate_ops ops;\n       int prec = GET_MODE_PRECISION (mode);\n       machine_mode hmode = mode_for_size (prec / 2, MODE_INT, 1);\n+      machine_mode wmode;\n       ops.op0 = make_tree (type, op0);\n       ops.op1 = make_tree (type, op1);\n       ops.op2 = NULL_TREE;\n       ops.location = loc;\n-      if (GET_MODE_2XWIDER_MODE (mode) != VOIDmode\n-\t  && targetm.scalar_mode_supported_p (GET_MODE_2XWIDER_MODE (mode)))\n+      if (GET_MODE_2XWIDER_MODE (mode).exists (&wmode)\n+\t  && targetm.scalar_mode_supported_p (wmode))\n \t{\n-\t  machine_mode wmode = GET_MODE_2XWIDER_MODE (mode);\n \t  ops.code = WIDEN_MULT_EXPR;\n \t  ops.type\n \t    = build_nonstandard_integer_type (GET_MODE_PRECISION (wmode), uns);"}, {"sha": "ac19e8f52ada0aed21f4fa92ad7d0efde5772d4f", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -266,7 +266,7 @@ init_lower_subreg (void)\n \n   memset (this_target_lower_subreg, 0, sizeof (*this_target_lower_subreg));\n \n-  twice_word_mode = GET_MODE_2XWIDER_MODE (word_mode);\n+  twice_word_mode = GET_MODE_2XWIDER_MODE (word_mode).require ();\n \n   rtxes.target = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n   rtxes.source = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 2);"}, {"sha": "51d9a7b222b5636e4b3f9a09eaad34f0924b8c0d", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -1636,7 +1636,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n \t\t\t\t    : GET_CLASS_NARROWEST_MODE (mclass);\n \t     pass ? mr < MAX_MACHINE_MODE : mr != VOIDmode;\n \t     pass ? mr = (machine_mode) (mr + 1)\n-\t\t  : mr = GET_MODE_WIDER_MODE (mr))\n+\t\t  : mr = GET_MODE_WIDER_MODE (mr).else_void ())\n \t  if (GET_MODE_CLASS (mr) != mclass\n \t      || GET_MODE_SIZE (mr) != size\n \t      || GET_MODE_PRECISION (mr) != prec"}, {"sha": "3b06f6d2c3ccf1d220a59bfe49e7ea15676c42be", "filename": "gcc/machmode.h", "status": "modified", "additions": 83, "deletions": 9, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -221,6 +221,71 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n #define POINTER_BOUNDS_MODE_P(MODE)      \\\n   (GET_MODE_CLASS (MODE) == MODE_POINTER_BOUNDS)\n \n+/* An optional T (i.e. a T or nothing), where T is some form of mode class.  */\n+template<typename T>\n+class opt_mode\n+{\n+public:\n+  enum from_int { dummy = MAX_MACHINE_MODE };\n+\n+  ALWAYS_INLINE opt_mode () : m_mode (E_VOIDmode) {}\n+  ALWAYS_INLINE opt_mode (const T &m) : m_mode (m) {}\n+  ALWAYS_INLINE opt_mode (from_int m) : m_mode (machine_mode (m)) {}\n+\n+  machine_mode else_void () const;\n+  T require () const;\n+\n+  bool exists () const;\n+  template<typename U> bool exists (U *) const;\n+\n+private:\n+  machine_mode m_mode;\n+};\n+\n+/* If the object contains a T, return its enum value, otherwise return\n+   E_VOIDmode.  */\n+\n+template<typename T>\n+ALWAYS_INLINE machine_mode\n+opt_mode<T>::else_void () const\n+{\n+  return m_mode;\n+}\n+\n+/* Assert that the object contains a T and return it.  */\n+\n+template<typename T>\n+inline T\n+opt_mode<T>::require () const\n+{\n+  gcc_checking_assert (m_mode != E_VOIDmode);\n+  return typename mode_traits<T>::from_int (m_mode);\n+}\n+\n+/* Return true if the object contains a T rather than nothing.  */\n+\n+template<typename T>\n+ALWAYS_INLINE bool\n+opt_mode<T>::exists () const\n+{\n+  return m_mode != E_VOIDmode;\n+}\n+\n+/* Return true if the object contains a T, storing it in *MODE if so.  */\n+\n+template<typename T>\n+template<typename U>\n+inline bool\n+opt_mode<T>::exists (U *mode) const\n+{\n+  if (m_mode != E_VOIDmode)\n+    {\n+      *mode = T (typename mode_traits<T>::from_int (m_mode));\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Return the base GET_MODE_SIZE value for MODE.  */\n \n ALWAYS_INLINE unsigned short\n@@ -352,13 +417,22 @@ extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n \n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n \n-extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n-#define GET_MODE_WIDER_MODE(MODE) ((machine_mode) mode_wider[MODE])\n+template<typename T>\n+ALWAYS_INLINE opt_mode<T>\n+GET_MODE_WIDER_MODE (const T &m)\n+{\n+  return typename opt_mode<T>::from_int (mode_wider[m]);\n+}\n \n /* For scalars, this is a mode with twice the precision.  For vectors,\n    this is a mode with the same inner mode but with twice the elements.  */\n-extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];\n-#define GET_MODE_2XWIDER_MODE(MODE) ((machine_mode) mode_2xwider[MODE])\n+\n+template<typename T>\n+ALWAYS_INLINE opt_mode<T>\n+GET_MODE_2XWIDER_MODE (const T &m)\n+{\n+  return typename opt_mode<T>::from_int (mode_2xwider[m]);\n+}\n \n /* Get the complex mode from the component mode.  */\n extern const unsigned char mode_complex[NUM_MACHINE_MODES];\n@@ -497,17 +571,17 @@ namespace mode_iterator\n   inline void\n   get_wider (machine_mode *iter)\n   {\n-    *iter = GET_MODE_WIDER_MODE (*iter);\n+    *iter = GET_MODE_WIDER_MODE (*iter).else_void ();\n   }\n \n   /* Set mode iterator *ITER to the next widest mode in the same class.\n      Such a mode is known to exist.  */\n \n+  template<typename T>\n   inline void\n-  get_known_wider (machine_mode *iter)\n+  get_known_wider (T *iter)\n   {\n-    *iter = GET_MODE_WIDER_MODE (*iter);\n-    gcc_checking_assert (*iter != VOIDmode);\n+    *iter = GET_MODE_WIDER_MODE (*iter).require ();\n   }\n \n   /* Set mode iterator *ITER to the mode that is two times wider than the\n@@ -516,7 +590,7 @@ namespace mode_iterator\n   inline void\n   get_2xwider (machine_mode *iter)\n   {\n-    *iter = GET_MODE_2XWIDER_MODE (*iter);\n+    *iter = GET_MODE_2XWIDER_MODE (*iter).else_void ();\n   }\n }\n "}, {"sha": "5deb5398c75308441eb91a9e73cbddf62d1621e6", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -3456,8 +3456,8 @@ omp_clause_aligned_alignment (tree clause)\n \t  continue;\n \twhile (vs\n \t       && GET_MODE_SIZE (vmode) < vs\n-\t       && GET_MODE_2XWIDER_MODE (vmode) != VOIDmode)\n-\t  vmode = GET_MODE_2XWIDER_MODE (vmode);\n+\t       && GET_MODE_2XWIDER_MODE (vmode).exists ())\n+\t  vmode = GET_MODE_2XWIDER_MODE (vmode).require ();\n \n \ttree type = lang_hooks.types.type_for_mode (mode, 1);\n \tif (type == NULL_TREE || TYPE_MODE (type) != mode)"}, {"sha": "7b53a465a091ef29c83ba399cadec3f16ec06e74", "filename": "gcc/optabs-libfuncs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Foptabs-libfuncs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Foptabs-libfuncs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-libfuncs.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -918,9 +918,10 @@ init_sync_libfuncs_1 (optab tab, const char *base, int max)\n   mode = QImode;\n   for (i = 1; i <= max; i *= 2)\n     {\n+      if (i > 1)\n+\tmode = GET_MODE_2XWIDER_MODE (mode).require ();\n       buf[len + 1] = '0' + i;\n       set_optab_libfunc (tab, mode, buf);\n-      mode = GET_MODE_2XWIDER_MODE (mode);\n     }\n }\n "}, {"sha": "021d8160cf420ca73bc3cdbb1be75f5b765a34be", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -425,7 +425,7 @@ find_widening_optab_handler_and_mode (optab op, machine_mode to_mode,\n   for (; (permit_non_widening || from_mode != to_mode)\n \t && GET_MODE_SIZE (from_mode) <= GET_MODE_SIZE (to_mode)\n \t && from_mode != VOIDmode;\n-       from_mode = GET_MODE_WIDER_MODE (from_mode))\n+       from_mode = GET_MODE_WIDER_MODE (from_mode).else_void ())\n     {\n       enum insn_code handler = widening_optab_handler (op, to_mode,\n \t\t\t\t\t\t       from_mode);"}, {"sha": "c6ad64b5f8d02dda81d134c1508087484572278e", "filename": "gcc/optabs.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -1186,13 +1186,13 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      takes operands of this mode and makes a wider mode.  */\n \n   if (binoptab == smul_optab\n-      && GET_MODE_2XWIDER_MODE (mode) != VOIDmode\n-      && (widening_optab_handler ((unsignedp ? umul_widen_optab\n-\t\t\t\t\t     : smul_widen_optab),\n-\t\t\t\t  GET_MODE_2XWIDER_MODE (mode), mode)\n-\t  != CODE_FOR_nothing))\n+      && GET_MODE_2XWIDER_MODE (mode).exists (&wider_mode)\n+      && (convert_optab_handler ((unsignedp\n+\t\t\t\t  ? umul_widen_optab\n+\t\t\t\t  : smul_widen_optab),\n+\t\t\t\t wider_mode, mode) != CODE_FOR_nothing))\n     {\n-      temp = expand_binop (GET_MODE_2XWIDER_MODE (mode),\n+      temp = expand_binop (wider_mode,\n \t\t\t   unsignedp ? umul_widen_optab : smul_widen_optab,\n \t\t\t   op0, op1, NULL_RTX, unsignedp, OPTAB_DIRECT);\n \n@@ -1253,14 +1253,14 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && methods != OPTAB_DIRECT && methods != OPTAB_LIB)\n     FOR_EACH_WIDER_MODE (wider_mode, mode)\n       {\n+\tmachine_mode next_mode;\n \tif (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n \t    || (binoptab == smul_optab\n-\t\t&& GET_MODE_WIDER_MODE (wider_mode) != VOIDmode\n+\t\t&& GET_MODE_WIDER_MODE (wider_mode).exists (&next_mode)\n \t\t&& (find_widening_optab_handler ((unsignedp\n \t\t\t\t\t\t  ? umul_widen_optab\n \t\t\t\t\t\t  : smul_widen_optab),\n-\t\t\t\t\t\t GET_MODE_WIDER_MODE (wider_mode),\n-\t\t\t\t\t\t mode, 0)\n+\t\t\t\t\t\t next_mode, mode, 0)\n \t\t    != CODE_FOR_nothing)))\n \t  {\n \t    rtx xop0 = op0, xop1 = op1;\n@@ -3702,7 +3702,7 @@ can_compare_p (enum rtx_code code, machine_mode mode,\n \t  && optab_handler (cmov_optab, mode) != CODE_FOR_nothing)\n \treturn 1;\n \n-      mode = GET_MODE_WIDER_MODE (mode);\n+      mode = GET_MODE_WIDER_MODE (mode).else_void ();\n       PUT_MODE (test, mode);\n     }\n   while (mode != VOIDmode);"}, {"sha": "157f592ee979f20f0ea46d44994115a02d520de3", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -5671,13 +5671,15 @@ init_num_sign_bit_copies_in_rep (void)\n \t/* Currently, it is assumed that TARGET_MODE_REP_EXTENDED\n \t   extends to the next widest mode.  */\n \tgcc_assert (targetm.mode_rep_extended (mode, in_mode) == UNKNOWN\n-\t\t    || GET_MODE_WIDER_MODE (mode) == in_mode);\n+\t\t    || GET_MODE_WIDER_MODE (mode).require () == in_mode);\n \n \t/* We are in in_mode.  Count how many bits outside of mode\n \t   have to be copies of the sign-bit.  */\n \tFOR_EACH_MODE (i, mode, in_mode)\n \t  {\n-\t    machine_mode wider = GET_MODE_WIDER_MODE (i);\n+\t    /* This must always exist (for the last iteration it will be\n+\t       IN_MODE).  */\n+\t    machine_mode wider = GET_MODE_WIDER_MODE (i).require ();\n \n \t    if (targetm.mode_rep_extended (i, wider) == SIGN_EXTEND\n \t\t/* We can only check sign-bit copies starting from the"}, {"sha": "f69fad8fd7599235d15cf112a233453bb6b76d1b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -2745,7 +2745,8 @@ ::bit_field_mode_iterator (HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n bool\n bit_field_mode_iterator::next_mode (machine_mode *out_mode)\n {\n-  for (; m_mode != VOIDmode; m_mode = GET_MODE_WIDER_MODE (m_mode))\n+  for (; m_mode != VOIDmode;\n+       m_mode = GET_MODE_WIDER_MODE (m_mode).else_void ())\n     {\n       unsigned int unit = GET_MODE_BITSIZE (m_mode);\n \n@@ -2782,7 +2783,7 @@ bit_field_mode_iterator::next_mode (machine_mode *out_mode)\n \tbreak;\n \n       *out_mode = m_mode;\n-      m_mode = GET_MODE_WIDER_MODE (m_mode);\n+      m_mode = GET_MODE_WIDER_MODE (m_mode).else_void ();\n       m_count++;\n       return true;\n     }"}, {"sha": "e6b7dbdf100c3ff8a3b332b02a09b1970529770d", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -3283,8 +3283,8 @@ convert_mult_to_widen (gimple *stmt, gimple_stmt_iterator *gsi)\n \t      || (TYPE_UNSIGNED (type2)\n \t\t  && TYPE_PRECISION (type2) == GET_MODE_PRECISION (from_mode)))\n \t    {\n-\t      from_mode = GET_MODE_WIDER_MODE (from_mode);\n-\t      if (GET_MODE_SIZE (to_mode) <= GET_MODE_SIZE (from_mode))\n+\t      if (!GET_MODE_WIDER_MODE (from_mode).exists (&from_mode)\n+\t\t  || GET_MODE_SIZE (to_mode) <= GET_MODE_SIZE (from_mode))\n \t\treturn false;\n \t    }\n \n@@ -3465,8 +3465,8 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple *stmt,\n \t  || (from_unsigned2\n \t      && TYPE_PRECISION (type2) == GET_MODE_PRECISION (from_mode)))\n \t{\n-\t  from_mode = GET_MODE_WIDER_MODE (from_mode);\n-\t  if (GET_MODE_SIZE (from_mode) >= GET_MODE_SIZE (to_mode))\n+\t  if (!GET_MODE_WIDER_MODE (from_mode).exists (&from_mode)\n+\t      || GET_MODE_SIZE (from_mode) >= GET_MODE_SIZE (to_mode))\n \t    return false;\n \t}\n "}, {"sha": "9f88869fbf9e2e2ddc503a569a3b268853fe79ae", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -1088,8 +1088,7 @@ array_value_type (gswitch *swtch, tree type, int num,\n \t  if (sign == 1)\n \t    sign = 0;\n \n-\t  mode = GET_MODE_WIDER_MODE (mode);\n-\t  if (mode == VOIDmode\n+\t  if (!GET_MODE_WIDER_MODE (mode).exists (&mode)\n \t      || GET_MODE_SIZE (mode) >= GET_MODE_SIZE (type_mode))\n \t    return type;\n \t}"}, {"sha": "268969700b62391d4f082becd8d2ff6794f65f78", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -10120,7 +10120,7 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n   else\n     {\n       mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-      do\n+      for (;;)\n \t{\n \t  /* If we cannot do a signed conversion to float from mode\n \t     or if the value-range does not fit in the signed type\n@@ -10129,15 +10129,12 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n \t      && range_fits_type_p (vr, GET_MODE_PRECISION (mode), SIGNED))\n \t    break;\n \n-\t  mode = GET_MODE_WIDER_MODE (mode);\n \t  /* But do not widen the input.  Instead leave that to the\n \t     optabs expansion code.  */\n-\t  if (GET_MODE_PRECISION (mode) > TYPE_PRECISION (TREE_TYPE (rhs1)))\n+\t  if (!GET_MODE_WIDER_MODE (mode).exists (&mode)\n+\t      || GET_MODE_PRECISION (mode) > TYPE_PRECISION (TREE_TYPE (rhs1)))\n \t    return false;\n \t}\n-      while (mode != VOIDmode);\n-      if (mode == VOIDmode)\n-\treturn false;\n     }\n \n   /* It works, insert a truncation or sign-change before the"}, {"sha": "0721771a69dc882207e22426d6dad4c99ec94b4f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490d0f6c91c0c4fef57a5ffe438629b0687113de/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=490d0f6c91c0c4fef57a5ffe438629b0687113de", "patch": "@@ -8706,12 +8706,11 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n       last_limit = offsets[n_var_parts] + GET_MODE_SIZE (mode);\n \n       /* Attempt to merge adjacent registers or memory.  */\n-      wider_mode = GET_MODE_WIDER_MODE (mode);\n       for (j = i + 1; j < var->n_var_parts; j++)\n \tif (last_limit <= VAR_PART_OFFSET (var, j))\n \t  break;\n       if (j < var->n_var_parts\n-\t  && wider_mode != VOIDmode\n+\t  && GET_MODE_WIDER_MODE (mode).exists (&wider_mode)\n \t  && var->var_part[j].cur_loc\n \t  && mode == GET_MODE (var->var_part[j].cur_loc)\n \t  && (REG_P (loc[n_var_parts]) || MEM_P (loc[n_var_parts]))"}]}