{"sha": "876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc2MjE3YWU3MWNmMGIzNDQ5MGY4ZjUzYmIyYTEyZDk5ZDhiYWE3YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-02-12T19:18:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-02-12T19:18:03Z"}, "message": "PR other/69554: avoid excessive source printing for widely-separated locations\n\ngcc/ChangeLog:\n\tPR other/69554\n\t* diagnostic-show-locus.c (struct line_span): New struct.\n\t(layout::get_first_line): Delete.\n\t(layout::get_last_line): Delete.\n\t(layout::get_num_line_spans): New member function.\n\t(layout::get_line_span): Likewise.\n\t(layout::print_heading_for_line_span_index_p): Likewise.\n\t(layout::get_expanded_location): Likewise.\n\t(layout::calculate_line_spans): Likewise.\n\t(layout::m_first_line): Delete.\n\t(layout::m_last_line): Delete.\n\t(layout::m_line_spans): New field.\n\t(layout::layout): Update comment.  Replace m_first_line and\n\tm_last_line with m_line_spans, replacing their initialization\n\twith a call to calculate_line_spans.\n\t(diagnostic_show_locus): When printing source lines and\n\tannotations, rather than looping over a single span\n\tof lines, instead loop over each line_span within\n\tthe layout, with an inner loop over the lines within them.\n\tCall the context's start_span callback when changing line spans.\n\t* diagnostic.c (diagnostic_initialize): Initialize start_span.\n\t(diagnostic_build_prefix): Break out the building of the location\n\tpart of the string into...\n\t(diagnostic_get_location_text): ...this new function, rewriting\n\tit from nested ternary expressions to a sequence of \"if\"\n\tstatements.\n\t(default_diagnostic_start_span_fn): New function.\n\t* diagnostic.h (diagnostic_start_span_fn): New typedef.\n\t(diagnostic_context::start_span): New field.\n\t(default_diagnostic_start_span_fn): New prototype.\n\ngcc/fortran/ChangeLog:\n\tPR other/69554\n\t* error.c (gfc_diagnostic_start_span): New function.\n\t(gfc_diagnostics_init): Initialize global_dc's start_span.\n\ngcc/testsuite/ChangeLog:\n\tPR other/69554\n\t* gcc.dg/pr69554-1.c: New test.\n\t* gfortran.dg/pr69554-1.F90: New test.\n\t* gfortran.dg/pr69554-2.F90: New test.\n\t* lib/gcc-dg.exp (proc dg-locus): New function.\n\t* lib/gfortran-dg.exp (proc gfortran-dg-test): Update comment to\n\tdistinguish between the caret-printing and non-caret-printing\n\tcases.  If caret-printing has been explicitly enabled, bail out\n\twithout attempting to fix up the output.\n\nFrom-SVN: r233386", "tree": {"sha": "22a70a51fef5f5d79fbd3d50832a5ca8535979ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22a70a51fef5f5d79fbd3d50832a5ca8535979ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8dccd19b3be7d3b94c6d3e0cbc7674d12314e909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dccd19b3be7d3b94c6d3e0cbc7674d12314e909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dccd19b3be7d3b94c6d3e0cbc7674d12314e909"}], "stats": {"total": 612, "additions": 571, "deletions": 41}, "files": [{"sha": "c486023936ccb277d091ddb3066ea4205fd70a9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -1,3 +1,36 @@\n+2016-02-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/69554\n+\t* diagnostic-show-locus.c (struct line_span): New struct.\n+\t(layout::get_first_line): Delete.\n+\t(layout::get_last_line): Delete.\n+\t(layout::get_num_line_spans): New member function.\n+\t(layout::get_line_span): Likewise.\n+\t(layout::print_heading_for_line_span_index_p): Likewise.\n+\t(layout::get_expanded_location): Likewise.\n+\t(layout::calculate_line_spans): Likewise.\n+\t(layout::m_first_line): Delete.\n+\t(layout::m_last_line): Delete.\n+\t(layout::m_line_spans): New field.\n+\t(layout::layout): Update comment.  Replace m_first_line and\n+\tm_last_line with m_line_spans, replacing their initialization\n+\twith a call to calculate_line_spans.\n+\t(diagnostic_show_locus): When printing source lines and\n+\tannotations, rather than looping over a single span\n+\tof lines, instead loop over each line_span within\n+\tthe layout, with an inner loop over the lines within them.\n+\tCall the context's start_span callback when changing line spans.\n+\t* diagnostic.c (diagnostic_initialize): Initialize start_span.\n+\t(diagnostic_build_prefix): Break out the building of the location\n+\tpart of the string into...\n+\t(diagnostic_get_location_text): ...this new function, rewriting\n+\tit from nested ternary expressions to a sequence of \"if\"\n+\tstatements.\n+\t(default_diagnostic_start_span_fn): New function.\n+\t* diagnostic.h (diagnostic_start_span_fn): New typedef.\n+\t(diagnostic_context::start_span): New field.\n+\t(default_diagnostic_start_span_fn): New prototype.\n+\n 2016-02-12  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR driver/69779"}, {"sha": "3acdb32089c976f704f5d31f9241f6500c1fb1f2", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 204, "deletions": 22, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -137,6 +137,40 @@ struct line_bounds\n   int m_last_non_ws;\n };\n \n+/* A range of contiguous source lines within a layout (e.g. \"lines 5-10\"\n+   or \"line 23\").  During the layout ctor, layout::calculate_line_spans\n+   splits the pertinent source lines into a list of disjoint line_span\n+   instances (e.g. lines 5-10, lines 15-20, line 23).  */\n+\n+struct line_span\n+{\n+  line_span (linenum_type first_line, linenum_type last_line)\n+    : m_first_line (first_line), m_last_line (last_line)\n+  {\n+    gcc_assert (first_line <= last_line);\n+  }\n+  linenum_type get_first_line () const { return m_first_line; }\n+  linenum_type get_last_line () const { return m_last_line; }\n+\n+  bool contains_line_p (linenum_type line) const\n+  {\n+    return line >= m_first_line && line <= m_last_line;\n+  }\n+\n+  static int comparator (const void *p1, const void *p2)\n+  {\n+    const line_span *ls1 = (const line_span *)p1;\n+    const line_span *ls2 = (const line_span *)p2;\n+    int first_line_diff = (int)ls1->m_first_line - (int)ls2->m_first_line;\n+    if (first_line_diff)\n+      return first_line_diff;\n+    return (int)ls1->m_last_line - (int)ls2->m_last_line;\n+  }\n+\n+  linenum_type m_first_line;\n+  linenum_type m_last_line;\n+};\n+\n /* A class to control the overall layout when printing a diagnostic.\n \n    The layout is determined within the constructor.\n@@ -151,14 +185,20 @@ class layout\n   layout (diagnostic_context *context,\n \t  const diagnostic_info *diagnostic);\n \n-  int get_first_line () const { return m_first_line; }\n-  int get_last_line () const { return m_last_line; }\n+  int get_num_line_spans () const { return m_line_spans.length (); }\n+  const line_span *get_line_span (int idx) const { return &m_line_spans[idx]; }\n+\n+  bool print_heading_for_line_span_index_p (int line_span_idx) const;\n+\n+  expanded_location get_expanded_location (const line_span *) const;\n \n   bool print_source_line (int row, line_bounds *lbounds_out);\n   void print_annotation_line (int row, const line_bounds lbounds);\n   void print_any_fixits (int row, const rich_location *richloc);\n \n  private:\n+  void calculate_line_spans ();\n+\n   void print_newline ();\n \n   bool\n@@ -183,8 +223,7 @@ class layout\n   colorizer m_colorizer;\n   bool m_colorize_source_p;\n   auto_vec <layout_range> m_layout_ranges;\n-  int m_first_line;\n-  int m_last_line;\n+  auto_vec <line_span> m_line_spans;\n   int m_x_offset;\n };\n \n@@ -424,7 +463,8 @@ get_line_width_without_trailing_whitespace (const char *line, int line_width)\n \n    Filter the ranges from the rich_location to those that we can\n    sanely print, populating m_layout_ranges.\n-   Determine the range of lines that we will print.\n+   Determine the range of lines that we will print, splitting them\n+   up into an ordered list of disjoint spans of contiguous line numbers.\n    Determine m_x_offset, to ensure that the primary caret\n    will fit within the max_width provided by the diagnostic_context.  */\n \n@@ -437,8 +477,7 @@ layout::layout (diagnostic_context * context,\n   m_colorizer (context, diagnostic),\n   m_colorize_source_p (context->colorize_source_p),\n   m_layout_ranges (rich_location::MAX_RANGES),\n-  m_first_line (m_exploc.line),\n-  m_last_line  (m_exploc.line),\n+  m_line_spans (1 + rich_location::MAX_RANGES),\n   m_x_offset (0)\n {\n   rich_location *richloc = diagnostic->richloc;\n@@ -484,14 +523,11 @@ layout::layout (diagnostic_context * context,\n       /* Passed all the tests; add the range to m_layout_ranges so that\n \t it will be printed.  */\n       m_layout_ranges.safe_push (ri);\n-\n-      /* Update m_first_line/m_last_line if necessary.  */\n-      if (ri.m_start.m_line < m_first_line)\n-\tm_first_line = ri.m_start.m_line;\n-      if (ri.m_finish.m_line > m_last_line)\n-\tm_last_line = ri.m_finish.m_line;\n     }\n \n+  /* Populate m_line_spans.  */\n+  calculate_line_spans ();\n+\n   /* Adjust m_x_offset.\n      Center the primary caret to fit in max_width; all columns\n      will be adjusted accordingly.  */\n@@ -511,6 +547,142 @@ layout::layout (diagnostic_context * context,\n     }\n }\n \n+/* Return true iff we should print a heading when starting the\n+   line span with the given index.  */\n+\n+bool\n+layout::print_heading_for_line_span_index_p (int line_span_idx) const\n+{\n+  /* We print a heading for every change of line span, hence for every\n+     line span after the initial one.  */\n+  if (line_span_idx > 0)\n+    return true;\n+\n+  /* We also do it for the initial span if the primary location of the\n+     diagnostic is in a different span.  */\n+  if (m_exploc.line > (int)get_line_span (0)->m_last_line)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Get an expanded_location for the first location of interest within\n+   the given line_span.\n+   Used when printing a heading to indicate a new line span.  */\n+\n+expanded_location\n+layout::get_expanded_location (const line_span *line_span) const\n+{\n+  /* Whenever possible, use the caret location.  */\n+  if (line_span->contains_line_p (m_exploc.line))\n+    return m_exploc;\n+\n+  /* Otherwise, use the start of the first range that's present\n+     within the line_span.  */\n+  for (unsigned int i = 0; i < m_layout_ranges.length (); i++)\n+    {\n+      const layout_range *lr = &m_layout_ranges[i];\n+      if (line_span->contains_line_p (lr->m_start.m_line))\n+\t{\n+\t  expanded_location exploc = m_exploc;\n+\t  exploc.line = lr->m_start.m_line;\n+\t  exploc.column = lr->m_start.m_column;\n+\t  return exploc;\n+\t}\n+    }\n+\n+  /* It should not be possible to have a line span that didn't\n+     contain any of the layout_range instances.  */\n+  gcc_unreachable ();\n+  return m_exploc;\n+}\n+\n+/* We want to print the pertinent source code at a diagnostic.  The\n+   rich_location can contain multiple locations.  This will have been\n+   filtered into m_exploc (the caret for the primary location) and\n+   m_layout_ranges, for those ranges within the same source file.\n+\n+   We will print a subset of the lines within the source file in question,\n+   as a collection of \"spans\" of lines.\n+\n+   This function populates m_line_spans with an ordered, disjoint list of\n+   the line spans of interest.\n+\n+   For example, if the primary caret location is on line 7, with ranges\n+   covering lines 5-6 and lines 9-12:\n+\n+     004\n+     005                   |RANGE 0\n+     006                   |RANGE 0\n+     007  |PRIMARY CARET\n+     008\n+     009                                |RANGE 1\n+     010                                |RANGE 1\n+     011                                |RANGE 1\n+     012                                |RANGE 1\n+     013\n+\n+   then we want two spans: lines 5-7 and lines 9-12.  */\n+\n+void\n+layout::calculate_line_spans ()\n+{\n+  /* This should only be called once, by the ctor.  */\n+  gcc_assert (m_line_spans.length () == 0);\n+\n+  /* Populate tmp_spans with individual spans, for each of\n+     m_exploc, and for m_layout_ranges.  */\n+  auto_vec<line_span> tmp_spans (1 + rich_location::MAX_RANGES);\n+  tmp_spans.safe_push (line_span (m_exploc.line, m_exploc.line));\n+  for (unsigned int i = 0; i < m_layout_ranges.length (); i++)\n+    {\n+      const layout_range *lr = &m_layout_ranges[i];\n+      gcc_assert (lr->m_start.m_line <= lr->m_finish.m_line);\n+      tmp_spans.safe_push (line_span (lr->m_start.m_line,\n+\t\t\t\t      lr->m_finish.m_line));\n+    }\n+\n+  /* Sort them.  */\n+  tmp_spans.qsort(line_span::comparator);\n+\n+  /* Now iterate through tmp_spans, copying into m_line_spans, and\n+     combining where possible.  */\n+  gcc_assert (tmp_spans.length () > 0);\n+  m_line_spans.safe_push (tmp_spans[0]);\n+  for (unsigned int i = 1; i < tmp_spans.length (); i++)\n+    {\n+      line_span *current = &m_line_spans[m_line_spans.length () - 1];\n+      const line_span *next = &tmp_spans[i];\n+      gcc_assert (next->m_first_line >= current->m_first_line);\n+      if (next->m_first_line <= current->m_last_line + 1)\n+\t{\n+\t  /* We can merge them. */\n+\t  if (next->m_last_line > current->m_last_line)\n+\t    current->m_last_line = next->m_last_line;\n+\t}\n+      else\n+\t{\n+\t  /* No merger possible.  */\n+\t  m_line_spans.safe_push (*next);\n+\t}\n+    }\n+\n+  /* Verify the result, in m_line_spans.  */\n+  gcc_assert (m_line_spans.length () > 0);\n+  for (unsigned int i = 1; i < m_line_spans.length (); i++)\n+    {\n+      const line_span *prev = &m_line_spans[i - 1];\n+      const line_span *next = &m_line_spans[i];\n+      /* The individual spans must be sane.  */\n+      gcc_assert (prev->m_first_line <= prev->m_last_line);\n+      gcc_assert (next->m_first_line <= next->m_last_line);\n+      /* The spans must be ordered.  */\n+      gcc_assert (prev->m_first_line < next->m_first_line);\n+      /* There must be a gap of at least one line between separate spans.  */\n+      gcc_assert ((prev->m_last_line + 1) < next->m_first_line);\n+    }\n+}\n+\n /* Attempt to print line ROW of source code, potentially colorized at any\n    ranges.\n    Return true if the line was printed, populating *LBOUNDS_OUT.\n@@ -826,17 +998,27 @@ diagnostic_show_locus (diagnostic_context * context,\n   pp_set_prefix (context->printer, NULL);\n \n   layout layout (context, diagnostic);\n-  int last_line = layout.get_last_line ();\n-  for (int row = layout.get_first_line (); row <= last_line; row++)\n+  for (int line_span_idx = 0; line_span_idx < layout.get_num_line_spans ();\n+       line_span_idx++)\n     {\n-      /* Print the source line, followed by an annotation line\n-\t consisting of any caret/underlines, then any fixits.\n-\t If the source line can't be read, print nothing.  */\n-      line_bounds lbounds;\n-      if (layout.print_source_line (row, &lbounds))\n+      const line_span *line_span = layout.get_line_span (line_span_idx);\n+      if (layout.print_heading_for_line_span_index_p (line_span_idx))\n+\t{\n+\t  expanded_location exploc = layout.get_expanded_location (line_span);\n+\t  context->start_span (context, exploc);\n+\t}\n+      int last_line = line_span->get_last_line ();\n+      for (int row = line_span->get_first_line (); row <= last_line; row++)\n \t{\n-\t  layout.print_annotation_line (row, lbounds);\n-\t  layout.print_any_fixits (row, diagnostic->richloc);\n+\t  /* Print the source line, followed by an annotation line\n+\t     consisting of any caret/underlines, then any fixits.\n+\t     If the source line can't be read, print nothing.  */\n+\t  line_bounds lbounds;\n+\t  if (layout.print_source_line (row, &lbounds))\n+\t    {\n+\t      layout.print_annotation_line (row, lbounds);\n+\t      layout.print_any_fixits (row, diagnostic->richloc);\n+\t    }\n \t}\n     }\n "}, {"sha": "322f2d9f5c08173c990257efa968e433454a2b01", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -158,6 +158,7 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n   context->max_errors = 0;\n   context->internal_error = NULL;\n   diagnostic_starter (context) = default_diagnostic_starter;\n+  context->start_span = default_diagnostic_start_span_fn;\n   diagnostic_finalizer (context) = default_diagnostic_finalizer;\n   context->option_enabled = NULL;\n   context->option_state = NULL;\n@@ -274,8 +275,34 @@ diagnostic_get_color_for_kind (diagnostic_t kind)\n   return diagnostic_kind_color[kind];\n }\n \n-/* Return a malloc'd string describing a location.  The caller is\n-   responsible for freeing the memory.  */\n+/* Return a malloc'd string describing a location e.g. \"foo.c:42:10\".\n+   The caller is responsible for freeing the memory.  */\n+\n+static char *\n+diagnostic_get_location_text (diagnostic_context *context,\n+\t\t\t      expanded_location s)\n+{\n+  pretty_printer *pp = context->printer;\n+  const char *locus_cs = colorize_start (pp_show_color (pp), \"locus\");\n+  const char *locus_ce = colorize_stop (pp_show_color (pp));\n+\n+  if (s.file == NULL)\n+    return build_message_string (\"%s%s:%s\", locus_cs, progname, locus_ce);\n+\n+  if (!strcmp (s.file, N_(\"<built-in>\")))\n+    return build_message_string (\"%s%s:%s\", locus_cs, s.file, locus_ce);\n+\n+  if (context->show_column)\n+    return build_message_string (\"%s%s:%d:%d:%s\", locus_cs, s.file, s.line,\n+\t\t\t\t s.column, locus_ce);\n+  else\n+    return build_message_string (\"%s%s:%d:%s\", locus_cs, s.file, s.line,\n+\t\t\t\t locus_ce);\n+}\n+\n+/* Return a malloc'd string describing a location and the severity of the\n+   diagnostic, e.g. \"foo.c:42:10: error: \".  The caller is responsible for\n+   freeing the memory.  */\n char *\n diagnostic_build_prefix (diagnostic_context *context,\n \t\t\t const diagnostic_info *diagnostic)\n@@ -290,7 +317,6 @@ diagnostic_build_prefix (diagnostic_context *context,\n \n   const char *text = _(diagnostic_kind_text[diagnostic->kind]);\n   const char *text_cs = \"\", *text_ce = \"\";\n-  const char *locus_cs, *locus_ce;\n   pretty_printer *pp = context->printer;\n \n   if (diagnostic_kind_color[diagnostic->kind])\n@@ -299,22 +325,14 @@ diagnostic_build_prefix (diagnostic_context *context,\n \t\t\t\tdiagnostic_kind_color[diagnostic->kind]);\n       text_ce = colorize_stop (pp_show_color (pp));\n     }\n-  locus_cs = colorize_start (pp_show_color (pp), \"locus\");\n-  locus_ce = colorize_stop (pp_show_color (pp));\n \n   expanded_location s = diagnostic_expand_location (diagnostic);\n-  return\n-    (s.file == NULL\n-     ? build_message_string (\"%s%s:%s %s%s%s\", locus_cs, progname, locus_ce,\n-\t\t\t     text_cs, text, text_ce)\n-     : !strcmp (s.file, N_(\"<built-in>\"))\n-     ? build_message_string (\"%s%s:%s %s%s%s\", locus_cs, s.file, locus_ce,\n-\t\t\t     text_cs, text, text_ce)\n-     : context->show_column\n-     ? build_message_string (\"%s%s:%d:%d:%s %s%s%s\", locus_cs, s.file, s.line,\n-\t\t\t     s.column, locus_ce, text_cs, text, text_ce)\n-     : build_message_string (\"%s%s:%d:%s %s%s%s\", locus_cs, s.file, s.line,\n-\t\t\t     locus_ce, text_cs, text, text_ce));\n+  char *location_text = diagnostic_get_location_text (context, s);\n+\n+  char *result = build_message_string (\"%s %s%s%s\", location_text,\n+\t\t\t\t       text_cs, text, text_ce);\n+  free (location_text);\n+  return result;\n }\n \n /* Functions at which to stop the backtrace print.  It's not\n@@ -540,6 +558,16 @@ default_diagnostic_starter (diagnostic_context *context,\n \t\t\t\t\t\t\t    diagnostic));\n }\n \n+void\n+default_diagnostic_start_span_fn (diagnostic_context *context,\n+\t\t\t\t  expanded_location exploc)\n+{\n+  pp_set_prefix (context->printer,\n+\t\t diagnostic_get_location_text (context, exploc));\n+  pp_string (context->printer, \"\");\n+  pp_newline (context->printer);\n+}\n+\n void\n default_diagnostic_finalizer (diagnostic_context *context,\n \t\t\t      diagnostic_info *diagnostic)"}, {"sha": "017ddcae0bf0beaf503844fc0b55dc8ac2a0ef00", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -56,6 +56,10 @@ struct diagnostic_classification_change_t\n /*  Forward declarations.  */\n typedef void (*diagnostic_starter_fn) (diagnostic_context *,\n \t\t\t\t       diagnostic_info *);\n+\n+typedef void (*diagnostic_start_span_fn) (diagnostic_context *,\n+\t\t\t\t\t  expanded_location);\n+\n typedef diagnostic_starter_fn diagnostic_finalizer_fn;\n \n /* This data structure bundles altogether any information relevant to\n@@ -148,6 +152,11 @@ struct diagnostic_context\n   */\n   diagnostic_starter_fn begin_diagnostic;\n \n+  /* This function is called by diagnostic_show_locus in between\n+     disjoint spans of source code, so that the context can print\n+     something to indicate that a new span of source code has begun.  */\n+  diagnostic_start_span_fn start_span;\n+\n   /* This function is called after the diagnostic message is printed.  */\n   diagnostic_finalizer_fn end_diagnostic;\n \n@@ -296,6 +305,8 @@ extern void diagnostic_append_note (diagnostic_context *, location_t,\n #endif\n extern char *diagnostic_build_prefix (diagnostic_context *, const diagnostic_info *);\n void default_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n+void default_diagnostic_start_span_fn (diagnostic_context *,\n+\t\t\t\t       expanded_location);\n void default_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n void diagnostic_set_caret_max_width (diagnostic_context *context, int value);\n void diagnostic_action_after_output (diagnostic_context *, diagnostic_t);"}, {"sha": "de669e03d2c3b5c6ebe1cb3d8f243b66c97d77dc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -1,3 +1,9 @@\n+2016-02-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/69554\n+\t* error.c (gfc_diagnostic_start_span): New function.\n+\t(gfc_diagnostics_init): Initialize global_dc's start_span.\n+\n 2016-02-11  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/69296"}, {"sha": "003702b1f364620be049b988de092d07dd4f47ba", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -1102,6 +1102,20 @@ gfc_diagnostic_starter (diagnostic_context *context,\n     }\n }\n \n+static void\n+gfc_diagnostic_start_span (diagnostic_context *context,\n+\t\t\t   expanded_location exploc)\n+{\n+  char *locus_prefix;\n+  locus_prefix = gfc_diagnostic_build_locus_prefix (context, exploc);\n+  pp_verbatim (context->printer, locus_prefix);\n+  free (locus_prefix);\n+  pp_newline (context->printer);\n+  /* Fortran uses an empty line between locus and caret line.  */\n+  pp_newline (context->printer);\n+}\n+\n+\n static void\n gfc_diagnostic_finalizer (diagnostic_context *context,\n \t\t\t  diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n@@ -1426,6 +1440,7 @@ void\n gfc_diagnostics_init (void)\n {\n   diagnostic_starter (global_dc) = gfc_diagnostic_starter;\n+  global_dc->start_span = gfc_diagnostic_start_span;\n   diagnostic_finalizer (global_dc) = gfc_diagnostic_finalizer;\n   diagnostic_format_decoder (global_dc) = gfc_format_decoder;\n   global_dc->caret_chars[0] = '1';"}, {"sha": "6d01ca3b7a13c08471c433c1d01ef7cc76c84388", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -1,3 +1,15 @@\n+2016-02-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/69554\n+\t* gcc.dg/pr69554-1.c: New test.\n+\t* gfortran.dg/pr69554-1.F90: New test.\n+\t* gfortran.dg/pr69554-2.F90: New test.\n+\t* lib/gcc-dg.exp (proc dg-locus): New function.\n+\t* lib/gfortran-dg.exp (proc gfortran-dg-test): Update comment to\n+\tdistinguish between the caret-printing and non-caret-printing\n+\tcases.  If caret-printing has been explicitly enabled, bail out\n+\twithout attempting to fix up the output.\n+\n 2016-02-12  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR driver/69265"}, {"sha": "07ad0db7cf6d4245cca4e44f71363305dd8d57bd", "filename": "gcc/testsuite/gcc.dg/pr69554-1.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69554-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69554-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69554-1.c?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -0,0 +1,152 @@\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+/* Various versions of the same C error, with a variety of line spacing,\n+   and of columns, to exercise the line-span handling in\n+   diagnostic-show-locus.c (PR other/69554).  */\n+\n+/* All on one line.  */\n+\n+int test_1 (const char *p, const char *q)\n+{\n+  return (p + 1) + (q + 1); /* { dg-error \"invalid operands\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   return (p + 1) + (q + 1);\n+          ~~~~~~~ ^ ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* On separate lines, but without intervening lines.\n+   This can be printed as a single span of lines.  */\n+\n+int test_2 (const char *p, const char *q)\n+{\n+  return (p + 1)\n+           +  /* { dg-error \"invalid operands\" } */\n+            (q + 1);\n+/* { dg-begin-multiline-output \"\" }\n+   return (p + 1)\n+          ~~~~~~~\n+            +\n+            ^\n+             (q + 1);\n+             ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* On separate lines, with an intervening line between lines 1 and 2.\n+   This is printed as 2 \"spans\" of lines, broken up by the intervening\n+   line.  */\n+\n+int test_3 (const char *p, const char *q)\n+{\n+  return (p + 1) /* { dg-locus \"10\" } */\n+\n+           +  /* { dg-error \"invalid operands\" } */\n+             (q + 1);\n+/* { dg-locus \"12\" \"\" { target *-*-* } \"44\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   return (p + 1)\n+          ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+            +\n+            ^\n+              (q + 1);\n+              ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* As above, but the intervening line is between lines 2 and 3,\n+   so that the 2 spans are grouped the other way.  */\n+\n+int test_4 (const char *p, const char *q)\n+{\n+  return (p + 1)\n+           +  /* { dg-error \"invalid operands\" } */\n+\n+             (q + 1); /* { dg-locus \"14\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   return (p + 1)\n+          ~~~~~~~\n+            +\n+            ^\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+              (q + 1);\n+              ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* On separate lines, with intervening lines.\n+   This is printed as 3 \"spans\" of lines, each span being an\n+   individual line.  */\n+\n+int test_5 (const char *p, const char *q)\n+{\n+  return (p + 1) /* { dg-locus \"10\" } */\n+\n+           +  /* { dg-error \"invalid operands\" } */\n+\n+             (q + 1); /* { dg-locus \"14\" } */\n+/* { dg-locus \"12\" \"\" { target *-*-* } \"88\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   return (p + 1)\n+          ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+            +\n+            ^\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+              (q + 1);\n+              ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* On separate lines, with numerous intervening lines.\n+   This is printed as 3 \"spans\" of lines, each span being an\n+   individual line.  */\n+\n+int test_6 (const char *p, const char *q)\n+{\n+  return (p + 1) /* { dg-locus \"10\" } */\n+\t  /* Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n+\t     Maecenas nisl sapien, rutrum non euismod et, rutrum ac felis.\n+\t     Morbi nec nisi ipsum. Quisque pulvinar ante nec urna rhoncus,\n+\t     a cursus nisi commodo. Praesent euismod neque lectus, at\n+\t     dapibus ipsum gravida in. Pellentesque tempor massa eu viverra\n+\t     feugiat. Proin eleifend pulvinar urna, ut dapibus metus vehicula\n+\t     ac. Suspendisse rutrum finibus quam, ac dignissim diam blandit\n+\t     maximus. In blandit viverra pulvinar. Praesent vel tellus\n+\t     elementum, placerat lacus quis, ornare lectus. Donec ac\n+\t     eleifend nulla, sit amet condimentum risus. Vestibulum aliquam\n+\t     maximus ante non pellentesque. Praesent mollis ante in risus\n+\t     feugiat hendrerit. Praesent feugiat maximus urna nec blandit. */\n+           +  /* { dg-error \"invalid operands\" } */\n+\t  /* Vestibulum ac nunc eget enim tempor tristique. Suspendisse\n+\t     potenti. Nam et sollicitudin enim. Morbi sed tincidunt lectus.\n+\t     Sed facilisis velit at ante maximus feugiat. Sed vestibulum mi\n+\t     id leo tempor, sed ullamcorper sapien efficitur. Vestibulum purus\n+\t     lacus, dignissim non magna at, tincidunt luctus nisl. Cum sociis\n+\t     natoque penatibus et magnis dis parturient montes, nascetur\n+\t     ridiculus mus. Donec elit elit, laoreet a dolor quis, eleifend\n+\t     dapibus metus. Proin lectus turpis, eleifend nec pharetra eu,\n+\t     fermentum in lacus. Morbi sit amet mauris orci. Nam sagittis,\n+\t     nibh vel fermentum dictum, purus ex hendrerit odio, feugiat\n+\t     fringilla sapien elit vitae nisl. Fusce mattis commodo risus\n+\t     nec convallis. */\n+             (q + 1); /* { dg-locus \"14\" } */\n+/* { dg-locus \"12\" \"\" { target *-*-* } \"125\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   return (p + 1)\n+          ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+            +\n+            ^\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+              (q + 1);\n+              ~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "38a3c88f3cbe5d80cec084c7a61db75728969c6d", "filename": "gcc/testsuite/gfortran.dg/pr69554-1.F90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69554-1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69554-1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69554-1.F90?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-options \"-fdiagnostics-show-caret\" }\n+! { dg-allow-blank-lines-in-output 1 }\n+\n+program main\n+  goto 1000\n+1000 continue ! first instance\n+  a = a\n+  a = a\n+  a = a\n+1000 continue ! second instance\n+end\n+\n+#if 0\n+! { dg-locus \"4\" \"\" { target *-*-* } \"7\" }\n+! { dg-begin-multiline-output \"\" }\n+\n+ 1000 continue ! first instance\n+    1\n+! { dg-end-multiline-output \"\" }\n+! { dg-locus \"4\" \"\" { target *-*-* } \"11\" }\n+! { dg-begin-multiline-output \"\" }\n+\n+ 1000 continue ! second instance\n+    2\n+Error: Duplicate statement label 1000 at (1) and (2)\n+! { dg-end-multiline-output \"\" }\n+#endif"}, {"sha": "0a25e58b7cc484c074994fb81e46b1f25fca80fb", "filename": "gcc/testsuite/gfortran.dg/pr69554-2.F90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69554-2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69554-2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr69554-2.F90?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-fdiagnostics-show-caret\" }\n+! { dg-allow-blank-lines-in-output 1 }\n+\n+program main\n+  goto 1000\n+1000 continue ! first instance\n+1000 continue ! second instance\n+end\n+\n+#if 0\n+! { dg-locus \"4\" \"\" { target *-*-* } \"7\" }\n+! { dg-begin-multiline-output \"\" }\n+\n+ 1000 continue ! first instance\n+    1\n+ 1000 continue ! second instance\n+    2\n+Error: Duplicate statement label 1000 at (1) and (2)\n+! { dg-end-multiline-output \"\" }\n+#endif"}, {"sha": "b732b54f4108046c80915b579aac31a66122f30a", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -988,6 +988,33 @@ proc dg-message { args } {\n     process-message saved-dg-warning \"\" $args\n }\n \n+# Look for a location marker of the form\n+#   file:line:column:\n+# with no extra text (e.g. a line-span separator).\n+\n+proc dg-locus { args } {\n+    upvar dg-messages dg-messages\n+\n+    # Process the dg- directive, including adding the regular expression\n+    # to the new message entry in dg-messages.\n+    set msgcnt [llength ${dg-messages}]\n+    eval saved-dg-warning $args\n+\n+    # If the target expression wasn't satisfied there is no new message.\n+    if { [llength ${dg-messages}] == $msgcnt } {\n+\treturn;\n+    }\n+\n+    # Get the entry for the new message.  Prepend the message prefix to\n+    # the regular expression and make it match a single line.\n+    set newentry [lindex ${dg-messages} end]\n+    set expmsg [lindex $newentry 2]\n+\n+    set newentry [lreplace $newentry 2 2 $expmsg]\n+    set dg-messages [lreplace ${dg-messages} end end $newentry]\n+    verbose \"process-message:\\n${dg-messages}\" 2\n+}\n+\n # Check the existence of a gdb in the path, and return true if there\n # is one.\n #"}, {"sha": "6b7f98bfbe39b09cc1a9abeb6df1f8217a7f7098", "filename": "gcc/testsuite/lib/gfortran-dg.exp", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876217ae71cf0b34490f8f53bb2a12d99d8baa7a/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp?ref=876217ae71cf0b34490f8f53bb2a12d99d8baa7a", "patch": "@@ -26,7 +26,15 @@ proc gfortran-dg-test { prog do_what extra_tool_flags } {\n     set comp_output [lindex $result 0]\n     set output_file [lindex $result 1]\n \n-    # gfortran error messages look like this:\n+    # gcc's default is to print the caret and source code, but\n+    # most test cases implicitly use the flag -fno-diagnostics-show-caret\n+    # to disable caret (and source code) printing.\n+    #\n+    # However, a few test cases override this back to the default by\n+    # explicily supplying \"-fdiagnostics-show-caret\", so that we can have\n+    # test coverage for caret/source code printing.\n+    #\n+    # gfortran error messages with caret-printing look like this:\n     #     [name]:[locus]:\n     #\n     #        some code\n@@ -49,7 +57,14 @@ proc gfortran-dg-test { prog do_what extra_tool_flags } {\n     #              1       2\n     #     Error: Some error at (1) and (2)\n     #\n-    # or\n+    # If this is such a test case, skip the rest of this function, so\n+    # that the test case can explicitly verify the output that it expects.\n+    if {[string first \"-fdiagnostics-show-caret\" $extra_tool_flags] >= 0} {\n+\treturn [list $comp_output $output_file]\n+    }\n+\n+    # Otherwise, caret-printing is disabled.\n+    # gfortran errors with caret-printing disabled look like this:\n     #     [name]:[locus]: Error: Some error\n     # or\n     #     [name]:[locus]: Error: (1)"}]}