{"sha": "90878b1250d7ef591b61912449df3d14bdec05cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA4NzhiMTI1MGQ3ZWY1OTFiNjE5MTI0NDlkZjNkMTRiZGVjMDVjZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T10:36:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T10:36:15Z"}, "message": "[multiple changes]\n\n2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): under restriction\n\tNo_Dispatching_Calls, do not look for the Assign primitive, because\n\tpredefined primitives are not created in this case.\n\n2011-08-02  Bob Duff  <duff@adacore.com>\n\n\t* stylesw.ads: Minor comment fixes.\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Add_To_Result): New procedure.\n\n2011-08-02  Jose Ruiz  <ruiz@adacore.com>\n\n\t* exp_attr.adb (Find_Stream_Subprogram): When using a configurable run\n\ttime, if the specific run-time routines for handling streams of strings\n\tare not available, use the default mechanism.\n\n2011-08-02  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-regpat.ads: Fix typo.\n\n2011-08-02  Vincent Celier  <celier@adacore.com>\n\n\t* prj-conf.adb (Get_Or_Create_Configuration_File): If On_Load_Config is\n\tnot null, call it to create the in memory config project file without\n\tparsing an existing default config project file.\n\n2011-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* atree.adb (Allocate_Initialize_Node): Remove useless temporaries.\n\n2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_elim.adb: an abstract subprogram does not need an eliminate\n\tpragma for its descendant to be eliminable.\n\n2011-08-02  Ed Falis  <falis@adacore.com>\n\n\t* init.c: revert to handling before previous checkin for VxWorks\n\t* s-intman-vxworks.adb: delete unnecessary declarations related to\n\tusing Ada interrupt facilities for handling signals.\n\tDelete Initialize_Interrupts. Use __gnat_install_handler instead.\n\t* s-intman-vxworks.ads: Import __gnat_install_handler as\n\tInitialize_Interrupts.\n\t* s-taprop-vxworks.adb: Delete Signal_Mask.\n\t(Abort_Handler): change construction of mask to unblock exception\n\tsignals.\n\nFrom-SVN: r177130", "tree": {"sha": "89cb9b543c3451d8512a002e8807ce04bbc885d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89cb9b543c3451d8512a002e8807ce04bbc885d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90878b1250d7ef591b61912449df3d14bdec05cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90878b1250d7ef591b61912449df3d14bdec05cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90878b1250d7ef591b61912449df3d14bdec05cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90878b1250d7ef591b61912449df3d14bdec05cd/comments", "author": null, "committer": null, "parents": [{"sha": "273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d"}], "stats": {"total": 502, "additions": 311, "deletions": 191}, "files": [{"sha": "61cb60a3a509608347ec90d5e852b7cfbbae56d2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -1,3 +1,54 @@\n+2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): under restriction\n+\tNo_Dispatching_Calls, do not look for the Assign primitive, because\n+\tpredefined primitives are not created in this case.\n+\n+2011-08-02  Bob Duff  <duff@adacore.com>\n+\n+\t* stylesw.ads: Minor comment fixes.\n+\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Add_To_Result): New procedure.\n+\n+2011-08-02  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* exp_attr.adb (Find_Stream_Subprogram): When using a configurable run\n+\ttime, if the specific run-time routines for handling streams of strings\n+\tare not available, use the default mechanism.\n+\n+2011-08-02  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-regpat.ads: Fix typo.\n+\n+2011-08-02  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-conf.adb (Get_Or_Create_Configuration_File): If On_Load_Config is\n+\tnot null, call it to create the in memory config project file without\n+\tparsing an existing default config project file.\n+\n+2011-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* atree.adb (Allocate_Initialize_Node): Remove useless temporaries.\n+\n+2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_elim.adb: an abstract subprogram does not need an eliminate\n+\tpragma for its descendant to be eliminable.\n+\n+2011-08-02  Ed Falis  <falis@adacore.com>\n+\n+\t* init.c: revert to handling before previous checkin for VxWorks\n+\t* s-intman-vxworks.adb: delete unnecessary declarations related to\n+\tusing Ada interrupt facilities for handling signals.\n+\tDelete Initialize_Interrupts. Use __gnat_install_handler instead.\n+\t* s-intman-vxworks.ads: Import __gnat_install_handler as\n+\tInitialize_Interrupts.\n+\t* s-taprop-vxworks.adb: Delete Signal_Mask.\n+\t(Abort_Handler): change construction of mask to unblock exception\n+\tsignals.\n+\n 2011-08-02  Jerome Guitton  <guitton@adacore.com>\n \n \t* a-except-2005.adb (Raise_From_Signal_Handler): Call"}, {"sha": "bb678a5b9cbfb785889357fa4e95fe2fb18a320f", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -481,34 +481,25 @@ package body Atree is\n      (Src            : Node_Id;\n       With_Extension : Boolean) return Node_Id\n    is\n-      New_Id : Node_Id     := Src;\n-      Nod    : Node_Record := Default_Node;\n-      Ext1   : Node_Record := Default_Node_Extension;\n-      Ext2   : Node_Record := Default_Node_Extension;\n-      Ext3   : Node_Record := Default_Node_Extension;\n-      Ext4   : Node_Record := Default_Node_Extension;\n+      New_Id : Node_Id;\n \n    begin\n-      if Present (Src) then\n-         Nod := Nodes.Table (Src);\n-\n-         if Has_Extension (Src) then\n-            Ext1 := Nodes.Table (Src + 1);\n-            Ext2 := Nodes.Table (Src + 2);\n-            Ext3 := Nodes.Table (Src + 3);\n-            Ext4 := Nodes.Table (Src + 4);\n-         end if;\n-      end if;\n-\n-      if not (Present (Src)\n-               and then not Has_Extension (Src)\n-               and then With_Extension\n-               and then Src = Nodes.Last)\n+      if Present (Src)\n+        and then not Has_Extension (Src)\n+        and then With_Extension\n+        and then Src = Nodes.Last\n       then\n+         New_Id := Src;\n+      else\n          --  We are allocating a new node, or extending a node\n          --  other than Nodes.Last.\n \n-         Nodes.Append (Nod);\n+         if Present (Src) then\n+            Nodes.Append (Nodes.Table (Src));\n+         else\n+            Nodes.Append (Default_Node);\n+         end if;\n+\n          New_Id := Nodes.Last;\n          Orig_Nodes.Append (New_Id);\n          Node_Count := Node_Count + 1;\n@@ -524,10 +515,15 @@ package body Atree is\n       --  Set extension nodes if required\n \n       if With_Extension then\n-         Nodes.Append (Ext1);\n-         Nodes.Append (Ext2);\n-         Nodes.Append (Ext3);\n-         Nodes.Append (Ext4);\n+         if Present (Src) and then Has_Extension (Src) then\n+            for J in 1 .. 4 loop\n+               Nodes.Append (Nodes.Table (Src + Node_Id (J)));\n+            end loop;\n+         else\n+            for J in 1 .. 4 loop\n+               Nodes.Append (Default_Node_Extension);\n+            end loop;\n+         end if;\n       end if;\n \n       Orig_Nodes.Set_Last (Nodes.Last);"}, {"sha": "008c8138dcb3fbc4e6d4f6dfd127ab9494d0e85c", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 135, "deletions": 24, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -5517,6 +5517,21 @@ package body Exp_Attr is\n       Base_Typ : constant Entity_Id := Base_Type (Typ);\n       Ent      : constant Entity_Id := TSS (Typ, Nam);\n \n+      function Is_Available (Entity : RE_Id) return Boolean;\n+      pragma Inline (Is_Available);\n+      --  Function to check whether the specified run-time call is available\n+      --  in the run time used. In the case of a configurable run time, it\n+      --  is normal that some subprograms are not there.\n+\n+      function Is_Available (Entity : RE_Id) return Boolean is\n+      begin\n+         --  Assume that the unit will always be available when using a\n+         --  \"normal\" (not configurable) run time.\n+\n+         return not Configurable_Run_Time_Mode\n+           or else RTE_Available (Entity);\n+      end Is_Available;\n+\n    begin\n       if Present (Ent) then\n          return Ent;\n@@ -5535,6 +5550,12 @@ package body Exp_Attr is\n       --  This is disabled for AAMP, to avoid creating dependences on files not\n       --  supported in the AAMP library (such as s-fileio.adb).\n \n+      --  In the case of using a configurable run time, it is very likely\n+      --  that stream routines for string types are not present (they require\n+      --  file system support). In this case, the specific stream routines for\n+      --  strings are not used, relying on the regular stream mechanism\n+      --  instead.\n+\n       if VM_Target /= JVM_Target\n         and then not AAMP_On_Target\n         and then\n@@ -5544,95 +5565,185 @@ package body Exp_Attr is\n \n          if Base_Typ = Standard_String then\n             if Restriction_Active (No_Stream_Optimizations) then\n-               if Nam = TSS_Stream_Input then\n+               if Nam = TSS_Stream_Input\n+                 and then Is_Available (RE_String_Input)\n+               then\n                   return RTE (RE_String_Input);\n \n-               elsif Nam = TSS_Stream_Output then\n+               elsif Nam = TSS_Stream_Output\n+                 and then Is_Available (RE_String_Output)\n+               then\n                   return RTE (RE_String_Output);\n \n-               elsif Nam = TSS_Stream_Read then\n+               elsif Nam = TSS_Stream_Read\n+                 and then Is_Available (RE_String_Read)\n+               then\n                   return RTE (RE_String_Read);\n \n-               else pragma Assert (Nam = TSS_Stream_Write);\n+               elsif Nam = TSS_Stream_Write\n+                 and then Is_Available (RE_String_Write)\n+               then\n                   return RTE (RE_String_Write);\n+\n+               elsif Nam /= TSS_Stream_Input and then\n+                     Nam /= TSS_Stream_Output and then\n+                     Nam /= TSS_Stream_Read and then\n+                     Nam /= TSS_Stream_Write\n+               then\n+                  raise Program_Error;\n                end if;\n \n             else\n-               if Nam = TSS_Stream_Input then\n+               if Nam = TSS_Stream_Input\n+                 and then Is_Available (RE_String_Input_Blk_IO)\n+               then\n                   return RTE (RE_String_Input_Blk_IO);\n \n-               elsif Nam = TSS_Stream_Output then\n+               elsif Nam = TSS_Stream_Output\n+                 and then Is_Available (RE_String_Output_Blk_IO)\n+               then\n                   return RTE (RE_String_Output_Blk_IO);\n \n-               elsif Nam = TSS_Stream_Read then\n+               elsif Nam = TSS_Stream_Read\n+                 and then Is_Available (RE_String_Read_Blk_IO)\n+               then\n                   return RTE (RE_String_Read_Blk_IO);\n \n-               else pragma Assert (Nam = TSS_Stream_Write);\n+               elsif Nam = TSS_Stream_Write\n+                 and then Is_Available (RE_String_Write_Blk_IO)\n+               then\n                   return RTE (RE_String_Write_Blk_IO);\n+\n+               elsif Nam /= TSS_Stream_Input and then\n+                     Nam /= TSS_Stream_Output and then\n+                     Nam /= TSS_Stream_Read and then\n+                     Nam /= TSS_Stream_Write\n+               then\n+                  raise Program_Error;\n                end if;\n             end if;\n \n          --  Wide_String as defined in package Ada\n \n          elsif Base_Typ = Standard_Wide_String then\n             if Restriction_Active (No_Stream_Optimizations) then\n-               if Nam = TSS_Stream_Input then\n+               if Nam = TSS_Stream_Input\n+                 and then Is_Available (RE_Wide_String_Input)\n+               then\n                   return RTE (RE_Wide_String_Input);\n \n-               elsif Nam = TSS_Stream_Output then\n+               elsif Nam = TSS_Stream_Output\n+                 and then Is_Available (RE_Wide_String_Output)\n+               then\n                   return RTE (RE_Wide_String_Output);\n \n-               elsif Nam = TSS_Stream_Read then\n+               elsif Nam = TSS_Stream_Read\n+                 and then Is_Available (RE_Wide_String_Read)\n+               then\n                   return RTE (RE_Wide_String_Read);\n \n-               else pragma Assert (Nam = TSS_Stream_Write);\n+               elsif Nam = TSS_Stream_Write\n+                 and then Is_Available (RE_Wide_String_Write)\n+               then\n                   return RTE (RE_Wide_String_Write);\n+\n+               elsif Nam /= TSS_Stream_Input and then\n+                     Nam /= TSS_Stream_Output and then\n+                     Nam /= TSS_Stream_Read and then\n+                     Nam /= TSS_Stream_Write\n+               then\n+                  raise Program_Error;\n                end if;\n \n             else\n-               if Nam = TSS_Stream_Input then\n+               if Nam = TSS_Stream_Input\n+                 and then Is_Available (RE_Wide_String_Input_Blk_IO)\n+               then\n                   return RTE (RE_Wide_String_Input_Blk_IO);\n \n-               elsif Nam = TSS_Stream_Output then\n+               elsif Nam = TSS_Stream_Output\n+                 and then Is_Available (RE_Wide_String_Output_Blk_IO)\n+               then\n                   return RTE (RE_Wide_String_Output_Blk_IO);\n \n-               elsif Nam = TSS_Stream_Read then\n+               elsif Nam = TSS_Stream_Read\n+                 and then Is_Available (RE_Wide_String_Read_Blk_IO)\n+               then\n                   return RTE (RE_Wide_String_Read_Blk_IO);\n \n-               else pragma Assert (Nam = TSS_Stream_Write);\n+               elsif Nam = TSS_Stream_Write\n+                 and then Is_Available (RE_Wide_String_Write_Blk_IO)\n+               then\n                   return RTE (RE_Wide_String_Write_Blk_IO);\n+\n+               elsif Nam /= TSS_Stream_Input and then\n+                     Nam /= TSS_Stream_Output and then\n+                     Nam /= TSS_Stream_Read and then\n+                     Nam /= TSS_Stream_Write\n+               then\n+                  raise Program_Error;\n                end if;\n             end if;\n \n          --  Wide_Wide_String as defined in package Ada\n \n          elsif Base_Typ = Standard_Wide_Wide_String then\n             if Restriction_Active (No_Stream_Optimizations) then\n-               if Nam = TSS_Stream_Input then\n+               if Nam = TSS_Stream_Input\n+                 and then Is_Available (RE_Wide_Wide_String_Input)\n+               then\n                   return RTE (RE_Wide_Wide_String_Input);\n \n-               elsif Nam = TSS_Stream_Output then\n+               elsif Nam = TSS_Stream_Output\n+                 and then Is_Available (RE_Wide_Wide_String_Output)\n+               then\n                   return RTE (RE_Wide_Wide_String_Output);\n \n-               elsif Nam = TSS_Stream_Read then\n+               elsif Nam = TSS_Stream_Read\n+                 and then Is_Available (RE_Wide_Wide_String_Read)\n+               then\n                   return RTE (RE_Wide_Wide_String_Read);\n \n-               else pragma Assert (Nam = TSS_Stream_Write);\n+               elsif Nam = TSS_Stream_Write\n+                 and then Is_Available (RE_Wide_Wide_String_Write)\n+               then\n                   return RTE (RE_Wide_Wide_String_Write);\n+\n+               elsif Nam /= TSS_Stream_Input and then\n+                     Nam /= TSS_Stream_Output and then\n+                     Nam /= TSS_Stream_Read and then\n+                     Nam /= TSS_Stream_Write\n+               then\n+                  raise Program_Error;\n                end if;\n \n             else\n-               if Nam = TSS_Stream_Input then\n+               if Nam = TSS_Stream_Input\n+                 and then Is_Available (RE_Wide_Wide_String_Input_Blk_IO)\n+               then\n                   return RTE (RE_Wide_Wide_String_Input_Blk_IO);\n \n-               elsif Nam = TSS_Stream_Output then\n+               elsif Nam = TSS_Stream_Output\n+                 and then Is_Available (RE_Wide_Wide_String_Output_Blk_IO)\n+               then\n                   return RTE (RE_Wide_Wide_String_Output_Blk_IO);\n \n-               elsif Nam = TSS_Stream_Read then\n+               elsif Nam = TSS_Stream_Read\n+                 and then Is_Available (RE_Wide_Wide_String_Read_Blk_IO)\n+               then\n                   return RTE (RE_Wide_Wide_String_Read_Blk_IO);\n \n-               else pragma Assert (Nam = TSS_Stream_Write);\n+               elsif Nam = TSS_Stream_Write\n+                 and then Is_Available (RE_Wide_Wide_String_Write_Blk_IO)\n+               then\n                   return RTE (RE_Wide_Wide_String_Write_Blk_IO);\n+\n+               elsif Nam /= TSS_Stream_Input and then\n+                     Nam /= TSS_Stream_Output and then\n+                     Nam /= TSS_Stream_Read and then\n+                     Nam /= TSS_Stream_Write\n+               then\n+                  raise Program_Error;\n                end if;\n             end if;\n          end if;"}, {"sha": "bd85af264c95bc2981a09720b332ae1da4743029", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -1943,13 +1943,17 @@ package body Exp_Ch5 is\n                --  correspond to initializations, where we do want to copy the\n                --  tag (No_Ctrl_Actions flag set True) by the expander and we\n                --  do not need to mess with tags ever (Expand_Ctrl_Actions flag\n-               --  is set True in this case).\n+               --  is set True in this case). Finally, it is suppressed if the\n+               --  restriction No_Dispatching_Calls is in force because in that\n+               --  case predefined primitives are not generated.\n \n                or else (Is_Tagged_Type (Typ)\n                          and then not Is_Value_Type (Etype (Lhs))\n                          and then Chars (Current_Scope) /= Name_uAssign\n                          and then Expand_Ctrl_Actions\n-                         and then not Discriminant_Checks_Suppressed (Empty))\n+                         and then not Discriminant_Checks_Suppressed (Empty)\n+                         and then\n+                           not Restriction_Active (No_Dispatching_Calls))\n             then\n                --  Fetch the primitive op _assign and proper type to call it.\n                --  Because of possible conflicts between private and full view,"}, {"sha": "f1a2b829bd0fabd4c0619410202309948f116901", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -1502,14 +1502,19 @@ package body Freeze is\n       Test_E : Entity_Id := E;\n       Comp   : Entity_Id;\n       F_Node : Node_Id;\n-      Result : List_Id;\n       Indx   : Node_Id;\n       Formal : Entity_Id;\n       Atype  : Entity_Id;\n \n+      Result : List_Id := No_List;\n+      --  List of freezing actions, left at No_List if none\n+\n       Has_Default_Initialization : Boolean := False;\n       --  This flag gets set to true for a variable with default initialization\n \n+      procedure Add_To_Result (N : Node_Id);\n+      --  N is a freezing action to be appended to the Result\n+\n       procedure Check_Current_Instance (Comp_Decl : Node_Id);\n       --  Check that an Access or Unchecked_Access attribute with a prefix\n       --  which is the current instance type can only be applied when the type\n@@ -1528,6 +1533,19 @@ package body Freeze is\n       --  Freeze each component, handle some representation clauses, and freeze\n       --  primitive operations if this is a tagged type.\n \n+      -------------------\n+      -- Add_To_Result --\n+      -------------------\n+\n+      procedure Add_To_Result (N : Node_Id) is\n+      begin\n+         if No (Result) then\n+            Result := New_List (N);\n+         else\n+            Append (N, Result);\n+         end if;\n+      end Add_To_Result;\n+\n       ----------------------------\n       -- After_Last_Declaration --\n       ----------------------------\n@@ -1769,12 +1787,7 @@ package body Freeze is\n                then\n                   IR := Make_Itype_Reference (Sloc (Comp));\n                   Set_Itype (IR, Desig);\n-\n-                  if No (Result) then\n-                     Result := New_List (IR);\n-                  else\n-                     Append (IR, Result);\n-                  end if;\n+                  Add_To_Result (IR);\n                end if;\n \n             elsif Ekind (Typ) = E_Anonymous_Access_Subprogram_Type\n@@ -2421,7 +2434,6 @@ package body Freeze is\n \n       --  Here to freeze the entity\n \n-      Result := No_List;\n       Set_Is_Frozen (E);\n \n       --  Case of entity being frozen is other than a type\n@@ -3602,11 +3614,7 @@ package body Freeze is\n \n                begin\n                   Set_Itype (Ref, E);\n-                  if No (Result) then\n-                     Result := New_List (Ref);\n-                  else\n-                     Append (Ref, Result);\n-                  end if;\n+                  Add_To_Result (Ref);\n                end;\n             end if;\n \n@@ -4052,12 +4060,7 @@ package body Freeze is\n          end if;\n \n          Set_Entity (F_Node, E);\n-\n-         if Result = No_List then\n-            Result := New_List (F_Node);\n-         else\n-            Append (F_Node, Result);\n-         end if;\n+         Add_To_Result (F_Node);\n \n          --  A final pass over record types with discriminants. If the type\n          --  has an incomplete declaration, there may be constrained access\n@@ -4135,6 +4138,8 @@ package body Freeze is\n          --  subprogram in main unit, generate descriptor if we are in\n          --  Propagate_Exceptions mode.\n \n+         --  This is very odd code, it makes a null result, why ???\n+\n          elsif Propagate_Exceptions\n            and then Is_Imported (E)\n            and then not Is_Intrinsic_Subprogram (E)"}, {"sha": "822837c0d19cbb2a3c5824a3ed85bdfa09916688", "filename": "gcc/ada/init.c", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -10,19 +10,20 @@\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n  * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n  * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n  *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * You should have received a copy of the GNU General Public License and    *\n- * a copy of the GCC Runtime Library Exception along with this program;     *\n- * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n- * <http://www.gnu.org/licenses/>.                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n  *                                                                          *\n  * GNAT was originally developed  by the GNAT team at  New York University. *\n  * Extensive contributions were provided by Ada Core Technologies Inc.      *\n@@ -378,7 +379,7 @@ __gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n     }\n \n   recurse = 0;\n-  Raise_From_Signal_Handler (exception, (const char *) msg);\n+  Raise_From_Signal_Handler (exception, (char *) msg);\n }\n \n void\n@@ -1975,23 +1976,20 @@ __gnat_map_signal (int sig)\n /* Tasking and Non-tasking signal handler.  Map SIGnal to Ada exception\n    propagation after the required low level adjustments.  */\n \n-sigset_t __gnat_signal_mask;\n-\n-  /* VxWorks will always mask out the signal during the signal handler and\n-     will reenable it on a longjmp.  GNAT does not generate a longjmp to\n-     return from a signal handler so exception signals will still be masked\n-     unless we unmask it. __gnat_signal mask tells sigaction to block the\n-     exception signals and sigprocmask to unblock them. */\n-\n void\n __gnat_error_handler (int sig,\n \t\t      void *si ATTRIBUTE_UNUSED,\n \t\t      struct sigcontext *sc ATTRIBUTE_UNUSED)\n {\n+  sigset_t mask;\n \n-  /* This routine handles the exception signals for all tasks */\n-\n-  sigprocmask (SIG_UNBLOCK, &__gnat_signal_mask, NULL);\n+  /* VxWorks will always mask out the signal during the signal handler and\n+     will reenable it on a longjmp.  GNAT does not generate a longjmp to\n+     return from a signal handler so the signal will still be masked unless\n+     we unmask it.  */\n+  sigprocmask (SIG_SETMASK, NULL, &mask);\n+  sigdelset (&mask, sig);\n+  sigprocmask (SIG_SETMASK, &mask, NULL);\n \n   __gnat_map_signal (sig);\n }\n@@ -2003,24 +2001,14 @@ __gnat_install_handler (void)\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! This routine is called\n-     only once, for the environment task. Other tasks are set up in the\n-     System.Interrupt_Manager package. */\n-\n-  sigemptyset (&__gnat_signal_mask);\n-  sigaddset (SIGBUS, &__gnat_signal_mask);\n-  sigaddset (SIGFPE, &__gnat_signal_mask);\n-  sigaddset (SIGILL, &__gnat_signal_mask);\n-  sigaddset (SIGSEGV, &__gnat_signal_mask);\n+     signal that might cause a scheduling event!  */\n \n   act.sa_handler = __gnat_error_handler;\n   act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n-  act.sa_mask = __gnat_signal_mask;\n-\n-  /* For VxWorks, unconditionally install the exception signal handlers, since\n-     pragma Interrupt_State applies to vectored hardware interrupts, not\n-     signals.  */\n+  sigemptyset (&act.sa_mask);\n \n+  /* For VxWorks, install all signal handlers, since pragma Interrupt_State\n+     applies to vectored hardware interrupts, not signals.  */\n   sigaction (SIGFPE,  &act, NULL);\n   sigaction (SIGILL,  &act, NULL);\n   sigaction (SIGSEGV, &act, NULL);\n@@ -2040,7 +2028,6 @@ __gnat_init_float (void)\n      below have no effect.  */\n #if defined (_ARCH_PPC) && !defined (_SOFT_FLOAT) && !defined (VTHREADS)\n #if defined (__SPE__)\n-  /* VxWorks 6 */\n   {\n      const unsigned long spefscr_mask = 0xfffffff3;\n      unsigned long spefscr;\n@@ -2049,15 +2036,14 @@ __gnat_init_float (void)\n      asm (\"mtspr 512, %0\\n\\tisync\" : : \"r\" (spefscr));\n   }\n #else\n-  /* all except VxWorks 653 and MILS */\n   asm (\"mtfsb0 25\");\n   asm (\"mtfsb0 26\");\n #endif\n #endif\n \n #if (defined (__i386__) || defined (i386)) && !defined (VTHREADS)\n   /* This is used to properly initialize the FPU on an x86 for each\n-     process thread. For all except VxWorks 653 */\n+     process thread.  */\n   asm (\"finit\");\n #endif\n "}, {"sha": "57b9fcafccaa5374e60d4029df4a2818e7ddb20b", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -1107,7 +1107,12 @@ package body Prj.Conf is\n          Write_Line (Config_File_Path.all);\n       end if;\n \n-      if Config_File_Path /= null then\n+      if On_Load_Config /= null then\n+         On_Load_Config\n+           (Config_File       => Config_Project_Node,\n+            Project_Node_Tree => Project_Node_Tree);\n+\n+      elsif Config_File_Path /= null then\n          Prj.Part.Parse\n            (In_Tree                => Project_Node_Tree,\n             Project                => Config_Project_Node,\n@@ -1119,16 +1124,9 @@ package body Prj.Conf is\n             Flags                  => Flags,\n             Target_Name            => Target_Name);\n       else\n-         --  Maybe the user will want to create his own configuration file\n          Config_Project_Node := Empty_Node;\n       end if;\n \n-      if On_Load_Config /= null then\n-         On_Load_Config\n-           (Config_File       => Config_Project_Node,\n-            Project_Node_Tree => Project_Node_Tree);\n-      end if;\n-\n       if Config_Project_Node /= Empty_Node then\n          Prj.Proc.Process_Project_Tree_Phase_1\n            (In_Tree                => Project_Tree,"}, {"sha": "35ab83cee478ea46df77df061043dd44c9e5f604", "filename": "gcc/ada/s-intman-vxworks.adb", "status": "modified", "additions": 4, "deletions": 51, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-intman-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-intman-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vxworks.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -19,10 +19,10 @@\n -- additional permissions described in the GCC Runtime Library Exception,   --\n -- version 3.1, as published by the Free Software Foundation.               --\n --                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University.       --\n -- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n@@ -39,27 +39,6 @@ package body System.Interrupt_Management is\n    use System.OS_Interface;\n    use type Interfaces.C.int;\n \n-   type Signal_List is array (Signal_ID range <>) of Signal_ID;\n-   Exception_Signals : constant Signal_List (1 .. 4) :=\n-                         (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n-\n-   Exception_Action : aliased struct_sigaction;\n-   --  Keep this a variable global so that it is initialized only once\n-\n-   Signal_Mask : aliased sigset_t;\n-   pragma Import (C, Signal_Mask, \"__gnat_signal_mask\");\n-   --  Mask indicating that all exception signals are to be masked\n-   --  when a signal is propagated.\n-\n-   procedure Notify_Exception\n-     (signo      : Signal;\n-      siginfo    : System.Address;\n-      sigcontext : System.Address);\n-   pragma Import (C, Notify_Exception, \"__gnat_error_handler\");\n-   --  Map a signal to Ada exception and raise it.  Different versions\n-   --  of VxWorks need different mappings. This is addressed in init.c in\n-   --  __gnat_map_signal.\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -77,26 +56,6 @@ package body System.Interrupt_Management is\n    --    's'   Interrupt_State pragma set state to System (use \"default\"\n    --           system handler)\n \n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n-\n-   --  Since there is no signal inheritance between VxWorks tasks, we need\n-   --  to initialize signal handling in each task.\n-\n-   procedure Initialize_Interrupts is\n-      Result  : int;\n-      old_act : aliased struct_sigaction;\n-   begin\n-      for J in Exception_Signals'Range loop\n-         Result :=\n-           sigaction\n-             (Signal (Exception_Signals (J)), Exception_Action'Access,\n-              old_act'Unchecked_Access);\n-         pragma Assert (Result = 0);\n-      end loop;\n-   end Initialize_Interrupts;\n-\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -118,12 +77,6 @@ package body System.Interrupt_Management is\n \n       Abort_Task_Interrupt := SIGABRT;\n \n-      --  Signal_Mask was initialized in __gnat_install_handler\n-\n-      Exception_Action.sa_handler := Notify_Exception'Address;\n-      Exception_Action.sa_flags := SA_ONSTACK + SA_SIGINFO;\n-      Exception_Action.sa_mask := Signal_Mask;\n-\n       --  Initialize hardware interrupt handling\n \n       pragma Assert (Reserve = (Interrupt_ID'Range => False));"}, {"sha": "d73324d9bc712f594ca451646adf1d8ab2b29876", "filename": "gcc/ada/s-intman-vxworks.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-intman-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-intman-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vxworks.ads?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -19,10 +19,10 @@\n -- additional permissions described in the GCC Runtime Library Exception,   --\n -- version 3.1, as published by the Free Software Foundation.               --\n --                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University.       --\n -- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n@@ -87,6 +87,7 @@ package System.Interrupt_Management is\n    --  or used to implement time delays.\n \n    procedure Initialize_Interrupts;\n+   pragma Import (C, Initialize_Interrupts, \"__gnat_install_handler\");\n    --  Under VxWorks, there is no signal inheritance between tasks.\n    --  This procedure is used to initialize signal-to-exception mapping in\n    --  each task."}, {"sha": "74e617fcdfb8ac346c011daf3bd5270fdbceebac", "filename": "gcc/ada/s-regpat.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-regpat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-regpat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.ads?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -349,7 +349,7 @@ package System.Regpat is\n    --                                                 12      3\n    --     Matches (0) is for \"a((b*)c+)(d+)\" (the entire expression)\n    --     Matches (1) is for \"(b*)c+\"\n-   --     Matches (2) is for \"c+\"\n+   --     Matches (2) is for \"b*\"\n    --     Matches (3) is for \"d+\"\n    --\n    --  The number of parenthesis groups that can be retrieved is limited only"}, {"sha": "c2b04a55c573f3ea3deb75f8628df76c50ee211c", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -19,10 +19,10 @@\n -- additional permissions described in the GCC Runtime Library Exception,   --\n -- version 3.1, as published by the Free Software Foundation.               --\n --                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University.       --\n -- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n@@ -94,11 +94,6 @@ package body System.Task_Primitives.Operations is\n \n    Mutex_Protocol : Priority_Type;\n \n-   Signal_Mask : aliased sigset_t;\n-   pragma Import (C, Signal_Mask, \"__gnat_signal_mask\");\n-   --  Mask indicating that all exception signals are to be masked\n-   --  when a signal is propagated.\n-\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at a\n    --  time; it is used to execute in mutual exclusion from all other tasks.\n@@ -180,11 +175,14 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (signo : Signal) is\n       pragma Unreferenced (signo);\n \n-      Self_ID : constant Task_Id := Self;\n-      Old_Set : aliased sigset_t;\n-      Result : int;\n+      Self_ID        : constant Task_Id := Self;\n+      Old_Set        : aliased sigset_t;\n+      Unblocked_Mask : aliased sigset_t;\n+      Result         : int;\n       pragma Warnings (Off, Result);\n \n+      use System.Interrupt_Management;\n+\n    begin\n       --  It is not safe to raise an exception when using ZCX and the GCC\n       --  exception handling mechanism.\n@@ -201,10 +199,26 @@ package body System.Task_Primitives.Operations is\n \n          --  Make sure signals used for RTS internal purposes are unmasked\n \n+         Result := sigemptyset (Unblocked_Mask'Access);\n+         pragma Assert (Result = 0);\n+         Result :=\n+           sigaddset\n+           (Unblocked_Mask'Access,\n+            Signal (Abort_Task_Interrupt));\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGBUS);\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGFPE);\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGILL);\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGSEGV);\n+         pragma Assert (Result = 0);\n+\n          Result :=\n            pthread_sigmask\n              (SIG_UNBLOCK,\n-              Signal_Mask'Access,\n+              Unblocked_Mask'Access,\n               Old_Set'Access);\n          pragma Assert (Result = 0);\n "}, {"sha": "aa6bbed1c8805f9e010102b927d33b4c2142018b", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -282,6 +282,7 @@ package body Sem_Elim is\n \n                   if Present (Overridden)\n                     and then not Is_Eliminated (Overridden)\n+                    and then not Is_Abstract_Subprogram (Overridden)\n                   then\n                      Error_Msg_Name_1 := Chars (E);\n                      Error_Msg_N (\"cannot eliminate subprogram %\", E);"}, {"sha": "2227049149291c926181f268226ede4dcb9708ab", "filename": "gcc/ada/stylesw.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90878b1250d7ef591b61912449df3d14bdec05cd/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=90878b1250d7ef591b61912449df3d14bdec05cd", "patch": "@@ -40,10 +40,10 @@ package Stylesw is\n    --  options. The default values shown here correspond to no style checking.\n \n    --  If any of these values is set to a non-default value, then\n-   --  Opt.Style_Check is set True to active calls to this package.\n+   --  Opt.Style_Check is set True to activate calls to this package.\n \n    --  The actual mechanism for setting these switches to other than default\n-   --  values is via the Set_Style_Check_Option procedure or through a call to\n+   --  values is via the Set_Style_Check_Options procedure or through a call to\n    --  Set_Default_Style_Check_Options. They should not be set directly in any\n    --  other manner.\n \n@@ -315,8 +315,8 @@ package Stylesw is\n \n    procedure Set_Style_Check_Options (Options : String);\n    --  Like the above procedure, but used when the Options string is known to\n-   --  be valid. This is for example appropriate for calls where the string ==\n-   --  was obtained by Save_Style_Check_Options.\n+   --  be valid. This is for example appropriate for calls where the string was\n+   --  obtained by Save_Style_Check_Options.\n \n    procedure Reset_Style_Check_Options;\n    --  Sets all style check options to off"}]}