{"sha": "9885da8e1b3b22d00cd59c167ede990d97a4322b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg4NWRhOGUxYjNiMjJkMDBjZDU5YzE2N2VkZTk5MGQ5N2E0MzIyYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-04-22T10:57:04Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-04-22T10:57:04Z"}, "message": "Makefile.in (LIBGCOV): Add _gcov_interval_profiler, _gcov_pow2_profiler and _gcov_one_value_profiler.\n\n\t* Makefile.in (LIBGCOV): Add _gcov_interval_profiler,\n\t_gcov_pow2_profiler and _gcov_one_value_profiler.\n\t(tree-profile.o): Add GGC_H and gt-tree-profile.h dependency.\n\t(GTFILES): Add $(srcdir)/tree-profile.c.\n\t* gcov-io.h (__gcov_interval_profiler, __gcov_pow2_profiler,\n\t__gcov_one_value_profiler): Declare.\n\t* gimplify.c (force_gimple_operand): Check whether the statements\n\tshould be produced in ssa form.\n\t(force_gimple_operand_bsi): New function.\n\t* libgcov.c (__gcov_interval_profiler, __gcov_pow2_profiler,\n\t__gcov_one_value_profiler): New functions.\n\t* rtl-profile.c (rtl_gen_pow2_profiler): Only measure whether\n\tthe profiled value is a power of two or not.\n\t* tree-cfg.c (tree_block_ends_with_condjump_p): Handle empty blocks.\n\t* tree-flow.h (in_ssa_p): Declare.\n\t(force_gimple_operand_bsi): Declare.\n\t* tree-into-ssa.c (in_ssa_p): New variable.\n\t(rewrite_into_ssa): Set in_ssa_p.\n\t* tree-outof-ssa.c (rewrite_out_of_ssa): Set in_ssa_p.\n\t* tree-profile.c: Include ggc.h and gt-tree-profile.h.\n\t(gcov_type_node, tree_interval_profiler_fn, tree_pow2_profiler_fn,\n\ttree_one_value_profiler_fn): New variables.\n\t(tree_init_edge_profiler): Initialize the profiler function decls.\n\t(tree_gen_edge_profiler): Use global gcov_type_node.\n\t(prepare_instrumented_value): New function.\n\t(tree_gen_interval_profiler, tree_gen_interval_profiler,\n\ttree_gen_one_value_profiler): Call the library functions instead of\n\tcreating instrumentation code.\n\t* tree.c (build_fn_decl): New function.\n\t* tree.h (build_fn_decl): Declare.\n\t* value-prof.c (rtl_divmod_values_to_profile,\n\trtl_find_values_to_profile, rtl_mod_pow2_value_transform,\n\ttree_mod_pow2_value_transform, tree_find_values_to_profile):\n\tDo not handle may_be_other and precise values of exponents at pow2\n\tprofiler.\n\t(tree_mod_subtract_transform): Reflect that value field of\n\thistogram has changed meaning.\n\t(tree_divmod_values_to_profile): Record the values correctly.\n\t(tree_values_to_profile): Update comment.\n\t* value-prof.h (struct histogram_value_t): Remove pow2 data.\n\nFrom-SVN: r98555", "tree": {"sha": "3d4bc0e193a087dc3f70c67b813b2d73c8772b43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d4bc0e193a087dc3f70c67b813b2d73c8772b43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9885da8e1b3b22d00cd59c167ede990d97a4322b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9885da8e1b3b22d00cd59c167ede990d97a4322b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9885da8e1b3b22d00cd59c167ede990d97a4322b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9885da8e1b3b22d00cd59c167ede990d97a4322b/comments", "author": null, "committer": null, "parents": [{"sha": "ebccb65d5a5a9dbeffbba9824cd2c4fbfdd684a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebccb65d5a5a9dbeffbba9824cd2c4fbfdd684a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebccb65d5a5a9dbeffbba9824cd2c4fbfdd684a6"}], "stats": {"total": 876, "additions": 320, "deletions": 556}, "files": [{"sha": "ee639575faf355d2507e10ce822a036b7c04cde5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -1,3 +1,46 @@\n+2005-04-22  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* Makefile.in (LIBGCOV): Add _gcov_interval_profiler,\n+\t_gcov_pow2_profiler and _gcov_one_value_profiler.\n+\t(tree-profile.o): Add GGC_H and gt-tree-profile.h dependency.\n+\t(GTFILES): Add $(srcdir)/tree-profile.c.\n+\t* gcov-io.h (__gcov_interval_profiler, __gcov_pow2_profiler,\n+\t__gcov_one_value_profiler): Declare.\n+\t* gimplify.c (force_gimple_operand): Check whether the statements\n+\tshould be produced in ssa form.\n+\t(force_gimple_operand_bsi): New function.\n+\t* libgcov.c (__gcov_interval_profiler, __gcov_pow2_profiler,\n+\t__gcov_one_value_profiler): New functions.\n+\t* rtl-profile.c (rtl_gen_pow2_profiler): Only measure whether\n+\tthe profiled value is a power of two or not.\n+\t* tree-cfg.c (tree_block_ends_with_condjump_p): Handle empty blocks.\n+\t* tree-flow.h (in_ssa_p): Declare.\n+\t(force_gimple_operand_bsi): Declare.\n+\t* tree-into-ssa.c (in_ssa_p): New variable.\n+\t(rewrite_into_ssa): Set in_ssa_p.\n+\t* tree-outof-ssa.c (rewrite_out_of_ssa): Set in_ssa_p.\n+\t* tree-profile.c: Include ggc.h and gt-tree-profile.h.\n+\t(gcov_type_node, tree_interval_profiler_fn, tree_pow2_profiler_fn,\n+\ttree_one_value_profiler_fn): New variables.\n+\t(tree_init_edge_profiler): Initialize the profiler function decls.\n+\t(tree_gen_edge_profiler): Use global gcov_type_node.\n+\t(prepare_instrumented_value): New function.\n+\t(tree_gen_interval_profiler, tree_gen_interval_profiler,\n+\ttree_gen_one_value_profiler): Call the library functions instead of\n+\tcreating instrumentation code.\n+\t* tree.c (build_fn_decl): New function.\n+\t* tree.h (build_fn_decl): Declare.\n+\t* value-prof.c (rtl_divmod_values_to_profile,\n+\trtl_find_values_to_profile, rtl_mod_pow2_value_transform,\n+\ttree_mod_pow2_value_transform, tree_find_values_to_profile):\n+\tDo not handle may_be_other and precise values of exponents at pow2\n+\tprofiler.\n+\t(tree_mod_subtract_transform): Reflect that value field of\n+\thistogram has changed meaning.\n+\t(tree_divmod_values_to_profile): Record the values correctly.\n+\t(tree_values_to_profile): Update comment.\n+\t* value-prof.h (struct histogram_value_t): Remove pow2 data.\n+\n 2005-04-22  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* varasm.c (do_assemble_alias): Return early if TREE_ASM_WRITTEN"}, {"sha": "e7d2b253814770fdc447f809fd1c52fd6792985a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -995,7 +995,8 @@ LIB2FUNCS_ST = _eprintf __gcc_bcmp\n # Defined in libgcov.c, included only in gcov library\n LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \\\n     _gcov_fork _gcov_execl _gcov_execlp _gcov_execle \\\n-    _gcov_execv _gcov_execvp _gcov_execve\n+    _gcov_execv _gcov_execvp _gcov_execve \\\n+    _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler\n \n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n@@ -2034,7 +2035,7 @@ profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) function.h \\\n    toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_H) value-prof.h \\\n-   tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H)\n+   tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H) $(GGC_H) gt-tree-profile.h\n rtl-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) function.h \\\n    toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h $(GGC_H)\n@@ -2466,7 +2467,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h $(srcdir)/reload.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n-  $(srcdir)/dojump.c \\\n+  $(srcdir)/dojump.c $(srcdir)/tree-profile.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/function.c \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n@@ -2500,7 +2501,7 @@ gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parser.h \\\n gt-c-pragma.h gtype-c.h gt-cfglayout.h \\\n gt-tree-mudflap.h gt-tree-complex.h \\\n-gt-tree-eh.h \\\n+gt-tree-eh.h gt-tree-profile.h \\\n gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \\"}, {"sha": "2b49dcff7e9ec607911de5bfa3a3990804c95f8a", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -443,6 +443,11 @@ extern void __gcov_merge_single (gcov_type *, unsigned);\n    consecutive values.  */\n extern void __gcov_merge_delta (gcov_type *, unsigned);\n \n+/* The profiler functions.  */\n+extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned); \n+extern void __gcov_pow2_profiler (gcov_type *, gcov_type);\n+extern void __gcov_one_value_profiler (gcov_type *, gcov_type);\n+\n #ifndef inhibit_libc\n /* The wrappers around some library functions..  */\n extern pid_t __gcov_fork (void);"}, {"sha": "8a510b27dcb5ca580d3f487dde258c969570d42b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -4662,7 +4662,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n   gimple_test_f = simple ? is_gimple_val : is_gimple_reg_rhs;\n \n   push_gimplify_context ();\n-  gimplify_ctxp->into_ssa = true;\n+  gimplify_ctxp->into_ssa = in_ssa_p;\n \n   if (var)\n     expr = build (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n@@ -4671,12 +4671,31 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n \t\t       gimple_test_f, fb_rvalue);\n   gcc_assert (ret != GS_ERROR);\n \n-  for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n-    add_referenced_tmp_var (t);\n+  if (referenced_vars)\n+    {\n+      for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n+\tadd_referenced_tmp_var (t);\n+    }\n \n   pop_gimplify_context (NULL);\n \n   return expr;\n }\n \n+/* Invokes force_gimple_operand for EXPR with parameters SIMPLE_P and VAR.  If\n+   some statements are produced, emits them before BSI.  */\n+\n+tree\n+force_gimple_operand_bsi (block_stmt_iterator *bsi, tree expr,\n+\t\t\t  bool simple_p, tree var)\n+{\n+  tree stmts;\n+\n+  expr = force_gimple_operand (expr, &stmts, simple_p, var);\n+  if (stmts)\n+    bsi_insert_before (bsi, stmts, BSI_SAME_STMT);\n+\n+  return expr;\n+}\n+\n #include \"gt-gimplify.h\""}, {"sha": "713b611e450c1c90b066a9c6e3d26389b6b97571", "filename": "gcc/libgcov.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -581,6 +581,67 @@ __gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n }\n #endif /* L_gcov_merge_delta */\n \n+#ifdef L_gcov_interval_profiler\n+/* If VALUE is in interval <START, START + STEPS - 1>, then increases the\n+   corresponding counter in COUNTERS.  If the VALUE is above or below\n+   the interval, COUNTERS[STEPS] or COUNTERS[STEPS + 1] is increased\n+   instead.  */\n+\n+void\n+__gcov_interval_profiler (gcov_type *counters, gcov_type value,\n+\t\t\t  int start, unsigned steps)\n+{\n+  gcov_type delta = value - start;\n+  if (delta < 0)\n+    counters[steps + 1]++;\n+  else if (delta >= steps)\n+    counters[steps]++;\n+  else\n+    counters[delta]++;\n+}\n+#endif\n+\n+#ifdef L_gcov_pow2_profiler\n+/* If VALUE is a power of two, COUNTERS[1] is incremented.  Otherwise\n+   COUNTERS[0] is incremented.  */\n+\n+void\n+__gcov_pow2_profiler (gcov_type *counters, gcov_type value)\n+{\n+  if (value & (value - 1))\n+    counters[0]++;\n+  else\n+    counters[1]++;\n+}\n+#endif\n+\n+#ifdef L_gcov_one_value_profiler\n+/* Tries to determine the most common value among its inputs.  Checks if the\n+   value stored in COUNTERS[0] matches VALUE.  If this is the case, COUNTERS[1]\n+   is incremented.  If this is not the case and COUNTERS[1] is not zero,\n+   COUNTERS[1] is decremented.  Otherwise COUNTERS[1] is set to one and\n+   VALUE is stored to COUNTERS[0].  This algorithm guarantees that if this\n+   function is called more than 50% of the time with one value, this value\n+   will be in COUNTERS[0] in the end.\n+\n+   In any case, COUNTERS[2] is incremented.  */\n+\n+void\n+__gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n+{\n+  if (value == counters[0])\n+    counters[1]++;\n+  else if (counters[1] == 0)\n+    {\n+      counters[1] = 1;\n+      counters[0] = value;\n+    }\n+  else\n+    counters[1]--;\n+  counters[2]++;\n+}\n+#endif\n+\n #ifdef L_gcov_fork\n /* A wrapper for the fork function.  Flushes the accumulated profiling data, so\n    that they are not counted twice.  */"}, {"sha": "4ba3f2f60a9aed868cfe4658c3d180bd027059c7", "filename": "gcc/rtl-profile.c", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Frtl-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Frtl-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-profile.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -172,10 +172,9 @@ rtl_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n   rtx mem_ref, tmp, mr, uval;\n   rtx sequence;\n   rtx end_of_code_label = gen_label_rtx ();\n-  rtx loop_label = gen_label_rtx ();\n   int per_counter = GCOV_TYPE_SIZE / BITS_PER_UNIT;\n   edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n-\t\t   PREV_INSN (value->hvalue.rtl.insn));\n+\t\t\tPREV_INSN (value->hvalue.rtl.insn));\n \n   start_sequence ();\n \n@@ -191,33 +190,20 @@ rtl_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n   emit_move_insn (uval, copy_rtx (value->hvalue.rtl.value));\n \n   /* Check for non-power of 2.  */\n-  if (value->hdata.pow2.may_be_other)\n-    {\n-      do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, LE, 0, value->hvalue.rtl.mode,\n-\t\t\t       NULL_RTX, NULL_RTX, end_of_code_label);\n-      tmp = expand_simple_binop (value->hvalue.rtl.mode, PLUS, copy_rtx (uval),\n-\t\t\t\t constm1_rtx, NULL_RTX, 0, OPTAB_WIDEN);\n-      tmp = expand_simple_binop (value->hvalue.rtl.mode, AND, copy_rtx (uval), tmp,\n-\t\t\t\t NULL_RTX, 0, OPTAB_WIDEN);\n-      do_compare_rtx_and_jump (tmp, const0_rtx, NE, 0, value->hvalue.rtl.mode, NULL_RTX,\n-\t\t\t       NULL_RTX, end_of_code_label);\n-    }\n-\n-  /* Count log_2(value).  */\n-  emit_label (loop_label);\n-\n-  tmp = expand_simple_binop (Pmode, PLUS, copy_rtx (mr), GEN_INT (per_counter), mr, 0, OPTAB_WIDEN);\n+  do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, LE, 0, value->hvalue.rtl.mode,\n+\t\t\t   NULL_RTX, NULL_RTX, end_of_code_label);\n+  tmp = expand_simple_binop (value->hvalue.rtl.mode, PLUS, copy_rtx (uval),\n+\t\t\t     constm1_rtx, NULL_RTX, 0, OPTAB_WIDEN);\n+  tmp = expand_simple_binop (value->hvalue.rtl.mode, AND, copy_rtx (uval), tmp,\n+\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n+  do_compare_rtx_and_jump (tmp, const0_rtx, NE, 0, value->hvalue.rtl.mode, NULL_RTX,\n+\t\t\t   NULL_RTX, end_of_code_label);\n+\n+  tmp = expand_simple_binop (Pmode, PLUS, copy_rtx (mr), GEN_INT (per_counter),\n+\t\t\t     mr, 0, OPTAB_WIDEN);\n   if (tmp != mr)\n     emit_move_insn (copy_rtx (mr), tmp);\n \n-  tmp = expand_simple_binop (value->hvalue.rtl.mode, ASHIFTRT, copy_rtx (uval), const1_rtx,\n-\t\t\t     uval, 0, OPTAB_WIDEN);\n-  if (tmp != uval)\n-    emit_move_insn (copy_rtx (uval), tmp);\n-\n-  do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, NE, 0, value->hvalue.rtl.mode,\n-\t\t\t   NULL_RTX, NULL_RTX, loop_label);\n-\n   /* Increase the counter.  */\n   emit_label (end_of_code_label);\n "}, {"sha": "d47c6b4d558e71da8af9959ebd7337ecdf88a12d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -5350,8 +5350,8 @@ tree_block_ends_with_call_p (basic_block bb)\n static bool\n tree_block_ends_with_condjump_p (basic_block bb)\n {\n-  tree stmt = tsi_stmt (bsi_last (bb).tsi);\n-  return (TREE_CODE (stmt) == COND_EXPR);\n+  tree stmt = last_stmt (bb);\n+  return (stmt && TREE_CODE (stmt) == COND_EXPR);\n }\n \n "}, {"sha": "74f625f5b34466301a79ba652492aec5082a9606", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -38,6 +38,9 @@ struct basic_block_def;\n typedef struct basic_block_def *basic_block;\n #endif\n \n+/* True if the code is in ssa form.  */\n+extern bool in_ssa_p;\n+\n /*---------------------------------------------------------------------------\n \t\t      Attributes for SSA_NAMEs.\n   \n@@ -796,9 +799,10 @@ extern void linear_transform_loops (struct loops *);\n \n /* In tree-ssa-loop-ivopts.c  */\n extern bool expr_invariant_in_loop_p (struct loop *, tree);\n-/* In gimplify.c  */\n \n+/* In gimplify.c  */\n tree force_gimple_operand (tree, tree *, bool, tree);\n+tree force_gimple_operand_bsi (block_stmt_iterator *, tree, bool, tree);\n \n #include \"tree-flow-inline.h\"\n "}, {"sha": "d90c752e57bb166465a053262df20111d1473d0a", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -54,6 +54,9 @@ Boston, MA 02111-1307, USA.  */\n    Graph. ACM Transactions on Programming Languages and Systems,\n    13(4):451-490, October 1991.  */\n \n+/* True if the code is in ssa form.  */\n+bool in_ssa_p;\n+\n /* Structure to map a variable VAR to the set of blocks that contain\n    definitions for VAR.  */\n struct def_blocks_d\n@@ -1773,6 +1776,7 @@ rewrite_into_ssa (void)\n   sbitmap_free (interesting_blocks);\n \n   timevar_pop (TV_TREE_SSA_OTHER);\n+  in_ssa_p = true;\n }\n \n "}, {"sha": "7d23db21d668053957d9b63e6a2189c6c5dc87f6", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -2511,6 +2511,8 @@ rewrite_out_of_ssa (void)\n \n   /* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */\n   discover_nonconstant_array_refs ();\n+\n+  in_ssa_p = false;\n }\n \n "}, {"sha": "2c91fc3859fa20d5d1c8e829a60f7b7e867cc80e", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 96, "deletions": 448, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -44,14 +44,56 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-pass.h\"\n #include \"timevar.h\"\n #include \"value-prof.h\"\n+#include \"ggc.h\"\n \n+static GTY(()) tree gcov_type_node;\n+static GTY(()) tree tree_interval_profiler_fn;\n+static GTY(()) tree tree_pow2_profiler_fn;\n+static GTY(()) tree tree_one_value_profiler_fn;\n \f\n \n /* Do initialization work for the edge profiler.  */\n \n static void\n tree_init_edge_profiler (void)\n {\n+  tree interval_profiler_fn_type;\n+  tree pow2_profiler_fn_type;\n+  tree one_value_profiler_fn_type;\n+  tree gcov_type_ptr;\n+\n+  if (!gcov_type_node)\n+    {\n+      gcov_type_node = get_gcov_type ();\n+      gcov_type_ptr = build_pointer_type (gcov_type_node);\n+\n+      /* void (*) (gcov_type *, gcov_type, int, unsigned)  */\n+      interval_profiler_fn_type\n+\t      = build_function_type_list (void_type_node,\n+\t\t\t\t\t  gcov_type_ptr, gcov_type_node,\n+\t\t\t\t\t  integer_type_node,\n+\t\t\t\t\t  unsigned_type_node, NULL_TREE);\n+      tree_interval_profiler_fn\n+\t      = build_fn_decl (\"__gcov_interval_profiler\",\n+\t\t\t\t     interval_profiler_fn_type);\n+\n+      /* void (*) (gcov_type *, gcov_type)  */\n+      pow2_profiler_fn_type\n+\t      = build_function_type_list (void_type_node,\n+\t\t\t\t\t  gcov_type_ptr, gcov_type_node,\n+\t\t\t\t\t  NULL_TREE);\n+      tree_pow2_profiler_fn = build_fn_decl (\"__gcov_pow2_profiler\",\n+\t\t\t\t\t\t   pow2_profiler_fn_type);\n+\n+      /* void (*) (gcov_type *, gcov_type)  */\n+      one_value_profiler_fn_type\n+\t      = build_function_type_list (void_type_node,\n+\t\t\t\t\t  gcov_type_ptr, gcov_type_node,\n+\t\t\t\t\t  NULL_TREE);\n+      tree_one_value_profiler_fn\n+\t      = build_fn_decl (\"__gcov_one_value_profiler\",\n+\t\t\t\t     one_value_profiler_fn_type);\n+    }\n }\n \n /* Output instructions as GIMPLE trees to increment the edge \n@@ -61,7 +103,6 @@ tree_init_edge_profiler (void)\n static void\n tree_gen_edge_profiler (int edgeno, edge e)\n {\n-  tree gcov_type_node = get_gcov_type ();\n   tree tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n@@ -75,170 +116,43 @@ tree_gen_edge_profiler (int edgeno, edge e)\n   bsi_insert_on_edge (e, stmt3);\n }\n \n+/* Emits code to get VALUE to instrument at BSI, and returns the\n+   variable containing the value.  */\n+\n+static tree\n+prepare_instrumented_value (block_stmt_iterator *bsi,\n+\t\t\t    histogram_value value)\n+{\n+  tree val = value->hvalue.tree.value;\n+  return force_gimple_operand_bsi (bsi, fold_convert (gcov_type_node, val),\n+\t\t\t\t   true, NULL_TREE);\n+}\n+\n /* Output instructions as GIMPLE trees to increment the interval histogram \n    counter.  VALUE is the expression whose value is profiled.  TAG is the \n    tag of the section for counters, BASE is offset of the counter position.  */\n \n static void\n tree_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  tree op, op1, op2, op1copy, op2copy;\n-  tree tmp1, tmp2, tmp3, val, index;\n-  tree label_decl2, label_decl3, label_decl4, label_decl5, label_decl6;\n-  edge e12, e23, e34, e45, e56;\n-  tree label2, label3, label4, label5, label6;\n-  tree stmt1, stmt2, stmt3, stmt4;\n-  /* Initializations are to prevent bogus uninitialized warnings. */\n-  tree bb1end = NULL_TREE, bb2end = NULL_TREE, bb3end = NULL_TREE;\n-  tree bb4end = NULL_TREE, bb5end = NULL_TREE;\n-  tree ref = tree_coverage_counter_ref (tag, base), ref2;\n-  basic_block bb2, bb3, bb4, bb5, bb6;\n   tree stmt = value->hvalue.tree.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n-  basic_block bb = bb_for_stmt (stmt);\n-  tree gcov_type_node = get_gcov_type ();\n-  tree optype;\n-\n-  op = stmt;\n-  if (TREE_CODE (stmt) == RETURN_EXPR\n-      && TREE_OPERAND (stmt, 0)\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n-    op = TREE_OPERAND (stmt, 0);\n-  /* op == MODIFY_EXPR */\n-  op = TREE_OPERAND (op, 1);\n-  /* op == TRUNC_DIV or TRUNC_MOD */\n-  op1 = TREE_OPERAND (op, 0);\n-  op2 = TREE_OPERAND (op, 1);\n-  optype = TREE_TYPE (op);\n-\n-  /* Blocks:\n-     Original = 1 \n-     For 2nd compare = 2\n-     Normal case, neither more nor less = 3\n-     More = 4\n-     Less = 5\n-     End = 6  */\n-  label_decl2 = create_artificial_label ();\n-  label_decl3 = create_artificial_label ();\n-  label_decl4 = create_artificial_label ();\n-  label_decl5 = create_artificial_label ();\n-  label_decl6 = create_artificial_label ();\n-\n-  /* Do not evaluate op1 or op2 more than once.  Probably\n-     volatile loads are the only things that could cause\n-     a problem, but this is harmless in any case.  */\n-  op1copy = create_tmp_var (optype, \"PROF\");\n-  op2copy = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, optype, op1copy, op1);\n-  stmt2 = build2 (MODIFY_EXPR, optype, op2copy, op2);\n-  TREE_OPERAND (op, 0) = op1copy;\n-  TREE_OPERAND (op, 1) = op2copy;\n-\n-  val = create_tmp_var (optype, \"PROF\");\n-  stmt3 = build2 (MODIFY_EXPR, optype, val,\n-\t\t  build2 (TRUNC_DIV_EXPR, optype, op1copy, op2copy));\n-  stmt4 = build2 (MODIFY_EXPR, optype, val,\n-\t\t  build2 (MINUS_EXPR, optype, val,\n-\t\t\t\tbuild_int_cst (optype, value->hdata.intvl.int_start)));\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n-\n-  index = create_tmp_var (gcov_type_node, \"PROF\");\n-\n-  /* Check for too big.  */\n-  stmt1 = build3 (COND_EXPR, void_type_node,\n-\t    build2 (GE_EXPR, boolean_type_node, val,\n-\t\t\tbuild_int_cst (optype, value->hdata.intvl.steps)),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl4),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl2));\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bb1end = stmt1;\n-\n-  /* Check for too small.  */\n-  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n-  stmt1 = build3 (COND_EXPR, void_type_node,\n-\t    build2 (LT_EXPR, boolean_type_node, val, integer_zero_node),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl5),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl3));\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bb2end = stmt1;\n-\n-  /* Normal case, within range. */\n-  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n-  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, index,\n-\t\t  build1 (NOP_EXPR, gcov_type_node, val));\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bb3end = stmt1;\n-\n-  /* Too big */\n-  label4 = build1 (LABEL_EXPR, void_type_node, label_decl4);\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, index,\n-\t\t  build_int_cst (gcov_type_node, value->hdata.intvl.steps));\n-  bsi_insert_before (&bsi, label4, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bb4end = stmt1;\n-\n-  /* Too small */\n-  label5 = build1 (LABEL_EXPR, void_type_node, label_decl5);\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, index,\n-\t\t  build_int_cst (gcov_type_node,\n-\t\t\t\t value->hdata.intvl.steps + 1));\n-  bsi_insert_before (&bsi, label5, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bb5end = stmt1;\n-\n-  /* Increment appropriate counter. */\n-  label6 = build1 (LABEL_EXPR, void_type_node, label_decl6);\n-  bsi_insert_before (&bsi, label6, BSI_SAME_STMT);\n-\n-  tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp3 = create_tmp_var (gcov_type_node, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1,\n-\t\t  build2 (PLUS_EXPR, gcov_type_node, index,\n-\t\t\t  TREE_OPERAND (ref, 1)));\n-  TREE_OPERAND (ref, 1) = tmp1;\n-  /* Make a copy to avoid sharing complaints. */\n-  ref2 = build4 (ARRAY_REF, TREE_TYPE (ref), TREE_OPERAND (ref, 0), \n-\t\tTREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2), \n-\t\tTREE_OPERAND (ref, 3));\n-\n-  stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2, ref);\n-  stmt3 = build2 (MODIFY_EXPR, gcov_type_node, tmp3,\n-\t\t  build2 (PLUS_EXPR, gcov_type_node, tmp2, integer_one_node));\n-  stmt4 = build2 (MODIFY_EXPR, gcov_type_node, ref2, tmp3);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n-\n-  /* Now fix up the CFG. */\n-  /* 1->2,4; 2->3,5; 3->6; 4->6; 5->6 */\n-  e12 = split_block (bb, bb1end);\n-  bb2 = e12->dest;\n-  e23 = split_block (bb2, bb2end);\n-  bb3 = e23->dest;\n-  e34 = split_block (bb3, bb3end);\n-  bb4 = e34->dest;\n-  e45 = split_block (bb4, bb4end);\n-  bb5 = e45->dest;\n-  e56 = split_block (bb5, bb5end);\n-  bb6 = e56->dest;\n-\n-  e12->flags &= ~EDGE_FALLTHRU;\n-  e12->flags |= EDGE_FALSE_VALUE;\n-  make_edge (bb, bb4, EDGE_TRUE_VALUE);\n-  e23->flags &= ~EDGE_FALLTHRU;\n-  e23->flags |= EDGE_FALSE_VALUE;\n-  make_edge (bb2, bb5, EDGE_TRUE_VALUE);\n-  remove_edge (e34);\n-  make_edge (bb3, bb6, EDGE_FALLTHRU);\n-  remove_edge (e45);\n-  make_edge (bb4, bb6, EDGE_FALLTHRU);\n+  tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n+  tree args, call, val;\n+  tree start = build_int_cst_type (integer_type_node, value->hdata.intvl.int_start);\n+  tree steps = build_int_cst_type (unsigned_type_node, value->hdata.intvl.steps);\n+  \n+  ref_ptr = force_gimple_operand_bsi (&bsi,\n+\t\t\t\t      build_addr (ref),\n+\t\t\t\t      true, NULL_TREE);\n+  val = prepare_instrumented_value (&bsi, value);\n+  args = tree_cons (NULL_TREE, ref_ptr,\n+\t\t    tree_cons (NULL_TREE, val,\n+\t\t\t       tree_cons (NULL_TREE, start,\n+\t\t\t\t\t  tree_cons (NULL_TREE, steps,\n+\t\t\t\t\t\t     NULL_TREE))));\n+  call = build_function_call_expr (tree_interval_profiler_fn, args);\n+  bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n /* Output instructions as GIMPLE trees to increment the power of two histogram \n@@ -248,162 +162,20 @@ tree_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n static void\n tree_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  tree op;\n-  tree tmp1, tmp2, tmp3;\n-  tree index, denom;\n-  tree label_decl1 = create_artificial_label ();\n-  tree label_decl2 = create_artificial_label ();\n-  tree label_decl3 = create_artificial_label ();\n-  tree label1, label2, label3;\n-  tree stmt1, stmt2, stmt3, stmt4;\n-  tree bb1end, bb2end, bb3end;\n-  tree ref = tree_coverage_counter_ref (tag, base), ref2;\n-  basic_block bb2, bb3, bb4;\n   tree stmt = value->hvalue.tree.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n-  basic_block bb = bb_for_stmt (stmt);\n-  tree gcov_type_node = get_gcov_type ();\n-  tree optype, optypesigned, optypeunsigned;\n-\n-  op = stmt;\n-  if (TREE_CODE (stmt) == RETURN_EXPR\n-      && TREE_OPERAND (stmt, 0)\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n-    op = TREE_OPERAND (stmt, 0);\n-  /* op == MODIFY_EXPR */\n-  op = TREE_OPERAND (op, 1);\n-  /* op == TRUNC_DIV or TRUNC_MOD */\n-  op = TREE_OPERAND (op, 1);\n-  /* op == denominator */\n-  optype = TREE_TYPE (op);\n-  if (TYPE_UNSIGNED (optype))\n-    {\n-      /* Right shift must be unsigned. */\n-      optypeunsigned = optype;\n-      optypesigned = build_distinct_type_copy (optype);\n-      TYPE_UNSIGNED (optypesigned) = false;\n-    }\n-  else\n-    {\n-      /* Compare to zero must be signed. */\n-      optypesigned = optype;\n-      optypeunsigned = build_distinct_type_copy (optype);\n-      TYPE_UNSIGNED (optypeunsigned) = true;\n-    }\n-\n-  /* Set up variables and check if denominator is negative when considered\n-     as signed.  */\n-  index = create_tmp_var (gcov_type_node, \"PROF\");\n-  denom = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, index, integer_zero_node);\n-  stmt2 = build2 (MODIFY_EXPR, optype, denom, op);\n-  if (optypesigned == optype)\n-    {\n-      tmp1 = denom;\n-      stmt3 = NULL_TREE;\n-    }\n-  else\n-    {\n-      tmp1 = create_tmp_var (optypesigned, \"PROF\");\n-      stmt3 = build2 (MODIFY_EXPR, optypesigned, tmp1,\n-\t\t\t    build1 (NOP_EXPR, optypesigned, denom));\n-    }\n-  stmt4 = build3 (COND_EXPR, void_type_node,\n-\t\tbuild2 (LE_EXPR, boolean_type_node, tmp1, integer_zero_node),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl1));\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  if (stmt3)\n-    bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n-  bb1end = stmt4;\n-\n-  /* Nonnegative.  Check if denominator is power of 2. */\n-  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-  tmp1 = create_tmp_var (optype, \"PROF\");\n-  tmp2 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, optype, tmp1,\n-\t\t    build2 (PLUS_EXPR, optype, denom, integer_minus_one_node));\n-  stmt2 = build2 (MODIFY_EXPR, optype, tmp2,\n-\t\t    build2 (BIT_AND_EXPR, optype, tmp1, denom));\n-  stmt3 = build3 (COND_EXPR, void_type_node, \n-\t\tbuild2 (NE_EXPR, boolean_type_node, tmp2, integer_zero_node),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2));\n-  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bb2end = stmt3;\n-\n-  /* Loop.  Increment index, shift denominator, repeat if denominator nonzero. */\n-  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, index,\n-\t\t  build2 (PLUS_EXPR, gcov_type_node, index, integer_one_node));\n-  if (optypeunsigned == optype)\n-    {\n-      tmp1 = denom;\n-      stmt2 = NULL_TREE;\n-    }\n-  else\n-    {\n-      tmp1 = create_tmp_var (optypeunsigned, \"PROF\");\n-      stmt2 = build2 (MODIFY_EXPR, optypeunsigned, tmp1,\n-\t\t\tbuild1 (NOP_EXPR, optypeunsigned, denom));\n-    }\n-  stmt3 = build2 (MODIFY_EXPR, optype, denom,\n-\t\t    build2 (RSHIFT_EXPR, optype, tmp1, integer_one_node));\n-  stmt4 = build3 (COND_EXPR, void_type_node, \n-\t\tbuild2 (NE_EXPR, boolean_type_node, denom, integer_zero_node),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3));\n-  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  if (stmt2)\n-    bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n-  bb3end = stmt4;\n-\n-  /* Increment the appropriate counter.  */\n-  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n-  tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp3 = create_tmp_var (gcov_type_node, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1,\n-\t\t  build2 (PLUS_EXPR, gcov_type_node,\n-\t\t\t  index, TREE_OPERAND (ref, 1)));\n-  TREE_OPERAND (ref, 1) = tmp1;\n-  /* Make a copy to avoid sharing complaints. */\n-  ref2 = build4 (ARRAY_REF, TREE_TYPE (ref), TREE_OPERAND (ref, 0), \n-\t\tTREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n-  stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2, ref);\n-  stmt3 = build2 (MODIFY_EXPR, gcov_type_node, tmp3,\n-\t\t  build2 (PLUS_EXPR, gcov_type_node, tmp2, integer_one_node));\n-  stmt4 = build2 (MODIFY_EXPR, gcov_type_node, ref2, tmp3);\n-  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n-\n-  /* Now fix up the CFG. */\n-  bb2 = (split_block (bb, bb1end))->dest;\n-  bb3 = (split_block (bb2, bb2end))->dest;\n-  bb4 = (split_block (bb3, bb3end))->dest;\n-\n-  EDGE_SUCC (bb, 0)->flags &= ~EDGE_FALLTHRU;\n-  EDGE_SUCC (bb, 0)->flags |= EDGE_FALSE_VALUE;\n-  make_edge (bb, bb4, EDGE_TRUE_VALUE);\n-\n-  EDGE_SUCC (bb2, 0)->flags &= ~EDGE_FALLTHRU;\n-  EDGE_SUCC (bb2, 0)->flags |= EDGE_FALSE_VALUE;\n-  make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n-\n-  EDGE_SUCC (bb3, 0)->flags &= ~EDGE_FALLTHRU;\n-  EDGE_SUCC (bb3, 0)->flags |= EDGE_FALSE_VALUE;\n-  make_edge (bb3, bb3, EDGE_TRUE_VALUE);\n+  tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n+  tree args, call, val;\n+  \n+  ref_ptr = force_gimple_operand_bsi (&bsi,\n+\t\t\t\t      build_addr (ref),\n+\t\t\t\t      true, NULL_TREE);\n+  val = prepare_instrumented_value (&bsi, value);\n+  args = tree_cons (NULL_TREE, ref_ptr,\n+\t\t    tree_cons (NULL_TREE, val,\n+\t\t\t       NULL_TREE));\n+  call = build_function_call_expr (tree_pow2_profiler_fn, args);\n+  bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value.\n@@ -413,146 +185,20 @@ tree_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n static void\n tree_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  tree op;\n-  tree tmp1, tmp2, tmp3;\n-  tree label_decl1 = create_artificial_label ();\n-  tree label_decl2 = create_artificial_label ();\n-  tree label_decl3 = create_artificial_label ();\n-  tree label_decl4 = create_artificial_label ();\n-  tree label_decl5 = create_artificial_label ();\n-  tree label1, label2, label3, label4, label5;\n-  tree stmt1, stmt2, stmt3, stmt4;\n-  tree bb1end, bb2end, bb3end, bb4end, bb5end;\n-  tree ref1 = tree_coverage_counter_ref (tag, base);\n-  tree ref2 = tree_coverage_counter_ref (tag, base + 1);\n-  tree ref3 = tree_coverage_counter_ref (tag, base + 2);\n-  basic_block bb2, bb3, bb4, bb5, bb6;\n   tree stmt = value->hvalue.tree.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n-  basic_block bb = bb_for_stmt (stmt);\n-  tree gcov_type_node = get_gcov_type ();\n-  tree optype;\n-\n-  op = stmt;\n-  if (TREE_CODE (stmt) == RETURN_EXPR\n-      && TREE_OPERAND (stmt, 0)\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n-    op = TREE_OPERAND (stmt, 0);\n-  /* op == MODIFY_EXPR */\n-  op = TREE_OPERAND (op, 1);\n-  /* op == TRUNC_DIV or TRUNC_MOD */\n-  op = TREE_OPERAND (op, 1);\n-  /* op == denominator */\n-  optype = TREE_TYPE (op);\n-\n-  /* Check if the stored value matches. */\n-  tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp2 = create_tmp_var (optype, \"PROF\");\n-  tmp3 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1, ref1);\n-  stmt2 = build2 (MODIFY_EXPR, optype, tmp2, \n-\t\t    build1 (NOP_EXPR, optype, tmp1));\n-  stmt3 = build2 (MODIFY_EXPR, optype, tmp3, op);\n-  stmt4 = build3 (COND_EXPR, void_type_node, \n-\t\tbuild2 (EQ_EXPR, boolean_type_node, tmp2, tmp3),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl4),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl1));\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n-  bb1end = stmt4;\n-\n-  /* Does not match; check whether the counter is zero. */\n-  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-  tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1, ref2);\n-  stmt2 = build3 (COND_EXPR, void_type_node, \n-\t\tbuild2 (EQ_EXPR, boolean_type_node, tmp1, integer_zero_node),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3), \n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2));\n-  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bb2end = stmt2;\n-\n-  /* Counter is not zero yet, decrement. */\n-  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1, ref2);\n-  stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2,\n-\t\t  build (MINUS_EXPR, gcov_type_node, tmp1, integer_one_node));\n-  stmt3 = build2 (MODIFY_EXPR, gcov_type_node, ref2, tmp2);\n-  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bb3end = stmt3;\n-\n-  /* Counter was zero, store new value. */\n-  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n-  tmp1 = create_tmp_var (optype, \"PROF\");\n-  tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, optype, tmp1, op);\n-  stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2,\n-\t\t  build1 (NOP_EXPR, gcov_type_node, tmp1));\n-  stmt3 = build2 (MODIFY_EXPR, gcov_type_node, ref1, tmp2);\n-  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bb4end = stmt3;\n-  /* (fall through) */\n-\n-  /* Increment counter.  */\n-  label4 = build1 (LABEL_EXPR, void_type_node, label_decl4);\n-  tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1, ref2);\n-  stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2,\n-\t\t  build (PLUS_EXPR, gcov_type_node, tmp1, integer_one_node));\n-  stmt3 = build2 (MODIFY_EXPR, gcov_type_node, ref2, tmp2);\n-  bsi_insert_before (&bsi, label4, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-  bb5end = stmt3;\n-\n-  /* Increment the counter of all executions; this seems redundant given\n-     that we have counts for edges in cfg, but it may happen that some\n-     optimization will change the counts for the block (either because\n-     it is unable to update them correctly, or because it will duplicate\n-     the block or its part).  */\n-  label5 = build1 (LABEL_EXPR, void_type_node, label_decl5);\n-  tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n-  tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1, ref3);\n-  stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2,\n-\t\t  build (PLUS_EXPR, gcov_type_node, tmp1, integer_one_node));\n-  stmt3 = build2 (MODIFY_EXPR, gcov_type_node, ref3, tmp2);\n-  bsi_insert_before (&bsi, label5, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n-  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n-\n-  /* Now fix up the CFG. */\n-  bb2 = (split_block (bb, bb1end))->dest;\n-  bb3 = (split_block (bb2, bb2end))->dest;\n-  bb4 = (split_block (bb3, bb3end))->dest;\n-  bb5 = (split_block (bb4, bb4end))->dest;\n-  bb6 = (split_block (bb5, bb5end))->dest;\n-\n-  EDGE_SUCC (bb, 0)->flags &= ~EDGE_FALLTHRU;\n-  EDGE_SUCC (bb, 0)->flags |= EDGE_FALSE_VALUE;\n-  make_edge (bb, bb5, EDGE_TRUE_VALUE);\n-\n-  EDGE_SUCC (bb2, 0)->flags &= ~EDGE_FALLTHRU;\n-  EDGE_SUCC (bb2, 0)->flags |= EDGE_FALSE_VALUE;\n-  make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n-\n-  remove_edge (EDGE_SUCC (bb3, 0));\n-  make_edge (bb3, bb6, EDGE_FALLTHRU);\n+  tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n+  tree args, call, val;\n+  \n+  ref_ptr = force_gimple_operand_bsi (&bsi,\n+\t\t\t\t      build_addr (ref),\n+\t\t\t\t      true, NULL_TREE);\n+  val = prepare_instrumented_value (&bsi, value);\n+  args = tree_cons (NULL_TREE, ref_ptr,\n+\t\t    tree_cons (NULL_TREE, val,\n+\t\t\t       NULL_TREE));\n+  call = build_function_call_expr (tree_one_value_profiler_fn, args);\n+  bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value \n@@ -637,3 +283,5 @@ struct profile_hooks tree_profile_hooks =\n   tree_gen_const_delta_profiler,/* gen_const_delta_profiler */\n   tree_profile_dump_file\t/* profile_dump_file */\n };\n+\n+#include \"gt-tree-profile.h\""}, {"sha": "a718bde4e654b4ca0db37d8a1ad7ba55cde172c2", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -2807,6 +2807,23 @@ build_decl_stat (enum tree_code code, tree name, tree type MEM_STAT_DECL)\n \n   return t;\n }\n+\n+/* Builds and returns function declaration with NAME and TYPE.  */\n+\n+tree\n+build_fn_decl (const char *name, tree type)\n+{\n+  tree id = get_identifier (name);\n+  tree decl = build_decl (FUNCTION_DECL, id, type);\n+\n+  DECL_EXTERNAL (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  TREE_NOTHROW (decl) = 1;\n+\n+  return decl;\n+}\n+\n \f\n /* BLOCK nodes are used to represent the structure of binding contours\n    and declarations, once those contours have been exited and their contents"}, {"sha": "cc2fba1aff132160fd6d9518c6540d40a55299ef", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -2905,6 +2905,7 @@ extern tree build_string (int, const char *);\n extern tree build_tree_list_stat (tree, tree MEM_STAT_DECL);\n #define build_tree_list(t,q) build_tree_list_stat(t,q MEM_STAT_INFO)\n extern tree build_decl_stat (enum tree_code, tree, tree MEM_STAT_DECL);\n+extern tree build_fn_decl (const char *, tree); \n #define build_decl(c,t,q) build_decl_stat (c,t,q MEM_STAT_INFO)\n extern tree build_block (tree, tree, tree, tree, tree);\n #ifndef USE_MAPPED_LOCATION"}, {"sha": "4f6d0c3cf9a9e4c226815e55a73443929519511a", "filename": "gcc/value-prof.c", "status": "modified", "additions": 45, "deletions": 68, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -128,8 +128,6 @@ static bool rtl_mod_subtract_transform (rtx);\n #ifdef HAVE_prefetch\n static bool speculative_prefetching_transform (rtx);\n #endif\n-static void tree_divmod_values_to_profile (tree, histogram_values *);\n-static void tree_values_to_profile (tree, histogram_values *);\n static tree tree_divmod_fixed_value (tree, tree, tree, tree, \n \t\t\t\t    tree, int, gcov_type, gcov_type);\n static tree tree_mod_pow2 (tree, tree, tree, tree, int, gcov_type, gcov_type);\n@@ -181,7 +179,6 @@ rtl_divmod_values_to_profile (rtx insn, histogram_values *values)\n \t  hist->hvalue.rtl.mode = mode;\n \t  hist->hvalue.rtl.insn = insn;\n \t  hist->type = HIST_TYPE_POW2;\n-\t  hist->hdata.pow2.may_be_other = 1;\n \t  VEC_safe_push (histogram_value, heap, *values, hist);\n \t}\n \n@@ -360,9 +357,7 @@ rtl_find_values_to_profile (histogram_values *values)\n \t    fprintf (dump_file,\n \t\t     \"Pow2 counter for insn %d.\\n\",\n \t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn));\n-\t  hist->n_counters \n-\t\t= GET_MODE_BITSIZE (hist->hvalue.rtl.mode)\n-\t\t  +  (hist->hdata.pow2.may_be_other ? 1 : 0);\n+\t  hist->n_counters = 2;\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n@@ -722,7 +717,7 @@ rtl_mod_pow2_value_transform (rtx insn)\n   enum machine_mode mode;\n   gcov_type wrong_values, count;\n   edge e;\n-  int i, all, prob;\n+  int all, prob;\n \n   set = single_set (insn);\n   if (!set)\n@@ -751,15 +746,9 @@ rtl_mod_pow2_value_transform (rtx insn)\n   histogram = XEXP (XEXP (histogram, 0), 1);\n   value = XEXP (histogram, 0);\n   histogram = XEXP (histogram, 1);\n-  wrong_values =INTVAL (XEXP (histogram, 0));\n+  wrong_values = INTVAL (XEXP (histogram, 0));\n   histogram = XEXP (histogram, 1);\n-\n-  count = 0;\n-  for (i = 0; i < GET_MODE_BITSIZE (mode); i++)\n-    {\n-      count += INTVAL (XEXP (histogram, 0));\n-      histogram = XEXP (histogram, 1);\n-    }\n+  count = INTVAL (XEXP (histogram, 0));\n \n   if (!rtx_equal_p (op2, value))\n     return false;\n@@ -1355,7 +1344,6 @@ tree_mod_pow2_value_transform (tree stmt)\n   gcov_type count, wrong_values, all;\n   tree modify, op, op1, op2, result, value;\n   int prob;\n-  unsigned int i;\n \n   modify = stmt;\n   if (TREE_CODE (stmt) == RETURN_EXPR\n@@ -1386,9 +1374,7 @@ tree_mod_pow2_value_transform (tree stmt)\n \n   value = histogram->hvalue.tree.value;\n   wrong_values = histogram->hvalue.tree.counters[0];\n-  count = 0;\n-  for (i = 1; i <= TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (stmt))); i++)\n-    count += histogram->hvalue.tree.counters[i];\n+  count = histogram->hvalue.tree.counters[1];\n \n   /* We require that we hit a power of 2 at least half of all evaluations.  */\n   if (simple_cst_equal (op2, value) != 1 || count < wrong_values)\n@@ -1576,10 +1562,6 @@ tree_mod_subtract_transform (tree stmt)\n   wrong_values += histogram->hvalue.tree.counters[i+1];\n   all += wrong_values;\n \n-  /* Sanity check. */\n-  if (simple_cst_equal (op2, value) != 1)\n-    return false;\n-\n   /* We require that we use just subtractions in at least 50% of all\n      evaluations.  */\n   count = 0;\n@@ -1638,66 +1620,67 @@ rtl_register_value_prof_hooks (void)\n   gcc_assert (!ir_type ());\n }\n \f\n-/* Find values inside INSN for that we want to measure histograms for\n+/* Find values inside STMT for that we want to measure histograms for\n    division/modulo optimization.  */\n static void\n tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n {\n-  tree op, op1, op2;\n+  tree assign, lhs, rhs, divisor, op0, type;\n   histogram_value hist;\n \n-  op = stmt;\n-  if (TREE_CODE (stmt) == RETURN_EXPR \n-      && TREE_OPERAND (stmt, 0)\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n-    op = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (stmt) == RETURN_EXPR)\n+    assign = TREE_OPERAND (stmt, 0);\n+  else\n+    assign = stmt;\n \n-  if (TREE_CODE (op) != MODIFY_EXPR)\n+  if (!assign\n+      || TREE_CODE (assign) != MODIFY_EXPR)\n     return;\n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+  lhs = TREE_OPERAND (assign, 0);\n+  type = TREE_TYPE (lhs);\n+  if (!INTEGRAL_TYPE_P (type))\n     return;\n-  op = TREE_OPERAND (op, 1);\n-  switch (TREE_CODE (op))\n+\n+  rhs = TREE_OPERAND (assign, 1);\n+  switch (TREE_CODE (rhs))\n     {\n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n-      op1 = TREE_OPERAND (op, 0);\n-      op2 = TREE_OPERAND (op, 1);\n+      divisor = TREE_OPERAND (rhs, 1);\n+      op0 = TREE_OPERAND (rhs, 0);\n \n       VEC_reserve (histogram_value, heap, *values, 3);\n-      \n-      /* Check for a special case where the divisor is power(s) of 2.\n-         This is more aggressive than the RTL version, under the\n-\t assumption that later phases will reduce / or % by power of 2\n-\t to something clever most of the time.  Signed or unsigned.  */\n-      if (TREE_CODE (op2) != INTEGER_CST)\n+\n+      if (is_gimple_reg (divisor))\n \t{\n+\t  /* Check for a special case where the divisor is power(s) of 2.\n+\t     This is more aggressive than the RTL version, under the\n+\t     assumption that later phases will reduce / or % by power of 2\n+\t     to something clever most of the time.  Signed or unsigned.  */\n \t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.tree.value = op2;\n+\t  hist->hvalue.tree.value = divisor;\n \t  hist->hvalue.tree.stmt = stmt;\n \t  hist->type = HIST_TYPE_POW2;\n-\t  hist->hdata.pow2.may_be_other = 1;\n \t  VEC_quick_push (histogram_value, *values, hist);\n-\t}\n \n-      /* Check for the case where the divisor is the same value most\n-\t of the time.  */\n-      if (TREE_CODE (op2) != INTEGER_CST)\n-\t{\n+\t  /* Check for the case where the divisor is the same value most\n+\t     of the time.  */\n \t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.tree.value = op2;\n+\t  hist->hvalue.tree.value = divisor;\n \t  hist->hvalue.tree.stmt = stmt;\n \t  hist->type = HIST_TYPE_SINGLE_VALUE;\n \t  VEC_quick_push (histogram_value, *values, hist);\n \t}\n \n       /* For mod, check whether it is not often a noop (or replaceable by\n \t a few subtractions).  */\n-      if (TREE_CODE (op) == TRUNC_MOD_EXPR && TYPE_UNSIGNED (TREE_TYPE (op)))\n+      if (TREE_CODE (rhs) == TRUNC_MOD_EXPR\n+\t  && TYPE_UNSIGNED (type))\n \t{\n \t  hist = ggc_alloc (sizeof (*hist));\n \t  hist->hvalue.tree.stmt = stmt;\n-\t  hist->hvalue.tree.value = op2;\n+\t  hist->hvalue.tree.value\n+\t\t  = build2 (TRUNC_DIV_EXPR, type, op0, divisor);\n \t  hist->type = HIST_TYPE_INTERVAL;\n \t  hist->hdata.intvl.int_start = 0;\n \t  hist->hdata.intvl.steps = 2;\n@@ -1710,8 +1693,9 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n     }\n }\n \n-/* Find values inside INSN for that we want to measure histograms and adds\n-   them to list VALUES (increasing the record of its length in N_VALUES).  */\n+/* Find values inside STMT for that we want to measure histograms and adds\n+   them to list VALUES.  */\n+\n static void\n tree_values_to_profile (tree stmt, histogram_values *values)\n {\n@@ -1724,17 +1708,13 @@ tree_find_values_to_profile (histogram_values *values)\n {\n   basic_block bb;\n   block_stmt_iterator bsi;\n-  tree stmt;\n-  unsigned int i;\n+  unsigned i;\n   histogram_value hist;\n-  \n+\n   *values = NULL;\n   FOR_EACH_BB (bb)\n     for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-      {\n-        tree stmt = bsi_stmt (bsi);\n-        tree_values_to_profile (stmt, values);\n-      }\n+      tree_values_to_profile (bsi_stmt (bsi), values);\n   static_values = *values;\n   \n   for (i = 0; VEC_iterate (histogram_value, *values, i, hist); i++)\n@@ -1758,20 +1738,17 @@ tree_find_values_to_profile (histogram_values *values)\n \tcase HIST_TYPE_POW2:\n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \"Pow2 counter for insn \");\n+\t      fprintf (dump_file, \"Pow2 counter for tree \");\n \t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n \t      fprintf (dump_file, \".\\n\");\n \t    }\n-\t  stmt = hist->hvalue.tree.stmt;\n-\t  hist->n_counters \n-\t\t= TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (stmt)))\n-\t\t  +  (hist->hdata.pow2.may_be_other ? 1 : 0);\n+\t  hist->n_counters = 2;\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \"Single value counter for insn \");\n+\t      fprintf (dump_file, \"Single value counter for tree \");\n \t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n \t      fprintf (dump_file, \".\\n\");\n \t    }\n@@ -1781,7 +1758,7 @@ tree_find_values_to_profile (histogram_values *values)\n \tcase HIST_TYPE_CONST_DELTA:\n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \"Constant delta counter for insn \");\n+\t      fprintf (dump_file, \"Constant delta counter for tree \");\n \t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n \t      fprintf (dump_file, \".\\n\");\n \t    }"}, {"sha": "692746a601de0e849ad0ccca2cb0d1352baac84f", "filename": "gcc/value-prof.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9885da8e1b3b22d00cd59c167ede990d97a4322b/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=9885da8e1b3b22d00cd59c167ede990d97a4322b", "patch": "@@ -66,10 +66,6 @@ struct histogram_value_t\n \t  int int_start;\t/* First value in interval.  */\n \t  unsigned int steps;\t/* Number of values in it.  */\n \t} intvl;\t/* Interval histogram data.  */\n-      struct\n-\t{\n-\t  int may_be_other;\t/* If the value may be non-positive or not 2^k.  */\n-\t} pow2;\t\t/* Power of 2 histogram data.  */\n     } hdata;\t\t/* Profiled information specific data.  */\n };\n "}]}