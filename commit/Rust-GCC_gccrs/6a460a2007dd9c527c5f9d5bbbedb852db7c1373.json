{"sha": "6a460a2007dd9c527c5f9d5bbbedb852db7c1373", "node_id": "C_kwDOANBUbNoAKDZhNDYwYTIwMDdkZDljNTI3YzVmOWQ1YmJiZWRiODUyZGI3YzEzNzM", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-04-27T09:36:16Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-04-27T09:36:16Z"}, "message": "fortran: Compare non-constant bound expressions. [PR105379]\n\nStarting with r12-8235-gfa5cd7102da676dcb1757b1288421f5f3439ae0e,\nclass descriptor types are compared to detect duplicate declarations.\n\nThis caused ICEs as the comparison of array spec supported only constant\nexplicit bounds, but dummy class variable descriptor types can have a\n_data field with non-constant array spec bounds.\n\nThis change adds support for non-constant bounds.  For that,\ngfc_dep_compare_expr is used.  It does probably more than strictly\nnecessary, but using it avoids rewriting a specific comparison function,\nmaking mistakes and forgetting cases.\n\n\tPR fortran/103662\n\tPR fortran/105379\n\ngcc/fortran/ChangeLog:\n\n\t* array.cc (compare_bounds): Use bool as return type.\n\tSupport non-constant expressions.\n\t(gfc_compare_array_spec): Update call to compare_bounds.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/class_dummy_8.f90: New test.\n\t* gfortran.dg/class_dummy_9.f90: New test.", "tree": {"sha": "c94770c91263d0e19de5d9dda05fd4b6ee641924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c94770c91263d0e19de5d9dda05fd4b6ee641924"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a460a2007dd9c527c5f9d5bbbedb852db7c1373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a460a2007dd9c527c5f9d5bbbedb852db7c1373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a460a2007dd9c527c5f9d5bbbedb852db7c1373", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a460a2007dd9c527c5f9d5bbbedb852db7c1373/comments", "author": null, "committer": null, "parents": [{"sha": "3e0c9fdfd00b5b5cbff1a0bd6ac012a10fe81348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0c9fdfd00b5b5cbff1a0bd6ac012a10fe81348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0c9fdfd00b5b5cbff1a0bd6ac012a10fe81348"}], "stats": {"total": 67, "additions": 56, "deletions": 11}, "files": [{"sha": "bbdb5b392fc86acdbba7b553c7d267004bb6cc13", "filename": "gcc/fortran/array.cc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a460a2007dd9c527c5f9d5bbbedb852db7c1373/gcc%2Ffortran%2Farray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a460a2007dd9c527c5f9d5bbbedb852db7c1373/gcc%2Ffortran%2Farray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.cc?ref=6a460a2007dd9c527c5f9d5bbbedb852db7c1373", "patch": "@@ -957,23 +957,28 @@ gfc_copy_array_spec (gfc_array_spec *src)\n }\n \n \n-/* Returns nonzero if the two expressions are equal.  Only handles integer\n-   constants.  */\n+/* Returns nonzero if the two expressions are equal.\n+   We should not need to support more than constant values, as that\u2019s what is\n+   allowed in derived type component array spec.  However, we may create types\n+   with non-constant array spec for dummy variable class container types, for\n+   which the _data component holds the array spec of the variable declaration.\n+   So we have to support non-constant bounds as well.  */\n \n-static int\n+static bool\n compare_bounds (gfc_expr *bound1, gfc_expr *bound2)\n {\n   if (bound1 == NULL || bound2 == NULL\n-      || bound1->expr_type != EXPR_CONSTANT\n-      || bound2->expr_type != EXPR_CONSTANT\n       || bound1->ts.type != BT_INTEGER\n       || bound2->ts.type != BT_INTEGER)\n     gfc_internal_error (\"gfc_compare_array_spec(): Array spec clobbered\");\n \n-  if (mpz_cmp (bound1->value.integer, bound2->value.integer) == 0)\n-    return 1;\n-  else\n-    return 0;\n+  /* What qualifies as identical bounds?  We could probably just check that the\n+     expressions are exact clones.  We avoid rewriting a specific comparison\n+     function and re-use instead the rather involved gfc_dep_compare_expr which\n+     is just a bit more permissive, as it can also detect identical values for\n+     some mismatching expressions (extra parenthesis, swapped operands, unary\n+     plus, etc).  It probably only makes a difference in corner cases.  */\n+  return gfc_dep_compare_expr (bound1, bound2) == 0;\n }\n \n \n@@ -1006,10 +1011,10 @@ gfc_compare_array_spec (gfc_array_spec *as1, gfc_array_spec *as2)\n   if (as1->type == AS_EXPLICIT)\n     for (i = 0; i < as1->rank + as1->corank; i++)\n       {\n-\tif (compare_bounds (as1->lower[i], as2->lower[i]) == 0)\n+\tif (!compare_bounds (as1->lower[i], as2->lower[i]))\n \t  return 0;\n \n-\tif (compare_bounds (as1->upper[i], as2->upper[i]) == 0)\n+\tif (!compare_bounds (as1->upper[i], as2->upper[i]))\n \t  return 0;\n       }\n "}, {"sha": "0976a72586606b86e2ba1abd2ef5f18225c457d5", "filename": "gcc/testsuite/gfortran.dg/class_dummy_8.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a460a2007dd9c527c5f9d5bbbedb852db7c1373/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a460a2007dd9c527c5f9d5bbbedb852db7c1373/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_8.f90?ref=6a460a2007dd9c527c5f9d5bbbedb852db7c1373", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+!\n+! PR fortran/105379\n+! Type comparison of class containers used to trigger an ICE when one of the\n+! class containers had a non-constant array spec.\n+!\n+! Contributed by Gerhard Steinmetz <gscfq@t-online.de>.\n+\n+program p\n+   type t\n+   end type\n+contains\n+   subroutine s1(x)\n+      class(t) :: x(3)\n+   end\n+   subroutine s2(n, x)\n+      integer :: n\n+      class(t) :: x(n)\n+   end\n+end"}, {"sha": "0fd98c05be2d97e4c46597086c6207ba148901c1", "filename": "gcc/testsuite/gfortran.dg/class_dummy_9.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a460a2007dd9c527c5f9d5bbbedb852db7c1373/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a460a2007dd9c527c5f9d5bbbedb852db7c1373/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_9.f90?ref=6a460a2007dd9c527c5f9d5bbbedb852db7c1373", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+!\n+! PR fortran/105379\n+! Type comparison of class containers used to trigger an ICE when one of the\n+! class containers had a non-constant array spec.\n+!\n+! Contributed by Gerhard Steinmetz <gscfq@t-online.de>.\n+\n+program p\n+   type t\n+   end type\n+   integer :: m = 3\n+contains\n+   subroutine s1(x)\n+      class(t) :: x(3)\n+   end\n+   subroutine s3(x)\n+      class(t) :: x(m)\n+   end\n+end"}]}