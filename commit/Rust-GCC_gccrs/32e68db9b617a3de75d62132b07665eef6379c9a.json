{"sha": "32e68db9b617a3de75d62132b07665eef6379c9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJlNjhkYjliNjE3YTNkZTc1ZDYyMTMyYjA3NjY1ZWVmNjM3OWM5YQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-08-11T20:25:50Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-08-11T20:25:50Z"}, "message": "Replace map with rename_map.\n\n2010-06-24  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-clast-to-gimple.c (build_iv_mapping): Rename map with\n\trename_map.\n\t* sese.c (debug_rename_map): Same.\n\t(get_rename): Same.\n\t(set_rename): Same.\n\t(rename_variables_in_stmt): Same.\n\t(expand_scalar_variables_call): Same.\n\t(expand_scalar_variables_ssa_name): Same.\n\t(expand_scalar_variables_expr): Same.\n\t(expand_scalar_variables_stmt): Same.\n\t(expand_scalar_variables): Same.\n\t(rename_variables): Same.\n\t(graphite_copy_stmts_from_block): Same.\n\t(copy_bb_and_scalar_dependences): Same.\n\nFrom-SVN: r163128", "tree": {"sha": "13453108f6015e975352d7ede7920567f045ba59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13453108f6015e975352d7ede7920567f045ba59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32e68db9b617a3de75d62132b07665eef6379c9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e68db9b617a3de75d62132b07665eef6379c9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32e68db9b617a3de75d62132b07665eef6379c9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e68db9b617a3de75d62132b07665eef6379c9a/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b164754dcb55a4bb64bbfd03c7a24cbf29ead57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b164754dcb55a4bb64bbfd03c7a24cbf29ead57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b164754dcb55a4bb64bbfd03c7a24cbf29ead57"}], "stats": {"total": 136, "additions": 85, "deletions": 51}, "files": [{"sha": "f539d6fd79bb96d0311aede260d4cba565967ab9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32e68db9b617a3de75d62132b07665eef6379c9a", "patch": "@@ -1,3 +1,20 @@\n+2010-08-02  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c (build_iv_mapping): Rename map with\n+\trename_map.\n+\t* sese.c (debug_rename_map): Same.\n+\t(get_rename): Same.\n+\t(set_rename): Same.\n+\t(rename_variables_in_stmt): Same.\n+\t(expand_scalar_variables_call): Same.\n+\t(expand_scalar_variables_ssa_name): Same.\n+\t(expand_scalar_variables_expr): Same.\n+\t(expand_scalar_variables_stmt): Same.\n+\t(expand_scalar_variables): Same.\n+\t(rename_variables): Same.\n+\t(graphite_copy_stmts_from_block): Same.\n+\t(copy_bb_and_scalar_dependences): Same.\n+\n 2010-08-02  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (copy_renames): Removed."}, {"sha": "3b048374bdcdd4e1aa4effd78f4c0702dbd60f65", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=32e68db9b617a3de75d62132b07665eef6379c9a", "patch": "@@ -1,3 +1,20 @@\n+2010-06-24  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c (build_iv_mapping): Rename map with\n+\trename_map.\n+\t* sese.c (debug_rename_map): Same.\n+\t(get_rename): Same.\n+\t(set_rename): Same.\n+\t(rename_variables_in_stmt): Same.\n+\t(expand_scalar_variables_call): Same.\n+\t(expand_scalar_variables_ssa_name): Same.\n+\t(expand_scalar_variables_expr): Same.\n+\t(expand_scalar_variables_stmt): Same.\n+\t(expand_scalar_variables): Same.\n+\t(rename_variables): Same.\n+\t(graphite_copy_stmts_from_block): Same.\n+\t(copy_bb_and_scalar_dependences): Same.\n+\n 2010-06-24  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (copy_renames): Removed."}, {"sha": "7eb916500ce21fe14e20b0980825b76940a9f776", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=32e68db9b617a3de75d62132b07665eef6379c9a", "patch": "@@ -819,11 +819,11 @@ graphite_create_new_loop (sese region, edge entry_edge,\n   return loop;\n }\n \n-/* Inserts in MAP a tuple (OLD_NAME, NEW_NAME) for the induction\n+/* Inserts in RENAME_MAP a tuple (OLD_NAME, NEW_NAME) for the induction\n    variables of the loops around GBB in SESE.  */\n \n static void\n-build_iv_mapping (htab_t map, sese region,\n+build_iv_mapping (htab_t rename_map, sese region,\n \t\t  VEC (tree, heap) *newivs, htab_t newivs_index,\n \t\t  struct clast_user_stmt *user_stmt,\n \t\t  htab_t params_index)\n@@ -842,7 +842,7 @@ build_iv_mapping (htab_t map, sese region,\n       tree old_name = pbb_to_depth_to_oldiv (pbb, index);\n       tree e = clast_to_gcc_expression (type, expr, region, newivs,\n \t\t\t\t\tnewivs_index, params_index);\n-      set_rename (map, old_name, e);\n+      set_rename (rename_map, old_name, e);\n     }\n }\n "}, {"sha": "a68ede562d7a34a35bfb31093ec6f2c38b3c94ed", "filename": "gcc/sese.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e68db9b617a3de75d62132b07665eef6379c9a/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=32e68db9b617a3de75d62132b07665eef6379c9a", "patch": "@@ -67,12 +67,12 @@ debug_rename_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n-/* Print to stderr all the elements of MAP.  */\n+/* Print to stderr all the elements of RENAME_MAP.  */\n \n DEBUG_FUNCTION void\n-debug_rename_map (htab_t map)\n+debug_rename_map (htab_t rename_map)\n {\n-  htab_traverse (map, debug_rename_map_1, NULL);\n+  htab_traverse (rename_map, debug_rename_map_1, NULL);\n }\n \n /* Computes a hash function for database element ELT.  */\n@@ -394,28 +394,28 @@ sese_insert_phis_for_liveouts (sese region, basic_block bb,\n   update_ssa (TODO_update_ssa);\n }\n \n-/* Returns the expression associated to OLD_NAME in MAP.  */\n+/* Returns the expression associated to OLD_NAME in RENAME_MAP.  */\n \n static tree\n-get_rename (htab_t map, tree old_name)\n+get_rename (htab_t rename_map, tree old_name)\n {\n   struct rename_map_elt_s tmp;\n   PTR *slot;\n \n   gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n   tmp.old_name = old_name;\n-  slot = htab_find_slot (map, &tmp, NO_INSERT);\n+  slot = htab_find_slot (rename_map, &tmp, NO_INSERT);\n \n   if (slot && *slot)\n     return ((rename_map_elt) *slot)->expr;\n \n   return old_name;\n }\n \n-/* Register in MAP the rename tuple (OLD_NAME, EXPR).  */\n+/* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).  */\n \n void\n-set_rename (htab_t map, tree old_name, tree expr)\n+set_rename (htab_t rename_map, tree old_name, tree expr)\n {\n   struct rename_map_elt_s tmp;\n   PTR *slot;\n@@ -424,7 +424,7 @@ set_rename (htab_t map, tree old_name, tree expr)\n     return;\n \n   tmp.old_name = old_name;\n-  slot = htab_find_slot (map, &tmp, INSERT);\n+  slot = htab_find_slot (rename_map, &tmp, INSERT);\n \n   if (!slot)\n     return;\n@@ -435,10 +435,10 @@ set_rename (htab_t map, tree old_name, tree expr)\n   *slot = new_rename_map_elt (old_name, expr);\n }\n \n-/* Rename the SSA_NAMEs used in STMT and that appear in MAP.  */\n+/* Rename the SSA_NAMEs used in STMT and that appear in RENAME_MAP.  */\n \n static void\n-rename_variables_in_stmt (gimple stmt, htab_t map, gimple_stmt_iterator *insert_gsi)\n+rename_variables_in_stmt (gimple stmt, htab_t rename_map, gimple_stmt_iterator *insert_gsi)\n {\n   ssa_op_iter iter;\n   use_operand_p use_p;\n@@ -452,7 +452,7 @@ rename_variables_in_stmt (gimple stmt, htab_t map, gimple_stmt_iterator *insert_\n       if (TREE_CODE (use) != SSA_NAME)\n \tcontinue;\n \n-      expr = get_rename (map, use);\n+      expr = get_rename (rename_map, use);\n       if (use == expr)\n \tcontinue;\n \n@@ -522,7 +522,7 @@ expand_scalar_variables_expr (tree, tree, enum tree_code, tree, basic_block,\n \n static tree\n expand_scalar_variables_call (gimple stmt, basic_block bb, sese region,\n-\t\t\t      htab_t map, gimple_stmt_iterator *gsi)\n+\t\t\t      htab_t rename_map, gimple_stmt_iterator *gsi)\n {\n   int i, nargs = gimple_call_num_args (stmt);\n   VEC (tree, gc) *args = VEC_alloc (tree, gc, nargs);\n@@ -538,7 +538,7 @@ expand_scalar_variables_call (gimple stmt, basic_block bb, sese region,\n \n       var = create_tmp_var (t, \"var\");\n       arg = expand_scalar_variables_expr (t, arg, TREE_CODE (arg), NULL,\n-\t\t\t\t\t  bb, region, map, gsi);\n+\t\t\t\t\t  bb, region, rename_map, gsi);\n       arg = build2 (MODIFY_EXPR, t, var, arg);\n       arg = force_gimple_operand_gsi (gsi, arg, true, NULL,\n \t\t\t\t      true, GSI_SAME_STMT);\n@@ -561,25 +561,25 @@ expand_scalar_variables_call (gimple stmt, basic_block bb, sese region,\n    the definition of OP0, that are defined outside BB and still in the\n    SESE, i.e. not a parameter of the SESE.  The expression that is\n    returned contains only induction variables from the generated code:\n-   MAP contains the induction variables renaming mapping, and is used\n+   RENAME_MAP contains the induction variables renaming mapping, and is used\n    to translate the names of induction variables.  */\n \n static tree\n expand_scalar_variables_ssa_name (tree type, tree op0, basic_block bb,\n-\t\t\t\t  sese region, htab_t map,\n+\t\t\t\t  sese region, htab_t rename_map,\n \t\t\t\t  gimple_stmt_iterator *gsi)\n {\n   gimple def_stmt;\n   tree new_op;\n \n   if (is_parameter (region, op0)\n       || is_iv (op0))\n-    return fold_convert (type, get_rename (map, op0));\n+    return fold_convert (type, get_rename (rename_map, op0));\n \n   def_stmt = SSA_NAME_DEF_STMT (op0);\n \n   /* Check whether we already have a rename for OP0.  */\n-  new_op = get_rename (map, op0);\n+  new_op = get_rename (rename_map, op0);\n \n   if (new_op != op0\n       && gimple_bb (SSA_NAME_DEF_STMT (new_op)) == bb)\n@@ -590,7 +590,7 @@ expand_scalar_variables_ssa_name (tree type, tree op0, basic_block bb,\n       /* If the defining statement is in the basic block already\n \t we do not need to create a new expression for it, we\n \t only need to ensure its operands are expanded.  */\n-      expand_scalar_variables_stmt (def_stmt, bb, region, map, gsi);\n+      expand_scalar_variables_stmt (def_stmt, bb, region, rename_map, gsi);\n       return fold_convert (type, new_op);\n     }\n   else\n@@ -609,11 +609,11 @@ expand_scalar_variables_ssa_name (tree type, tree op0, basic_block bb,\n \t    tree type = gimple_expr_type (def_stmt);\n \n \t    return expand_scalar_variables_expr (type, var0, subcode, var1, bb,\n-\t\t\t\t\t\t region, map, gsi);\n+\t\t\t\t\t\t region, rename_map, gsi);\n \t  }\n \n \tcase GIMPLE_CALL:\n-\t  return expand_scalar_variables_call (def_stmt, bb, region, map, gsi);\n+\t  return expand_scalar_variables_call (def_stmt, bb, region, rename_map, gsi);\n \n \tdefault:\n \t  gcc_unreachable ();\n@@ -627,13 +627,13 @@ expand_scalar_variables_ssa_name (tree type, tree op0, basic_block bb,\n    variables used in OP0 and OP1, defined outside BB and still defined\n    in the SESE, i.e. not a parameter of the SESE.  The expression that\n    is returned contains only induction variables from the generated\n-   code: MAP contains the induction variables renaming mapping, and is\n+   code: RENAME_MAP contains the induction variables renaming mapping, and is\n    used to translate the names of induction variables.  */\n \n static tree\n expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n \t\t\t      tree op1, basic_block bb, sese region,\n-\t\t\t      htab_t map, gimple_stmt_iterator *gsi)\n+\t\t\t      htab_t rename_map, gimple_stmt_iterator *gsi)\n {\n   if (TREE_CODE_CLASS (code) == tcc_constant\n       || TREE_CODE_CLASS (code) == tcc_declaration)\n@@ -650,15 +650,15 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n \t  {\n \t    tree op = TREE_OPERAND (op0, 0);\n \t    tree res = expand_scalar_variables_expr\n-\t      (type, op, TREE_CODE (op), NULL, bb, region, map, gsi);\n+\t      (type, op, TREE_CODE (op), NULL, bb, region, rename_map, gsi);\n \t    return build1 (code, type, res);\n \t  }\n \n \tcase INDIRECT_REF:\n \t  {\n \t    tree old_name = TREE_OPERAND (op0, 0);\n \t    tree expr = expand_scalar_variables_ssa_name\n-\t      (type, old_name, bb, region, map, gsi);\n+\t      (type, old_name, bb, region, rename_map, gsi);\n \n \t    if (TREE_CODE (expr) != SSA_NAME\n \t\t&& is_gimple_reg (old_name))\n@@ -682,10 +682,10 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n \t    tree op03 = TREE_OPERAND (op0, 3);\n \t    tree base = expand_scalar_variables_expr\n \t      (TREE_TYPE (op00), op00, TREE_CODE (op00), NULL, bb, region,\n-\t       map, gsi);\n+\t       rename_map, gsi);\n \t    tree subscript = expand_scalar_variables_expr\n \t      (TREE_TYPE (op01), op01, TREE_CODE (op01), NULL, bb, region,\n-\t       map, gsi);\n+\t       rename_map, gsi);\n \n \t    return build4 (ARRAY_REF, type, base, subscript, op02, op03);\n \t  }\n@@ -704,7 +704,7 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n       tree op0_type = TREE_TYPE (op0);\n       enum tree_code op0_code = TREE_CODE (op0);\n       tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t\t\t    NULL, bb, region, map, gsi);\n+\t\t\t\t\t\t    NULL, bb, region, rename_map, gsi);\n \n       return fold_build1 (code, type, op0_expr);\n     }\n@@ -715,17 +715,17 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n       tree op0_type = TREE_TYPE (op0);\n       enum tree_code op0_code = TREE_CODE (op0);\n       tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t\t\t    NULL, bb, region, map, gsi);\n+\t\t\t\t\t\t    NULL, bb, region, rename_map, gsi);\n       tree op1_type = TREE_TYPE (op1);\n       enum tree_code op1_code = TREE_CODE (op1);\n       tree op1_expr = expand_scalar_variables_expr (op1_type, op1, op1_code,\n-\t\t\t\t\t\t    NULL, bb, region, map, gsi);\n+\t\t\t\t\t\t    NULL, bb, region, rename_map, gsi);\n \n       return fold_build2 (code, type, op0_expr, op1_expr);\n     }\n \n   if (code == SSA_NAME)\n-    return expand_scalar_variables_ssa_name (type, op0, bb, region, map, gsi);\n+    return expand_scalar_variables_ssa_name (type, op0, bb, region, rename_map, gsi);\n \n   if (code == ADDR_EXPR)\n     {\n@@ -736,7 +736,7 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n \t{\n \t  tree e = expand_scalar_variables_expr (TREE_TYPE (op00), op00,\n \t\t\t\t\t\t TREE_CODE (op00),\n-\t\t\t\t\t\t NULL, bb, region, map, gsi);\n+\t\t\t\t\t\t NULL, bb, region, rename_map, gsi);\n \t  return fold_build1 (code, TREE_TYPE (op0), e);\n \t}\n \n@@ -751,13 +751,13 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n    STMT depends on in the SESE: these are all the scalar variables used\n    in STMT, defined outside BB and still defined in the SESE, i.e. not a\n    parameter of the SESE.  The expression that is returned contains\n-   only induction variables from the generated code: MAP contains the\n+   only induction variables from the generated code: RENAME_MAP contains the\n    induction variables renaming mapping, and is used to translate the\n    names of induction variables.  */\n \n static void\n expand_scalar_variables_stmt (gimple stmt, basic_block bb, sese region,\n-\t\t\t      htab_t map, gimple_stmt_iterator *gsi)\n+\t\t\t      htab_t rename_map, gimple_stmt_iterator *gsi)\n {\n   ssa_op_iter iter;\n   use_operand_p use_p;\n@@ -773,12 +773,12 @@ expand_scalar_variables_stmt (gimple stmt, basic_block bb, sese region,\n \tcontinue;\n \n       /* Don't expand USE if we already have a rename for it.  */\n-      use_expr = get_rename (map, use);\n+      use_expr = get_rename (rename_map, use);\n       if (use_expr != use)\n \tcontinue;\n \n       use_expr = expand_scalar_variables_expr (type, use, code, NULL, bb,\n-\t\t\t\t\t       region, map, gsi);\n+\t\t\t\t\t       region, rename_map, gsi);\n       use_expr = fold_convert (type, use_expr);\n \n       if (use_expr == use)\n@@ -813,33 +813,33 @@ expand_scalar_variables_stmt (gimple stmt, basic_block bb, sese region,\n    BB depends on in the SESE: these are all the scalar variables used\n    in BB, defined outside BB and still defined in the SESE, i.e. not a\n    parameter of the SESE.  The expression that is returned contains\n-   only induction variables from the generated code: MAP contains the\n+   only induction variables from the generated code: RENAME_MAP contains the\n    induction variables renaming mapping, and is used to translate the\n    names of induction variables.  */\n \n static void\n-expand_scalar_variables (basic_block bb, sese region, htab_t map)\n+expand_scalar_variables (basic_block bb, sese region, htab_t rename_map)\n {\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n     {\n       gimple stmt = gsi_stmt (gsi);\n-      expand_scalar_variables_stmt (stmt, bb, region, map, &gsi);\n+      expand_scalar_variables_stmt (stmt, bb, region, rename_map, &gsi);\n       gsi_next (&gsi);\n     }\n }\n \n-/* Rename all the SSA_NAMEs from block BB according to the MAP.  */\n+/* Rename all the SSA_NAMEs from block BB according to the RENAME_MAP.  */\n \n static void\n-rename_variables (basic_block bb, htab_t map)\n+rename_variables (basic_block bb, htab_t rename_map)\n {\n   gimple_stmt_iterator gsi;\n   gimple_stmt_iterator insert_gsi = gsi_start_bb (bb);\n \n   for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    rename_variables_in_stmt (gsi_stmt (gsi), map, &insert_gsi);\n+    rename_variables_in_stmt (gsi_stmt (gsi), rename_map, &insert_gsi);\n }\n \n /* Remove condition from BB.  */\n@@ -1172,7 +1172,7 @@ insert_guard_phis (basic_block bb, edge true_edge, edge false_edge,\n    preserve SSA form.  */\n \n static void\n-graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n+graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t rename_map)\n {\n   gimple_stmt_iterator gsi, gsi_tgt;\n \n@@ -1202,7 +1202,7 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n \t{\n \t  tree old_name = DEF_FROM_PTR (def_p);\n \t  tree new_name = create_new_def_for (old_name, copy, def_p);\n-\t  set_rename (map, old_name, new_name);\n+\t  set_rename (rename_map, old_name, new_name);\n \t}\n     }\n }\n@@ -1213,16 +1213,16 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n \n edge\n copy_bb_and_scalar_dependences (basic_block bb, sese region,\n-\t\t\t\tedge next_e, htab_t map)\n+\t\t\t\tedge next_e, htab_t rename_map)\n {\n   basic_block new_bb = split_edge (next_e);\n \n   next_e = single_succ_edge (new_bb);\n-  graphite_copy_stmts_from_block (bb, new_bb, map);\n+  graphite_copy_stmts_from_block (bb, new_bb, rename_map);\n   remove_condition (new_bb);\n   remove_phi_nodes (new_bb);\n-  expand_scalar_variables (new_bb, region, map);\n-  rename_variables (new_bb, map);\n+  expand_scalar_variables (new_bb, region, rename_map);\n+  rename_variables (new_bb, rename_map);\n \n   return next_e;\n }"}]}