{"sha": "0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1ZDU2OWNkNTZlNDlkZDViZTlhNjdkNTUzZjBjMDA3ZmY1NDM2Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-04-21T06:37:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-04-21T06:37:52Z"}, "message": "sparc.c (reg_or_0_operand, [...]): Delete.\n\n\t* config/sparc/sparc.c (reg_or_0_operand, const1_operand,\n\tfp_zero_operand, fp_register_operand, intreg_operand,\n\tfcc_reg_operand, fcc0_reg_operand, icc_or_fcc_reg_operand,\n\tcall_operand, call_operand_address, tgd_symbolic_operand,\n\ttld_symbolic_operand, tie_symbolic_operand, tle_symbolic_operand,\n\tsymbolic_operand, symbolic_memory_operand, label_ref_operand,\n\tsp64_medium_pic_operand, data_segment_operand,\n\ttext_segment_operand, splittable_symbolic_memory_operand,\n\treg_or_nonsymb_mem_operand, splittable_immediate_memory_operand,\n\teq_or_neq, normal_comp_operator, noov_compare_op,\n\tnoov_compare64_op, v9_regcmp_op, extend_op, cc_arithop,\n\tcc_arithopn, arith_operand, arith_4096_operand, arith_add_operand,\n\tconst64_operand, const64_high_operand, arith11_operand,\n\tarith10_operand, arith_double_operand, arith_double_4096_operand,\n\tarith_double_add_operand, arith11_double_operand,\n\tarith10_double_operand, small_int, small_int_or_double,\n\tuns_small_int, uns_arith_operand, clobbered_register,\n\tinput_operand, compare_operand): Delete.\n\t(sparc_emit_set_const32): Use predicates in assertion.  Remove special\n\tcode for TARGET_ARCH64 && HOST_BITS_PER_WIDE_INT != 64.\n\t(sparc_emit_set_const64): Call gcc_unreachable if H_B_P_W_I == 32.\n\t(GEN_HIGHINT64, GEN_INT64): Delete.\n\t(sparc_emit_set_safe_HIGH64, gen_safe_SET64, gen_safe_OR64,\n\tgen_safe_XOR64): Adjust for above deletion.\n\t(sparc_emit_set_const64): Support only H_B_P_W_I == 64 and CONST_INTs.\n\tUse 'unsigned HOST_WIDE_INT' instead of 'long' for bitmask.\n\t(legitimate_constant_p): Use const_zero_operand instead.\n\t(sparc_extra_constraint_check): Likewise.\n\t* config/sparc/sparc.h (CONST_DOUBLE_OK_FOR_LETTER_P): Remove 'O'.\n\t(PREFERRED_RELOAD_CLASS): Use const_zero_operand.\n\t(PREDICATE_CODES): Delete.\n\t* config/sparc/sparc.md: Include predicates.md.\n\t(All patterns): Adjust for new predicate names.\n\t(cmpdi, cmpdi_sp64): Use arith_operand predicate.\n\t(movhi_const64_special, movsi_const64_special): Add 'K' constraint.\n\t(movdi): Use general_operand predicate.\n\t(movdi_sp64_dbl): Delete.\n\t(movdi_const64_special): Add 'N' constraint.\n\t(movdicc): Use arith10_operand predicate.\n\t(movdi_cc_sp64, movdi_cc_sp64_trunc): Use arith11_operand predicate.\n\t(movdi_cc_reg_sp64): Use arith10_operand predicate.\n\t(movdi_cc_reg_sp64_trunc): Delete.\n\t(cmp_zero_extract, cmp_zero_extract_sp64): Use small_int_operand.\n\t(adddi3_insn_sp32, addx, cmp_cc_plus, cmp_ccx_plus, cmp_cc_plus_set,\n\tcmp_ccx_plus_set): Use register_operand predicate.\n\t(adddi3_sp64, cmp_ccx_plus_set): Use arith_operand predicate.\n\t(subdi3_sp32): Delete.\n\t(subdi3_insn_sp32): Change to define_insn_and_split.\n\t(subdi3_sp64, cmp_minus_ccx, cmp_minus_ccx_set): Use arith_operand.\n\t(muldi3, muldi3_sp64, muldi3_v8plus): Likewise.\n\t(smulsi3_highpart_v8plus, const_smulsi3_highpart_v8plus,\n\tumulsi3_highpart_v8plus, const_umulsi3_highpart_v8plus): Use\n\tsmall_int_operand predicate.\n\t(divdi3, udivdi3): Use arith_operand predicate.\n\t(udivsi3, udivsi3_sp32, udivsi3_sp64): Use nonimmediate_operand.\n\t(and<V64I>3_sp64, ior<V64I>3_sp64, xor<V64I:mode>3_sp64,\n\txor_not_<V64I:mode>_sp64) : Use arith_operand predicate.\n\t(xordi3_sp64_dbl): Delete.\n\t(cmp_ccx_arith_op, cmp_ccx_arith_op_set, cmp_ccx_xor_not,\n\tcmp_ccx_xor_not_set, cmp_ccx_arith_op_not, cmp_ccx_arith_op_not_set,\n\tcmp_ccx_neg, cmp_ccx_set_neg, one_cmpl<V64I>2_sp64, cmp_ccx_not,\n\tcmp_ccx_set_not): Use arith_operand predicate.\n\t(ashrsi3_extend2, lshrsi3_extend2 et al.): Use small_int_operand.\n\t* config/sparc/predicates.md: New file.\n\nFrom-SVN: r98494", "tree": {"sha": "dc0049bb428fa243f31fa61b199ea78de064aa7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc0049bb428fa243f31fa61b199ea78de064aa7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9850b3d44898c346b98e702eef0363b47fd0cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9850b3d44898c346b98e702eef0363b47fd0cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9850b3d44898c346b98e702eef0363b47fd0cbb"}], "stats": {"total": 2181, "additions": 866, "deletions": 1315}, "files": [{"sha": "08945e94083bca94c49738a62357a56788b429bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "patch": "@@ -1,3 +1,70 @@\n+2005-04-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc.c (reg_or_0_operand, const1_operand,\n+\tfp_zero_operand, fp_register_operand, intreg_operand,\n+\tfcc_reg_operand, fcc0_reg_operand, icc_or_fcc_reg_operand,\n+\tcall_operand, call_operand_address, tgd_symbolic_operand,\n+\ttld_symbolic_operand, tie_symbolic_operand, tle_symbolic_operand,\n+\tsymbolic_operand, symbolic_memory_operand, label_ref_operand,\n+\tsp64_medium_pic_operand, data_segment_operand,\n+\ttext_segment_operand, splittable_symbolic_memory_operand,\n+\treg_or_nonsymb_mem_operand, splittable_immediate_memory_operand,\n+\teq_or_neq, normal_comp_operator, noov_compare_op,\n+\tnoov_compare64_op, v9_regcmp_op, extend_op, cc_arithop,\n+\tcc_arithopn, arith_operand, arith_4096_operand, arith_add_operand,\n+\tconst64_operand, const64_high_operand, arith11_operand,\n+\tarith10_operand, arith_double_operand, arith_double_4096_operand,\n+\tarith_double_add_operand, arith11_double_operand,\n+\tarith10_double_operand, small_int, small_int_or_double,\n+\tuns_small_int, uns_arith_operand, clobbered_register,\n+\tinput_operand, compare_operand): Delete.\n+\t(sparc_emit_set_const32): Use predicates in assertion.  Remove special\n+\tcode for TARGET_ARCH64 && HOST_BITS_PER_WIDE_INT != 64.\n+\t(sparc_emit_set_const64): Call gcc_unreachable if H_B_P_W_I == 32.\n+\t(GEN_HIGHINT64, GEN_INT64): Delete.\n+\t(sparc_emit_set_safe_HIGH64, gen_safe_SET64, gen_safe_OR64,\n+\tgen_safe_XOR64): Adjust for above deletion.\n+\t(sparc_emit_set_const64): Support only H_B_P_W_I == 64 and CONST_INTs.\n+\tUse 'unsigned HOST_WIDE_INT' instead of 'long' for bitmask.\n+\t(legitimate_constant_p): Use const_zero_operand instead.\n+\t(sparc_extra_constraint_check): Likewise.\n+\t* config/sparc/sparc.h (CONST_DOUBLE_OK_FOR_LETTER_P): Remove 'O'.\n+\t(PREFERRED_RELOAD_CLASS): Use const_zero_operand.\n+\t(PREDICATE_CODES): Delete.\n+\t* config/sparc/sparc.md: Include predicates.md.\n+\t(All patterns): Adjust for new predicate names.\n+\t(cmpdi, cmpdi_sp64): Use arith_operand predicate.\n+\t(movhi_const64_special, movsi_const64_special): Add 'K' constraint.\n+\t(movdi): Use general_operand predicate.\n+\t(movdi_sp64_dbl): Delete.\n+\t(movdi_const64_special): Add 'N' constraint.\n+\t(movdicc): Use arith10_operand predicate.\n+\t(movdi_cc_sp64, movdi_cc_sp64_trunc): Use arith11_operand predicate.\n+\t(movdi_cc_reg_sp64): Use arith10_operand predicate.\n+\t(movdi_cc_reg_sp64_trunc): Delete.\n+\t(cmp_zero_extract, cmp_zero_extract_sp64): Use small_int_operand.\n+\t(adddi3_insn_sp32, addx, cmp_cc_plus, cmp_ccx_plus, cmp_cc_plus_set,\n+\tcmp_ccx_plus_set): Use register_operand predicate.\n+\t(adddi3_sp64, cmp_ccx_plus_set): Use arith_operand predicate.\n+\t(subdi3_sp32): Delete.\n+\t(subdi3_insn_sp32): Change to define_insn_and_split.\n+\t(subdi3_sp64, cmp_minus_ccx, cmp_minus_ccx_set): Use arith_operand.\n+\t(muldi3, muldi3_sp64, muldi3_v8plus): Likewise.\n+\t(smulsi3_highpart_v8plus, const_smulsi3_highpart_v8plus,\n+\tumulsi3_highpart_v8plus, const_umulsi3_highpart_v8plus): Use\n+\tsmall_int_operand predicate.\n+\t(divdi3, udivdi3): Use arith_operand predicate.\n+\t(udivsi3, udivsi3_sp32, udivsi3_sp64): Use nonimmediate_operand.\n+\t(and<V64I>3_sp64, ior<V64I>3_sp64, xor<V64I:mode>3_sp64,\n+\txor_not_<V64I:mode>_sp64) : Use arith_operand predicate.\n+\t(xordi3_sp64_dbl): Delete.\n+\t(cmp_ccx_arith_op, cmp_ccx_arith_op_set, cmp_ccx_xor_not,\n+\tcmp_ccx_xor_not_set, cmp_ccx_arith_op_not, cmp_ccx_arith_op_not_set,\n+\tcmp_ccx_neg, cmp_ccx_set_neg, one_cmpl<V64I>2_sp64, cmp_ccx_not,\n+\tcmp_ccx_set_not): Use arith_operand predicate.\n+\t(ashrsi3_extend2, lshrsi3_extend2 et al.): Use small_int_operand.\n+\t* config/sparc/predicates.md: New file.\n+\n 2005-04-21  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR tree-optimization/14846"}, {"sha": "059ed47eeb2573916bfd4b97be1ffdf4437977b6", "filename": "gcc/config/sparc/predicates.md", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "patch": "@@ -0,0 +1,456 @@\n+;; Predicate definitions for SPARC.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Predicates for numerical constants.\n+\n+;; Return true if OP is the zero constant for MODE.\n+(define_predicate \"const_zero_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Return true if OP is the one constant for MODE.\n+(define_predicate \"const_one_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST1_RTX (mode)\")))\n+\n+;; Return true if OP is the integer constant 4096.\n+(define_predicate \"const_4096_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 4096\")))\n+\n+;; Return true if OP is a constant that is representable by a 13-bit\n+;; signed field.  This is an acceptable immediate operand for most\n+;; 3-address instructions.\n+(define_predicate \"small_int_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SPARC_SIMM13_P (INTVAL (op))\")))\n+\n+;; Return true if OP is a constant operand for the umul instruction.  That\n+;; instruction sign-extends immediate values just like all other SPARC\n+;; instructions, but interprets the extended result as an unsigned number.\n+(define_predicate \"uns_small_int_operand\"\n+  (match_code \"const_int,const_double\")\n+{\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  return ((GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 0x1000)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && CONST_DOUBLE_HIGH (op) == 0\n+\t      && (unsigned) CONST_DOUBLE_LOW (op) - 0xFFFFF000 < 0x1000));\n+#else\n+  return (GET_CODE (op) == CONST_INT\n+\t  && ((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n+\t      || (INTVAL (op) >= 0xFFFFF000\n+                  && INTVAL (op) <= 0xFFFFFFFF)));\n+#endif\n+})\n+\n+;; Return true if OP is a constant that can be loaded by the sethi instruction.\n+;; The first test avoids emitting sethi to load zero for example.\n+(define_predicate \"const_high_operand\"\n+  (and (match_code \"const_int\")\n+       (and (match_test \"INTVAL (op) & ~(HOST_WIDE_INT)0x3ff\")\n+            (match_test \"SPARC_SETHI_P (INTVAL (op) & GET_MODE_MASK (mode))\"))))\n+\n+\n+;; Predicates for symbolic constants.\n+\n+;; Return true if OP is either a symbol reference or a sum of a symbol\n+;; reference and a constant.\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  enum machine_mode omode = GET_MODE (op);\n+\n+  if (omode != mode && omode != VOIDmode && mode != VOIDmode)\n+    return false;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+      return !SYMBOL_REF_TLS_MODEL (op);\n+\n+    case LABEL_REF:\n+      return true;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t\t&& !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n+\n+;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.\n+(define_predicate \"tgd_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"tls_symbolic_operand (op) == TLS_MODEL_GLOBAL_DYNAMIC\")))\n+\n+;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.\n+(define_predicate \"tld_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"tls_symbolic_operand (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n+\n+;; Return true if OP is a symbolic operand for the TLS Initial Exec model.\n+(define_predicate \"tie_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"tls_symbolic_operand (op) == TLS_MODEL_INITIAL_EXEC\")))\n+\n+;; Return true if OP is a symbolic operand for the TLS Local Exec model.\n+(define_predicate \"tle_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"tls_symbolic_operand (op) == TLS_MODEL_LOCAL_EXEC\")))\n+\n+;; Return true if the operand is an argument used in generating PIC references\n+;; in either the medium/low or embedded medium/anywhere code models on V9.\n+;; Check for (const (minus (symbol_ref:GOT)\n+;;                         (const (minus (label) (pc)))))\n+(define_predicate \"medium_pic_operand\"\n+  (match_code \"const\")\n+{\n+  /* Check for (const (minus (symbol_ref:GOT)\n+                             (const (minus (label) (pc))))).  */\n+  op = XEXP (op, 0);\n+  return GET_CODE (op) == MINUS\n+         && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+         && GET_CODE (XEXP (op, 1)) == CONST\n+         && GET_CODE (XEXP (XEXP (op, 1), 0)) == MINUS;\n+})\n+\n+;; Return true if OP is a LABEL_REF of mode MODE.\n+(define_predicate \"label_ref_operand\"\n+  (and (match_code \"label_ref\")\n+       (match_test \"GET_MODE (op) == mode\")))\n+\n+;; Return true if OP is a data segment reference.  This includes the readonly\n+;; data segment or, in other words, anything but the text segment.\n+;; This is needed in the embedded medium/anywhere code model on V9.  These\n+;; values are accessed with EMBMEDANY_BASE_REG.  */\n+(define_predicate \"data_segment_operand\"\n+  (match_code \"symbol_ref,plus,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF :\n+      return ! SYMBOL_REF_FUNCTION_P (op);\n+    case PLUS :\n+      /* Assume canonical format of symbol + constant.\n+\t Fall through.  */\n+    case CONST :\n+      return data_segment_operand (XEXP (op, 0), VOIDmode);\n+    default :\n+      gcc_unreachable ();\n+    }\n+})\n+\n+;; Return true if OP is a text segment reference.\n+;; This is needed in the embedded medium/anywhere code model on V9.\n+(define_predicate \"text_segment_operand\"\n+  (match_code \"label_ref,symbol_ref,plus,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF :\n+      return true;\n+    case SYMBOL_REF :\n+      return SYMBOL_REF_FUNCTION_P (op);\n+    case PLUS :\n+      /* Assume canonical format of symbol + constant.\n+\t Fall through.  */\n+    case CONST :\n+      return text_segment_operand (XEXP (op, 0), VOIDmode);\n+    default :\n+      gcc_unreachable ();\n+    }\n+})\n+\n+\n+;; Predicates for registers.\n+\n+;; Return true if OP is either the zero constant or a register.\n+(define_predicate \"register_or_zero_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_zero_operand\")))\n+\n+;; Return true if OP is a register operand in a floating point register.\n+(define_predicate \"fp_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op); /* Possibly a MEM */\n+  return REG_P (op) && SPARC_FP_REG_P (REGNO (op));\n+})\n+\n+;; Return true if OP is an integer register.\n+(define_special_predicate \"int_register_operand\"\n+  (ior (match_test \"register_operand (op, SImode)\")\n+       (match_test \"TARGET_ARCH64 && register_operand (op, DImode)\")))\n+\n+;; Return true if OP is a floating point condition code register.\n+(define_predicate \"fcc_register_operand\"\n+  (match_code \"reg\")\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return false;\n+  if (mode == VOIDmode\n+      && (GET_MODE (op) != CCFPmode && GET_MODE (op) != CCFPEmode))\n+    return false;\n+\n+#if 0 /* ??? 1 when %fcc0-3 are pseudos first.  See gen_compare_reg().  */\n+  if (reg_renumber == 0)\n+    return REGNO (op) >= FIRST_PSEUDO_REGISTER;\n+  return REGNO_OK_FOR_CCFP_P (REGNO (op));\n+#else\n+  return ((unsigned) REGNO (op) - SPARC_FIRST_V9_FCC_REG) < 4;\n+#endif\n+})\n+\n+;; Return true if OP is the floating point condition code register fcc0.\n+(define_predicate \"fcc0_register_operand\"\n+  (match_code \"reg\")\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return false;\n+  if (mode == VOIDmode\n+      && (GET_MODE (op) != CCFPmode && GET_MODE (op) != CCFPEmode))\n+    return false;\n+\n+  return REGNO (op) == SPARC_FCC_REG;\n+})\n+\n+;; Return true if OP is an integer or floating point condition code register.\n+(define_predicate \"icc_or_fcc_register_operand\"\n+  (match_code \"reg\")\n+{\n+  if (REGNO (op) == SPARC_ICC_REG)\n+    {\n+      if (mode != VOIDmode && mode != GET_MODE (op))\n+\treturn false;\n+      if (mode == VOIDmode\n+\t  && GET_MODE (op) != CCmode && GET_MODE (op) != CCXmode)\n+\treturn false;\n+\n+      return true;\n+    }\n+\n+  return fcc_register_operand (op, mode);\n+})\n+\n+\n+;; Predicates for arithmetic instructions.\n+\n+;; Return true if OP is a register, or is a constant that is representable\n+;; by a 13-bit signed field.  This is an acceptable operand for most\n+;; 3-address instructions.\n+(define_predicate \"arith_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"small_int_operand\")))\n+\n+;; 64-bit: Same as above.\n+;; 32-bit: Return true if OP is a register, or is a constant that is \n+;; representable by a couple of 13-bit signed fields.  This is an\n+;; acceptable operand for most 3-address splitters.\n+(define_predicate \"arith_double_operand\"\n+  (match_code \"const_int,const_double,reg,subreg\")\n+{\n+  bool arith_simple_operand = arith_operand (op, mode);\n+  HOST_WIDE_INT m1, m2;\n+\n+  if (TARGET_ARCH64 || arith_simple_operand)\n+    return arith_simple_operand;\n+\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  if (GET_CODE (op) != CONST_DOUBLE)\n+    return false;\n+  m1 = CONST_DOUBLE_LOW (op);\n+  m2 = CONST_DOUBLE_HIGH (op);\n+#else\n+  if (GET_CODE (op) != CONST_INT)\n+    return false;\n+  m1 = INTVAL (op) & 0xffffffff;\n+  m2 = INTVAL (op) >> 32;\n+#endif\n+\n+  return SPARC_SIMM13_P (m1) && SPARC_SIMM13_P (m2);\n+})\n+\n+;; Return true if OP is suitable as second operand for add/sub.\n+(define_predicate \"arith_add_operand\"\n+  (ior (match_operand 0 \"arith_operand\")\n+       (match_operand 0 \"const_4096_operand\")))\n+       \n+;; Return true if OP is suitable as second double operand for add/sub.\n+(define_predicate \"arith_double_add_operand\"\n+  (match_code \"const_int,const_double,reg,subreg\")\n+{\n+  bool _arith_double_operand = arith_double_operand (op, mode);\n+\n+  if (_arith_double_operand)\n+    return true;\n+\n+  return TARGET_ARCH64 && const_4096_operand (op, mode);\n+})\n+\n+;; Return true if OP is a register, or is a CONST_INT that can fit in a\n+;; signed 10-bit immediate field.  This is an acceptable SImode operand for\n+;; the movrcc instructions.\n+(define_predicate \"arith10_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+            (match_test \"SPARC_SIMM10_P (INTVAL (op))\"))))\n+\n+;; Return true if OP is a register, or is a CONST_INT that can fit in a\n+;; signed 11-bit immediate field.  This is an acceptable SImode operand for\n+;; the movcc instructions.\n+(define_predicate \"arith11_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+            (match_test \"SPARC_SIMM11_P (INTVAL (op))\"))))\n+\n+;; Return true if OP is a register or a constant for the umul instruction.\n+(define_predicate \"uns_arith_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"uns_small_int_operand\")))\n+\n+\n+;; Predicates for miscellanous instructions.\n+\n+;; Return true if OP is valid for the lhs of a comparison insn.\n+(define_predicate \"compare_operand\"\n+  (match_code \"reg, subreg, zero_extract\")\n+{\n+  if (GET_CODE (op) == ZERO_EXTRACT)\n+    return (register_operand (XEXP (op, 0), mode)\n+\t    && small_int_operand (XEXP (op, 1), mode)\n+\t    && small_int_operand (XEXP (op, 2), mode)\n+\t    /* This matches cmp_zero_extract.  */\n+\t    && ((mode == SImode\n+\t\t && INTVAL (XEXP (op, 2)) > 19)\n+\t\t/* This matches cmp_zero_extract_sp64.  */\n+\t\t|| (TARGET_ARCH64\n+\t\t    && mode == DImode\n+\t\t    && INTVAL (XEXP (op, 2)) > 51)));\n+  else\n+    return register_operand (op, mode);\n+})\n+\n+;; Return true if OP is a valid operand for the source of a move insn.\n+(define_predicate \"input_operand\"\n+  (match_code \"const_int,const_double,const_vector,reg,subreg,mem\")\n+{\n+  enum mode_class mclass;\n+\n+  /* If both modes are non-void they must be the same.  */\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return false;\n+\n+  /* Allow any 1-instruction integer constant.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && (small_int_operand (op, mode) || const_high_operand (op, mode)))\n+    return true;\n+\n+  /* If 32-bit mode and this is a DImode constant, allow it\n+     so that the splits can be generated.  */\n+  if (TARGET_ARCH32\n+      && mode == DImode\n+      && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n+    return true;\n+\n+  if (register_operand (op, mode))\n+    return true;\n+\n+  mclass = GET_MODE_CLASS (mode);\n+  if ((mclass == MODE_FLOAT && GET_CODE (op) == CONST_DOUBLE)\n+      || (mclass == MODE_VECTOR_INT && GET_CODE (op) == CONST_VECTOR))\n+    return true;\n+\n+  /* If this is a SUBREG, look inside so that we handle\n+     paradoxical ones.  */\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  /* Check for valid MEM forms.  */\n+  if (GET_CODE (op) == MEM)\n+    return memory_address_p (mode, XEXP (op, 0));\n+\n+  return false;\n+})\n+\n+;; Return true if OP is an address suitable for a call insn.\n+;; Call insn on SPARC can take a PC-relative constant address\n+;; or any regular memory address.\n+(define_predicate \"call_address_operand\"\n+  (ior (match_operand 0 \"symbolic_operand\")\n+       (match_test \"memory_address_p (Pmode, op)\")))\n+\n+;; Return true if OP is an operand suitable for a call insn.\n+(define_predicate \"call_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"call_address_operand (XEXP (op, 0), mode)\")))\n+\n+\n+;; Predicates for operators.\n+\n+;; Return true if OP is a comparison operator.  This allows the use of\n+;; MATCH_OPERATOR to recognize all the branch insns.\n+(define_predicate \"noov_compare_operator\"\n+  (match_code \"ne,eq,ge,gt,le,lt,geu,gtu,leu,ltu\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  if (GET_MODE (XEXP (op, 0)) == CC_NOOVmode\n+      || GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n+    /* These are the only branches which work with CC_NOOVmode.  */\n+    return (code == EQ || code == NE || code == GE || code == LT);\n+  return true;\n+})\n+\n+;; Return true if OP is a 64-bit comparison operator.  This allows the use of\n+;; MATCH_OPERATOR to recognize all the branch insns.\n+(define_predicate \"noov_compare64_operator\"\n+  (and (match_code \"ne,eq,ge,gt,le,lt,geu,gtu,leu,ltu\")\n+       (match_test \"TARGET_V9\"))\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  if (GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n+    /* These are the only branches which work with CCX_NOOVmode.  */\n+    return (code == EQ || code == NE || code == GE || code == LT);\n+  return (GET_MODE (XEXP (op, 0)) == CCXmode);\n+})\n+\n+;; Return true if OP is a comparison operator suitable for use in V9\n+;; conditional move or branch on register contents instructions.\n+(define_predicate \"v9_register_compare_operator\"\n+  (match_code \"eq,ne,ge,lt,le,gt\"))\n+\n+;; Return true if OP is an operator which can set the condition codes\n+;; explicitly.  We do not include PLUS and MINUS because these\n+;; require CC_NOOVmode, which we handle explicitly.\n+(define_predicate \"cc_arith_operator\"\n+  (match_code \"and,ior,xor\"))\n+\n+;; Return true if OP is an operator which can bitwise complement its\n+;; second operand and set the condition codes explicitly.\n+;; XOR is not here because combine canonicalizes (xor (not ...) ...)\n+;; and (xor ... (not ...)) to (not (xor ...)).  */\n+(define_predicate \"cc_arith_not_operator\"\n+  (match_code \"and,ior\"))"}, {"sha": "8e2893d4cd3e9ba30fbc4e3127ed3cf1391f7922", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 25, "deletions": 830, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "patch": "@@ -805,56 +805,6 @@ v9_regcmp_p (enum rtx_code code)\n \f\n /* Operand constraints.  */\n \n-/* Return nonzero only if OP is a register of mode MODE,\n-   or const0_rtx.  */\n-\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-  if (op == const0_rtx)\n-    return 1;\n-  if (GET_MODE (op) == VOIDmode && GET_CODE (op) == CONST_DOUBLE\n-      && CONST_DOUBLE_HIGH (op) == 0\n-      && CONST_DOUBLE_LOW (op) == 0)\n-    return 1;\n-  if (fp_zero_operand (op, mode))\n-    return 1;\n-  return 0;\n-}\n-\n-/* Return nonzero only if OP is const1_rtx.  */\n-\n-int\n-const1_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return op == const1_rtx;\n-}\n-\n-/* Nonzero if OP is a floating point value with value 0.0.  */\n-\n-int\n-fp_zero_operand (rtx op, enum machine_mode mode)\n-{\n-  enum mode_class mclass = GET_MODE_CLASS (GET_MODE (op));\n-  if (mclass != MODE_FLOAT && mclass != MODE_VECTOR_INT)\n-    return 0;\n-  return op == CONST0_RTX (mode);\n-}\n-\n-/* Nonzero if OP is a register operand in floating point register.  */\n-\n-int\n-fp_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! register_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return GET_CODE (op) == REG && SPARC_FP_REG_P (REGNO (op));\n-}\n-\n /* Nonzero if OP is a floating point constant which can\n    be loaded into an integer register using a single\n    sethi instruction.  */\n@@ -931,94 +881,6 @@ fp_high_losum_p (rtx op)\n   return 0;\n }\n \n-/* Nonzero if OP is an integer register.  */\n-\n-int\n-intreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (register_operand (op, SImode)\n-\t  || (TARGET_ARCH64 && register_operand (op, DImode)));\n-}\n-\n-/* Nonzero if OP is a floating point condition code register.  */\n-\n-int\n-fcc_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  /* This can happen when recog is called from combine.  Op may be a MEM.\n-     Fail instead of calling abort in this case.  */\n-  if (GET_CODE (op) != REG)\n-    return 0;\n-\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-  if (mode == VOIDmode\n-      && (GET_MODE (op) != CCFPmode && GET_MODE (op) != CCFPEmode))\n-    return 0;\n-\n-#if 0\t/* ??? ==> 1 when %fcc0-3 are pseudos first.  See gen_compare_reg().  */\n-  if (reg_renumber == 0)\n-    return REGNO (op) >= FIRST_PSEUDO_REGISTER;\n-  return REGNO_OK_FOR_CCFP_P (REGNO (op));\n-#else\n-  return (unsigned) REGNO (op) - SPARC_FIRST_V9_FCC_REG < 4;\n-#endif\n-}\n-\n-/* Nonzero if OP is a floating point condition code fcc0 register.  */\n-\n-int\n-fcc0_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  /* This can happen when recog is called from combine.  Op may be a MEM.\n-     Fail instead of calling abort in this case.  */\n-  if (GET_CODE (op) != REG)\n-    return 0;\n-\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-  if (mode == VOIDmode\n-      && (GET_MODE (op) != CCFPmode && GET_MODE (op) != CCFPEmode))\n-    return 0;\n-\n-  return REGNO (op) == SPARC_FCC_REG;\n-}\n-\n-/* Nonzero if OP is an integer or floating point condition code register.  */\n-\n-int\n-icc_or_fcc_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG && REGNO (op) == SPARC_ICC_REG)\n-    {\n-      if (mode != VOIDmode && mode != GET_MODE (op))\n-\treturn 0;\n-      if (mode == VOIDmode\n-\t  && GET_MODE (op) != CCmode && GET_MODE (op) != CCXmode)\n-\treturn 0;\n-      return 1;\n-    }\n-\n-  return fcc_reg_operand (op, mode);\n-}\n-\n-/* Call insn on SPARC can take a PC-relative constant address, or any regular\n-   memory address.  */\n-\n-int\n-call_operand (rtx op, enum machine_mode mode)\n-{\n-  gcc_assert (GET_CODE (op) == MEM);\n-  op = XEXP (op, 0);\n-  return (symbolic_operand (op, mode) || memory_address_p (Pmode, op));\n-}\n-\n-int\n-call_operand_address (rtx op, enum machine_mode mode)\n-{\n-  return (symbolic_operand (op, mode) || memory_address_p (Pmode, op));\n-}\n-\n /* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,\n    otherwise return 0.  */\n \n@@ -1029,628 +891,6 @@ tls_symbolic_operand (rtx op)\n     return 0;\n   return SYMBOL_REF_TLS_MODEL (op);\n }\n-\n-int\n-tgd_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return tls_symbolic_operand (op) == TLS_MODEL_GLOBAL_DYNAMIC;\n-}\n-\n-int\n-tld_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return tls_symbolic_operand (op) == TLS_MODEL_LOCAL_DYNAMIC;\n-}\n-\n-int\n-tie_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return tls_symbolic_operand (op) == TLS_MODEL_INITIAL_EXEC;\n-}\n-\n-int\n-tle_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return tls_symbolic_operand (op) == TLS_MODEL_LOCAL_EXEC;\n-}\n-\n-/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n-   reference and a constant.  */\n-\n-int\n-symbolic_operand (register rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode omode = GET_MODE (op);\n-\n-  if (omode != mode && omode != VOIDmode && mode != VOIDmode)\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-      return !SYMBOL_REF_TLS_MODEL (op);\n-\n-    case LABEL_REF:\n-      return 1;\n-\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t\t&& !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))\n-\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return truth value of statement that OP is a symbolic memory\n-   operand of mode MODE.  */\n-\n-int\n-symbolic_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return ((GET_CODE (op) == SYMBOL_REF && !SYMBOL_REF_TLS_MODEL (op))\n-\t  || GET_CODE (op) == CONST || GET_CODE (op) == HIGH\n-\t  || GET_CODE (op) == LABEL_REF);\n-}\n-\n-/* Return truth value of statement that OP is a LABEL_REF of mode MODE.  */\n-\n-int\n-label_ref_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != LABEL_REF)\n-    return 0;\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-  return 1;\n-}\n-\n-/* Return 1 if the operand is an argument used in generating pic references\n-   in either the medium/low or medium/anywhere code models of sparc64.  */\n-\n-int\n-sp64_medium_pic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  /* Check for (const (minus (symbol_ref:GOT)\n-                             (const (minus (label) (pc))))).  */\n-  if (GET_CODE (op) != CONST)\n-    return 0;\n-  op = XEXP (op, 0);\n-  if (GET_CODE (op) != MINUS)\n-    return 0;\n-  if (GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n-    return 0;\n-  /* ??? Ensure symbol is GOT.  */\n-  if (GET_CODE (XEXP (op, 1)) != CONST)\n-    return 0;\n-  if (GET_CODE (XEXP (XEXP (op, 1), 0)) != MINUS)\n-    return 0;\n-  return 1;\n-}\n-\n-/* Return 1 if the operand is a data segment reference.  This includes\n-   the readonly data segment, or in other words anything but the text segment.\n-   This is needed in the medium/anywhere code model on v9.  These values\n-   are accessed with EMBMEDANY_BASE_REG.  */\n-\n-int\n-data_segment_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF :\n-      return ! SYMBOL_REF_FUNCTION_P (op);\n-    case PLUS :\n-      /* Assume canonical format of symbol + constant.\n-\t Fall through.  */\n-    case CONST :\n-      return data_segment_operand (XEXP (op, 0), VOIDmode);\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return 1 if the operand is a text segment reference.\n-   This is needed in the medium/anywhere code model on v9.  */\n-\n-int\n-text_segment_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case LABEL_REF :\n-      return 1;\n-    case SYMBOL_REF :\n-      return SYMBOL_REF_FUNCTION_P (op);\n-    case PLUS :\n-      /* Assume canonical format of symbol + constant.\n-\t Fall through.  */\n-    case CONST :\n-      return text_segment_operand (XEXP (op, 0), VOIDmode);\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return 1 if the operand is either a register or a memory operand that is\n-   not symbolic.  */\n-\n-int\n-reg_or_nonsymb_mem_operand (register rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (memory_operand (op, mode) && ! symbolic_memory_operand (op, mode))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-int\n-splittable_symbolic_memory_operand (rtx op,\n-\t\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  if (! symbolic_operand (XEXP (op, 0), Pmode))\n-    return 0;\n-  return 1;\n-}\n-\n-int\n-splittable_immediate_memory_operand (rtx op,\n-\t\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  if (! immediate_operand (XEXP (op, 0), Pmode))\n-    return 0;\n-  return 1;\n-}\n-\n-/* Return truth value of whether OP is EQ or NE.  */\n-\n-int\n-eq_or_neq (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n-}\n-\n-/* Return 1 if this is a comparison operator, but not an EQ, NE, GEU,\n-   or LTU for non-floating-point.  We handle those specially.  */\n-\n-int\n-normal_comp_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code;\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  if (GET_MODE (XEXP (op, 0)) == CCFPmode\n-      || GET_MODE (XEXP (op, 0)) == CCFPEmode)\n-    return 1;\n-\n-  code = GET_CODE (op);\n-  return (code != NE && code != EQ && code != GEU && code != LTU);\n-}\n-\n-/* Return 1 if this is a comparison operator.  This allows the use of\n-   MATCH_OPERATOR to recognize all the branch insns.  */\n-\n-int\n-noov_compare_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code;\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  code = GET_CODE (op);\n-  if (GET_MODE (XEXP (op, 0)) == CC_NOOVmode\n-      || GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n-    /* These are the only branches which work with CC_NOOVmode.  */\n-    return (code == EQ || code == NE || code == GE || code == LT);\n-  return 1;\n-}\n-\n-/* Return 1 if this is a 64-bit comparison operator.  This allows the use of\n-   MATCH_OPERATOR to recognize all the branch insns.  */\n-\n-int\n-noov_compare64_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code;\n-\n-  if (! TARGET_V9)\n-    return 0;\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  code = GET_CODE (op);\n-  if (GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n-    /* These are the only branches which work with CCX_NOOVmode.  */\n-    return (code == EQ || code == NE || code == GE || code == LT);\n-  return (GET_MODE (XEXP (op, 0)) == CCXmode);\n-}\n-\n-/* Nonzero if OP is a comparison operator suitable for use in v9\n-   conditional move or branch on register contents instructions.  */\n-\n-int\n-v9_regcmp_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code;\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  code = GET_CODE (op);\n-  return v9_regcmp_p (code);\n-}\n-\n-/* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */\n-\n-int\n-extend_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND;\n-}\n-\n-/* Return nonzero if OP is an operator of mode MODE which can set\n-   the condition codes explicitly.  We do not include PLUS and MINUS\n-   because these require CC_NOOVmode, which we handle explicitly.  */\n-\n-int\n-cc_arithop (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == AND\n-      || GET_CODE (op) == IOR\n-      || GET_CODE (op) == XOR)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return nonzero if OP is an operator of mode MODE which can bitwise\n-   complement its second operand and set the condition codes explicitly.  */\n-\n-int\n-cc_arithopn (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  /* XOR is not here because combine canonicalizes (xor (not ...) ...)\n-     and (xor ... (not ...)) to (not (xor ...)).  */\n-  return (GET_CODE (op) == AND\n-\t  || GET_CODE (op) == IOR);\n-}\n-\f\n-/* Return true if OP is a register, or is a CONST_INT that can fit in a\n-   signed 13 bit immediate field.  This is an acceptable SImode operand for\n-   most 3 address instructions.  */\n-\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return SMALL_INT32 (op);\n-}\n-\n-/* Return true if OP is a constant 4096  */\n-\n-int\n-arith_4096_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  else\n-    return INTVAL (op) == 4096;\n-}\n-\n-/* Return true if OP is suitable as second operand for add/sub */\n-\n-int\n-arith_add_operand (rtx op, enum machine_mode mode)\n-{\n-  return arith_operand (op, mode) || arith_4096_operand (op, mode);\n-}\n-\n-/* Return true if OP is a CONST_INT or a CONST_DOUBLE which can fit in the\n-   immediate field of OR and XOR instructions.  Used for 64-bit\n-   constant formation patterns.  */\n-int\n-const64_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && SPARC_SIMM13_P (INTVAL (op)))\n-#if HOST_BITS_PER_WIDE_INT != 64\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))\n-\t      && (CONST_DOUBLE_HIGH (op) ==\n-\t\t  ((CONST_DOUBLE_LOW (op) & 0x80000000) != 0 ?\n-\t\t   (HOST_WIDE_INT)-1 : 0)))\n-#endif\n-\t  );\n-}\n-\n-/* The same, but only for sethi instructions.  */\n-int\n-const64_high_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && (INTVAL (op) & ~(HOST_WIDE_INT)0x3ff) != 0\n-\t   && SPARC_SETHI_P (INTVAL (op) & GET_MODE_MASK (mode))\n-\t   )\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && (CONST_DOUBLE_LOW (op) & ~(HOST_WIDE_INT)0x3ff) != 0\n-\t      && SPARC_SETHI_P (CONST_DOUBLE_LOW (op))));\n-}\n-\n-/* Return true if OP is a register, or is a CONST_INT that can fit in a\n-   signed 11 bit immediate field.  This is an acceptable SImode operand for\n-   the movcc instructions.  */\n-\n-int\n-arith11_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM11_P (INTVAL (op))));\n-}\n-\n-/* Return true if OP is a register, or is a CONST_INT that can fit in a\n-   signed 10 bit immediate field.  This is an acceptable SImode operand for\n-   the movrcc instructions.  */\n-\n-int\n-arith10_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM10_P (INTVAL (op))));\n-}\n-\n-/* Return true if OP is a register, is a CONST_INT that fits in a 13 bit\n-   immediate field, or is a CONST_DOUBLE whose both parts fit in a 13 bit\n-   immediate field.\n-   ARCH64: Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n-   can fit in a 13 bit immediate field.  This is an acceptable DImode operand\n-   for most 3 address instructions.  */\n-\n-int\n-arith_double_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-\t  || (! TARGET_ARCH64\n-\t      && GET_CODE (op) == CONST_DOUBLE\n-\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n-\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_HIGH (op) + 0x1000) < 0x2000)\n-\t  || (TARGET_ARCH64\n-\t      && GET_CODE (op) == CONST_DOUBLE\n-\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n-\t      && ((CONST_DOUBLE_HIGH (op) == -1\n-\t\t   && (CONST_DOUBLE_LOW (op) & 0x1000) == 0x1000)\n-\t\t  || (CONST_DOUBLE_HIGH (op) == 0\n-\t\t      && (CONST_DOUBLE_LOW (op) & 0x1000) == 0))));\n-}\n-\n-/* Return true if OP is a constant 4096 for DImode on ARCH64 */\n-\n-int\n-arith_double_4096_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (TARGET_ARCH64 &&\n-  \t  ((GET_CODE (op) == CONST_INT && INTVAL (op) == 4096) ||\n-  \t   (GET_CODE (op) == CONST_DOUBLE &&\n-  \t    CONST_DOUBLE_LOW (op) == 4096 &&\n-  \t    CONST_DOUBLE_HIGH (op) == 0)));\n-}\n-\n-/* Return true if OP is suitable as second operand for add/sub in DImode */\n-\n-int\n-arith_double_add_operand (rtx op, enum machine_mode mode)\n-{\n-  return arith_double_operand (op, mode) || arith_double_4096_operand (op, mode);\n-}\n-\n-/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n-   can fit in an 11 bit immediate field.  This is an acceptable DImode\n-   operand for the movcc instructions.  */\n-/* ??? Replace with arith11_operand?  */\n-\n-int\n-arith11_double_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n-\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x400) < 0x800\n-\t      && ((CONST_DOUBLE_HIGH (op) == -1\n-\t\t   && (CONST_DOUBLE_LOW (op) & 0x400) == 0x400)\n-\t\t  || (CONST_DOUBLE_HIGH (op) == 0\n-\t\t      && (CONST_DOUBLE_LOW (op) & 0x400) == 0)))\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n-\t      && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x400) < 0x800));\n-}\n-\n-/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n-   can fit in an 10 bit immediate field.  This is an acceptable DImode\n-   operand for the movrcc instructions.  */\n-/* ??? Replace with arith10_operand?  */\n-\n-int\n-arith10_double_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n-\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x200) < 0x400\n-\t      && ((CONST_DOUBLE_HIGH (op) == -1\n-\t\t   && (CONST_DOUBLE_LOW (op) & 0x200) == 0x200)\n-\t\t  || (CONST_DOUBLE_HIGH (op) == 0\n-\t\t      && (CONST_DOUBLE_LOW (op) & 0x200) == 0)))\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n-\t      && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x200) < 0x400));\n-}\n-\n-/* Return truth value of whether OP is an integer which fits the\n-   range constraining immediate operands in most three-address insns,\n-   which have a 13 bit immediate field.  */\n-\n-int\n-small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n-}\n-\n-int\n-small_int_or_double (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return ((GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))));\n-}\n-\n-/* Recognize operand values for the umul instruction.  That instruction sign\n-   extends immediate values just like all other sparc instructions, but\n-   interprets the extended result as an unsigned number.  */\n-\n-int\n-uns_small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-#if HOST_BITS_PER_WIDE_INT > 32\n-  /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && ((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n-\t      || (INTVAL (op) >= 0xFFFFF000\n-                  && INTVAL (op) <= 0xFFFFFFFF)));\n-#else\n-  return ((GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 0x1000)\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && (unsigned) CONST_DOUBLE_LOW (op) - 0xFFFFF000 < 0x1000));\n-#endif\n-}\n-\n-int\n-uns_arith_operand (rtx op, enum machine_mode mode)\n-{\n-  return register_operand (op, mode) || uns_small_int (op, mode);\n-}\n-\n-/* Return truth value of statement that OP is a call-clobbered register.  */\n-int\n-clobbered_register (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == REG && call_used_regs[REGNO (op)]);\n-}\n-\n-/* Return 1 if OP is a valid operand for the source of a move insn.  */\n-\n-int\n-input_operand (rtx op, enum machine_mode mode)\n-{\n-  enum mode_class mclass;\n-\n-  /* If both modes are non-void they must be the same.  */\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  /* Allow any one instruction integer constant, and all CONST_INT\n-     variants when we are working in DImode and !arch64.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && ((GET_CODE (op) == CONST_INT\n-\t   && (SPARC_SETHI_P (INTVAL (op) & GET_MODE_MASK (mode))\n-\t       || SPARC_SIMM13_P (INTVAL (op))\n-\t       || (mode == DImode\n-\t\t   && ! TARGET_ARCH64)))\n-\t  || (TARGET_ARCH64\n-\t      && GET_CODE (op) == CONST_DOUBLE\n-\t      && ((CONST_DOUBLE_HIGH (op) == 0\n-\t\t   && SPARC_SETHI_P (CONST_DOUBLE_LOW (op)))\n-\t\t  ||\n-#if HOST_BITS_PER_WIDE_INT == 64\n-\t\t  (CONST_DOUBLE_HIGH (op) == 0\n-\t\t   && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op)))\n-#else\n-\t\t  (SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))\n-\t\t   && (((CONST_DOUBLE_LOW (op) & 0x80000000) == 0\n-\t\t\t&& CONST_DOUBLE_HIGH (op) == 0)\n-\t\t       || (CONST_DOUBLE_HIGH (op) == -1\n-\t\t\t   && CONST_DOUBLE_LOW (op) & 0x80000000) != 0))\n-#endif\n-\t\t  ))))\n-    return 1;\n-\n-  /* If !arch64 and this is a DImode const, allow it so that\n-     the splits can be generated.  */\n-  if (! TARGET_ARCH64\n-      && mode == DImode\n-      && GET_CODE (op) == CONST_DOUBLE)\n-    return 1;\n-\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  mclass = GET_MODE_CLASS (mode);\n-  if ((mclass == MODE_FLOAT && GET_CODE (op) == CONST_DOUBLE)\n-      || (mclass == MODE_VECTOR_INT && GET_CODE (op) == CONST_VECTOR))\n-    return 1;\n-\n-  /* If this is a SUBREG, look inside so that we handle\n-     paradoxical ones.  */\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  /* Check for valid MEM forms.  */\n-  if (GET_CODE (op) == MEM)\n-    return memory_address_p (mode, XEXP (op, 0));\n-\n-  return 0;\n-}\n-\n-/* Return 1 if OP is valid for the lhs of a compare insn.  */\n-\n-int\n-compare_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == ZERO_EXTRACT)\n-    return (register_operand (XEXP (op, 0), mode)\n-\t    && small_int_or_double (XEXP (op, 1), mode)\n-\t    && small_int_or_double (XEXP (op, 2), mode)\n-\t    /* This matches cmp_zero_extract.  */\n-\t    && ((mode == SImode\n-\t\t && ((GET_CODE (XEXP (op, 2)) == CONST_INT\n-\t\t      && INTVAL (XEXP (op, 2)) > 19)\n-\t\t     || (GET_CODE (XEXP (op, 2)) == CONST_DOUBLE\n-\t\t\t && CONST_DOUBLE_LOW (XEXP (op, 2)) > 19)))\n-\t\t/* This matches cmp_zero_extract_sp64.  */\n-\t\t|| (mode == DImode\n-\t\t    && TARGET_ARCH64\n-\t\t    && ((GET_CODE (XEXP (op, 2)) == CONST_INT\n-\t\t\t && INTVAL (XEXP (op, 2)) > 51)\n-\t\t\t|| (GET_CODE (XEXP (op, 2)) == CONST_DOUBLE\n-\t\t\t    && CONST_DOUBLE_LOW (XEXP (op, 2)) > 51)))));\n-  else\n-    return register_operand (op, mode);\n-}\n-\n \f\n /* We know it can't be done in one insn when we get here,\n    the movsi expander guarantees this.  */\n@@ -1660,36 +900,22 @@ sparc_emit_set_const32 (rtx op0, rtx op1)\n   enum machine_mode mode = GET_MODE (op0);\n   rtx temp;\n \n-  if (GET_CODE (op1) == CONST_INT)\n-    {\n-      HOST_WIDE_INT value = INTVAL (op1);\n-\n-      gcc_assert (! SPARC_SETHI_P (value & GET_MODE_MASK (mode))\n-\t  \t  && ! SPARC_SIMM13_P (value));\n-    }\n-\n-  /* Full 2-insn decomposition is needed.  */\n   if (reload_in_progress || reload_completed)\n     temp = op0;\n   else\n     temp = gen_reg_rtx (mode);\n \n   if (GET_CODE (op1) == CONST_INT)\n     {\n+      gcc_assert (!small_int_operand (op1, mode)\n+\t\t  && !const_high_operand (op1, mode));\n+\n       /* Emit them as real moves instead of a HIGH/LO_SUM,\n \t this way CSE can see everything and reuse intermediate\n \t values if it wants.  */\n-      if (TARGET_ARCH64\n-\t  && HOST_BITS_PER_WIDE_INT != 64\n-\t  && (INTVAL (op1) & 0x80000000) != 0)\n-\temit_insn (gen_rtx_SET\n-\t\t   (VOIDmode, temp,\n-\t\t    immed_double_const (INTVAL (op1) & ~(HOST_WIDE_INT)0x3ff,\n-\t\t\t\t\t0, DImode)));\n-      else\n-\temit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t\tGEN_INT (INTVAL (op1)\n-\t\t\t\t\t & ~(HOST_WIDE_INT)0x3ff)));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t      GEN_INT (INTVAL (op1)\n+\t\t\t        & ~(HOST_WIDE_INT)0x3ff)));\n \n       emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t      op0,\n@@ -1703,7 +929,6 @@ sparc_emit_set_const32 (rtx op0, rtx op1)\n \t\t\t      gen_rtx_HIGH (mode, op1)));\n       emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t      op0, gen_rtx_LO_SUM (mode, temp, op1)));\n-\n     }\n }\n \n@@ -1910,6 +1135,13 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp)\n     }\n }\n \n+#if HOST_BITS_PER_WIDE_INT == 32\n+void\n+sparc_emit_set_const64 (rtx op0 ATTRIBUTE_UNUSED, rtx op1 ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+#else\n /* These avoid problems when cross compiling.  If we do not\n    go through all this hair then the optimizer will see\n    invalid REG_EQUAL notes or in some cases none at all.  */\n@@ -1918,17 +1150,6 @@ static rtx gen_safe_SET64 (rtx, HOST_WIDE_INT);\n static rtx gen_safe_OR64 (rtx, HOST_WIDE_INT);\n static rtx gen_safe_XOR64 (rtx, HOST_WIDE_INT);\n \n-#if HOST_BITS_PER_WIDE_INT == 64\n-#define GEN_HIGHINT64(__x)\t\tGEN_INT ((__x) & ~(HOST_WIDE_INT)0x3ff)\n-#define GEN_INT64(__x)\t\t\tGEN_INT (__x)\n-#else\n-#define GEN_HIGHINT64(__x) \\\n-\timmed_double_const ((__x) & ~(HOST_WIDE_INT)0x3ff, 0, DImode)\n-#define GEN_INT64(__x) \\\n-\timmed_double_const ((__x) & 0xffffffff, \\\n-\t\t\t    ((__x) & 0x80000000 ? -1 : 0), DImode)\n-#endif\n-\n /* The optimizer is not to assume anything about exactly\n    which bits are set for a HIGH, they are unspecified.\n    Unfortunately this leads to many missed optimizations\n@@ -1937,25 +1158,25 @@ static rtx gen_safe_XOR64 (rtx, HOST_WIDE_INT);\n static void\n sparc_emit_set_safe_HIGH64 (rtx dest, HOST_WIDE_INT val)\n {\n-  emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_HIGHINT64 (val)));\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_INT (val & ~(HOST_WIDE_INT)0x3ff)));\n }\n \n static rtx\n gen_safe_SET64 (rtx dest, HOST_WIDE_INT val)\n {\n-  return gen_rtx_SET (VOIDmode, dest, GEN_INT64 (val));\n+  return gen_rtx_SET (VOIDmode, dest, GEN_INT (val));\n }\n \n static rtx\n gen_safe_OR64 (rtx src, HOST_WIDE_INT val)\n {\n-  return gen_rtx_IOR (DImode, src, GEN_INT64 (val));\n+  return gen_rtx_IOR (DImode, src, GEN_INT (val));\n }\n \n static rtx\n gen_safe_XOR64 (rtx src, HOST_WIDE_INT val)\n {\n-  return gen_rtx_XOR (DImode, src, GEN_INT64 (val));\n+  return gen_rtx_XOR (DImode, src, GEN_INT (val));\n }\n \n /* Worker routines for 64-bit constant formation on arch64.\n@@ -2293,8 +1514,7 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n   if (reload_in_progress || reload_completed)\n     temp = op0;\n \n-  if (GET_CODE (op1) != CONST_DOUBLE\n-      && GET_CODE (op1) != CONST_INT)\n+  if (GET_CODE (op1) != CONST_INT)\n     {\n       sparc_emit_set_symbolic_const64 (op0, op1, temp);\n       return;\n@@ -2303,28 +1523,8 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n   if (! temp)\n     temp = gen_reg_rtx (DImode);\n \n-  if (GET_CODE (op1) == CONST_DOUBLE)\n-    {\n-#if HOST_BITS_PER_WIDE_INT == 64\n-      high_bits = (CONST_DOUBLE_LOW (op1) >> 32) & 0xffffffff;\n-      low_bits  = CONST_DOUBLE_LOW (op1) & 0xffffffff;\n-#else\n-      high_bits = CONST_DOUBLE_HIGH (op1);\n-      low_bits = CONST_DOUBLE_LOW (op1);\n-#endif\n-    }\n-  else\n-    {\n-#if HOST_BITS_PER_WIDE_INT == 64\n-      high_bits = ((INTVAL (op1) >> 32) & 0xffffffff);\n-      low_bits = (INTVAL (op1) & 0xffffffff);\n-#else\n-      high_bits = ((INTVAL (op1) < 0) ?\n-\t\t   0xffffffff :\n-\t\t   0x00000000);\n-      low_bits = INTVAL (op1);\n-#endif\n-    }\n+  high_bits = ((INTVAL (op1) >> 32) & 0xffffffff);\n+  low_bits = (INTVAL (op1) & 0xffffffff);\n \n   /* low_bits\tbits 0  --> 31\n      high_bits\tbits 32 --> 63  */\n@@ -2452,26 +1652,20 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n \t  || (((~high_bits) & 0xffffffff) == 0xffffffff\n \t      && ((~low_bits) & 0x80000000) != 0))\n \t{\n-\t  int fast_int = (~low_bits & 0xffffffff);\n+\t  unsigned HOST_WIDE_INT fast_int = (~low_bits & 0xffffffff);\n \n \t  if ((SPARC_SETHI_P (fast_int)\n \t       && (~high_bits & 0xffffffff) == 0)\n \t      || SPARC_SIMM13_P (fast_int))\n \t    emit_insn (gen_safe_SET64 (temp, fast_int));\n \t  else\n-\t    sparc_emit_set_const64 (temp, GEN_INT64 (fast_int));\n+\t    sparc_emit_set_const64 (temp, GEN_INT (fast_int));\n \t}\n       else\n \t{\n \t  rtx negated_const;\n-#if HOST_BITS_PER_WIDE_INT == 64\n \t  negated_const = GEN_INT (((~low_bits) & 0xfffffc00) |\n \t\t\t\t   (((HOST_WIDE_INT)((~high_bits) & 0xffffffff))<<32));\n-#else\n-\t  negated_const = immed_double_const ((~low_bits) & 0xfffffc00,\n-\t\t\t\t\t      (~high_bits) & 0xffffffff,\n-\t\t\t\t\t      DImode);\n-#endif\n \t  sparc_emit_set_const64 (temp, negated_const);\n \t}\n \n@@ -2536,6 +1730,7 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n #endif\n   sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits);\n }\n+#endif /* HOST_BITS_PER_WIDE_INT == 32 */\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n@@ -3448,7 +2643,7 @@ legitimate_constant_p (rtx x)\n \t  && (GET_MODE (x) == SFmode\n \t      || GET_MODE (x) == DFmode\n \t      || GET_MODE (x) == TFmode)\n-\t  && fp_zero_operand (x, GET_MODE (x)))\n+\t  && const_zero_operand (x, GET_MODE (x)))\n \treturn true;\n \n       return false;\n@@ -8643,7 +7838,7 @@ sparc_extra_constraint_check (rtx op, int c, int strict)\n       break;\n \n     case 'Y':\n-      return fp_zero_operand (op, GET_MODE (op));\n+      return const_zero_operand (op, GET_MODE (op));\n \n     default:\n       return 0;"}, {"sha": "72416913fb755c45e3a89234cb7e09bf2f1bf8df", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 22, "deletions": 64, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "patch": "@@ -1189,8 +1189,8 @@ extern char leaf_reg_remap[];\n     : (C) == 'c' ? FPCC_REGS\t\t\t\\\n     : NO_REGS))\n \n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of CONST_INTs.\n    This macro defines what the ranges are.\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n@@ -1201,20 +1201,32 @@ extern char leaf_reg_remap[];\n    `L' is used for the range of constants supported by the movcc insns.\n    `M' is used for the range of constants supported by the movrcc insns.\n    `N' is like K, but for constants wider than 32 bits.\n-   `O' is used for the range which is just 4096.  */\n+   `O' is used for the range which is just 4096.\n+   `P' is free.  */\n \n+/* Predicates for 10-bit, 11-bit and 13-bit signed constants.  */\n #define SPARC_SIMM10_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x200 < 0x400)\n #define SPARC_SIMM11_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x400 < 0x800)\n #define SPARC_SIMM13_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x1000 < 0x2000)\n-/* 10 and 11 bit immediates are only used for a few specific insns.\n+\n+/* 10- and 11-bit immediates are only used for a few specific insns.\n    SMALL_INT is used throughout the port so we continue to use it.  */\n #define SMALL_INT(X) (SPARC_SIMM13_P (INTVAL (X)))\n-/* 13 bit immediate, considering only the low 32 bits */\n-#define SMALL_INT32(X) (SPARC_SIMM13_P (trunc_int_for_mode \\\n-\t\t\t\t\t(INTVAL (X), SImode)))\n+\n+/* Predicate for constants that can be loaded with a sethi instruction.\n+   This is the general, 64-bit aware, bitwise version that ensures that\n+   only constants whose representation fits in the mask\n+\n+     0x00000000fffffc00\n+\n+   are accepted.  It will reject, for example, negative SImode constants\n+   on 64-bit hosts, so correct handling is to mask the value beforehand\n+   according to the mode of the instruction.  */\n #define SPARC_SETHI_P(X) \\\n   (((unsigned HOST_WIDE_INT) (X) \\\n     & ((unsigned HOST_WIDE_INT) 0x3ff - GET_MODE_MASK (SImode) - 1)) == 0)\n+\n+/* Version of the above predicate for SImode constants and below.  */\n #define SPARC_SETHI32_P(X) \\\n   (SPARC_SETHI_P ((unsigned HOST_WIDE_INT) (X) & GET_MODE_MASK (SImode)))\n \n@@ -1228,13 +1240,12 @@ extern char leaf_reg_remap[];\n    : (C) == 'O' ? (VALUE) == 4096\t\t\t\\\n    : 0)\n \n-/* Similar, but for floating constants, and defining letters G and H.\n+/* Similar, but for CONST_DOUBLEs, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.  */\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n-  ((C) == 'G' ? fp_zero_operand (VALUE, GET_MODE (VALUE))\t\\\n+  ((C) == 'G' ? const_zero_operand (VALUE, GET_MODE (VALUE))\t\\\n    : (C) == 'H' ? arith_double_operand (VALUE, DImode)\t\t\\\n-   : (C) == 'O' ? arith_double_4096_operand (VALUE, DImode)\t\\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -1257,7 +1268,7 @@ extern char leaf_reg_remap[];\n        || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n \t   && ! TARGET_FPU)\t\t\t\t\\\n        || (GET_MODE (X) == TFmode\t\t\t\\\n-\t   && ! fp_zero_operand (X, TFmode)))\t\t\\\n+\t   && ! const_zero_operand (X, TFmode)))\t\\\n       ? NO_REGS\t\t\t\t\t\t\\\n       : (!FP_REG_CLASS_P (CLASS)\t\t\t\\\n          && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)\t\\\n@@ -2449,58 +2460,5 @@ extern int sparc_indent_opcode;\n #define TARGET_SUN_TLS TARGET_TLS\n #define TARGET_GNU_TLS 0\n \n-/* Define the codes that are matched by predicates in sparc.c.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-{\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\\\n-{\"const1_operand\", {CONST_INT}},\t\t\t\t\t\\\n-{\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\t\\\n-{\"fp_register_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n-{\"intreg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n-{\"fcc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n-{\"fcc0_reg_operand\", {REG}},\t\t\t\t\t\t\\\n-{\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\\\n-{\"call_operand\", {MEM}},\t\t\t\t\t\t\\\n-{\"call_operand_address\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE,\t\\\n-\tSUBREG, REG, PLUS, LO_SUM, CONST_INT}},\t\t\t\t\\\n-{\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n-{\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n-{\"label_ref_operand\", {LABEL_REF}},\t\t\t\t\t\\\n-{\"sp64_medium_pic_operand\", {CONST}},\t\t\t\t\t\\\n-{\"data_segment_operand\", {SYMBOL_REF, PLUS, CONST}},\t\t\t\\\n-{\"text_segment_operand\", {LABEL_REF, SYMBOL_REF, PLUS, CONST}},\t\t\\\n-{\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-{\"splittable_symbolic_memory_operand\", {MEM}},\t\t\t\t\\\n-{\"splittable_immediate_memory_operand\", {MEM}},\t\t\t\t\\\n-{\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\\\n-{\"normal_comp_operator\", {GE, GT, LE, LT, GTU, LEU}},\t\t\t\\\n-{\"noov_compare_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\\\n-{\"noov_compare64_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\\\n-{\"v9_regcmp_op\", {EQ, NE, GE, LT, LE, GT}},\t\t\t\t\\\n-{\"extend_op\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\t\\\n-{\"cc_arithop\", {AND, IOR, XOR}},\t\t\t\t\t\\\n-{\"cc_arithopn\", {AND, IOR}},\t\t\t\t\t\t\\\n-{\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-{\"arith_add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{\"arith11_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-{\"arith10_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-{\"arith_double_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-{\"arith_double_add_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-{\"arith11_double_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-{\"arith10_double_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-{\"small_int\", {CONST_INT}},\t\t\t\t\t\t\\\n-{\"small_int_or_double\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n-{\"uns_small_int\", {CONST_INT}},\t\t\t\t\t\t\\\n-{\"uns_arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{\"clobbered_register\", {REG}},\t\t\t\t\t\t\\\n-{\"input_operand\", {SUBREG, REG, CONST_INT, MEM, CONST}},\t\t\\\n-{\"compare_operand\", {SUBREG, REG, ZERO_EXTRACT}},\t\t\t\\\n-{\"const64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\t\\\n-{\"const64_high_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n-{\"tgd_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n-{\"tld_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n-{\"tie_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n-{\"tle_symbolic_operand\", {SYMBOL_REF}},\n-\n /* The number of Pmode words for the setjmp buffer.  */\n #define JMP_BUF_SIZE 12"}, {"sha": "5b840373f1de29e6e2bc2b5fa1d2b9d162fb5ab1", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 296, "deletions": 421, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5d569cd56e49dd5be9a67d553f0c007ff5436c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=0e5d569cd56e49dd5be9a67d553f0c007ff5436c", "patch": "@@ -158,7 +158,7 @@\n \t       (const_int 2)\n \t       (const_int 1)))\n \t (eq_attr \"branch_type\" \"icc\")\n-\t   (if_then_else (match_operand 0 \"noov_compare64_op\" \"\")\n+\t   (if_then_else (match_operand 0 \"noov_compare64_operator\" \"\")\n \t     (if_then_else (lt (pc) (match_dup 1))\n \t       (if_then_else (lt (minus (match_dup 1) (pc)) (const_int 260000))\n \t\t (if_then_else (eq_attr \"empty_delay_slot\" \"true\")\n@@ -178,7 +178,7 @@\n \t       (const_int 2)\n \t       (const_int 1)))\n \t (eq_attr \"branch_type\" \"fcc\")\n-\t   (if_then_else (match_operand 0 \"fcc0_reg_operand\" \"\")\n+\t   (if_then_else (match_operand 0 \"fcc0_register_operand\" \"\")\n \t     (if_then_else (eq_attr \"empty_delay_slot\" \"true\")\n \t       (if_then_else (eq (symbol_ref \"TARGET_V9\") (const_int 0))\n \t\t (const_int 3)\n@@ -309,9 +309,12 @@\n (include \"ultra1_2.md\")\n (include \"ultra3.md\")\n \n-\f\n+;; Operand and operator predicates.\n+\n+(include \"predicates.md\")\n+\n+\n ;; Compare instructions.\n-;; This controls RTL generation and register allocation.\n \n ;; We generate RTL for comparisons and branches by having the cmpxx \n ;; patterns store away the operands.  Then, the scc and bcc patterns\n@@ -345,7 +348,7 @@\n (define_expand \"cmpdi\"\n   [(set (reg:CCX 100)\n \t(compare:CCX (match_operand:DI 0 \"compare_operand\" \"\")\n-\t\t     (match_operand:DI 1 \"arith_double_operand\" \"\")))]\n+\t\t     (match_operand:DI 1 \"arith_operand\" \"\")))]\n   \"TARGET_ARCH64\"\n {\n   if (GET_CODE (operands[0]) == ZERO_EXTRACT && operands[1] != const0_rtx)\n@@ -405,13 +408,13 @@\n (define_insn \"*cmpdi_sp64\"\n   [(set (reg:CCX 100)\n \t(compare:CCX (match_operand:DI 0 \"register_operand\" \"r\")\n-\t\t     (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))]\n+\t\t     (match_operand:DI 1 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n   \"cmp\\t%0, %1\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmpsf_fpe\"\n-  [(set (match_operand:CCFPE 0 \"fcc_reg_operand\" \"=c\")\n+  [(set (match_operand:CCFPE 0 \"fcc_register_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_FPU\"\n@@ -423,7 +426,7 @@\n   [(set_attr \"type\" \"fpcmp\")])\n \n (define_insn \"*cmpdf_fpe\"\n-  [(set (match_operand:CCFPE 0 \"fcc_reg_operand\" \"=c\")\n+  [(set (match_operand:CCFPE 0 \"fcc_register_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:DF 1 \"register_operand\" \"e\")\n \t\t       (match_operand:DF 2 \"register_operand\" \"e\")))]\n   \"TARGET_FPU\"\n@@ -436,7 +439,7 @@\n    (set_attr \"fptype\" \"double\")])\n \n (define_insn \"*cmptf_fpe\"\n-  [(set (match_operand:CCFPE 0 \"fcc_reg_operand\" \"=c\")\n+  [(set (match_operand:CCFPE 0 \"fcc_register_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t       (match_operand:TF 2 \"register_operand\" \"e\")))]\n   \"TARGET_FPU && TARGET_HARD_QUAD\"\n@@ -448,7 +451,7 @@\n   [(set_attr \"type\" \"fpcmp\")])\n \n (define_insn \"*cmpsf_fp\"\n-  [(set (match_operand:CCFP 0 \"fcc_reg_operand\" \"=c\")\n+  [(set (match_operand:CCFP 0 \"fcc_register_operand\" \"=c\")\n \t(compare:CCFP (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_FPU\"\n@@ -460,7 +463,7 @@\n   [(set_attr \"type\" \"fpcmp\")])\n \n (define_insn \"*cmpdf_fp\"\n-  [(set (match_operand:CCFP 0 \"fcc_reg_operand\" \"=c\")\n+  [(set (match_operand:CCFP 0 \"fcc_register_operand\" \"=c\")\n \t(compare:CCFP (match_operand:DF 1 \"register_operand\" \"e\")\n \t\t      (match_operand:DF 2 \"register_operand\" \"e\")))]\n   \"TARGET_FPU\"\n@@ -473,7 +476,7 @@\n    (set_attr \"fptype\" \"double\")])\n \n (define_insn \"*cmptf_fp\"\n-  [(set (match_operand:CCFP 0 \"fcc_reg_operand\" \"=c\")\n+  [(set (match_operand:CCFP 0 \"fcc_register_operand\" \"=c\")\n \t(compare:CCFP (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t      (match_operand:TF 2 \"register_operand\" \"e\")))]\n   \"TARGET_FPU && TARGET_HARD_QUAD\"\n@@ -573,7 +576,7 @@\n ;; ??? v9: Operand 0 needs a mode, so SImode was chosen.\n ;; However, the code handles both SImode and DImode.\n (define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(eq:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -625,7 +628,7 @@\n ;; ??? v9: Operand 0 needs a mode, so SImode was chosen.\n ;; However, the code handles both SImode and DImode.\n (define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(ne:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -675,7 +678,7 @@\n })\n \n (define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(gt:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -695,7 +698,7 @@\n })\n \n (define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(lt:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -715,7 +718,7 @@\n })\n \n (define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(ge:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -735,7 +738,7 @@\n })\n \n (define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(le:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -755,7 +758,7 @@\n })\n \n (define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(gtu:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -789,7 +792,7 @@\n })\n \n (define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(ltu:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -802,7 +805,7 @@\n })\n \n (define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(geu:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -815,7 +818,7 @@\n })\n \n (define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"intreg_operand\" \"\")\n+  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n \t(leu:SI (match_dup 1) (const_int 0)))]\n   \"\"\n {\n@@ -1186,7 +1189,7 @@\n ;; ??? Combine should canonicalize these next two to the same pattern.\n (define_insn \"*x_minus_y_minus_sltu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n \t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t  (ltu:SI (reg:CC 100) (const_int 0))))]\n   \"\"\n@@ -1195,7 +1198,7 @@\n \n (define_insn \"*x_minus_sltu_plus_y\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n+\t(minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n \t\t  (plus:SI (ltu:SI (reg:CC 100) (const_int 0))\n \t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n   \"\"\n@@ -1220,8 +1223,8 @@\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operator:SI 2 \"noov_compare_op\"\n-\t\t\t   [(match_operand 1 \"icc_or_fcc_reg_operand\" \"\")\n+\t(match_operator:SI 2 \"noov_compare_operator\"\n+\t\t\t   [(match_operand 1 \"icc_or_fcc_register_operand\" \"\")\n \t\t\t    (const_int 0)]))]\n   \"TARGET_V9\n    && REGNO (operands[1]) == SPARC_ICC_REG\n@@ -1556,7 +1559,7 @@\n ;; XXX fpcmp nop braindamage\n (define_insn \"*normal_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"noov_compare_op\"\n+\t(if_then_else (match_operator 0 \"noov_compare_operator\"\n \t\t\t\t      [(reg 100) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n@@ -1572,7 +1575,7 @@\n ;; XXX fpcmp nop braindamage\n (define_insn \"*inverted_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"noov_compare_op\"\n+\t(if_then_else (match_operator 0 \"noov_compare_operator\"\n \t\t\t\t      [(reg 100) (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n@@ -1589,7 +1592,7 @@\n (define_insn \"*normal_fp_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFP 0 \"fcc_reg_operand\" \"c\")\n+\t\t\t\t      [(match_operand:CCFP 0 \"fcc_register_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n@@ -1606,7 +1609,7 @@\n (define_insn \"*inverted_fp_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFP 0 \"fcc_reg_operand\" \"c\")\n+\t\t\t\t      [(match_operand:CCFP 0 \"fcc_register_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n@@ -1623,7 +1626,7 @@\n (define_insn \"*normal_fpe_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFPE 0 \"fcc_reg_operand\" \"c\")\n+\t\t\t\t      [(match_operand:CCFPE 0 \"fcc_register_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n@@ -1640,7 +1643,7 @@\n (define_insn \"*inverted_fpe_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:CCFPE 0 \"fcc_reg_operand\" \"c\")\n+\t\t\t\t      [(match_operand:CCFPE 0 \"fcc_register_operand\" \"c\")\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n@@ -1661,7 +1664,7 @@\n ;; XXX\n (define_insn \"*normal_int_branch_sp64\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"v9_regcmp_op\"\n+\t(if_then_else (match_operator 0 \"v9_register_compare_operator\"\n \t\t\t\t      [(match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n@@ -1678,7 +1681,7 @@\n ;; XXX\n (define_insn \"*inverted_int_branch_sp64\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"v9_regcmp_op\"\n+\t(if_then_else (match_operator 0 \"v9_register_compare_operator\"\n \t\t\t\t      [(match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n@@ -1699,7 +1702,7 @@\n (define_insn \"load_pcrel_sym<P:mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n \t(unspec:P [(match_operand:P 1 \"symbolic_operand\" \"\")\n-\t\t   (match_operand:P 2 \"call_operand_address\" \"\")] UNSPEC_LOAD_PCREL_SYM))\n+\t\t   (match_operand:P 2 \"call_address_operand\" \"\")] UNSPEC_LOAD_PCREL_SYM))\n    (clobber (reg:P 15))]\n   \"\"\n {\n@@ -1732,7 +1735,7 @@\n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (reg_or_0_operand (operands[1], QImode))\n+      if (register_or_zero_operand (operands[1], QImode))\n \tgoto movqi_is_ok;\n \n       if (! reload_in_progress)\n@@ -1774,7 +1777,7 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:QI 1 \"input_operand\"   \"rI,m,rJ\"))]\n   \"(register_operand (operands[0], QImode)\n-    || reg_or_0_operand (operands[1], QImode))\"\n+    || register_or_zero_operand (operands[1], QImode))\"\n   \"@\n    mov\\t%1, %0\n    ldub\\t%1, %0\n@@ -1795,7 +1798,7 @@\n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (reg_or_0_operand (operands[1], HImode))\n+      if (register_or_zero_operand (operands[1], HImode))\n \tgoto movhi_is_ok;\n \n       if (! reload_in_progress)\n@@ -1843,15 +1846,15 @@\n \n (define_insn \"*movhi_const64_special\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(match_operand:HI 1 \"const64_high_operand\" \"\"))]\n+\t(match_operand:HI 1 \"const_high_operand\" \"K\"))]\n   \"TARGET_ARCH64\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n (define_insn \"*movhi_insn\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n \t(match_operand:HI 1 \"input_operand\"   \"rI,K,m,rJ\"))]\n   \"(register_operand (operands[0], HImode)\n-    || reg_or_0_operand (operands[1], HImode))\"\n+    || register_or_zero_operand (operands[1], HImode))\"\n   \"@\n    mov\\t%1, %0\n    sethi\\t%%hi(%a1), %0\n@@ -1864,7 +1867,7 @@\n (define_insn \"*movhi_lo_sum\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(ior:HI (match_operand:HI 1 \"register_operand\" \"%r\")\n-                (match_operand:HI 2 \"small_int\" \"I\")))]\n+                (match_operand:HI 2 \"small_int_operand\" \"I\")))]\n   \"\"\n   \"or\\t%1, %2, %0\")\n \n@@ -1881,7 +1884,7 @@\n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (reg_or_0_operand (operands[1], SImode))\n+      if (register_or_zero_operand (operands[1], SImode))\n \tgoto movsi_is_ok;\n \n       if (! reload_in_progress)\n@@ -1947,15 +1950,15 @@\n ;; in a 64-bit register by sethi instructions.\n (define_insn \"*movsi_const64_special\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"const64_high_operand\" \"\"))]\n+\t(match_operand:SI 1 \"const_high_operand\" \"K\"))]\n   \"TARGET_ARCH64\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n (define_insn \"*movsi_insn\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,f,r,r,r,f,m,m,d\")\n \t(match_operand:SI 1 \"input_operand\"   \"rI,!f,K,J,m,!m,rJ,!f,J\"))]\n   \"(register_operand (operands[0], SImode)\n-    || reg_or_0_operand (operands[1], SImode))\"\n+    || register_or_zero_operand (operands[1], SImode))\"\n   \"@\n    mov\\t%1, %0\n    fmovs\\t%1, %0\n@@ -2038,7 +2041,7 @@\n   \"or\\t%1, %%lo(%a3-(%a2-.)), %0\")\n \n (define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n@@ -2186,19 +2189,11 @@\n   [(set_attr \"type\" \"store,store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n    (set_attr \"length\" \"2,*,*,2,2,2,2,*,*,2,2,2\")])\n \n-;; The following are generated by sparc_emit_set_const64\n-(define_insn \"*movdi_sp64_dbl\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (match_operand:DI 1 \"const64_operand\" \"\"))]\n-  \"(TARGET_ARCH64\n-    && HOST_BITS_PER_WIDE_INT != 64)\"\n-  \"mov\\t%1, %0\")\n-\n ;; This is needed to show CSE exactly which bits are set\n ;; in a 64-bit register by sethi instructions.\n (define_insn \"*movdi_const64_special\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"const64_high_operand\" \"\"))]\n+\t(match_operand:DI 1 \"const_high_operand\" \"N\"))]\n   \"TARGET_ARCH64\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n@@ -2207,7 +2202,7 @@\n         (match_operand:DI 1 \"input_operand\"   \"rI,N,J,m,rJ,e,W,e\"))]\n   \"TARGET_ARCH64 && ! TARGET_VIS\n    && (register_operand (operands[0], DImode)\n-       || reg_or_0_operand (operands[1], DImode))\"\n+       || register_or_zero_operand (operands[1], DImode))\"\n   \"@\n    mov\\t%1, %0\n    sethi\\t%%hi(%a1), %0\n@@ -2229,7 +2224,7 @@\n         (match_operand:DI 1 \"input_operand\"   \"rI,N,J,m,rJ,e,W,e,J\"))]\n   \"TARGET_ARCH64 && TARGET_VIS &&\n    (register_operand (operands[0], DImode)\n-    || reg_or_0_operand (operands[1], DImode))\"\n+    || register_or_zero_operand (operands[1], DImode))\"\n   \"@\n    mov\\t%1, %0\n    sethi\\t%%hi(%a1), %0\n@@ -2302,7 +2297,7 @@\n \n (define_insn \"*sethi_di_medlow_embmedany_pic\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (high:DI (match_operand:DI 1 \"sp64_medium_pic_operand\" \"\")))]\n+        (high:DI (match_operand:DI 1 \"medium_pic_operand\" \"\")))]\n   \"(TARGET_CM_MEDLOW || TARGET_CM_EMBMEDANY) && check_pic (1)\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n@@ -2604,7 +2599,7 @@\n   \"(TARGET_FPU && ! TARGET_VIS)\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode)\n-       || fp_zero_operand (operands[1], SFmode))\"\n+       || const_zero_operand (operands[1], SFmode))\"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && (which_alternative == 2\n@@ -2649,7 +2644,7 @@\n   \"(TARGET_FPU && TARGET_VIS)\n    && (register_operand (operands[0], <V32:MODE>mode)\n        || register_operand (operands[1], <V32:MODE>mode)\n-       || fp_zero_operand (operands[1], <V32:MODE>mode))\"\n+       || const_zero_operand (operands[1], <V32:MODE>mode))\"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && (which_alternative == 3\n@@ -2700,7 +2695,7 @@\n   \"! TARGET_FPU\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode)\n-       || fp_zero_operand (operands[1], SFmode))\"\n+       || const_zero_operand (operands[1], SFmode))\"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && (which_alternative == 1\n@@ -2791,7 +2786,7 @@\n         operands[1] = CONST0_RTX (<V32:MODE>mode);\n \n       if ((TARGET_VIS || REGNO (operands[0]) < 32)\n-\t  && fp_zero_operand (operands[1], <V32:MODE>mode))\n+\t  && const_zero_operand (operands[1], <V32:MODE>mode))\n \tgoto movsf_is_ok;\n \n       /* We are able to build any SF constant in integer registers\n@@ -2808,7 +2803,7 @@\n   if (GET_CODE (operands[0]) == MEM)\n     {\n       if (register_operand (operands[1], <V32:MODE>mode)\n-\t  || fp_zero_operand (operands[1], <V32:MODE>mode))\n+\t  || const_zero_operand (operands[1], <V32:MODE>mode))\n \tgoto movsf_is_ok;\n \n       if (! reload_in_progress)\n@@ -2855,7 +2850,7 @@\n         operands[1] = CONST0_RTX (<V64:MODE>mode);\n \n       if ((TARGET_VIS || REGNO (operands[0]) < 32)\n-\t  && fp_zero_operand (operands[1], <V64:MODE>mode))\n+\t  && const_zero_operand (operands[1], <V64:MODE>mode))\n \tgoto movdf_is_ok;\n \n       /* We are able to build any DF constant in integer registers.  */\n@@ -2872,7 +2867,7 @@\n   if (GET_CODE (operands[0]) == MEM)\n     {\n       if (register_operand (operands[1], <V64:MODE>mode)\n-\t  || fp_zero_operand (operands[1], <V64:MODE>mode))\n+\t  || const_zero_operand (operands[1], <V64:MODE>mode))\n \tgoto movdf_is_ok;\n \n       if (! reload_in_progress)\n@@ -2911,7 +2906,7 @@\n    && ! TARGET_V9\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+       || const_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\t%1, %0\n   std\\t%1, %0\n@@ -2934,7 +2929,7 @@\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+       || const_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\t%1, %0\n   std\\t%1, %0\n@@ -2952,7 +2947,7 @@\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+       || const_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\t%1, %0\n   std\\t%1, %0\n@@ -2973,7 +2968,7 @@\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+       || const_zero_operand (operands[1], DFmode))\"\n   \"@\n   fmovd\\t%1, %0\n   ldd\\t%1, %0\n@@ -2998,7 +2993,7 @@\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], <V64:MODE>mode)\n        || register_operand (operands[1], <V64:MODE>mode)\n-       || fp_zero_operand (operands[1], <V64:MODE>mode))\"\n+       || const_zero_operand (operands[1], <V64:MODE>mode))\"\n   \"@\n   fzero\\t%0\n   fmovd\\t%1, %0\n@@ -3024,7 +3019,7 @@\n    && TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+       || const_zero_operand (operands[1], DFmode))\"\n   \"@\n   fmovd\\t%1, %0\n   ldd\\t%1, %0\n@@ -3047,7 +3042,7 @@\n    && TARGET_ARCH64\n    && (register_operand (operands[0], <V64:MODE>mode)\n        || register_operand (operands[1], <V64:MODE>mode)\n-       || fp_zero_operand (operands[1], <V64:MODE>mode))\"\n+       || const_zero_operand (operands[1], <V64:MODE>mode))\"\n   \"@\n   fzero\\t%0\n   fmovd\\t%1, %0\n@@ -3068,7 +3063,7 @@\n    && TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n-       || fp_zero_operand (operands[1], DFmode))\"\n+       || const_zero_operand (operands[1], DFmode))\"\n   \"@\n   mov\\t%1, %0\n   ldx\\t%1, %0\n@@ -3082,7 +3077,7 @@\n   \"TARGET_FPU\n    && (GET_CODE (operands[0]) == REG\n        && REGNO (operands[0]) < 32)\n-   && ! fp_zero_operand(operands[1], DFmode)\n+   && ! const_zero_operand(operands[1], DFmode)\n    && reload_completed\"\n   [(clobber (const_int 0))]\n {\n@@ -3243,7 +3238,7 @@\n \n (define_split\n   [(set (match_operand:V64 0 \"memory_operand\" \"\")\n-        (match_operand:V64 1 \"fp_zero_operand\" \"\"))]\n+        (match_operand:V64 1 \"const_zero_operand\" \"\"))]\n   \"reload_completed\n    && (! TARGET_V9\n        || (! TARGET_ARCH64\n@@ -3270,7 +3265,7 @@\n \n (define_split\n   [(set (match_operand:V64 0 \"register_operand\" \"\")\n-        (match_operand:V64 1 \"fp_zero_operand\" \"\"))]\n+        (match_operand:V64 1 \"const_zero_operand\" \"\"))]\n   \"reload_completed\n    && ! TARGET_ARCH64\n    && ((GET_CODE (operands[0]) == REG\n@@ -3312,7 +3307,7 @@\n       if (operands [1] == const0_rtx)\n         operands[1] = CONST0_RTX (TFmode);\n \n-      if (TARGET_VIS && fp_zero_operand (operands[1], TFmode))\n+      if (TARGET_VIS && const_zero_operand (operands[1], TFmode))\n \tgoto movtf_is_ok;\n \n       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n@@ -3324,7 +3319,7 @@\n   if (GET_CODE (operands[0]) == MEM)\n     {\n       if (register_operand (operands[1], TFmode)\n-\t  || fp_zero_operand (operands[1], TFmode))\n+\t  || const_zero_operand (operands[1], TFmode))\n \tgoto movtf_is_ok;\n \n       if (! reload_in_progress)\n@@ -3365,7 +3360,7 @@\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -3377,7 +3372,7 @@\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -3392,7 +3387,7 @@\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -3407,7 +3402,7 @@\n    && TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"@\n   fmovq\\t%1, %0\n   ldq\\t%1, %0\n@@ -3426,7 +3421,7 @@\n    && TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"@\n   fmovq\\t%1, %0\n   ldq\\t%1, %0\n@@ -3448,7 +3443,7 @@\n    && ! TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3461,7 +3456,7 @@\n    && ! TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3472,7 +3467,7 @@\n    && TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode)\n-       || fp_zero_operand (operands[1], TFmode))\"\n+       || const_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3514,7 +3509,7 @@\n \n (define_split\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:TF 1 \"fp_zero_operand\" \"\"))]\n+        (match_operand:TF 1 \"const_zero_operand\" \"\"))]\n   \"reload_completed\"\n   [(clobber (const_int 0))]\n {\n@@ -3689,8 +3684,8 @@\n (define_expand \"movdicc\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:DI 2 \"arith10_double_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"arith10_double_operand\" \"\")))]\n+\t\t\t (match_operand:DI 2 \"arith10_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"arith10_operand\" \"\")))]\n   \"TARGET_ARCH64\"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n@@ -3804,7 +3799,7 @@\n (define_insn \"*movqi_cc_sp64\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:QI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:QI 3 \"arith11_operand\" \"rL,0\")\n                          (match_operand:QI 4 \"arith11_operand\" \"0,rL\")))]\n@@ -3817,7 +3812,7 @@\n (define_insn \"*movhi_cc_sp64\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:HI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:HI 3 \"arith11_operand\" \"rL,0\")\n                          (match_operand:HI 4 \"arith11_operand\" \"0,rL\")))]\n@@ -3830,7 +3825,7 @@\n (define_insn \"*movsi_cc_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:SI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:SI 3 \"arith11_operand\" \"rL,0\")\n                          (match_operand:SI 4 \"arith11_operand\" \"0,rL\")))]\n@@ -3840,14 +3835,13 @@\n    mov%c1\\t%x2, %4, %0\"\n   [(set_attr \"type\" \"cmove\")])\n \n-;; ??? The constraints of operands 3,4 need work.\n (define_insn \"*movdi_cc_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:DI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:DI 3 \"arith11_double_operand\" \"rLH,0\")\n-                         (match_operand:DI 4 \"arith11_double_operand\" \"0,rLH\")))]\n+                         (match_operand:DI 3 \"arith11_operand\" \"rL,0\")\n+                         (match_operand:DI 4 \"arith11_operand\" \"0,rL\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    mov%C1\\t%x2, %3, %0\n@@ -3857,10 +3851,10 @@\n (define_insn \"*movdi_cc_sp64_trunc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:SI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:SI 3 \"arith11_double_operand\" \"rLH,0\")\n-                         (match_operand:SI 4 \"arith11_double_operand\" \"0,rLH\")))]\n+                         (match_operand:SI 3 \"arith11_operand\" \"rL,0\")\n+                         (match_operand:SI 4 \"arith11_operand\" \"0,rL\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    mov%C1\\t%x2, %3, %0\n@@ -3870,7 +3864,7 @@\n (define_insn \"*movsf_cc_sp64\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:SF (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:SF 3 \"register_operand\" \"f,0\")\n                          (match_operand:SF 4 \"register_operand\" \"0,f\")))]\n@@ -3883,7 +3877,7 @@\n (define_insn \"movdf_cc_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:DF (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:DF 3 \"register_operand\" \"e,0\")\n                          (match_operand:DF 4 \"register_operand\" \"0,e\")))]\n@@ -3897,7 +3891,7 @@\n (define_insn \"*movtf_cc_hq_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:TF 3 \"register_operand\" \"e,0\")\n                          (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n@@ -3910,7 +3904,7 @@\n (define_insn_and_split \"*movtf_cc_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n-\t\t\t    [(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t    [(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t     (const_int 0)])\n                          (match_operand:TF 3 \"register_operand\" \"e,0\")\n                          (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n@@ -3952,7 +3946,7 @@\n \n (define_insn \"*movqi_cc_reg_sp64\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:QI (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:QI (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:QI 3 \"arith10_operand\" \"rM,0\")\n@@ -3965,7 +3959,7 @@\n \n (define_insn \"*movhi_cc_reg_sp64\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:HI (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:HI (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:HI 3 \"arith10_operand\" \"rM,0\")\n@@ -3978,7 +3972,7 @@\n \n (define_insn \"*movsi_cc_reg_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SI (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:SI (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:SI 3 \"arith10_operand\" \"rM,0\")\n@@ -3989,27 +3983,13 @@\n    movr%d1\\t%2, %r4, %0\"\n   [(set_attr \"type\" \"cmove\")])\n \n-;; ??? The constraints of operands 3,4 need work.\n (define_insn \"*movdi_cc_reg_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:DI (match_operator 1 \"v9_regcmp_op\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:DI 3 \"arith10_double_operand\" \"rMH,0\")\n-                         (match_operand:DI 4 \"arith10_double_operand\" \"0,rMH\")))]\n-  \"TARGET_ARCH64\"\n-  \"@\n-   movr%D1\\t%2, %r3, %0\n-   movr%d1\\t%2, %r4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movdi_cc_reg_sp64_trunc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SI (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:DI (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:SI 3 \"arith10_double_operand\" \"rMH,0\")\n-                         (match_operand:SI 4 \"arith10_double_operand\" \"0,rMH\")))]\n+                         (match_operand:DI 3 \"arith10_operand\" \"rM,0\")\n+                         (match_operand:DI 4 \"arith10_operand\" \"0,rM\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    movr%D1\\t%2, %r3, %0\n@@ -4018,7 +3998,7 @@\n \n (define_insn \"*movsf_cc_reg_sp64\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:SF (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:SF (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:SF 3 \"register_operand\" \"f,0\")\n@@ -4031,7 +4011,7 @@\n \n (define_insn \"movdf_cc_reg_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n-\t(if_then_else:DF (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:DF (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:DF 3 \"register_operand\" \"e,0\")\n@@ -4045,7 +4025,7 @@\n \n (define_insn \"*movtf_cc_reg_hq_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(if_then_else:TF (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:TF 3 \"register_operand\" \"e,0\")\n@@ -4058,7 +4038,7 @@\n \n (define_insn_and_split \"*movtf_cc_reg_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(if_then_else:TF (match_operator 1 \"v9_regcmp_op\"\n+\t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:TF 3 \"register_operand\" \"e,0\")\n@@ -4573,23 +4553,14 @@\n   [(set (reg:CC 100)\n \t(compare:CC\n \t (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"small_int_or_double\" \"n\")\n-\t\t\t  (match_operand:SI 2 \"small_int_or_double\" \"n\"))\n+\t\t\t  (match_operand:SI 1 \"small_int_operand\" \"I\")\n+\t\t\t  (match_operand:SI 2 \"small_int_operand\" \"I\"))\n \t (const_int 0)))]\n-  \"(GET_CODE (operands[2]) == CONST_INT\n-    && INTVAL (operands[2]) > 19)\n-   || (GET_CODE (operands[2]) == CONST_DOUBLE\n-       && CONST_DOUBLE_LOW (operands[2]) > 19)\"\n-{\n-  int len = (GET_CODE (operands[1]) == CONST_INT\n-             ? INTVAL (operands[1])\n-             : CONST_DOUBLE_LOW (operands[1]));\n-  int pos = 32 -\n-            (GET_CODE (operands[2]) == CONST_INT\n-             ? INTVAL (operands[2])\n-             : CONST_DOUBLE_LOW (operands[2])) - len;\n+  \"INTVAL (operands[2]) > 19\"\n+{\n+  int len = INTVAL (operands[1]);\n+  int pos = 32 - INTVAL (operands[2]) - len;\n   HOST_WIDE_INT mask = ((1 << len) - 1) << pos;\n-\n   operands[1] = GEN_INT (mask);\n   return \"andcc\\t%0, %1, %%g0\";\n }\n@@ -4599,24 +4570,14 @@\n   [(set (reg:CCX 100)\n \t(compare:CCX\n \t (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"small_int_or_double\" \"n\")\n-\t\t\t  (match_operand:SI 2 \"small_int_or_double\" \"n\"))\n+\t\t\t  (match_operand:SI 1 \"small_int_operand\" \"I\")\n+\t\t\t  (match_operand:SI 2 \"small_int_operand\" \"I\"))\n \t (const_int 0)))]\n-  \"TARGET_ARCH64\n-   && ((GET_CODE (operands[2]) == CONST_INT\n-        && INTVAL (operands[2]) > 51)\n-       || (GET_CODE (operands[2]) == CONST_DOUBLE\n-           && CONST_DOUBLE_LOW (operands[2]) > 51))\"\n-{\n-  int len = (GET_CODE (operands[1]) == CONST_INT\n-             ? INTVAL (operands[1])\n-             : CONST_DOUBLE_LOW (operands[1]));\n-  int pos = 64 -\n-            (GET_CODE (operands[2]) == CONST_INT\n-             ? INTVAL (operands[2])\n-             : CONST_DOUBLE_LOW (operands[2])) - len;\n+  \"TARGET_ARCH64 && INTVAL (operands[2]) > 51\"\n+{\n+  int len = INTVAL (operands[1]);\n+  int pos = 64 - INTVAL (operands[2]) - len;\n   HOST_WIDE_INT mask = (((unsigned HOST_WIDE_INT) 1 << len) - 1) << pos;\n-\n   operands[1] = GEN_INT (mask);\n   return \"andcc\\t%0, %1, %%g0\";\n }\n@@ -4874,8 +4835,8 @@\n \t(unsigned_fix:DI (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n   \"emit_tfmode_cvt (UNSIGNED_FIX, operands); DONE;\")\n-\f\n-;;- arithmetic instructions\n+\n+;; Integer Addition/Substraction.\n \n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4897,7 +4858,7 @@\n \n (define_insn_and_split \"adddi3_insn_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n \t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n    (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64\"\n@@ -4933,45 +4894,10 @@\n }\n   [(set_attr \"length\" \"2\")])\n \n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(minus:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t  (match_operand:DI 2 \"arith_double_operand\" \"\")))\n-   (clobber (reg:CC 100))]\n-  \"! TARGET_ARCH64 && reload_completed\"\n-  [(parallel [(set (reg:CC_NOOV 100)\n-\t\t   (compare:CC_NOOV (minus:SI (match_dup 4)\n-\t\t\t\t\t      (match_dup 5))\n-\t\t\t\t    (const_int 0)))\n-\t      (set (match_dup 3)\n-\t\t   (minus:SI (match_dup 4) (match_dup 5)))])\n-   (set (match_dup 6)\n-\t(minus:SI (minus:SI (match_dup 7)\n-\t\t\t    (match_dup 8))\n-\t\t  (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n-{\n-  operands[3] = gen_lowpart (SImode, operands[0]);\n-  operands[4] = gen_lowpart (SImode, operands[1]);\n-  operands[5] = gen_lowpart (SImode, operands[2]);\n-  operands[6] = gen_highpart (SImode, operands[0]);\n-  operands[7] = gen_highpart (SImode, operands[1]);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      if (INTVAL (operands[2]) < 0)\n-\toperands[8] = constm1_rtx;\n-      else\n-\toperands[8] = const0_rtx;\n-    }\n-  else\n-#endif\n-    operands[8] = gen_highpart_mode (SImode, DImode, operands[2]);\n-})\n-\n ;; LTU here means \"carry set\"\n (define_insn \"addx\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t(plus:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n \t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n   \"\"\n@@ -4981,7 +4907,7 @@\n (define_insn_and_split \"*addx_extend_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (plus:SI (plus:SI\n-                                  (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n+                                  (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ\")\n                                   (match_operand:SI 2 \"arith_operand\" \"rI\"))\n                                  (ltu:SI (reg:CC_NOOV 100) (const_int 0)))))]\n   \"! TARGET_ARCH64\"\n@@ -4996,46 +4922,13 @@\n \n (define_insn \"*addx_extend_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (plus:SI (plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n+\t(zero_extend:DI (plus:SI (plus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ\")\n                                           (match_operand:SI 2 \"arith_operand\" \"rI\"))\n                                  (ltu:SI (reg:CC_NOOV 100) (const_int 0)))))]\n   \"TARGET_ARCH64\"\n   \"addx\\t%r1, %2, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"subx\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-\t\t  (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n-  \"\"\n-  \"subx\\t%r1, %2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n-(define_insn \"*subx_extend_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (minus:SI (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-                                            (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-                                  (ltu:SI (reg:CC_NOOV 100) (const_int 0)))))]\n-  \"TARGET_ARCH64\"\n-  \"subx\\t%r1, %2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n-(define_insn_and_split \"*subx_extend\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (minus:SI (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-                                            (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-                                  (ltu:SI (reg:CC_NOOV 100) (const_int 0)))))]\n-  \"! TARGET_ARCH64\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 3) (minus:SI (minus:SI (match_dup 1) (match_dup 2))\n-                                (ltu:SI (reg:CC_NOOV 100) (const_int 0))))\n-   (set (match_dup 4) (const_int 0))]\n-  \"operands[3] = gen_lowpart (SImode, operands[0]);\n-   operands[4] = gen_highpart (SImode, operands[0]);\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn_and_split \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (plus:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n@@ -5060,7 +4953,7 @@\n (define_insn \"*adddi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:DI 2 \"arith_double_add_operand\" \"rHI,O\")))]\n+\t\t (match_operand:DI 2 \"arith_add_operand\" \"rI,O\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    add\\t%1, %2, %0\n@@ -5080,7 +4973,7 @@\n \n (define_insn \"*cmp_cc_plus\"\n   [(set (reg:CC_NOOV 100)\n-\t(compare:CC_NOOV (plus:SI (match_operand:SI 0 \"arith_operand\" \"%r\")\n+\t(compare:CC_NOOV (plus:SI (match_operand:SI 0 \"register_operand\" \"%r\")\n \t\t\t\t  (match_operand:SI 1 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))]\n   \"\"\n@@ -5089,16 +4982,16 @@\n \n (define_insn \"*cmp_ccx_plus\"\n   [(set (reg:CCX_NOOV 100)\n-\t(compare:CCX_NOOV (plus:DI (match_operand:DI 0 \"arith_double_operand\" \"%r\")\n-\t\t\t\t   (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n+\t(compare:CCX_NOOV (plus:DI (match_operand:DI 0 \"register_operand\" \"%r\")\n+\t\t\t\t   (match_operand:DI 1 \"arith_operand\" \"rI\"))\n \t\t\t  (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"addcc\\t%0, %1, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_plus_set\"\n   [(set (reg:CC_NOOV 100)\n-\t(compare:CC_NOOV (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t(compare:CC_NOOV (plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n \t\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -5109,8 +5002,8 @@\n \n (define_insn \"*cmp_ccx_plus_set\"\n   [(set (reg:CCX_NOOV 100)\n-\t(compare:CCX_NOOV (plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t\t\t   (match_operand:DI 2 \"arith_double_operand\" \"rHI\"))\n+\t(compare:CCX_NOOV (plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t\t\t   (match_operand:DI 2 \"arith_operand\" \"rI\"))\n \t\t\t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_dup 1) (match_dup 2)))]\n@@ -5136,62 +5029,77 @@\n     }\n })\n \n-(define_insn_and_split \"*subdi3_sp32\"\n+(define_insn_and_split \"subdi3_insn_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n    (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64\"\n   \"#\"\n-  \"&& reload_completed\n-   && (GET_CODE (operands[2]) == CONST_INT\n-       || GET_CODE (operands[2]) == CONST_DOUBLE)\"\n-  [(clobber (const_int 0))]\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:CC_NOOV 100)\n+\t\t   (compare:CC_NOOV (minus:SI (match_dup 4)\n+\t\t\t\t\t      (match_dup 5))\n+\t\t\t\t    (const_int 0)))\n+\t      (set (match_dup 3)\n+\t\t   (minus:SI (match_dup 4) (match_dup 5)))])\n+   (set (match_dup 6)\n+\t(minus:SI (minus:SI (match_dup 7)\n+\t\t\t    (match_dup 8))\n+\t\t  (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n {\n-  rtx highp, lowp;\n-\n-  highp = gen_highpart_mode (SImode, DImode, operands[2]);\n-  lowp = gen_lowpart (SImode, operands[2]);\n-  if ((lowp == const0_rtx)\n-      && (operands[0] == operands[1]))\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+  operands[4] = gen_lowpart (SImode, operands[1]);\n+  operands[5] = gen_lowpart (SImode, operands[2]);\n+  operands[6] = gen_highpart (SImode, operands[0]);\n+  operands[7] = gen_highpart (SImode, operands[1]);\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode,\n-                              gen_highpart (SImode, operands[0]),\n-                              gen_rtx_MINUS (SImode,\n-                                             gen_highpart_mode (SImode, DImode,\n-\t\t\t\t\t\t\t\toperands[1]),\n-                                             highp)));\n+      if (INTVAL (operands[2]) < 0)\n+\toperands[8] = constm1_rtx;\n+      else\n+\toperands[8] = const0_rtx;\n     }\n   else\n-    {\n-      emit_insn (gen_cmp_minus_cc_set (gen_lowpart (SImode, operands[0]),\n-                                       gen_lowpart (SImode, operands[1]),\n-                                       lowp));\n-      emit_insn (gen_subx (gen_highpart (SImode, operands[0]),\n-                           gen_highpart_mode (SImode, DImode, operands[1]),\n-                           highp));\n-    }\n-  DONE;\n+#endif\n+    operands[8] = gen_highpart_mode (SImode, DImode, operands[2]);\n }\n   [(set_attr \"length\" \"2\")])\n \n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-        (minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-                  (match_operand:DI 2 \"register_operand\" \"\")))\n-   (clobber (reg:CC 100))]\n-  \"! TARGET_ARCH64\n-   && reload_completed\"\n-  [(clobber (const_int 0))]\n-{\n-  emit_insn (gen_cmp_minus_cc_set (gen_lowpart (SImode, operands[0]),\n-                                   gen_lowpart (SImode, operands[1]),\n-                                   gen_lowpart (SImode, operands[2])));\n-  emit_insn (gen_subx (gen_highpart (SImode, operands[0]),\n-                       gen_highpart (SImode, operands[1]),\n-                       gen_highpart (SImode, operands[2])));\n-  DONE;\n-})\n+;; LTU here means \"carry set\"\n+(define_insn \"subx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t  (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n+  \"\"\n+  \"subx\\t%r1, %2, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*subx_extend_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                                            (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+                                  (ltu:SI (reg:CC_NOOV 100) (const_int 0)))))]\n+  \"TARGET_ARCH64\"\n+  \"subx\\t%r1, %2, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn_and_split \"*subx_extend\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                                            (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+                                  (ltu:SI (reg:CC_NOOV 100) (const_int 0)))))]\n+  \"! TARGET_ARCH64\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3) (minus:SI (minus:SI (match_dup 1) (match_dup 2))\n+                                (ltu:SI (reg:CC_NOOV 100) (const_int 0))))\n+   (set (match_dup 4) (const_int 0))]\n+  \"operands[3] = gen_lowpart (SImode, operands[0]);\n+   operands[4] = gen_highpart (SImode, operands[0]);\"\n+  [(set_attr \"length\" \"2\")])\n \n (define_insn_and_split \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -5217,7 +5125,7 @@\n (define_insn \"*subdi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n-\t\t  (match_operand:DI 2 \"arith_double_add_operand\" \"rHI,O\")))]\n+\t\t  (match_operand:DI 2 \"arith_add_operand\" \"rI,O\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    sub\\t%1, %2, %0\n@@ -5237,7 +5145,7 @@\n \n (define_insn \"*cmp_minus_cc\"\n   [(set (reg:CC_NOOV 100)\n-\t(compare:CC_NOOV (minus:SI (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n+\t(compare:CC_NOOV (minus:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n \t\t\t\t   (match_operand:SI 1 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))]\n   \"\"\n@@ -5247,15 +5155,15 @@\n (define_insn \"*cmp_minus_ccx\"\n   [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (minus:DI (match_operand:DI 0 \"register_operand\" \"r\")\n-\t\t\t\t    (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n+\t\t\t\t    (match_operand:DI 1 \"arith_operand\" \"rI\"))\n \t\t\t  (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"subcc\\t%0, %1, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"cmp_minus_cc_set\"\n   [(set (reg:CC_NOOV 100)\n-\t(compare:CC_NOOV (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n+\t(compare:CC_NOOV (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n \t\t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t\t (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -5267,7 +5175,7 @@\n (define_insn \"*cmp_minus_ccx_set\"\n   [(set (reg:CCX_NOOV 100)\n \t(compare:CCX_NOOV (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t    (match_operand:DI 2 \"arith_double_operand\" \"rHI\"))\n+\t\t\t\t    (match_operand:DI 2 \"arith_operand\" \"rI\"))\n \t\t\t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_dup 1) (match_dup 2)))]\n@@ -5289,9 +5197,9 @@\n   [(set_attr \"type\" \"imul\")])\n \n (define_expand \"muldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(mult:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(mult:DI (match_operand:DI 1 \"arith_operand\" \"\")\n+\t\t (match_operand:DI 2 \"arith_operand\" \"\")))]\n   \"TARGET_ARCH64 || TARGET_V8PLUS\"\n {\n   if (TARGET_V8PLUS)\n@@ -5303,8 +5211,8 @@\n \n (define_insn \"*muldi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(mult:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+\t(mult:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n   \"mulx\\t%1, %2, %0\"\n   [(set_attr \"type\" \"imul\")])\n@@ -5313,8 +5221,8 @@\n ;; XXX\n (define_insn \"muldi3_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,h\")\n-\t(mult:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,0\")\n-\t\t (match_operand:DI 2 \"arith_double_operand\" \"rI,rI\")))\n+\t(mult:DI (match_operand:DI 1 \"arith_operand\" \"%r,0\")\n+\t\t (match_operand:DI 2 \"arith_operand\" \"rI,rI\")))\n    (clobber (match_scratch:SI 3 \"=&h,X\"))\n    (clobber (match_scratch:SI 4 \"=&h,X\"))]\n   \"TARGET_V8PLUS\"\n@@ -5403,7 +5311,7 @@\n (define_insn \"const_mulsidi3_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=h,r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n-\t\t (match_operand:DI 2 \"small_int\" \"I,I\")))\n+\t\t (match_operand:DI 2 \"small_int_operand\" \"I,I\")))\n    (clobber (match_scratch:SI 3 \"=X,&h\"))]\n   \"TARGET_V8PLUS\"\n   \"@\n@@ -5444,7 +5352,7 @@\n (define_insn \"const_mulsidi3_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DI 2 \"small_int\" \"I\")))]\n+\t\t (match_operand:DI 2 \"small_int_operand\" \"I\")))]\n   \"TARGET_HARD_MUL32\"\n {\n   return TARGET_SPARCLET\n@@ -5461,7 +5369,7 @@\n (define_insn \"const_mulsidi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DI 2 \"small_int\" \"I\")))]\n+\t\t (match_operand:DI 2 \"small_int_operand\" \"I\")))]\n   \"TARGET_DEPRECATED_V8_INSNS && TARGET_ARCH64\"\n   \"smul\\t%1, %2, %0\"\n   [(set_attr \"type\" \"imul\")])\n@@ -5501,7 +5409,7 @@\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\")))\n-\t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n+\t\t      (match_operand:SI 3 \"small_int_operand\" \"I,I\"))))\n    (clobber (match_scratch:SI 4 \"=X,&h\"))]\n   \"TARGET_V8PLUS\"\n   \"@\n@@ -5518,7 +5426,7 @@\n \t (lshiftrt:DI\n \t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n \t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\")))\n-\t  (match_operand:SI 3 \"const_int_operand\" \"i,i\"))\n+\t  (match_operand:SI 3 \"small_int_operand\" \"I,I\"))\n \t 4))\n    (clobber (match_scratch:SI 4 \"=X,&h\"))]\n   \"TARGET_V8PLUS\"\n@@ -5533,8 +5441,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=h,r\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n-\t\t\t       (match_operand:DI 2 \"small_int\" \"i,i\"))\n-\t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n+\t\t\t       (match_operand:DI 2 \"small_int_operand\" \"I,I\"))\n+\t\t      (match_operand:SI 3 \"small_int_operand\" \"I,I\"))))\n    (clobber (match_scratch:SI 4 \"=X,&h\"))]\n   \"TARGET_V8PLUS\"\n   \"@\n@@ -5560,7 +5468,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t\t       (match_operand:DI 2 \"small_int\" \"i\"))\n+\t\t\t       (match_operand:DI 2 \"small_int_operand\" \"i\"))\n \t\t      (const_int 32))))]\n   \"TARGET_HARD_MUL32\"\n   \"smul\\t%1, %2, %%g0\\n\\trd\\t%%y, %0\"\n@@ -5638,7 +5546,7 @@\n (define_insn \"const_umulsidi3_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DI 2 \"uns_small_int\" \"\")))]\n+\t\t (match_operand:DI 2 \"uns_small_int_operand\" \"\")))]\n   \"TARGET_HARD_MUL32\"\n {\n   return TARGET_SPARCLET\n@@ -5655,7 +5563,7 @@\n (define_insn \"const_umulsidi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DI 2 \"uns_small_int\" \"\")))]\n+\t\t (match_operand:DI 2 \"uns_small_int_operand\" \"\")))]\n   \"TARGET_DEPRECATED_V8_INSNS && TARGET_ARCH64\"\n   \"umul\\t%1, %s2, %0\"\n   [(set_attr \"type\" \"imul\")])\n@@ -5664,7 +5572,7 @@\n (define_insn \"const_umulsidi3_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=h,r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n-\t\t (match_operand:DI 2 \"uns_small_int\" \"\")))\n+\t\t (match_operand:DI 2 \"uns_small_int_operand\" \"\")))\n    (clobber (match_scratch:SI 3 \"=X,h\"))]\n   \"TARGET_V8PLUS\"\n   \"@\n@@ -5708,7 +5616,7 @@\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\")))\n-\t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n+\t\t      (match_operand:SI 3 \"small_int_operand\" \"I,I\"))))\n    (clobber (match_scratch:SI 4 \"=X,h\"))]\n   \"TARGET_V8PLUS\"\n   \"@\n@@ -5722,8 +5630,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=h,r\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n-\t\t\t       (match_operand:DI 2 \"uns_small_int\" \"\"))\n-\t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n+\t\t\t       (match_operand:DI 2 \"uns_small_int_operand\" \"\"))\n+\t\t      (match_operand:SI 3 \"small_int_operand\" \"I,I\"))))\n    (clobber (match_scratch:SI 4 \"=X,h\"))]\n   \"TARGET_V8PLUS\"\n   \"@\n@@ -5749,15 +5657,15 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t\t       (match_operand:DI 2 \"uns_small_int\" \"\"))\n+\t\t\t       (match_operand:DI 2 \"uns_small_int_operand\" \"\"))\n \t\t      (const_int 32))))]\n   \"TARGET_HARD_MUL32\"\n   \"umul\\t%1, %s2, %%g0\\n\\trd\\t%%y, %0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2\")])\n \n-;; The v8 architecture specifies that there must be 3 instructions between\n-;; a y register write and a use of it for correct results.\n+;; The V8 architecture specifies that there must be 3 instructions between\n+;; a Y register write and a use of it for correct results.\n \n (define_expand \"divsi3\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -5813,7 +5721,7 @@\n (define_insn \"divdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(div:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+\t\t(match_operand:DI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n   \"sdivx\\t%1, %2, %0\"\n   [(set_attr \"type\" \"idiv\")])\n@@ -5841,17 +5749,19 @@\n ;; XXX\n (define_expand \"udivsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(udiv:SI (match_operand:SI 1 \"reg_or_nonsymb_mem_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n \t\t (match_operand:SI 2 \"input_operand\" \"\")))]\n   \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n   \"\")\n \n+;; The V8 architecture specifies that there must be 3 instructions between\n+;; a Y register write and a use of it for correct results.\n+\n (define_insn \"udivsi3_sp32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,&r,&r\")\n-\t(udiv:SI (match_operand:SI 1 \"reg_or_nonsymb_mem_operand\" \"r,r,m\")\n+\t(udiv:SI (match_operand:SI 1 \"nonimmediate_operand\" \"r,r,m\")\n \t\t (match_operand:SI 2 \"input_operand\" \"rI,m,r\")))]\n-  \"(TARGET_V8\n-    || TARGET_DEPRECATED_V8_INSNS)\n+  \"(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS)\n    && TARGET_ARCH32\"\n {\n   output_asm_insn (\"wr\\t%%g0, %%g0, %%y\", operands);\n@@ -5870,7 +5780,7 @@\n \n (define_insn \"udivsi3_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(udiv:SI (match_operand:SI 1 \"reg_or_nonsymb_mem_operand\" \"r\")\n+\t(udiv:SI (match_operand:SI 1 \"nonimmediate_operand\" \"r\")\n \t\t (match_operand:SI 2 \"input_operand\" \"rI\")))]\n   \"TARGET_DEPRECATED_V8_INSNS && TARGET_ARCH64\"\n   \"wr\\t%%g0, 0, %%y\\n\\tudiv\\t%1, %2, %0\"\n@@ -5880,7 +5790,7 @@\n (define_insn \"udivdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(udiv:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+\t\t (match_operand:DI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n   \"udivx\\t%1, %2, %0\"\n   [(set_attr \"type\" \"idiv\")])\n@@ -5966,8 +5876,8 @@\n \n (define_insn \"*and<V64I:mode>3_sp64\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(and:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n+\t(and:V64I (match_operand:V64I 1 \"arith_operand\" \"%r,b\")\n+\t\t  (match_operand:V64I 2 \"arith_operand\" \"rI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    and\\t%1, %2, %0\n@@ -5978,7 +5888,7 @@\n (define_insn \"and<V32I:mode>3\"\n   [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n \t(and:V32I (match_operand:V32I 1 \"arith_operand\" \"%r,d\")\n-\t\t(match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n+\t\t  (match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n   \"@\n    and\\t%1, %2, %0\n@@ -5992,7 +5902,7 @@\n \t\t(match_operand:SI 2 \"\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT32 (operands[2])\n+   && !SMALL_INT (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 1)))]\n@@ -6069,8 +5979,8 @@\n \n (define_insn \"*ior<V64I:mode>3_sp64\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(ior:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n+\t(ior:V64I (match_operand:V64I 1 \"arith_operand\" \"%r,b\")\n+\t\t  (match_operand:V64I 2 \"arith_operand\" \"rI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n   or\\t%1, %2, %0\n@@ -6095,7 +6005,7 @@\n \t\t(match_operand:SI 2 \"\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT32 (operands[2])\n+   && !SMALL_INT (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (ior:SI (not:SI (match_dup 3)) (match_dup 1)))]\n@@ -6172,23 +6082,15 @@\n \n (define_insn \"*xor<V64I:mode>3_sp64\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(xor:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%rJ,b\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n+\t(xor:V64I (match_operand:V64I 1 \"arith_operand\" \"%rJ,b\")\n+\t\t  (match_operand:V64I 2 \"arith_operand\" \"rI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n   xor\\t%r1, %2, %0\n   fxor\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*xordi3_sp64_dbl\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t(match_operand:DI 2 \"const64_operand\" \"\")))]\n-  \"(TARGET_ARCH64\n-    && HOST_BITS_PER_WIDE_INT != 64)\"\n-  \"xor\\t%1, %2, %0\")\n-\n (define_insn \"xor<V32I:mode>3\"\n   [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n \t(xor:V32I (match_operand:V32I 1 \"arith_operand\" \"%rJ,d\")\n@@ -6206,7 +6108,7 @@\n \t\t(match_operand:SI 2 \"\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT32 (operands[2])\n+   && !SMALL_INT (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (not:SI (xor:SI (match_dup 3) (match_dup 1))))]\n@@ -6220,7 +6122,7 @@\n \t\t\t(match_operand:SI 2 \"\" \"\"))))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT32 (operands[2])\n+   && !SMALL_INT (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (xor:SI (match_dup 3) (match_dup 1)))]\n@@ -6231,7 +6133,7 @@\n ;; Split DImode logical operations requiring two instructions.\n (define_split\n   [(set (match_operand:V64I 0 \"register_operand\" \"\")\n-\t(match_operator:V64I 1 \"cc_arithop\"\t; AND, IOR, XOR\n+\t(match_operator:V64I 1 \"cc_arith_operator\"\t; AND, IOR, XOR\n \t\t\t   [(match_operand:V64I 2 \"register_operand\" \"\")\n \t\t\t    (match_operand:V64I 3 \"arith_double_operand\" \"\")]))]\n   \"! TARGET_ARCH64\n@@ -6292,8 +6194,8 @@\n \n (define_insn \"*xor_not_<V64I:mode>_sp64\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(not:V64I (xor:V64I (match_operand:V64I 1 \"reg_or_0_operand\" \"rJ,b\")\n-\t\t\t    (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\"))))]\n+\t(not:V64I (xor:V64I (match_operand:V64I 1 \"register_or_zero_operand\" \"rJ,b\")\n+\t\t\t    (match_operand:V64I 2 \"arith_operand\" \"rI,b\"))))]\n   \"TARGET_ARCH64\"\n   \"@\n   xnor\\t%r1, %2, %0\n@@ -6303,7 +6205,7 @@\n \n (define_insn \"*xor_not_<V32I:mode>\"\n   [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(not:V32I (xor:V32I (match_operand:V32I 1 \"reg_or_0_operand\" \"rJ,d\")\n+\t(not:V32I (xor:V32I (match_operand:V32I 1 \"register_or_zero_operand\" \"rJ,d\")\n \t\t\t    (match_operand:V32I 2 \"arith_operand\" \"rI,d\"))))]\n   \"\"\n   \"@\n@@ -6318,7 +6220,7 @@\n (define_insn \"*cmp_cc_arith_op\"\n   [(set (reg:CC 100)\n \t(compare:CC\n-\t (match_operator:SI 2 \"cc_arithop\"\n+\t (match_operator:SI 2 \"cc_arith_operator\"\n \t\t\t    [(match_operand:SI 0 \"arith_operand\" \"%r\")\n \t\t\t     (match_operand:SI 1 \"arith_operand\" \"rI\")])\n \t (const_int 0)))]\n@@ -6329,9 +6231,9 @@\n (define_insn \"*cmp_ccx_arith_op\"\n   [(set (reg:CCX 100)\n \t(compare:CCX\n-\t (match_operator:DI 2 \"cc_arithop\"\n-\t\t\t    [(match_operand:DI 0 \"arith_double_operand\" \"%r\")\n-\t\t\t     (match_operand:DI 1 \"arith_double_operand\" \"rHI\")])\n+\t (match_operator:DI 2 \"cc_arith_operator\"\n+\t\t\t    [(match_operand:DI 0 \"arith_operand\" \"%r\")\n+\t\t\t     (match_operand:DI 1 \"arith_operand\" \"rI\")])\n \t (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"%A2cc\\t%0, %1, %%g0\"\n@@ -6340,33 +6242,33 @@\n (define_insn \"*cmp_cc_arith_op_set\"\n   [(set (reg:CC 100)\n \t(compare:CC\n-\t (match_operator:SI 3 \"cc_arithop\"\n+\t (match_operator:SI 3 \"cc_arith_operator\"\n \t\t\t    [(match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")])\n \t (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 4 \"cc_arithop\" [(match_dup 1) (match_dup 2)]))]\n+\t(match_operator:SI 4 \"cc_arith_operator\" [(match_dup 1) (match_dup 2)]))]\n   \"GET_CODE (operands[3]) == GET_CODE (operands[4])\"\n   \"%A3cc\\t%1, %2, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_ccx_arith_op_set\"\n   [(set (reg:CCX 100)\n \t(compare:CCX\n-\t (match_operator:DI 3 \"cc_arithop\"\n-\t\t\t    [(match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t\t     (match_operand:DI 2 \"arith_double_operand\" \"rHI\")])\n+\t (match_operator:DI 3 \"cc_arith_operator\"\n+\t\t\t    [(match_operand:DI 1 \"arith_operand\" \"%r\")\n+\t\t\t     (match_operand:DI 2 \"arith_operand\" \"rI\")])\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operator:DI 4 \"cc_arithop\" [(match_dup 1) (match_dup 2)]))]\n+\t(match_operator:DI 4 \"cc_arith_operator\" [(match_dup 1) (match_dup 2)]))]\n   \"TARGET_ARCH64 && GET_CODE (operands[3]) == GET_CODE (operands[4])\"\n   \"%A3cc\\t%1, %2, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n (define_insn \"*cmp_cc_xor_not\"\n   [(set (reg:CC 100)\n \t(compare:CC\n-\t (not:SI (xor:SI (match_operand:SI 0 \"reg_or_0_operand\" \"%rJ\")\n+\t (not:SI (xor:SI (match_operand:SI 0 \"register_or_zero_operand\" \"%rJ\")\n \t\t\t (match_operand:SI 1 \"arith_operand\" \"rI\")))\n \t (const_int 0)))]\n   \"\"\n@@ -6376,8 +6278,8 @@\n (define_insn \"*cmp_ccx_xor_not\"\n   [(set (reg:CCX 100)\n \t(compare:CCX\n-\t (not:DI (xor:DI (match_operand:DI 0 \"reg_or_0_operand\" \"%rJ\")\n-\t\t\t (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))\n+\t (not:DI (xor:DI (match_operand:DI 0 \"register_or_zero_operand\" \"%rJ\")\n+\t\t\t (match_operand:DI 1 \"arith_operand\" \"rI\")))\n \t (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"xnorcc\\t%r0, %1, %%g0\"\n@@ -6386,7 +6288,7 @@\n (define_insn \"*cmp_cc_xor_not_set\"\n   [(set (reg:CC 100)\n \t(compare:CC\n-\t (not:SI (xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n+\t (not:SI (xor:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ\")\n \t\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n \t (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -6398,8 +6300,8 @@\n (define_insn \"*cmp_ccx_xor_not_set\"\n   [(set (reg:CCX 100)\n \t(compare:CCX\n-\t (not:DI (xor:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ\")\n-\t\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n+\t (not:DI (xor:DI (match_operand:DI 1 \"register_or_zero_operand\" \"%rJ\")\n+\t\t\t (match_operand:DI 2 \"arith_operand\" \"rI\")))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (xor:DI (match_dup 1) (match_dup 2))))]\n@@ -6410,9 +6312,9 @@\n (define_insn \"*cmp_cc_arith_op_not\"\n   [(set (reg:CC 100)\n \t(compare:CC\n-\t (match_operator:SI 2 \"cc_arithopn\"\n+\t (match_operator:SI 2 \"cc_arith_not_operator\"\n \t\t\t    [(not:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n-\t\t\t     (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")])\n+\t\t\t     (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")])\n \t (const_int 0)))]\n   \"\"\n   \"%B2cc\\t%r1, %0, %%g0\"\n@@ -6421,9 +6323,9 @@\n (define_insn \"*cmp_ccx_arith_op_not\"\n   [(set (reg:CCX 100)\n \t(compare:CCX\n-\t (match_operator:DI 2 \"cc_arithopn\"\n-\t\t\t    [(not:DI (match_operand:DI 0 \"arith_double_operand\" \"rHI\"))\n-\t\t\t     (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")])\n+\t (match_operator:DI 2 \"cc_arith_not_operator\"\n+\t\t\t    [(not:DI (match_operand:DI 0 \"arith_operand\" \"rI\"))\n+\t\t\t     (match_operand:DI 1 \"register_or_zero_operand\" \"rJ\")])\n \t (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"%B2cc\\t%r1, %0, %%g0\"\n@@ -6432,12 +6334,12 @@\n (define_insn \"*cmp_cc_arith_op_not_set\"\n   [(set (reg:CC 100)\n \t(compare:CC\n-\t (match_operator:SI 3 \"cc_arithopn\"\n+\t (match_operator:SI 3 \"cc_arith_not_operator\"\n \t\t\t    [(not:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n-\t\t\t     (match_operand:SI 2 \"reg_or_0_operand\" \"rJ\")])\n+\t\t\t     (match_operand:SI 2 \"register_or_zero_operand\" \"rJ\")])\n \t (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 4 \"cc_arithopn\"\n+\t(match_operator:SI 4 \"cc_arith_not_operator\"\n \t\t\t    [(not:SI (match_dup 1)) (match_dup 2)]))]\n   \"GET_CODE (operands[3]) == GET_CODE (operands[4])\"\n   \"%B3cc\\t%r2, %1, %0\"\n@@ -6446,12 +6348,12 @@\n (define_insn \"*cmp_ccx_arith_op_not_set\"\n   [(set (reg:CCX 100)\n \t(compare:CCX\n-\t (match_operator:DI 3 \"cc_arithopn\"\n-\t\t\t    [(not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n-\t\t\t     (match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")])\n+\t (match_operator:DI 3 \"cc_arith_not_operator\"\n+\t\t\t    [(not:DI (match_operand:DI 1 \"arith_operand\" \"rI\"))\n+\t\t\t     (match_operand:DI 2 \"register_or_zero_operand\" \"rJ\")])\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operator:DI 4 \"cc_arithopn\"\n+\t(match_operator:DI 4 \"cc_arith_not_operator\"\n \t\t\t    [(not:DI (match_dup 1)) (match_dup 2)]))]\n   \"TARGET_ARCH64 && GET_CODE (operands[3]) == GET_CODE (operands[4])\"\n   \"%B3cc\\t%r2, %1, %0\"\n@@ -6520,7 +6422,7 @@\n \n (define_insn \"*cmp_ccx_neg\"\n   [(set (reg:CCX_NOOV 100)\n-\t(compare:CCX_NOOV (neg:DI (match_operand:DI 0 \"arith_double_operand\" \"rHI\"))\n+\t(compare:CCX_NOOV (neg:DI (match_operand:DI 0 \"arith_operand\" \"rI\"))\n \t\t\t  (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"subcc\\t%%g0, %0, %%g0\"\n@@ -6538,7 +6440,7 @@\n \n (define_insn \"*cmp_ccx_set_neg\"\n   [(set (reg:CCX_NOOV 100)\n-\t(compare:CCX_NOOV (neg:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n+\t(compare:CCX_NOOV (neg:DI (match_operand:DI 1 \"arith_operand\" \"rI\"))\n \t\t\t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (match_dup 1)))]\n@@ -6579,7 +6481,7 @@\n \n (define_insn \"*one_cmpl<V64I:mode>2_sp64\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(not:V64I (match_operand:V64I 1 \"arith_double_operand\" \"rHI,b\")))]\n+\t(not:V64I (match_operand:V64I 1 \"arith_operand\" \"rI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    xnor\\t%%g0, %1, %0\n@@ -6607,7 +6509,7 @@\n \n (define_insn \"*cmp_ccx_not\"\n   [(set (reg:CCX 100)\n-\t(compare:CCX (not:DI (match_operand:DI 0 \"arith_double_operand\" \"rHI\"))\n+\t(compare:CCX (not:DI (match_operand:DI 0 \"arith_operand\" \"rI\"))\n \t\t     (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"xnorcc\\t%%g0, %0, %%g0\"\n@@ -6625,7 +6527,7 @@\n \n (define_insn \"*cmp_ccx_set_not\"\n   [(set (reg:CCX 100)\n-\t(compare:CCX (not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n+\t(compare:CCX (not:DI (match_operand:DI 1 \"arith_operand\" \"rI\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_dup 1)))]\n@@ -7026,7 +6928,7 @@\n   return \"sll\\t%1, %2, %0\";\n }\n   [(set (attr \"type\")\n-\t(if_then_else (match_operand 2 \"const1_operand\" \"\")\n+\t(if_then_else (match_operand 2 \"const_one_operand\" \"\")\n \t\t      (const_string \"ialu\") (const_string \"shift\")))])\n \n (define_expand \"ashldi3\"\n@@ -7055,7 +6957,7 @@\n   return \"sllx\\t%1, %2, %0\";\n }\n   [(set (attr \"type\")\n-\t(if_then_else (match_operand 2 \"const1_operand\" \"\")\n+\t(if_then_else (match_operand 2 \"const_one_operand\" \"\")\n \t\t      (const_string \"ialu\") (const_string \"shift\")))])\n \n ;; XXX UGH!\n@@ -7132,17 +7034,10 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashiftrt:DI (ashift:DI (subreg:DI (match_operand:SI 1 \"register_operand\" \"r\") 0)\n \t\t\t\t(const_int 32))\n-\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")))]\n-  \"TARGET_ARCH64\n-   && ((GET_CODE (operands[2]) == CONST_INT\n-        && INTVAL (operands[2]) >= 32 && INTVAL (operands[2]) < 64)\n-       || (GET_CODE (operands[2]) == CONST_DOUBLE\n-\t   && !CONST_DOUBLE_HIGH (operands[2])\n-           && CONST_DOUBLE_LOW (operands[2]) >= 32\n-           && CONST_DOUBLE_LOW (operands[2]) < 64))\"\n+\t\t     (match_operand:SI 2 \"small_int_operand\" \"I\")))]\n+  \"TARGET_ARCH64 && INTVAL (operands[2]) >= 32 && INTVAL (operands[2]) < 64\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n-\n   return \"sra\\t%1, %2, %0\";\n }\n   [(set_attr \"type\" \"shift\")])\n@@ -7222,17 +7117,11 @@\n (define_insn \"*lshrsi3_extend2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (subreg:DI (match_operand:SI 1 \"register_operand\" \"r\") 0)\n-\t\t\t (match_operand 2 \"small_int_or_double\" \"n\")\n+\t\t\t (match_operand 2 \"small_int_operand\" \"I\")\n \t\t\t (const_int 32)))]\n-  \"TARGET_ARCH64\n-   && ((GET_CODE (operands[2]) == CONST_INT\n-        && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) < 32)\n-       || (GET_CODE (operands[2]) == CONST_DOUBLE\n-\t   && CONST_DOUBLE_HIGH (operands[2]) == 0\n-           && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (operands[2]) < 32))\"\n+  \"TARGET_ARCH64 && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) < 32\"\n {\n   operands[2] = GEN_INT (32 - INTVAL (operands[2]));\n-\n   return \"srl\\t%1, %2, %0\";\n }\n   [(set_attr \"type\" \"shift\")])\n@@ -7279,16 +7168,10 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ashiftrt:SI (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t\t     (const_int 32)) 4)\n-\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")))]\n-  \"TARGET_ARCH64\n-   && ((GET_CODE (operands[2]) == CONST_INT\n-        && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) < 32)\n-       || (GET_CODE (operands[2]) == CONST_DOUBLE\n-\t   && !CONST_DOUBLE_HIGH (operands[2])\n-           && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (operands[2]) < 32))\"\n+\t\t     (match_operand:SI 2 \"small_int_operand\" \"I\")))]\n+  \"TARGET_ARCH64 && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) < 32\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 32);\n-\n   return \"srax\\t%1, %2, %0\";\n }\n   [(set_attr \"type\" \"shift\")])\n@@ -7297,27 +7180,20 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:SI (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t\t     (const_int 32)) 4)\n-\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")))]\n-  \"TARGET_ARCH64\n-   && ((GET_CODE (operands[2]) == CONST_INT\n-        && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) < 32)\n-       || (GET_CODE (operands[2]) == CONST_DOUBLE\n-\t   && !CONST_DOUBLE_HIGH (operands[2])\n-           && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (operands[2]) < 32))\"\n+\t\t     (match_operand:SI 2 \"small_int_operand\" \"I\")))]\n+  \"TARGET_ARCH64 && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) < 32\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 32);\n-\n   return \"srlx\\t%1, %2, %0\";\n }\n   [(set_attr \"type\" \"shift\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ashiftrt:SI (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")) 4)\n-\t\t     (match_operand:SI 3 \"small_int_or_double\" \"n\")))]\n+\t\t\t\t\t     (match_operand:SI 2 \"small_int_operand\" \"I\")) 4)\n+\t\t     (match_operand:SI 3 \"small_int_operand\" \"I\")))]\n   \"TARGET_ARCH64\n-   && GET_CODE (operands[2]) == CONST_INT && GET_CODE (operands[3]) == CONST_INT\n    && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) >= 32\n    && (unsigned HOST_WIDE_INT) INTVAL (operands[3]) < 32\n    && (unsigned HOST_WIDE_INT) (INTVAL (operands[2]) + INTVAL (operands[3])) < 64\"\n@@ -7331,10 +7207,9 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:SI (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")) 4)\n-\t\t     (match_operand:SI 3 \"small_int_or_double\" \"n\")))]\n+\t\t\t\t\t     (match_operand:SI 2 \"small_int_operand\" \"I\")) 4)\n+\t\t     (match_operand:SI 3 \"small_int_operand\" \"I\")))]\n   \"TARGET_ARCH64\n-   && GET_CODE (operands[2]) == CONST_INT && GET_CODE (operands[3]) == CONST_INT\n    && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) >= 32\n    && (unsigned HOST_WIDE_INT) INTVAL (operands[3]) < 32\n    && (unsigned HOST_WIDE_INT) (INTVAL (operands[2]) + INTVAL (operands[3])) < 64\"\n@@ -8275,7 +8150,7 @@\n   [(set_attr \"type\" \"trap\")])\n \n (define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"noov_compare_op\" [(match_dup 2) (match_dup 3)])\n+  [(trap_if (match_operator 0 \"noov_compare_operator\" [(match_dup 2) (match_dup 3)])\n \t    (match_operand:SI 1 \"arith_operand\" \"\"))]\n   \"\"\n   \"operands[2] = gen_compare_reg (GET_CODE (operands[0]),\n@@ -8285,7 +8160,7 @@\n    operands[3] = const0_rtx;\")\n \n (define_insn \"\"\n-  [(trap_if (match_operator 0 \"noov_compare_op\" [(reg:CC 100) (const_int 0)])\n+  [(trap_if (match_operator 0 \"noov_compare_operator\" [(reg:CC 100) (const_int 0)])\n \t    (match_operand:SI 1 \"arith_operand\" \"rM\"))]\n   \"\"\n {\n@@ -8297,7 +8172,7 @@\n   [(set_attr \"type\" \"trap\")])\n \n (define_insn \"\"\n-  [(trap_if (match_operator 0 \"noov_compare_op\" [(reg:CCX 100) (const_int 0)])\n+  [(trap_if (match_operator 0 \"noov_compare_operator\" [(reg:CCX 100) (const_int 0)])\n \t    (match_operand:SI 1 \"arith_operand\" \"rM\"))]\n   \"TARGET_V9\"\n   \"t%C0\\t%%xcc, %1\"\n@@ -9088,8 +8963,8 @@\n \n (define_insn \"alignaddr<P:mode>_vis\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-        (unspec:P [(match_operand:P 1 \"reg_or_0_operand\" \"rJ\")\n-                   (match_operand:P 2 \"reg_or_0_operand\" \"rJ\")]\n+        (unspec:P [(match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n+                   (match_operand:P 2 \"register_or_zero_operand\" \"rJ\")]\n          UNSPEC_ALIGNADDR))]\n   \"TARGET_VIS\"\n   \"alignaddr\\t%r1, %r2, %0\")"}]}