{"sha": "998d20d22a7632ac162773c0561bc8cd6f269f26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk4ZDIwZDIyYTc2MzJhYzE2Mjc3M2MwNTYxYmM4Y2Q2ZjI2OWYyNg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2001-07-13T17:24:48Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2001-07-13T17:24:48Z"}, "message": "Revert Jan Hubicka's patch of Fri Jul 13 14:46:21 CEST 2001.\n\nFrom-SVN: r43986", "tree": {"sha": "e56c88ab85654a27ddc609666a10878d5099f75d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e56c88ab85654a27ddc609666a10878d5099f75d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/998d20d22a7632ac162773c0561bc8cd6f269f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998d20d22a7632ac162773c0561bc8cd6f269f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/998d20d22a7632ac162773c0561bc8cd6f269f26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998d20d22a7632ac162773c0561bc8cd6f269f26/comments", "author": null, "committer": null, "parents": [{"sha": "4a9d51090acc89a3bed7d1bae7f9d4e1da267243", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a9d51090acc89a3bed7d1bae7f9d4e1da267243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a9d51090acc89a3bed7d1bae7f9d4e1da267243"}], "stats": {"total": 612, "additions": 543, "deletions": 69}, "files": [{"sha": "5143add5c67f31e34bcf176a547b38713f40e90f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -1,3 +1,7 @@\n+2001-07-13  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\tRevert Jan Hubicka's patch of Fri Jul 13 14:46:21 CEST 2001.\n+\n 2001-07-13  David Edelsohn  <edelsohn@gnu.org>\n \n \t* combine.c (try_combine): Ensure const_int pow2 is positive."}, {"sha": "f97abae903007530eecccc6b7b8734448f049561", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -2908,6 +2908,9 @@ Dump after sibling call optimizations, to @file{@var{file}.01.sibling}.\n @item j\n @opindex dj\n Dump after the first jump optimization, to @file{@var{file}.03.jump}.\n+@item J\n+@opindex dJ\n+Dump after the last jump optimization, to @file{@var{file}.29.jump2}.\n @item k\n @opindex dk\n Dump after conversion from registers to stack, to @file{@var{file}.32.stack}."}, {"sha": "eae04b6cff70d9ec7a23b283603814624891f3c3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -2518,7 +2518,7 @@ try_split (pat, trial, last)\n \t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n \t    if (GET_CODE (XVECEXP (seq, 0, i)) == JUMP_INSN)\n \t      mark_jump_label (PATTERN (XVECEXP (seq, 0, i)),\n-\t\t\t       XVECEXP (seq, 0, i), 0);\n+\t\t\t       XVECEXP (seq, 0, i), 0, 0);\n \n \t  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n \t     in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */"}, {"sha": "92f63099ff2d3b8dc86db01c36e22ba0d50a497c", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -798,7 +798,7 @@ find_sub_basic_blocks (bb)\n       bb = BASIC_BLOCK (i);\n       if (GET_CODE (bb->end) == JUMP_INSN)\n \t{\n-\t  mark_jump_label (PATTERN (bb->end), bb->end, 0);\n+\t  mark_jump_label (PATTERN (bb->end), bb->end, 0, 0);\n \t  make_label_edge (NULL, bb, JUMP_LABEL (bb->end), 0);\n \t}\n       insn = NEXT_INSN (insn);"}, {"sha": "010c1c7319d9a2e7b7b22e059c643cd241d70206", "filename": "gcc/jump.c", "status": "modified", "additions": 474, "deletions": 31, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -36,6 +36,11 @@ Boston, MA 02111-1307, USA.  */\n    formerly used them.  The JUMP_LABEL info is sometimes looked\n    at by later passes.\n \n+   Optionally, cross-jumping can be done.  Currently it is done\n+   only the last time (when after reload and before final).\n+   In fact, the code for cross-jumping now assumes that register\n+   allocation has been done, since it uses `rtx_renumbered_equal_p'.\n+\n    Jump optimization is done after cse when cse's constant-propagation\n    causes jumps to become unconditional or to be deleted.\n \n@@ -91,12 +96,23 @@ static rtx *jump_chain;\n \n static int max_jump_chain;\n \n+/* Indicates whether death notes are significant in cross jump analysis.\n+   Normally they are not significant, because of A and B jump to C,\n+   and R dies in A, it must die in B.  But this might not be true after\n+   stack register conversion, and we must compare death notes in that\n+   case.  */\n+\n+static int cross_jump_death_matters = 0;\n+\n static int init_label_info\t\tPARAMS ((rtx));\n static void delete_barrier_successors\tPARAMS ((rtx));\n-static void mark_all_labels\t\tPARAMS ((rtx));\n+static void mark_all_labels\t\tPARAMS ((rtx, int));\n static rtx delete_unreferenced_labels\tPARAMS ((rtx));\n static void delete_noop_moves\t\tPARAMS ((rtx));\n static int duplicate_loop_exit_test\tPARAMS ((rtx));\n+static void find_cross_jump\t\tPARAMS ((rtx, rtx, int, rtx *, rtx *));\n+static void do_cross_jump\t\tPARAMS ((rtx, rtx, rtx));\n+static int jump_back_p\t\t\tPARAMS ((rtx, rtx));\n static int tension_vector_labels\tPARAMS ((rtx, int));\n static void delete_computation\t\tPARAMS ((rtx));\n static void redirect_exp_1\t\tPARAMS ((rtx *, rtx, rtx, rtx));\n@@ -107,19 +123,20 @@ static void delete_from_jump_chain\tPARAMS ((rtx));\n static int delete_labelref_insn\t\tPARAMS ((rtx, rtx, int));\n static void mark_modified_reg\t\tPARAMS ((rtx, rtx, void *));\n static void redirect_tablejump\t\tPARAMS ((rtx, rtx));\n-static void jump_optimize_1\t\tPARAMS ((rtx, int, int, int, int));\n+static void jump_optimize_1\t\tPARAMS ((rtx, int, int, int, int, int));\n static int returnjump_p_1\t        PARAMS ((rtx *, void *));\n static void delete_prior_computation    PARAMS ((rtx, rtx));\n \f\n /* Main external entry point into the jump optimizer.  See comments before\n    jump_optimize_1 for descriptions of the arguments.  */\n void\n-jump_optimize (f, noop_moves, after_regscan)\n+jump_optimize (f, cross_jump, noop_moves, after_regscan)\n      rtx f;\n+     int cross_jump;\n      int noop_moves;\n      int after_regscan;\n {\n-  jump_optimize_1 (f, noop_moves, after_regscan, 0, 0);\n+  jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, 0, 0);\n }\n \n /* Alternate entry into the jump optimizer.  This entry point only rebuilds\n@@ -129,7 +146,7 @@ void\n rebuild_jump_labels (f)\n      rtx f;\n {\n-  jump_optimize_1 (f, 0, 0, 1, 0);\n+  jump_optimize_1 (f, 0, 0, 0, 1, 0);\n }\n \n /* Alternate entry into the jump optimizer.  Do only trivial optimizations.  */\n@@ -138,13 +155,17 @@ void\n jump_optimize_minimal (f)\n      rtx f;\n {\n-  jump_optimize_1 (f, 0, 0, 0, 1);\n+  jump_optimize_1 (f, 0, 0, 0, 0, 1);\n }\n \f\n /* Delete no-op jumps and optimize jumps to jumps\n    and jumps around jumps.\n    Delete unused labels and unreachable code.\n \n+   If CROSS_JUMP is 1, detect matching code\n+   before a jump and its destination and unify them.\n+   If CROSS_JUMP is 2, do cross-jumping, but pay attention to death notes.\n+\n    If NOOP_MOVES is nonzero, delete no-op move insns.\n \n    If AFTER_REGSCAN is nonzero, then this jump pass is being run immediately\n@@ -172,9 +193,10 @@ jump_optimize_minimal (f)\n   */\n \n static void\n-jump_optimize_1 (f, noop_moves, after_regscan,\n+jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t\t mark_labels_only, minimal)\n      rtx f;\n+     int cross_jump;\n      int noop_moves;\n      int after_regscan;\n      int mark_labels_only;\n@@ -190,14 +212,15 @@ jump_optimize_1 (f, noop_moves, after_regscan,\n   enum rtx_code reversed_code;\n #endif\n \n+  cross_jump_death_matters = (cross_jump == 2);\n   max_uid = init_label_info (f) + 1;\n \n   /* Leave some extra room for labels and duplicate exit test insns\n      we make.  */\n   max_jump_chain = max_uid * 14 / 10;\n   jump_chain = (rtx *) xcalloc (max_jump_chain, sizeof (rtx));\n \n-  mark_all_labels (f);\n+  mark_all_labels (f, cross_jump);\n \n   /* Keep track of labels used from static data; we don't track them\n      closely enough to delete them here, so make sure their reference\n@@ -551,6 +574,125 @@ jump_optimize_1 (f, noop_moves, after_regscan,\n \t\t}\n \t    }\n #endif\n+\t  else\n+\t    {\n+\t      /* Now that the jump has been tensioned,\n+\t\t try cross jumping: check for identical code\n+\t\t before the jump and before its target label.  */\n+\n+\t      /* First, cross jumping of conditional jumps:  */\n+\n+\t      if (cross_jump && condjump_p (insn))\n+\t\t{\n+\t\t  rtx newjpos, newlpos;\n+\t\t  rtx x = prev_real_insn (JUMP_LABEL (insn));\n+\n+\t\t  /* A conditional jump may be crossjumped\n+\t\t     only if the place it jumps to follows\n+\t\t     an opposing jump that comes back here.  */\n+\n+\t\t  if (x != 0 && ! jump_back_p (x, insn))\n+\t\t    /* We have no opposing jump;\n+\t\t       cannot cross jump this insn.  */\n+\t\t    x = 0;\n+\n+\t\t  newjpos = 0;\n+\t\t  /* TARGET is nonzero if it is ok to cross jump\n+\t\t     to code before TARGET.  If so, see if matches.  */\n+\t\t  if (x != 0)\n+\t\t    find_cross_jump (insn, x, 2,\n+\t\t\t\t     &newjpos, &newlpos);\n+\n+\t\t  if (newjpos != 0)\n+\t\t    {\n+\t\t      do_cross_jump (insn, newjpos, newlpos);\n+\t\t      /* Make the old conditional jump\n+\t\t\t into an unconditional one.  */\n+\t\t      PATTERN (insn) = gen_jump (JUMP_LABEL (insn));\n+\t\t      INSN_CODE (insn) = -1;\n+\t\t      emit_barrier_after (insn);\n+\t\t      /* Add to jump_chain unless this is a new label\n+\t\t\t whose UID is too large.  */\n+\t\t      if (INSN_UID (JUMP_LABEL (insn)) < max_jump_chain)\n+\t\t\t{\n+\t\t\t  jump_chain[INSN_UID (insn)]\n+\t\t\t    = jump_chain[INSN_UID (JUMP_LABEL (insn))];\n+\t\t\t  jump_chain[INSN_UID (JUMP_LABEL (insn))] = insn;\n+\t\t\t}\n+\t\t      changed = 1;\n+\t\t      next = insn;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Cross jumping of unconditional jumps:\n+\t\t a few differences.  */\n+\n+\t      if (cross_jump && simplejump_p (insn))\n+\t\t{\n+\t\t  rtx newjpos, newlpos;\n+\t\t  rtx target;\n+\n+\t\t  newjpos = 0;\n+\n+\t\t  /* TARGET is nonzero if it is ok to cross jump\n+\t\t     to code before TARGET.  If so, see if matches.  */\n+\t\t  find_cross_jump (insn, JUMP_LABEL (insn), 1,\n+\t\t\t\t   &newjpos, &newlpos);\n+\n+\t\t  /* If cannot cross jump to code before the label,\n+\t\t     see if we can cross jump to another jump to\n+\t\t     the same label.  */\n+\t\t  /* Try each other jump to this label.  */\n+\t\t  if (INSN_UID (JUMP_LABEL (insn)) < max_uid)\n+\t\t    for (target = jump_chain[INSN_UID (JUMP_LABEL (insn))];\n+\t\t\t target != 0 && newjpos == 0;\n+\t\t\t target = jump_chain[INSN_UID (target)])\n+\t\t      if (target != insn\n+\t\t\t  && JUMP_LABEL (target) == JUMP_LABEL (insn)\n+\t\t\t  /* Ignore TARGET if it's deleted.  */\n+\t\t\t  && ! INSN_DELETED_P (target))\n+\t\t\tfind_cross_jump (insn, target, 2,\n+\t\t\t\t\t &newjpos, &newlpos);\n+\n+\t\t  if (newjpos != 0)\n+\t\t    {\n+\t\t      do_cross_jump (insn, newjpos, newlpos);\n+\t\t      changed = 1;\n+\t\t      next = insn;\n+\t\t    }\n+\t\t}\n+\n+\t      /* This code was dead in the previous jump.c!  */\n+\t      if (cross_jump && GET_CODE (PATTERN (insn)) == RETURN)\n+\t\t{\n+\t\t  /* Return insns all \"jump to the same place\"\n+\t\t     so we can cross-jump between any two of them.  */\n+\n+\t\t  rtx newjpos, newlpos, target;\n+\n+\t\t  newjpos = 0;\n+\n+\t\t  /* If cannot cross jump to code before the label,\n+\t\t     see if we can cross jump to another jump to\n+\t\t     the same label.  */\n+\t\t  /* Try each other jump to this label.  */\n+\t\t  for (target = jump_chain[0];\n+\t\t       target != 0 && newjpos == 0;\n+\t\t       target = jump_chain[INSN_UID (target)])\n+\t\t    if (target != insn\n+\t\t\t&& ! INSN_DELETED_P (target)\n+\t\t\t&& GET_CODE (PATTERN (target)) == RETURN)\n+\t\t      find_cross_jump (insn, target, 2,\n+\t\t\t\t       &newjpos, &newlpos);\n+\n+\t\t  if (newjpos != 0)\n+\t\t    {\n+\t\t      do_cross_jump (insn, newjpos, newlpos);\n+\t\t      changed = 1;\n+\t\t      next = insn;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n \n       first = 0;\n@@ -695,11 +837,16 @@ delete_barrier_successors (f)\n \n    For each label, make a chain (using `jump_chain')\n    of all the *unconditional* jumps that jump to it;\n-   also make a chain of all returns.  */\n+   also make a chain of all returns.\n+\n+   CROSS_JUMP indicates whether we are doing cross jumping\n+   and if we are whether we will be paying attention to\n+   death notes or not.  */\n \n static void\n-mark_all_labels (f)\n+mark_all_labels (f, cross_jump)\n      rtx f;\n+     int cross_jump;\n {\n   rtx insn;\n \n@@ -709,24 +856,24 @@ mark_all_labels (f)\n \tif (GET_CODE (insn) == CALL_INSN\n \t    && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n \t  {\n-\t    mark_all_labels (XEXP (PATTERN (insn), 0));\n-\t    mark_all_labels (XEXP (PATTERN (insn), 1));\n-\t    mark_all_labels (XEXP (PATTERN (insn), 2));\n+\t    mark_all_labels (XEXP (PATTERN (insn), 0), cross_jump);\n+\t    mark_all_labels (XEXP (PATTERN (insn), 1), cross_jump);\n+\t    mark_all_labels (XEXP (PATTERN (insn), 2), cross_jump);\n \n \t    /* Canonicalize the tail recursion label attached to the\n \t       CALL_PLACEHOLDER insn.  */\n \t    if (XEXP (PATTERN (insn), 3))\n \t      {\n \t\trtx label_ref = gen_rtx_LABEL_REF (VOIDmode,\n \t\t\t\t\t\t   XEXP (PATTERN (insn), 3));\n-\t\tmark_jump_label (label_ref, insn, 0);\n+\t\tmark_jump_label (label_ref, insn, cross_jump, 0);\n \t\tXEXP (PATTERN (insn), 3) = XEXP (label_ref, 0);\n \t      }\n \n \t    continue;\n \t  }\n \n-\tmark_jump_label (PATTERN (insn), insn, 0);\n+\tmark_jump_label (PATTERN (insn), insn, cross_jump, 0);\n \tif (! INSN_DELETED_P (insn) && GET_CODE (insn) == JUMP_INSN)\n \t  {\n \t    /* When we know the LABEL_REF contained in a REG used in\n@@ -742,7 +889,7 @@ mark_all_labels (f)\n \t\t    rtx label_ref = gen_rtx_LABEL_REF (VOIDmode,\n \t\t\t\t\t\t       XEXP (label_note, 0));\n \n-\t\t    mark_jump_label (label_ref, insn, 0);\n+\t\t    mark_jump_label (label_ref, insn, cross_jump, 0);\n \t\t    XEXP (label_note, 0) = XEXP (label_ref, 0);\n \t\t    JUMP_LABEL (insn) = XEXP (label_note, 0);\n \t\t  }\n@@ -1066,7 +1213,7 @@ duplicate_loop_exit_test (loop_start)\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \n-\t  mark_jump_label (PATTERN (copy), copy, 0);\n+\t  mark_jump_label (PATTERN (copy), copy, 0, 0);\n \n \t  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n \t     make them.  */\n@@ -1094,7 +1241,7 @@ duplicate_loop_exit_test (loop_start)\n \t\t\t\t\tloop_start);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n-\t  mark_jump_label (PATTERN (copy), copy, 0);\n+\t  mark_jump_label (PATTERN (copy), copy, 0, 0);\n \t  if (REG_NOTES (insn))\n \t    {\n \t      REG_NOTES (copy) = copy_insn_1 (REG_NOTES (insn));\n@@ -1155,7 +1302,7 @@ duplicate_loop_exit_test (loop_start)\n       if (! first_copy)\n \tfirst_copy = copy;\n \n-      mark_jump_label (PATTERN (copy), copy, 0);\n+      mark_jump_label (PATTERN (copy), copy, 0, 0);\n       if (INSN_UID (copy) < max_jump_chain\n \t  && INSN_UID (JUMP_LABEL (copy)) < max_jump_chain)\n \t{\n@@ -1225,6 +1372,248 @@ squeeze_notes (start, end)\n   return start;\n }\n \f\n+/* Compare the instructions before insn E1 with those before E2\n+   to find an opportunity for cross jumping.\n+   (This means detecting identical sequences of insns followed by\n+   jumps to the same place, or followed by a label and a jump\n+   to that label, and replacing one with a jump to the other.)\n+\n+   Assume E1 is a jump that jumps to label E2\n+   (that is not always true but it might as well be).\n+   Find the longest possible equivalent sequences\n+   and store the first insns of those sequences into *F1 and *F2.\n+   Store zero there if no equivalent preceding instructions are found.\n+\n+   We give up if we find a label in stream 1.\n+   Actually we could transfer that label into stream 2.  */\n+\n+static void\n+find_cross_jump (e1, e2, minimum, f1, f2)\n+     rtx e1, e2;\n+     int minimum;\n+     rtx *f1, *f2;\n+{\n+  register rtx i1 = e1, i2 = e2;\n+  register rtx p1, p2;\n+  int lose = 0;\n+\n+  rtx last1 = 0, last2 = 0;\n+  rtx afterlast1 = 0, afterlast2 = 0;\n+\n+  *f1 = 0;\n+  *f2 = 0;\n+\n+  while (1)\n+    {\n+      i1 = prev_nonnote_insn (i1);\n+\n+      i2 = PREV_INSN (i2);\n+      while (i2 && (GET_CODE (i2) == NOTE || GET_CODE (i2) == CODE_LABEL))\n+\ti2 = PREV_INSN (i2);\n+\n+      if (i1 == 0)\n+\tbreak;\n+\n+      /* Don't allow the range of insns preceding E1 or E2\n+\t to include the other (E2 or E1).  */\n+      if (i2 == e1 || i1 == e2)\n+\tbreak;\n+\n+      /* If we will get to this code by jumping, those jumps will be\n+\t tensioned to go directly to the new label (before I2),\n+\t so this cross-jumping won't cost extra.  So reduce the minimum.  */\n+      if (GET_CODE (i1) == CODE_LABEL)\n+\t{\n+\t  --minimum;\n+\t  break;\n+\t}\n+\n+      if (i2 == 0 || GET_CODE (i1) != GET_CODE (i2))\n+\tbreak;\n+\n+      p1 = PATTERN (i1);\n+      p2 = PATTERN (i2);\n+\n+      /* If this is a CALL_INSN, compare register usage information.\n+\t If we don't check this on stack register machines, the two\n+\t CALL_INSNs might be merged leaving reg-stack.c with mismatching\n+\t numbers of stack registers in the same basic block.\n+\t If we don't check this on machines with delay slots, a delay slot may\n+\t be filled that clobbers a parameter expected by the subroutine.\n+\n+\t ??? We take the simple route for now and assume that if they're\n+\t equal, they were constructed identically.  */\n+\n+      if (GET_CODE (i1) == CALL_INSN\n+\t  && ! rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n+\t\t\t    CALL_INSN_FUNCTION_USAGE (i2)))\n+\tlose = 1;\n+\n+#ifdef STACK_REGS\n+      /* If cross_jump_death_matters is not 0, the insn's mode\n+\t indicates whether or not the insn contains any stack-like\n+\t regs.  */\n+\n+      if (!lose && cross_jump_death_matters && stack_regs_mentioned (i1))\n+\t{\n+\t  /* If register stack conversion has already been done, then\n+\t     death notes must also be compared before it is certain that\n+\t     the two instruction streams match.  */\n+\n+\t  rtx note;\n+\t  HARD_REG_SET i1_regset, i2_regset;\n+\n+\t  CLEAR_HARD_REG_SET (i1_regset);\n+\t  CLEAR_HARD_REG_SET (i2_regset);\n+\n+\t  for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_DEAD\n+\t\t&& STACK_REG_P (XEXP (note, 0)))\n+\t      SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n+\n+\t  for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_DEAD\n+\t\t&& STACK_REG_P (XEXP (note, 0)))\n+\t      SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n+\n+\t  GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n+\n+\t  lose = 1;\n+\n+\tdone:\n+\t  ;\n+\t}\n+#endif\n+\n+      /* Don't allow old-style asm or volatile extended asms to be accepted\n+\t for cross jumping purposes.  It is conceptually correct to allow\n+\t them, since cross-jumping preserves the dynamic instruction order\n+\t even though it is changing the static instruction order.  However,\n+\t if an asm is being used to emit an assembler pseudo-op, such as\n+\t the MIPS `.set reorder' pseudo-op, then the static instruction order\n+\t matters and it must be preserved.  */\n+      if (GET_CODE (p1) == ASM_INPUT || GET_CODE (p2) == ASM_INPUT\n+\t  || (GET_CODE (p1) == ASM_OPERANDS && MEM_VOLATILE_P (p1))\n+\t  || (GET_CODE (p2) == ASM_OPERANDS && MEM_VOLATILE_P (p2)))\n+\tlose = 1;\n+\n+      if (lose || GET_CODE (p1) != GET_CODE (p2)\n+\t  || ! rtx_renumbered_equal_p (p1, p2))\n+\t{\n+\t  /* The following code helps take care of G++ cleanups.  */\n+\t  rtx equiv1;\n+\t  rtx equiv2;\n+\n+\t  if (!lose && GET_CODE (p1) == GET_CODE (p2)\n+\t      && ((equiv1 = find_reg_note (i1, REG_EQUAL, NULL_RTX)) != 0\n+\t\t  || (equiv1 = find_reg_note (i1, REG_EQUIV, NULL_RTX)) != 0)\n+\t      && ((equiv2 = find_reg_note (i2, REG_EQUAL, NULL_RTX)) != 0\n+\t\t  || (equiv2 = find_reg_note (i2, REG_EQUIV, NULL_RTX)) != 0)\n+\t      /* If the equivalences are not to a constant, they may\n+\t\t reference pseudos that no longer exist, so we can't\n+\t\t use them.  */\n+\t      && CONSTANT_P (XEXP (equiv1, 0))\n+\t      && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n+\t    {\n+\t      rtx s1 = single_set (i1);\n+\t      rtx s2 = single_set (i2);\n+\t      if (s1 != 0 && s2 != 0\n+\t\t  && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n+\t\t{\n+\t\t  validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n+\t\t  validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n+\t\t  if (! rtx_renumbered_equal_p (p1, p2))\n+\t\t    cancel_changes (0);\n+\t\t  else if (apply_change_group ())\n+\t\t    goto win;\n+\t\t}\n+\t    }\n+\n+\t  /* Insns fail to match; cross jumping is limited to the following\n+\t     insns.  */\n+\n+#ifdef HAVE_cc0\n+\t  /* Don't allow the insn after a compare to be shared by\n+\t     cross-jumping unless the compare is also shared.\n+\t     Here, if either of these non-matching insns is a compare,\n+\t     exclude the following insn from possible cross-jumping.  */\n+\t  if (sets_cc0_p (p1) || sets_cc0_p (p2))\n+\t    last1 = afterlast1, last2 = afterlast2, ++minimum;\n+#endif\n+\n+\t  /* If cross-jumping here will feed a jump-around-jump\n+\t     optimization, this jump won't cost extra, so reduce\n+\t     the minimum.  */\n+\t  if (GET_CODE (i1) == JUMP_INSN\n+\t      && JUMP_LABEL (i1)\n+\t      && prev_real_insn (JUMP_LABEL (i1)) == e1)\n+\t    --minimum;\n+\t  break;\n+\t}\n+\n+    win:\n+      if (GET_CODE (p1) != USE && GET_CODE (p1) != CLOBBER)\n+\t{\n+\t  /* Ok, this insn is potentially includable in a cross-jump here.  */\n+\t  afterlast1 = last1, afterlast2 = last2;\n+\t  last1 = i1, last2 = i2, --minimum;\n+\t}\n+    }\n+\n+  if (minimum <= 0 && last1 != 0 && last1 != e1)\n+    *f1 = last1, *f2 = last2;\n+}\n+\n+static void\n+do_cross_jump (insn, newjpos, newlpos)\n+     rtx insn, newjpos, newlpos;\n+{\n+  /* Find an existing label at this point\n+     or make a new one if there is none.  */\n+  register rtx label = get_label_before (newlpos);\n+\n+  /* Make the same jump insn jump to the new point.  */\n+  if (GET_CODE (PATTERN (insn)) == RETURN)\n+    {\n+      /* Remove from jump chain of returns.  */\n+      delete_from_jump_chain (insn);\n+      /* Change the insn.  */\n+      PATTERN (insn) = gen_jump (label);\n+      INSN_CODE (insn) = -1;\n+      JUMP_LABEL (insn) = label;\n+      LABEL_NUSES (label)++;\n+      /* Add to new the jump chain.  */\n+      if (INSN_UID (label) < max_jump_chain\n+\t  && INSN_UID (insn) < max_jump_chain)\n+\t{\n+\t  jump_chain[INSN_UID (insn)] = jump_chain[INSN_UID (label)];\n+\t  jump_chain[INSN_UID (label)] = insn;\n+\t}\n+    }\n+  else\n+    redirect_jump (insn, label, 1);\n+\n+  /* Delete the matching insns before the jump.  Also, remove any REG_EQUAL\n+     or REG_EQUIV note in the NEWLPOS stream that isn't also present in\n+     the NEWJPOS stream.  */\n+\n+  while (newjpos != insn)\n+    {\n+      rtx lnote;\n+\n+      for (lnote = REG_NOTES (newlpos); lnote; lnote = XEXP (lnote, 1))\n+\tif ((REG_NOTE_KIND (lnote) == REG_EQUAL\n+\t     || REG_NOTE_KIND (lnote) == REG_EQUIV)\n+\t    && ! find_reg_note (newjpos, REG_EQUAL, XEXP (lnote, 0))\n+\t    && ! find_reg_note (newjpos, REG_EQUIV, XEXP (lnote, 0)))\n+\t  remove_note (newlpos, lnote);\n+\n+      delete_insn (newjpos);\n+      newjpos = next_real_insn (newjpos);\n+      newlpos = next_real_insn (newlpos);\n+    }\n+}\n+\f\n /* Return the label before INSN, or put a new label there.  */\n \n rtx\n@@ -1269,6 +1658,50 @@ get_label_after (insn)\n   return label;\n }\n \f\n+/* Return 1 if INSN is a jump that jumps to right after TARGET\n+   only on the condition that TARGET itself would drop through.\n+   Assumes that TARGET is a conditional jump.  */\n+\n+static int\n+jump_back_p (insn, target)\n+     rtx insn, target;\n+{\n+  rtx cinsn, ctarget;\n+  enum rtx_code codei, codet;\n+  rtx set, tset;\n+\n+  if (! any_condjump_p (insn)\n+      || any_uncondjump_p (target)\n+      || target != prev_real_insn (JUMP_LABEL (insn)))\n+    return 0;\n+  set = pc_set (insn);\n+  tset = pc_set (target);\n+\n+  cinsn = XEXP (SET_SRC (set), 0);\n+  ctarget = XEXP (SET_SRC (tset), 0);\n+\n+  codei = GET_CODE (cinsn);\n+  codet = GET_CODE (ctarget);\n+\n+  if (XEXP (SET_SRC (set), 1) == pc_rtx)\n+    {\n+      codei = reversed_comparison_code (cinsn, insn);\n+      if (codei == UNKNOWN)\n+\treturn 0;\n+    }\n+\n+  if (XEXP (SET_SRC (tset), 2) == pc_rtx)\n+    {\n+      codet = reversed_comparison_code (ctarget, target);\n+      if (codei == UNKNOWN)\n+\treturn 0;\n+    }\n+\n+  return (codei == codet\n+\t  && rtx_renumbered_equal_p (XEXP (cinsn, 0), XEXP (ctarget, 0))\n+\t  && rtx_renumbered_equal_p (XEXP (cinsn, 1), XEXP (ctarget, 1)));\n+}\n+\f\n /* Given a comparison (CODE ARG0 ARG1), inside a insn, INSN, return an code\n    of reversed comparison if it is possible to do so.  Otherwise return UNKNOWN.\n    UNKNOWN may be returned in case we are having CC_MODE compare and we don't\n@@ -2038,12 +2471,16 @@ tension_vector_labels (x, idx)\n    must be kept distinct if we have not yet done loop-optimization,\n    because the gap between them is where loop-optimize\n    will want to move invariant code to.  CROSS_JUMP tells us\n-   that loop-optimization is done with.  */\n+   that loop-optimization is done with.\n+\n+   Once reload has completed (CROSS_JUMP non-zero), we need not consider\n+   two labels distinct if they are separated by only USE or CLOBBER insns.  */\n \n void\n-mark_jump_label (x, insn, in_mem)\n+mark_jump_label (x, insn, cross_jump, in_mem)\n      register rtx x;\n      rtx insn;\n+     int cross_jump;\n      int in_mem;\n {\n   register RTX_CODE code = GET_CODE (x);\n@@ -2072,7 +2509,7 @@ mark_jump_label (x, insn, in_mem)\n \n       /* If this is a constant-pool reference, see if it is a label.  */\n       if (CONSTANT_POOL_ADDRESS_P (x))\n-\tmark_jump_label (get_pool_constant (x), insn, in_mem);\n+\tmark_jump_label (get_pool_constant (x), insn, cross_jump, in_mem);\n       break;\n \n     case LABEL_REF:\n@@ -2100,14 +2537,19 @@ mark_jump_label (x, insn, in_mem)\n \t  {\n \t    if (GET_CODE (next) == CODE_LABEL)\n \t      label = next;\n+\t    else if (cross_jump && GET_CODE (next) == INSN\n+\t\t     && (GET_CODE (PATTERN (next)) == USE\n+\t\t\t || GET_CODE (PATTERN (next)) == CLOBBER))\n+\t      continue;\n \t    else if (GET_CODE (next) != NOTE)\n \t      break;\n-\t    else if ((NOTE_LINE_NUMBER (next) == NOTE_INSN_LOOP_BEG\n-\t\t      || NOTE_LINE_NUMBER (next) == NOTE_INSN_FUNCTION_END\n-\t\t      /* ??? Optional.  Disables some optimizations, but\n-\t\t\t makes gcov output more accurate with -O.  */\n-\t\t      || (flag_test_coverage\n-\t\t\t  && NOTE_LINE_NUMBER (next) > 0)))\n+\t    else if (! cross_jump\n+\t\t     && (NOTE_LINE_NUMBER (next) == NOTE_INSN_LOOP_BEG\n+\t\t\t || NOTE_LINE_NUMBER (next) == NOTE_INSN_FUNCTION_END\n+\t\t\t /* ??? Optional.  Disables some optimizations, but\n+\t\t\t    makes gcov output more accurate with -O.  */\n+\t\t\t || (flag_test_coverage\n+\t\t\t     && NOTE_LINE_NUMBER (next) > 0)))\n \t      break;\n \t  }\n \n@@ -2163,7 +2605,8 @@ mark_jump_label (x, insn, in_mem)\n \t  int eltnum = code == ADDR_DIFF_VEC ? 1 : 0;\n \n \t  for (i = 0; i < XVECLEN (x, eltnum); i++)\n-\t    mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX, in_mem);\n+\t    mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX,\n+\t\t\t     cross_jump, in_mem);\n \t}\n       return;\n \n@@ -2175,12 +2618,12 @@ mark_jump_label (x, insn, in_mem)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tmark_jump_label (XEXP (x, i), insn, in_mem);\n+\tmark_jump_label (XEXP (x, i), insn, cross_jump, in_mem);\n       else if (fmt[i] == 'E')\n \t{\n \t  register int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    mark_jump_label (XVECEXP (x, i, j), insn, in_mem);\n+\t    mark_jump_label (XVECEXP (x, i, j), insn, cross_jump, in_mem);\n \t}\n     }\n }"}, {"sha": "af5453db5865315adc8be65201efefef3bf5d22d", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -419,9 +419,6 @@ reg_to_stack (first, file)\n   int max_uid;\n   block_info bi;\n \n-  if (!optimize)\n-    split_all_insns (0);\n-\n   /* See if there is something to do.  Flow analysis is quite\n      expensive so we might save some compilation time.  */\n   for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n@@ -432,8 +429,7 @@ reg_to_stack (first, file)\n \n   /* Ok, floating point instructions exist.  If not optimizing, \n      build the CFG and run life analysis.  */\n-  if (!optimize)\n-    find_basic_blocks (first, max_reg_num (), file);\n+  find_basic_blocks (first, max_reg_num (), file);\n   count_or_remove_death_notes (NULL, 1);\n   life_analysis (first, file, PROP_DEATH_NOTES);\n "}, {"sha": "121e0f000a5e77468b0e9746ccedd9a6ce2d0f49", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -1285,7 +1285,7 @@ extern enum rtx_code reverse_condition_maybe_unordered PARAMS ((enum rtx_code));\n extern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));\n-extern void mark_jump_label\t\tPARAMS ((rtx, rtx, int));\n+extern void mark_jump_label\t\tPARAMS ((rtx, rtx, int, int));\n \n /* In jump.c */\n extern rtx squeeze_notes\t\tPARAMS ((rtx, rtx));\n@@ -1715,7 +1715,7 @@ extern int rtx_renumbered_equal_p\tPARAMS ((rtx, rtx));\n extern int true_regnum\t\t\tPARAMS ((rtx));\n extern int redirect_jump_1\t\tPARAMS ((rtx, rtx));\n extern int redirect_jump\t\tPARAMS ((rtx, rtx, int));\n-extern void jump_optimize\t\tPARAMS ((rtx, int, int));\n+extern void jump_optimize\t\tPARAMS ((rtx, int, int, int));\n extern void jump_optimize_minimal\tPARAMS ((rtx));\n extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n extern void thread_jumps\t\tPARAMS ((rtx, int, int));\n@@ -1729,6 +1729,8 @@ extern int condjump_in_parallel_p\tPARAMS ((rtx));\n extern void never_reached_warning\tPARAMS ((rtx));\n \n /* Flags for jump_optimize() */\n+#define JUMP_CROSS_JUMP\t\t\t1\n+#define JUMP_CROSS_JUMP_DEATH_MATTERS\t2\n #define JUMP_NOOP_MOVES\t\t\t1\n #define JUMP_AFTER_REGSCAN\t\t1\n "}, {"sha": "198790e75ab5d352eb9ed060dc3a2c6ca13bfd24", "filename": "gcc/toplev.c", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998d20d22a7632ac162773c0561bc8cd6f269f26/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=998d20d22a7632ac162773c0561bc8cd6f269f26", "patch": "@@ -282,10 +282,11 @@ enum dump_file_index\n   DFI_rnreg,\n   DFI_ce2,\n   DFI_sched2,\n-  DFI_stack,\n   DFI_bbro,\n+  DFI_jump2,\n   DFI_mach,\n   DFI_dbr,\n+  DFI_stack,\n   DFI_MAX\n };\n \n@@ -295,7 +296,7 @@ enum dump_file_index\n    Remaining -d letters:\n \n \t\"              o q   u     \"\n-\t\"       H JK   OPQ  TUV  YZ\"\n+\t\"       H  K   OPQ  TUV  YZ\"\n */\n \n struct dump_file_info dump_file[DFI_MAX] =\n@@ -329,6 +330,7 @@ struct dump_file_info dump_file[DFI_MAX] =\n   { \"ce2\",\t'E', 1, 0, 0 },\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"bbro\",\t'B', 1, 0, 0 },\n+  { \"jump2\",\t'J', 1, 0, 0 },\n   { \"mach\",\t'M', 1, 0, 0 },\n   { \"dbr\",\t'd', 0, 0, 0 },\n   { \"stack\",\t'k', 1, 0, 0 },\n@@ -2837,7 +2839,8 @@ rest_of_compilation (decl)\n \n \t      optimize = 0;\n \t      find_exception_handler_labels ();\n-\t      jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t      jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t\t     !JUMP_AFTER_REGSCAN);\n \t      optimize = saved_optimize;\n \t    }\n \n@@ -2944,7 +2947,8 @@ rest_of_compilation (decl)\n   expected_value_to_br_prob ();\n \n   reg_scan (insns, max_reg_num (), 0);\n-  jump_optimize (insns, !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n+  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t JUMP_AFTER_REGSCAN);\n \n   timevar_pop (TV_JUMP);\n \n@@ -3086,7 +3090,8 @@ rest_of_compilation (decl)\n       if (tem || optimize > 1)\n \t{\n \t  timevar_push (TV_JUMP);\n-\t  jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t\t !JUMP_AFTER_REGSCAN);\n \t  timevar_pop (TV_JUMP);\n \t}\n \n@@ -3158,7 +3163,8 @@ rest_of_compilation (decl)\n \t{\n \t  tem = tem2 = 0;\n \t  timevar_push (TV_JUMP);\n-\t  jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t\t !JUMP_AFTER_REGSCAN);\n \t  timevar_pop (TV_JUMP);\n \n \t  if (flag_expensive_optimizations)\n@@ -3231,7 +3237,8 @@ rest_of_compilation (decl)\n \t  delete_trivially_dead_insns (insns, max_reg_num ());\n \n \t  reg_scan (insns, max_reg_num (), 0);\n-\t  jump_optimize (insns, !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n+\t  jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t\t !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n \n \t  timevar_push (TV_IFCVT);\n \n@@ -3249,7 +3256,8 @@ rest_of_compilation (decl)\n \t  if (tem)\n \t    {\n \t      timevar_push (TV_JUMP);\n-\t      jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t      jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t\t     !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n \t      timevar_pop (TV_JUMP);\n \t    }\n \t}\n@@ -3563,7 +3571,8 @@ rest_of_compilation (decl)\n   timevar_push (TV_FLOW2);\n   open_dump_file (DFI_flow2, decl);\n \n-  jump_optimize (insns, JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+  jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n   /* On some machines, the prologue and epilogue code, or parts thereof,\n@@ -3628,10 +3637,6 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n       timevar_pop (TV_IFCVT2);\n     }\n-#ifdef STACK_REGS\n-  if (optimize)\n-    split_all_insns (1);\n-#endif\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n@@ -3658,17 +3663,6 @@ rest_of_compilation (decl)\n     = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n #endif\n \n-#ifdef STACK_REGS\n-  timevar_push (TV_REG_STACK);\n-  open_dump_file (DFI_stack, decl);\n-\n-  reg_to_stack (insns, rtl_dump_file);\n-\n-  close_dump_file (DFI_stack, print_rtl, insns);\n-  timevar_pop (TV_REG_STACK);\n-\n-  ggc_collect ();\n-#endif\n   if (optimize > 0 && flag_reorder_blocks)\n     {\n       timevar_push (TV_REORDER_BLOCKS);\n@@ -3677,10 +3671,26 @@ rest_of_compilation (decl)\n       reorder_basic_blocks ();\n \n       close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n       timevar_pop (TV_REORDER_BLOCKS);\n     }\n \n+  /* One more attempt to remove jumps to .+1 left by dead-store elimination.\n+     Also do cross-jumping this time and delete no-op move insns.  */\n+\n+  if (optimize > 0)\n+    {\n+      timevar_push (TV_JUMP);\n+      open_dump_file (DFI_jump2, decl);\n+\n+      jump_optimize (insns, JUMP_CROSS_JUMP, JUMP_NOOP_MOVES,\n+\t\t     !JUMP_AFTER_REGSCAN);\n+\n+      /* CFG no longer kept up to date.  */\n+\n+      close_dump_file (DFI_jump2, print_rtl, insns);\n+      timevar_pop (TV_JUMP);\n+    }\n+\n   /* If a machine dependent reorganization is needed, call it.  */\n #ifdef MACHINE_DEPENDENT_REORG\n   open_dump_file (DFI_mach, decl);\n@@ -3692,8 +3702,6 @@ rest_of_compilation (decl)\n   ggc_collect ();\n #endif\n \n-  /* CFG no longer kept up to date.  */\n-\n   /* If a scheduling pass for delayed branches is to be done,\n      call the scheduling code.  */\n \n@@ -3712,10 +3720,28 @@ rest_of_compilation (decl)\n     }\n #endif\n \n-#if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n   timevar_push (TV_SHORTEN_BRANCH);\n-  split_all_insns (0);\n+  if (0\n+#ifdef HAVE_ATTR_length\n+      || 1\n+#endif\n+#ifdef STACK_REGS\n+      || 1\n+#endif\n+      )\n+    split_all_insns (0);\n   timevar_pop (TV_SHORTEN_BRANCH);\n+\n+#ifdef STACK_REGS\n+  timevar_push (TV_REG_STACK);\n+  open_dump_file (DFI_stack, decl);\n+\n+  reg_to_stack (insns, rtl_dump_file);\n+\n+  close_dump_file (DFI_stack, print_rtl, insns);\n+  timevar_pop (TV_REG_STACK);\n+\n+  ggc_collect ();\n #endif\n \n   convert_to_eh_region_ranges ();"}]}