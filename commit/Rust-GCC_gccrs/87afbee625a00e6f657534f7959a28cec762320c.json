{"sha": "87afbee625a00e6f657534f7959a28cec762320c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdhZmJlZTYyNWEwMGU2ZjY1NzUzNGY3OTU5YTI4Y2VjNzYyMzIwYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-07-14T22:30:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-07-14T22:30:24Z"}, "message": "reload.c (find_reloads): Emit a USE for a pseudo register without a hard register if...\n\n\ufffd\n        * reload.c (find_reloads): Emit a USE for a pseudo register without\n        a hard register if we could not create an optional reload for the\n        pseudo.\n\nFrom-SVN: r28103", "tree": {"sha": "88ffb81405bba08f3effade2c45b96d557a98c1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88ffb81405bba08f3effade2c45b96d557a98c1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87afbee625a00e6f657534f7959a28cec762320c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87afbee625a00e6f657534f7959a28cec762320c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87afbee625a00e6f657534f7959a28cec762320c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87afbee625a00e6f657534f7959a28cec762320c/comments", "author": null, "committer": null, "parents": [{"sha": "bb183b9e6bd24141a9754677a782d341b52d00e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb183b9e6bd24141a9754677a782d341b52d00e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb183b9e6bd24141a9754677a782d341b52d00e3"}], "stats": {"total": 9, "additions": 7, "deletions": 2}, "files": [{"sha": "d8b41363d3633d479d61892e7bccd745d3f0ab6a", "filename": "gcc/reload.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87afbee625a00e6f657534f7959a28cec762320c/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87afbee625a00e6f657534f7959a28cec762320c/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=87afbee625a00e6f657534f7959a28cec762320c", "patch": "@@ -3803,11 +3803,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   (insn_code_number < 0 ? 0\n \t\t\t    : insn_operand_strict_low[insn_code_number][i]),\n \t\t\t   1, i, operand_type[i]);\n-\t/* If a memory reference remains, yet we can't make an optional\n+\t/* If a memory reference remains (either as a MEM or a pseudo that\n+\t   did not get a hard register), yet we can't make an optional\n \t   reload, check if this is actually a pseudo register reference;\n \t   we then need to emit a USE and/or a CLOBBER so that reload\n \t   inheritance will do the right thing.  */\n-\telse if (replace && GET_CODE (operand) == MEM)\n+\telse if (replace\n+\t\t && (GET_CODE (operand) == MEM\n+\t\t     || (GET_CODE (operand) == REG\n+\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t && reg_renumber [REGNO (operand)] < 0)))\n \t  {\n \t    operand = *recog_operand_loc[i];\n "}]}