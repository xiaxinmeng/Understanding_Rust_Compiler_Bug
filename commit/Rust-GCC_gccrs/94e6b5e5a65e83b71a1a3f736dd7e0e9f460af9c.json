{"sha": "94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlNmI1ZTVhNjVlODNiNzFhMWEzZjczNmRkN2UwZTlmNDYwYWY5Yw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2018-03-03T19:49:20Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2018-03-03T19:49:20Z"}, "message": "re PR fortran/66128 (ICE for some intrinsics with zero sized array parameter)\n\n2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/66128\n\t* simplify.c (is_size_zero_array): New function to check for size\n\tzero array.\n\t(gfc_simplify_all, gfc_simplify_any, gfc_simplify_count, \n\t gfc_simplify_iall, gfc_simplify_iany, gfc_simplify_iparity,\n\t gfc_simplify_minval, gfc_simplify_maxval, gfc_simplify_norm2,\n\t gfc_simplify_product, gfc_simplify_sum): Use it, and implement\n\trequirements from F2018.\n\n2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/66128\n\t* gfortran.dg/zero_sized_8.f90: New test.\n\nFrom-SVN: r258223", "tree": {"sha": "d77c4c3d7937a60e71eede30aa46811774b9b017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d77c4c3d7937a60e71eede30aa46811774b9b017"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c/comments", "author": null, "committer": null, "parents": [{"sha": "250540af390875625bf9c611597786c29addafb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250540af390875625bf9c611597786c29addafb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/250540af390875625bf9c611597786c29addafb9"}], "stats": {"total": 196, "additions": 196, "deletions": 0}, "files": [{"sha": "eb64c7452f173c84c7715a0e2dee5c68d26c51ec", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c", "patch": "@@ -1,3 +1,14 @@\n+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/66128\n+\t* simplify.c (is_size_zero_array): New function to check for size\n+\tzero array.\n+\t(gfc_simplify_all, gfc_simplify_any, gfc_simplify_count, \n+\t gfc_simplify_iall, gfc_simplify_iany, gfc_simplify_iparity,\n+\t gfc_simplify_minval, gfc_simplify_maxval, gfc_simplify_norm2,\n+\t gfc_simplify_product, gfc_simplify_sum): Use it, and implement\n+\trequirements from F2018.\n+\n 2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/51434"}, {"sha": "3bd98688e8839b074a74c9224057d0d5207243d6", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c", "patch": "@@ -258,6 +258,29 @@ is_constant_array_expr (gfc_expr *e)\n   return true;\n }\n \n+/* Test for a size zero array.  */\n+static bool\n+is_size_zero_array (gfc_expr *array)\n+{\n+  gfc_expr *e;\n+  bool t;\n+\n+  e = gfc_copy_expr (array);\n+  gfc_simplify_expr (e, 1);\n+\n+  if (e->expr_type == EXPR_CONSTANT && e->rank > 0 && !e->shape)\n+     t = true;\n+  else if (e->expr_type == EXPR_ARRAY && e->rank > 0 \n+\t   && !e->shape && !e->value.constructor)\n+     t = true;\n+  else\n+     t = false;\n+\n+  gfc_free_expr (e);\n+\n+  return t;\n+}\n+\n \n /* Initialize a transformational result expression with a given value.  */\n \n@@ -951,6 +974,9 @@ gfc_simplify_aint (gfc_expr *e, gfc_expr *k)\n gfc_expr *\n gfc_simplify_all (gfc_expr *mask, gfc_expr *dim)\n {\n+  if (is_size_zero_array (mask))\n+    return gfc_get_logical_expr (mask->ts.kind, &mask->where, true);\n+\n   return simplify_transformation (mask, dim, NULL, true, gfc_and);\n }\n \n@@ -1040,6 +1066,9 @@ gfc_simplify_and (gfc_expr *x, gfc_expr *y)\n gfc_expr *\n gfc_simplify_any (gfc_expr *mask, gfc_expr *dim)\n {\n+  if (is_size_zero_array (mask))\n+    return gfc_get_logical_expr (mask->ts.kind, &mask->where, false);\n+\n   return simplify_transformation (mask, dim, NULL, false, gfc_or);\n }\n \n@@ -1936,6 +1965,13 @@ gfc_simplify_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n {\n   gfc_expr *result;\n \n+  if (is_size_zero_array (mask))\n+    {\n+      int k;\n+      k = kind ? mpz_get_si (kind->value.integer) : gfc_default_integer_kind;\n+      return gfc_get_int_expr (k, NULL, 0);\n+    }\n+\n   if (!is_constant_array_expr (mask)\n       || !gfc_is_constant_expr (dim)\n       || !gfc_is_constant_expr (kind))\n@@ -3227,6 +3263,9 @@ do_bit_and (gfc_expr *result, gfc_expr *e)\n gfc_expr *\n gfc_simplify_iall (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n+  if (is_size_zero_array (array))\n+    return gfc_get_int_expr (array->ts.kind, NULL, -1);\n+\n   return simplify_transformation (array, dim, mask, -1, do_bit_and);\n }\n \n@@ -3246,6 +3285,9 @@ do_bit_ior (gfc_expr *result, gfc_expr *e)\n gfc_expr *\n gfc_simplify_iany (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n+  if (is_size_zero_array (array))\n+    return gfc_get_int_expr (array->ts.kind, NULL, 0);\n+\n   return simplify_transformation (array, dim, mask, 0, do_bit_ior);\n }\n \n@@ -3686,6 +3728,9 @@ do_bit_xor (gfc_expr *result, gfc_expr *e)\n gfc_expr *\n gfc_simplify_iparity (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n+  if (is_size_zero_array (array))\n+    return gfc_get_int_expr (array->ts.kind, NULL, 0);\n+\n   return simplify_transformation (array, dim, mask, 0, do_bit_xor);\n }\n \n@@ -4993,6 +5038,43 @@ gfc_min (gfc_expr *op1, gfc_expr *op2)\n gfc_expr *\n gfc_simplify_minval (gfc_expr *array, gfc_expr* dim, gfc_expr *mask)\n {\n+  if (is_size_zero_array (array))\n+    {\n+      gfc_expr *result;\n+      int i;\n+\n+      i = gfc_validate_kind (array->ts.type, array->ts.kind, false);\n+      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n+\t\t\t\t      &array->where);\n+      switch (array->ts.type)\n+\t{\n+\t  case BT_INTEGER:\n+\t    mpz_set (result->value.integer, gfc_integer_kinds[i].huge);\n+\t    break;\n+\n+\t  case BT_REAL:\n+\t    mpfr_set (result->value.real, gfc_real_kinds[i].huge, GFC_RND_MODE);\n+\t    break;\n+\n+\t  case BT_CHARACTER:\n+\t    /* If ARRAY has size zero and type character, the result has the\n+\t       value of a string of characters of length LEN (ARRAY), with\n+\t       each character equal to CHAR(n - 1, KIND (ARRAY)), where n is\n+\t       the number of characters in the collating sequence for\n+\t       characters with the kind type parameter of ARRAY.  */\n+\t    gfc_error (\"MINVAL(string) at %L is not implemented, yet!\",\n+\t\t\t&array->where);\n+\t    gfc_free_expr (result);\n+\t    return &gfc_bad_expr;\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+    \t}\n+\n+      return result;\n+    }\n+\n   return simplify_transformation (array, dim, mask, INT_MAX, gfc_min);\n }\n \n@@ -5012,6 +5094,42 @@ gfc_max (gfc_expr *op1, gfc_expr *op2)\n gfc_expr *\n gfc_simplify_maxval (gfc_expr *array, gfc_expr* dim, gfc_expr *mask)\n {\n+  if (is_size_zero_array (array))\n+    {\n+      gfc_expr *result;\n+      int i;\n+\n+      i = gfc_validate_kind (array->ts.type, array->ts.kind, false);\n+      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n+\t\t\t\t      &array->where);\n+      switch (array->ts.type)\n+\t{\n+\t  case BT_INTEGER:\n+\t    mpz_set (result->value.integer, gfc_integer_kinds[i].min_int);\n+\t    break;\n+\n+\t  case BT_REAL:\n+\t    mpfr_set (result->value.real, gfc_real_kinds[i].huge, GFC_RND_MODE);\n+\t    mpfr_neg (result->value.real, result->value.real,  GFC_RND_MODE);\n+\t    break;\n+\n+\t  case BT_CHARACTER:\n+\t    /* If ARRAY has size zero and type character, the result has the\n+               value of a string of characters of length LEN (ARRAY), with\n+               each character equal to CHAR (0, KIND (ARRAY)).  */\n+\t    gfc_error (\"MAXVAL(string) at %L is not implemented, yet!\",\n+\t\t\t&array->where);\n+\t    gfc_free_expr (result);\n+\t    return &gfc_bad_expr;\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+    \t}\n+\n+      return result;\n+    }\n+\n   return simplify_transformation (array, dim, mask, INT_MIN, gfc_max);\n }\n \n@@ -5658,6 +5776,14 @@ gfc_simplify_norm2 (gfc_expr *e, gfc_expr *dim)\n {\n   gfc_expr *result;\n \n+  if (is_size_zero_array (e))\n+    {\n+      gfc_expr *result;\n+      result = gfc_get_constant_expr (e->ts.type, e->ts.kind, &e->where);\n+      mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n+      return result;\n+    }\n+\n   if (!is_constant_array_expr (e)\n       || (dim != NULL && !gfc_is_constant_expr (dim)))\n     return NULL;\n@@ -5914,6 +6040,33 @@ gfc_simplify_precision (gfc_expr *e)\n gfc_expr *\n gfc_simplify_product (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n+  if (is_size_zero_array (array))\n+    {\n+      gfc_expr *result;\n+\n+      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n+\t\t\t\t      &array->where);\n+      switch (array->ts.type)\n+\t{\n+\t  case BT_INTEGER:\n+\t    mpz_set_ui (result->value.integer, 1);\n+\t    break;\n+\n+\t  case BT_REAL:\n+\t    mpfr_set_ui (result->value.real, 1, GFC_RND_MODE);\n+\t    break;\n+\n+\t  case BT_COMPLEX:\n+\t    mpc_set_ui (result->value.complex, 1, GFC_MPC_RND_MODE);\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+    \t}\n+\n+      return result;\n+    }\n+\n   return simplify_transformation (array, dim, mask, 1, gfc_multiply);\n }\n \n@@ -7231,6 +7384,33 @@ gfc_simplify_sqrt (gfc_expr *e)\n gfc_expr *\n gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n+  if (is_size_zero_array (array))\n+    {\n+      gfc_expr *result;\n+\n+      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n+\t\t\t\t      &array->where);\n+      switch (array->ts.type)\n+\t{\n+\t  case BT_INTEGER:\n+\t    mpz_set_ui (result->value.integer, 0);\n+\t    break;\n+\n+\t  case BT_REAL:\n+\t    mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n+\t    break;\n+\n+\t  case BT_COMPLEX:\n+\t    mpc_set_ui (result->value.complex, 0, GFC_MPC_RND_MODE);\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+    \t}\n+\n+      return result;\n+    }\n+\n   return simplify_transformation (array, dim, mask, 0, gfc_add);\n }\n "}, {"sha": "1df6a18f4e082725d5f9b338c9de9cdbb7f5077d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=94e6b5e5a65e83b71a1a3f736dd7e0e9f460af9c", "patch": "@@ -1,3 +1,8 @@\n+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/66128\n+\t* gfortran.dg/zero_sized_8.f90: New test.\n+\n 2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/51434"}]}