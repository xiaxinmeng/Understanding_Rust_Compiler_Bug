{"sha": "24bd3c6e80acc80f02d5016cf192a702553ae673", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRiZDNjNmU4MGFjYzgwZjAyZDUwMTZjZjE5MmE3MDI1NTNhZTY3Mw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2015-12-17T14:10:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2015-12-17T14:10:03Z"}, "message": "DWARF: describe Ada dynamic arrays as proper arrays\n\ngcc/ada/ChangeLog:\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): When\n\t-fgnat-encodings-minimal, do not add ___XUP/XUT suffixes to type\n\tnames and do not generate ___XA parallel types.\n\t* gcc-interface/misc.c (gnat_get_array_descr_info): Match fat\n\tand thin pointers and generate the corresponding array type\n\tdescriptions.\n\nFrom-SVN: r231765", "tree": {"sha": "03b4f9cf1230ddb91051cb4ef4c4d96ccc9563b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03b4f9cf1230ddb91051cb4ef4c4d96ccc9563b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24bd3c6e80acc80f02d5016cf192a702553ae673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bd3c6e80acc80f02d5016cf192a702553ae673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24bd3c6e80acc80f02d5016cf192a702553ae673", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bd3c6e80acc80f02d5016cf192a702553ae673/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2971780e404ebe8f3094c4d014b258b5c337959d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2971780e404ebe8f3094c4d014b258b5c337959d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2971780e404ebe8f3094c4d014b258b5c337959d"}], "stats": {"total": 234, "additions": 195, "deletions": 39}, "files": [{"sha": "4cf3fe4b4ea2664ea043d8e120933e4a8424fd1d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd3c6e80acc80f02d5016cf192a702553ae673/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd3c6e80acc80f02d5016cf192a702553ae673/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=24bd3c6e80acc80f02d5016cf192a702553ae673", "patch": "@@ -1,3 +1,12 @@\n+2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): When\n+\t-fgnat-encodings-minimal, do not add ___XUP/XUT suffixes to type\n+\tnames and do not generate ___XA parallel types.\n+\t* gcc-interface/misc.c (gnat_get_array_descr_info): Match fat\n+\tand thin pointers and generate the corresponding array type\n+\tdescriptions.\n+\n 2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc-interface/ada-tree.def (POWER_EXPR): New binary operation."}, {"sha": "287898ffb94c7fdd662e9228a5522a3f045ac6dc", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd3c6e80acc80f02d5016cf192a702553ae673/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd3c6e80acc80f02d5016cf192a702553ae673/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=24bd3c6e80acc80f02d5016cf192a702553ae673", "patch": "@@ -2274,22 +2274,31 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"), tem,\n \t\t\t  artificial_p, debug_info_p, gnat_entity);\n \n-\t/* Give the fat pointer type a name.  If this is a packed array, tell\n-\t   the debugger how to interpret the underlying bits.  */\n+\t/* If told to generate GNAT encodings for them (GDB rely on them at the\n+\t   moment): give the fat pointer type a name.  If this is a packed\n+\t   array, tell the debugger how to interpret the underlying bits.  */\n \tif (Present (Packed_Array_Impl_Type (gnat_entity)))\n \t  gnat_name = Packed_Array_Impl_Type (gnat_entity);\n \telse\n \t  gnat_name = gnat_entity;\n-\tcreate_type_decl (create_concat_name (gnat_name, \"XUP\"), gnu_fat_type,\n-\t\t\t  artificial_p, debug_info_p, gnat_entity);\n+\tif (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t  gnu_entity_name = create_concat_name (gnat_name, \"XUP\");\n+\tcreate_type_decl (gnu_entity_name, gnu_fat_type, artificial_p,\n+\t\t\t  debug_info_p, gnat_entity);\n \n \t/* Create the type to be designated by thin pointers: a record type for\n \t   the array and its template.  We used to shift the fields to have the\n \t   template at a negative offset, but this was somewhat of a kludge; we\n \t   now shift thin pointer values explicitly but only those which have a\n-\t   TYPE_UNCONSTRAINED_ARRAY attached to the designated RECORD_TYPE.  */\n-\ttem = build_unc_object_type (gnu_template_type, tem,\n-\t\t\t\t     create_concat_name (gnat_name, \"XUT\"),\n+\t   TYPE_UNCONSTRAINED_ARRAY attached to the designated RECORD_TYPE.\n+\t   Note that GDB can handle standard DWARF information for them, so we\n+\t   don't have to name them as a GNAT encoding, except if specifically\n+\t   asked to.  */\n+\tif (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t  gnu_entity_name = create_concat_name (gnat_name, \"XUT\");\n+\telse\n+\t  gnu_entity_name = get_entity_name (gnat_name);\n+\ttem = build_unc_object_type (gnu_template_type, tem, gnu_entity_name,\n \t\t\t\t     debug_info_p);\n \n \tSET_TYPE_UNCONSTRAINED_ARRAY (tem, gnu_type);\n@@ -2522,14 +2531,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* We need special types for debugging information to point to\n \t\t the index types if they have variable bounds, are not integer\n-\t\t types or are biased.  */\n-\t      if (TREE_CODE (gnu_orig_min) != INTEGER_CST\n-\t\t  || TREE_CODE (gnu_orig_max) != INTEGER_CST\n-\t\t  || TREE_CODE (gnu_index_type) != INTEGER_TYPE\n-\t\t  || (TREE_TYPE (gnu_index_type)\n-\t\t      && TREE_CODE (TREE_TYPE (gnu_index_type))\n-\t\t\t != INTEGER_TYPE)\n-\t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_index_type))\n+\t\t types, are biased or are wider than sizetype.  These are GNAT\n+\t\t encodings, so we have to include them only when all encodings\n+\t\t are requested.  */\n+\t      if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\t\t  && (TREE_CODE (gnu_orig_min) != INTEGER_CST\n+\t\t      || TREE_CODE (gnu_orig_max) != INTEGER_CST\n+\t\t      || TREE_CODE (gnu_index_type) != INTEGER_TYPE\n+\t\t      || (TREE_TYPE (gnu_index_type)\n+\t\t\t  && TREE_CODE (TREE_TYPE (gnu_index_type))\n+\t\t\t     != INTEGER_TYPE)\n+\t\t      || TYPE_BIASED_REPRESENTATION_P (gnu_index_type)))\n \t\tneed_index_type_struct = true;\n \t    }\n "}, {"sha": "279e5fcaa37f8c55a11b97214a8fc363b645fd43", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 159, "deletions": 24, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd3c6e80acc80f02d5016cf192a702553ae673/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd3c6e80acc80f02d5016cf192a702553ae673/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=24bd3c6e80acc80f02d5016cf192a702553ae673", "patch": "@@ -739,54 +739,189 @@ static bool\n gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n {\n   bool convention_fortran_p;\n-  tree index_type;\n+  bool is_array = false;\n+  bool is_fat_ptr = false;\n \n-  const_tree dimen = NULL_TREE;\n+  const tree type_ = const_cast<tree> (type);\n+\n+  const_tree first_dimen = NULL_TREE;\n   const_tree last_dimen = NULL_TREE;\n+  const_tree dimen;\n   int i;\n \n-  if (TREE_CODE (type) != ARRAY_TYPE\n-      || !TYPE_DOMAIN (type)\n-      || !TYPE_INDEX_TYPE (TYPE_DOMAIN (type)))\n+  /* Temporaries created in the first pass and used in the second one for thin\n+     pointers.  The first one is an expression that yields the template record\n+     from the base address (i.e. the PLACEHOLDER_EXPR).  The second one is just\n+     a cursor through this record's fields.  */\n+  tree thinptr_template_expr = NULL_TREE;\n+  tree thinptr_bound_field = NULL_TREE;\n+\n+  /* First pass: gather all information about this array except everything\n+     related to dimensions.  */\n+\n+  /* Only handle ARRAY_TYPE nodes that come from GNAT.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_DOMAIN (type)\n+      && TYPE_INDEX_TYPE (TYPE_DOMAIN (type)))\n+    {\n+      is_array = true;\n+      first_dimen = type;\n+      info->data_location = NULL_TREE;\n+    }\n+\n+  else if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n+\t   && TYPE_IS_FAT_POINTER_P (type))\n+    {\n+      const tree ua_type = TYPE_UNCONSTRAINED_ARRAY (type_);\n+\n+      /* This will be our base object address.  */\n+      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type_);\n+\n+      /* We assume below that maybe_unconstrained_array returns an INDIRECT_REF\n+\t node.  */\n+      const tree ua_val\n+        = maybe_unconstrained_array (build_unary_op (INDIRECT_REF,\n+\t\t\t\t\t\t     ua_type,\n+\t\t\t\t\t\t     placeholder_expr));\n+\n+      is_fat_ptr = true;\n+      first_dimen = TREE_TYPE (ua_val);\n+\n+      /* Get the *address* of the array, not the array itself.  */\n+      info->data_location = TREE_OPERAND (ua_val, 0);\n+    }\n+\n+  /* Unlike fat pointers (which appear for unconstrained arrays passed in\n+     argument), thin pointers are used only for array access types, so we want\n+     them to appear in the debug info as pointers to an array type.  That's why\n+     we match only the RECORD_TYPE here instead of the POINTER_TYPE with the\n+     TYPE_IS_THIN_POINTER_P predicate.  */\n+  else if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n+\t   && TREE_CODE (type) == RECORD_TYPE\n+\t   && TYPE_CONTAINS_TEMPLATE_P (type))\n+    {\n+      /* This will be our base object address.  Note that we assume that\n+\t pointers to these will actually point to the array field (thin\n+\t pointers are shifted).  */\n+      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type_);\n+      const tree placeholder_addr\n+        = build_unary_op (ADDR_EXPR, NULL_TREE, placeholder_expr);\n+\n+      const tree bounds_field = TYPE_FIELDS (type);\n+      const tree bounds_type = TREE_TYPE (bounds_field);\n+      const tree array_field = DECL_CHAIN (bounds_field);\n+      const tree array_type = TREE_TYPE (array_field);\n+\n+      /* Shift the thin pointer address to get the address of the template.  */\n+      const tree shift_amount\n+\t= fold_build1 (NEGATE_EXPR, sizetype, byte_position (array_field));\n+      tree template_addr\n+\t= build_binary_op (POINTER_PLUS_EXPR, TREE_TYPE (placeholder_addr),\n+\t\t\t   placeholder_addr, shift_amount);\n+      template_addr\n+\t= fold_convert (TYPE_POINTER_TO (bounds_type), template_addr);\n+\n+      first_dimen = array_type;\n+\n+      /* The thin pointer is already the pointer to the array data, so there's\n+\t no need for a specific \"data location\" expression.  */\n+      info->data_location = NULL_TREE;\n+\n+      thinptr_template_expr = build_unary_op (INDIRECT_REF,\n+\t\t\t\t\t      bounds_type,\n+\t\t\t\t\t      template_addr);\n+      thinptr_bound_field = TYPE_FIELDS (bounds_type);\n+    }\n+  else\n     return false;\n \n-  /* Count how many dimentions this array has.  */\n-  for (i = 0, dimen = type; ; ++i, dimen = TREE_TYPE (dimen))\n-    if (i > 0\n-\t&& (TREE_CODE (dimen) != ARRAY_TYPE\n-\t    || !TYPE_MULTI_ARRAY_P (dimen)))\n-      break;\n-  info->ndimensions = i;\n-  convention_fortran_p = TYPE_CONVENTION_FORTRAN_P (type);\n+  /* Second pass: compute the remaining information: dimensions and\n+     corresponding bounds.  */\n \n-  /* TODO: for row major ordering, we probably want to emit nothing and\n+  /* If this array has fortran convention, it's arranged in column-major\n+     order, so our view here has reversed dimensions.  */\n+  convention_fortran_p = TYPE_CONVENTION_FORTRAN_P (first_dimen);\n+  /* ??? For row major ordering, we probably want to emit nothing and\n      instead specify it as the default in Dw_TAG_compile_unit.  */\n   info->ordering = (convention_fortran_p\n \t\t    ? array_descr_ordering_column_major\n \t\t    : array_descr_ordering_row_major);\n-  info->base_decl = NULL_TREE;\n-  info->data_location = NULL_TREE;\n-  info->allocated = NULL_TREE;\n-  info->associated = NULL_TREE;\n \n+  /* Count how many dimensions this array has.  */\n+  for (i = 0, dimen = first_dimen; ; ++i, dimen = TREE_TYPE (dimen))\n+    {\n+      if (i > 0\n+\t  && (TREE_CODE (dimen) != ARRAY_TYPE\n+\t      || !TYPE_MULTI_ARRAY_P (dimen)))\n+\tbreak;\n+      last_dimen = dimen;\n+    }\n+  info->ndimensions = i;\n+  info->element_type = TREE_TYPE (last_dimen);\n+\n+  /* Now iterate over all dimensions in source-order and fill the info\n+     structure.  */\n   for (i = (convention_fortran_p ? info->ndimensions - 1 : 0),\n-       dimen = type;\n+       dimen = first_dimen;\n \n        0 <= i && i < info->ndimensions;\n \n        i += (convention_fortran_p ? -1 : 1),\n        dimen = TREE_TYPE (dimen))\n     {\n       /* We are interested in the stored bounds for the debug info.  */\n-      index_type = TYPE_INDEX_TYPE (TYPE_DOMAIN (dimen));\n+      tree index_type = TYPE_INDEX_TYPE (TYPE_DOMAIN (dimen));\n \n+      if (is_array || is_fat_ptr)\n+\t{\n+\t  /* GDB does not handle very well the self-referencial bound\n+\t     expressions we are able to generate here for XUA types (they are\n+\t     used only by XUP encodings) so avoid them in this case.  Note that\n+\t     there are two cases where we generate self-referencial bound\n+\t     expressions:  arrays that are constrained by record discriminants\n+\t     and XUA types.  */\n+\t  const bool is_xua_type =\n+\t   (TREE_CODE (TYPE_CONTEXT (first_dimen)) != RECORD_TYPE\n+\t    && contains_placeholder_p (TYPE_MIN_VALUE (index_type)));\n+\n+\t  if (is_xua_type && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t    {\n+\t      info->dimen[i].lower_bound = NULL_TREE;\n+\t      info->dimen[i].upper_bound = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      info->dimen[i].lower_bound = TYPE_MIN_VALUE (index_type);\n+\t      info->dimen[i].upper_bound = TYPE_MAX_VALUE (index_type);\n+\t    }\n+\t}\n+\n+      /* This is a thin pointer.  */\n+      else\n+\t{\n+\t  info->dimen[i].lower_bound\n+\t    = build_component_ref (thinptr_template_expr, thinptr_bound_field,\n+\t\t\t\t   false);\n+\t  thinptr_bound_field = DECL_CHAIN (thinptr_bound_field);\n+\n+\t  info->dimen[i].upper_bound\n+\t    = build_component_ref (thinptr_template_expr, thinptr_bound_field,\n+\t\t\t\t   false);\n+\t  thinptr_bound_field = DECL_CHAIN (thinptr_bound_field);\n+\t}\n+\n+      /* The DWARF back-end will output exactly INDEX_TYPE as the array index'\n+\t \"root\" type, so pell subtypes when possible.  */\n+      while (TREE_TYPE (index_type) != NULL_TREE\n+\t     && !subrange_type_for_debug_p (index_type, NULL, NULL))\n+\tindex_type = TREE_TYPE (index_type);\n       info->dimen[i].bounds_type = index_type;\n-      info->dimen[i].lower_bound = TYPE_MIN_VALUE (index_type);\n-      info->dimen[i].upper_bound = TYPE_MAX_VALUE (index_type);\n-      last_dimen = dimen;\n+      info->dimen[i].stride = NULL_TREE;\n     }\n \n-  info->element_type = TREE_TYPE (last_dimen);\n+  /* These are Fortran-specific fields.  They make no sense here.  */\n+  info->allocated = NULL_TREE;\n+  info->associated = NULL_TREE;\n \n   /* When arrays contain dynamically-sized elements, we usually wrap them in\n      padding types, or we create constrained types for them.  Then, if such"}]}