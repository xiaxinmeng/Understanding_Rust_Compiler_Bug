{"sha": "31e6f8293362979aea53b5cae3fa6ab0b6981694", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFlNmY4MjkzMzYyOTc5YWVhNTNiNWNhZTNmYTZhYjBiNjk4MTY5NA==", "commit": {"author": {"name": "Paul Thomas", "email": "paul.richard.thomas@gmail.com", "date": "2020-04-30T08:56:01Z"}, "committer": {"name": "Paul Thomas", "email": "paul.richard.thomas@gmail.com", "date": "2020-04-30T08:56:01Z"}, "message": "PR94725 - deleting gfortran.dg/dtio_5.f90 and pdt_5.f03", "tree": {"sha": "416ab7090d086378cbdc674c5770131d28b18314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/416ab7090d086378cbdc674c5770131d28b18314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31e6f8293362979aea53b5cae3fa6ab0b6981694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e6f8293362979aea53b5cae3fa6ab0b6981694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e6f8293362979aea53b5cae3fa6ab0b6981694", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e6f8293362979aea53b5cae3fa6ab0b6981694/comments", "author": null, "committer": null, "parents": [{"sha": "03afbf335776916724b0608c256495c04a369d2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03afbf335776916724b0608c256495c04a369d2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03afbf335776916724b0608c256495c04a369d2b"}], "stats": {"total": 503, "additions": 0, "deletions": 503}, "files": [{"sha": "f761b2594865fe5a7c8f1e34515b360d4a4e3fb8", "filename": "gcc/testsuite/gfortran.dg/dtio_5.f90", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03afbf335776916724b0608c256495c04a369d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03afbf335776916724b0608c256495c04a369d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_5.f90?ref=03afbf335776916724b0608c256495c04a369d2b", "patch": "@@ -1,280 +0,0 @@\n-! { dg-do run }\n-!\n-! This test is based on the second case in the PGInsider article at\n-! https://www.pgroup.com/lit/articles/insider/v6n2a3.htm\n-!\n-! The complete original code is at:\n-! https://www.pgroup.com/lit/samples/pginsider/stack.f90\n-!\n-! Thanks to Mark LeAir.\n-!\n-!     Copyright (c) 2015, NVIDIA CORPORATION.  All rights reserved.\n-!\n-! NVIDIA CORPORATION and its licensors retain all intellectual property\n-! and proprietary rights in and to this software, related documentation\n-! and any modifications thereto.  Any use, reproduction, disclosure or\n-! distribution of this software and related documentation without an express\n-! license agreement from NVIDIA CORPORATION is strictly prohibited.\n-!\n-\n-!          THIS CODE AND INFORMATION ARE PROVIDED \"AS IS\" WITHOUT\n-!   WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT\n-!   NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR\n-!   FITNESS FOR A PARTICULAR PURPOSE.\n-!\n-\n-module stack_mod\n-\n-  type, abstract :: stack\n-     private\n-     class(*), allocatable :: item           ! an item on the stack\n-     class(stack), pointer :: next=>null()   ! next item on the stack\n-   contains\n-     procedure :: empty                      ! returns true if stack is empty\n-     procedure :: delete                     ! empties the stack\n-  end type stack\n-\n-type, extends(stack) :: integer_stack\n-contains\n-  procedure :: push => push_integer ! add integer item to stack\n-  procedure :: pop => pop_integer   ! remove integer item from stack\n-  procedure :: compare => compare_integer   ! compare with an integer array\n-end type integer_stack\n-\n-type, extends(integer_stack) :: io_stack\n-contains\n-  procedure,private :: wio_stack\n-  procedure,private :: rio_stack\n-  procedure,private :: dump_stack\n-  generic :: write(unformatted) => wio_stack ! write stack item to file\n-  generic :: read(unformatted) => rio_stack  ! push item from file\n-  generic :: write(formatted) => dump_stack  ! print all items from stack\n-end type io_stack\n-\n-contains\n-\n-  subroutine rio_stack (dtv, unit, iostat, iomsg)\n-\n-    ! read item from file and add it to stack\n-\n-    class(io_stack), intent(inout) :: dtv\n-    integer, intent(in) :: unit\n-    integer, intent(out) :: iostat\n-    character(len=*), intent(inout) :: iomsg\n-\n-    integer :: item\n-\n-    read(unit,IOSTAT=iostat,IOMSG=iomsg) item\n-\n-    if (iostat .ne. 0) then\n-      call dtv%push(item)\n-    endif\n-\n-  end subroutine rio_stack\n-\n-  subroutine wio_stack(dtv, unit, iostat, iomsg)\n-\n-    ! pop an item from stack and write it to file\n-\n-    class(io_stack), intent(in) :: dtv\n-    integer, intent(in) :: unit\n-    integer, intent(out) :: iostat\n-    character(len=*), intent(inout) :: iomsg\n-    integer :: item\n-\n-    item = dtv%pop()\n-    write(unit,IOSTAT=iostat,IOMSG=iomsg) item\n-\n-  end subroutine wio_stack\n-\n-  subroutine dump_stack(dtv, unit, iotype, v_list, iostat, iomsg)\n-\n-    ! Pop all items off stack and write them out to unit\n-    ! Assumes default LISTDIRECTED output\n-\n-    class(io_stack), intent(in) :: dtv\n-    integer, intent(in) :: unit\n-    character(len=*), intent(in) :: iotype\n-    integer, intent(in) :: v_list(:)\n-    integer, intent(out) :: iostat\n-    character(len=*), intent(inout) :: iomsg\n-    character(len=80) :: buffer\n-    integer :: item\n-\n-    if (iotype .ne. 'LISTDIRECTED') then\n-       ! Error\n-       iomsg = 'dump_stack: unsupported iotype'\n-       iostat = 1\n-    else\n-       iostat = 0\n-       do while( (.not. dtv%empty()) .and. (iostat .eq. 0) )\n-         item = dtv%pop()\n-          write(unit, '(I6/)',IOSTAT=iostat,IOMSG=iomsg) item\n-       enddo\n-    endif\n-  end subroutine dump_stack\n-\n-  logical function empty(this)\n-    class(stack) :: this\n-    if (.not.associated(this%next)) then\n-       empty = .true.\n-    else\n-       empty = .false.\n-    end if\n-  end function empty\n-\n-  subroutine push_integer(this,item)\n-    class(integer_stack) :: this\n-    integer :: item\n-    type(integer_stack), allocatable :: new_item\n-\n-    allocate(new_item)\n-    allocate(new_item%item, source=item)\n-    new_item%next => this%next\n-    allocate(this%next, source=new_item)\n-  end subroutine push_integer\n-\n-  function pop_integer(this) result(item)\n-    class(integer_stack) :: this\n-    class(stack), pointer :: dealloc_item\n-    integer item\n-\n-    if (this%empty()) then\n-       stop 'Error! pop_integer invoked on empty stack'\n-    endif\n-    select type(top=>this%next)\n-    type is (integer_stack)\n-       select type(i => top%item)\n-       type is(integer)\n-          item = i\n-          class default\n-          stop 'Error #1! pop_integer encountered non-integer stack item'\n-       end select\n-       dealloc_item => this%next\n-       this%next => top%next\n-       deallocate(dealloc_item)\n-       class default\n-       stop 'Error #2! pop_integer encountered non-integer_stack item'\n-    end select\n-  end function pop_integer\n-\n-! gfortran addition to check read/write\n-  logical function compare_integer (this, array, error)\n-    class(integer_stack), target :: this\n-    class(stack), pointer :: ptr, next\n-    integer :: array(:), i, j, error\n-    compare_integer = .true.\n-    ptr => this\n-    do j = 0, size (array, 1)\n-      if (compare_integer .eqv. .false.) return\n-      select type (ptr)\n-        type is (integer_stack)\n-          select type(k => ptr%item)\n-            type is(integer)\n-              if (k .ne. array(j)) error = 1\n-            class default\n-              error = 2\n-              compare_integer = .false.\n-          end select\n-        class default\n-          if (j .ne. 0) then\n-            error = 3\n-            compare_integer = .false.\n-          end if\n-      end select\n-      next => ptr%next\n-      if (associated (next)) then\n-        ptr => next\n-      else if (j .ne. size (array, 1)) then\n-        error = 4\n-        compare_integer = .false.\n-      end if\n-    end do\n-  end function\n-\n-  subroutine delete (this)\n-    class(stack), target :: this\n-    class(stack), pointer :: ptr1, ptr2\n-    ptr1 => this%next\n-    ptr2 => ptr1%next\n-    do while (associated (ptr1))\n-      deallocate (ptr1)\n-      ptr1 => ptr2\n-      if (associated (ptr1)) ptr2 => ptr1%next\n-    end do\n-  end subroutine\n-\n-end module stack_mod\n-\n-program stack_demo\n-\n-  use stack_mod\n-  implicit none\n-\n-  integer i, k(10), error\n-  class(io_stack), allocatable :: stk\n-  allocate(stk)\n-\n-  k = [3,1,7,0,2,9,4,8,5,6]\n-\n-  ! step 1: set up an 'output' file > changed to 'scratch'\n-\n-  open(10, status='scratch', form='unformatted')\n-\n-  ! step 2: add values to stack\n-\n-  do i=1,10\n-!     write(*,*) 'Adding ',i,' to the stack'\n-     call stk%push(k(i))\n-  enddo\n-\n-  ! step 3: pop values from stack and write them to file\n-\n-!  write(*,*)\n-!  write(*,*) 'Removing each item from stack and writing it to file.'\n-!  write(*,*)\n-  do while(.not.stk%empty())\n-     write(10) stk\n-  enddo\n-\n-  ! step 4: close file and reopen it for read > changed to rewind.\n-\n-  rewind(10)\n-\n-  ! step 5: read values back into stack\n-!  write(*,*) 'Reading each value from file and adding it to stack:'\n-  do while(.true.)\n-     read(10,END=9999) i\n-!     write(*,*), 'Reading ',i,' from file. Adding it to stack'\n-     call stk%push(i)\n-  enddo\n-\n-9999 continue\n-\n-  ! step 6: Dump stack to standard out\n-\n-!  write(*,*)\n-!  write(*,*), 'Removing every element from stack and writing it to screen:'\n-!  write(*,*) stk\n-\n-! gfortran addition to check read/write\n-  if (.not. stk%compare (k, error)) then\n-    select case (error)\n-      case(1)\n-        print *, \"values do not match\"\n-      case(2)\n-        print *, \"non integer found in stack\"\n-      case(3)\n-        print *, \"type mismatch in stack\"\n-      case(4)\n-        print *, \"too few values in stack\"\n-    end select\n-    STOP 1\n-  end if\n-\n-  close(10)\n-\n-! Clean up - valgrind indicates no leaks.\n-  call stk%delete\n-  deallocate (stk)\n-end program stack_demo"}, {"sha": "2472603db41455969b57dcf40b7c91dcbb47add3", "filename": "gcc/testsuite/gfortran.dg/pdt_5.f03", "status": "removed", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03afbf335776916724b0608c256495c04a369d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03afbf335776916724b0608c256495c04a369d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_5.f03?ref=03afbf335776916724b0608c256495c04a369d2b", "patch": "@@ -1,223 +0,0 @@\n-! { dg-do run }\n-!\n-! Third, complete example from the PGInsider article:\n-! \"Object-Oriented Programming in Fortran 2003 Part 3: Parameterized Derived Types\"\n-! by Mark Leair\n-!\n-!     Copyright (c) 2013, NVIDIA CORPORATION.  All rights reserved.\n-!\n-! NVIDIA CORPORATION and its licensors retain all intellectual property\n-! and proprietary rights in and to this software, related documentation\n-! and any modifications thereto.  Any use, reproduction, disclosure or\n-! distribution of this software and related documentation without an express\n-! license agreement from NVIDIA CORPORATION is strictly prohibited.\n-!\n-\n-!          THIS CODE AND INFORMATION ARE PROVIDED \"AS IS\" WITHOUT\n-!   WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT\n-!   NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR\n-!   FITNESS FOR A PARTICULAR PURPOSE.\n-!\n-! Note that modification had to be made all of which are commented.\n-!\n-module matrix\n-\n-type :: base_matrix(k,c,r)\n-  private\n-    integer, kind :: k = 4\n-    integer, len :: c = 1\n-    integer, len :: r = 1\n-end type base_matrix\n-\n-type, extends(base_matrix) ::  adj_matrix\n-  private\n-    class(*), pointer :: m(:,:) => null()\n-end type adj_matrix\n-\n-interface getKind\n-  module procedure getKind4\n-  module procedure getKind8\n-end interface getKind\n-\n-interface getColumns\n-  module procedure getNumCols4\n-  module procedure getNumCols8\n-end interface getColumns\n-\n-interface getRows\n-  module procedure getNumRows4\n-  module procedure getNumRows8\n-end interface getRows\n-\n-interface adj_matrix\n-   module procedure construct_4   ! kind=4 constructor\n-   module procedure construct_8   ! kind=8 constructor\n-end interface adj_matrix\n-\n-interface assignment(=)\n-   module procedure m2m4          ! assign kind=4 matrix\n-   module procedure a2m4          ! assign kind=4 array\n-   module procedure m2m8          ! assign kind=8 matrix\n-   module procedure a2m8          ! assign kind=8 array\n-   module procedure m2a4          ! assign kind=4 matrix to array\n-   module procedure m2a8          ! assign kind=8 matrix to array\n-end interface assignment(=)\n-\n-\n-contains\n-\n-  function getKind4(this) result(rslt)\n-   class(adj_matrix(4,*,*)) :: this\n-   integer :: rslt\n-   rslt = this%k\n-  end function getKind4\n-\n- function getKind8(this) result(rslt)\n-   class(adj_matrix(8,*,*)) :: this\n-   integer :: rslt\n-   rslt = this%k\n- end function getKind8\n-\n-  function getNumCols4(this) result(rslt)\n-   class(adj_matrix(4,*,*)) :: this\n-   integer :: rslt\n-   rslt = this%c\n-  end function getNumCols4\n-\n-  function getNumCols8(this) result(rslt)\n-   class(adj_matrix(8,*,*)) :: this\n-   integer :: rslt\n-   rslt = this%c\n-  end function getNumCols8\n-\n-  function getNumRows4(this) result(rslt)\n-   class(adj_matrix(4,*,*)) :: this\n-   integer :: rslt\n-   rslt = this%r\n-  end function getNumRows4\n-\n-  function getNumRows8(this) result(rslt)\n-   class(adj_matrix(8,*,*)) :: this\n-   integer :: rslt\n-   rslt = this%r\n-  end function getNumRows8\n-\n-\n- function construct_4(k,c,r) result(mat)\n-     integer(4) :: k\n-     integer :: c\n-     integer :: r\n-     class(adj_matrix(4,:,:)),allocatable :: mat\n-\n-     allocate(adj_matrix(4,c,r)::mat)\n-\n-  end function construct_4\n-\n-  function construct_8(k,c,r) result(mat)\n-     integer(8) :: k\n-     integer :: c\n-     integer :: r\n-     class(adj_matrix(8,:,:)),allocatable :: mat\n-\n-     allocate(adj_matrix(8,c,r)::mat)\n-\n-  end function construct_8\n-\n-  subroutine a2m4(d,s)\n-   class(adj_matrix(4,:,:)),allocatable :: d\n-   class(*),dimension(:,:) :: s\n-\n-   if (allocated(d)) deallocate(d)\n-!    allocate(adj_matrix(4,size(s,1),size(s,2))::d)     ! generates assembler error\n-   allocate(d, mold = adj_matrix(4,size(s,1),size(s,2)))\n-   allocate(d%m(size(s,1),size(s,2)),source=s)\n- end subroutine a2m4\n-\n- subroutine a2m8(d,s)\n-   class(adj_matrix(8,:,:)),allocatable :: d\n-   class(*),dimension(:,:) :: s\n-\n-   if (allocated(d)) deallocate(d)\n-!    allocate(adj_matrix(8,size(s,1),size(s,2))::d)     ! generates assembler error\n-   allocate(d, mold = adj_matrix(8_8,size(s,1),size(s,2))) ! Needs 8_8 to match arg1 of 'construct_8'\n-   allocate(d%m(size(s,1),size(s,2)),source=s)\n- end subroutine a2m8\n-\n-subroutine m2a8(a,this)\n-class(adj_matrix(8,*,*)), intent(in) :: this         ! Intents required for\n-real(8),allocatable, intent(out) :: a(:,:)           ! defined assignment\n-  select type (array => this%m)                      ! Added SELECT TYPE because...\n-    type is (real(8))\n-  if (allocated(a)) deallocate(a)\n-  allocate(a,source=array)\n-  end select\n-!   allocate(a(size(this%m,1),size(this%m,2)),source=this%m) ! ...CLASS(*) source does not work in gfortran\n- end subroutine m2a8\n-\n- subroutine m2a4(a,this)\n- class(adj_matrix(4,*,*)), intent(in) :: this        ! Intents required for\n- real(4),allocatable, intent(out) :: a(:,:)          ! defined assignment\n-  select type (array => this%m)                      ! Added SELECT TYPE because...\n-    type is (real(4))\n-   if (allocated(a)) deallocate(a)\n-   allocate(a,source=array)\n-  end select\n-!   allocate(a(size(this%m,1),size(this%m,2)),source=this%m) ! ...CLASS(*) source does not work in gfortran\n- end subroutine m2a4\n-\n-  subroutine m2m4(d,s)\n-   CLASS(adj_matrix(4,:,:)),allocatable, intent(OUT) :: d   ! Intents required for\n-   CLASS(adj_matrix(4,*,*)), intent(in) :: s                ! defined assignment\n-\n-   if (allocated(d)) deallocate(d)\n-   allocate(d,source=s)\n- end subroutine m2m4\n-\n- subroutine m2m8(d,s)\n-   CLASS(adj_matrix(8,:,:)),allocatable, intent(OUT) :: d   ! Intents required for\n-   CLASS(adj_matrix(8,*,*)), intent(in) :: s                ! defined assignment\n-\n-   if (allocated(d)) deallocate(d)\n-   allocate(d,source=s)\n- end subroutine m2m8\n-\n-\n-end module matrix\n-\n-\n-program adj3\n-\n-  use matrix\n-  implicit none\n-  integer(8) :: i\n-\n-  class(adj_matrix(8,:,:)),allocatable :: adj             ! Was TYPE: Fails in\n-  real(8) :: a(2,3)                                       ! defined assignment\n-  real(8),allocatable :: b(:,:)\n-\n-  class(adj_matrix(4,:,:)),allocatable :: adj_4           ! Ditto and ....\n-  real(4) :: a_4(3,2)                                     ! ... these declarations were\n-  real(4),allocatable :: b_4(:,:)                         ! added to check KIND=4\n-\n-! Check constructor of PDT and instrinsic assignment\n-  adj = adj_matrix(INT(8,8),2,4)\n-  if (adj%k .ne. 8) STOP 1\n-  if (adj%c .ne. 2) STOP 2\n-  if (adj%r .ne. 4) STOP 3\n-  a = reshape ([(i, i = 1, 6)], [2,3])\n-  adj = a\n-  b = adj\n-  if (any (b .ne. a)) STOP 4\n-\n-! Check allocation with MOLD of PDT. Note that only KIND parameters set.\n-  allocate (adj_4, mold = adj_matrix(4,3,2))           ! Added check of KIND = 4\n-  if (adj_4%k .ne. 4) STOP 5\n-  a_4 = reshape (a, [3,2])\n-  adj_4 = a_4\n-  b_4 = adj_4\n-  if (any (b_4 .ne. a_4)) STOP 6\n-\n-end program adj3\n-\n-\n-"}]}