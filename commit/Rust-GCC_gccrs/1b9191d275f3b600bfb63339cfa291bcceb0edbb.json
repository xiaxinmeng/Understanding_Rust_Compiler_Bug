{"sha": "1b9191d275f3b600bfb63339cfa291bcceb0edbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI5MTkxZDI3NWYzYjYwMGJmYjYzMzM5Y2ZhMjkxYmNjZWIwZWRiYg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2001-12-07T18:49:16Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2001-12-07T18:49:16Z"}, "message": "extend.texi (Variable Attributes): Document vector_size.\n\n2001-12-07  Aldy Hernandez  <aldyh@redhat.com>\n\n\t* doc/extend.texi (Variable Attributes): Document vector_size.\n\n        * attribs.c (c_common_attribute_table): Add vector_size.\n\t(handle_vector_size_attribute): New.\n        (vector_size_helper): New.\n\t(decl_attributes): Relayout the decl after calculating attribs.\n\nFrom-SVN: r47764", "tree": {"sha": "dc2539980b12177f52a207f7da96b8918df5c4a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc2539980b12177f52a207f7da96b8918df5c4a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b9191d275f3b600bfb63339cfa291bcceb0edbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9191d275f3b600bfb63339cfa291bcceb0edbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b9191d275f3b600bfb63339cfa291bcceb0edbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9191d275f3b600bfb63339cfa291bcceb0edbb/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a9040c77986f3d775e6054af9cb1aa356e14082c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9040c77986f3d775e6054af9cb1aa356e14082c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9040c77986f3d775e6054af9cb1aa356e14082c"}], "stats": {"total": 190, "additions": 184, "deletions": 6}, "files": [{"sha": "04b32b921404ca4fb106ba2f19fc63fa9d449ad1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9191d275f3b600bfb63339cfa291bcceb0edbb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9191d275f3b600bfb63339cfa291bcceb0edbb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b9191d275f3b600bfb63339cfa291bcceb0edbb", "patch": "@@ -1,3 +1,12 @@\n+2001-12-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* doc/extend.texi (Variable Attributes): Document vector_size.\n+\n+        * attribs.c (c_common_attribute_table): Add vector_size.\n+\t(handle_vector_size_attribute): New.\n+        (vector_size_helper): New.\n+\t(decl_attributes): Relayout the decl after calculating attribs.\n+\n 2001-12-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* doc/gcc.texi: Don't include install-old.texi.  Adjust menu"}, {"sha": "554591310d9a64f9b02cb51e6454959e1b4e87e7", "filename": "gcc/attribs.c", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9191d275f3b600bfb63339cfa291bcceb0edbb/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9191d275f3b600bfb63339cfa291bcceb0edbb/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=1b9191d275f3b600bfb63339cfa291bcceb0edbb", "patch": "@@ -82,6 +82,9 @@ static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t     bool *));\n static tree handle_pure_attribute\tPARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t bool *));\n+static tree handle_vector_size_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t  bool *));\n+static tree vector_size_helper PARAMS ((tree, tree));\n \n /* Table of machine-independent attributes common to all C-like languages.  */\n static const struct attribute_spec c_common_attribute_table[] =\n@@ -135,6 +138,8 @@ static const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_no_limit_stack_attribute },\n   { \"pure\",                   0, 0, true,  false, false,\n \t\t\t      handle_pure_attribute },\n+  { \"vector_size\",\t      1, 1, false, true, false,\n+\t\t\t      handle_vector_size_attribute },\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n \n@@ -363,6 +368,18 @@ decl_attributes (node, attributes, flags)\n \treturned_attrs = chainon ((*spec->handler) (anode, name, args,\n \t\t\t\t\t\t    flags, &no_add_attrs),\n \t\t\t\t  returned_attrs);\n+\n+      /* Layout the decl in case anything changed.  */\n+      if (spec->type_required && DECL_P (*node)\n+\t  && TREE_CODE (*node) == VAR_DECL)\n+\t{\n+\t  /* Force a recalculation of mode and size.  */\n+\t  DECL_MODE (*node) = VOIDmode;\n+\t  DECL_SIZE (*node) = 0;\n+\n+\t  layout_decl (*node, 0);\n+\t}\n+\n       if (!no_add_attrs)\n \t{\n \t  tree old_attrs;\n@@ -1119,6 +1136,128 @@ handle_pure_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \n+/* Handle a \"vector_size\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  unsigned int vecsize, nunits;\n+  enum machine_mode mode, orig_mode, new_mode;\n+  tree type = *node, new_type;\n+\n+  *no_add_attrs = true;\n+\n+  if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      return NULL_TREE;\n+    }\n+\n+  /* Get the vector size (in bytes).  */\n+  vecsize = TREE_INT_CST_LOW (TREE_VALUE (args));\n+\n+  /* We need to provide for vector pointers, vector arrays, and\n+     functions returning vectors.  For example:\n+\n+       __attribute__((vector_size(16))) short *foo;\n+\n+     In this case, the mode is SI, but the type being modified is\n+     HI, so we need to look further.  */\n+\n+  while (POINTER_TYPE_P (type)\n+\t || TREE_CODE (type) == FUNCTION_TYPE\n+\t || TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  /* Get the mode of the type being modified.  */\n+  orig_mode = TYPE_MODE (type);\n+\n+  if (TREE_CODE (type) == RECORD_TYPE ||\n+      (GET_MODE_CLASS (orig_mode) != MODE_FLOAT\n+       && GET_MODE_CLASS (orig_mode) != MODE_INT))\n+    {\n+      error (\"invalid vector type for attribute `%s'\",\n+\t     IDENTIFIER_POINTER (name));\n+      return NULL_TREE;\n+    }\n+\n+  /* Calculate how many units fit in the vector.  */\n+  nunits = vecsize / TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n+\n+  /* Find a suitably sized vector.  */\n+  new_mode = VOIDmode;\n+  for (mode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_mode) == MODE_INT\n+\t\t\t\t\t? MODE_VECTOR_INT\n+\t\t\t\t\t: MODE_VECTOR_FLOAT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (vecsize == GET_MODE_SIZE (mode)\t&& nunits == GET_MODE_NUNITS (mode))\n+      {\n+\tnew_mode = mode;\n+\tbreak;\n+      }\n+\n+  if (new_mode == VOIDmode)\n+    error (\"no vector mode with the size and type specified could be found\");\n+  else\n+    {\n+      new_type = type_for_mode (new_mode, TREE_UNSIGNED (type));\n+      if (!new_type)\n+\terror (\"no vector mode with the size and type specified could be found\");\n+      else\n+\t/* Build back pointers if needed.  */\n+\t*node = vector_size_helper (*node, new_type);\n+    }\n+    \n+  return NULL_TREE;\n+}\n+\n+/* HACK.  GROSS.  This is absolutely disgusting.  I wish there was a\n+   better way.\n+\n+   If we requested a pointer to a vector, build up the pointers that\n+   we stripped off while looking for the inner type.  Similarly for\n+   return values from functions.\n+\n+   The argument \"type\" is the top of the chain, and \"bottom\" is the\n+   new type which we will point to.  */\n+\n+static tree\n+vector_size_helper (type, bottom)\n+     tree type, bottom;\n+{\n+  tree inner, outer;\n+\n+  if (POINTER_TYPE_P (type))\n+    {\n+      inner = vector_size_helper (TREE_TYPE (type), bottom);\n+      outer = build_pointer_type (inner);\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      inner = vector_size_helper (TREE_TYPE (type), bottom);\n+      outer = build_array_type (inner, TYPE_VALUES (type));\n+    }\n+  else if (TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      inner = vector_size_helper (TREE_TYPE (type), bottom);\n+      outer = build_function_type (inner, TYPE_VALUES (type));\n+    }\n+  else\n+    return bottom;\n+  \n+  TREE_READONLY (outer) = TREE_READONLY (type);\n+  TREE_THIS_VOLATILE (outer) = TREE_THIS_VOLATILE (type);\n+\n+  return outer;\n+}\n+\n /* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two\n    lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).\n "}, {"sha": "e75a8d600c9f708d3bfefa585f7ab95defdde24b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b9191d275f3b600bfb63339cfa291bcceb0edbb/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b9191d275f3b600bfb63339cfa291bcceb0edbb/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1b9191d275f3b600bfb63339cfa291bcceb0edbb", "patch": "@@ -2794,14 +2794,15 @@ section.\n \n The keyword @code{__attribute__} allows you to specify special\n attributes of variables or structure fields.  This keyword is followed\n-by an attribute specification inside double parentheses.  Eight\n+by an attribute specification inside double parentheses.  Nine\n attributes are currently defined for variables: @code{aligned},\n @code{mode}, @code{nocommon}, @code{packed}, @code{section},\n-@code{transparent_union}, @code{unused}, and @code{weak}.  Some other\n-attributes are defined for variables on particular target systems.  Other\n-attributes are available for functions (@pxref{Function Attributes}) and\n-for types (@pxref{Type Attributes}).  Other front ends might define more\n-attributes (@pxref{C++ Extensions,,Extensions to the C++ Language}).\n+@code{transparent_union}, @code{unused}, @code{vector_size}, and\n+@code{weak}.  Some other attributes are defined for variables on\n+particular target systems.  Other attributes are available for functions\n+(@pxref{Function Attributes}) and for types (@pxref{Type Attributes}).\n+Other front ends might define more attributes (@pxref{C++\n+Extensions,,Extensions to the C++ Language}).\n \n You may also specify attributes with @samp{__} preceding and following\n each keyword.  This allows you to use them in header files without\n@@ -3003,6 +3004,35 @@ This attribute, attached to a variable, means that the variable is meant\n to be possibly unused.  GCC will not produce a warning for this\n variable.\n \n+@item vector_size (@var{bytes})\n+This attribute specifies the vector size for the variable, measured in\n+bytes.  For example, the declaration:\n+\n+@smallexample\n+int foo __attribute__ ((vector_size (16)));\n+@end smallexample\n+\n+@noindent\n+causes the compiler to set the mode for @code{foo}, to be 16 bytes,\n+divided into @code{int} sized units.  Assuming a 32-bit int (a vector of\n+4 units of 4 bytes), the corresponding mode of @code{foo} will be V4SI@.\n+\n+This attribute is only applicable to integral and float scalars,\n+although arrays, pointers, and function return values are allowed in\n+conjunction with this construct.\n+\n+Aggregates with this attribute are invalid, even if they are of the same\n+size as a corresponding scalar.  For example, the declaration:\n+\n+@smallexample\n+struct S { int a; };\n+struct S  __attribute__ ((vector_size (16))) foo;\n+@end smallexample\n+\n+@noindent\n+is invalid even if the size of the structure is the same as the size of\n+the @code{int}.\n+\n @item weak\n The @code{weak} attribute is described in @xref{Function Attributes}.\n "}]}