{"sha": "6136f0aebbb84cbcf8f92bed206733391aaa3866", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzNmYwYWViYmI4NGNiY2Y4ZjkyYmVkMjA2NzMzMzkxYWFhMzg2Ng==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-15T17:48:11Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "This is a new HIR -> GIMPLE pass it reuses the mappings from hir,\nname resolution and type resolution to simplify the generation of\ngimple.", "tree": {"sha": "49c24a3b9c9483bb2755642496bcd0aec3f8c598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49c24a3b9c9483bb2755642496bcd0aec3f8c598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6136f0aebbb84cbcf8f92bed206733391aaa3866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6136f0aebbb84cbcf8f92bed206733391aaa3866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6136f0aebbb84cbcf8f92bed206733391aaa3866", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6136f0aebbb84cbcf8f92bed206733391aaa3866/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a621e19365473b477d121c28a057cc25d3951c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a621e19365473b477d121c28a057cc25d3951c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a621e19365473b477d121c28a057cc25d3951c76"}], "stats": {"total": 1837, "additions": 1738, "deletions": 99}, "files": [{"sha": "5ac60ea7df1384a32a0551345e61e8818e4d59a1", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -70,6 +70,7 @@ GRS_OBJS = \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n     rust/rust-compile.o \\\n+    rust/rust-compile-resolve-path.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-hir-full-test.o \\\n     rust/rust-hir-map.o \\"}, {"sha": "6410fd414bc4ba6a3d6586a84346cb6088ee0a6d", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,249 @@\n+\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_BASE\n+#define RUST_COMPILE_BASE\n+\n+#include \"rust-compile-context.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class HIRCompileBase : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~HIRCompileBase () {}\n+\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input) {}\n+  // virtual void visit(TokenTree& token_tree) {}\n+  // virtual void visit(MacroMatch& macro_match) {}\n+  virtual void visit (HIR::Token &tok) {}\n+  virtual void visit (HIR::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (HIR::AttrInputMetaItemContainer &input) {}\n+  // virtual void visit(MetaItem& meta_item) {}\n+  // virtual void visit(Stmt& stmt) {}\n+  // virtual void visit(Expr& expr) {}\n+  virtual void visit (HIR::IdentifierExpr &ident_expr) {}\n+  // virtual void visit(Pattern& pattern) {}\n+  // virtual void visit(Type& type) {}\n+  // virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (HIR::Lifetime &lifetime) {}\n+  // virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (HIR::LifetimeParam &lifetime_param) {}\n+  // virtual void visit(TraitItem& trait_item) {}\n+  // virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  // virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (HIR::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (HIR::PathInExpression &path) {}\n+  virtual void visit (HIR::TypePathSegment &segment) {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (HIR::TypePathSegmentFunction &segment) {}\n+  virtual void visit (HIR::TypePath &path) {}\n+  virtual void visit (HIR::QualifiedPathInExpression &path) {}\n+  virtual void visit (HIR::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (HIR::LiteralExpr &expr) {}\n+  virtual void visit (HIR::AttrInputLiteral &attr_input) {}\n+  virtual void visit (HIR::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (HIR::MetaItemPathLit &meta_item) {}\n+  virtual void visit (HIR::BorrowExpr &expr) {}\n+  virtual void visit (HIR::DereferenceExpr &expr) {}\n+  virtual void visit (HIR::ErrorPropagationExpr &expr) {}\n+  virtual void visit (HIR::NegationExpr &expr) {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (HIR::ComparisonExpr &expr) {}\n+  virtual void visit (HIR::LazyBooleanExpr &expr) {}\n+  virtual void visit (HIR::TypeCastExpr &expr) {}\n+  virtual void visit (HIR::AssignmentExpr &expr) {}\n+  virtual void visit (HIR::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (HIR::GroupedExpr &expr) {}\n+  // virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (HIR::ArrayElemsValues &elems) {}\n+  virtual void visit (HIR::ArrayElemsCopied &elems) {}\n+  virtual void visit (HIR::ArrayExpr &expr) {}\n+  virtual void visit (HIR::ArrayIndexExpr &expr) {}\n+  virtual void visit (HIR::TupleExpr &expr) {}\n+  virtual void visit (HIR::TupleIndexExpr &expr) {}\n+  virtual void visit (HIR::StructExprStruct &expr) {}\n+  // virtual void visit(StructExprField& field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::StructExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::StructExprStructFields &expr) {}\n+  virtual void visit (HIR::StructExprStructBase &expr) {}\n+  virtual void visit (HIR::StructExprTuple &expr) {}\n+  virtual void visit (HIR::StructExprUnit &expr) {}\n+  // virtual void visit(EnumExprField& field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::EnumExprStruct &expr) {}\n+  virtual void visit (HIR::EnumExprTuple &expr) {}\n+  virtual void visit (HIR::EnumExprFieldless &expr) {}\n+  virtual void visit (HIR::CallExpr &expr) {}\n+  virtual void visit (HIR::MethodCallExpr &expr) {}\n+  virtual void visit (HIR::FieldAccessExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInner &expr) {}\n+  virtual void visit (HIR::BlockExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (HIR::ContinueExpr &expr) {}\n+  virtual void visit (HIR::BreakExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToExpr &expr) {}\n+  virtual void visit (HIR::RangeFromExpr &expr) {}\n+  virtual void visit (HIR::RangeToExpr &expr) {}\n+  virtual void visit (HIR::RangeFullExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToInclExpr &expr) {}\n+  virtual void visit (HIR::RangeToInclExpr &expr) {}\n+  virtual void visit (HIR::ReturnExpr &expr) {}\n+  virtual void visit (HIR::UnsafeBlockExpr &expr) {}\n+  virtual void visit (HIR::LoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLetLoopExpr &expr) {}\n+  virtual void visit (HIR::ForLoopExpr &expr) {}\n+  virtual void visit (HIR::IfExpr &expr) {}\n+  virtual void visit (HIR::IfExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfExprConseqIfLet &expr) {}\n+  virtual void visit (HIR::IfLetExpr &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &expr) {}\n+  // virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (HIR::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (HIR::MatchCaseExpr &match_case) {}\n+  virtual void visit (HIR::MatchExpr &expr) {}\n+  virtual void visit (HIR::AwaitExpr &expr) {}\n+  virtual void visit (HIR::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (HIR::TypeParam &param) {}\n+  // virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (HIR::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (HIR::Method &method) {}\n+  virtual void visit (HIR::ModuleBodied &module) {}\n+  virtual void visit (HIR::ModuleNoBody &module) {}\n+  virtual void visit (HIR::ExternCrate &crate) {}\n+  // virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (HIR::UseTreeGlob &use_tree) {}\n+  virtual void visit (HIR::UseTreeList &use_tree) {}\n+  virtual void visit (HIR::UseTreeRebind &use_tree) {}\n+  virtual void visit (HIR::UseDeclaration &use_decl) {}\n+  virtual void visit (HIR::Function &function) {}\n+  virtual void visit (HIR::TypeAlias &type_alias) {}\n+  virtual void visit (HIR::StructStruct &struct_item) {}\n+  virtual void visit (HIR::TupleStruct &tuple_struct) {}\n+  virtual void visit (HIR::EnumItem &item) {}\n+  virtual void visit (HIR::EnumItemTuple &item) {}\n+  virtual void visit (HIR::EnumItemStruct &item) {}\n+  virtual void visit (HIR::EnumItemDiscriminant &item) {}\n+  virtual void visit (HIR::Enum &enum_item) {}\n+  virtual void visit (HIR::Union &union_item) {}\n+  virtual void visit (HIR::ConstantItem &const_item) {}\n+  virtual void visit (HIR::StaticItem &static_item) {}\n+  virtual void visit (HIR::TraitItemFunc &item) {}\n+  virtual void visit (HIR::TraitItemMethod &item) {}\n+  virtual void visit (HIR::TraitItemConst &item) {}\n+  virtual void visit (HIR::TraitItemType &item) {}\n+  virtual void visit (HIR::Trait &trait) {}\n+  virtual void visit (HIR::InherentImpl &impl) {}\n+  virtual void visit (HIR::TraitImpl &impl) {}\n+  // virtual void visit(ExternalItem& item) {}\n+  virtual void visit (HIR::ExternalStaticItem &item) {}\n+  virtual void visit (HIR::ExternalFunctionItem &item) {}\n+  virtual void visit (HIR::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (HIR::MacroMatchFragment &match) {}\n+  virtual void visit (HIR::MacroMatchRepetition &match) {}\n+  virtual void visit (HIR::MacroMatcher &matcher) {}\n+  virtual void visit (HIR::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (HIR::MacroInvocation &macro_invoc) {}\n+  virtual void visit (HIR::MetaItemPath &meta_item) {}\n+  virtual void visit (HIR::MetaItemSeq &meta_item) {}\n+  virtual void visit (HIR::MetaWord &meta_item) {}\n+  virtual void visit (HIR::MetaNameValueStr &meta_item) {}\n+  virtual void visit (HIR::MetaListPaths &meta_item) {}\n+  virtual void visit (HIR::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (HIR::LiteralPattern &pattern) {}\n+  virtual void visit (HIR::IdentifierPattern &pattern) {}\n+  virtual void visit (HIR::WildcardPattern &pattern) {}\n+  // virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (HIR::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (HIR::RangePatternBoundPath &bound) {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (HIR::RangePattern &pattern) {}\n+  virtual void visit (HIR::ReferencePattern &pattern) {}\n+  // virtual void visit(StructPatternField& field) {}\n+  virtual void visit (HIR::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdent &field) {}\n+  virtual void visit (HIR::StructPattern &pattern) {}\n+  // virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructPattern &pattern) {}\n+  // virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (HIR::TuplePattern &pattern) {}\n+  virtual void visit (HIR::GroupedPattern &pattern) {}\n+  virtual void visit (HIR::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (HIR::EmptyStmt &stmt) {}\n+  virtual void visit (HIR::LetStmt &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (HIR::TraitBound &bound) {}\n+  virtual void visit (HIR::ImplTraitType &type) {}\n+  virtual void visit (HIR::TraitObjectType &type) {}\n+  virtual void visit (HIR::ParenthesisedType &type) {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (HIR::TupleType &type) {}\n+  virtual void visit (HIR::NeverType &type) {}\n+  virtual void visit (HIR::RawPointerType &type) {}\n+  virtual void visit (HIR::ReferenceType &type) {}\n+  virtual void visit (HIR::ArrayType &type) {}\n+  virtual void visit (HIR::SliceType &type) {}\n+  virtual void visit (HIR::InferredType &type) {}\n+  virtual void visit (HIR::BareFunctionType &type) {}\n+\n+protected:\n+  HIRCompileBase (Context *ctx) : ctx (ctx) {}\n+\n+  Context *get_context () { return ctx; }\n+\n+  Context *ctx;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_BASE"}, {"sha": "f8906788e1298dac25e0e2d98b173dd0c03d1e4b", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,247 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_CONTEXT\n+#define RUST_COMPILE_CONTEXT\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+struct fncontext\n+{\n+  ::Bfunction *fndecl;\n+  ::Bvariable *ret_addr;\n+};\n+\n+class Context\n+{\n+public:\n+  Context (::Backend *backend)\n+    : backend (backend), resolver (Resolver::Resolver::get ()),\n+      tyctx (Resolver::TypeCheckContext::get ()),\n+      mappings (Analysis::Mappings::get ())\n+  {\n+    // insert the builtins\n+    auto builtins = resolver->get_builtin_types ();\n+    for (auto it = builtins.begin (); it != builtins.end (); it++)\n+      {\n+\tHirId ref;\n+\trust_assert (\n+\t  tyctx->lookup_type_by_node_id ((*it)->get_node_id (), &ref));\n+\n+\tTyTy::TyBase *lookup;\n+\trust_assert (tyctx->lookup_type (ref, &lookup));\n+\n+\tauto compiled = TyTyCompile::compile (backend, lookup);\n+\tcompiled_type_map[ref] = compiled;\n+      }\n+  }\n+\n+  ~Context () {}\n+\n+  bool lookup_compiled_types (HirId id, ::Btype **type)\n+  {\n+    auto it = compiled_type_map.find (id);\n+    if (it == compiled_type_map.end ())\n+      return false;\n+\n+    *type = it->second;\n+    return true;\n+  }\n+\n+  void insert_compiled_type (HirId id, ::Btype *type)\n+  {\n+    compiled_type_map[id] = type;\n+  }\n+\n+  ::Backend *get_backend () { return backend; }\n+  Resolver::Resolver *get_resolver () { return resolver; }\n+  Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n+  Analysis::Mappings *get_mappings () { return mappings; }\n+\n+  void push_block (Bblock *scope)\n+  {\n+    scope_stack.push_back (scope);\n+    statements.push_back ({});\n+  }\n+\n+  Bblock *pop_block ()\n+  {\n+    auto block = scope_stack.back ();\n+    scope_stack.pop_back ();\n+\n+    auto stmts = statements.back ();\n+    statements.pop_back ();\n+\n+    backend->block_add_statements (block, stmts);\n+\n+    return block;\n+  }\n+\n+  Bblock *peek_enclosing_scope ()\n+  {\n+    if (scope_stack.size () == 0)\n+      return nullptr;\n+\n+    return scope_stack.back ();\n+  }\n+\n+  void add_statement (Bstatement *stmt) { statements.back ().push_back (stmt); }\n+\n+  void insert_var_decl (HirId id, ::Bvariable *decl)\n+  {\n+    compiled_var_decls[id] = decl;\n+  }\n+\n+  bool lookup_var_decl (HirId id, ::Bvariable **decl)\n+  {\n+    auto it = compiled_var_decls.find (id);\n+    if (it == compiled_var_decls.end ())\n+      return false;\n+\n+    *decl = it->second;\n+    return true;\n+  }\n+\n+  void insert_function_decl (HirId id, ::Bfunction *fn)\n+  {\n+    compiled_fn_map[id] = fn;\n+  }\n+\n+  bool lookup_function_decl (HirId id, ::Bfunction **fn)\n+  {\n+    auto it = compiled_fn_map.find (id);\n+    if (it == compiled_fn_map.end ())\n+      return false;\n+\n+    *fn = it->second;\n+    return true;\n+  }\n+\n+  void push_fn (::Bfunction *fn, ::Bvariable *ret_addr)\n+  {\n+    fn_stack.push_back (fncontext{fn, ret_addr});\n+  }\n+  void pop_fn () { fn_stack.pop_back (); }\n+  fncontext peek_fn () { return fn_stack.back (); }\n+\n+  void push_type (::Btype *t) { type_decls.push_back (t); }\n+  void push_var (::Bvariable *v) { var_decls.push_back (v); }\n+  void push_const (::Bexpression *c) { const_decls.push_back (c); }\n+  void push_function (::Bfunction *f) { func_decls.push_back (f); }\n+\n+  void write_to_backend ()\n+  {\n+    backend->write_global_definitions (type_decls, const_decls, func_decls,\n+\t\t\t\t       var_decls);\n+  }\n+\n+  bool function_completed (Bfunction *fn)\n+  {\n+    for (auto it = func_decls.begin (); it != func_decls.end (); it++)\n+      {\n+\tBfunction *i = (*it);\n+\tif (i == fn)\n+\t  {\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+private:\n+  ::Backend *backend;\n+  Resolver::Resolver *resolver;\n+  Resolver::TypeCheckContext *tyctx;\n+  Analysis::Mappings *mappings;\n+\n+  // state\n+  std::vector<fncontext> fn_stack;\n+  std::map<HirId, ::Bvariable *> compiled_var_decls;\n+  std::map<HirId, ::Btype *> compiled_type_map;\n+  std::map<HirId, ::Bfunction *> compiled_fn_map;\n+  std::vector< ::std::vector<Bstatement *> > statements;\n+  std::vector< ::Bblock *> scope_stack;\n+\n+  // To GCC middle-end\n+  std::vector< ::Btype *> type_decls;\n+  std::vector< ::Bvariable *> var_decls;\n+  std::vector< ::Bexpression *> const_decls;\n+  std::vector< ::Bfunction *> func_decls;\n+};\n+\n+class TyTyResolveCompile : public TyTy::TyVisitor\n+{\n+public:\n+  static ::Btype *compile (Context *ctx, TyTy::TyBase *ty)\n+  {\n+    TyTyResolveCompile compiler (ctx);\n+    ty->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  virtual ~TyTyResolveCompile () {}\n+\n+  void visit (TyTy::FnType &type) { gcc_unreachable (); }\n+\n+  void visit (TyTy::BoolType &type)\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+  void visit (TyTy::IntType &type)\n+  {\n+    printf (\"type [%s] has ref: %u\\n\", type.as_string ().c_str (),\n+\t    type.get_ref ());\n+\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+  void visit (TyTy::UintType &type)\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+private:\n+  TyTyResolveCompile (Context *ctx) : ctx (ctx) {}\n+\n+  Context *ctx;\n+  ::Btype *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_CONTEXT"}, {"sha": "7808af2bb4fed72de27e7634891420d608d001ce", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,285 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_EXPR\n+#define RUST_COMPILE_EXPR\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-compile-resolve-path.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileExpr : public HIRCompileBase\n+{\n+public:\n+  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  {\n+    CompileExpr compiler (ctx);\n+    expr->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  virtual ~CompileExpr () {}\n+\n+  void visit (HIR::ReturnExpr &expr)\n+  {\n+    Bexpression *compiled_expr\n+      = CompileExpr::Compile (expr.return_expr.get (), ctx);\n+    rust_assert (compiled_expr != nullptr);\n+\n+    auto fncontext = ctx->peek_fn ();\n+\n+    std::vector<Bexpression *> retstmts;\n+    retstmts.push_back (compiled_expr);\n+    auto s = ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n+\t\t\t\t\t\t    expr.get_locus ());\n+    ctx->add_statement (s);\n+  }\n+\n+  void visit (HIR::CallExpr &expr)\n+  {\n+    Bexpression *fn = ResolvePath::Compile (expr.get_fnexpr (), ctx);\n+    rust_assert (fn != nullptr);\n+\n+    std::vector<Bexpression *> args;\n+    expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+      Bexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+      rust_assert (compiled_expr != nullptr);\n+      args.push_back (compiled_expr);\n+      return true;\n+    });\n+\n+    auto fncontext = ctx->peek_fn ();\n+    translated\n+      = ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n+\t\t\t\t\t      nullptr, expr.get_locus ());\n+  }\n+\n+  void visit (HIR::IdentifierExpr &expr)\n+  {\n+    // need to look up the reference for this identifier\n+    NodeId ref_node_id;\n+    if (!ctx->get_resolver ()->lookup_resolved_name (\n+\t  expr.get_mappings ().get_nodeid (), &ref_node_id))\n+      {\n+\trust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n+\treturn;\n+      }\n+\n+    printf (\"have ast node id %u ref %u for expr [%s]\\n\",\n+\t    expr.get_mappings ().get_nodeid (), ref_node_id,\n+\t    expr.as_string ().c_str ());\n+\n+    // these ref_node_ids will resolve to a pattern declaration but we are\n+    // interested in the definition that this refers to get the parent id\n+    Resolver::Definition def;\n+    if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown reference\");\n+\treturn;\n+      }\n+\n+    HirId ref;\n+    if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\t  expr.get_mappings ().get_crate_num (), def.parent, &ref))\n+      {\n+\trust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    Bvariable *var = nullptr;\n+    if (!ctx->lookup_var_decl (ref, &var))\n+      {\n+\trust_fatal_error (expr.get_locus (),\n+\t\t\t  \"failed to lookup compiled variable\");\n+\treturn;\n+      }\n+\n+    translated = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr)\n+  {\n+    switch (expr.get_lit_type ())\n+      {\n+\tcase HIR::Literal::BOOL: {\n+\t  bool bval = expr.as_string ().compare (\"true\") == 0;\n+\t  translated = ctx->get_backend ()->boolean_constant_expression (bval);\n+\t}\n+\treturn;\n+\n+\tcase HIR::Literal::INT: {\n+\t  mpz_t ival;\n+\t  if (mpz_init_set_str (ival, expr.as_string ().c_str (), 10) != 0)\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n+\t      return;\n+\t    }\n+\n+\t  TyTy::TyBase *tyty = nullptr;\n+\t  if (!ctx->get_tyctx ()->lookup_type (\n+\t\texpr.get_mappings ().get_hirid (), &tyty))\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (),\n+\t\t\t\t\"did not resolve type for this literal expr\");\n+\t      return;\n+\t    }\n+\n+\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  translated\n+\t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n+\t}\n+\treturn;\n+\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"unknown literal\");\n+\treturn;\n+      }\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr)\n+  {\n+    fncontext fn = ctx->peek_fn ();\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    Bstatement *assignment\n+      = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, rhs,\n+\t\t\t\t\t\t   expr.get_locus ());\n+    ctx->add_statement (assignment);\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr)\n+  {\n+    Operator op;\n+    switch (expr.get_expr_type ())\n+      {\n+      case HIR::ArithmeticOrLogicalExpr::ADD:\n+\top = OPERATOR_PLUS;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::SUBTRACT:\n+\top = OPERATOR_MINUS;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::MULTIPLY:\n+\top = OPERATOR_MULT;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::DIVIDE:\n+\top = OPERATOR_DIV;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::MODULUS:\n+\top = OPERATOR_MOD;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_AND:\n+\top = OPERATOR_AND;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_OR:\n+\top = OPERATOR_OR;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_XOR:\n+\top = OPERATOR_XOR;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n+\top = OPERATOR_LSHIFT;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::RIGHT_SHIFT:\n+\top = OPERATOR_RSHIFT;\n+\tbreak;\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n+\treturn;\n+      }\n+\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    translated = ctx->get_backend ()->binary_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (HIR::ComparisonExpr &expr)\n+  {\n+    Operator op;\n+    switch (expr.get_expr_type ())\n+      {\n+      case HIR::ComparisonExpr::EQUAL:\n+\top = OPERATOR_EQEQ;\n+\tbreak;\n+      case HIR::ComparisonExpr::NOT_EQUAL:\n+\top = OPERATOR_NOTEQ;\n+\tbreak;\n+      case HIR::ComparisonExpr::GREATER_THAN:\n+\top = OPERATOR_GT;\n+\tbreak;\n+      case HIR::ComparisonExpr::LESS_THAN:\n+\top = OPERATOR_LT;\n+\tbreak;\n+      case HIR::ComparisonExpr::GREATER_OR_EQUAL:\n+\top = OPERATOR_GE;\n+\tbreak;\n+      case HIR::ComparisonExpr::LESS_OR_EQUAL:\n+\top = OPERATOR_LE;\n+\tbreak;\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n+\treturn;\n+      }\n+\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    translated = ctx->get_backend ()->binary_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (HIR::LazyBooleanExpr &expr)\n+  {\n+    Operator op;\n+    switch (expr.get_expr_type ())\n+      {\n+      case HIR::LazyBooleanExpr::LOGICAL_OR:\n+\top = OPERATOR_OROR;\n+\tbreak;\n+      case HIR::LazyBooleanExpr::LOGICAL_AND:\n+\top = OPERATOR_ANDAND;\n+\tbreak;\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n+\treturn;\n+      }\n+\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    translated = ctx->get_backend ()->binary_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+  }\n+\n+private:\n+  CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+\n+  Bexpression *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_EXPR"}, {"sha": "dd0743515ed1c1d0ee7f998639ab500a14dc74c5", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,180 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_ITEM\n+#define RUST_COMPILE_ITEM\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-compile-var-decl.h\"\n+#include \"rust-compile-stmt.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileItem : public HIRCompileBase\n+{\n+public:\n+  static void compile (HIR::Item *item, Context *ctx)\n+  {\n+    CompileItem compiler (ctx);\n+    item->accept_vis (compiler);\n+  }\n+\n+  virtual ~CompileItem () {}\n+\n+  void visit (HIR::Function &function)\n+  {\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (function.get_mappings ().get_hirid (),\n+\t\t\t\t   &lookup))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    printf (\"returning early the function [%s] is completed!\\n\",\n+\t\t    function.as_string ().c_str ());\n+\t    return;\n+\t  }\n+      }\n+\n+    TyTy::TyBase *fnType;\n+    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n+\t\t\t\t\t &fnType))\n+      {\n+\trust_fatal_error (function.locus, \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    // convert to the actual function type\n+    auto compiled_fn_type = TyTyCompile::compile (ctx->get_backend (), fnType);\n+\n+    Bfunction *fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, function.function_name,\n+\t\t\t\t       \"\" /* asm_name */, 0 /* flags */,\n+\t\t\t\t       function.get_locus ());\n+    ctx->insert_function_decl (function.get_mappings ().get_hirid (), fndecl);\n+\n+    // setup the params\n+    TyTy::TyBase *tyret = TyTyExtractRetFromFnType::compile (fnType);\n+    std::vector<TyTy::ParamType *> typarams\n+      = TyTyExtractParamsFromFnType::compile (fnType);\n+    std::vector<Bvariable *> param_vars;\n+\n+    for (auto &it : typarams)\n+      {\n+\tauto compiled_param\n+\t  = TyTyCompileParam::compile (ctx->get_backend (), fndecl, it);\n+\tparam_vars.push_back (compiled_param);\n+\n+\tctx->insert_var_decl (it->get_ref (), compiled_param);\n+      }\n+\n+    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to setup parameter variables\");\n+\treturn;\n+      }\n+\n+    // lookup locals\n+    auto block_expr = function.function_body.get ();\n+    auto body_mappings = block_expr->get_mappings ();\n+\n+    Resolver::Rib *rib = nullptr;\n+    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n+\t\t\t\t\t      &rib))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to setup locals per block\");\n+\treturn;\n+      }\n+\n+    std::vector<Bvariable *> locals;\n+    rib->iterate_decls ([&] (NodeId n) mutable -> bool {\n+      Resolver::Definition d;\n+      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+      rust_assert (ok);\n+\n+      HIR::Stmt *decl = nullptr;\n+      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+      rust_assert (ok);\n+\n+      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+      locals.push_back (compiled);\n+\n+      return true;\n+    });\n+\n+    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+    HIR::BlockExpr *function_body = function.function_body.get ();\n+\n+    Location start_location = function_body->get_locus ();\n+    Location end_location = function_body->get_closing_locus ();\n+\n+    Bblock *code_block\n+      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t    start_location, end_location);\n+    ctx->push_block (code_block);\n+\n+    Bvariable *return_address = nullptr;\n+    if (function.has_function_return_type ())\n+      {\n+\tBtype *return_type = TyTyCompile::compile (ctx->get_backend (), tyret);\n+\n+\tbool address_is_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\n+\treturn_address = ctx->get_backend ()->temporary_variable (\n+\t  fndecl, code_block, return_type, NULL, address_is_taken,\n+\t  function.get_locus (), &ret_var_stmt);\n+\n+\tctx->add_statement (ret_var_stmt);\n+      }\n+\n+    ctx->push_fn (fndecl, return_address);\n+\n+    // compile the block\n+    function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      CompileStmt::Compile (s, ctx);\n+      return true;\n+    });\n+\n+    ctx->pop_block ();\n+    auto body = ctx->get_backend ()->block_statement (code_block);\n+    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n+      {\n+\trust_error_at (function.get_locus (), \"failed to set body to function\");\n+\treturn;\n+      }\n+\n+    ctx->pop_fn ();\n+\n+    ctx->push_function (fndecl);\n+  }\n+\n+private:\n+  CompileItem (Context *ctx) : HIRCompileBase (ctx) {}\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_ITEM"}, {"sha": "e6683fa9f45a083fd24b73d93f3900089eef105b", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-linemap.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-item.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+ResolvePath::visit (HIR::PathInExpression &expr)\n+{\n+  // need to look up the reference for this identifier\n+  NodeId ref_node_id;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &ref_node_id))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n+      return;\n+    }\n+\n+  printf (\"PATHIN have ast node id %u ref %u for expr [%s]\\n\",\n+\t  expr.get_mappings ().get_nodeid (), ref_node_id,\n+\t  expr.as_string ().c_str ());\n+\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // assumes paths are functions for now\n+  Bfunction *fn;\n+  if (!ctx->lookup_function_decl (ref, &fn))\n+    {\n+      printf (\n+\t\"path failed to lookup function attempting to forward resolve!\\n\");\n+\n+      // this might fail because its a forward decl so we can attempt to\n+      // resolve it now\n+      HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item (\n+\texpr.get_mappings ().get_crate_num (), ref);\n+      if (resolved_item == nullptr)\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"failed to lookup forward decl\");\n+\t  return;\n+\t}\n+\n+      CompileItem::compile (resolved_item, ctx);\n+      if (!ctx->lookup_function_decl (ref, &fn))\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+\t  return;\n+\t}\n+    }\n+\n+  resolved\n+    = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "d8f393d5ccff6880894c68305b31d2ec78252b7a", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_RESOLVE_PATH\n+#define RUST_COMPILE_RESOLVE_PATH\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class ResolvePath : public HIRCompileBase\n+{\n+public:\n+  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  {\n+    ResolvePath resolver (ctx);\n+    expr->accept_vis (resolver);\n+    rust_assert (resolver.resolved != nullptr);\n+    return resolver.resolved;\n+  }\n+\n+  virtual ~ResolvePath () {}\n+\n+  void visit (HIR::PathInExpression &expr);\n+\n+private:\n+  ResolvePath (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+\n+  Bexpression *resolved;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_RESOLVE_PATH"}, {"sha": "0a081303332474e5e767454bf5487d1f687645ea", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_STMT\n+#define RUST_COMPILE_STMT\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileStmt : public HIRCompileBase\n+{\n+public:\n+  static void Compile (HIR::Stmt *stmt, Context *ctx)\n+  {\n+    CompileStmt compiler (ctx);\n+    stmt->accept_vis (compiler);\n+    rust_assert (compiler.ok);\n+  }\n+\n+  virtual ~CompileStmt () {}\n+\n+  void visit (HIR::ExprStmtWithoutBlock &stmt)\n+  {\n+    ok = true;\n+    auto translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n+\n+    // these can be null\n+    if (translated == nullptr)\n+      return;\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    // marks that the statement has been looked at\n+    ok = true;\n+\n+    // nothing to do\n+    if (!stmt.has_init_expr ())\n+      return;\n+\n+    Bvariable *var = nullptr;\n+    if (!ctx->lookup_var_decl (stmt.get_mappings ().get_hirid (), &var))\n+      {\n+\trust_fatal_error (stmt.get_locus (),\n+\t\t\t  \"failed to lookup compiled variable decl\");\n+\treturn;\n+      }\n+\n+    auto *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    auto fnctx = ctx->peek_fn ();\n+    auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n+    ctx->add_statement (s);\n+  }\n+\n+private:\n+  CompileStmt (Context *ctx) : HIRCompileBase (ctx), ok (false) {}\n+\n+  bool ok;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_STMT"}, {"sha": "66d2472265cce0867ba7d6bb9fda734314f2d2e4", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,247 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_TYTY\n+#define RUST_COMPILE_TYTY\n+\n+#include \"rust-system.h\"\n+#include \"rust-location.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class TyTyCompile : public TyTy::TyVisitor\n+{\n+public:\n+  static ::Btype *compile (::Backend *backend, TyTy::TyBase *ty)\n+  {\n+    TyTyCompile compiler (backend);\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyCompile () {}\n+\n+  void visit (TyTy::InferType &type) override\n+  {\n+    // there shouldn't be any of these left\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::UnitType &type) override {}\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    Backend::Btyped_identifier receiver;\n+    std::vector<Backend::Btyped_identifier> parameters;\n+    std::vector<Backend::Btyped_identifier> results;\n+\n+    if (!type.get_return_type ()->is_unit ())\n+      {\n+\tauto hir_type = type.get_return_type ();\n+\tauto ret = TyTyCompile::compile (backend, hir_type);\n+\tresults.push_back (Backend::Btyped_identifier (\n+\t  \"_\", ret, mappings->lookup_location (hir_type->get_ref ())));\n+      }\n+\n+    for (size_t i = 0; i < type.num_params (); i++)\n+      {\n+\tauto param_tyty = type.param_at (i);\n+\tauto compiled_param_type\n+\t  = TyTyCompile::compile (backend, param_tyty->get_base_type ());\n+\tauto compiled_param = Backend::Btyped_identifier (\n+\t  param_tyty->get_identifier (), compiled_param_type,\n+\t  mappings->lookup_location (param_tyty->get_ref ()));\n+\n+\tparameters.push_back (compiled_param);\n+      }\n+\n+    translated\n+      = backend->function_type (receiver, parameters, results, NULL,\n+\t\t\t\tmappings->lookup_location (type.get_ref ()));\n+  }\n+\n+  void visit (TyTy::ParamType &type) override {}\n+\n+  void visit (TyTy::BoolType &type) override\n+  {\n+    translated = backend->named_type (\"bool\", backend->bool_type (),\n+\t\t\t\t      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::IntType &type) override\n+  {\n+    switch (type.get_kind ())\n+      {\n+      case TyTy::IntType::I8:\n+\ttranslated\n+\t  = backend->named_type (\"i8\", backend->integer_type (false, 8),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I16:\n+\ttranslated\n+\t  = backend->named_type (\"i16\", backend->integer_type (false, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I32:\n+\ttranslated\n+\t  = backend->named_type (\"i32\", backend->integer_type (false, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::UintType &type) override\n+  {\n+    switch (type.get_kind ())\n+      {\n+      case TyTy::UintType::U8:\n+\ttranslated = backend->named_type (\"i8\", backend->integer_type (true, 8),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U16:\n+\ttranslated\n+\t  = backend->named_type (\"i16\", backend->integer_type (true, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U32:\n+\ttranslated\n+\t  = backend->named_type (\"i32\", backend->integer_type (true, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+private:\n+  TyTyCompile (::Backend *backend)\n+    : backend (backend), translated (nullptr),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  ::Backend *backend;\n+  ::Btype *translated;\n+  Analysis::Mappings *mappings;\n+};\n+\n+class TyTyExtractParamsFromFnType : public TyTy::TyVisitor\n+{\n+public:\n+  static std::vector<TyTy::ParamType *> compile (TyTy::TyBase *ty)\n+  {\n+    TyTyExtractParamsFromFnType compiler;\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.ok);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyExtractParamsFromFnType () {}\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    ok = true;\n+    for (size_t i = 0; i < type.num_params (); i++)\n+      {\n+\ttranslated.push_back (type.param_at (i));\n+      }\n+  }\n+\n+private:\n+  TyTyExtractParamsFromFnType () : ok (false) {}\n+\n+  bool ok;\n+  std::vector<TyTy::ParamType *> translated;\n+};\n+\n+class TyTyExtractRetFromFnType : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::TyBase *compile (TyTy::TyBase *ty)\n+  {\n+    TyTyExtractRetFromFnType compiler;\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.ok);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyExtractRetFromFnType () {}\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    ok = true;\n+    translated = type.get_return_type ();\n+  }\n+\n+private:\n+  TyTyExtractRetFromFnType () : ok (false), translated (nullptr) {}\n+\n+  bool ok;\n+  TyTy::TyBase *translated;\n+};\n+\n+class TyTyCompileParam : public TyTy::TyVisitor\n+{\n+public:\n+  static ::Bvariable *compile (::Backend *backend, Bfunction *fndecl,\n+\t\t\t       TyTy::TyBase *ty)\n+  {\n+    TyTyCompileParam compiler (backend, fndecl);\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyCompileParam () {}\n+\n+  void visit (TyTy::ParamType &type) override\n+  {\n+    auto btype = TyTyCompile::compile (backend, type.get_base_type ());\n+    bool tree_addressable = false;\n+    translated = backend->parameter_variable (fndecl, type.get_identifier (),\n+\t\t\t\t\t      btype, tree_addressable,\n+\t\t\t\t\t      mappings->lookup_location (\n+\t\t\t\t\t\ttype.get_ref ()));\n+  }\n+\n+private:\n+  TyTyCompileParam (::Backend *backend, ::Bfunction *fndecl)\n+    : backend (backend), translated (nullptr), fndecl (fndecl),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  ::Backend *backend;\n+  ::Bvariable *translated;\n+  ::Bfunction *fndecl;\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_TYTY"}, {"sha": "be3141a2bae200b6b858131ed1e3c1239b20dd60", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_VAR_DECL\n+#define RUST_COMPILE_VAR_DECL\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileVarDecl : public HIRCompileBase\n+{\n+public:\n+  static ::Bvariable *compile (::Bfunction *fndecl, HIR::Stmt *stmt,\n+\t\t\t       Context *ctx)\n+  {\n+    CompileVarDecl compiler (ctx, fndecl);\n+    stmt->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    ctx->insert_var_decl (stmt->get_mappings ().get_hirid (),\n+\t\t\t  compiler.translated);\n+    return compiler.translated;\n+  }\n+\n+  virtual ~CompileVarDecl () {}\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    TyTy::TyBase *resolved_type = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t\t      &resolved_type);\n+    rust_assert (ok);\n+\n+    ::Btype *translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n+\n+    translated = ctx->get_backend ()->local_variable (\n+      fndecl, stmt.get_pattern ()->as_string (), translated_type,\n+      NULL /*decl_var*/, false /*address_taken*/, stmt.get_locus ());\n+  }\n+\n+private:\n+  CompileVarDecl (Context *ctx, ::Bfunction *fndecl)\n+    : HIRCompileBase (ctx), fndecl (fndecl), translated (nullptr)\n+  {}\n+\n+  ::Bfunction *fndecl;\n+  ::Bvariable *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_VAR_DECL"}, {"sha": "11c380b19251fe9ac0ec6a52c5151183a4f4e9a9", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -17,16 +17,31 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile.h\"\n-#include \"rust-diagnostics.h\"\n+#include \"rust-compile-item.h\"\n \n namespace Rust {\n namespace Compile {\n \n+CompileCrate::CompileCrate (HIR::Crate &crate, Context *ctx)\n+  : crate (crate), ctx (ctx)\n+{}\n+\n CompileCrate::~CompileCrate () {}\n \n void\n CompileCrate::Compile (HIR::Crate &crate, Context *ctx)\n-{}\n+\n+{\n+  CompileCrate c (crate, ctx);\n+  c.go ();\n+}\n+\n+void\n+CompileCrate::go ()\n+{\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    CompileItem::compile (it->get (), ctx);\n+}\n \n } // namespace Compile\n } // namespace Rust"}, {"sha": "18f3e54083573b0892a1c1f235e8f35941349e82", "filename": "gcc/rust/backend/rust-compile.h", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -20,55 +20,12 @@\n #define RUST_COMPILE_H\n \n #include \"rust-system.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-name-resolver.h\"\n-#include \"rust-hir-type-check.h\"\n-#include \"rust-linemap.h\"\n-#include \"rust-backend.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-compile-context.h\"\n \n namespace Rust {\n namespace Compile {\n \n-class Context\n-{\n-public:\n-  Context (::Backend *backend)\n-    : backend (backend), resolver (Resolver::Resolver::get ()),\n-      tyctx (Resolver::TypeCheckContext::get ()),\n-      mappings (Analysis::Mappings::get ())\n-  {}\n-\n-  ~Context () {}\n-\n-  ::Backend *get_backend () { return backend; }\n-  Resolver::Resolver *get_resolver () { return resolver; }\n-  Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n-  Analysis::Mappings *get_mappings () { return mappings; }\n-\n-  void push_type (::Btype *t) { type_decls.push_back (t); }\n-  void push_var (::Bvariable *v) { var_decls.push_back (v); }\n-  void push_const (::Bexpression *c) { const_decls.push_back (c); }\n-  void push_function (::Bfunction *f) { func_decls.push_back (f); }\n-\n-  void write_to_backend ()\n-  {\n-    backend->write_global_definitions (type_decls, const_decls, func_decls,\n-\t\t\t\t       var_decls);\n-  }\n-\n-private:\n-  ::Backend *backend;\n-  Resolver::Resolver *resolver;\n-  Resolver::TypeCheckContext *tyctx;\n-  Analysis::Mappings *mappings;\n-\n-  // To GCC middle-end\n-  std::vector< ::Btype *> type_decls;\n-  std::vector< ::Bvariable *> var_decls;\n-  std::vector< ::Bexpression *> const_decls;\n-  std::vector< ::Bfunction *> func_decls;\n-};\n-\n class CompileCrate\n {\n public:\n@@ -78,6 +35,7 @@ class CompileCrate\n \n private:\n   CompileCrate (HIR::Crate &crate, Context *ctx);\n+  void go ();\n \n   HIR::Crate &crate;\n   Context *ctx;"}, {"sha": "e6c86b8ca4501b4c2f01ac6b3dc1a440d0f4d04e", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -69,9 +69,16 @@ class ASTLoweringItem : public ASTLoweringBase\n \tauto translated_type = std::unique_ptr<HIR::Type> (\n \t  ASTLoweringType::translate (param.get_type ().get ()));\n \n-\tfunction_params.push_back (\n-\t  HIR::FunctionParam (std::move (translated_pattern),\n-\t\t\t      std::move (translated_type), param.get_locus ()));\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n       }\n \n     std::unique_ptr<HIR::BlockExpr> function_body\n@@ -83,7 +90,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    translated\n+    auto fn\n       = new HIR::Function (mapping, std::move (function_name),\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n \t\t\t   std::move (function_params), std::move (return_type),\n@@ -92,9 +99,21 @@ class ASTLoweringItem : public ASTLoweringBase\n \n     mappings->insert_defid_mapping (mapping.get_defid (), translated);\n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n+\t\t\t       fn);\n     mappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t       function.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : fn->function_params)\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ()->get_hirid (),\n+\t\t\t\t    &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n+\n+    translated = fn;\n   }\n \n   // Helpers"}, {"sha": "c57d14fbbe2ef6b7a57e1c25ad891f4bcf4d19fc", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -60,6 +60,7 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t\t       stmt.get_locus ());\n     mappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t       stmt.get_locus ());\n+    mappings->insert_hir_stmt (crate_num, mapping.get_hirid (), translated);\n   }\n \n   void visit (AST::LetStmt &stmt)\n@@ -86,6 +87,7 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t  std::move (outer_attrs), stmt.get_locus ());\n     mappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t       stmt.get_locus ());\n+    mappings->insert_hir_stmt (crate_num, mapping.get_hirid (), translated);\n   }\n \n private:"}, {"sha": "36c2085578212d00619a070a70339604d8340b4d", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -536,6 +536,7 @@ class ComparisonExpr : public OperatorExpr\n   void accept_vis (HIRVisitor &vis) override;\n \n   Expr *get_lhs () { return main_or_left_expr.get (); }\n+  Expr *get_rhs () { return right_expr.get (); }\n \n   /* TODO: implement via a function call to std::cmp::PartialEq::eq(&op1, &op2)\n    * maybe? */\n@@ -610,6 +611,8 @@ class LazyBooleanExpr : public OperatorExpr\n \n   Expr *get_lhs () { return main_or_left_expr.get (); }\n \n+  Expr *get_rhs () { return right_expr.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2562,6 +2565,14 @@ class BlockExpr : public ExprWithBlock\n       }\n   }\n \n+  Location get_closing_locus ()\n+  {\n+    if (statements.size () == 0)\n+      return get_locus ();\n+\n+    return statements[statements.size () - 1]->get_locus_slow ();\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "e0477f438a18c678fbece7fd4a002c02f072b73a", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -409,17 +409,20 @@ struct FunctionParam\n   std::unique_ptr<Type> type;\n \n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n-  FunctionParam (std::unique_ptr<Pattern> param_name,\n+  FunctionParam (Analysis::NodeMapping mappings,\n+\t\t std::unique_ptr<Pattern> param_name,\n \t\t std::unique_ptr<Type> param_type, Location locus)\n     : param_name (std::move (param_name)), type (std::move (param_type)),\n-      locus (locus)\n+      locus (locus), mappings (mappings)\n   {}\n \n   // Copy constructor uses clone\n   FunctionParam (FunctionParam const &other)\n     : param_name (other.param_name->clone_pattern ()),\n-      type (other.type->clone_type ()), locus (other.locus)\n+      type (other.type->clone_type ()), locus (other.locus),\n+      mappings (other.mappings)\n   {}\n \n   // Overload assignment operator to use clone\n@@ -428,6 +431,7 @@ struct FunctionParam\n     param_name = other.param_name->clone_pattern ();\n     type = other.type->clone_type ();\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -436,22 +440,15 @@ struct FunctionParam\n   FunctionParam (FunctionParam &&other) = default;\n   FunctionParam &operator= (FunctionParam &&other) = default;\n \n-  // Returns whether FunctionParam is in an invalid state.\n-  bool is_error () const { return param_name == nullptr || type == nullptr; }\n-\n-  // Creates an error FunctionParam.\n-  static FunctionParam create_error ()\n-  {\n-    return FunctionParam (nullptr, nullptr, Location ());\n-  }\n-\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n \n   Pattern *get_param_name () { return param_name.get (); }\n \n   Type *get_type () { return type.get (); }\n+\n+  Analysis::NodeMapping *get_mappings () { return &mappings; }\n };\n \n // Visibility of item - if the item has it, then it is some form of public\n@@ -1191,8 +1188,6 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location locus;\n \n-  std::vector<LetStmt *> locals;\n-\n   std::string as_string () const override;\n \n   // Returns whether function has generic parameters."}, {"sha": "c799b5e5fa53c18f82a5e4e702169608d3d1404a", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -117,6 +117,8 @@ class LetStmt : public Stmt\n \n   HIR::Expr *get_init_expr () { return init_expr.get (); }\n \n+  HIR::Pattern *get_pattern () { return variables_pattern.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -174,6 +176,8 @@ class ExprStmtWithoutBlock : public ExprStmt\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Expr *get_expr () { return expr.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "9e98fda08628d79179abff48199574c6d018ede9", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -38,7 +38,13 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::PathInExpression &expr)\n   {\n-    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown path %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+    else\n       {\n \tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (expr.get_node_id (),\n@@ -60,7 +66,7 @@ class ResolveExpr : public ResolverBase\n       ResolveExpr::go (p, expr.get_node_id ());\n       return true;\n     });\n-    /// resolver->insert_resolved_name(NodeId refId,NodeId defId)\n+    // resolver->insert_resolved_name(NodeId refId,NodeId defId)\n   }\n \n   void visit (AST::AssignmentExpr &expr)"}, {"sha": "fc2da703e6cbebe76d15fbe95998c7b1bf521d61", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -78,7 +78,6 @@ class PatternDeclaration : public ResolverBase\n \n   void visit (AST::IdentifierPattern &pattern)\n   {\n-    printf (\"declaration for: %s\\n\", pattern.as_string ().c_str ());\n     // if we have a duplicate id this then allows for shadowing correctly\n     // as new refs to this decl will match back here so it is ok to overwrite\n     resolver->get_name_scope ().insert (pattern.get_ident (),"}, {"sha": "20d40f1c1a595e6e711603487bfe2b7b5f0d9af0", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -39,6 +39,11 @@ class ResolveStmt : public ResolverBase\n \n   ~ResolveStmt () {}\n \n+  void visit (AST::ExprStmtWithoutBlock &stmt)\n+  {\n+    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());\n+  }\n+\n   void visit (AST::LetStmt &stmt)\n   {\n     PatternDeclaration::go (stmt.get_pattern ().get (), stmt.get_node_id ());"}, {"sha": "32a5d8b2da45e84d44f50a79196dbabbb1e8388f", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -110,16 +110,25 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n+    // these ref_node_ids will resolve to a pattern declaration but we are\n+    // interested in the definition that this refers to get the parent id\n+    Definition def;\n+    if (!resolver->lookup_definition (ref_node_id, &def))\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown reference\");\n+\treturn;\n+      }\n+\n     // node back to HIR\n     HirId ref;\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n+\t\t\t\t       def.parent, &ref))\n       {\n \trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n \treturn;\n       }\n \n-    // check if this has a type\n+    // the base reference for this name _must_ have a type set\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (ref, &lookup))\n       {\n@@ -138,13 +147,19 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     switch (expr.get_lit_type ())\n       {\n-      case HIR::Literal::LitType::INT:\n-\tinfered = new TyTy::IntType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t     TyTy::IntType::IntKind::I32);\n+\tcase HIR::Literal::LitType::INT: {\n+\t  // FIXME:\n+\t  // assume i32 let the combiner functions figure it out\n+\t  // this should look at the suffix of the literal value to check\n+\t  auto ok = context->lookup_builtin (\"i32\", &infered);\n+\t  rust_assert (ok);\n+\t}\n \tbreak;\n \n-      case HIR::Literal::LitType::BOOL:\n-\tinfered = new TyTy::BoolType (expr.get_mappings ().get_hirid ());\n+\tcase HIR::Literal::LitType::BOOL: {\n+\t  auto ok = context->lookup_builtin (\"bool\", &infered);\n+\t  rust_assert (ok);\n+\t}\n \tbreak;\n \n       default:"}, {"sha": "ab964a9bd6f97c23eb9ccbfdb20f9b39dc3cb238", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -66,6 +66,7 @@ class TypeCheckItem : public TypeCheckBase\n \trust_error_at (function.locus, \"failed to lookup function type\");\n \treturn;\n       }\n+\n     // need to get the return type from this\n     ResolveFnType resolve_fn_type (fnType);\n     context->push_return_type (resolve_fn_type.go ());"}, {"sha": "ccf11388cd44131a75cecfc9f8956622f41fca57", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -36,6 +36,11 @@ class TypeCheckStmt : public TypeCheckBase\n     stmt->accept_vis (resolver);\n   }\n \n+  void visit (HIR::ExprStmtWithoutBlock &stmt)\n+  {\n+    TypeCheckExpr::Resolve (stmt.get_expr ());\n+  }\n+\n   void visit (HIR::LetStmt &stmt)\n   {\n     TyTy::TyBase *init_expr_ty = nullptr;"}, {"sha": "25e6c0bb9b583c8c466db05c682193415ccbabd4", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -44,9 +44,18 @@ class TypeCheckTopLevel : public TypeCheckBase\n     else\n       ret_type = TypeCheckType::Resolve (function.return_type.get ());\n \n-    std::vector<TyTy::TyBase *> params;\n+    std::vector<TyTy::ParamType *> params;\n     for (auto &param : function.function_params)\n-      params.push_back (TypeCheckType::Resolve (param.type.get ()));\n+      {\n+\t// get the name as well required for later on\n+\tauto param_type = TypeCheckType::Resolve (param.type.get ());\n+\tauto param_tyty\n+\t  = new TyTy::ParamType (param.get_mappings ()->get_hirid (),\n+\t\t\t\t param.param_name->as_string (), param_type);\n+\tparams.push_back (param_tyty);\n+\n+\tcontext->insert_type (param.get_mappings ()->get_hirid (), param_tyty);\n+      }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n \t\t\t\t    params, ret_type);"}, {"sha": "beab77a838d11d8a746e2f70664f15f25b3e0d89", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -55,6 +55,7 @@ class TypeCheckType : public TypeCheckBase\n \treturn;\n       }\n \n+    // reverse lookup the hir node from ast node id\n     HirId hir_lookup;\n     if (context->lookup_type_by_node_id (ref, &hir_lookup))\n       {\n@@ -63,7 +64,7 @@ class TypeCheckType : public TypeCheckBase\n \t  return;\n       }\n \n-    // this might be a struct type reference\n+    // this might be a struct type (TyTy::ADT) reference\n     // TODO\n     printf (\"UNREACHABLE %s\\n\", path.as_string ().c_str ());\n     gcc_unreachable ();"}, {"sha": "6deecddfd747b3d6287128a3dbdbaad95bc8e90f", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -33,6 +33,7 @@ class TypeCheckContext\n \n   ~TypeCheckContext ();\n \n+  bool lookup_builtin (std::string name, TyTy::TyBase **type);\n   void insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type);\n \n   void insert_type (HirId id, TyTy::TyBase *type);"}, {"sha": "8869e34b36ca5bfeec8a63f5bd3858a54899906a", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -35,11 +35,23 @@ TypeCheckContext::TypeCheckContext () {}\n \n TypeCheckContext::~TypeCheckContext () {}\n \n+bool\n+TypeCheckContext::lookup_builtin (std::string name, TyTy::TyBase **type)\n+{\n+  for (auto &builtin : builtins)\n+    {\n+      if (name.compare (builtin->as_string ()) == 0)\n+\t{\n+\t  *type = builtin.get ();\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n void\n TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type)\n {\n-  printf (\"inserting builtin: hir %u node %u -> %s\\n\", id, ref,\n-\t  type->as_string ().c_str ());\n   node_id_refs[ref] = id;\n   resolved[id] = type;\n   builtins.push_back (std::unique_ptr<TyTy::TyBase> (type));"}, {"sha": "372229bfd4f782432cc8c721b7d388c3ca4aaeaa", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -155,8 +155,8 @@ class ParamRules : protected BaseRules\n \n   TyBase *combine (TyBase *other)\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    // we only case about the base type of a param\n+    return base->get_base_type ()->combine (other);\n   }\n \n private:"}, {"sha": "4a36d4f4315ae9a3cbf4b9170924ba2fcc2e3964", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -99,7 +99,7 @@ ParamType::accept_vis (TyVisitor &vis)\n std::string\n ParamType::as_string () const\n {\n-  return \"(\" + type->as_string () + \")\";\n+  return \"(\" + identifier + \" :\" + type->as_string () + \")\";\n }\n \n TyBase *"}, {"sha": "4e044906d2fc3e5698e90270a541a6eadb78f703", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -54,12 +54,12 @@ class TyBase\n \n   virtual void accept_vis (TyVisitor &vis) = 0;\n \n-  virtual bool is_unit () const { return false; }\n-\n   virtual std::string as_string () const = 0;\n \n   virtual TyBase *combine (TyBase *other) = 0;\n \n+  virtual bool is_unit () const { return kind == TypeKind::UNIT; }\n+\n protected:\n   TyBase (HirId ref, TypeKind kind) : kind (kind), ref (ref) {}\n \n@@ -95,46 +95,51 @@ class UnitType : public TyBase\n   TyBase *combine (TyBase *other) override;\n };\n \n-class FnType : public TyBase\n+class ParamType : public TyBase\n {\n public:\n-  FnType (HirId ref, std::vector<TyBase *> params, TyBase *type)\n-    : TyBase (ref, TypeKind::FNDEF), params (params), type (type)\n+  ParamType (HirId ref, std::string identifier, TyBase *type)\n+    : TyBase (ref, TypeKind::PARAM), identifier (identifier), type (type)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n   std::string as_string () const override;\n \n-  TyBase *return_type () { return type; }\n-\n   TyBase *combine (TyBase *other) override;\n \n-  size_t num_params () const { return params.size (); }\n+  std::string get_identifier () const { return identifier; }\n \n-  TyBase *param_at (size_t idx) { return params[idx]; }\n-\n-  TyBase *get_return_type () { return type; }\n+  TyBase *get_base_type () { return type; }\n \n private:\n-  std::vector<TyBase *> params;\n+  std::string identifier;\n   TyBase *type;\n };\n \n-class ParamType : public TyBase\n+class FnType : public TyBase\n {\n public:\n-  ParamType (HirId ref, TyBase *type)\n-    : TyBase (ref, TypeKind::PARAM), type (type)\n+  FnType (HirId ref, std::vector<ParamType *> params, TyBase *type)\n+    : TyBase (ref, TypeKind::FNDEF), params (params), type (type)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n   std::string as_string () const override;\n \n+  TyBase *return_type () { return type; }\n+\n   TyBase *combine (TyBase *other) override;\n \n+  size_t num_params () const { return params.size (); }\n+\n+  ParamType *param_at (size_t idx) { return params[idx]; }\n+\n+  TyBase *get_return_type () { return type; }\n+\n private:\n+  std::vector<ParamType *> params;\n   TyBase *type;\n };\n "}, {"sha": "bdf487e8c158c8d841068c3b75f4dc4ff207109f", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -304,6 +304,55 @@ Mappings::lookup_hir_type (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_stmt (CrateNum crateNum, HirId id, HIR::Stmt *type)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  hirStmtMappings[crateNum][id] = type;\n+  nodeIdToHirMappings[crateNum][type->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::Stmt *\n+Mappings::lookup_hir_stmt (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirStmtMappings.find (crateNum);\n+  if (it == hirStmtMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_hir_param (CrateNum crateNum, HirId id,\n+\t\t\t    HIR::FunctionParam *param)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  printf (\"inserting param with node id %u hir id: %u\\n\",\n+\t  param->get_mappings ()->get_nodeid (), id);\n+  hirParamMappings[crateNum][id] = param;\n+  nodeIdToHirMappings[crateNum][param->get_mappings ()->get_nodeid ()] = id;\n+}\n+\n+HIR::FunctionParam *\n+Mappings::lookup_hir_param (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirParamMappings.find (crateNum);\n+  if (it == hirParamMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n \t\t\t\t      HIR::Item *item)\n@@ -377,5 +426,22 @@ Mappings::lookup_location (CrateNum crate, HirId id)\n   return iy->second;\n }\n \n+bool\n+Mappings::resolve_nodeid_to_stmt (CrateNum crate, NodeId id, HIR::Stmt **stmt)\n+{\n+  auto it = nodeIdToHirMappings.find (crate);\n+  if (it == nodeIdToHirMappings.end ())\n+    return false;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return false;\n+\n+  HirId resolved = iy->second;\n+  auto resolved_stmt = lookup_hir_stmt (crate, resolved);\n+  *stmt = resolved_stmt;\n+  return resolved_stmt != nullptr;\n+}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "a400265428bf8fd9307d2ccb885840021f13663a", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6136f0aebbb84cbcf8f92bed206733391aaa3866/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=6136f0aebbb84cbcf8f92bed206733391aaa3866", "patch": "@@ -115,6 +115,12 @@ class Mappings\n   void insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type);\n   HIR::Type *lookup_hir_type (CrateNum crateNum, HirId id);\n \n+  void insert_hir_stmt (CrateNum crateNum, HirId id, HIR::Stmt *type);\n+  HIR::Stmt *lookup_hir_stmt (CrateNum crateNum, HirId id);\n+\n+  void insert_hir_param (CrateNum crateNum, HirId id, HIR::FunctionParam *type);\n+  HIR::FunctionParam *lookup_hir_param (CrateNum crateNum, HirId id);\n+\n   void walk_local_defids_for_crate (CrateNum crateNum,\n \t\t\t\t    std::function<bool (HIR::Item *)> cb);\n \n@@ -127,6 +133,12 @@ class Mappings\n     return lookup_location (get_current_crate (), id);\n   }\n \n+  bool resolve_nodeid_to_stmt (CrateNum crate, NodeId id, HIR::Stmt **stmt);\n+  bool resolve_nodeid_to_stmt (NodeId id, HIR::Stmt **stmt)\n+  {\n+    return resolve_nodeid_to_stmt (get_current_crate (), id, stmt);\n+  }\n+\n private:\n   Mappings ();\n \n@@ -145,6 +157,8 @@ class Mappings\n   std::map<CrateNum, std::map<HirId, HIR::Item *> > hirItemMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Type *> > hirTypeMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Expr *> > hirExprMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Stmt *> > hirStmtMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::FunctionParam *> > hirParamMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}]}