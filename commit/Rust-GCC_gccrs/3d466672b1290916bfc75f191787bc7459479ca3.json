{"sha": "3d466672b1290916bfc75f191787bc7459479ca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q0NjY2NzJiMTI5MDkxNmJmYzc1ZjE5MTc4N2JjNzQ1OTQ3OWNhMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-10-12T21:39:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-12T21:39:35Z"}, "message": "[PATCH] Allow FSM threader to thread more complex conditions\n\n\t* tree-ssa-threadbackward.c (get_gimple_control_stmt): New function.\n\t(fsm_find_control_stmt_paths): Change name of first argument to\n\tmore accurately relfect what it really is.  Handle simplification\n\tof GIMPLE_COND after finding a thread path for NAME.\n\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Allow\n\tnontrivial conditions to be handled by FSM threader.\n\t(thread_through_normal_block): Extract the name to looup via\n\tFSM threader from COND_EXPR.\n\n\t* gcc.dg/tree-ssa/ssa-thread-12.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Update expected output.\n\t* gcc.dg/tree-ssa/ssa-thread-11.c: Renamed from\n\tssa-dom-thread-11.c.\n\nFrom-SVN: r228739", "tree": {"sha": "175480cddd480785cb6eb725aa212724d5416228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/175480cddd480785cb6eb725aa212724d5416228"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d466672b1290916bfc75f191787bc7459479ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d466672b1290916bfc75f191787bc7459479ca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d466672b1290916bfc75f191787bc7459479ca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d466672b1290916bfc75f191787bc7459479ca3/comments", "author": null, "committer": null, "parents": [{"sha": "058a654b30b40d19db1306daa38df363b9bf8a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058a654b30b40d19db1306daa38df363b9bf8a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058a654b30b40d19db1306daa38df363b9bf8a56"}], "stats": {"total": 151, "additions": 139, "deletions": 12}, "files": [{"sha": "a8650439eef6e3b1fc77b31a80ae298992175916", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d466672b1290916bfc75f191787bc7459479ca3", "patch": "@@ -7,6 +7,15 @@\n \n 2015-10-12  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-threadbackward.c (get_gimple_control_stmt): New function.\n+\t(fsm_find_control_stmt_paths): Change name of first argument to\n+\tmore accurately relfect what it really is.  Handle simplification\n+\tof GIMPLE_COND after finding a thread path for NAME. \n+\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Allow\n+\tnontrivial conditions to be handled by FSM threader.\n+\t(thread_through_normal_block): Extract the name to looup via\n+\tFSM threader from COND_EXPR.\n+\n \t* tree-ssa-threadbackward.c (fsm_find_thread_path): Remove\n \trestriction that traced SSA_NAME is a user variable.\n "}, {"sha": "4a08f0fe6370932a929a347cf1693fbade1cc1f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d466672b1290916bfc75f191787bc7459479ca3", "patch": "@@ -1,5 +1,10 @@\n 2015-10-12  Jeff Law  <law@redhat.com>\n \n+\t* gcc.dg/tree-ssa/ssa-thread-12.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Update expected output.\n+\t* gcc.dg/tree-ssa/ssa-thread-11.c: Renamed from\n+\tssa-dom-thread-11.c.\n+\n \t* gcc.dg/tree-ssa/ssa-dom-thread-11.c: New test.\n \n 2015-10-12  Ville Voutilainen  <ville.voutilainen@gmail.com>"}, {"sha": "445f2509dc3041e44fc0d5d328c0bfb39891c2bb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=3d466672b1290916bfc75f191787bc7459479ca3", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-dom1-details\" } */\n-/* { dg-final { scan-tree-dump-times \"FSM\" 19 \"dom1\" } } */\n+/* { dg-final { scan-tree-dump-times \"FSM\" 38 \"dom1\" } } */\n \n enum STATE {\n   S0=0,"}, {"sha": "03d033456a1026ab7db8b90494f85110e181f464", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-11.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-11.c?ref=3d466672b1290916bfc75f191787bc7459479ca3", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-11.c"}, {"sha": "0697fb0caf5eaa0ed3d12ddce26de27475a5cd38", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-12.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c?ref=3d466672b1290916bfc75f191787bc7459479ca3", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom1-details\" } */\n+/* { dg-final { scan-tree-dump \"FSM\" \"dom1\" } } */\n+\n+typedef struct bitmap_head_def *bitmap;\n+typedef const struct bitmap_head_def *const_bitmap;\n+typedef struct VEC_int_base\n+{\n+}\n+VEC_int_base;\n+typedef struct VEC_int_heap\n+{\n+  VEC_int_base base;\n+}\n+VEC_int_heap;\n+typedef unsigned long BITMAP_WORD;\n+typedef struct bitmap_element_def\n+{\n+  struct bitmap_element_def *next;\n+  unsigned int indx;\n+}\n+bitmap_element;\n+typedef struct bitmap_head_def\n+{\n+}\n+bitmap_head;\n+typedef struct\n+{\n+  bitmap_element *elt1;\n+  bitmap_element *elt2;\n+  BITMAP_WORD bits;\n+}\n+bitmap_iterator;\n+static __inline__ void\n+bmp_iter_and_compl_init (bitmap_iterator * bi, const_bitmap map1,\n+\t\t\t const_bitmap map2, unsigned start_bit,\n+\t\t\t unsigned *bit_no)\n+{\n+}\n+\n+static __inline__ void\n+bmp_iter_next (bitmap_iterator * bi, unsigned *bit_no)\n+{\n+}\n+\n+static __inline__ unsigned char\n+bmp_iter_and_compl (bitmap_iterator * bi, unsigned *bit_no)\n+{\n+  if (bi->bits)\n+    {\n+      while (bi->elt2 && bi->elt2->indx < bi->elt1->indx)\n+\tbi->elt2 = bi->elt2->next;\n+    }\n+}\n+\n+extern int VEC_int_base_length (VEC_int_base *);\n+bitmap\n+compute_idf (bitmap def_blocks, bitmap_head * dfs)\n+{\n+  bitmap_iterator bi;\n+  unsigned bb_index, i;\n+  VEC_int_heap *work_stack;\n+  bitmap phi_insertion_points;\n+  while ((VEC_int_base_length (((work_stack) ? &(work_stack)->base : 0))) > 0)\n+    {\n+      for (bmp_iter_and_compl_init\n+\t   (&(bi), (&dfs[bb_index]), (phi_insertion_points), (0), &(i));\n+\t   bmp_iter_and_compl (&(bi), &(i)); bmp_iter_next (&(bi), &(i)))\n+\t{\n+\t}\n+    }\n+}"}, {"sha": "5be6ee443e3ab29b8c07212e9b9d31a9576196d6", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=3d466672b1290916bfc75f191787bc7459479ca3", "patch": "@@ -36,6 +36,22 @@ along with GCC; see the file COPYING3.  If not see\n \n static int max_threaded_paths;\n \n+/* Simple helper to get the last statement from BB, which is assumed\n+   to be a control statement.  */\n+static gimple *\n+get_gimple_control_stmt (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\n+  if (gsi_end_p (gsi))\n+    return NULL;\n+\n+  gimple *stmt = gsi_stmt (gsi);\n+  enum gimple_code code = gimple_code (stmt);\n+  gcc_assert (code == GIMPLE_COND || code == GIMPLE_SWITCH || code == GIMPLE_GOTO);\n+  return stmt;\n+}\n+\n /* Return true if the CFG contains at least one path from START_BB to END_BB.\n    When a path is found, record in PATH the blocks from END_BB to START_BB.\n    VISITED_BBS is used to make sure we don't fall into an infinite loop.  Bound\n@@ -70,17 +86,17 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n   return false;\n }\n \n-/* We trace the value of the SSA_NAME EXPR back through any phi nodes looking\n+/* We trace the value of the SSA_NAME NAME back through any phi nodes looking\n    for places where it gets a constant value and save the path.  Stop after\n    having recorded MAX_PATHS jump threading paths.  */\n \n static void\n-fsm_find_control_statement_thread_paths (tree expr,\n+fsm_find_control_statement_thread_paths (tree name,\n \t\t\t\t\t hash_set<basic_block> *visited_bbs,\n \t\t\t\t\t vec<basic_block, va_gc> *&path,\n \t\t\t\t\t bool seen_loop_phi)\n {\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n   basic_block var_bb = gimple_bb (def_stmt);\n \n   if (var_bb == NULL)\n@@ -284,6 +300,20 @@ fsm_find_control_statement_thread_paths (tree expr,\n \t  jump_thread_path->safe_push (x);\n \t}\n \n+      gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n+      gcc_assert (stmt);\n+      /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n+\t and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n+\t we need to substitute, fold and simplify.  */\n+      if (gimple_code (stmt) == GIMPLE_COND)\n+\t{\n+\t  enum tree_code cond_code = gimple_cond_code (stmt);\n+\n+\t  /* We know the underyling format of the condition.  */\n+\t  arg = fold_binary (cond_code, boolean_type_node,\n+\t\t\t     arg, gimple_cond_rhs (stmt));\n+\t}\n+\n       /* Add the edge taken when the control variable has value ARG.  */\n       edge taken_edge = find_taken_edge ((*path)[0], arg);\n       jump_thread_edge *x"}, {"sha": "da2fb1fde46991fe5710768d059ce0cfcb44a59f", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d466672b1290916bfc75f191787bc7459479ca3/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=3d466672b1290916bfc75f191787bc7459479ca3", "patch": "@@ -551,21 +551,24 @@ simplify_control_stmt_condition (edge e,\n           || !is_gimple_min_invariant (cached_lhs))\n         cached_lhs = (*simplify) (dummy_cond, stmt, avail_exprs_stack);\n \n-      /* If we were just testing that an integral type was != 0, and that\n-\t failed, just return the first operand.  This gives the FSM code a\n-\t chance to optimize the path.  */\n-      if (cached_lhs == NULL\n-\t  && cond_code == NE_EXPR)\n+      /* If we were testing an integer/pointer against a constant, then\n+\t we can use the FSM code to trace the value of the SSA_NAME.  If\n+\t a value is found, then the condition will collapse to a constant.\n+\n+\t Return the SSA_NAME we want to trace back rather than the full\n+\t expression and give the FSM threader a chance to find its value.  */\n+      if (cached_lhs == NULL)\n \t{\n \t  /* Recover the original operands.  They may have been simplified\n \t     using context sensitive equivalences.  Those context sensitive\n \t     equivalences may not be valid on paths found by the FSM optimizer.  */\n \t  tree op0 = gimple_cond_lhs (stmt);\n \t  tree op1 = gimple_cond_rhs (stmt);\n \n-\t  if (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t  if ((INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t       || POINTER_TYPE_P (TREE_TYPE (op0)))\n \t      && TREE_CODE (op0) == SSA_NAME\n-\t      && integer_zerop (op1))\n+\t      && TREE_CODE (op1) == INTEGER_CST)\n \t    return op0;\n \t}\n \n@@ -1046,11 +1049,19 @@ thread_through_normal_block (edge e,\n \n       if (!flag_expensive_optimizations\n \t  || optimize_function_for_size_p (cfun)\n-\t  || TREE_CODE (cond) != SSA_NAME\n+\t  || !(TREE_CODE (cond) == SSA_NAME\n+\t       || (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n+\t\t   && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n+\t\t   && TREE_CODE (TREE_OPERAND (cond, 1)) == INTEGER_CST))\n \t  || e->dest->loop_father != e->src->loop_father\n \t  || loop_depth (e->dest->loop_father) == 0)\n \treturn 0;\n \n+      /* Extract the SSA_NAME we want to trace backwards if COND is not\n+\t already a bare SSA_NAME.  */\n+      if (TREE_CODE (cond) != SSA_NAME)\n+\tcond = TREE_OPERAND (cond, 0);\n+\n       /* When COND cannot be simplified, try to find paths from a control\n \t statement back through the PHI nodes which would affect that control\n \t statement.  */"}]}