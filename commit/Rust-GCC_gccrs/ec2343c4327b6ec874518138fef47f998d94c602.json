{"sha": "ec2343c4327b6ec874518138fef47f998d94c602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyMzQzYzQzMjdiNmVjODc0NTE4MTM4ZmVmNDdmOTk4ZDk0YzYwMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-04T08:50:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-04T08:50:38Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r679", "tree": {"sha": "3fb0a3a4db04aef4efd36475548a55ee7645961d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fb0a3a4db04aef4efd36475548a55ee7645961d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec2343c4327b6ec874518138fef47f998d94c602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2343c4327b6ec874518138fef47f998d94c602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec2343c4327b6ec874518138fef47f998d94c602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2343c4327b6ec874518138fef47f998d94c602/comments", "author": null, "committer": null, "parents": [{"sha": "59014d0a6fb7f546b7f289f147d9a0c5eb820e35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59014d0a6fb7f546b7f289f147d9a0c5eb820e35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59014d0a6fb7f546b7f289f147d9a0c5eb820e35"}], "stats": {"total": 70, "additions": 42, "deletions": 28}, "files": [{"sha": "1117958dd4f1d87f5667688a784b57a952f77ba2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec2343c4327b6ec874518138fef47f998d94c602/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec2343c4327b6ec874518138fef47f998d94c602/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ec2343c4327b6ec874518138fef47f998d94c602", "patch": "@@ -574,7 +574,7 @@ c_decode_option (p)\n     warn_missing_prototypes = 0;\n   else if (!strcmp (p, \"-Wredundant-decls\"))\n     warn_redundant_decls = 1;\n-  else if (!strcmp (p, \"-Wnoredundant-decls\"))\n+  else if (!strcmp (p, \"-Wno-redundant-decls\"))\n     warn_redundant_decls = 0;\n   else if (!strcmp (p, \"-Wnested-externs\"))\n     warn_nested_externs = 1;\n@@ -1369,8 +1369,9 @@ duplicate_decls (newdecl, olddecl)\n \t{\n \t  /* Since the type is OLDDECL's, make OLDDECL's size go with.  */\n \t  DECL_SIZE (newdecl) = DECL_SIZE (olddecl);\n-\t  if (DECL_ALIGN (olddecl) > DECL_ALIGN (newdecl))\n-\t    DECL_ALIGN (newdecl) = DECL_ALIGN (olddecl);\n+\t  if (TREE_CODE (olddecl) != FUNCTION_DECL)\n+\t    if (DECL_ALIGN (olddecl) > DECL_ALIGN (newdecl))\n+\t      DECL_ALIGN (newdecl) = DECL_ALIGN (olddecl);\n \t}\n \n       /* Merge the type qualifiers.  */\n@@ -2562,10 +2563,7 @@ init_decl_processing ()\n       builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP, 0);\n       builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY, 0);\n       builtin_function (\"strlen\", sizet_ftype_string, BUILT_IN_STRLEN, 0);\n-#if 0 /* No good, since open-coded implementation fails to set errno.\n-\t The ANSI committee made a real mistake in specifying math fns.  */\n       builtin_function (\"sqrt\", double_ftype_double, BUILT_IN_FSQRT, 0);\n-#endif\n     }\n \n #if 0\n@@ -3601,7 +3599,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t      error (\"size of array `%s' is negative\", name);\n \t\t      size = integer_one_node;\n \t\t    }\n-\t\t  itype = build_index_type (build_int_2 (TREE_INT_CST_LOW (size) - 1, 0));\n+\t\t  itype = build_index_type (size_binop (MINUS_EXPR, size,\n+\t\t\t\t\t\t\tsize_one_node));\n \t\t}\n \t      else\n \t\t{\n@@ -4532,8 +4531,13 @@ finish_struct (t, fieldlist)\n \t    }\n \t}\n       else\n-\t/* Non-bit-fields are aligned for their type.  */\n-\tDECL_ALIGN (x) = MAX (DECL_ALIGN (x), TYPE_ALIGN (TREE_TYPE (x)));\n+\t{\n+\t  int min_align = (DECL_PACKED (x) ? BITS_PER_UNIT\n+\t\t\t   : TYPE_ALIGN (TREE_TYPE (x)));\n+\t  /* Non-bit-fields are aligned for their type, except packed\n+\t     fields which require only BITS_PER_UNIT alignment.  */\n+\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), min_align);\n+\t}\n     }\n \n   /* Now DECL_INITIAL is null on all members.  */\n@@ -4819,7 +4823,8 @@ finish_enum (enumtype, values)\n       {\n \tTREE_TYPE (TREE_PURPOSE (pair)) = enumtype;\n \tDECL_SIZE (TREE_PURPOSE (pair)) = TYPE_SIZE (enumtype);\n-\tDECL_ALIGN (TREE_PURPOSE (pair)) = TYPE_ALIGN (enumtype);\n+\tif (TREE_CODE (TREE_PURPOSE (pair)) != FUNCTION_DECL)\n+\t  DECL_ALIGN (TREE_PURPOSE (pair)) = TYPE_ALIGN (enumtype);\n       }\n \n   /* Replace the decl nodes in VALUES with their names.  */\n@@ -5289,27 +5294,33 @@ store_parm_decls ()\n \t\t}\n \t      /* Type for passing arg must be consistent\n \t\t with that declared for the arg.  */\n-\t      if (! comptypes (DECL_ARG_TYPE (parm), TREE_VALUE (type))\n-\t\t  /* If -traditional, allow `unsigned int' instead of `int'\n-\t\t     in the prototype.  */\n-\t\t  && (! (flag_traditional\n-\t\t\t && DECL_ARG_TYPE (parm) == integer_type_node\n-\t\t\t && TREE_VALUE (type) == unsigned_type_node)))\n+\t      if (! comptypes (DECL_ARG_TYPE (parm), TREE_VALUE (type)))\n \t\t{\n-\t\t  error (\"argument `%s' doesn't match function prototype\",\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parm)));\n-\t\t  if (DECL_ARG_TYPE (parm) == integer_type_node\n-\t\t      && TREE_VALUE (type) == TREE_TYPE (parm))\n+\t\t  if (TREE_TYPE (parm) == TREE_VALUE (type))\n \t\t    {\n-\t\t      error (\"a formal parameter type that promotes to `int'\");\n-\t\t      error (\"can match only `int' in the prototype\");\n-\t\t    }\n-\t\t  if (DECL_ARG_TYPE (parm) == double_type_node\n-\t\t      && TREE_VALUE (type) == TREE_TYPE (parm))\n-\t\t    {\n-\t\t      error (\"a formal parameter type that promotes to `double'\");\n-\t\t      error (\"can match only `double' in the prototype\");\n+\t\t      /* Adjust argument to match prototype.  E.g. a previous\n+\t\t\t `int foo(float);' prototype causes\n+\t\t\t `int foo(x) float x; {...}' to be treated like\n+\t\t\t `int foo(float x) {...}'.  This is particularly\n+\t\t\t useful for argument types like uid_t.  */\n+\t\t      DECL_ARG_TYPE (parm) = TREE_TYPE (parm);\n+#ifdef PROMOTE_PROTOTYPES\n+\t\t      if (TREE_CODE (TREE_TYPE (parm)) == INTEGER_TYPE\n+\t\t\t  && TYPE_PRECISION (TREE_TYPE (parm))\n+\t\t\t  < TYPE_PRECISION (integer_type_node))\n+\t\t\tDECL_ARG_TYPE (parm) = integer_type_node;\n+#endif\n+\t\t      if (pedantic)\n+\t\t\twarning (\"promoted argument `%s' doesn't match prototype\",\n+\t\t\t\t IDENTIFIER_POINTER (DECL_NAME (parm)));\n \t\t    }\n+\t\t  /* If -traditional, allow `int' argument to match\n+\t\t     `unsigned' prototype.  */\n+\t\t  else if (! (flag_traditional\n+\t\t\t      && TREE_TYPE (parm) == integer_type_node\n+\t\t\t      && TREE_VALUE (type) == unsigned_type_node))\n+\t\t    error (\"argument `%s' doesn't match prototype\",\n+\t\t\t   IDENTIFIER_POINTER (DECL_NAME (parm)));\n \t\t}\n \t    }\n \t  TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = 0;\n@@ -5653,6 +5664,9 @@ push_c_function_context ()\n   struct c_function *p\n     = (struct c_function *) xmalloc (sizeof (struct c_function));\n \n+  if (pedantic)\n+    pedwarn (\"ANSI C forbids nested functions\");\n+\n   push_function_context ();\n \n   p->next = c_function_chain;"}]}