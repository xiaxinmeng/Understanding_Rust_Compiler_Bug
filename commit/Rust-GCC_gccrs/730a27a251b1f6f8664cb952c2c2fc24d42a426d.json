{"sha": "730a27a251b1f6f8664cb952c2c2fc24d42a426d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwYTI3YTI1MWIxZjZmODY2NGNiOTUyYzJjMmZjMjRkNDJhNDI2ZA==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-07-16T15:59:33Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-07-16T15:59:33Z"}, "message": "pa.c (hppa_profile_hook): Allocate stack space for register parameters.\n\n\t* config/pa/pa.c (hppa_profile_hook): Allocate stack space for\n\tregister parameters.  Remove code to initialize argument pointer\n\ton TARGET_64BIT.  Optimize call to _mcount when it can be reached\n\tusing a pc-relative branch.  Cleanup conditional code.\n\t* config/pa/pa.md (call_mcount): New expander.\n\t(call_mcount_nonpic): New insn.\n\t(call_mcount_pic): New insn and split.\n\t(call_mcount_pic_post_reload): New insn.\n\t(call_mcount_64bit): New insn and split.\n\t(call_mcount_64bit_post_reload): New insn.\n\nFrom-SVN: r238414", "tree": {"sha": "7aa3b83d0344090824f99eab5019a10d7cbd4537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aa3b83d0344090824f99eab5019a10d7cbd4537"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/730a27a251b1f6f8664cb952c2c2fc24d42a426d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/730a27a251b1f6f8664cb952c2c2fc24d42a426d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/730a27a251b1f6f8664cb952c2c2fc24d42a426d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/730a27a251b1f6f8664cb952c2c2fc24d42a426d/comments", "author": null, "committer": null, "parents": [{"sha": "a9356b1242b57fc99b2200e6c3d5039c9d4948fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9356b1242b57fc99b2200e6c3d5039c9d4948fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9356b1242b57fc99b2200e6c3d5039c9d4948fe"}], "stats": {"total": 280, "additions": 238, "deletions": 42}, "files": [{"sha": "62ca076d1d5ecdeb626a1a9c8d5318aa4da20752", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730a27a251b1f6f8664cb952c2c2fc24d42a426d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730a27a251b1f6f8664cb952c2c2fc24d42a426d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=730a27a251b1f6f8664cb952c2c2fc24d42a426d", "patch": "@@ -1,3 +1,16 @@\n+2016-07-16  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa.c (hppa_profile_hook): Allocate stack space for\n+\tregister parameters.  Remove code to initialize argument pointer\n+\ton TARGET_64BIT.  Optimize call to _mcount when it can be reached\n+\tusing a pc-relative branch.  Cleanup conditional code.\n+\t* config/pa/pa.md (call_mcount): New expander.\n+\t(call_mcount_nonpic): New insn.\n+\t(call_mcount_pic): New insn and split.\n+\t(call_mcount_pic_post_reload): New insn.\n+\t(call_mcount_64bit): New insn and split.\n+\t(call_mcount_64bit_post_reload): New insn.\n+\n 2016-07-15  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/predicates.md (const_m255_to_m1_operand): New."}, {"sha": "67aa55b67f70370068ff8e810caf8944eca5187e", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 61, "deletions": 42, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730a27a251b1f6f8664cb952c2c2fc24d42a426d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730a27a251b1f6f8664cb952c2c2fc24d42a426d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=730a27a251b1f6f8664cb952c2c2fc24d42a426d", "patch": "@@ -4532,70 +4532,89 @@ hppa_profile_hook (int label_no)\n      lcla2 and load_offset_label_address insn patterns.  */\n   rtx reg = gen_reg_rtx (SImode);\n   rtx_code_label *label_rtx = gen_label_rtx ();\n-  rtx begin_label_rtx;\n+  rtx mcount = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (Pmode, \"_mcount\"));\n+  int reg_parm_stack_space = REG_PARM_STACK_SPACE (NULL_TREE);\n+  rtx arg_bytes, begin_label_rtx;\n   rtx_insn *call_insn;\n   char begin_label_name[16];\n+  bool use_mcount_pcrel_call;\n+\n+  /* If we can reach _mcount with a pc-relative call, we can optimize\n+     loading the address of the current function.  This requires linker\n+     long branch stub support.  */\n+  if (!TARGET_PORTABLE_RUNTIME\n+      && !TARGET_LONG_CALLS\n+      && (TARGET_SOM || flag_function_sections))\n+    use_mcount_pcrel_call = TRUE;\n+  else\n+    use_mcount_pcrel_call = FALSE;\n \n   ASM_GENERATE_INTERNAL_LABEL (begin_label_name, FUNC_BEGIN_PROLOG_LABEL,\n \t\t\t       label_no);\n   begin_label_rtx = gen_rtx_SYMBOL_REF (SImode, ggc_strdup (begin_label_name));\n \n-  if (TARGET_64BIT)\n-    emit_move_insn (arg_pointer_rtx,\n-\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n-\t\t\t\t  GEN_INT (64)));\n-\n   emit_move_insn (gen_rtx_REG (word_mode, 26), gen_rtx_REG (word_mode, 2));\n \n-  /* The address of the function is loaded into %r25 with an instruction-\n-     relative sequence that avoids the use of relocations.  The sequence\n-     is split so that the load_offset_label_address instruction can\n-     occupy the delay slot of the call to _mcount.  */\n-  if (TARGET_PA_20)\n-    emit_insn (gen_lcla2 (reg, label_rtx));\n-  else\n-    emit_insn (gen_lcla1 (reg, label_rtx));\n-\n-  emit_insn (gen_load_offset_label_address (gen_rtx_REG (SImode, 25), \n-\t\t\t\t\t    reg, begin_label_rtx, label_rtx));\n-\n-#if !NO_DEFERRED_PROFILE_COUNTERS\n-  {\n-    rtx count_label_rtx, addr, r24;\n-    char count_label_name[16];\n+  if (!use_mcount_pcrel_call)\n+    {\n+      /* The address of the function is loaded into %r25 with an instruction-\n+\t relative sequence that avoids the use of relocations.  The sequence\n+\t is split so that the load_offset_label_address instruction can\n+\t occupy the delay slot of the call to _mcount.  */\n+      if (TARGET_PA_20)\n+\temit_insn (gen_lcla2 (reg, label_rtx));\n+      else\n+\temit_insn (gen_lcla1 (reg, label_rtx));\n \n-    funcdef_nos.safe_push (label_no);\n-    ASM_GENERATE_INTERNAL_LABEL (count_label_name, \"LP\", label_no);\n-    count_label_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (count_label_name));\n+      emit_insn (gen_load_offset_label_address (gen_rtx_REG (SImode, 25), \n+\t\t\t\t\t\treg,\n+\t\t\t\t\t\tbegin_label_rtx,\n+\t\t\t\t\t\tlabel_rtx));\n+    }\n \n-    addr = force_reg (Pmode, count_label_rtx);\n-    r24 = gen_rtx_REG (Pmode, 24);\n-    emit_move_insn (r24, addr);\n+  if (!NO_DEFERRED_PROFILE_COUNTERS)\n+    {\n+      rtx count_label_rtx, addr, r24;\n+      char count_label_name[16];\n \n-    call_insn =\n-      emit_call_insn (gen_call (gen_rtx_MEM (Pmode, \n-\t\t\t\t\t     gen_rtx_SYMBOL_REF (Pmode, \n-\t\t\t\t\t\t\t\t \"_mcount\")),\n-\t\t\t\tGEN_INT (TARGET_64BIT ? 24 : 12)));\n+      funcdef_nos.safe_push (label_no);\n+      ASM_GENERATE_INTERNAL_LABEL (count_label_name, \"LP\", label_no);\n+      count_label_rtx = gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t    ggc_strdup (count_label_name));\n \n-    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), r24);\n-  }\n-#else\n+      addr = force_reg (Pmode, count_label_rtx);\n+      r24 = gen_rtx_REG (Pmode, 24);\n+      emit_move_insn (r24, addr);\n \n-  call_insn =\n-    emit_call_insn (gen_call (gen_rtx_MEM (Pmode, \n-\t\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, \n-\t\t\t\t\t\t\t       \"_mcount\")),\n-\t\t\t      GEN_INT (TARGET_64BIT ? 16 : 8)));\n+      arg_bytes = GEN_INT (TARGET_64BIT ? 24 : 12);\n+      if (use_mcount_pcrel_call)\n+\tcall_insn = emit_call_insn (gen_call_mcount (mcount, arg_bytes,\n+\t\t\t\t\t\t     begin_label_rtx));\n+      else\n+\tcall_insn = emit_call_insn (gen_call (mcount, arg_bytes));\n \n-#endif\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), r24);\n+    }\n+  else\n+    {\n+      arg_bytes = GEN_INT (TARGET_64BIT ? 16 : 8);\n+      if (use_mcount_pcrel_call)\n+\tcall_insn = emit_call_insn (gen_call_mcount (mcount, arg_bytes,\n+\t\t\t\t\t\t     begin_label_rtx));\n+      else\n+\tcall_insn = emit_call_insn (gen_call (mcount, arg_bytes));\n+    }\n \n   use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), gen_rtx_REG (SImode, 25));\n   use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), gen_rtx_REG (SImode, 26));\n \n   /* Indicate the _mcount call cannot throw, nor will it execute a\n      non-local goto.  */\n   make_reg_eh_region_note_nothrow_nononlocal (call_insn);\n+\n+  /* Allocate space for fixed arguments.  */\n+  if (reg_parm_stack_space > crtl->outgoing_args_size)\n+    crtl->outgoing_args_size = reg_parm_stack_space;\n }\n \n /* Fetch the return address for the frame COUNT steps up from"}, {"sha": "e4c806f84a8d2cbd97db4dad77cd0912ddf6da73", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730a27a251b1f6f8664cb952c2c2fc24d42a426d/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730a27a251b1f6f8664cb952c2c2fc24d42a426d/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=730a27a251b1f6f8664cb952c2c2fc24d42a426d", "patch": "@@ -8207,6 +8207,170 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(cond [(and (const_int 0) (eq (const_int 0) (pc))) (const_int 12)]\n \t      (symbol_ref \"pa_attr_length_indirect_call (insn)\")))])\n \n+/* Expand special pc-relative call to _mcount.  */\n+\n+(define_expand \"call_mcount\"\n+  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (set (reg:SI 25)\n+\t\t   (plus:SI (reg:SI 2)\n+\t\t\t    (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t\t      (plus:SI (pc) (const_int 4)))))\n+\t      (clobber (reg:SI 2))])]\n+  \"!TARGET_PORTABLE_RUNTIME\"\n+  \"\n+{\n+  rtx op = XEXP (operands[0], 0);\n+  rtx nb = operands[1];\n+  rtx lab = operands[2];\n+\n+  if (TARGET_64BIT)\n+    {\n+      rtx r4 = gen_rtx_REG (word_mode, 4);\n+      emit_move_insn (arg_pointer_rtx,\n+\t\t      gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t    GEN_INT (64)));\n+      emit_call_insn (gen_call_mcount_64bit (op, nb, lab, r4));\n+    }\n+  else\n+    {\n+      if (flag_pic)\n+\t{\n+\t  rtx r4 = gen_rtx_REG (word_mode, 4);\n+\t  emit_call_insn (gen_call_mcount_pic (op, nb, lab, r4));\n+\t}\n+      else\n+\temit_call_insn (gen_call_mcount_nonpic (op, nb, lab));\n+    }\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"call_mcount_nonpic\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (set (reg:SI 25)\n+\t(plus:SI (reg:SI 2)\n+\t\t (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t   (plus:SI (pc) (const_int 4)))))\n+   (clobber (reg:SI 2))]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  pa_output_arg_descriptor (insn);\n+  return \\\"{bl|b,l} %0,%%r2\\;ldo %2-.-4(%%r2),%%r25\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"call_mcount_pic\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (set (reg:SI 25)\n+\t(plus:SI (reg:SI 2)\n+\t\t (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t   (plus:SI (pc) (const_int 4)))))\n+   (clobber (reg:SI 2))\n+   (clobber (match_operand 3))\n+   (use (reg:SI 19))]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"#\")\n+\n+(define_split\n+  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (set (reg:SI 25)\n+\t\t   (plus:SI (reg:SI 2)\n+\t\t\t    (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t\t      (plus:SI (pc) (const_int 4)))))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (match_operand 3))\n+\t      (use (reg:SI 19))])]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\"\n+  [(set (match_dup 3) (reg:SI 19))\n+   (parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (set (reg:SI 25)\n+\t\t   (plus:SI (reg:SI 2)\n+\t\t\t    (minus:SI (match_dup 2)\n+\t\t\t\t      (plus:SI (pc) (const_int 4)))))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))])\n+   (set (reg:SI 19) (match_dup 3))]\n+  \"\")\n+\n+(define_insn \"*call_mcount_pic_post_reload\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (set (reg:SI 25)\n+\t(plus:SI (reg:SI 2)\n+\t\t (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t   (plus:SI (pc) (const_int 4)))))\n+   (clobber (reg:SI 2))\n+   (use (reg:SI 19))]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  pa_output_arg_descriptor (insn);\n+  return \\\"{bl|b,l} %0,%%r2\\;ldo %2-.-4(%%r2),%%r25\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"call_mcount_64bit\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (set (reg:SI 25)\n+\t(plus:SI (reg:SI 2)\n+\t\t (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t   (plus:SI (pc) (const_int 4)))))\n+   (clobber (reg:DI 2))\n+   (clobber (match_operand 3))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))]\n+  \"TARGET_64BIT\"\n+  \"#\")\n+\n+(define_split\n+  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (set (reg:SI 25)\n+\t\t   (plus:SI (reg:SI 2)\n+\t\t\t    (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t\t      (plus:SI (pc) (const_int 4)))))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (match_operand 3))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))])]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(set (match_dup 3) (reg:DI 27))\n+   (parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (set (reg:SI 25)\n+\t\t   (plus:SI (reg:SI 2)\n+\t\t\t    (minus:SI (match_dup 2)\n+\t\t\t\t      (plus:SI (pc) (const_int 4)))))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))])\n+   (set (reg:DI 27) (match_dup 3))]\n+  \"\")\n+\n+(define_insn \"*call_mcount_64bit_post_reload\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (set (reg:SI 25)\n+\t(plus:SI (reg:SI 2)\n+\t\t (minus:SI (match_operand 2 \"\" \"\")\n+\t\t\t   (plus:SI (pc) (const_int 4)))))\n+   (clobber (reg:DI 2))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))]\n+  \"TARGET_64BIT\"\n+  \"{bl|b,l} %0,%%r2\\;ldo %2-.-4(%%r2),%%r25\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n ;; Call subroutine returning any type.\n \n (define_expand \"untyped_call\""}]}