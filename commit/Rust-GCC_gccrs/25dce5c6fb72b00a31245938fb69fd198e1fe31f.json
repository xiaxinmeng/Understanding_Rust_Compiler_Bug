{"sha": "25dce5c6fb72b00a31245938fb69fd198e1fe31f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVkY2U1YzZmYjcyYjAwYTMxMjQ1OTM4ZmI2OWZkMTk4ZTFmZTMxZg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mjw@redhat.com", "date": "2014-04-15T17:18:20Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2014-04-15T17:18:20Z"}, "message": "Add DW_AT_const_value as unsigned or int depending on type and value used.\n\nAs the comment in the code already indicated DWARF2 does provide\nDW_FORM_sdata/DW_FORM_udata to represent signed/unsigned data.\nEnumeration constants wider than HOST_WIDE_INT are already handled\nseparately. Those constant values that do fit a HOST_WIDE_INT can\nbe encoded as signed or unsigned depending on type and value for\nmore efficient encoding.\n\n\t* dwarf2out.c (gen_enumeration_type_die): Add DW_AT_const_value\n\tas unsigned or int depending on type and value used.\n\nFrom-SVN: r209424", "tree": {"sha": "ab4a9c02e9c772a47ed327a4916a64ef0d051155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab4a9c02e9c772a47ed327a4916a64ef0d051155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25dce5c6fb72b00a31245938fb69fd198e1fe31f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25dce5c6fb72b00a31245938fb69fd198e1fe31f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25dce5c6fb72b00a31245938fb69fd198e1fe31f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25dce5c6fb72b00a31245938fb69fd198e1fe31f/comments", "author": null, "committer": null, "parents": [{"sha": "8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b"}], "stats": {"total": 34, "additions": 20, "deletions": 14}, "files": [{"sha": "b7b5a9aa503dbca5b45797953a7e2a086551c344", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25dce5c6fb72b00a31245938fb69fd198e1fe31f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25dce5c6fb72b00a31245938fb69fd198e1fe31f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25dce5c6fb72b00a31245938fb69fd198e1fe31f", "patch": "@@ -1,3 +1,8 @@\n+2014-03-21  Mark Wielaard  <mjw@redhat.com>\n+\n+\t* dwarf2out.c (gen_enumeration_type_die): Add DW_AT_const_value\n+\tas unsigned or int depending on type and value used.\n+\n 2014-04-15  Richard Biener  <rguenther@suse.de>\n \n \tPR rtl-optimization/56965"}, {"sha": "0cdb3dca308a57995818a9012b1a72c62d955637", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25dce5c6fb72b00a31245938fb69fd198e1fe31f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25dce5c6fb72b00a31245938fb69fd198e1fe31f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=25dce5c6fb72b00a31245938fb69fd198e1fe31f", "patch": "@@ -17361,22 +17361,23 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n \n \t  if (simple_type_size_in_bits (TREE_TYPE (value))\n \t      <= HOST_BITS_PER_WIDE_INT || tree_fits_shwi_p (value))\n-\t    /* DWARF2 does not provide a way of indicating whether or\n-\t       not enumeration constants are signed or unsigned.  GDB\n-\t       always assumes the values are signed, so we output all\n-\t       values as if they were signed.  That means that\n-\t       enumeration constants with very large unsigned values\n-\t       will appear to have negative values in the debugger.\n-\n-\t       TODO: the above comment is wrong, DWARF2 does provide\n-\t       DW_FORM_sdata/DW_FORM_udata to represent signed/unsigned data.\n-\t       This should be re-worked to use correct signed/unsigned\n-\t       int/double tags for all cases, instead of always treating as\n-\t       signed.  */\n-\t    add_AT_int (enum_die, DW_AT_const_value, TREE_INT_CST_LOW (value));\n+\t    {\n+\t      /* For constant forms created by add_AT_unsigned DWARF\n+\t\t consumers (GDB, elfutils, etc.) always zero extend\n+\t\t the value.  Only when the actual value is negative\n+\t\t do we need to use add_AT_int to generate a constant\n+\t\t form that can represent negative values.  */\n+\t      HOST_WIDE_INT val = TREE_INT_CST_LOW (value);\n+\t      if (TYPE_UNSIGNED (TREE_TYPE (value)) || val >= 0)\n+\t\tadd_AT_unsigned (enum_die, DW_AT_const_value,\n+\t\t\t\t (unsigned HOST_WIDE_INT) val);\n+\t      else\n+\t\tadd_AT_int (enum_die, DW_AT_const_value, val);\n+\t    }\n \t  else\n \t    /* Enumeration constants may be wider than HOST_WIDE_INT.  Handle\n-\t       that here.  */\n+\t       that here.  TODO: This should be re-worked to use correct\n+\t       signed/unsigned double tags for all cases.  */\n \t    add_AT_double (enum_die, DW_AT_const_value,\n \t\t\t   TREE_INT_CST_HIGH (value), TREE_INT_CST_LOW (value));\n \t}"}]}